// Decompiled: cgminer_ad9aff56bd08c912_debug

int _init(EVP_PKEY_CTX *ctx)

{
    int iVar1;

    iVar1 = call_weak_fn();
    return iVar1;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

int main(int argc, char **argv)

{
    byte *pbVar1;
    bool bVar2;
    work *pwVar3;
    cgpu_info **ppcVar4;
    size_t *psVar5;
    _Bool _Var6;
    long lVar7;
    char **ppcVar8;
    char *pcVar9;
    char *pcVar10;
    char *__src;
    size_t sVar11;
    byte *__s;
    size_t sVar12;
    pool *ppVar13;
    FILE *pFVar14;
    undefined4 *puVar15;
    __sighandler_t p_Var16;
    __sighandler_t p_Var17;
    thr_info *ptVar18;
    thr_info **pptVar19;
    int iVar20;
    void *pvVar21;
    double *pdVar22;
    work *pwVar24;
    pool *ppVar25;
    int extraout_r1;
    pthread_mutex_t *__mutex;
    _func_int *extraout_r2;
    code *pcVar26;
    char *func;
    undefined4 uVar27;
    char *func_00;
    char *func_01;
    char *func_02;
    char *func_03;
    _func_void_thr_info_ptr *p_Var28;
    _func_void_thr_info_ptr *p_Var29;
    undefined1 clean;
    byte bVar30;
    _func_int **extraout_r3;
    _func_int **pp_Var31;
    int line;
    int line_00;
    int line_01;
    int line_02;
    int line_03;
    int line_04;
    int line_05;
    int line_06;
    int line_07;
    int line_08;
    int line_09;
    int line_10;
    _func_int64_t_thr_info_ptr *p_Var32;
    int iVar33;
    undefined4 uVar34;
    pool_enable pVar35;
    int line_11;
    undefined4 uVar36;
    int line_12;
    int line_13;
    device_drv *pdVar37;
    device_drv *extraout_r3_00;
    int line_14;
    int line_15;
    _func_void_thr_info_ptr *p_Var38;
    _func_void_thr_info_ptr *p_Var39;
    work *pwVar40;
    uint uVar41;
    uint uVar42;
    drv_driver dVar43;
    int iVar44;
    uint uVar45;
    uint uVar46;
    uchar(*p)[160];
    cgpu_info *pcVar47;
    int *piVar48;
    _func_void_thr_info_ptr *p_Var49;
    char **ppcVar50;
    _Bool *p_Var51;
    cgpu_info ***thr;
    device_drv *pdVar52;
    uchar(*p_00)[160];
    int *piVar53;
    timeval *ptVar54;
    byte *pbVar55;
    char acStack_3238[4104];
    char local_2230[12];
    undefined2 uStack_2224;
    undefined1 local_2222;
    char *local_1238;
    thr_info **local_1228;
    device_drv *local_1224;
    size_t *local_1220;
    device_drv *local_121c;
    device_drv *local_1218;
    device_drv *local_1214;
    device_drv *local_1210;
    device_drv *local_120c;
    device_drv *local_1208;
    device_drv *local_1204;
    device_drv *local_1200;
    device_drv *local_11fc;
    device_drv *local_11f8;
    device_drv *local_11f4;
    device_drv *local_11f0;
    pool *local_11ec;
    device_drv *local_11e8;
    device_drv *local_11e4;
    device_drv *local_11e0;
    device_drv *local_11dc;
    work *local_11d8;
    char **local_11d4;
    _Bool *local_11d0;
    int local_11cc[2];
    sigaction handler;
    char tmp[256];
    char tmp42[4096];
    double *pdVar23;

    local_11d0 = &use_syslog;
    local_11dc = (device_drv *)argv;
    local_11cc[0] = argc;
    set_miner_name("Z15e");
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "z15e init...", 0xc);
        tmp42[0xc] = '\n';
        tmp42[0xd] = '\0';
        _applog(5, tmp42, false);
    }
    local_11e4 = (device_drv *)g_logfile_openflag;
    builtin_strncpy(g_logfile_path, "cgminer.", 8);
    builtin_strncpy(g_logfile_path + 8, "log", 4);
    local_11e0 = (device_drv *)&g_logfile_enable;
    g_logfile_openflag[0] = 'a';
    g_logfile_openflag[1] = '+';
    g_logfile_openflag[2] = '\0';
    g_logfile_enable = false;
    lVar7 = sysconf(0x54);
    pcVar26 = extraout_r2;
    pp_Var31 = extraout_r3;
    if (lVar7 == 1) {
        pp_Var31 = &selective_yield;
        pcVar26 = sched_yield;
    }
    if (lVar7 == 1) {
        *pp_Var31 = pcVar26;
    }
    local_11d4 = &opt_logfile_path;
    ppcVar8 = (char **)malloc((local_11cc[0] + 1) * 4);
    initial_args = ppcVar8;
    if (0 < local_11cc[0]) {
        ppcVar50 = ppcVar8 + -1;
        iVar44 = 0;
        puVar15 = (undefined4 *)((int)&local_11dc[-1].min_diff + 4);
        do {
            puVar15 = puVar15 + 1;
            iVar44 = iVar44 + 1;
            pcVar9 = (char *)__strdup(*puVar15);
            ppcVar50 = ppcVar50 + 1;
            *ppcVar50 = pcVar9;
        } while (iVar44 < local_11cc[0]);
    }
    ppcVar8[local_11cc[0]] = (char *)0x0;
    _mutex_init(&hash_lock, "main", (char *)0x29e4, 0xe958);
    _mutex_init(&update_job_lock, "main", (char *)0x29e5, line);
    _mutex_init(&console_lock, "main", (char *)0x29e6, line_00);
    _cglock_init(&control_lock, "main", (char *)0x29e7, line_01);
    _mutex_init(&stats_lock, "main", (char *)0x29e8, line_02);
    local_11d8 = (work *)(bench_lodiff_bins[2] + 0xc);
    _mutex_init(&sharelog_lock, "main", (char *)0x29e9, 0x6e958);
    _cglock_init(&ch_lock, "main", (char *)0x29ea, line_03);
    _mutex_init(&sshare_lock, "main", (char *)0x29eb, line_04);
    _rwlock_init(&blk_lock, "main", (char *)0x29ec, line_05);
    _rwlock_init(&netacc_lock, "main", (char *)0x29ed, line_06);
    _rwlock_init(&mining_thr_lock, "main", (char *)0x29ee, line_07);
    _rwlock_init(&devices_lock, "main", (char *)0x29ef, line_08);
    _mutex_init(&lp_lock, "main", (char *)0x29f1, line_09);
    iVar44 = pthread_cond_init((pthread_cond_t *)&lp_cond,
                               (pthread_condattr_t *)0x0);
    if (iVar44 != 0) {
        builtin_strncpy(tmp42, "Failed to pthread_cond_init lp_cond", 0x24);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, false);
    }
    _mutex_init(&restart_lock, "main", (char *)0x29f5, line_10);
    iVar44 = pthread_cond_init((pthread_cond_t *)&restart_cond,
                               (pthread_condattr_t *)0x0);
    if (iVar44 != 0) {
        builtin_strncpy(tmp42, "Failed to pthread_cond_init restart_cond",
                        0x28);
        tmp42._40_4_ = tmp42._40_4_ & 0xffffff00;
        goto LAB_00013a18;
    }
    local_11ec = (pool *)pthread_cond_init((pthread_cond_t *)&gws_cond,
                                           (pthread_condattr_t *)0x0);
    if (local_11ec != (pool *)0x0) {
        builtin_strncpy(tmp42, "Failed to pthread_cond_init gws_cond", 0x24);
        tmp42._36_4_ = tmp42._36_4_ & 0xffffff00;
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, false);
    }
    getq = tq_new();
    uVar34 = tmp42._20_4_;
    if (getq == (thread_q *)0x0) {
        builtin_strncpy(tmp42, "Failed to create getq", 0x16);
        tmp42._22_2_ = SUB42(uVar34, 2);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, false);
    }
    local_1238 = "4.9.0";
    local_11d4[0x111] = (char *)&getq->mutex;
    snprintf(packagename, 0x100, "%s %s", "cgminer");
    handler.sa_flags = (int)local_11ec;
    handler.__sigaction_handler =
        (anon_union_4_2_5ad2d23e_for___sigaction_handler)(code *)0x1a87d;
    sigemptyset((sigset_t *)&handler.sa_mask);
    sigaction(0xf, (sigaction *)&handler, (sigaction *)&termhandler);
    sigaction(2, (sigaction *)&handler, (sigaction *)&inthandler);
    signal(0xd, (__sighandler_t)0x1);
    opt_kernel_path = local_2230;
    local_11f8 = (device_drv *)&opt_kernel_path;
    builtin_strncpy(local_2230, "/usr/local/b", 0xc);
    cgminer_path = acStack_3238;
    uStack_2224 = 0x6e69;
    local_2222 = 0;
    local_11f0 = (device_drv *)0x4f7d0;
    pcVar10 = (char *)__strdup((char *)local_11dc->drv_id);
    pcVar9 = cgminer_path;
    __src = dirname(pcVar10);
    strcpy(pcVar9, __src);
    free(pcVar10);
    pcVar9 = cgminer_path;
    sVar11 = strlen(cgminer_path);
    dVar43 = local_11f0->drv_id;
    local_11d8[1].equihash_data[0x1c0] = '\t';
    local_11d8[1].equihash_data[0x1c1] = '\0';
    local_11d8[1].equihash_data[0x1c2] = '\0';
    local_11d8[1].equihash_data[0x1c3] = '\0';
    *(short *)(pcVar9 + sVar11) = (short)dVar43;
    __s = (byte *)calloc(0x68, 1);
    if (__s == (byte *)0x0) {
        builtin_strncpy(tmp42, "main OOM", 8);
        tmp42._8_4_ = tmp42._8_4_ & 0xffffff00;
    LAB_00013aae:
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    iVar44 = 0x24;
    do {
        sVar11 = strlen((char *)__s);
        iVar44 = iVar44 + -1;
        (__s + sVar11)[0] = '0';
        (__s + sVar11)[1] = '\0';
    } while (iVar44 != 0);
    __s[0x4c] = 0;
    __s[0x4d] = 0;
    __s[0x4e] = 0;
    __s[0x4f] = 0;
    *(byte **)(__s + 0x58) = __s;
    sVar11 = strlen((char *)__s);
    *(size_t *)(__s + 0x5c) = sVar11;
    iVar44 = *(int *)(local_11d8[1].equihash_data + 0x150);
    if (iVar44 == 0) {
        __s[0x48] = 0;
        __s[0x49] = 0;
        __s[0x4a] = 0;
        __s[0x4b] = 0;
        *(byte **)(local_11d8[1].equihash_data + 0x150) = __s;
        puVar15 = (undefined4 *)malloc(0x2c);
        *(undefined4 **)(__s + 0x44) = puVar15;
        if (puVar15 == (undefined4 *)0x0)
            goto LAB_00013906;
        memset(puVar15 + 3, 0, 0x20);
        local_11e8 = (device_drv *)(__s + 0x44);
        puVar15[1] = 0x20;
        puVar15[2] = 5;
        puVar15[4] = local_11e8;
        puVar15[5] = 0x44;
        pvVar21 = calloc(0x180, 1);
        *puVar15 = pvVar21;
        if (pvVar21 == (void *)0x0)
            goto LAB_00013906;
        puVar15[10] = 0xa0111fe1;
    } else {
        local_11e8 = (device_drv *)(__s + 0x44);
        *(byte **)(*(int *)(*(int *)(iVar44 + 0x44) + 0x10) + 8) = __s;
        *(int *)(__s + 0x48) = *(int *)(*(int *)(iVar44 + 0x44) + 0x10) -
                               *(int *)(*(int *)(iVar44 + 0x44) + 0x14);
        *(device_drv **)(*(int *)(iVar44 + 0x44) + 0x10) = local_11e8;
    }
    uVar41 = 0xfeedbeef;
    pdVar52 = *(device_drv **)(local_11d8[1].equihash_data + 0x150);
    *(int *)(pdVar52->scanwork + 0xc) = *(int *)(pdVar52->scanwork + 0xc) + 1;
    p_Var32 = pdVar52->scanwork;
    __s[0x60] = 0xef;
    __s[0x61] = 0xbe;
    __s[0x62] = 0xed;
    __s[99] = 0xfe;
    *(_func_int64_t_thr_info_ptr **)(__s + 0x44) = p_Var32;
    sVar11 = strlen((char *)__s);
    if (sVar11 < 0xc) {
        uVar45 = 0x9e3779b9;
        uVar42 = uVar45;
        pbVar55 = __s;
    } else {
        uVar45 = 0x9e3779b9;
        uVar42 = uVar45;
        pbVar1 = __s;
        do {
            pbVar55 = pbVar1 + 0xc;
            sVar11 = sVar11 - 0xc;
            uVar41 = (uint)pbVar1[10] * 0x10000 + (uint)pbVar1[9] * 0x100 +
                     (uint)pbVar1[8] + (uint)pbVar1[0xb] * 0x1000000 + uVar41;
            iVar44 = uVar42 + (uint)pbVar1[6] * 0x10000 +
                     (uint)pbVar1[5] * 0x100 + (uint)pbVar1[4] +
                     (uint)pbVar1[7] * 0x1000000;
            uVar42 =
                uVar45 +
                    ((((uint)pbVar1[2] * 0x10000 + (uint)pbVar1[1] * 0x100 +
                       (uint)*pbVar1 + (uint)pbVar1[3] * 0x1000000) -
                      uVar41) -
                     iVar44) ^
                uVar41 >> 0xd;
            uVar45 = (iVar44 - uVar41) - uVar42 ^ uVar42 << 8;
            uVar41 = (uVar41 - uVar42) - uVar45 ^ uVar45 >> 0xd;
            uVar42 = (uVar42 - uVar45) - uVar41 ^ uVar41 >> 0xc;
            uVar46 = (uVar45 - uVar41) - uVar42 ^ uVar42 << 0x10;
            uVar41 = (uVar41 - uVar42) - uVar46 ^ uVar46 >> 5;
            uVar45 = (uVar42 - uVar46) - uVar41 ^ uVar41 >> 3;
            uVar42 = (uVar46 - uVar41) - uVar45 ^ uVar45 << 10;
            uVar41 = (uVar41 - uVar45) - uVar42 ^ uVar42 >> 0xf;
            *(uint *)(__s + 0x60) = uVar41;
            pbVar1 = pbVar55;
            local_11f4 = pdVar52;
        } while (0xb < sVar11);
    }
    sVar12 = strlen((char *)__s);
    uVar41 = sVar12 + *(int *)(__s + 0x60);
    *(uint *)(__s + 0x60) = uVar41;
    switch (sVar11) {
    case 0xb:
        uVar41 = uVar41 + (uint)pbVar55[10] * 0x1000000;
        *(uint *)(__s + 0x60) = uVar41;
    case 10:
        uVar41 = uVar41 + (uint)pbVar55[9] * 0x10000;
        *(uint *)(__s + 0x60) = uVar41;
    case 9:
        uVar41 = uVar41 + (uint)pbVar55[8] * 0x100;
        *(uint *)(__s + 0x60) = uVar41;
    case 8:
        uVar42 = uVar42 + (uint)pbVar55[7] * 0x1000000;
    case 7:
        uVar42 = uVar42 + (uint)pbVar55[6] * 0x10000;
    case 6:
        uVar42 = uVar42 + (uint)pbVar55[5] * 0x100;
    case 5:
        uVar42 = uVar42 + pbVar55[4];
    case 4:
        uVar45 = uVar45 + (uint)pbVar55[3] * 0x1000000;
    case 3:
        uVar45 = uVar45 + (uint)pbVar55[2] * 0x10000;
    case 2:
        uVar45 = uVar45 + (uint)pbVar55[1] * 0x100;
    case 1:
        uVar45 = uVar45 + *pbVar55;
    }
    uVar45 = (uVar45 - uVar42) - uVar41 ^ uVar41 >> 0xd;
    uVar46 = (uVar42 - uVar41) - uVar45 ^ uVar45 << 8;
    uVar41 = (uVar41 - uVar45) - uVar46 ^ uVar46 >> 0xd;
    uVar42 = (uVar45 - uVar46) - uVar41 ^ uVar41 >> 0xc;
    uVar45 = (uVar46 - uVar41) - uVar42 ^ uVar42 << 0x10;
    uVar41 = (uVar41 - uVar42) - uVar45 ^ uVar45 >> 5;
    uVar42 = (uVar42 - uVar45) - uVar41 ^ uVar41 >> 3;
    uVar45 = (uVar45 - uVar41) - uVar42 ^ uVar42 << 10;
    uVar41 = (uVar41 - uVar42) - uVar45 ^ uVar45 >> 0xf;
    *(uint *)(__s + 0x60) = uVar41;
    iVar44 = (uVar41 & *(int *)(pdVar52->scanwork + 4) - 1U) * 0xc;
    iVar33 = *(int *)pdVar52->scanwork + iVar44;
    *(int *)(iVar33 + 4) = *(int *)(iVar33 + 4) + 1;
    uVar34 = *(undefined4 *)(*(int *)pdVar52->scanwork + iVar44);
    __s[0x50] = 0;
    __s[0x51] = 0;
    __s[0x52] = 0;
    __s[0x53] = 0;
    *(undefined4 *)(__s + 0x54) = uVar34;
    p_Var32 = pdVar52->scanwork;
    if (*(int *)(*(int *)p_Var32 + iVar44) != 0) {
        *(device_drv **)(*(int *)(*(int *)p_Var32 + iVar44) + 0xc) = local_11e8;
        p_Var32 = pdVar52->scanwork;
    }
    *(device_drv **)(*(int *)p_Var32 + iVar44) = local_11e8;
    iVar44 = iVar44 + *(int *)pdVar52->scanwork;
    if ((*(int *)(iVar44 + 8) * 10 + 10U <= *(uint *)(iVar44 + 4)) &&
        (iVar44 = *(int *)(__s + 0x44), *(int *)(iVar44 + 0x24) != 1)) {
        pvVar21 = calloc(*(int *)(iVar44 + 4) * 0x18, 1);
        if (pvVar21 == (void *)0x0) {
        LAB_00013906:
            /* WARNING: Subroutine does not return */
            exit(-1);
        }
        uVar41 = *(uint *)(iVar44 + 0xc) >> (*(int *)(iVar44 + 8) + 1U & 0xff);
        if ((*(int *)(iVar44 + 4) * 2 - 1U & *(uint *)(iVar44 + 0xc)) != 0) {
            uVar41 = uVar41 + 1;
        }
        *(uint *)(iVar44 + 0x18) = uVar41;
        *(undefined4 *)(*(int *)(__s + 0x44) + 0x1c) = 0;
        piVar53 = *(int **)(__s + 0x44);
        if (piVar53[1] != 0) {
            local_11e8 = (device_drv *)0x0;
            do {
                iVar44 = *(int *)(*piVar53 + (int)local_11e8 * 0xc);
                while (iVar44 != 0) {
                    iVar33 = *(int *)(iVar44 + 0x10);
                    uVar42 = piVar53[1] * 2 - 1U & *(uint *)(iVar44 + 0x1c);
                    uVar41 = *(int *)((int)pvVar21 + uVar42 * 0xc + 4) + 1;
                    *(uint *)((int)pvVar21 + uVar42 * 0xc + 4) = uVar41;
                    if ((uint)piVar53[6] < uVar41) {
                        piVar53[7] = piVar53[7] + 1;
                        uVar34 = __udivsi3(
                            *(undefined4 *)((int)pvVar21 + uVar42 * 0xc + 4),
                            *(undefined4 *)(*(int *)(__s + 0x44) + 0x18));
                        *(undefined4 *)((int)pvVar21 + uVar42 * 0xc + 8) =
                            uVar34;
                    }
                    *(undefined4 *)(iVar44 + 0xc) = 0;
                    *(undefined4 *)(iVar44 + 0x10) =
                        *(undefined4 *)((int)pvVar21 + uVar42 * 0xc);
                    iVar20 = *(int *)((int)pvVar21 + uVar42 * 0xc);
                    if (iVar20 != 0) {
                        *(int *)(iVar20 + 0xc) = iVar44;
                    }
                    *(int *)((int)pvVar21 + uVar42 * 0xc) = iVar44;
                    piVar53 = *(int **)(__s + 0x44);
                    iVar44 = iVar33;
                }
                local_11e8 = (device_drv *)((int)&local_11e8->drv_id + 1);
            } while (local_11e8 < (device_drv *)piVar53[1]);
        }
        free((void *)*piVar53);
        *(int *)(*(int *)(__s + 0x44) + 4) = *(int *)(*(int *)(__s + 0x44) + 4)
                                             << 1;
        *(int *)(*(int *)(__s + 0x44) + 8) =
            *(int *)(*(int *)(__s + 0x44) + 8) + 1;
        **(undefined4 **)(__s + 0x44) = pvVar21;
        iVar44 = *(int *)(__s + 0x44);
        if (*(uint *)(iVar44 + 0xc) >> 1 < *(uint *)(iVar44 + 0x1c)) {
            iVar33 = *(int *)(iVar44 + 0x20) + 1;
        } else {
            iVar33 = 0;
        }
        *(int *)(iVar44 + 0x20) = iVar33;
        uVar42 = *(uint *)(*(int *)(__s + 0x44) + 0x20);
        uVar41 = uVar42;
        if (1 < uVar42) {
            uVar41 = 1;
        }
        if (1 < uVar42) {
            *(uint *)(*(int *)(__s + 0x44) + 0x24) = uVar41;
        }
    }
    strcpy(current_hash, (char *)__s);
    scan_devices.next = &scan_devices;
    scan_devices.prev = &scan_devices;
    opt_register_table(opt_config_table,
                       "Options for both config file and command line");
    opt_register_table(opt_cmdline_table, "Options for command line only");
    opt_parse(local_11cc, (char **)local_11dc,
              (_func_void_char_ptr_varargs *)0x16e09);
    uVar34 = tmp42._36_4_;
    if (local_11cc[0] != 1) {
        builtin_strncpy(tmp42, "Unexpected extra commandline arguments", 0x27);
        tmp42[0x27] = SUB41(uVar34, 3);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, false);
    }
    if (*(char *)(local_11d4 + 0xd6) == '\0') {
        pcVar9 = (char *)malloc(0x1000);
        ppcVar8 = local_11d4;
        local_11d4[0xd7] = pcVar9;
        default_save_file(pcVar9);
        iVar44 = access(ppcVar8[0xd7], 4);
        ppcVar50 = local_11d4;
        if (iVar44 == 0) {
            load_config(ppcVar8[0xd7], (void *)0x0);
        } else {
            free(local_11d4[0xd7]);
            ppcVar50[0xd7] = (char *)0x0;
        }
    }
    uVar34 = tmp42._36_4_;
    if ((*(char *)((int)local_11d4 + 0x561) != '\0') ||
        (local_11d4[0x10d] != (char *)0x0)) {
        if (opt_scrypt != false) {
            builtin_strncpy(tmp42, "Cannot use benchmark mode with scrypt",
                            0x26);
            tmp42._38_2_ = SUB42(uVar34, 2);
            _applog(3, tmp42, true);
            /* WARNING: Subroutine does not return */
            __quit(1, true);
        }
        ppVar13 = add_pool();
        pcVar9 = (char *)malloc(0xff);
        ppVar13->rpc_url = pcVar9;
        if (local_11d4[0x10d] == (char *)0x0) {
            builtin_strncpy(pcVar9, "Benchmark", 10);
        } else {
            builtin_strncpy(pcVar9, "Benchfile", 10);
        }
        pcVar9 = ppVar13->rpc_url;
        ppVar13->rpc_user = pcVar9;
        ppVar13->rpc_pass = pcVar9;
        ppVar13->rpc_userpass = pcVar9;
        ppVar13->sockaddr_url = pcVar9;
        strncpy(ppVar13->diff, "?", 7);
        pVar35 = ppVar13->enabled;
        ppVar13->diff[7] = '\0';
        if (pVar35 != POOL_ENABLED) {
            enable_pool((pool *)&ppVar13->enabled);
        }
        iVar44 = 0;
        ppVar13->idle = false;
        p = bench_lodiff_bins;
        successful_connect = true;
        p_00 = bench_hidiff_bins;
        do {
            hex2bin(*p_00, bench_hidiffs[0] + iVar44, 0xa0);
            pcVar9 = bench_lodiffs[0] + iVar44;
            iVar44 = iVar44 + 0x144;
            hex2bin(*p, pcVar9, 0xa0);
            p = p + 1;
            p_00 = p_00 + 1;
        } while (iVar44 != 0x1440);
        set_target(bench_target, 32.0);
    }
    if (local_11d4[4] != (char *)0x0) {
        pFVar14 = fopen(local_11d4[4], "rb");
        memset(tmp, 0, 0x100);
        if (pFVar14 == (FILE *)0x0) {
            if (((*local_11d0 != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Open miner version file %s error",
                         local_11d4[4]);
                _applog(3, tmp42, false);
                goto LAB_00012fa0;
            }
        LAB_00013ba8:
            if (opt_log_level < 3)
                goto LAB_00012fde;
        } else {
            sVar11 = fread(tmp, 1, 0x100, pFVar14);
            if ((int)sVar11 < 1) {
                if (((*local_11d0 == false) && (opt_log_output == false)) &&
                    (opt_log_level < 3))
                    goto LAB_00013ba8;
                snprintf(tmp42, 0x1000, "Read miner version file %s error %d",
                         local_11d4[4]);
                _applog(3, tmp42, false);
            } else {
                if (((*local_11d0 != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "%s:%s\n", local_11d4[4]);
                    _applog(5, tmp42, false);
                }
                pcVar9 = strchr(tmp, 10);
                if (pcVar9 == (char *)0x0) {
                    strcpy(g_miner_compiletime, tmp);
                } else {
                    memcpy(g_miner_compiletime, tmp, (int)pcVar9 - (int)tmp);
                    strcpy(g_miner_type, pcVar9 + 1);
                }
                sVar11 = strlen(g_miner_compiletime);
                if (local_11d8[1].equihash_data[sVar11 + 0x1e3] == '\n') {
                    local_11d8[1].equihash_data[sVar11 + 0x1e3] = '\0';
                }
                sVar11 = strlen(g_miner_compiletime);
                if (local_11d8[1].equihash_data[sVar11 + 0x1e3] == '\r') {
                    local_11d8[1].equihash_data[sVar11 + 0x1e3] = '\0';
                }
                sVar11 = strlen(g_miner_type);
                if (local_11d8[1].equihash_data[sVar11 + 0x2e3] == '\n') {
                    local_11d8[1].equihash_data[sVar11 + 0x2e3] = '\0';
                }
                sVar11 = strlen(g_miner_type);
                if (local_11d8[1].equihash_data[sVar11 + 0x2e3] == '\r') {
                    local_11d8[1].equihash_data[sVar11 + 0x2e3] = '\0';
                }
            }
        LAB_00012fa0:
            if ((*local_11d0 == false) && (opt_log_output == false))
                goto LAB_00013ba8;
        }
        snprintf(tmp42, 0x1000, "Miner compile time: %s type: %s",
                 g_miner_compiletime);
        _applog(3, tmp42, false);
    }
LAB_00012fde:
    ppcVar8 = local_11d4;
    pcVar9 = *local_11d4;
    if (pcVar9 == (char *)0x0) {
    LAB_00013048:
        pcVar9 = local_11d4[2];
        if (pcVar9 != (char *)0x0) {
        LAB_00013052:
            memset(tmp, 0, 0x100);
            pcVar10 = local_11d4[1];
            if (pcVar10 == (char *)0x0) {
                if (((*local_11d0 != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "Log work path: %s", pcVar9);
                    _applog(3, tmp42, false);
                }
            } else {
                if (*pcVar10 == '\0') {
                    pcVar10 = tmp42;
                    pcVar9 = "Log work asic num empty";
                LAB_00013ca8:
                    uVar34 = *(undefined4 *)(pcVar9 + 4);
                    uVar27 = *(undefined4 *)(pcVar9 + 8);
                    uVar36 = *(undefined4 *)(pcVar9 + 0xc);
                    *(undefined4 *)pcVar10 = *(undefined4 *)pcVar9;
                    *(undefined4 *)(pcVar10 + 4) = uVar34;
                    *(undefined4 *)(pcVar10 + 8) = uVar27;
                    *(undefined4 *)(pcVar10 + 0xc) = uVar36;
                    uVar34 = *(undefined4 *)(pcVar9 + 0x14);
                    *(undefined4 *)(pcVar10 + 0x10) =
                        *(undefined4 *)(pcVar9 + 0x10);
                    *(undefined4 *)(pcVar10 + 0x14) = uVar34;
                    goto LAB_00013cba;
                }
                lVar7 = strtol(pcVar10, (char **)0x0, 10);
                *(long *)(local_11d8[1].equihash_data + 0x3e4) = lVar7;
                if (((lVar7 - 0x20U & 0xffffffdf) != 0) && (lVar7 != 1)) {
                    builtin_strncpy(
                        tmp42, "Log work asic num must be 1, 32, 64", 0x24);
                    _applog(3, tmp42, true);
                    /* WARNING: Subroutine does not return */
                    __quit(1, true);
                }
                if (((*local_11d0 != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "Log work path: %s Asic num: %s",
                             local_11d4[2]);
                    _applog(3, tmp42, false);
                }
            }
            sprintf(tmp, "%s.txt", local_11d4[2]);
            pFVar14 = fopen(tmp, "a+");
            _Var6 = *local_11d0;
            *(FILE **)(local_11d8[1].equihash_data + 1000) = pFVar14;
            if (((_Var6 != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Log work open file %s", tmp);
                _applog(3, tmp42, false);
            }
            pwVar3 = local_11d8;
            if (*(int *)(local_11d8[1].equihash_data + 0x3e4) == 1) {
                sprintf(tmp, "%s%02d.txt", local_11d4[2]);
                pFVar14 = fopen(tmp, "a+");
                _Var6 = *local_11d0;
                *(FILE **)(local_11d8[1].equihash_data + 0x3ec) = pFVar14;
                if (((_Var6 != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(
                        tmp42, 0x1000, "Log work open asic %d file %s",
                        *(undefined4 *)(local_11d8[1].equihash_data + 0x3e4));
                    _applog(3, tmp42, false);
                }
            } else if ((*(int *)(local_11d8[1].equihash_data + 0x3e4) - 0x20U &
                        0xffffffdf) == 0) {
                for (iVar44 = 0;
                     iVar44 <= *(int *)(pwVar3[1].equihash_data + 0x3e4);
                     iVar44 = iVar44 + 1) {
                    sprintf(tmp, "%s%02d_%02d.txt", local_11d4[2]);
                    pFVar14 = fopen(tmp, "a+");
                    g_logwork_files[iVar44] = (FILE *)pFVar14;
                    if (((*local_11d0 != false) || (opt_log_output != false)) ||
                        (2 < opt_log_level)) {
                        snprintf(
                            tmp42, 0x1000, "Log work open asic %d file %s",
                            *(undefined4 *)(pwVar3[1].equihash_data + 0x3e4));
                        _applog(3, tmp42, false);
                    }
                }
            }
            ppcVar8 = local_11d4;
            if (local_11d8[1].equihash_data[0x4f0] != '\0') {
                p_Var51 = &opt_logwork_diff;
                local_11dc = (device_drv *)0x519dc;
                iVar44 = 0;
                do {
                    sprintf(tmp, "%s_diff_%02d.txt", ppcVar8[2], iVar44);
                    pFVar14 = fopen(tmp, "a+");
                    p_Var51 = p_Var51 + 4;
                    *(FILE **)p_Var51 = pFVar14;
                    if (((*local_11d0 != false) || (opt_log_output != false)) ||
                        (2 < opt_log_level)) {
                        snprintf(tmp42, 0x1000, (char *)local_11dc, tmp);
                        _applog(3, tmp42, false);
                    }
                    iVar44 = iVar44 + 1;
                } while (iVar44 != 0x41);
            }
        }
        if ((*local_11d0 == false) && (opt_log_output == false))
            goto LAB_00013ac6;
    LAB_000132a0:
        snprintf(tmp42, 0x1000, "Started %s", packagename);
        _applog(4, tmp42, false);
    } else {
        *(_Bool *)&local_11e0->drv_id = true;
        strcpy(g_logfile_path, pcVar9);
        if (ppcVar8[3] != (char *)0x0) {
            strcpy(g_logfile_openflag, ppcVar8[3]);
        }
        if (((*local_11d0 != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "Log file path: %s Open flag: %s",
                     g_logfile_path);
            _applog(3, tmp42, false);
            goto LAB_00013048;
        }
        pcVar9 = local_11d4[2];
        if (pcVar9 != (char *)0x0)
            goto LAB_00013052;
    LAB_00013ac6:
        if (3 < opt_log_level)
            goto LAB_000132a0;
    }
    if (local_11d4[0xd7] != (char *)0x0) {
        if (opt_debug == false) {
        LAB_0001395c:
            pcVar9 = local_11d4[0x10b];
            if (pcVar9 != (char *)0xffffffff)
                goto LAB_00013968;
            if (*local_11d0 == false)
                goto LAB_00013312;
        LAB_00013c38:
            uVar34 = tmp42._44_4_;
            builtin_strncpy(
                tmp42, "Error in configuration file, partially loaded.", 0x2f);
            tmp42[0x2f] = SUB41(uVar34, 3);
            _applog(4, tmp42, false);
            if (use_curses != false) {
                if ((*local_11d0 == false) && (opt_log_output == false)) {
                LAB_00013340:
                    if (opt_log_level < 4)
                        goto LAB_0001336e;
                }
                uVar34 = tmp42._48_4_;
                builtin_strncpy(
                    tmp42, "Start cgminer with -T to see what failed to load.",
                    0x32);
                tmp42._50_2_ = SUB42(uVar34, 2);
                _applog(4, tmp42, false);
            }
        } else {
            if (((*local_11d0 != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Loaded configuration file %s");
                _applog(7, tmp42, false);
                goto LAB_0001395c;
            }
            pcVar9 = local_11d4[0x10b];
            if (pcVar9 == (char *)0xffffffff) {
            LAB_00013312:
                if ((opt_log_output != false) || (3 < opt_log_level))
                    goto LAB_00013c38;
                if (use_curses != false)
                    goto LAB_00013340;
                goto LAB_0001336e;
            }
        LAB_00013968:
            if (pcVar9 == (char *)0x0) {
                if (((*local_11d0 == false) && (opt_log_output == false)) &&
                    (opt_log_level < 4)) {
                LAB_00013998:
                    if (opt_log_level < 4)
                        goto LAB_0001336e;
                } else {
                    builtin_strncpy(
                        tmp42, "Fatal JSON error in configuration file.", 0x28);
                    _applog(4, tmp42, false);
                    if ((*local_11d0 == false) && (opt_log_output == false))
                        goto LAB_00013998;
                }
                uVar34 = tmp42._36_4_;
                builtin_strncpy(tmp42, "Configuration file could not be used.",
                                0x26);
                tmp42._38_2_ = SUB42(uVar34, 2);
                _applog(4, tmp42, false);
            }
        }
    LAB_0001336e:
        ppcVar8 = local_11d4;
        free(local_11d4[0xd7]);
        ppcVar8[0xd7] = (char *)0x0;
    }
    pcVar9 = (char *)local_11f8->drv_id;
    sVar11 = strlen(pcVar9);
    *(short *)(pcVar9 + sVar11) = (short)local_11f0->drv_id;
    if (want_per_device_stats != false) {
        opt_log_output = true;
    }
    if (opt_scantime < 0) {
        if (opt_scrypt == false) {
            opt_scantime = 0x3c;
        } else {
            opt_scantime = 0x1e;
        }
    }
    local_11d8[1].tv_staged.tv_sec = 8;
    control_thr = (thr_info *)calloc(8, 0x40);
    local_1228 = &control_thr;
    if (control_thr == (thr_info *)0x0) {
        tmp42[0] = 'F';
        tmp42[1] = 'a';
        tmp42[2] = 'i';
        tmp42[3] = 'l';
        tmp42[4] = 'e';
        tmp42[5] = 'd';
        tmp42[6] = ' ';
        tmp42[7] = 't';
        tmp42[8] = 'o';
        tmp42[9] = ' ';
        tmp42[10] = 'c';
        tmp42[0xb] = 'a';
        tmp42[0xc] = 'l';
        tmp42[0xd] = 'l';
        tmp42[0xe] = 'o';
        tmp42[0xf] = 'c';
        tmp42[0x10] = ' ';
        tmp42[0x11] = 'c';
        tmp42[0x12] = 'o';
        tmp42[0x13] = 'n';
        tmp42[0x14] = 't';
        tmp42[0x15] = 'r';
        tmp42[0x16] = 'o';
        tmp42[0x17] = 'l';
        tmp42[0x18] = '_';
        tmp42[0x19] = 't';
        tmp42[0x1a] = 'h';
        tmp42[0x1b] = 'r';
        pcVar9 = tmp42 + 0x1c;
    LAB_00013b34:
        *pcVar9 = '\0';
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, false);
    }
    local_11dc = &modminer_drv;
    fill_device_drv(&bitforce_drv);
    local_1224 = local_11dc;
    fill_device_drv(local_11dc);
    fill_device_drv(&bitmain_drv);
    fill_device_drv(&bitmain_c5_drv);
    pdVar52 = &bmsc_drv;
    fill_device_drv(&bitmainZCASH_drv);
    local_11e0 = (device_drv *)0x2930;
    local_11dc = (device_drv *)0x1f50;
    fill_device_drv(&bmsc_drv);
    local_11dc = (device_drv *)((uint)local_11dc & 0xffff | 0x70000);
    fill_device_drv(&avalon_drv);
    local_11e8 = (device_drv *)0x2338;
    local_11e0 = (device_drv *)((uint)local_11e0 & 0xffff | 0x70000);
    local_11e4 = (device_drv *)0x25c0;
    fill_device_drv(local_11dc);
    local_11e4 = (device_drv *)((uint)local_11e4 & 0xffff | 0x70000);
    fill_device_drv(local_11e0);
    local_11f4 = (device_drv *)0x1a68;
    local_11f0 = (device_drv *)0x1dc0;
    local_11e8 = (device_drv *)((uint)local_11e8 & 0xffff | 0x70000);
    fill_device_drv(local_11e4);
    local_11f0 = (device_drv *)((uint)local_11f0 & 0xffff | 0x70000);
    fill_device_drv(local_11e8);
    local_11f8 = (device_drv *)0x19d0;
    local_11fc = (device_drv *)0x28a8;
    local_11f4 = (device_drv *)((uint)local_11f4 & 0xffff | 0x70000);
    fill_device_drv(local_11f0);
    local_11f8 = (device_drv *)((uint)local_11f8 & 0xffff | 0x70000);
    fill_device_drv(local_11f4);
    local_1200 = (device_drv *)0x2508;
    local_11fc = (device_drv *)((uint)local_11fc & 0xffff | 0x70000);
    local_1204 = (device_drv *)0x1c30;
    fill_device_drv(local_11f8);
    local_1200 = (device_drv *)((uint)local_1200 & 0xffff | 0x70000);
    fill_device_drv(local_11fc);
    local_1204 = (device_drv *)((uint)local_1204 & 0xffff | 0x70000);
    local_1208 = (device_drv *)0x1e58;
    local_120c = (device_drv *)0x22b0;
    fill_device_drv(local_1200);
    local_1208 = (device_drv *)((uint)local_1208 & 0xffff | 0x70000);
    fill_device_drv(local_1204);
    local_120c = (device_drv *)((uint)local_120c & 0xffff | 0x70000);
    local_1210 = (device_drv *)0x2220;
    local_1214 = (device_drv *)0x2158;
    fill_device_drv(local_1208);
    local_1210 = (device_drv *)((uint)local_1210 & 0xffff | 0x70000);
    fill_device_drv(local_120c);
    local_1214 = (device_drv *)((uint)local_1214 & 0xffff | 0x70000);
    local_1218 = (device_drv *)0x1ba8;
    local_121c = (device_drv *)0x20c8;
    fill_device_drv(local_1210);
    local_1218 = (device_drv *)((uint)local_1218 & 0xffff | 0x70000);
    fill_device_drv(local_1214);
    local_121c = (device_drv *)((uint)local_121c & 0xffff | 0x70000);
    local_1220 = (size_t *)0x21d8;
    fill_device_drv(local_1218);
    fill_device_drv(local_121c);
    local_1220 = (size_t *)((uint)local_1220 & 0xffff | 0x70000);
    fill_device_drv(&sp30_drv);
    (**(code **)(extraout_r1 + 0xc))(0);
    (*local_1224->drv_detect)(false);
    (*bitmain_drv.drv_detect)(false);
    (*bitmain_c5_drv.drv_detect)(false);
    (*bitmainZCASH_drv.drv_detect)(false);
    (*bmsc_drv.drv_detect)(false);
    (*avalon_drv.drv_detect)(false);
    (*local_11dc->drv_detect)(false);
    (*local_11e0->drv_detect)(false);
    (*local_11e4->drv_detect)(false);
    (*local_11e8->drv_detect)(false);
    (*local_11f0->drv_detect)(false);
    (*local_11f4->drv_detect)(false);
    (*local_11f8->drv_detect)(false);
    (*local_11fc->drv_detect)(false);
    (*local_1200->drv_detect)(false);
    (*local_1204->drv_detect)(false);
    (*local_1208->drv_detect)(false);
    (*local_120c->drv_detect)(false);
    (*local_1210->drv_detect)(false);
    (*local_1214->drv_detect)(false);
    (*local_1218->drv_detect)(false);
    (*local_121c->drv_detect)(false);
    (*sp30_drv.drv_detect)(false);
    piVar53 = &total_devices;
    *local_1220 = 0;
    for (iVar44 = 0; uVar34 = tmp42._32_4_, iVar44 < total_devices;
         iVar44 = iVar44 + 1) {
        enable_device(devices[iVar44]);
    }
    if (total_devices == 0) {
        builtin_strncpy(tmp42, "All devices disabled, cannot mine!", 0x22);
        pcVar9 = tmp42 + 0x22;
        tmp42._34_2_ = SUB42(uVar34, 2);
        goto LAB_00013b34;
    }
    pcVar9 = local_11d4[0xca];
    *(int *)(local_11d8[1].equihash_data + 0x1bc) = total_devices;
    if (pcVar9 == (char *)0x0) {
        iVar33 = pthread_rwlock_rdlock((pthread_rwlock_t *)&devices_lock);
        iVar44 = total_devices;
        ppcVar4 = devices;
        if (iVar33 != 0) {
            _rd_lock((pthread_rwlock_t *)"load_temp_cutoffs", (char *)0x480,
                     func_00, line_12);
            pdVar37 = extraout_r3_00;
        LAB_00014290:
            clean = SUB41(pdVar37, 0);
            snprintf(tmp42, 0x1000,
                     "No login credentials supplied for pool %u %s", pdVar52);
            goto LAB_0001413a;
        }
        local_11e4 = (device_drv *)&devices;
        for (iVar33 = 0; iVar33 < iVar44; iVar33 = iVar33 + 1) {
            if (ppcVar4[iVar33]->cutofftemp == 0) {
                ppcVar4[iVar33]->cutofftemp = 0x5f;
            }
        }
        iVar44 = pthread_rwlock_unlock((pthread_rwlock_t *)&devices_lock);
        if (iVar44 != 0) {
            /* WARNING: Subroutine does not return */
            _rw_unlock((pthread_rwlock_t *)"load_temp_cutoffs", (char *)0x486,
                       func_01, line_13);
        }
    LAB_00013e2a:
        (*selective_yield)();
    } else {
        iVar44 = 0;
        uVar41 = 0;
        thr = &devices;
        pp_Var31 = &selective_yield;
        pcVar9 = strtok(pcVar9, ",");
        while (pcVar9 != (char *)0x0) {
            if (total_devices <= iVar44) {
                tmp42[0] = 'T';
                tmp42[1] = 'o';
                tmp42[2] = 'o';
                tmp42[3] = ' ';
                tmp42[4] = 'm';
                tmp42[5] = 'a';
                tmp42[6] = 'n';
                tmp42[7] = 'y';
                tmp42[8] = ' ';
                tmp42[9] = 'v';
                tmp42[10] = 'a';
                tmp42[0xb] = 'l';
                tmp42[0xc] = 'u';
                tmp42[0xd] = 'e';
                tmp42[0xe] = 's';
                tmp42[0xf] = ' ';
                tmp42[0x10] = 'p';
                tmp42[0x11] = 'a';
                tmp42[0x12] = 's';
                tmp42[0x13] = 's';
                tmp42[0x14] = 'e';
                tmp42[0x15] = 'd';
                tmp42[0x16] = ' ';
                tmp42[0x17] = 't';
                tmp42[0x18] = 'o';
                tmp42[0x19] = ' ';
                tmp42[0x1a] = 's';
                tmp42[0x1b] = 'e';
                tmp42[0x1c] = 't';
                tmp42[0x1d] = ' ';
                tmp42[0x1e] = 't';
                tmp42[0x1f] = 'e';
                tmp42[0x20] = 'm';
                tmp42[0x21] = 'p';
                tmp42[0x22] = ' ';
                tmp42[0x23] = 'c';
                tmp42[0x24] = 'u';
                tmp42[0x25] = 't';
                tmp42[0x26] = 'o';
                tmp42[0x27] = 'f';
                tmp42[0x28] = 'f';
                tmp42[0x29] = '\0';
                goto LAB_00013aae;
            }
            uVar41 = strtol(pcVar9, (char **)0x0, 10);
            if (200 < uVar41) {
                tmp42[0] = 'I';
                tmp42[1] = 'n';
                tmp42[2] = 'v';
                tmp42[3] = 'a';
                tmp42[4] = 'l';
                tmp42[5] = 'i';
                tmp42[6] = 'd';
                tmp42[7] = ' ';
                tmp42[8] = 'v';
                tmp42[9] = 'a';
                tmp42[10] = 'l';
                tmp42[0xb] = 'u';
                tmp42[0xc] = 'e';
                tmp42[0xd] = ' ';
                tmp42[0xe] = 'p';
                tmp42[0xf] = 'a';
                pcVar9 = "ssed to set temp cutoff";
                pcVar10 = tmp42 + 0x10;
                goto LAB_00013ca8;
            }
            iVar33 = pthread_rwlock_rdlock((pthread_rwlock_t *)&devices_lock);
            if (iVar33 != 0) {
                _rd_lock((pthread_rwlock_t *)"load_temp_cutoffs", (char *)0x479,
                         func, line_11);
            LAB_00014250:
                piVar53 = __errno_location();
                snprintf(tmp42, 0x1000,
                         "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                         *piVar53);
                goto LAB_00013cba;
            }
            devices[iVar44]->cutofftemp = uVar41;
            pdVar52 = (device_drv *)pthread_rwlock_unlock(
                (pthread_rwlock_t *)&devices_lock);
            if (pdVar52 != (device_drv *)0x0)
                goto LAB_00014250;
            iVar44 = iVar44 + 1;
            local_11dc = pdVar52;
            (*selective_yield)();
            pcVar9 = strtok((char *)local_11dc, ",");
        }
        if (iVar44 < 2) {
            iVar20 = pthread_rwlock_rdlock((pthread_rwlock_t *)&devices_lock);
            iVar33 = total_devices;
            ppcVar4 = devices;
            if (iVar20 != 0) {
                _rd_lock((pthread_rwlock_t *)"load_temp_cutoffs", (char *)0x48c,
                         func_02, line_14);
            LAB_00014342:
                snprintf((char *)pp_Var31, 0x1000, "thread %d create failed",
                         ((thr_info *)thr)->id);
                _applog(3, (char *)pp_Var31, true);
                /* WARNING: Subroutine does not return */
                __quit(1, false);
            }
            local_11e4 = (device_drv *)&devices;
            for (; iVar44 < iVar33; iVar44 = iVar44 + 1) {
                ppcVar4[iVar44]->cutofftemp = uVar41;
            }
            iVar44 = pthread_rwlock_unlock((pthread_rwlock_t *)&devices_lock);
            if (iVar44 != 0) {
                /* WARNING: Subroutine does not return */
                _rw_unlock((pthread_rwlock_t *)"load_temp_cutoffs",
                           (char *)0x48f, func_03, line_15);
            }
            goto LAB_00013e2a;
        }
        local_11e4 = (device_drv *)&devices;
    }
    uVar34 = tmp42._40_4_;
    iVar44 = total_devices;
    dVar43 = local_11e4->drv_id;
    for (iVar33 = 0; iVar33 < iVar44; iVar33 = iVar33 + 1) {
        *(undefined4 *)(*(int *)(dVar43 + iVar33 * 4) + 0x138) = 99999999;
    }
    if (opt_compact == false) {
        *(int *)(local_11d8[1].equihash_data + 0x1c0) =
            *(int *)(local_11d8[1].equihash_data + 0x1c0) +
            *(int *)(local_11d8[1].equihash_data + 0x1bc);
    }
    local_11dc = (device_drv *)&total_pools;
    if (total_pools == 0) {
        if (((*local_11d0 != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            builtin_strncpy(tmp42, "Need to specify at least one pool server.",
                            0x2a);
            tmp42._42_2_ = SUB42(uVar34, 2);
            _applog(4, tmp42, false);
        }
        builtin_strncpy(tmp42, "Pool setup faile", 0x10);
        tmp42[0x10] = 'd';
        tmp42[0x11] = '\0';
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, false);
    }
    local_11e0 = (device_drv *)&pools;
    local_11e8 = (device_drv *)0x542a4;
    for (pdVar52 = (device_drv *)0x0; (int)pdVar52 < (int)local_11dc->drv_id;
         pdVar52 = (device_drv *)((int)&pdVar52->drv_id + 1)) {
        iVar44 = ((undefined4 *)local_11e0->drv_id)[(int)pdVar52];
        *(undefined4 *)(iVar44 + 0x1ac) = 99999999;
        *(undefined4 *)(iVar44 + 0x1d0) = 99999999;
        if (*(int *)(iVar44 + 200) == 0) {
            if (*(int *)(iVar44 + 0xd0) == 0) {
                pvVar21 = calloc(1, 1);
                *(void **)(iVar44 + 0xd0) = pvVar21;
            }
            pdVar37 = *(device_drv **)(iVar44 + 0xcc);
            if (pdVar37 == (device_drv *)0x0)
                goto LAB_00014290;
            local_11f4 = pdVar37;
            sVar11 = strlen((char *)pdVar37);
            local_11f0 = *(device_drv **)(iVar44 + 0xd0);
            sVar12 = strlen((char *)local_11f0);
            sVar11 = sVar12 + sVar11 + 2;
            pcVar9 = (char *)malloc(sVar11);
            uVar34 = tmp42._24_4_;
            *(char **)(iVar44 + 200) = pcVar9;
            if (pcVar9 == (char *)0x0) {
                builtin_strncpy(tmp42, "Failed to malloc userpass", 0x1a);
                tmp42._26_2_ = SUB42(uVar34, 2);
                goto LAB_000142de;
            }
            snprintf(pcVar9, sVar11, (char *)local_11e8, local_11f4);
        }
    }
    _Var6 = *local_11d0;
    local_11d4[0x13f] = *(char **)local_11e0->drv_id;
    if (_Var6 != false) {
        openlog("cgminer", 1, 8);
    }
    pp_Var31 = (_func_int **)tmp42;
    if (local_11d8[1].tv_staged.tv_usec != 0) {
        iVar44 = pipe((int *)pp_Var31);
        if (iVar44 < 0) {
            perror("pipe - failed to create pipe for --monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
        fflush(stderr);
        iVar44 = dup2(tmp42._4_4_, 2);
        if (iVar44 < 0) {
            perror("dup2 - failed to alias stderr to write end of pipe for "
                   "--monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
        iVar44 = close(tmp42._4_4_);
        if (iVar44 < 0) {
            perror("close - failed to close write end of pipe for --monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
        p_Var16 = signal(0xd, (__sighandler_t)0x1);
        p_Var17 = signal(0xd, (__sighandler_t)0x1);
        if ((p_Var16 == (__sighandler_t)0xffffffff) ||
            (p_Var17 == (__sighandler_t)0xffffffff)) {
            perror("signal - failed to edit signal mask for --monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
        pcVar9 = (char *)fork();
        local_11d4[0xd1] = pcVar9;
        if ((int)pcVar9 < 0) {
            perror("fork - failed to fork child process for --monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
        if (pcVar9 == (char *)0x0) {
            iVar44 = dup2(tmp42._0_4_, 0);
            if (iVar44 < 0) {
                perror("dup2 - in child, failed to alias read end of pipe to "
                       "stdin for --monitor");
                /* WARNING: Subroutine does not return */
                exit(1);
            }
            close(tmp42._0_4_);
            execl("/bin/bash", "/bin/bash", &DAT_00051d14,
                  local_11d8[1].tv_staged.tv_usec);
            perror("execl - in child failed to exec user specified command for "
                   "--monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
        iVar44 = close(tmp42._0_4_);
        if (iVar44 < 0) {
            perror("close - failed to close read end of pipe for --monitor");
            /* WARNING: Subroutine does not return */
            exit(1);
        }
    }
    mining_thr = (thr_info **)calloc(*local_1220, 4);
    psVar5 = local_1220;
    local_11f4 = (device_drv *)&mining_thr;
    if (mining_thr != (thr_info **)0x0) {
        for (iVar44 = 0; pptVar19 = mining_thr, iVar44 < (int)*psVar5;
             iVar44 = iVar44 + 1) {
            ptVar18 = (thr_info *)calloc(1, 0x40);
            pptVar19[iVar44] = ptVar18;
            if (mining_thr[iVar44] == (thr_info *)0x0) {
                snprintf((char *)pp_Var31, 0x1000,
                         "Failed to calloc mining_thr[%d]", iVar44);
                goto LAB_00014138;
            }
        }
        local_11e8 = (device_drv *)0x0;
        local_11f8 = (device_drv *)&opt_debug;
        local_11f0 = (device_drv *)(code *)0x16b81;
        for (iVar44 = 0; pdVar52 = local_11dc, iVar44 < total_devices;
             iVar44 = iVar44 + 1) {
            pcVar47 = *(cgpu_info **)(local_11e4->drv_id + iVar44 * 4);
            iVar33 = pcVar47->threads;
            pptVar19 = (thr_info **)malloc((iVar33 + 1) * 4);
            pcVar47->thr = pptVar19;
            pptVar19[iVar33] = (thr_info *)0x0;
            pcVar47->status = LIFE_INIT;
            for (iVar33 = 0;
                 pdVar52 = (device_drv *)((int)&local_11e8->drv_id + iVar33),
                iVar33 < pcVar47->threads;
                 iVar33 = iVar33 + 1) {
                local_11fc = pdVar52;
                thr = (cgpu_info ***)get_thread((int)pdVar52);
                ((thr_info *)thr)->cgpu = pcVar47;
                ((thr_info *)thr)->device_thread = iVar33;
                ((thr_info *)thr)->id = (int)local_11fc;
                _Var6 = (*pcVar47->drv->thread_prepare)((thr_info *)thr);
                if (_Var6) {
                    iVar20 = thr_info_create(
                        (thr_info *)thr, (pthread_attr_t *)0x0,
                        (_func_void_ptr_void_ptr *)local_11f0, thr);
                    if (iVar20 != 0)
                        goto LAB_00014342;
                    pcVar47->thr[iVar33] = (thr_info *)thr;
                    if (pcVar47->deven != DEV_DISABLED) {
                        if (((char)local_11f8->drv_id != DRIVER_bitforce) &&
                            (((*local_11d0 != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            snprintf((char *)pp_Var31, 0x1000,
                                     "Pushing sem post to thread %d",
                                     ((thr_info *)thr)->id);
                            _applog(7, (char *)pp_Var31, false);
                        }
                        _cgsem_post(&((thr_info *)thr)->sem, "cgminer.c",
                                    "main", 0x2b7a);
                    }
                }
            }
            local_11e8 = pdVar52;
        }
        if ((*(char *)((int)local_11d4 + 0x561) == '\0') &&
            (local_11d4[0x10d] == (char *)0x0)) {
            for (iVar44 = 0;
                 uVar34 = tmp42._24_4_, iVar44 < (int)pdVar52->drv_id;
                 iVar44 = iVar44 + 1) {
                iVar33 = *(int *)(local_11e0->drv_id + iVar44 * 4);
                if (*(int *)(iVar33 + 0x84) != 1) {
                    enable_pool((pool *)(iVar33 + 0x84));
                }
                *(undefined1 *)(iVar33 + 0x81) = 1;
            }
            if ((opt_debug != false) &&
                (((*local_11d0 != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                builtin_strncpy(tmp42, "Probing for an alive pool", 0x1a);
                tmp42._26_2_ = SUB42(uVar34, 2);
                _applog(7, (char *)pp_Var31, false);
            }
            pdVar52 = local_11e0;
            for (iVar44 = 0; iVar44 < (int)local_11dc->drv_id;
                 iVar44 = iVar44 + 1) {
                pvVar21 = *(void **)(pdVar52->drv_id + iVar44 * 4);
                *(undefined1 *)((int)pvVar21 + 0x13c) = 1;
                pthread_create((pthread_t *)((int)pvVar21 + 0x138),
                               (pthread_attr_t *)0x0,
                               (__start_routine *)0x1ecdd, pvVar21);
            }
            iVar44 = 0;
            do {
                iVar44 = iVar44 + 1;
                sleep(1);
                p_Var51 = local_11d0;
                if (iVar44 == 0x3c) {
                    bVar30 = 0;
                } else {
                    bVar30 = (*(byte *)(local_11d4 + 0x158) ^ 1) & 1;
                }
            } while (bVar30 != 0);
            local_11f8 = (device_drv *)&total_devices;
            piVar48 = &opt_log_level;
            local_11f0 = (device_drv *)0x51efc;
            bVar2 = false;
            while (piVar53 = (int *)local_11f8,
                   *(char *)(local_11d4 + 0x158) == '\0') {
                if (bVar2) {
                LAB_000145d6:
                    if (use_curses == false) {
                    LAB_00014efc:
                        uVar34 = tmp42._32_4_;
                        builtin_strncpy(
                            tmp42, "No servers could be used! Exiting.", 0x23);
                        tmp42[0x23] = SUB41(uVar34, 3);
                        _applog(3, (char *)pp_Var31, true);
                        /* WARNING: Subroutine does not return */
                        __quit(0, false);
                    }
                } else {
                    if (((*p_Var51 == false) && (opt_log_output == false)) &&
                        ((int)((device_drv *)piVar48)->drv_id < 3)) {
                    LAB_00014ee6:
                        if (2 < (int)((device_drv *)piVar48)->drv_id)
                            goto LAB_00014e52;
                    LAB_00014eec:
                        if (2 < (int)((device_drv *)piVar48)->drv_id)
                            goto LAB_00014e78;
                    } else {
                        builtin_strncpy(tmp42,
                                        "No servers were found that could be "
                                        "used to get work fro",
                                        0x38);
                        tmp42[0x38] = 'm';
                        tmp42[0x39] = '.';
                        tmp42[0x3a] = '\0';
                        _applog(3, (char *)pp_Var31, false);
                        if ((*p_Var51 == false) && (opt_log_output == false))
                            goto LAB_00014ee6;
                    LAB_00014e52:
                        memcpy(pp_Var31,
                               "Please check the details from the list below "
                               "of the servers you have input",
                               0x4b);
                        _applog(3, (char *)pp_Var31, false);
                        if ((*p_Var51 == false) && (opt_log_output == false))
                            goto LAB_00014eec;
                    LAB_00014e78:
                        memcpy(pp_Var31,
                               "Most likely you have input the wrong URL, "
                               "forgotten to add a port, or have not set up "
                               "workers",
                               0x5e);
                        _applog(3, (char *)pp_Var31, false);
                    }
                    local_11e8 = (device_drv *)piVar48;
                    for (iVar44 = 0; piVar48 = (int *)local_11e8,
                        iVar44 < (int)local_11dc->drv_id;
                         iVar44 = iVar44 + 1) {
                        if (((*p_Var51 != false) ||
                             (opt_log_output != false)) ||
                            (3 < (int)local_11e8->drv_id)) {
                            snprintf((char *)pp_Var31, 0x1000,
                                     (char *)local_11f0, iVar44);
                            _applog(4, (char *)pp_Var31, false);
                        }
                    }
                    if (use_curses == false)
                        goto LAB_00014efc;
                    if (((*p_Var51 != false) || (opt_log_output != false)) ||
                        (2 < (int)local_11e8->drv_id)) {
                        memcpy(pp_Var31,
                               "Press any key to exit, or cgminer will wait "
                               "indefinitely for an alive pool.",
                               0x4c);
                        _applog(3, (char *)pp_Var31, false);
                        goto LAB_000145d6;
                    }
                }
                bVar2 = true;
            }
        }
        total_mhashes_done._0_4_ = 0;
        total_mhashes_done._4_4_ = 0;
        pdVar22 = g_local_mhashes_dones;
        do {
            pdVar23 = pdVar22 + 1;
            *(int *)pdVar22 = 0;
            *(int *)((int)pdVar22 + 4) = 0;
            pdVar22 = pdVar23;
        } while (pdVar23 != (double *)&g_local_mhashes_index);
        pcVar9 = (char *)((device_drv *)piVar53)->drv_id;
        dVar43 = local_11e4->drv_id;
        local_11d4[0x130] = (char *)0x0;
        for (ppVar13 = local_11ec; (int)ppVar13 < (int)pcVar9;
             ppVar13 = (pool *)((int)&ppVar13->pool_no + 1)) {
            iVar44 = *(int *)(dVar43 + (int)ppVar13 * 4);
            *(undefined4 *)(iVar44 + 0x50) = 0;
            *(undefined4 *)(iVar44 + 0x54) = 0;
            *(undefined4 *)(iVar44 + 0x30) = 0;
            *(undefined4 *)(iVar44 + 0x34) = 0;
        }
        cgtime(&total_tv_start);
        cgtime(&total_tv_end);
        cgtime(&tv_hashmeter);
        get_datestamp(datestamp, 0x28, &total_tv_start);
        ptVar18 = *local_1228;
        local_11d4[0x13d] = (char *)0x2;
        iVar44 =
            thr_info_create(ptVar18 + 2, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x1eebd, (void *)0x0);
        uVar34 = tmp42._28_4_;
        if (iVar44 != 0) {
            builtin_strncpy(tmp42, "watchpool thread create failed", 0x1f);
            tmp42[0x1f] = SUB41(uVar34, 3);
            _applog(3, (char *)pp_Var31, true);
            /* WARNING: Subroutine does not return */
            __quit(1, false);
        }
        pthread_detach(ptVar18[2].pth);
        ptVar18 = *local_1228;
        local_11d4[0x13e] = (char *)0x3;
        iVar44 =
            thr_info_create(ptVar18 + 3, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x22481, (void *)0x0);
        uVar34 = tmp42._28_4_;
        if (iVar44 != 0) {
            builtin_strncpy(tmp42, "watchdog thread create failed", 0x1e);
            tmp42._30_2_ = SUB42(uVar34, 2);
            _applog(3, (char *)pp_Var31, true);
            /* WARNING: Subroutine does not return */
            __quit(1, false);
        }
        pthread_detach(ptVar18[3].pth);
        ptVar18 = *local_1228;
        local_11d4[200] = (char *)0x5;
        iVar44 =
            thr_info_create(ptVar18 + 5, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x1734d, ptVar18 + 5);
        if (iVar44 != 0) {
            tmp42[0] = 'A';
            tmp42[1] = 'P';
            tmp42[2] = 'I';
            tmp42[3] = ' ';
            tmp42[4] = 't';
            tmp42[5] = 'h';
            tmp42[6] = 'r';
            tmp42[7] = 'e';
            tmp42[8] = 'a';
            tmp42[9] = 'd';
            tmp42[10] = ' ';
            tmp42[0xb] = 'c';
            tmp42[0xc] = 'r';
            tmp42[0xd] = 'e';
            tmp42[0xe] = 'a';
            tmp42[0xf] = 't';
            tmp42[0x10] = 'e';
            tmp42[0x11] = ' ';
            tmp42[0x12] = 'f';
            tmp42[0x13] = 'a';
            tmp42[0x14] = 'i';
            tmp42[0x15] = 'l';
            tmp42[0x16] = 'e';
            tmp42[0x17] = 'd';
            tmp42._24_4_ = tmp42._24_4_ & 0xffffff00;
        LAB_000142de:
            _applog(3, tmp42, true);
            /* WARNING: Subroutine does not return */
            __quit(1, false);
        }
        if (local_11d8[1].tv_staged.tv_sec != 8) {
            snprintf((char *)pp_Var31, 0x1000,
                     "incorrect total_control_threads (%d) should be 8");
        LAB_00013a18:
            _applog(3, tmp42, true);
            /* WARNING: Subroutine does not return */
            __quit(1, false);
        }
        iVar44 = nice(-10);
        uVar34 = tmp42._36_4_;
        if (((iVar44 == 0) && (opt_debug != false)) &&
            ((*local_11d0 != false ||
              ((opt_log_output != false || (6 < opt_log_level)))))) {
            builtin_strncpy(tmp42, "Unable to set thread to high priority",
                            0x26);
            tmp42._38_2_ = SUB42(uVar34, 2);
            _applog(7, (char *)pp_Var31, false);
        }
        ppcVar8 = local_11d4;
        pwVar3 = local_11d8;
        local_11e8 = (device_drv *)&global_quota_gcd;
        local_11f0 = (device_drv *)&opt_work_update;
        local_11e4 = (device_drv *)&opt_fail_only;
        local_11d4 = (char **)&opt_debug;
        pwVar24 = (work *)0x0;
    LAB_00014674:
        while (true) {
            p_Var49 = local_11e8[0xf].thread_shutdown;
            if (*(code *)&local_11f0->drv_id != (code)0x0) {
                if ((*(char *)local_11d4 != '\0') &&
                    (((*local_11d0 != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    builtin_strncpy(tmp42, "Work update message received",
                                    0x1c);
                    tmp42._28_4_ = tmp42._28_4_ & 0xffffff00;
                    _applog(7, (char *)pp_Var31, false);
                }
                cgtime(&update_tv_start);
                iVar44 =
                    pthread_rwlock_rdlock((pthread_rwlock_t *)&mining_thr_lock);
                if (iVar44 != 0) {
                    piVar53 = __errno_location();
                    pcVar9 = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
                    goto LAB_00014cd6;
                }
                sVar11 = *local_1220;
                dVar43 = local_11f4->drv_id;
                for (iVar44 = 0; iVar44 < (int)sVar11; iVar44 = iVar44 + 1) {
                    *(undefined1 *)(*(int *)(dVar43 + iVar44 * 4) + 0x3f) = 1;
                }
                iVar44 =
                    pthread_rwlock_unlock((pthread_rwlock_t *)&mining_thr_lock);
                if (iVar44 != 0) {
                    piVar53 = __errno_location();
                    pcVar9 =
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                    goto LAB_00014cd6;
                }
                (*selective_yield)();
            }
            *(code *)&local_11f0->drv_id = (code)0x0;
            current_pool();
            iVar44 = pthread_mutex_lock((pthread_mutex_t *)ppcVar8[0x111]);
            if (iVar44 != 0) {
                piVar53 = __errno_location();
                pcVar9 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                goto LAB_00014cd6;
            }
            pcVar9 = ppcVar8[0x144];
            if (pcVar9 != (char *)0x0) {
                pcVar9 = *(char **)(*(int *)(pcVar9 + 0x728) + 0xc);
            }
            __mutex = (pthread_mutex_t *)ppcVar8[0x111];
            if ((int)pcVar9 <= (int)p_Var49)
                break;
            if (*(char *)((int)ppcVar8 + 0x589) != '\0') {
                p_Var38 = local_11e8[0xf].thread_shutdown;
                p_Var28 = local_11e8[0xf].thread_enable;
                p_Var29 = p_Var28;
                p_Var39 = p_Var38;
                if ((int)p_Var38 < (int)p_Var28) {
                    p_Var39 = p_Var38 + 1;
                    p_Var29 = (_func_void_thr_info_ptr *)0x0;
                }
                if ((int)p_Var38 < (int)p_Var28) {
                    local_11e8[0xf].thread_shutdown = p_Var39;
                    *(char *)((int)ppcVar8 + 0x589) = (char)p_Var29;
                }
            }
            *(char *)(ppcVar8 + 0x162) = '\x01';
            pthread_cond_wait((pthread_cond_t *)&gws_cond, __mutex);
            pcVar9 = ppcVar8[0x144];
            if (pcVar9 != (char *)0x0) {
                pcVar9 = *(char **)(*(int *)(pcVar9 + 0x728) + 0xc);
            }
            iVar44 = pthread_mutex_unlock((pthread_mutex_t *)ppcVar8[0x111]);
            if (iVar44 != 0)
                goto LAB_00014dbc;
            (*selective_yield)();
            if ((int)pcVar9 <= (int)p_Var49)
                goto LAB_00014764;
            if (*(char *)((int)ppcVar8 + 0x589) != '\0') {
                p_Var29 = local_11e8[0xf].thread_shutdown;
                p_Var39 = local_11e8[0xf].thread_enable;
                p_Var49 = p_Var29;
                if ((int)p_Var29 < (int)p_Var39) {
                    p_Var49 = p_Var29 + 1;
                    *(char *)((int)ppcVar8 + 0x589) = '\0';
                }
                if ((int)p_Var29 < (int)p_Var39) {
                    local_11e8[0xf].thread_shutdown = p_Var49;
                }
            }
            *(char *)(ppcVar8 + 0x162) = '\x01';
            pwVar24 = hash_pop(false);
            if (pwVar24 != (work *)0x0) {
                _discard_work(pwVar24);
                pwVar24 = (work *)0x0;
            }
        }
        iVar44 = pthread_mutex_unlock(__mutex);
        if (iVar44 == 0) {
            (*selective_yield)();
        LAB_00014764:
            if (pwVar24 != (work *)0x0) {
                _discard_work(pwVar24);
            }
            pwVar24 = make_work();
            ppVar13 = current_pool();
            pdVar52 = local_11dc;
            if (ppcVar8[0xc9] == (char *)0x4) {
                ppVar25 = select_balanced(ppVar13);
            } else {
                ppVar25 = ppVar13;
                if (ppcVar8[0xc9] == (char *)0x3) {
                    dVar43 = local_11e0->drv_id;
                    pcVar9 = (char *)local_11dc->drv_id;
                    for (iVar44 = 0; iVar44 < (int)pcVar9;
                         iVar44 = iVar44 + 1) {
                        iVar33 = *(int *)(dVar43 + iVar44 * 4);
                        if (*(int *)(iVar33 + 0x40) < *(int *)(iVar33 + 0x3c))
                            goto LAB_00014b5c;
                    }
                    for (iVar44 = 0; iVar44 < (int)pcVar9;
                         iVar44 = iVar44 + 1) {
                        *(undefined4 *)(*(int *)(dVar43 + iVar44 * 4) + 0x40) =
                            0;
                    }
                    iVar44 = *(int *)&pwVar3[1].mined + 1;
                    *(int *)&pwVar3[1].mined = iVar44;
                    if ((int)pcVar9 <= iVar44) {
                        pwVar3[1].mined = false;
                        pwVar3[1].clone = false;
                        pwVar3[1].cloned = false;
                        pwVar3[1].field_0x6e3 = 0;
                    }
                LAB_00014b5c:
                    iVar44 = 0;
                    while (pdVar37 = local_11dc, iVar33 = iVar44 + 1,
                           iVar44 < (int)pdVar52->drv_id) {
                        ppVar25 = *(pool **)(local_11e0->drv_id +
                                             *(int *)&pwVar3[1].mined * 4);
                        iVar44 = ppVar25->quota_used;
                        ppVar25->quota_used = iVar44 + 1;
                        if (iVar44 < ppVar25->quota_gcd) {
                            if (((ppVar25->idle == false) &&
                                 (ppVar25->enabled == POOL_ENABLED)) &&
                                ((ppVar25->has_stratum == false ||
                                  (ppVar25->stratum_active != false))))
                                goto LAB_0001478e;
                            if ((char)local_11e4->drv_id != DRIVER_bitforce) {
                                ppVar25 = priority_pool(0);
                                ppVar25->quota_used = ppVar25->quota_used + -1;
                            }
                        }
                        pcVar9 = (char *)pdVar52->drv_id;
                        iVar20 = *(int *)&pwVar3[1].mined + 1;
                        *(int *)&pwVar3[1].mined = iVar20;
                        iVar44 = iVar33;
                        if ((int)pcVar9 <= iVar20) {
                            pwVar3[1].mined = false;
                            pwVar3[1].clone = false;
                            pwVar3[1].cloned = false;
                            pwVar3[1].field_0x6e3 = 0;
                        }
                    }
                    iVar44 = 0;
                    while ((ppVar25 = ppVar13,
                            iVar44 < (int)pdVar37->drv_id &&
                                ((ppVar25 = priority_pool(iVar44),
                                  ppVar25->idle != false ||
                                      (ppVar25->enabled != POOL_ENABLED))))) {
                        iVar44 = iVar44 + 1;
                    }
                }
            }
        LAB_0001478e:
            pdVar52 = local_11dc;
            if ((*(char *)local_11d4 != '\0') &&
                (((*local_11d0 != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf((char *)pp_Var31, 0x1000, "Selecting pool %d for work",
                         ppVar25->pool_no);
                _applog(7, (char *)pp_Var31, false);
                pdVar52 = local_11dc;
            }
            while (local_11d8 = pwVar24, ppVar13 = ppVar25,
                   pwVar24 = local_11d8, ppVar13->has_stratum != false) {
                do {
                    pwVar24 = local_11d8;
                    if ((ppVar13->stratum_active != false) &&
                        (ppVar13->stratum_notify != false)) {
                        gen_stratum_work(ppVar13, local_11d8);
                        uVar34 = tmp42._20_4_;
                        if ((*(char *)local_11d4 != '\0') &&
                            (((*local_11d0 != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            builtin_strncpy(tmp42, "Generated stratum work",
                                            0x17);
                            tmp42[0x17] = SUB41(uVar34, 3);
                            _applog(7, (char *)pp_Var31, false);
                        }
                        goto LAB_000149ea;
                    }
                    ppVar25 = current_pool();
                    local_11ec = ppVar25;
                    if (ppcVar8[0xc9] == (char *)0x4) {
                        ppVar25 = select_balanced(ppVar25);
                    } else if ((ppcVar8[0xc9] == (char *)0x3) ||
                               ((char)local_11e4->drv_id == DRIVER_bitforce)) {
                        pcVar9 = (char *)pdVar52->drv_id;
                        dVar43 = local_11e0->drv_id;
                        for (iVar44 = 0; iVar44 < (int)pcVar9;
                             iVar44 = iVar44 + 1) {
                            iVar33 = *(int *)(dVar43 + iVar44 * 4);
                            if (*(int *)(iVar33 + 0x40) <
                                *(int *)(iVar33 + 0x3c))
                                goto LAB_000148ae;
                        }
                        for (iVar44 = 0; iVar44 < (int)pcVar9;
                             iVar44 = iVar44 + 1) {
                            *(undefined4 *)(*(int *)(dVar43 + iVar44 * 4) +
                                            0x40) = 0;
                        }
                        iVar44 = *(int *)&pwVar3[1].mined + 1;
                        *(int *)&pwVar3[1].mined = iVar44;
                        if ((int)pcVar9 <= iVar44) {
                            pwVar3[1].mined = false;
                            pwVar3[1].clone = false;
                            pwVar3[1].cloned = false;
                            pwVar3[1].field_0x6e3 = 0;
                        }
                    LAB_000148ae:
                        for (iVar44 = 0; iVar44 < (int)pdVar52->drv_id;
                             iVar44 = iVar44 + 1) {
                            ppVar25 = *(pool **)(local_11e0->drv_id +
                                                 *(int *)&pwVar3[1].mined * 4);
                            iVar33 = ppVar25->quota_used;
                            ppVar25->quota_used = iVar33 + 1;
                            if (iVar33 < ppVar25->quota_gcd) {
                                if (((ppVar25->idle == false) &&
                                     (ppVar25->enabled == POOL_ENABLED)) &&
                                    ((ppVar25->has_stratum == false ||
                                      (ppVar25->stratum_active != false))))
                                    goto LAB_0001481c;
                                if ((char)local_11e4->drv_id !=
                                    DRIVER_bitforce) {
                                    ppVar25 = priority_pool(0);
                                    ppVar25->quota_used =
                                        ppVar25->quota_used + -1;
                                }
                            }
                            pcVar9 = (char *)pdVar52->drv_id;
                            iVar33 = *(int *)&pwVar3[1].mined + 1;
                            *(int *)&pwVar3[1].mined = iVar33;
                            if ((int)pcVar9 <= iVar33) {
                                pwVar3[1].mined = false;
                                pwVar3[1].clone = false;
                                pwVar3[1].cloned = false;
                                pwVar3[1].field_0x6e3 = 0;
                            }
                        }
                        iVar44 = 0;
                        while (
                            (ppVar25 = local_11ec,
                             iVar44 < (int)pdVar52->drv_id &&
                                 ((ppVar25 = priority_pool(iVar44),
                                   ppVar25->idle != false ||
                                       (ppVar25->enabled != POOL_ENABLED))))) {
                            iVar44 = iVar44 + 1;
                        }
                    }
                LAB_0001481c:
                    if ((*(char *)local_11d4 != '\0') &&
                        (((*local_11d0 != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf((char *)pp_Var31, 0x1000,
                                 "Selecting pool %d for work",
                                 ppVar25->pool_no);
                        _applog(7, (char *)pp_Var31, false);
                    }
                    cgsleep_ms(5000);
                    pwVar24 = local_11d8;
                } while (ppVar13 == ppVar25);
            }
            if (ppcVar8[0x10d] == (char *)0x0) {
                if (*(char *)((int)ppcVar8 + 0x561) == '\0')
                    goto LAB_00014674;
                local_11d8->work_difficulty = 32.0;
                ptVar54 = &local_11d8->tv_getwork;
                local_11d8->drv_rolllimit = 0;
                local_11d8->mandatory = true;
                uVar36 = bench_target._12_4_;
                uVar27 = bench_target._8_4_;
                uVar34 = bench_target._4_4_;
                pwVar40 = (work *)local_11e0->drv_id;
                *(undefined4 *)local_11d8->target = bench_target._0_4_;
                *(undefined4 *)(local_11d8->target + 4) = uVar34;
                *(undefined4 *)(local_11d8->target + 8) = uVar27;
                *(undefined4 *)(local_11d8->target + 0xc) = uVar36;
                uVar36 = bench_target._24_4_;
                uVar27 = bench_target._20_4_;
                uVar34 = bench_target._16_4_;
                *(undefined4 *)(local_11d8->target + 0x1c) =
                    bench_target._28_4_;
                *(undefined4 *)(local_11d8->target + 0x18) = uVar36;
                *(undefined4 *)(local_11d8->target + 0x10) = uVar34;
                *(undefined4 *)(local_11d8->target + 0x14) = uVar27;
                local_11d8->pool = *(pool **)pwVar40->data;
                local_11d8 = pwVar40;
                cgtime(ptVar54);
                copy_time(&pwVar24->tv_getwork_reply, ptVar54);
                pwVar24->getwork_mode = 'B';
                if ((*(char *)local_11d4 != '\0') &&
                    (((*local_11d0 != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    pcVar9 = "Generated benchmark work";
                    goto LAB_000149d4;
                }
            } else {
                ptVar54 = &local_11d8->tv_getwork;
                benchfile_get_work(local_11d8);
                pwVar24->mandatory = true;
                pwVar24->pool = *(pool **)local_11e0->drv_id;
                cgtime(ptVar54);
                copy_time(&pwVar24->tv_getwork_reply, ptVar54);
                pwVar24->getwork_mode = 'B';
                calc_diff(pwVar24, 0.0);
                if ((*(char *)local_11d4 != '\0') &&
                    (((*local_11d0 != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    pcVar9 = "Generated benchfile work";
                LAB_000149d4:
                    tmp42._0_4_ = *(undefined4 *)pcVar9;
                    tmp42._4_4_ = *(undefined4 *)(pcVar9 + 4);
                    tmp42._8_4_ = *(undefined4 *)(pcVar9 + 8);
                    tmp42._12_4_ = *(undefined4 *)(pcVar9 + 0xc);
                    tmp42._16_4_ = *(undefined4 *)(pcVar9 + 0x10);
                    tmp42._20_4_ = *(undefined4 *)(pcVar9 + 0x14);
                    tmp42[0x18] = (char)*(undefined4 *)(pcVar9 + 0x18);
                    _applog(7, (char *)pp_Var31, false);
                }
            }
        LAB_000149ea:
            _stage_work(pwVar24);
            pwVar24 = (work *)0x0;
            goto LAB_00014674;
        }
    LAB_00014dbc:
        piVar53 = __errno_location();
        pcVar9 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    LAB_00014cd6:
        snprintf((char *)pp_Var31, 0x1000, pcVar9, *piVar53);
    LAB_00013cba:
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    tmp42[0] = 'F';
    tmp42[1] = 'a';
    tmp42[2] = 'i';
    tmp42[3] = 'l';
    tmp42[4] = 'e';
    tmp42[5] = 'd';
    tmp42[6] = ' ';
    tmp42[7] = 't';
    tmp42[8] = 'o';
    tmp42[9] = ' ';
    tmp42[10] = 'c';
    tmp42[0xb] = 'a';
    tmp42[0xc] = 'l';
    tmp42[0xd] = 'l';
    tmp42[0xe] = 'o';
    tmp42[0xf] = 'c';
    tmp42[0x10] = ' ';
    tmp42[0x11] = 'm';
    tmp42[0x12] = 'i';
    tmp42[0x13] = 'n';
    tmp42[0x14] = 'i';
    tmp42[0x15] = 'n';
    tmp42[0x16] = 'g';
    tmp42[0x17] = '_';
    tmp42[0x18] = 't';
    tmp42[0x19] = 'h';
    tmp42[0x1a] = 'r';
    tmp42[0x1b] = '\0';
LAB_00014138:
    clean = false;
LAB_0001413a:
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, (_Bool)clean);
}

void _start(undefined4 param_1)

{
    undefined4 in_stack_00000000;

    __libc_start_main(0x12701, in_stack_00000000, &stack0x00000004, 0x4c501,
                      0x4c53d, param_1);
    /* WARNING: Subroutine does not return */
    abort();
}

/* WARNING: Removing unreachable block (ram,0x00014fd8) */

void call_weak_fn(void)

{
    __gmon_start__();
    return;
}

/* WARNING: Removing unreachable block (ram,0x00014ffc) */
/* WARNING: Removing unreachable block (ram,0x00015006) */

void deregister_tm_clones(void)

{
    return;
}

/* WARNING: Removing unreachable block (ram,0x00015028) */
/* WARNING: Removing unreachable block (ram,0x00015032) */

void register_tm_clones(void)

{
    return;
}

void __do_global_dtors_aux(void)

{
    if (completed_10529 == '\0') {
        deregister_tm_clones();
        completed_10529 = '\x01';
    }
    return;
}

/* WARNING: Unknown calling convention */

char *set_balance(pool_strategy *strategy)

{
    *strategy = POOL_BALANCE;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_loadbalance(pool_strategy *strategy)

{
    *strategy = POOL_LOADBALANCE;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_rr(pool_strategy *strategy)

{
    *strategy = POOL_ROUNDROBIN;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *enable_debug(_Bool *flag)

{
    *flag = true;
    opt_log_output = true;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_null(char *arg)

{
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

void noop_reinit_device(cgpu_info *cgpu)

{
    return;
}

/* WARNING: Unknown calling convention */

void blank_get_statline_before(char *buf, size_t bufsiz, cgpu_info *cgpu)

{
    return;
}

/* WARNING: Unknown calling convention */

_Bool noop_get_stats(cgpu_info *cgpu)

{
    return true;
}

/* WARNING: Unknown calling convention */

uint64_t noop_can_limit_work(thr_info *thr)

{
    return 0xffffffff;
}

/* WARNING: Unknown calling convention */

_Bool noop_prepare_work(thr_info *thr, work *work)

{
    return true;
}

/* WARNING: Unknown calling convention */

void noop_detect(_Bool hotplug)

{
    return;
}

/* WARNING: Unknown calling convention */

api_data *noop_get_api_stats(cgpu_info *cgpu)

{
    return (api_data *)0x0;
}

void SHA256_Transform(SHA256_CTX *c, uchar *data)

{
    uint *puVar1;
    uint uVar2;
    uint *puVar3;
    int in_r2;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    uint32_t uVar8;
    uint uVar9;
    int iVar10;
    uint uVar11;
    uint uVar12;
    uint32_t *puVar13;
    uint uVar14;
    uint uVar15;
    uint uVar16;
    uint32_t *local_154;
    uint32_t S[8];
    uint32_t W[64];

    if (in_r2 == 0) {
        W[0] = *(uint32_t *)data;
        W[1] = *(uint32_t *)(data + 4);
        W[2] = *(uint32_t *)(data + 8);
        W[3] = *(uint32_t *)(data + 0xc);
        W[4] = *(uint32_t *)(data + 0x10);
        W[5] = *(uint32_t *)(data + 0x14);
        W[6] = *(uint32_t *)(data + 0x18);
        W[7] = *(uint32_t *)(data + 0x1c);
        W[8] = *(uint32_t *)(data + 0x20);
        W[9] = *(uint32_t *)(data + 0x24);
        W[10] = *(uint32_t *)(data + 0x28);
        W[0xb] = *(uint32_t *)(data + 0x2c);
        W[0xc] = *(uint32_t *)(data + 0x30);
        W[0xd] = *(uint32_t *)(data + 0x34);
        W[0xe] = *(uint32_t *)(data + 0x38);
        W[0xf] = *(uint32_t *)(data + 0x3c);
    } else {
        puVar1 = (uint *)(data + -4);
        puVar3 = S + 7;
        do {
            puVar1 = puVar1 + 1;
            uVar6 = *puVar1;
            puVar3 = puVar3 + 1;
            *puVar3 = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                      (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        } while (W + 0xf != puVar3);
    }
    local_154 = W;
    do {
        uVar9 = local_154[0xe];
        uVar6 = local_154[0xf];
        uVar7 = local_154[1];
        uVar14 = local_154[2];
        local_154[0x10] = ((uVar9 >> 0x13 | uVar9 << 0xd) ^
                           (uVar9 >> 0x11 | uVar9 << 0xf) ^ uVar9 >> 10) +
                          local_154[9] + *local_154 +
                          ((uVar7 >> 0x12 | uVar7 << 0xe) ^
                           (uVar7 >> 7 | uVar7 << 0x19) ^ uVar7 >> 3);
        local_154[0x11] = uVar7 + local_154[10] +
                          ((uVar6 >> 0x13 | uVar6 << 0xd) ^
                           (uVar6 >> 0x11 | uVar6 << 0xf) ^ uVar6 >> 10) +
                          ((uVar14 >> 0x12 | uVar14 << 0xe) ^
                           (uVar14 >> 7 | uVar14 << 0x19) ^ uVar14 >> 3);
        local_154 = local_154 + 2;
    } while (W + 0x30 != local_154);
    uVar6 = c->h[0];
    uVar2 = c->h[1];
    uVar4 = c->h[2];
    uVar7 = c->h[4];
    uVar14 = c->h[5];
    uVar5 = c->h[6];
    iVar10 = c->h[7] + W[0] + 0x428a2f98 +
             ((uVar7 >> 0xb | uVar7 << 0x15) ^ (uVar7 >> 6 | uVar7 << 0x1a) ^
              (uVar7 >> 0x19 | uVar7 << 7)) +
             ((uVar14 ^ uVar5) & uVar7 ^ uVar5);
    uVar9 = c->h[3] + iVar10;
    uVar11 = iVar10 + ((uVar2 | uVar4) & uVar6 | uVar2 & uVar4) +
             ((uVar6 >> 0xd | uVar6 << 0x13) ^ (uVar6 >> 2 | uVar6 << 0x1e) ^
              (uVar6 >> 0x16 | uVar6 << 10));
    iVar10 =
        uVar5 + W[1] + 0x71374491 + ((uVar7 ^ uVar14) & uVar9 ^ uVar14) +
        ((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
         (uVar9 >> 0x19 | uVar9 * 0x80));
    uVar4 = uVar4 + iVar10;
    uVar16 = iVar10 + ((uVar6 | uVar2) & uVar11 | uVar6 & uVar2) +
             ((uVar11 >> 0xd | uVar11 * 0x80000) ^
              (uVar11 >> 2 | uVar11 * 0x40000000) ^
              (uVar11 >> 0x16 | uVar11 * 0x400));
    iVar10 =
        uVar14 + W[2] + -0x4a3f0431 + ((uVar7 ^ uVar9) & uVar4 ^ uVar7) +
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80));
    uVar2 = uVar2 + iVar10;
    uVar15 = iVar10 +
             ((uVar16 >> 0xd | uVar16 * 0x80000) ^
              (uVar16 >> 2 | uVar16 * 0x40000000) ^
              (uVar16 >> 0x16 | uVar16 * 0x400)) +
             ((uVar6 | uVar11) & uVar16 | uVar6 & uVar11);
    iVar10 =
        ((uVar9 ^ uVar4) & uVar2 ^ uVar9) + W[3] + uVar7 + -0x164a245b +
        ((uVar2 >> 0xb | uVar2 * 0x200000) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
         (uVar2 >> 0x19 | uVar2 * 0x80));
    uVar6 = uVar6 + iVar10;
    uVar5 = ((uVar11 | uVar16) & uVar15 | uVar11 & uVar16) +
            ((uVar15 >> 0xd | uVar15 * 0x80000) ^
             (uVar15 >> 2 | uVar15 * 0x40000000) ^
             (uVar15 >> 0x16 | uVar15 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
         (uVar6 >> 0x19 | uVar6 * 0x80)) +
        uVar9 + W[4] + 0x3956c25b + ((uVar4 ^ uVar2) & uVar6 ^ uVar4);
    uVar11 = uVar11 + iVar10;
    uVar7 =
        ((uVar16 | uVar15) & uVar5 | uVar16 & uVar15) +
        ((uVar5 >> 0xd | uVar5 * 0x80000) ^ (uVar5 >> 2 | uVar5 * 0x40000000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        iVar10;
    iVar10 = ((uVar11 >> 0xb | uVar11 * 0x200000) ^
              (uVar11 >> 6 | uVar11 * 0x4000000) ^
              (uVar11 >> 0x19 | uVar11 * 0x80)) +
             ((uVar2 ^ uVar6) & uVar11 ^ uVar2) + uVar4 + W[5] + 0x59f111f1;
    uVar16 = uVar16 + iVar10;
    uVar14 =
        iVar10 +
        ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        ((uVar15 | uVar5) & uVar7 | uVar15 & uVar5);
    iVar10 = ((uVar16 >> 0xb | uVar16 * 0x200000) ^
              (uVar16 >> 6 | uVar16 * 0x4000000) ^
              (uVar16 >> 0x19 | uVar16 * 0x80)) +
             uVar2 + W[6] + 0x923f82a4 + ((uVar6 ^ uVar11) & uVar16 ^ uVar6);
    uVar4 = ((uVar5 | uVar7) & uVar14 | uVar5 & uVar7) +
            ((uVar14 >> 0xd | uVar14 * 0x80000) ^
             (uVar14 >> 2 | uVar14 * 0x40000000) ^
             (uVar14 >> 0x16 | uVar14 * 0x400)) +
            iVar10;
    uVar15 = uVar15 + iVar10;
    iVar10 = ((uVar15 >> 0xb | uVar15 * 0x200000) ^
              (uVar15 >> 6 | uVar15 * 0x4000000) ^
              (uVar15 >> 0x19 | uVar15 * 0x80)) +
             uVar6 + W[7] + 0xab1c5ed5 + ((uVar11 ^ uVar16) & uVar15 ^ uVar11);
    uVar5 = uVar5 + iVar10;
    uVar12 =
        ((uVar7 | uVar14) & uVar4 | uVar7 & uVar14) +
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar5 >> 0xb | uVar5 * 0x200000) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
         (uVar5 >> 0x19 | uVar5 * 0x80)) +
        uVar11 + W[8] + 0xd807aa98 + ((uVar16 ^ uVar15) & uVar5 ^ uVar16);
    uVar7 = uVar7 + iVar10;
    uVar9 = ((uVar14 | uVar4) & uVar12 | uVar14 & uVar4) +
            ((uVar12 >> 0xd | uVar12 * 0x80000) ^
             (uVar12 >> 2 | uVar12 * 0x40000000) ^
             (uVar12 >> 0x16 | uVar12 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
         (uVar7 >> 0x19 | uVar7 * 0x80)) +
        uVar16 + W[9] + 0x12835b01 + ((uVar15 ^ uVar5) & uVar7 ^ uVar15);
    uVar14 = uVar14 + iVar10;
    uVar6 =
        iVar10 +
        ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        ((uVar4 | uVar12) & uVar9 | uVar4 & uVar12);
    iVar10 =
        ((uVar5 ^ uVar7) & uVar14 ^ uVar5) + uVar15 + W[10] + 0x243185be +
        ((uVar14 >> 0xb | uVar14 * 0x200000) ^
         (uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0x19 | uVar14 * 0x80));
    uVar4 = uVar4 + iVar10;
    uVar2 =
        iVar10 +
        ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        ((uVar12 | uVar9) & uVar6 | uVar12 & uVar9);
    iVar10 =
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80)) +
        uVar5 + W[0xb] + 0x550c7dc3 + ((uVar7 ^ uVar14) & uVar4 ^ uVar7);
    uVar12 = uVar12 + iVar10;
    uVar15 =
        ((uVar9 | uVar6) & uVar2 | uVar9 & uVar6) +
        ((uVar2 >> 0xd | uVar2 * 0x80000) ^ (uVar2 >> 2 | uVar2 * 0x40000000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        iVar10;
    iVar10 = ((uVar12 >> 0xb | uVar12 * 0x200000) ^
              (uVar12 >> 6 | uVar12 * 0x4000000) ^
              (uVar12 >> 0x19 | uVar12 * 0x80)) +
             uVar7 + W[0xc] + 0x72be5d74 + ((uVar14 ^ uVar4) & uVar12 ^ uVar14);
    uVar9 = uVar9 + iVar10;
    uVar5 = ((uVar6 | uVar2) & uVar15 | uVar6 & uVar2) +
            ((uVar15 >> 0xd | uVar15 * 0x80000) ^
             (uVar15 >> 2 | uVar15 * 0x40000000) ^
             (uVar15 >> 0x16 | uVar15 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar4 ^ uVar12) & uVar9 ^ uVar4) + uVar14 + W[0xd] + 0x80deb1fe +
        ((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
         (uVar9 >> 0x19 | uVar9 * 0x80));
    uVar6 = uVar6 + iVar10;
    uVar14 =
        ((uVar2 | uVar15) & uVar5 | uVar2 & uVar15) +
        ((uVar5 >> 0xd | uVar5 * 0x80000) ^ (uVar5 >> 2 | uVar5 * 0x40000000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
         (uVar6 >> 0x19 | uVar6 * 0x80)) +
        ((uVar12 ^ uVar9) & uVar6 ^ uVar12) + uVar4 + W[0xe] + 0x9bdc06a7;
    uVar2 = uVar2 + iVar10;
    uVar7 = ((uVar15 | uVar5) & uVar14 | uVar15 & uVar5) +
            ((uVar14 >> 0xd | uVar14 * 0x80000) ^
             (uVar14 >> 2 | uVar14 * 0x40000000) ^
             (uVar14 >> 0x16 | uVar14 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar9 ^ uVar6) & uVar2 ^ uVar9) + uVar12 + W[0xf] + 0xc19bf174 +
        ((uVar2 >> 0xb | uVar2 * 0x200000) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
         (uVar2 >> 0x19 | uVar2 * 0x80));
    uVar15 = uVar15 + iVar10;
    uVar4 =
        ((uVar5 | uVar14) & uVar7 | uVar5 & uVar14) +
        ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        iVar10;
    iVar10 = ((uVar15 >> 0xb | uVar15 * 0x200000) ^
              (uVar15 >> 6 | uVar15 * 0x4000000) ^
              (uVar15 >> 0x19 | uVar15 * 0x80)) +
             ((uVar6 ^ uVar2) & uVar15 ^ uVar6) + uVar9 + W[0x10] + 0xe49b69c1;
    uVar5 = uVar5 + iVar10;
    uVar12 =
        ((uVar14 | uVar7) & uVar4 | uVar14 & uVar7) +
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar5 >> 0xb | uVar5 * 0x200000) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
         (uVar5 >> 0x19 | uVar5 * 0x80)) +
        ((uVar2 ^ uVar15) & uVar5 ^ uVar2) + uVar6 + W[0x11] + 0xefbe4786;
    uVar14 = uVar14 + iVar10;
    uVar11 = ((uVar7 | uVar4) & uVar12 | uVar7 & uVar4) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar10;
    iVar10 =
        ((uVar15 ^ uVar5) & uVar14 ^ uVar15) + uVar2 + W[0x12] + 0xfc19dc6 +
        ((uVar14 >> 0xb | uVar14 * 0x200000) ^
         (uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0x19 | uVar14 * 0x80));
    uVar7 = uVar7 + iVar10;
    uVar9 = ((uVar4 | uVar12) & uVar11 | uVar4 & uVar12) +
            ((uVar11 >> 0xd | uVar11 * 0x80000) ^
             (uVar11 >> 2 | uVar11 * 0x40000000) ^
             (uVar11 >> 0x16 | uVar11 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
         (uVar7 >> 0x19 | uVar7 * 0x80)) +
        ((uVar5 ^ uVar14) & uVar7 ^ uVar5) + uVar15 + W[0x13] + 0x240ca1cc;
    uVar4 = uVar4 + iVar10;
    uVar6 =
        ((uVar12 | uVar11) & uVar9 | uVar12 & uVar11) +
        ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80)) +
        ((uVar14 ^ uVar7) & uVar4 ^ uVar14) + uVar5 + W[0x14] + 0x2de92c6f;
    uVar12 = uVar12 + iVar10;
    uVar2 =
        ((uVar11 | uVar9) & uVar6 | uVar11 & uVar9) +
        ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar7 ^ uVar4) & uVar12 ^ uVar7) + uVar14 + W[0x15] + 0x4a7484aa +
        ((uVar12 >> 0xb | uVar12 * 0x200000) ^
         (uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0x19 | uVar12 * 0x80));
    uVar11 = uVar11 + iVar10;
    uVar15 =
        ((uVar9 | uVar6) & uVar2 | uVar9 & uVar6) +
        ((uVar2 >> 0xd | uVar2 * 0x80000) ^ (uVar2 >> 2 | uVar2 * 0x40000000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        iVar10;
    iVar10 = ((uVar11 >> 0xb | uVar11 * 0x200000) ^
              (uVar11 >> 6 | uVar11 * 0x4000000) ^
              (uVar11 >> 0x19 | uVar11 * 0x80)) +
             ((uVar4 ^ uVar12) & uVar11 ^ uVar4) + uVar7 + W[0x16] + 0x5cb0a9dc;
    uVar9 = uVar9 + iVar10;
    uVar5 = ((uVar6 | uVar2) & uVar15 | uVar6 & uVar2) +
            ((uVar15 >> 0xd | uVar15 * 0x80000) ^
             (uVar15 >> 2 | uVar15 * 0x40000000) ^
             (uVar15 >> 0x16 | uVar15 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
         (uVar9 >> 0x19 | uVar9 * 0x80)) +
        ((uVar12 ^ uVar11) & uVar9 ^ uVar12) + uVar4 + W[0x17] + 0x76f988da;
    uVar6 = uVar6 + iVar10;
    uVar14 =
        ((uVar2 | uVar15) & uVar5 | uVar2 & uVar15) +
        ((uVar5 >> 0xd | uVar5 * 0x80000) ^ (uVar5 >> 2 | uVar5 * 0x40000000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar11 ^ uVar9) & uVar6 ^ uVar11) + uVar12 + W[0x18] + 0x983e5152 +
        ((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
         (uVar6 >> 0x19 | uVar6 * 0x80));
    uVar2 = uVar2 + iVar10;
    uVar7 = ((uVar15 | uVar5) & uVar14 | uVar15 & uVar5) +
            ((uVar14 >> 0xd | uVar14 * 0x80000) ^
             (uVar14 >> 2 | uVar14 * 0x40000000) ^
             (uVar14 >> 0x16 | uVar14 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar2 >> 0xb | uVar2 * 0x200000) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
         (uVar2 >> 0x19 | uVar2 * 0x80)) +
        ((uVar9 ^ uVar6) & uVar2 ^ uVar9) + uVar11 + W[0x19] + 0xa831c66d;
    uVar15 = uVar15 + iVar10;
    uVar4 =
        ((uVar5 | uVar14) & uVar7 | uVar5 & uVar14) +
        ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        iVar10;
    iVar10 = ((uVar15 >> 0xb | uVar15 * 0x200000) ^
              (uVar15 >> 6 | uVar15 * 0x4000000) ^
              (uVar15 >> 0x19 | uVar15 * 0x80)) +
             ((uVar6 ^ uVar2) & uVar15 ^ uVar6) + uVar9 + W[0x1a] + 0xb00327c8;
    uVar5 = uVar5 + iVar10;
    uVar12 =
        ((uVar14 | uVar7) & uVar4 | uVar14 & uVar7) +
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar2 ^ uVar15) & uVar5 ^ uVar2) + uVar6 + W[0x1b] + 0xbf597fc7 +
        ((uVar5 >> 0xb | uVar5 * 0x200000) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
         (uVar5 >> 0x19 | uVar5 * 0x80));
    uVar14 = uVar14 + iVar10;
    uVar11 = ((uVar7 | uVar4) & uVar12 | uVar7 & uVar4) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar10;
    iVar10 = ((uVar14 >> 0xb | uVar14 * 0x200000) ^
              (uVar14 >> 6 | uVar14 * 0x4000000) ^
              (uVar14 >> 0x19 | uVar14 * 0x80)) +
             ((uVar15 ^ uVar5) & uVar14 ^ uVar15) + uVar2 + W[0x1c] +
             0xc6e00bf3;
    uVar7 = uVar7 + iVar10;
    uVar9 = ((uVar4 | uVar12) & uVar11 | uVar4 & uVar12) +
            ((uVar11 >> 0xd | uVar11 * 0x80000) ^
             (uVar11 >> 2 | uVar11 * 0x40000000) ^
             (uVar11 >> 0x16 | uVar11 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
         (uVar7 >> 0x19 | uVar7 * 0x80)) +
        ((uVar5 ^ uVar14) & uVar7 ^ uVar5) + uVar15 + W[0x1d] + 0xd5a79147;
    uVar4 = uVar4 + iVar10;
    uVar6 =
        ((uVar12 | uVar11) & uVar9 | uVar12 & uVar11) +
        ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar14 ^ uVar7) & uVar4 ^ uVar14) + uVar5 + W[0x1e] + 0x6ca6351 +
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80));
    uVar12 = uVar12 + iVar10;
    uVar2 =
        ((uVar11 | uVar9) & uVar6 | uVar11 & uVar9) +
        ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        iVar10;
    iVar10 = ((uVar12 >> 0xb | uVar12 * 0x200000) ^
              (uVar12 >> 6 | uVar12 * 0x4000000) ^
              (uVar12 >> 0x19 | uVar12 * 0x80)) +
             ((uVar7 ^ uVar4) & uVar12 ^ uVar7) + uVar14 + W[0x1f] + 0x14292967;
    uVar11 = uVar11 + iVar10;
    uVar15 =
        ((uVar9 | uVar6) & uVar2 | uVar9 & uVar6) +
        ((uVar2 >> 0xd | uVar2 * 0x80000) ^ (uVar2 >> 2 | uVar2 * 0x40000000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        iVar10;
    iVar10 = ((uVar11 >> 0xb | uVar11 * 0x200000) ^
              (uVar11 >> 6 | uVar11 * 0x4000000) ^
              (uVar11 >> 0x19 | uVar11 * 0x80)) +
             ((uVar4 ^ uVar12) & uVar11 ^ uVar4) + uVar7 + W[0x20] + 0x27b70a85;
    uVar9 = uVar9 + iVar10;
    uVar5 = ((uVar6 | uVar2) & uVar15 | uVar6 & uVar2) +
            ((uVar15 >> 0xd | uVar15 * 0x80000) ^
             (uVar15 >> 2 | uVar15 * 0x40000000) ^
             (uVar15 >> 0x16 | uVar15 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar12 ^ uVar11) & uVar9 ^ uVar12) + uVar4 + W[0x21] + 0x2e1b2138 +
        ((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
         (uVar9 >> 0x19 | uVar9 * 0x80));
    uVar6 = uVar6 + iVar10;
    uVar14 =
        ((uVar2 | uVar15) & uVar5 | uVar2 & uVar15) +
        ((uVar5 >> 0xd | uVar5 * 0x80000) ^ (uVar5 >> 2 | uVar5 * 0x40000000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
         (uVar6 >> 0x19 | uVar6 * 0x80)) +
        ((uVar11 ^ uVar9) & uVar6 ^ uVar11) + uVar12 + W[0x22] + 0x4d2c6dfc;
    uVar2 = uVar2 + iVar10;
    uVar7 = ((uVar15 | uVar5) & uVar14 | uVar15 & uVar5) +
            ((uVar14 >> 0xd | uVar14 * 0x80000) ^
             (uVar14 >> 2 | uVar14 * 0x40000000) ^
             (uVar14 >> 0x16 | uVar14 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar2 >> 0xb | uVar2 * 0x200000) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
         (uVar2 >> 0x19 | uVar2 * 0x80)) +
        ((uVar9 ^ uVar6) & uVar2 ^ uVar9) + uVar11 + W[0x23] + 0x53380d13;
    uVar15 = uVar15 + iVar10;
    uVar4 =
        ((uVar5 | uVar14) & uVar7 | uVar5 & uVar14) +
        ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar6 ^ uVar2) & uVar15 ^ uVar6) + uVar9 + W[0x24] + 0x650a7354 +
        ((uVar15 >> 0xb | uVar15 * 0x200000) ^
         (uVar15 >> 6 | uVar15 * 0x4000000) ^ (uVar15 >> 0x19 | uVar15 * 0x80));
    uVar5 = uVar5 + iVar10;
    uVar12 =
        ((uVar14 | uVar7) & uVar4 | uVar14 & uVar7) +
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar5 >> 0xb | uVar5 * 0x200000) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
         (uVar5 >> 0x19 | uVar5 * 0x80)) +
        ((uVar2 ^ uVar15) & uVar5 ^ uVar2) + uVar6 + W[0x25] + 0x766a0abb;
    uVar14 = uVar14 + iVar10;
    uVar11 = ((uVar7 | uVar4) & uVar12 | uVar7 & uVar4) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar10;
    iVar10 = ((uVar14 >> 0xb | uVar14 * 0x200000) ^
              (uVar14 >> 6 | uVar14 * 0x4000000) ^
              (uVar14 >> 0x19 | uVar14 * 0x80)) +
             ((uVar15 ^ uVar5) & uVar14 ^ uVar15) + uVar2 + W[0x26] +
             0x81c2c92e;
    uVar7 = uVar7 + iVar10;
    uVar9 = ((uVar4 | uVar12) & uVar11 | uVar4 & uVar12) +
            ((uVar11 >> 0xd | uVar11 * 0x80000) ^
             (uVar11 >> 2 | uVar11 * 0x40000000) ^
             (uVar11 >> 0x16 | uVar11 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar5 ^ uVar14) & uVar7 ^ uVar5) + uVar15 + W[0x27] + 0x92722c85 +
        ((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
         (uVar7 >> 0x19 | uVar7 * 0x80));
    uVar4 = uVar4 + iVar10;
    uVar6 =
        ((uVar12 | uVar11) & uVar9 | uVar12 & uVar11) +
        ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80)) +
        ((uVar14 ^ uVar7) & uVar4 ^ uVar14) + uVar5 + W[0x28] + 0xa2bfe8a1;
    uVar12 = uVar12 + iVar10;
    uVar2 =
        ((uVar11 | uVar9) & uVar6 | uVar11 & uVar9) +
        ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        iVar10;
    iVar10 = ((uVar12 >> 0xb | uVar12 * 0x200000) ^
              (uVar12 >> 6 | uVar12 * 0x4000000) ^
              (uVar12 >> 0x19 | uVar12 * 0x80)) +
             ((uVar7 ^ uVar4) & uVar12 ^ uVar7) + uVar14 + W[0x29] + 0xa81a664b;
    uVar11 = uVar11 + iVar10;
    uVar15 =
        ((uVar9 | uVar6) & uVar2 | uVar9 & uVar6) +
        ((uVar2 >> 0xd | uVar2 * 0x80000) ^ (uVar2 >> 2 | uVar2 * 0x40000000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar4 ^ uVar12) & uVar11 ^ uVar4) + uVar7 + W[0x2a] + 0xc24b8b70 +
        ((uVar11 >> 0xb | uVar11 * 0x200000) ^
         (uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0x19 | uVar11 * 0x80));
    uVar9 = uVar9 + iVar10;
    uVar5 = ((uVar6 | uVar2) & uVar15 | uVar6 & uVar2) +
            ((uVar15 >> 0xd | uVar15 * 0x80000) ^
             (uVar15 >> 2 | uVar15 * 0x40000000) ^
             (uVar15 >> 0x16 | uVar15 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
         (uVar9 >> 0x19 | uVar9 * 0x80)) +
        ((uVar12 ^ uVar11) & uVar9 ^ uVar12) + uVar4 + W[0x2b] + 0xc76c51a3;
    uVar6 = uVar6 + iVar10;
    uVar14 =
        ((uVar2 | uVar15) & uVar5 | uVar2 & uVar15) +
        ((uVar5 >> 0xd | uVar5 * 0x80000) ^ (uVar5 >> 2 | uVar5 * 0x40000000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
         (uVar6 >> 0x19 | uVar6 * 0x80)) +
        ((uVar11 ^ uVar9) & uVar6 ^ uVar11) + uVar12 + W[0x2c] + 0xd192e819;
    uVar2 = uVar2 + iVar10;
    uVar7 = ((uVar15 | uVar5) & uVar14 | uVar15 & uVar5) +
            ((uVar14 >> 0xd | uVar14 * 0x80000) ^
             (uVar14 >> 2 | uVar14 * 0x40000000) ^
             (uVar14 >> 0x16 | uVar14 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar9 ^ uVar6) & uVar2 ^ uVar9) + uVar11 + W[0x2d] + 0xd6990624 +
        ((uVar2 >> 0xb | uVar2 * 0x200000) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
         (uVar2 >> 0x19 | uVar2 * 0x80));
    uVar15 = uVar15 + iVar10;
    uVar4 =
        ((uVar5 | uVar14) & uVar7 | uVar5 & uVar14) +
        ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        iVar10;
    iVar10 = ((uVar15 >> 0xb | uVar15 * 0x200000) ^
              (uVar15 >> 6 | uVar15 * 0x4000000) ^
              (uVar15 >> 0x19 | uVar15 * 0x80)) +
             ((uVar6 ^ uVar2) & uVar15 ^ uVar6) + uVar9 + W[0x2e] + 0xf40e3585;
    uVar5 = uVar5 + iVar10;
    uVar12 =
        ((uVar14 | uVar7) & uVar4 | uVar14 & uVar7) +
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar5 >> 0xb | uVar5 * 0x200000) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
         (uVar5 >> 0x19 | uVar5 * 0x80)) +
        ((uVar2 ^ uVar15) & uVar5 ^ uVar2) + uVar6 + W[0x2f] + 0x106aa070;
    uVar14 = uVar14 + iVar10;
    uVar11 = ((uVar7 | uVar4) & uVar12 | uVar7 & uVar4) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar10;
    iVar10 =
        ((uVar15 ^ uVar5) & uVar14 ^ uVar15) + uVar2 + W[0x30] + 0x19a4c116 +
        ((uVar14 >> 0xb | uVar14 * 0x200000) ^
         (uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0x19 | uVar14 * 0x80));
    uVar7 = uVar7 + iVar10;
    uVar9 = ((uVar4 | uVar12) & uVar11 | uVar4 & uVar12) +
            ((uVar11 >> 0xd | uVar11 * 0x80000) ^
             (uVar11 >> 2 | uVar11 * 0x40000000) ^
             (uVar11 >> 0x16 | uVar11 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
         (uVar7 >> 0x19 | uVar7 * 0x80)) +
        ((uVar5 ^ uVar14) & uVar7 ^ uVar5) + uVar15 + W[0x31] + 0x1e376c08;
    uVar4 = uVar4 + iVar10;
    uVar6 =
        ((uVar12 | uVar11) & uVar9 | uVar12 & uVar11) +
        ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80)) +
        ((uVar14 ^ uVar7) & uVar4 ^ uVar14) + uVar5 + W[0x32] + 0x2748774c;
    uVar12 = uVar12 + iVar10;
    uVar2 =
        ((uVar11 | uVar9) & uVar6 | uVar11 & uVar9) +
        ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar7 ^ uVar4) & uVar12 ^ uVar7) + uVar14 + W[0x33] + 0x34b0bcb5 +
        ((uVar12 >> 0xb | uVar12 * 0x200000) ^
         (uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0x19 | uVar12 * 0x80));
    uVar11 = uVar11 + iVar10;
    uVar15 =
        ((uVar9 | uVar6) & uVar2 | uVar9 & uVar6) +
        ((uVar2 >> 0xd | uVar2 * 0x80000) ^ (uVar2 >> 2 | uVar2 * 0x40000000) ^
         (uVar2 >> 0x16 | uVar2 * 0x400)) +
        iVar10;
    iVar10 = ((uVar11 >> 0xb | uVar11 * 0x200000) ^
              (uVar11 >> 6 | uVar11 * 0x4000000) ^
              (uVar11 >> 0x19 | uVar11 * 0x80)) +
             ((uVar4 ^ uVar12) & uVar11 ^ uVar4) + uVar7 + W[0x34] + 0x391c0cb3;
    uVar9 = uVar9 + iVar10;
    uVar5 = ((uVar6 | uVar2) & uVar15 | uVar6 & uVar2) +
            ((uVar15 >> 0xd | uVar15 * 0x80000) ^
             (uVar15 >> 2 | uVar15 * 0x40000000) ^
             (uVar15 >> 0x16 | uVar15 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^
         (uVar9 >> 0x19 | uVar9 * 0x80)) +
        ((uVar12 ^ uVar11) & uVar9 ^ uVar12) + uVar4 + W[0x35] + 0x4ed8aa4a;
    uVar6 = uVar6 + iVar10;
    uVar14 =
        ((uVar2 | uVar15) & uVar5 | uVar2 & uVar15) +
        ((uVar5 >> 0xd | uVar5 * 0x80000) ^ (uVar5 >> 2 | uVar5 * 0x40000000) ^
         (uVar5 >> 0x16 | uVar5 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar11 ^ uVar9) & uVar6 ^ uVar11) + uVar12 + W[0x36] + 0x5b9cca4f +
        ((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^
         (uVar6 >> 0x19 | uVar6 * 0x80));
    uVar2 = uVar2 + iVar10;
    uVar7 = ((uVar15 | uVar5) & uVar14 | uVar15 & uVar5) +
            ((uVar14 >> 0xd | uVar14 * 0x80000) ^
             (uVar14 >> 2 | uVar14 * 0x40000000) ^
             (uVar14 >> 0x16 | uVar14 * 0x400)) +
            iVar10;
    iVar10 =
        ((uVar2 >> 0xb | uVar2 * 0x200000) ^ (uVar2 >> 6 | uVar2 * 0x4000000) ^
         (uVar2 >> 0x19 | uVar2 * 0x80)) +
        ((uVar9 ^ uVar6) & uVar2 ^ uVar9) + uVar11 + W[0x37] + 0x682e6ff3;
    uVar15 = uVar15 + iVar10;
    uVar4 =
        ((uVar5 | uVar14) & uVar7 | uVar5 & uVar14) +
        ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^
         (uVar7 >> 0x16 | uVar7 * 0x400)) +
        iVar10;
    iVar10 = ((uVar15 >> 0xb | uVar15 * 0x200000) ^
              (uVar15 >> 6 | uVar15 * 0x4000000) ^
              (uVar15 >> 0x19 | uVar15 * 0x80)) +
             uVar9 + W[0x38] + 0x748f82ee + ((uVar6 ^ uVar2) & uVar15 ^ uVar6);
    uVar5 = uVar5 + iVar10;
    uVar12 =
        ((uVar14 | uVar7) & uVar4 | uVar14 & uVar7) +
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar5 >> 0xb | uVar5 * 0x200000) ^ (uVar5 >> 6 | uVar5 * 0x4000000) ^
         (uVar5 >> 0x19 | uVar5 * 0x80)) +
        ((uVar2 ^ uVar15) & uVar5 ^ uVar2) + uVar6 + W[0x39] + 0x78a5636f;
    uVar14 = uVar14 + iVar10;
    uVar11 = ((uVar7 | uVar4) & uVar12 | uVar7 & uVar4) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar10;
    iVar10 = ((uVar14 >> 0xb | uVar14 * 0x200000) ^
              (uVar14 >> 6 | uVar14 * 0x4000000) ^
              (uVar14 >> 0x19 | uVar14 * 0x80)) +
             ((uVar15 ^ uVar5) & uVar14 ^ uVar15) + uVar2 + W[0x3a] +
             0x84c87814;
    uVar7 = uVar7 + iVar10;
    uVar9 = ((uVar4 | uVar12) & uVar11 | uVar4 & uVar12) +
            ((uVar11 >> 0xd | uVar11 * 0x80000) ^
             (uVar11 >> 2 | uVar11 * 0x40000000) ^
             (uVar11 >> 0x16 | uVar11 * 0x400)) +
            iVar10;
    iVar10 =
        uVar15 + W[0x3b] + 0x8cc70208 + ((uVar5 ^ uVar14) & uVar7 ^ uVar5) +
        ((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^
         (uVar7 >> 0x19 | uVar7 * 0x80));
    uVar4 = uVar4 + iVar10;
    uVar6 =
        ((uVar12 | uVar11) & uVar9 | uVar12 & uVar11) +
        ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^
         (uVar9 >> 0x16 | uVar9 * 0x400)) +
        iVar10;
    iVar10 =
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80)) +
        ((uVar14 ^ uVar7) & uVar4 ^ uVar14) + W[0x3c] + 0x90befffa + uVar5;
    S[7] = uVar12 + iVar10;
    S[3] =
        ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^
         (uVar6 >> 0x16 | uVar6 * 0x400)) +
        ((uVar11 | uVar9) & uVar6 | uVar11 & uVar9) + iVar10;
    iVar10 = uVar14 + W[0x3d] + 0xa4506ceb + ((uVar7 ^ uVar4) & S[7] ^ uVar7) +
             ((S[7] >> 0xb | S[7] * 0x200000) ^ (S[7] >> 6 | S[7] * 0x4000000) ^
              (S[7] >> 0x19 | S[7] * 0x80));
    S[6] = uVar11 + iVar10;
    S[2] = ((S[3] >> 0xd | S[3] * 0x80000) ^ (S[3] >> 2 | S[3] * 0x40000000) ^
            (S[3] >> 0x16 | S[3] * 0x400)) +
           ((uVar9 | uVar6) & S[3] | uVar9 & uVar6) + iVar10;
    iVar10 = ((S[6] >> 0xb | S[6] * 0x200000) ^ (S[6] >> 6 | S[6] * 0x4000000) ^
              (S[6] >> 0x19 | S[6] * 0x80)) +
             ((uVar4 ^ S[7]) & S[6] ^ uVar4) + uVar7 + W[0x3e] + 0xbef9a3f7;
    S[5] = uVar9 + iVar10;
    S[1] = iVar10 +
           ((S[2] >> 0xd | S[2] * 0x80000) ^ (S[2] >> 2 | S[2] * 0x40000000) ^
            (S[2] >> 0x16 | S[2] * 0x400)) +
           ((uVar6 | S[3]) & S[2] | uVar6 & S[3]);
    iVar10 = uVar4 + W[0x3f] + 0xc67178f2 + ((S[7] ^ S[6]) & S[5] ^ S[7]) +
             ((S[5] >> 0xb | S[5] * 0x200000) ^ (S[5] >> 6 | S[5] * 0x4000000) ^
              (S[5] >> 0x19 | S[5] * 0x80));
    uVar8 = ((S[1] >> 0xd | S[1] * 0x80000) ^ (S[1] >> 2 | S[1] * 0x40000000) ^
             (S[1] >> 0x16 | S[1] * 0x400)) +
            ((S[3] | S[2]) & S[1] | S[3] & S[2]) + iVar10;
    puVar3 = &c[-1].md_len;
    S[4] = uVar6 + iVar10;
    puVar13 = S;
    while (true) {
        puVar13 = puVar13 + 1;
        puVar3 = puVar3 + 1;
        *puVar3 = uVar8 + *puVar3;
        if (c->h + 7 == puVar3)
            break;
        uVar8 = *puVar13;
    }
    return;
}

/* WARNING: Unknown calling convention */

void benchfile_dspwork(work *work, uint32_t nonce)

{
    int iVar1;
    uint uVar2;
    int iVar3;
    char buf[1024];
    char tmp42[4096];

    iVar1 = 4;
    iVar3 = 0;
    do {
        uVar2 = nonce & 0xff;
        iVar1 = iVar1 + -1;
        nonce = nonce >> 8;
        iVar3 = uVar2 + iVar3 * 0x100;
    } while (iVar1 != 0);
    __bin2hex(buf, work->data, 0x80);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 3)) {
        return;
    }
    snprintf(tmp42, 0x1000, "BENCHFILE nonce %u=0x%08x for work=%s", iVar3,
             iVar3, buf);
    _applog(3, tmp42, false);
    return;
}

void suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits)

{
    uint uVar1;
    int iVar2;
    uint uVar3;
    undefined4 uVar4;
    bool bVar5;
    double dVar6;
    char suffix[2];

    uVar3 = (uint)(val >> 0x20);
    uVar1 = (uint)val;
    bVar5 = uVar3 < 0xde0b6b4;
    suffix[0] = '\0';
    suffix[1] = '\0';
    if (uVar3 == 0xde0b6b3) {
        bVar5 = uVar1 < 0xa7640000;
    }
    if (bVar5) {
        bVar5 = uVar3 < 0x38d7f;
        if (uVar3 == 0x38d7e) {
            bVar5 = uVar1 < 0xa4c68000;
        }
        if (!bVar5) {
            iVar2 = __aeabi_uldivmod(uVar1, uVar3, 0xd4a51000, 0xe8);
            suffix[0] = 'P';
            suffix[1] = '\0';
            goto LAB_000166c6;
        }
        bVar5 = uVar3 < 0xe9;
        if (uVar3 == 0xe8) {
            bVar5 = uVar1 < 0xd4a51000;
        }
        if (!bVar5) {
            iVar2 = __aeabi_uldivmod(uVar1, uVar3, 1000000000, 0);
            suffix[0] = 'T';
            suffix[1] = '\0';
            goto LAB_000166c6;
        }
        bVar5 = uVar3 == 0;
        if (uVar3 == 0) {
            bVar5 = uVar1 < 1000000000;
        }
        if (!bVar5) {
            iVar2 = __aeabi_uldivmod(uVar1, uVar3, 1000000, 0);
            suffix[0] = 'G';
            suffix[1] = '\0';
            goto LAB_000166c6;
        }
        bVar5 = uVar3 == 0;
        if (uVar3 == 0) {
            bVar5 = uVar1 < 1000000;
        }
        if (!bVar5) {
            iVar2 = __aeabi_uldivmod(uVar1, uVar3, 1000, 0);
            suffix[0] = 'M';
            suffix[1] = '\0';
            goto LAB_000166c6;
        }
        dVar6 = (double)(longlong)(int)uVar1;
        if (uVar3 == 0 && uVar1 < 1000) {
            if (sigdigits == 0) {
                snprintf(buf, bufsiz, "%d%s", uVar1, suffix);
                return;
            }
            goto LAB_00016730;
        }
        suffix[0] = 'K';
        suffix[1] = '\0';
    } else {
        iVar2 = __aeabi_uldivmod(uVar1, uVar3, 0xa4c68000, 0x38d7e);
        suffix[0] = 'E';
        suffix[1] = '\0';
    LAB_000166c6:
        dVar6 = (double)(longlong)iVar2;
    }
    dVar6 = dVar6 / 1000.0;
    if (sigdigits == 0) {
        snprintf(buf, bufsiz, "%.3g%s", suffix, dVar6, suffix);
        return;
    }
LAB_00016730:
    if (dVar6 <= 0.0) {
        uVar4 = 3;
    } else {
        dVar6 = log10(dVar6);
        dVar6 = floor(dVar6);
        uVar4 = (undefined4)(longlong)(3.0 - dVar6);
    }
    snprintf(buf, bufsiz, "%*.*f%s", sigdigits + 1, uVar4);
    return;
}

/* WARNING: Unknown calling convention */

char *set_logfile_path(char *arg)

{
    opt_set_charp(arg, &opt_logfile_path);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_logwork_asicnum(char *arg)

{
    opt_set_charp(arg, &opt_logwork_asicnum);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_logwork_path(char *arg)

{
    opt_set_charp(arg, &opt_logwork_path);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_logfile_openflag(char *arg)

{
    opt_set_charp(arg, &opt_logfile_openflag);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_version_path(char *arg)

{
    opt_set_charp(arg, &opt_version_path);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_default_config(char *arg)

{
    opt_set_charp(arg, &default_config);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_sharelog(char *arg)

{
    char *__fd;
    char *__format;
    bool bVar1;
    char *r;
    char tmp42[4096];

    r = "";
    __fd = (char *)strtol(arg, &r, 10);
    bVar1 = __fd == (char *)0x0;
    if (-1 < (int)__fd) {
        bVar1 = *r == '\0';
    }
    if (bVar1) {
        sharelog_file = (FILE *)fdopen((int)__fd, "a");
        if ((sharelog_file == (FILE *)0x0) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (2 < opt_log_level)))) {
            __format = "Failed to open fd %u for share log";
        LAB_00016958:
            sharelog_file = (FILE *)0x0;
            snprintf(tmp42, 0x1000, __format, __fd);
            _applog(3, tmp42, false);
            return (char *)0x0;
        }
    } else if ((*arg == '-') && (arg[1] == '\0')) {
        sharelog_file = stdout;
        if ((stdout == (FILE *)0x0) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (2 < opt_log_level)))) {
            builtin_strncpy(tmp42, "Standard output missing for share lo",
                            0x24);
            tmp42[0x24] = 'g';
            tmp42[0x25] = '\0';
            _applog(3, tmp42, false);
            return (char *)0x0;
        }
    } else {
        sharelog_file = (FILE *)fopen(arg, "a");
        if ((sharelog_file == (FILE *)0x0) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (2 < opt_log_level)))) {
            __format = "Failed to open %s for share log";
            __fd = arg;
            goto LAB_00016958;
        }
    }
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *json_escape(char *str)

{
    char cVar1;
    char *pcVar2;
    size_t sVar3;
    char *pcVar4;
    JE *pJVar5;
    char *pcVar6;

    sVar3 = strlen(str);
    pcVar4 = (char *)malloc(sVar3 * 2 + 1);
    pJVar5 = (JE *)malloc(8);
    cVar1 = *str;
    pJVar5->buf = pcVar4;
    pJVar5->next = jedata;
    jedata = pJVar5;
    pcVar2 = pcVar4;
    while (cVar1 != '\0') {
        pcVar6 = pcVar2 + 1;
        if (cVar1 == '\"' || cVar1 == '\\') {
            *pcVar2 = '\\';
            pcVar6 = pcVar2 + 2;
            pcVar2 = pcVar2 + 1;
        }
        *pcVar2 = cVar1;
        str = str + 1;
        pcVar2 = pcVar6;
        cVar1 = *str;
    }
    *pcVar2 = '\0';
    return pcVar4;
}

/* WARNING: Unknown calling convention */

void thread_reportout(thr_info *thr)

{
    time_t tVar1;
    cgpu_info *pcVar2;

    thr->getwork = true;
    cgtime(&thr->last);
    thr->cgpu->status = LIFE_WELL;
    pcVar2 = thr->cgpu;
    tVar1 = time((time_t *)0x0);
    pcVar2->device_last_well = tVar1;
    return;
}

/* WARNING: Unknown calling convention */

void thread_reportin(thr_info *thr)

{
    time_t tVar1;
    cgpu_info *pcVar2;

    thr->getwork = false;
    cgtime(&thr->last);
    thr->cgpu->status = LIFE_WELL;
    pcVar2 = thr->cgpu;
    tVar1 = time((time_t *)0x0);
    pcVar2->device_last_well = tVar1;
    return;
}

/* WARNING: Unknown calling convention */

void regen_hash(work *work)

{
    char *__ptr;
    uint *puVar1;
    uint *puVar2;
    uint uVar3;
    uchar hash1[32];
    uchar swap[80];
    char tmp42[4096];

    puVar1 = (uint *)&work[-1].field_0x7ac;
    puVar2 = (uint *)(hash1 + 0x1c);
    do {
        puVar1 = puVar1 + 1;
        uVar3 = *puVar1;
        puVar2 = puVar2 + 1;
        *puVar2 = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                  (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
    } while (puVar2 != (uint *)(swap + 0x4c));
    sha256(swap, 0x50, hash1);
    sha256(hash1, 0x20, work->hash);
    __ptr = bin2hex(work->hash, 0x20);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        free(__ptr);
        return;
    }
    snprintf(tmp42, 0x1000, "regen:%s", __ptr);
    _applog(5, tmp42, false);
    free(__ptr);
    return;
}

/* WARNING: Unknown calling convention */

void *submit_work_thread(void *userdata)

{
    pthread_t __th;

    __th = pthread_self();
    pthread_detach(__th);
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void *miner_thread(void *userdata)

{
    _Bool _Var1;
    time_t tVar2;
    device_drv *drv;
    device_drv *pdVar3;
    cgpu_info *cgpu;
    cgpu_info *dev;
    char threadname[16];
    char tmp42[4096];

    dev = *(cgpu_info **)((int)userdata + 0x24);
    /* WARNING: Load size is inaccurate */
    pdVar3 = dev->drv;
    snprintf(threadname, 0x10, "%d/Miner", *userdata);
    RenameThread(threadname);
    thread_reportout((thr_info *)userdata);
    _Var1 = (*pdVar3->thread_init)((thr_info *)userdata);
    if (_Var1) {
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            builtin_strncpy(tmp42, "Waiting on sem in miner thre", 0x1c);
            tmp42[0x1c] = 'a';
            tmp42[0x1d] = 'd';
            tmp42[0x1e] = '\0';
            _applog(7, tmp42, false);
        }
        _cgsem_wait((cgsem_t *)((int)userdata + 0x10), "cgminer.c",
                    "miner_thread", 0x23bb);
        tVar2 = time((time_t *)0x0);
        dev->last_device_valid_work = tVar2;
        (*pdVar3->hash_work)((thr_info *)userdata);
        (*pdVar3->thread_shutdown)((thr_info *)userdata);
        return (void *)0x0;
    }
    dev_error(dev, REASON_THREAD_FAIL_INIT);
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void *killall_thread(void *arg)

{
    pthread_t __th;

    __th = pthread_self();
    pthread_detach(__th);
    pthread_setcanceltype(1, (int *)0x0);
    sleep(5);
    /* WARNING: Subroutine does not return */
    exit(1);
}

void calc_diff(work *work, double known)

{
    int iVar1;
    pool *ppVar2;
    double dVar3;
    double dVar4;
    double dVar5;
    double dVar6;
    double dVar7;

    ppVar2 = work->pool;
    if (known == 0.0) {
        dVar4 = 65536.0;
        if (!opt_scrypt) {
            dVar4 = 2.695953529101131e+67;
        }
        dVar5 = (double)__floatundidf(*(undefined4 *)(work->target + 0x18),
                                      *(undefined4 *)(work->target + 0x1c));
        dVar7 = (double)__floatundidf(*(undefined4 *)(work->target + 0x10),
                                      *(undefined4 *)(work->target + 0x14));
        dVar3 = (double)__floatundidf(*(undefined4 *)(work->target + 8),
                                      *(undefined4 *)(work->target + 0xc));
        dVar6 = (double)__floatundidf(*(undefined4 *)work->target,
                                      *(undefined4 *)(work->target + 4));
        dVar6 = dVar6 + dVar5 * 6.277101735386681e+57 +
                dVar7 * 3.402823669209385e+38 + dVar3 * 1.8446744073709552e+19;
        if (dVar6 != 0.0) {
            dVar4 = dVar4 / dVar6;
        }
        work->work_difficulty = dVar4;
    } else {
        work->work_difficulty = known;
    }
    iVar1 = target_zero_cal(work->target);
    dVar7 = (double)(longlong)iVar1;
    work->work_difficulty = dVar7;
    (ppVar2->cgminer_pool_stats).last_diff = dVar7;
    suffix_string((longlong)iVar1, work->pool->diff, 8, 0);
    dVar4 = (ppVar2->cgminer_pool_stats).min_diff;
    if (dVar7 == dVar4) {
        (ppVar2->cgminer_pool_stats).min_diff_count =
            (ppVar2->cgminer_pool_stats).min_diff_count + 1;
    LAB_00016cee:
        dVar4 = (ppVar2->cgminer_pool_stats).max_diff;
    } else {
        if ((int)((uint)(dVar7 < dVar4) << 0x1f) < 0) {
            (ppVar2->cgminer_pool_stats).min_diff = dVar7;
            (ppVar2->cgminer_pool_stats).min_diff_count = 1;
        } else {
            if (dVar4 != 0.0)
                goto LAB_00016cee;
            (ppVar2->cgminer_pool_stats).min_diff = dVar7;
            (ppVar2->cgminer_pool_stats).min_diff_count = 1;
        }
        dVar4 = (ppVar2->cgminer_pool_stats).max_diff;
    }
    if (dVar7 != dVar4) {
        if (dVar4 < dVar7) {
            (ppVar2->cgminer_pool_stats).max_diff = dVar7;
            (ppVar2->cgminer_pool_stats).max_diff_count = 1;
        }
        return;
    }
    (ppVar2->cgminer_pool_stats).max_diff_count =
        (ppVar2->cgminer_pool_stats).max_diff_count + 1;
    return;
}

void applog_and_exit(char *fmt, ...)

{
    undefined4 in_r1;
    undefined4 in_r2;
    undefined4 in_r3;
    va_list ap;
    char *fmt_local;
    undefined4 uStack_c;
    undefined4 uStack_8;
    undefined4 uStack_4;

    uStack_c = in_r1;
    uStack_8 = in_r2;
    uStack_4 = in_r3;
    vsnprintf(exit_buf, 0x200, fmt, &uStack_c);
    _applog(3, exit_buf, true);
    /* WARNING: Subroutine does not return */
    exit(1);
}

/* WARNING: Unknown calling convention */

char *opt_verusage_and_exit(char *extra)

{
    char *pcVar1;

    printf("%s\nBuilt with bitmain_zcash mining support.\n", packagename);
    pcVar1 = opt_usage(opt_argv0, extra);
    printf("%s", pcVar1);
    fflush(stdout);
    /* WARNING: Subroutine does not return */
    exit(0);
}

void enable_pool(pool *pool)

{
    enabled_pools = enabled_pools + 1;
    pool->pool_no = 1;
    return;
}

/* WARNING: Unknown calling convention */

pool *priority_pool(int choice)

{
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (2 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "WTF No pool %d found!", choice);
        _applog(3, tmp42, false);
    }
    return pools[choice];
}

/* WARNING: Unknown calling convention */

pool *priority_pool(int choice)

{
    pool *ppVar1;
    pool **pppVar2;
    int iVar3;

    if (0 < total_pools) {
        ppVar1 = *pools;
        if (ppVar1->prio != choice) {
            iVar3 = 0;
            pppVar2 = pools;
            do {
                iVar3 = iVar3 + 1;
                if (iVar3 == total_pools)
                    goto LAB_00016f2e;
                pppVar2 = pppVar2 + 1;
                ppVar1 = *pppVar2;
            } while (ppVar1->prio != choice);
        }
        return ppVar1;
    }
LAB_00016f2e:
    ppVar1 = priority_pool(choice);
    return ppVar1;
}

_Bool new_nonce(thr_info *thr, uint32_t nonce)

{
    undefined1 uVar1;
    char tmp42[4096];

    if (thr[3].last.tv_sec != nonce) {
        thr[3].last.tv_sec = nonce;
        return true;
    }
    uVar1 = opt_debug;
    if ((opt_debug) && (((use_syslog || (opt_log_output)) ||
                         (uVar1 = opt_log_output, 6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s %d duplicate share detected as HW error",
                 *(undefined4 *)(thr->device_thread + 8),
                 *(undefined4 *)&thr->primary_thread);
        _applog(7, tmp42, false);
        return false;
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

char *set_sched_start(char *arg)

{
    int iVar1;
    char *pcVar2;

    iVar1 = sscanf(arg, "%d:%d", 0x71af4, 0x71af0);
    if (iVar1 == 2) {
        if ((0x17 < (uint)schedstart.tm.tm_hour) ||
            (0x3b < (uint)schedstart.tm.tm_min)) {
            return "Invalid time set.";
        }
        pcVar2 = (char *)0x0;
        schedstart.enable = true;
    } else {
        pcVar2 = "Invalid time set, should be HH:MM";
    }
    return pcVar2;
}

/* WARNING: Unknown calling convention */

_Bool should_run(void)

{
    _Bool _Var1;
    tm *ptVar2;
    int iVar3;
    int iVar4;
    undefined1 uVar5;
    time_t tmp_time;
    timeval tv;

    cgtime(&tv);
    tmp_time = tv.tv_sec;
    ptVar2 = localtime(&tmp_time);
    _Var1 = schedstart.enable;
    if (schedstart.enable == false) {
        if (schedstop.tm.tm_hour <= ptVar2->tm_hour) {
            return ptVar2->tm_hour == schedstop.tm.tm_hour &&
                   ptVar2->tm_min < schedstop.tm.tm_min;
        }
        uVar5 = 1;
    } else {
        iVar4 = ptVar2->tm_min;
        iVar3 = ptVar2->tm_hour;
        uVar5 = schedstop.enable;
        if (schedstop.enable == false) {
            if ((schedstart.tm.tm_hour <= iVar3) &&
                (schedstart.tm.tm_min <= iVar4 ||
                 schedstart.tm.tm_hour != iVar3)) {
                schedstart.enable = schedstop.enable;
                uVar5 = _Var1;
            }
        } else if ((schedstart.tm.tm_hour < schedstop.tm.tm_hour) ||
                   (schedstart.tm.tm_min < schedstop.tm.tm_min &&
                    schedstop.tm.tm_hour == schedstart.tm.tm_hour)) {
            if ((iVar3 < schedstop.tm.tm_hour) ||
                (uVar5 = iVar4 < schedstop.tm.tm_min &&
                         schedstop.tm.tm_hour == iVar3,
                 iVar4 < schedstop.tm.tm_min &&
                     schedstop.tm.tm_hour == iVar3)) {
                if (iVar3 < schedstart.tm.tm_hour) {
                    uVar5 = 0;
                } else {
                    uVar5 = schedstart.tm.tm_min <= iVar4 ||
                            schedstart.tm.tm_hour != iVar3;
                }
            }
        } else if (((iVar3 < schedstart.tm.tm_hour) ||
                    (iVar4 < schedstart.tm.tm_min &&
                     schedstart.tm.tm_hour == iVar3)) &&
                   (schedstop.tm.tm_hour <= iVar3)) {
            uVar5 =
                iVar4 < schedstop.tm.tm_min && schedstop.tm.tm_hour == iVar3;
        }
    }
    return (_Bool)uVar5;
}

/* WARNING: Unknown calling convention */

char *set_float_100_to_250(char *arg, float *i)

{
    int iVar1;
    char *pcVar2;

    pcVar2 = opt_set_floatval(arg, i);
    if (pcVar2 == (char *)0x0) {
        iVar1 = (uint)(*i < 100.0) << 0x1f;
        if (iVar1 < 0) {
            pcVar2 = "Value out of range";
        }
        if (-1 < iVar1) {
            if (250.0 < *i) {
                pcVar2 = "Value out of range";
            }
            return pcVar2;
        }
    }
    return pcVar2;
}

/* WARNING: Unknown calling convention */

char *set_float_125_to_500(char *arg, float *i)

{
    int iVar1;
    char *pcVar2;

    pcVar2 = opt_set_floatval(arg, i);
    if (pcVar2 == (char *)0x0) {
        iVar1 = (uint)(*i < 125.0) << 0x1f;
        if (iVar1 < 0) {
            pcVar2 = "Value out of range";
        }
        if (-1 < iVar1) {
            if (500.0 < *i) {
                pcVar2 = "Value out of range";
            }
            return pcVar2;
        }
    }
    return pcVar2;
}

void mt_disable(thr_info *mythr, int thr_id, device_drv *drv)

{
    _Bool _Var1;
    cgpu_info *pcVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (3 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "Thread %d being disabled", thr_id);
        _applog(4, tmp42, false);
    }
    _Var1 = opt_debug;
    pcVar2 = mythr->cgpu;
    *(undefined4 *)&pcVar2->rolling = 0;
    *(undefined4 *)((int)&pcVar2->rolling + 4) = 0;
    if ((_Var1 != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Waiting on sem in miner thre", 0x1c);
        tmp42[0x1c] = 'a';
        tmp42[0x1d] = 'd';
        tmp42[0x1e] = '\0';
        _applog(7, tmp42, false);
    }
    _cgsem_wait(&mythr->sem, "cgminer.c", "mt_disable", 0x2171);
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (3 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "Thread %d being re-enabled", thr_id);
        _applog(4, tmp42, false);
    }
    (*(code *)drv->drv_id)(mythr);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void set_lowprio(void)

{
    char tmp42[4096];

    builtin_strncpy(tmp42, "Unable to set thread to low priority", 0x24);
    tmp42[0x24] = '\0';
    _applog(7, tmp42, false);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void set_lowprio(void)

{
    int iVar1;

    iVar1 = nice(10);
    if (((iVar1 == 0) && (opt_debug != false)) &&
        ((use_syslog != false ||
          ((opt_log_output != false || (6 < opt_log_level)))))) {
        set_lowprio();
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void *api_thread(void *userdata)

{
    pthread_t __th;

    __th = pthread_self();
    pthread_detach(__th);
    pthread_setcanceltype(1, (int *)0x0);
    RenameThread("API");
    set_lowprio();
    api(api_thr_id);
    *(undefined4 *)((int)userdata + 0xc) = 0;
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_int_42_to_65(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (0x14 < *i - 0x2aU) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_22_to_55(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (0x21 < *i - 0x16U) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_32_to_63(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (0x1f < *i - 0x20U) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_0_to_4(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (4 < (uint)*i) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_0_to_200(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (200 < (uint)*i) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_0_to_255(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (0xff < (uint)*i) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_0_to_100(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (100 < (uint)*i) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_1_to_10(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (9 < *i - 1U) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_0_to_10(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (10 < (uint)*i) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_1_to_65535(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (0xfffe < *i - 1U) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_int_0_to_9999(char *arg, int *i)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (9999 < (uint)*i) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_rotate(char *arg, char *i)

{
    char *pcVar1;

    pool_strategy = POOL_ROTATE;
    pcVar1 = opt_set_intval(arg, &opt_rotate_period);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    pcVar1 = (char *)0x0;
    if (9999 < (uint)opt_rotate_period) {
        pcVar1 = "Value out of range";
    }
    return pcVar1;
}

void decay_time(double *f, double fadd, double fsecs, double interval)

{
    double dVar1;

    dVar1 = exp(fsecs / interval);
    dVar1 = 1.0 - 1.0 / dVar1;
    *f = (*f + (fadd / fsecs) * dVar1) / (dVar1 + 1.0);
    return;
}

void flush_queue(cgpu_info *cgpu)

{
    char tmp42[4096];

    builtin_strncpy(tmp42, "Discarded queued work it", 0x18);
    tmp42[0x18] = 'e';
    tmp42[0x19] = 'm';
    tmp42[0x1a] = '\0';
    _applog(7, tmp42, false);
    return;
}

_Bool submit_tested_work(thr_info *thr, work *work)

{
    char tmp42[4096];

    snprintf(tmp42, 0x1000, "%s %s %d: Share above target",
             "submit_tested_work", thr->cgpu->drv->name, thr->cgpu->device_id);
    _applog(7, tmp42, false);
    return false;
}

void noop_get_statline(void)

{
    return;
}

void noop_hash_work(void)

{
    return;
}

undefined4 noop_thread_prepare(void)

{
    return 1;
}

undefined4 noop_thread_init(void)

{
    return 1;
}

void noop_hw_error(void)

{
    return;
}

void noop_thread_shutdown(void)

{
    return;
}

void noop_thread_enable(void)

{
    return;
}

/* WARNING: Unknown calling convention */

pool *select_balanced(pool *cp)

{
    pool **pppVar1;
    pool *ppVar3;
    int iVar4;
    pool **pppVar2;

    iVar4 = cp->shares;
    if (0 < total_pools) {
        pppVar1 = pools;
        do {
            pppVar2 = pppVar1 + 1;
            ppVar3 = *pppVar1;
            if ((((ppVar3->idle == false) &&
                  (ppVar3->enabled == POOL_ENABLED)) &&
                 ((ppVar3->has_stratum == false ||
                   (ppVar3->stratum_active != false)))) &&
                (ppVar3->shares < iVar4)) {
                cp = ppVar3;
                iVar4 = ppVar3->shares;
            }
            pppVar1 = pppVar2;
        } while (pppVar2 != pools + total_pools);
        iVar4 = cp->shares;
    }
    cp->shares = iVar4 + 1;
    return cp;
}

/* WARNING: Unknown calling convention */

char *set_sched_stop(char *arg)

{
    int iVar1;
    char *pcVar2;

    iVar1 = sscanf(arg, "%d:%d", 0x71940, 0x7193c);
    if (iVar1 == 2) {
        if ((0x17 < (uint)schedstop.tm.tm_hour) ||
            (0x3b < (uint)schedstop.tm.tm_min)) {
            return "Invalid time set.";
        }
        pcVar2 = (char *)0x0;
        schedstop.enable = true;
    } else {
        pcVar2 = "Invalid time set, should be HH:MM";
    }
    return pcVar2;
}

/* WARNING: Unknown calling convention */

void scrypt_1024_1_1_256_sp(uint32_t *input, char *scratchpad, uint32_t *ostate)

{
    uint32_t uVar1;
    uint32_t uVar2;
    uint32_t uVar3;
    uint32_t uVar4;
    uint32_t uVar5;
    uint32_t uVar6;
    uint32_t uVar7;
    uint32_t uVar8;
    uint32_t uVar9;
    uint32_t uVar10;
    uint32_t uVar11;
    uint32_t uVar12;
    uint32_t uVar13;
    uint32_t uVar14;
    uint32_t uVar15;
    uint32_t uVar16;
    uint32_t uVar17;
    uint32_t uVar18;
    uint32_t uVar19;
    uint32_t uVar20;
    uint32_t uVar21;
    uint32_t uVar22;
    uint32_t uVar23;
    uint32_t uVar24;
    uint32_t uVar25;
    uint32_t uVar26;
    uint32_t uVar27;
    uint32_t uVar28;
    uint32_t uVar29;
    uint32_t uVar30;
    uint32_t uVar31;
    uint uVar32;
    undefined1 *puVar33;
    uint uVar34;
    uint uVar35;
    uint uVar36;
    uint uVar37;
    uint uVar38;
    uint *puVar39;
    uint uVar40;
    uint uVar41;
    uint uVar42;
    uint uVar43;
    uint uVar44;
    uint uVar45;
    uint uVar46;
    uint *puVar47;
    uint uVar48;
    uint *puVar49;
    uint uVar50;
    void *pvVar51;
    uint uVar52;
    uint uVar53;
    uint uVar54;
    uint uVar55;
    uint uVar56;
    uint uVar57;
    uint uVar58;
    uint uVar59;
    int iVar60;
    uint uVar61;
    uint uVar62;
    uint uVar63;
    uint uVar64;
    uint uVar65;
    uint uVar66;
    uint uVar67;
    uint *puVar68;
    uint uVar69;
    uint uVar70;
    uint uVar71;
    uint32_t uVar72;
    uint uVar73;
    uint uVar74;
    uint uVar75;
    uint uVar76;
    uint uVar77;
    uint uVar78;
    uint uVar79;
    uint32_t *puVar80;
    uint uVar81;
    uint uVar82;
    uint uVar83;
    uint uVar84;
    uint32_t *puVar85;
    uint uVar86;
    uint local_308;
    uint local_304;
    uint local_300;
    uint local_2fc;
    uint local_2f8;
    uint local_2f4;
    uint local_2f0;
    uint local_2ec;
    uint local_2e8;
    int local_2e4;
    void *local_2e0;
    int local_2dc;
    int local_2b4;
    uint32_t tstate[8];
    uint32_t ihash[8];
    uint32_t istate[8];
    uint32_t ostate_1[8];
    uint32_t pad[16];
    SHA256_CTX PShictx;
    SHA256_CTX PShoctx;
    uint32_t X[32];
    uint uStack_28;

    pvVar51 = (void *)((uint)(scratchpad + 0x3f) & 0xffffffc0);
    tstate[0] = 0x6a09e667;
    tstate[1] = 0xbb67ae85;
    puVar47 = tstate + 7;
    tstate[3] = 0xa54ff53a;
    tstate[4] = 0x510e527f;
    tstate[5] = 0x9b05688c;
    puVar68 = ostate_1 + 7;
    tstate[6] = 0x1f83d9ab;
    tstate[7] = 0x5be0cd19;
    tstate[2] = 0x3c6ef372;
    SHA256_Transform((SHA256_CTX *)tstate, (uchar *)input);
    pad[0] = input[0x10];
    pad[1] = input[0x11];
    pad[2] = input[0x12];
    pad[3] = input[0x13];
    pad[4] = 0x80;
    pad[5] = 0;
    pad[6] = 0;
    pad[7] = 0;
    pad[8] = 0;
    pad[9] = 0;
    pad[10] = 0;
    pad[0xb] = 0;
    pad[0xc] = 0;
    pad[0xd] = 0;
    pad[0xe] = 0;
    pad[0xf] = 0x80020000;
    SHA256_Transform((SHA256_CTX *)tstate, (uchar *)pad);
    PShictx.state[3] = 0xa54ff53a;
    PShictx.state[4] = 0x510e527f;
    PShictx.state[5] = 0x9b05688c;
    ihash[0] = tstate[0];
    ihash[1] = tstate[1];
    ihash[2] = tstate[2];
    ihash[3] = tstate[3];
    PShictx.state[0] = 0x6a09e667;
    PShictx.state[1] = 0xbb67ae85;
    PShictx.state[6] = 0x1f83d9ab;
    PShictx.state[7] = 0x5be0cd19;
    PShictx.state[2] = 0x3c6ef372;
    ihash[4] = tstate[4];
    ihash[5] = tstate[5];
    ihash[6] = tstate[6];
    ihash[7] = tstate[7];
    puVar49 = puVar47;
    puVar39 = puVar68;
    do {
        puVar49 = puVar49 + 1;
        puVar39 = puVar39 + 1;
        *puVar39 = *puVar49 ^ 0x36363636;
    } while (ihash + 7 != puVar49);
    pad[8] = 0x36363636;
    pad[9] = 0x36363636;
    pad[10] = 0x36363636;
    pad[0xb] = 0x36363636;
    pad[0xc] = 0x36363636;
    pad[0xd] = 0x36363636;
    pad[0xe] = 0x36363636;
    pad[0xf] = 0x36363636;
    SHA256_Transform((SHA256_CTX *)&PShictx, (uchar *)pad);
    SHA256_Transform((SHA256_CTX *)&PShictx, (uchar *)input);
    uVar48 = input[0x12];
    uVar52 = input[0x13];
    uVar32 = input[0x10];
    puVar85 = PShictx.buf + 4;
    uVar38 = input[0x11];
    PShictx.buf[3] = uVar52 << 0x18 | (uVar52 >> 8 & 0xff) << 0x10 |
                     (uVar52 >> 0x10 & 0xff) << 8 | uVar52 >> 0x18;
    PShictx.buf[0] = uVar32 << 0x18 | (uVar32 >> 8 & 0xff) << 0x10 |
                     (uVar32 >> 0x10 & 0xff) << 8 | uVar32 >> 0x18;
    PShictx.buf[1] = uVar38 << 0x18 | (uVar38 >> 8 & 0xff) << 0x10 |
                     (uVar38 >> 0x10 & 0xff) << 8 | uVar38 >> 0x18;
    PShictx.buf[2] = uVar48 << 0x18 | (uVar48 >> 8 & 0xff) << 0x10 |
                     (uVar48 >> 0x10 & 0xff) << 8 | uVar48 >> 0x18;
    uVar32 = 0x80000000;
    puVar33 = innerpad_13357;
    while (true) {
        puVar85 = puVar85 + 1;
        *puVar85 = uVar32;
        if (PShictx.buf + 0xf == puVar85)
            break;
        puVar33 = (undefined1 *)((int)puVar33 + 4);
        uVar32 = *(uint *)puVar33;
        uVar32 = uVar32 << 0x18 | (uVar32 >> 8 & 0xff) << 0x10 |
                 (uVar32 >> 0x10 & 0xff) << 8 | uVar32 >> 0x18;
    }
    PShoctx.state[0] = 0x6a09e667;
    PShoctx.state[1] = 0xbb67ae85;
    PShoctx.state[2] = 0x3c6ef372;
    PShoctx.state[3] = 0xa54ff53a;
    PShoctx.state[4] = 0x510e527f;
    PShoctx.state[5] = 0x9b05688c;
    PShoctx.state[6] = 0x1f83d9ab;
    PShoctx.state[7] = 0x5be0cd19;
    puVar39 = puVar68;
    do {
        puVar47 = puVar47 + 1;
        puVar39 = puVar39 + 1;
        *puVar39 = *puVar47 ^ 0x5c5c5c5c;
    } while (puVar49 != puVar47);
    pad[8] = 0x5c5c5c5c;
    pad[9] = 0x5c5c5c5c;
    pad[10] = 0x5c5c5c5c;
    uVar72 = 0;
    pad[0xb] = 0x5c5c5c5c;
    pad[0xc] = 0x5c5c5c5c;
    pad[0xd] = 0x5c5c5c5c;
    puVar47 = X;
    pad[0xe] = 0x5c5c5c5c;
    pad[0xf] = 0x5c5c5c5c;
    SHA256_Transform((SHA256_CTX *)&PShoctx, (uchar *)pad);
    PShoctx.buf[8] = 0x80000000;
    PShoctx.buf[9] = 0;
    PShoctx.buf[10] = 0;
    PShoctx.buf[0xb] = 0;
    PShoctx.buf[0xc] = 0;
    PShoctx.buf[0xd] = 0;
    PShoctx.buf[0xe] = 0;
    PShoctx.buf[0xf] = 0x300;
    do {
        uVar72 = uVar72 + 1;
        istate[0] = PShictx.state[0];
        istate[1] = PShictx.state[1];
        istate[2] = PShictx.state[2];
        istate[3] = PShictx.state[3];
        istate[4] = PShictx.state[4];
        istate[5] = PShictx.state[5];
        istate[6] = PShictx.state[6];
        istate[7] = PShictx.state[7];
        PShictx.buf[4] = uVar72;
        SHA256_Transform((SHA256_CTX *)istate, (uchar *)PShictx.buf);
        PShoctx.buf[0] = istate[0];
        PShoctx.buf[1] = istate[1];
        PShoctx.buf[2] = istate[2];
        PShoctx.buf[3] = istate[3];
        PShoctx.buf[4] = istate[4];
        PShoctx.buf[5] = istate[5];
        PShoctx.buf[6] = istate[6];
        PShoctx.buf[7] = istate[7];
        ostate_1[0] = PShoctx.state[0];
        ostate_1[1] = PShoctx.state[1];
        ostate_1[2] = PShoctx.state[2];
        ostate_1[3] = PShoctx.state[3];
        ostate_1[4] = PShoctx.state[4];
        ostate_1[5] = PShoctx.state[5];
        ostate_1[6] = PShoctx.state[6];
        ostate_1[7] = PShoctx.state[7];
        SHA256_Transform((SHA256_CTX *)ostate_1, (uchar *)PShoctx.buf);
        puVar49 = istate + 7;
        puVar39 = puVar47;
        do {
            puVar49 = puVar49 + 1;
            uVar32 = *puVar49;
            *puVar39 = uVar32 << 0x18 | (uVar32 >> 8 & 0xff) << 0x10 |
                       (uVar32 >> 0x10 & 0xff) << 8 | uVar32 >> 0x18;
            puVar39 = puVar39 + 1;
        } while (puVar49 != puVar68);
        puVar47 = puVar47 + 8;
    } while (uVar72 != 4);
    local_2e0 = pvVar51;
    do {
        uVar31 = X[0x1f];
        uVar30 = X[0x1e];
        uVar29 = X[0x1d];
        uVar28 = X[0x1c];
        uVar27 = X[0x1b];
        uVar26 = X[0x1a];
        uVar25 = X[0x19];
        uVar24 = X[0x18];
        uVar23 = X[0x17];
        uVar22 = X[0x16];
        uVar21 = X[0x15];
        uVar20 = X[0x14];
        uVar19 = X[0x13];
        uVar18 = X[0x12];
        uVar17 = X[0x11];
        uVar16 = X[0x10];
        uVar15 = X[0xf];
        uVar14 = X[0xe];
        uVar13 = X[0xd];
        uVar12 = X[0xc];
        uVar11 = X[0xb];
        uVar10 = X[10];
        uVar9 = X[9];
        uVar8 = X[8];
        uVar7 = X[7];
        uVar6 = X[6];
        uVar5 = X[5];
        uVar4 = X[4];
        uVar3 = X[3];
        uVar2 = X[2];
        uVar1 = X[1];
        uVar72 = X[0];
        memcpy(local_2e0, X, 0x80);
        uVar73 = uVar72 ^ uVar16;
        uVar61 = uVar1 ^ uVar17;
        uVar69 = uVar2 ^ uVar18;
        uVar58 = uVar3 ^ uVar19;
        uVar34 = uVar4 ^ uVar20;
        uVar53 = uVar5 ^ uVar21;
        uVar50 = uVar6 ^ uVar22;
        uVar40 = uVar7 ^ uVar23;
        uVar54 = uVar8 ^ uVar24;
        uVar41 = uVar9 ^ uVar25;
        uVar42 = uVar10 ^ uVar26;
        uVar43 = uVar11 ^ uVar27;
        uVar44 = uVar12 ^ uVar28;
        uVar45 = uVar13 ^ uVar29;
        uVar62 = uVar14 ^ uVar30;
        uVar63 = uVar15 ^ uVar31;
        local_2e4 = 4;
        uVar32 = uVar34;
        uVar38 = uVar54;
        uVar48 = uVar41;
        uVar52 = uVar62;
        uVar59 = uVar58;
        uVar84 = uVar44;
        uVar81 = uVar40;
        uVar82 = uVar69;
        uVar83 = uVar42;
        uVar55 = uVar45;
        uVar74 = uVar63;
        local_308 = uVar73;
        local_304 = uVar61;
        local_2f8 = uVar53;
        local_2f4 = uVar50;
        local_2f0 = uVar43;
        do {
            uVar32 = uVar32 ^
                     (local_308 + uVar84 >> 0x19 | (local_308 + uVar84) * 0x80);
            uVar52 = uVar52 ^
                     (local_2f4 + uVar83 >> 0x19 | (local_2f4 + uVar83) * 0x80);
            uVar59 = uVar59 ^
                     (uVar74 + local_2f0 >> 0x19 | (uVar74 + local_2f0) * 0x80);
            uVar48 = uVar48 ^ (local_304 + local_2f8 >> 0x19 |
                               (local_304 + local_2f8) * 0x80);
            uVar38 = uVar38 ^ (uVar32 + local_308 >> 0x17 |
                               (uVar32 + local_308) * 0x200);
            uVar82 =
                uVar82 ^ (uVar83 + uVar52 >> 0x17 | (uVar83 + uVar52) * 0x200);
            uVar81 =
                uVar81 ^ (uVar74 + uVar59 >> 0x17 | (uVar74 + uVar59) * 0x200);
            uVar55 = uVar55 ^ (local_2f8 + uVar48 >> 0x17 |
                               (local_2f8 + uVar48) * 0x200);
            uVar84 =
                uVar84 ^ (uVar32 + uVar38 >> 0x13 | (uVar32 + uVar38) * 0x2000);
            local_2f0 = local_2f0 ^
                        (uVar59 + uVar81 >> 0x13 | (uVar59 + uVar81) * 0x2000);
            local_304 = local_304 ^
                        (uVar48 + uVar55 >> 0x13 | (uVar48 + uVar55) * 0x2000);
            uVar64 = uVar81 + local_2f0;
            local_2f4 = local_2f4 ^
                        (uVar52 + uVar82 >> 0x13 | (uVar52 + uVar82) * 0x2000);
            uVar70 = uVar38 + uVar84;
            local_308 = local_308 ^ (uVar70 >> 0xe | uVar70 * 0x40000);
            uVar74 = uVar74 ^ (uVar64 >> 0xe | uVar64 * 0x40000);
            uVar64 = uVar82 + local_2f4;
            uVar83 = uVar83 ^ (uVar64 >> 0xe | uVar64 * 0x40000);
            uVar64 = uVar55 + local_304;
            local_2f8 = local_2f8 ^ (uVar64 >> 0xe | uVar64 * 0x40000);
            uVar84 =
                uVar84 ^ (uVar52 + uVar74 >> 0x19 | (uVar52 + uVar74) * 0x80);
            local_2f0 = local_2f0 ^
                        (uVar48 + uVar83 >> 0x19 | (uVar48 + uVar83) * 0x80);
            local_2f4 = local_2f4 ^ (uVar32 + local_2f8 >> 0x19 |
                                     (uVar32 + local_2f8) * 0x80);
            local_304 = local_304 ^ (uVar59 + local_308 >> 0x19 |
                                     (uVar59 + local_308) * 0x80);
            uVar81 = uVar81 ^ (local_2f8 + local_2f4 >> 0x17 |
                               (local_2f8 + local_2f4) * 0x200);
            uVar82 = uVar82 ^ (local_304 + local_308 >> 0x17 |
                               (local_304 + local_308) * 0x200);
            uVar55 =
                uVar55 ^ (uVar74 + uVar84 >> 0x17 | (uVar74 + uVar84) * 0x200);
            uVar38 = uVar38 ^ (uVar83 + local_2f0 >> 0x17 |
                               (uVar83 + local_2f0) * 0x200);
            uVar32 = uVar32 ^ (local_2f4 + uVar81 >> 0x13 |
                               (local_2f4 + uVar81) * 0x2000);
            uVar48 = uVar48 ^ (local_2f0 + uVar38 >> 0x13 |
                               (local_2f0 + uVar38) * 0x2000);
            uVar59 = uVar59 ^ (local_304 + uVar82 >> 0x13 |
                               (local_304 + uVar82) * 0x2000);
            uVar52 =
                uVar52 ^ (uVar84 + uVar55 >> 0x13 | (uVar84 + uVar55) * 0x2000);
            local_308 = local_308 ^
                        (uVar82 + uVar59 >> 0xe | (uVar82 + uVar59) * 0x40000);
            uVar83 =
                uVar83 ^ (uVar38 + uVar48 >> 0xe | (uVar38 + uVar48) * 0x40000);
            local_2f8 = local_2f8 ^
                        (uVar81 + uVar32 >> 0xe | (uVar81 + uVar32) * 0x40000);
            uVar74 =
                uVar74 ^ (uVar55 + uVar52 >> 0xe | (uVar55 + uVar52) * 0x40000);
            local_2e4 = local_2e4 + -1;
        } while (local_2e4 != 0);
        uVar58 = uVar58 + uVar59;
        uVar73 = uVar73 + local_308;
        uVar34 = uVar34 + uVar32;
        uVar61 = uVar61 + local_304;
        uVar69 = uVar69 + uVar82;
        uVar53 = uVar53 + local_2f8;
        uVar50 = uVar50 + local_2f4;
        uVar40 = uVar40 + uVar81;
        uVar54 = uVar54 + uVar38;
        uVar41 = uVar41 + uVar48;
        uVar42 = uVar42 + uVar83;
        uVar43 = uVar43 + local_2f0;
        uVar44 = uVar44 + uVar84;
        uVar45 = uVar45 + uVar55;
        uVar62 = uVar62 + uVar52;
        uVar63 = uVar63 + uVar74;
        uVar56 = uVar16 ^ uVar73;
        uVar65 = uVar17 ^ uVar61;
        uVar75 = uVar18 ^ uVar69;
        uVar66 = uVar19 ^ uVar58;
        uVar71 = uVar22 ^ uVar50;
        uVar76 = uVar20 ^ uVar34;
        uVar70 = uVar21 ^ uVar53;
        uVar35 = uVar23 ^ uVar40;
        uVar67 = uVar24 ^ uVar54;
        uVar77 = uVar25 ^ uVar41;
        uVar64 = uVar27 ^ uVar43;
        uVar78 = uVar26 ^ uVar42;
        uVar57 = uVar28 ^ uVar44;
        uVar36 = uVar29 ^ uVar45;
        uVar79 = uVar30 ^ uVar62;
        uVar37 = uVar31 ^ uVar63;
        local_2e4 = 4;
        uVar32 = uVar66;
        uVar38 = uVar76;
        uVar48 = uVar77;
        uVar52 = uVar78;
        uVar59 = uVar79;
        uVar84 = uVar57;
        uVar81 = uVar35;
        uVar82 = uVar75;
        uVar83 = uVar37;
        uVar55 = uVar67;
        uVar74 = uVar64;
        local_308 = uVar56;
        local_300 = uVar70;
        local_2f4 = uVar71;
        local_2f0 = uVar65;
        local_2e8 = uVar36;
        do {
            uVar38 = uVar38 ^
                     (local_308 + uVar84 >> 0x19 | (local_308 + uVar84) * 0x80);
            uVar48 = uVar48 ^ (local_300 + local_2f0 >> 0x19 |
                               (local_300 + local_2f0) * 0x80);
            uVar59 = uVar59 ^
                     (local_2f4 + uVar52 >> 0x19 | (local_2f4 + uVar52) * 0x80);
            uVar32 =
                uVar32 ^ (uVar83 + uVar74 >> 0x19 | (uVar83 + uVar74) * 0x80);
            uVar55 = uVar55 ^ (local_308 + uVar38 >> 0x17 |
                               (local_308 + uVar38) * 0x200);
            uVar81 =
                uVar81 ^ (uVar32 + uVar83 >> 0x17 | (uVar32 + uVar83) * 0x200);
            uVar82 =
                uVar82 ^ (uVar59 + uVar52 >> 0x17 | (uVar59 + uVar52) * 0x200);
            local_2e8 = local_2e8 ^ (local_300 + uVar48 >> 0x17 |
                                     (local_300 + uVar48) * 0x200);
            uVar84 =
                uVar84 ^ (uVar38 + uVar55 >> 0x13 | (uVar38 + uVar55) * 0x2000);
            uVar46 = uVar55 + uVar84;
            uVar74 =
                uVar74 ^ (uVar32 + uVar81 >> 0x13 | (uVar32 + uVar81) * 0x2000);
            uVar86 = uVar81 + uVar74;
            local_2f4 = local_2f4 ^
                        (uVar59 + uVar82 >> 0x13 | (uVar59 + uVar82) * 0x2000);
            uVar83 = uVar83 ^ (uVar86 >> 0xe | uVar86 * 0x40000);
            local_2f0 = local_2f0 ^ (uVar48 + local_2e8 >> 0x13 |
                                     (uVar48 + local_2e8) * 0x2000);
            local_308 = local_308 ^ (uVar46 >> 0xe | uVar46 * 0x40000);
            uVar46 = uVar82 + local_2f4;
            uVar52 = uVar52 ^ (uVar46 >> 0xe | uVar46 * 0x40000);
            uVar46 = local_2e8 + local_2f0;
            local_300 = local_300 ^ (uVar46 >> 0xe | uVar46 * 0x40000);
            uVar84 =
                uVar84 ^ (uVar59 + uVar83 >> 0x19 | (uVar59 + uVar83) * 0x80);
            uVar74 =
                uVar74 ^ (uVar48 + uVar52 >> 0x19 | (uVar48 + uVar52) * 0x80);
            local_2f4 = local_2f4 ^ (uVar38 + local_300 >> 0x19 |
                                     (uVar38 + local_300) * 0x80);
            local_2f0 = local_2f0 ^ (uVar32 + local_308 >> 0x19 |
                                     (uVar32 + local_308) * 0x80);
            uVar81 = uVar81 ^ (local_300 + local_2f4 >> 0x17 |
                               (local_300 + local_2f4) * 0x200);
            uVar82 = uVar82 ^ (local_2f0 + local_308 >> 0x17 |
                               (local_2f0 + local_308) * 0x200);
            local_2e8 = local_2e8 ^
                        (uVar83 + uVar84 >> 0x17 | (uVar83 + uVar84) * 0x200);
            uVar55 =
                uVar55 ^ (uVar52 + uVar74 >> 0x17 | (uVar52 + uVar74) * 0x200);
            uVar38 = uVar38 ^ (local_2f4 + uVar81 >> 0x13 |
                               (local_2f4 + uVar81) * 0x2000);
            uVar32 = uVar32 ^ (local_2f0 + uVar82 >> 0x13 |
                               (local_2f0 + uVar82) * 0x2000);
            uVar48 =
                uVar48 ^ (uVar74 + uVar55 >> 0x13 | (uVar74 + uVar55) * 0x2000);
            uVar59 = uVar59 ^ (uVar84 + local_2e8 >> 0x13 |
                               (uVar84 + local_2e8) * 0x2000);
            local_308 = local_308 ^
                        (uVar82 + uVar32 >> 0xe | (uVar82 + uVar32) * 0x40000);
            local_300 = local_300 ^
                        (uVar81 + uVar38 >> 0xe | (uVar81 + uVar38) * 0x40000);
            uVar83 = uVar83 ^ (local_2e8 + uVar59 >> 0xe |
                               (local_2e8 + uVar59) * 0x40000);
            uVar52 =
                uVar52 ^ (uVar55 + uVar48 >> 0xe | (uVar55 + uVar48) * 0x40000);
            local_2e4 = local_2e4 + -1;
        } while (local_2e4 != 0);
        uVar56 = uVar56 + local_308;
        uVar65 = uVar65 + local_2f0;
        uVar75 = uVar75 + uVar82;
        uVar66 = uVar66 + uVar32;
        uVar76 = uVar76 + uVar38;
        uVar70 = uVar70 + local_300;
        uVar71 = uVar71 + local_2f4;
        uVar35 = uVar35 + uVar81;
        uVar67 = uVar67 + uVar55;
        uVar77 = uVar77 + uVar48;
        uVar78 = uVar78 + uVar52;
        uVar64 = uVar64 + uVar74;
        uVar57 = uVar57 + uVar84;
        uVar36 = uVar36 + local_2e8;
        uVar79 = uVar79 + uVar59;
        uVar37 = uVar37 + uVar83;
        X[0] = uVar73;
        X[1] = uVar61;
        X[2] = uVar69;
        X[3] = uVar58;
        X[4] = uVar34;
        X[5] = uVar53;
        X[6] = uVar50;
        X[7] = uVar40;
        X[8] = uVar54;
        X[9] = uVar41;
        X[10] = uVar42;
        X[0xb] = uVar43;
        X[0xc] = uVar44;
        X[0xd] = uVar45;
        X[0xe] = uVar62;
        X[0xf] = uVar63;
        X[0x10] = uVar56;
        X[0x11] = uVar65;
        X[0x12] = uVar75;
        X[0x13] = uVar66;
        X[0x14] = uVar76;
        X[0x15] = uVar70;
        X[0x16] = uVar71;
        X[0x17] = uVar35;
        X[0x18] = uVar67;
        X[0x19] = uVar77;
        X[0x1a] = uVar78;
        X[0x1b] = uVar64;
        X[0x1c] = uVar57;
        X[0x1d] = uVar36;
        X[0x1e] = uVar79;
        X[0x1f] = uVar37;
        memcpy((void *)((int)local_2e0 + 0x80), X, 0x80);
        local_2e4 = 4;
        uVar32 = uVar34 ^ uVar76;
        uVar38 = uVar54 ^ uVar67;
        uVar48 = uVar41 ^ uVar77;
        uVar52 = uVar62 ^ uVar79;
        uVar59 = uVar58 ^ uVar66;
        uVar84 = uVar44 ^ uVar57;
        uVar81 = uVar40 ^ uVar35;
        uVar82 = uVar69 ^ uVar75;
        uVar83 = uVar42 ^ uVar78;
        uVar55 = uVar45 ^ uVar36;
        uVar74 = uVar63 ^ uVar37;
        local_308 = uVar73 ^ uVar56;
        local_304 = uVar61 ^ uVar65;
        local_2f8 = uVar53 ^ uVar70;
        local_2f4 = uVar50 ^ uVar71;
        local_2f0 = uVar43 ^ uVar64;
        do {
            uVar32 = uVar32 ^
                     (uVar84 + local_308 >> 0x19 | (uVar84 + local_308) * 0x80);
            uVar52 = uVar52 ^
                     (local_2f4 + uVar83 >> 0x19 | (local_2f4 + uVar83) * 0x80);
            uVar59 = uVar59 ^
                     (uVar74 + local_2f0 >> 0x19 | (uVar74 + local_2f0) * 0x80);
            uVar48 = uVar48 ^ (local_2f8 + local_304 >> 0x19 |
                               (local_2f8 + local_304) * 0x80);
            uVar38 = uVar38 ^ (local_308 + uVar32 >> 0x17 |
                               (local_308 + uVar32) * 0x200);
            uVar82 =
                uVar82 ^ (uVar52 + uVar83 >> 0x17 | (uVar52 + uVar83) * 0x200);
            uVar81 =
                uVar81 ^ (uVar74 + uVar59 >> 0x17 | (uVar74 + uVar59) * 0x200);
            uVar55 = uVar55 ^ (local_2f8 + uVar48 >> 0x17 |
                               (local_2f8 + uVar48) * 0x200);
            uVar84 =
                uVar84 ^ (uVar32 + uVar38 >> 0x13 | (uVar32 + uVar38) * 0x2000);
            local_2f0 = local_2f0 ^
                        (uVar59 + uVar81 >> 0x13 | (uVar59 + uVar81) * 0x2000);
            local_304 = local_304 ^
                        (uVar48 + uVar55 >> 0x13 | (uVar48 + uVar55) * 0x2000);
            uVar46 = uVar81 + local_2f0;
            local_2f4 = local_2f4 ^
                        (uVar52 + uVar82 >> 0x13 | (uVar52 + uVar82) * 0x2000);
            uVar86 = uVar38 + uVar84;
            local_308 = local_308 ^ (uVar86 >> 0xe | uVar86 * 0x40000);
            uVar74 = uVar74 ^ (uVar46 >> 0xe | uVar46 * 0x40000);
            uVar46 = uVar82 + local_2f4;
            uVar83 = uVar83 ^ (uVar46 >> 0xe | uVar46 * 0x40000);
            uVar46 = uVar55 + local_304;
            local_2f8 = local_2f8 ^ (uVar46 >> 0xe | uVar46 * 0x40000);
            uVar84 =
                uVar84 ^ (uVar52 + uVar74 >> 0x19 | (uVar52 + uVar74) * 0x80);
            local_2f0 = local_2f0 ^
                        (uVar48 + uVar83 >> 0x19 | (uVar48 + uVar83) * 0x80);
            local_2f4 = local_2f4 ^ (uVar32 + local_2f8 >> 0x19 |
                                     (uVar32 + local_2f8) * 0x80);
            local_304 = local_304 ^ (uVar59 + local_308 >> 0x19 |
                                     (uVar59 + local_308) * 0x80);
            uVar81 = uVar81 ^ (local_2f8 + local_2f4 >> 0x17 |
                               (local_2f8 + local_2f4) * 0x200);
            uVar82 = uVar82 ^ (local_304 + local_308 >> 0x17 |
                               (local_304 + local_308) * 0x200);
            uVar55 =
                uVar55 ^ (uVar74 + uVar84 >> 0x17 | (uVar74 + uVar84) * 0x200);
            uVar38 = uVar38 ^ (uVar83 + local_2f0 >> 0x17 |
                               (uVar83 + local_2f0) * 0x200);
            uVar32 = uVar32 ^ (local_2f4 + uVar81 >> 0x13 |
                               (local_2f4 + uVar81) * 0x2000);
            uVar48 = uVar48 ^ (local_2f0 + uVar38 >> 0x13 |
                               (local_2f0 + uVar38) * 0x2000);
            uVar59 = uVar59 ^ (local_304 + uVar82 >> 0x13 |
                               (local_304 + uVar82) * 0x2000);
            uVar52 =
                uVar52 ^ (uVar84 + uVar55 >> 0x13 | (uVar84 + uVar55) * 0x2000);
            local_308 = local_308 ^
                        (uVar82 + uVar59 >> 0xe | (uVar82 + uVar59) * 0x40000);
            uVar83 =
                uVar83 ^ (uVar38 + uVar48 >> 0xe | (uVar38 + uVar48) * 0x40000);
            local_2f8 = local_2f8 ^
                        (uVar81 + uVar32 >> 0xe | (uVar81 + uVar32) * 0x40000);
            uVar74 =
                uVar74 ^ (uVar55 + uVar52 >> 0xe | (uVar55 + uVar52) * 0x40000);
            local_2e4 = local_2e4 + -1;
        } while (local_2e4 != 0);
        X[0] = (uVar73 ^ uVar56) + local_308;
        X[1] = (uVar61 ^ uVar65) + local_304;
        X[2] = (uVar69 ^ uVar75) + uVar82;
        X[3] = (uVar58 ^ uVar66) + uVar59;
        X[4] = (uVar34 ^ uVar76) + uVar32;
        X[5] = (uVar53 ^ uVar70) + local_2f8;
        X[6] = (uVar50 ^ uVar71) + local_2f4;
        X[7] = (uVar40 ^ uVar35) + uVar81;
        X[8] = (uVar54 ^ uVar67) + uVar38;
        X[9] = (uVar41 ^ uVar77) + uVar48;
        X[10] = (uVar42 ^ uVar78) + uVar83;
        X[0xb] = (uVar43 ^ uVar64) + local_2f0;
        X[0xc] = (uVar44 ^ uVar57) + uVar84;
        X[0xd] = (uVar45 ^ uVar36) + uVar55;
        X[0xe] = (uVar62 ^ uVar79) + uVar52;
        X[0xf] = (uVar63 ^ uVar37) + uVar74;
        uVar65 = uVar65 ^ X[1];
        uVar56 = uVar56 ^ X[0];
        uVar75 = uVar75 ^ X[2];
        uVar66 = uVar66 ^ X[3];
        uVar76 = uVar76 ^ X[4];
        uVar70 = uVar70 ^ X[5];
        uVar71 = uVar71 ^ X[6];
        uVar35 = uVar35 ^ X[7];
        uVar67 = uVar67 ^ X[8];
        uVar77 = uVar77 ^ X[9];
        uVar64 = uVar64 ^ X[0xb];
        uVar78 = uVar78 ^ X[10];
        uVar57 = uVar57 ^ X[0xc];
        uVar36 = uVar36 ^ X[0xd];
        uVar79 = uVar79 ^ X[0xe];
        uVar37 = uVar37 ^ X[0xf];
        local_2e4 = 4;
        uVar32 = uVar66;
        uVar38 = uVar76;
        uVar48 = uVar77;
        uVar52 = uVar78;
        uVar59 = uVar79;
        uVar84 = uVar57;
        uVar81 = uVar35;
        uVar82 = uVar75;
        uVar83 = uVar37;
        uVar55 = uVar67;
        uVar74 = uVar64;
        local_308 = uVar56;
        local_300 = uVar70;
        local_2f4 = uVar65;
        local_2f0 = uVar71;
        local_2e8 = uVar36;
        do {
            uVar38 = uVar38 ^
                     (uVar84 + local_308 >> 0x19 | (uVar84 + local_308) * 0x80);
            uVar48 = uVar48 ^ (local_300 + local_2f4 >> 0x19 |
                               (local_300 + local_2f4) * 0x80);
            uVar59 = uVar59 ^
                     (uVar52 + local_2f0 >> 0x19 | (uVar52 + local_2f0) * 0x80);
            uVar32 =
                uVar32 ^ (uVar83 + uVar74 >> 0x19 | (uVar83 + uVar74) * 0x80);
            uVar55 = uVar55 ^ (uVar38 + local_308 >> 0x17 |
                               (uVar38 + local_308) * 0x200);
            uVar81 =
                uVar81 ^ (uVar83 + uVar32 >> 0x17 | (uVar83 + uVar32) * 0x200);
            uVar82 =
                uVar82 ^ (uVar52 + uVar59 >> 0x17 | (uVar52 + uVar59) * 0x200);
            local_2e8 = local_2e8 ^ (local_300 + uVar48 >> 0x17 |
                                     (local_300 + uVar48) * 0x200);
            uVar84 =
                uVar84 ^ (uVar38 + uVar55 >> 0x13 | (uVar38 + uVar55) * 0x2000);
            uVar34 = uVar55 + uVar84;
            uVar74 =
                uVar74 ^ (uVar32 + uVar81 >> 0x13 | (uVar32 + uVar81) * 0x2000);
            uVar40 = uVar81 + uVar74;
            local_2f0 = local_2f0 ^
                        (uVar59 + uVar82 >> 0x13 | (uVar59 + uVar82) * 0x2000);
            uVar83 = uVar83 ^ (uVar40 >> 0xe | uVar40 * 0x40000);
            local_2f4 = local_2f4 ^ (uVar48 + local_2e8 >> 0x13 |
                                     (uVar48 + local_2e8) * 0x2000);
            local_308 = local_308 ^ (uVar34 >> 0xe | uVar34 * 0x40000);
            uVar34 = uVar82 + local_2f0;
            uVar52 = uVar52 ^ (uVar34 >> 0xe | uVar34 * 0x40000);
            uVar34 = local_2e8 + local_2f4;
            local_300 = local_300 ^ (uVar34 >> 0xe | uVar34 * 0x40000);
            uVar84 =
                uVar84 ^ (uVar59 + uVar83 >> 0x19 | (uVar59 + uVar83) * 0x80);
            uVar74 =
                uVar74 ^ (uVar48 + uVar52 >> 0x19 | (uVar48 + uVar52) * 0x80);
            local_2f0 = local_2f0 ^ (uVar38 + local_300 >> 0x19 |
                                     (uVar38 + local_300) * 0x80);
            local_2f4 = local_2f4 ^ (uVar32 + local_308 >> 0x19 |
                                     (uVar32 + local_308) * 0x80);
            uVar81 = uVar81 ^ (local_300 + local_2f0 >> 0x17 |
                               (local_300 + local_2f0) * 0x200);
            uVar82 = uVar82 ^ (local_2f4 + local_308 >> 0x17 |
                               (local_2f4 + local_308) * 0x200);
            local_2e8 = local_2e8 ^
                        (uVar83 + uVar84 >> 0x17 | (uVar83 + uVar84) * 0x200);
            uVar55 =
                uVar55 ^ (uVar52 + uVar74 >> 0x17 | (uVar52 + uVar74) * 0x200);
            uVar38 = uVar38 ^ (local_2f0 + uVar81 >> 0x13 |
                               (local_2f0 + uVar81) * 0x2000);
            uVar32 = uVar32 ^ (local_2f4 + uVar82 >> 0x13 |
                               (local_2f4 + uVar82) * 0x2000);
            uVar48 =
                uVar48 ^ (uVar74 + uVar55 >> 0x13 | (uVar74 + uVar55) * 0x2000);
            uVar59 = uVar59 ^ (uVar84 + local_2e8 >> 0x13 |
                               (uVar84 + local_2e8) * 0x2000);
            local_308 = local_308 ^
                        (uVar82 + uVar32 >> 0xe | (uVar82 + uVar32) * 0x40000);
            local_300 = local_300 ^
                        (uVar81 + uVar38 >> 0xe | (uVar81 + uVar38) * 0x40000);
            uVar83 = uVar83 ^ (local_2e8 + uVar59 >> 0xe |
                               (local_2e8 + uVar59) * 0x40000);
            uVar52 =
                uVar52 ^ (uVar55 + uVar48 >> 0xe | (uVar55 + uVar48) * 0x40000);
            local_2e4 = local_2e4 + -1;
        } while (local_2e4 != 0);
        X[0x10] = uVar56 + local_308;
        X[0x12] = uVar75 + uVar82;
        X[0x13] = uVar66 + uVar32;
        X[0x14] = uVar76 + uVar38;
        X[0x17] = uVar35 + uVar81;
        X[0x18] = uVar67 + uVar55;
        X[0x19] = uVar77 + uVar48;
        X[0x1a] = uVar78 + uVar52;
        local_2e0 = (void *)((int)local_2e0 + 0x100);
        X[0x11] = uVar65 + local_2f4;
        X[0x15] = uVar70 + local_300;
        X[0x16] = uVar71 + local_2f0;
        X[0x1b] = uVar64 + uVar74;
        X[0x1c] = uVar57 + uVar84;
        X[0x1d] = uVar36 + local_2e8;
        X[0x1e] = uVar79 + uVar59;
        X[0x1f] = uVar37 + uVar83;
    } while (local_2e0 != (void *)((int)pvVar51 + 0x20000U));
    local_2b4 = 0x200;
    do {
        iVar60 = (int)pvVar51 + ((X[0x10] & 0x3ff) * 0x80 - (int)X);
        puVar47 = X;
        do {
            uVar32 = *(uint *)(iVar60 + (int)puVar47);
            puVar68 = puVar47 + 2;
            puVar47[1] = puVar47[1] ^ *(uint *)((int)puVar47 + iVar60 + 4);
            *puVar47 = *puVar47 ^ uVar32;
            puVar47 = puVar68;
        } while (&uStack_28 != puVar68);
        local_2e0 = (void *)0x4;
        uVar32 = X[0xd] ^ X[0x1d];
        uVar38 = X[0x1e] ^ X[0xe];
        uVar48 = X[0x14] ^ X[4];
        uVar52 = X[0xf] ^ X[0x1f];
        uVar59 = X[0xc] ^ X[0x1c];
        uVar84 = X[8] ^ X[0x18];
        uVar81 = X[7] ^ X[0x17];
        uVar82 = X[0x12] ^ X[2];
        uVar83 = X[9] ^ X[0x19];
        uVar55 = X[3] ^ X[0x13];
        local_308 = X[0xb] ^ X[0x1b];
        local_304 = X[0x11] ^ X[1];
        local_300 = X[0x10] ^ X[0];
        local_2fc = X[5] ^ X[0x15];
        local_2f8 = X[10] ^ X[0x1a];
        local_2f0 = X[6] ^ X[0x16];
        do {
            uVar48 = uVar48 ^
                     (local_300 + uVar59 >> 0x19 | (local_300 + uVar59) * 0x80);
            uVar38 = uVar38 ^ (local_2f0 + local_2f8 >> 0x19 |
                               (local_2f0 + local_2f8) * 0x80);
            uVar55 = uVar55 ^
                     (local_308 + uVar52 >> 0x19 | (local_308 + uVar52) * 0x80);
            uVar83 = uVar83 ^ (local_304 + local_2fc >> 0x19 |
                               (local_304 + local_2fc) * 0x80);
            uVar81 =
                uVar81 ^ (uVar55 + uVar52 >> 0x17 | (uVar55 + uVar52) * 0x200);
            uVar84 = uVar84 ^ (uVar48 + local_300 >> 0x17 |
                               (uVar48 + local_300) * 0x200);
            uVar82 = uVar82 ^ (uVar38 + local_2f8 >> 0x17 |
                               (uVar38 + local_2f8) * 0x200);
            uVar32 = uVar32 ^ (uVar83 + local_2fc >> 0x17 |
                               (uVar83 + local_2fc) * 0x200);
            uVar59 =
                uVar59 ^ (uVar48 + uVar84 >> 0x13 | (uVar48 + uVar84) * 0x2000);
            uVar74 = uVar84 + uVar59;
            local_300 = local_300 ^ (uVar74 >> 0xe | uVar74 * 0x40000);
            local_308 = local_308 ^
                        (uVar55 + uVar81 >> 0x13 | (uVar55 + uVar81) * 0x2000);
            local_2f0 = local_2f0 ^
                        (uVar38 + uVar82 >> 0x13 | (uVar38 + uVar82) * 0x2000);
            uVar34 = uVar82 + local_2f0;
            local_304 = local_304 ^
                        (uVar83 + uVar32 >> 0x13 | (uVar83 + uVar32) * 0x2000);
            uVar74 = uVar81 + local_308;
            uVar52 = uVar52 ^ (uVar74 >> 0xe | uVar74 * 0x40000);
            uVar74 = uVar32 + local_304;
            local_2f8 = local_2f8 ^ (uVar34 >> 0xe | uVar34 * 0x40000);
            uVar59 =
                uVar59 ^ (uVar38 + uVar52 >> 0x19 | (uVar38 + uVar52) * 0x80);
            local_2fc = local_2fc ^ (uVar74 >> 0xe | uVar74 * 0x40000);
            local_308 = local_308 ^ (uVar83 + local_2f8 >> 0x19 |
                                     (uVar83 + local_2f8) * 0x80);
            local_2f0 = local_2f0 ^ (uVar48 + local_2fc >> 0x19 |
                                     (uVar48 + local_2fc) * 0x80);
            local_304 = local_304 ^ (uVar55 + local_300 >> 0x19 |
                                     (uVar55 + local_300) * 0x80);
            uVar81 = uVar81 ^ (local_2fc + local_2f0 >> 0x17 |
                               (local_2fc + local_2f0) * 0x200);
            uVar82 = uVar82 ^ (local_300 + local_304 >> 0x17 |
                               (local_300 + local_304) * 0x200);
            uVar32 =
                uVar32 ^ (uVar52 + uVar59 >> 0x17 | (uVar52 + uVar59) * 0x200);
            uVar84 = uVar84 ^ (local_2f8 + local_308 >> 0x17 |
                               (local_2f8 + local_308) * 0x200);
            uVar55 = uVar55 ^ (local_304 + uVar82 >> 0x13 |
                               (local_304 + uVar82) * 0x2000);
            uVar48 = uVar48 ^ (local_2f0 + uVar81 >> 0x13 |
                               (local_2f0 + uVar81) * 0x2000);
            local_300 = local_300 ^
                        (uVar82 + uVar55 >> 0xe | (uVar82 + uVar55) * 0x40000);
            uVar83 = uVar83 ^ (local_308 + uVar84 >> 0x13 |
                               (local_308 + uVar84) * 0x2000);
            uVar38 =
                uVar38 ^ (uVar59 + uVar32 >> 0x13 | (uVar59 + uVar32) * 0x2000);
            local_2fc = local_2fc ^
                        (uVar81 + uVar48 >> 0xe | (uVar81 + uVar48) * 0x40000);
            local_2f8 = local_2f8 ^
                        (uVar84 + uVar83 >> 0xe | (uVar84 + uVar83) * 0x40000);
            uVar52 =
                uVar52 ^ (uVar32 + uVar38 >> 0xe | (uVar32 + uVar38) * 0x40000);
            local_2e0 = (void *)((int)local_2e0 + -1);
        } while (local_2e0 != (void *)0x0);
        X[0] = (X[0x10] ^ X[0]) + local_300;
        X[1] = (X[0x11] ^ X[1]) + local_304;
        X[2] = (X[0x12] ^ X[2]) + uVar82;
        X[3] = (X[3] ^ X[0x13]) + uVar55;
        X[4] = (X[0x14] ^ X[4]) + uVar48;
        X[5] = (X[5] ^ X[0x15]) + local_2fc;
        X[6] = (X[6] ^ X[0x16]) + local_2f0;
        X[7] = (X[7] ^ X[0x17]) + uVar81;
        X[8] = (X[8] ^ X[0x18]) + uVar84;
        X[9] = (X[9] ^ X[0x19]) + uVar83;
        X[10] = (X[10] ^ X[0x1a]) + local_2f8;
        X[0xb] = (X[0xb] ^ X[0x1b]) + local_308;
        X[0xc] = (X[0xc] ^ X[0x1c]) + uVar59;
        X[0xd] = (X[0xd] ^ X[0x1d]) + uVar32;
        X[0xe] = (X[0x1e] ^ X[0xe]) + uVar38;
        X[0xf] = (X[0xf] ^ X[0x1f]) + uVar52;
        uVar62 = X[0x10] ^ X[0];
        uVar45 = X[0x11] ^ X[1];
        uVar50 = X[0x12] ^ X[2];
        uVar63 = X[0x15] ^ X[5];
        uVar53 = X[0x13] ^ X[3];
        uVar73 = X[0x16] ^ X[6];
        uVar61 = X[0x14] ^ X[4];
        uVar40 = X[0x17] ^ X[7];
        uVar41 = X[0x18] ^ X[8];
        uVar54 = X[0x19] ^ X[9];
        uVar58 = X[0x1a] ^ X[10];
        uVar42 = X[0x1b] ^ X[0xb];
        uVar43 = X[0x1c] ^ X[0xc];
        uVar44 = X[0x1d] ^ X[0xd];
        uVar74 = X[0x1e] ^ X[0xe];
        uVar34 = X[0x1f] ^ X[0xf];
        local_2e4 = 4;
        uVar32 = uVar61;
        uVar38 = uVar54;
        uVar48 = uVar34;
        uVar52 = uVar43;
        uVar59 = uVar74;
        uVar84 = uVar41;
        uVar81 = uVar40;
        uVar82 = uVar50;
        uVar83 = uVar53;
        uVar55 = uVar44;
        local_304 = uVar42;
        local_300 = uVar45;
        local_2fc = uVar63;
        local_2f8 = uVar58;
        local_2f4 = uVar62;
        local_2ec = uVar73;
        do {
            uVar32 = uVar32 ^
                     (uVar52 + local_2f4 >> 0x19 | (uVar52 + local_2f4) * 0x80);
            uVar59 = uVar59 ^ (local_2ec + local_2f8 >> 0x19 |
                               (local_2ec + local_2f8) * 0x80);
            uVar83 = uVar83 ^
                     (local_304 + uVar48 >> 0x19 | (local_304 + uVar48) * 0x80);
            uVar38 = uVar38 ^ (local_300 + local_2fc >> 0x19 |
                               (local_300 + local_2fc) * 0x80);
            uVar81 =
                uVar81 ^ (uVar48 + uVar83 >> 0x17 | (uVar48 + uVar83) * 0x200);
            uVar84 = uVar84 ^ (local_2f4 + uVar32 >> 0x17 |
                               (local_2f4 + uVar32) * 0x200);
            uVar82 = uVar82 ^ (local_2f8 + uVar59 >> 0x17 |
                               (local_2f8 + uVar59) * 0x200);
            uVar52 =
                uVar52 ^ (uVar32 + uVar84 >> 0x13 | (uVar32 + uVar84) * 0x2000);
            uVar55 = uVar55 ^ (local_2fc + uVar38 >> 0x17 |
                               (local_2fc + uVar38) * 0x200);
            local_304 = local_304 ^
                        (uVar83 + uVar81 >> 0x13 | (uVar83 + uVar81) * 0x2000);
            uVar69 = uVar81 + local_304;
            uVar48 = uVar48 ^ (uVar69 >> 0xe | uVar69 * 0x40000);
            local_2ec = local_2ec ^
                        (uVar59 + uVar82 >> 0x13 | (uVar59 + uVar82) * 0x2000);
            uVar69 = uVar84 + uVar52;
            uVar52 =
                uVar52 ^ (uVar59 + uVar48 >> 0x19 | (uVar59 + uVar48) * 0x80);
            local_300 = local_300 ^
                        (uVar38 + uVar55 >> 0x13 | (uVar38 + uVar55) * 0x2000);
            local_2f4 = local_2f4 ^ (uVar69 >> 0xe | uVar69 * 0x40000);
            uVar69 = uVar82 + local_2ec;
            local_2f8 = local_2f8 ^ (uVar69 >> 0xe | uVar69 * 0x40000);
            uVar69 = uVar55 + local_300;
            local_2fc = local_2fc ^ (uVar69 >> 0xe | uVar69 * 0x40000);
            local_304 = local_304 ^ (uVar38 + local_2f8 >> 0x19 |
                                     (uVar38 + local_2f8) * 0x80);
            local_2ec = local_2ec ^ (uVar32 + local_2fc >> 0x19 |
                                     (uVar32 + local_2fc) * 0x80);
            local_300 = local_300 ^ (uVar83 + local_2f4 >> 0x19 |
                                     (uVar83 + local_2f4) * 0x80);
            uVar81 = uVar81 ^ (local_2fc + local_2ec >> 0x17 |
                               (local_2fc + local_2ec) * 0x200);
            uVar82 = uVar82 ^ (local_2f4 + local_300 >> 0x17 |
                               (local_2f4 + local_300) * 0x200);
            uVar84 = uVar84 ^ (local_2f8 + local_304 >> 0x17 |
                               (local_2f8 + local_304) * 0x200);
            uVar55 =
                uVar55 ^ (uVar48 + uVar52 >> 0x17 | (uVar48 + uVar52) * 0x200);
            uVar83 = uVar83 ^ (local_300 + uVar82 >> 0x13 |
                               (local_300 + uVar82) * 0x2000);
            uVar32 = uVar32 ^ (local_2ec + uVar81 >> 0x13 |
                               (local_2ec + uVar81) * 0x2000);
            local_2f4 = local_2f4 ^
                        (uVar82 + uVar83 >> 0xe | (uVar82 + uVar83) * 0x40000);
            uVar38 = uVar38 ^ (local_304 + uVar84 >> 0x13 |
                               (local_304 + uVar84) * 0x2000);
            uVar59 =
                uVar59 ^ (uVar52 + uVar55 >> 0x13 | (uVar52 + uVar55) * 0x2000);
            local_2fc = local_2fc ^
                        (uVar81 + uVar32 >> 0xe | (uVar81 + uVar32) * 0x40000);
            local_2f8 = local_2f8 ^
                        (uVar84 + uVar38 >> 0xe | (uVar84 + uVar38) * 0x40000);
            uVar48 =
                uVar48 ^ (uVar55 + uVar59 >> 0xe | (uVar55 + uVar59) * 0x40000);
            local_2e4 = local_2e4 + -1;
        } while (local_2e4 != 0);
        X[0x11] = uVar45 + local_300;
        X[0x10] = uVar62 + local_2f4;
        iVar60 = (int)pvVar51 + ((X[0x10] & 0x3ff) * 0x80 - (int)X);
        X[0x15] = uVar63 + local_2fc;
        X[0x19] = uVar54 + uVar38;
        X[0x1a] = uVar58 + local_2f8;
        X[0x1c] = uVar43 + uVar52;
        X[0x12] = uVar50 + uVar82;
        X[0x13] = uVar53 + uVar83;
        X[0x14] = uVar61 + uVar32;
        X[0x16] = uVar73 + local_2ec;
        X[0x17] = uVar40 + uVar81;
        X[0x18] = uVar41 + uVar84;
        X[0x1b] = uVar42 + local_304;
        X[0x1d] = uVar44 + uVar55;
        X[0x1e] = uVar74 + uVar59;
        X[0x1f] = uVar34 + uVar48;
        puVar47 = X;
        do {
            uVar32 = *(uint *)(iVar60 + (int)puVar47);
            puVar49 = puVar47 + 2;
            puVar47[1] = puVar47[1] ^ *(uint *)((int)puVar47 + iVar60 + 4);
            *puVar47 = *puVar47 ^ uVar32;
            puVar47 = puVar49;
        } while (puVar49 != puVar68);
        local_2dc = 4;
        uVar32 = X[0x19] ^ X[9];
        uVar38 = X[0xd] ^ X[0x1d];
        uVar48 = X[0xe] ^ X[0x1e];
        uVar52 = X[0xf] ^ X[0x1f];
        uVar59 = X[3] ^ X[0x13];
        uVar84 = X[7] ^ X[0x17];
        uVar81 = X[2] ^ X[0x12];
        uVar82 = X[0xb] ^ X[0x1b];
        uVar83 = X[8] ^ X[0x18];
        uVar55 = X[4] ^ X[0x14];
        local_308 = X[0x11] ^ X[1];
        local_304 = X[0x10] ^ X[0];
        local_300 = X[5] ^ X[0x15];
        local_2fc = X[10] ^ X[0x1a];
        local_2f8 = X[6] ^ X[0x16];
        local_2f4 = X[0xc] ^ X[0x1c];
        do {
            uVar48 = uVar48 ^ (local_2f8 + local_2fc >> 0x19 |
                               (local_2f8 + local_2fc) * 0x80);
            uVar55 = uVar55 ^ (local_304 + local_2f4 >> 0x19 |
                               (local_304 + local_2f4) * 0x80);
            uVar59 =
                uVar59 ^ (uVar82 + uVar52 >> 0x19 | (uVar82 + uVar52) * 0x80);
            uVar32 = uVar32 ^ (local_308 + local_300 >> 0x19 |
                               (local_308 + local_300) * 0x80);
            uVar84 =
                uVar84 ^ (uVar59 + uVar52 >> 0x17 | (uVar59 + uVar52) * 0x200);
            uVar83 = uVar83 ^ (uVar55 + local_304 >> 0x17 |
                               (uVar55 + local_304) * 0x200);
            uVar38 = uVar38 ^ (uVar32 + local_300 >> 0x17 |
                               (uVar32 + local_300) * 0x200);
            uVar82 =
                uVar82 ^ (uVar59 + uVar84 >> 0x13 | (uVar59 + uVar84) * 0x2000);
            uVar81 = uVar81 ^ (uVar48 + local_2fc >> 0x17 |
                               (uVar48 + local_2fc) * 0x200);
            local_2f4 = local_2f4 ^
                        (uVar55 + uVar83 >> 0x13 | (uVar55 + uVar83) * 0x2000);
            local_2f8 = local_2f8 ^
                        (uVar48 + uVar81 >> 0x13 | (uVar48 + uVar81) * 0x2000);
            uVar74 = uVar84 + uVar82;
            uVar34 = uVar83 + local_2f4;
            local_304 = local_304 ^ (uVar34 >> 0xe | uVar34 * 0x40000);
            uVar52 = uVar52 ^ (uVar74 >> 0xe | uVar74 * 0x40000);
            local_308 = local_308 ^
                        (uVar32 + uVar38 >> 0x13 | (uVar32 + uVar38) * 0x2000);
            uVar74 = uVar81 + local_2f8;
            local_2fc = local_2fc ^ (uVar74 >> 0xe | uVar74 * 0x40000);
            uVar74 = uVar38 + local_308;
            local_2f4 = local_2f4 ^
                        (uVar48 + uVar52 >> 0x19 | (uVar48 + uVar52) * 0x80);
            local_300 = local_300 ^ (uVar74 >> 0xe | uVar74 * 0x40000);
            uVar82 = uVar82 ^
                     (uVar32 + local_2fc >> 0x19 | (uVar32 + local_2fc) * 0x80);
            local_2f8 = local_2f8 ^ (uVar55 + local_300 >> 0x19 |
                                     (uVar55 + local_300) * 0x80);
            uVar83 = uVar83 ^ (local_2fc + uVar82 >> 0x17 |
                               (local_2fc + uVar82) * 0x200);
            local_308 = local_308 ^ (uVar59 + local_304 >> 0x19 |
                                     (uVar59 + local_304) * 0x80);
            uVar84 = uVar84 ^ (local_300 + local_2f8 >> 0x17 |
                               (local_300 + local_2f8) * 0x200);
            uVar81 = uVar81 ^ (local_304 + local_308 >> 0x17 |
                               (local_304 + local_308) * 0x200);
            uVar55 = uVar55 ^ (local_2f8 + uVar84 >> 0x13 |
                               (local_2f8 + uVar84) * 0x2000);
            uVar38 = uVar38 ^ (uVar52 + local_2f4 >> 0x17 |
                               (uVar52 + local_2f4) * 0x200);
            uVar59 = uVar59 ^ (local_308 + uVar81 >> 0x13 |
                               (local_308 + uVar81) * 0x2000);
            uVar32 =
                uVar32 ^ (uVar82 + uVar83 >> 0x13 | (uVar82 + uVar83) * 0x2000);
            local_304 = local_304 ^
                        (uVar81 + uVar59 >> 0xe | (uVar81 + uVar59) * 0x40000);
            uVar48 = uVar48 ^ (local_2f4 + uVar38 >> 0x13 |
                               (local_2f4 + uVar38) * 0x2000);
            local_300 = local_300 ^
                        (uVar84 + uVar55 >> 0xe | (uVar84 + uVar55) * 0x40000);
            local_2fc = local_2fc ^
                        (uVar83 + uVar32 >> 0xe | (uVar83 + uVar32) * 0x40000);
            uVar52 =
                uVar52 ^ (uVar38 + uVar48 >> 0xe | (uVar38 + uVar48) * 0x40000);
            local_2dc = local_2dc + -1;
        } while (local_2dc != 0);
        X[0] = (X[0x10] ^ X[0]) + local_304;
        X[1] = (X[0x11] ^ X[1]) + local_308;
        X[2] = (X[2] ^ X[0x12]) + uVar81;
        X[3] = (X[3] ^ X[0x13]) + uVar59;
        X[4] = (X[4] ^ X[0x14]) + uVar55;
        X[5] = (X[5] ^ X[0x15]) + local_300;
        X[6] = (X[6] ^ X[0x16]) + local_2f8;
        X[7] = (X[7] ^ X[0x17]) + uVar84;
        X[8] = (X[8] ^ X[0x18]) + uVar83;
        X[9] = (X[0x19] ^ X[9]) + uVar32;
        X[10] = (X[10] ^ X[0x1a]) + local_2fc;
        X[0xb] = (X[0xb] ^ X[0x1b]) + uVar82;
        X[0xc] = (X[0xc] ^ X[0x1c]) + local_2f4;
        X[0xd] = (X[0xd] ^ X[0x1d]) + uVar38;
        X[0xe] = (X[0xe] ^ X[0x1e]) + uVar48;
        uVar34 = X[0x12] ^ X[2];
        X[0xf] = (X[0xf] ^ X[0x1f]) + uVar52;
        uVar45 = X[0x13] ^ X[3];
        uVar58 = X[0x10] ^ X[0];
        uVar54 = X[0x11] ^ X[1];
        uVar69 = X[0x15] ^ X[5];
        uVar62 = X[0x14] ^ X[4];
        uVar61 = X[0x16] ^ X[6];
        uVar50 = X[0x17] ^ X[7];
        uVar53 = X[0x18] ^ X[8];
        uVar40 = X[0x19] ^ X[9];
        uVar41 = X[0x1a] ^ X[10];
        uVar42 = X[0x1b] ^ X[0xb];
        uVar43 = X[0x1c] ^ X[0xc];
        uVar44 = X[0x1d] ^ X[0xd];
        uVar63 = X[0x1e] ^ X[0xe];
        uVar73 = X[0x1f] ^ X[0xf];
        local_2dc = 4;
        uVar32 = uVar45;
        uVar38 = uVar62;
        uVar48 = uVar40;
        uVar52 = uVar44;
        uVar59 = uVar63;
        uVar84 = uVar58;
        uVar81 = uVar50;
        uVar82 = uVar34;
        uVar83 = uVar41;
        uVar55 = uVar53;
        uVar74 = uVar73;
        local_308 = uVar42;
        local_304 = uVar54;
        local_300 = uVar43;
        local_2fc = uVar69;
        local_2f0 = uVar61;
        do {
            uVar38 = uVar38 ^
                     (uVar84 + local_300 >> 0x19 | (uVar84 + local_300) * 0x80);
            uVar59 = uVar59 ^
                     (local_2f0 + uVar83 >> 0x19 | (local_2f0 + uVar83) * 0x80);
            uVar32 = uVar32 ^
                     (local_308 + uVar74 >> 0x19 | (local_308 + uVar74) * 0x80);
            uVar48 = uVar48 ^ (local_304 + local_2fc >> 0x19 |
                               (local_304 + local_2fc) * 0x80);
            uVar81 =
                uVar81 ^ (uVar32 + uVar74 >> 0x17 | (uVar32 + uVar74) * 0x200);
            uVar55 =
                uVar55 ^ (uVar38 + uVar84 >> 0x17 | (uVar38 + uVar84) * 0x200);
            uVar82 =
                uVar82 ^ (uVar59 + uVar83 >> 0x17 | (uVar59 + uVar83) * 0x200);
            uVar52 = uVar52 ^ (uVar48 + local_2fc >> 0x17 |
                               (uVar48 + local_2fc) * 0x200);
            local_300 = local_300 ^
                        (uVar55 + uVar38 >> 0x13 | (uVar55 + uVar38) * 0x2000);
            local_2f0 = local_2f0 ^
                        (uVar59 + uVar82 >> 0x13 | (uVar59 + uVar82) * 0x2000);
            local_308 = local_308 ^
                        (uVar32 + uVar81 >> 0x13 | (uVar32 + uVar81) * 0x2000);
            uVar35 = uVar55 + local_300;
            local_304 = local_304 ^
                        (uVar48 + uVar52 >> 0x13 | (uVar48 + uVar52) * 0x2000);
            uVar64 = uVar82 + local_2f0;
            uVar83 = uVar83 ^ (uVar64 >> 0xe | uVar64 * 0x40000);
            uVar64 = uVar81 + local_308;
            uVar70 = uVar52 + local_304;
            uVar74 = uVar74 ^ (uVar64 >> 0xe | uVar64 * 0x40000);
            uVar84 = uVar84 ^ (uVar35 >> 0xe | uVar35 * 0x40000);
            local_308 = local_308 ^
                        (uVar48 + uVar83 >> 0x19 | (uVar48 + uVar83) * 0x80);
            local_2fc = local_2fc ^ (uVar70 >> 0xe | uVar70 * 0x40000);
            local_300 = local_300 ^
                        (uVar59 + uVar74 >> 0x19 | (uVar59 + uVar74) * 0x80);
            local_2f0 = local_2f0 ^ (uVar38 + local_2fc >> 0x19 |
                                     (uVar38 + local_2fc) * 0x80);
            local_304 = local_304 ^
                        (uVar32 + uVar84 >> 0x19 | (uVar32 + uVar84) * 0x80);
            uVar81 = uVar81 ^ (local_2fc + local_2f0 >> 0x17 |
                               (local_2fc + local_2f0) * 0x200);
            uVar82 = uVar82 ^ (uVar84 + local_304 >> 0x17 |
                               (uVar84 + local_304) * 0x200);
            uVar55 = uVar55 ^ (uVar83 + local_308 >> 0x17 |
                               (uVar83 + local_308) * 0x200);
            uVar32 = uVar32 ^ (local_304 + uVar82 >> 0x13 |
                               (local_304 + uVar82) * 0x2000);
            uVar52 = uVar52 ^ (uVar74 + local_300 >> 0x17 |
                               (uVar74 + local_300) * 0x200);
            uVar84 =
                uVar84 ^ (uVar82 + uVar32 >> 0xe | (uVar82 + uVar32) * 0x40000);
            uVar38 = uVar38 ^ (local_2f0 + uVar81 >> 0x13 |
                               (local_2f0 + uVar81) * 0x2000);
            uVar48 = uVar48 ^ (local_308 + uVar55 >> 0x13 |
                               (local_308 + uVar55) * 0x2000);
            uVar83 =
                uVar83 ^ (uVar55 + uVar48 >> 0xe | (uVar55 + uVar48) * 0x40000);
            uVar59 = uVar59 ^ (local_300 + uVar52 >> 0x13 |
                               (local_300 + uVar52) * 0x2000);
            local_2fc = local_2fc ^
                        (uVar81 + uVar38 >> 0xe | (uVar81 + uVar38) * 0x40000);
            uVar74 =
                uVar74 ^ (uVar52 + uVar59 >> 0xe | (uVar52 + uVar59) * 0x40000);
            local_2dc = local_2dc + -1;
        } while (local_2dc != 0);
        X[0x10] = uVar58 + uVar84;
        X[0x11] = uVar54 + local_304;
        X[0x12] = uVar34 + uVar82;
        X[0x13] = uVar45 + uVar32;
        X[0x14] = uVar62 + uVar38;
        X[0x15] = uVar69 + local_2fc;
        X[0x1c] = uVar43 + local_300;
        X[0x16] = uVar61 + local_2f0;
        X[0x17] = uVar50 + uVar81;
        X[0x18] = uVar53 + uVar55;
        X[0x19] = uVar40 + uVar48;
        X[0x1a] = uVar41 + uVar83;
        X[0x1b] = uVar42 + local_308;
        X[0x1d] = uVar44 + uVar52;
        X[0x1e] = uVar63 + uVar59;
        local_2b4 = local_2b4 + -1;
        X[0x1f] = uVar73 + uVar74;
    } while (local_2b4 != 0);
    pad[4] = 0x510e527f;
    pad[3] = 0xa54ff53a;
    puVar80 = PShictx.buf + 0xf;
    puVar47 = pad + 0xf;
    pad[5] = 0x9b05688c;
    pad[6] = 0x1f83d9ab;
    pad[7] = 0x5be0cd19;
    pad[0] = 0x6a09e667;
    pad[1] = 0xbb67ae85;
    pad[2] = 0x3c6ef372;
    SHA256_Transform((SHA256_CTX *)pad, (uchar *)input);
    PShoctx.state[0] = input[0x10];
    PShoctx.state[1] = input[0x11];
    PShoctx.state[2] = input[0x12];
    PShoctx.state[3] = input[0x13];
    PShoctx.state[4] = 0x80;
    PShoctx.state[5] = 0;
    PShoctx.state[6] = 0;
    PShoctx.state[7] = 0;
    PShoctx.buf[0] = 0;
    PShoctx.buf[1] = 0;
    PShoctx.buf[2] = 0;
    PShoctx.buf[3] = 0;
    PShoctx.buf[4] = 0;
    PShoctx.buf[5] = 0;
    PShoctx.buf[6] = 0;
    PShoctx.buf[7] = 0x80020000;
    SHA256_Transform((SHA256_CTX *)pad, (uchar *)&PShoctx);
    *ostate = 0x6a09e667;
    ostate[1] = 0xbb67ae85;
    PShictx.state[0] = pad[0];
    PShictx.state[1] = pad[1];
    PShictx.state[2] = pad[2];
    PShictx.state[3] = pad[3];
    ostate[2] = 0x3c6ef372;
    ostate[3] = 0xa54ff53a;
    ostate[4] = 0x510e527f;
    ostate[5] = 0x9b05688c;
    ostate[6] = 0x1f83d9ab;
    ostate[7] = 0x5be0cd19;
    PShictx.state[4] = pad[4];
    PShictx.state[5] = pad[5];
    PShictx.state[6] = pad[6];
    PShictx.state[7] = pad[7];
    puVar68 = puVar47;
    puVar85 = puVar80;
    do {
        puVar68 = puVar68 + 1;
        puVar85 = puVar85 + 1;
        *puVar85 = *puVar68 ^ 0x5c5c5c5c;
    } while (PShictx.state + 7 != puVar68);
    PShoctx.buf[0] = 0x5c5c5c5c;
    PShoctx.buf[1] = 0x5c5c5c5c;
    PShoctx.buf[2] = 0x5c5c5c5c;
    PShoctx.buf[3] = 0x5c5c5c5c;
    PShoctx.buf[4] = 0x5c5c5c5c;
    PShoctx.buf[5] = 0x5c5c5c5c;
    PShoctx.buf[6] = 0x5c5c5c5c;
    PShoctx.buf[7] = 0x5c5c5c5c;
    SHA256_Transform((SHA256_CTX *)ostate, (uchar *)&PShoctx);
    pad[0] = 0x6a09e667;
    pad[1] = 0xbb67ae85;
    pad[2] = 0x3c6ef372;
    pad[3] = 0xa54ff53a;
    pad[4] = 0x510e527f;
    pad[5] = 0x9b05688c;
    pad[6] = 0x1f83d9ab;
    pad[7] = 0x5be0cd19;
    do {
        puVar47 = puVar47 + 1;
        puVar80 = puVar80 + 1;
        *puVar80 = *puVar47 ^ 0x36363636;
    } while (puVar47 != puVar68);
    PShoctx.buf[0] = 0x36363636;
    PShoctx.buf[1] = 0x36363636;
    PShoctx.buf[2] = 0x36363636;
    PShoctx.buf[3] = 0x36363636;
    PShoctx.buf[4] = 0x36363636;
    PShoctx.buf[5] = 0x36363636;
    PShoctx.buf[6] = 0x36363636;
    PShoctx.buf[7] = 0x36363636;
    SHA256_Transform((SHA256_CTX *)pad, (uchar *)&PShoctx);
    SHA256_Transform((SHA256_CTX *)pad, (uchar *)X);
    SHA256_Transform((SHA256_CTX *)pad, (uchar *)(X + 0x10));
    SHA256_Transform((SHA256_CTX *)pad, ihash_finalblk_13384);
    PShoctx.state[0] = pad[0];
    PShoctx.state[1] = pad[1];
    PShoctx.state[2] = pad[2];
    PShoctx.state[3] = pad[3];
    PShoctx.state[4] = pad[4];
    PShoctx.state[5] = pad[5];
    PShoctx.state[6] = pad[6];
    PShoctx.state[7] = pad[7];
    PShoctx.buf[0] = 0x80000000;
    PShoctx.buf[1] = 0;
    PShoctx.buf[2] = 0;
    PShoctx.buf[3] = 0;
    PShoctx.buf[4] = 0;
    PShoctx.buf[5] = 0;
    PShoctx.buf[6] = 0;
    PShoctx.buf[7] = 0x300;
    SHA256_Transform((SHA256_CTX *)ostate, (uchar *)&PShoctx);
    return;
}

/* WARNING: Unknown calling convention */

void scrypt_regenhash(work *work)

{
    uchar *puVar1;
    uint *puVar2;
    uint32_t **ppuVar3;
    uint uVar4;
    uint32_t *ohash;
    uint32_t *puStack_20264;
    uint32_t data[20];
    char scratchbuf[131584];

    memset(scratchbuf + 4, 0, 0x201fc);
    puVar2 = (uint *)&work[-1].field_0x7ac;
    ppuVar3 = &puStack_20264;
    do {
        puVar2 = puVar2 + 1;
        uVar4 = *puVar2;
        ppuVar3 = ppuVar3 + 1;
        *ppuVar3 = (uint32_t *)(uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10 |
                                (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18);
    } while (ppuVar3 != (uint32_t **)(data + 0x12));
    uVar4 = *(uint *)(work->data + 0x4c);
    puStack_20264 = data;
    data[0x13] = uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10 |
                 (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
    scrypt_1024_1_1_256_sp(puStack_20264, scratchbuf, (uint32_t *)work->hash);
    puVar1 = work->target + 0x1c;
    do {
        puVar1 = puVar1 + 4;
        uVar4 = *(uint *)puVar1;
        *(uint *)puVar1 = uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10 |
                          (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
    } while (puVar1 != work->hash + 0x1c);
    return;
}

/* WARNING: Unknown calling convention */

void rebuild_hash(work *work)

{
    if (!opt_scrypt) {
        regen_hash(work);
        return;
    }
    scrypt_regenhash(work);
    return;
}

/* WARNING: Unknown calling convention */

int scrypt_test(uchar *pdata, uchar *ptarget, uint32_t nonce)

{
    uint *puVar1;
    int iVar2;
    uint *puVar3;
    uint uVar4;
    uint uVar5;
    char acStack_21290[131600];
    uint32_t ohash[8];
    uint32_t data[20];
    char tmp42[4096];

    puVar1 = (uint *)(pdata + -4);
    uVar5 = *(uint *)(ptarget + 0x1c);
    puVar3 = ohash + 7;
    do {
        puVar1 = puVar1 + 1;
        uVar4 = *puVar1;
        puVar3 = puVar3 + 1;
        *puVar3 = uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10 |
                  (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
    } while (puVar3 != data + 0x12);
    data[0x13] = nonce << 0x18 | (nonce >> 8 & 0xff) << 0x10 |
                 (nonce >> 0x10 & 0xff) << 8 | nonce >> 0x18;
    scrypt_1024_1_1_256_sp(data, acStack_21290, ohash);
    uVar4 = ohash[7] << 0x18 | (ohash[7] >> 8 & 0xff) << 0x10 |
            (ohash[7] >> 0x10 & 0xff) << 8 | ohash[7] >> 0x18;
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "htarget %08lx diff1 %08lx hash %08lx", uVar5,
                 0xffff, uVar4);
        _applog(7, tmp42, false);
    }
    if (uVar4 < 0x10000) {
        if (uVar5 < uVar4) {
            iVar2 = 0;
        } else {
            iVar2 = 1;
        }
    } else {
        iVar2 = -1;
    }
    return iVar2;
}

/* WARNING: Unknown calling convention */

_Bool scanhash_scrypt(thr_info *thr, uchar *pmidstate, uchar *pdata,
                      uchar *phash1, uchar *phash, uchar *ptarget,
                      uint32_t max_nonce, uint32_t *last_nonce, uint32_t n)

{
    char *scratchpad;
    uint *puVar1;
    uint *puVar2;
    uint uVar3;
    _Bool _Var4;
    uint uVar5;
    uint uStack_1074;
    uint32_t data[20];
    char tmp42[4096];

    puVar1 = (uint *)(pdata + -4);
    puVar2 = &uStack_1074;
    uVar5 = *(uint *)(ptarget + 0x1c);
    do {
        puVar1 = puVar1 + 1;
        uVar3 = *puVar1;
        puVar2 = puVar2 + 1;
        *puVar2 = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                  (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
    } while (puVar2 != data + 0x12);
    scratchpad = (char *)malloc(0x20200);
    if (scratchpad == (char *)0x0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (_Var4 = false, 2 < opt_log_level)) {
            _Var4 = false;
            builtin_strncpy(
                tmp42, "Failed to malloc scratchbuf in scanhash_scry", 0x2c);
            tmp42[0x2c] = 'p';
            tmp42[0x2d] = 't';
            tmp42[0x2e] = '\0';
            _applog(3, tmp42, false);
        }
    } else {
        do {
            n = n + 1;
            *(uint32_t *)(pdata + 0x4c) = n;
            uVar3 = n * 0x1000000 | (n >> 8 & 0xff) << 0x10 |
                    (n >> 0x10 & 0xff) << 8 | n >> 0x18;
            data[0x13] = uVar3;
            scrypt_1024_1_1_256_sp(data, scratchpad, (uint32_t *)tmp42);
            if ((tmp42._28_4_ << 0x18 |
                 ((uint)tmp42._28_4_ >> 8 & 0xff) << 0x10 |
                 ((uint)tmp42._28_4_ >> 0x10 & 0xff) << 8 |
                 (uint)tmp42._28_4_ >> 0x18) <= uVar5) {
                *(uint *)(pdata + 0x4c) = uVar3;
                _Var4 = true;
                *last_nonce = n;
                goto LAB_000193c2;
            }
        } while ((n < max_nonce) && (thr->work_restart == false));
        _Var4 = false;
        *last_nonce = n;
    LAB_000193c2:
        free(scratchpad);
    }
    return _Var4;
}

/* WARNING: Unknown calling convention */

void get_datestamp(char *f, size_t fsiz, timeval *tv)

{
    tm *ptVar1;
    time_t tmp_time;

    tmp_time = tv->tv_sec;
    ptVar1 = localtime(&tmp_time);
    snprintf(f, fsiz, "[%d-%02d-%02d %02d:%02d:%02d]", ptVar1->tm_year + 0x76c,
             ptVar1->tm_mon + 1, ptVar1->tm_mday, ptVar1->tm_hour,
             ptVar1->tm_min, ptVar1->tm_sec);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void adjust_quota_gcd(void)

{
    ulong uVar1;
    int extraout_r1;
    int iVar2;
    int extraout_r1_00;
    uint uVar3;
    ulong uVar4;
    pool **pppVar5;
    int iVar7;
    pool *ppVar8;
    pool **pppVar9;
    pool **pppVar10;
    char tmp42[4096];
    pool **pppVar6;

    pppVar9 = pools;
    if (total_pools < 1) {
        uVar4 = 1;
    } else {
        uVar4 = 0xffffffff;
        pppVar5 = pools;
        do {
            pppVar6 = pppVar5 + 1;
            uVar3 = (*pppVar5)->quota;
            if (uVar3 != 0 && uVar3 < uVar4) {
                uVar4 = uVar3;
            }
            pppVar5 = pppVar6;
        } while (pools + total_pools != pppVar6);
        pppVar5 = pools;
        if (uVar4 == 0xffffffff) {
            uVar4 = 1;
            uVar1 = global_quota_gcd;
        } else {
            do {
                pppVar10 = pppVar5 + 1;
                iVar7 = (*pppVar5)->quota;
                if (iVar7 != 0) {
                    __aeabi_uidivmod(iVar7, uVar4);
                    iVar2 = extraout_r1;
                    while (iVar2 != 0) {
                        uVar4 = uVar4 - 1;
                        __aeabi_uidivmod(iVar7, uVar4);
                        iVar2 = extraout_r1_00;
                    }
                }
                pppVar5 = pppVar10;
                uVar1 = global_quota_gcd;
            } while (pppVar6 != pppVar10);
        }
        do {
            pppVar5 = pppVar9 + 1;
            ppVar8 = *pppVar9;
            iVar7 = __udivsi3(ppVar8->quota_used * uVar1, uVar4);
            ppVar8->quota_used = iVar7;
            iVar7 = __udivsi3(ppVar8->quota, uVar4);
            ppVar8->quota_gcd = iVar7;
            pppVar9 = pppVar5;
        } while (pppVar6 != pppVar5);
    }
    global_quota_gcd = uVar4;
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000,
                 "Global quota greatest common denominator set to %lu", uVar4);
        _applog(7, tmp42, false);
    }
    return;
}

/* WARNING: Unknown calling convention */

char *set_int_range(char *arg, int *i, int min, int max)

{
    char *pcVar1;

    pcVar1 = opt_set_intval(arg, i);
    if (pcVar1 == (char *)0x0) {
        pcVar1 = (char *)0x0;
        if (max < *i || *i < min) {
            pcVar1 = "Value out of range";
        }
        return pcVar1;
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

void get_intrange(char *arg, int *val1, int *val2)

{
    int iVar1;

    iVar1 = sscanf(arg, "%d-%d", val1, val2);
    if (iVar1 == 1) {
        *val2 = *val1;
    }
    return;
}

/* WARNING: Unknown calling convention */

_Bool detect_stratum(pool *pool, char *url)

{
    _Bool _Var1;
    int iVar2;
    char *pcVar3;

    check_extranonce_option(pool, url);
    _Var1 = extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port);
    if (_Var1) {
        iVar2 = strncasecmp(url, "stratum+tcp://", 0xe);
        if (iVar2 == 0) {
            pcVar3 = (char *)__strdup(url);
            pool->rpc_url = pcVar3;
            pool->has_stratum = true;
            pool->stratum_url = pool->sockaddr_url;
            return _Var1;
        }
        _Var1 = false;
    }
    return _Var1;
}

/* WARNING: Unknown calling convention */

char *set_temp_cutoff(char *arg)

{
    char *pcVar1;
    char *pcVar2;
    char **extraout_r3;
    char **ppcVar3;

    if (arg == (char *)0x0) {
        return "Invalid parameters for set temp cutoff";
    }
    if (*arg == '\0') {
        pcVar1 = "Invalid parameters for set temp cutoff";
    } else {
        pcVar2 = (char *)strtol(arg, (char **)0x0, 10);
        ppcVar3 = extraout_r3;
        pcVar1 = pcVar2;
        if (pcVar2 < (char *)0xc9) {
            pcVar1 = (char *)0x0;
            ppcVar3 = &opt_logfile_path;
        }
        if ((char *)0xc8 < pcVar2) {
            return "Invalid value passed to set temp cutoff";
        }
        ppcVar3[0xca] = arg;
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

void clean_work(work *work)

{
    undefined4 extraout_r3;
    undefined4 unaff_lr;

    free(work->job_id);
    free(work->ntime);
    free(work->coinbase);
    free(work->nonce1);
    (*(code *)(undefined *)0x0)(work, 0, 0x7b0, extraout_r3, unaff_lr);
    return;
}

/* WARNING: Unknown calling convention */

void _copy_work(work *work, work *base_work, int noffset)

{
    char *pcVar1;
    uint uVar2;
    uint32_t id;
    uint32_t uVar3;
    uchar bin[4];

    uVar3 = work->id;
    clean_work(work);
    memcpy(work, base_work, 0x7b0);
    work->id = uVar3;
    if (base_work->job_id != (char *)0x0) {
        pcVar1 = (char *)__strdup();
        work->job_id = pcVar1;
    }
    if (base_work->nonce1 != (char *)0x0) {
        pcVar1 = (char *)__strdup();
        work->nonce1 = pcVar1;
    }
    if (base_work->ntime == (char *)0x0) {
        if (noffset != 0) {
            uVar2 = *(uint *)(work->data + 0x44);
            uVar2 = noffset + (uVar2 << 0x18 | (uVar2 >> 8 & 0xff) << 0x10 |
                               (uVar2 >> 0x10 & 0xff) << 8 | uVar2 >> 0x18);
            *(uint *)(work->data + 0x44) =
                uVar2 * 0x1000000 | (uVar2 >> 8 & 0xff) << 0x10 |
                (uVar2 >> 0x10 & 0xff) << 8 | uVar2 >> 0x18;
        }
    } else if (noffset == 0) {
        pcVar1 = (char *)__strdup();
        work->ntime = pcVar1;
    } else {
        uVar2 = *(uint *)(work->data + 0x44);
        uVar2 = (uVar2 << 0x18 | (uVar2 >> 8 & 0xff) << 0x10 |
                 (uVar2 >> 0x10 & 0xff) << 8 | uVar2 >> 0x18) +
                noffset;
        *(uint *)(work->data + 0x44) =
            uVar2 * 0x1000000 | (uVar2 >> 8 & 0xff) << 0x10 |
            (uVar2 >> 0x10 & 0xff) << 8 | uVar2 >> 0x18;
        hex2bin(bin, base_work->ntime, 4);
        uVar2 = noffset + ((int)bin << 0x18 | ((uint)bin >> 8 & 0xff) << 0x10 |
                           ((uint)bin >> 0x10 & 0xff) << 8 | (uint)bin >> 0x18);
        bin = (uchar[4])(uVar2 * 0x1000000 | (uVar2 >> 8 & 0xff) << 0x10 |
                         (uVar2 >> 0x10 & 0xff) << 8 | uVar2 >> 0x18);
        pcVar1 = bin2hex(bin, 4);
        work->ntime = pcVar1;
    }
    if (base_work->coinbase != (char *)0x0) {
        pcVar1 = (char *)__strdup();
        work->coinbase = pcVar1;
    }
    return;
}

/* WARNING: Unknown calling convention */

void _free_work(work *work)

{
    clean_work(work);
    (*(code *)(undefined *)0x0)(work);
    return;
}

void decay_time(double *f, double fadd, double fsecs, double interval)

{
    if (0.0 < fsecs) {
        decay_time(f, fadd, fsecs, interval);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

double cgpu_runtime(cgpu_info *cgpu)

{
    double dVar1;
    timeval now;

    dVar1 = total_secs;
    if ((cgpu->dev_start_tv).tv_sec != 0) {
        cgtime(&now);
        dVar1 = tdiff(&now, &cgpu->dev_start_tv);
    }
    if ((int)((uint)(dVar1 < 1.0) << 0x1f) < 0) {
        dVar1 = 1.0;
    }
    return dVar1;
}

/* WARNING: Unknown calling convention */

double tsince_restart(void)

{
    double dVar1;
    timeval now;

    cgtime(&now);
    dVar1 = tdiff(&now, &restart_tv_start);
    return dVar1;
}

/* WARNING: Unknown calling convention */

double tsince_update(void)

{
    double dVar1;
    timeval now;

    cgtime(&now);
    dVar1 = tdiff(&now, &update_tv_start);
    return dVar1;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void app_restart(void)

{
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (3 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "Attempting to restart %s", packagename);
        _applog(4, tmp42, false);
    }
    cg_completion_timeout((void *)0x1d5a9, (void *)0x0, 5000);
    cgtime(&total_tv_end);
    if (0 < forkpid) {
        kill(forkpid, 0xf);
        forkpid = 0;
    }
    execv(*initial_args, initial_args);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 4)) {
        return;
    }
    builtin_strncpy(tmp42, "Failed to restart applicatio", 0x1c);
    tmp42[0x1c] = 'n';
    tmp42[0x1d] = '\0';
    _applog(4, tmp42, false);
    return;
}

/* WARNING: Unknown calling convention */

void set_work_ntime(work *work, int ntime)

{
    char *pcVar1;

    pcVar1 = work->ntime;
    *(uint *)(work->data + 0x44) =
        ntime << 0x18 | ((uint)ntime >> 8 & 0xff) << 0x10 |
        ((uint)ntime >> 0x10 & 0xff) << 8 | (uint)ntime >> 0x18;
    if (pcVar1 != (char *)0x0) {
        free(pcVar1);
        pcVar1 = bin2hex(work->data + 0x44, 4);
        work->ntime = pcVar1;
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

uint64_t share_ndiff(work *work)

{
    undefined4 uVar1;
    undefined4 extraout_r1;
    undefined4 extraout_s0;
    undefined4 extraout_s1;
    double dVar2;
    double dVar3;
    double dVar4;
    UDItype UVar5;

    if (work != (work *)0x0) {
        dVar4 = (double)__floatundidf(*(undefined4 *)(work->hash + 0x18),
                                      *(undefined4 *)(work->hash + 0x1c));
        dVar2 = (double)__floatundidf(*(undefined4 *)(work->hash + 0x10),
                                      *(undefined4 *)(work->hash + 0x14));
        dVar3 = (double)__floatundidf(*(undefined4 *)(work->hash + 8),
                                      *(undefined4 *)(work->hash + 0xc));
        uVar1 = __floatundidf(*(undefined4 *)work->hash,
                              *(undefined4 *)(work->hash + 4));
        if ((double)CONCAT44(extraout_r1, uVar1) +
                dVar4 * 6.277101735386681e+57 + dVar2 * 3.402823669209385e+38 +
                dVar3 * 1.8446744073709552e+19 ==
            0.0) {
            UVar5 = 0;
        } else {
            UVar5 = __fixunsdfdi((DFtype)CONCAT44(extraout_s1, extraout_s0));
        }
        return UVar5;
    }
    return 0;
}

/* WARNING: Unknown calling convention */

void _discard_work(work *work)

{
    pool *ppVar1;
    bool bVar2;
    char tmp42[4096];

    if (((work->clone == false) && (work->rolls == 0)) &&
        (work->mined == false)) {
        ppVar1 = work->pool;
        if (ppVar1 != (pool *)0x0) {
            ppVar1->discarded_work = ppVar1->discarded_work + 1;
            work->pool->quota_used = work->pool->quota_used + -1;
            work->pool->works = work->pool->works + -1;
        }
        bVar2 = 0xfffffffe < (uint)total_discarded;
        total_discarded._0_4_ = (uint)total_discarded + 1;
        total_discarded._4_4_ = total_discarded._4_4_ + (uint)bVar2;
    } else if ((opt_debug) &&
               (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Discarded cloned or rolled work", 0x20);
        _applog(7, tmp42, false);
    }
    clean_work(work);
    (*(code *)(undefined *)0x0)(work);
    return;
}

/* WARNING: Unknown calling convention */

void remove_pool(pool *pool)

{
    pool **pppVar1;
    int iVar3;
    pool **pppVar4;
    int iVar5;
    int last_pool;
    int iVar6;
    pool **pppVar2;

    iVar5 = total_pools;
    iVar6 = total_pools + -1;
    if (0 < total_pools) {
        pppVar4 = pools + total_pools;
        pppVar1 = pools;
        do {
            pppVar2 = pppVar1 + 1;
            iVar3 = (*pppVar1)->prio;
            if (pool->prio < iVar3) {
                (*pppVar1)->prio = iVar3 + -1;
            }
            pppVar1 = pppVar2;
        } while (pppVar2 != pppVar4);
    }
    if (pool->pool_no < iVar6) {
        pools[iVar6]->pool_no = pool->pool_no;
        pools[pool->pool_no] = pools[iVar6];
        iVar5 = total_pools;
    }
    pool->pool_no = iVar5;
    pool->removed = true;
    total_pools = total_pools + -1;
    return;
}

/* WARNING: Unknown calling convention */

void write_config(FILE *fcfg)

{
    int *piVar1;
    JE *__ptr;
    char *pcVar2;
    pool *ppVar3;
    char *pcVar4;
    char *pcVar5;
    char *pcVar6;
    char *pcVar7;
    uint uVar8;
    int iVar9;
    JE *jenext;
    JE *pJVar10;
    int iVar11;
    char *pcVar12;
    char *local_34;

    fwrite(&DAT_0004f6a8, 1, 0xd, (FILE *)fcfg);
    if (0 < total_pools) {
        pcVar12 = "";
        iVar11 = 0;
        do {
            ppVar3 = priority_pool(iVar11);
            iVar9 = ppVar3->quota;
            if (iVar9 == 1) {
                pcVar2 = pcVar12;
                if (iVar11 != 0) {
                    pcVar2 = ",";
                }
                pcVar7 = pcVar12;
                if (ppVar3->rpc_proxy == (char *)0x0) {
                    pcVar4 = "";
                    pcVar5 = "";
                } else {
                    pcVar4 = proxytype(ppVar3->rpc_proxytype);
                    pcVar5 = json_escape(pcVar4);
                    pcVar4 = pcVar12;
                    if (ppVar3->rpc_proxy != (char *)0x0) {
                        pcVar4 = json_escape(ppVar3->rpc_proxy);
                        pcVar7 = "|";
                        if (ppVar3->rpc_proxy == (char *)0x0) {
                            pcVar7 = pcVar12;
                        }
                    }
                }
                pcVar6 = json_escape(ppVar3->rpc_url);
                fprintf((FILE *)fcfg, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",",
                        pcVar2, pcVar5, pcVar4, pcVar7, pcVar6);
            } else {
                pcVar2 = pcVar12;
                if (iVar11 != 0) {
                    pcVar2 = ",";
                }
                pcVar7 = pcVar12;
                if (ppVar3->rpc_proxy == (char *)0x0) {
                    local_34 = "";
                    pcVar4 = "";
                } else {
                    pcVar4 = proxytype(ppVar3->rpc_proxytype);
                    pcVar4 = json_escape(pcVar4);
                    if (ppVar3->rpc_proxy == (char *)0x0) {
                        iVar9 = ppVar3->quota;
                        local_34 = "";
                    } else {
                        local_34 = json_escape(ppVar3->rpc_proxy);
                        iVar9 = ppVar3->quota;
                        pcVar7 = "|";
                        if (ppVar3->rpc_proxy == (char *)0x0) {
                            pcVar7 = pcVar12;
                        }
                    }
                }
                pcVar5 = json_escape(ppVar3->rpc_url);
                fprintf((FILE *)fcfg,
                        "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", pcVar2,
                        pcVar4, local_34, pcVar7, iVar9, pcVar5);
            }
            iVar11 = iVar11 + 1;
            pcVar2 = json_escape(ppVar3->rpc_user);
            fprintf((FILE *)fcfg, "\n\t\t\"user\" : \"%s\",", pcVar2);
            pcVar2 = json_escape(ppVar3->rpc_pass);
            fprintf((FILE *)fcfg, "\n\t\t\"pass\" : \"%s\"\n\t}", pcVar2);
        } while (iVar11 < total_pools);
    }
    fwrite(&DAT_0004f720, 1, 3, (FILE *)fcfg);
    if (opt_config_table[0].type != OPT_END) {
        iVar11 = 0x6c2d4;
        do {
            pcVar2 = (char *)__strdup(*(undefined4 *)(iVar11 + -0x1c));
            pcVar12 = strtok(pcVar2, "|");
            while (pcVar12 != (char *)0x0) {
            LAB_00019d98:
                if ((pcVar12[1] != '-') ||
                    (*(undefined4 **)(iVar11 + -4) == &opt_hidden))
                    goto LAB_00019d8a;
                uVar8 = *(uint *)(iVar11 + -0x18);
                if ((int)(uVar8 << 0x1f) < 0) {
                    iVar9 = *(int *)(iVar11 + -0x14);
                    if ((iVar9 == 0x4ad1d || iVar9 == 0x4ad25) &&
                        ((bool)**(char **)(iVar11 + -8) ==
                         (iVar9 == 0x4ad1d))) {
                        fprintf((FILE *)fcfg, ",\n\"%s\" : true", pcVar12 + 2);
                        goto LAB_00019d8a;
                    }
                }
                if (-1 < (int)(uVar8 << 0x1e)) {
                LAB_00019de8:
                    if ((((uVar8 & 6) == 0) ||
                         (*(char ***)(iVar11 + -8) == &opt_set_null)) ||
                        (pcVar7 = **(char ***)(iVar11 + -8),
                         pcVar7 == (char *)0x0))
                        goto LAB_00019d8a;
                    pcVar7 = json_escape(pcVar7);
                    fprintf((FILE *)fcfg, ",\n\"%s\" : \"%s\"", pcVar12 + 2,
                            pcVar7);
                    pcVar12 = strtok((char *)0x0, "|");
                    if (pcVar12 == (char *)0x0)
                        break;
                    goto LAB_00019d98;
                }
                iVar9 = *(int *)(iVar11 + -0x10);
                if (iVar9 != 0x17389 &&
                    (iVar9 != 0x173a9 &&
                     (iVar9 != 0x173c9 &&
                      (iVar9 != 0x173e9 &&
                       (iVar9 != 0x17409 &&
                        (iVar9 != 0x17429 &&
                         (iVar9 != 0x17449 &&
                          (iVar9 != 0x17469 &&
                           (iVar9 != 0x17489 &&
                            (iVar9 != 0x174a9 &&
                             (iVar9 != 0x174cd && iVar9 != 0x4ae4d))))))))))) {
                    if (iVar9 == 0x17119 || iVar9 == 0x17165) {
                        fprintf((FILE *)fcfg, ",\n\"%s\" : \"%.1f\"",
                                pcVar12 + 2, *(float **)(iVar11 + -8),
                                (double)**(float **)(iVar11 + -8));
                        goto LAB_00019d8a;
                    }
                    goto LAB_00019de8;
                }
                fprintf((FILE *)fcfg, ",\n\"%s\" : \"%d\"", pcVar12 + 2,
                        **(undefined4 **)(iVar11 + -8));
            LAB_00019d8a:
                pcVar12 = strtok((char *)0x0, "|");
            }
            free(pcVar2);
            piVar1 = (int *)(iVar11 + 4);
            iVar11 = iVar11 + 0x1c;
        } while (*piVar1 != 0x10);
    }
    if (pool_strategy == POOL_BALANCE) {
        fwrite(",\n\"balance\" : true", 1, 0x12, (FILE *)fcfg);
    }
    if (pool_strategy == POOL_LOADBALANCE) {
        fwrite(",\n\"load-balance\" : true", 1, 0x17, (FILE *)fcfg);
    }
    if (pool_strategy == POOL_ROUNDROBIN) {
        fwrite(",\n\"round-robin\" : true", 1, 0x16, (FILE *)fcfg);
    }
    if (pool_strategy == POOL_ROTATE) {
        fprintf((FILE *)fcfg, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
    }
    fwrite(&DAT_0004f7bc, 1, 3, (FILE *)fcfg);
    __ptr = jedata;
    jedata = (JE *)0x0;
    while (__ptr != (JE *)0x0) {
        pJVar10 = __ptr->next;
        free(__ptr->buf);
        free(__ptr);
        __ptr = pJVar10;
    }
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void zero_bestshare(void)

{
    pool *ppVar1;
    pool **pppVar2;
    pool **pppVar4;
    pool **pppVar3;

    best_share[0] = '\0';
    best_share[1] = '\0';
    best_share[2] = '\0';
    best_share[3] = '\0';
    best_share[4] = '\0';
    best_share[5] = '\0';
    best_share[6] = '\0';
    best_share[7] = '\0';
    best_diff._0_4_ = 0;
    best_diff._4_4_ = 0;
    suffix_string(0, best_share, 8, 0);
    if (0 < total_pools) {
        pppVar4 = pools + total_pools;
        pppVar2 = pools;
        do {
            pppVar3 = pppVar2 + 1;
            ppVar1 = *pppVar2;
            *(undefined4 *)&ppVar1->best_diff = 0;
            *(undefined4 *)((int)&ppVar1->best_diff + 4) = 0;
            pppVar2 = pppVar3;
        } while (pppVar3 != pppVar4);
    }
    return;
}

/* WARNING: Unknown calling convention */

void default_save_file(char *filename)

{
    char *pcVar1;
    size_t sVar2;

    if ((default_config != (char *)0x0) && (*default_config != '\0')) {
        strcpy(filename, default_config);
        return;
    }
    pcVar1 = getenv("HOME");
    if ((pcVar1 == (char *)0x0) || (pcVar1 = getenv("HOME"), *pcVar1 == '\0')) {
        *filename = '\0';
    } else {
        pcVar1 = getenv("HOME");
        pcVar1 = stpcpy(filename, pcVar1);
        pcVar1[0] = '/';
        pcVar1[1] = '\0';
    }
    sVar2 = strlen(filename);
    builtin_strncpy(filename + sVar2, ".cgminer/", 10);
    mkdir(filename, 0x1ff);
    sVar2 = strlen(filename);
    builtin_strncpy(filename + sVar2, "cgminer.conf", 0xd);
    return;
}

void set_target(uchar *dest_target, double diff)

{
    char *__ptr;
    undefined4 uVar1;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined4 extraout_s1_01;
    uchar target[32];
    char tmp42[4096];

    if ((diff == 0.0) && (((use_syslog || (opt_log_output)) ||
                           (diff = 1.0, 2 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Diff zero passed to set_targ", 0x1c);
        tmp42[0x1c] = 'e';
        tmp42[0x1d] = 't';
        tmp42[0x1e] = '\0';
        _applog(3, tmp42, false);
        diff = 1.0;
    }
    target._24_8_ = __fixunsdfdi(diff);
    uVar1 = __floatundidf();
    target._16_8_ = __fixunsdfdi((DFtype)CONCAT44(extraout_s1, uVar1));
    uVar1 = __floatundidf();
    target._8_8_ = __fixunsdfdi((DFtype)CONCAT44(extraout_s1_00, uVar1));
    uVar1 = __floatundidf();
    target._0_8_ = __fixunsdfdi((DFtype)CONCAT44(extraout_s1_01, uVar1));
    if (opt_debug != false) {
        __ptr = bin2hex(target, 0x20);
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "Generated target %s", __ptr);
            _applog(7, tmp42, false);
        }
        free(__ptr);
    }
    *(undefined4 *)dest_target = target._0_4_;
    *(undefined4 *)(dest_target + 4) = target._4_4_;
    *(undefined4 *)(dest_target + 8) = target._8_4_;
    *(undefined4 *)(dest_target + 0xc) = target._12_4_;
    *(undefined4 *)(dest_target + 0x10) = target._16_4_;
    *(undefined4 *)(dest_target + 0x14) = target._20_4_;
    *(undefined4 *)(dest_target + 0x18) = target._24_4_;
    *(undefined4 *)(dest_target + 0x1c) = target._28_4_;
    return;
}

int add_var_int(uint8_t *msg, uint64_t var_int)

{
    size_t __n;
    int iVar1;
    int iVar2;
    int iVar3;
    uint64_t local_18;

    iVar1 = (int)(var_int >> 0x20);
    if (iVar1 == 0 && (uint)var_int < 0xfd) {
        *msg = (uint8_t)var_int;
        iVar3 = 1;
        __n = 0;
    } else if (iVar1 == 0 && (uint)var_int < 0x10000) {
        iVar3 = 3;
        *msg = 0xfd;
        __n = 2;
    } else {
        if (iVar1 == 0) {
            iVar3 = 5;
            __n = 4;
            iVar2 = 0xfe;
        } else {
            iVar3 = 9;
            __n = 8;
            iVar2 = iVar1;
        }
        if (iVar1 == 0) {
            *msg = (uint8_t)iVar2;
        } else {
            *msg = 0xff;
        }
    }
    local_18 = var_int;
    memcpy(msg + 1, &local_18, __n);
    return iVar3;
}

/* WARNING: Unknown calling convention */

int share_work_tdiff(cgpu_info *cgpu)

{
    return last_getwork - cgpu->last_device_valid_work;
}

/* WARNING: Unknown calling convention */

_Bool test_nonce(work *work, uint32_t nonce)

{
    undefined1 uVar1;
    uint uVar2;
    uint uVar3;
    uint32_t diff1targ;
    uint uVar4;

    *(uint32_t *)(work->data + 0x4c) = nonce;
    rebuild_hash(work);
    uVar2 = *(uint *)(work->hash + 0x1c);
    uVar4 = 0xffff;
    if (opt_scrypt == false) {
        uVar4 = 0;
    }
    uVar3 = uVar2;
    if (uVar4 < uVar2) {
        uVar3 = 0;
    }
    uVar1 = (undefined1)uVar3;
    if (uVar2 <= uVar4) {
        uVar1 = 1;
    }
    return (_Bool)uVar1;
}

_Bool test_nonce_diff(work *work, uint32_t nonce, double diff)

{
    undefined1 uVar1;
    uint uVar2;
    uint uVar3;
    bool bVar4;
    DFtype a;
    UDItype UVar5;

    *(uint32_t *)(work->data + 0x4c) = nonce;
    rebuild_hash(work);
    UVar5 = __fixunsdfdi(a);
    uVar3 = (uint)(UVar5 >> 0x20);
    uVar2 = (uint)UVar5;
    bVar4 = *(uint *)(work->hash + 0x1c) <= uVar3;
    if (uVar3 == *(uint *)(work->hash + 0x1c)) {
        bVar4 = *(uint *)(work->hash + 0x18) <= uVar2;
    }
    if (bVar4) {
        uVar2 = 1;
    }
    uVar1 = (undefined1)uVar2;
    if (!bVar4) {
        uVar1 = 0;
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

void __add_queued(cgpu_info *cgpu, work *work)

{
    UT_hash_table *pUVar1;
    uint uVar2;
    UT_hash_handle *pUVar3;
    uint uVar4;
    uint uVar5;
    UT_hash_bucket *pUVar6;
    UT_hash_handle *pUVar7;
    work *pwVar8;
    int iVar9;
    uint local_2c;

    cgpu->queued_count = cgpu->queued_count + 1;
    (work->hh).next = (void *)0x0;
    (work->hh).key = &work->id;
    (work->hh).keylen = 4;
    if (cgpu->queued_work == (work *)0x0) {
        cgpu->queued_work = work;
        (work->hh).prev = (void *)0x0;
        pwVar8 = cgpu->queued_work;
        pUVar1 = (UT_hash_table *)malloc(0x2c);
        (pwVar8->hh).tbl = pUVar1;
        pUVar1 = (cgpu->queued_work->hh).tbl;
        if (pUVar1 == (UT_hash_table *)0x0)
            goto LAB_0001a62e;
        memset(pUVar1, 0, 0x2c);
        ((cgpu->queued_work->hh).tbl)->tail = &cgpu->queued_work->hh;
        ((cgpu->queued_work->hh).tbl)->num_buckets = 0x20;
        ((cgpu->queued_work->hh).tbl)->log2_num_buckets = 5;
        ((cgpu->queued_work->hh).tbl)->hho = 0x728;
        pUVar1 = (cgpu->queued_work->hh).tbl;
        pUVar6 = (UT_hash_bucket *)malloc(0x180);
        pUVar1->buckets = pUVar6;
        pUVar6 = ((cgpu->queued_work->hh).tbl)->buckets;
        if (pUVar6 == (UT_hash_bucket *)0x0)
            goto LAB_0001a62e;
        memset(pUVar6, 0, 0x180);
        ((cgpu->queued_work->hh).tbl)->signature = 0xa0111fe1;
    } else {
        ((cgpu->queued_work->hh).tbl)->tail->next = work;
        pUVar1 = (cgpu->queued_work->hh).tbl;
        (work->hh).prev = (void *)((int)pUVar1->tail - pUVar1->hho);
        ((cgpu->queued_work->hh).tbl)->tail = &work->hh;
    }
    pUVar1 = (cgpu->queued_work->hh).tbl;
    pUVar1->num_items = pUVar1->num_items + 1;
    uVar5 = (byte)work->id + 0x112410d +
                (uint) * (byte *)((int)&work->id + 3) * 0x1000000 +
                (uint) * (byte *)((int)&work->id + 2) * 0x10000 +
                (uint) * (byte *)((int)&work->id + 1) * 0x100 ^
            0x7f76d;
    uVar2 = 0x9f49bac6 - uVar5 ^ uVar5 << 8;
    uVar4 = (-0x112410d - uVar5) - uVar2 ^ uVar2 >> 0xd;
    pUVar7 = &work->hh;
    pUVar7->tbl = (cgpu->queued_work->hh).tbl;
    uVar5 = (uVar5 - uVar2) - uVar4 ^ uVar4 >> 0xc;
    uVar2 = (uVar2 - uVar4) - uVar5 ^ uVar5 << 0x10;
    uVar4 = (uVar4 - uVar5) - uVar2 ^ uVar2 >> 5;
    uVar5 = (uVar5 - uVar2) - uVar4 ^ uVar4 >> 3;
    uVar2 = (uVar2 - uVar4) - uVar5 ^ uVar5 << 10;
    uVar2 = (uVar4 - uVar5) - uVar2 ^ uVar2 >> 0xf;
    (work->hh).hashv = uVar2;
    pUVar1 = (cgpu->queued_work->hh).tbl;
    pUVar6 = pUVar1->buckets;
    uVar2 = uVar2 & pUVar1->num_buckets - 1;
    pUVar6[uVar2].count = pUVar6[uVar2].count + 1;
    pUVar3 = ((cgpu->queued_work->hh).tbl)->buckets[uVar2].hh_head;
    (work->hh).hh_prev = (UT_hash_handle *)0x0;
    (work->hh).hh_next = pUVar3;
    pUVar6 = ((cgpu->queued_work->hh).tbl)->buckets;
    if (pUVar6[uVar2].hh_head != (UT_hash_handle *)0x0) {
        (pUVar6[uVar2].hh_head)->hh_prev = pUVar7;
        pUVar6 = ((cgpu->queued_work->hh).tbl)->buckets;
    }
    pUVar6[uVar2].hh_head = pUVar7;
    pUVar6 = ((cgpu->queued_work->hh).tbl)->buckets;
    if (((pUVar6[uVar2].expand_mult + 1) * 10 <= pUVar6[uVar2].count) &&
        (pUVar1 = (work->hh).tbl, pUVar1->noexpand != 1)) {
        pUVar6 = (UT_hash_bucket *)calloc(pUVar1->num_buckets * 0x18, 1);
        if (pUVar6 == (UT_hash_bucket *)0x0) {
        LAB_0001a62e:
            /* WARNING: Subroutine does not return */
            exit(-1);
        }
        iVar9 = 0;
        uVar2 = pUVar1->num_items >> (pUVar1->log2_num_buckets + 1 & 0xff);
        if ((pUVar1->num_buckets * 2 - 1 & pUVar1->num_items) != 0) {
            uVar2 = uVar2 + 1;
        }
        pUVar1->ideal_chain_maxlen = uVar2;
        ((work->hh).tbl)->nonideal_items = 0;
        pUVar1 = (work->hh).tbl;
        uVar2 = pUVar1->num_buckets;
        if (uVar2 != 0) {
            local_2c = 0;
            do {
                pUVar7 = *(UT_hash_handle **)((int)&pUVar1->buckets->hh_head +
                                              iVar9);
                if (pUVar7 != (UT_hash_handle *)0x0) {
                    while (true) {
                        pUVar3 = pUVar7->hh_next;
                        uVar4 = uVar2 * 2 - 1 & pUVar7->hashv;
                        uVar2 = pUVar6[uVar4].count + 1;
                        pUVar6[uVar4].count = uVar2;
                        if (pUVar1->ideal_chain_maxlen < uVar2) {
                            pUVar1->nonideal_items = pUVar1->nonideal_items + 1;
                            uVar2 =
                                __udivsi3(pUVar6[uVar4].count,
                                          ((work->hh).tbl)->ideal_chain_maxlen);
                            pUVar6[uVar4].expand_mult = uVar2;
                        }
                        pUVar7->hh_prev = (UT_hash_handle *)0x0;
                        pUVar7->hh_next = pUVar6[uVar4].hh_head;
                        if (pUVar6[uVar4].hh_head != (UT_hash_handle *)0x0) {
                            (pUVar6[uVar4].hh_head)->hh_prev = pUVar7;
                        }
                        pUVar6[uVar4].hh_head = pUVar7;
                        pUVar1 = (work->hh).tbl;
                        if (pUVar3 == (UT_hash_handle *)0x0)
                            break;
                        uVar2 = pUVar1->num_buckets;
                        pUVar7 = pUVar3;
                    }
                    uVar2 = pUVar1->num_buckets;
                }
                iVar9 = iVar9 + 0xc;
                local_2c = local_2c + 1;
            } while (local_2c < uVar2);
        }
        free(pUVar1->buckets);
        pUVar1 = (work->hh).tbl;
        pUVar1->num_buckets = pUVar1->num_buckets << 1;
        pUVar1 = (work->hh).tbl;
        pUVar1->log2_num_buckets = pUVar1->log2_num_buckets + 1;
        ((work->hh).tbl)->buckets = pUVar6;
        pUVar1 = (work->hh).tbl;
        if (pUVar1->num_items >> 1 < pUVar1->nonideal_items) {
            uVar2 = pUVar1->ineff_expands + 1;
        } else {
            uVar2 = 0;
        }
        pUVar1->ineff_expands = uVar2;
        pUVar1 = (work->hh).tbl;
        uVar4 = pUVar1->ineff_expands;
        uVar2 = uVar4;
        if (1 < uVar4) {
            uVar2 = 1;
        }
        if (1 < uVar4) {
            pUVar1->noexpand = uVar2;
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

work *__find_work_bymidstate(work *que, char *midstate, size_t midstatelen,
                             char *data, int offset, size_t datalen)

{
    int iVar1;
    work *pwVar2;

    if (que != (work *)0x0) {
        pwVar2 = (work *)(que->hh).next;
        for (; ((iVar1 = memcmp(que->midstate, midstate, midstatelen),
               iVar1 != 0 || (iVar1 = memcmp(que->data + offset, data, datalen),
                             iVar1 != 0)) &&
                (que = pwVar2, pwVar2 != (work *)0x0));
             pwVar2 = (work *)(pwVar2->hh).next) {
        }
    }
    return que;
}

/* WARNING: Unknown calling convention */

work *__find_work_byid(work *que, uint32_t id)

{
    work *pwVar1;
    work *pwVar2;
    work *pwVar3;

    if ((que != (work *)0x0) &&
        (pwVar3 = (work *)(que->hh).next, id != que->id)) {
        if (pwVar3 != (work *)0x0) {
            pwVar1 = (work *)(pwVar3->hh).next;
            while (pwVar2 = pwVar1, pwVar3->id != id) {
                if (pwVar2 == (work *)0x0) {
                    return (work *)0x0;
                }
                pwVar1 = (work *)(pwVar2->hh).next;
                pwVar3 = pwVar2;
            }
        }
        return pwVar3;
    }
    return que;
}

/* WARNING: Unknown calling convention */

void __work_completed(cgpu_info *cgpu, work *work)

{
    void *pvVar1;
    UT_hash_bucket *pUVar2;
    int iVar3;
    uint uVar4;
    UT_hash_handle *pUVar5;
    UT_hash_handle *pUVar6;
    UT_hash_table *pUVar7;
    work *pwVar8;
    bool bVar9;

    cgpu->queued_count = cgpu->queued_count - 1;
    pvVar1 = (work->hh).prev;
    if (pvVar1 == (void *)0x0) {
        pwVar8 = (work *)(work->hh).next;
        pUVar7 = (cgpu->queued_work->hh).tbl;
        if (pwVar8 == (work *)0x0) {
            free(pUVar7->buckets);
            free((cgpu->queued_work->hh).tbl);
            cgpu->queued_work = (work *)0x0;
            return;
        }
        iVar3 = pUVar7->hho;
        if (work == (work *)((int)pUVar7->tail - iVar3))
            goto LAB_0001a756;
    LAB_0001a784:
        cgpu->queued_work = pwVar8;
    } else {
        pUVar7 = (cgpu->queued_work->hh).tbl;
        iVar3 = pUVar7->hho;
        if (work == (work *)((int)pUVar7->tail - iVar3)) {
        LAB_0001a756:
            pUVar7->tail = (UT_hash_handle *)(iVar3 + (int)pvVar1);
            pvVar1 = (work->hh).prev;
            if (pvVar1 == (void *)0x0) {
                pwVar8 = (work *)(work->hh).next;
                goto LAB_0001a784;
            }
            iVar3 = ((cgpu->queued_work->hh).tbl)->hho;
        }
        *(void **)((int)pvVar1 + iVar3 + 8) = (work->hh).next;
        pwVar8 = cgpu->queued_work;
    }
    pUVar6 = &work->hh;
    pvVar1 = (work->hh).next;
    pUVar7 = (pwVar8->hh).tbl;
    if (pvVar1 != (void *)0x0) {
        *(void **)((int)pvVar1 + pUVar7->hho + 4) = (work->hh).prev;
        pUVar7 = (cgpu->queued_work->hh).tbl;
    }
    uVar4 = pUVar7->num_buckets - 1 & (work->hh).hashv;
    pUVar7->buckets[uVar4].count = pUVar7->buckets[uVar4].count - 1;
    pUVar2 = ((cgpu->queued_work->hh).tbl)->buckets;
    bVar9 = pUVar2[uVar4].hh_head == pUVar6;
    if (bVar9) {
        pUVar6 = (work->hh).hh_next;
    }
    if (bVar9) {
        pUVar2[uVar4].hh_head = pUVar6;
    }
    pUVar6 = (work->hh).hh_prev;
    pUVar5 = (work->hh).hh_next;
    if (pUVar6 != (UT_hash_handle *)0x0) {
        pUVar6->hh_next = pUVar5;
        pUVar5 = (work->hh).hh_next;
    }
    if (pUVar5 != (UT_hash_handle *)0x0) {
        pUVar5->hh_prev = (work->hh).hh_prev;
    }
    pUVar7 = (cgpu->queued_work->hh).tbl;
    pUVar7->num_items = pUVar7->num_items - 1;
    return;
}

/* WARNING: Unknown calling convention */

void reinit_device(cgpu_info *cgpu)

{
    if (cgpu->deven != DEV_DISABLED) {
        /* WARNING: Could not recover jumptable at 0x0001a7b6. Too many branches
         */
        /* WARNING: Treating indirect jump as call */
        (*cgpu->drv->reinit_device)(cgpu);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void __quit(int status, _Bool clean)

{
    int iVar1;
    pthread_t killall_t;

    iVar1 = pthread_create(&killall_t, (pthread_attr_t *)0x0,
                           (__start_routine *)0x16c6d, (void *)0x0);
    if (iVar1 == 0) {
        if (((clean) && (cgtime(&total_tv_end), opt_realquiet == false)) &&
            (successful_connect != false)) {
            print_summary();
        }
        if (0 < forkpid) {
            kill(forkpid, 0xf);
            forkpid = 0;
        }
        pthread_cancel(killall_t);
        /* WARNING: Subroutine does not return */
        exit(status);
    }
    /* WARNING: Subroutine does not return */
    exit(1);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void kill_work(void)

{
    char tmp42[4096];

    cg_completion_timeout((void *)0x1d5a9, (void *)0x0, 5000);
    builtin_strncpy(tmp42, "Shutdown signal received", 0x18);
    tmp42[0x18] = '.';
    tmp42[0x19] = '\0';
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(0, true);
}

/* WARNING: Unknown calling convention */

void sighandler(int sig)

{
    _Bool _Var1;
    pool *pool;
    char *url;
    int iVar2;
    char *__dest;
    char *url_00;
    char acStack_1020[24];
    undefined2 uStack_1008;
    undefined1 uStack_1006;

    sigaction(0xf, (sigaction *)&termhandler, (sigaction *)0x0);
    sigaction(2, (sigaction *)&inthandler, (sigaction *)0x0);
    kill_work();
    url = get_proxy(url_00, pool);
    _Var1 = detect_stratum(pool, url);
    if (!_Var1) {
        opt_set_charp(url, &pool->rpc_url);
        iVar2 = strncmp(url, "http://", 7);
        if ((iVar2 != 0) && (iVar2 = strncmp(url, "https://", 8), iVar2 != 0)) {
            __dest = (char *)malloc(0x100);
            if (__dest == (char *)0x0) {
                builtin_strncpy(acStack_1020, "Failed to malloc httpinp", 0x18);
                uStack_1008 = 0x7475;
                uStack_1006 = 0;
                _applog(3, acStack_1020, true);
                /* WARNING: Subroutine does not return */
                __quit(1, true);
            }
            builtin_strncpy(__dest, "stratum+tcp://", 0xf);
            strncat(__dest, url, 0xf2);
            detect_stratum(pool, __dest);
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void setup_url(pool *pool, char *arg)

{
    _Bool _Var1;
    char *url;
    int iVar2;
    char *__dest;
    char tmp42[4096];

    url = get_proxy(arg, pool);
    _Var1 = detect_stratum(pool, url);
    if (!_Var1) {
        opt_set_charp(url, &pool->rpc_url);
        iVar2 = strncmp(url, "http://", 7);
        if ((iVar2 != 0) && (iVar2 = strncmp(url, "https://", 8), iVar2 != 0)) {
            __dest = (char *)malloc(0x100);
            if (__dest == (char *)0x0) {
                builtin_strncpy(tmp42, "Failed to malloc httpinp", 0x18);
                tmp42[0x18] = 'u';
                tmp42[0x19] = 't';
                tmp42[0x1a] = '\0';
                _applog(3, tmp42, true);
                /* WARNING: Subroutine does not return */
                __quit(1, true);
            }
            builtin_strncpy(__dest, "stratum+tcp://", 0xf);
            strncat(__dest, url, 0xf2);
            detect_stratum(pool, __dest);
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void get_statline(char *buf, size_t bufsiz, cgpu_info *cgpu)

{
    size_t sVar1;
    size_t sVar2;
    int iVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined4 extraout_s1;
    DFtype a;
    double dVar6;
    UDItype val;
    UDItype val_00;
    char displayed_hashes[16];
    char displayed_rolling[16];
    char tmp13[64];
    char tmp42[4096];

    cgpu_runtime(cgpu);
    uVar5 =
        __aeabi_l2d((int)cgpu->diff1, *(undefined4 *)((int)&cgpu->diff1 + 4));
    val = __fixunsdfdi((DFtype)CONCAT44(extraout_s1, uVar5));
    val_00 = __fixunsdfdi(a);
    suffix_string(val_00, displayed_hashes, 0x10, 4);
    suffix_string(val, displayed_rolling, 0x10, 4);
    snprintf(buf, bufsiz, "%s%d ", cgpu->drv->name, cgpu->device_id);
    (*cgpu->drv->get_statline_before)(buf, bufsiz, cgpu);
    sVar1 = strlen(buf);
    iVar3 = cgpu->hw_errors;
    dVar6 = cgpu->diff_rejected;
    uVar5 = *(undefined4 *)&cgpu->diff_accepted;
    uVar4 = *(undefined4 *)((int)&cgpu->diff_accepted + 4);
    snprintf(tmp13, 0x40,
             "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
             opt_log_interval, displayed_rolling, displayed_hashes, uVar5,
             uVar4, dVar6, iVar3);
    sVar2 = strlen(tmp13);
    if (sVar2 + sVar1 < bufsiz) {
        strcat(buf, tmp13);
        (*cgpu->drv->get_statline)(buf, bufsiz, cgpu);
        return;
    }
    snprintf(tmp42, 0x1000, "tailsprintf buffer overflow in %s %s line %d",
             "cgminer.c", "get_statline", 0xc09, uVar5, uVar4, dVar6, iVar3);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void restart_threads(void)

{
    char tmp42[4096];

    builtin_strncpy(tmp42, "Failed to create restart thread", 0x20);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void restart_threads(void)

{
    int iVar1;
    char *path;
    json_t *config;
    size_t sVar2;
    size_t sVar3;
    char *__s;
    char *__format;
    char *unaff_r5;
    uint unaff_r6;
    int unaff_r8;
    char cVar4;
    char in_OV;
    json_error_t jStack_1124;
    char acStack_1028[4100];
    pthread_t rthread;
    undefined4 uStack_8;

    cgtime(&restart_tv_start);
    cVar4 = '\0';
    iVar1 = pthread_create(&rthread, (pthread_attr_t *)0x0,
                           (__start_routine *)0x208d9, (void *)0x0);
    if (iVar1 == 0) {
        return;
    }
    restart_threads();
    if (cVar4 == in_OV) {
        config = json_load_file(path, 0, &jStack_1124);
        if ((config != (json_t *)0x0) && (config->type == JSON_OBJECT)) {
            config_loaded = true;
            parse_config(config, true);
            return;
        }
        sVar2 = strlen(path);
        sVar3 = strlen(jStack_1124.text);
        sVar2 = sVar2 + sVar3 + 0x23;
        __s = (char *)malloc(sVar2);
        if (__s != (char *)0x0) {
            snprintf(__s, sVar2, "JSON decode of file \'%s\' failed\n %s", path,
                     jStack_1124.text);
            return;
        }
        builtin_strncpy(acStack_1028, "Malloc failure in json error", 0x1c);
        acStack_1028[0x1c] = 0;
        _applog(3, acStack_1028, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    uStack_8 = *(undefined4 *)((int)path * 0x100 + 200);
    snprintf(&stack0x00000038, 0x40, __format);
    sVar2 = strlen(&stack0x00000038);
    if (sVar2 + unaff_r8 < unaff_r6) {
        strcat(unaff_r5, &stack0x00000038);
        (**(code **)(*(int *)((int)path * 0x100 + 4) + 0x18))();
        return;
    }
    rthread = 0xc09;
    snprintf(&stack0x00000078, 0x1000,
             "tailsprintf buffer overflow in %s %s line %d", "cgminer.c");
    _applog(3, &stack0x00000078, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

char *load_config(char *arg, void *unused)

{
    json_t *config;
    size_t sVar1;
    size_t sVar2;
    char *pcVar3;
    json_error_t err;
    char tmp42[4096];

    config = json_load_file(arg, 0, &err);
    if ((config != (json_t *)0x0) && (config->type == JSON_OBJECT)) {
        config_loaded = true;
        pcVar3 = parse_config(config, true);
        return pcVar3;
    }
    sVar1 = strlen(arg);
    sVar2 = strlen(err.text);
    sVar1 = sVar1 + sVar2 + 0x23;
    pcVar3 = (char *)malloc(sVar1);
    if (pcVar3 != (char *)0x0) {
        snprintf(pcVar3, sVar1, "JSON decode of file \'%s\' failed\n %s", arg,
                 err.text);
        return pcVar3;
    }
    builtin_strncpy(tmp42, "Malloc failure in json error", 0x1c);
    tmp42[0x1c] = '\0';
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

char *load_config(char *arg, void *unused)

{
    char *pcVar1;
    undefined8 uVar2;

    uVar2 = CONCAT44(unused, cnfbuf);
    if (cnfbuf == (char *)0x0) {
        uVar2 = __strdup();
    }
    cnfbuf = (char *)uVar2;
    include_count = include_count + 1;
    if (10 < include_count) {
        return "Too many levels of JSON includes (limit 10) or a loop";
    }
    pcVar1 = load_config(arg, (void *)((ulonglong)uVar2 >> 0x20));
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *parse_config(json_t *config, _Bool fileconf)

{
    char *__s;
    char *pcVar1;
    char *pcVar2;
    json_t *pjVar3;
    size_t sVar4;
    json_t *json;
    char *pcVar5;
    int iVar6;
    size_t index;
    int iVar7;
    char tmp42[4096];

    if ((fileconf) && (fileconf_load == 0)) {
        fileconf_load = 1;
    }
    if (opt_config_table[0].type != OPT_END) {
        if (-1 < (int)(opt_config_table[0].type << 0x1c)) {
            iVar7 = 0x6c2d4;
            do {
                if (*(int *)(iVar7 + -0x1c) == 0) {
                    iVar6 = *(int *)(iVar7 + 4);
                } else {
                    __s = (char *)__strdup();
                    pcVar1 = strtok(__s, "|");
                    while (pcVar1 != (char *)0x0) {
                    LAB_0001ac82:
                        if ((pcVar1[1] != '-') ||
                            (pjVar3 = json_object_get(config, pcVar1 + 2),
                             pjVar3 == (json_t *)0x0))
                            goto LAB_0001ac74;
                        if ((*(uint *)(iVar7 + -0x18) & 6) == 0) {
                        LAB_0001acac:
                            if (((int)(*(uint *)(iVar7 + -0x18) << 0x1f) < 0) &&
                                (pjVar3->type == JSON_TRUE)) {
                                pcVar2 = (char *)(**(code **)(iVar7 + -0x14))(
                                    *(undefined4 *)(iVar7 + -8));
                                goto joined_r0x0001acc4;
                            }
                            pcVar2 = "Invalid value";
                        joined_r0x0001ad5e:
                            if (!fileconf) {
                                snprintf(parse_config::err_buf, 200,
                                         "Parsing JSON option %s: %s", pcVar1,
                                         pcVar2);
                                return parse_config::err_buf;
                            }
                            if (((use_syslog != false) ||
                                 (opt_log_output != false)) ||
                                (2 < opt_log_level)) {
                                snprintf(tmp42, 0x1000,
                                         "Invalid config option %s: %s", pcVar1,
                                         pcVar2);
                                _applog(3, tmp42, false);
                            }
                            fileconf_load = -1;
                            pcVar1 = strtok((char *)0x0, "|");
                            if (pcVar1 == (char *)0x0)
                                break;
                            goto LAB_0001ac82;
                        }
                        if (pjVar3->type == JSON_STRING) {
                            pcVar5 = json_string_value(pjVar3);
                            pcVar2 = (char *)(**(code **)(iVar7 + -0x10))(
                                pcVar5, *(undefined4 *)(iVar7 + -8));
                            if (*(int *)(iVar7 + -0x18) == 4) {
                                opt_set_charp(pcVar5, *(char ***)(iVar7 + -8));
                            }
                        joined_r0x0001acc4:
                            if (pcVar2 == (char *)0x0)
                                goto LAB_0001ac74;
                            goto joined_r0x0001ad5e;
                        }
                        if (pjVar3->type != JSON_ARRAY)
                            goto LAB_0001acac;
                        index = 0;
                        sVar4 = json_array_size(pjVar3);
                        if (sVar4 != 0) {
                            do {
                                json = json_array_get(pjVar3, index);
                                if (json == (json_t *)0x0)
                                    break;
                                if (json->type == JSON_STRING) {
                                    pcVar5 = json_string_value(json);
                                    pcVar2 = (char *)(**(code **)(iVar7 +
                                                                  -0x10))(
                                        pcVar5, *(undefined4 *)(iVar7 + -8));
                                    if (*(int *)(iVar7 + -0x18) == 4) {
                                        opt_set_charp(pcVar5,
                                                      *(char ***)(iVar7 + -8));
                                    }
                                joined_r0x0001ae18:
                                    if (pcVar2 != (char *)0x0)
                                        goto joined_r0x0001ad5e;
                                } else if (json->type == JSON_OBJECT) {
                                    pcVar2 = parse_config(json, false);
                                    goto joined_r0x0001ae18;
                                }
                                index = index + 1;
                                sVar4 = json_array_size(pjVar3);
                                if (sVar4 <= index)
                                    break;
                            } while (true);
                        }
                    LAB_0001ac74:
                        pcVar1 = strtok((char *)0x0, "|");
                    }
                    free(__s);
                    iVar6 = *(int *)(iVar7 + 4);
                }
                if (iVar6 == 0x10)
                    goto LAB_0001ad28;
                iVar7 = iVar7 + 0x1c;
            } while (-1 < iVar6 << 0x1c);
        }
        /* WARNING: Subroutine does not return */
        __assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x7a0,
                      "parse_config");
    }
LAB_0001ad28:
    pjVar3 = json_object_get(config, "include");
    if ((pjVar3 != (json_t *)0x0) && (pjVar3->type == JSON_STRING)) {
        pcVar1 = json_string_value(pjVar3);
        pcVar1 = load_config(pcVar1, (void *)0x0);
        return pcVar1;
    }
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

_Bool benchfile_get_work(work *work)

{
    _Bool _Var1;
    FILE *pFVar2;
    FILE *pFVar3;
    char *pcVar4;
    size_t sVar5;
    long lVar6;
    int iVar7;
    uint *puVar8;
    uint uVar9;
    char **ppcVar10;
    char *pcVar11;
    FILE *pFVar12;
    uint uVar13;
    int iVar14;
    char *pcVar15;
    int iVar16;
    int iVar17;
    int iVar18;
    char *commas[5];
    uchar data[64];
    sha256_ctx ctx;
    char buf[1024];
    char item[1024];

    pFVar12 = benchfile_in;
    if (benchfile_in == (FILE *)0x0) {
        if (opt_benchfile == (char *)0x0) {
            builtin_strncpy(item, "BENCHFILE Invalid benchfile NULL", 0x20);
            item[0x20] = '\0';
            _applog(3, item, true);
            /* WARNING: Subroutine does not return */
            __quit(1, true);
        }
        benchfile_in = (FILE *)fopen(opt_benchfile, "r");
        if (benchfile_in == (FILE *)0x0) {
            pcVar11 = "BENCHFILE Failed to open benchfile \'%s\'";
        } else {
            benchfile_line = (int)pFVar12;
            pcVar11 = fgets(buf, 0x400, (FILE *)benchfile_in);
            if (pcVar11 != (char *)0x0)
                goto LAB_0001ae90;
            pcVar11 = "BENCHFILE Failed to read benchfile \'%s\'";
        }
    } else {
        pFVar2 = (FILE *)fgets(buf, 0x400, (FILE *)benchfile_in);
        pFVar3 = pFVar2;
        while (pFVar12 = (FILE *)benchfile_work, pFVar3 != (FILE *)0x0) {
        LAB_0001ae90:
            benchfile_work = (int)pFVar12;
            pcVar11 = buf;
            uVar9 = (uint)(byte)buf[0];
            uVar13 = uVar9 - 0x23;
            if (uVar13 != 0) {
                uVar13 = 1;
            }
            iVar14 = benchfile_line + 1;
            if (uVar9 == 0) {
                uVar13 = 0;
            }
            if (uVar9 == 0x2f) {
                uVar13 = 0;
            } else {
                uVar13 = uVar13 & 1;
            }
            benchfile_line = iVar14;
            if (uVar13 != 0) {
                iVar16 = 0;
                ppcVar10 = commas;
                commas[0] = pcVar11;
                goto LAB_0001af4c;
            }
            pFVar3 = (FILE *)fgets(pcVar11, 0x400, (FILE *)benchfile_in);
            pFVar2 = (FILE *)0x0;
        }
        if (benchfile_work != 0) {
            fclose((FILE *)benchfile_in);
            benchfile_in = pFVar2;
            _Var1 = benchfile_get_work(work);
            return _Var1;
        }
        pcVar11 = "BENCHFILE No work in benchfile \'%s\'";
    }
    snprintf(item, 0x1000, pcVar11, opt_benchfile);
    goto LAB_0001b0f6;
    while (true) {
        pcVar11 = pcVar4 + 1;
        *pcVar4 = '\0';
        ((int *)ppcVar10)[1] = (int)pcVar11;
        iVar16 = iVar17;
        ppcVar10 = (char **)((int *)ppcVar10 + 1);
        if (iVar17 == 4)
            break;
    LAB_0001af4c:
        pcVar4 = strchr(pcVar11, 0x2c);
        iVar17 = iVar16 + 1;
        ((int *)ppcVar10)[1] = (int)pcVar4;
        if (pcVar4 == (char *)0x0) {
            snprintf(item, 0x1000,
                     "BENCHFILE Invalid input file line %d - field count is %d "
                     "but should be %d",
                     iVar14, iVar17, 5);
            goto LAB_0001b0f6;
        }
        iVar18 = benchfile_data[iVar16].length;
        iVar7 = iVar18 - ((int)pcVar4 - (int)*ppcVar10);
        if (iVar7 != 0) {
            iVar7 = 1;
        }
        if (iVar18 == 0) {
            iVar7 = 0;
        }
        if (iVar7 != 0) {
            snprintf(item, 0x1000,
                     "BENCHFILE Invalid input file line %d field %d (%s) "
                     "length is %d but should be %d",
                     iVar14, iVar17, benchfile_data[iVar16].name,
                     (int)pcVar4 - (int)*ppcVar10, iVar18);
            goto LAB_0001b0f6;
        }
    }
    sVar5 = strlen(commas[4]);
    if (9 < sVar5) {
        sprintf(item, "0000000%c", (uint)(byte)*commas[0]);
        sVar5 = strlen(item);
        pcVar4 = item + sVar5;
        pcVar11 = commas[2] + 0x38;
        do {
            pcVar15 = pcVar11 + -8;
            sprintf(pcVar4, "%.8s", pcVar11);
            pcVar4 = pcVar4 + 8;
            pcVar11 = pcVar15;
        } while (commas[2] + -8 != pcVar15);
        pcVar4 = item + sVar5 + 0x40;
        pcVar11 = commas[1] + 0x38;
        do {
            pcVar15 = pcVar11 + -8;
            sprintf(pcVar4, "%.8s", pcVar11);
            pcVar4 = pcVar4 + 8;
            pcVar11 = pcVar15;
        } while (commas[1] + -8 != pcVar15);
        lVar6 = strtol(commas[4], (char **)0x0, 10);
        sprintf(item + sVar5 + 0x80, "%08lx", lVar6);
        strcpy(item + sVar5 + 0x88, commas[3]);
        memset(work, 0, 0x7b0);
        hex2bin(work->data, item, (int)(sVar5 + 0x90) >> 1);
        puVar8 = (uint *)&work[-1].field_0x7ac;
        ppcVar10 = commas + 4;
        do {
            puVar8 = puVar8 + 1;
            uVar9 = *puVar8;
            ppcVar10 = ppcVar10 + 1;
            *ppcVar10 = (char *)(uVar9 << 0x18 | (uVar9 >> 8 & 0xff) << 0x10 |
                                 (uVar9 >> 0x10 & 0xff) << 8 | uVar9 >> 0x18);
        } while ((char **)(data + 0x3c) != ppcVar10);
        sha256_init(&ctx);
        sha256_update(&ctx, data, 0x40);
        benchfile_work = benchfile_work + 1;
        *(uint32_t *)work->midstate = ctx.h[0];
        *(uint32_t *)(work->midstate + 4) = ctx.h[1];
        *(uint32_t *)(work->midstate + 8) = ctx.h[2];
        *(uint32_t *)(work->midstate + 0xc) = ctx.h[3];
        *(uint32_t *)(work->midstate + 0x10) = ctx.h[4];
        *(uint32_t *)(work->midstate + 0x14) = ctx.h[5];
        *(uint32_t *)(work->midstate + 0x18) = ctx.h[6];
        *(uint32_t *)(work->midstate + 0x1c) = ctx.h[7];
        return SUB41(uVar13, 0);
    }
    snprintf(item, 0x1000,
             "BENCHFILE Invalid input file line %d field %d (%s) length is %d "
             "but should be least %d",
             iVar14, 5, "NonceTime", sVar5, 10);
LAB_0001b0f6:
    _applog(3, item, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void _mutex_init(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000,
             "Failed to pthread_mutex_init errno=%d in %s %s():%d", *piVar1,
             "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void _mutex_init(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int iVar1;
    undefined4 extraout_r0;
    int *piVar2;
    undefined4 extraout_r1;
    char *func_00;
    int line_00;
    char acStack_1018[4100];
    undefined4 uStack_14;
    int iStack_10;

    iStack_10 = line;
    iVar1 =
        pthread_mutex_init((pthread_mutex_t *)lock, (pthread_mutexattr_t *)0x0);
    if (iVar1 == 0) {
        return;
    }
    _mutex_init((pthread_mutex_t *)file, func, func_00, line_00);
    uStack_14 = 0x1b235;
    piVar2 = __errno_location();
    snprintf(acStack_1018, 0x1000,
             "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *piVar2,
             "cgminer.c", extraout_r0, extraout_r1);
    _applog(3, acStack_1018, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void _rwlock_init(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000,
             "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *piVar1,
             "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void _rwlock_init(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int iVar1;
    char *func_00;
    int line_00;

    iVar1 = pthread_rwlock_init((pthread_rwlock_t *)lock,
                                (pthread_rwlockattr_t *)0x0);
    if (iVar1 == 0) {
        return;
    }
    /* WARNING: Subroutine does not return */
    _rwlock_init((pthread_rwlock_t *)file, func, func_00, line_00);
}

void _cglock_init(cglock_t *lock, char *file, char *func, int line)

{
    int iVar1;
    int iVar2;
    char *func_00;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_01;
    int line_00;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 =
        pthread_mutex_init((pthread_mutex_t *)lock, (pthread_mutexattr_t *)0x0);
    if (iVar1 == 0) {
        iVar2 = pthread_rwlock_init((pthread_rwlock_t *)&lock->rwlock,
                                    (pthread_rwlockattr_t *)0x0);
        func_01 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            return;
        }
    } else {
        _mutex_init((pthread_mutex_t *)file, func, func_00, line_00);
        func_01 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rwlock_init((pthread_rwlock_t *)file, func, func_01, iVar1);
}

void _wr_lock(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar1, "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void _mutex_lock(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar1, "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void _mutex_unlock_noyield(pthread_mutex_t *lock, char *file, char *func,
                           int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
             *piVar1, "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

_Bool pool_tset(pool *pool, _Bool *var)

{
    _Bool _Var1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&pool->pool_lock);
    if (iVar2 == 0) {
        _Var1 = *var;
        *var = true;
        iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&pool->pool_lock);
        func_00 = extraout_r2;
        iVar2 = extraout_r3;
        if (iVar3 == 0) {
            (*selective_yield)();
            return _Var1;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"pool_tset", (char *)0x304, func, line);
        func_00 = extraout_r2_00;
        iVar2 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"pool_tset", (char *)0x307,
                          func_00, iVar2);
}

/* WARNING: Unknown calling convention */

_Bool pool_tclear(pool *pool, _Bool *var)

{
    _Bool _Var1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&pool->pool_lock);
    if (iVar2 == 0) {
        _Var1 = *var;
        *var = false;
        iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&pool->pool_lock);
        func_00 = extraout_r2;
        iVar2 = extraout_r3;
        if (iVar3 == 0) {
            (*selective_yield)();
            return _Var1;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"pool_tclear", (char *)0x310, func,
                    line);
        func_00 = extraout_r2_00;
        iVar2 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"pool_tclear", (char *)0x313,
                          func_00, iVar2);
}

/* WARNING: Unknown calling convention */

_Bool pool_active(pool *pool, _Bool pinging)

{
    undefined4 uVar1;
    _Bool _Var2;
    _Bool _Var3;
    int iVar4;
    char *pcVar5;
    timeval tv_getwork;
    timeval tv_getwork_reply;
    char tmp42[4096];

    if (pool->has_gbt == false) {
        if ((opt_debug) &&
            (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
            pcVar5 = "Testing pool %s";
            goto LAB_0001b7bc;
        }
    } else if ((opt_debug) &&
               (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        pcVar5 = "Retrieving block template from pool %s";
    LAB_0001b7bc:
        snprintf(tmp42, 0x1000, pcVar5, pool->rpc_url);
        _applog(7, tmp42, false);
    }
    uVar1 = tmp42._24_4_;
    if (pool->has_stratum != false)
        goto LAB_0001b556;
    if (curly == (char *)0x0) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return false;
        }
        builtin_strncpy(tmp42, "CURL initialisation failed", 0x1b);
        tmp42[0x1b] = SUB41(uVar1, 3);
        _applog(3, tmp42, false);
        return false;
    }
    if (pool->probed == false) {
        if (opt_debug == false) {
            pool->probed = false;
        } else if (((use_syslog == false) && (opt_log_output == false)) &&
                   (opt_log_level < 7)) {
            pool->probed = false;
            if (pool->has_gbt == false) {
                if (pool->gbt_solo == false) {
                joined_r0x0001b7e0:
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (6 < opt_log_level)) {
                        pcVar5 = "No GBT coinbase + append support found, "
                                 "using getwork protocol";
                        goto LAB_0001b4ea;
                    }
                } else {
                LAB_0001b6f2:
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (6 < opt_log_level)) {
                        memcpy(tmp42,
                               "GBT coinbase without append found, switching "
                               "to GBT solo protocol",
                               0x42);
                        _applog(7, tmp42, false);
                    }
                }
            } else {
            LAB_0001b4ca:
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (6 < opt_log_level)) {
                    pcVar5 = "GBT coinbase + append support found, switching "
                             "to GBT protocol";
                LAB_0001b4ea:
                    tmp42._0_4_ = *(undefined4 *)pcVar5;
                    tmp42._4_4_ = *(undefined4 *)(pcVar5 + 4);
                    tmp42._8_4_ = *(undefined4 *)(pcVar5 + 8);
                    tmp42._12_4_ = *(undefined4 *)(pcVar5 + 0xc);
                    tmp42._16_4_ = *(undefined4 *)(pcVar5 + 0x10);
                    tmp42._20_4_ = *(undefined4 *)(pcVar5 + 0x14);
                    tmp42._24_4_ = *(undefined4 *)(pcVar5 + 0x18);
                    tmp42._28_4_ = *(undefined4 *)(pcVar5 + 0x1c);
                    tmp42._32_4_ = *(undefined4 *)(pcVar5 + 0x20);
                    tmp42._36_4_ = *(undefined4 *)(pcVar5 + 0x24);
                    tmp42._40_4_ = *(undefined4 *)(pcVar5 + 0x28);
                    tmp42._44_4_ = *(undefined4 *)(pcVar5 + 0x2c);
                    tmp42._48_4_ = *(undefined4 *)(pcVar5 + 0x30);
                    tmp42._52_4_ = *(undefined4 *)(pcVar5 + 0x34);
                    tmp42._56_4_ = *(undefined4 *)(pcVar5 + 0x38);
                    tmp42._60_2_ = (undefined2) * (undefined4 *)(pcVar5 + 0x3c);
                    tmp42[0x3e] =
                        (char)((uint) * (undefined4 *)(pcVar5 + 0x3c) >> 0x10);
                    _applog(7, tmp42, false);
                }
            }
        } else {
            builtin_strncpy(tmp42, "Probing for GBT support", 0x18);
            _applog(7, tmp42, false);
            pool->probed = false;
            if (pool->has_gbt == false) {
                if (pool->gbt_solo == false) {
                    if (opt_debug != false)
                        goto joined_r0x0001b7e0;
                } else if (opt_debug != false)
                    goto LAB_0001b6f2;
            } else if (opt_debug != false)
                goto LAB_0001b4ca;
        }
    }
    cgtime(&tv_getwork);
    cgtime(&tv_getwork_reply);
    pcVar5 = pool->stratum_url;
    if ((pcVar5 == (char *)0x0) || (opt_fix_protocol != false)) {
    LAB_0001b544:
        _Var2 = initiate_stratum(pool);
        if (!_Var2) {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000,
                         "FAILED to retrieve work from pool %u %s",
                         pool->pool_no, pool->rpc_url);
                _applog(7, tmp42, false);
            }
            if (pinging) {
                return false;
            }
            if (pool->idle != false) {
                return false;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 4)) {
                return false;
            }
            snprintf(tmp42, 0x1000,
                     "Pool %u slow/down or URL or credentials invalid",
                     pool->pool_no);
            _applog(4, tmp42, false);
            return false;
        }
    } else {
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "Testing pool %d stratum %s", pool->pool_no,
                     pcVar5);
            _applog(7, tmp42, false);
            pcVar5 = pool->stratum_url;
        }
        check_extranonce_option(pool, pcVar5);
        _Var2 = extract_sockaddr(pool->stratum_url, &pool->sockaddr_url,
                                 &pool->stratum_port);
        if ((!_Var2) || (_Var2 = initiate_stratum(pool), !_Var2))
            goto LAB_0001b544;
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "Switching pool %d %s to %s", pool->pool_no,
                     pool->rpc_url, pool->stratum_url);
            _applog(7, tmp42, false);
        }
        if (pool->rpc_url == (char *)0x0) {
            pcVar5 = (char *)__strdup(pool->stratum_url);
            pool->rpc_url = pcVar5;
        }
    }
    pool->has_stratum = true;
LAB_0001b556:
    _Var2 = pool_tset(pool, &pool->stratum_init);
    if (_Var2) {
        return pool->stratum_active;
    }
    _Var3 = initiate_stratum(pool);
    if ((_Var3) && (_Var3 = auth_stratum(pool), _Var3)) {
        extranonce_subscribe_stratum(pool);
        have_longpoll = true;
        iVar4 = pthread_create(&pool->stratum_sthread, (pthread_attr_t *)0x0,
                               (__start_routine *)0x209c9, pool);
        if (iVar4 == 0) {
            iVar4 =
                pthread_create(&pool->stratum_rthread, (pthread_attr_t *)0x0,
                               (__start_routine *)0x248ed, pool);
            if (iVar4 == 0) {
                return _Var3;
            }
            pcVar5 = "Failed to create stratum rthread";
        } else {
            pcVar5 = "Failed to create stratum sthread";
        }
        tmp42._0_4_ = *(undefined4 *)pcVar5;
        tmp42._4_4_ = *(undefined4 *)(pcVar5 + 4);
        tmp42._8_4_ = *(undefined4 *)(pcVar5 + 8);
        tmp42._12_4_ = *(undefined4 *)(pcVar5 + 0xc);
        tmp42._16_4_ = *(undefined4 *)(pcVar5 + 0x10);
        tmp42._20_4_ = *(undefined4 *)(pcVar5 + 0x14);
        tmp42._24_4_ = *(undefined4 *)(pcVar5 + 0x18);
        tmp42._28_4_ = *(undefined4 *)(pcVar5 + 0x1c);
        tmp42[0x20] = (char)*(undefined4 *)(pcVar5 + 0x20);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    extranonce_subscribe_stratum(pool);
    pool_tclear(pool, &pool->stratum_init);
    return _Var2;
}

/* WARNING: Unknown calling convention */

void inc_dev_status(int max_fan, int max_temp)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
    if (iVar1 == 0) {
        g_max_fan = max_fan;
        g_max_temp = max_temp;
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            /* WARNING: Could not recover jumptable at 0x0001b998. Too many
             * branches */
            /* WARNING: Treating indirect jump as call */
            (*selective_yield)();
            return;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"inc_dev_status", (char *)0x2081, func,
                    line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"inc_dev_status", (char *)0x2084,
                          func_00, iVar1);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void wake_gws(void)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)stgd_lock);
    if (iVar1 == 0) {
        pthread_cond_signal((pthread_cond_t *)&gws_cond);
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            /* WARNING: Could not recover jumptable at 0x0001b9ec. Too many
             * branches */
            /* WARNING: Treating indirect jump as call */
            (*selective_yield)();
            return;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"wake_gws", (char *)0x1454, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"wake_gws", (char *)0x1456,
                          func_00, iVar1);
}

/* WARNING: Unknown calling convention */

int restart_wait(thr_info *thr, uint mstime)

{
    int iVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    timeval now;
    timespec abstime;

    cgtime(&now);
    abstime.tv_sec = mstime / 1000 + now.tv_sec;
    iVar3 = mstime * 1000 + (mstime / 1000) * -1000000 + now.tv_usec;
    if (999999 < iVar3) {
        abstime.tv_sec = abstime.tv_sec + 1;
        iVar3 = iVar3 + -1000000;
    }
    abstime.tv_nsec = iVar3 * 1000;
    iVar3 = pthread_mutex_lock((pthread_mutex_t *)&restart_lock);
    if (iVar3 == 0) {
        iVar1 = 0;
        if (thr->work_restart == false) {
            iVar1 = pthread_cond_timedwait((pthread_cond_t *)&restart_cond,
                                           (pthread_mutex_t *)&restart_lock,
                                           (timespec *)&abstime);
        }
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&restart_lock);
        func_00 = extraout_r2;
        iVar3 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            return iVar1;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"restart_wait", (char *)0x1481, func,
                    line);
        func_00 = extraout_r2_00;
        iVar3 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"restart_wait", (char *)0x1486,
                          func_00, iVar3);
}

void _rw_unlock(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000,
             "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar1,
             "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

int total_work_inc(void)

{
    uint32_t uVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    char *extraout_r2_01;
    char *extraout_r2_02;
    char *pcVar4;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    int line_00;
    int extraout_r3_01;
    int extraout_r3_02;

    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
    if (iVar2 == 0) {
        iVar3 = pthread_rwlock_wrlock((pthread_rwlock_t *)&control_lock.rwlock);
        uVar1 = total_work;
        pcVar4 = extraout_r2;
        iVar2 = extraout_r3;
        if (iVar3 == 0) {
            total_work = total_work + 1;
            iVar3 =
                pthread_rwlock_unlock((pthread_rwlock_t *)&control_lock.rwlock);
            pcVar4 = extraout_r2_00;
            iVar2 = extraout_r3_00;
            if (iVar3 == 0) {
                iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
                if (iVar2 == 0) {
                    (*selective_yield)();
                    return uVar1;
                }
                /* WARNING: Subroutine does not return */
                _mutex_unlock_noyield((pthread_mutex_t *)"total_work_inc",
                                      (char *)0x8e3, func_00, line_00);
            }
            goto LAB_0001bb70;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"total_work_inc", (char *)0x8e1, func,
                    line);
        pcVar4 = extraout_r2_01;
        iVar2 = extraout_r3_01;
    }
    _wr_lock((pthread_rwlock_t *)"total_work_inc", (char *)0x8e1, pcVar4,
             iVar2);
    pcVar4 = extraout_r2_02;
    iVar2 = extraout_r3_02;
LAB_0001bb70:
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"total_work_inc", (char *)0x8e3, pcVar4,
               iVar2);
}

/* WARNING: Unknown calling convention */

void roll_work(work *work)

{
    _Bool _Var1;
    int iVar2;
    uint32_t uVar3;
    uint uVar4;
    char *hexstr;
    char tmp42[4096];

    _Var1 = opt_debug;
    uVar4 = *(uint *)(work->data + 0x44);
    iVar2 = work->rolls;
    uVar4 = (uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10 |
             (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18) +
            1;
    local_work = local_work + 1;
    *(uint *)(work->data + 0x44) = uVar4 * 0x1000000 |
                                   (uVar4 >> 8 & 0xff) << 0x10 |
                                   (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
    work->rolls = iVar2 + 1;
    work->nonce = 0;
    if ((_Var1) && (((use_syslog != false || (opt_log_output != false)) ||
                     (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Successfully rolled work", 0x18);
        tmp42[0x18] = '\0';
        _applog(7, tmp42, false);
    }
    hexstr = work->ntime;
    if (hexstr != (char *)0x0) {
        hex2bin((uchar *)tmp42, hexstr, 4);
        uVar4 = (tmp42._0_4_ << 0x18 | ((uint)tmp42._0_4_ >> 8 & 0xff) << 0x10 |
                 ((uint)tmp42._0_4_ >> 0x10 & 0xff) << 8 |
                 (uint)tmp42._0_4_ >> 0x18) +
                1;
        tmp42._0_4_ = uVar4 * 0x1000000 | (uVar4 >> 8 & 0xff) << 0x10 |
                      (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
        __bin2hex(hexstr, (uchar *)tmp42, 4);
    }
    uVar3 = total_work_inc();
    work->id = uVar3;
    return;
}

/* WARNING: Unknown calling convention */

work *make_work(void)

{
    work *pwVar1;
    uint32_t uVar2;
    char tmp42[4096];

    pwVar1 = (work *)calloc(1, 0x7b0);
    if (pwVar1 != (work *)0x0) {
        uVar2 = total_work_inc();
        pwVar1->id = uVar2;
        return pwVar1;
    }
    builtin_strncpy(tmp42, "Failed to calloc work in make_wo", 0x20);
    tmp42[0x20] = 'r';
    tmp42[0x21] = 'k';
    tmp42[0x22] = '\0';
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

work *copy_work_noffset(work *base_work, int noffset)

{
    work *work;

    work = make_work();
    _copy_work(work, base_work, noffset);
    return work;
}

/* WARNING: Unknown calling convention */

work *make_clone(work *work)

{
    work *work_00;
    int iVar1;

    work_00 = make_work();
    _copy_work(work_00, work, 0);
    work_00->clone = true;
    cgtime(&work_00->tv_cloned);
    iVar1 = (work_00->tv_staged).tv_sec;
    work_00->longpoll = false;
    work_00->mandatory = false;
    (work_00->tv_staged).tv_sec = iVar1 + -1;
    return work_00;
}

/* WARNING: Unknown calling convention */

void add_queued(cgpu_info *cgpu, work *work)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        __add_queued(cgpu, work);
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            /* WARNING: Could not recover jumptable at 0x0001bd1c. Too many
             * branches */
            /* WARNING: Treating indirect jump as call */
            (*selective_yield)();
            return;
        }
    } else {
        _wr_lock((pthread_rwlock_t *)"add_queued", (char *)0x2279, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"add_queued", (char *)0x227b, func_00,
               iVar1);
}

/* WARNING: Unknown calling convention */

void work_completed(cgpu_info *cgpu, work *work)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        __work_completed(cgpu, work);
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            clean_work(work);
            (*(code *)(undefined *)0x0)(work);
            return;
        }
    } else {
        _wr_lock((pthread_rwlock_t *)"work_completed", (char *)0x2309, func,
                 line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"work_completed", (char *)0x230b, func_00,
               iVar1);
}

/* WARNING: Unknown calling convention */

work *take_queued_work_bymidstate(cgpu_info *cgpu, char *midstate,
                                  size_t midstatelen, char *data, int offset,
                                  size_t datalen)

{
    int iVar1;
    work *work;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        work = __find_work_bymidstate(cgpu->queued_work, midstate, midstatelen,
                                      data, offset, datalen);
        if (work != (work *)0x0) {
            __work_completed(cgpu, work);
        }
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            return work;
        }
    } else {
        _wr_lock((pthread_rwlock_t *)"take_queued_work_bymidstate",
                 (char *)0x2316, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"take_queued_work_bymidstate",
               (char *)0x231a, func_00, iVar1);
}

int age_queued_work(cgpu_info *cgpu, double secs)

{
    work *pwVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    work *pwVar4;
    work *work;
    int iVar5;
    double dVar6;
    timeval tv_now;

    cgtime(&tv_now);
    iVar2 = pthread_rwlock_wrlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar2 == 0) {
        work = cgpu->queued_work;
        iVar5 = 0;
        if (work != (work *)0x0) {
            pwVar1 = (work *)(work->hh).next;
            while (true) {
                pwVar4 = pwVar1;
                dVar6 = tdiff(&tv_now, &work->tv_work_start);
                if (secs < dVar6) {
                    __work_completed(cgpu, work);
                    iVar5 = iVar5 + 1;
                    clean_work(work);
                    free(work);
                }
                if (pwVar4 == (work *)0x0)
                    break;
                pwVar1 = (work *)(pwVar4->hh).next;
                work = pwVar4;
            }
        }
        iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar2 = extraout_r3;
        if (iVar3 == 0) {
            (*selective_yield)();
            return iVar5;
        }
    } else {
        _wr_lock((pthread_rwlock_t *)"age_queued_work", (char *)0x22f6, func,
                 line);
        func_00 = extraout_r2_00;
        iVar2 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"age_queued_work", (char *)0x2300, func_00,
               iVar2);
}

/* WARNING: Unknown calling convention */

void flush_queue(cgpu_info *cgpu)

{
    int iVar1;
    cgpu_info *cgpu_00;
    char *func;
    int ret;
    int line;
    work *work;

    if (cgpu == (cgpu_info *)0x0) {
        return;
    }
    iVar1 = pthread_rwlock_trywrlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        work = cgpu->unqueued_work;
        cgpu->unqueued_work = (work *)0x0;
        iVar1 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        if (iVar1 != 0) {
            /* WARNING: Subroutine does not return */
            _rw_unlock((pthread_rwlock_t *)"flush_queue", (char *)0x232c, func,
                       line);
        }
        (*selective_yield)();
        if (work != (work *)0x0) {
            clean_work(work);
            free(work);
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                flush_queue(cgpu_00);
                return;
            }
        }
    }
    return;
}

void _rd_lock(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar1, "cgminer.c", lock, file);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

work *clone_queued_work_byid(cgpu_info *cgpu, uint32_t id)

{
    work *pwVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    work *base_work;
    work *work;

    iVar2 = pthread_rwlock_rdlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar2 != 0) {
        _rd_lock((pthread_rwlock_t *)"clone_queued_work_byid", (char *)0x22dc,
                 func, line);
        func_00 = extraout_r2_00;
        iVar2 = extraout_r3_00;
        goto LAB_0001bfe8;
    }
    base_work = cgpu->queued_work;
    work = base_work;
    if (base_work != (work *)0x0) {
        work = (work *)(base_work->hh).next;
        if (id != base_work->id) {
            if (work == (work *)0x0)
                goto LAB_0001bfb4;
            pwVar1 = (work *)(work->hh).next;
            base_work = work;
            while (work = pwVar1, id != base_work->id) {
                if (work == (work *)0x0)
                    goto LAB_0001bfb4;
                pwVar1 = (work *)(work->hh).next;
                base_work = work;
            }
        }
        work = make_work();
        _copy_work(work, base_work, 0);
    }
LAB_0001bfb4:
    iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
    func_00 = extraout_r2;
    iVar2 = extraout_r3;
    if (iVar3 == 0) {
        (*selective_yield)();
        return work;
    }
LAB_0001bfe8:
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"clone_queued_work_byid", (char *)0x22e0,
               func_00, iVar2);
}

/* WARNING: Unknown calling convention */

work *clone_queued_work_bymidstate(cgpu_info *cgpu, char *midstate,
                                   size_t midstatelen, char *data, int offset,
                                   size_t datalen)

{
    int iVar1;
    work *base_work;
    work *work;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        base_work = __find_work_bymidstate(cgpu->queued_work, midstate,
                                           midstatelen, data, offset, datalen);
        if (base_work == (work *)0x0) {
            work = (work *)0x0;
        } else {
            work = make_work();
            _copy_work(work, base_work, 0);
        }
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            return work;
        }
    } else {
        _rd_lock((pthread_rwlock_t *)"clone_queued_work_bymidstate",
                 (char *)0x22b0, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"clone_queued_work_bymidstate",
               (char *)0x22b4, func_00, iVar1);
}

/* WARNING: Unknown calling convention */

work *find_queued_work_byid(cgpu_info *cgpu, uint32_t id)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    work *pwVar3;
    int extraout_r3;
    int extraout_r3_00;
    work *pwVar4;

    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        pwVar4 = cgpu->queued_work;
        if (((pwVar4 != (work *)0x0) &&
             (pwVar3 = (work *)(pwVar4->hh).next, id != pwVar4->id)) &&
            (pwVar4 = pwVar3, pwVar3 != (work *)0x0)) {
            for (pwVar3 = (work *)(pwVar3->hh).next;
                 (id != pwVar4->id && (pwVar4 = pwVar3, pwVar3 != (work *)0x0));
                 pwVar3 = (work *)(pwVar3->hh).next) {
            }
        }
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            return pwVar4;
        }
    } else {
        _rd_lock((pthread_rwlock_t *)"find_queued_work_byid", (char *)0x22d1,
                 func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"find_queued_work_byid", (char *)0x22d3,
               func_00, iVar1);
}

/* WARNING: Unknown calling convention */

work *find_queued_work_bymidstate(cgpu_info *cgpu, char *midstate,
                                  size_t midstatelen, char *data, int offset,
                                  size_t datalen)

{
    int iVar1;
    work *pwVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        pwVar2 = __find_work_bymidstate(cgpu->queued_work, midstate,
                                        midstatelen, data, offset, datalen);
        iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar3 == 0) {
            (*selective_yield)();
            return pwVar2;
        }
    } else {
        _rd_lock((pthread_rwlock_t *)"find_queued_work_bymidstate",
                 (char *)0x22a5, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"find_queued_work_bymidstate",
               (char *)0x22a7, func_00, iVar1);
}

/* WARNING: Unknown calling convention */

cgpu_info *get_devices(int id)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    cgpu_info *pcVar3;

    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)&devices_lock);
    if (iVar1 == 0) {
        pcVar3 = devices[id];
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&devices_lock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            return pcVar3;
        }
    } else {
        _rd_lock((pthread_rwlock_t *)"get_devices", (char *)0x278, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"get_devices", &DAT_0000027a, func_00,
               iVar1);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void zero_stats(void)

{
    cgpu_info *pcVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    double *pdVar4;
    pool *ppVar6;
    int extraout_r3;
    int extraout_r3_00;
    int id;
    pool **pppVar7;
    pool **pppVar9;
    double *pdVar5;
    pool **pppVar8;

    cgtime(&total_tv_start);
    copy_time(&tv_hashmeter, &total_tv_start);
    total_rolling._0_4_ = 0;
    total_rolling._4_4_ = 0;
    rolling1._0_4_ = 0;
    rolling1._4_4_ = 0;
    rolling5._0_4_ = 0;
    rolling5._4_4_ = 0;
    rolling15._0_4_ = 0;
    rolling15._4_4_ = 0;
    total_mhashes_done._0_4_ = 0;
    total_mhashes_done._4_4_ = 0;
    pdVar4 = g_local_mhashes_dones;
    do {
        pdVar5 = pdVar4 + 1;
        *(int *)pdVar4 = 0;
        *(int *)((int)pdVar4 + 4) = 0;
        pdVar4 = pdVar5;
    } while (pdVar5 != (double *)&g_local_mhashes_index);
    total_secs._0_4_ = 0;
    total_secs._4_4_ = 0x3ff00000;
    zero_stats_flag = true;
    g_local_mhashes_index = 0;
    hw_errors = 0;
    local_work = 0;
    found_blocks = 0;
    last_total_secs._0_4_ = 0;
    last_total_secs._4_4_ = 0x3ff00000;
    total_getworks._0_4_ = 0;
    total_getworks._4_4_ = 0;
    total_accepted._0_4_ = 0;
    total_accepted._4_4_ = 0;
    total_rejected._0_4_ = 0;
    total_rejected._4_4_ = 0;
    g_max_fan = 0;
    g_max_temp = 0;
    total_stale._0_4_ = 0;
    total_stale._4_4_ = 0;
    total_discarded._0_4_ = 0;
    total_discarded._4_4_ = 0;
    total_diff1._0_4_ = 0;
    total_diff1._4_4_ = 0;
    total_go = 0;
    total_ro = 0;
    total_diff_accepted._0_4_ = 0;
    total_diff_accepted._4_4_ = 0;
    total_diff_rejected._0_4_ = 0;
    total_diff_rejected._4_4_ = 0;
    total_diff_stale._0_4_ = 0;
    total_diff_stale._4_4_ = 0;
    if (0 < total_pools) {
        pppVar9 = pools + total_pools;
        pppVar7 = pools;
        do {
            pppVar8 = pppVar7 + 1;
            ppVar6 = *pppVar7;
            ppVar6->getwork_requested = 0;
            *(undefined4 *)&ppVar6->accepted = 0;
            *(undefined4 *)((int)&ppVar6->accepted + 4) = 0;
            *(undefined4 *)&ppVar6->rejected = 0;
            *(undefined4 *)((int)&ppVar6->rejected + 4) = 0;
            ppVar6->stale_shares = 0;
            ppVar6->discarded_work = 0;
            ppVar6->getfail_occasions = 0;
            ppVar6->remotefail_occasions = 0;
            ppVar6->last_share_time = 0;
            *(undefined4 *)&ppVar6->diff1 = 0;
            *(undefined4 *)((int)&ppVar6->diff1 + 4) = 0;
            *(undefined4 *)&ppVar6->diff_accepted = 0;
            *(undefined4 *)((int)&ppVar6->diff_accepted + 4) = 0;
            *(undefined4 *)&ppVar6->diff_rejected = 0;
            *(undefined4 *)((int)&ppVar6->diff_rejected + 4) = 0;
            *(undefined4 *)&ppVar6->diff_stale = 0;
            *(undefined4 *)((int)&ppVar6->diff_stale + 4) = 0;
            *(undefined4 *)&ppVar6->last_share_diff = 0;
            *(undefined4 *)((int)&ppVar6->last_share_diff + 4) = 0;
            pppVar7 = pppVar8;
        } while (pppVar9 != pppVar8);
    }
    zero_bestshare();
    if (0 < total_devices) {
        id = 0;
        do {
            pcVar1 = get_devices(id);
            copy_time(&pcVar1->dev_start_tv, &total_tv_start);
            iVar2 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
            if (iVar2 != 0) {
                _mutex_lock((pthread_mutex_t *)"zero_stats", (char *)0x16f2,
                            func, iVar2);
                func_00 = extraout_r2_00;
                iVar2 = extraout_r3_00;
            LAB_0001c3fa:
                /* WARNING: Subroutine does not return */
                _mutex_unlock_noyield((pthread_mutex_t *)"zero_stats",
                                      (char *)0x16fd, func_00, iVar2);
            }
            pcVar1->accepted = 0;
            pcVar1->total_mhashes = 0.0;
            pcVar1->rejected = 0;
            pcVar1->hw_errors = 0;
            pcVar1->utility = 0.0;
            pcVar1->last_share_pool_time = 0;
            pcVar1->diff_accepted = 0.0;
            pcVar1->diff_rejected = 0.0;
            pcVar1->last_share_diff = 0.0;
            *(undefined4 *)&pcVar1->diff1 = 0;
            *(undefined4 *)((int)&pcVar1->diff1 + 4) = 0;
            iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
            func_00 = extraout_r2;
            iVar2 = extraout_r3;
            if (iVar3 != 0)
                goto LAB_0001c3fa;
            id = id + 1;
            (*selective_yield)();
            (*pcVar1->drv->zero_stats)(pcVar1);
        } while (id < total_devices);
    }
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void print_summary(void)

{
    cgpu_info *cgpu;
    int iVar1;
    char *pcVar2;
    int iVar3;
    double *pdVar4;
    int iVar5;
    uint uVar6;
    _Bool *p_Var7;
    int iVar8;
    pool *ppVar9;
    uint uVar10;
    double dVar11;
    double dVar12;
    double dVar13;
    double dVar14;
    char logline[255];
    char tmp42[4096];

    dVar14 = total_secs;
    iVar8 = total_tv_end.tv_sec - total_tv_start.tv_sec;
    if (total_tv_end.tv_usec - total_tv_start.tv_usec < 0) {
        iVar8 = iVar8 + -1;
    }
    dVar11 = (double)__aeabi_l2d((uint)total_accepted, total_accepted._4_4_,
                                 (iVar8 % 0xe10) * -0x77777777);
    dVar12 = (double)__aeabi_l2d((undefined4)total_diff1, total_diff1._4_4_);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 4)) {
        if (opt_log_level < 4)
            goto LAB_0001d01a;
    LAB_0001c53e:
        snprintf(tmp42, 0x1000, "Started at %s", datestamp);
        _applog(4, tmp42, false);
        if (total_pools == 1) {
            if ((use_syslog == false) && (opt_log_output == false))
                goto LAB_0001d10c;
            goto LAB_0001d116;
        }
    LAB_0001c56e:
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d036;
    LAB_0001c582:
        snprintf(tmp42, 0x1000, "Runtime: %d hrs : %d mins : %d secs",
                 iVar8 / 0xe10, (iVar8 % 0xe10) / 0x3c, iVar8 % 0x3c);
        _applog(4, tmp42, false);
        pdVar4 = &total_mhashes_done;
        dVar13 = total_mhashes_done / total_secs;
        if ((use_syslog == false) &&
            (pdVar4 = (double *)(uint)opt_log_output, pdVar4 == (double *)0x0))
            goto LAB_0001d052;
    LAB_0001c5d0:
        snprintf(tmp42, 0x1000, "Average hashrate: %.1f Mhash/s", pdVar4,
                 dVar13);
        _applog(4, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d2a8;
    LAB_0001c604:
        snprintf(tmp42, 0x1000, "Solved blocks: %d", found_blocks);
        _applog(4, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d2b4;
    LAB_0001c63e:
        snprintf(tmp42, 0x1000, "Best share difficulty: %s", best_share);
        _applog(4, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d14e;
    LAB_0001c670:
        snprintf(tmp42, 0x1000, "Share submissions: %lld",
                 (uint)total_accepted + (uint)total_rejected,
                 (uint)total_accepted + (uint)total_rejected,
                 total_rejected._4_4_ + total_accepted._4_4_ +
                     (uint)CARRY4((uint)total_accepted, (uint)total_rejected));
        _applog(4, tmp42, false);
        uVar10 = (uint)use_syslog;
        if ((use_syslog == 0) &&
            (uVar10 = (uint)opt_log_output, opt_log_output == 0))
            goto LAB_0001d15a;
    LAB_0001c6ba:
        snprintf(tmp42, 0x1000, "Accepted shares: %lld", uVar10,
                 (uint)total_accepted, total_accepted._4_4_);
        _applog(4, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d166;
    LAB_0001c6f2:
        snprintf(tmp42, 0x1000, "Rejected shares: %lld", &total_rejected,
                 (uint)total_rejected, total_rejected._4_4_);
        _applog(4, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d172;
    LAB_0001c732:
        snprintf(tmp42, 0x1000, "Accepted difficulty shares: %1.f",
                 &total_diff_accepted, total_diff_accepted._0_4_,
                 total_diff_accepted._4_4_);
        _applog(4, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d17e;
    LAB_0001c788:
        snprintf(tmp42, 0x1000, "Rejected difficulty shares: %1.f",
                 &total_diff_rejected, total_diff_rejected._0_4_,
                 total_diff_rejected._4_4_);
        _applog(4, tmp42, false);
        uVar10 = (uint)total_accepted;
        iVar8 = total_accepted._4_4_;
        if ((uint)total_accepted != 0 || total_accepted._4_4_ != 0) {
        joined_r0x0001c7c2:
            if ((use_syslog == false) && (opt_log_output == false))
                goto LAB_0001d196;
            goto LAB_0001c7d4;
        }
    LAB_0001ca74:
        if (total_rejected._4_4_ != 0 || (uint)total_rejected != 0) {
            uVar10 = 0;
            iVar8 = 0;
            goto joined_r0x0001c7c2;
        }
    LAB_0001c844:
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d08c;
    LAB_0001c858:
        snprintf(tmp42, 0x1000, "Hardware errors: %d", hw_errors);
        _applog(4, tmp42, false);
        uVar10 = (uint)use_syslog;
        if (((use_syslog == 0) &&
             (uVar10 = (uint)opt_log_output, opt_log_output == 0)) &&
            (uVar10 = opt_log_level, opt_log_level < 4))
            goto LAB_0001d0a0;
    LAB_0001c894:
        snprintf(tmp42, 0x1000, "Utility (accepted shares / min): %.2f/min",
                 uVar10, (dVar11 / dVar14) * 60.0);
        _applog(4, tmp42, false);
        uVar10 = (uint)use_syslog;
        if (((use_syslog == 0) &&
             (uVar10 = (uint)opt_log_output, opt_log_output == 0)) &&
            (uVar10 = opt_log_level, opt_log_level < 4))
            goto LAB_0001d0ac;
    LAB_0001c8c8:
        snprintf(tmp42, 0x1000,
                 "Work Utility (diff1 shares solved / min): %.2f/min\n", uVar10,
                 (dVar12 / dVar14) * 60.0);
        _applog(4, tmp42, false);
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4))
            goto LAB_0001d0b8;
    LAB_0001c8fc:
        snprintf(tmp42, 0x1000,
                 "Stale submissions discarded due to new blocks: %lld",
                 &total_stale, (undefined4)total_stale, total_stale._4_4_);
        _applog(4, tmp42, false);
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4))
            goto LAB_0001d0c4;
    LAB_0001c93c:
        snprintf(tmp42, 0x1000, "Unable to get work from server occasions: %d",
                 total_go);
        _applog(4, tmp42, false);
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4))
            goto LAB_0001d0d0;
    LAB_0001c976:
        snprintf(tmp42, 0x1000, "Work items generated locally: %d", local_work);
        _applog(4, tmp42, false);
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4))
            goto LAB_0001d0dc;
    LAB_0001c9b0:
        snprintf(tmp42, 0x1000, "Submitting work remotely delay occasions: %d",
                 total_ro);
        _applog(4, tmp42, false);
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4))
            goto LAB_0001d0e8;
    LAB_0001c9ea:
        snprintf(tmp42, 0x1000, "New blocks detected on network: %d\n",
                 new_blocks);
        _applog(4, tmp42, false);
        if (1 < total_pools)
            goto LAB_0001ca1a;
    LAB_0001cd40:
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0001d068;
    LAB_0001cd54:
        builtin_strncpy(tmp42, "Summary of per device statistics", 0x20);
        tmp42[0x20] = ':';
        tmp42[0x21] = '\n';
        tmp42[0x22] = '\0';
        _applog(4, tmp42, false);
    } else {
        builtin_strncpy(tmp42, "\nSummary of runtime statistics:\n", 0x20);
        tmp42._32_2_ = tmp42._32_2_ & 0xff00;
        _applog(4, tmp42, false);
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level))
            goto LAB_0001c53e;
    LAB_0001d01a:
        if (total_pools != 1)
            goto LAB_0001c56e;
    LAB_0001d10c:
        if (3 < opt_log_level) {
        LAB_0001d116:
            snprintf(tmp42, 0x1000, "Pool: %s", (*pools)->rpc_url);
            _applog(4, tmp42, false);
            goto LAB_0001c56e;
        }
    LAB_0001d036:
        if (3 < opt_log_level)
            goto LAB_0001c582;
        dVar13 = total_mhashes_done / total_secs;
    LAB_0001d052:
        pdVar4 = (double *)opt_log_level;
        if (3 < opt_log_level)
            goto LAB_0001c5d0;
    LAB_0001d2a8:
        if (3 < opt_log_level)
            goto LAB_0001c604;
    LAB_0001d2b4:
        if (3 < opt_log_level)
            goto LAB_0001c63e;
    LAB_0001d14e:
        if (3 < opt_log_level)
            goto LAB_0001c670;
    LAB_0001d15a:
        uVar10 = opt_log_level;
        if (3 < opt_log_level)
            goto LAB_0001c6ba;
    LAB_0001d166:
        if (3 < opt_log_level)
            goto LAB_0001c6f2;
    LAB_0001d172:
        if (3 < opt_log_level)
            goto LAB_0001c732;
    LAB_0001d17e:
        if (3 < opt_log_level)
            goto LAB_0001c788;
        uVar10 = (uint)total_accepted;
        iVar8 = total_accepted._4_4_;
        if ((uint)total_accepted == 0 && total_accepted._4_4_ == 0)
            goto LAB_0001ca74;
    LAB_0001d196:
        if (3 < opt_log_level) {
        LAB_0001c7d4:
            iVar5 = total_rejected._4_4_;
            uVar6 = (uint)total_rejected;
            iVar1 =
                total_rejected._4_4_ * 3 +
                (uint)CARRY4((uint)total_rejected, (uint)total_rejected) +
                (uint)CARRY4((uint)total_rejected * 2, (uint)total_rejected);
            __aeabi_l2d((uint)total_rejected * 100,
                        (iVar1 * 0x20 | (uint)total_rejected * 3 >> 0x1b) +
                            iVar1 +
                            (uint)CARRY4((uint)total_rejected * 3,
                                         (uint)total_rejected * 0x60) +
                            total_rejected._4_4_ +
                            (uint)CARRY4((uint)total_rejected * 99,
                                         (uint)total_rejected));
            __aeabi_l2d(uVar6 + uVar10,
                        iVar5 + iVar8 + (uint)CARRY4(uVar6, uVar10));
            snprintf(tmp42, 0x1000, "Reject ratio: %.1f%%");
            _applog(4, tmp42, false);
            goto LAB_0001c844;
        }
    LAB_0001d08c:
        if (3 < opt_log_level)
            goto LAB_0001c858;
        uVar10 = opt_log_level;
        if (3 < opt_log_level)
            goto LAB_0001c894;
    LAB_0001d0a0:
        uVar10 = opt_log_level;
        if (3 < opt_log_level)
            goto LAB_0001c8c8;
    LAB_0001d0ac:
        if (3 < opt_log_level)
            goto LAB_0001c8fc;
    LAB_0001d0b8:
        if (3 < opt_log_level)
            goto LAB_0001c93c;
    LAB_0001d0c4:
        if (3 < opt_log_level)
            goto LAB_0001c976;
    LAB_0001d0d0:
        if (3 < opt_log_level)
            goto LAB_0001c9b0;
    LAB_0001d0dc:
        if (3 < opt_log_level)
            goto LAB_0001c9ea;
    LAB_0001d0e8:
        if (1 < total_pools) {
        LAB_0001ca1a:
            iVar8 = 0;
            do {
                ppVar9 = pools[iVar8];
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 4)) {
                    iVar5 = ppVar9->solved;
                    if (iVar5 == 0)
                        goto LAB_0001cafa;
                LAB_0001ca68:
                    if (3 < opt_log_level)
                        goto LAB_0001cac2;
                LAB_0001cf12:
                    if (3 < opt_log_level)
                        goto LAB_0001cb04;
                LAB_0001cf1a:
                    uVar10 = opt_log_level;
                    if (3 < opt_log_level)
                        goto LAB_0001cb40;
                LAB_0001cf26:
                    uVar10 = opt_log_level;
                    if (3 < opt_log_level)
                        goto LAB_0001cb70;
                LAB_0001cf32:
                    uVar10 = opt_log_level;
                    if (3 < opt_log_level)
                        goto LAB_0001cba0;
                LAB_0001cf3e:
                    uVar10 = opt_log_level;
                    if (3 < opt_log_level)
                        goto LAB_0001cbd0;
                    uVar10 = (uint)ppVar9->accepted;
                    iVar5 = *(int *)((int)&ppVar9->accepted + 4);
                    if (uVar10 == 0 && iVar5 == 0)
                        goto LAB_0001cbfe;
                    if (3 < opt_log_level)
                        goto LAB_0001cc1a;
                LAB_0001cf5e:
                    if (3 < opt_log_level)
                        goto LAB_0001cc9a;
                LAB_0001cf66:
                    if (3 < opt_log_level)
                        goto LAB_0001ccc6;
                LAB_0001cf72:
                    if (3 < opt_log_level)
                        goto LAB_0001ccf2;
                LAB_0001cf7e:
                    if (3 < opt_log_level)
                        goto LAB_0001cd18;
                } else {
                    snprintf(tmp42, 0x1000, "Pool: %s", ppVar9->rpc_url);
                    _applog(4, tmp42, false);
                    iVar5 = ppVar9->solved;
                    if (iVar5 != 0) {
                        if ((use_syslog == false) && (opt_log_output == false))
                            goto LAB_0001ca68;
                    LAB_0001cac2:
                        pcVar2 = "S";
                        if (iVar5 < 2) {
                            pcVar2 = "";
                        }
                        snprintf(tmp42, 0x1000, "SOLVED %d BLOCK%s!", iVar5,
                                 pcVar2);
                        _applog(4, tmp42, false);
                    }
                    if (use_syslog == false) {
                    LAB_0001cafa:
                        if (opt_log_output == false)
                            goto LAB_0001cf12;
                    }
                LAB_0001cb04:
                    uVar10 = (uint)ppVar9->rejected;
                    uVar6 = (uint)ppVar9->accepted;
                    snprintf(tmp42, 0x1000, " Share submissions: %lld",
                             *(int *)((int)&ppVar9->accepted + 4) +
                                 *(int *)((int)&ppVar9->rejected + 4) +
                                 (uint)CARRY4(uVar6, uVar10),
                             uVar6 + uVar10);
                    _applog(4, tmp42, false);
                    uVar10 = (uint)use_syslog;
                    if ((use_syslog == 0) &&
                        (uVar10 = (uint)opt_log_output, opt_log_output == 0))
                        goto LAB_0001cf1a;
                LAB_0001cb40:
                    snprintf(tmp42, 0x1000, " Accepted shares: %lld", uVar10,
                             (int)ppVar9->accepted);
                    _applog(4, tmp42, false);
                    uVar10 = (uint)use_syslog;
                    if ((use_syslog == 0) &&
                        (uVar10 = (uint)opt_log_output, opt_log_output == 0))
                        goto LAB_0001cf26;
                LAB_0001cb70:
                    snprintf(tmp42, 0x1000, " Rejected shares: %lld", uVar10,
                             (int)ppVar9->rejected);
                    _applog(4, tmp42, false);
                    uVar10 = (uint)use_syslog;
                    if ((use_syslog == 0) &&
                        (uVar10 = (uint)opt_log_output, opt_log_output == 0))
                        goto LAB_0001cf32;
                LAB_0001cba0:
                    snprintf(tmp42, 0x1000, " Accepted difficulty shares: %1.f",
                             uVar10, *(undefined4 *)&ppVar9->diff_accepted);
                    _applog(4, tmp42, false);
                    uVar10 = (uint)use_syslog;
                    if ((use_syslog == 0) &&
                        (uVar10 = (uint)opt_log_output, opt_log_output == 0))
                        goto LAB_0001cf3e;
                LAB_0001cbd0:
                    snprintf(tmp42, 0x1000, " Rejected difficulty shares: %1.f",
                             uVar10, *(undefined4 *)&ppVar9->diff_rejected);
                    _applog(4, tmp42, false);
                    uVar10 = (uint)ppVar9->accepted;
                    iVar5 = *(int *)((int)&ppVar9->accepted + 4);
                    if (uVar10 == 0 && iVar5 == 0) {
                    LAB_0001cbfe:
                        if (*(int *)((int)&ppVar9->rejected + 4) != 0 ||
                            (int)ppVar9->rejected != 0) {
                            uVar10 = 0;
                            iVar5 = 0;
                            goto LAB_0001cc0e;
                        }
                    } else {
                    LAB_0001cc0e:
                        if (((use_syslog == false) &&
                             (opt_log_output == false)) &&
                            (opt_log_level < 4))
                            goto LAB_0001cf5e;
                    LAB_0001cc1a:
                        uVar6 = (uint)ppVar9->rejected;
                        iVar3 = *(int *)((int)&ppVar9->rejected + 4);
                        iVar1 = iVar3 * 3 + (uint)CARRY4(uVar6, uVar6) +
                                (uint)CARRY4(uVar6 * 2, uVar6);
                        __aeabi_l2d(uVar6 * 100,
                                    iVar3 + iVar1 +
                                        (iVar1 * 0x20 | uVar6 * 3 >> 0x1b) +
                                        (uint)CARRY4(uVar6 * 3, uVar6 * 0x60) +
                                        (uint)CARRY4(uVar6 * 99, uVar6));
                        __aeabi_l2d(uVar6 + uVar10,
                                    iVar3 + iVar5 +
                                        (uint)CARRY4(uVar6, uVar10));
                        snprintf(tmp42, 0x1000, " Reject ratio: %.1f%%");
                        _applog(4, tmp42, false);
                    }
                    if ((use_syslog == false) && (opt_log_output == false))
                        goto LAB_0001cf5e;
                LAB_0001cc9a:
                    snprintf(tmp42, 0x1000, " Items worked on: %d",
                             ppVar9->works);
                    _applog(4, tmp42, false);
                    if ((use_syslog == false) && (opt_log_output == false))
                        goto LAB_0001cf66;
                LAB_0001ccc6:
                    snprintf(
                        tmp42, 0x1000,
                        " Stale submissions discarded due to new blocks: %d",
                        ppVar9->stale_shares);
                    _applog(4, tmp42, false);
                    if ((use_syslog == false) && (opt_log_output == false))
                        goto LAB_0001cf72;
                LAB_0001ccf2:
                    snprintf(tmp42, 0x1000,
                             " Unable to get work from server occasions: %d",
                             ppVar9->getfail_occasions);
                    _applog(4, tmp42, false);
                    if ((use_syslog == false) && (opt_log_output == false))
                        goto LAB_0001cf7e;
                LAB_0001cd18:
                    snprintf(tmp42, 0x1000,
                             " Submitting work remotely delay occasions: %d\n",
                             ppVar9->remotefail_occasions);
                    _applog(4, tmp42, false);
                }
                iVar8 = iVar8 + 1;
            } while (iVar8 < total_pools);
            goto LAB_0001cd40;
        }
    LAB_0001d068:
        if (3 < opt_log_level)
            goto LAB_0001cd54;
    }
    if (0 < total_devices) {
        iVar8 = 0;
        do {
            cgpu = get_devices(iVar8);
            iVar8 = iVar8 + 1;
            cgpu->drv->get_statline_before =
                (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x1508d;
            cgpu->drv->get_statline =
                (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x175e5;
            get_statline(logline, 0xff, cgpu);
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "%s", logline);
                _applog(4, tmp42, false);
            }
        } while (iVar8 < total_devices);
    }
    p_Var7 = (_Bool *)(uint)use_syslog;
    if (opt_shares == 0) {
    LAB_0001cebe:
        if ((p_Var7 == (_Bool *)0x0) && (opt_log_output == false))
            goto LAB_0001d07a;
    } else {
        dVar14 = (double)CONCAT44(total_diff_accepted._4_4_,
                                  total_diff_accepted._0_4_);
        if (((p_Var7 != (_Bool *)0x0) ||
             (p_Var7 = &opt_log_output, opt_log_output != false)) ||
            (3 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "Mined %.0f accepted shares of %d requested\n", p_Var7,
                     dVar14, opt_shares);
            _applog(4, tmp42, false);
            dVar14 = (double)CONCAT44(total_diff_accepted._4_4_,
                                      total_diff_accepted._0_4_);
            p_Var7 = (_Bool *)(uint)use_syslog;
            if (dVar14 < (double)(longlong)opt_shares) {
                if (p_Var7 == (_Bool *)0x0)
                    goto LAB_0001ce84;
            LAB_0001ce9a:
                snprintf(tmp42, 0x1000,
                         "WARNING - Mined only %.0f shares of %d requested.",
                         p_Var7, dVar14, opt_shares);
                _applog(4, tmp42, false);
                p_Var7 = (_Bool *)(uint)use_syslog;
            }
            goto LAB_0001cebe;
        }
        if (dVar14 < (double)(longlong)opt_shares) {
        LAB_0001ce84:
            p_Var7 = (_Bool *)(uint)opt_log_output;
            if (((_Bool *)(uint)opt_log_output != (_Bool *)0x0) ||
                (p_Var7 = (_Bool *)opt_log_level, 3 < opt_log_level))
                goto LAB_0001ce9a;
        }
    LAB_0001d07a:
        if (opt_log_level < 4)
            goto LAB_0001cee0;
    }
    tmp42[0] = ' ';
    tmp42[1] = '\0';
    _applog(4, tmp42, false);
LAB_0001cee0:
    fflush(stderr);
    fflush(stdout);
    return;
}

/* WARNING: Unknown calling convention */

thr_info *get_thread(int thr_id)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    thr_info *ptVar3;

    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)&mining_thr_lock);
    if (iVar1 == 0) {
        ptVar3 = mining_thr[thr_id];
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&mining_thr_lock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            return ptVar3;
        }
    } else {
        _rd_lock((pthread_rwlock_t *)"get_thread", (char *)0x266, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"get_thread", (char *)0x268, func_00, iVar1);
}

/* WARNING: Unknown calling convention */

int dev_from_id(int thr_id)

{
    thr_info *ptVar1;

    ptVar1 = get_thread(thr_id);
    return ptVar1->cgpu->device_id;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void __kill_work(void)

{
    undefined4 uVar1;
    thr_info *ptVar2;
    int thr_id;
    int iVar3;
    char tmp42[4096];

    uVar1 = tmp42._20_4_;
    if (!opt_debug)
        goto LAB_0001d3d6;
    if (((use_syslog) || (opt_log_output)) || (6 < opt_log_level)) {
        builtin_strncpy(tmp42, "Received kill message", 0x16);
        tmp42._22_2_ = SUB42(uVar1, 2);
        _applog(7, tmp42, true);
        if (opt_debug == false)
            goto LAB_0001d3d6;
        if (use_syslog == false)
            goto LAB_0001d3ac;
    } else {
    LAB_0001d3ac:
        if ((opt_log_output == false) && (opt_log_level < 7))
            goto LAB_0001d3d6;
    }
    builtin_strncpy(tmp42, "Killing off watchpool thread", 0x1c);
    tmp42[0x1c] = '\0';
    _applog(7, tmp42, true);
LAB_0001d3d6:
    cg_completion_timeout((void *)0x27bc9, control_thr + watchpool_thr_id,
                          1000);
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Killing off watchdog thread", 0x1c);
        _applog(7, tmp42, true);
    }
    cg_completion_timeout((void *)0x27bc9, control_thr + watchdog_thr_id, 1000);
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Shutting down mining threads", 0x1c);
        tmp42[0x1c] = '\0';
        _applog(7, tmp42, true);
    }
    if (0 < mining_threads) {
        thr_id = 0;
        do {
            iVar3 = thr_id + 1;
            ptVar2 = get_thread(thr_id);
            if ((ptVar2 != (thr_info *)0x0) &&
                (ptVar2->cgpu != (cgpu_info *)0x0)) {
                ptVar2->cgpu->shutdown = true;
            }
            thr_id = iVar3;
        } while (iVar3 < mining_threads);
    }
    sleep(1);
    cg_completion_timeout((void *)0x1d5b9, (void *)0x0, 3000);
    uVar1 = tmp42._20_4_;
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Killing off API thread", 0x17);
        tmp42[0x17] = SUB41(uVar1, 3);
        _applog(7, tmp42, true);
    }
    cg_completion_timeout((void *)0x27bc9, control_thr + api_thr_id, 1000);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void __kill_work(void)

{
    if (successful_connect) {
        __kill_work();
        return;
    }
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void kill_mining(void)

{
    thr_info *thr;
    int thr_id;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Killing off mining threa", 0x18);
        tmp42[0x18] = 'd';
        tmp42[0x19] = 's';
        tmp42[0x1a] = '\0';
        _applog(7, tmp42, true);
    }
    if (mining_threads < 1) {
        return;
    }
    thr_id = 0;
    do {
        while ((thr = get_thread(thr_id),
                thr != (thr_info *)0x0 && (thr->pth != 0))) {
            thr_info_cancel(thr);
            if (thr->pth == 0)
                goto LAB_0001d620;
            thr_id = thr_id + 1;
            pthread_join(thr->pth, (void **)0x0);
            if (mining_threads <= thr_id) {
                return;
            }
        }
        thr_info_cancel(thr);
    LAB_0001d620:
        thr_id = thr_id + 1;
        if (mining_threads <= thr_id) {
            return;
        }
    } while (true);
}

/* WARNING: Unknown calling convention */

pool *current_pool(void)

{
    pool *ppVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    char *extraout_r2_01;
    char *extraout_r2_02;
    char *pcVar4;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    int line_00;
    int extraout_r3_01;
    int extraout_r3_02;

    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
    if (iVar2 == 0) {
        iVar3 = pthread_rwlock_rdlock((pthread_rwlock_t *)&control_lock.rwlock);
        pcVar4 = extraout_r2;
        iVar2 = extraout_r3;
        if (iVar3 == 0) {
            iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
            ppVar1 = currentpool;
            pcVar4 = extraout_r2_00;
            iVar2 = extraout_r3_00;
            if (iVar3 == 0) {
                iVar2 = pthread_rwlock_unlock(
                    (pthread_rwlock_t *)&control_lock.rwlock);
                if (iVar2 == 0) {
                    (*selective_yield)();
                    return ppVar1;
                }
                /* WARNING: Subroutine does not return */
                _rw_unlock((pthread_rwlock_t *)"current_pool", (char *)0x31e,
                           func_00, line_00);
            }
            goto LAB_0001d6c6;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"current_pool", (char *)0x31c, func,
                    line);
        pcVar4 = extraout_r2_01;
        iVar2 = extraout_r3_01;
    }
    _rd_lock((pthread_rwlock_t *)"current_pool", (char *)0x31c, pcVar4, iVar2);
    pcVar4 = extraout_r2_02;
    iVar2 = extraout_r3_02;
LAB_0001d6c6:
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"current_pool", (char *)0x31c,
                          pcVar4, iVar2);
}

/* WARNING: Unknown calling convention */

void inc_work_stats(thr_info *thr, pool *pool, int diff1)

{
    int iVar1;
    time_t tVar2;
    pool *ppVar3;
    cgpu_info *pcVar4;
    char *func;
    uint uVar5;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    int iVar6;
    bool bVar7;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
    if (iVar1 == 0) {
        pcVar4 = thr->cgpu;
        iVar1 = diff1 >> 0x1f;
        uVar5 = (uint)pcVar4->diff1;
        iVar6 = *(int *)((int)&pcVar4->diff1 + 4);
        bVar7 = CARRY4((uint)total_diff1, diff1);
        total_diff1._0_4_ = (uint)total_diff1 + diff1;
        total_diff1._4_4_ = iVar1 + total_diff1._4_4_ + (uint)bVar7;
        *(uint *)&pcVar4->diff1 = uVar5 + diff1;
        *(uint *)((int)&pcVar4->diff1 + 4) =
            iVar1 + iVar6 + (uint)CARRY4(uVar5, diff1);
        if (pool == (pool *)0x0) {
            ppVar3 = current_pool();
            uVar5 = (uint)ppVar3->diff1;
            iVar6 = *(int *)((int)&ppVar3->diff1 + 4);
            *(uint *)&ppVar3->diff1 = uVar5 + diff1;
            *(uint *)((int)&ppVar3->diff1 + 4) =
                iVar1 + iVar6 + (uint)CARRY4(uVar5, diff1);
        } else {
            uVar5 = (uint)pool->diff1;
            iVar6 = *(int *)((int)&pool->diff1 + 4);
            *(uint *)&pool->diff1 = uVar5 + diff1;
            *(uint *)((int)&pool->diff1 + 4) =
                iVar1 + iVar6 + (uint)CARRY4(uVar5, diff1);
        }
        pcVar4 = thr->cgpu;
        tVar2 = time((time_t *)0x0);
        pcVar4->last_device_valid_work = tVar2;
        iVar6 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar6 == 0) {
            /* WARNING: Could not recover jumptable at 0x0001d76a. Too many
             * branches */
            /* WARNING: Treating indirect jump as call */
            (*selective_yield)();
            return;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"inc_work_stats", (char *)0x20c9, func,
                    line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"inc_work_stats", (char *)0x20d6,
                          func_00, iVar1);
}

/* WARNING: Unknown calling convention */

int cp_prio(void)

{
    int iVar1;
    int iVar2;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    char *extraout_r2_01;
    char *extraout_r2_02;
    char *pcVar3;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    int line_00;
    int extraout_r3_01;
    int extraout_r3_02;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
    if (iVar1 == 0) {
        iVar2 = pthread_rwlock_rdlock((pthread_rwlock_t *)&control_lock.rwlock);
        pcVar3 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
            pcVar3 = extraout_r2_00;
            iVar1 = extraout_r3_00;
            if (iVar2 == 0) {
                iVar2 = currentpool->prio;
                iVar1 = pthread_rwlock_unlock(
                    (pthread_rwlock_t *)&control_lock.rwlock);
                if (iVar1 == 0) {
                    (*selective_yield)();
                    return iVar2;
                }
                /* WARNING: Subroutine does not return */
                _rw_unlock((pthread_rwlock_t *)"cp_prio", (char *)0x1b7e,
                           func_00, line_00);
            }
            goto LAB_0001d7f8;
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"cp_prio", (char *)0x1b7c, func, line);
        pcVar3 = extraout_r2_01;
        iVar1 = extraout_r3_01;
    }
    _rd_lock((pthread_rwlock_t *)"cp_prio", (char *)0x1b7c, pcVar3, iVar1);
    pcVar3 = extraout_r2_02;
    iVar1 = extraout_r3_02;
LAB_0001d7f8:
    /* WARNING: Subroutine does not return */
    _mutex_unlock_noyield((pthread_mutex_t *)"cp_prio", (char *)0x1b7c, pcVar3,
                          iVar1);
}

/* WARNING: Unknown calling convention */

void pool_resus(pool *pool)

{
    pool_strategy pVar1;
    int iVar2;
    int iVar3;
    char tmp42[4096];

    pVar1 = pool_strategy;
    pool->seq_getfails = 0;
    if ((pVar1 == POOL_FAILOVER) &&
        (iVar3 = pool->prio, iVar2 = cp_prio(), iVar3 < iVar2)) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "Pool %d %s alive, testing stability",
                     pool->pool_no, pool->rpc_url);
            _applog(4, tmp42, false);
            return;
        }
    } else if ((opt_debug != false) &&
               (((use_syslog != false || (opt_log_output != false)) ||
                 (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Pool %d %s alive", pool->pool_no,
                 pool->rpc_url);
        _applog(7, tmp42, false);
    }
    return;
}

/* WARNING: Unknown calling convention */

void stratum_resumed(pool *pool)

{
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Stratum connection to pool %d resumed",
                 pool->pool_no);
        _applog(7, tmp42, false);
    }
    pool_resus(pool);
    return;
}

/* WARNING: Unknown calling convention */

void stratum_resumed(pool *pool)

{
    _Bool _Var1;

    _Var1 = pool_tclear(pool, &pool->idle);
    if (_Var1) {
        stratum_resumed(pool);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

_Bool cnx_needed(pool *pool)

{
    pool *ppVar1;
    int iVar2;
    int iVar3;

    if (pool->enabled != POOL_ENABLED) {
        return false;
    }
    if ((((1 < pool_strategy - POOL_LOADBALANCE) &&
          (((pool->has_stratum == false || (pool->idle == false)) &&
            (ppVar1 = current_pool(), pool != ppVar1)))) &&
         (pool->sshares == 0)) &&
        ((pool_strategy != POOL_FAILOVER ||
          (iVar3 = pool->prio, iVar2 = cp_prio(), iVar2 <= iVar3)))) {
        return no_work;
    }
    return true;
}

/* WARNING: Unknown calling convention */

pool *add_pool(void)

{
    pool **pppVar1;
    pool *ppVar2;
    int iVar3;
    int *piVar4;
    int iVar5;
    undefined4 uVar6;
    char tmp42[4096];

    ppVar2 = (pool *)calloc(0x750, 1);
    uVar6 = tmp42._32_4_;
    pppVar1 = pools;
    iVar3 = total_pools;
    if (ppVar2 == (pool *)0x0) {
        builtin_strncpy(tmp42, "Failed to malloc pool in add_pool", 0x22);
        tmp42._34_2_ = SUB42(uVar6, 2);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    iVar5 = total_pools + 2;
    ppVar2->pool_no = total_pools;
    ppVar2->prio = iVar3;
    pools = (pool **)realloc(pppVar1, iVar5 * 4);
    pppVar1 = pools + total_pools;
    total_pools = total_pools + 1;
    *pppVar1 = ppVar2;
    iVar3 = pthread_mutex_init((pthread_mutex_t *)&ppVar2->pool_lock,
                               (pthread_mutexattr_t *)0x0);
    if (iVar3 == 0) {
        iVar3 = pthread_cond_init((pthread_cond_t *)&ppVar2->cr_cond,
                                  (pthread_condattr_t *)0x0);
        if (iVar3 != 0) {
            tmp42[0] = 'F';
            tmp42[1] = 'a';
            tmp42[2] = 'i';
            tmp42[3] = 'l';
            tmp42[4] = 'e';
            tmp42[5] = 'd';
            tmp42[6] = ' ';
            tmp42[7] = 't';
            tmp42[8] = 'o';
            tmp42[9] = ' ';
            tmp42[10] = 'p';
            tmp42[0xb] = 't';
            tmp42[0xc] = 'h';
            tmp42[0xd] = 'r';
            tmp42[0xe] = 'e';
            tmp42[0xf] = 'a';
            tmp42[0x10] = 'd';
            tmp42[0x11] = '_';
            tmp42[0x12] = 'c';
            tmp42[0x13] = 'o';
            tmp42[0x14] = 'n';
            tmp42[0x15] = 'd';
            tmp42[0x16] = '_';
            tmp42[0x17] = 'i';
            tmp42[0x18] = 'n';
            tmp42[0x19] = 'i';
            tmp42[0x1a] = 't';
            tmp42[0x1b] = ' ';
            tmp42[0x1c] = 'i';
            tmp42[0x1d] = 'n';
            tmp42[0x1e] = ' ';
            tmp42[0x1f] = 'a';
            tmp42[0x20] = 'd';
            tmp42[0x21] = 'd';
            tmp42[0x22] = '_';
            tmp42[0x23] = 'p';
            tmp42[0x24] = 'o';
            tmp42[0x25] = 'o';
            tmp42[0x26] = 'l';
            tmp42[0x27] = '\0';
            goto LAB_0001dae6;
        }
        iVar3 = pthread_mutex_init((pthread_mutex_t *)&ppVar2->data_lock,
                                   (pthread_mutexattr_t *)0x0);
        if (iVar3 == 0) {
            iVar3 = pthread_rwlock_init(
                (pthread_rwlock_t *)&(ppVar2->data_lock).rwlock,
                (pthread_rwlockattr_t *)0x0);
            if (iVar3 != 0) {
                piVar4 = __errno_location();
                iVar3 = *piVar4;
                uVar6 = 0x2ef;
            LAB_0001db7c:
                snprintf(tmp42, 0x1000,
                         "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
                         iVar3, "cgminer.c", "add_pool", uVar6);
                goto LAB_0001dae6;
            }
            iVar3 = pthread_mutex_init((pthread_mutex_t *)&ppVar2->stratum_lock,
                                       (pthread_mutexattr_t *)0x0);
            if (iVar3 == 0) {
                iVar3 = pthread_mutex_init((pthread_mutex_t *)&ppVar2->gbt_lock,
                                           (pthread_mutexattr_t *)0x0);
                if (iVar3 == 0) {
                    iVar3 = pthread_rwlock_init(
                        (pthread_rwlock_t *)&(ppVar2->gbt_lock).rwlock,
                        (pthread_rwlockattr_t *)0x0);
                    if (iVar3 == 0) {
                        ppVar2->rpc_proxy = (char *)0x0;
                        ppVar2->rpc_req = "{\"method\": \"getwork\", "
                                          "\"params\": [], \"id\":0}\n";
                        (ppVar2->curlring).next = &ppVar2->curlring;
                        (ppVar2->curlring).prev = &ppVar2->curlring;
                        (ppVar2->tv_idle).tv_sec = -1;
                        ppVar2->quota = 1;
                        adjust_quota_gcd();
                        return ppVar2;
                    }
                    piVar4 = __errno_location();
                    iVar3 = *piVar4;
                    uVar6 = 0x2f1;
                    goto LAB_0001db7c;
                }
                piVar4 = __errno_location();
                iVar3 = *piVar4;
                uVar6 = 0x2f1;
            } else {
                piVar4 = __errno_location();
                iVar3 = *piVar4;
                uVar6 = 0x2f0;
            }
        } else {
            piVar4 = __errno_location();
            iVar3 = *piVar4;
            uVar6 = 0x2ef;
        }
    } else {
        piVar4 = __errno_location();
        iVar3 = *piVar4;
        uVar6 = 0x2ec;
    }
    snprintf(tmp42, 0x1000,
             "Failed to pthread_mutex_init errno=%d in %s %s():%d", iVar3,
             "cgminer.c", "add_pool", uVar6);
LAB_0001dae6:
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

char *set_userpass(char *arg)

{
    char *pcVar1;
    char *pcVar2;
    pool *ppVar3;

    if ((total_users == 0) && (total_passes == 0)) {
        total_userpasses = total_userpasses + 1;
        if (total_pools < total_userpasses) {
            add_pool();
        }
        ppVar3 = pools[total_userpasses + 0x3fffffff];
        pcVar1 = (char *)__strdup(arg);
        opt_set_charp(arg, &ppVar3->rpc_userpass);
        pcVar2 = strtok(pcVar1, ":");
        pcVar1 = "Failed to find : delimited user info";
        ppVar3->rpc_user = pcVar2;
        if (pcVar2 != (char *)0x0) {
            pcVar1 = strtok((char *)0x0, ":");
            ppVar3->rpc_pass = pcVar1;
            if (pcVar1 != (char *)0x0) {
                return (char *)0x0;
            }
            pcVar1 = (char *)calloc(1, 1);
            ppVar3->rpc_pass = pcVar1;
            pcVar1 = (char *)0x0;
        }
    } else {
        pcVar1 = "Use only user + pass or userpass, but not both";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_user(char *arg)

{
    if (total_userpasses != 0) {
        return "Use only user + pass or userpass, but not both";
    }
    total_users = total_users + 1;
    if (total_pools < total_users) {
        add_pool();
    }
    opt_set_charp(arg, &pools[total_users + 0x3fffffff]->rpc_user);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

pool *add_url(void)

{
    total_urls = total_urls + 1;
    if (total_pools < total_urls) {
        add_pool();
    }
    return pools[total_urls + 0x3fffffff];
}

/* WARNING: Unknown calling convention */

char *set_url(char *arg)

{
    pool *pool;

    pool = add_url();
    setup_url(pool, arg);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *set_quota(char *arg)

{
    char *pcVar1;
    size_t sVar2;
    size_t sVar3;
    long lVar4;
    pool *pool;
    char tmp42[4096];

    pcVar1 = strchr(arg, 0x3b);
    if (pcVar1 == (char *)0x0) {
        return "No semicolon separated quota;URL pair found";
    }
    sVar2 = strlen(arg);
    *pcVar1 = '\0';
    sVar3 = strlen(arg);
    if (sVar3 == 0) {
        pcVar1 = "No parameter for quota found";
    } else if ((int)(sVar2 - (sVar3 + 1)) < 1) {
        pcVar1 = "No parameter for URL found";
    } else {
        lVar4 = strtol(arg, (char **)0x0, 10);
        if (lVar4 < 0) {
            pcVar1 = "Invalid negative parameter for quota set";
        } else {
            pool = add_url();
            setup_url(pool, arg + sVar3 + 1);
            pool->quota = lVar4;
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "Setting pool %d to quota %d",
                         pool->pool_no, lVar4);
                _applog(7, tmp42, false);
            }
            adjust_quota_gcd();
            pcVar1 = (char *)0x0;
        }
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *set_pass(char *arg)

{
    if (total_userpasses != 0) {
        return "Use only user + pass or userpass, but not both";
    }
    total_passes = total_passes + 1;
    if (total_pools < total_passes) {
        add_pool();
    }
    opt_set_charp(arg, &pools[total_passes + 0x3fffffff]->rpc_pass);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

void inc_hw_errors_with_diff(thr_info *thr, int diff)

{
    int iVar1;
    int *piVar2;
    char *__format;
    undefined4 uVar3;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s%d: invalid nonce - HW error",
                 thr->cgpu->drv->name, thr->cgpu->device_id);
        _applog(7, tmp42, false);
    }
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
    if (iVar1 == 0) {
        hw_errors = hw_errors + diff;
        thr->cgpu->hw_errors = thr->cgpu->hw_errors + diff;
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        if (iVar1 == 0) {
            (*selective_yield)();
            (*thr->cgpu->drv->hw_error)(thr);
            return;
        }
        piVar2 = __errno_location();
        iVar1 = *piVar2;
        __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar3 = 0x2078;
    } else {
        piVar2 = __errno_location();
        iVar1 = *piVar2;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar3 = 0x2075;
    }
    snprintf(tmp42, 0x1000, __format, iVar1, "cgminer.c",
             "inc_hw_errors_with_diff", uVar3);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void inc_hw_errors(thr_info *thr)

{
    int iVar1;
    int *piVar2;
    char *__format;
    undefined4 uVar3;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s %d: invalid nonce - HW error",
                 thr->cgpu->drv->name, thr->cgpu->device_id);
        _applog(7, tmp42, true);
    }
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
    if (iVar1 == 0) {
        hw_errors = hw_errors + 1;
        thr->cgpu->hw_errors = thr->cgpu->hw_errors + 1;
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        if (iVar1 == 0) {
            (*selective_yield)();
            (*thr->cgpu->drv->hw_error)(thr);
            return;
        }
        piVar2 = __errno_location();
        iVar1 = *piVar2;
        __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar3 = 0x206b;
    } else {
        piVar2 = __errno_location();
        iVar1 = *piVar2;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar3 = 0x2068;
    }
    snprintf(tmp42, 0x1000, __format, iVar1, "cgminer.c", "inc_hw_errors",
             uVar3);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

uint64_t share_diff(work *work)

{
    uint64_t uVar1;
    int iVar2;
    int *piVar3;
    uint uVar4;
    pool *ppVar5;
    char *__format;
    uint uVar6;
    bool bVar7;
    bool bVar8;
    double dVar9;
    double dVar10;
    double dVar11;
    double dVar12;
    double dVar13;
    UDItype val;
    undefined4 uVar14;
    char tmp42[4096];

    dVar9 = 2.695953529101131e+67;
    if (opt_scrypt) {
        dVar9 = 1.7668201048317172e+72;
    }
    dVar12 = (double)__floatundidf(*(undefined4 *)(work->hash + 0x18),
                                   *(undefined4 *)(work->hash + 0x1c));
    dVar10 = (double)__floatundidf(*(undefined4 *)(work->hash + 0x10),
                                   *(undefined4 *)(work->hash + 0x14));
    dVar11 = (double)__floatundidf(*(undefined4 *)(work->hash + 8),
                                   *(undefined4 *)(work->hash + 0xc));
    dVar13 = (double)__floatundidf(*(undefined4 *)work->hash,
                                   *(undefined4 *)(work->hash + 4));
    dVar13 = dVar13 + dVar12 * 6.277101735386681e+57 +
             dVar10 * 3.402823669209385e+38 + dVar11 * 1.8446744073709552e+19;
    if (dVar13 == 0.0) {
        dVar13 = 0.0;
    }
    dVar9 = round(dVar9 / dVar13);
    val = __fixunsdfdi(dVar9);
    uVar4 = (uint)(val >> 0x20);
    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
    if (iVar2 == 0) {
        iVar2 = pthread_rwlock_wrlock((pthread_rwlock_t *)&control_lock.rwlock);
        if (iVar2 == 0) {
            bVar7 = uVar4 <= best_diff._4_4_;
            if (best_diff._4_4_ == uVar4) {
                bVar7 = (uint)val <= (uint)best_diff;
            }
            if (!bVar7) {
                best_diff = val;
                suffix_string(val, best_share, 8, 0);
            }
            ppVar5 = work->pool;
            uVar6 = *(uint *)((int)&ppVar5->best_diff + 4);
            bVar8 = uVar4 <= uVar6;
            if (uVar6 == uVar4) {
                bVar8 = (uint)val <= (uint)ppVar5->best_diff;
            }
            if (!bVar8) {
                ppVar5->best_diff = val;
            }
            iVar2 =
                pthread_rwlock_unlock((pthread_rwlock_t *)&control_lock.rwlock);
            if (iVar2 == 0) {
                iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
                if (iVar2 == 0) {
                    (*selective_yield)();
                    uVar1 = best_diff;
                    if (((!bVar7) && (opt_debug != false)) &&
                        ((use_syslog != false || ((opt_log_output != false ||
                                                   (6 < opt_log_level)))))) {
                        snprintf(tmp42, 0x1000, "New best share: %s",
                                 best_share);
                        _applog(7, tmp42, false);
                        uVar1 = best_diff;
                    }
                    best_diff._4_4_ = (uint)(uVar1 >> 0x20);
                    best_diff._0_4_ = (uint)uVar1;
                    return val;
                }
                piVar3 = __errno_location();
                iVar2 = *piVar3;
                __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                uVar14 = 0x1383;
            } else {
                piVar3 = __errno_location();
                iVar2 = *piVar3;
                __format = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                uVar14 = 0x1383;
            }
        } else {
            piVar3 = __errno_location();
            iVar2 = *piVar3;
            __format = "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            uVar14 = 0x137a;
        }
    } else {
        piVar3 = __errno_location();
        iVar2 = *piVar3;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar14 = 0x137a;
    }
    snprintf(tmp42, 0x1000, __format, iVar2, "cgminer.c", "share_diff", uVar14);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void update_work_stats(thr_info *thr, work *work)

{
    _Bool _Var1;
    int iVar2;
    time_t tVar3;
    int *piVar4;
    char *__format;
    pool *ppVar5;
    cgpu_info *pcVar6;
    undefined4 uVar7;
    undefined4 extraout_s1;
    undefined4 extraout_s1_00;
    undefined4 extraout_s1_01;
    double dVar8;
    double dVar9;
    uint64_t uVar10;
    DItype DVar11;
    char tmp42[4096];

    dVar9 = current_diff;
    uVar10 = share_diff(work);
    work->share_diff = uVar10;
    if (opt_scrypt != false) {
        dVar9 = dVar9 * 65536.0;
    }
    dVar8 = (double)__floatundidf();
    if (dVar9 <= dVar8) {
        work->block = true;
        _Var1 = use_syslog;
        found_blocks = found_blocks + 1;
        work->pool->solved = work->pool->solved + 1;
        work->mandatory = true;
        if (((_Var1 != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "Found block for pool %d!",
                     work->pool->pool_no);
            _applog(5, tmp42, false);
        }
    }
    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
    if (iVar2 == 0) {
        uVar7 = __aeabi_l2d((undefined4)total_diff1, total_diff1._4_4_);
        total_diff1 = __fixdfdi((DFtype)CONCAT44(extraout_s1, uVar7));
        pcVar6 = thr->cgpu;
        uVar7 = __aeabi_l2d((int)pcVar6->diff1,
                            *(undefined4 *)((int)&pcVar6->diff1 + 4));
        DVar11 = __fixdfdi((DFtype)CONCAT44(extraout_s1_00, uVar7));
        pcVar6->diff1 = DVar11;
        ppVar5 = work->pool;
        uVar7 = __aeabi_l2d((int)ppVar5->diff1,
                            *(undefined4 *)((int)&ppVar5->diff1 + 4));
        DVar11 = __fixdfdi((DFtype)CONCAT44(extraout_s1_01, uVar7));
        ppVar5->diff1 = DVar11;
        pcVar6 = thr->cgpu;
        tVar3 = time((time_t *)0x0);
        pcVar6->last_device_valid_work = tVar3;
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        if (iVar2 == 0) {
            (*selective_yield)();
            return;
        }
        piVar4 = __errno_location();
        iVar2 = *piVar4;
        __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar7 = 0x20c4;
    } else {
        piVar4 = __errno_location();
        iVar2 = *piVar4;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar7 = 0x20bf;
    }
    snprintf(tmp42, 0x1000, __format, iVar2, "cgminer.c", "update_work_stats",
             uVar7);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

_Bool submit_nonce_1(thr_info *thr, work *work, uint32_t nonce, int *nofull)

{
    _Bool _Var1;
    uint uVar2;
    undefined1 uVar3;
    char tmp42[4096];

    if (nofull != (int *)0x0) {
        *nofull = 0;
    }
    *(uint32_t *)(work->data + 0x4c) = nonce;
    rebuild_hash(work);
    uVar2 = 0xffff;
    if (opt_scrypt == false) {
        uVar2 = 0;
    }
    if (*(uint *)(work->hash + 0x1c) <= uVar2) {
        update_work_stats(thr, work);
        _Var1 = fulltest(work->hash, work->target);
        if (!_Var1) {
            if (nofull != (int *)0x0) {
                *nofull = 1;
            }
            uVar3 = opt_debug;
            if ((opt_debug == false) ||
                (((use_syslog == false && (opt_log_output == false)) &&
                  (uVar3 = 0, opt_log_level < 7)))) {
                return (_Bool)uVar3;
            }
            builtin_strncpy(tmp42, "Share above targ", 0x10);
            tmp42[0x10] = 'e';
            tmp42[0x11] = 't';
            tmp42[0x12] = '\0';
            _applog(7, tmp42, false);
        }
        return _Var1;
    }
    inc_hw_errors(thr);
    return false;
}

/* WARNING: Unknown calling convention */

void clear_pool_work(pool *pool)

{
    work *pwVar1;
    work *work;
    work *pwVar2;
    int iVar3;
    int *piVar4;
    work *pwVar5;
    pool *ppVar6;
    int iVar7;
    work *pwVar8;
    uint uVar9;
    UT_hash_handle *pUVar10;
    char *__format;
    UT_hash_bucket *pUVar11;
    UT_hash_handle *pUVar12;
    void *pvVar13;
    UT_hash_table *pUVar14;
    bool bVar15;
    undefined4 uVar16;
    char tmp42[4096];

    iVar3 = pthread_mutex_lock((pthread_mutex_t *)stgd_lock);
    if (iVar3 != 0) {
        piVar4 = __errno_location();
        iVar3 = *piVar4;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar16 = 0x1b68;
        goto LAB_0001e7e0;
    }
    if (staged_work != (work *)0x0) {
        ppVar6 = staged_work->pool;
        iVar3 = 0;
        pwVar5 = (work *)(staged_work->hh).next;
        work = staged_work;
        pwVar2 = staged_work;
        do {
            pwVar1 = pwVar5;
            staged_work = pwVar2;
            if (ppVar6 == pool) {
                pvVar13 = (work->hh).prev;
                pUVar14 = (pwVar2->hh).tbl;
                if (pvVar13 == (void *)0x0) {
                    pwVar5 = (work *)(work->hh).next;
                    if (pwVar5 != (work *)0x0) {
                        iVar7 = pUVar14->hho;
                        pwVar8 = pwVar5;
                        staged_work = pwVar5;
                        if (work == (work *)((int)pUVar14->tail - iVar7))
                            goto LAB_0001e77e;
                        goto LAB_0001e660;
                    }
                    free(pUVar14->buckets);
                    free((staged_work->hh).tbl);
                    staged_work = pwVar5;
                } else {
                    iVar7 = pUVar14->hho;
                    if (work == (work *)((int)pUVar14->tail - iVar7)) {
                    LAB_0001e77e:
                        staged_work = pwVar2;
                        pUVar14->tail =
                            (UT_hash_handle *)(iVar7 + (int)pvVar13);
                        pvVar13 = (work->hh).prev;
                        if (pvVar13 == (void *)0x0) {
                            pwVar5 = (work *)(work->hh).next;
                            pwVar8 = pwVar5;
                            staged_work = pwVar5;
                            goto LAB_0001e660;
                        }
                        iVar7 = ((pwVar2->hh).tbl)->hho;
                    }
                    *(void **)((int)pvVar13 + iVar7 + 8) = (work->hh).next;
                    pwVar5 = pwVar2;
                    pwVar8 = (work *)(work->hh).next;
                LAB_0001e660:
                    pUVar14 = (pwVar5->hh).tbl;
                    if (pwVar8 != (work *)0x0) {
                        *(void **)((int)pwVar8->data + pUVar14->hho + 4) =
                            (work->hh).prev;
                        pUVar14 = (pwVar5->hh).tbl;
                    }
                    uVar9 = pUVar14->num_buckets - 1 & (work->hh).hashv;
                    pUVar14->buckets[uVar9].count =
                        pUVar14->buckets[uVar9].count - 1;
                    pUVar11 = ((pwVar5->hh).tbl)->buckets;
                    bVar15 = pUVar11[uVar9].hh_head == &work->hh;
                    if (bVar15) {
                        pwVar5 = (work *)(work->hh).hh_next;
                        pUVar11[uVar9].hh_head = (UT_hash_handle *)pwVar5;
                    }
                    pUVar10 = (work->hh).hh_prev;
                    if (bVar15) {
                        pwVar5 = staged_work;
                    }
                    pUVar12 = (work->hh).hh_next;
                    if (pUVar10 != (UT_hash_handle *)0x0) {
                        pUVar10->hh_next = pUVar12;
                        pUVar12 = (work->hh).hh_next;
                    }
                    if (pUVar12 != (UT_hash_handle *)0x0) {
                        pUVar12->hh_prev = (work->hh).hh_prev;
                    }
                    pUVar14 = (pwVar5->hh).tbl;
                    pUVar14->num_items = pUVar14->num_items - 1;
                }
                iVar3 = iVar3 + 1;
                clean_work(work);
                free(work);
            }
            if (pwVar1 == (work *)0x0)
                goto LAB_0001e6e4;
            ppVar6 = pwVar1->pool;
            pwVar5 = (work *)(pwVar1->hh).next;
            work = pwVar1;
            pwVar2 = staged_work;
        } while (true);
    }
    iVar3 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
    if (iVar3 == 0) {
        (*selective_yield)();
        return;
    }
    goto LAB_0001e7fa;
LAB_0001e6e4:
    iVar7 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
    if (iVar7 == 0) {
        (*selective_yield)();
        if (((iVar3 != 0) && (opt_debug != false)) &&
            ((use_syslog != false ||
              ((opt_log_output != false || (6 < opt_log_level)))))) {
            snprintf(
                tmp42, 0x1000,
                "Cleared %d work items due to stratum disconnect on pool %d",
                iVar3, pool->pool_no);
            _applog(7, tmp42, false);
        }
        return;
    }
LAB_0001e7fa:
    piVar4 = __errno_location();
    iVar3 = *piVar4;
    __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    uVar16 = 0x1b72;
LAB_0001e7e0:
    snprintf(tmp42, 0x1000, __format, iVar3, "cgminer.c", "clear_pool_work",
             uVar16);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void switch_pools(pool *selected)

{
    pool_strategy pVar1;
    pool *pool;
    int iVar2;
    int iVar3;
    pool **pppVar4;
    int *piVar5;
    pool **pppVar6;
    char *__format;
    int iVar7;
    undefined4 uVar8;
    pool *ppVar9;
    int iVar10;
    int iVar11;
    pool **pppVar12;
    char tmp42[4096];

    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
    if (iVar2 == 0) {
        iVar3 = pthread_rwlock_wrlock((pthread_rwlock_t *)&control_lock.rwlock);
        pppVar12 = pools;
        iVar2 = total_pools;
        pool = currentpool;
        pVar1 = pool_strategy;
        if (iVar3 != 0) {
            piVar5 = __errno_location();
            iVar2 = *piVar5;
            __format = "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            uVar8 = 0x13ed;
            goto LAB_0001ead4;
        }
        iVar10 = currentpool->pool_no;
        iVar3 = 0;
        if (selected == (pool *)0x0) {
            switch (pool_strategy) {
            case POOL_FAILOVER:
            case POOL_LOADBALANCE:
            case POOL_BALANCE:
            switchD_0001e8f0_caseD_0:
            switchD_0001eba8_caseD_0:
                if (0 < iVar2)
                    goto switchD_0001e8e0_caseD_0;
            default:
            switchD_0001eba8_default:
                ppVar9 = pools[iVar10];
                break;
            case POOL_ROUNDROBIN:
            case POOL_ROTATE:
            LAB_0001ea70:
                if (1 < total_pools) {
                    iVar3 = 1;
                    iVar2 = iVar10;
                    do {
                        iVar2 = iVar2 + 1;
                        if (iVar2 < total_pools) {
                            pppVar6 = pppVar12 + iVar2;
                        } else {
                            iVar2 = 0;
                            pppVar6 = pppVar12;
                        }
                        ppVar9 = *pppVar6;
                        if ((ppVar9->idle == false) &&
                            (ppVar9->enabled == POOL_ENABLED))
                            goto LAB_0001e932;
                        iVar3 = iVar3 + 1;
                    } while (iVar3 != total_pools);
                }
            switchD_0001e8e0_default:
                ppVar9 = pppVar12[iVar10];
            }
        } else {
            iVar11 = selected->prio;
            if (iVar11 != 0) {
                if (total_pools < 1) {
                    selected->prio = 0;
                    switch (pVar1) {
                    case POOL_FAILOVER:
                    case POOL_LOADBALANCE:
                    case POOL_BALANCE:
                        goto switchD_0001eba8_caseD_0;
                    case POOL_ROUNDROBIN:
                    case POOL_ROTATE:
                        goto switchD_0001eba8_caseD_1;
                    default:
                        goto switchD_0001eba8_default;
                    }
                }
                pppVar4 = pools + total_pools;
                pppVar6 = pools;
                while (true) {
                    iVar7 = (*pppVar6)->prio;
                    iVar2 = iVar7;
                    if (iVar7 < iVar11) {
                        iVar2 = iVar7 + 1;
                    }
                    if (iVar7 < iVar11) {
                        (*pppVar6)->prio = iVar2;
                    }
                    if (pppVar4 == pppVar6 + 1)
                        break;
                    iVar11 = selected->prio;
                    pppVar6 = pppVar6 + 1;
                }
                selected->prio = 0;
                switch (pVar1) {
                case POOL_FAILOVER:
                case POOL_LOADBALANCE:
                case POOL_BALANCE:
                    goto switchD_0001e8e0_caseD_0;
                case POOL_ROUNDROBIN:
                case POOL_ROTATE:
                    goto switchD_0001e8e0_caseD_1;
                default:
                    goto switchD_0001e8e0_default;
                }
            }
            switch (pool_strategy) {
            case POOL_FAILOVER:
            case POOL_LOADBALANCE:
            case POOL_BALANCE:
                goto switchD_0001e8f0_caseD_0;
            case POOL_ROUNDROBIN:
            case POOL_ROTATE:
            switchD_0001eba8_caseD_1:
                pppVar12 = pools;
            switchD_0001e8e0_caseD_1:
                if (selected->idle != false)
                    goto LAB_0001ea70;
                ppVar9 = pppVar12[selected->pool_no];
                break;
            default:
                goto switchD_0001eba8_default;
            }
        }
        goto LAB_0001e932;
    }
    piVar5 = __errno_location();
    iVar2 = *piVar5;
    uVar8 = 0x13ed;
LAB_0001eac4:
    __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    goto LAB_0001ead4;
switchD_0001e8e0_caseD_0:
    do {
        ppVar9 = priority_pool(iVar3);
        if ((ppVar9->idle == false) && (ppVar9->enabled == POOL_ENABLED)) {
            ppVar9 = pools[ppVar9->pool_no];
            goto LAB_0001e932;
        }
        iVar3 = iVar3 + 1;
    } while (iVar3 < total_pools);
    ppVar9 = pools[iVar10];
LAB_0001e932:
    currentpool = ppVar9;
    iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&control_lock.rwlock);
    if (iVar2 != 0) {
        piVar5 = __errno_location();
        iVar2 = *piVar5;
        __format = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar8 = 0x142b;
        goto LAB_0001ead4;
    }
    iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
    if (iVar2 == 0) {
        (*selective_yield)();
        if (opt_fail_only != false) {
            pool_tset(ppVar9, &ppVar9->lagging);
        }
        if ((pool != ppVar9) && (1 < pool_strategy - POOL_LOADBALANCE)) {
            if ((use_syslog != false) ||
                ((opt_log_output != false || (3 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "Switching to pool %d %s",
                         ppVar9->pool_no, ppVar9->rpc_url);
                _applog(4, tmp42, false);
            }
            clear_pool_work(pool);
        }
        iVar2 = pthread_mutex_lock((pthread_mutex_t *)&lp_lock);
        if (iVar2 != 0) {
            piVar5 = __errno_location();
            iVar2 = *piVar5;
            uVar8 = 0x143a;
            goto LAB_0001eac4;
        }
        pthread_cond_broadcast((pthread_cond_t *)&lp_cond);
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&lp_lock);
        if (iVar2 == 0) {
            (*selective_yield)();
            return;
        }
        piVar5 = __errno_location();
        iVar2 = *piVar5;
        uVar8 = 0x143c;
    } else {
        piVar5 = __errno_location();
        iVar2 = *piVar5;
        uVar8 = 0x142b;
    }
    __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
LAB_0001ead4:
    snprintf(tmp42, 0x1000, __format, iVar2, "cgminer.c", "switch_pools",
             uVar8);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void pool_failed(pool *pool)

{
    _Bool _Var1;
    pool *ppVar2;

    _Var1 = pool_tset(pool, &pool->idle);
    if (!_Var1) {
        cgtime(&pool->tv_idle);
        ppVar2 = current_pool();
        if (pool == ppVar2) {
            switch_pools((pool *)0x0);
            return;
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void pool_died(pool *pool)

{
    _Bool _Var1;
    pool *ppVar2;
    char tmp42[4096];

    _Var1 = pool_tset(pool, &pool->idle);
    if (!_Var1) {
        cgtime(&pool->tv_idle);
        ppVar2 = current_pool();
        if (pool == ppVar2) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Pool %d %s not responding!",
                         pool->pool_no, pool->rpc_url);
                _applog(4, tmp42, false);
            }
            switch_pools((pool *)0x0);
            return;
        }
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "Pool %d %s failed to return work",
                     pool->pool_no, pool->rpc_url);
            _applog(7, tmp42, false);
            return;
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void *test_pool_thread(void *arg)

{
    _Bool _Var1;
    int iVar2;
    int iVar3;
    pthread_t __th;
    int *piVar4;
    char *__format;
    undefined4 uVar5;
    char tmp42[4096];

    if (*(char *)((int)arg + 0x8b) == '\0') {
        __th = pthread_self();
        pthread_detach(__th);
    }
    while (_Var1 = pool_active((pool *)arg, false), !_Var1) {
        pool_died((pool *)arg);
        sleep(5);
    }
    pool_tset((pool *)arg, (_Bool *)((int)arg + 0x82));
    pool_tclear((pool *)arg, (_Bool *)((int)arg + 0x81));
    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
    if (iVar2 == 0) {
        iVar2 = pthread_rwlock_wrlock((pthread_rwlock_t *)&control_lock.rwlock);
        if (iVar2 == 0) {
            iVar2 = 0;
            if (pools_active == false) {
                /* WARNING: Load size is inaccurate */
                iVar2 = *arg;
                pools_active = true;
                currentpool = (pool *)arg;
                if (iVar2 != 0) {
                    iVar2 = 1;
                }
            }
            iVar3 =
                pthread_rwlock_unlock((pthread_rwlock_t *)&control_lock.rwlock);
            if (iVar3 == 0) {
                iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
                if (iVar3 == 0) {
                    (*selective_yield)();
                    if (((iVar2 != 0) && (opt_debug != false)) &&
                        ((use_syslog != false || ((opt_log_output != false ||
                                                   (6 < opt_log_level)))))) {
                        /* WARNING: Load size is inaccurate */
                        snprintf(tmp42, 0x1000,
                                 "Switching to pool %d %s - first alive pool",
                                 *arg, *(undefined4 *)((int)arg + 0xc4));
                        _applog(7, tmp42, false);
                    }
                    pool_resus((pool *)arg);
                    switch_pools((pool *)0x0);
                    *(undefined1 *)((int)arg + 0x13c) = 0;
                    return (void *)0x0;
                }
                piVar4 = __errno_location();
                iVar2 = *piVar4;
                __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                uVar5 = 0x2720;
            } else {
                piVar4 = __errno_location();
                iVar2 = *piVar4;
                __format = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                uVar5 = 0x2720;
            }
        } else {
            piVar4 = __errno_location();
            iVar2 = *piVar4;
            __format = "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            uVar5 = 0x2718;
        }
    } else {
        piVar4 = __errno_location();
        iVar2 = *piVar4;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar5 = 0x2718;
    }
    snprintf(tmp42, 0x1000, __format, iVar2, "cgminer.c", "test_pool_thread",
             uVar5);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void *watchpool_thread(void *userdata)

{
    stratum_share *psVar1;
    stratum_share *__ptr;
    _Bool _Var2;
    uint uVar3;
    int iVar4;
    time_t tVar5;
    void *pvVar6;
    UT_hash_bucket *pUVar7;
    int *piVar8;
    list_head *plVar9;
    uint uVar10;
    UT_hash_handle *pUVar11;
    undefined4 uVar12;
    list_head *plVar13;
    list_head *plVar14;
    stratum_share *psVar15;
    char *pcVar16;
    pthread_mutex_t *__mutex;
    list_head *plVar17;
    pool *ppVar18;
    work *work;
    pool *ppVar19;
    char *pcVar20;
    int iVar21;
    int iVar22;
    UT_hash_table *pUVar23;
    bool bVar24;
    double dVar25;
    int local_1060;
    stratum_share *local_1054;
    timeval now;
    timeval now_1;
    char tmp42[4096];

    pthread_setcanceltype(1, (int *)0x0);
    local_1060 = 0;
    RenameThread("Watchpool");
    set_lowprio();
    while (true) {
        local_1060 = local_1060 + 1;
        if (0x14 < local_1060) {
            local_1060 = 0;
        }
        cgtime(&now);
        if (0 < total_pools)
            break;
    LAB_0001eff8:
        ppVar19 = current_pool();
        if (ppVar19->idle != false) {
            switch_pools((pool *)0x0);
        }
        if ((pool_strategy == POOL_ROTATE) &&
            (iVar21 = now.tv_sec - rotate_tv.tv_sec,
             iVar21 != opt_rotate_period * 0x3c &&
                 iVar21 + opt_rotate_period * -0x3c < 0 ==
                     SBORROW4(iVar21, opt_rotate_period * 0x3c))) {
            cgtime(&rotate_tv);
            switch_pools((pool *)0x0);
        }
        cgsleep_ms(30000);
    }
    iVar21 = 0;
LAB_0001ef4a:
    ppVar19 = pools[iVar21];
    if ((opt_benchmark == false) && (opt_benchfile == (char *)0x0)) {
        __mutex = &ppVar19->pool_lock;
        cgtime(&now_1);
        iVar4 = pthread_mutex_lock((pthread_mutex_t *)__mutex);
        if (iVar4 != 0) {
            piVar8 = __errno_location();
            uVar12 = 0x251f;
            pcVar16 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            pcVar20 = "reap_curl";
            goto LAB_0001f3ca;
        }
        plVar9 = (ppVar19->curlring).next;
        if (&ppVar19->curlring == plVar9) {
        LAB_0001f39c:
            iVar4 = pthread_mutex_unlock((pthread_mutex_t *)__mutex);
            if (iVar4 != 0)
                goto LAB_0001f3ea;
            (*selective_yield)();
        LAB_0001f180:
            tVar5 = time((time_t *)0x0);
            iVar4 = pthread_mutex_lock((pthread_mutex_t *)&sshare_lock);
            if (iVar4 != 0) {
                piVar8 = __errno_location();
                uVar12 = 0x253c;
                pcVar20 = "prune_stratum_shares";
                pcVar16 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                goto LAB_0001f3ca;
            }
            if (stratum_shares != (stratum_share *)0x0) {
                ppVar18 = stratum_shares->work->pool;
                uVar3 = 0;
                psVar15 = (stratum_share *)(stratum_shares->hh).next;
                __ptr = stratum_shares;
                local_1054 = stratum_shares;
                do {
                    psVar1 = psVar15;
                    stratum_shares = local_1054;
                    if ((ppVar19 == ppVar18) &&
                        (__ptr->sshare_time + 0x78 < tVar5)) {
                        pvVar6 = (__ptr->hh).prev;
                        pUVar23 = (local_1054->hh).tbl;
                        if (pvVar6 == (void *)0x0) {
                            psVar15 = (stratum_share *)(__ptr->hh).next;
                            if (psVar15 != (stratum_share *)0x0) {
                                iVar4 = pUVar23->hho;
                                if (__ptr ==
                                    (stratum_share *)((int)pUVar23->tail -
                                                      iVar4))
                                    goto LAB_0001f344;
                            LAB_0001f334:
                                local_1054 = psVar15;
                                stratum_shares = local_1054;
                                goto LAB_0001f1ee;
                            }
                            free(pUVar23->buckets);
                            free((local_1054->hh).tbl);
                            stratum_shares = psVar15;
                        } else {
                            iVar4 = pUVar23->hho;
                            if (__ptr ==
                                (stratum_share *)((int)pUVar23->tail - iVar4)) {
                            LAB_0001f344:
                                pUVar23->tail =
                                    (UT_hash_handle *)(iVar4 + (int)pvVar6);
                                pvVar6 = (__ptr->hh).prev;
                                if (pvVar6 == (void *)0x0) {
                                    psVar15 = (stratum_share *)(__ptr->hh).next;
                                    goto LAB_0001f334;
                                }
                                iVar4 = ((local_1054->hh).tbl)->hho;
                            }
                            *(void **)((int)pvVar6 + iVar4 + 8) =
                                (__ptr->hh).next;
                        LAB_0001f1ee:
                            pvVar6 = (__ptr->hh).next;
                            if (pvVar6 != (void *)0x0) {
                                *(void **)((int)pvVar6 +
                                           ((local_1054->hh).tbl)->hho + 4) =
                                    (__ptr->hh).prev;
                            }
                            pUVar23 = (local_1054->hh).tbl;
                            pUVar7 = pUVar23->buckets;
                            uVar10 =
                                pUVar23->num_buckets - 1 & (__ptr->hh).hashv;
                            pUVar7[uVar10].count = pUVar7[uVar10].count - 1;
                            pUVar7 = ((local_1054->hh).tbl)->buckets;
                            if ((stratum_share *)pUVar7[uVar10].hh_head ==
                                __ptr) {
                                pUVar7[uVar10].hh_head = (__ptr->hh).hh_next;
                            }
                            pUVar11 = (__ptr->hh).hh_prev;
                            if (pUVar11 != (UT_hash_handle *)0x0) {
                                pUVar11->hh_next = (__ptr->hh).hh_next;
                            }
                            pUVar11 = (__ptr->hh).hh_next;
                            if (pUVar11 != (UT_hash_handle *)0x0) {
                                pUVar11->hh_prev = (__ptr->hh).hh_prev;
                            }
                            pUVar23 = (local_1054->hh).tbl;
                            pUVar23->num_items = pUVar23->num_items - 1;
                        }
                        work = __ptr->work;
                        uVar3 = uVar3 + 1;
                        clean_work(work);
                        free(work);
                        free(__ptr);
                    }
                    if (psVar1 == (stratum_share *)0x0)
                        goto LAB_0001f260;
                    ppVar18 = psVar1->work->pool;
                    psVar15 = (stratum_share *)(psVar1->hh).next;
                    __ptr = psVar1;
                    local_1054 = stratum_shares;
                } while (true);
            }
            iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
            if (iVar4 == 0) {
                (*selective_yield)();
                goto LAB_0001ef62;
            }
            goto LAB_0001f42a;
        }
        iVar22 = ppVar19->curls;
        iVar4 = 0;
        plVar14 = plVar9->next;
        if (iVar22 < 2)
            goto LAB_0001f39c;
        do {
            plVar13 = plVar14;
            if (now_1.tv_sec - (int)plVar9[1].next < 0x12d) {
                plVar14 = plVar13->next;
            } else {
                iVar4 = iVar4 + 1;
                ppVar19->curls = iVar22 + -1;
                plVar14 = plVar9->next;
                plVar17 = plVar9->prev;
                plVar14->prev = plVar17;
                plVar17->next = plVar14;
                free(&plVar9[-1].prev);
                plVar14 = plVar13->next;
            }
        } while ((&ppVar19->curlring != plVar13) &&
                 (iVar22 = ppVar19->curls, plVar9 = plVar13, 1 < iVar22));
        iVar22 = pthread_mutex_unlock((pthread_mutex_t *)__mutex);
        if (iVar22 == 0) {
            (*selective_yield)();
            if (((iVar4 != 0) && (opt_debug != false)) &&
                ((use_syslog != false ||
                  ((opt_log_output != false || (6 < opt_log_level)))))) {
                pcVar16 = "s";
                if (iVar4 == 1) {
                    pcVar16 = "";
                }
                snprintf(tmp42, 0x1000, "Reaped %d curl%s from pool %d", iVar4,
                         pcVar16, ppVar19->pool_no);
                _applog(7, tmp42, false);
            }
            goto LAB_0001f180;
        }
    LAB_0001f3ea:
        pcVar20 = "reap_curl";
        piVar8 = __errno_location();
        uVar12 = 0x252d;
        goto LAB_0001f3fc;
    }
    goto LAB_0001ef62;
LAB_0001f260:
    iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
    if (iVar4 != 0) {
    LAB_0001f42a:
        piVar8 = __errno_location();
        pcVar20 = "prune_stratum_shares";
        uVar12 = 0x2547;
    LAB_0001f3fc:
        pcVar16 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    LAB_0001f3ca:
        snprintf(tmp42, 0x1000, pcVar16, *piVar8, "cgminer.c", pcVar20, uVar12);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    (*selective_yield)();
    if (uVar3 != 0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            snprintf(
                tmp42, 0x1000,
                "Lost %d shares due to no stratum share response from pool %d",
                uVar3, ppVar19->pool_no);
            _applog(4, tmp42, false);
        }
        ppVar19->stale_shares = ppVar19->stale_shares + uVar3;
        bVar24 = CARRY4((uint)total_stale, uVar3);
        total_stale._0_4_ = (uint)total_stale + uVar3;
        total_stale._4_4_ =
            total_stale._4_4_ + ((int)uVar3 >> 0x1f) + (uint)bVar24;
    }
LAB_0001ef62:
    if (local_1060 == 0x14) {
        uVar3 = ppVar19->last_shares;
        uVar10 = (uint)ppVar19->diff1;
        dVar25 = (double)__aeabi_l2d(
            uVar10 - uVar3,
            (*(int *)((int)&ppVar19->diff1 + 4) - ((int)uVar3 >> 0x1f)) -
                (uint)(uVar10 < uVar3));
        ppVar19->last_shares = uVar10;
        dVar25 = (ppVar19->utility + dVar25 * 0.63) / 1.63;
        ppVar19->utility = dVar25;
        ppVar19->shares = (int)(longlong)dVar25;
    }
    if ((ppVar19->enabled != POOL_DISABLED) && (ppVar19->testing == false)) {
        if (ppVar19->idle != false) {
            if (now.tv_sec - (ppVar19->tv_idle).tv_sec < 0x1f)
                goto LAB_0001ef40;
            _Var2 = pool_active(ppVar19, true);
            if ((_Var2) &&
                (_Var2 = pool_tclear(ppVar19, &ppVar19->idle), _Var2)) {
                pool_resus(ppVar19);
            } else {
                cgtime(&ppVar19->tv_idle);
            }
            if (ppVar19->idle != false) {
                iVar21 = iVar21 + 1;
                if (total_pools <= iVar21)
                    goto LAB_0001eff8;
                goto LAB_0001ef4a;
            }
        }
        if (((pool_strategy == POOL_FAILOVER) &&
             (iVar22 = ppVar19->prio, iVar4 = cp_prio(), iVar22 < iVar4)) &&
            (300 < now.tv_sec - (ppVar19->tv_idle).tv_sec)) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Pool %d %s stable for 5 mins",
                         ppVar19->pool_no, ppVar19->rpc_url);
                _applog(4, tmp42, false);
            }
            switch_pools((pool *)0x0);
        }
    }
LAB_0001ef40:
    iVar21 = iVar21 + 1;
    if (total_pools <= iVar21)
        goto LAB_0001eff8;
    goto LAB_0001ef4a;
}

/* WARNING: Unknown calling convention */

void clear_stratum_shares(pool *pool)

{
    stratum_share *psVar1;
    stratum_share *__ptr;
    stratum_share *psVar2;
    int iVar3;
    void *pvVar4;
    int *piVar5;
    UT_hash_bucket *pUVar6;
    stratum_share *psVar7;
    uint uVar8;
    UT_hash_handle *pUVar9;
    char *__format;
    pool *ppVar10;
    UT_hash_handle *pUVar11;
    stratum_share *psVar12;
    work *work;
    uint uVar13;
    UT_hash_table *pUVar14;
    bool bVar15;
    double dVar16;
    undefined4 uVar17;
    char tmp42[4096];

    iVar3 = pthread_mutex_lock((pthread_mutex_t *)&sshare_lock);
    if (iVar3 != 0) {
        piVar5 = __errno_location();
        iVar3 = *piVar5;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar17 = 0x1b4a;
        goto LAB_0001f69a;
    }
    if (stratum_shares != (stratum_share *)0x0) {
        dVar16 = 0.0;
        ppVar10 = stratum_shares->work->pool;
        uVar13 = 0;
        psVar7 = (stratum_share *)(stratum_shares->hh).next;
        __ptr = stratum_shares;
        psVar2 = stratum_shares;
        do {
            psVar1 = psVar7;
            stratum_shares = psVar2;
            if (ppVar10 == pool) {
                pvVar4 = (__ptr->hh).prev;
                pUVar14 = (psVar2->hh).tbl;
                if (pvVar4 == (void *)0x0) {
                    psVar7 = (stratum_share *)(__ptr->hh).next;
                    if (psVar7 != (stratum_share *)0x0) {
                        iVar3 = pUVar14->hho;
                        psVar12 = psVar7;
                        stratum_shares = psVar7;
                        if (__ptr ==
                            (stratum_share *)((int)pUVar14->tail - iVar3))
                            goto LAB_0001f62a;
                        goto LAB_0001f4ea;
                    }
                    free(pUVar14->buckets);
                    free((psVar2->hh).tbl);
                    stratum_shares = psVar7;
                } else {
                    iVar3 = pUVar14->hho;
                    if (__ptr ==
                        (stratum_share *)((int)pUVar14->tail - iVar3)) {
                    LAB_0001f62a:
                        stratum_shares = psVar2;
                        pUVar14->tail = (UT_hash_handle *)(iVar3 + (int)pvVar4);
                        pvVar4 = (__ptr->hh).prev;
                        if (pvVar4 == (void *)0x0) {
                            psVar7 = (stratum_share *)(__ptr->hh).next;
                            psVar12 = psVar7;
                            stratum_shares = psVar7;
                            goto LAB_0001f4ea;
                        }
                        iVar3 = ((psVar2->hh).tbl)->hho;
                    }
                    *(void **)((int)pvVar4 + iVar3 + 8) = (__ptr->hh).next;
                    psVar7 = (stratum_share *)(__ptr->hh).next;
                    psVar12 = psVar2;
                LAB_0001f4ea:
                    pUVar14 = (psVar12->hh).tbl;
                    if (psVar7 != (stratum_share *)0x0) {
                        *(void **)((int)&(psVar7->hh).prev + pUVar14->hho) =
                            (__ptr->hh).prev;
                        pUVar14 = (psVar12->hh).tbl;
                    }
                    uVar8 = pUVar14->num_buckets - 1 & (__ptr->hh).hashv;
                    pUVar14->buckets[uVar8].count =
                        pUVar14->buckets[uVar8].count - 1;
                    pUVar6 = ((psVar12->hh).tbl)->buckets;
                    if ((stratum_share *)pUVar6[uVar8].hh_head == __ptr) {
                        pUVar6[uVar8].hh_head = (__ptr->hh).hh_next;
                    }
                    pUVar11 = (__ptr->hh).hh_prev;
                    pUVar9 = (__ptr->hh).hh_next;
                    if (pUVar11 != (UT_hash_handle *)0x0) {
                        pUVar11->hh_next = pUVar9;
                        pUVar9 = (__ptr->hh).hh_next;
                    }
                    if (pUVar9 != (UT_hash_handle *)0x0) {
                        pUVar9->hh_prev = (__ptr->hh).hh_prev;
                    }
                    pUVar14 = (psVar12->hh).tbl;
                    pUVar14->num_items = pUVar14->num_items - 1;
                }
                work = __ptr->work;
                uVar13 = uVar13 + 1;
                dVar16 = dVar16 + work->work_difficulty;
                clean_work(work);
                free(work);
                __ptr->work = (work *)0x0;
                pool->sshares = pool->sshares + -1;
                free(__ptr);
            }
            if (psVar1 == (stratum_share *)0x0)
                goto LAB_0001f570;
            ppVar10 = psVar1->work->pool;
            psVar7 = (stratum_share *)(psVar1->hh).next;
            __ptr = psVar1;
            psVar2 = stratum_shares;
        } while (true);
    }
    iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
    if (iVar3 == 0) {
        (*selective_yield)();
        return;
    }
    goto LAB_0001f6b4;
LAB_0001f570:
    iVar3 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
    if (iVar3 == 0) {
        (*selective_yield)();
        if (uVar13 != 0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000,
                         "Lost %d shares due to stratum disconnect on pool %d",
                         uVar13, pool->pool_no);
                _applog(4, tmp42, false);
            }
            total_diff_stale = total_diff_stale + dVar16;
            bVar15 = CARRY4((uint)total_stale, uVar13);
            total_stale._0_4_ = (uint)total_stale + uVar13;
            total_stale._4_4_ =
                total_stale._4_4_ + ((int)uVar13 >> 0x1f) + (uint)bVar15;
            pool->diff_stale = pool->diff_stale + dVar16;
            pool->stale_shares = pool->stale_shares + uVar13;
        }
        return;
    }
LAB_0001f6b4:
    piVar5 = __errno_location();
    iVar3 = *piVar5;
    __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    uVar17 = 6999;
LAB_0001f69a:
    snprintf(tmp42, 0x1000, __format, iVar3, "cgminer.c",
             "clear_stratum_shares", uVar17);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

work *hash_pop(_Bool blocking)

{
    code *pcVar1;
    work *pwVar2;
    work *pwVar3;
    work *pwVar4;
    int iVar5;
    int *piVar6;
    UT_hash_table *pUVar7;
    work *pwVar8;
    UT_hash_bucket *pUVar9;
    UT_hash_handle *pUVar10;
    char *__format;
    void *pvVar11;
    uint uVar12;
    UT_hash_handle *pUVar13;
    work *pwVar14;
    bool bVar15;
    undefined4 uVar16;
    timespec then;
    timeval now;
    char tmp42[4096];

    pwVar4 = (work *)(uint)blocking;
    iVar5 = pthread_mutex_lock((pthread_mutex_t *)stgd_lock);
    if (iVar5 != 0) {
        piVar6 = __errno_location();
        iVar5 = *piVar6;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar16 = 0x1e23;
        goto LAB_0001fa5c;
    }
    if ((staged_work == (work *)0x0) ||
        (((staged_work->hh).tbl)->num_items == 0)) {
        if ((work_filled != false) && (max_queue < opt_queue)) {
            max_queue = max_queue + 1;
            work_filled = false;
        }
        work_emptied = true;
        if (pwVar4 != (work *)0x0) {
            do {
                cgtime(&now);
                then.tv_nsec = now.tv_usec * 1000;
                then.tv_sec = now.tv_sec + 10;
                pthread_cond_signal((pthread_cond_t *)&gws_cond);
                iVar5 = pthread_cond_timedwait((pthread_cond_t *)&getq->cond,
                                               (pthread_mutex_t *)stgd_lock,
                                               (timespec *)&then);
                if (((iVar5 != 0) && (no_work == false)) &&
                    ((no_work = true,
                      use_syslog != false || ((opt_log_output != false ||
                                               (3 < opt_log_level)))))) {
                    builtin_strncpy(
                        tmp42, "Waiting for work to be available from pools.",
                        0x2c);
                    tmp42[0x2c] = '\0';
                    _applog(4, tmp42, false);
                }
            } while ((staged_work == (work *)0x0) ||
                     (((staged_work->hh).tbl)->num_items == 0));
            goto joined_r0x0001f808;
        }
    } else {
    joined_r0x0001f808:
        if (no_work != false) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                builtin_strncpy(tmp42, "Work available from pools, resuming.",
                                0x24);
                tmp42._36_4_ = tmp42._36_4_ & 0xffffff00;
                _applog(4, tmp42, false);
            }
            no_work = false;
            if (staged_work == (work *)0x0) {
            LAB_0001f988:
                /* WARNING: Does not return */
                pcVar1 = (code *)software_udf(0xff, 0x1f98e);
                (*pcVar1)();
            }
        }
        pwVar2 = staged_work;
        pUVar7 = (staged_work->hh).tbl;
        pwVar4 = staged_work;
        if (((staged_rollable < (int)pUVar7->num_items) &&
             (staged_work->clone == false)) &&
            (staged_work->rolltime != 0)) {
            pwVar8 = (work *)(staged_work->hh).next;
            do {
                pwVar4 = pwVar8;
                if (pwVar4 == (work *)0x0)
                    goto LAB_0001f988;
            } while (
                (pwVar4->clone == false) &&
                (pwVar8 = (work *)(pwVar4->hh).next, pwVar4->rolltime != 0));
        }
        pvVar11 = (pwVar4->hh).prev;
        if (pvVar11 == (void *)0x0) {
            pwVar8 = (work *)(pwVar4->hh).next;
            if (pwVar8 != (work *)0x0) {
                iVar5 = pUVar7->hho;
                pwVar14 = pwVar8;
                pwVar3 = pwVar8;
                if (pwVar4 == (work *)((int)pUVar7->tail - iVar5))
                    goto LAB_0001f9e4;
                goto LAB_0001f858;
            }
            free(pUVar7->buckets);
            free((staged_work->hh).tbl);
            staged_work = pwVar8;
        } else {
            iVar5 = pUVar7->hho;
            if (pwVar4 == (work *)((int)pUVar7->tail - iVar5)) {
            LAB_0001f9e4:
                pUVar7->tail = (UT_hash_handle *)((int)pvVar11 + iVar5);
                pvVar11 = (pwVar4->hh).prev;
                if (pvVar11 == (void *)0x0) {
                    pwVar8 = (work *)(pwVar4->hh).next;
                    pwVar14 = pwVar8;
                    pwVar3 = pwVar8;
                    goto LAB_0001f858;
                }
                iVar5 = ((pwVar2->hh).tbl)->hho;
            }
            pwVar8 = staged_work;
            *(void **)((int)pvVar11 + iVar5 + 8) = (pwVar4->hh).next;
            pwVar14 = (work *)(pwVar4->hh).next;
            pwVar3 = staged_work;
        LAB_0001f858:
            staged_work = pwVar3;
            pUVar7 = (pwVar8->hh).tbl;
            if (pwVar14 != (work *)0x0) {
                *(void **)((int)pwVar14->data + pUVar7->hho + 4) =
                    (pwVar4->hh).prev;
                pUVar7 = (pwVar8->hh).tbl;
            }
            uVar12 = pUVar7->num_buckets - 1 & (pwVar4->hh).hashv;
            pUVar7->buckets[uVar12].count = pUVar7->buckets[uVar12].count - 1;
            pUVar9 = ((pwVar8->hh).tbl)->buckets;
            bVar15 = pUVar9[uVar12].hh_head == &pwVar4->hh;
            if (bVar15) {
                pwVar8 = (work *)(pwVar4->hh).hh_next;
            }
            if (bVar15) {
                pUVar9[uVar12].hh_head = (UT_hash_handle *)pwVar8;
            }
            pUVar10 = (pwVar4->hh).hh_prev;
            if (bVar15) {
                pwVar8 = staged_work;
            }
            pUVar13 = (pwVar4->hh).hh_next;
            if (pUVar10 != (UT_hash_handle *)0x0) {
                pUVar10->hh_next = pUVar13;
                pUVar13 = (pwVar4->hh).hh_next;
            }
            if (pUVar13 != (UT_hash_handle *)0x0) {
                pUVar13->hh_prev = (pwVar4->hh).hh_prev;
            }
            pUVar7 = (pwVar8->hh).tbl;
            pUVar7->num_items = pUVar7->num_items - 1;
        }
        if ((pwVar4->clone == false) && (pwVar4->rolltime != 0)) {
            staged_rollable = staged_rollable + -1;
        }
        pthread_cond_signal((pthread_cond_t *)&gws_cond);
        pthread_cond_signal((pthread_cond_t *)&getq->cond);
        last_getwork = time((time_t *)0x0);
    }
    iVar5 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
    if (iVar5 == 0) {
        (*selective_yield)();
        return pwVar4;
    }
    piVar6 = __errno_location();
    iVar5 = *piVar6;
    __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    uVar16 = 0x1e66;
LAB_0001fa5c:
    snprintf(tmp42, 0x1000, __format, iVar5, "cgminer.c", "hash_pop", uVar16);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void sharelog(char *disposition, work *work)

{
    thr_info *ptVar1;
    char *pcVar2;
    char *__ptr;
    char *__ptr_00;
    size_t sVar3;
    int *piVar4;
    __time_t _Var5;
    int iVar6;
    pool *ppVar7;
    cgpu_info *pcVar8;
    undefined4 uVar9;
    char s[1024];
    char tmp42[4096];

    if (sharelog_file == (FILE *)0x0) {
        return;
    }
    iVar6 = work->thr_id;
    ptVar1 = get_thread(iVar6);
    _Var5 = (work->tv_work_found).tv_sec;
    pcVar8 = ptVar1->cgpu;
    ppVar7 = work->pool;
    pcVar2 = bin2hex(work->target, 0x20);
    __ptr = bin2hex(work->hash, 0x20);
    __ptr_00 = bin2hex(work->data, 0x80);
    sVar3 = snprintf(s, 0x400, "%lu,%s,%s,%s,%s%u,%u,%s,%s\n", _Var5,
                     disposition, pcVar2, ppVar7->rpc_url, pcVar8->drv->name,
                     pcVar8->device_id, iVar6, __ptr, __ptr_00);
    free(pcVar2);
    free(__ptr);
    free(__ptr_00);
    if ((int)sVar3 < 0x400) {
        if ((int)sVar3 < 0) {
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3)) {
                return;
            }
            pcVar2 = "sharelog printf error";
            goto LAB_0001fbd8;
        }
    } else {
        s[0x3ff] = '\0';
    }
    iVar6 = pthread_mutex_lock((pthread_mutex_t *)&sharelog_lock);
    if (iVar6 == 0) {
        sVar3 = fwrite(s, sVar3, 1, (FILE *)sharelog_file);
        fflush((FILE *)sharelog_file);
        iVar6 = pthread_mutex_unlock((pthread_mutex_t *)&sharelog_lock);
        if (iVar6 == 0) {
            (*selective_yield)();
            if (sVar3 == 1) {
                return;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3)) {
                return;
            }
            pcVar2 = "sharelog fwrite error";
        LAB_0001fbd8:
            tmp42._0_4_ = *(undefined4 *)pcVar2;
            tmp42._4_4_ = *(undefined4 *)(pcVar2 + 4);
            tmp42._8_4_ = *(undefined4 *)(pcVar2 + 8);
            tmp42._12_4_ = *(undefined4 *)(pcVar2 + 0xc);
            tmp42._16_4_ = *(undefined4 *)(pcVar2 + 0x10);
            tmp42._20_2_ = (undefined2) * (undefined4 *)(pcVar2 + 0x14);
            _applog(3, tmp42, false);
            return;
        }
        piVar4 = __errno_location();
        iVar6 = *piVar4;
        pcVar2 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar9 = 0x2a4;
    } else {
        piVar4 = __errno_location();
        iVar6 = *piVar4;
        pcVar2 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar9 = 0x2a1;
    }
    snprintf(tmp42, 0x1000, pcVar2, iVar6, "cgminer.c", "sharelog", uVar9);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void gen_stratum_work(pool *pool, work *work)

{
    int iVar1;
    size_t sVar2;
    int *piVar3;
    uint uVar4;
    undefined4 uVar5;
    pthread_rwlock_t *__rwlock;
    uint64_t *__src;
    uchar *p;
    char *pcVar6;
    undefined4 uVar7;
    undefined4 uVar8;
    char tmp42[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&pool->data_lock);
    if (iVar1 != 0) {
        piVar3 = __errno_location();
        iVar1 = *piVar3;
        pcVar6 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar5 = 0x1f0d;
        goto LAB_0001ff5c;
    }
    __rwlock = &(pool->data_lock).rwlock;
    iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)__rwlock);
    if (iVar1 != 0) {
        piVar3 = __errno_location();
        iVar1 = *piVar3;
        pcVar6 = "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar5 = 0x1f0d;
        goto LAB_0001ff5c;
    }
    uVar4 = (uint)pool->nonce2;
    __src = &work->nonce2;
    iVar1 = *(int *)((int)&pool->nonce2 + 4);
    *(uint *)&pool->nonce2 = uVar4 + 1;
    *(uint *)((int)&pool->nonce2 + 4) = iVar1 + (uint)(0xfffffffe < uVar4);
    *(uint *)__src = uVar4;
    *(int *)((int)&work->nonce2 + 4) = iVar1;
    work->nonce2_len = 2;
    iVar1 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
    if (iVar1 != 0) {
        piVar3 = __errno_location();
        iVar1 = *piVar3;
        uVar5 = 0x1f12;
    LAB_0001ffb0:
        pcVar6 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
    LAB_0001ff5c:
        snprintf(tmp42, 0x1000, pcVar6, iVar1, "cgminer.c", "gen_stratum_work",
                 uVar5);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)__rwlock);
    if (iVar1 != 0) {
        piVar3 = __errno_location();
        iVar1 = *piVar3;
        pcVar6 = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar5 = 0x1f12;
        goto LAB_0001ff5c;
    }
    iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&pool->data_lock);
    if (iVar1 != 0) {
        piVar3 = __errno_location();
        iVar1 = *piVar3;
        pcVar6 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar5 = 0x1f12;
        goto LAB_0001ff5c;
    }
    p = work->equihash_data;
    memset(p, 0, 0x5cf);
    memcpy(p, pool->header_bin, 0x80);
    pcVar6 = pool->nonce1;
    sVar2 = strlen(pcVar6);
    hex2bin(work->equihash_data + 0x6c, pcVar6, sVar2 >> 1);
    memcpy(p + (0x80 - work->nonce2_len), __src, work->nonce2_len);
    work->equihash_data[0x8c] = 0xfd;
    work->equihash_data[0x8d] = '@';
    work->equihash_data[0x8e] = '\x05';
    uVar5 = *(undefined4 *)((int)&(pool->swork).diff + 4);
    *(undefined4 *)&work->sdiff = *(undefined4 *)&(pool->swork).diff;
    *(undefined4 *)((int)&work->sdiff + 4) = uVar5;
    pcVar6 = (char *)__strdup((pool->swork).job_id);
    work->job_id = pcVar6;
    pcVar6 = (char *)__strdup(pool->nonce1);
    work->nonce1 = pcVar6;
    pcVar6 = (char *)__strdup((pool->swork).ntime);
    work->ntime = pcVar6;
    iVar1 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
    if (iVar1 != 0) {
        piVar3 = __errno_location();
        iVar1 = *piVar3;
        uVar5 = 0x1f27;
        goto LAB_0001ffb0;
    }
    (*selective_yield)();
    if (opt_debug == false)
        goto LAB_0001fdca;
    pcVar6 = bin2hex(p, 0x8f);
    if (opt_debug != false) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
        LAB_0001fee0:
            if ((opt_log_output != false) || (6 < opt_log_level)) {
            LAB_0001fef6:
                snprintf(tmp42, 0x1000,
                         "[THR%d] job_id %s, nonce1 %s, nonce2 %llu, ntime %s",
                         work->thr_id, work->job_id, work->nonce1, (int)*__src,
                         *(undefined4 *)((int)&work->nonce2 + 4), work->ntime);
                _applog(7, tmp42, false);
            }
        } else {
            snprintf(tmp42, 0x1000, "[THR%d] Generated stratum header %s",
                     work->thr_id, pcVar6);
            _applog(7, tmp42, false);
            if (opt_debug != false) {
                if (use_syslog == false)
                    goto LAB_0001fee0;
                goto LAB_0001fef6;
            }
        }
    }
    free(pcVar6);
LAB_0001fdca:
    uVar8 = *(undefined4 *)(pool->Target + 4);
    uVar7 = *(undefined4 *)(pool->Target + 8);
    uVar5 = *(undefined4 *)(pool->Target + 0xc);
    local_work = local_work + 1;
    *(undefined4 *)work->target = *(undefined4 *)pool->Target;
    *(undefined4 *)(work->target + 4) = uVar8;
    *(undefined4 *)(work->target + 8) = uVar7;
    *(undefined4 *)(work->target + 0xc) = uVar5;
    uVar5 = *(undefined4 *)(pool->Target + 0x10);
    uVar8 = *(undefined4 *)(pool->Target + 0x14);
    uVar7 = *(undefined4 *)(pool->Target + 0x18);
    *(undefined4 *)(work->target + 0x1c) = *(undefined4 *)(pool->Target + 0x1c);
    uVar4 = work_block;
    *(undefined4 *)(work->target + 0x10) = uVar5;
    *(undefined4 *)(work->target + 0x14) = uVar8;
    *(undefined4 *)(work->target + 0x18) = uVar7;
    work->id = total_work;
    total_work = total_work + 1;
    work->work_block = uVar4;
    work->getwork_mode = 'S';
    work->drv_rolllimit = 0x3c;
    work->pool = pool;
    work->stratum = true;
    work->longpoll = false;
    calc_diff(work, work->sdiff);
    cgtime(&work->tv_staged);
    return;
}

/* WARNING: Unknown calling convention */

_Bool stale_work(work *work, _Bool share)

{
    _Bool _Var1;
    _Bool _Var2;
    pool *ppVar3;
    int iVar4;
    int iVar5;
    int iVar6;
    int *piVar7;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    undefined4 uVar8;
    char *pcVar9;
    pool *ppVar10;
    pthread_rwlock_t *__rwlock;
    timeval now;
    char tmp42[4096];

    uVar8 = tmp42._32_4_;
    _Var2 = opt_debug;
    _Var1 = opt_benchmark;
    if (opt_benchmark) {
        return false;
    }
    if (opt_benchfile != (char *)0x0) {
        return opt_benchmark;
    }
    if (work->work_block != work_block) {
        if (!opt_debug) {
            return true;
        }
        if (((!use_syslog) && (!opt_log_output)) && (opt_log_level < 7)) {
            return opt_debug;
        }
        builtin_strncpy(tmp42, "Work stale due to block mismatch", 0x20);
        tmp42._32_4_ = tmp42._32_4_ & 0xffffff00;
        _applog(7, tmp42, false);
        return _Var2;
    }
    ppVar10 = work->pool;
    iVar6 = work->rolltime;
    if (work->rolltime <= opt_scantime) {
        iVar6 = opt_expiry;
    }
    if ((share) || (ppVar10->has_stratum == false)) {
    LAB_00020188:
        iVar6 =
            iVar6 -
            (int)(longlong)((ppVar10->cgminer_pool_stats).getwork_wait_rolling *
                                5.0 +
                            1.0);
        cgtime(&now);
        _Var2 = opt_debug;
        if (iVar6 < 5) {
            iVar6 = 5;
        }
        if (now.tv_sec - (work->tv_staged).tv_sec < iVar6) {
            if (opt_fail_only != true || share) {
                return _Var1;
            }
            ppVar3 = current_pool();
            if (ppVar10 == ppVar3) {
                return _Var1;
            }
            if (work->mandatory != false) {
                return _Var1;
            }
            if (pool_strategy - POOL_LOADBALANCE < 2) {
                return _Var1;
            }
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                pcVar9 = "Work stale due to fail only pool mismatch";
            LAB_0002028e:
                _Var1 = opt_debug;
                tmp42._0_4_ = *(undefined4 *)pcVar9;
                tmp42._4_4_ = *(undefined4 *)(pcVar9 + 4);
                tmp42._8_4_ = *(undefined4 *)(pcVar9 + 8);
                tmp42._12_4_ = *(undefined4 *)(pcVar9 + 0xc);
                tmp42._16_4_ = *(undefined4 *)(pcVar9 + 0x10);
                tmp42._20_4_ = *(undefined4 *)(pcVar9 + 0x14);
                tmp42._24_4_ = *(undefined4 *)(pcVar9 + 0x18);
                tmp42._28_4_ = *(undefined4 *)(pcVar9 + 0x1c);
                tmp42._32_4_ = *(undefined4 *)(pcVar9 + 0x20);
                tmp42._36_4_ = *(undefined4 *)(pcVar9 + 0x24);
                tmp42._40_2_ = (undefined2) * (undefined4 *)(pcVar9 + 0x28);
                _applog(7, tmp42, false);
                return _Var1;
            }
        } else if ((opt_debug != false) &&
                   (((use_syslog != false || (opt_log_output != false)) ||
                     (6 < opt_log_level)))) {
            builtin_strncpy(tmp42, "Work stale due to expiry", 0x18);
            tmp42._24_4_ = tmp42._24_4_ & 0xffffff00;
            _applog(7, tmp42, false);
            return _Var2;
        }
        return true;
    }
    if ((ppVar10->stratum_active == false) ||
        (ppVar10->stratum_notify == false)) {
        if (!opt_debug) {
            return true;
        }
        if (((!use_syslog) && (!opt_log_output)) && (opt_log_level < 7)) {
            return true;
        }
        builtin_strncpy(tmp42, "Work stale due to stratum inactive", 0x23);
        tmp42[0x23] = SUB41(uVar8, 3);
        _applog(7, tmp42, false);
        return _Var2;
    }
    iVar4 = pthread_mutex_lock((pthread_mutex_t *)&ppVar10->data_lock);
    if (iVar4 == 0) {
        __rwlock = &(ppVar10->data_lock).rwlock;
        iVar5 = pthread_rwlock_rdlock((pthread_rwlock_t *)__rwlock);
        pcVar9 = extraout_r2;
        iVar4 = extraout_r3;
        if (iVar5 != 0)
            goto LAB_00020344;
        iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&ppVar10->data_lock);
        if (iVar4 != 0) {
            piVar7 = __errno_location();
            uVar8 = 0x1347;
            pcVar9 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
            goto LAB_0002036a;
        }
        iVar4 = strcmp(work->job_id, (ppVar10->swork).job_id);
        if (iVar4 == 0) {
            iVar4 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
            if (iVar4 == 0) {
                (*selective_yield)();
                goto LAB_00020188;
            }
        } else {
            iVar6 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
            if (iVar6 == 0) {
                (*selective_yield)();
                if (opt_debug == false) {
                    return true;
                }
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 7)) {
                    return true;
                }
                pcVar9 = "Work stale due to stratum job_id mismatch";
                goto LAB_0002028e;
            }
        }
    } else {
        _mutex_lock((pthread_mutex_t *)"stale_work", (char *)0x1347, func,
                    line);
        pcVar9 = extraout_r2_00;
        iVar4 = extraout_r3_00;
    LAB_00020344:
        _rd_lock((pthread_rwlock_t *)"stale_work", (char *)0x1347, pcVar9,
                 iVar4);
    }
    piVar7 = __errno_location();
    uVar8 = 0x134a;
    pcVar9 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
LAB_0002036a:
    snprintf(tmp42, 0x1000, pcVar9, *piVar7, "cgminer.c", "stale_work", uVar8);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

work *get_work(thr_info *thr, int thr_id)

{
    _Bool _Var1;
    time_t tVar2;
    work *work;
    time_t tVar3;
    char **__src;
    char cVar4;
    char **ppcVar5;
    int iVar6;
    cgpu_info *cgpu;
    cgpu_info *pcVar7;
    bool bVar8;
    bool bVar9;
    bool bVar10;
    double dVar11;
    double dVar12;
    char tmp42[4096];

    pcVar7 = thr->cgpu;
    thread_reportout(thr);
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Popping work from get queue to get work", 0x28);
        _applog(7, tmp42, false);
    }
    tVar2 = time((time_t *)0x0);
    do {
        while (true) {
            work = hash_pop(true);
            _Var1 = stale_work(work, false);
            if (!_Var1)
                break;
            _discard_work(work);
            wake_gws();
        }
    } while (work == (work *)0x0);
    tVar3 = time((time_t *)0x0);
    iVar6 = tVar3 - tVar2;
    cVar4 = opt_debug;
    if (iVar6 < 1) {
    LAB_000204a6:
        if (cVar4 != '\0') {
        LAB_000204b0:
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                snprintf(tmp42, 0x1000,
                         "Got work from get queue to get work for thread %d",
                         thr_id);
                _applog(7, tmp42, false);
            }
        }
    } else {
        if (opt_debug != false) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Get work blocked for %d seconds",
                         iVar6);
                _applog(7, tmp42, false);
                cVar4 = opt_debug;
                pcVar7->last_device_valid_work =
                    pcVar7->last_device_valid_work + iVar6;
                goto LAB_000204a6;
            }
            pcVar7->last_device_valid_work =
                pcVar7->last_device_valid_work + iVar6;
            goto LAB_000204b0;
        }
        pcVar7->last_device_valid_work = pcVar7->last_device_valid_work + iVar6;
    }
    work->thr_id = thr_id;
    ppcVar5 = &opt_logfile_path;
    if (opt_benchmark != false) {
        iVar6 = pcVar7->direction + pcVar7->lodiff;
        pcVar7->lodiff = iVar6;
        if (iVar6 < 1) {
            ppcVar5 = (char **)0x1;
        }
        if (iVar6 < 1) {
            pcVar7->direction = (int)ppcVar5;
        } else if (0xf < iVar6) {
            __src = (char **)0xffffffff;
            pcVar7->direction = -1;
            iVar6 = pcVar7->hidiff + 1;
            bVar10 = SBORROW4(iVar6, 0xf);
            bVar8 = pcVar7->hidiff + -0xe < 0;
            bVar9 = iVar6 == 0xf;
            if (iVar6 < 0x10) {
                __src = (char **)(iVar6 * 5);
            }
            if (bVar9 || bVar8 != bVar10) {
                ppcVar5 = ppcVar5 + 0x16b;
            } else {
                __src = ppcVar5 + 0x16b;
            }
            if (bVar9 || bVar8 != bVar10) {
                pcVar7->hidiff = iVar6;
                __src = ppcVar5 + (int)__src * 8;
            } else {
                ppcVar5 = (char **)0x0;
            }
            if (!bVar9 && bVar8 == bVar10) {
                pcVar7->hidiff = (int)ppcVar5;
            }
            memcpy(work, __src, 0xa0);
            goto LAB_000204f2;
        }
        memcpy(work, bench_lodiff_bins + iVar6, 0xa0);
    }
LAB_000204f2:
    thread_reportin(thr);
    work->mined = true;
    dVar12 = pcVar7->drv->max_diff;
    if (work->work_difficulty < dVar12) {
        dVar12 = work->work_difficulty;
    }
    work->device_diff = dVar12;
    dVar11 = pcVar7->drv->min_diff;
    if (dVar12 < dVar11) {
        dVar12 = dVar11;
    }
    work->device_diff = dVar12;
    return work;
}

/* WARNING: Unknown calling convention */

work *get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id)

{
    work *work;

    work = get_work(thr, thr_id);
    add_queued(cgpu, work);
    return work;
}

/* WARNING: Unknown calling convention */

work *__get_queued(cgpu_info *cgpu)

{
    _Bool _Var1;
    work *work;
    work *pwVar2;

    work = cgpu->unqueued_work;
    pwVar2 = work;
    if (work != (work *)0x0) {
        _Var1 = stale_work(work, false);
        if (_Var1) {
            pwVar2 = (work *)0x0;
            _discard_work(work);
            wake_gws();
        } else {
            __add_queued(cgpu, work);
        }
        cgpu->unqueued_work = (work *)0x0;
    }
    return pwVar2;
}

/* WARNING: Unknown calling convention */

work *get_queued(cgpu_info *cgpu)

{
    int iVar1;
    work *pwVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *extraout_r2_00;
    char *func_00;
    int line;
    int extraout_r3;
    int extraout_r3_00;

    iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)&cgpu->qlock);
    if (iVar1 == 0) {
        pwVar2 = __get_queued(cgpu);
        iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&cgpu->qlock);
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar3 == 0) {
            (*selective_yield)();
            return pwVar2;
        }
    } else {
        _wr_lock((pthread_rwlock_t *)"get_queued", (char *)0x2270, func, line);
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"get_queued", (char *)0x2272, func_00,
               iVar1);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void discard_stale(void)

{
    work *pwVar1;
    work *pwVar2;
    _Bool _Var3;
    int iVar4;
    int iVar5;
    UT_hash_bucket *pUVar6;
    int *piVar7;
    void *pvVar8;
    UT_hash_handle *pUVar9;
    work *pwVar10;
    char *__format;
    work *pwVar11;
    uint uVar12;
    UT_hash_handle *pUVar13;
    work *work;
    work *pwVar14;
    UT_hash_table *pUVar15;
    bool bVar16;
    undefined4 uVar17;
    char tmp42[4096];

    iVar4 = pthread_mutex_lock((pthread_mutex_t *)stgd_lock);
    if (iVar4 != 0) {
        piVar7 = __errno_location();
        iVar4 = *piVar7;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar17 = 0x145e;
        goto LAB_0002088c;
    }
    if (staged_work != (work *)0x0) {
        iVar4 = 0;
        work = staged_work;
        pwVar14 = (work *)(staged_work->hh).next;
        do {
            _Var3 = stale_work(work, false);
            pwVar1 = staged_work;
            if (_Var3) {
                pvVar8 = (work->hh).prev;
                pUVar15 = (staged_work->hh).tbl;
                if (pvVar8 == (void *)0x0) {
                    pwVar10 = (work *)(work->hh).next;
                    if (pwVar10 != (work *)0x0) {
                        iVar5 = pUVar15->hho;
                        pwVar11 = pwVar10;
                        pwVar2 = pwVar10;
                        if (work == (work *)((int)pUVar15->tail - iVar5))
                            goto LAB_0002077a;
                        goto LAB_000206de;
                    }
                    free(pUVar15->buckets);
                    free((staged_work->hh).tbl);
                    staged_work = pwVar10;
                } else {
                    iVar5 = pUVar15->hho;
                    if (work == (work *)((int)pUVar15->tail - iVar5)) {
                    LAB_0002077a:
                        pUVar15->tail = (UT_hash_handle *)(iVar5 + (int)pvVar8);
                        pvVar8 = (work->hh).prev;
                        if (pvVar8 == (void *)0x0) {
                            pwVar10 = (work *)(work->hh).next;
                            pwVar11 = pwVar10;
                            pwVar2 = pwVar10;
                            goto LAB_000206de;
                        }
                        iVar5 = ((pwVar1->hh).tbl)->hho;
                    }
                    *(void **)((int)pvVar8 + iVar5 + 8) = (work->hh).next;
                    pwVar10 = pwVar1;
                    pwVar11 = (work *)(work->hh).next;
                    pwVar2 = staged_work;
                LAB_000206de:
                    staged_work = pwVar2;
                    pUVar15 = (pwVar10->hh).tbl;
                    if (pwVar11 != (work *)0x0) {
                        *(void **)(pwVar11->data + pUVar15->hho + 4) =
                            (work->hh).prev;
                        pUVar15 = (pwVar10->hh).tbl;
                    }
                    uVar12 = pUVar15->num_buckets - 1 & (work->hh).hashv;
                    pUVar15->buckets[uVar12].count =
                        pUVar15->buckets[uVar12].count - 1;
                    pUVar6 = ((pwVar10->hh).tbl)->buckets;
                    bVar16 = pUVar6[uVar12].hh_head == &work->hh;
                    if (bVar16) {
                        pwVar10 = (work *)(work->hh).hh_next;
                        pUVar6[uVar12].hh_head = (UT_hash_handle *)pwVar10;
                    }
                    pUVar9 = (work->hh).hh_prev;
                    if (bVar16) {
                        pwVar10 = staged_work;
                    }
                    pUVar13 = (work->hh).hh_next;
                    if (pUVar9 != (UT_hash_handle *)0x0) {
                        pUVar9->hh_next = pUVar13;
                        pUVar13 = (work->hh).hh_next;
                    }
                    if (pUVar13 != (UT_hash_handle *)0x0) {
                        pUVar13->hh_prev = (work->hh).hh_prev;
                    }
                    pUVar15 = (pwVar10->hh).tbl;
                    pUVar15->num_items = pUVar15->num_items - 1;
                }
                iVar4 = iVar4 + 1;
                _discard_work(work);
            }
            if (pwVar14 == (work *)0x0)
                goto LAB_00020798;
            work = pwVar14;
            pwVar14 = (work *)(pwVar14->hh).next;
        } while (true);
    }
    pthread_cond_signal((pthread_cond_t *)&gws_cond);
    iVar4 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
    if (iVar4 == 0) {
        (*selective_yield)();
        return;
    }
    goto LAB_000208a6;
LAB_00020798:
    pthread_cond_signal((pthread_cond_t *)&gws_cond);
    iVar5 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
    if (iVar5 == 0) {
        (*selective_yield)();
        if (((iVar4 != 0) && (opt_debug != false)) &&
            ((use_syslog != false ||
              ((opt_log_output != false || (6 < opt_log_level)))))) {
            snprintf(tmp42, 0x1000,
                     "Discarded %d stales that didn\'t match current hash",
                     iVar4);
            _applog(7, tmp42, false);
        }
        return;
    }
LAB_000208a6:
    piVar7 = __errno_location();
    iVar4 = *piVar7;
    __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    uVar17 = 0x1469;
LAB_0002088c:
    snprintf(tmp42, 0x1000, __format, iVar4, "cgminer.c", "discard_stale",
             uVar17);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void *restart_thread(void *arg)

{
    pool *pool;
    pthread_t __th;
    int iVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *func_00;
    char *extraout_r2_00;
    char *extraout_r2_01;
    char *extraout_r2_02;
    char *pcVar4;
    int line;
    int extraout_r3;
    int line_00;
    int extraout_r3_00;
    int extraout_r3_01;
    int extraout_r3_02;
    cgpu_info *cgpu;

    pool = current_pool();
    __th = pthread_self();
    pthread_detach(__th);
    pool_tset(pool, &pool->lagging);
    discard_stale();
    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)&mining_thr_lock);
    iVar3 = mining_threads;
    if (iVar1 == 0) {
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&mining_thr_lock);
        pcVar4 = extraout_r2;
        iVar1 = extraout_r3;
        if (iVar2 == 0) {
            (*selective_yield)();
            if (0 < iVar3) {
                iVar1 = 0;
                do {
                    cgpu = mining_thr[iVar1]->cgpu;
                    if ((cgpu != (cgpu_info *)0x0) &&
                        (cgpu->deven == DEV_ENABLED)) {
                        mining_thr[iVar1]->work_restart = true;
                        flush_queue(cgpu);
                        (*cgpu->drv->flush_work)(cgpu);
                    }
                    iVar1 = iVar1 + 1;
                } while (iVar3 != iVar1);
            }
            iVar3 = pthread_mutex_lock((pthread_mutex_t *)&restart_lock);
            if (iVar3 == 0) {
                pthread_cond_broadcast((pthread_cond_t *)&restart_cond);
                iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&restart_lock);
                pcVar4 = extraout_r2_00;
                iVar3 = extraout_r3_00;
                if (iVar1 == 0) {
                    (*selective_yield)();
                    return (void *)0x0;
                }
            } else {
                _mutex_lock((pthread_mutex_t *)"restart_thread", (char *)0x14a4,
                            func_00, line_00);
                pcVar4 = extraout_r2_02;
                iVar3 = extraout_r3_02;
            }
            /* WARNING: Subroutine does not return */
            _mutex_unlock_noyield((pthread_mutex_t *)"restart_thread",
                                  (char *)0x14a6, pcVar4, iVar3);
        }
    } else {
        _rd_lock((pthread_rwlock_t *)"restart_thread", (char *)0x1496, func,
                 line);
        pcVar4 = extraout_r2_01;
        iVar1 = extraout_r3_01;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"restart_thread", (char *)0x1498, pcVar4,
               iVar1);
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void *stratum_sthread(void *userdata)

{
    char cVar1;
    byte bVar2;
    byte bVar3;
    byte bVar4;
    _Bool _Var5;
    pthread_t __th;
    thread_q *tq;
    work *pwVar6;
    stratum_share *psVar7;
    time_t tVar8;
    char *pcVar9;
    char *pcVar10;
    int iVar11;
    size_t sVar12;
    uint uVar13;
    int *piVar14;
    uint uVar15;
    UT_hash_handle *pUVar16;
    UT_hash_table *pUVar17;
    undefined4 uVar18;
    uint uVar19;
    undefined4 uVar20;
    stratum_share *psVar21;
    undefined4 uVar22;
    UT_hash_bucket *pUVar23;
    UT_hash_handle *pUVar24;
    pthread_rwlock_t *__rwlock;
    int local_2058;
    char threadname[16];
    char s[4096];
    char tmp42[4096];

    __th = pthread_self();
    pthread_detach(__th);
    /* WARNING: Load size is inaccurate */
    snprintf(threadname, 0x10, "%d/SStratum", *userdata);
    RenameThread(threadname);
    tq = tq_new();
    *(thread_q **)((int)userdata + 0x2f0) = tq;
    if (tq == (thread_q *)0x0) {
        pcVar10 = " stratum_q in stratum_sthread";
        builtin_strncpy(tmp42, "Failed to create", 0x10);
        pcVar9 = tmp42 + 0x10;
    } else {
        memset(s, 0, 0x1000);
        cVar1 = *(char *)((int)userdata + 0x89);
        while (true) {
            if (cVar1 != '\0') {
                tq_freeze(tq);
                return (void *)0x0;
            }
            pwVar6 = (work *)tq_pop(tq, (timespec *)0x0);
            if (pwVar6 == (work *)0x0)
                break;
            psVar7 = (stratum_share *)calloc(0x34, 1);
            if (psVar7 == (stratum_share *)0x0) {
                snprintf(tmp42, 0x1000, "%s: calloc() failed on sshare.",
                         "stratum_sthread");
                goto LAB_00020dcc;
            }
            tVar8 = time((time_t *)0x0);
            psVar7->sshare_time = tVar8;
            psVar7->work = pwVar6;
            pcVar9 = bin2hex(pwVar6->equihash_data + 0x6c, 0x20);
            pcVar10 = bin2hex(pwVar6->equihash_data + 0x8c, 0x543);
            iVar11 = pthread_mutex_lock((pthread_mutex_t *)&sshare_lock);
            if (iVar11 != 0) {
                piVar14 = __errno_location();
                iVar11 = *piVar14;
                uVar22 = 0x1c78;
            LAB_00020f88:
                pcVar9 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            LAB_00020f9c:
                snprintf(tmp42, 0x1000, pcVar9, iVar11, "cgminer.c",
                         "stratum_sthread", uVar22);
            LAB_00020dcc:
                _applog(3, tmp42, true);
                /* WARNING: Subroutine does not return */
                __quit(1, true);
            }
            psVar7->id = swork_id;
            swork_id = swork_id + 1;
            iVar11 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
            if (iVar11 != 0) {
                piVar14 = __errno_location();
                iVar11 = *piVar14;
                uVar22 = 0x1c7b;
            LAB_00020fba:
                pcVar9 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                goto LAB_00020f9c;
            }
            (*selective_yield)();
            sVar12 = strlen(pwVar6->nonce1);
            snprintf(s, 0x1000,
                     "{\"id\": %d, \"method\": \"mining.submit\", \"params\": "
                     "[\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"]}",
                     psVar7->id, *(undefined4 *)((int)userdata + 0xcc),
                     pwVar6->job_id, pwVar6->ntime, pcVar9 + sVar12, pcVar10);
            free(pcVar9);
            free(pcVar10);
            while (true) {
                iVar11 = psVar7->sshare_time;
                tVar8 = time((time_t *)0x0);
                if (iVar11 + 0x77 < tVar8)
                    goto LAB_00020d22;
                sVar12 = strlen(s);
                _Var5 = stratum_send((pool *)userdata, s, sVar12);
                if (_Var5)
                    break;
                _Var5 = pool_tset((pool *)userdata,
                                  (_Bool *)((int)userdata + 0x80));
                if ((!_Var5) && (_Var5 = cnx_needed((pool *)userdata), _Var5)) {
                    if ((use_syslog != false) ||
                        ((opt_log_output != false || (3 < opt_log_level)))) {
                        /* WARNING: Load size is inaccurate */
                        snprintf(tmp42, 0x1000,
                                 "Pool %d stratum share submission failure",
                                 *userdata);
                        _applog(4, tmp42, false);
                    }
                    total_ro = total_ro + 1;
                    *(int *)((int)userdata + 0xa4) =
                        *(int *)((int)userdata + 0xa4) + 1;
                }
                uVar22 = tmp42._48_4_;
                if (opt_lowmem != false) {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        builtin_strncpy(
                            tmp42,
                            "Lowmem option prevents resubmitting stratum share",
                            0x32);
                        tmp42._50_2_ = SUB42(uVar22, 2);
                        _applog(7, tmp42, false);
                    }
                    goto LAB_00020d22;
                }
                iVar11 = pthread_mutex_lock(
                    (pthread_mutex_t *)((int)userdata + 0xf4));
                if (iVar11 != 0) {
                    piVar14 = __errno_location();
                    iVar11 = *piVar14;
                    uVar22 = 0x1ca2;
                    goto LAB_00020f88;
                }
                __rwlock = (pthread_rwlock_t *)((int)userdata + 0x10c);
                iVar11 = pthread_rwlock_rdlock(__rwlock);
                if (iVar11 != 0) {
                    piVar14 = __errno_location();
                    iVar11 = *piVar14;
                    uVar22 = 0x1ca2;
                    pcVar9 = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
                    goto LAB_00020f9c;
                }
                iVar11 = pthread_mutex_unlock(
                    (pthread_mutex_t *)((int)userdata + 0xf4));
                if (iVar11 != 0) {
                    piVar14 = __errno_location();
                    iVar11 = *piVar14;
                    uVar22 = 0x1ca2;
                    goto LAB_00020fba;
                }
                if ((*(char **)((int)userdata + 0x27c) == (char *)0x0) ||
                    (iVar11 = strcmp(pwVar6->nonce1,
                                     *(char **)((int)userdata + 0x27c)),
                     iVar11 != 0)) {
                    iVar11 = pthread_rwlock_unlock(__rwlock);
                    if (iVar11 != 0) {
                    LAB_0002108a:
                        piVar14 = __errno_location();
                        iVar11 = *piVar14;
                        uVar22 = 0x1ca4;
                        pcVar9 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s "
                                 "%s():%d";
                        goto LAB_00020f9c;
                    }
                    (*selective_yield)();
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        builtin_strncpy(tmp42,
                                        "No matching session id for "
                                        "resubmitting stratum shar",
                                        0x34);
                        tmp42[0x34] = 'e';
                        tmp42[0x35] = '\0';
                        _applog(7, tmp42, false);
                    }
                    goto LAB_00020d22;
                }
                iVar11 = pthread_rwlock_unlock(__rwlock);
                if (iVar11 != 0)
                    goto LAB_0002108a;
                (*selective_yield)();
                sleep(5);
            }
            iVar11 = pthread_mutex_lock((pthread_mutex_t *)&sshare_lock);
            psVar21 = stratum_shares;
            if (iVar11 != 0) {
                piVar14 = __errno_location();
                iVar11 = *piVar14;
                uVar22 = 0x1c8a;
                goto LAB_00020f88;
            }
            (psVar7->hh).next = (void *)0x0;
            (psVar7->hh).key = &psVar7->id;
            (psVar7->hh).keylen = 4;
            if (psVar21 == (stratum_share *)0x0) {
                (psVar7->hh).prev = (void *)0x0;
                stratum_shares = psVar7;
                pUVar17 = (UT_hash_table *)malloc(0x2c);
                (psVar7->hh).tbl = pUVar17;
                if (pUVar17 == (UT_hash_table *)0x0)
                    goto LAB_00021244;
                memset(&pUVar17->num_items, 0, 0x20);
                pUVar17->num_buckets = 0x20;
                pUVar17->tail = (UT_hash_handle *)psVar7;
                pUVar17->hho = 0;
                pUVar17->log2_num_buckets = 5;
                pUVar23 = (UT_hash_bucket *)calloc(0x180, 1);
                pUVar17->buckets = pUVar23;
                if (pUVar23 == (UT_hash_bucket *)0x0)
                    goto LAB_00021244;
                pUVar17->signature = 0xa0111fe1;
                psVar21 = psVar7;
            } else {
                ((psVar21->hh).tbl)->tail->next = psVar7;
                pUVar17 = (psVar21->hh).tbl;
                (psVar7->hh).prev = (void *)((int)pUVar17->tail - pUVar17->hho);
                ((psVar21->hh).tbl)->tail = (UT_hash_handle *)psVar7;
                pUVar17 = (psVar21->hh).tbl;
            }
            pUVar17->num_items = pUVar17->num_items + 1;
            bVar2 = *(byte *)((int)&psVar7->id + 3);
            iVar11 = psVar7->id;
            bVar3 = *(byte *)((int)&psVar7->id + 2);
            bVar4 = *(byte *)((int)&psVar7->id + 1);
            (psVar7->hh).tbl = (psVar21->hh).tbl;
            uVar15 = (byte)iVar11 + 0x112410d + (uint)bVar2 * 0x1000000 +
                         (uint)bVar3 * 0x10000 + (uint)bVar4 * 0x100 ^
                     0x7f76d;
            uVar13 = 0x9f49bac6 - uVar15 ^ uVar15 << 8;
            uVar19 = (-0x112410d - uVar15) - uVar13 ^ uVar13 >> 0xd;
            uVar15 = (uVar15 - uVar13) - uVar19 ^ uVar19 >> 0xc;
            uVar13 = (uVar13 - uVar19) - uVar15 ^ uVar15 << 0x10;
            uVar19 = (uVar19 - uVar15) - uVar13 ^ uVar13 >> 5;
            uVar15 = (uVar15 - uVar13) - uVar19 ^ uVar19 >> 3;
            uVar13 = (uVar13 - uVar19) - uVar15 ^ uVar15 << 10;
            uVar13 = (uVar19 - uVar15) - uVar13 ^ uVar13 >> 0xf;
            (psVar7->hh).hashv = uVar13;
            pUVar17 = (psVar21->hh).tbl;
            pUVar23 = pUVar17->buckets;
            uVar13 = uVar13 & pUVar17->num_buckets - 1;
            pUVar23[uVar13].count = pUVar23[uVar13].count + 1;
            pUVar16 = ((psVar21->hh).tbl)->buckets[uVar13].hh_head;
            (psVar7->hh).hh_prev = (UT_hash_handle *)0x0;
            (psVar7->hh).hh_next = pUVar16;
            pUVar23 = ((psVar21->hh).tbl)->buckets;
            if (pUVar23[uVar13].hh_head != (UT_hash_handle *)0x0) {
                (pUVar23[uVar13].hh_head)->hh_prev = (UT_hash_handle *)psVar7;
                pUVar23 = ((psVar21->hh).tbl)->buckets;
            }
            pUVar23[uVar13].hh_head = (UT_hash_handle *)psVar7;
            pUVar23 = ((psVar21->hh).tbl)->buckets;
            if (((pUVar23[uVar13].expand_mult + 1) * 10 <=
                 pUVar23[uVar13].count) &&
                (pUVar17 = (psVar7->hh).tbl, pUVar17->noexpand != 1)) {
                pUVar23 =
                    (UT_hash_bucket *)calloc(pUVar17->num_buckets * 0x18, 1);
                if (pUVar23 == (UT_hash_bucket *)0x0) {
                LAB_00021244:
                    /* WARNING: Subroutine does not return */
                    exit(-1);
                }
                uVar13 = pUVar17->num_items >>
                         (pUVar17->log2_num_buckets + 1 & 0xff);
                if ((pUVar17->num_buckets * 2 - 1 & pUVar17->num_items) != 0) {
                    uVar13 = uVar13 + 1;
                }
                pUVar17->ideal_chain_maxlen = uVar13;
                ((psVar7->hh).tbl)->nonideal_items = 0;
                pUVar17 = (psVar7->hh).tbl;
                uVar13 = pUVar17->num_buckets;
                if (uVar13 != 0) {
                    uVar15 = 0;
                    local_2058 = 0;
                    do {
                        pUVar16 = *(
                            UT_hash_handle **)((int)&pUVar17->buckets->hh_head +
                                               local_2058);
                        if (pUVar16 != (UT_hash_handle *)0x0) {
                            while (true) {
                                pUVar24 = pUVar16->hh_next;
                                uVar19 = uVar13 * 2 - 1 & pUVar16->hashv;
                                uVar13 = pUVar23[uVar19].count + 1;
                                pUVar23[uVar19].count = uVar13;
                                if (pUVar17->ideal_chain_maxlen < uVar13) {
                                    pUVar17->nonideal_items =
                                        pUVar17->nonideal_items + 1;
                                    uVar13 = __udivsi3(
                                        pUVar23[uVar19].count,
                                        ((psVar7->hh).tbl)->ideal_chain_maxlen);
                                    pUVar23[uVar19].expand_mult = uVar13;
                                }
                                pUVar16->hh_prev = (UT_hash_handle *)0x0;
                                pUVar16->hh_next = pUVar23[uVar19].hh_head;
                                if (pUVar23[uVar19].hh_head !=
                                    (UT_hash_handle *)0x0) {
                                    (pUVar23[uVar19].hh_head)->hh_prev =
                                        pUVar16;
                                }
                                pUVar23[uVar19].hh_head = pUVar16;
                                pUVar17 = (psVar7->hh).tbl;
                                if (pUVar24 == (UT_hash_handle *)0x0)
                                    break;
                                uVar13 = pUVar17->num_buckets;
                                pUVar16 = pUVar24;
                            }
                            uVar13 = pUVar17->num_buckets;
                        }
                        uVar15 = uVar15 + 1;
                        local_2058 = local_2058 + 0xc;
                    } while (uVar15 < uVar13);
                }
                free(pUVar17->buckets);
                pUVar17 = (psVar7->hh).tbl;
                pUVar17->num_buckets = pUVar17->num_buckets << 1;
                pUVar17 = (psVar7->hh).tbl;
                pUVar17->log2_num_buckets = pUVar17->log2_num_buckets + 1;
                ((psVar7->hh).tbl)->buckets = pUVar23;
                pUVar17 = (psVar7->hh).tbl;
                if (pUVar17->num_items >> 1 < pUVar17->nonideal_items) {
                    uVar13 = pUVar17->ineff_expands + 1;
                } else {
                    uVar13 = 0;
                }
                pUVar17->ineff_expands = uVar13;
                pUVar17 = (psVar7->hh).tbl;
                uVar15 = pUVar17->ineff_expands;
                uVar13 = uVar15;
                if (1 < uVar15) {
                    uVar13 = 1;
                }
                if (1 < uVar15) {
                    pUVar17->noexpand = uVar13;
                }
            }
            *(int *)((int)userdata + 0x2f4) =
                *(int *)((int)userdata + 0x2f4) + 1;
            iVar11 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
            if (iVar11 != 0) {
                piVar14 = __errno_location();
                iVar11 = *piVar14;
                uVar22 = 0x1c8d;
                goto LAB_00020fba;
            }
            (*selective_yield)();
            _Var5 =
                pool_tclear((pool *)userdata, (_Bool *)((int)userdata + 0x80));
            if (_Var5) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (3 < opt_log_level)) {
                    /* WARNING: Load size is inaccurate */
                    snprintf(tmp42, 0x1000,
                             "Pool %d communication resumed, submitting work",
                             *userdata);
                    _applog(4, tmp42, false);
                    goto LAB_00020cca;
                }
                if (opt_debug != false) {
                LAB_00020cf0:
                    if (6 < opt_log_level)
                        goto LAB_00020cf6;
                }
            } else {
            LAB_00020cca:
                if (opt_debug != false) {
                    if ((use_syslog == false) && (opt_log_output == false))
                        goto LAB_00020cf0;
                LAB_00020cf6:
                    builtin_strncpy(
                        tmp42,
                        "Successfully submitted, adding to stratum_shares db",
                        0x34);
                    _applog(7, tmp42, false);
                }
            }
        LAB_00020d22:
            tVar8 = time((time_t *)0x0);
            _Var5 = opt_debug;
            psVar7->sshare_sent = tVar8;
            if ((_Var5 != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                /* WARNING: Load size is inaccurate */
                snprintf(tmp42, 0x1000,
                         "Pool %d stratum share submission lag time %d seconds",
                         *userdata, tVar8 - psVar7->sshare_time);
                _applog(7, tmp42, false);
            }
            memset(s, 0, 0x1000);
            cVar1 = *(char *)((int)userdata + 0x89);
            tq = *(thread_q **)((int)userdata + 0x2f0);
        }
        pcVar10 = "Stratum q returned empty work";
        pcVar9 = tmp42;
    }
    uVar22 = *(undefined4 *)(pcVar10 + 4);
    uVar18 = *(undefined4 *)(pcVar10 + 8);
    uVar20 = *(undefined4 *)(pcVar10 + 0xc);
    *(undefined4 *)pcVar9 = *(undefined4 *)pcVar10;
    *(undefined4 *)(pcVar9 + 4) = uVar22;
    *(undefined4 *)(pcVar9 + 8) = uVar18;
    *(undefined4 *)(pcVar9 + 0xc) = uVar20;
    uVar22 = *(undefined4 *)(pcVar10 + 0x14);
    uVar18 = *(undefined4 *)(pcVar10 + 0x18);
    uVar20 = *(undefined4 *)(pcVar10 + 0x1c);
    *(undefined4 *)(pcVar9 + 0x10) = *(undefined4 *)(pcVar10 + 0x10);
    *(undefined4 *)(pcVar9 + 0x14) = uVar22;
    *(undefined4 *)(pcVar9 + 0x18) = uVar18;
    *(short *)(pcVar9 + 0x1c) = (short)uVar20;
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

void hashmeter(int thr_id, uint64_t hashes_done)

{
    bool bVar1;
    ulonglong uVar2;
    __time_t _Var3;
    int iVar4;
    thr_info *ptVar5;
    int *piVar6;
    uint uVar7;
    char *pcVar8;
    undefined4 uVar9;
    cgpu_info *pcVar10;
    int iVar11;
    double *pdVar12;
    int iVar13;
    undefined4 uVar14;
    double dVar15;
    double dVar16;
    undefined4 extraout_s1;
    DFtype a;
    DFtype extraout_d0;
    DFtype a_00;
    DFtype a_01;
    DFtype a_02;
    DFtype a_03;
    double fsecs;
    double fadd;
    UDItype UVar17;
    longlong lVar18;
    undefined8 in_stack_ffffef50;
    undefined8 uVar19;
    undefined4 local_10a0;
    undefined4 uStack_109c;
    char displayed_hashes[16];
    char displayed_rolling[16];
    char displayed_r1[16];
    char displayed_r5[16];
    char logline[256];

    cgtime(&total_tv_end);
    dVar15 = tdiff(&total_tv_end, &tv_hashmeter);
    _Var3 = total_tv_end.tv_sec;
    uVar2 = CONCAT44(global_hashrate._4_4_, (undefined4)global_hashrate);
    local_10a0 = (undefined4)hashes_done;
    uStack_109c = (undefined4)(hashes_done >> 0x20);
    if (total_tv_end.tv_sec - hashdisplay_t < opt_log_interval) {
        if (thr_id < 0)
            goto LAB_000216da;
        bVar1 = false;
        copy_time(&tv_hashmeter, &total_tv_end);
    LAB_00021532:
        ptVar5 = get_thread(thr_id);
        pcVar10 = ptVar5->cgpu;
        copy_time(&ptVar5->last, &total_tv_end);
        pcVar10->device_last_well = _Var3;
        dVar16 = tdiff(&total_tv_end, &pcVar10->last_message_tv);
        copy_time(&pcVar10->last_message_tv, &total_tv_end);
        iVar4 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
        uVar14 = (undefined4)((ulonglong)in_stack_ffffef50 >> 0x20);
        if (iVar4 != 0) {
            piVar6 = __errno_location();
            iVar4 = *piVar6;
            uVar9 = 0x1a51;
        LAB_000219e4:
            pcVar8 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            uVar19 = CONCAT44(uVar14, uVar9);
        LAB_000219f4:
            snprintf(logline, 0x1000, pcVar8, iVar4, 0x4c9180004f3c0, uVar19);
            goto LAB_000219a0;
        }
        fadd = (double)__floatundidf(local_10a0, uStack_109c);
        pcVar10->total_mhashes = pcVar10->total_mhashes + fadd;
        if (0.0 < dVar16) {
            decay_time(&pcVar10->rolling, fadd, dVar16,
                       (double)(longlong)opt_log_interval);
            decay_time(&pcVar10->rolling1, fadd, dVar16, 60.0);
            if (0.0 < dVar16) {
                decay_time(&pcVar10->rolling5, fadd, dVar16, 300.0);
                if (0.0 < dVar16) {
                    decay_time(&pcVar10->rolling15, fadd, dVar16, 900.0);
                }
            }
        }
        iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
        uVar14 = (undefined4)((ulonglong)in_stack_ffffef50 >> 0x20);
        if (iVar4 != 0) {
            piVar6 = __errno_location();
            iVar4 = *piVar6;
            uVar9 = 0x1a57;
            goto LAB_00021a2a;
        }
        (*selective_yield)();
        get_statline(logline, 0x100, pcVar10);
        printf("%s          \r", logline);
        fflush(stdout);
        iVar4 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
        uVar14 = (undefined4)((ulonglong)in_stack_ffffef50 >> 0x20);
        if (iVar4 == 0) {
            total_mhashes_done = total_mhashes_done + fadd;
            if (bVar1)
                goto LAB_000213f8;
            dVar15 = g_local_mhashes_dones[g_local_mhashes_index];
            iVar4 = g_local_mhashes_index;
            goto LAB_0002161e;
        }
    LAB_00021972:
        piVar6 = __errno_location();
        iVar4 = *piVar6;
        uVar14 = 0x1a7b;
        pcVar8 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
    } else {
        hashdisplay_t = total_tv_end.tv_sec;
        copy_time(&tv_hashmeter, &total_tv_end);
        if (-1 < thr_id) {
            bVar1 = true;
            goto LAB_00021532;
        }
        iVar4 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
        uVar14 = (undefined4)((ulonglong)in_stack_ffffef50 >> 0x20);
        if (iVar4 != 0) {
            piVar6 = __errno_location();
            iVar4 = *piVar6;
            uVar9 = 0x1a6b;
            goto LAB_000219e4;
        }
        if (0 < mining_threads) {
            iVar4 = 0;
            do {
                while (true) {
                    ptVar5 = get_thread(iVar4);
                    pcVar10 = ptVar5->cgpu;
                    dVar16 = tdiff(&total_tv_end, &pcVar10->last_message_tv);
                    copy_time(&pcVar10->last_message_tv, &total_tv_end);
                    if (0.0 < dVar16)
                        break;
                LAB_000212f8:
                    iVar4 = iVar4 + 1;
                    if (mining_threads <= iVar4)
                        goto LAB_000213a2;
                }
                decay_time(&pcVar10->rolling, 0.0, dVar16,
                           (double)(longlong)opt_log_interval);
                decay_time(&pcVar10->rolling1, 0.0, dVar16, 60.0);
                if (dVar16 <= 0.0)
                    goto LAB_000212f8;
                decay_time(&pcVar10->rolling5, 0.0, dVar16, 300.0);
                if (dVar16 <= 0.0)
                    goto LAB_000212f8;
                iVar4 = iVar4 + 1;
                decay_time(&pcVar10->rolling15, 0.0, dVar16, 900.0);
            } while (iVar4 < mining_threads);
        }
    LAB_000213a2:
        iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
        uVar14 = (undefined4)((ulonglong)in_stack_ffffef50 >> 0x20);
        if (iVar4 != 0) {
            piVar6 = __errno_location();
            iVar4 = *piVar6;
            uVar9 = 0x1a78;
        LAB_00021a2a:
            uVar19 = CONCAT44(uVar14, uVar9);
            pcVar8 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
            goto LAB_000219f4;
        }
        (*selective_yield)();
        iVar4 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
        if (iVar4 != 0)
            goto LAB_00021972;
        fadd = (double)__floatundidf(local_10a0, uStack_109c);
        total_mhashes_done = total_mhashes_done + fadd;
    LAB_000213f8:
        iVar11 = g_local_mhashes_index + 1;
        iVar4 = g_local_mhashes_index + -10;
        iVar13 = 0;
        if (iVar11 < 0xc) {
            g_local_mhashes_index = iVar11;
        }
        pdVar12 = g_local_mhashes_dones;
        UVar17 = 0;
        if (iVar11 != 0xb && iVar4 < 0 == SBORROW4(iVar11, 0xb)) {
            g_local_mhashes_index = 0;
            UVar17 = 0;
        }
        do {
            dVar16 = *pdVar12;
            pdVar12 = pdVar12 + 1;
            if (0.0 <= dVar16) {
                uVar14 = __floatundidf((int)UVar17, (int)(UVar17 >> 0x20));
                iVar13 = iVar13 + 1;
                UVar17 = __fixunsdfdi((DFtype)CONCAT44(extraout_s1, uVar14));
            }
            uVar14 = (undefined4)((ulonglong)in_stack_ffffef50 >> 0x20);
        } while (pdVar12 != (double *)&g_local_mhashes_index);
        dVar16 = fadd;
        if (iVar13 != 0) {
            __aeabi_uldivmod();
            dVar16 = (double)__floatundidf();
        }
        fsecs = (double)(longlong)opt_log_interval;
        if (0.0 < fsecs) {
            decay_time(&total_rolling, dVar16, fsecs, fsecs);
        }
        if (0.0 < dVar15) {
            decay_time(&rolling1, fadd, dVar15, 60.0);
            decay_time(&rolling5, fadd, dVar15, 300.0);
            if (0.0 < dVar15) {
                decay_time(&rolling15, fadd, dVar15, 900.0);
            }
        }
        bVar1 = true;
        lVar18 = llround(total_rolling);
        iVar4 = g_local_mhashes_index;
        uVar7 = (uint)(lVar18 * 0x1f);
        dVar15 = 0.0;
        global_hashrate =
            lVar18 * 0x40 +
            CONCAT44((int)((ulonglong)(lVar18 * 0x1f) >> 0x20) * 0x200 |
                         uVar7 >> 0x17,
                     uVar7 * 0x200) *
                0x3f;
        g_local_mhashes_dones[g_local_mhashes_index] = 0.0;
    LAB_0002161e:
        g_local_mhashes_dones[iVar4] = dVar15 + fadd;
        a = tdiff(&total_tv_end, &total_tv_start);
        total_secs = a;
        if (a - last_total_secs <= 86400.0) {
            last_total_secs = a;
            if (!bVar1)
                goto LAB_000216c2;
        LAB_000216f2:
            UVar17 = __fixunsdfdi(a);
            suffix_string(UVar17, displayed_hashes, 0x10, 4);
            g_displayed_rolling = total_rolling / 1000.0;
            UVar17 = __fixunsdfdi(a_00);
            suffix_string(UVar17, displayed_rolling, 0x10, 4);
            UVar17 = __fixunsdfdi(a_01);
            suffix_string(UVar17, displayed_r1, 0x10, 4);
            UVar17 = __fixunsdfdi(a_02);
            suffix_string(UVar17, displayed_r5, 0x10, 4);
            UVar17 = __fixunsdfdi(a_03);
            suffix_string(UVar17, logline, 0x10, 4);
            snprintf(statusline, 0x100,
                     "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
                     opt_log_interval, displayed_rolling, displayed_r1,
                     displayed_r5, logline, displayed_hashes);
            iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
            if (iVar4 == 0) {
                (*selective_yield)();
                printf("%s          \r", statusline);
                fflush(stdout);
                return;
            }
        } else {
            uVar7 = (uint)use_syslog;
            if (((use_syslog != 0) ||
                 (uVar7 = (uint)opt_log_output, opt_log_output != 0)) ||
                (uVar7 = opt_log_level, 2 < opt_log_level)) {
                dVar15 = last_total_secs;
                snprintf(
                    logline, 0x1000,
                    "cgminer time error total_secs = %f last_total_secs = %f",
                    uVar7, a, last_total_secs);
                uVar14 = (undefined4)((ulonglong)dVar15 >> 0x20);
                _applog(3, logline, false);
            }
            iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
            if (iVar4 != 0) {
                piVar6 = __errno_location();
                iVar4 = *piVar6;
                uVar9 = 0x1aa3;
                goto LAB_00021a2a;
            }
            (*selective_yield)();
            zero_stats();
            iVar4 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
            if (iVar4 != 0) {
                piVar6 = __errno_location();
                iVar4 = *piVar6;
                uVar9 = 0x1aa5;
                goto LAB_000219e4;
            }
            a = extraout_d0;
            if (bVar1)
                goto LAB_000216f2;
        LAB_000216c2:
            iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
            if (iVar4 == 0) {
                (*selective_yield)();
                uVar2 = global_hashrate;
            LAB_000216da:
                global_hashrate._4_4_ = (undefined4)(uVar2 >> 0x20);
                global_hashrate._0_4_ = (undefined4)uVar2;
                return;
            }
        }
        piVar6 = __errno_location();
        iVar4 = *piVar6;
        uVar14 = 0x1ac2;
        pcVar8 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    }
    snprintf(logline, 0x1000, pcVar8, iVar4, "cgminer.c", "hashmeter", uVar14);
LAB_000219a0:
    _applog(3, logline, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void hash_queued_work(thr_info *mythr)

{
    char cVar1;
    uint64_t hashes_done;
    int iVar2;
    uint64_t uVar3;
    _Bool _Var4;
    work *work;
    int iVar5;
    int *piVar6;
    undefined4 uVar7;
    char *__format;
    int iVar8;
    int iVar9;
    cgpu_info *dev;
    device_drv *pdVar10;
    pthread_rwlock_t *__rwlock;
    bool bVar11;
    int64_t iVar12;
    int thr_id;
    timeval tv_start;
    timeval tv_end;
    char tmp42[4096];

    dev = mythr->cgpu;
    tv_start.tv_sec = 0;
    tv_start.tv_usec = 0;
    pdVar10 = dev->drv;
    iVar8 = mythr->id;
    hashes_done = 0;
LAB_00021aca:
    cVar1 = dev->shutdown;
    do {
        if (cVar1 != '\0') {
        LAB_00021bbc:
            dev->deven = DEV_DISABLED;
            return;
        }
        __rwlock = &dev->qlock;
        mythr->work_update = false;
    LAB_00021ae4:
        do {
            if (dev->unqueued_work == (work *)0x0) {
                work = get_work(mythr, iVar8);
                iVar5 = pthread_rwlock_wrlock((pthread_rwlock_t *)__rwlock);
                if (iVar5 != 0) {
                    piVar6 = __errno_location();
                    iVar8 = *piVar6;
                    uVar7 = 0x223b;
                    __format =
                        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
                    goto LAB_00021c06;
                }
                if (dev->unqueued_work == (work *)0x0) {
                    dev->unqueued_work = work;
                    iVar5 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
                    if (iVar5 == 0) {
                        (*selective_yield)();
                        _Var4 = (*pdVar10->queue_full)(dev);
                        if (_Var4)
                            break;
                        goto LAB_00021ae4;
                    }
                } else {
                    iVar5 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
                    if (iVar5 == 0) {
                        (*selective_yield)();
                        _discard_work(work);
                        goto LAB_00021adc;
                    }
                }
                piVar6 = __errno_location();
                iVar8 = *piVar6;
                uVar7 = 0x2242;
                __format = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
            LAB_00021c06:
                snprintf(tmp42, 0x1000, __format, iVar8, "cgminer.c",
                         "fill_queue", uVar7);
                _applog(3, tmp42, true);
                /* WARNING: Subroutine does not return */
                __quit(1, true);
            }
        LAB_00021adc:
            _Var4 = (*pdVar10->queue_full)(dev);
        } while (!_Var4);
        iVar12 = (*pdVar10->scanwork)(mythr);
        mythr->work_restart = false;
        if (iVar12 == -1) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "%s %d failure, disabling!",
                         pdVar10->name, dev->device_id);
                _applog(3, tmp42, false);
            }
            dev->deven = DEV_DISABLED;
            dev_error(dev, REASON_THREAD_ZERO_HASH);
            goto LAB_00021bbc;
        }
        hashes_done = iVar12 + hashes_done;
        cgtime(&tv_end);
        iVar9 = tv_end.tv_usec - tv_start.tv_usec;
        iVar5 = tv_end.tv_sec - tv_start.tv_sec;
        if (iVar9 < 0) {
            iVar5 = iVar5 + -1;
            iVar9 = iVar9 + 1000000;
        }
        if (hashes_done == 0) {
        LAB_00021bca:
            if (opt_log_interval <= iVar5)
                goto LAB_00021b86;
            uVar3 = hashes_done;
            if (mythr->pause == false)
                goto LAB_00021ba2;
        LAB_00021bda:
            mt_disable(mythr, iVar8, (device_drv *)&pdVar10->thread_enable);
        } else {
            bVar11 = iVar9 == 200000;
            iVar2 = iVar9 + -200000;
            if (200000 >= iVar9) {
                bVar11 = iVar5 == 0;
                iVar2 = iVar5;
            }
            if (bVar11 ||
                iVar2 < 0 != (200000 < iVar9 && SBORROW4(iVar9, 200000)))
                goto LAB_00021bca;
        LAB_00021b86:
            hashmeter(iVar8, hashes_done);
            copy_time(&tv_start, &tv_end);
            hashes_done = 0;
            uVar3 = 0;
            if (mythr->pause != false)
                goto LAB_00021bda;
        LAB_00021ba2:
            hashes_done = uVar3;
            if (dev->deven != DEV_ENABLED)
                goto LAB_00021bda;
        }
        if (mythr->work_update == false)
            goto LAB_00021aca;
        (*pdVar10->update_work)(dev);
        cVar1 = dev->shutdown;
    } while (true);
}

/* WARNING: Unknown calling convention */

void hash_driver_work(thr_info *mythr)

{
    int iVar1;
    char cVar2;
    uint64_t hashes_done;
    uint64_t uVar3;
    int *piVar4;
    undefined4 uVar5;
    int iVar6;
    char *__format;
    int iVar7;
    int iVar8;
    cgpu_info *cgpu;
    cgpu_info *dev;
    device_drv *drv;
    device_drv *pdVar9;
    bool bVar10;
    int64_t iVar11;
    int thr_id;
    timeval tv_start;
    timeval tv_end;
    char tmp42[4096];

    dev = mythr->cgpu;
    tv_start.tv_usec = 0;
    pdVar9 = dev->drv;
    tv_start.tv_sec = 0;
    iVar7 = mythr->id;
    hashes_done = 0;
LAB_00021cee:
    cVar2 = dev->shutdown;
    do {
        if (cVar2 != '\0') {
        LAB_00021da6:
            dev->deven = DEV_DISABLED;
            return;
        }
        mythr->work_update = false;
        iVar11 = (*pdVar9->scanwork)(mythr);
        mythr->work_restart = false;
        if (iVar11 == -1) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "%s %d failure, disabling!",
                         pdVar9->name, dev->device_id);
                _applog(3, tmp42, false);
            }
            dev->deven = DEV_DISABLED;
            dev_error(dev, REASON_THREAD_ZERO_HASH);
            goto LAB_00021da6;
        }
        hashes_done = iVar11 + hashes_done;
        cgtime(&tv_end);
        iVar8 = tv_end.tv_usec - tv_start.tv_usec;
        iVar6 = tv_end.tv_sec - tv_start.tv_sec;
        if (iVar8 < 0) {
            iVar6 = iVar6 + -1;
            iVar8 = iVar8 + 1000000;
        }
        if (hashes_done == 0) {
        LAB_00021db4:
            if (opt_log_interval <= iVar6)
                goto LAB_00021d4c;
            uVar3 = hashes_done;
            if (mythr->pause == false)
                goto LAB_00021d68;
        LAB_00021dc4:
            mt_disable(mythr, iVar7, (device_drv *)&pdVar9->thread_enable);
        } else {
            bVar10 = iVar6 == 0;
            iVar1 = iVar6;
            if (iVar6 < 1) {
                iVar1 = iVar8 + -200000;
                bVar10 = iVar8 == 200000;
            }
            if (bVar10 || iVar1 < 0 != (iVar6 < 1 && SBORROW4(iVar8, 200000)))
                goto LAB_00021db4;
        LAB_00021d4c:
            hashmeter(iVar7, hashes_done);
            copy_time(&tv_start, &tv_end);
            hashes_done = 0;
            uVar3 = 0;
            if (mythr->pause != false)
                goto LAB_00021dc4;
        LAB_00021d68:
            hashes_done = uVar3;
            if (dev->deven != DEV_ENABLED)
                goto LAB_00021dc4;
        }
        if (mythr->work_update == false)
            goto LAB_00021cee;
        iVar6 = pthread_mutex_lock((pthread_mutex_t *)&update_job_lock);
        if (iVar6 != 0) {
            piVar4 = __errno_location();
            iVar7 = *piVar4;
            uVar5 = 0x23a0;
            __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        LAB_00021e48:
            snprintf(tmp42, 0x1000, __format, iVar7, "cgminer.c",
                     "hash_driver_work", uVar5);
            _applog(3, tmp42, true);
            /* WARNING: Subroutine does not return */
            __quit(1, true);
        }
        (*pdVar9->update_work)(dev);
        iVar6 = pthread_mutex_unlock((pthread_mutex_t *)&update_job_lock);
        if (iVar6 != 0) {
            piVar4 = __errno_location();
            iVar7 = *piVar4;
            uVar5 = 0x23a2;
            __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
            goto LAB_00021e48;
        }
        (*selective_yield)();
        cVar2 = dev->shutdown;
    } while (true);
}

/* WARNING: Removing unreachable block (ram,0x00021f3e) */
/* WARNING: Unknown calling convention */

void hash_sole_work(thr_info *mythr)

{
    int iVar1;
    char cVar2;
    __time_t _Var3;
    __suseconds_t _Var4;
    _Bool _Var5;
    _Bool _Var6;
    int thr_id;
    work *work;
    uint uVar7;
    undefined4 uVar8;
    int iVar9;
    int iVar10;
    timeval *b;
    timeval *b_00;
    int iVar11;
    int iVar12;
    device_drv *pdVar13;
    double *pdVar14;
    timeval *ptVar15;
    pool *ppVar16;
    int iVar17;
    int iVar18;
    cgpu_info *cgpu;
    cgpu_info *dev;
    int iVar19;
    bool bVar20;
    double dVar21;
    double diff;
    double dVar22;
    double dVar23;
    uint64_t uVar24;
    int64_t iVar25;
    uint local_1098;
    uint local_1080;
    timeval getwork_start;
    timeval tv_start;
    timeval tv_workstart;
    timeval tv_lastupdate;
    char tmp42[4096];

    dev = mythr->cgpu;
    thr_id = mythr->id;
    pdVar13 = dev->drv;
    iVar9 = opt_log_interval / 5;
    if (iVar9 == 0) {
        iVar9 = 1;
    }
    if (mythr->device_thread == 0) {
        local_1080 = 1;
    } else {
        local_1080 = (uint)mythr->primary_thread;
    }
    uVar24 = (*pdVar13->can_limit_work)(mythr);
    local_1098 = (uint)uVar24;
    cgtime(&getwork_start);
    cgtime(&tv_lastupdate);
    if (dev->shutdown == false) {
        iVar10 = iVar9 * 1000000;
        uVar24 = 0;
        iVar18 = 0;
        iVar19 = 0;
        do {
            work = get_work(mythr, thr_id);
            mythr->work_restart = false;
            dev->new_work = true;
            cgtime(&tv_workstart);
            work->nonce = 0;
            *(undefined4 *)&dev->max_hashes = 0;
            *(undefined4 *)((int)&dev->max_hashes + 4) = 0;
            _Var5 = (*pdVar13->prepare_work)(mythr, work);
            _Var6 = opt_scrypt;
            if (!_Var5) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000,
                             "work prepare failed, exiting mining thread %d",
                             thr_id);
                    _applog(3, tmp42, false);
                }
                break;
            }
            dVar22 = work->work_difficulty;
            pdVar14 = &work->device_diff;
            diff = pdVar13->max_diff;
            if (dVar22 < pdVar13->max_diff) {
                diff = dVar22;
            }
            *pdVar14 = diff;
            if (diff < pdVar13->min_diff) {
                diff = pdVar13->min_diff;
            }
            *pdVar14 = diff;
            if (_Var6 != false) {
                dVar23 = pdVar13->working_diff;
                dVar21 = (double)__aeabi_l2d((undefined4)total_diff1,
                                             total_diff1._4_4_);
                _Var6 = opt_debug;
                if ((((dVar21 / total_secs) * 60.0 <= 30.0) ||
                     (pdVar13->max_diff <= dVar23)) ||
                    (dVar22 <= dVar23)) {
                    if ((int)((uint)(dVar22 < dVar23) << 0x1f) < 0) {
                        pdVar13->working_diff = dVar22;
                        diff = *pdVar14;
                    }
                } else {
                    diff = dVar23 + 1.0;
                    pdVar13->working_diff = diff;
                    if ((_Var6 != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000,
                                 "Driver %s working diff changed to %.0f",
                                 pdVar13->dname, diff);
                        _applog(7, tmp42, false);
                        diff = pdVar13->working_diff;
                    }
                    dVar22 = work->work_difficulty;
                    if ((int)((uint)(dVar22 < diff) << 0x1f) < 0) {
                        diff = dVar22;
                    }
                    *pdVar14 = diff;
                }
                set_target(work->device_target, diff);
            }
            b = &(dev->cgminer_stats).getwork_wait_max;
            b_00 = &(dev->cgminer_stats).getwork_wait_min;
            while (true) {
                cgtime(&tv_start);
                subtime(&tv_start, &getwork_start);
                addtime(&getwork_start, &(dev->cgminer_stats).getwork_wait);
                _Var6 = time_more(&getwork_start, b);
                if (_Var6) {
                    copy_time(b, &getwork_start);
                }
                _Var6 = time_less(&getwork_start, b_00);
                if (_Var6) {
                    copy_time(b_00, &getwork_start);
                }
                (dev->cgminer_stats).getwork_calls =
                    (dev->cgminer_stats).getwork_calls + 1;
                ppVar16 = work->pool;
                ptVar15 = &(ppVar16->cgminer_stats).getwork_wait_max;
                addtime(&getwork_start, &(ppVar16->cgminer_stats).getwork_wait);
                _Var6 = time_more(&getwork_start, ptVar15);
                if (_Var6) {
                    copy_time(ptVar15, &getwork_start);
                }
                ptVar15 = &(ppVar16->cgminer_stats).getwork_wait_min;
                _Var6 = time_less(&getwork_start, ptVar15);
                if (_Var6) {
                    copy_time(ptVar15, &getwork_start);
                }
                (ppVar16->cgminer_stats).getwork_calls =
                    (ppVar16->cgminer_stats).getwork_calls + 1;
                cgtime(&work->tv_work_start);
                pthread_setcancelstate(1, (int *)0x0);
                thread_reportin(mythr);
                iVar25 = (*pdVar13->scanhash)(
                    mythr, work, (ulonglong)(work->nonce + local_1098));
                iVar12 = (int)((ulonglong)iVar25 >> 0x20);
                thread_reportout(mythr);
                pthread_setcancelstate(0, (int *)0x0);
                pthread_testcancel();
                cgtime(&getwork_start);
                _Var4 = getwork_start.tv_usec;
                _Var3 = getwork_start.tv_sec;
                if (iVar25 == -1)
                    break;
                iVar11 = *(int *)((int)&dev->max_hashes + 4);
                uVar24 = iVar25 + uVar24;
                bVar20 = (uint)dev->max_hashes < (uint)iVar25;
                if ((int)((iVar11 - iVar12) - (uint)bVar20) < 0 !=
                    (SBORROW4(iVar11, iVar12) !=
                     SBORROW4(iVar11 - iVar12, (uint)bVar20))) {
                    dev->max_hashes = iVar25;
                }
                iVar12 = getwork_start.tv_usec - tv_start.tv_usec;
                bVar20 = iVar12 < 0;
                if (bVar20) {
                    iVar12 = iVar12 + 0xf4000;
                }
                iVar11 = getwork_start.tv_sec - tv_start.tv_sec;
                if (bVar20) {
                    iVar12 = iVar12 + 0x240;
                    iVar11 = iVar11 + -1;
                }
                iVar19 = iVar19 + iVar12;
                iVar18 = iVar18 + iVar11;
                if (1000000 < iVar19) {
                    iVar18 = iVar18 + 1;
                    iVar19 = iVar19 + -1000000;
                }
                iVar12 = getwork_start.tv_sec - tv_workstart.tv_sec;
                if (getwork_start.tv_usec - tv_workstart.tv_usec < 0) {
                    iVar12 = iVar12 + -1;
                }
                if (iVar18 < iVar9) {
                    if (local_1098 != 0xffffffff) {
                        iVar11 = iVar19 + 0x7ff;
                        if (-1 < iVar19 + 0x400) {
                            iVar11 = iVar19 + 0x400;
                        }
                        iVar11 = __aeabi_idiv(1000000, iVar11 >> 10);
                        iVar11 = (iVar11 + 0x10) * iVar9;
                        uVar7 = __udivsi3(0xfffffc00, iVar11);
                        if (uVar7 < local_1098) {
                            local_1098 = 0xffffffff;
                        } else {
                            local_1098 = local_1098 * iVar11 >> 10;
                        }
                        goto LAB_00022196;
                    }
                } else {
                    if (iVar9 < iVar18) {
                        local_1098 = __udivsi3(local_1098 * iVar9, iVar18);
                    } else if (100000 < iVar19) {
                        uVar8 = __aeabi_idiv(
                            iVar10 + iVar19,
                            (int)(iVar10 + 0x3ffU & iVar10 >> 0x20) >> 10);
                        local_1098 = __udivsi3(local_1098 << 10, uVar8);
                    }
                LAB_00022196:
                    iVar17 = _Var4 - tv_lastupdate.tv_usec;
                    iVar11 = _Var3 - tv_lastupdate.tv_sec;
                    if (iVar17 < 0) {
                        iVar11 = iVar11 + -1;
                        iVar17 = iVar17 + 1000000;
                    }
                    if (uVar24 == 0) {
                    LAB_0002225e:
                        if (opt_log_interval <= iVar11)
                            goto LAB_000221c0;
                        cVar2 = mythr->work_restart;
                    } else {
                        bVar20 = iVar11 == 0;
                        iVar1 = iVar11;
                        if (iVar11 < 1) {
                            iVar1 = iVar17 + -200000;
                            bVar20 = iVar17 == 200000;
                        }
                        if (bVar20 || iVar1 < 0 != (iVar11 < 1 &&
                                                    SBORROW4(iVar17, 200000)))
                            goto LAB_0002225e;
                    LAB_000221c0:
                        hashmeter(thr_id, uVar24);
                        uVar24 = 0;
                        copy_time(&tv_lastupdate, &getwork_start);
                        cVar2 = mythr->work_restart;
                    }
                    if (cVar2 != '\0') {
                        if (local_1080 == 0) {
                            tmp42[0] = (undefined1)local_1080;
                            tmp42[1] = local_1080._1_1_;
                            tmp42[2] = local_1080._2_1_;
                            tmp42[3] = local_1080._3_1_;
                            tmp42._4_4_ = mythr->device_thread * 250000000;
                            nanosleep((timespec *)tmp42, (timespec *)0x0);
                        }
                        goto LAB_00022234;
                    }
                    if ((mythr->pause == false) &&
                        (dev->deven == DEV_ENABLED)) {
                        iVar18 = 0;
                        iVar19 = 0;
                    } else {
                        iVar19 = 0;
                        iVar18 = 0;
                        mt_disable(mythr, thr_id,
                                   (device_drv *)&pdVar13->thread_enable);
                    }
                }
                iVar11 = *(int *)((int)&dev->max_hashes + 4);
                bVar20 = iVar11 == 0;
                if (iVar11 == 0) {
                    bVar20 = (uint)dev->max_hashes < 0xfffffffe;
                }
                if ((opt_scantime < iVar12 || !bVar20) ||
                    (_Var6 = stale_work(work, false), _Var6))
                    goto LAB_00022234;
            }
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "%s %d failure, disabling!",
                         pdVar13->name, dev->device_id);
                _applog(3, tmp42, false);
            }
            dev->deven = DEV_DISABLED;
            dev_error(dev, REASON_THREAD_ZERO_HASH);
            dev->shutdown = true;
        LAB_00022234:
            clean_work(work);
            free(work);
        } while (dev->shutdown == false);
    }
    dev->deven = DEV_DISABLED;
    return;
}

/* WARNING: Unknown calling convention */

void *watchdog_thread(void *userdata)

{
    _Bool _Var1;
    cgpu_info *dev;
    time_t tVar2;
    int *piVar3;
    alive aVar4;
    thr_info **pptVar5;
    int iVar6;
    thr_info **pptVar7;
    int iVar9;
    thr_info *ptVar10;
    int iVar11;
    timeval zero_tv;
    timeval now;
    char dev_str[8];
    char tmp42[4096];
    thr_info **pptVar8;

    pthread_setcanceltype(1, (int *)0x0);
    RenameThread("Watchdog");
    set_lowprio();
    cgtime(&rotate_tv);
    do {
        sleep(2);
        discard_stale();
        hashmeter(-1, 0);
        cgtime(&now);
        if (sched_paused == false) {
            if ((schedstart.enable != false) || (schedstop.enable != false)) {
                _Var1 = should_run();
                if (_Var1) {
                    if (sched_paused != false)
                        goto LAB_00022514;
                } else {
                    if (((use_syslog == false) && (opt_log_output == false)) &&
                        (opt_log_level < 4)) {
                        if (schedstart.enable == false) {
                        LAB_000229b6:
                            builtin_strncpy(tmp42,
                                            "Terminating execution as planned",
                                            0x20);
                            tmp42[0x20] = '\0';
                            _applog(3, tmp42, true);
                            /* WARNING: Subroutine does not return */
                            __quit(0, true);
                        }
                    LAB_00022792:
                        if (3 < opt_log_level)
                            goto LAB_00022830;
                    } else {
                        snprintf(tmp42, 0x1000,
                                 "Pausing execution as per stop time %02d:%02d "
                                 "scheduled",
                                 schedstop.tm.tm_hour, schedstop.tm.tm_min);
                        _applog(4, tmp42, false);
                        if (schedstart.enable == false)
                            goto LAB_000229b6;
                        if ((use_syslog == false) && (opt_log_output == false))
                            goto LAB_00022792;
                    LAB_00022830:
                        snprintf(
                            tmp42, 0x1000,
                            "Will restart execution as scheduled at %02d:%02d",
                            schedstart.tm.tm_hour, schedstart.tm.tm_min);
                        _applog(4, tmp42, false);
                    }
                    sched_paused = true;
                    iVar9 = pthread_rwlock_rdlock(
                        (pthread_rwlock_t *)&mining_thr_lock);
                    if (iVar9 != 0) {
                        piVar3 = __errno_location();
                        snprintf(
                            tmp42, 0x1000,
                            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                            *piVar3, "cgminer.c", "watchdog_thread", 0x25f9);
                        goto LAB_00022a0e;
                    }
                    if (0 < mining_threads) {
                        pptVar5 = mining_thr + mining_threads;
                        pptVar7 = mining_thr;
                        do {
                            pptVar8 = pptVar7 + 1;
                            (*pptVar7)->pause = true;
                            pptVar7 = pptVar8;
                        } while (pptVar8 != pptVar5);
                    }
                    iVar9 = pthread_rwlock_unlock(
                        (pthread_rwlock_t *)&mining_thr_lock);
                    if (iVar9 != 0) {
                        piVar3 = __errno_location();
                        snprintf(tmp42, 0x1000,
                                 "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s "
                                 "%s():%d",
                                 *piVar3, "cgminer.c", "watchdog_thread",
                                 0x25fc);
                    LAB_00022a0e:
                        _applog(3, tmp42, true);
                        /* WARNING: Subroutine does not return */
                        __quit(1, true);
                    }
                    (*selective_yield)();
                }
            }
        } else {
        LAB_00022514:
            if (((schedstart.enable == false) && (schedstop.enable == false)) ||
                (_Var1 = should_run(), _Var1)) {
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 4)) {
                    if (schedstop.enable != false) {
                    LAB_00022976:
                        if (3 < opt_log_level)
                            goto LAB_0002297c;
                    }
                } else {
                    snprintf(tmp42, 0x1000,
                             "Restarting execution as per start time %02d:%02d "
                             "scheduled",
                             schedstart.tm.tm_hour, schedstart.tm.tm_min);
                    _applog(4, tmp42, false);
                    if (schedstop.enable != false) {
                        if ((use_syslog == false) && (opt_log_output == false))
                            goto LAB_00022976;
                    LAB_0002297c:
                        snprintf(
                            tmp42, 0x1000,
                            "Will pause execution as scheduled at %02d:%02d",
                            schedstop.tm.tm_hour, schedstop.tm.tm_min);
                        _applog(4, tmp42, false);
                    }
                }
                iVar9 = 0;
                sched_paused = false;
                if (0 < mining_threads) {
                    do {
                        ptVar10 = get_thread(iVar9);
                        _Var1 = opt_debug;
                        if (ptVar10->cgpu->deven != DEV_DISABLED) {
                            ptVar10->pause = false;
                            if ((_Var1 != false) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (6 < opt_log_level)))) {
                                snprintf(tmp42, 0x1000,
                                         "Pushing sem post to thread %d",
                                         ptVar10->id);
                                _applog(7, tmp42, false);
                            }
                            _cgsem_post(&ptVar10->sem, "cgminer.c",
                                        "watchdog_thread", 0x2612);
                        }
                        iVar9 = iVar9 + 1;
                    } while (iVar9 < mining_threads);
                }
            }
        }
        if (0 < total_devices) {
            iVar9 = 0;
            do {
                dev = get_devices(iVar9);
                ptVar10 = *dev->thr;
                if (ptVar10 != (thr_info *)0x0) {
                    (*dev->drv->get_stats)(dev);
                    iVar11 = dev->device_id;
                    snprintf(dev_str, 8, "%s %d", dev->drv->name, iVar11);
                    _Var1 = use_syslog;
                    if ((ptVar10->getwork == false) &&
                        (dev->deven != DEV_DISABLED)) {
                        aVar4 = dev->status;
                        iVar6 = now.tv_sec - (ptVar10->last).tv_sec;
                        if (aVar4 == LIFE_WELL) {
                            if (0x78 < iVar6) {
                                dev->rolling = 0.0;
                                dev->status = LIFE_SICK;
                                if (((_Var1 != false) ||
                                     (opt_log_output != false)) ||
                                    (2 < opt_log_level)) {
                                    snprintf(tmp42, 0x1000,
                                             "%s: Idle for more than 60 "
                                             "seconds, declaring SICK!",
                                             dev_str, iVar11);
                                    _applog(3, tmp42, false);
                                }
                                cgtime(&ptVar10->sick);
                                dev_error(dev, REASON_DEV_SICK_IDLE_60);
                                if (opt_restart != false) {
                                    if (((use_syslog != false) ||
                                         (opt_log_output != false)) ||
                                        (2 < opt_log_level)) {
                                        snprintf(tmp42, 0x1000,
                                                 "%s: Attempting to restart",
                                                 dev_str, iVar11);
                                        _applog(3, tmp42, false);
                                    }
                                LAB_000225fe:
                                    if (dev->deven != DEV_DISABLED) {
                                        (*dev->drv->reinit_device)(dev);
                                    }
                                }
                            }
                        } else if (iVar6 < 0x78) {
                            if ((aVar4 != LIFE_INIT) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (2 < opt_log_level)))) {
                                snprintf(tmp42, 0x1000,
                                         "%s: Recovered, declaring WELL!",
                                         dev_str, iVar11);
                                _applog(3, tmp42, false);
                            }
                            dev->status = LIFE_WELL;
                            tVar2 = time((time_t *)0x0);
                            dev->device_last_well = tVar2;
                        } else if (aVar4 == LIFE_SICK) {
                            if (iVar6 < 0x259) {
                                if (0x3c <
                                    now.tv_sec - (ptVar10->sick).tv_sec) {
                                    cgtime(&ptVar10->sick);
                                    goto joined_r0x0002272e;
                                }
                            } else {
                                dev->status = LIFE_DEAD;
                                if (((_Var1 != false) ||
                                     (opt_log_output != false)) ||
                                    (2 < opt_log_level)) {
                                    snprintf(tmp42, 0x1000,
                                             "%s: Not responded for more than "
                                             "10 minutes, declaring DEAD!",
                                             dev_str, iVar11);
                                    _applog(3, tmp42, false);
                                }
                                cgtime(&ptVar10->sick);
                                dev_error(dev, REASON_DEV_DEAD_IDLE_600);
                            }
                        } else if ((0x3c <
                                    now.tv_sec - (ptVar10->sick).tv_sec) &&
                                   (aVar4 == LIFE_DEAD)) {
                            cgtime(&ptVar10->sick);
                        joined_r0x0002272e:
                            if (opt_restart != false)
                                goto LAB_000225fe;
                        }
                    }
                }
                iVar9 = iVar9 + 1;
            } while (iVar9 < total_devices);
        }
    } while (true);
}

/* WARNING: Type propagation algorithm not settling */
/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Restarted to delay deadcode elimination for space: stack */
/* WARNING: Unknown calling convention */

_Bool test_work_current(work *work)

{
    undefined1 uVar1;
    undefined1 uVar2;
    int iVar3;
    size_t __n;
    int *piVar4;
    block *pbVar5;
    UT_hash_handle *pUVar6;
    UT_hash_table *pUVar7;
    int iVar8;
    tm *ptVar9;
    UT_hash_bucket *pUVar10;
    pool *ppVar11;
    UT_hash_handle *pUVar12;
    undefined4 extraout_r1;
    uint uVar13;
    char *pcVar14;
    UT_hash_handle *pUVar15;
    UT_hash_handle *pUVar16;
    pool *ppVar17;
    uint uVar18;
    uint uVar19;
    uint uVar20;
    uint uVar21;
    UT_hash_handle *pUVar22;
    int iVar23;
    block *pbVar24;
    pool *ppVar25;
    UT_hash_handle *pUVar26;
    void *pvVar27;
    uint uVar28;
    block *pbVar29;
    block *pbVar30;
    UT_hash_handle *pUVar31;
    UT_hash_handle *pUVar32;
    byte *pbVar33;
    UT_hash_handle *pUVar34;
    size_t sVar35;
    bool bVar36;
    undefined4 extraout_s0;
    undefined4 extraout_s1;
    double dVar37;
    UDItype val;
    char *pcVar38;
    undefined4 uVar39;
    uint local_10a8;
    int local_10a4;
    uchar bedata[32];
    char hexstr[68];
    char tmp42[4096];

    if (work->mandatory != false) {
        return work->mandatory;
    }
    bedata._4_4_ = *(undefined4 *)(work->data + 0x1c);
    bedata._0_4_ = *(undefined4 *)(work->data + 0x20);
    bedata._16_4_ = *(undefined4 *)(work->data + 0x10);
    bedata._20_4_ = *(undefined4 *)(work->data + 0xc);
    bedata._24_4_ = *(undefined4 *)(work->data + 8);
    bedata._12_4_ = *(undefined4 *)(work->data + 0x14);
    bedata._8_4_ = *(undefined4 *)(work->data + 0x18);
    bedata._28_4_ = *(undefined4 *)(work->data + 4);
    ppVar17 = work->pool;
    __bin2hex(hexstr, bedata, 0x20);
    iVar3 = pthread_rwlock_rdlock((pthread_rwlock_t *)&blk_lock);
    pbVar5 = blocks;
    if (iVar3 == 0) {
        uVar2 = 0;
        if (blocks != (block *)0x0) {
            __n = strlen(hexstr);
            uVar18 = 0x9e3779b9;
            sVar35 = __n;
            if (__n < 0xc) {
                uVar21 = 0xfeedbeef;
                pbVar33 = (byte *)hexstr;
                uVar13 = uVar18;
            } else {
                pbVar33 = (byte *)hexstr;
                uVar21 = 0xfeedbeef;
                uVar13 = uVar18;
                do {
                    pbVar33 = pbVar33 + 0xc;
                    sVar35 = sVar35 - 0xc;
                    iVar3 = uVar13 + (uint)pbVar33[-6] * 0x10000 +
                            (uint)pbVar33[-7] * 0x100 + (uint)pbVar33[-8] +
                            (uint)pbVar33[-5] * 0x1000000;
                    uVar21 = (uint)pbVar33[-4] + (uint)pbVar33[-2] * 0x10000 +
                             (uint)pbVar33[-3] * 0x100 +
                             (uint)pbVar33[-1] * 0x1000000 + uVar21;
                    uVar13 =
                        ((((uint)pbVar33[-10] * 0x10000 +
                           (uint)pbVar33[-0xb] * 0x100 + (uint)pbVar33[-0xc] +
                           (uint)pbVar33[-9] * 0x1000000) -
                          iVar3) -
                         uVar21) +
                            uVar18 ^
                        uVar21 >> 0xd;
                    uVar18 = (iVar3 - uVar21) - uVar13 ^ uVar13 << 8;
                    uVar19 = (uVar21 - uVar13) - uVar18 ^ uVar18 >> 0xd;
                    uVar21 = (uVar13 - uVar18) - uVar19 ^ uVar19 >> 0xc;
                    uVar13 = (uVar18 - uVar19) - uVar21 ^ uVar21 << 0x10;
                    uVar19 = (uVar19 - uVar21) - uVar13 ^ uVar13 >> 5;
                    uVar18 = (uVar21 - uVar13) - uVar19 ^ uVar19 >> 3;
                    uVar13 = (uVar13 - uVar19) - uVar18 ^ uVar18 << 10;
                    uVar21 = (uVar19 - uVar18) - uVar13 ^ uVar13 >> 0xf;
                } while (0xb < sVar35);
            }
            uVar21 = uVar21 + __n;
            switch (sVar35) {
            case 0xb:
                uVar21 = uVar21 + (uint)pbVar33[10] * 0x1000000;
            case 10:
                uVar21 = uVar21 + (uint)pbVar33[9] * 0x10000;
            case 9:
                uVar21 = uVar21 + (uint)pbVar33[8] * 0x100;
            case 8:
                uVar13 = uVar13 + (uint)pbVar33[7] * 0x1000000;
            case 7:
                uVar13 = uVar13 + (uint)pbVar33[6] * 0x10000;
            case 6:
                uVar13 = uVar13 + (uint)pbVar33[5] * 0x100;
            case 5:
                uVar13 = uVar13 + pbVar33[4];
            case 4:
                uVar18 = uVar18 + (uint)pbVar33[3] * 0x1000000;
            case 3:
                uVar18 = uVar18 + (uint)pbVar33[2] * 0x10000;
            case 2:
                uVar18 = uVar18 + (uint)pbVar33[1] * 0x100;
            case 1:
                uVar18 = uVar18 + *pbVar33;
            }
            pUVar7 = (pbVar5->hh).tbl;
            uVar18 = (uVar18 - uVar13) - uVar21 ^ uVar21 >> 0xd;
            uVar13 = (uVar13 - uVar21) - uVar18 ^ uVar18 << 8;
            uVar19 = (uVar21 - uVar18) - uVar13 ^ uVar13 >> 0xd;
            uVar21 = (uVar18 - uVar13) - uVar19 ^ uVar19 >> 0xc;
            uVar18 = (uVar13 - uVar19) - uVar21 ^ uVar21 << 0x10;
            uVar19 = (uVar19 - uVar21) - uVar18 ^ uVar18 >> 5;
            uVar13 = (uVar21 - uVar18) - uVar19 ^ uVar19 >> 3;
            uVar18 = (uVar18 - uVar19) - uVar13 ^ uVar13 << 10;
            pUVar22 =
                pUVar7
                    ->buckets[pUVar7->num_buckets - 1 &
                              ((uVar19 - uVar13) - uVar18 ^ uVar18 >> 0xf)]
                    .hh_head;
            if (pUVar22 != (UT_hash_handle *)0x0) {
                iVar3 = pUVar7->hho;
                do {
                    iVar23 = (int)pUVar22 - iVar3;
                    if (iVar23 == 0)
                        break;
                    if ((__n == *(size_t *)(iVar23 + 0x5c)) &&
                        (iVar8 = memcmp(*(void **)(iVar23 + 0x58), hexstr, __n),
                         iVar8 == 0)) {
                        iVar3 = pthread_rwlock_unlock(
                            (pthread_rwlock_t *)&blk_lock);
                        if (iVar3 != 0)
                            goto LAB_00022c12;
                        (*selective_yield)();
                        iVar3 = memcmp(ppVar17->prev_block, bedata, 0x20);
                        if (iVar3 == 0) {
                            uVar1 = 1;
                        } else {
                            iVar3 = memcmp(bedata, current_block, 0x20);
                            if (iVar3 == 0) {
                                if ((opt_debug != false) &&
                                    (((use_syslog != false ||
                                       (opt_log_output != false)) ||
                                      (6 < opt_log_level)))) {
                                    snprintf(tmp42, 0x1000,
                                             "Pool %d now up to date",
                                             ppVar17->pool_no);
                                    _applog(7, tmp42, false);
                                }
                                *(undefined4 *)ppVar17->prev_block =
                                    bedata._0_4_;
                                *(undefined4 *)(ppVar17->prev_block + 4) =
                                    bedata._4_4_;
                                *(undefined4 *)(ppVar17->prev_block + 8) =
                                    bedata._8_4_;
                                *(undefined4 *)(ppVar17->prev_block + 0xc) =
                                    bedata._12_4_;
                                *(undefined4 *)(ppVar17->prev_block + 0x10) =
                                    bedata._16_4_;
                                *(undefined4 *)(ppVar17->prev_block + 0x14) =
                                    bedata._20_4_;
                                *(undefined4 *)(ppVar17->prev_block + 0x18) =
                                    bedata._24_4_;
                                *(undefined4 *)(ppVar17->prev_block + 0x1c) =
                                    bedata._28_4_;
                                uVar1 = 1;
                            } else {
                                uVar1 = opt_debug;
                                if (opt_debug != false) {
                                    if (((use_syslog == false) &&
                                         (opt_log_output == false)) &&
                                        (opt_log_level < 7)) {
                                        uVar1 = 0;
                                    } else {
                                        snprintf(tmp42, 0x1000,
                                                 "Stale data from pool %d",
                                                 ppVar17->pool_no);
                                        _applog(7, tmp42, false);
                                        uVar1 = uVar2;
                                    }
                                }
                            }
                        }
                        uVar2 = uVar1;
                        if (work->longpoll != false) {
                            uVar18 = pool_strategy - POOL_LOADBALANCE;
                            work_block = work_block + 1;
                            work->work_block = work_block;
                            if ((uVar18 < 2) ||
                                (ppVar25 = work->pool, ppVar11 = current_pool(),
                                 ppVar25 == ppVar11)) {
                                if (work->stratum == false) {
                                    if ((opt_debug != false) &&
                                        (((use_syslog != false ||
                                           (opt_log_output != false)) ||
                                          (6 < opt_log_level)))) {
                                        pcVar14 = "";
                                        if (work->gbt != false) {
                                            pcVar14 = "GBT ";
                                        }
                                        snprintf(tmp42, 0x1000,
                                                 "%sLONGPOLL from pool %d "
                                                 "requested work restart",
                                                 pcVar14, work->pool->pool_no);
                                        _applog(7, tmp42, false);
                                    }
                                } else if ((opt_debug != false) &&
                                           (((use_syslog != false ||
                                              (opt_log_output != false)) ||
                                             (6 < opt_log_level)))) {
                                    snprintf(tmp42, 0x1000,
                                             "Stratum from pool %d requested "
                                             "work restart",
                                             ppVar17->pool_no);
                                    _applog(7, tmp42, false);
                                }
                                restart_threads();
                            }
                        }
                        goto LAB_00022f12;
                    }
                    pUVar22 = *(UT_hash_handle **)(iVar23 + 0x54);
                } while (pUVar22 != (UT_hash_handle *)0x0);
            }
        }
        iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&blk_lock);
        if (iVar3 == 0) {
            (*selective_yield)();
            pbVar5 = (block *)calloc(0x68, 1);
            uVar39 = tmp42._20_4_;
            if (pbVar5 == (block *)0x0) {
                builtin_strncpy(tmp42, "test_work_current OOM", 0x16);
                tmp42._22_2_ = SUB42(uVar39, 2);
                _applog(3, tmp42, true);
                /* WARNING: Subroutine does not return */
                __quit(1, true);
            }
            strcpy((char *)pbVar5, hexstr);
            pbVar5->block_no = new_blocks;
            new_blocks = new_blocks + 1;
            iVar3 = pthread_rwlock_wrlock((pthread_rwlock_t *)&blk_lock);
            pbVar30 = blocks;
            if (iVar3 == 0) {
                if (blocks == (block *)0x0) {
                    (pbVar5->hh).key = pbVar5;
                    (pbVar5->hh).next = (void *)0x0;
                    sVar35 = strlen((char *)pbVar5);
                    (pbVar5->hh).keylen = sVar35;
                    local_10a4 = 0;
                LAB_0002368a:
                    (pbVar5->hh).prev = (void *)0x0;
                    blocks = pbVar5;
                    pUVar7 = (UT_hash_table *)malloc(0x2c);
                    (pbVar5->hh).tbl = pUVar7;
                    if (pUVar7 == (UT_hash_table *)0x0)
                        goto LAB_00023bca;
                    memset(&pUVar7->num_items, 0, 0x20);
                    pUVar7->tail = &pbVar5->hh;
                    pUVar7->num_buckets = 0x20;
                    pUVar7->log2_num_buckets = 5;
                    pUVar7->hho = 0x44;
                    pUVar10 = (UT_hash_bucket *)calloc(0x180, 1);
                    pUVar7->buckets = pUVar10;
                    if (pUVar10 == (UT_hash_bucket *)0x0)
                        goto LAB_00023bca;
                    pUVar7->signature = 0xa0111fe1;
                    pbVar30 = pbVar5;
                } else {
                    if (6 < ((blocks->hh).tbl)->num_items) {
                        pUVar22 = &blocks->hh;
                        pUVar31 = (UT_hash_handle *)0x1;
                    LAB_00022cb4:
                        pUVar15 = (UT_hash_handle *)0x0;
                        uVar18 = 0;
                        pUVar34 = pUVar22;
                        pUVar22 = (UT_hash_handle *)0x0;
                    LAB_00022cbe:
                        uVar18 = uVar18 + 1;
                        pUVar6 = pUVar31;
                        if (pUVar31 == (UT_hash_handle *)0x0) {
                            pUVar12 = (UT_hash_handle *)0x0;
                            pUVar26 = pUVar34;
                        } else {
                            pUVar26 = (UT_hash_handle *)pUVar34->next;
                            if (pUVar26 != (UT_hash_handle *)0x0) {
                                iVar3 = ((blocks->hh).tbl)->hho;
                                pUVar26 =
                                    (UT_hash_handle *)((int)&pUVar26->tbl +
                                                       iVar3);
                                if (pUVar26 != (UT_hash_handle *)0x0) {
                                    pUVar12 = (UT_hash_handle *)0x1;
                                    while (pUVar6 = pUVar12,
                                           pUVar12 != pUVar31) {
                                        pUVar26 =
                                            (UT_hash_handle *)pUVar26->next;
                                        pUVar12 =
                                            (UT_hash_handle
                                                 *)((int)&pUVar12->tbl + 1);
                                        pUVar6 = pUVar31;
                                        if ((pUVar26 ==
                                             (UT_hash_handle *)0x0) ||
                                            (pUVar26 =
                                                 (UT_hash_handle
                                                      *)((int)&pUVar26->tbl +
                                                         iVar3),
                                             pUVar26 == (UT_hash_handle *)0x0))
                                            break;
                                    }
                                    goto LAB_00022cf8;
                                }
                            }
                            pUVar12 = (UT_hash_handle *)0x1;
                        }
                    LAB_00022cf8:
                        do {
                            pUVar16 = pUVar15;
                            if (pUVar12 != (UT_hash_handle *)0x0)
                                goto LAB_00022d3c;
                        LAB_00022cfa:
                            if (pUVar6 == (UT_hash_handle *)0x0 ||
                                pUVar26 == (UT_hash_handle *)0x0) {
                                pUVar34 = pUVar26;
                                if (pUVar26 != (UT_hash_handle *)0x0)
                                    goto LAB_00022cbe;
                                if (pUVar15 != (UT_hash_handle *)0x0) {
                                    pUVar15->next = (void *)0x0;
                                }
                                if ((1 < uVar18) &&
                                    (pUVar31 =
                                         (UT_hash_handle *)((int)pUVar31 << 1),
                                     pUVar15 = pUVar22,
                                     pUVar22 != (UT_hash_handle *)0x0))
                                    goto LAB_00022cb4;
                                ((blocks->hh).tbl)->tail = pUVar15;
                                pbVar24 = (block *)((int)pUVar22 -
                                                    ((blocks->hh).tbl)->hho);
                                pvVar27 = (pbVar24->hh).prev;
                                local_10a4 = pbVar24->block_no;
                                blocks = pbVar24;
                                if (pvVar27 == (void *)0x0) {
                                    pbVar30 = (block *)(pbVar24->hh).next;
                                    pUVar7 = (pbVar24->hh).tbl;
                                    if (pbVar30 != (block *)0x0) {
                                        iVar3 = pUVar7->hho;
                                        pbVar29 = pbVar30;
                                        blocks = pbVar30;
                                        if (pbVar24 ==
                                            (block *)((int)pUVar7->tail -
                                                      iVar3))
                                            goto LAB_00023a52;
                                        goto LAB_0002361e;
                                    }
                                    free(pUVar7->buckets);
                                    free((pbVar24->hh).tbl);
                                    blocks = (block *)0x0;
                                } else {
                                    pUVar7 = (pbVar24->hh).tbl;
                                    iVar3 = pUVar7->hho;
                                    if (pbVar24 ==
                                        (block *)((int)pUVar7->tail - iVar3)) {
                                    LAB_00023a52:
                                        blocks = pbVar24;
                                        pUVar7->tail =
                                            (UT_hash_handle *)(iVar3 +
                                                               (int)pvVar27);
                                        pvVar27 = (pbVar24->hh).prev;
                                        if (pvVar27 == (void *)0x0) {
                                            pbVar30 =
                                                (block *)(pbVar24->hh).next;
                                            pbVar29 = pbVar30;
                                            blocks = pbVar30;
                                            goto LAB_0002361e;
                                        }
                                        iVar3 = ((pbVar24->hh).tbl)->hho;
                                    }
                                    *(void **)((int)pvVar27 + iVar3 + 8) =
                                        (pbVar24->hh).next;
                                    pbVar30 = pbVar24;
                                    pbVar29 = (block *)(pbVar24->hh).next;
                                LAB_0002361e:
                                    pUVar7 = (pbVar30->hh).tbl;
                                    if (pbVar29 != (block *)0x0) {
                                        *(void **)(pbVar29->hash + pUVar7->hho +
                                                   4) = (pbVar24->hh).prev;
                                        pUVar7 = (pbVar30->hh).tbl;
                                    }
                                    uVar18 = pUVar7->num_buckets - 1 &
                                             (pbVar24->hh).hashv;
                                    pUVar7->buckets[uVar18].count =
                                        pUVar7->buckets[uVar18].count - 1;
                                    pUVar10 = ((pbVar30->hh).tbl)->buckets;
                                    pUVar22 = pUVar10[uVar18].hh_head;
                                    bVar36 = pUVar22 == &pbVar24->hh;
                                    if (bVar36) {
                                        pUVar22 = (pbVar24->hh).hh_next;
                                    }
                                    if (bVar36) {
                                        pUVar10[uVar18].hh_head = pUVar22;
                                    }
                                    pUVar31 = (pbVar24->hh).hh_prev;
                                    pUVar22 = (pbVar24->hh).hh_next;
                                    if (pUVar31 != (UT_hash_handle *)0x0) {
                                        pUVar31->hh_next = pUVar22;
                                        pUVar22 = (pbVar24->hh).hh_next;
                                    }
                                    if (pUVar22 != (UT_hash_handle *)0x0) {
                                        pUVar22->hh_prev =
                                            (pbVar24->hh).hh_prev;
                                    }
                                    pUVar7 = (pbVar30->hh).tbl;
                                    pUVar7->num_items = pUVar7->num_items - 1;
                                }
                                free(pbVar24);
                                (pbVar5->hh).key = pbVar5;
                                (pbVar5->hh).next = (void *)0x0;
                                sVar35 = strlen((char *)pbVar5);
                                (pbVar5->hh).keylen = sVar35;
                                if (pbVar30 == (block *)0x0)
                                    goto LAB_0002368a;
                                goto LAB_00022f48;
                            }
                            pUVar16 = pUVar15;
                            pUVar15 = pUVar26;
                            pUVar32 = pUVar12;
                            if (pUVar26->next != (void *)0x0) {
                                pUVar32 =
                                    (UT_hash_handle *)((int)pUVar26->next +
                                                       ((blocks->hh).tbl)->hho);
                            }
                        LAB_00022d16:
                            pUVar6 =
                                (UT_hash_handle *)((int)&pUVar6[-1].hashv + 3);
                            pUVar26 = pUVar32;
                            if (pUVar16 == (UT_hash_handle *)0x0)
                                goto LAB_0002357c;
                        LAB_00022d1e:
                            pUVar26 = pUVar32;
                            pUVar16->next = (void *)((int)pUVar15 -
                                                     ((blocks->hh).tbl)->hho);
                            if (pUVar15 != (UT_hash_handle *)0x0) {
                            LAB_00022d2c:
                                pvVar27 = (void *)((int)pUVar16 -
                                                   ((blocks->hh).tbl)->hho);
                                do {
                                    pUVar15->prev = pvVar27;
                                    pUVar16 = pUVar15;
                                    if (pUVar12 == (UT_hash_handle *)0x0)
                                        goto LAB_00022cfa;
                                LAB_00022d3c:
                                    pUVar15 = pUVar34;
                                    pUVar34 = pUVar15;
                                    if (pUVar26 == (UT_hash_handle *)0x0 ||
                                        pUVar6 == (UT_hash_handle *)0x0) {
                                        if ((pUVar15 !=
                                             (UT_hash_handle *)0x0) &&
                                            (pUVar34 = (UT_hash_handle *)
                                                           pUVar15->next,
                                             pUVar34 !=
                                                 (UT_hash_handle *)0x0)) {
                                            pUVar34 =
                                                (UT_hash_handle
                                                     *)((int)&pUVar34->tbl +
                                                        ((blocks->hh).tbl)
                                                            ->hho);
                                        }
                                    LAB_00022d5c:
                                        pUVar12 =
                                            (UT_hash_handle *)((int)&pUVar12[-1]
                                                                   .hashv +
                                                               3);
                                        if (pUVar16 != (UT_hash_handle *)0x0)
                                            goto code_r0x00022d64;
                                    } else {
                                        iVar3 = ((blocks->hh).tbl)->hho;
                                        if (*(int *)((int)pUVar15 + -iVar3 +
                                                     100) -
                                                *(int *)((int)pUVar26 + -iVar3 +
                                                         100) <
                                            1) {
                                            if ((pUVar15 !=
                                                 (UT_hash_handle *)0x0) &&
                                                (pUVar34 = (UT_hash_handle
                                                                *)(iVar3 +
                                                                   (int)pUVar15
                                                                       ->next),
                                                 pUVar15->next ==
                                                     (void *)0x0)) {
                                                pUVar34 = (UT_hash_handle *)0x0;
                                            }
                                            goto LAB_00022d5c;
                                        }
                                        pUVar15 = pUVar26;
                                        pUVar32 =
                                            (UT_hash_handle
                                                 *)((int)pUVar26->next + iVar3);
                                        if (pUVar26->next != (void *)0x0)
                                            goto LAB_00022d16;
                                        pUVar6 =
                                            (UT_hash_handle
                                                 *)((int)&pUVar6[-1].hashv + 3);
                                        pUVar26 = (UT_hash_handle *)0x0;
                                        pUVar32 = (UT_hash_handle *)0x0;
                                        if (pUVar16 != (UT_hash_handle *)0x0)
                                            goto LAB_00022d1e;
                                    }
                                LAB_0002357c:
                                    pvVar27 = (void *)0x0;
                                    pUVar22 = pUVar15;
                                    if (pUVar15 == (UT_hash_handle *)0x0)
                                        break;
                                } while (true);
                            }
                        } while (true);
                    }
                    (pbVar5->hh).key = pbVar5;
                    (pbVar5->hh).next = (void *)0x0;
                    sVar35 = strlen((char *)pbVar5);
                    (pbVar5->hh).keylen = sVar35;
                    local_10a4 = 0;
                LAB_00022f48:
                    ((pbVar30->hh).tbl)->tail->next = pbVar5;
                    pUVar7 = (pbVar30->hh).tbl;
                    (pbVar5->hh).prev =
                        (void *)((int)pUVar7->tail - pUVar7->hho);
                    ((pbVar30->hh).tbl)->tail = &pbVar5->hh;
                    pUVar7 = (pbVar30->hh).tbl;
                }
                uVar19 = 0xfeedbeef;
                uVar28 = 0x9e3779b9;
                pUVar7->num_items = pUVar7->num_items + 1;
                pUVar7 = (pbVar30->hh).tbl;
                (pbVar5->hh).hashv = 0xfeedbeef;
                pUVar22 = &pbVar5->hh;
                pUVar22->tbl = pUVar7;
                uVar13 = strlen((char *)pbVar5);
                uVar18 = uVar28;
                pbVar24 = pbVar5;
                uVar21 = uVar13;
                if (0xb < uVar13) {
                    do {
                        pcVar14 = pbVar24->hash;
                        uVar21 = uVar13 - 0xc;
                        uVar19 = (uint)(byte)pbVar24->hash[10] * 0x10000 +
                                 (uint)(byte)pbVar24->hash[9] * 0x100 +
                                 (uint)(byte)pbVar24->hash[8] +
                                 (uint)(byte)pbVar24->hash[0xb] * 0x1000000 +
                                 uVar19;
                        iVar3 = (uint)(byte)pbVar24->hash[6] * 0x10000 +
                                (uint)(byte)pbVar24->hash[5] * 0x100 +
                                (uint)(byte)pbVar24->hash[4] +
                                (uint)(byte)pbVar24->hash[7] * 0x1000000 +
                                uVar18;
                        uVar13 = ((((uint)(byte)pbVar24->hash[2] * 0x10000 +
                                    (uint)(byte)pbVar24->hash[1] * 0x100 +
                                    (uint)(byte)pbVar24->hash[0] +
                                    (uint)(byte)pbVar24->hash[3] * 0x1000000) -
                                   uVar19) -
                                  iVar3) +
                                     uVar28 ^
                                 uVar19 >> 0xd;
                        uVar28 = (iVar3 - uVar19) - uVar13 ^ uVar13 << 8;
                        uVar18 = (uVar19 - uVar13) - uVar28 ^ uVar28 >> 0xd;
                        uVar19 = (uVar13 - uVar28) - uVar18 ^ uVar18 >> 0xc;
                        uVar20 = (uVar28 - uVar18) - uVar19 ^ uVar19 << 0x10;
                        uVar13 = (uVar18 - uVar19) - uVar20 ^ uVar20 >> 5;
                        uVar28 = (uVar19 - uVar20) - uVar13 ^ uVar13 >> 3;
                        uVar18 = (uVar20 - uVar13) - uVar28 ^ uVar28 << 10;
                        uVar19 = (uVar13 - uVar28) - uVar18 ^ uVar18 >> 0xf;
                        (pbVar5->hh).hashv = uVar19;
                        uVar13 = uVar21;
                        pbVar24 = (block *)(pcVar14 + 0xc);
                    } while (0xb < uVar21);
                    uVar13 = strlen((char *)pbVar5);
                }
                uVar19 = uVar19 + uVar13;
                (pbVar5->hh).hashv = uVar19;
                switch (uVar21) {
                case 0xb:
                    uVar19 = uVar19 + (uint)(byte)pbVar24->hash[10] * 0x1000000;
                    (pbVar5->hh).hashv = uVar19;
                case 10:
                    uVar19 = uVar19 + (uint)(byte)pbVar24->hash[9] * 0x10000;
                    (pbVar5->hh).hashv = uVar19;
                case 9:
                    uVar19 = uVar19 + (uint)(byte)pbVar24->hash[8] * 0x100;
                    (pbVar5->hh).hashv = uVar19;
                case 8:
                    uVar18 = uVar18 + (uint)(byte)pbVar24->hash[7] * 0x1000000;
                case 7:
                    uVar18 = uVar18 + (uint)(byte)pbVar24->hash[6] * 0x10000;
                case 6:
                    uVar18 = uVar18 + (uint)(byte)pbVar24->hash[5] * 0x100;
                case 5:
                    uVar18 = uVar18 + (byte)pbVar24->hash[4];
                case 4:
                    uVar28 = uVar28 + (uint)(byte)pbVar24->hash[3] * 0x1000000;
                case 3:
                    uVar28 = uVar28 + (uint)(byte)pbVar24->hash[2] * 0x10000;
                case 2:
                    uVar28 = uVar28 + (uint)(byte)pbVar24->hash[1] * 0x100;
                case 1:
                    uVar28 = uVar28 + (byte)pbVar24->hash[0];
                }
                uVar13 = (uVar28 - uVar18) - uVar19 ^ uVar19 >> 0xd;
                uVar21 = (uVar18 - uVar19) - uVar13 ^ uVar13 << 8;
                uVar19 = (uVar19 - uVar13) - uVar21 ^ uVar21 >> 0xd;
                uVar18 = (uVar13 - uVar21) - uVar19 ^ uVar19 >> 0xc;
                uVar13 = (uVar21 - uVar19) - uVar18 ^ uVar18 << 0x10;
                uVar21 = (uVar19 - uVar18) - uVar13 ^ uVar13 >> 5;
                uVar18 = (uVar18 - uVar13) - uVar21 ^ uVar21 >> 3;
                uVar13 = (uVar13 - uVar21) - uVar18 ^ uVar18 << 10;
                uVar18 = (uVar21 - uVar18) - uVar13 ^ uVar13 >> 0xf;
                (pbVar5->hh).hashv = uVar18;
                pUVar7 = (pbVar30->hh).tbl;
                pUVar10 = pUVar7->buckets;
                uVar18 = uVar18 & pUVar7->num_buckets - 1;
                pUVar10[uVar18].count = pUVar10[uVar18].count + 1;
                pUVar31 = ((pbVar30->hh).tbl)->buckets[uVar18].hh_head;
                (pbVar5->hh).hh_prev = (UT_hash_handle *)0x0;
                (pbVar5->hh).hh_next = pUVar31;
                pUVar10 = ((pbVar30->hh).tbl)->buckets;
                if (pUVar10[uVar18].hh_head != (UT_hash_handle *)0x0) {
                    (pUVar10[uVar18].hh_head)->hh_prev = pUVar22;
                    pUVar10 = ((pbVar30->hh).tbl)->buckets;
                }
                pUVar10[uVar18].hh_head = pUVar22;
                pUVar10 = ((pbVar30->hh).tbl)->buckets;
                if (((pUVar10[uVar18].expand_mult + 1) * 10 <=
                     pUVar10[uVar18].count) &&
                    (pUVar7 = (pbVar5->hh).tbl, pUVar7->noexpand != 1)) {
                    pUVar10 =
                        (UT_hash_bucket *)calloc(pUVar7->num_buckets * 0x18, 1);
                    if (pUVar10 == (UT_hash_bucket *)0x0) {
                    LAB_00023bca:
                        /* WARNING: Subroutine does not return */
                        exit(-1);
                    }
                    uVar18 = pUVar7->num_items >>
                             (pUVar7->log2_num_buckets + 1 & 0xff);
                    if ((pUVar7->num_buckets * 2 - 1 & pUVar7->num_items) !=
                        0) {
                        uVar18 = uVar18 + 1;
                    }
                    pUVar7->ideal_chain_maxlen = uVar18;
                    ((pbVar5->hh).tbl)->nonideal_items = 0;
                    pUVar7 = (pbVar5->hh).tbl;
                    uVar18 = pUVar7->num_buckets;
                    if (uVar18 != 0) {
                        iVar3 = 0;
                        local_10a8 = 0;
                        do {
                            pUVar22 = *(UT_hash_handle **)((int)&pUVar7->buckets
                                                               ->hh_head +
                                                           iVar3);
                            if (pUVar22 != (UT_hash_handle *)0x0) {
                                while (true) {
                                    pUVar31 = pUVar22->hh_next;
                                    uVar13 = uVar18 * 2 - 1 & pUVar22->hashv;
                                    uVar18 = pUVar10[uVar13].count + 1;
                                    pUVar10[uVar13].count = uVar18;
                                    if (pUVar7->ideal_chain_maxlen < uVar18) {
                                        pUVar7->nonideal_items =
                                            pUVar7->nonideal_items + 1;
                                        uVar18 =
                                            __udivsi3(pUVar10[uVar13].count,
                                                      ((pbVar5->hh).tbl)
                                                          ->ideal_chain_maxlen);
                                        pUVar10[uVar13].expand_mult = uVar18;
                                    }
                                    pUVar22->hh_prev = (UT_hash_handle *)0x0;
                                    pUVar22->hh_next = pUVar10[uVar13].hh_head;
                                    if (pUVar10[uVar13].hh_head !=
                                        (UT_hash_handle *)0x0) {
                                        (pUVar10[uVar13].hh_head)->hh_prev =
                                            pUVar22;
                                    }
                                    pUVar10[uVar13].hh_head = pUVar22;
                                    pUVar7 = (pbVar5->hh).tbl;
                                    if (pUVar31 == (UT_hash_handle *)0x0)
                                        break;
                                    uVar18 = pUVar7->num_buckets;
                                    pUVar22 = pUVar31;
                                }
                                uVar18 = pUVar7->num_buckets;
                            }
                            iVar3 = iVar3 + 0xc;
                            local_10a8 = local_10a8 + 1;
                        } while (local_10a8 < uVar18);
                    }
                    free(pUVar7->buckets);
                    pUVar7 = (pbVar5->hh).tbl;
                    pUVar7->num_buckets = pUVar7->num_buckets << 1;
                    pUVar7 = (pbVar5->hh).tbl;
                    pUVar7->log2_num_buckets = pUVar7->log2_num_buckets + 1;
                    ((pbVar5->hh).tbl)->buckets = pUVar10;
                    pUVar7 = (pbVar5->hh).tbl;
                    if (pUVar7->num_items >> 1 < pUVar7->nonideal_items) {
                        uVar18 = pUVar7->ineff_expands + 1;
                    } else {
                        uVar18 = 0;
                    }
                    pUVar7->ineff_expands = uVar18;
                    pUVar7 = (pbVar5->hh).tbl;
                    uVar13 = pUVar7->ineff_expands;
                    uVar18 = uVar13;
                    if (1 < uVar13) {
                        uVar18 = 1;
                    }
                    if (1 < uVar13) {
                        pUVar7->noexpand = uVar18;
                    }
                }
                uVar18 = *(uint *)(work->data + 0x48);
                iVar3 = 0x1d - (uint)work->data[0x48];
                uVar13 = iVar3 * 8;
                uVar39 =
                    __floatundidf(0xffff << (uVar13 & 0xff),
                                  0xffff << (uVar13 - 0x20 & 0xff) |
                                      0xffffU >> (iVar3 * -8 + 0x20U & 0xff));
                dVar37 = (double)CONCAT44(extraout_r1, uVar39) /
                         (double)(longlong)(int)((uVar18 >> 8 & 0xff) << 0x10 |
                                                 (uVar18 >> 0x10 & 0xff) << 8 |
                                                 uVar18 >> 0x18);
                if (dVar37 != current_diff) {
                    val = __fixunsdfdi(
                        (DFtype)CONCAT44(extraout_s1, extraout_s0));
                    suffix_string(val, block_diff, 8, 0);
                    current_diff = dVar37;
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000, "Network diff set to %s",
                                 block_diff);
                        _applog(7, tmp42, false);
                    }
                }
                iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&blk_lock);
                if (iVar3 == 0) {
                    (*selective_yield)();
                    if (((local_10a4 != 0) && (opt_debug != false)) &&
                        ((use_syslog != false || ((opt_log_output != false ||
                                                   (6 < opt_log_level)))))) {
                        snprintf(tmp42, 0x1000,
                                 "Deleted block %d from database", local_10a4);
                        _applog(7, tmp42, false);
                    }
                    iVar3 = pthread_mutex_lock((pthread_mutex_t *)&ch_lock);
                    if (iVar3 == 0) {
                        iVar3 = pthread_rwlock_wrlock(
                            (pthread_rwlock_t *)&ch_lock.rwlock);
                        if (iVar3 == 0) {
                            cgtime(&block_timeval);
                            strcpy(current_hash, hexstr);
                            current_block[0] = bedata[0];
                            current_block[1] = bedata[1];
                            current_block[2] = bedata[2];
                            current_block[3] = bedata[3];
                            current_block[4] = bedata[4];
                            current_block[5] = bedata[5];
                            current_block[6] = bedata[6];
                            current_block[7] = bedata[7];
                            current_block[8] = bedata[8];
                            current_block[9] = bedata[9];
                            current_block[10] = bedata[10];
                            current_block[0xb] = bedata[0xb];
                            current_block[0xc] = bedata[0xc];
                            current_block[0xd] = bedata[0xd];
                            current_block[0xe] = bedata[0xe];
                            current_block[0xf] = bedata[0xf];
                            tmp42[0] = (undefined1)block_timeval.tv_sec;
                            tmp42[1] = block_timeval.tv_sec._1_1_;
                            tmp42[2] = block_timeval.tv_sec._2_1_;
                            tmp42[3] = block_timeval.tv_sec._3_1_;
                            current_block[0x10] = bedata[0x10];
                            current_block[0x11] = bedata[0x11];
                            current_block[0x12] = bedata[0x12];
                            current_block[0x13] = bedata[0x13];
                            current_block[0x14] = bedata[0x14];
                            current_block[0x15] = bedata[0x15];
                            current_block[0x16] = bedata[0x16];
                            current_block[0x17] = bedata[0x17];
                            current_block[0x18] = bedata[0x18];
                            current_block[0x19] = bedata[0x19];
                            current_block[0x1a] = bedata[0x1a];
                            current_block[0x1b] = bedata[0x1b];
                            current_block[0x1c] = bedata[0x1c];
                            current_block[0x1d] = bedata[0x1d];
                            current_block[0x1e] = bedata[0x1e];
                            current_block[0x1f] = bedata[0x1f];
                            ptVar9 = localtime((time_t *)tmp42);
                            pcVar14 = (char *)ptVar9->tm_min;
                            snprintf(blocktime, 0x20, "[%02d:%02d:%02d]",
                                     ptVar9->tm_hour, pcVar14, ptVar9->tm_sec);
                            iVar3 = pthread_rwlock_unlock(
                                (pthread_rwlock_t *)&ch_lock.rwlock);
                            if (iVar3 == 0) {
                                iVar3 = pthread_mutex_unlock(
                                    (pthread_mutex_t *)&ch_lock);
                                if (iVar3 == 0) {
                                    (*selective_yield)();
                                    iVar3 = 0;
                                    pcVar38 = current_hash;
                                    do {
                                        if (*pcVar38 != '0')
                                            break;
                                        iVar3 = iVar3 + 1;
                                        pcVar38 = pcVar38 + 1;
                                    } while (iVar3 != 0x39);
                                    strncpy(prev_block, current_hash + iVar3,
                                            8);
                                    prev_block[8] = '\0';
                                    if ((opt_debug != false) &&
                                        (((use_syslog != false ||
                                           (opt_log_output != false)) ||
                                          (6 < opt_log_level)))) {
                                        pcVar14 = block_diff;
                                        snprintf(tmp42, 0x1000,
                                                 "New block: %s... diff %s",
                                                 current_hash, block_diff);
                                        _applog(7, tmp42, false);
                                    }
                                    uVar39 = tmp42._28_4_;
                                    bVar36 = new_blocks != 1;
                                    *(undefined4 *)ppVar17->prev_block =
                                        bedata._0_4_;
                                    *(undefined4 *)(ppVar17->prev_block + 4) =
                                        bedata._4_4_;
                                    *(undefined4 *)(ppVar17->prev_block + 8) =
                                        bedata._8_4_;
                                    *(undefined4 *)(ppVar17->prev_block + 0xc) =
                                        bedata._12_4_;
                                    *(undefined4 *)(ppVar17->prev_block +
                                                    0x10) = bedata._16_4_;
                                    *(undefined4 *)(ppVar17->prev_block +
                                                    0x14) = bedata._20_4_;
                                    *(undefined4 *)(ppVar17->prev_block +
                                                    0x18) = bedata._24_4_;
                                    *(undefined4 *)(ppVar17->prev_block +
                                                    0x1c) = bedata._28_4_;
                                    if (bVar36) {
                                        work_block = work_block + 1;
                                        work->work_block = work_block;
                                        if (work->longpoll == false) {
                                            if (have_longpoll == false) {
                                                if (((ppVar17->gbt_solo ==
                                                      false) &&
                                                     (opt_debug != false)) &&
                                                    ((use_syslog != false ||
                                                      ((opt_log_output !=
                                                            false ||
                                                        (6 <
                                                         opt_log_level)))))) {
                                                    builtin_strncpy(
                                                        tmp42,
                                                        "New block detected on "
                                                        "network",
                                                        0x1e);
                                                    tmp42._30_2_ =
                                                        SUB42(uVar39, 2);
                                                    _applog(7, tmp42, false);
                                                }
                                            } else if (
                                                ((ppVar17->gbt_solo == false) &&
                                                 (opt_debug != false)) &&
                                                ((use_syslog != false ||
                                                  ((opt_log_output != false ||
                                                    (6 < opt_log_level)))))) {
                                                builtin_strncpy(
                                                    tmp42,
                                                    "New block detected on "
                                                    "network before pool "
                                                    "notificati",
                                                    0x34);
                                                tmp42[0x34] = 'o';
                                                tmp42[0x35] = 'n';
                                                tmp42[0x36] = '\0';
                                                _applog(7, tmp42, false);
                                            }
                                        } else if (work->stratum == false) {
                                            if ((opt_debug != false) &&
                                                (((use_syslog != false ||
                                                   (opt_log_output != false)) ||
                                                  (6 < opt_log_level)))) {
                                                pcVar14 = "";
                                                if (work->gbt != false) {
                                                    pcVar14 = "GBT ";
                                                }
                                                snprintf(
                                                    tmp42, 0x1000,
                                                    "%sLONGPOLL from pool %d "
                                                    "detected new block",
                                                    pcVar14,
                                                    work->pool->pool_no);
                                                _applog(7, tmp42, false);
                                            }
                                        } else if ((opt_debug != false) &&
                                                   (((use_syslog != false ||
                                                      (opt_log_output !=
                                                       false)) ||
                                                     (6 < opt_log_level)))) {
                                            snprintf(tmp42, 0x1000,
                                                     "Stratum from pool %d "
                                                     "detected new block",
                                                     ppVar17->pool_no, pcVar14);
                                            _applog(7, tmp42, false);
                                        }
                                        restart_threads();
                                        uVar2 = 1;
                                    }
                                LAB_00022f12:
                                    work->longpoll = false;
                                    return (_Bool)uVar2;
                                }
                                piVar4 = __errno_location();
                                iVar3 = *piVar4;
                                pcVar38 = "set_curblock";
                                uVar39 = 0x14d1;
                                pcVar14 = "WTF MUTEX ERROR ON UNLOCK! errno=%d "
                                          "in %s %s():%d";
                            } else {
                                piVar4 = __errno_location();
                                iVar3 = *piVar4;
                                pcVar38 = "set_curblock";
                                uVar39 = 0x14d1;
                                pcVar14 = "WTF RWLOCK ERROR ON UNLOCK! "
                                          "errno=%d in %s %s():%d";
                            }
                        } else {
                            piVar4 = __errno_location();
                            iVar3 = *piVar4;
                            pcVar38 = "set_curblock";
                            uVar39 = 0x14cc;
                            pcVar14 = "WTF WRLOCK ERROR ON LOCK! errno=%d in "
                                      "%s %s():%d";
                        }
                    } else {
                        piVar4 = __errno_location();
                        iVar3 = *piVar4;
                        pcVar38 = "set_curblock";
                        uVar39 = 0x14cc;
                        pcVar14 =
                            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                    }
                } else {
                    pcVar38 = "test_work_current";
                    piVar4 = __errno_location();
                    iVar3 = *piVar4;
                    uVar39 = 0x1536;
                    pcVar14 =
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
                }
                snprintf(tmp42, 0x1000, pcVar14, iVar3, "cgminer.c", pcVar38,
                         uVar39);
                goto LAB_00022c40;
            }
            piVar4 = __errno_location();
            iVar3 = *piVar4;
            pcVar14 = "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            pcVar38 = "test_work_current";
            uVar39 = 0x1526;
        } else {
        LAB_00022c12:
            piVar4 = __errno_location();
            iVar3 = *piVar4;
            pcVar14 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
            pcVar38 = "block_exists";
            uVar39 = 0x14e5;
        }
    } else {
        piVar4 = __errno_location();
        iVar3 = *piVar4;
        pcVar14 = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
        pcVar38 = "block_exists";
        uVar39 = 0x14e3;
    }
    snprintf(tmp42, 0x1000, pcVar14, iVar3, "cgminer.c", pcVar38, uVar39);
LAB_00022c40:
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
code_r0x00022d64:
    if (pUVar15 == (UT_hash_handle *)0x0) {
        pUVar16->next = (void *)0x0;
        goto LAB_00022cf8;
    }
    pUVar16->next = (void *)((int)pUVar15 - ((blocks->hh).tbl)->hho);
    goto LAB_00022d2c;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void _stage_work(work *work)

{
    pthread_mutex_t *__mutex;
    UT_hash_handle *pUVar1;
    int iVar2;
    uint uVar3;
    UT_hash_bucket *pUVar4;
    UT_hash_handle *pUVar5;
    int *piVar6;
    uint uVar7;
    UT_hash_handle *pUVar8;
    UT_hash_handle *pUVar9;
    UT_hash_table *pUVar10;
    UT_hash_handle *pUVar11;
    UT_hash_handle *pUVar12;
    char *__format;
    uint uVar13;
    UT_hash_handle *pUVar14;
    work *pwVar15;
    UT_hash_handle *pUVar16;
    void *pvVar17;
    thread_q *ptVar18;
    UT_hash_handle *pUVar19;
    undefined4 uVar20;
    uint local_1034;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Pushing work from pool %d to hash queue",
                 work->pool->pool_no);
        _applog(7, tmp42, false);
    }
    work->work_block = work_block;
    test_work_current(work);
    __mutex = stgd_lock;
    work->pool->works = work->pool->works + 1;
    iVar2 = pthread_mutex_lock((pthread_mutex_t *)__mutex);
    pwVar15 = staged_work;
    if (iVar2 == 0) {
        if ((work->clone == false) && (work->rolltime != 0)) {
            staged_rollable = staged_rollable + 1;
        }
        ptVar18 = getq;
        if (getq->frozen == false) {
            (work->hh).next = (void *)0x0;
            (work->hh).key = &work->id;
            (work->hh).keylen = 4;
            if (pwVar15 == (work *)0x0) {
                (work->hh).prev = (void *)0x0;
                staged_work = work;
                pUVar10 = (UT_hash_table *)malloc(0x2c);
                (work->hh).tbl = pUVar10;
                if (pUVar10 == (UT_hash_table *)0x0)
                    goto LAB_00024164;
                memset(&pUVar10->num_items, 0, 0x20);
                pUVar10->num_buckets = 0x20;
                pUVar10->tail = &work->hh;
                pUVar10->log2_num_buckets = 5;
                pUVar10->hho = 0x728;
                pUVar4 = (UT_hash_bucket *)calloc(0x180, 1);
                pUVar10->buckets = pUVar4;
                if (pUVar4 == (UT_hash_bucket *)0x0)
                    goto LAB_00024164;
                pUVar10->signature = 0xa0111fe1;
                pwVar15 = work;
            } else {
                ((pwVar15->hh).tbl)->tail->next = work;
                pUVar10 = (pwVar15->hh).tbl;
                (work->hh).prev = (void *)((int)pUVar10->tail - pUVar10->hho);
                ((pwVar15->hh).tbl)->tail = &work->hh;
                pUVar10 = (pwVar15->hh).tbl;
            }
            pUVar10->num_items = pUVar10->num_items + 1;
            uVar3 = (byte)work->id + 0x112410d +
                        (uint) * (byte *)((int)&work->id + 3) * 0x1000000 +
                        (uint) * (byte *)((int)&work->id + 2) * 0x10000 +
                        (uint) * (byte *)((int)&work->id + 1) * 0x100 ^
                    0x7f76d;
            uVar7 = 0x9f49bac6 - uVar3 ^ uVar3 << 8;
            pUVar14 = &work->hh;
            pUVar14->tbl = (pwVar15->hh).tbl;
            uVar13 = (-0x112410d - uVar3) - uVar7 ^ uVar7 >> 0xd;
            uVar3 = (uVar3 - uVar7) - uVar13 ^ uVar13 >> 0xc;
            uVar7 = (uVar7 - uVar13) - uVar3 ^ uVar3 << 0x10;
            uVar13 = (uVar13 - uVar3) - uVar7 ^ uVar7 >> 5;
            uVar3 = (uVar3 - uVar7) - uVar13 ^ uVar13 >> 3;
            uVar7 = (uVar7 - uVar13) - uVar3 ^ uVar3 << 10;
            uVar3 = (uVar13 - uVar3) - uVar7 ^ uVar7 >> 0xf;
            (work->hh).hashv = uVar3;
            pUVar10 = (pwVar15->hh).tbl;
            pUVar4 = pUVar10->buckets;
            uVar3 = uVar3 & pUVar10->num_buckets - 1;
            pUVar4[uVar3].count = pUVar4[uVar3].count + 1;
            pUVar8 = ((pwVar15->hh).tbl)->buckets[uVar3].hh_head;
            (work->hh).hh_prev = (UT_hash_handle *)0x0;
            (work->hh).hh_next = pUVar8;
            pUVar4 = ((pwVar15->hh).tbl)->buckets;
            if (pUVar4[uVar3].hh_head != (UT_hash_handle *)0x0) {
                (pUVar4[uVar3].hh_head)->hh_prev = pUVar14;
                pUVar4 = ((pwVar15->hh).tbl)->buckets;
            }
            pUVar4[uVar3].hh_head = pUVar14;
            pUVar4 = ((staged_work->hh).tbl)->buckets;
            pwVar15 = staged_work;
            if ((pUVar4[uVar3].count < (pUVar4[uVar3].expand_mult + 1) * 10) ||
                (pUVar10 = (work->hh).tbl, pUVar10->noexpand == 1)) {
            LAB_00023ef4:
                ptVar18 = getq;
                pUVar14 = &pwVar15->hh;
                pUVar8 = (UT_hash_handle *)0x1;
            LAB_00023efa:
                pUVar11 = (UT_hash_handle *)0x0;
                uVar3 = 0;
                pUVar19 = pUVar14;
                pUVar14 = (UT_hash_handle *)0x0;
            LAB_00023f04:
                uVar3 = uVar3 + 1;
                pUVar5 = pUVar8;
                if (pUVar8 == (UT_hash_handle *)0x0) {
                    pUVar9 = (UT_hash_handle *)0x0;
                    pUVar16 = pUVar19;
                } else {
                    pUVar16 = (UT_hash_handle *)pUVar19->next;
                    if (pUVar16 != (UT_hash_handle *)0x0) {
                        iVar2 = ((pwVar15->hh).tbl)->hho;
                        pUVar16 =
                            (UT_hash_handle *)((int)&pUVar16->tbl + iVar2);
                        if (pUVar16 != (UT_hash_handle *)0x0) {
                            pUVar9 = (UT_hash_handle *)0x1;
                            while (pUVar5 = pUVar9, pUVar9 != pUVar8) {
                                pUVar16 = (UT_hash_handle *)pUVar16->next;
                                pUVar9 =
                                    (UT_hash_handle *)((int)&pUVar9->tbl + 1);
                                pUVar5 = pUVar8;
                                if ((pUVar16 == (UT_hash_handle *)0x0) ||
                                    (pUVar16 =
                                         (UT_hash_handle *)((int)&pUVar16->tbl +
                                                            iVar2),
                                     pUVar16 == (UT_hash_handle *)0x0))
                                    break;
                            }
                            goto LAB_00023f40;
                        }
                    }
                    pUVar9 = (UT_hash_handle *)0x1;
                }
            LAB_00023f40:
                do {
                    pUVar12 = pUVar11;
                    if (pUVar9 != (UT_hash_handle *)0x0)
                        goto LAB_00023f84;
                LAB_00023f42:
                    if (pUVar5 == (UT_hash_handle *)0x0 ||
                        pUVar16 == (UT_hash_handle *)0x0) {
                        pUVar19 = pUVar16;
                        if (pUVar16 != (UT_hash_handle *)0x0)
                            goto LAB_00023f04;
                        if (pUVar11 != (UT_hash_handle *)0x0) {
                            pUVar11->next = (void *)0x0;
                        }
                        if ((1 < uVar3) &&
                            (pUVar8 = (UT_hash_handle *)((int)pUVar8 << 1),
                             pUVar11 = pUVar14,
                             pUVar14 != (UT_hash_handle *)0x0))
                            goto LAB_00023efa;
                        ((pwVar15->hh).tbl)->tail = pUVar11;
                        staged_work =
                            (work *)((int)pUVar14 - ((pwVar15->hh).tbl)->hho);
                        goto LAB_00024044;
                    }
                    pUVar12 = pUVar11;
                    pUVar11 = pUVar16;
                    pUVar1 = pUVar9;
                    if (pUVar16->next != (void *)0x0) {
                        pUVar1 = (UT_hash_handle *)((int)pUVar16->next +
                                                    ((pwVar15->hh).tbl)->hho);
                    }
                LAB_00023f5c:
                    pUVar16 = pUVar1;
                    pUVar5 = (UT_hash_handle *)((int)&pUVar5[-1].hashv + 3);
                    pUVar1 = pUVar16;
                    if (pUVar12 == (UT_hash_handle *)0x0)
                        goto LAB_00023fe8;
                LAB_00023f62:
                    pUVar16 = pUVar1;
                    pUVar12->next =
                        (void *)((int)pUVar11 - ((pwVar15->hh).tbl)->hho);
                    if (pUVar11 != (UT_hash_handle *)0x0) {
                    LAB_00023f72:
                        pvVar17 =
                            (void *)((int)pUVar12 - ((pwVar15->hh).tbl)->hho);
                        do {
                            pUVar11->prev = pvVar17;
                            pUVar12 = pUVar11;
                            if (pUVar9 == (UT_hash_handle *)0x0)
                                goto LAB_00023f42;
                        LAB_00023f84:
                            pUVar11 = pUVar19;
                            pUVar19 = pUVar11;
                            if (pUVar16 == (UT_hash_handle *)0x0 ||
                                pUVar5 == (UT_hash_handle *)0x0) {
                                if ((pUVar11 != (UT_hash_handle *)0x0) &&
                                    (pUVar19 = (UT_hash_handle *)pUVar11->next,
                                     pUVar19 != (UT_hash_handle *)0x0)) {
                                    pUVar19 =
                                        (UT_hash_handle *)((int)&pUVar19->tbl +
                                                           ((pwVar15->hh).tbl)
                                                               ->hho);
                                }
                            joined_r0x00023ffc:
                                if (pUVar12 != (UT_hash_handle *)0x0)
                                    goto LAB_00023fa4;
                                pUVar9 =
                                    (UT_hash_handle *)((int)&pUVar9[-1].hashv +
                                                       3);
                            } else {
                                iVar2 = ((pwVar15->hh).tbl)->hho;
                                if (*(int *)((int)pUVar11 + -iVar2 + 0x6d8) -
                                        *(int *)((int)pUVar16 + -iVar2 +
                                                 0x6d8) <
                                    1) {
                                    if ((pUVar11 != (UT_hash_handle *)0x0) &&
                                        (pUVar19 = (UT_hash_handle
                                                        *)(iVar2 +
                                                           (int)pUVar11->next),
                                         pUVar11->next == (void *)0x0)) {
                                        pUVar19 = (UT_hash_handle *)0x0;
                                    }
                                    goto joined_r0x00023ffc;
                                }
                                pUVar11 = pUVar16;
                                pUVar1 = (UT_hash_handle *)((int)pUVar16->next +
                                                            iVar2);
                                if (pUVar16->next != (void *)0x0)
                                    goto LAB_00023f5c;
                                pUVar5 =
                                    (UT_hash_handle *)((int)&pUVar5[-1].hashv +
                                                       3);
                                pUVar16 = (UT_hash_handle *)0x0;
                                pUVar1 = (UT_hash_handle *)0x0;
                                if (pUVar12 != (UT_hash_handle *)0x0)
                                    goto LAB_00023f62;
                            }
                        LAB_00023fe8:
                            pvVar17 = (void *)0x0;
                            pUVar14 = pUVar11;
                            if (pUVar11 == (UT_hash_handle *)0x0)
                                break;
                        } while (true);
                    }
                } while (true);
            }
            pUVar4 = (UT_hash_bucket *)calloc(pUVar10->num_buckets * 0x18, 1);
            if (pUVar4 == (UT_hash_bucket *)0x0) {
            LAB_00024164:
                /* WARNING: Subroutine does not return */
                exit(-1);
            }
            uVar3 =
                pUVar10->num_items >> (pUVar10->log2_num_buckets + 1 & 0xff);
            if ((pUVar10->num_buckets * 2 - 1 & pUVar10->num_items) != 0) {
                uVar3 = uVar3 + 1;
            }
            pUVar10->ideal_chain_maxlen = uVar3;
            ((work->hh).tbl)->nonideal_items = 0;
            pUVar10 = (work->hh).tbl;
            uVar3 = pUVar10->num_buckets;
            if (uVar3 != 0) {
                iVar2 = 0;
                local_1034 = 0;
                do {
                    pUVar14 =
                        *(UT_hash_handle **)((int)&pUVar10->buckets->hh_head +
                                             iVar2);
                    if (pUVar14 != (UT_hash_handle *)0x0) {
                        while (true) {
                            pUVar8 = pUVar14->hh_next;
                            uVar7 = uVar3 * 2 - 1 & pUVar14->hashv;
                            uVar3 = pUVar4[uVar7].count + 1;
                            pUVar4[uVar7].count = uVar3;
                            if (pUVar10->ideal_chain_maxlen < uVar3) {
                                pUVar10->nonideal_items =
                                    pUVar10->nonideal_items + 1;
                                uVar3 = __udivsi3(
                                    pUVar4[uVar7].count,
                                    ((work->hh).tbl)->ideal_chain_maxlen);
                                pUVar4[uVar7].expand_mult = uVar3;
                            }
                            pUVar14->hh_prev = (UT_hash_handle *)0x0;
                            pUVar14->hh_next = pUVar4[uVar7].hh_head;
                            if (pUVar4[uVar7].hh_head !=
                                (UT_hash_handle *)0x0) {
                                (pUVar4[uVar7].hh_head)->hh_prev = pUVar14;
                            }
                            pUVar4[uVar7].hh_head = pUVar14;
                            pUVar10 = (work->hh).tbl;
                            if (pUVar8 == (UT_hash_handle *)0x0)
                                break;
                            uVar3 = pUVar10->num_buckets;
                            pUVar14 = pUVar8;
                        }
                        uVar3 = pUVar10->num_buckets;
                    }
                    iVar2 = iVar2 + 0xc;
                    local_1034 = local_1034 + 1;
                } while (local_1034 < uVar3);
            }
            free(pUVar10->buckets);
            pUVar10 = (work->hh).tbl;
            pUVar10->num_buckets = pUVar10->num_buckets << 1;
            pUVar10 = (work->hh).tbl;
            pUVar10->log2_num_buckets = pUVar10->log2_num_buckets + 1;
            ((work->hh).tbl)->buckets = pUVar4;
            pwVar15 = staged_work;
            pUVar10 = (work->hh).tbl;
            if (pUVar10->num_items >> 1 < pUVar10->nonideal_items) {
                uVar3 = pUVar10->ineff_expands + 1;
            } else {
                uVar3 = 0;
            }
            pUVar10->ineff_expands = uVar3;
            pUVar10 = (work->hh).tbl;
            uVar7 = pUVar10->ineff_expands;
            uVar3 = uVar7;
            if (1 < uVar7) {
                uVar3 = 1;
            }
            if (1 < uVar7) {
                pUVar10->noexpand = uVar3;
            }
            ptVar18 = getq;
            if (pwVar15 != (work *)0x0)
                goto LAB_00023ef4;
        }
    LAB_00024044:
        pthread_cond_broadcast((pthread_cond_t *)&ptVar18->cond);
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)stgd_lock);
        if (iVar2 == 0) {
            (*selective_yield)();
            return;
        }
        piVar6 = __errno_location();
        iVar2 = *piVar6;
        __format = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
        uVar20 = 0x15a8;
    } else {
        piVar6 = __errno_location();
        iVar2 = *piVar6;
        __format = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        uVar20 = 0x159d;
    }
    snprintf(tmp42, 0x1000, __format, iVar2, "cgminer.c", "hash_push", uVar20);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
LAB_00023fa4:
    pUVar9 = (UT_hash_handle *)((int)&pUVar9[-1].hashv + 3);
    if (pUVar11 == (UT_hash_handle *)0x0) {
        pUVar12->next = (void *)0x0;
        goto LAB_00023f40;
    }
    pUVar12->next = (void *)((int)pUVar11 - ((pwVar15->hh).tbl)->hho);
    goto LAB_00023f72;
}

/* WARNING: Unknown calling convention */

void submit_work_async(work *work)

{
    char cVar1;
    _Bool _Var2;
    thr_info *ptVar3;
    int iVar4;
    int *piVar5;
    char *pcVar6;
    uint uVar7;
    undefined4 uVar8;
    pool *ppVar9;
    cgpu_info *pcVar10;
    bool bVar11;
    double dVar12;
    pthread_t submit_thread;
    char tmp42[4096];

    if (*(int *)(work->data + 0x4c) == 0) {
        if (((!use_syslog) && (!opt_log_output)) && (opt_log_level < 4)) {
            return;
        }
        builtin_strncpy(tmp42, "Get A Error Data To Push!DROP!\r\n", 0x20);
        tmp42._32_4_ = tmp42._32_4_ & 0xffffff00;
        _applog(4, tmp42, false);
        return;
    }
    ppVar9 = work->pool;
    cgtime(&work->tv_work_found);
    if (opt_benchmark != false) {
        ptVar3 = get_thread(work->thr_id);
        pcVar10 = ptVar3->cgpu;
        iVar4 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
        if (iVar4 != 0) {
            piVar5 = __errno_location();
            iVar4 = *piVar5;
            uVar8 = 0x202c;
        LAB_00024604:
            pcVar6 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            goto LAB_00024614;
        }
        pcVar10->accepted = pcVar10->accepted + 1;
        bVar11 = 0xfffffffe < (uint)total_accepted;
        total_accepted._0_4_ = (uint)total_accepted + 1;
        total_accepted._4_4_ = total_accepted._4_4_ + (uint)bVar11;
        uVar7 = (uint)ppVar9->accepted;
        iVar4 = *(int *)((int)&ppVar9->accepted + 4);
        *(uint *)&ppVar9->accepted = uVar7 + 1;
        *(uint *)((int)&ppVar9->accepted + 4) =
            iVar4 + (uint)(0xfffffffe < uVar7);
        pcVar10->diff_accepted = pcVar10->diff_accepted + work->work_difficulty;
        dVar12 = work->work_difficulty;
        total_diff_accepted = total_diff_accepted + dVar12;
        ppVar9->diff_accepted = ppVar9->diff_accepted + dVar12;
        iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        if (iVar4 == 0) {
            (*selective_yield)();
            if (opt_debug == false) {
                return;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 7)) {
                return;
            }
            snprintf(tmp42, 0x1000, "Accepted %s %d benchmark share nonce %08x",
                     pcVar10->drv->name, pcVar10->device_id,
                     *(undefined4 *)(work->data + 0x4c));
            _applog(7, tmp42, false);
            return;
        }
        piVar5 = __errno_location();
        iVar4 = *piVar5;
        uVar8 = 0x2033;
    LAB_00024642:
        pcVar6 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
    LAB_00024614:
        snprintf(tmp42, 0x1000, pcVar6, iVar4, "cgminer.c", "submit_work_async",
                 uVar8);
        _applog(3, tmp42, true);
        /* WARNING: Subroutine does not return */
        __quit(1, true);
    }
    _Var2 = stale_work(work, true);
    cVar1 = opt_debug;
    if (_Var2) {
        if (opt_submit_stale == false) {
            if (ppVar9->submit_old == false) {
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    snprintf(tmp42, 0x1000,
                             "Pool %d stale share detected, discarding",
                             ppVar9->pool_no);
                    _applog(7, tmp42, false);
                }
                sharelog("discard", work);
                iVar4 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
                if (iVar4 != 0) {
                    piVar5 = __errno_location();
                    iVar4 = *piVar5;
                    uVar8 = 0x2045;
                    goto LAB_00024604;
                }
                ppVar9->stale_shares = ppVar9->stale_shares + 1;
                bVar11 = 0xfffffffe < (uint)total_stale;
                total_stale._0_4_ = (uint)total_stale + 1;
                total_diff_stale = total_diff_stale + work->work_difficulty;
                total_stale._4_4_ = total_stale._4_4_ + (uint)bVar11;
                ppVar9->diff_stale = ppVar9->diff_stale + work->work_difficulty;
                iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
                if (iVar4 == 0) {
                    (*selective_yield)();
                    goto LAB_00012000;
                }
                piVar5 = __errno_location();
                iVar4 = *piVar5;
                uVar8 = 0x204a;
                goto LAB_00024642;
            }
            if (opt_debug == false)
                goto LAB_00024512;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                pcVar6 = "Pool %d stale share detected, submitting as pool "
                         "requested";
                goto LAB_000244f4;
            }
        LAB_00024372:
            work->stale = true;
            if (work->stratum != false)
                goto LAB_00024380;
            goto LAB_00024438;
        }
        if (opt_debug != false) {
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 7))
                goto LAB_00024372;
            pcVar6 =
                "Pool %d stale share detected, submitting as user requested";
        LAB_000244f4:
            snprintf(tmp42, 0x1000, pcVar6, ppVar9->pool_no);
            _applog(7, tmp42, false);
            cVar1 = opt_debug;
            work->stale = true;
            goto LAB_000242fe;
        }
    LAB_00024512:
        work->stale = true;
        if (work->stratum == false)
            goto LAB_0002447e;
    } else {
    LAB_000242fe:
        if (work->stratum == false) {
            if (cVar1 == '\0')
                goto LAB_0002447e;
        LAB_00024438:
            uVar8 = tmp42._32_4_;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                builtin_strncpy(tmp42, "Pushing submit work to work thread",
                                0x23);
                tmp42[0x23] = SUB41(uVar8, 3);
                _applog(7, tmp42, false);
            }
        LAB_0002447e:
            iVar4 = pthread_create(&submit_thread, (pthread_attr_t *)0x0,
                                   (__start_routine *)0x16b71, work);
            if (iVar4 == 0) {
                return;
            }
            builtin_strncpy(tmp42, "Failed to create submit_work_thread", 0x24);
            _applog(3, tmp42, true);
            /* WARNING: Subroutine does not return */
            __quit(1, true);
        }
        if (cVar1 != '\0') {
        LAB_00024380:
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Pushing pool %d work to stratum queue",
                         ppVar9->pool_no);
                _applog(7, tmp42, false);
            }
        }
    }
    _Var2 = tq_push(ppVar9->stratum_q, work);
    uVar8 = tmp42._32_4_;
    if (_Var2) {
        return;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Discarding work from removed pool", 0x22);
        tmp42._34_2_ = SUB42(uVar8, 2);
        _applog(7, tmp42, false);
    }
LAB_00012000:
    clean_work(work);
    (*(code *)(undefined *)0x0)(work);
    return;
}

/* WARNING: Unknown calling convention */

_Bool submit_tested_work(thr_info *thr, work *work)

{
    undefined1 uVar1;
    _Bool _Var2;
    work *work_00;
    work *work_01;

    update_work_stats(thr, work);
    uVar1 = fulltest(work->hash, work->target);
    if ((bool)uVar1) {
        work_00 = make_work();
        _copy_work(work_00, work, 0);
        submit_work_async(work_00);
    } else {
        uVar1 = opt_debug;
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (uVar1 = 0, 6 < opt_log_level)))) {
            _Var2 = submit_tested_work(thr, work_01);
            return _Var2;
        }
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

_Bool submit_nonce(thr_info *thr, work *work, uint32_t nonce)

{
    _Bool _Var1;
    _Bool _Var2;
    uint32_t diff1targ;
    uint uVar3;

    _Var2 = new_nonce((thr_info *)thr->cgpu, nonce);
    if (_Var2) {
        *(uint32_t *)(work->data + 0x4c) = nonce;
        rebuild_hash(work);
        uVar3 = 0xffff;
        if (opt_scrypt == false) {
            uVar3 = 0;
        }
        if (*(uint *)(work->hash + 0x1c) <= uVar3) {
            submit_tested_work(thr, work);
            _Var1 = opt_benchfile_display;
            if (opt_benchfile == (char *)0x0) {
                return _Var2;
            }
            if (opt_benchfile_display == false) {
                return _Var2;
            }
            benchfile_dspwork(work, nonce);
            return _Var1;
        }
    }
    inc_hw_errors(thr);
    return false;
}

/* WARNING: Unknown calling convention */

void submit_nonce_2(work *work)

{
    work *work_00;

    work_00 = make_work();
    _copy_work(work_00, work, 0);
    submit_work_async(work_00);
    return;
}

/* WARNING: Unknown calling convention */

_Bool submit_nonce_direct(thr_info *thr, work *work, uint32_t nonce)

{
    work *work_00;

    *(uint32_t *)(work->data + 0x4c) = nonce;
    work_00 = make_work();
    _copy_work(work_00, work, 0);
    submit_work_async(work_00);
    return true;
}

/* WARNING: Unknown calling convention */

_Bool submit_noffset_nonce(thr_info *thr, work *work_in, uint32_t nonce,
                           int noffset)

{
    _Bool _Var1;
    undefined1 uVar2;
    work *work;
    uint uVar3;
    char tmp42[4096];

    work = make_work();
    _copy_work(work, work_in, noffset);
    *(uint32_t *)(work->data + 0x4c) = nonce;
    rebuild_hash(work);
    uVar3 = 0xffff;
    if (opt_scrypt == false) {
        uVar3 = 0;
    }
    if (uVar3 < *(uint *)(work->hash + 0x1c)) {
        clean_work(work);
        free(work);
        inc_hw_errors(thr);
        return false;
    }
    update_work_stats(thr, work);
    if ((opt_benchfile != (char *)0x0) && (opt_benchfile_display != false)) {
        benchfile_dspwork(work, nonce);
    }
    uVar2 = fulltest(work->hash, work->target);
    if ((bool)uVar2) {
        submit_work_async(work);
    } else {
        clean_work(work);
        free(work);
        _Var1 = opt_debug;
        if (opt_debug == false) {
            return true;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (uVar2 = opt_debug, 6 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "%s %d: Share above target",
                     thr->cgpu->drv->name, thr->cgpu->device_id);
            _applog(7, tmp42, false);
            return _Var1;
        }
    }
    return (_Bool)uVar2;
}

/* WARNING: Type propagation algorithm not settling */
/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void *stratum_rthread(void *userdata)

{
    char cVar1;
    stratum_share *psVar2;
    stratum_share *psVar3;
    _Bool _Var4;
    pthread_t __th;
    int iVar5;
    char *pcVar6;
    json_t *json;
    json_t *json_00;
    json_t *json_01;
    UT_hash_table *pUVar7;
    time_t tVar8;
    thr_info *ptVar9;
    char *pcVar10;
    size_t __n;
    pool *ppVar11;
    work *pwVar12;
    int *piVar13;
    void *pvVar14;
    json_type jVar15;
    undefined4 uVar16;
    byte *pbVar17;
    UT_hash_bucket *pUVar18;
    double *pdVar19;
    char *func;
    char *func_00;
    uint uVar20;
    uint uVar21;
    uint uVar22;
    UT_hash_handle *pUVar23;
    cgpu_info *pcVar24;
    size_t sVar25;
    int line;
    int line_00;
    uint uVar26;
    UT_hash_handle *pUVar27;
    stratum_share *psVar28;
    stratum_share *psVar29;
    pool *ppVar30;
    char *unaff_r9;
    int iVar31;
    bool bVar32;
    double dVar33;
    json_int_t jVar34;
    json_t *local_127c;
    char *local_1274;
    int id;
    timeval timeout;
    char threadname[16];
    char where[20];
    char reason[32];
    char disposition[36];
    char hashshow[64];
    fd_set rd;
    json_error_t err;
    char tmp42[4096];

    __th = pthread_self();
    pthread_detach(__th);
    /* WARNING: Load size is inaccurate */
    snprintf(threadname, 0x10, "%d/RStratum", *userdata);
    RenameThread(threadname);
    do {
        cVar1 = *(char *)((int)userdata + 0x89);
    joined_r0x00024954:
        if (cVar1 != '\0') {
            suspend_stratum((pool *)userdata);
            return (void *)0x0;
        }
        _Var4 = sock_full((pool *)userdata);
        if ((!_Var4) && (_Var4 = cnx_needed((pool *)userdata), !_Var4)) {
            suspend_stratum((pool *)userdata);
            clear_stratum_shares((pool *)userdata);
            clear_pool_work((pool *)userdata);
            bVar32 = cnx_needed((pool *)userdata);
            while ((!bVar32 &&
                    ((*(int *)((int)userdata + 0x84) == 0 ||
                      ((ppVar30 = current_pool(),
                        (pool *)userdata != ppVar30 &&
                            (1 < pool_strategy - POOL_LOADBALANCE))))))) {
                iVar5 = pthread_mutex_lock((pthread_mutex_t *)&lp_lock);
                if (iVar5 != 0) {
                    piVar13 = __errno_location();
                    pcVar6 = "wait_lpcurrent";
                    iVar5 = *piVar13;
                    uVar16 = 0x2420;
                    goto LAB_00025402;
                }
                pthread_cond_wait((pthread_cond_t *)&lp_cond,
                                  (pthread_mutex_t *)&lp_lock);
                iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&lp_lock);
                if (iVar5 != 0) {
                    piVar13 = __errno_location();
                    pcVar6 = "wait_lpcurrent";
                    iVar5 = *piVar13;
                    uVar16 = 0x2422;
                    goto LAB_00025466;
                }
                (*selective_yield)();
                bVar32 = cnx_needed((pool *)userdata);
            }
            while (_Var4 = restart_stratum((pool *)userdata), !_Var4) {
                if (*(char *)((int)userdata + 0x89) != '\0') {
                    return (void *)0x0;
                }
                if (enabled_pools < 2) {
                    iVar5 = 3000;
                } else {
                    iVar5 = 30000;
                }
                cgsleep_ms(iVar5);
            }
        }
        pcVar6 = hashshow + 0x3c;
        do {
            pcVar6 = pcVar6 + 4;
            pcVar6[0] = '\0';
            pcVar6[1] = '\0';
            pcVar6[2] = '\0';
            pcVar6[3] = '\0';
        } while (rd.fds_bits + 0x1f != (__fd_mask *)pcVar6);
        uVar20 = *(uint *)((int)userdata + 0x264);
        timeout.tv_usec = 0;
        uVar22 = uVar20 + 0x1f & (int)uVar20 >> 0x20;
        if (rd.fds_bits + 0x1f < pcVar6) {
            uVar22 = uVar20;
        }
        uVar21 = uVar20 & 0x1f;
        if ((int)uVar20 < 1) {
            uVar21 = -(-uVar20 & 0x1f);
        }
        timeout.tv_sec = 0x5a;
        ((fd_set *)&rd)->fds_bits[(int)uVar22 >> 5] =
            1 << (uVar21 & 0xff) | ((fd_set *)&rd)->fds_bits[(int)uVar22 >> 5];
        _Var4 = sock_full((pool *)userdata);
        if ((_Var4) ||
            (iVar5 = select(*(int *)((int)userdata + 0x264) + 1, (fd_set *)&rd,
                            (fd_set *)0x0, (fd_set *)0x0, (timeval *)&timeout),
             0 < iVar5)) {
            pcVar6 = recv_line((pool *)userdata);
            if (pcVar6 != (char *)0x0) {
                stratum_resumed((pool *)userdata);
                _Var4 = parse_method((pool *)userdata, pcVar6);
                if (_Var4)
                    goto LAB_000249e8;
                json = json_loads(pcVar6, 0, &err);
                if (json == (json_t *)0x0) {
                    if (opt_debug != false) {
                        if (((use_syslog != false) ||
                             (opt_log_output != false)) ||
                            (6 < opt_log_level)) {
                            unaff_r9 = tmp42;
                            snprintf(unaff_r9, 0x1000,
                                     "JSON decode failed(%d): %s", err.line,
                                     err.text);
                            _applog(7, unaff_r9, false);
                            goto LAB_00025390;
                        }
                    LAB_000253ac:
                        if ((opt_log_output != false) || (6 < opt_log_level)) {
                        LAB_000253c0:
                            unaff_r9 = tmp42;
                            snprintf(unaff_r9, 0x1000,
                                     "Unknown stratum msg: %s", pcVar6);
                            _applog(7, unaff_r9, false);
                        }
                    }
                    goto LAB_000249f2;
                }
                local_127c = json_object_get(json, "result");
                json_00 = json_object_get(json, "error");
                json_01 = json_object_get(json, "id");
                if ((json_01 == (json_t *)0x0) ||
                    (json_01->type == JSON_NULL)) {
                    if (json_00 == (json_t *)0x0) {
                        pcVar10 = (char *)malloc(0x11);
                        if (pcVar10 != (char *)0x0) {
                            builtin_strncpy(pcVar10, "(unknown reason)", 0x11);
                        }
                    } else {
                        pcVar10 = json_dumps(json_00, 3);
                    }
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        unaff_r9 = tmp42;
                        snprintf(unaff_r9, 0x1000,
                                 "JSON-RPC non method decode failed: %s",
                                 pcVar10);
                        _applog(7, unaff_r9, false);
                    }
                    free(pcVar10);
                    sVar25 = json->refcount;
                joined_r0x00025380:
                    if (sVar25 != 0xffffffff) {
                    LAB_00025382:
                        json->refcount = sVar25 - 1;
                        if (sVar25 - 1 == 0) {
                            json_delete(json);
                        }
                    }
                LAB_00025390:
                    if (opt_debug != false) {
                        if (use_syslog == false)
                            goto LAB_000253ac;
                        goto LAB_000253c0;
                    }
                    goto LAB_000249f2;
                }
                jVar34 = json_integer_value(json_01);
                uVar22 = (uint)jVar34;
                iVar5 = pthread_mutex_lock((pthread_mutex_t *)&sshare_lock);
                psVar2 = stratum_shares;
                if (iVar5 != 0) {
                    piVar13 = __errno_location();
                    pcVar6 = "parse_stratum_response";
                    iVar5 = *piVar13;
                    uVar16 = 0x1b09;
                    goto LAB_00025402;
                }
                if (stratum_shares != (stratum_share *)0x0) {
                    pUVar7 = (stratum_shares->hh).tbl;
                    uVar20 = (uVar22 & 0xff000000) + (uVar22 & 0xff) +
                                 0x112410d + (uVar22 & 0xff0000) +
                                 (uVar22 & 0xff00) ^
                             0x7f76d;
                    uVar21 = 0x9f49bac6 - uVar20 ^ uVar20 << 8;
                    uVar26 = (-0x112410d - uVar20) - uVar21 ^ uVar21 >> 0xd;
                    uVar20 = (uVar20 - uVar21) - uVar26 ^ uVar26 >> 0xc;
                    uVar21 = (uVar21 - uVar26) - uVar20 ^ uVar20 << 0x10;
                    uVar26 = (uVar26 - uVar20) - uVar21 ^ uVar21 >> 5;
                    uVar20 = (uVar20 - uVar21) - uVar26 ^ uVar26 >> 3;
                    uVar21 = (uVar21 - uVar26) - uVar20 ^ uVar20 << 10;
                    pUVar27 = pUVar7
                                  ->buckets[((uVar26 - uVar20) - uVar21 ^
                                             uVar21 >> 0xf) &
                                            pUVar7->num_buckets - 1]
                                  .hh_head;
                    if (pUVar27 != (UT_hash_handle *)0x0) {
                        iVar31 = pUVar7->hho;
                        iVar5 = -iVar31;
                        do {
                            pUVar27 = (UT_hash_handle *)((int)pUVar27 + iVar5);
                            if (pUVar27 == (UT_hash_handle *)0x0)
                                break;
                            if ((((pUVar27->keylen == 4) &&
                                  (pbVar17 = (byte *)pUVar27->key,
                                   (uint)*pbVar17 == (uVar22 & 0xff))) &&
                                 (id._1_1_ = (byte)((ulonglong)jVar34 >> 8),
                                  pbVar17[1] == id._1_1_)) &&
                                ((id._2_1_ = (byte)((ulonglong)jVar34 >> 0x10),
                                  pbVar17[2] == id._2_1_ &&
                                      (id._3_1_ =
                                           (byte)((ulonglong)jVar34 >> 0x18),
                                       pbVar17[3] == id._3_1_)))) {
                                pvVar14 = pUVar27->prev;
                                if (pvVar14 == (void *)0x0) {
                                    psVar29 = (stratum_share *)pUVar27->next;
                                    if (psVar29 != (stratum_share *)0x0) {
                                        psVar28 = psVar29;
                                        psVar3 = psVar29;
                                        if (pUVar27 ==
                                            (UT_hash_handle
                                                 *)(iVar5 + (int)pUVar7->tail))
                                            goto LAB_000256b6;
                                        goto LAB_00024d2c;
                                    }
                                    free(pUVar7->buckets);
                                    free((psVar2->hh).tbl);
                                    stratum_shares = (stratum_share *)0x0;
                                } else {
                                    if (pUVar27 ==
                                        (UT_hash_handle *)(iVar5 +
                                                           (int)pUVar7->tail)) {
                                    LAB_000256b6:
                                        pUVar7->tail =
                                            (UT_hash_handle *)((int)pvVar14 +
                                                               iVar31);
                                        pvVar14 = pUVar27->prev;
                                        if (pvVar14 == (void *)0x0) {
                                            psVar29 =
                                                (stratum_share *)pUVar27->next;
                                            psVar28 = psVar29;
                                            psVar3 = psVar29;
                                            goto LAB_00024d2c;
                                        }
                                        iVar31 = ((psVar2->hh).tbl)->hho;
                                    }
                                    *(void **)((int)pvVar14 + iVar31 + 8) =
                                        pUVar27->next;
                                    psVar29 = psVar2;
                                    psVar28 = (stratum_share *)pUVar27->next;
                                    psVar3 = stratum_shares;
                                LAB_00024d2c:
                                    stratum_shares = psVar3;
                                    pUVar7 = (psVar29->hh).tbl;
                                    if (psVar28 != (stratum_share *)0x0) {
                                        *(void **)((int)&(psVar28->hh).prev +
                                                   pUVar7->hho) = pUVar27->prev;
                                        pUVar7 = (psVar29->hh).tbl;
                                    }
                                    uVar22 = pUVar7->num_buckets - 1 &
                                             pUVar27->hashv;
                                    pUVar7->buckets[uVar22].count =
                                        pUVar7->buckets[uVar22].count - 1;
                                    pUVar18 = ((psVar29->hh).tbl)->buckets;
                                    if (pUVar18[uVar22].hh_head == pUVar27) {
                                        pUVar18[uVar22].hh_head =
                                            pUVar27->hh_next;
                                    }
                                    pUVar23 = pUVar27->hh_next;
                                    if (pUVar27->hh_prev !=
                                        (UT_hash_handle *)0x0) {
                                        pUVar27->hh_prev->hh_next = pUVar23;
                                        pUVar23 = pUVar27->hh_next;
                                    }
                                    if (pUVar23 != (UT_hash_handle *)0x0) {
                                        pUVar23->hh_prev = pUVar27->hh_prev;
                                    }
                                    pUVar7 = (psVar29->hh).tbl;
                                    pUVar7->num_items = pUVar7->num_items - 1;
                                }
                                *(int *)((int)userdata + 0x2f4) =
                                    *(int *)((int)userdata + 0x2f4) + -1;
                                iVar5 = pthread_mutex_unlock(
                                    (pthread_mutex_t *)&sshare_lock);
                                if (iVar5 != 0)
                                    goto LAB_00025a10;
                                (*selective_yield)();
                                pwVar12 = (work *)pUVar27[1].prev;
                                tVar8 = time((time_t *)0x0);
                                if ((opt_debug != false) &&
                                    (((use_syslog != false ||
                                       (opt_log_output != false)) ||
                                      (6 < opt_log_level)))) {
                                    snprintf(tmp42, 0x1000,
                                             "Pool %d stratum share result lag "
                                             "time %d seconds",
                                             pwVar12->pool->pool_no,
                                             tVar8 - (int)pUVar27[1].hh_next);
                                    _applog(7, tmp42, false);
                                }
                                unaff_r9 = tmp42;
                                uVar22 = *(uint *)(pwVar12->hash + 0x1c);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[0] = (char)uVar22;
                                tmp42[1] = (char)(uVar22 >> 8);
                                tmp42[2] = (char)(uVar22 >> 0x10);
                                tmp42[3] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)(pwVar12->hash + 0x18);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[4] = (char)uVar22;
                                tmp42[5] = (char)(uVar22 >> 8);
                                tmp42[6] = (char)(uVar22 >> 0x10);
                                tmp42[7] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)(pwVar12->hash + 0x14);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[8] = (char)uVar22;
                                tmp42[9] = (char)(uVar22 >> 8);
                                tmp42[10] = (char)(uVar22 >> 0x10);
                                tmp42[0xb] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)(pwVar12->hash + 0x10);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[0xc] = (char)uVar22;
                                tmp42[0xd] = (char)(uVar22 >> 8);
                                tmp42[0xe] = (char)(uVar22 >> 0x10);
                                tmp42[0xf] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)(pwVar12->hash + 0xc);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[0x10] = (char)uVar22;
                                tmp42[0x11] = (char)(uVar22 >> 8);
                                tmp42[0x12] = (char)(uVar22 >> 0x10);
                                tmp42[0x13] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)(pwVar12->hash + 8);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[0x14] = (char)uVar22;
                                tmp42[0x15] = (char)(uVar22 >> 8);
                                tmp42[0x16] = (char)(uVar22 >> 0x10);
                                tmp42[0x17] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)(pwVar12->hash + 4);
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[0x18] = (char)uVar22;
                                tmp42[0x19] = (char)(uVar22 >> 8);
                                tmp42[0x1a] = (char)(uVar22 >> 0x10);
                                tmp42[0x1b] = (char)(uVar22 >> 0x18);
                                uVar22 = *(uint *)pwVar12->hash;
                                uVar22 = uVar22 << 0x18 |
                                         (uVar22 >> 8 & 0xff) << 0x10 |
                                         (uVar22 >> 0x10 & 0xff) << 8 |
                                         uVar22 >> 0x18;
                                tmp42[0x1c] = (char)uVar22;
                                tmp42[0x1d] = (char)(uVar22 >> 8);
                                tmp42[0x1e] = (char)(uVar22 >> 0x10);
                                tmp42[0x1f] = (char)(uVar22 >> 0x18);
                                iVar5 = 0;
                                pcVar10 = unaff_r9;
                                goto LAB_00024e22;
                            }
                            pUVar27 = pUVar27->hh_next;
                        } while (pUVar27 != (UT_hash_handle *)0x0);
                    }
                }
                iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&sshare_lock);
                if (iVar5 != 0) {
                LAB_00025a10:
                    piVar13 = __errno_location();
                    pcVar6 = "parse_stratum_response";
                    iVar5 = *piVar13;
                    uVar16 = 0x1b10;
                    goto LAB_00025466;
                }
                (*selective_yield)();
                if (local_127c == (json_t *)0x0) {
                    sVar25 = json->refcount;
                    if (sVar25 == 0xffffffff)
                        goto LAB_00025390;
                    goto LAB_00025382;
                }
                iVar5 = pthread_mutex_lock(
                    (pthread_mutex_t *)((int)userdata + 0xf4));
                if (iVar5 == 0) {
                    iVar5 = pthread_rwlock_rdlock(
                        (pthread_rwlock_t *)((int)userdata + 0x10c));
                    if (iVar5 != 0) {
                        piVar13 = __errno_location();
                        uVar16 = 0x1b1a;
                        pcVar10 =
                            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
                        goto LAB_00025b98;
                    }
                    iVar5 = pthread_mutex_unlock(
                        (pthread_mutex_t *)((int)userdata + 0xf4));
                    if (iVar5 != 0) {
                        piVar13 = __errno_location();
                        uVar16 = 0x1b1a;
                    LAB_00025b8e:
                        pcVar10 =
                            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                        goto LAB_00025b98;
                    }
                    dVar33 = *(double *)((int)userdata + 0x730);
                    iVar5 = pthread_rwlock_unlock(
                        (pthread_rwlock_t *)((int)userdata + 0x10c));
                    if (iVar5 != 0) {
                        piVar13 = __errno_location();
                        uVar16 = 0x1b1c;
                        pcVar10 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s "
                                  "%s():%d";
                        goto LAB_00025b98;
                    }
                    (*selective_yield)();
                    if (local_127c->type != JSON_TRUE) {
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            unaff_r9 = tmp42;
                            /* WARNING: Load size is inaccurate */
                            snprintf(
                                unaff_r9, 0x1000,
                                "Rejected untracked stratum share from pool %d",
                                *userdata);
                            _applog(7, unaff_r9, false);
                        }
                        iVar5 =
                            pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
                        if (iVar5 == 0) {
                            bVar32 = 0xfffffffe < (uint)total_rejected;
                            total_rejected._0_4_ = (uint)total_rejected + 1;
                            uVar22 = *(uint *)((int)userdata + 0x10);
                            total_rejected._4_4_ =
                                total_rejected._4_4_ + (uint)bVar32;
                            total_diff_rejected = total_diff_rejected + dVar33;
                            *(uint *)((int)userdata + 0x10) = uVar22 + 1;
                            *(uint *)((int)userdata + 0x14) =
                                *(int *)((int)userdata + 0x14) +
                                (uint)(0xfffffffe < uVar22);
                            *(double *)((int)userdata + 0x70) =
                                *(double *)((int)userdata + 0x70) + dVar33;
                            iVar5 = pthread_mutex_unlock(
                                (pthread_mutex_t *)&stats_lock);
                            if (iVar5 != 0) {
                                piVar13 = __errno_location();
                                uVar16 = 0x1b34;
                                goto LAB_00025b8e;
                            }
                            goto LAB_000255fe;
                        }
                        piVar13 = __errno_location();
                        uVar16 = 0x1b2f;
                        pcVar10 =
                            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                        goto LAB_00025b98;
                    }
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        unaff_r9 = tmp42;
                        /* WARNING: Load size is inaccurate */
                        snprintf(
                            unaff_r9, 0x1000,
                            "Accepted untracked stratum share from pool %d",
                            *userdata);
                        _applog(7, unaff_r9, false);
                    }
                    iVar5 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
                    if (iVar5 == 0) {
                        bVar32 = 0xfffffffe < (uint)total_accepted;
                        total_accepted._0_4_ = (uint)total_accepted + 1;
                        total_accepted._4_4_ =
                            total_accepted._4_4_ + (uint)bVar32;
                        uVar22 = *(uint *)((int)userdata + 8);
                        total_diff_accepted = total_diff_accepted + dVar33;
                        *(double *)((int)userdata + 0x68) =
                            *(double *)((int)userdata + 0x68) + dVar33;
                        *(uint *)((int)userdata + 8) = uVar22 + 1;
                        *(uint *)((int)userdata + 0xc) =
                            *(int *)((int)userdata + 0xc) +
                            (uint)(0xfffffffe < uVar22);
                        iVar5 = pthread_mutex_unlock(
                            (pthread_mutex_t *)&stats_lock);
                        if (iVar5 != 0) {
                            /* WARNING: Subroutine does not return */
                            _mutex_unlock_noyield(
                                (pthread_mutex_t *)"parse_stratum_response",
                                (char *)0x1b29, func_00, line_00);
                        }
                    LAB_000255fe:
                        (*selective_yield)();
                        sVar25 = json->refcount;
                        goto joined_r0x00025380;
                    }
                    _mutex_lock((pthread_mutex_t *)"parse_stratum_response",
                                (char *)0x1b24, func, line);
                    goto LAB_00025a92;
                }
                piVar13 = __errno_location();
                uVar16 = 0x1b1a;
                pcVar10 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            LAB_00025b98:
                pcVar6 = "parse_stratum_response";
                iVar5 = *piVar13;
                goto LAB_00025416;
            }
        } else {
            if (opt_debug == false)
                goto LAB_00024b0c;
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 7))
                goto LAB_00024ae0;
            unaff_r9 = tmp42;
            /* WARNING: Load size is inaccurate */
            snprintf(unaff_r9, 0x1000,
                     "Stratum select failed on pool %d with value %d",
                     *userdata, iVar5);
            _applog(7, unaff_r9, false);
        }
        if (opt_debug != false) {
            if (use_syslog == false) {
            LAB_00024ae0:
                if ((opt_log_output == false) && (opt_log_level < 7))
                    goto LAB_00024b0c;
            }
            unaff_r9 = tmp42;
            /* WARNING: Load size is inaccurate */
            snprintf(unaff_r9, 0x1000,
                     "Stratum connection to pool %d interrupted", *userdata);
            _applog(7, unaff_r9, false);
        }
    LAB_00024b0c:
        *(int *)((int)userdata + 0xa0) = *(int *)((int)userdata + 0xa0) + 1;
        total_go = total_go + 1;
        iVar5 = pthread_mutex_lock((pthread_mutex_t *)((int)userdata + 0xf4));
        if (iVar5 != 0) {
            piVar13 = __errno_location();
            pcVar6 = "supports_resume";
            iVar5 = *piVar13;
            uVar16 = 0x1bbd;
        LAB_00025402:
            pcVar10 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
        LAB_00025416:
            snprintf(tmp42, 0x1000, pcVar10, iVar5, "cgminer.c", pcVar6,
                     uVar16);
            unaff_r9 = tmp42;
        LAB_0002541c:
            _applog(3, unaff_r9, true);
            /* WARNING: Subroutine does not return */
            __quit(1, true);
        }
        iVar5 =
            pthread_rwlock_rdlock((pthread_rwlock_t *)((int)userdata + 0x10c));
        if (iVar5 != 0) {
            piVar13 = __errno_location();
            iVar5 = *piVar13;
            pcVar10 = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            pcVar6 = "supports_resume";
            uVar16 = 0x1bbd;
            goto LAB_00025416;
        }
        iVar5 = pthread_mutex_unlock((pthread_mutex_t *)((int)userdata + 0xf4));
        if (iVar5 != 0) {
            piVar13 = __errno_location();
            pcVar6 = "supports_resume";
            iVar5 = *piVar13;
            uVar16 = 0x1bbd;
        LAB_00025466:
            pcVar10 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
            goto LAB_00025416;
        }
        iVar31 = *(int *)((int)userdata + 0x294);
        iVar5 =
            pthread_rwlock_unlock((pthread_rwlock_t *)((int)userdata + 0x10c));
        if (iVar5 != 0) {
            piVar13 = __errno_location();
            iVar5 = *piVar13;
            pcVar10 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
            pcVar6 = "supports_resume";
            uVar16 = 0x1bbf;
            goto LAB_00025416;
        }
        (*selective_yield)();
        if ((iVar31 == 0) || (opt_lowmem != false)) {
            clear_stratum_shares((pool *)userdata);
        }
        clear_pool_work((pool *)userdata);
        ppVar30 = current_pool();
        if ((pool *)userdata == ppVar30) {
            restart_threads();
        }
        bVar32 = restart_stratum((pool *)userdata);
        while (!bVar32) {
            if (*(char *)((int)userdata + 0x89) != '\0') {
                return (void *)0x0;
            }
            cgsleep_ms(30000);
            bVar32 = restart_stratum((pool *)userdata);
        }
    } while (true);
    while (iVar5 = iVar5 + 1, pcVar10 = pcVar10 + 1, iVar5 != 0x1d) {
    LAB_00024e22:
        if (*pcVar10 != '\0')
            break;
    }
    uVar22 = *(uint *)(unaff_r9 + iVar5);
    pdVar19 = &pwVar12->work_difficulty;
    dVar33 = round(*pdVar19);
    __fixunsdfdi(dVar33);
    suffix_string(pwVar12->share_diff, disposition, 0x10, 0);
    pcVar10 = disposition;
    snprintf(hashshow, 0x40, "%08lx Diff %s/%llu%s",
             uVar22 << 0x18 | (uVar22 >> 8 & 0xff) << 0x10 |
                 (uVar22 >> 0x10 & 0xff) << 8 | uVar22 >> 0x18,
             pcVar10);
    ppVar30 = pwVar12->pool;
    ptVar9 = get_thread(pwVar12->thr_id);
    pcVar24 = ptVar9->cgpu;
    if ((local_127c == (json_t *)0x0) ||
        ((local_127c->type != JSON_TRUE &&
          ((pwVar12->gbt == false || (local_127c->type != JSON_NULL)))))) {
        iVar5 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
        if (iVar5 != 0) {
            piVar13 = __errno_location();
            uVar16 = 0xdcb;
            pcVar6 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            goto LAB_00025ab0;
        }
        bVar32 = 0xfffffffe < (uint)total_rejected;
        total_rejected._0_4_ = (uint)total_rejected + 1;
        pcVar24->rejected = pcVar24->rejected + 1;
        uVar22 = (uint)ppVar30->rejected;
        total_rejected._4_4_ = total_rejected._4_4_ + (uint)bVar32;
        iVar5 = *(int *)((int)&ppVar30->rejected + 4);
        *(uint *)&ppVar30->rejected = uVar22 + 1;
        *(uint *)((int)&ppVar30->rejected + 4) =
            iVar5 + (uint)(0xfffffffe < uVar22);
        pcVar24->diff_rejected = pcVar24->diff_rejected + *pdVar19;
        dVar33 = *pdVar19;
        total_diff_rejected = total_diff_rejected + dVar33;
        ppVar30->seq_rejects = ppVar30->seq_rejects + 1;
        ppVar30->diff_rejected = ppVar30->diff_rejected + dVar33;
        iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        if (iVar5 == 0) {
            (*selective_yield)();
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                builtin_strncpy(tmp42, "PROOF OF WORK RESULT: false (booooo)",
                                0x24);
                tmp42[0x24] = '\0';
                _applog(7, unaff_r9, false);
            }
            _Var4 = opt_realquiet;
            if ((opt_quiet == false) && (opt_realquiet == false)) {
                builtin_strncpy(disposition, "reje", 4);
                disposition[4] = 'c';
                disposition[5] = 't';
                disposition[6] = '\0';
                memset(disposition + 7, 0, 0x1d);
                reason._0_2_ = reason._0_2_ & 0xff00;
                if (total_pools < 2) {
                    where[0] = _Var4;
                } else {
                    snprintf(where, 0x14, "pool %d", pwVar12->pool->pool_no);
                }
                local_1274 = where;
                if (pwVar12->gbt == false) {
                    local_127c = json_object_get(json, "reject-reason");
                }
                if (local_127c == (json_t *)0x0) {
                    if ((json_00 != (json_t *)0x0) &&
                        (pwVar12->stratum != false)) {
                        jVar15 = json_00->type;
                        if (jVar15 == JSON_ARRAY) {
                            json_00 = json_array_get(json_00, 1);
                            if (json_00 == (json_t *)0x0)
                                goto LAB_00025088;
                            jVar15 = json_00->type;
                        }
                        if (jVar15 == JSON_STRING) {
                            pcVar10 = json_string_value(json_00);
                            snprintf(reason, 0x1f, " (%s)", pcVar10);
                        }
                    }
                } else {
                    pcVar10 = json_string_value(local_127c);
                    __n = strlen(pcVar10);
                    if (0x1b < __n) {
                        __n = 0x1c;
                    }
                    reason[0] = ' ';
                    reason[1] = '(';
                    memcpy(reason + 2, pcVar10, __n);
                    reason[__n + 2] = ')';
                    reason[__n + 3] = '\0';
                    memcpy(disposition + 7, pcVar10, __n);
                    disposition[6] = ':';
                    disposition[__n + 7] = '\0';
                }
            LAB_00025088:
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    snprintf(unaff_r9, 0x1000, "Rejected %s %s %d %s%s %s%s",
                             hashshow, pcVar24->drv->name, pcVar24->device_id,
                             local_1274, reason, "", "");
                    _applog(7, unaff_r9, false);
                }
                sharelog(disposition, pwVar12);
            }
            iVar5 = ppVar30->seq_rejects;
            if (((10 < iVar5) && (pwVar12->stale == false)) &&
                ((opt_disable_pool != false &&
                  ((1 < enabled_pools &&
                    (dVar33 = (double)__aeabi_l2d((uint)total_accepted,
                                                  total_accepted._4_4_),
                     (dVar33 / total_secs) * 60.0 * 3.0 <
                         (double)(longlong)iVar5)))))) {
                if ((use_syslog != false) ||
                    ((opt_log_output != false || (3 < opt_log_level)))) {
                    snprintf(
                        unaff_r9, 0x1000,
                        "Pool %d rejected %d sequential shares, disabling!",
                        ppVar30->pool_no, iVar5);
                    _applog(4, unaff_r9, false);
                }
                if (ppVar30->enabled == POOL_ENABLED) {
                    enabled_pools = enabled_pools + -1;
                }
                ppVar30->enabled = POOL_REJECTING;
                ppVar11 = current_pool();
                if (ppVar30 == ppVar11) {
                    switch_pools((pool *)0x0);
                }
                ppVar30->seq_rejects = 0;
            }
        LAB_000251dc:
            pwVar12 = (work *)pUVar27[1].prev;
            clean_work(pwVar12);
            free(pwVar12);
            free(pUVar27);
            if ((json->refcount != 0xffffffff) &&
                (sVar25 = json->refcount - 1, json->refcount = sVar25,
                 sVar25 == 0)) {
                json_delete(json);
            }
        LAB_000249e8:
            if (*(char *)((int)userdata + 0x2b8) != '\0') {
                pwVar12 = make_work();
                *(undefined1 *)((int)userdata + 0x2b8) = 0;
                gen_stratum_work((pool *)userdata, pwVar12);
                pwVar12->longpoll = true;
                test_work_current(pwVar12);
                clean_work(pwVar12);
                free(pwVar12);
            }
        LAB_000249f2:
            free(pcVar6);
            cVar1 = *(char *)((int)userdata + 0x89);
            goto joined_r0x00024954;
        }
        piVar13 = __errno_location();
        uVar16 = 0xdd3;
    } else {
        iVar5 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
        if (iVar5 != 0) {
            piVar13 = __errno_location();
            uVar16 = 0xd99;
            pcVar6 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            goto LAB_00025ab0;
        }
        bVar32 = 0xfffffffe < (uint)total_accepted;
        total_accepted._0_4_ = (uint)total_accepted + 1;
        total_accepted._4_4_ = total_accepted._4_4_ + (uint)bVar32;
        pcVar24->accepted = pcVar24->accepted + 1;
        uVar22 = (uint)ppVar30->accepted;
        iVar5 = *(int *)((int)&ppVar30->accepted + 4);
        *(uint *)&ppVar30->accepted = uVar22 + 1;
        *(uint *)((int)&ppVar30->accepted + 4) =
            iVar5 + (uint)(0xfffffffe < uVar22);
        pcVar24->diff_accepted = pcVar24->diff_accepted + *pdVar19;
        total_diff_accepted = total_diff_accepted + *pdVar19;
        ppVar30->diff_accepted = ppVar30->diff_accepted + *pdVar19;
        iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
        if (iVar5 == 0) {
            (*selective_yield)();
            ppVar30->seq_rejects = 0;
            pcVar24->last_share_pool = ppVar30->pool_no;
            tVar8 = time((time_t *)0x0);
            pcVar24->last_share_pool_time = tVar8;
            _Var4 = opt_debug;
            pcVar24->last_share_diff = *pdVar19;
            ppVar30->last_share_time = tVar8;
            uVar16 = *(undefined4 *)((int)&pwVar12->work_difficulty + 4);
            *(undefined4 *)&ppVar30->last_share_diff = *(undefined4 *)pdVar19;
            *(undefined4 *)((int)&ppVar30->last_share_diff + 4) = uVar16;
            if ((_Var4 != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                builtin_strncpy(tmp42, "PROOF OF WORK RESULT: true (yay!!!)",
                                0x24);
                _applog(7, unaff_r9, false);
            }
            if ((opt_quiet == false) && (opt_realquiet == false)) {
                if (total_pools < 2) {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        pcVar10 = pcVar24->drv->name;
                        snprintf(unaff_r9, 0x1000, "Accepted %s %s %d %s%s",
                                 hashshow, pcVar10, pcVar24->device_id, "", "");
                        _applog(7, unaff_r9, false);
                    }
                } else if ((opt_debug != false) &&
                           (((use_syslog != false ||
                              (opt_log_output != false)) ||
                             (6 < opt_log_level)))) {
                    pcVar10 = pcVar24->drv->name;
                    snprintf(unaff_r9, 0x1000, "Accepted %s %s %d pool %d %s%s",
                             hashshow, pcVar10, pcVar24->device_id,
                             pwVar12->pool->pool_no, "", "");
                    _applog(7, unaff_r9, false);
                }
            }
            sharelog("accept", pwVar12);
            if ((opt_shares != 0) &&
                ((double)(longlong)opt_shares <= total_diff_accepted)) {
                if ((use_syslog != false) ||
                    ((opt_log_output != false || (3 < opt_log_level)))) {
                    snprintf(unaff_r9, 0x1000,
                             "Successfully mined %d accepted shares as "
                             "requested and exiting.",
                             opt_shares, pcVar10);
                    _applog(4, unaff_r9, false);
                }
                kill_work();
            }
            if (ppVar30->enabled == POOL_REJECTING) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (3 < opt_log_level)) {
                    snprintf(
                        unaff_r9, 0x1000,
                        "Rejecting pool %d now accepting shares, re-enabling!",
                        ppVar30->pool_no);
                    _applog(4, unaff_r9, false);
                }
                if (ppVar30->enabled != POOL_ENABLED) {
                    enable_pool((pool *)&ppVar30->enabled);
                }
                switch_pools((pool *)0x0);
            }
            if (pwVar12->block != false) {
                restart_threads();
            }
            goto LAB_000251dc;
        }
    LAB_00025a92:
        piVar13 = __errno_location();
        uVar16 = 0xda0;
    }
    pcVar6 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
LAB_00025ab0:
    snprintf(unaff_r9, 0x1000, pcVar6, *piVar13, "cgminer.c", "share_result",
             uVar16);
    goto LAB_0002541c;
}

/* WARNING: Unknown calling convention */

void _quit(int status)

{
    /* WARNING: Subroutine does not return */
    __quit(status, true);
}

/* WARNING: Unknown calling convention */

_Bool add_pool_details(pool *pool, _Bool live, char *url, char *user,
                       char *pass)

{
    char *pcVar1;
    size_t sVar2;
    size_t sVar3;
    char tmp42[4096];

    pcVar1 = get_proxy(url, pool);
    pool->rpc_user = user;
    pool->rpc_url = pcVar1;
    pool->rpc_pass = pass;
    sVar2 = strlen(user);
    sVar3 = strlen(pass);
    sVar2 = sVar2 + sVar3 + 2;
    pcVar1 = (char *)malloc(sVar2);
    pool->rpc_userpass = pcVar1;
    if (pcVar1 != (char *)0x0) {
        snprintf(pcVar1, sVar2, "%s:%s", user, pass);
        pool->testing = true;
        pool->idle = true;
        pool->blocking = !live;
        if (pool->enabled != POOL_ENABLED) {
            enable_pool((pool *)&pool->enabled);
        }
        pthread_create(&pool->test_thread, (pthread_attr_t *)0x0,
                       (__start_routine *)0x1ecdd, pool);
        if (!live) {
            pthread_join(pool->test_thread, (void **)0x0);
            live = pools_active;
        }
        return live;
    }
    builtin_strncpy(tmp42, "Failed to malloc userpas", 0x18);
    tmp42[0x18] = 's';
    tmp42[0x19] = '\0';
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void fill_device_drv(device_drv *drv)

{
    _func_void_cgpu_info_ptr *p_Var1;
    _func_void_char_ptr_size_t_cgpu_info_ptr *p_Var2;
    _func__Bool_cgpu_info_ptr *p_Var3;
    _func__Bool_thr_info_ptr *p_Var4;
    _func_uint64_t_thr_info_ptr *p_Var5;
    _func__Bool_thr_info_ptr_work_ptr *p_Var6;
    _func_void_thr_info_ptr *p_Var7;

    if (drv->drv_detect == (_func_void__Bool *)0x0) {
        drv->drv_detect = (_func_void__Bool *)0x150a1;
        p_Var1 = drv->reinit_device;
    } else {
        p_Var1 = drv->reinit_device;
    }
    if (p_Var1 == (_func_void_cgpu_info_ptr *)0x0) {
        drv->reinit_device = (_func_void_cgpu_info_ptr *)0x15089;
        p_Var2 = drv->get_statline_before;
    } else {
        p_Var2 = drv->get_statline_before;
    }
    if (p_Var2 == (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x0) {
        drv->get_statline_before =
            (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x1508d;
        p_Var2 = drv->get_statline;
    } else {
        p_Var2 = drv->get_statline;
    }
    if (p_Var2 == (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x0) {
        drv->get_statline = (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x175e5;
        p_Var3 = drv->get_stats;
    } else {
        p_Var3 = drv->get_stats;
    }
    if (p_Var3 == (_func__Bool_cgpu_info_ptr *)0x0) {
        drv->get_stats = (_func__Bool_cgpu_info_ptr *)0x15091;
        p_Var4 = drv->thread_prepare;
    } else {
        p_Var4 = drv->thread_prepare;
    }
    if (p_Var4 == (_func__Bool_thr_info_ptr *)0x0) {
        drv->thread_prepare = (_func__Bool_thr_info_ptr *)0x175ed;
        p_Var5 = drv->can_limit_work;
    } else {
        p_Var5 = drv->can_limit_work;
    }
    if (p_Var5 == (_func_uint64_t_thr_info_ptr *)0x0) {
        drv->can_limit_work = (_func_uint64_t_thr_info_ptr *)0x15095;
        p_Var4 = drv->thread_init;
    } else {
        p_Var4 = drv->thread_init;
    }
    if (p_Var4 == (_func__Bool_thr_info_ptr *)0x0) {
        drv->thread_init = (_func__Bool_thr_info_ptr *)0x175f1;
        p_Var6 = drv->prepare_work;
    } else {
        p_Var6 = drv->prepare_work;
    }
    if (p_Var6 == (_func__Bool_thr_info_ptr_work_ptr *)0x0) {
        drv->prepare_work = (_func__Bool_thr_info_ptr_work_ptr *)0x1509d;
        p_Var7 = drv->hw_error;
    } else {
        p_Var7 = drv->hw_error;
    }
    if (p_Var7 == (_func_void_thr_info_ptr *)0x0) {
        drv->hw_error = (_func_void_thr_info_ptr *)0x175f5;
        p_Var7 = drv->thread_shutdown;
    } else {
        p_Var7 = drv->thread_shutdown;
    }
    if (p_Var7 == (_func_void_thr_info_ptr *)0x0) {
        drv->thread_shutdown = (_func_void_thr_info_ptr *)0x175f9;
        p_Var7 = drv->thread_enable;
    } else {
        p_Var7 = drv->thread_enable;
    }
    if (p_Var7 == (_func_void_thr_info_ptr *)0x0) {
        drv->thread_enable = (_func_void_thr_info_ptr *)0x175fd;
        p_Var7 = drv->hash_work;
    } else {
        p_Var7 = drv->hash_work;
    }
    if (p_Var7 == (_func_void_thr_info_ptr *)0x0) {
        drv->hash_work = (_func_void_thr_info_ptr *)0x21e8d;
        p_Var1 = drv->flush_work;
    } else {
        p_Var1 = drv->flush_work;
    }
    if (p_Var1 == (_func_void_cgpu_info_ptr *)0x0) {
        drv->flush_work = (_func_void_cgpu_info_ptr *)0x15089;
        p_Var1 = drv->update_work;
    } else {
        p_Var1 = drv->update_work;
    }
    if (p_Var1 == (_func_void_cgpu_info_ptr *)0x0) {
        drv->update_work = (_func_void_cgpu_info_ptr *)0x15089;
        p_Var3 = drv->queue_full;
    } else {
        p_Var3 = drv->queue_full;
    }
    if (p_Var3 == (_func__Bool_cgpu_info_ptr *)0x0) {
        drv->queue_full = (_func__Bool_cgpu_info_ptr *)0x15091;
        p_Var1 = drv->zero_stats;
    } else {
        p_Var1 = drv->zero_stats;
    }
    if (p_Var1 == (_func_void_cgpu_info_ptr *)0x0) {
        drv->zero_stats = (_func_void_cgpu_info_ptr *)0x15089;
    }
    if (drv->max_diff == 0.0) {
        *(undefined4 *)&drv->max_diff = 0;
        *(undefined4 *)((int)&drv->max_diff + 4) = 0x3ff00000;
    }
    return;
}

/* WARNING: Unknown calling convention */

void null_device_drv(device_drv *drv)

{
    drv->get_api_stats = (_func_api_data_ptr_cgpu_info_ptr *)0x150a5;
    drv->drv_detect = (_func_void__Bool *)0x150a1;
    drv->get_statline_before =
        (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x1508d;
    drv->get_statline = (_func_void_char_ptr_size_t_cgpu_info_ptr *)0x175e5;
    drv->set_device =
        (_func_char_ptr_cgpu_info_ptr_char_ptr_char_ptr_char_ptr *)0x0;
    drv->thread_prepare = (_func__Bool_thr_info_ptr *)0x175ed;
    drv->can_limit_work = (_func_uint64_t_thr_info_ptr *)0x15095;
    drv->thread_init = (_func__Bool_thr_info_ptr *)0x175f1;
    drv->prepare_work = (_func__Bool_thr_info_ptr_work_ptr *)0x1509d;
    drv->hash_work = (_func_void_thr_info_ptr *)0x175e9;
    drv->hw_error = (_func_void_thr_info_ptr *)0x175f5;
    drv->thread_shutdown = (_func_void_thr_info_ptr *)0x175f9;
    drv->thread_enable = (_func_void_thr_info_ptr *)0x175fd;
    *(undefined4 *)&drv->max_diff = 0;
    *(undefined4 *)((int)&drv->max_diff + 4) = 0x3ff00000;
    *(undefined4 *)&drv->min_diff = 0;
    *(undefined4 *)((int)&drv->min_diff + 4) = 0x3ff00000;
    drv->reinit_device = (_func_void_cgpu_info_ptr *)0x15089;
    drv->identify_device = (_func_void_cgpu_info_ptr *)0x15089;
    drv->zero_stats = (_func_void_cgpu_info_ptr *)0x15089;
    drv->flush_work = (_func_void_cgpu_info_ptr *)0x15089;
    drv->update_work = (_func_void_cgpu_info_ptr *)0x15089;
    drv->get_stats = (_func__Bool_cgpu_info_ptr *)0x15091;
    drv->queue_full = (_func__Bool_cgpu_info_ptr *)0x15091;
    return;
}

/* WARNING: Unknown calling convention */

void enable_device(cgpu_info *cgpu)

{
    cgpu_info **ppcVar1;
    int iVar2;
    int iVar3;
    char *func;
    char *extraout_r2;
    char *func_00;
    char *extraout_r2_00;
    char *func_01;
    int line;
    int extraout_r3;
    int line_00;
    int extraout_r3_00;

    cgpu->deven = DEV_ENABLED;
    iVar2 = pthread_rwlock_wrlock((pthread_rwlock_t *)&devices_lock);
    ppcVar1 = devices;
    if (iVar2 == 0) {
        cgpu->cgminer_id = cgminer_id_count;
        ppcVar1[cgminer_id_count] = cgpu;
        cgminer_id_count = cgminer_id_count + 1;
        iVar3 = pthread_rwlock_unlock((pthread_rwlock_t *)&devices_lock);
        func_01 = extraout_r2;
        iVar2 = extraout_r3;
        if (iVar3 == 0) {
            (*selective_yield)();
            if (hotplug_mode == false) {
                mining_threads = cgpu->threads + mining_threads;
            } else {
                new_threads = cgpu->threads + new_threads;
            }
            iVar2 = pthread_rwlock_init((pthread_rwlock_t *)&cgpu->qlock,
                                        (pthread_rwlockattr_t *)0x0);
            if (iVar2 == 0) {
                cgpu->queued_work = (work *)0x0;
                return;
            }
            /* WARNING: Subroutine does not return */
            _rwlock_init((pthread_rwlock_t *)"enable_device", (char *)0x289d,
                         func_00, line_00);
        }
    } else {
        _wr_lock((pthread_rwlock_t *)"enable_device", (char *)0x2894, func,
                 line);
        func_01 = extraout_r2_00;
        iVar2 = extraout_r3_00;
    }
    /* WARNING: Subroutine does not return */
    _rw_unlock((pthread_rwlock_t *)"enable_device", (char *)0x2896, func_01,
               iVar2);
}

/* WARNING: Unknown calling convention */

_Bool add_cgpu(cgpu_info *cgpu)

{
    cgpu_info **ppcVar1;
    _cgpu_devid_counter *p_Var2;
    UT_hash_handle *__n;
    int iVar3;
    time_t tVar4;
    _cgpu_devid_counter *__s;
    size_t sVar5;
    UT_hash_bucket *pUVar6;
    _cgpu_devid_counter *__s_00;
    size_t extraout_r0;
    int iVar7;
    UT_hash_table *pUVar8;
    char *extraout_r2;
    char *func;
    char *func_00;
    char *extraout_r2_00;
    char *extraout_r2_01;
    char *extraout_r2_02;
    char *pcVar9;
    UT_hash_handle *pUVar10;
    uint uVar11;
    uint uVar12;
    uint uVar13;
    int extraout_r3;
    int line;
    int line_00;
    int extraout_r3_00;
    int extraout_r3_01;
    int extraout_r3_02;
    UT_hash_handle *pUVar14;
    uint uVar15;
    UT_hash_handle *pUVar16;
    _cgpu_devid_counter *p_Var17;
    size_t unaff_r10;
    UT_hash_handle *local_2c;

    __s_00 = add_cgpu::devids;
    pUVar10 = (UT_hash_handle *)cgpu->drv->name;
    if (add_cgpu::devids != (_cgpu_devid_counter *)0x0) {
        __n = (UT_hash_handle *)strlen((char *)pUVar10);
        uVar11 = 0x9e3779b9;
        uVar15 = 0xfeedbeef;
        pUVar14 = pUVar10;
        uVar12 = uVar11;
        for (pUVar16 = __n; (UT_hash_handle *)0xb < pUVar16;
             pUVar16 = (UT_hash_handle *)&pUVar16[-1].key) {
            unaff_r10 = (size_t) * (byte *)&pUVar14->next;
            iVar7 = uVar12 +
                    (uint) * (byte *)((int)&pUVar14->prev + 2) * 0x10000 +
                    (uint) * (byte *)((int)&pUVar14->prev + 1) * 0x100 +
                    (uint) * (byte *)&pUVar14->prev +
                    (uint) * (byte *)((int)&pUVar14->prev + 3) * 0x1000000;
            uVar15 =
                (uint) * (byte *)((int)&pUVar14->next + 2) * 0x10000 +
                (uint) * (byte *)((int)&pUVar14->next + 1) * 0x100 + unaff_r10 +
                (uint) * (byte *)((int)&pUVar14->next + 3) * 0x1000000 + uVar15;
            uVar12 = ((((uint) * (byte *)((int)&pUVar14->tbl + 2) * 0x10000 +
                        (uint) * (byte *)((int)&pUVar14->tbl + 1) * 0x100 +
                        (uint) * (byte *)&pUVar14->tbl +
                        (uint) * (byte *)((int)&pUVar14->tbl + 3) * 0x1000000) -
                       iVar7) -
                      uVar15) +
                         uVar11 ^
                     uVar15 >> 0xd;
            uVar11 = (iVar7 - uVar15) - uVar12 ^ uVar12 << 8;
            uVar15 = (uVar15 - uVar12) - uVar11 ^ uVar11 >> 0xd;
            uVar13 = (uVar12 - uVar11) - uVar15 ^ uVar15 >> 0xc;
            uVar12 = (uVar11 - uVar15) - uVar13 ^ uVar13 << 0x10;
            uVar15 = (uVar15 - uVar13) - uVar12 ^ uVar12 >> 5;
            uVar11 = (uVar13 - uVar12) - uVar15 ^ uVar15 >> 3;
            uVar12 = (uVar12 - uVar15) - uVar11 ^ uVar11 << 10;
            uVar15 = (uVar15 - uVar11) - uVar12 ^ uVar12 >> 0xf;
            pUVar14 = (UT_hash_handle *)&pUVar14->hh_prev;
        }
        uVar15 = (int)&__n->tbl + uVar15;
        switch (pUVar16) {
        case (UT_hash_handle *)0xb:
            uVar15 =
                uVar15 + (uint) * (byte *)((int)&pUVar14->next + 2) * 0x1000000;
        case (UT_hash_handle *)0xa:
            uVar15 =
                uVar15 + (uint) * (byte *)((int)&pUVar14->next + 1) * 0x10000;
        case (UT_hash_handle *)0x9:
            uVar15 = uVar15 + (uint) * (byte *)&pUVar14->next * 0x100;
        case (UT_hash_handle *)0x8:
            uVar12 =
                uVar12 + (uint) * (byte *)((int)&pUVar14->prev + 3) * 0x1000000;
        case (UT_hash_handle *)0x7:
            uVar12 =
                uVar12 + (uint) * (byte *)((int)&pUVar14->prev + 2) * 0x10000;
        case (UT_hash_handle *)0x6:
            uVar12 =
                uVar12 + (uint) * (byte *)((int)&pUVar14->prev + 1) * 0x100;
        case (UT_hash_handle *)0x5:
            uVar12 = uVar12 + *(byte *)&pUVar14->prev;
        case (UT_hash_handle *)0x4:
            uVar11 =
                uVar11 + (uint) * (byte *)((int)&pUVar14->tbl + 3) * 0x1000000;
        case (UT_hash_handle *)0x3:
            uVar11 =
                uVar11 + (uint) * (byte *)((int)&pUVar14->tbl + 2) * 0x10000;
        case (UT_hash_handle *)0x2:
            uVar11 = uVar11 + (uint) * (byte *)((int)&pUVar14->tbl + 1) * 0x100;
        case (UT_hash_handle *)0x1:
            uVar11 = uVar11 + *(byte *)&pUVar14->tbl;
        }
        pUVar8 = (__s_00->hh).tbl;
        uVar11 = (uVar11 - uVar12) - uVar15 ^ uVar15 >> 0xd;
        uVar13 = (uVar12 - uVar15) - uVar11 ^ uVar11 << 8;
        uVar15 = (uVar15 - uVar11) - uVar13 ^ uVar13 >> 0xd;
        uVar12 = (uVar11 - uVar13) - uVar15 ^ uVar15 >> 0xc;
        uVar11 = (uVar13 - uVar15) - uVar12 ^ uVar12 << 0x10;
        uVar15 = (uVar15 - uVar12) - uVar11 ^ uVar11 >> 5;
        uVar12 = (uVar12 - uVar11) - uVar15 ^ uVar15 >> 3;
        uVar11 = (uVar11 - uVar15) - uVar12 ^ uVar12 << 10;
        pUVar14 = pUVar8
                      ->buckets[((uVar15 - uVar12) - uVar11 ^ uVar11 >> 0xf) &
                                pUVar8->num_buckets - 1]
                      .hh_head;
        if (pUVar14 != (UT_hash_handle *)0x0) {
            __s = (_cgpu_devid_counter *)-pUVar8->hho;
            for (pcVar9 = __s->name + (int)pUVar14; pcVar9 != (char *)0x0;
                 pcVar9 =
                     __s->name + (int)*(UT_hash_handle **)(pcVar9 + 0x18)) {
                if ((*(UT_hash_handle **)(pcVar9 + 0x20) == __n) &&
                    (iVar7 = memcmp(*(void **)(pcVar9 + 0x1c), pUVar10,
                                    (size_t)__n),
                     iVar7 == 0)) {
                    iVar7 = *(int *)(pcVar9 + 4);
                    *(int *)(pcVar9 + 4) = iVar7 + 1;
                    cgpu->device_id = iVar7 + 1;
                    local_2c = pUVar10;
                    goto LAB_000262f6;
                }
                if (*(UT_hash_handle **)(pcVar9 + 0x18) ==
                    (UT_hash_handle *)0x0)
                    break;
            }
        }
        __s = (_cgpu_devid_counter *)malloc(0x28);
        local_2c = &__s->hh;
        pUVar8 = pUVar10->tbl;
        (__s->hh).key = __s;
        (__s->hh).next = (void *)0x0;
        *(UT_hash_table **)__s->name = pUVar8;
        __s->lastid = 0;
        cgpu->device_id = 0;
        sVar5 = strlen((char *)__s);
        (__s->hh).keylen = sVar5;
        ((__s_00->hh).tbl)->tail->next = __s;
        pUVar8 = (__s_00->hh).tbl;
        (__s->hh).prev = (void *)((int)pUVar8->tail - pUVar8->hho);
        ((__s_00->hh).tbl)->tail = local_2c;
        pUVar8 = (__s_00->hh).tbl;
    LAB_000263fc:
        pUVar10 = (UT_hash_handle *)0xfeedbeef;
        pUVar14 = (UT_hash_handle *)0x9e3779b9;
        pUVar8->num_items = pUVar8->num_items + 1;
        pUVar8 = (__s_00->hh).tbl;
        (__s->hh).hashv = 0xfeedbeef;
        (__s->hh).tbl = pUVar8;
        sVar5 = strlen(__s->name);
        __n = pUVar14;
        p_Var17 = __s;
        uVar11 = sVar5;
        p_Var2 = __s;
        if (0xb < sVar5) {
            do {
                p_Var17 = (_cgpu_devid_counter *)&(p_Var2->hh).prev;
                uVar11 = sVar5 - 0xc;
                uVar13 =
                    (int)&pUVar10
                        [(uint) * (byte *)((int)&(p_Var2->hh).tbl + 3) *
                             0x80000 +
                         (uint) * (byte *)((int)&(p_Var2->hh).tbl + 1) * 8 +
                         (uint) * (byte *)((int)&(p_Var2->hh).tbl + 2) * 0x800]
                            .tbl +
                    (uint) * (byte *)&(p_Var2->hh).tbl;
                iVar7 =
                    (int)&__n[(uint) * (byte *)((int)&p_Var2->lastid + 3) *
                                  0x80000 +
                              (uint) * (byte *)((int)&p_Var2->lastid + 1) * 8 +
                              (uint) * (byte *)((int)&p_Var2->lastid + 2) *
                                  0x800]
                        .tbl +
                    (uint)(byte)p_Var2->lastid;
                uVar12 = ((((uint)(byte)p_Var2->name[2] * 0x10000 +
                            (uint)(byte)p_Var2->name[1] * 0x100 +
                            (uint)(byte)p_Var2->name[0] +
                            (uint)(byte)p_Var2->name[3] * 0x1000000) -
                           uVar13) -
                          iVar7) +
                             (int)pUVar14 ^
                         uVar13 >> 0xd;
                uVar15 = (iVar7 - uVar13) - uVar12 ^ uVar12 << 8;
                uVar13 = uVar13 + (-uVar15 - uVar12) ^ uVar15 >> 0xd;
                uVar12 = (uVar12 - uVar15) - uVar13 ^ uVar13 >> 0xc;
                uVar15 = (uVar15 - uVar13) - uVar12 ^ uVar12 << 0x10;
                uVar13 = (uVar13 - uVar12) - uVar15 ^ uVar15 >> 5;
                pUVar14 = (UT_hash_handle *)((uVar12 - uVar15) - uVar13 ^
                                             uVar13 >> 3);
                __n = (UT_hash_handle *)((uVar15 - uVar13) - (int)pUVar14 ^
                                         (int)pUVar14 << 10);
                pUVar10 =
                    (UT_hash_handle *)((uVar13 - (int)pUVar14) - (int)__n ^
                                       (uint)__n >> 0xf);
                (__s->hh).hashv = (uint)pUVar10;
                sVar5 = uVar11;
                p_Var2 = p_Var17;
            } while (0xb < uVar11);
            sVar5 = strlen(__s->name);
        }
        do {
            uVar12 = (int)&pUVar10->tbl + sVar5;
            unaff_r10 = uVar11 - 1;
            (__s->hh).hashv = uVar12;
            switch (uVar11) {
            case 0xb:
                uVar12 = uVar12 + (uint) *
                                      (byte *)((int)&(p_Var17->hh).tbl + 2) *
                                      0x1000000;
                (__s->hh).hashv = uVar12;
            case 10:
                uVar12 = uVar12 + (uint) *
                                      (byte *)((int)&(p_Var17->hh).tbl + 1) *
                                      0x10000;
                (__s->hh).hashv = uVar12;
            case 9:
                uVar12 = uVar12 + (uint) * (byte *)&(p_Var17->hh).tbl * 0x100;
                (__s->hh).hashv = uVar12;
            case 8:
                __n = __n +
                      (uint) * (byte *)((int)&p_Var17->lastid + 3) * 0x80000;
            case 7:
                __n =
                    __n + (uint) * (byte *)((int)&p_Var17->lastid + 2) * 0x800;
            case 6:
                __n = __n + (uint) * (byte *)((int)&p_Var17->lastid + 1) * 8;
            case 5:
                __n = (UT_hash_handle *)((int)&__n->tbl +
                                         (uint)(byte)p_Var17->lastid);
            case 4:
                pUVar14 = pUVar14 + (uint)(byte)p_Var17->name[3] * 0x80000;
            case 3:
                pUVar14 = pUVar14 + (uint)(byte)p_Var17->name[2] * 0x800;
            case 2:
                pUVar14 = pUVar14 + (uint)(byte)p_Var17->name[1] * 8;
            case 1:
                pUVar14 = (UT_hash_handle *)((int)&pUVar14->tbl +
                                             (uint)(byte)p_Var17->name[0]);
            }
            uVar13 = (int)pUVar14 + (-uVar12 - (int)__n) ^ uVar12 >> 0xd;
            uVar15 = (int)__n + (-uVar13 - uVar12) ^ uVar13 << 8;
            uVar11 = uVar12 + (-uVar15 - uVar13) ^ uVar15 >> 0xd;
            uVar13 = (uVar13 - uVar15) - uVar11 ^ uVar11 >> 0xc;
            uVar12 = (uVar15 - uVar11) - uVar13 ^ uVar13 << 0x10;
            uVar11 = (uVar11 - uVar13) - uVar12 ^ uVar12 >> 5;
            uVar15 = (uVar13 - uVar12) - uVar11 ^ uVar11 >> 3;
            uVar12 = (uVar12 - uVar11) - uVar15 ^ uVar15 << 10;
            uVar11 = (uVar11 - uVar15) - uVar12 ^ uVar12 >> 0xf;
            (__s->hh).hashv = uVar11;
            pUVar8 = (__s_00->hh).tbl;
            pUVar6 = pUVar8->buckets;
            uVar11 = uVar11 & pUVar8->num_buckets - 1;
            pUVar6[uVar11].count = pUVar6[uVar11].count + 1;
            pUVar14 = ((__s_00->hh).tbl)->buckets[uVar11].hh_head;
            (__s->hh).hh_prev = (UT_hash_handle *)0x0;
            (__s->hh).hh_next = pUVar14;
            pUVar6 = ((__s_00->hh).tbl)->buckets;
            if (pUVar6[uVar11].hh_head != (UT_hash_handle *)0x0) {
                (pUVar6[uVar11].hh_head)->hh_prev = local_2c;
                pUVar6 = ((__s_00->hh).tbl)->buckets;
            }
            pUVar6[uVar11].hh_head = local_2c;
            pUVar6 = ((__s_00->hh).tbl)->buckets;
            if ((pUVar6[uVar11].count <
                 (pUVar6[uVar11].expand_mult + 1) * 10) ||
                (pUVar8 = (__s->hh).tbl, pUVar8->noexpand == 1)) {
            LAB_000262f6:
                iVar3 =
                    pthread_rwlock_wrlock((pthread_rwlock_t *)&devices_lock);
                pcVar9 = extraout_r2;
                iVar7 = extraout_r3;
                pUVar14 = __n;
            } else {
                __s_00 = (_cgpu_devid_counter *)calloc(
                    pUVar8->num_buckets * 0x18, 1);
                if (__s_00 == (_cgpu_devid_counter *)0x0)
                    goto LAB_000267fc;
                uVar11 =
                    pUVar8->num_items >> (pUVar8->log2_num_buckets + 1 & 0xff);
                if ((pUVar8->num_buckets * 2 - 1 & pUVar8->num_items) != 0) {
                    uVar11 = uVar11 + 1;
                }
                pUVar8->ideal_chain_maxlen = uVar11;
                ((__s->hh).tbl)->nonideal_items = 0;
                pUVar8 = (__s->hh).tbl;
                pUVar14 = (UT_hash_handle *)pUVar8->num_buckets;
                if (pUVar14 != (UT_hash_handle *)0x0) {
                    iVar7 = 0;
                    unaff_r10 = 0;
                    local_2c = (UT_hash_handle *)0x0;
                    do {
                        __n = *(
                            UT_hash_handle **)((int)&pUVar8->buckets->hh_head +
                                               iVar7);
                        if (__n != (UT_hash_handle *)0x0) {
                            while (true) {
                                pUVar16 = __n->hh_next;
                                uVar11 = (int)pUVar14 * 2 - 1U & __n->hashv;
                                pUVar10 =
                                    (UT_hash_handle
                                         *)((int)&(
                                                *(UT_hash_handle *
                                                      *)((int)__s_00->name +
                                                         (uVar11 * 3 + 1) * 4))
                                                ->tbl +
                                            1);
                                *(UT_hash_handle **)((int)__s_00->name +
                                                     (uVar11 * 3 + 1) * 4) =
                                    pUVar10;
                                if ((UT_hash_handle *)
                                        pUVar8->ideal_chain_maxlen < pUVar10) {
                                    pUVar8->nonideal_items =
                                        pUVar8->nonideal_items + 1;
                                    pUVar10 = (UT_hash_handle *)__udivsi3(
                                        *(UT_hash_handle **)((int)__s_00->name +
                                                             (uVar11 * 3 + 1) *
                                                                 4),
                                        ((__s->hh).tbl)->ideal_chain_maxlen);
                                    *(UT_hash_handle **)((int)__s_00->name +
                                                         (uVar11 * 3 + 2) * 4) =
                                        pUVar10;
                                }
                                __n->hh_prev = (UT_hash_handle *)0x0;
                                __n->hh_next =
                                    *(UT_hash_handle **)((int)__s_00->name +
                                                         uVar11 * 3 * 4);
                                if (*(UT_hash_handle **)((int)__s_00->name +
                                                         uVar11 * 3 * 4) !=
                                    (UT_hash_handle *)0x0) {
                                    (*(UT_hash_handle **)((int)__s_00->name +
                                                          uVar11 * 3 * 4))
                                        ->hh_prev = __n;
                                }
                                *(UT_hash_handle **)((int)__s_00->name +
                                                     uVar11 * 3 * 4) = __n;
                                pUVar8 = (__s->hh).tbl;
                                if (pUVar16 == (UT_hash_handle *)0x0)
                                    break;
                                pUVar14 = (UT_hash_handle *)pUVar8->num_buckets;
                                __n = pUVar16;
                            }
                            pUVar14 = (UT_hash_handle *)pUVar8->num_buckets;
                            pUVar10 = (UT_hash_handle *)0x0;
                        }
                        iVar7 = iVar7 + 0xc;
                        local_2c = (UT_hash_handle *)((int)&local_2c->tbl + 1);
                    } while (local_2c < pUVar14);
                }
                free(pUVar8->buckets);
                pUVar8 = (__s->hh).tbl;
                pUVar8->num_buckets = pUVar8->num_buckets << 1;
                pUVar8 = (__s->hh).tbl;
                pUVar8->log2_num_buckets = pUVar8->log2_num_buckets + 1;
                ((__s->hh).tbl)->buckets = (UT_hash_bucket *)__s_00;
                pUVar8 = (__s->hh).tbl;
                if (pUVar8->num_items >> 1 < pUVar8->nonideal_items) {
                    uVar11 = pUVar8->ineff_expands + 1;
                } else {
                    uVar11 = 0;
                }
                pUVar8->ineff_expands = uVar11;
                pUVar8 = (__s->hh).tbl;
                uVar12 = pUVar8->ineff_expands;
                uVar11 = uVar12;
                if (1 < uVar12) {
                    uVar11 = 1;
                }
                if (1 < uVar12) {
                    pUVar8->noexpand = uVar11;
                }
                iVar3 =
                    pthread_rwlock_wrlock((pthread_rwlock_t *)&devices_lock);
                pcVar9 = extraout_r2_01;
                iVar7 = extraout_r3_01;
                pUVar14 = __n;
            }
            if (iVar3 == 0) {
                devices = (cgpu_info **)realloc(
                    devices, (total_devices + new_devices + 2) * 4);
                iVar7 =
                    pthread_rwlock_unlock((pthread_rwlock_t *)&devices_lock);
                if (iVar7 != 0) {
                    /* WARNING: Subroutine does not return */
                    _rw_unlock((pthread_rwlock_t *)"add_cgpu", (char *)0x28ce,
                               func, line);
                }
                (*selective_yield)();
                iVar7 = pthread_mutex_lock((pthread_mutex_t *)&stats_lock);
                if (iVar7 == 0) {
                    tVar4 = time((time_t *)0x0);
                    cgpu->last_device_valid_work = tVar4;
                    iVar3 =
                        pthread_mutex_unlock((pthread_mutex_t *)&stats_lock);
                    pcVar9 = extraout_r2_00;
                    iVar7 = extraout_r3_00;
                    if (iVar3 == 0) {
                        (*selective_yield)();
                        if (hotplug_mode == false) {
                            ppcVar1 = devices + total_devices;
                            total_devices = total_devices + 1;
                            *ppcVar1 = cgpu;
                        } else {
                            iVar7 = new_devices + total_devices;
                            new_devices = new_devices + 1;
                            devices[iVar7] = cgpu;
                        }
                        if (most_devices < total_devices - zombie_devs) {
                            most_devices = total_devices - zombie_devs;
                        }
                        return true;
                    }
                } else {
                    _mutex_lock((pthread_mutex_t *)"add_cgpu", (char *)0x28d0,
                                func_00, line_00);
                    pcVar9 = extraout_r2_02;
                    iVar7 = extraout_r3_02;
                }
                /* WARNING: Subroutine does not return */
                _mutex_unlock_noyield((pthread_mutex_t *)"add_cgpu",
                                      (char *)0x28d2, pcVar9, iVar7);
            }
            _wr_lock((pthread_rwlock_t *)"add_cgpu", (char *)0x28cc, pcVar9,
                     iVar7);
            sVar5 = extraout_r0;
            __n = pUVar14;
            p_Var17 = __s;
            uVar11 = unaff_r10;
        } while (true);
    }
    __s_00 = (_cgpu_devid_counter *)malloc(0x28);
    pUVar8 = pUVar10->tbl;
    cgpu->device_id = 0;
    (__s_00->hh).next = (void *)0x0;
    *(UT_hash_table **)__s_00->name = pUVar8;
    __s_00->lastid = 0;
    (__s_00->hh).key = __s_00;
    sVar5 = strlen((char *)__s_00);
    (__s_00->hh).keylen = sVar5;
    (__s_00->hh).prev = (void *)0x0;
    add_cgpu::devids = __s_00;
    pUVar8 = (UT_hash_table *)malloc(0x2c);
    (__s_00->hh).tbl = pUVar8;
    if (pUVar8 != (UT_hash_table *)0x0) {
        memset(&pUVar8->num_items, 0, 0x20);
        local_2c = &__s_00->hh;
        pUVar8->tail = local_2c;
        pUVar8->num_buckets = 0x20;
        pUVar8->log2_num_buckets = 5;
        pUVar8->hho = 8;
        pUVar6 = (UT_hash_bucket *)calloc(0x180, 1);
        pUVar8->buckets = pUVar6;
        if (pUVar6 != (UT_hash_bucket *)0x0) {
            pUVar8->signature = 0xa0111fe1;
            __s = __s_00;
            goto LAB_000263fc;
        }
    }
LAB_000267fc:
    /* WARNING: Subroutine does not return */
    exit(-1);
}

/* WARNING: Unknown calling convention */

device_drv *copy_drv(device_drv *drv)

{
    device_drv *__dest;
    char *pcVar1;
    char tmp42[4096];

    __dest = (device_drv *)malloc(0x80);
    if (__dest != (device_drv *)0x0) {
        memcpy(__dest, drv, 0x80);
        __dest->copy = true;
        return __dest;
    }
    pcVar1 = "original";
    if (drv->copy != false) {
        pcVar1 = "copy";
    }
    snprintf(tmp42, 0x1000, "Failed to allocate device_drv copy of %s (%s)",
             drv->name, pcVar1);
    _applog(3, tmp42, true);
    /* WARNING: Subroutine does not return */
    __quit(1, true);
}

/* WARNING: Unknown calling convention */

void set_miner_name(char *name)

{
    FILE *pFVar1;
    char rbuf1[128];
    char tmp42[4096];

    pFVar1 = fopen("/usr/bin/compile_time", "r");
    memset(rbuf1, 0, 0x80);
    fgets(rbuf1, 0x80, pFVar1);
    fclose(pFVar1);
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "rbuf1 %s\n", rbuf1);
        _applog(5, tmp42, false);
    }
    pFVar1 = fopen("/usr/bin/compile_time", "w");
    fputs(rbuf1, pFVar1);
    fprintf(pFVar1, "Antminer %s\n", name);
    fclose(pFVar1);
    return;
}

/* WARNING: Unknown calling convention */

int no_yield(void)

{
    return 0;
}

/* WARNING: Removing unreachable block (ram,0x00026976) */
/* WARNING: Unknown calling convention */

send_ret __stratum_send(pool *pool, char *s, ssize_t len)

{
    size_t sVar1;
    int iVar2;
    int *piVar3;
    ssize_t sVar4;
    int iVar5;
    uint uVar6;
    __suseconds_t *p_Var7;
    uint uVar8;
    int iVar9;
    uint uVar10;
    size_t local_c0;
    uint local_bc;
    timeval timeout;
    fd_set wd;

    local_c0 = len + 1;
    sVar1 = strlen(s);
    uVar6 = pool->sock;
    (s + sVar1)[0] = '\n';
    (s + sVar1)[1] = '\0';
    if ((int)local_c0 < 1) {
        local_bc = 0;
        iVar5 = 0;
    } else {
        uVar10 = uVar6 & 0x1f;
        iVar5 = (int)(uVar6 + 0x1f & (int)uVar6 >> 0x20) >> 5;
        if ((int)uVar6 < 1) {
            uVar10 = -(-uVar6 & 0x1f);
        }
        local_bc = 0;
        do {
            while (true) {
                timeout.tv_sec = 1;
                timeout.tv_usec = 0;
                while (true) {
                    p_Var7 = &timeout.tv_usec;
                    do {
                        p_Var7 = p_Var7 + 1;
                        *p_Var7 = 0;
                    } while (p_Var7 != wd.fds_bits + 0x1f);
                    wd.fds_bits[iVar5] =
                        wd.fds_bits[iVar5] | 1 << (uVar10 & 0xff);
                    iVar2 = select(uVar6 + 1, (fd_set *)0x0, (fd_set *)&wd,
                                   (fd_set *)0x0, (timeval *)&timeout);
                    if (0 < iVar2)
                        break;
                    piVar3 = __errno_location();
                    if (*piVar3 != 4) {
                        return SEND_SELECTFAIL;
                    }
                }
                sVar4 = send(pool->sock, s + local_bc, local_c0, 0x4000);
                if (-1 < sVar4)
                    break;
                piVar3 = __errno_location();
                if (*piVar3 != 0xb) {
                    return SEND_SENDFAIL;
                }
            }
            local_bc = local_bc + sVar4;
            local_c0 = local_c0 - sVar4;
        } while (0 < (int)local_c0);
        iVar5 = (int)local_bc >> 0x1f;
    }
    uVar8 = (uint)(pool->cgminer_pool_stats).times_sent;
    iVar9 = *(int *)((int)&(pool->cgminer_pool_stats).times_sent + 4);
    uVar6 = (uint)(pool->cgminer_pool_stats).bytes_sent;
    iVar2 = *(int *)((int)&(pool->cgminer_pool_stats).bytes_sent + 4);
    *(uint *)&(pool->cgminer_pool_stats).times_sent = uVar8 + 1;
    uVar10 = (uint)(pool->cgminer_pool_stats).net_bytes_sent;
    *(uint *)((int)&(pool->cgminer_pool_stats).times_sent + 4) =
        iVar9 + (uint)(0xfffffffe < uVar8);
    iVar9 = *(int *)((int)&(pool->cgminer_pool_stats).net_bytes_sent + 4);
    *(uint *)&(pool->cgminer_pool_stats).bytes_sent = uVar6 + local_bc;
    *(uint *)((int)&(pool->cgminer_pool_stats).bytes_sent + 4) =
        iVar5 + iVar2 + (uint)CARRY4(uVar6, local_bc);
    *(uint *)&(pool->cgminer_pool_stats).net_bytes_sent = uVar10 + local_bc;
    *(uint *)((int)&(pool->cgminer_pool_stats).net_bytes_sent + 4) =
        iVar5 + iVar9 + (uint)CARRY4(uVar10, local_bc);
    return SEND_OK;
}

/* WARNING: Unknown calling convention */

_Bool http_negotiate(pool *pool, int sockd, _Bool http0)

{
    char cVar1;
    char cVar2;
    char *pcVar3;
    size_t __n;
    ssize_t sVar4;
    int iVar5;
    char *pcVar6;
    char cVar7;
    char buf[1024];
    char tmp42[4096];

    pcVar3 = pool->sockaddr_url;
    pcVar6 = pool->stratum_port;
    if (http0) {
        snprintf(buf, 0x400, "CONNECT %s:%s HTTP/1.0\r\n\r\n", pcVar3, pcVar6);
    } else {
        snprintf(buf, 0x400, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
                 pcVar3, pcVar6, pcVar3, pcVar6);
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Sending proxy %s:%s - %s",
                 pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);
        _applog(7, tmp42, false);
    }
    __n = strlen(buf);
    send(sockd, buf, __n, 0);
    sVar4 = recv(sockd, buf, 0xc, 0);
    if (sVar4 < 1) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "Couldn\'t read from proxy %s:%s after sending CONNECT",
                     pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);
            _applog(4, tmp42, false);
            return false;
        }
    } else {
        buf[sVar4] = '\0';
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "Received from proxy %s:%s - %s",
                     pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);
            _applog(7, tmp42, false);
        }
        iVar5 = strcmp(buf, "HTTP/1.1 200");
        if ((iVar5 == 0) || (iVar5 = strcmp(buf, "HTTP/1.0 200"), iVar5 == 0)) {
            do {
                sVar4 = recv(sockd, tmp42, 1, 0);
                if (sVar4 == -1) {
                    buf[iVar5] = -1;
                    goto LAB_00026cca;
                }
                buf[iVar5] = tmp42[0];
                iVar5 = iVar5 + 1;
                if (tmp42[0] == -1)
                    goto LAB_00026cca;
            } while (iVar5 != 4);
            iVar5 = strncmp(buf, "\r\n\r\n", 4);
            cVar7 = opt_debug;
            cVar1 = buf[0];
            buf[0] = buf[1];
            buf[1] = buf[2];
            buf[2] = buf[3];
            while (true) {
                opt_debug = (_Bool)cVar7;
                buf[3] = buf[2];
                if (iVar5 == 0) {
                    if (cVar7 == '\0') {
                        cVar7 = '\x01';
                    } else if (((use_syslog != false) ||
                                (opt_log_output != false)) ||
                               (6 < opt_log_level)) {
                        cVar2 = buf[0];
                        buf[0] = cVar1;
                        cVar1 = buf[1];
                        buf[1] = cVar2;
                        buf[2] = cVar1;
                        snprintf(tmp42, 0x1000,
                                 "Success negotiating with %s:%s HTTP proxy",
                                 pool->sockaddr_proxy_url,
                                 pool->sockaddr_proxy_port);
                        _applog(7, tmp42, false);
                    }
                    return (_Bool)cVar7;
                }
                sVar4 = recv(sockd, tmp42, 1, 0);
                if (sVar4 == -1)
                    break;
                buf[3] = tmp42[0];
                if (tmp42[0] == -1)
                    goto LAB_00026cca;
                iVar5 = strncmp(buf, "\r\n\r\n", 4);
                cVar7 = opt_debug;
                cVar1 = buf[0];
                buf[0] = buf[1];
                buf[1] = buf[2];
                buf[2] = buf[3];
            }
            buf[3] = -1;
        LAB_00026cca:
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000,
                         "Couldn\'t read HTTP byte from proxy %s:%s",
                         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);
                _applog(4, tmp42, false);
                return false;
            }
        } else if (((use_syslog != false) || (opt_log_output != false)) ||
                   (3 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "HTTP Error from proxy %s:%s - %s",
                     pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);
            _applog(4, tmp42, false);
            return false;
        }
    }
    return false;
}

/* WARNING: Unknown calling convention */

void __suspend_stratum(pool *pool)

{
    if (pool->sockbuf != (char *)0x0) {
        *pool->sockbuf = '\0';
    }
    pool->stratum_notify = false;
    pool->stratum_active = false;
    if (pool->sock != 0) {
        close(pool->sock);
    }
    pool->sock = 0;
    return;
}

/* WARNING: Unknown calling convention */

void block_socket(long fd)

{
    uint uVar1;

    uVar1 = fcntl(fd, 3, 0);
    fcntl(fd, 4, uVar1 & 0xfffff7ff);
    return;
}

/* WARNING: Unknown calling convention */

_Bool socks4_negotiate(pool *pool, int sockd, _Bool socks4a)

{
    long lVar1;
    in_addr_t iVar2;
    ssize_t sVar3;
    size_t __n;
    int iVar4;
    uint uVar5;
    char *__s;
    addrinfo *servinfo;
    addrinfo servinfobase;
    char buf[515];
    addrinfo hints;

    buf[0] = '\x04';
    buf[1] = '\x01';
    lVar1 = strtol(pool->stratum_port, (char **)0x0, 10);
    buf[3] = (char)lVar1;
    buf[2] = (char)((uint)lVar1 >> 8);
    builtin_strncpy(buf + 8, "CGMINER", 8);
    iVar2 = inet_addr(pool->sockaddr_url);
    uVar5 = iVar2 << 0x18 | (iVar2 >> 8 & 0xff) << 0x10 |
            (iVar2 >> 0x10 & 0xff) << 8 | iVar2 >> 0x18;
    if (uVar5 == 0xffffffff) {
        servinfo = &servinfobase;
        memset((addrinfo *)&hints, 0, 0x20);
        hints.ai_family = 2;
        iVar4 = getaddrinfo(pool->sockaddr_url, (char *)0x0, (addrinfo *)&hints,
                            (addrinfo **)&servinfo);
        if (iVar4 == 0) {
            uVar5 = *(uint *)(servinfo->ai_addr->sa_data + 2);
            freeaddrinfo((addrinfo *)servinfo);
            uVar5 = uVar5 << 0x18 | (uVar5 >> 8 & 0xff) << 0x10 |
                    (uVar5 >> 0x10 & 0xff) << 8 | uVar5 >> 0x18;
            if (uVar5 == 0xffffffff)
                goto LAB_00026fa0;
            goto LAB_00026e68;
        }
        if (!socks4a) {
        LAB_00026fa0:
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 4)) {
                return false;
            }
            snprintf((char *)&hints, 0x1000,
                     "Invalid IP address specified for socks4 proxy: %s",
                     pool->sockaddr_url);
            goto LAB_00026ee2;
        }
        __s = pool->sockaddr_url;
        buf[4] = '\0';
        buf[5] = '\0';
        buf[6] = '\0';
        buf[7] = '\x01';
        __n = strlen(__s);
        if (0xfe < __n) {
            __n = 0xff;
        }
        memcpy(buf + 0x10, __s, __n);
        buf[__n + 0x10] = '\0';
        send(sockd, buf, __n + 0x11, 0);
    } else {
    LAB_00026e68:
        buf[5] = (char)(uVar5 >> 0x10);
        buf[4] = (char)(uVar5 >> 0x18);
        buf[7] = (char)uVar5;
        buf[6] = (char)(uVar5 >> 8);
        send(sockd, buf, 0x10, 0);
    }
    sVar3 = recv(sockd, (addrinfo *)&hints, 1, 0);
    if (((sVar3 != -1) && ((char)hints.ai_flags == '\0')) &&
        ((sVar3 = recv(sockd, (addrinfo *)&hints, 1, 0),
          sVar3 != -1 && ((char)hints.ai_flags == 'Z')))) {
        iVar4 = 6;
        do {
            recv(sockd, (addrinfo *)&hints, 1, 0);
            iVar4 = iVar4 + -1;
        } while (iVar4 != 0);
        return true;
    }
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 4)) {
        return false;
    }
    snprintf((char *)&hints, 0x1000, "Bad response from %s:%s SOCKS4 server",
             pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);
LAB_00026ee2:
    _applog(4, (char *)&hints, false);
    return false;
}

_Bool socket_full(pool *pool, int wait)

{
    undefined1 uVar1;
    int iVar2;
    int iVar3;
    __suseconds_t *p_Var4;
    uint uVar5;
    pool *ppVar6;
    timeval timeout;
    fd_set rd;

    timeout.tv_sec = wait & ~(wait >> 0x1f);
    p_Var4 = &timeout.tv_usec;
    do {
        p_Var4 = p_Var4 + 1;
        *p_Var4 = 0;
    } while (rd.fds_bits + 0x1f != p_Var4);
    ppVar6 = (pool *)((uint)((int)&pool->seq_getfails + 3) & (int)pool >> 0x20);
    if (rd.fds_bits + 0x1f < p_Var4) {
        ppVar6 = pool;
    }
    timeout.tv_usec = 0;
    uVar5 = (uint)pool & 0x1f;
    if ((int)pool < 1) {
        uVar5 = -(-(int)pool & 0x1fU);
    }
    rd.fds_bits[(int)ppVar6 >> 5] =
        1 << (uVar5 & 0xff) | rd.fds_bits[(int)ppVar6 >> 5];
    iVar2 = select((int)((int)&pool->pool_no + 1), (fd_set *)&rd, (fd_set *)0x0,
                   (fd_set *)0x0, (timeval *)&timeout);
    iVar3 = iVar2;
    if (iVar2 < 1) {
        iVar3 = 0;
    }
    uVar1 = (undefined1)iVar3;
    if (0 < iVar2) {
        uVar1 = 1;
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

char *__json_array_string(json_t *val, uint entry)

{
    size_t sVar1;
    json_t *json;
    char *pcVar2;

    if (val == (json_t *)0x0) {
        return (char *)0x0;
    }
    if ((((val->type == JSON_ARRAY) &&
          (sVar1 = json_array_size(val), entry <= sVar1)) &&
         (json = json_array_get(val, entry), json != (json_t *)0x0)) &&
        (json->type == JSON_STRING)) {
        pcVar2 = json_string_value(json);
        return pcVar2;
    }
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *json_array_string(json_t *val, uint entry)

{
    char *pcVar1;

    pcVar1 = __json_array_string(val, entry);
    if (pcVar1 == (char *)0x0) {
        return (char *)0x0;
    }
    pcVar1 = (char *)__strdup();
    return pcVar1;
}

/* WARNING: Unknown calling convention */

void _cgsem_post(cgsem_t *cgsem, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000,
             "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *piVar1,
             cgsem, file, func, line);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void _mutex_unlock_noyield(pthread_mutex_t *lock, char *file, char *func,
                           int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_mutex_unlock((pthread_mutex_t *)lock);
    if (iVar1 == 0) {
        return;
    }
    piVar2 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
             *piVar2, "util.c", file, func);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void _mutex_lock(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar1, "util.c", lock, file);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

/* WARNING: Unknown calling convention */

void clear_sock(pool *pool)

{
    int iVar1;
    ssize_t sVar2;
    char *func;
    int line;
    int extraout_r3;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&pool->stratum_lock);
    if (iVar1 != 0) {
        _mutex_lock((pthread_mutex_t *)"clear_sock", (char *)0x7a3, func, line);
    }
    do {
        iVar1 = 0;
        if (pool->sock == 0)
            break;
        sVar2 = recv(pool->sock, pool->sockbuf, 0x1ffc, 0);
        iVar1 = extraout_r3;
    } while (0 < sVar2);
    _mutex_unlock_noyield(&pool->stratum_lock, "clear_sock", (char *)0x7ac,
                          iVar1);
    (*selective_yield)();
    if (pool->sockbuf != (char *)0x0) {
        *pool->sockbuf = '\0';
    }
    return;
}

/* WARNING: Unknown calling convention */

void tq_freezethaw(thread_q *tq, _Bool frozen)

{
    int iVar1;
    char *func;
    int line;
    int line_00;

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&tq->mutex);
    if (iVar1 != 0) {
        _mutex_lock((pthread_mutex_t *)"tq_freezethaw", (char *)0x4d4, func,
                    line);
    }
    tq->frozen = frozen;
    pthread_cond_signal((pthread_cond_t *)&tq->cond);
    _mutex_unlock_noyield(&tq->mutex, "tq_freezethaw", (char *)0x4d7, line_00);
    /* WARNING: Could not recover jumptable at 0x0002722e. Too many branches */
    /* WARNING: Treating indirect jump as call */
    (*selective_yield)();
    return;
}

/* WARNING: Unknown calling convention */

char *proxytype(proxytypes_t proxytype)

{
    char *pcVar1;
    anon_struct_8_2_f5308dc4 *paVar2;

    if (proxytype == 0) {
        pcVar1 = "http:";
    } else {
        pcVar1 = "http0:";
        paVar2 = proxynames;
        do {
            if (paVar2[1].proxytype == proxytype) {
                return pcVar1;
            }
            pcVar1 = paVar2[2].name;
            paVar2 = paVar2 + 1;
        } while (pcVar1 != (char *)0x0);
        pcVar1 = "invalid";
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

void __bin2hex(char *s, uchar *p, size_t len)

{
    byte *pbVar1;
    char *pcVar2;

    if (0 < (int)len) {
        pbVar1 = p + -1;
        pcVar2 = s + 2;
        do {
            pbVar1 = pbVar1 + 1;
            pcVar2[-2] = hex_11605[*pbVar1 >> 4];
            pcVar2[-1] = hex_11605[*pbVar1 & 0xf];
            pcVar2 = pcVar2 + 2;
        } while (pbVar1 != p + (len - 1));
        s[len * 2] = '\0';
        return;
    }
    *s = '\0';
    return;
}

/* WARNING: Unknown calling convention */

char *bin2hex(uchar *p, size_t len)

{
    char cVar1;
    uint uVar2;
    char *pcVar3;
    byte *pbVar4;
    byte *pbVar5;
    uint uVar6;
    char *pcVar7;
    char tmp42[4096];

    uVar2 = len * 2 + 1;
    uVar6 = uVar2 & 3;
    if ((int)uVar2 < 1) {
        uVar6 = -(-uVar2 & 3);
    }
    pcVar3 = (char *)calloc(uVar2 + (4 - uVar6), 1);
    if (pcVar3 == (char *)0x0) {
        snprintf(tmp42, 0x1000, "Failed to calloc in %s %s():%d", "util.c",
                 "bin2hex", 0x398);
        _applog(3, tmp42, true);
        _quit(1);
    }
    pcVar7 = pcVar3;
    if (0 < (int)len) {
        pbVar4 = p + -1;
        pbVar5 = pbVar4 + len;
        do {
            pbVar4 = pbVar4 + 1;
            cVar1 = hex_11605[*pbVar4 >> 4];
            pcVar7[1] = hex_11605[*pbVar4 & 0xf];
            *pcVar7 = cVar1;
            pcVar7 = pcVar7 + 2;
        } while (pbVar4 != pbVar5);
        pcVar7 = pcVar3 + len * 2;
    }
    *pcVar7 = '\0';
    return pcVar3;
}

/* WARNING: Unknown calling convention */

_Bool hex2bin(uchar *p, char *hexstr, size_t len)

{
    byte *pbVar1;
    byte *pbVar2;
    int iVar3;
    char *pcVar4;
    uint uVar5;
    uint uVar6;
    char tmp42[4096];

    if ((byte)*hexstr == 0) {
        if (len == 0) {
            return true;
        }
    } else if (len != 0) {
        if ((byte)hexstr[1] == 0) {
        LAB_00027438:
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                builtin_strncpy(tmp42, "hex2bin str truncate", 0x14);
                tmp42[0x14] = 'd';
                tmp42[0x15] = '\0';
                _applog(3, tmp42, false);
            }
        } else {
            uVar5 = hex2bin_tbl[(byte)hexstr[1]];
            uVar6 = hex2bin_tbl[(byte)*hexstr];
            iVar3 = -((int)(uVar5 | uVar6) >> 0x1f);
            if (iVar3 == 0) {
                pcVar4 = hexstr + 4;
                do {
                    len = len - 1;
                    *p = (byte)uVar5 | (byte)(uVar6 << 4);
                    pbVar1 = (byte *)(pcVar4 + -2);
                    if (*pbVar1 == 0) {
                        if (len != 0) {
                            return false;
                        }
                        return true;
                    }
                    if (len == 0) {
                        return (_Bool)(char)iVar3;
                    }
                    pbVar2 = (byte *)(pcVar4 + -1);
                    pcVar4 = pcVar4 + 2;
                    if (*pbVar2 == 0)
                        goto LAB_00027438;
                    uVar6 = hex2bin_tbl[*pbVar1];
                    uVar5 = hex2bin_tbl[*pbVar2];
                    p = p + 1;
                } while (-1 < (int)(uVar6 | uVar5));
            }
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                builtin_strncpy(tmp42, "hex2bin scan failed", 0x14);
                _applog(3, tmp42, false);
                return false;
            }
        }
        return false;
    }
    return false;
}

/* WARNING: Unknown calling convention */

_Bool parse_extranonce_equihash(pool *pool, json_t *val, int type)

{
    char *__s;
    int iVar1;
    size_t sVar2;
    uchar *p;
    int *piVar3;
    size_t sVar4;
    pthread_rwlock_t *__rwlock;
    char tmp42[4096];

    __s = json_array_string(val, type);
    if (__s != (char *)0x0) {
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&pool->data_lock);
        if (iVar1 != 0) {
            piVar3 = __errno_location();
            snprintf(tmp42, 0x1000,
                     "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar3,
                     "util.c", "parse_extranonce_equihash", 0x9da);
            _applog(3, tmp42, true);
            _quit(1);
        }
        __rwlock = &(pool->data_lock).rwlock;
        iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)__rwlock);
        if (iVar1 != 0) {
            piVar3 = __errno_location();
            snprintf(tmp42, 0x1000,
                     "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                     *piVar3, "util.c", "parse_extranonce_equihash", 0x9da);
            _applog(3, tmp42, true);
            _quit(1);
        }
        free(pool->nonce1);
        pool->nonce1 = __s;
        sVar2 = strlen(__s);
        pool->n1_len = sVar2 >> 1;
        free(pool->nonce1bin);
        sVar4 = pool->n1_len;
        p = (uchar *)calloc(sVar4, 1);
        pool->nonce1bin = p;
        if (p == (uchar *)0x0) {
            snprintf(tmp42, 0x1000,
                     "%s: Failed to calloc pool->nonce1bin in %s %s():%d",
                     "parse_extranonce_equihash", "util.c",
                     "parse_extranonce_equihash", 0x9e2);
            _applog(3, tmp42, true);
            _quit(1);
            p = pool->nonce1bin;
            sVar4 = pool->n1_len;
        }
        hex2bin(p, pool->nonce1, sVar4);
        sVar4 = pool->n1_len;
        *(undefined4 *)&pool->nonce2 = 0;
        *(undefined4 *)((int)&pool->nonce2 + 4) = 0;
        pool->n2size = 0x40 - sVar4;
        iVar1 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
        if (iVar1 != 0) {
            piVar3 = __errno_location();
            snprintf(tmp42, 0x1000,
                     "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                     *piVar3, "util.c", "parse_extranonce_equihash", 0x9e8);
            _applog(3, tmp42, true);
            _quit(1);
        }
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&pool->data_lock);
        if (iVar1 != 0) {
            piVar3 = __errno_location();
            snprintf(tmp42, 0x1000,
                     "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                     *piVar3, "util.c", "parse_extranonce_equihash", 0x9e8);
            _applog(3, tmp42, true);
            _quit(1);
        }
        (*selective_yield)();
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 6)) {
            __s = (char *)0x1;
        } else {
            snprintf(tmp42, 0x1000, "Pool %d extranonce set to %s",
                     pool->pool_no, __s);
            _applog(6, tmp42, false);
            __s = (char *)0x1;
        }
    }
    return SUB41(__s, 0);
}

/* WARNING: Unknown calling convention */

void b58tobin(uchar *b58bin, char *b58)

{
    longlong lVar1;
    size_t sVar2;
    uint uVar3;
    uint uVar4;
    size_t sVar5;
    uint *puVar6;
    uint *puVar7;
    size_t *psVar8;
    byte *pbVar9;
    byte *pbVar10;
    uint uStack_38;
    uint32_t bin32[7];

    bin32[0] = 0;
    bin32[1] = 0;
    bin32[2] = 0;
    bin32[3] = 0;
    bin32[4] = 0;
    bin32[5] = 0;
    bin32[6] = 0;
    sVar2 = strlen(b58);
    sVar5 = sVar2;
    if (sVar2 != 0) {
        pbVar10 = (byte *)(b58 + -1);
        pbVar9 = pbVar10 + sVar2;
        uVar4 = 0;
        do {
            pbVar10 = pbVar10 + 1;
            uVar3 = b58tobin_tbl[*pbVar10];
            puVar7 = bin32 + 6;
            while (true) {
                lVar1 = (ulonglong)uVar4 * 0x3a + (ulonglong)uVar3;
                uVar3 = (uint)((ulonglong)lVar1 >> 0x20);
                puVar6 = puVar7 + -1;
                *puVar7 = (uint)lVar1;
                if (&uStack_38 == puVar6)
                    break;
                uVar4 = *puVar6;
                puVar7 = puVar6;
            }
            uVar4 = bin32[6];
        } while (pbVar9 != pbVar10);
        sVar5 = bin32[0] & 0xff;
        sVar2 = bin32[1] << 0x18 | (bin32[1] >> 8 & 0xff) << 0x10 |
                (bin32[1] >> 0x10 & 0xff) << 8 | bin32[1] >> 0x18;
    }
    puVar7 = bin32 + 1;
    *b58bin = (uchar)sVar5;
    psVar8 = (size_t *)(b58bin + 1);
    while (true) {
        *psVar8 = sVar2;
        if (psVar8 + 1 == (size_t *)(b58bin + 0x19))
            break;
        puVar7 = puVar7 + 1;
        uVar4 = *puVar7;
        sVar2 = uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10 |
                (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
        psVar8 = psVar8 + 1;
    }
    return;
}

/* WARNING: Unknown calling convention */

void address_to_pubkeyhash(uchar *pkh, char *addr)

{
    uchar b58bin[25];

    b58bin[0] = '\0';
    b58bin[1] = '\0';
    b58bin[2] = '\0';
    b58bin[3] = '\0';
    b58bin[4] = '\0';
    b58bin[5] = '\0';
    b58bin[6] = '\0';
    b58bin[7] = '\0';
    b58bin[8] = '\0';
    b58bin[9] = '\0';
    b58bin[10] = '\0';
    b58bin[0xb] = '\0';
    b58bin[0xc] = '\0';
    b58bin[0xd] = '\0';
    b58bin[0xe] = '\0';
    b58bin[0xf] = '\0';
    b58bin[0x10] = '\0';
    b58bin[0x11] = '\0';
    b58bin[0x12] = '\0';
    b58bin[0x13] = '\0';
    b58bin[0x14] = '\0';
    b58bin[0x15] = '\0';
    b58bin[0x16] = '\0';
    b58bin[0x17] = '\0';
    b58bin[0x18] = '\0';
    b58tobin(b58bin, addr);
    pkh[2] = '\x14';
    *pkh = 'v';
    pkh[1] = 0xa9;
    *(uint *)(pkh + 3) = CONCAT13(b58bin[4], b58bin._1_3_);
    *(uint *)(pkh + 7) = CONCAT13(b58bin[8], b58bin._5_3_);
    *(uint *)(pkh + 0xb) = CONCAT13(b58bin[0xc], b58bin._9_3_);
    *(uint *)(pkh + 0xf) = CONCAT13(b58bin[0x10], b58bin._13_3_);
    *(uint *)(pkh + 0x13) = CONCAT13(b58bin[0x14], b58bin._17_3_);
    pkh[0x17] = 0x88;
    pkh[0x18] = 0xac;
    return;
}

/* WARNING: Unknown calling convention */

int ser_number(uchar *s, int32_t val)

{
    int iVar1;
    uchar uVar2;

    if (val < 0x80) {
        uVar2 = '\x01';
        iVar1 = 2;
    } else if (val < 0x4080) {
        iVar1 = 3;
        uVar2 = '\x02';
    } else if (val < 0x204080) {
        iVar1 = 4;
        uVar2 = '\x03';
    } else {
        iVar1 = 5;
        uVar2 = '\x04';
    }
    *(int32_t *)(s + 1) = val;
    *s = uVar2;
    return iVar1;
}

/* WARNING: Unknown calling convention */

uchar *ser_string(char *s, int *slen)

{
    size_t __n;
    uchar *puVar1;
    char tmp42[4096];

    __n = strlen(s);
    puVar1 = (uchar *)malloc(__n + 9);
    if (puVar1 == (uchar *)0x0) {
        builtin_strncpy(tmp42, "Failed to malloc ret in ser_stri", 0x20);
        tmp42[0x20] = 'n';
        tmp42[0x21] = 'g';
        tmp42[0x22] = '\0';
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (0xfc < __n) {
        if (0xffff < __n) {
            *puVar1 = 0xfe;
            *(size_t *)(puVar1 + 1) = __n << 0x18 | (__n >> 8 & 0xff) << 0x10 |
                                      (__n >> 0x10 & 0xff) << 8 | __n >> 0x18;
            memcpy(puVar1 + 5, s, __n);
            *slen = __n + 5;
            return puVar1;
        }
        *puVar1 = 0xfd;
        *(ushort *)(puVar1 + 1) =
            (ushort)((__n & 0xff) << 8) | (ushort)(__n >> 8) & 0xff;
        memcpy(puVar1 + 3, s, __n);
        *slen = __n + 3;
        return puVar1;
    }
    *puVar1 = (uchar)__n;
    memcpy(puVar1 + 1, s, __n);
    *slen = __n + 1;
    return puVar1;
}

/* WARNING: Unknown calling convention */

_Bool fulltest(uchar *hash, uchar *target)

{
    bool bVar1;
    char *__ptr;
    char *__ptr_00;
    uint *puVar2;
    uint uVar3;
    uint *puVar4;
    char *pcVar5;
    uint uVar6;
    uint uVar7;
    uchar hash_swap[32];
    uchar target_swap[32];
    char tmp42[4096];

    puVar4 = (uint *)(hash + 0x20);
    puVar2 = (uint *)(target + 0x20);
    do {
        puVar4 = puVar4 + -1;
        puVar2 = puVar2 + -1;
        if (*puVar2 < *puVar4) {
            bVar1 = false;
            goto LAB_000278f6;
        }
    } while ((*puVar2 <= *puVar4) && ((uint *)hash != puVar4));
    bVar1 = true;
LAB_000278f6:
    if (opt_debug) {
        uVar7 = *(uint *)(hash + 0x18);
        uVar3 = *(uint *)(hash + 0x1c);
        uVar6 = *(uint *)(hash + 0x14);
        hash_swap._0_4_ = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                          (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
        hash_swap._4_4_ = uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
                          (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
        hash_swap._8_4_ = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                          (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        uVar3 = *(uint *)(hash + 0x10);
        hash_swap._12_4_ = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                           (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
        uVar3 = *(uint *)(hash + 8);
        uVar6 = *(uint *)(hash + 0xc);
        hash_swap._16_4_ = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                           (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        uVar6 = *(uint *)hash;
        uVar7 = *(uint *)(hash + 4);
        hash_swap._20_4_ = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                           (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
        uVar3 = *(uint *)(target + 0x1c);
        hash_swap._24_4_ = uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
                           (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
        hash_swap._28_4_ = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                           (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        uVar6 = *(uint *)(target + 0x18);
        target_swap._0_4_ = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                            (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
        uVar7 = *(uint *)(target + 0x14);
        target_swap._4_4_ = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                            (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        uVar3 = *(uint *)(target + 0xc);
        target_swap._8_4_ = uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
                            (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
        uVar6 = *(uint *)(target + 0x10);
        target_swap._16_4_ = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                             (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
        target_swap._12_4_ = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                             (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        uVar7 = *(uint *)(target + 8);
        uVar6 = *(uint *)target;
        uVar3 = *(uint *)(target + 4);
        target_swap._20_4_ = uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
                             (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
        target_swap._28_4_ = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
                             (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
        target_swap._24_4_ = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10 |
                             (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
        __ptr = bin2hex(hash_swap, 0x20);
        __ptr_00 = bin2hex(target_swap, 0x20);
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            pcVar5 = "YES (hash <= target)";
            if (!bVar1) {
                pcVar5 = "no (false positive; hash > target)";
            }
            snprintf(tmp42, 0x1000, " Proof: %s\nTarget: %s\nTrgVal? %s", __ptr,
                     __ptr_00, pcVar5);
            _applog(7, tmp42, false);
        }
        free(__ptr);
        free(__ptr_00);
        return bVar1;
    }
    return bVar1;
}

/* WARNING: Unknown calling convention */

thread_q *tq_new(void)

{
    thread_q *ptVar1;

    ptVar1 = (thread_q *)calloc(1, 0x58);
    if (ptVar1 != (thread_q *)0x0) {
        (ptVar1->q).next = (list_head *)ptVar1;
        (ptVar1->q).prev = (list_head *)ptVar1;
        pthread_mutex_init((pthread_mutex_t *)&ptVar1->mutex,
                           (pthread_mutexattr_t *)0x0);
        pthread_cond_init((pthread_cond_t *)&ptVar1->cond,
                          (pthread_condattr_t *)0x0);
    }
    return ptVar1;
}

/* WARNING: Unknown calling convention */

void tq_free(thread_q *tq)

{
    thread_q *ptVar1;
    thread_q *ptVar2;
    thread_q *ptVar3;
    list_head *plVar4;

    if (tq != (thread_q *)0x0) {
        ptVar3 = (thread_q *)(tq->q).next;
        ptVar2 = (thread_q *)(ptVar3->q).next;
        while (ptVar1 = ptVar2, tq != ptVar3) {
            plVar4 = (ptVar3->q).prev;
            (ptVar1->q).prev = plVar4;
            plVar4->next = &ptVar1->q;
            free((void *)((int)&ptVar3[-1].cond + 0x2c));
            ptVar2 = (thread_q *)(ptVar1->q).next;
            ptVar3 = ptVar1;
        }
        pthread_cond_destroy((pthread_cond_t *)&tq->cond);
        pthread_mutex_destroy((pthread_mutex_t *)&tq->mutex);
        (*(code *)(undefined *)0x0)(tq);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void tq_freeze(thread_q *tq)

{
    tq_freezethaw(tq, true);
    return;
}

/* WARNING: Unknown calling convention */

void tq_thaw(thread_q *tq)

{
    tq_freezethaw(tq, false);
    return;
}

/* WARNING: Unknown calling convention */

_Bool tq_push(thread_q *tq, void *data)

{
    bool bVar1;
    undefined4 *__ptr;
    int iVar2;
    char *func;
    int line;
    list_head *plVar3;
    int line_00;
    list_head *plVar4;

    __ptr = (undefined4 *)calloc(1, 0xc);
    if (__ptr != (undefined4 *)0x0) {
        plVar4 = (list_head *)(__ptr + 1);
        *__ptr = data;
        __ptr[1] = plVar4;
        __ptr[2] = plVar4;
        iVar2 = pthread_mutex_lock((pthread_mutex_t *)&tq->mutex);
        if (iVar2 != 0) {
            _mutex_lock((pthread_mutex_t *)"tq_push", (char *)0x4f0, func,
                        line);
        }
        bVar1 = tq->frozen != false;
        if (bVar1) {
            free(__ptr);
        } else {
            plVar3 = (tq->q).prev;
            __ptr[1] = tq;
            (tq->q).prev = plVar4;
            __ptr[2] = plVar3;
            plVar3->next = plVar4;
        }
        pthread_cond_signal((pthread_cond_t *)&tq->cond);
        _mutex_unlock_noyield(&tq->mutex, "tq_push", (char *)0x4fb, line_00);
        (*selective_yield)();
        return !bVar1;
    }
    return false;
}

/* WARNING: Unknown calling convention */

void *tq_pop(thread_q *tq, timespec *abstime)

{
    int iVar1;
    list_head *plVar2;
    char *func;
    list_head *plVar3;
    int line;
    thread_q *extraout_r3;
    thread_q *extraout_r3_00;
    thread_q *line_00;
    thread_q *extraout_r3_01;
    thread_q *ptVar4;
    void *pvVar5;
    pthread_mutex_t *__mutex;

    __mutex = &tq->mutex;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)__mutex);
    if (iVar1 != 0) {
        _mutex_lock((pthread_mutex_t *)"tq_pop", (char *)0x506, func, line);
    }
    ptVar4 = (thread_q *)(tq->q).next;
    line_00 = ptVar4;
    if (tq == ptVar4) {
        if (abstime == (timespec *)0x0) {
            iVar1 = pthread_cond_wait((pthread_cond_t *)&tq->cond,
                                      (pthread_mutex_t *)__mutex);
            line_00 = extraout_r3_01;
        } else {
            iVar1 = pthread_cond_timedwait((pthread_cond_t *)&tq->cond,
                                           (pthread_mutex_t *)__mutex,
                                           (timespec *)abstime);
            line_00 = extraout_r3_00;
        }
        if (iVar1 != 0) {
            pvVar5 = (void *)0x0;
            goto LAB_00027b40;
        }
        line_00 = (thread_q *)(tq->q).next;
        if (ptVar4 == line_00) {
            pvVar5 = (void *)0x0;
            goto LAB_00027b40;
        }
    }
    plVar3 = (line_00->q).prev;
    plVar2 = (line_00->q).next;
    pvVar5 = (void *)line_00[-1].cond.__data.__g_signals[1];
    plVar2->prev = plVar3;
    plVar3->next = plVar2;
    (line_00->q).next = (list_head *)0x0;
    (line_00->q).prev = (list_head *)0x0;
    free((void *)((int)&line_00[-1].cond + 0x2c));
    line_00 = extraout_r3;
LAB_00027b40:
    _mutex_unlock_noyield(__mutex, "tq_pop", (char *)0x519, (int)line_00);
    (*selective_yield)();
    return pvVar5;
}

/* WARNING: Unknown calling convention */

void thr_info_join(thr_info *thr)

{
    if (thr == (thr_info *)0x0) {
        return;
    }
    if (thr->pth != 0) {
        pthread_join(thr->pth, (void **)0x0);
        thr->pth = 0;
    }
    sem_destroy((sem_t *)&thr->sem);
    return;
}

/* WARNING: Unknown calling convention */

void thr_info_cancel(thr_info *thr)

{
    if (thr == (thr_info *)0x0) {
        return;
    }
    if (thr->pth != 0) {
        pthread_cancel(thr->pth);
        thr->pth = 0;
    }
    sem_destroy((sem_t *)&thr->sem);
    return;
}

/* WARNING: Unknown calling convention */

void subtime(timeval *a, timeval *b)

{
    int iVar1;
    int iVar2;

    iVar1 = a->tv_sec - b->tv_sec;
    b->tv_sec = iVar1;
    iVar2 = a->tv_usec - b->tv_usec;
    b->tv_usec = iVar2;
    if (iVar2 < 0) {
        b->tv_sec = iVar1 + -1;
        b->tv_usec = iVar2 + 1000000;
    }
    return;
}

/* WARNING: Unknown calling convention */

void addtime(timeval *a, timeval *b)

{
    int iVar1;
    int iVar2;

    iVar1 = a->tv_sec + b->tv_sec;
    b->tv_sec = iVar1;
    iVar2 = a->tv_usec + b->tv_usec;
    b->tv_usec = iVar2;
    if (999999 < iVar2) {
        b->tv_sec = iVar1 + 1;
        b->tv_usec = iVar2 + -1000000;
    }
    return;
}

/* WARNING: Unknown calling convention */

_Bool time_more(timeval *a, timeval *b)

{
    undefined1 uVar1;
    int iVar2;
    int iVar3;

    iVar2 = a->tv_sec;
    iVar3 = b->tv_sec;
    if (iVar2 != iVar3) {
        if (iVar3 < iVar2) {
            a = (timeval *)0x1;
        }
        uVar1 = SUB41(a, 0);
        if (iVar2 <= iVar3) {
            uVar1 = 0;
        }
        return (_Bool)uVar1;
    }
    iVar3 = a->tv_usec;
    iVar2 = iVar3;
    if (iVar3 <= b->tv_usec) {
        iVar2 = 0;
    }
    uVar1 = (undefined1)iVar2;
    if (b->tv_usec < iVar3) {
        uVar1 = 1;
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

_Bool time_less(timeval *a, timeval *b)

{
    undefined1 uVar1;
    int iVar2;
    int iVar3;

    iVar2 = a->tv_sec;
    iVar3 = b->tv_sec;
    if (iVar2 != iVar3) {
        if (iVar2 < iVar3) {
            a = (timeval *)0x1;
        }
        uVar1 = SUB41(a, 0);
        if (iVar3 <= iVar2) {
            uVar1 = 0;
        }
        return (_Bool)uVar1;
    }
    iVar3 = a->tv_usec;
    iVar2 = iVar3;
    if (b->tv_usec <= iVar3) {
        iVar2 = 0;
    }
    uVar1 = (undefined1)iVar2;
    if (iVar3 < b->tv_usec) {
        uVar1 = 1;
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

void copy_time(timeval *dest, timeval *src)

{
    __suseconds_t _Var1;

    _Var1 = src->tv_usec;
    dest->tv_sec = src->tv_sec;
    dest->tv_usec = _Var1;
    return;
}

/* WARNING: Unknown calling convention */

void timespec_to_val(timeval *val, timespec *spec)

{
    val->tv_sec = spec->tv_sec;
    val->tv_usec = spec->tv_nsec / 1000;
    return;
}

/* WARNING: Unknown calling convention */

void timeval_to_spec(timespec *spec, timeval *val)

{
    spec->tv_sec = val->tv_sec;
    spec->tv_nsec = val->tv_usec * 1000;
    return;
}

void us_to_timeval(timeval *val, int64_t us)

{
    lldiv_t tvdiv;

    lldiv((lldiv_t *)&tvdiv, us, 1000000);
    val->tv_sec = (__time_t)tvdiv.quot;
    val->tv_usec = (__suseconds_t)tvdiv.rem;
    return;
}

void us_to_timespec(timespec *spec, int64_t us)

{
    lldiv_t tvdiv;

    lldiv((lldiv_t *)&tvdiv, us, 1000000);
    spec->tv_sec = (__time_t)tvdiv.quot;
    spec->tv_nsec = (int)tvdiv.rem * 1000;
    return;
}

void ms_to_timespec(timespec *spec, int64_t ms)

{
    lldiv_t tvdiv;

    lldiv((lldiv_t *)&tvdiv, ms, 1000);
    spec->tv_sec = (__time_t)tvdiv.quot;
    spec->tv_nsec = (int)tvdiv.rem * 1000000;
    return;
}

void ms_to_timeval(timeval *val, int64_t ms)

{
    lldiv_t tvdiv;

    lldiv((lldiv_t *)&tvdiv, ms, 1000);
    val->tv_sec = (__time_t)tvdiv.quot;
    val->tv_usec = (int)tvdiv.rem * 1000;
    return;
}

/* WARNING: Unknown calling convention */

void timeraddspec(timespec *a, timespec *b)

{
    __syscall_slong_t _Var1;
    int iVar2;
    int iVar3;
    __time_t _Var4;
    bool bVar5;
    bool bVar6;

    iVar2 = a->tv_sec + b->tv_sec;
    a->tv_sec = iVar2;
    iVar3 = a->tv_nsec + b->tv_nsec;
    a->tv_nsec = iVar3;
    if (iVar3 < 1000000000) {
        if (iVar3 < 0) {
            do {
                iVar3 = iVar3 + 1000000000;
                iVar2 = iVar2 + -1;
            } while (iVar3 < 0);
            a->tv_sec = iVar2;
            a->tv_nsec = iVar3;
        }
    } else {
        _Var4 = iVar2 + 1;
        _Var1 = iVar3 + -1000000000;
        bVar6 = SBORROW4(_Var1, 999999999);
        bVar5 = _Var1 != 999999999;
        if (999999999 < _Var1) {
            _Var4 = iVar2 + 2;
            _Var1 = -2000000000;
        }
        if (bVar5 && iVar3 + -1999999999 < 0 == bVar6) {
            _Var1 = _Var1 + iVar3;
        }
        a->tv_sec = _Var4;
        a->tv_nsec = _Var1;
    }
    return;
}

/* WARNING: Unknown calling convention */

char *Strcasestr(char *haystack, char *needle)

{
    int iVar1;
    int iVar2;
    size_t sVar3;
    size_t sVar4;
    __int32_t **pp_Var5;
    undefined1 *puVar6;
    char *pcVar7;
    byte *pbVar8;
    int iVar9;
    __int32_t *p_Var10;
    undefined1 uStack_21;

    if (needle == (char *)0x0 || haystack == (char *)0x0) {
        return (char *)0x0;
    }
    sVar3 = strlen(haystack);
    sVar4 = strlen(needle);
    if (sVar3 != 0 && sVar4 != 0) {
        iVar1 = -(sVar3 + 0xe & 0xfffffff8);
        iVar2 = -(sVar4 + 0xe & 0xfffffff8);
        pp_Var5 = __ctype_tolower_loc();
        p_Var10 = *pp_Var5;
        puVar6 = &uStack_21 + iVar1;
        pbVar8 = (byte *)(haystack + -1);
        iVar9 = 0;
        do {
            pbVar8 = pbVar8 + 1;
            iVar9 = iVar9 + 1;
            puVar6 = puVar6 + 1;
            *puVar6 = (char)p_Var10[*pbVar8];
        } while (iVar9 < (int)sVar3);
        pbVar8 = (byte *)(needle + -1);
        puVar6 = &uStack_21 + iVar2 + iVar1;
        iVar9 = 0;
        do {
            pbVar8 = pbVar8 + 1;
            iVar9 = iVar9 + 1;
            puVar6 = puVar6 + 1;
            *puVar6 = (char)p_Var10[*pbVar8];
        } while (iVar9 < (int)sVar4);
        pcVar7 =
            strstr(&stack0xffffffe0 + iVar1, &stack0xffffffe0 + iVar2 + iVar1);
        if (pcVar7 != (char *)0x0) {
            return haystack + ((int)pcVar7 - (int)(&stack0xffffffe0 + iVar1));
        }
    }
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *Strsep(char **stringp, char *delim)

{
    char *pcVar1;
    char *ret;
    char *__s;

    __s = *stringp;
    if ((__s != (char *)0x0) &&
        (pcVar1 = strpbrk(__s, delim), pcVar1 != (char *)0x0)) {
        *pcVar1 = '\0';
        *stringp = pcVar1 + 1;
        return __s;
    }
    *stringp = (char *)0x0;
    return __s;
}

/* WARNING: Unknown calling convention */

void cgtime(timeval *tv)

{
    gettimeofday((timeval *)tv, (__timezone_ptr_t)0x0);
    return;
}

/* WARNING: Unknown calling convention */

int cgtimer_to_ms(cgtimer_t *cgt)

{
    return cgt->tv_sec * 1000 + cgt->tv_nsec / 1000000;
}

/* WARNING: Unknown calling convention */

void cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)

{
    int iVar1;
    int iVar2;
    __time_t _Var3;
    bool bVar4;

    _Var3 = a->tv_sec - b->tv_sec;
    res->tv_sec = _Var3;
    iVar2 = b->tv_nsec;
    iVar1 = a->tv_nsec - iVar2;
    bVar4 = iVar1 < 0;
    if (bVar4) {
        _Var3 = _Var3 + -1;
        iVar2 = 1000000000;
    }
    if (bVar4) {
        iVar2 = iVar2 + iVar1;
        res->tv_sec = _Var3;
    } else {
        res->tv_nsec = iVar1;
    }
    if (bVar4) {
        res->tv_nsec = iVar2;
    }
    return;
}

/* WARNING: Unknown calling convention */

void cgtimer_time(cgtimer_t *ts_start)

{
    clock_gettime(1, (timespec *)ts_start);
    return;
}

/* WARNING: Unknown calling convention */

void cgsleep_ms_r(cgtimer_t *ts_start, int ms)

{
    int iVar1;
    int iVar2;
    bool bVar3;
    bool bVar4;
    timespec ts_end;

    ms_to_timespec(&ts_end, (longlong)ms);
    iVar2 = ts_end.tv_nsec + ts_start->tv_nsec;
    iVar1 = ts_end.tv_sec + ts_start->tv_sec;
    ts_end.tv_nsec = iVar2;
    ts_end.tv_sec = iVar1;
    if (iVar2 < 1000000000) {
        for (; ts_end.tv_nsec < 0;
             ts_end.tv_nsec = ts_end.tv_nsec + 1000000000) {
            ts_end.tv_sec = ts_end.tv_sec + -1;
        }
    } else {
        ts_end.tv_sec = iVar1 + 1;
        ts_end.tv_nsec = iVar2 + -1000000000;
        bVar4 = SBORROW4(ts_end.tv_nsec, 999999999);
        bVar3 = ts_end.tv_nsec != 999999999;
        if (999999999 < ts_end.tv_nsec) {
            ts_end.tv_sec = iVar1 + 2;
            ts_end.tv_nsec = -2000000000;
        }
        if (bVar3 && iVar2 + -1999999999 < 0 == bVar4) {
            ts_end.tv_nsec = ts_end.tv_nsec + iVar2;
        }
    }
    do {
        iVar1 = clock_nanosleep(1, 1, (timespec *)&ts_end, (timespec *)0x0);
    } while (iVar1 == 4);
    return;
}

void cgsleep_us_r(cgtimer_t *ts_start, int64_t us)

{
    int iVar1;
    int iVar2;
    bool bVar3;
    bool bVar4;
    timespec ts_end;

    us_to_timespec(&ts_end, us);
    iVar2 = ts_end.tv_nsec + ts_start->tv_nsec;
    iVar1 = ts_end.tv_sec + ts_start->tv_sec;
    ts_end.tv_nsec = iVar2;
    ts_end.tv_sec = iVar1;
    if (iVar2 < 1000000000) {
        for (; ts_end.tv_nsec < 0;
             ts_end.tv_nsec = ts_end.tv_nsec + 1000000000) {
            ts_end.tv_sec = ts_end.tv_sec + -1;
        }
    } else {
        ts_end.tv_sec = iVar1 + 1;
        ts_end.tv_nsec = iVar2 + -1000000000;
        bVar4 = SBORROW4(ts_end.tv_nsec, 999999999);
        bVar3 = ts_end.tv_nsec != 999999999;
        if (999999999 < ts_end.tv_nsec) {
            ts_end.tv_sec = iVar1 + 2;
            ts_end.tv_nsec = -2000000000;
        }
        if (bVar3 && iVar2 + -1999999999 < 0 == bVar4) {
            ts_end.tv_nsec = ts_end.tv_nsec + iVar2;
        }
    }
    do {
        iVar1 = clock_nanosleep(1, 1, (timespec *)&ts_end, (timespec *)0x0);
    } while (iVar1 == 4);
    return;
}

/* WARNING: Unknown calling convention */

void cgsleep_ms(int ms)

{
    cgtimer_t ts_start;

    clock_gettime(1, (timespec *)&ts_start);
    cgsleep_ms_r(&ts_start, ms);
    return;
}

void cgsleep_us(int64_t us)

{
    cgtimer_t ts_start;

    clock_gettime(1, (timespec *)&ts_start);
    cgsleep_us_r(&ts_start, us);
    return;
}

/* WARNING: Unknown calling convention */

double us_tdiff(timeval *end, timeval *start)

{
    int iVar1;

    iVar1 = end->tv_sec - start->tv_sec;
    if (iVar1 < 0x3d) {
        return (double)(longlong)(iVar1 * 1000000 +
                                  (end->tv_usec - start->tv_usec));
    }
    return 60000000.0;
}

/* WARNING: Unknown calling convention */

int ms_tdiff(timeval *end, timeval *start)

{
    int iVar1;

    iVar1 = end->tv_sec - start->tv_sec;
    if (iVar1 < 0xe11) {
        return iVar1 * 1000 + (end->tv_usec - start->tv_usec) / 1000;
    }
    return 3600000;
}

/* WARNING: Unknown calling convention */

double tdiff(timeval *end, timeval *start)

{
    return (double)(longlong)(end->tv_usec - start->tv_usec) / 1000000.0 +
           (double)(longlong)(end->tv_sec - start->tv_sec);
}

/* WARNING: Unknown calling convention */

void check_extranonce_option(pool *pool, char *url)

{
    char *__src;
    int iVar1;
    char extra_op[16];
    char tmp42[4096];

    __src = strchr(url, 0x23);
    if ((__src != (char *)0x0) && (pool->extranonce_subscribe == false)) {
        strcpy(extra_op, __src);
        *__src = '\0';
        iVar1 = strcmp(extra_op, "#xnsub");
        if (((iVar1 == 0) &&
             (pool->extranonce_subscribe = true, opt_debug != false)) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "Pool %d extranonce subscribing enabled.",
                     pool->pool_no);
            _applog(7, tmp42, false);
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

_Bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)

{
    char *pcVar1;
    char *pcVar2;
    uint uVar3;
    char *pcVar4;
    uint uVar5;
    int iVar6;
    char port[6];
    char url_address[256];

    *sockaddr_url = url;
    pcVar1 = strstr(url, "//");
    if (pcVar1 != (char *)0x0) {
        url = pcVar1 + 2;
    }
    pcVar2 = strchr(url, 0x5b);
    pcVar1 = strchr(url, 0x5d);
    pcVar4 = pcVar1;
    if (pcVar1 != (char *)0x0) {
        pcVar4 = (char *)0x1;
    }
    if (pcVar2 == (char *)0x0) {
        pcVar4 = (char *)0x0;
    }
    if (pcVar2 < pcVar1) {
        uVar5 = (uint)pcVar4 & 1;
    } else {
        uVar5 = 0;
    }
    if (uVar5 == 0) {
        pcVar1 = url;
    }
    pcVar1 = strchr(pcVar1, 0x3a);
    uVar3 = strlen(url);
    if (pcVar1 == (char *)0x0) {
        pcVar4 = (char *)0x0;
        iVar6 = 0;
    } else {
        iVar6 = ~((int)pcVar1 - (int)url) + uVar3;
        if (iVar6 < 1) {
            return false;
        }
        pcVar4 = pcVar1 + 1;
        uVar3 = (int)pcVar1 - (int)url;
    }
    if ((int)uVar3 < 1) {
        return false;
    }
    if (uVar5 != 0) {
        uVar3 = uVar3 - 2;
        url = url + 1;
    }
    snprintf(url_address, 0xfe, "%.*s", uVar3, url);
    if (iVar6 == 0) {
        port[0] = '8';
        port[1] = '0';
        port[2] = '\0';
    } else {
        snprintf(port, 6, "%.*s", iVar6, pcVar4);
        pcVar1 = strchr(port, 0x2f);
        if (pcVar1 != (char *)0x0) {
            *pcVar1 = '\0';
        }
    }
    pcVar1 = (char *)__strdup(port);
    *sockaddr_port = pcVar1;
    pcVar1 = (char *)__strdup(url_address);
    *sockaddr_url = pcVar1;
    return true;
}

/* WARNING: Unknown calling convention */

char *get_proxy(char *url, pool *pool)

{
    int iVar1;
    char *__dest;
    char *__src;
    char *pcVar2;
    int iVar3;
    int plen;
    size_t __n;
    char tmp42[4096];

    iVar3 = 0;
    pcVar2 = "http:";
    __n = 5;
    pool->rpc_proxy = (char *)0x0;
    while (true) {
        iVar1 = strncmp(url, pcVar2, __n);
        if (iVar1 == 0) {
            pcVar2 = strchr(url, 0x7c);
            if (pcVar2 != (char *)0x0) {
                *pcVar2 = '\0';
                __dest =
                    (char *)malloc((size_t)(pcVar2 + ((1 - (int)url) - __n)));
                pool->rpc_proxy = __dest;
                if (__dest == (char *)0x0) {
                    snprintf(tmp42, 0x1000,
                             "Failed to malloc rpc_proxy in %s %s():%d",
                             "util.c", "get_proxy", 0x371);
                    _applog(3, tmp42, true);
                    _quit(1);
                    __dest = pool->rpc_proxy;
                }
                __src = url + __n;
                url = pcVar2 + 1;
                strcpy(__dest, __src);
                extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url,
                                 &pool->sockaddr_proxy_port);
                pool->rpc_proxytype = proxynames[iVar3].proxytype;
            }
            return url;
        }
        iVar3 = iVar3 + 1;
        pcVar2 = proxynames[iVar3].name;
        if (pcVar2 == (char *)0x0)
            break;
        __n = strlen(pcVar2);
    }
    return url;
}

/* WARNING: Unknown calling convention */

_Bool sock_full(pool *pool)

{
    _Bool _Var1;

    if (*pool->sockbuf != '\0') {
        return true;
    }
    _Var1 = socket_full((pool *)pool->sock, 0);
    return _Var1;
}

/* WARNING: Unknown calling convention */

void _recalloc(void **ptr, size_t old, size_t new, char *file, char *func,
               int line)

{
    void *pvVar1;
    char tmp42[4096];

    if (new == old) {
        return;
    }
    pvVar1 = realloc(*ptr, new);
    *ptr = pvVar1;
    if (pvVar1 == (void *)0x0) {
        snprintf(tmp42, 0x1000, "Failed to realloc in %s %s():%d", file, func,
                 line);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (new <= old) {
        return;
    }
    memset((void *)((int)*ptr + old), 0, new - old);
    return;
}

/* WARNING: Unknown calling convention */

void suspend_stratum(pool *pool)

{
    int iVar1;
    int *piVar2;
    pthread_mutex_t *__mutex;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Closing socket for stratum pool %d",
                 pool->pool_no);
        _applog(7, tmp42, false);
    }
    __mutex = &pool->stratum_lock;
    iVar1 = pthread_mutex_lock((pthread_mutex_t *)__mutex);
    if (iVar1 == 0) {
        __suspend_stratum(pool);
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)__mutex);
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "util.c", "suspend_stratum", 0xd1a);
        _applog(3, tmp42, true);
        _quit(1);
        __suspend_stratum(pool);
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)__mutex);
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "util.c", "suspend_stratum", 0xd1c);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    return;
}

/* WARNING: Unknown calling convention */

_Bool stratum_send(pool *pool, char *s, ssize_t len)

{
    undefined1 uVar1;
    int iVar2;
    int *piVar3;
    send_ret sVar4;
    char tmp42[4096];

    if (((opt_protocol) && (opt_debug)) &&
        ((use_syslog || ((opt_log_output || (6 < opt_log_level)))))) {
        snprintf(tmp42, 0x1000, "SEND: %s", s);
        _applog(7, tmp42, false);
        iVar2 = pthread_mutex_lock((pthread_mutex_t *)&pool->stratum_lock);
        if (iVar2 != 0)
            goto LAB_000285f2;
    LAB_0002854c:
        if (pool->stratum_active == false)
            goto LAB_00028554;
    LAB_0002863a:
        sVar4 = __stratum_send(pool, s, len);
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&pool->stratum_lock);
        if (iVar2 != 0) {
        LAB_00028562:
            piVar3 = __errno_location();
            snprintf(tmp42, 0x1000,
                     "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                     *piVar3, "util.c", "stratum_send", 0x768);
            _applog(3, tmp42, true);
            _quit(1);
        }
        (*selective_yield)();
        if (sVar4 == SEND_SENDFAIL) {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                builtin_strncpy(tmp42, "Failed to send in stratum_send", 0x1f);
                _applog(7, tmp42, false);
                suspend_stratum(pool);
                return false;
            }
        } else {
            if (sVar4 == SEND_INACTIVE)
                goto LAB_000286d0;
            if (sVar4 != SEND_SELECTFAIL) {
                return sVar4 == SEND_OK;
            }
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "Write select failed on pool %d sock",
                         pool->pool_no);
                _applog(7, tmp42, false);
            }
        }
        suspend_stratum(pool);
        uVar1 = 0;
    } else {
        iVar2 = pthread_mutex_lock((pthread_mutex_t *)&pool->stratum_lock);
        if (iVar2 == 0)
            goto LAB_0002854c;
    LAB_000285f2:
        piVar3 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar3,
                 "util.c", "stratum_send", 0x765);
        _applog(3, tmp42, true);
        _quit(1);
        if (pool->stratum_active != false)
            goto LAB_0002863a;
    LAB_00028554:
        sVar4 = SEND_INACTIVE;
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&pool->stratum_lock);
        if (iVar2 != 0)
            goto LAB_00028562;
        (*selective_yield)();
    LAB_000286d0:
        uVar1 = opt_debug;
        if (opt_debug != false) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (6 < opt_log_level)) {
                builtin_strncpy(
                    tmp42, "Stratum send failed due to no pool stratum_activ",
                    0x30);
                tmp42[0x30] = 'e';
                tmp42[0x31] = '\0';
                _applog(7, tmp42, false);
                return false;
            }
            uVar1 = 0;
        }
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

char *recv_line(pool *pool)

{
    undefined4 uVar1;
    _Bool _Var2;
    char *pcVar3;
    size_t sVar4;
    size_t sVar5;
    int *piVar6;
    ssize_t sVar7;
    uint uVar8;
    uint uVar9;
    uint uVar10;
    int iVar11;
    char *__s;
    int iVar12;
    timeval rstart;
    timeval now;
    char tmp42_1[4096];
    char tmp42[4096];

    __s = pool->sockbuf;
    pcVar3 = strchr(__s, 10);
    if (pcVar3 == (char *)0x0) {
        gettimeofday((timeval *)&rstart, (__timezone_ptr_t)0x0);
        _Var2 = socket_full((pool *)pool->sock, 0x3c);
        uVar1 = tmp42._40_4_;
        if (!_Var2) {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                builtin_strncpy(
                    tmp42, "Timed out waiting for data on socket_full", 0x2a);
                tmp42._42_2_ = SUB42(uVar1, 2);
                _applog(7, tmp42, false);
            }
            goto LAB_00028a52;
        }
        while (true) {
            memset(tmp42, 0, 0x2000);
            sVar7 = recv(pool->sock, tmp42, 0x1ffc, 0);
            if (sVar7 == 0)
                break;
            gettimeofday((timeval *)&now, (__timezone_ptr_t)0x0);
            iVar11 =
                (int)(longlong)((double)(longlong)(now.tv_usec -
                                                   rstart.tv_usec) /
                                    1000000.0 +
                                (double)(longlong)(now.tv_sec - rstart.tv_sec));
            if (sVar7 < 0) {
                piVar6 = __errno_location();
                if ((*piVar6 != 0xb) ||
                    (_Var2 = socket_full((pool *)pool->sock, 0x3c - iVar11),
                     !_Var2)) {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        builtin_strncpy(
                            tmp42_1, "Failed to recv sock in recv_line", 0x20);
                        tmp42_1._32_2_ = tmp42_1._32_2_ & 0xff00;
                        _applog(7, tmp42_1, false);
                    }
                    goto LAB_00028aae;
                }
            } else {
                sVar4 = strlen(tmp42);
                pcVar3 = pool->sockbuf;
                sVar5 = strlen(pcVar3);
                uVar8 = sVar4 + sVar5 + 1;
                if (pool->sockbuf_size <= uVar8) {
                    sVar4 = (uVar8 & 0xffffe000) + 0x2000;
                    pcVar3 = (char *)realloc(pcVar3, sVar4);
                    pool->sockbuf = pcVar3;
                    if (pcVar3 == (char *)0x0) {
                        snprintf(tmp42_1, 0x1000,
                                 "Failed to realloc pool sockbuf in %s %s():%d",
                                 "util.c", "recalloc_sock", 0x7cd);
                        _applog(3, tmp42_1, true);
                        _quit(1);
                        pcVar3 = pool->sockbuf;
                    }
                    memset(pcVar3 + sVar5, 0, sVar4 - sVar5);
                    pcVar3 = pool->sockbuf;
                    pool->sockbuf_size = sVar4;
                }
                strcat(pcVar3, tmp42);
            }
            __s = pool->sockbuf;
            if ((0x3b < iVar11) ||
                (pcVar3 = strchr(__s, 10), pcVar3 != (char *)0x0))
                goto LAB_000287d0;
        }
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            builtin_strncpy(tmp42_1, "Socket closed waiting in recv_li", 0x20);
            tmp42_1[0x20] = 'n';
            tmp42_1[0x21] = 'e';
            tmp42_1[0x22] = '\0';
            _applog(7, tmp42_1, false);
        }
    LAB_00028aae:
        suspend_stratum(pool);
        __s = pool->sockbuf;
    }
LAB_000287d0:
    sVar4 = strlen(__s);
    pcVar3 = strtok(__s, "\n");
    if (pcVar3 != (char *)0x0) {
        pcVar3 = (char *)__strdup();
        sVar5 = strlen(pcVar3);
        if ((int)(sVar5 + 1) < (int)sVar4) {
            memmove(pool->sockbuf, pool->sockbuf + sVar5 + 1,
                    (sVar4 - sVar5) + 1);
        } else {
            *pool->sockbuf = '\0';
        }
        _Var2 = opt_protocol;
        uVar9 = (uint)(pool->cgminer_pool_stats).times_received;
        uVar8 = (uint)(pool->cgminer_pool_stats).bytes_received;
        iVar12 = *(int *)((int)&(pool->cgminer_pool_stats).bytes_received + 4);
        *(uint *)((int)&(pool->cgminer_pool_stats).times_received + 4) =
            *(int *)((int)&(pool->cgminer_pool_stats).times_received + 4) +
            (uint)(0xfffffffe < uVar9);
        uVar10 = (uint)(pool->cgminer_pool_stats).net_bytes_received;
        *(uint *)&(pool->cgminer_pool_stats).times_received = uVar9 + 1;
        iVar11 =
            *(int *)((int)&(pool->cgminer_pool_stats).net_bytes_received + 4);
        *(uint *)&(pool->cgminer_pool_stats).bytes_received = uVar8 + sVar5;
        *(uint *)((int)&(pool->cgminer_pool_stats).bytes_received + 4) =
            iVar12 + (uint)CARRY4(uVar8, sVar5);
        *(uint *)&(pool->cgminer_pool_stats).net_bytes_received =
            uVar10 + sVar5;
        *(uint *)((int)&(pool->cgminer_pool_stats).net_bytes_received + 4) =
            iVar11 + (uint)CARRY4(uVar10, sVar5);
        if (_Var2 == false) {
            return pcVar3;
        }
        if (opt_debug == false) {
            return pcVar3;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
            return pcVar3;
        }
        snprintf(tmp42, 0x1000, "RECVD: %s", pcVar3);
        _applog(7, tmp42, false);
        return pcVar3;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42,
                        "Failed to parse a \\n terminated string in recv_line",
                        0x34);
        _applog(7, tmp42, false);
    }
LAB_00028a52:
    clear_sock(pool);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

void extranonce_subscribe_stratum(pool *pool)

{
    return;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

_Bool initiate_stratum(pool *pool)

{
    bool bVar1;
    bool bVar2;
    _Bool _Var3;
    char cVar4;
    int iVar5;
    uint uVar6;
    uint *puVar7;
    uint __fd;
    undefined4 uVar8;
    int iVar9;
    size_t sVar10;
    send_ret sVar11;
    ssize_t sVar12;
    long lVar13;
    char *pcVar14;
    json_t *val;
    json_t *json;
    int *piVar15;
    undefined4 uVar16;
    undefined4 uVar17;
    size_t sVar18;
    char *pcVar19;
    addrinfo *paVar20;
    pthread_rwlock_t *__rwlock;
    uint uVar21;
    char *local_3380;
    char *local_337c;
    json_t *local_3370;
    addrinfo *servinfo;
    socklen_t len;
    int err_1;
    timeval tv_timeout;
    addrinfo hints;
    json_error_t err;
    fd_set rw;
    char tmp42[4096];
    char s[8192];

    local_3370 = (json_t *)0x0;
    bVar1 = false;
LAB_00028bec:
    iVar5 = pthread_mutex_lock((pthread_mutex_t *)&pool->stratum_lock);
    if (iVar5 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar15,
                 "util.c", "setup_stratum_socket", 0xc5f);
        _applog(3, tmp42, true);
        _quit(1);
    }
    pool->stratum_active = false;
    if (pool->sock != 0) {
        close(pool->sock);
    }
    pool->sock = 0;
    iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&pool->stratum_lock);
    if (iVar5 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar15,
                 "util.c", "setup_stratum_socket", 0xc64);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    memset(&hints, 0, 0x20);
    pcVar14 = opt_socks_proxy;
    hints.ai_socktype = 1;
    if (pool->rpc_proxy == (char *)0x0) {
        if (opt_socks_proxy == (char *)0x0) {
            local_337c = pool->sockaddr_url;
        } else {
            pool->rpc_proxy = opt_socks_proxy;
            extract_sockaddr(pcVar14, &pool->sockaddr_proxy_url,
                             &pool->sockaddr_proxy_port);
            pool->rpc_proxytype = 3;
            local_337c = pool->sockaddr_url;
            if (pool->rpc_proxy != (char *)0x0)
                goto LAB_00028c34;
        }
        local_3380 = pool->stratum_port;
    } else {
    LAB_00028c34:
        local_337c = pool->sockaddr_proxy_url;
        local_3380 = pool->sockaddr_proxy_port;
    }
    iVar5 = getaddrinfo(local_337c, local_3380, (addrinfo *)&hints,
                        (addrinfo **)&servinfo);
    if (iVar5 == 0) {
        if (servinfo == (addrinfo *)0x0) {
        LAB_00028e24:
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "Failed to connect to stratum on %s:%s",
                         local_337c, local_3380);
                _applog(7, tmp42, false);
            }
            freeaddrinfo((addrinfo *)servinfo);
            goto LAB_00028cb2;
        }
        paVar20 = servinfo;
        while (__fd = socket(paVar20->ai_family, paVar20->ai_socktype,
                             paVar20->ai_protocol),
               __fd == 0xffffffff) {
            if ((opt_debug == false) ||
                (((use_syslog == false && (opt_log_output == false)) &&
                  (opt_log_level < 7))))
                goto LAB_00028db0;
            pcVar14 = tmp42;
            uVar8._0_1_ = 'F';
            uVar8._1_1_ = 'a';
            uVar8._2_1_ = 'i';
            uVar8._3_1_ = 'l';
            uVar16._0_1_ = 'e';
            uVar16._1_1_ = 'd';
            uVar16._2_1_ = ' ';
            uVar16._3_1_ = 's';
            uVar17._0_1_ = 'o';
            uVar17._1_1_ = 'c';
            uVar17._2_1_ = 'k';
            uVar17._3_1_ = 'e';
        LAB_00028e0c:
            *(undefined4 *)pcVar14 = uVar8;
            *(undefined4 *)(pcVar14 + 4) = uVar16;
            *(undefined4 *)(pcVar14 + 8) = uVar17;
            pcVar14[0xc] = 't';
            pcVar14[0xd] = '\0';
            _applog(7, tmp42, false);
            paVar20 = paVar20->ai_next;
        joined_r0x00028e1e:
            if (paVar20 == (addrinfo *)0x0)
                goto LAB_00028e24;
        }
        uVar6 = fcntl(__fd, 3, 0);
        fcntl(__fd, 4, uVar6 | 0x800);
        iVar5 =
            connect(__fd, (sockaddr *)paVar20->ai_addr, paVar20->ai_addrlen);
        if (iVar5 == -1) {
            tv_timeout.tv_usec = 0;
            tv_timeout.tv_sec = 1;
            puVar7 = (uint *)__errno_location();
            if (*puVar7 == 0x73) {
                uVar6 = __fd & 0x1f;
                uVar21 = __fd + 0x1f & (int)__fd >> 0x20;
                if (*puVar7 < 0x73) {
                    uVar21 = __fd;
                }
                iVar5 = (int)uVar21 >> 5;
                if ((int)__fd < 1) {
                    uVar6 = -(-__fd & 0x1f);
                }
                uVar6 = 1 << (uVar6 & 0xff);
                while (true) {
                    pcVar14 = err.text + 0x9c;
                    do {
                        pcVar14 = pcVar14 + 4;
                        pcVar14[0] = '\0';
                        pcVar14[1] = '\0';
                        pcVar14[2] = '\0';
                        pcVar14[3] = '\0';
                    } while (rw.fds_bits + 0x1f != (__fd_mask *)pcVar14);
                    ((fd_set *)&rw)->fds_bits[iVar5] =
                        rw.fds_bits[iVar5] | uVar6;
                    iVar9 = select(__fd + 1, (fd_set *)0x0, (fd_set *)&rw,
                                   (fd_set *)0x0, (timeval *)&tv_timeout);
                    if (0 < iVar9)
                        break;
                    if ((iVar9 == 0) || (*puVar7 != 4))
                        goto LAB_00028ed6;
                }
                if ((uVar6 & rw.fds_bits[iVar5]) != 0) {
                    len = 4;
                    iVar5 = getsockopt(__fd, 1, 4, &err_1, &len);
                    uVar8 = tmp42._24_4_;
                    if ((iVar5 == 0) && (err_1 == 0)) {
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            builtin_strncpy(tmp42, "Succeeded delayed connect",
                                            0x1a);
                            tmp42._26_2_ = SUB42(uVar8, 2);
                            _applog(7, tmp42, false);
                        }
                        goto LAB_00028fb4;
                    }
                }
            LAB_00028ed6:
                close(__fd);
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    tmp42[0] = 'S';
                    tmp42[1] = 'e';
                    tmp42[2] = 'l';
                    tmp42[3] = 'e';
                    tmp42[4] = 'c';
                    tmp42[5] = 't';
                    tmp42[6] = ' ';
                    tmp42[7] = 't';
                    tmp42[8] = 'i';
                    tmp42[9] = 'm';
                    tmp42[10] = 'e';
                    tmp42[0xb] = 'o';
                    tmp42[0xc] = 'u';
                    tmp42[0xd] = 't';
                    tmp42[0xe] = '/';
                    tmp42[0xf] = 'f';
                    pcVar14 = tmp42 + 0x10;
                    uVar8._0_1_ = 'a';
                    uVar8._1_1_ = 'i';
                    uVar8._2_1_ = 'l';
                    uVar8._3_1_ = 'e';
                    uVar16._0_1_ = 'd';
                    uVar16._1_1_ = ' ';
                    uVar16._2_1_ = 'c';
                    uVar16._3_1_ = 'o';
                    uVar17._0_1_ = 'n';
                    uVar17._1_1_ = 'n';
                    uVar17._2_1_ = 'e';
                    uVar17._3_1_ = 'c';
                    goto LAB_00028e0c;
                }
            } else {
                close(__fd);
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    builtin_strncpy(tmp42, "Failed sock connect", 0x14);
                    _applog(7, tmp42, false);
                }
            }
        LAB_00028db0:
            paVar20 = paVar20->ai_next;
            goto joined_r0x00028e1e;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            builtin_strncpy(tmp42, "Succeeded immediate connect", 0x1c);
            _applog(4, tmp42, false);
        }
    LAB_00028fb4:
        block_socket(__fd);
        freeaddrinfo((addrinfo *)servinfo);
        if (pool->rpc_proxy == (char *)0x0)
            goto LAB_000290e4;
        switch (pool->rpc_proxytype) {
        case 0:
            _Var3 = http_negotiate(pool, __fd, false);
            if (_Var3)
                goto LAB_000290e4;
            break;
        case 1:
            _Var3 = http_negotiate(pool, __fd, true);
            if (_Var3)
                goto LAB_000290e4;
            break;
        case 2:
            bVar2 = socks4_negotiate(pool, __fd, false);
            goto joined_r0x000290da;
        case 3:
        case 5:
            rw.fds_bits[0] = CONCAT13(rw.fds_bits[0]._3_1_, 0x105);
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000,
                         "Attempting to negotiate with %s:%s SOCKS5 proxy",
                         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);
                _applog(7, tmp42, false);
            }
            send(__fd, &rw, 3, 0);
            sVar12 = recv(__fd, tmp42, 1, 0);
            if ((((sVar12 == -1) || (tmp42[0] != '\x05')) ||
                 (sVar12 = recv(__fd, tmp42, 1, 0), sVar12 == -1)) ||
                (((uint)rw.fds_bits[0] >> 0x10 & 0xff) !=
                 (tmp42._0_4_ & 0xff))) {
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 4))
                    goto LAB_000298d4;
                pcVar14 = pool->sockaddr_proxy_url;
                pcVar19 = pool->sockaddr_proxy_port;
            } else {
                pcVar14 = pool->sockaddr_url;
                rw.fds_bits[0] = 0x3000105;
                sVar10 = strlen(pcVar14);
                if (0xfe < sVar10) {
                    sVar10 = 0xff;
                }
                rw.fds_bits[1]._0_1_ = (undefined1)sVar10;
                memcpy((void *)((int)rw.fds_bits + 5), pcVar14, sVar10);
                lVar13 = strtol(pool->stratum_port, (char **)0x0, 10);
                *(char *)((int)rw.fds_bits + sVar10 + 6) = (char)lVar13;
                *(char *)((int)rw.fds_bits + sVar10 + 5) =
                    (char)((uint)lVar13 >> 8);
                send(__fd, &rw, sVar10 + 7, 0);
                sVar12 = recv(__fd, tmp42, 1, 0);
                if (((sVar12 != -1) && (tmp42[0] == '\x05')) &&
                    ((sVar12 = recv(__fd, tmp42, 1, 0),
                      sVar12 != -1 && ((tmp42._0_4_ & 0xff) == 0)))) {
                    recv(__fd, tmp42, 1, 0);
                    sVar12 = recv(__fd, tmp42, 1, 0);
                    if (sVar12 != -1) {
                        if ((tmp42._0_4_ & 0xff) == 1) {
                            iVar5 = 4;
                            do {
                                recv(__fd, tmp42, 1, 0);
                                iVar5 = iVar5 + -1;
                            } while (iVar5 != 0);
                        } else {
                            if ((tmp42._0_4_ & 0xff) != 3)
                                goto LAB_00029654;
                            sVar12 = recv(__fd, tmp42, 1, 0);
                            iVar5 = 0;
                            if (sVar12 == -1) {
                                uVar6 = 0xffffffff;
                            } else {
                                uVar6 = tmp42._0_4_ & 0xff;
                            }
                            while (iVar5 < (int)uVar6) {
                                recv(__fd, tmp42, 1, 0);
                                iVar5 = iVar5 + 1;
                            }
                        }
                        recv(__fd, tmp42, 1, 0);
                        recv(__fd, tmp42, 1, 0);
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            snprintf(
                                tmp42, 0x1000,
                                "Success negotiating with %s:%s SOCKS5 proxy",
                                pool->sockaddr_proxy_url,
                                pool->sockaddr_proxy_port);
                            _applog(7, tmp42, false);
                        }
                        goto LAB_000290e4;
                    }
                }
            LAB_00029654:
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 4))
                    break;
                pcVar19 = pool->sockaddr_proxy_port;
                pcVar14 = pool->sockaddr_proxy_url;
            }
            snprintf(tmp42, 0x1000, "Bad response from %s:%s SOCKS5 server",
                     pcVar14, pcVar19);
            _applog(4, tmp42, false);
            break;
        case 4:
            goto switchD_00028fd4_caseD_4;
        default:
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Unsupported proxy type for %s:%s",
                         pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);
                _applog(4, tmp42, false);
                break;
            }
        LAB_000298d4:
            cVar4 = '\0';
            if (opt_debug != false)
                goto joined_r0x000298e2;
            goto LAB_000291da;
        }
    } else {
        if (pool->probed == false) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Failed to resolve (?wrong URL) %s:%s",
                         local_337c, local_3380);
                _applog(4, tmp42, false);
            }
            pool->probed = true;
            goto LAB_00028cb2;
        }
        if (opt_debug == false)
            goto LAB_000291da;
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (cVar4 = '\0', opt_log_level < 7))
            goto LAB_00028cc4;
        snprintf(tmp42, 0x1000, "Failed to getaddrinfo for %s:%s", local_337c,
                 local_3380);
        _applog(7, tmp42, false);
    }
LAB_00028cb2:
    if (opt_debug == false)
        goto LAB_000291da;
    cVar4 = '\0';
LAB_00028cc4:
    if (use_syslog == false) {
    joined_r0x000298e2:
        if ((opt_log_output == false) && (opt_log_level < 7))
            goto LAB_00028cf8;
    }
    builtin_strncpy(tmp42, "Initiate stratum failed", 0x18);
    _applog(7, tmp42, false);
LAB_00028cf8:
    if (cVar4 != '\0') {
    LAB_000291d4:
        suspend_stratum(pool);
    }
LAB_000291da:
    cVar4 = '\0';
    if (local_3370 == (json_t *)0x0) {
        cVar4 = '\0';
    } else {
    LAB_0002930a:
        if ((local_3370->refcount != 0xffffffff) &&
            (sVar18 = local_3370->refcount - 1, local_3370->refcount = sVar18,
             sVar18 == 0)) {
            json_delete(local_3370);
            return (_Bool)cVar4;
        }
    }
    return (_Bool)cVar4;
switchD_00028fd4_caseD_4:
    bVar2 = socks4_negotiate(pool, __fd, true);
joined_r0x000290da:
    if (!bVar2)
        goto LAB_00028cb2;
LAB_000290e4:
    if (pool->sockbuf == (char *)0x0) {
        pcVar14 = (char *)calloc(0x2000, 1);
        pool->sockbuf = pcVar14;
        if (pcVar14 == (char *)0x0) {
            snprintf(tmp42, 0x1000,
                     "Failed to calloc pool sockbuf in %s %s():%d", "util.c",
                     "setup_stratum_socket", 0xcef);
            _applog(3, tmp42, true);
            _quit(1);
            pool->sockbuf_size = 0x2000;
        } else {
            pool->sockbuf_size = 0x2000;
        }
    }
    pool->sock = __fd;
    tmp42[0] = '\x1e';
    tmp42[1] = '\0';
    tmp42[2] = '\0';
    tmp42[3] = '\0';
    rw.fds_bits[0] = 0x2d;
    tv_timeout.tv_sec = 1;
    uVar6 = fcntl(__fd, 3, 0);
    fcntl(__fd, 4, uVar6 | 0x800);
    setsockopt(__fd, 1, 9, &tv_timeout, 4);
    if (opt_delaynet == false) {
        fcntl(__fd, 2, 1);
    }
    setsockopt(__fd, 6, 1, &tv_timeout, 4);
    setsockopt(__fd, 6, 6, &tv_timeout, 4);
    setsockopt(__fd, 6, 4, &rw, 4);
    setsockopt(__fd, 6, 5, tmp42, 4);
    iVar5 = swork_id;
    if (bVar1) {
        clear_sock(pool);
        swork_id = swork_id + 1;
        sprintf(
            s,
            "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}");
    } else {
        swork_id = swork_id + 1;
        if (pool->sessionid == (char *)0x0) {
            sprintf(s,
                    "{\"id\":%d, \"method\":\"mining.subscribe\", "
                    "\"params\":[\"cgminer/4.9.0\", null, \"%s\", \"%s\"]}",
                    iVar5, pool->sockaddr_url, pool->stratum_port);
        } else {
            sprintf(s, "{\"id\": %d, \"method\": \"mining.subscribe\", "
                       "\"params\": [\"cgminer/4.9.0\", \"%s\"]}");
        }
    }
    sVar10 = strlen(s);
    sVar11 = __stratum_send(pool, s, sVar10);
    if (sVar11 != SEND_OK) {
        if (opt_debug == false)
            goto LAB_000291d4;
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (cVar4 = opt_debug, 6 < opt_log_level)) {
            builtin_strncpy(tmp42, "Failed to send s in initiate_stratum",
                            0x24);
            tmp42._36_4_ = tmp42._36_4_ & 0xffffff00;
            _applog(7, tmp42, false);
            goto LAB_00029372;
        }
        goto LAB_00028cc4;
    }
    _Var3 = socket_full((pool *)pool->sock, 0x3c);
    if (!_Var3) {
        if (opt_debug == false)
            goto LAB_000291d4;
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (cVar4 = opt_debug, opt_log_level < 7))
            goto LAB_00028cc4;
        builtin_strncpy(
            tmp42, "Timed out waiting for response in initiate_strat", 0x30);
        tmp42[0x30] = 'u';
        tmp42[0x31] = 'm';
        tmp42[0x32] = '\0';
        _applog(7, tmp42, false);
    LAB_00029372:
        cVar4 = opt_debug;
        if (opt_debug != false)
            goto LAB_00028cc4;
        goto LAB_000291d4;
    }
    pcVar14 = recv_line(pool);
    if (pcVar14 == (char *)0x0)
        goto LAB_00029372;
    local_3370 = json_loads(pcVar14, 0, &err);
    free(pcVar14);
    if (local_3370 != (json_t *)0x0) {
        val = json_object_get(local_3370, "result");
        json = json_object_get(local_3370, "error");
        if ((val == (json_t *)0x0) || (val->type == JSON_NULL)) {
            if (json != (json_t *)0x0)
                goto LAB_00029746;
            pcVar14 = (char *)malloc(0x11);
            if (pcVar14 != (char *)0x0) {
                builtin_strncpy(pcVar14, "(unknown reason)", 0x11);
            }
        LAB_0002974e:
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "JSON-RPC decode failed: %s", pcVar14);
                _applog(7, tmp42, false);
            }
            free(pcVar14);
            goto LAB_000297ac;
        }
        if ((json != (json_t *)0x0) && (json->type != JSON_NULL)) {
        LAB_00029746:
            pcVar14 = json_dumps(json, 3);
            goto LAB_0002974e;
        }
        cVar4 = parse_extranonce_equihash(pool, val, 1);
        if (!(bool)cVar4) {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "%s: Failed to get parse extranonce.",
                         "initiate_stratum");
                _applog(7, tmp42, false);
            }
            goto LAB_000297ac;
        }
        if (pool->stratum_url == (char *)0x0) {
            pool->stratum_url = pool->sockaddr_url;
        }
        _Var3 = opt_protocol;
        pool->stratum_active = true;
        *(undefined4 *)&pool->sdiff = 0;
        *(undefined4 *)((int)&pool->sdiff + 4) = 0x3ff00000;
        if (((_Var3 != false) && (opt_debug != false)) &&
            ((use_syslog != false ||
              ((opt_log_output != false || (6 < opt_log_level)))))) {
            snprintf(tmp42, 0x1000,
                     "Pool %d confirmed mining.subscribe with extranonce1 %s "
                     "extran2size %d",
                     pool->pool_no, pool->nonce1, pool->n2size);
            _applog(7, tmp42, false);
        }
        _Var3 = pool->extranonce_subscribe;
        if (_Var3 != false) {
            swork_id = swork_id + 1;
            sprintf(s, "{\"id\": %d, \"method\": "
                       "\"mining.extranonce.subscribe\", \"params\": []}");
            sVar10 = strlen(s);
            stratum_send(pool, s, sVar10);
            pcVar14 = recv_line(pool);
            cVar4 = _Var3;
            if (pcVar14 == (char *)0x0) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    builtin_strncpy(tmp42,
                                    "recv mining.extranonce.subscribe failed\n",
                                    0x28);
                    tmp42._40_4_ = tmp42._40_4_ & 0xffffff00;
                    _applog(3, tmp42, false);
                }
            } else {
                free(pcVar14);
            }
        }
        goto LAB_0002930a;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "JSON decode failed(%d): %s", err.line,
                 err.text);
        _applog(7, tmp42, false);
    }
LAB_000297ac:
    bVar1 = (bool)(bVar1 ^ 1);
    if (!bVar1)
        goto LAB_00029372;
    iVar5 = pthread_mutex_lock((pthread_mutex_t *)&pool->data_lock);
    if (iVar5 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar15,
                 "util.c", "initiate_stratum", 0xe18);
        _applog(3, tmp42, true);
        _quit(1);
    }
    __rwlock = &(pool->data_lock).rwlock;
    iVar5 = pthread_rwlock_wrlock((pthread_rwlock_t *)__rwlock);
    if (iVar5 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *piVar15,
                 "util.c", "initiate_stratum", 0xe18);
        _applog(3, tmp42, true);
        _quit(1);
    }
    free(pool->sessionid);
    free(pool->nonce1);
    pool->nonce1 = (char *)0x0;
    pool->sessionid = (char *)0x0;
    iVar5 = pthread_rwlock_unlock((pthread_rwlock_t *)__rwlock);
    if (iVar5 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar15,
                 "util.c", "initiate_stratum", 0xe1c);
        _applog(3, tmp42, true);
        _quit(1);
    }
    iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&pool->data_lock);
    if (iVar5 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar15,
                 "util.c", "initiate_stratum", 0xe1c);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Failed to resume stratum, trying afresh", 0x28);
        _applog(7, tmp42, false);
    }
    if (((local_3370 != (json_t *)0x0) &&
         (local_3370->refcount != 0xffffffff)) &&
        (sVar18 = local_3370->refcount - 1, local_3370->refcount = sVar18,
         sVar18 == 0)) {
        json_delete(local_3370);
    }
    goto LAB_00028bec;
}

/* WARNING: Unknown calling convention */

_Bool restart_stratum(pool *pool)

{
    _Bool _Var1;

    if (pool->stratum_active != false) {
        suspend_stratum(pool);
    }
    _Var1 = initiate_stratum(pool);
    if ((_Var1) && (((pool->extranonce_subscribe == false ||
                      (_Var1 = subscribe_extranonce(pool), _Var1)) &&
                     (_Var1 = auth_stratum(pool), _Var1)))) {
        stratum_resumed(pool);
        return _Var1;
    }
    pool_died(pool);
    return false;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

_Bool parse_method(pool *pool, char *s)

{
    bool bVar1;
    _Bool _Var2;
    undefined1 uVar3;
    json_t *json;
    json_t *pjVar4;
    json_t *json_00;
    json_t *val;
    char *pcVar5;
    int iVar6;
    undefined4 uVar7;
    size_t sVar8;
    char *__ptr;
    char *__s;
    char *__s_00;
    char *pcVar9;
    char *pcVar10;
    size_t sVar11;
    char *pcVar12;
    pool *ppVar13;
    int *piVar14;
    char *pcVar15;
    char *func;
    char *func_00;
    char *func_01;
    size_t sVar16;
    int line;
    int line_00;
    int line_01;
    cglock_t *__mutex;
    undefined4 *puVar17;
    pthread_rwlock_t *ppVar18;
    char *pcVar19;
    bool bVar20;
    double dVar21;
    double dVar22;
    json_int_t jVar23;
    undefined8 in_stack_ffffdd88;
    undefined8 uVar24;
    char *pcVar25;
    char *pcVar26;
    char *pcVar27;
    char *local_2254;
    char *local_2250;
    char *sockaddr_url;
    uint8_t hex_time[4];
    json_error_t err;
    timeval stime;
    uint local_2130;
    uint uStack_212c;
    uint local_2128;
    uint local_2124;
    uint uStack_2120;
    uint local_211c;
    char tmp42[4096];

    pcVar15 = (char *)((ulonglong)in_stack_ffffdd88 >> 0x20);
    json = json_loads(s, 0, &err);
    if (json == (json_t *)0x0) {
        if (opt_debug == false) {
            return false;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
            return false;
        }
        snprintf(tmp42, 0x1000, "JSON decode failed(%d): %s", err.line,
                 err.text);
        _applog(7, tmp42, false);
        return false;
    }
    pjVar4 = json_object_get(json, "method");
    if (pjVar4 == (json_t *)0x0)
        goto LAB_00029e7a;
    json_00 = json_object_get(json, "error");
    val = json_object_get(json, "params");
    if ((json_00 != (json_t *)0x0) && (json_00->type != JSON_NULL)) {
        pcVar15 = json_dumps(json_00, 3);
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "JSON-RPC method decode failed: %s",
                     pcVar15);
            _applog(7, tmp42, false);
        }
        uVar3 = 0;
        free(pcVar15);
        goto LAB_00029e7c;
    }
    pcVar5 = json_string_value(pjVar4);
    if (pcVar5 != (char *)0x0) {
        iVar6 = strncasecmp(pcVar5, "mining.notify", 0xd);
        if (iVar6 == 0) {
            pcVar15 = json_array_string(val, 0);
            pcVar5 = json_array_string(val, 1);
            pcVar9 = json_array_string(val, 2);
            pcVar10 = json_array_string(val, 3);
            __ptr = json_array_string(val, 4);
            __s = json_array_string(val, 5);
            __s_00 = json_array_string(val, 6);
            pjVar4 = json_array_get(val, 7);
            if (pjVar4 == (json_t *)0x0) {
                bVar1 = false;
            } else {
                pjVar4 = json_array_get(val, 7);
                bVar1 = pjVar4->type == JSON_TRUE;
            }
            if (pcVar9 == (char *)0x0 || pcVar15 == (char *)0x0) {
                if (pcVar15 != (char *)0x0)
                    goto LAB_0002a14c;
            } else {
                if ((__ptr != (char *)0x0 && pcVar10 != (char *)0x0) &&
                    (__s != (char *)0x0 &&
                     (pcVar5 != (char *)0x0 && __s_00 != (char *)0x0))) {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        builtin_strncpy(tmp42, "Valid Notify", 0xc);
                        tmp42[0xc] = '\n';
                        tmp42[0xd] = '\0';
                        _applog(7, tmp42, false);
                    }
                    __mutex = &pool->data_lock;
                    iVar6 = pthread_mutex_lock((pthread_mutex_t *)__mutex);
                    if (iVar6 != 0) {
                        piVar14 = __errno_location();
                        snprintf(
                            tmp42, 0x1000,
                            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                            *piVar14, "util.c", "parse_notify_equihash", 0x85e);
                        _applog(3, tmp42, true);
                        _quit(1);
                    }
                    ppVar18 = &(pool->data_lock).rwlock;
                    iVar6 = pthread_rwlock_wrlock((pthread_rwlock_t *)ppVar18);
                    if (iVar6 != 0) {
                        piVar14 = __errno_location();
                        snprintf(
                            tmp42, 0x1000,
                            "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                            *piVar14, "util.c", "parse_notify_equihash", 0x85e);
                        _applog(3, tmp42, true);
                        _quit(1);
                    }
                    free((pool->swork).job_id);
                    free((pool->swork).prev_hash);
                    free((pool->swork).bbversion);
                    free((pool->swork).nbit);
                    free((pool->swork).ntime);
                    (pool->swork).job_id = pcVar15;
                    (pool->swork).prev_hash = pcVar9;
                    (pool->swork).clean = bVar1;
                    (pool->swork).bbversion = pcVar5;
                    (pool->swork).nbit = __s_00;
                    (pool->swork).ntime = __s;
                    if (0.0 < pool->next_diff) {
                        (pool->swork).diff = pool->next_diff;
                    }
                    if (bVar1) {
                        *(undefined4 *)&pool->nonce2 = 0;
                        *(undefined4 *)((int)&pool->nonce2 + 4) = 0;
                    }
                    sVar8 = strlen(pcVar5);
                    sVar11 = strlen(pcVar9);
                    pool->merkle_offset = sVar8 + sVar11;
                    iVar6 = (int)(sVar8 + sVar11) / 2;
                    sVar8 = strlen(__s);
                    sVar11 = strlen(__s_00);
                    pool->merkle_offset = iVar6;
                    _Var2 = opt_debug;
                    sVar8 =
                        ((sVar11 >> 1) + (sVar8 >> 1) + 0x54 + iVar6) * 2 + 1;
                    (pool->swork).header_len = sVar8;
                    if ((_Var2 != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000,
                                 "%s: pool->swork.header_len = %d",
                                 "parse_notify_equihash", sVar8);
                        _applog(7, tmp42, false);
                        sVar8 = (pool->swork).header_len;
                    }
                    bVar20 = (sVar8 & 3) != 0;
                    if (bVar20) {
                        sVar8 = (sVar8 & 0xfffffffc) + 4;
                    }
                    if (bVar20) {
                        (pool->swork).header_len = sVar8;
                    }
                    local_2254 = (char *)malloc(sVar8);
                    if (local_2254 == (char *)0x0) {
                        snprintf(tmp42, 0x1000,
                                 "%s: Failed to malloc header. in %s %s():%d",
                                 "parse_notify_equihash", "util.c",
                                 "parse_notify_equihash", 0x88c);
                        _applog(3, tmp42, true);
                        _quit(1);
                        sVar8 = (pool->swork).header_len;
                    }
                    pcVar19 = (pool->swork).nbit;
                    pcVar12 = (pool->swork).ntime;
                    pcVar27 = "0000000000000000000000000000000000000000";
                    pcVar26 = __ptr;
                    pcVar25 = pcVar10;
                    snprintf(local_2254, sVar8, "%s%s%s%s%s%s%s",
                             (pool->swork).bbversion, (pool->swork).prev_hash,
                             pcVar10, __ptr, pcVar12, pcVar19,
                             "0000000000000000000000000000000000000000");
                    uVar3 = hex2bin(pool->header_bin, local_2254, 0x80);
                    if ((bool)uVar3) {
                        pool->getwork_requested = pool->getwork_requested + 1;
                        bVar20 = 0xfffffffe < (uint)total_getworks;
                        total_getworks._0_4_ = (uint)total_getworks + 1;
                        total_getworks._4_4_ =
                            total_getworks._4_4_ + (uint)bVar20;
                        iVar6 =
                            pthread_rwlock_unlock((pthread_rwlock_t *)ppVar18);
                        if (iVar6 != 0) {
                            piVar14 = __errno_location();
                            snprintf(tmp42, 0x1000,
                                     "WTF RWLOCK ERROR ON UNLOCK! errno=%d in "
                                     "%s %s():%d",
                                     *piVar14, "util.c",
                                     "parse_notify_equihash", 0x8a6, pcVar12,
                                     pcVar19, pcVar27);
                            _applog(3, tmp42, true);
                            _quit(1);
                        }
                        iVar6 =
                            pthread_mutex_unlock((pthread_mutex_t *)__mutex);
                        if (iVar6 != 0) {
                            piVar14 = __errno_location();
                            snprintf(tmp42, 0x1000,
                                     "WTF MUTEX ERROR ON UNLOCK! errno=%d in "
                                     "%s %s():%d",
                                     *piVar14, "util.c",
                                     "parse_notify_equihash", 0x8a6);
                            _applog(3, tmp42, true);
                            _quit(1);
                        }
                        (*selective_yield)();
                        ppVar13 = current_pool();
                        if (pool == ppVar13) {
                            opt_work_update = true;
                        }
                        if (opt_protocol != false) {
                            if (opt_debug == false) {
                            LAB_0002a77a:
                                if (opt_debug == false)
                                    goto LAB_0002a784;
                                if (use_syslog != false) {
                                LAB_0002abc8:
                                    snprintf(tmp42, 0x1000, "reserved: %s",
                                             __ptr);
                                    _applog(7, tmp42, false);
                                    goto LAB_0002abee;
                                }
                            LAB_0002ab32:
                                if ((opt_log_output != false) ||
                                    (6 < opt_log_level))
                                    goto LAB_0002abc8;
                            LAB_0002ab46:
                                if ((opt_log_output != false) ||
                                    (6 < opt_log_level)) {
                                LAB_0002ab5c:
                                    local_2250 = tmp42;
                                    snprintf(local_2250, 0x1000, "nbit: %s",
                                             __s_00);
                                    _applog(7, local_2250, false);
                                LAB_0002ab7e:
                                    if (opt_debug == false)
                                        goto LAB_0002a784;
                                    if (use_syslog == false)
                                        goto LAB_0002ab98;
                                LAB_0002aaae:
                                    local_2250 = tmp42;
                                    snprintf(local_2250, 0x1000, "ntime: %s",
                                             __s);
                                    _applog(7, local_2250, false);
                                    goto LAB_0002aad0;
                                }
                            LAB_0002ab98:
                                if ((opt_log_output != false) ||
                                    (6 < opt_log_level))
                                    goto LAB_0002aaae;
                            LAB_0002abae:
                                if ((opt_log_output != false) ||
                                    (6 < opt_log_level)) {
                                LAB_0002aae4:
                                    local_2250 = tmp42;
                                    puVar17 = (undefined4 *)&DAT_000545f0;
                                    if (!bVar1) {
                                        puVar17 = &DAT_000545f4;
                                    }
                                    snprintf(local_2250, 0x1000, "clean: %s",
                                             puVar17);
                                    _applog(7, local_2250, false);
                                }
                            } else {
                                if (((use_syslog != false) ||
                                     (opt_log_output != false)) ||
                                    (6 < opt_log_level)) {
                                    snprintf(tmp42, 0x1000, "job_id: %s",
                                             pcVar15);
                                    _applog(7, tmp42, false);
                                    if (opt_debug != false) {
                                        if (use_syslog == false)
                                            goto LAB_0002a6a0;
                                        goto LAB_0002a6b6;
                                    }
                                LAB_0002abee:
                                    if (opt_debug != false) {
                                        if (use_syslog == false)
                                            goto LAB_0002ab46;
                                        goto LAB_0002ab5c;
                                    }
                                    goto LAB_0002a784;
                                }
                            LAB_0002a6a0:
                                if ((opt_log_output != false) ||
                                    (6 < opt_log_level)) {
                                LAB_0002a6b6:
                                    local_2250 = tmp42;
                                    snprintf(local_2250, 0x1000, "version: %s",
                                             pcVar5);
                                    _applog(7, local_2250, false);
                                    if (opt_debug != false) {
                                        if (use_syslog == false)
                                            goto LAB_0002a6f0;
                                        goto LAB_0002a706;
                                    }
                                    goto LAB_0002ab7e;
                                }
                            LAB_0002a6f0:
                                if ((opt_log_output == false) &&
                                    (opt_log_level < 7)) {
                                LAB_0002a740:
                                    if ((opt_log_output != false) ||
                                        (6 < opt_log_level)) {
                                    LAB_0002a758:
                                        local_2250 = tmp42;
                                        snprintf(local_2250, 0x1000,
                                                 "merkle: %s", pcVar10);
                                        _applog(7, local_2250, false);
                                        goto LAB_0002a77a;
                                    }
                                    goto LAB_0002ab32;
                                }
                            LAB_0002a706:
                                local_2250 = tmp42;
                                snprintf(local_2250, 0x1000, "prev_hash: %s",
                                         pcVar9);
                                _applog(7, local_2250, false);
                                if (opt_debug != false) {
                                    if (use_syslog == false)
                                        goto LAB_0002a740;
                                    goto LAB_0002a758;
                                }
                            LAB_0002aad0:
                                if (opt_debug != false) {
                                    if (use_syslog == false)
                                        goto LAB_0002abae;
                                    goto LAB_0002aae4;
                                }
                            }
                        }
                    LAB_0002a784:
                        if (set_os_time_12121 == '\0') {
                            hex2bin(hex_time, __s, 4);
                            gettimeofday((timeval *)&stime,
                                         (__timezone_ptr_t)0x0);
                            if (((use_syslog != false) ||
                                 (opt_log_output != false)) ||
                                (4 < opt_log_level)) {
                                snprintf(tmp42, 0x1000,
                                         "stime.tv_sec %lu, block_ntime %lu\n",
                                         stime.tv_sec, hex_time);
                                _applog(5, tmp42, false);
                            }
                            if (stime.tv_sec + 0xe10U < (uint)hex_time) {
                                stime.tv_sec._0_1_ = hex_time[0];
                                stime.tv_sec._1_1_ = hex_time[1];
                                stime.tv_sec._2_1_ = hex_time[2];
                                stime.tv_sec._3_1_ = hex_time[3];
                                settimeofday((timeval *)&stime,
                                             (timezone *)0x0);
                            }
                            set_os_time_12121 = '\x01';
                        }
                        if (local_2254 != (char *)0x0) {
                            free(local_2254);
                        }
                        pool->stratum_notify = true;
                        goto LAB_00029e7c;
                    }
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (3 < opt_log_level)) {
                        snprintf(tmp42, 0x1000,
                                 "%s: Failed to convert header to header_bin, "
                                 "got %s",
                                 "parse_notify_equihash", local_2254, pcVar25,
                                 pcVar26, pcVar12, pcVar19, pcVar27);
                        _applog(4, tmp42, false);
                    }
                    iVar6 = pthread_rwlock_unlock((pthread_rwlock_t *)ppVar18);
                    if (iVar6 != 0) {
                        piVar14 = __errno_location();
                        snprintf(tmp42, 0x1000,
                                 "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s "
                                 "%s():%d",
                                 *piVar14, "util.c", "parse_notify_equihash",
                                 0x89d);
                        _applog(3, tmp42, true);
                        _quit(1);
                    }
                    iVar6 = pthread_mutex_unlock((pthread_mutex_t *)__mutex);
                    if (iVar6 != 0) {
                        piVar14 = __errno_location();
                        snprintf(
                            tmp42, 0x1000,
                            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                            *piVar14, "util.c", "parse_notify_equihash", 0x89d);
                        _applog(3, tmp42, true);
                        _quit(1);
                    }
                    (*selective_yield)();
                    pool_failed(pool);
                }
            LAB_0002a14c:
                free(pcVar15);
            }
            if (pcVar9 != (char *)0x0) {
                free(pcVar9);
            }
            if (__ptr != (char *)0x0) {
                free(__ptr);
            }
            if (pcVar10 != (char *)0x0) {
                free(pcVar10);
            }
            if (pcVar5 != (char *)0x0) {
                free(pcVar5);
            }
            if (__s_00 != (char *)0x0) {
                free(__s_00);
            }
            if (__s != (char *)0x0) {
                free(__s);
            }
            if (local_2254 != (char *)0x0) {
                free(local_2254);
            }
            uVar3 = 0;
            pool->stratum_notify = false;
            goto LAB_00029e7c;
        }
        iVar6 = strncasecmp(pcVar5, "mining.set_extranonce", 0x15);
        if (iVar6 == 0) {
            uVar3 = parse_extranonce_equihash(pool, val, 0);
            goto LAB_00029e7c;
        }
        iVar6 = strncasecmp(pcVar5, "mining.set_difficulty", 0x15);
        if (iVar6 == 0) {
            pjVar4 = json_array_get(val, 0);
            dVar21 = json_number_value(pjVar4);
            if (dVar21 != 0.0) {
                iVar6 = pthread_mutex_lock((pthread_mutex_t *)&pool->data_lock);
                if (iVar6 != 0) {
                    _mutex_lock((pthread_mutex_t *)"parse_diff", (char *)0x9b3,
                                func, line);
                }
                ppVar18 = &(pool->data_lock).rwlock;
                iVar6 = pthread_rwlock_wrlock((pthread_rwlock_t *)ppVar18);
                if (iVar6 != 0) {
                    piVar14 = __errno_location();
                    pcVar15 = "parse_diff";
                    snprintf(tmp42, 0x1000,
                             "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                             *piVar14, "util.c", "parse_diff", 0x9b3);
                    _applog(3, tmp42, true);
                    _quit(1);
                }
                dVar22 = pool->sdiff;
                pool->sdiff = dVar21;
                iVar6 = pthread_rwlock_unlock((pthread_rwlock_t *)ppVar18);
                if (iVar6 != 0) {
                    piVar14 = __errno_location();
                    pcVar15 = "parse_diff";
                    snprintf(
                        tmp42, 0x1000,
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *piVar14, "util.c", "parse_diff", 0x9b6);
                    _applog(3, tmp42, true);
                    _quit(1);
                }
                iVar6 =
                    pthread_mutex_unlock((pthread_mutex_t *)&pool->data_lock);
                if (iVar6 != 0) {
                    piVar14 = __errno_location();
                    pcVar15 = "parse_diff";
                    snprintf(
                        tmp42, 0x1000,
                        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *piVar14, "util.c", "parse_diff", 0x9b6);
                    _applog(3, tmp42, true);
                    _quit(1);
                }
                (*selective_yield)();
                uVar3 = opt_debug;
                if (dVar21 == dVar22) {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        pcVar15 = "Pool %d difficulty set to %f";
                        iVar6 = pool->pool_no;
                    LAB_0002a7f2:
                        snprintf(tmp42, 0x1000, pcVar15, iVar6, dVar21);
                        _applog(7, tmp42, false);
                        goto LAB_00029e7c;
                    }
                } else if (dVar21 == (double)(longlong)(int)(longlong)dVar21) {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        uVar24 = CONCAT44(pcVar15, (int)(longlong)dVar21);
                        iVar6 = pool->pool_no;
                        pcVar15 = "Pool %d difficulty changed to %d";
                    LAB_0002a034:
                        uVar3 = opt_debug;
                        snprintf(tmp42, 0x1000, pcVar15, iVar6, uVar24);
                        _applog(7, tmp42, false);
                        goto LAB_00029e7c;
                    }
                } else if ((opt_debug != false) &&
                           (((use_syslog != false ||
                              (opt_log_output != false)) ||
                             (6 < opt_log_level)))) {
                    iVar6 = pool->pool_no;
                    pcVar15 = "Pool %d difficulty changed to %.1f";
                    goto LAB_0002a7f2;
                }
            LAB_0002a420:
                uVar3 = 1;
                goto LAB_00029e7c;
            }
        } else {
            iVar6 = strncasecmp(pcVar5, "client.reconnect", 0x10);
            if (iVar6 == 0) {
                memset(&stime, 0, 0xff);
                pjVar4 = json_array_get(val, 0);
                pcVar15 = json_string_value(pjVar4);
                if (pcVar15 == (char *)0x0) {
                    pcVar15 = pool->sockaddr_url;
                LAB_0002a22c:
                    pjVar4 = json_array_get(val, 1);
                    pcVar5 = json_string_value(pjVar4);
                    if (pcVar5 == (char *)0x0) {
                        pcVar5 = pool->stratum_port;
                    }
                    snprintf((char *)&stime, 0xfe, "%s:%s", pcVar15, pcVar5);
                    _Var2 = extract_sockaddr((char *)&stime, &sockaddr_url,
                                             (char **)hex_time);
                    if (_Var2) {
                        if (((use_syslog != false) ||
                             (opt_log_output != false)) ||
                            (3 < opt_log_level)) {
                            snprintf(tmp42, 0x1000,
                                     "Stratum reconnect requested from pool %d "
                                     "to %s",
                                     pool->pool_no, &stime);
                            _applog(4, tmp42, false);
                        }
                        clear_pool_work(pool);
                        iVar6 = pthread_mutex_lock(
                            (pthread_mutex_t *)&pool->stratum_lock);
                        if (iVar6 != 0) {
                            _mutex_lock((pthread_mutex_t *)"parse_reconnect",
                                        (char *)0xa51, func_00, line_00);
                        }
                        __suspend_stratum(pool);
                        pcVar15 = pool->sockaddr_url;
                        pool->stratum_url = sockaddr_url;
                        pool->sockaddr_url = sockaddr_url;
                        free(pcVar15);
                        pcVar15 = pool->stratum_port;
                        pool->stratum_port = (char *)hex_time;
                        free(pcVar15);
                        iVar6 = pthread_mutex_unlock(
                            (pthread_mutex_t *)&pool->stratum_lock);
                        if (iVar6 != 0) {
                            piVar14 = __errno_location();
                            snprintf(tmp42, 0x1000,
                                     "WTF MUTEX ERROR ON UNLOCK! errno=%d in "
                                     "%s %s():%d",
                                     *piVar14, "util.c", "parse_reconnect",
                                     0xa5a);
                            _applog(3, tmp42, true);
                            _quit(1);
                        }
                        (*selective_yield)();
                        uVar3 = restart_stratum(pool);
                        goto LAB_00029e7c;
                    }
                } else {
                    pcVar5 = pool->sockaddr_url;
                    pcVar9 = strchr(pcVar5, 0x2e);
                    if (pcVar9 == (char *)0x0) {
                        if (((use_syslog != false) ||
                             (opt_log_output != false)) ||
                            (2 < opt_log_level)) {
                            pcVar9 = "Denied stratum reconnect request for "
                                     "pool without domain \'%s\'";
                        LAB_0002a1d8:
                            snprintf(tmp42, 0x1000, pcVar9, pcVar5);
                            uVar3 = 0;
                            _applog(3, tmp42, false);
                            goto LAB_00029e7c;
                        }
                    } else {
                        pcVar10 = strchr(pcVar15, 0x2e);
                        if (pcVar10 == (char *)0x0) {
                            if (((use_syslog != false) ||
                                 (opt_log_output != false)) ||
                                (2 < opt_log_level)) {
                                pcVar9 = "Denied stratum reconnect request to "
                                         "url without domain \'%s\'";
                                pcVar5 = pcVar15;
                                goto LAB_0002a1d8;
                            }
                        } else {
                            iVar6 = strcmp(pcVar9, pcVar10);
                            if (iVar6 == 0)
                                goto LAB_0002a22c;
                            if (((use_syslog != false) ||
                                 (opt_log_output != false)) ||
                                (2 < opt_log_level)) {
                                pcVar9 = "Denied stratum reconnect request to "
                                         "non-matching domain url \'%s\'";
                                goto LAB_0002a1d8;
                            }
                        }
                    }
                }
            } else {
                iVar6 = strncasecmp(pcVar5, "client.get_version", 0x12);
                if (iVar6 == 0) {
                    pjVar4 = json_object_get(json, "id");
                    if (pjVar4 != (json_t *)0x0) {
                        pjVar4 = json_object_get(json, "id");
                        jVar23 = json_integer_value(pjVar4);
                        uVar7 = (undefined4)jVar23;
                        pcVar15 = "{\"id\": %d, \"result\": \"cgminer/4.9.0\", "
                                  "\"error\": null}";
                    LAB_00029e60:
                        sprintf(tmp42, pcVar15, uVar7);
                        sVar8 = strlen(tmp42);
                        _Var2 = stratum_send(pool, tmp42, sVar8);
                        pjVar4 = (json_t *)(uint)_Var2;
                    }
                    uVar3 = SUB41(pjVar4, 0);
                    goto LAB_00029e7c;
                }
                iVar6 = strncasecmp(pcVar5, "client.show_message", 0x13);
                if (iVar6 == 0) {
                    if ((val != (json_t *)0x0) && (val->type == JSON_ARRAY)) {
                        pjVar4 = json_array_get(val, 0);
                        pcVar5 = json_string_value(pjVar4);
                        if (pcVar5 != (char *)0x0) {
                            if ((opt_debug != false) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (6 < opt_log_level)))) {
                                uVar24 = CONCAT44(pcVar15, pcVar5);
                                pcVar15 = "Pool %d message: %s";
                                iVar6 = pool->pool_no;
                                goto LAB_0002a034;
                            }
                            goto LAB_0002a420;
                        }
                    }
                } else {
                    iVar6 = strncasecmp(pcVar5, "mining.ping", 0xb);
                    if (iVar6 == 0) {
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            snprintf(tmp42, 0x1000, "Pool %d ping",
                                     pool->pool_no);
                            _applog(7, tmp42, false);
                        }
                        pjVar4 = json_object_get(json, "id");
                        if (pjVar4 != (json_t *)0x0) {
                            pjVar4 = json_object_get(json, "id");
                            jVar23 = json_integer_value(pjVar4);
                            uVar7 = (undefined4)jVar23;
                            pcVar15 = "{\"id\": %d, \"result\": \"pong\", "
                                      "\"error\": null}";
                            goto LAB_00029e60;
                        }
                    } else {
                        iVar6 = strncasecmp(pcVar5, "mining.set_target", 0x11);
                        if (iVar6 == 0) {
                            pcVar15 = json_array_string(val, 0);
                            if (pcVar15 != (char *)0x0) {
                                hex2bin((uchar *)&stime, pcVar15, 0x20);
                                iVar6 = pthread_mutex_lock(
                                    (pthread_mutex_t *)&pool->data_lock);
                                if (iVar6 != 0) {
                                    _mutex_lock(
                                        (pthread_mutex_t *)"parse_target",
                                        (char *)0xa9a, func_01, line_01);
                                }
                                ppVar18 = &(pool->data_lock).rwlock;
                                iVar6 = pthread_rwlock_wrlock(
                                    (pthread_rwlock_t *)ppVar18);
                                if (iVar6 != 0) {
                                    piVar14 = __errno_location();
                                    snprintf(tmp42, 0x1000,
                                             "WTF WRLOCK ERROR ON LOCK! "
                                             "errno=%d in %s %s():%d",
                                             *piVar14, "util.c", "parse_target",
                                             0xa9a);
                                    _applog(3, tmp42, true);
                                    _quit(1);
                                }
                                *(uint *)pool->Target =
                                    local_211c << 0x18 |
                                    (local_211c >> 8 & 0xff) << 0x10 |
                                    (local_211c >> 0x10 & 0xff) << 8 |
                                    local_211c >> 0x18;
                                *(uint *)(pool->Target + 4) =
                                    uStack_2120 << 0x18 |
                                    (uStack_2120 >> 8 & 0xff) << 0x10 |
                                    (uStack_2120 >> 0x10 & 0xff) << 8 |
                                    uStack_2120 >> 0x18;
                                *(uint *)(pool->Target + 8) =
                                    local_2124 << 0x18 |
                                    (local_2124 >> 8 & 0xff) << 0x10 |
                                    (local_2124 >> 0x10 & 0xff) << 8 |
                                    local_2124 >> 0x18;
                                *(uint *)(pool->Target + 0xc) =
                                    local_2128 << 0x18 |
                                    (local_2128 >> 8 & 0xff) << 0x10 |
                                    (local_2128 >> 0x10 & 0xff) << 8 |
                                    local_2128 >> 0x18;
                                *(uint *)(pool->Target + 0x10) =
                                    uStack_212c << 0x18 |
                                    (uStack_212c >> 8 & 0xff) << 0x10 |
                                    (uStack_212c >> 0x10 & 0xff) << 8 |
                                    uStack_212c >> 0x18;
                                *(uint *)(pool->Target + 0x14) =
                                    local_2130 << 0x18 |
                                    (local_2130 >> 8 & 0xff) << 0x10 |
                                    (local_2130 >> 0x10 & 0xff) << 8 |
                                    local_2130 >> 0x18;
                                *(uint *)(pool->Target + 0x18) =
                                    stime.tv_usec << 0x18 |
                                    ((uint)stime.tv_usec >> 8 & 0xff) << 0x10 |
                                    ((uint)stime.tv_usec >> 0x10 & 0xff) << 8 |
                                    (uint)stime.tv_usec >> 0x18;
                                *(uint *)(pool->Target + 0x1c) =
                                    stime.tv_sec << 0x18 |
                                    ((uint)stime.tv_sec >> 8 & 0xff) << 0x10 |
                                    ((uint)stime.tv_sec >> 0x10 & 0xff) << 8 |
                                    (uint)stime.tv_sec >> 0x18;
                                iVar6 = pthread_rwlock_unlock(
                                    (pthread_rwlock_t *)ppVar18);
                                if (iVar6 != 0) {
                                    piVar14 = __errno_location();
                                    snprintf(tmp42, 0x1000,
                                             "WTF RWLOCK ERROR ON UNLOCK! "
                                             "errno=%d in %s %s():%d",
                                             *piVar14, "util.c", "parse_target",
                                             0xa9d);
                                    _applog(3, tmp42, true);
                                    _quit(1);
                                }
                                iVar6 = pthread_mutex_unlock(
                                    (pthread_mutex_t *)&pool->data_lock);
                                if (iVar6 != 0) {
                                    piVar14 = __errno_location();
                                    snprintf(tmp42, 0x1000,
                                             "WTF MUTEX ERROR ON UNLOCK! "
                                             "errno=%d in %s %s():%d",
                                             *piVar14, "util.c", "parse_target",
                                             0xa9d);
                                    _applog(3, tmp42, true);
                                    _quit(1);
                                }
                                uVar3 = 1;
                                (*selective_yield)();
                                free(pcVar15);
                                goto LAB_00029e7c;
                            }
                            if ((opt_debug != false) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (6 < opt_log_level)))) {
                                uVar3 = 0;
                                builtin_strncpy(
                                    tmp42,
                                    "parse_target: Missing an array value",
                                    0x24);
                                tmp42[0x24] = '.';
                                tmp42[0x25] = '\0';
                                _applog(7, tmp42, false);
                                goto LAB_00029e7c;
                            }
                        }
                    }
                }
            }
        }
    }
LAB_00029e7a:
    uVar3 = 0;
LAB_00029e7c:
    if ((json->refcount != 0xffffffff) &&
        (sVar16 = json->refcount - 1, json->refcount = sVar16, sVar16 == 0)) {
        json_delete(json);
    }
    return (_Bool)uVar3;
}

/* WARNING: Unknown calling convention */

_Bool parse_method(pool *pool, char *s)

{
    _Bool _Var1;

    if (s != (char *)0x0) {
        _Var1 = parse_method(pool, s);
        return _Var1;
    }
    return false;
}

/* WARNING: Unknown calling convention */

_Bool auth_stratum(pool *pool)

{
    int iVar1;
    _Bool _Var2;
    _Bool _Var3;
    size_t sVar4;
    char *pcVar5;
    json_t *json;
    json_t *pjVar6;
    json_t *json_00;
    size_t sVar7;
    json_error_t err;
    char tmp42[4096];
    char s[8192];

    iVar1 = swork_id;
    swork_id = swork_id + 1;
    sprintf(s,
            "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": "
            "[\"%s\", \"%s\"]}",
            iVar1, pool->rpc_user, pool->rpc_pass);
    sVar4 = strlen(s);
    _Var2 = stratum_send(pool, s, sVar4);
    if (_Var2) {
        while (pcVar5 = recv_line(pool), pcVar5 != (char *)0x0) {
            _Var3 = parse_method(pool, pcVar5);
            if (!_Var3) {
                json = json_loads(pcVar5, 0, &err);
                free(pcVar5);
                pjVar6 = json_object_get(json, "result");
                json_00 = json_object_get(json, "error");
                if ((pjVar6 == (json_t *)0x0) || (pjVar6->type == JSON_FALSE)) {
                    if (json_00 != (json_t *)0x0)
                        goto LAB_0002b074;
                    pcVar5 = (char *)malloc(0x11);
                    if (pcVar5 != (char *)0x0) {
                        builtin_strncpy(pcVar5, "(unknown reason)", 0x11);
                    }
                } else {
                    if ((json_00 == (json_t *)0x0) ||
                        (json_00->type == JSON_NULL)) {
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            snprintf(
                                tmp42, 0x1000,
                                "Stratum authorisation success for pool %d",
                                pool->pool_no);
                            _applog(7, tmp42, false);
                        }
                        iVar1 = opt_suggest_diff;
                        successful_connect = true;
                        pool->probed = true;
                        if (iVar1 != 0) {
                            swork_id = swork_id + 1;
                            sprintf(s, "{\"id\": %d, \"method\": "
                                       "\"mining.suggest_difficulty\", "
                                       "\"params\": [%d]}");
                            sVar4 = strlen(s);
                            stratum_send(pool, s, sVar4);
                        }
                        if (opt_multi_version != 0) {
                            swork_id = swork_id + 1;
                            sprintf(
                                s,
                                "{\"id\": %d, \"method\": "
                                "\"mining.multi_version\", \"params\": [%d]}");
                            sVar4 = strlen(s);
                            stratum_send(pool, s, sVar4);
                        }
                        goto LAB_0002b0d0;
                    }
                LAB_0002b074:
                    pcVar5 = json_dumps(json_00, 3);
                }
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    snprintf(tmp42, 0x1000,
                             "pool %d JSON stratum auth failed: %s",
                             pool->pool_no, pcVar5);
                    _applog(7, tmp42, false);
                }
                free(pcVar5);
                suspend_stratum(pool);
                _Var2 = _Var3;
            LAB_0002b0d0:
                if (json == (json_t *)0x0) {
                    return _Var2;
                }
                if (json->refcount == 0xffffffff) {
                    return _Var2;
                }
                sVar7 = json->refcount - 1;
                json->refcount = sVar7;
                if (sVar7 != 0) {
                    return _Var2;
                }
                json_delete(json);
                return _Var2;
            }
            free(pcVar5);
        }
    }
    return false;
}

/* WARNING: Unknown calling convention */

_Bool subscribe_extranonce(pool *pool)

{
    undefined1 uVar1;
    _Bool _Var2;
    _Bool _Var3;
    size_t len;
    char *pcVar4;
    json_t *json;
    json_t *pjVar5;
    json_t *val;
    int iVar6;
    size_t sVar7;
    json_error_t err;
    char tmp42[4096];
    char s[8192];

    swork_id = swork_id + 1;
    sprintf(s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", "
               "\"params\": []}");
    len = strlen(s);
    uVar1 = stratum_send(pool, s, len);
    if ((bool)uVar1) {
        while (_Var3 = socket_full((pool *)pool->sock, 2), _Var2 = opt_debug,
               _Var3) {
            pcVar4 = recv_line(pool);
            if (pcVar4 == (char *)0x0) {
                return false;
            }
            _Var2 = parse_method(pool, pcVar4);
            if (!_Var2) {
                json = json_loads(pcVar4, 0, &err);
                free(pcVar4);
                pjVar5 = json_object_get(json, "result");
                val = json_object_get(json, "error");
                if ((pjVar5 == (json_t *)0x0) || (pjVar5->type == JSON_FALSE)) {
                    if (val != (json_t *)0x0)
                        goto LAB_0002b336;
                    pcVar4 = (char *)malloc(0x11);
                    if (pcVar4 != (char *)0x0) {
                        builtin_strncpy(pcVar4, "(unknown reason)", 0x11);
                    }
                } else {
                    if ((val == (json_t *)0x0) || (val->type == JSON_NULL)) {
                        if ((use_syslog != false) ||
                            ((opt_log_output != false ||
                              (5 < opt_log_level)))) {
                            snprintf(tmp42, 0x1000,
                                     "Stratum extranonce subscribe for pool %d",
                                     pool->pool_no);
                            _applog(6, tmp42, false);
                        }
                        goto LAB_0002b3ba;
                    }
                LAB_0002b336:
                    pcVar4 = __json_array_string(val, 1);
                    if (((pcVar4 != (char *)0x0) ||
                         (pcVar4 = json_string_value(val),
                          pcVar4 != (char *)0x0)) &&
                        ((iVar6 = strcmp(pcVar4,
                                         "Method \'subscribe\' not found for "
                                         "service \'mining.extranonce\'"),
                          iVar6 == 0 ||
                              (iVar6 = strcmp(pcVar4,
                                              "Unrecognized request provided"),
                               iVar6 == 0)))) {
                        if (((use_syslog != false) ||
                             (opt_log_output != false)) ||
                            (5 < opt_log_level)) {
                            snprintf(tmp42, 0x1000,
                                     "Cannot subscribe to mining.extranonce "
                                     "for pool %d",
                                     pool->pool_no);
                            _applog(6, tmp42, false);
                        }
                        goto LAB_0002b3ba;
                    }
                    pcVar4 = json_dumps(val, 3);
                }
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (5 < opt_log_level)) {
                    snprintf(tmp42, 0x1000,
                             "Pool %d JSON extranonce subscribe failed: %s",
                             pool->pool_no, pcVar4);
                    _applog(6, tmp42, false);
                }
                _Var3 = false;
                free(pcVar4);
            LAB_0002b3ba:
                if (json == (json_t *)0x0) {
                    return _Var3;
                }
                if (json->refcount == 0xffffffff) {
                    return _Var3;
                }
                sVar7 = json->refcount - 1;
                json->refcount = sVar7;
                if (sVar7 != 0) {
                    return _Var3;
                }
                json_delete(json);
                return _Var3;
            }
            free(pcVar4);
        }
        if ((opt_debug != false) &&
            (((uVar1 = _Var2,
               use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            builtin_strncpy(
                tmp42, "Timed out waiting for response extranonce.subscribe",
                0x34);
            _applog(7, tmp42, false);
        }
    }
    return (_Bool)uVar1;
}

/* WARNING: Unknown calling convention */

void dev_error(cgpu_info *dev, dev_reason reason)

{
    time_t tVar1;

    tVar1 = time((time_t *)0x0);
    dev->device_last_not_well = tVar1;
    dev->device_not_well_reason = reason;
    switch (reason) {
    case REASON_THREAD_FAIL_INIT:
        dev->thread_fail_init_count = dev->thread_fail_init_count + 1;
        return;
    case REASON_THREAD_ZERO_HASH:
        dev->thread_zero_hash_count = dev->thread_zero_hash_count + 1;
        return;
    case REASON_THREAD_FAIL_QUEUE:
        dev->thread_fail_queue_count = dev->thread_fail_queue_count + 1;
        return;
    case REASON_DEV_SICK_IDLE_60:
        dev->dev_sick_idle_60_count = dev->dev_sick_idle_60_count + 1;
        return;
    case REASON_DEV_DEAD_IDLE_600:
        dev->dev_dead_idle_600_count = dev->dev_dead_idle_600_count + 1;
        return;
    case REASON_DEV_NOSTART:
        dev->dev_nostart_count = dev->dev_nostart_count + 1;
        return;
    case REASON_DEV_OVER_HEAT:
        dev->dev_over_heat_count = dev->dev_over_heat_count + 1;
        return;
    case REASON_DEV_THERMAL_CUTOFF:
        dev->dev_thermal_cutoff_count = dev->dev_thermal_cutoff_count + 1;
        return;
    case REASON_DEV_COMMS_ERROR:
        dev->dev_comms_error_count = dev->dev_comms_error_count + 1;
        return;
    case REASON_DEV_THROTTLE:
        dev->dev_throttle_count = dev->dev_throttle_count + 1;
    }
    return;
}

/* WARNING: Unknown calling convention */

void *realloc_strcat(char *ptr, char *s)

{
    size_t sVar1;
    char *pcVar2;
    char tmp42[4096];

    sVar1 = strlen(s);
    pcVar2 = ptr;
    if (sVar1 != 0) {
        if (ptr != (char *)0x0) {
            pcVar2 = (char *)strlen(ptr);
        }
        pcVar2 = pcVar2 + sVar1 + 1;
        if (((uint)pcVar2 & 3) != 0) {
            pcVar2 = (char *)(((uint)pcVar2 & 0xfffffffc) + 4);
        }
        pcVar2 = (char *)malloc((size_t)pcVar2);
        if (pcVar2 == (char *)0x0) {
            snprintf(tmp42, 0x1000, "Failed to malloc in %s %s():%d", "util.c",
                     "realloc_strcat", 0xe79);
            _applog(3, tmp42, true);
            _quit(1);
        }
        if (ptr == (char *)0x0) {
            strcpy(pcVar2, s);
            return pcVar2;
        }
        sprintf(pcVar2, "%s%s", ptr, s);
        free(ptr);
    }
    return pcVar2;
}

/* WARNING: Unknown calling convention */

void *str_text(char *ptr)

{
    byte *pbVar1;
    size_t sVar2;
    byte *pbVar3;
    undefined4 *puVar4;
    byte *__s;
    byte *pbVar5;
    char tmp42[4096];

    if (ptr == (char *)0x0) {
        puVar4 = (undefined4 *)malloc(7);
        if (puVar4 == (undefined4 *)0x0) {
            snprintf(tmp42, 0x1000, "Failed to malloc null in %s %s():%d",
                     "util.c", "str_text", 0xe92);
            _applog(3, tmp42, true);
            _quit(1);
        } else {
            *puVar4 = 0x6c756e28;
            *(undefined2 *)(puVar4 + 1) = 0x296c;
            *(undefined1 *)((int)puVar4 + 6) = 0;
        }
    }
    sVar2 = strlen(ptr);
    pbVar3 = (byte *)malloc(sVar2 * 4 + 5);
    if (pbVar3 == (byte *)0x0) {
        snprintf(tmp42, 0x1000, "Failed to malloc txt in %s %s():%d", "util.c",
                 "str_text", 0xe99);
        _applog(3, tmp42, true);
        _quit(1);
    }
    pbVar5 = (byte *)(ptr + -1);
    pbVar1 = pbVar3;
    do {
        while (true) {
            __s = pbVar1;
            pbVar5 = pbVar5 + 1;
            if (0x5e < *pbVar5 - 0x20)
                break;
            *__s = *pbVar5;
            pbVar1 = __s + 1;
        }
        sprintf((char *)__s, "0x%02x");
        pbVar1 = __s + 4;
    } while (*pbVar5 != 0);
    __s[4] = 0;
    return pbVar3;
}

/* WARNING: Unknown calling convention */

void RenameThread(char *name)

{
    char buf[16];

    snprintf(buf, 0x10, "cg@%s", name);
    prctl(0xf, buf, 0, 0, 0);
    return;
}

/* WARNING: Unknown calling convention */

void _cgsem_init(cgsem_t *cgsem, char *file, char *func, int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = sem_init((sem_t *)cgsem, 0, 0);
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "Failed to sem_init ret=%d errno=%d in %s %s():%d", iVar1,
                 *piVar2, file, func, line);
        _applog(3, tmp42, true);
        _quit(1);
    }
    return;
}

/* WARNING: Unknown calling convention */

int thr_info_create(thr_info *thr, pthread_attr_t *attr,
                    _func_void_ptr_void_ptr *start, void *arg)

{
    int iVar1;

    _cgsem_init(&thr->sem, "util.c", "thr_info_create", 0x520);
    iVar1 = pthread_create(&thr->pth, (pthread_attr_t *)attr,
                           (__start_routine *)start, arg);
    return iVar1;
}

/* WARNING: Unknown calling convention */

void _cgsem_post(cgsem_t *cgsem, char *file, char *func, int line)

{
    int iVar1;

    iVar1 = sem_post((sem_t *)cgsem);
    if (iVar1 == 0) {
        return;
    }
    _cgsem_post(cgsem, file, func, line);
    return;
}

/* WARNING: Unknown calling convention */

void *completion_thread(void *arg)

{
    pthread_setcanceltype(1, (int *)0x0);
    (**(code **)((int)arg + 0x10))(*(undefined4 *)((int)arg + 0x14));
    _cgsem_post((cgsem_t *)arg, "util.c", "completion_thread", 0xf7b);
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void _cgsem_wait(cgsem_t *cgsem, char *file, char *func, int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    do {
        iVar1 = sem_wait((sem_t *)cgsem);
        if (iVar1 == 0) {
            return;
        }
        piVar2 = __errno_location();
    } while (*piVar2 == 4);
    snprintf(tmp42, 0x1000,
             "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", *piVar2,
             cgsem, file, func, line);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

/* WARNING: Unknown calling convention */

int _cgsem_mswait(cgsem_t *cgsem, int ms, char *file, char *func, int line)

{
    int *piVar1;
    int iVar2;
    int iVar3;
    timespec abs_timeout;
    timeval tv_now;
    char tmp42[4096];

    gettimeofday((timeval *)&tv_now, (__timezone_ptr_t)0x0);
    ms_to_timespec(&abs_timeout, (longlong)ms);
    do {
        iVar3 = abs_timeout.tv_nsec + tv_now.tv_usec * 1000;
        iVar2 = abs_timeout.tv_sec + tv_now.tv_sec;
        abs_timeout.tv_nsec = iVar3;
        abs_timeout.tv_sec = iVar2;
        if (iVar3 < 1000000000) {
            for (; abs_timeout.tv_nsec < 0;
                 abs_timeout.tv_nsec = abs_timeout.tv_nsec + 1000000000) {
                abs_timeout.tv_sec = abs_timeout.tv_sec + -1;
            }
        } else {
            abs_timeout.tv_nsec = iVar3 + -1000000000;
            abs_timeout.tv_sec = iVar2 + 1;
            if (999999999 < abs_timeout.tv_nsec) {
                abs_timeout.tv_nsec = iVar3 + -2000000000;
                abs_timeout.tv_sec = iVar2 + 2;
            }
        }
        iVar2 = sem_timedwait((sem_t *)cgsem, (timespec *)&abs_timeout);
        if (iVar2 == 0) {
            return 0;
        }
        piVar1 = __errno_location();
        iVar2 = *piVar1;
        if (iVar2 == 0x6e) {
            return 0x6e;
        }
    } while (iVar2 == 4);
    snprintf(tmp42, 0x1000,
             "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", iVar2,
             cgsem, file, func, line);
    _applog(3, tmp42, true);
    _quit(1);
    return 0;
}

/* WARNING: Unknown calling convention */

void cgsem_reset(cgsem_t *cgsem)

{
    int iVar1;
    int *piVar2;

    do {
        while (true) {
            iVar1 = sem_trywait((sem_t *)cgsem);
            if (iVar1 < 0)
                break;
            if (iVar1 != 0) {
                return;
            }
        }
        piVar2 = __errno_location();
    } while (*piVar2 == 4);
    return;
}

/* WARNING: Unknown calling convention */

void cgsem_destroy(cgsem_t *cgsem)

{
    sem_destroy((sem_t *)cgsem);
    return;
}

/* WARNING: Unknown calling convention */

_Bool cg_completion_timeout(void *fn, void *fnarg, int timeout)

{
    cgsem_t *cgsem;
    int iVar1;
    pthread_t pthread;

    cgsem = (cgsem_t *)malloc(0x18);
    if (cgsem != (cgsem_t *)0x0) {
        _cgsem_init(cgsem, "util.c", "cg_completion_timeout", 0xf89);
        cgsem[1].__align = (long)fn;
        *(void **)((int)cgsem + 0x14) = fnarg;
        pthread_create(&pthread, (pthread_attr_t *)0x0,
                       (__start_routine *)0x2b7d5, cgsem);
        iVar1 = _cgsem_mswait(cgsem, timeout, "util.c", "cg_completion_timeout",
                              0xf8f);
        if (iVar1 == 0) {
            pthread_join(pthread, (void **)0x0);
            free(cgsem);
        } else {
            pthread_cancel(pthread);
        }
        cgsem = (cgsem_t *)(uint)(iVar1 == 0);
    }
    return SUB41(cgsem, 0);
}

/* WARNING: Unknown calling convention */

void _cg_memcpy(void *dest, void *src, uint n, char *file, char *func, int line)

{
    char tmp42[4096];

    if ((int)(n - 1) < 0) {
        if (((use_syslog) || (opt_log_output)) || (2 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "ERR: Asked to memcpy %u bytes from %s %s():%d", n, file,
                     func, line);
            _applog(3, tmp42, false);
        }
        return;
    }
    memcpy(dest, src, n);
    return;
}

/* WARNING: Unknown calling convention */

int cg_timeval_subtract(timeval *result, timeval *x, timeval *y)

{
    int iVar1;
    int iVar2;
    int iVar3;

    iVar3 = x->tv_sec;
    iVar1 = y->tv_sec;
    if ((iVar3 != iVar1 && iVar1 <= iVar3) ||
        ((iVar3 == iVar1 && (y->tv_usec < x->tv_usec)))) {
        iVar1 = -1;
    } else {
        result->tv_sec = iVar1 - iVar3;
        iVar2 = y->tv_usec - x->tv_usec;
        result->tv_usec = iVar2;
        if (iVar2 < 0) {
            result->tv_sec = (iVar1 - iVar3) + -1;
            result->tv_usec = iVar2 + 1000000;
            iVar1 = 0;
        } else {
            iVar1 = 0;
        }
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

void rev(uchar *s, size_t l)

{
    uchar uVar1;
    uchar *puVar2;
    uint uVar3;
    uchar *puVar4;

    if (l != 1) {
        uVar3 = 0;
        puVar4 = s + -1;
        puVar2 = s + l;
        do {
            uVar3 = uVar3 + 1;
            puVar4 = puVar4 + 1;
            uVar1 = *puVar4;
            puVar2 = puVar2 + -1;
            *puVar4 = *puVar2;
            *puVar2 = uVar1;
        } while (uVar3 < ~uVar3 + l);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

int check_asicnum(int asic_num, uchar nonce)

{
    int iVar1;
    byte bVar2;
    uint uVar3;

    switch (asic_num) {
    case 1:
        goto switchD_0002bad2_caseD_1;
    case 2:
        if ((nonce & 0x80) != 0x80) {
            asic_num = 1;
        }
        return asic_num;
    default:
        return 0;
    case 4:
        bVar2 = nonce & 0xc0;
        if (bVar2 == 0x80) {
            return 3;
        }
        if (bVar2 == 0xc0) {
            return asic_num;
        }
        if (bVar2 == 0x40) {
            iVar1 = 2;
        } else {
            iVar1 = 1;
        }
        return iVar1;
    case 8:
        bVar2 = nonce & 0xe0;
        if (bVar2 == 0x80) {
            return 5;
        }
        if (bVar2 < 0x81) {
            if (bVar2 == 0x40) {
                return 3;
            }
            if (bVar2 == 0x60) {
                return 4;
            }
            if (bVar2 == 0x20) {
                return 2;
            }
        } else {
            if (bVar2 == 0xc0) {
                return 7;
            }
            if (bVar2 == 0xe0) {
                return asic_num;
            }
            if (bVar2 == 0xa0) {
                return 6;
            }
        }
        break;
    case 0x10:
        bVar2 = nonce & 0xf0;
        if (bVar2 == 0x80) {
            return 9;
        }
        if (bVar2 < 0x81) {
            if (bVar2 == 0x40) {
                return 5;
            }
            if (bVar2 < 0x41) {
                if (bVar2 == 0x20) {
                    return 3;
                }
                if (bVar2 == 0x30) {
                    return 4;
                }
                if (bVar2 == 0x10) {
                    return 2;
                }
            } else {
                if (bVar2 == 0x60) {
                    return 7;
                }
                if (bVar2 == 0x70) {
                    return 8;
                }
                if (bVar2 == 0x50) {
                    return 6;
                }
            }
        } else {
            if (bVar2 == 0xc0) {
                return 0xd;
            }
            if (bVar2 < 0xc1) {
                if (bVar2 == 0xa0) {
                    return 0xb;
                }
                if (bVar2 == 0xb0) {
                    return 0xc;
                }
                if (bVar2 == 0x90) {
                    return 10;
                }
            } else {
                if (bVar2 == 0xe0) {
                    return 0xf;
                }
                if (bVar2 == 0xf0) {
                    return asic_num;
                }
                if (bVar2 == 0xd0) {
                    return 0xe;
                }
            }
        }
        break;
    case 0x20:
        uVar3 = (uint)(byte)((nonce & 0xf8) - 8);
        if (uVar3 < 0xf1) {
            return (int)(char)CSWTCH_677[uVar3];
        }
        break;
    case 0x40:
        uVar3 = (uint)(byte)((nonce & 0xfc) - 4);
        if (uVar3 < 0xf9) {
            return (int)(char)CSWTCH_678[uVar3];
        }
    }
    asic_num = 1;
switchD_0002bad2_caseD_1:
    return asic_num;
}

/* WARNING: Unknown calling convention */

void cg_logwork(work *work, uchar *nonce_bin, _Bool ok)

{
    uchar uVar1;
    uint uVar2;
    char *__ptr;
    char *__ptr_00;
    char *__ptr_01;
    char *__ptr_02;
    char *__ptr_03;
    char *__ptr_04;
    int iVar3;
    size_t sVar4;
    uchar *puVar5;
    uchar *puVar6;
    uint uVar7;
    uint uVar8;
    uint64_t uVar9;
    uint local_14e4;
    uint local_14e0;
    undefined4 local_14dc;
    uchar midstate_tmp[32];
    uchar data_tmp[32];
    uchar hash_tmp[32];
    uchar workdata[80];
    char szmsg[1024];
    char tmp42[4096];

    memset(szmsg, 0, 0x400);
    data_tmp[0xc] = '\0';
    data_tmp[0xd] = '\0';
    data_tmp[0xe] = '\0';
    data_tmp[0xf] = '\0';
    data_tmp[0x10] = '\0';
    data_tmp[0x11] = '\0';
    data_tmp[0x12] = '\0';
    data_tmp[0x13] = '\0';
    data_tmp[0x14] = '\0';
    data_tmp[0x15] = '\0';
    data_tmp[0x16] = '\0';
    data_tmp[0x17] = '\0';
    data_tmp[0x18] = '\0';
    data_tmp[0x19] = '\0';
    data_tmp[0x1a] = '\0';
    data_tmp[0x1b] = '\0';
    data_tmp[0x1c] = '\0';
    data_tmp[0x1d] = '\0';
    data_tmp[0x1e] = '\0';
    data_tmp[0x1f] = '\0';
    memset(workdata, 0, 0x50);
    midstate_tmp._0_4_ = *(undefined4 *)work->midstate;
    midstate_tmp._4_4_ = *(undefined4 *)(work->midstate + 4);
    midstate_tmp._8_4_ = *(undefined4 *)(work->midstate + 8);
    midstate_tmp._12_4_ = *(undefined4 *)(work->midstate + 0xc);
    midstate_tmp._16_4_ = *(undefined4 *)(work->midstate + 0x10);
    midstate_tmp._20_4_ = *(undefined4 *)(work->midstate + 0x14);
    midstate_tmp._24_4_ = *(undefined4 *)(work->midstate + 0x18);
    midstate_tmp._28_4_ = *(undefined4 *)(work->midstate + 0x1c);
    puVar6 = data_tmp;
    puVar5 = (uchar *)((int)&local_14dc + 3);
    data_tmp._0_4_ = *(undefined4 *)(work->data + 0x40);
    data_tmp._4_4_ = *(undefined4 *)(work->data + 0x44);
    data_tmp._8_4_ = *(undefined4 *)(work->data + 0x48);
    hash_tmp._0_4_ = *(undefined4 *)work->hash;
    hash_tmp._4_4_ = *(undefined4 *)(work->hash + 4);
    hash_tmp._8_4_ = *(undefined4 *)(work->hash + 8);
    hash_tmp._12_4_ = *(undefined4 *)(work->hash + 0xc);
    hash_tmp._16_4_ = *(undefined4 *)(work->hash + 0x10);
    hash_tmp._20_4_ = *(undefined4 *)(work->hash + 0x14);
    hash_tmp._24_4_ = *(undefined4 *)(work->hash + 0x18);
    hash_tmp._28_4_ = *(undefined4 *)(work->hash + 0x1c);
    do {
        puVar5 = puVar5 + 1;
        uVar1 = *puVar5;
        puVar6 = puVar6 + -1;
        *puVar5 = *puVar6;
        *puVar6 = uVar1;
    } while (midstate_tmp + 0xf != puVar5);
    puVar6 = data_tmp + 0xc;
    puVar5 = data_tmp;
    do {
        puVar6 = puVar6 + -1;
        uVar1 = *puVar5;
        *puVar5 = *puVar6;
        *puVar6 = uVar1;
        puVar5 = puVar5 + 1;
    } while (data_tmp + 6 != puVar6);
    puVar5 = data_tmp + 0x1f;
    puVar6 = workdata;
    do {
        puVar5 = puVar5 + 1;
        uVar1 = *puVar5;
        puVar6 = puVar6 + -1;
        *puVar5 = *puVar6;
        *puVar6 = uVar1;
    } while (hash_tmp + 0xf != puVar5);
    if (opt_scrypt == false) {
        __ptr = bin2hex(work->data, 0x80);
    } else {
        memcpy(workdata, work, 0x50);
        puVar5 = hash_tmp + 0x1f;
        puVar6 = (uchar *)szmsg;
        do {
            puVar5 = puVar5 + 1;
            uVar1 = *puVar5;
            puVar6 = puVar6 + -1;
            *puVar5 = *puVar6;
            *puVar6 = uVar1;
        } while (workdata + 0x27 != puVar5);
        uVar7 = (workdata._0_4_ << 0x18 |
                 ((uint)workdata._0_4_ >> 8 & 0xff) << 0x10 |
                 ((uint)workdata._0_4_ >> 0x10 & 0xff) << 8 |
                 (uint)workdata._0_4_ >> 0x18)
                << 4;
        workdata._0_4_ = ((uint)workdata._0_4_ >> 0x18) << 0x1c |
                         (uVar7 >> 8 & 0xff) << 0x10 |
                         (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
        __ptr = bin2hex(workdata, 0x50);
    }
    __ptr_00 = bin2hex(midstate_tmp, 0x20);
    __ptr_01 = bin2hex(data_tmp, 0xc);
    __ptr_02 = bin2hex(nonce_bin, 4);
    __ptr_03 = bin2hex(nonce_bin, 5);
    __ptr_04 = bin2hex(hash_tmp, 0x20);
    uVar9 = share_ndiff(work);
    iVar3 = strcmp(opt_logwork_path, "screen");
    if (iVar3 == 0) {
        if (ok) {
            sprintf(szmsg, "work %s nonce %s", __ptr, __ptr_02);
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, szmsg);
                _applog(3, tmp42, false);
            }
            sVar4 = strlen(szmsg);
            fwrite(szmsg, sVar4, 1, (FILE *)g_logwork_file);
            fwrite("\n", 1, 1, (FILE *)g_logwork_file);
            fflush((FILE *)g_logwork_file);
        }
    } else {
        local_14dc = &use_syslog;
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            snprintf(tmp42, 0x1000, szmsg);
            _applog(3, tmp42, false);
        }
        if (g_logwork_file != (FILE *)0x0) {
            if (ok) {
                sprintf(szmsg,
                        "%s %08x work %s midstate %s data %s nonce %s hash %s "
                        "diff %lld",
                        &DAT_00054e60, work->id, __ptr, __ptr_00, __ptr_01,
                        __ptr_03, __ptr_04);
                sVar4 = strlen(szmsg);
                fwrite(szmsg, sVar4, 1, (FILE *)g_logwork_file);
                fwrite("\n", 1, 1, (FILE *)g_logwork_file);
                fflush((FILE *)g_logwork_file);
                if (g_logwork_asicnum == 1) {
                    sprintf(szmsg, "midstate %s data %s nonce %s hash %s",
                            __ptr_00, __ptr_01, __ptr_02, __ptr_04);
                    sVar4 = strlen(szmsg);
                    fwrite(szmsg, sVar4, 1, (FILE *)g_logwork_files[0]);
                    fwrite("\n", 1, 1, (FILE *)g_logwork_files[0]);
                    fflush((FILE *)g_logwork_files[0]);
                } else if ((g_logwork_asicnum - 0x20U & 0xffffffdf) == 0) {
                    sprintf(szmsg, "midstate %s data %s nonce %s hash %s",
                            __ptr_00, __ptr_01, __ptr_02, __ptr_04);
                    iVar3 = check_asicnum(g_logwork_asicnum, *nonce_bin);
                    sVar4 = strlen(szmsg);
                    fwrite(szmsg, sVar4, 1, (FILE *)g_logwork_files[iVar3]);
                    fwrite("\n", 1, 1, (FILE *)g_logwork_files[iVar3]);
                    fflush((FILE *)g_logwork_files[iVar3]);
                }
                if (opt_logwork_diff != false) {
                    local_14e4 = (uint)uVar9;
                    iVar3 = 0;
                    local_14e0 = (uint)(uVar9 >> 0x20);
                    uVar7 = local_14e4;
                    uVar8 = local_14e0;
                    do {
                        uVar2 = uVar8 & 1;
                        uVar8 = uVar8 >> 1;
                        uVar7 = (uint)(uVar2 != 0) << 0x1f | uVar7 >> 1;
                        if (uVar7 == 0 && uVar8 == 0)
                            break;
                        iVar3 = iVar3 + 1;
                    } while (iVar3 != 0x40);
                    if ((opt_debug != false) &&
                        (((*local_14dc != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000, "work diff %lld diffnum %d",
                                 local_14e0, local_14e4, local_14e0, iVar3);
                        _applog(7, tmp42, false);
                    }
                    sprintf(szmsg, "midstate %s data %s nonce %s hash %s",
                            __ptr_00, __ptr_01, __ptr_02, __ptr_04);
                    sVar4 = strlen(szmsg);
                    fwrite(szmsg, sVar4, 1, (FILE *)g_logwork_diffs[iVar3]);
                    fwrite("\n", 1, 1, (FILE *)g_logwork_diffs[iVar3]);
                    fflush((FILE *)g_logwork_diffs[iVar3]);
                }
            } else {
                sprintf(szmsg,
                        "%s %08x work %s midstate %s data %s nonce %s hash %s "
                        "diff %lld",
                        "x", work->id, __ptr, __ptr_00, __ptr_01, __ptr_03,
                        __ptr_04);
                sVar4 = strlen(szmsg);
                fwrite(szmsg, sVar4, 1, (FILE *)g_logwork_file);
                fwrite("\n", 1, 1, (FILE *)g_logwork_file);
                fflush((FILE *)g_logwork_file);
            }
        }
    }
    if (__ptr != (char *)0x0) {
        free(__ptr);
    }
    if (__ptr_00 != (char *)0x0) {
        free(__ptr_00);
    }
    if (__ptr_01 != (char *)0x0) {
        free(__ptr_01);
    }
    if (__ptr_02 != (char *)0x0) {
        free(__ptr_02);
    }
    if (__ptr_03 != (char *)0x0) {
        free(__ptr_03);
    }
    if (__ptr_04 != (char *)0x0) {
        free(__ptr_04);
    }
    return;
}

/* WARNING: Unknown calling convention */

void cg_logwork(work *work, uchar *nonce_bin, _Bool ok)

{
    if (opt_logwork_path != (char *)0x0) {
        cg_logwork(work, nonce_bin, ok);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void cg_logwork_uint32(work *work, uint32_t nonce, _Bool ok)

{
    uchar nonce_bin[5];

    if (opt_logwork_path != (char *)0x0) {
        nonce_bin[4] = '\0';
        nonce_bin._0_4_ = nonce;
        cg_logwork(work, nonce_bin, ok);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void sha256_transf(sha256_ctx *ctx, uchar *message, uint block_nb)

{
    byte *pbVar1;
    uint uVar2;
    uint32_t *puVar3;
    uint32_t *puVar4;
    uint32_t *puVar6;
    uint *puVar7;
    uint *puVar8;
    uint uVar9;
    int iVar10;
    byte *local_164;
    uint32_t local_14c;
    uint32_t wv[8];
    uint32_t w[64];
    uint32_t *puVar5;

    if ((int)block_nb < 1) {
        return;
    }
    local_164 = message;
    do {
        puVar8 = wv + 7;
        pbVar1 = local_164;
        do {
            puVar8 = puVar8 + 1;
            *puVar8 = (uint)pbVar1[1] << 0x10 | (uint)pbVar1[2] << 8 |
                      (uint)pbVar1[3] | (uint)*pbVar1 << 0x18;
            pbVar1 = pbVar1 + 4;
            puVar7 = w;
        } while (w + 0xf != puVar8);
        do {
            uVar9 = puVar7[0xe];
            puVar8 = puVar7 + 1;
            uVar2 = *puVar8;
            puVar7[0x10] = ((uVar9 >> 0x13 | uVar9 << 0xd) ^
                            (uVar9 >> 0x11 | uVar9 << 0xf) ^ uVar9 >> 10) +
                           puVar7[9] + *puVar7 +
                           ((uVar2 >> 0x12 | uVar2 << 0xe) ^
                            (uVar2 >> 7 | uVar2 << 0x19) ^ uVar2 >> 3);
            puVar7 = puVar8;
        } while (w + 0x30 != puVar8);
        puVar3 = &local_14c;
        puVar4 = ctx->h;
        puVar6 = puVar3;
        do {
            puVar5 = puVar4 + 1;
            puVar6 = puVar6 + 1;
            *puVar6 = *puVar4;
            puVar4 = puVar5;
        } while (ctx + 1 != (sha256_ctx *)puVar5);
        iVar10 = 0;
        do {
            iVar10 = iVar10 + 1;
            puVar6 = ctx->h;
        } while (iVar10 != 0x40);
        do {
            puVar3 = puVar3 + 1;
            puVar4 = puVar6 + 1;
            *puVar6 = *puVar3 + *puVar6;
            puVar6 = puVar4;
        } while (puVar5 != puVar4);
        local_164 = local_164 + 0x40;
    } while (message + block_nb * 0x40 != local_164);
    return;
}

/* WARNING: Unknown calling convention */

void sha256_init(sha256_ctx *ctx)

{
    uint32_t *puVar1;
    uint32_t *puVar2;
    uint32_t *puVar3;

    puVar1 = sha256_k + 0x3f;
    puVar2 = ctx->h;
    do {
        puVar1 = puVar1 + 1;
        puVar3 = puVar2 + 1;
        *puVar2 = *puVar1;
        puVar2 = puVar3;
    } while ((sha256_ctx *)puVar3 != ctx + 1);
    ctx->tot_len = 0;
    ctx->len = 0;
    return;
}

/* WARNING: Unknown calling convention */

void sha256_update(sha256_ctx *ctx, uchar *message, uint len)

{
    uint uVar1;
    uint __n;

    __n = 0x40 - ctx->len;
    if (len <= __n) {
        __n = len;
    }
    memcpy(ctx->block + ctx->len, message, __n);
    uVar1 = ctx->len + len;
    if (uVar1 < 0x40) {
        ctx->len = uVar1;
    } else {
        uVar1 = len - __n;
        sha256_transf(ctx, ctx->block, 1);
        sha256_transf(ctx, message + __n, uVar1 >> 6);
        memcpy(ctx->block, message + __n + (uVar1 & 0xffffffc0), uVar1 & 0x3f);
        ctx->len = uVar1 & 0x3f;
        ctx->tot_len = ctx->tot_len + ((uVar1 >> 6) + 1) * 0x40;
    }
    return;
}

/* WARNING: Unknown calling convention */

void sha256_final(sha256_ctx *ctx, uchar *digest)

{
    int iVar1;
    uint uVar2;
    int iVar3;
    uint32_t *puVar4;
    uint32_t *puVar5;
    uchar *message;
    uint uVar6;
    int iVar7;
    int iVar8;
    int iVar9;
    uint block_nb;
    uint block_nb_00;
    bool bVar10;

    uVar2 = ctx->len;
    message = ctx->block;
    uVar6 = ctx->tot_len;
    bVar10 = (uVar2 & 0x3f) < 0x38;
    if (bVar10) {
        iVar1 = 0x40;
    } else {
        iVar1 = 0x80;
    }
    if (bVar10) {
        iVar3 = 0x3c;
        iVar7 = 0x3d;
        iVar8 = 0x3e;
        iVar9 = 0x3f;
        block_nb_00 = 1;
    } else {
        iVar3 = 0x7c;
        iVar7 = 0x7d;
        iVar8 = 0x7e;
        iVar9 = 0x7f;
        block_nb_00 = 2;
    }
    memset(message + uVar2, 0, iVar1 - uVar2);
    iVar1 = (uVar6 + uVar2) * 8;
    ctx->block[ctx->len] = 0x80;
    message[iVar9] = (uchar)iVar1;
    message[iVar8] = (uchar)((uint)iVar1 >> 8);
    message[iVar7] = (uchar)((uint)iVar1 >> 0x10);
    message[iVar3] = (uchar)((uint)iVar1 >> 0x18);
    sha256_transf(ctx, message, block_nb_00);
    puVar4 = ctx->h;
    do {
        digest[3] = (uchar)*puVar4;
        puVar5 = puVar4 + 1;
        digest[2] = (uchar)(*puVar4 >> 8);
        digest[1] = (uchar) * (undefined2 *)((int)puVar4 + 2);
        *digest = *(undefined1 *)((int)puVar4 + 3);
        puVar4 = puVar5;
        digest = digest + 4;
    } while (ctx + 1 != (sha256_ctx *)puVar5);
    return;
}

/* WARNING: Unknown calling convention */

void sha256(uchar *message, uint len, uchar *digest)

{
    uint32_t *puVar1;
    uint32_t *puVar2;
    sha256_ctx ctx;

    puVar2 = sha256_k + 0x3f;
    puVar1 = ctx.h;
    do {
        puVar2 = puVar2 + 1;
        *puVar1 = *puVar2;
        puVar1 = puVar1 + 1;
    } while (puVar2 != sha256_h0 + 7);
    ctx.tot_len = 0;
    ctx.len = 0;
    sha256_update(&ctx, message, len);
    sha256_final(&ctx, digest);
    return;
}

/* WARNING: Unknown calling convention */

api_data *api_add_data_full(api_data *root, char *name, api_data_type type,
                            void *data, _Bool copy_data)

{
    undefined1 uVar1;
    undefined2 uVar2;
    api_data *paVar3;
    char *pcVar4;
    undefined2 *puVar5;
    size_t sVar6;
    void *__dest;
    undefined1 *puVar7;
    undefined4 *puVar8;
    api_data *paVar9;
    undefined4 uVar10;
    undefined4 uVar11;

    paVar3 = (api_data *)malloc(0x18);
    pcVar4 = (char *)__strdup(name);
    paVar3->type = type;
    paVar3->name = pcVar4;
    if (root == (api_data *)0x0) {
        paVar3->prev = paVar3;
        paVar3->next = paVar3;
        root = paVar3;
    } else {
        paVar9 = root->prev;
        paVar3->next = root;
        root->prev = paVar3;
        paVar3->prev = paVar9;
        paVar9->next = paVar3;
    }
    paVar3->data_was_malloc = copy_data;
    if (data == (void *)0x0) {
        paVar3->data_was_malloc = false;
        data = &DAT_00054c90;
        paVar3->type = API_CONST;
    } else if (copy_data) {
        switch (type) {
        case API_UINT8:
            puVar7 = (undefined1 *)malloc(4);
            /* WARNING: Load size is inaccurate */
            uVar1 = *data;
            paVar3->data = puVar7;
            *puVar7 = uVar1;
            return root;
        case API_INT16:
        case API_UINT16:
            puVar5 = (undefined2 *)malloc(4);
            /* WARNING: Load size is inaccurate */
            uVar2 = *data;
            paVar3->data = puVar5;
            *puVar5 = uVar2;
            return root;
        case API_INT:
        case API_UINT:
        case API_UINT32:
        case API_HEX32:
        case API_TIME:
            puVar8 = (undefined4 *)malloc(4);
            /* WARNING: Load size is inaccurate */
            uVar11 = *data;
            paVar3->data = puVar8;
            *puVar8 = uVar11;
            return root;
        case API_UINT64:
        case API_INT64:
            puVar8 = (undefined4 *)malloc(8);
            /* WARNING: Load size is inaccurate */
            uVar11 = *data;
            uVar10 = *(undefined4 *)((int)data + 4);
            paVar3->data = puVar8;
            *puVar8 = uVar11;
            puVar8[1] = uVar10;
            return root;
        case API_DOUBLE:
        case API_ELAPSED:
        case API_MHS:
        case API_MHTOTAL:
        case API_UTILITY:
        case API_FREQ:
        case API_HS:
        case API_DIFF:
        case API_PERCENT:
            puVar8 = (undefined4 *)malloc(8);
            /* WARNING: Load size is inaccurate */
            uVar11 = *data;
            uVar10 = *(undefined4 *)((int)data + 4);
            paVar3->data = puVar8;
            *puVar8 = uVar11;
            puVar8[1] = uVar10;
            return root;
        case API_BOOL:
            puVar7 = (undefined1 *)malloc(1);
            /* WARNING: Load size is inaccurate */
            uVar1 = *data;
            paVar3->data = puVar7;
            *puVar7 = uVar1;
            return root;
        case API_TIMEVAL:
            puVar8 = (undefined4 *)malloc(8);
            uVar10 = *(undefined4 *)((int)data + 4);
            /* WARNING: Load size is inaccurate */
            uVar11 = *data;
            paVar3->data = puVar8;
            *puVar8 = uVar11;
            puVar8[1] = uVar10;
            return root;
        case API_TEMP:
        case API_VOLTS:
        case API_AVG:
            puVar8 = (undefined4 *)malloc(4);
            /* WARNING: Load size is inaccurate */
            uVar11 = *data;
            paVar3->data = puVar8;
            *puVar8 = uVar11;
            return root;
        default:
            sVar6 = strlen((char *)data);
            __dest = malloc(sVar6 + 1);
            paVar3->data = __dest;
            memcpy(__dest, data, sVar6 + 1);
            return root;
        }
    }
    paVar3->data = data;
    return root;
}

/* WARNING: Unknown calling convention */

_Bool io_add(io_data *io_data, char *buf)

{
    size_t sVar1;
    char *pcVar2;
    char *__dest;
    uint uVar3;
    size_t __size;
    size_t dif;
    int iVar4;
    float fVar5;

    sVar1 = strlen(buf);
    __dest = io_data->cur;
    iVar4 = (int)__dest - (int)io_data->ptr;
    uVar3 = iVar4 + 0xc + sVar1;
    if (io_data->siz < uVar3) {
        __size = io_data->siz + 0x20000;
        if (__size < uVar3) {
            fVar5 = (float)FixedToFP(uVar3, 0x20, 0x20, 0x10, 1, 0);
            __size = ((uint)(0.0 < fVar5) * (int)fVar5 + 2) * 0x10000;
        }
        pcVar2 = (char *)realloc(io_data->ptr, __size);
        __dest = pcVar2 + iVar4;
        io_data->siz = __size;
        io_data->ptr = pcVar2;
        io_data->cur = __dest;
    }
    memcpy(__dest, buf, sVar1 + 1);
    io_data->cur = io_data->cur + sVar1;
    return true;
}

/* WARNING: Unknown calling convention */

void doquit(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    char *pcVar1;

    pcVar1 = io_data->ptr;
    if (isjson) {
        io_data->cur = pcVar1;
        *pcVar1 = '\0';
        io_data->close = false;
        io_add(io_data, "{\"STATUS\":\"BYE\"");
    } else {
        io_data->cur = pcVar1;
        *pcVar1 = isjson;
        io_data->close = isjson;
        io_add(io_data, "BYE");
    }
    bye = true;
    do_a_quit = true;
    return;
}

/* WARNING: Unknown calling convention */

void dorestart(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    char *pcVar1;

    pcVar1 = io_data->ptr;
    if (isjson) {
        io_data->cur = pcVar1;
        *pcVar1 = '\0';
        io_data->close = false;
        io_add(io_data, "{\"STATUS\":\"RESTART\"");
    } else {
        io_data->cur = pcVar1;
        *pcVar1 = isjson;
        io_data->close = isjson;
        io_add(io_data, "RESTART");
    }
    bye = true;
    do_a_restart = true;
    return;
}

/* WARNING: Unknown calling convention */

char *escape_string(char *str, _Bool isjson)

{
    byte bVar1;
    size_t sVar2;
    byte *pbVar3;
    byte *pbVar4;
    byte *pbVar5;
    byte bVar6;
    int iVar7;
    char tmp42[4096];

    bVar1 = *str;
    if (bVar1 != 0) {
        iVar7 = 0;
        pbVar5 = (byte *)str;
        bVar6 = bVar1;
    LAB_0002c678:
        do {
            if (bVar6 == 0x3d) {
            LAB_0002c686:
                if (isjson) {
                LAB_0002c68a:
                    pbVar5 = pbVar5 + 1;
                    bVar6 = *pbVar5;
                    if (bVar6 == 0)
                        break;
                    goto LAB_0002c678;
                }
            LAB_0002c670:
                iVar7 = iVar7 + 1;
            } else {
                if (0x3d < bVar6) {
                    if (bVar6 != 0x5c) {
                        if (bVar6 != 0x7c)
                            goto LAB_0002c672;
                        goto LAB_0002c686;
                    }
                    goto LAB_0002c670;
                }
                if (bVar6 == 0x22) {
                    if (isjson)
                        goto LAB_0002c670;
                } else if (bVar6 == 0x2c) {
                    if (!isjson)
                        goto LAB_0002c670;
                    goto LAB_0002c68a;
                }
            }
        LAB_0002c672:
            pbVar5 = pbVar5 + 1;
            bVar6 = *pbVar5;
        } while (bVar6 != 0);
        if (iVar7 != 0) {
            sVar2 = strlen(str);
            sVar2 = iVar7 + 1 + sVar2;
            pbVar3 = (byte *)malloc(sVar2);
            pbVar5 = pbVar3;
            if (pbVar3 == (byte *)0x0) {
                snprintf(tmp42, 0x1000,
                         "Failed to malloc escape buf %d in %s %s():%d", sVar2,
                         "api.c", "escape_string", 0x348);
                _applog(3, tmp42, true);
                _quit(1);
                bVar1 = *str;
            }
            do {
                if (bVar1 == 0) {
                    *pbVar5 = 0;
                    return (char *)pbVar3;
                }
                if (bVar1 == 0x3d) {
                LAB_0002c70e:
                    pbVar4 = pbVar5 + 1;
                    if (!isjson) {
                        pbVar4 = pbVar5 + 2;
                        *pbVar5 = 0x5c;
                        pbVar5 = pbVar5 + 1;
                    }
                    *pbVar5 = bVar1;
                } else if (bVar1 < 0x3e) {
                    if (bVar1 == 0x22) {
                        pbVar4 = pbVar5 + 1;
                        if (isjson) {
                            pbVar4 = pbVar5 + 2;
                            *pbVar5 = 0x5c;
                            pbVar5 = pbVar5 + 1;
                        }
                        *pbVar5 = 0x22;
                    } else {
                        if (bVar1 == 0x2c)
                            goto LAB_0002c70e;
                    LAB_0002c726:
                        *pbVar5 = bVar1;
                        pbVar4 = pbVar5 + 1;
                    }
                } else {
                    if (bVar1 != 0x5c) {
                        if (bVar1 != 0x7c)
                            goto LAB_0002c726;
                        goto LAB_0002c70e;
                    }
                    pbVar4 = pbVar5 + 2;
                    *pbVar5 = 0x5c;
                    pbVar5[1] = 0x5c;
                }
                str = (char *)((byte *)str + 1);
                bVar1 = *str;
                pbVar5 = pbVar4;
            } while (true);
        }
    }
    return str;
}

/* WARNING: Unknown calling convention */

void head_join(io_data *io_data, char *cmdptr, _Bool isjson, _Bool *firstjoin)

{
    char *buf;

    if (*firstjoin == false) {
        if (isjson) {
            io_add(io_data, ",");
            buf = escape_string(cmdptr, true);
            goto LAB_0002c7fc;
        }
    } else {
        if (isjson) {
            io_add(io_data, "{");
            *firstjoin = false;
            buf = escape_string(cmdptr, true);
        LAB_0002c7fc:
            io_add(io_data, "\"");
            io_add(io_data, buf);
            io_add(io_data, "\":[");
            goto LAB_0002c7ae;
        }
        *firstjoin = isjson;
    }
    buf = escape_string(cmdptr, isjson);
    io_add(io_data, "CMD=");
    io_add(io_data, buf);
    io_add(io_data, "|");
LAB_0002c7ae:
    if (cmdptr == buf) {
        return;
    }
    (*(code *)(undefined *)0x0)(buf);
    return;
}

/* WARNING: Unknown calling convention */

_Bool check_connect(sockaddr_storage *cli, char **connectaddr, char *group)

{
    char *__host;
    __int32_t **pp_Var1;
    in6_addr *piVar2;
    byte *pbVar3;
    byte *pbVar4;
    undefined1 uVar5;
    byte *pbVar6;
    int iVar7;
    in6_addr client_ip;
    char tmp[30];

    __host = (char *)malloc(0x2e);
    *connectaddr = __host;
    getnameinfo((sockaddr *)cli, 0x80, __host, 0x2e, (char *)0x0, 0, 1);
    if (cli->ss_family == 2) {
        sprintf(tmp, "::ffff:%s", *connectaddr);
        inet_pton(10, tmp, &client_ip);
    } else {
        inet_pton(10, *connectaddr, &client_ip);
    }
    pp_Var1 = __ctype_toupper_loc();
    *group = (char)(*pp_Var1)[0x52];
    uVar5 = opt_api_network;
    if (opt_api_allow == (char *)0x0) {
        if (opt_api_network == false) {
            iVar7 = strcmp(*connectaddr, "127.0.0.1");
            if (iVar7 == 0) {
                uVar5 = 1;
            } else if (((client_ip.__in6_u.__u6_addr32[0] == 0) &&
                        (client_ip.__in6_u.__u6_addr32[1] == 0)) &&
                       (client_ip.__in6_u.__u6_addr32[2] == 0)) {
                uVar5 = client_ip.__in6_u.__u6_addr32[3] == 0x1000000;
            }
        }
        return (_Bool)uVar5;
    }
    if (0 < ips) {
        iVar7 = 0;
        pbVar6 = (ipaccess->ip).__in6_u.__u6_addr8 + 0xf;
        do {
            pbVar4 = pbVar6 + -0x10;
            piVar2 = &client_ip;
            pbVar3 = pbVar6;
            while (true) {
                pbVar3 = pbVar3 + 1;
                pbVar4 = pbVar4 + 1;
                if (*pbVar4 != ((piVar2->__in6_u).__u6_addr8[0] & *pbVar3))
                    break;
                piVar2 = (in6_addr *)((int)&piVar2->__in6_u + 1);
                if (pbVar4 == pbVar6) {
                    *group = pbVar6[0x11];
                    return true;
                }
            }
            iVar7 = iVar7 + 1;
            pbVar6 = pbVar6 + 0x24;
        } while (iVar7 != ips);
    }
    return false;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void mcast(void)

{
    undefined4 uVar1;
    _Bool _Var2;
    int iVar3;
    int *piVar4;
    char *pcVar5;
    time_t tVar6;
    time_t tVar7;
    size_t sVar8;
    uint uVar9;
    int iVar10;
    long lVar11;
    ssize_t sVar12;
    char *pcVar13;
    uint uVar14;
    sockaddr *psVar15;
    uint __n;
    addrinfo *paVar16;
    int local_1938;
    int local_1920;
    char *local_1918;
    char group;
    socklen_t came_from_siz;
    char *connectaddr;
    addrinfo *res;
    int optval;
    char expect[9];
    char port_s[10];
    char came_from_port[10];
    addrinfo hints;
    sockaddr_storage came_from;
    char buf[1024];
    char replybuf[1024];
    char tmp42[4096];

    builtin_strncpy(expect, "cgminer-", 8);
    expect[8] = '\0';
    sprintf(port_s, "%d", opt_api_mcast_port);
    memset(&hints, 0, 0x20);
    iVar3 = getaddrinfo(opt_api_mcast_addr, port_s, (addrinfo *)&hints,
                        (addrinfo **)&res);
    uVar1 = tmp42._28_4_;
    if (iVar3 != 0) {
        builtin_strncpy(tmp42, "Invalid API Multicast Address", 0x1e);
        tmp42._30_2_ = SUB42(uVar1, 2);
        _applog(3, tmp42, true);
        _quit(1);
    }
    paVar16 = res;
    if (res == (addrinfo *)0x0) {
    LAB_0002ca6a:
        freeaddrinfo((addrinfo *)res);
        paVar16 = (addrinfo *)0x0;
        local_1938 = -1;
        builtin_strncpy(tmp42, "API mcast could not open socket", 0x20);
        _applog(3, tmp42, true);
        _quit(1);
    } else {
        do {
            local_1938 = socket(res->ai_family, 2, 0);
            if (0 < local_1938)
                goto LAB_0002c9e0;
            paVar16 = paVar16->ai_next;
        } while (paVar16 != (addrinfo *)0x0);
        if (local_1938 == -1)
            goto LAB_0002ca6a;
    }
LAB_0002c9e0:
    optval = 1;
    iVar3 = setsockopt(local_1938, 1, 2, &optval, 4);
    if (iVar3 < 0) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3))
            goto LAB_0002ca54;
        piVar4 = __errno_location();
        pcVar5 = strerror(*piVar4);
        pcVar13 = "API mcast setsockopt SO_REUSEADDR failed (%s)%s";
    } else {
        tVar6 = time((time_t *)0x0);
        while (iVar3 = bind(local_1938, (sockaddr *)paVar16->ai_addr,
                            paVar16->ai_addrlen),
               iVar3 < 0) {
            piVar4 = __errno_location();
            pcVar5 = strerror(*piVar4);
            tVar7 = time((time_t *)0x0);
            if (0x3d < tVar7 - tVar6) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000,
                             "API mcast bind to port %d failed (%s)%s",
                             opt_api_mcast_port, pcVar5,
                             " - API multicast listener will not be available");
                    _applog(3, tmp42, false);
                }
                goto LAB_0002ca54;
            }
            cgsleep_ms(30000);
        }
        if (paVar16->ai_family == 2) {
            replybuf[4] = '\0';
            replybuf[5] = '\0';
            replybuf[6] = '\0';
            replybuf[7] = '\0';
            replybuf._0_4_ = *(undefined4 *)(paVar16->ai_addr->sa_data + 2);
            iVar3 = setsockopt(local_1938, 0, 0x23, replybuf, 8);
        } else {
            if (paVar16->ai_family != 10)
                goto LAB_0002cb26;
            psVar15 = paVar16->ai_addr;
            replybuf._0_4_ = *(undefined4 *)(psVar15->sa_data + 6);
            replybuf._4_4_ = *(undefined4 *)(psVar15->sa_data + 10);
            replybuf._8_4_ = *(undefined4 *)(psVar15 + 1);
            replybuf._12_4_ = *(undefined4 *)(psVar15[1].sa_data + 2);
            replybuf[0x10] = '\0';
            replybuf[0x11] = '\0';
            replybuf[0x12] = '\0';
            replybuf[0x13] = '\0';
            iVar3 = setsockopt(local_1938, 0x29, 0x14, replybuf, 0x14);
        }
        if (-1 < iVar3) {
        LAB_0002cb26:
            local_1918 = replybuf;
            freeaddrinfo((addrinfo *)res);
            pcVar5 = opt_api_mcast_code;
            sVar8 = strlen(opt_api_mcast_code);
            __n = sVar8 + 9;
            pcVar13 = (char *)malloc(sVar8 + 10);
            if (pcVar13 == (char *)0x0) {
                builtin_strncpy(tmp42, "Failed to malloc mcast expect_co",
                                0x20);
                tmp42[0x20] = 'd';
                tmp42[0x21] = 'e';
                tmp42[0x22] = '\0';
                _applog(3, tmp42, true);
                _quit(1);
                pcVar5 = opt_api_mcast_code;
            }
            local_1920 = -1;
            iVar3 = 0;
            snprintf(pcVar13, sVar8 + 10, "%s%s-", expect, pcVar5);
        LAB_0002cbd8:
            do {
                do {
                    while (true) {
                        cgsleep_ms(1000);
                        came_from_siz = 0x80;
                        iVar3 = iVar3 + 1;
                        uVar9 =
                            recvfrom(local_1938, buf, 0x3ff, 0,
                                     (sockaddr *)&came_from, &came_from_siz);
                        if (-1 < (int)uVar9)
                            break;
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            piVar4 = __errno_location();
                            pcVar5 = strerror(*piVar4);
                            snprintf(tmp42, 0x1000,
                                     "API mcast failed count=%d (%s) (%d)",
                                     iVar3, pcVar5, local_1938);
                            _applog(7, tmp42, false);
                        }
                    }
                    _Var2 = check_connect(&came_from, &connectaddr, &group);
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        pcVar5 = "Ignored";
                        if (_Var2) {
                            pcVar5 = "Accepted";
                        }
                        snprintf(tmp42, 0x1000, "API mcast from %s - %s",
                                 connectaddr, pcVar5);
                        _applog(7, tmp42, false);
                    }
                } while (!_Var2);
                buf[uVar9] = '\0';
                if (uVar9 == 0)
                    goto LAB_0002cdb4;
                uVar14 = uVar9 - 1;
                if (buf[uVar14] == '\n') {
                    buf[uVar14] = '\0';
                    uVar9 = uVar14;
                }
                getnameinfo((sockaddr *)&came_from, came_from_siz, (char *)0x0,
                            0, came_from_port, 10, 1);
                if (opt_debug != false)
                    goto LAB_0002cdd4;
            } while ((uVar9 <= __n) ||
                     (iVar10 = memcmp(buf, pcVar13, __n), iVar10 != 0));
            goto LAB_0002ccb4;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3))
            goto LAB_0002ca54;
        piVar4 = __errno_location();
        pcVar5 = strerror(*piVar4);
        pcVar13 = "API mcast join failed (%s)%s";
    }
    snprintf(tmp42, 0x1000, pcVar13, pcVar5,
             " - API multicast listener will not be available");
    _applog(3, tmp42, false);
LAB_0002ca54:
    close(local_1938);
    return;
LAB_0002cdb4:
    getnameinfo((sockaddr *)&came_from, came_from_siz, (char *)0x0, 0,
                came_from_port, 10, 1);
    if (opt_debug != false) {
    LAB_0002cdd4:
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (6 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "API mcast request rep=%d (%s) from [%s]:%s", uVar9, buf,
                     connectaddr, came_from_port);
            _applog(7, tmp42, false);
        }
        if ((__n < uVar9) &&
            (iVar10 = memcmp(buf, pcVar13, __n), iVar10 == 0)) {
        LAB_0002ccb4:
            pcVar5 = buf + __n;
            lVar11 = strtol(pcVar5, (char **)0x0, 10);
            if (lVar11 - 1U < 0xffff) {
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    snprintf(tmp42, 0x1000, "API mcast request OK port %s=%d",
                             pcVar5, lVar11);
                    _applog(7, tmp42, false);
                }
                iVar10 = getaddrinfo(connectaddr, pcVar5, (addrinfo *)&hints,
                                     (addrinfo **)&res);
                paVar16 = res;
                if (iVar10 == 0) {
                    while ((paVar16 != (addrinfo *)0x0 &&
                            (local_1920 = socket(res->ai_family, 2, 0),
                             local_1938 < 1))) {
                        paVar16 = paVar16->ai_next;
                    }
                    if (local_1920 != -1) {
                        snprintf(local_1918, 0x400, "cgm-FTW-%d-%s",
                                 opt_api_port, opt_api_mcast_des);
                        sVar8 = strlen(local_1918);
                        sVar12 = sendto(local_1920, local_1918, sVar8 + 1, 0,
                                        (sockaddr *)paVar16->ai_addr,
                                        paVar16->ai_addrlen);
                        freeaddrinfo((addrinfo *)res);
                        if (sVar12 < 0) {
                            if ((opt_debug != false) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (6 < opt_log_level)))) {
                                piVar4 = __errno_location();
                                pcVar5 = strerror(*piVar4);
                                snprintf(
                                    tmp42, 0x1000,
                                    "API mcast send reply failed (%s) (%d)",
                                    pcVar5, local_1920);
                                _applog(7, tmp42, false);
                            }
                        } else if ((opt_debug != false) &&
                                   (((use_syslog != false ||
                                      (opt_log_output != false)) ||
                                     (6 < opt_log_level)))) {
                            snprintf(
                                tmp42, 0x1000,
                                "API mcast send reply (%s) succeeded (%d) (%d)",
                                local_1918, sVar12, local_1920);
                            _applog(7, tmp42, false);
                        }
                        close(local_1920);
                        goto LAB_0002cbd8;
                    }
                    freeaddrinfo((addrinfo *)res);
                    if (((use_syslog == false) && (opt_log_output == false)) &&
                        (opt_log_level < 3))
                        goto LAB_0002cbd8;
                    pcVar5 = "API mcast could not open socket to client %s";
                } else {
                    if (((use_syslog == false) && (opt_log_output == false)) &&
                        (opt_log_level < 3))
                        goto LAB_0002cbd8;
                    pcVar5 = "Invalid client address %s";
                }
                snprintf(tmp42, 0x1000, pcVar5, connectaddr);
                _applog(3, tmp42, false);
                goto LAB_0002cbd8;
            }
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000,
                         "API mcast request ignored - invalid port (%s)",
                         pcVar5);
                _applog(7, tmp42, false);
            }
        } else {
            uVar1 = tmp42._28_4_;
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                builtin_strncpy(tmp42, "API mcast request was no good", 0x1e);
                tmp42._30_2_ = SUB42(uVar1, 2);
                _applog(7, tmp42, false);
            }
        }
    }
    goto LAB_0002cbd8;
}

/* WARNING: Unknown calling convention */

void *mcast_thread(void *userdata)

{
    pthread_t __th;

    __th = pthread_self();
    pthread_detach(__th);
    pthread_setcanceltype(1, (int *)0x0);
    RenameThread("APIMcast");
    mcast();
    *(undefined4 *)((int)userdata + 0xc) = 0;
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void tail_join(io_data *io_data, _Bool isjson)

{
    if (io_data->close != false) {
        io_add(io_data, "]");
        io_data->close = false;
    }
    if (isjson) {
        io_add(io_data, ",\"id\":1}");
        io_add(io_data, "]");
        return;
    }
    return;
}

void add_item_buf(K_ITEM *item, char *str)

{
    size_t sVar1;
    char *pcVar2;
    void *__ptr;
    size_t old_siz;
    int iVar3;
    size_t ext;
    int iVar4;
    char tmp42[4096];

    pcVar2 = item->name;
    sVar1 = strlen(str);
    iVar3 = *(int *)(pcVar2 + 4);
    __ptr = *(void **)pcVar2;
    if (*(uint *)(pcVar2 + 8) < iVar3 + 1 + sVar1) {
        iVar4 = (sVar1 + 0x1001) - (sVar1 + 1 & 0xfff);
        __ptr = realloc(__ptr, *(uint *)(pcVar2 + 8) + iVar4);
        *(void **)item->name = __ptr;
        if (__ptr == (void *)0x0) {
            snprintf(tmp42, 0x1000,
                     "OOM buf siz=%d tot=%d ext=%d in %s %s():%d", sVar1,
                     *(undefined4 *)(item->name + 8), iVar4, "api.c",
                     "add_item_buf", 0x49b);
            _applog(3, tmp42, true);
            _quit(1);
        }
        *(int *)(item->name + 8) = *(int *)(item->name + 8) + iVar4;
    }
    memcpy((void *)((int)__ptr + iVar3), str, sVar1 + 1);
    *(size_t *)(item->name + 4) = sVar1 + *(int *)(item->name + 4);
    return;
}

/* DWARF original prototype: void send_result(io_data * io_data, long c, _Bool
 * isjson, io_data * io_data) */

void send_result(io_data *io_data, long c, _Bool isjson, io_data *io_data_1)

{
    size_t sVar1;
    size_t sVar2;
    int iVar3;
    size_t sVar4;
    int *piVar5;
    char *pcVar6;
    uint __fd;
    uint uVar7;
    __suseconds_t *p_Var8;
    uint uVar9;
    int iVar10;
    char cVar11;
    int local_10c4;
    timeval timeout;
    fd_set wd;
    char tmp42[4096];

    __fd = (uint)isjson;
    sVar1 = strlen((char *)io_data);
    sVar2 = sVar1;
    if (c != 0) {
        sVar2 = sVar1 + 1;
        pcVar6 = (char *)((int)&io_data->siz + sVar1);
        pcVar6[0] = ']';
        pcVar6[1] = '\0';
    }
    if (io_data_1 != (io_data *)0x0) {
        *(undefined4 *)((int)&io_data->siz + sVar2) = 0x6469222c;
        *(undefined4 *)((int)&io_data->ptr + sVar2) = 0x7d313a22;
        *(undefined1 *)((int)&io_data->cur + sVar2) = 0;
        sVar2 = strlen((char *)io_data);
    }
    cVar11 = 0xfffffffe < sVar2;
    sVar1 = sVar2 + 1;
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (cVar11 = 5 < (uint)opt_log_level, 6 < opt_log_level)))) {
        cVar11 = 9 < sVar2;
        pcVar6 = "";
        if (10 < sVar2) {
            pcVar6 = "...";
        }
        snprintf(tmp42, 0x1000, "API: send reply: (%d) \'%.10s%s\'", sVar1,
                 io_data, pcVar6);
        _applog(7, tmp42, false);
    }
    uVar9 = 0;
    if (cVar11 == '\0') {
        uVar9 = __fd;
    }
    uVar7 = __fd & 0x1f;
    if (__fd == 0) {
        uVar7 = -(-__fd & 0x1f);
    }
    iVar10 = 0;
    local_10c4 = 0;
    sVar2 = sVar1;
    while (true) {
        if ((int)sVar2 < 1 || 4 < local_10c4) {
            return;
        }
        p_Var8 = &timeout.tv_usec;
        timeout.tv_sec = 0;
        timeout.tv_usec = 50000;
        do {
            p_Var8 = p_Var8 + 1;
            *p_Var8 = 0;
        } while (wd.fds_bits + 0x1f != p_Var8);
        ((fd_set *)&wd)->fds_bits[(int)uVar9 >> 5] =
            ((fd_set *)&wd)->fds_bits[(int)uVar9 >> 5] | 1 << (uVar7 & 0xff);
        iVar3 = select(__fd + 1, (fd_set *)0x0, (fd_set *)&wd, (fd_set *)0x0,
                       (timeval *)&timeout);
        if (iVar3 < 1) {
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 4)) {
                return;
            }
            snprintf(tmp42, 0x1000, "API: send select failed (%d)", iVar3);
            _applog(4, tmp42, false);
            return;
        }
        sVar4 = send(__fd, io_data, sVar2, 0);
        iVar10 = iVar10 + 1;
        if ((int)sVar4 < 0)
            break;
        if (iVar10 == 1) {
            if (sVar2 != sVar4) {
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    snprintf(tmp42, 0x1000, "API: sent %d of %d first go",
                             sVar4, sVar2);
                    _applog(7, tmp42, false);
                }
                goto LAB_0002d362;
            }
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "API: sent all of %d first go", sVar2);
                _applog(7, tmp42, false);
            }
        LAB_0002d488:
            sVar2 = sVar2 - sVar4;
            io_data = (io_data *)((int)&io_data->siz + sVar4);
        } else if (sVar2 == sVar4) {
            if ((opt_debug == false) ||
                (((use_syslog == false && (opt_log_output == false)) &&
                  (opt_log_level < 7))))
                goto LAB_0002d488;
            snprintf(tmp42, 0x1000, "API: sent all of remaining %d (sendc=%d)",
                     sVar2, iVar10);
            sVar2 = sVar2 - sVar4;
            _applog(7, tmp42, false);
            io_data = (io_data *)((int)&io_data->siz + sVar4);
        } else {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000,
                         "API: sent %d of remaining %d (sendc=%d)", sVar4,
                         sVar2, iVar10);
                _applog(7, tmp42, false);
            }
        LAB_0002d362:
            sVar2 = sVar2 - sVar4;
            io_data = (io_data *)((int)&io_data->siz + sVar4);
            if (sVar4 == 0) {
            LAB_0002d36a:
                local_10c4 = local_10c4 + 1;
            }
        }
    }
    piVar5 = __errno_location();
    if (*piVar5 != 0xb) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4)) {
            return;
        }
        pcVar6 = strerror(*piVar5);
        snprintf(tmp42, 0x1000, "API: send (%d:%d) failed: %s", sVar1,
                 sVar1 - sVar2, pcVar6);
        _applog(4, tmp42, false);
        return;
    }
    goto LAB_0002d36a;
}

void copyadvanceafter(char ch, char **param, char **buf)

{
    char cVar1;
    undefined4 *puVar2;
    char *pcVar3;
    char *pcVar4;

    puVar2 = (undefined4 *)(int)ch;
    pcVar3 = (char *)*puVar2;
    cVar1 = *pcVar3;
    do {
        if (cVar1 == '\0') {
        LAB_0002d582:
            pcVar3 = *param;
            *param = pcVar3 + 1;
            *pcVar3 = '\0';
            return;
        }
        if (cVar1 == ',') {
            *puVar2 = pcVar3 + 1;
            goto LAB_0002d582;
        }
        if ((cVar1 == '\\') && (pcVar3[1] != '\0')) {
            pcVar3 = pcVar3 + 1;
        }
        *puVar2 = pcVar3 + 1;
        pcVar4 = *param;
        *param = pcVar4 + 1;
        *pcVar4 = *pcVar3;
        pcVar3 = (char *)*puVar2;
        cVar1 = *pcVar3;
    } while (true);
}

/* WARNING: Unknown calling convention */

_Bool pooldetails(char *param, char **url, char **user, char **pass)

{
    char cVar1;
    size_t sVar2;
    char *__ptr;
    char **extraout_r2;
    char **buf_00;
    char **buf_01;
    char **buf_02;
    char **extraout_r2_00;
    char *buf;
    char tmp42[4096];

    sVar2 = strlen(param);
    __ptr = (char *)malloc(sVar2 + 1);
    buf_00 = extraout_r2;
    buf = __ptr;
    if (__ptr == (char *)0x0) {
        builtin_strncpy(tmp42, "Failed to malloc pooldetails buf", 0x20);
        tmp42[0x20] = '\0';
        _applog(3, tmp42, true);
        _quit(1);
        buf_00 = extraout_r2_00;
    }
    *url = buf;
    cVar1 = (char)&stack0xffffffe8;
    copyadvanceafter(cVar1 + -0xc, &buf, buf_00);
    if (*param != '\0') {
        *user = buf;
        copyadvanceafter(cVar1 + -0xc, &buf, buf_01);
        if (*param != '\0') {
            *pass = buf;
            copyadvanceafter(cVar1 + -0xc, &buf, buf_02);
            return true;
        }
    }
    free(__ptr);
    return false;
}

void _rd_lock(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_rwlock_rdlock((pthread_rwlock_t *)lock);
    if (iVar1 == 0) {
        return;
    }
    piVar2 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar2, "api.c", file, func);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void _mutex_lock(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar1, "api.c", lock, file);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void _rw_unlock(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000,
             "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar1,
             "api.c", lock, file);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void _mutex_unlock_noyield(pthread_mutex_t *lock, char *file, char *func,
                           int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
             *piVar1, "api.c", lock, file);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

/* WARNING: Unknown calling convention */

void tidyup(void *arg)

{
    io_list *piVar1;
    int iVar2;
    char *func;
    char *func_00;
    int line;
    int line_00;
    io_list *__ptr;
    io_list *piVar3;

    iVar2 = pthread_mutex_lock((pthread_mutex_t *)&quit_restart_lock);
    if (iVar2 != 0) {
        _mutex_lock((pthread_mutex_t *)"tidyup", (char *)0x120c, func, line);
    }
    /* WARNING: Load size is inaccurate */
    bye = true;
    if (*arg != -1) {
        shutdown(*arg, 2);
        /* WARNING: Load size is inaccurate */
        close(*arg);
        *(undefined4 *)arg = 0xffffffff;
    }
    if (ipaccess != (IPACCESS *)0x0) {
        free(ipaccess);
        ipaccess = (IPACCESS *)0x0;
    }
    piVar1 = io_head;
    __ptr = io_head;
    if (io_head != (io_list *)0x0) {
        do {
            piVar3 = __ptr->next;
            free(__ptr->io_data->ptr);
            free(__ptr->io_data);
            free(__ptr);
            __ptr = piVar3;
        } while (piVar1 != piVar3);
        io_head = (io_list *)0x0;
    }
    iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
    if (iVar2 != 0) {
        _mutex_unlock_noyield((pthread_mutex_t *)"tidyup", (char *)0x1221,
                              func_00, line_00);
    }
    /* WARNING: Could not recover jumptable at 0x0002d7f0. Too many branches */
    /* WARNING: Treating indirect jump as call */
    (*selective_yield)();
    return;
}

/* WARNING: Unknown calling convention */

void *quit_thread(void *userdata)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&quit_restart_lock);
    if (iVar1 == 0) {
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "quit_thread", 0x1349);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "quit_thread", 0x134a);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "API: killing cgminer", 0x14);
        tmp42[0x14] = '\0';
        _applog(7, tmp42, false);
    }
    kill_work();
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void *restart_thread(void *userdata)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&quit_restart_lock);
    if (iVar1 == 0) {
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "restart_thread", 0x1357);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "restart_thread", 0x1358);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "API: restarting cgminer", 0x18);
        _applog(7, tmp42, false);
    }
    app_restart();
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

api_data *print_data(io_data *io_data, api_data *root, _Bool isjson,
                     _Bool precom)

{
    void **item;
    int iVar1;
    K_ITEM *item_00;
    int *piVar2;
    char *pcVar3;
    api_data *paVar4;
    float *pfVar5;
    api_data *__ptr;
    pthread_mutex_t *ppVar6;
    char *local_1074;
    char buf[64];
    char tmp42[4096];

    ppVar6 = (pthread_mutex_t *)strbufs->lock;
    iVar1 = pthread_mutex_lock(ppVar6);
    if (iVar1 == 0) {
        iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)(ppVar6 + 1));
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x4ac);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)(ppVar6 + 1));
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x4ac);
        _applog(3, tmp42, true);
        _quit(1);
    }
    item_00 = _k_unlink_head(strbufs, "api.c", "print_data", 0x4ad);
    ppVar6 = (pthread_mutex_t *)strbufs->lock;
    iVar1 = pthread_rwlock_unlock((pthread_rwlock_t *)(ppVar6 + 1));
    if (iVar1 == 0) {
        iVar1 = pthread_mutex_unlock(ppVar6);
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x4ae);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_mutex_unlock(ppVar6);
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x4ae);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    item = &item_00->data;
    *(undefined4 *)((int)*item + 4) = 0;
    if (precom) {
        add_item_buf((K_ITEM *)item, ",");
    }
    if (isjson) {
        add_item_buf((K_ITEM *)item, "{");
        if (root != (api_data *)0x0)
            goto LAB_0002daf2;
    LAB_0002dd18:
        add_item_buf((K_ITEM *)item, "}");
    } else {
        if (root != (api_data *)0x0) {
        LAB_0002daf2:
            if (isjson)
                goto LAB_0002dbb2;
        LAB_0002db10:
            add_item_buf((K_ITEM *)item, root->name);
            add_item_buf((K_ITEM *)item, "=");
            switch (root->type) {
            case API_ESCAPE:
                local_1074 = (char *)root->data;
                pcVar3 = escape_string(local_1074, false);
                add_item_buf((K_ITEM *)item, pcVar3);
                break;
            case API_STRING:
            case API_CONST:
                goto switchD_0002db28_caseD_1;
            case API_UINT8:
                goto switchD_0002db28_caseD_3;
            case API_INT16:
                goto switchD_0002db28_caseD_4;
            case API_UINT16:
                goto switchD_0002db28_caseD_5;
            case API_INT:
                goto switchD_0002db28_caseD_6;
            case API_UINT:
            case API_UINT32:
                goto switchD_0002db28_caseD_7;
            case API_HEX32:
                goto switchD_0002db28_caseD_9;
            case API_UINT64:
                goto switchD_0002db28_caseD_a;
            case API_INT64:
                goto switchD_0002db28_caseD_b;
            case API_DOUBLE:
                goto switchD_0002db28_caseD_c;
            case API_ELAPSED:
                goto switchD_0002db28_caseD_d;
            case API_BOOL:
                goto switchD_0002db28_caseD_e;
            case API_TIMEVAL:
                goto switchD_0002db28_caseD_f;
            case API_TIME:
                goto switchD_0002db28_caseD_10;
            case API_MHS:
            case API_UTILITY:
            case API_FREQ:
                goto switchD_0002db28_caseD_11;
            case API_MHTOTAL:
                goto switchD_0002db28_caseD_12;
            case API_TEMP:
                goto switchD_0002db28_caseD_13;
            case API_VOLTS:
            case API_AVG:
                goto switchD_0002db28_caseD_16;
            case API_HS:
                goto switchD_0002db28_caseD_17;
            case API_DIFF:
                goto switchD_0002db28_caseD_18;
            case API_PERCENT:
                goto switchD_0002db28_caseD_19;
            default:
                goto switchD_0002db28_default;
            }
        LAB_0002dff4:
            __ptr = root;
            if (local_1074 != pcVar3) {
                free(pcVar3);
            }
        LAB_0002db80:
            free(__ptr->name);
            if (__ptr->data_was_malloc == false) {
                root = __ptr->next;
            } else {
                free(__ptr->data);
                root = __ptr->next;
            }
            if (root == __ptr) {
                free(__ptr);
                if (!isjson)
                    goto LAB_0002dc7a;
                goto LAB_0002dd18;
            }
            paVar4 = __ptr->prev;
            root->prev = paVar4;
            paVar4->next = root;
            free(__ptr);
            add_item_buf((K_ITEM *)item, ",");
            if (!isjson)
                goto LAB_0002db10;
        LAB_0002dbb2:
            add_item_buf((K_ITEM *)item, "\"");
            add_item_buf((K_ITEM *)item, root->name);
            add_item_buf((K_ITEM *)item, "\"");
            add_item_buf((K_ITEM *)item, ":");
            switch (root->type) {
            case API_ESCAPE:
                goto switchD_0002dbee_caseD_0;
            case API_STRING:
            case API_CONST:
                if (isjson) {
                    add_item_buf((K_ITEM *)item, "\"");
                    pcVar3 = (char *)root->data;
                    goto LAB_0002e050;
                }
            switchD_0002db28_caseD_1:
                add_item_buf((K_ITEM *)item, (char *)root->data);
                __ptr = root;
                goto LAB_0002db80;
            case API_UINT8:
            switchD_0002db28_caseD_3:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%u", (uint)*root->data);
                break;
            case API_INT16:
            switchD_0002db28_caseD_4:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%d", (int)*root->data);
                break;
            case API_UINT16:
            switchD_0002db28_caseD_5:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%u", (uint)*root->data);
                break;
            case API_INT:
            switchD_0002db28_caseD_6:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%d", *root->data);
                break;
            case API_UINT:
            case API_UINT32:
            switchD_0002db28_caseD_7:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%u", *root->data);
                break;
            case API_HEX32:
                if (isjson) {
                    add_item_buf((K_ITEM *)item, "\"");
                    /* WARNING: Load size is inaccurate */
                    snprintf(buf, 0x40, "0x%08x", *root->data);
                    pcVar3 = buf;
                LAB_0002e050:
                    add_item_buf((K_ITEM *)item, pcVar3);
                    add_item_buf((K_ITEM *)item, "\"");
                    __ptr = root;
                } else {
                switchD_0002db28_caseD_9:
                    /* WARNING: Load size is inaccurate */
                    snprintf(buf, 0x40, "0x%08x", *root->data);
                    add_item_buf((K_ITEM *)item, buf);
                    __ptr = root;
                }
                goto LAB_0002db80;
            case API_UINT64:
            switchD_0002db28_caseD_a:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%llu", root->data, *root->data);
                break;
            case API_INT64:
            switchD_0002db28_caseD_b:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%lld", root->data, *root->data);
                break;
            case API_DOUBLE:
            switchD_0002db28_caseD_c:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%f", root->data, *root->data);
                break;
            case API_ELAPSED:
            switchD_0002db28_caseD_d:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%.0f", root->data, *root->data);
                break;
            case API_BOOL:
            switchD_0002db28_caseD_e:
                /* WARNING: Load size is inaccurate */
                pcVar3 = "false";
                if (*root->data != '\0') {
                    pcVar3 = "true";
                }
                snprintf(buf, 0x40, "%s", pcVar3);
                break;
            case API_TIMEVAL:
            switchD_0002db28_caseD_f:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%ld.%06ld", *root->data,
                         *(undefined4 *)((int)root->data + 4));
                break;
            case API_TIME:
            switchD_0002db28_caseD_10:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%lu", *root->data);
                break;
            case API_MHS:
            case API_UTILITY:
            case API_FREQ:
            switchD_0002db28_caseD_11:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%.2f", root->data, *root->data);
                break;
            case API_MHTOTAL:
            switchD_0002db28_caseD_12:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%.4f", root->data, *root->data);
                break;
            case API_TEMP:
            switchD_0002db28_caseD_13:
                pfVar5 = (float *)root->data;
                pcVar3 = "%.2f";
                goto LAB_0002ddde;
            case API_VOLTS:
            case API_AVG:
            switchD_0002db28_caseD_16:
                pfVar5 = (float *)root->data;
                pcVar3 = "%.3f";
            LAB_0002ddde:
                snprintf(buf, 0x40, pcVar3, pfVar5, (double)*pfVar5);
                break;
            case API_HS:
            switchD_0002db28_caseD_17:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%.15f", root->data, *root->data);
                break;
            case API_DIFF:
            switchD_0002db28_caseD_18:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%.8f", root->data, *root->data);
                break;
            case API_PERCENT:
            switchD_0002db28_caseD_19:
                /* WARNING: Load size is inaccurate */
                snprintf(buf, 0x40, "%.4f", root->data, *root->data * 100.0);
                break;
            default:
            switchD_0002db28_default:
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000,
                             "API: unknown2 data type %d ignored");
                    _applog(3, tmp42, false);
                }
                if (isjson) {
                    add_item_buf((K_ITEM *)item, "\"");
                    pcVar3 = "Unknown";
                    goto LAB_0002e050;
                }
                add_item_buf((K_ITEM *)item, "Unknown");
                __ptr = root;
                goto LAB_0002db80;
            }
            add_item_buf((K_ITEM *)item, buf);
            __ptr = root;
            goto LAB_0002db80;
        }
    LAB_0002dc7a:
        add_item_buf((K_ITEM *)item, "|");
    }
    /* WARNING: Load size is inaccurate */
    io_add(io_data, *item_00->data);
    ppVar6 = (pthread_mutex_t *)strbufs->lock;
    iVar1 = pthread_mutex_lock(ppVar6);
    if (iVar1 == 0) {
        iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)(ppVar6 + 1));
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x558);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_rwlock_wrlock((pthread_rwlock_t *)(ppVar6 + 1));
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x558);
        _applog(3, tmp42, true);
        _quit(1);
    }
    _k_add_head(strbufs, item_00, "api.c", "print_data", 0x559);
    ppVar6 = (pthread_mutex_t *)strbufs->lock;
    iVar1 = pthread_rwlock_unlock((pthread_rwlock_t *)(ppVar6 + 1));
    if (iVar1 == 0) {
        iVar1 = pthread_mutex_unlock(ppVar6);
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x55a);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_mutex_unlock(ppVar6);
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar2,
                 "api.c", "print_data", 0x55a);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    return (api_data *)0x0;
switchD_0002dbee_caseD_0:
    local_1074 = (char *)root->data;
    pcVar3 = escape_string(local_1074, true);
    add_item_buf((K_ITEM *)item, "\"");
    add_item_buf((K_ITEM *)item, pcVar3);
    add_item_buf((K_ITEM *)item, "\"");
    goto LAB_0002dff4;
}

/* WARNING: Unknown calling convention */

void message(io_data *io_data, int messageid, int paramid, char *param2,
             _Bool isjson)

{
    CODES *pCVar1;
    int iVar2;
    api_data *paVar3;
    code_severity cVar4;
    char *__format;
    char *pcVar5;
    CODES *pCVar6;
    int local_2024;
    char severity[2];
    int id;
    char buf[8192];

    local_2024 = messageid;
    if (isjson) {
        io_add(io_data, "{\"STATUS\":[");
    }
    if (codes[0].severity == SEVERITY_FAIL) {
    LAB_0002e2ee:
        paVar3 = api_add_data_full((api_data *)0x0, "STATUS", API_STRING,
                                   &DAT_000554b0, false);
        paVar3 = api_add_data_full(paVar3, "When", API_TIME, &when, false);
        id = -1;
        paVar3 = api_add_data_full(paVar3, "Code", API_INT, &id, false);
        sprintf(buf, "%d", local_2024);
    } else {
        if (codes[0].code == local_2024) {
            iVar2 = 0;
            cVar4 = codes[0].severity;
        } else {
            iVar2 = 0;
            pCVar6 = codes;
            do {
                cVar4 = pCVar6[1].severity;
                iVar2 = iVar2 + 1;
                if (cVar4 == SEVERITY_FAIL)
                    goto LAB_0002e2ee;
                pCVar1 = pCVar6 + 1;
                pCVar6 = pCVar6 + 1;
            } while (pCVar1->code != local_2024);
        }
        if (cVar4 == SEVERITY_INFO) {
            severity[0] = 'I';
        } else if (cVar4 == SEVERITY_SUCC) {
            severity[0] = 'S';
        } else if (cVar4 == SEVERITY_WARN) {
            severity[0] = 'W';
        } else {
            severity[0] = 'E';
        }
        severity[1] = '\0';
        __format = codes[iVar2].description;
        switch (codes[iVar2].params) {
        case PARAM_PGA:
        case PARAM_ASC:
        case PARAM_PID:
        case PARAM_INT:
            sprintf(buf, __format, paramid);
            break;
        default:
            strcpy(buf, __format);
            break;
        case PARAM_PMAX:
            sprintf(buf, __format, total_pools);
            break;
        case PARAM_POOLMAX:
            sprintf(buf, __format, paramid, total_pools + -1);
            break;
        case PARAM_DMAX:
            sprintf(buf, __format);
            break;
        case PARAM_CMD:
            sprintf(buf, __format, "command");
            break;
        case PARAM_POOL:
            sprintf(buf, __format, paramid, pools[paramid]->rpc_url);
            break;
        case PARAM_STR:
            sprintf(buf, __format, param2);
            break;
        case PARAM_BOTH:
            sprintf(buf, __format, paramid, param2);
            break;
        case PARAM_BOOL:
            pcVar5 = "false";
            if (paramid != 0) {
                pcVar5 = "true";
            }
            sprintf(buf, __format, pcVar5);
            break;
        case PARAM_SET:
            sprintf(buf, __format, param2, paramid);
        }
        paVar3 = api_add_data_full((api_data *)0x0, "STATUS", API_STRING,
                                   severity, false);
        paVar3 = api_add_data_full(paVar3, "When", API_TIME, &when, false);
        paVar3 = api_add_data_full(paVar3, "Code", API_INT, &local_2024, false);
    }
    paVar3 = api_add_data_full(paVar3, "Msg", API_ESCAPE, buf, false);
    paVar3 = api_add_data_full(paVar3, "Description", API_ESCAPE,
                               opt_api_description, false);
    print_data(io_data, paVar3, isjson, false);
    if (isjson) {
        io_add(io_data, "]");
    }
    return;
}

/* WARNING: Unknown calling convention */

void privileged(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    message(io_data, 0x2e, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void dosave(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    FILE *fcfg;
    char *pcVar1;
    char filename[4096];

    if ((param == (char *)0x0) || (*param == '\0')) {
        default_save_file(filename);
        param = filename;
    }
    fcfg = fopen(param, "w");
    if (fcfg == (FILE *)0x0) {
        pcVar1 = escape_string(param, isjson);
        message(io_data, 0x2b, 0, pcVar1, isjson);
        if (param != pcVar1) {
            free(pcVar1);
            return;
        }
    } else {
        write_config((FILE *)fcfg);
        fclose(fcfg);
        pcVar1 = escape_string(param, isjson);
        message(io_data, 0x2c, 0, pcVar1, isjson);
        if (param != pcVar1) {
            free(pcVar1);
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void lockstats(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    message(io_data, 0x7c, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void dohotplug(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    message(io_data, 0x66, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void dozero(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    byte bVar1;
    char cVar2;
    bool bVar3;
    bool bVar4;
    char *pcVar5;
    int iVar6;
    __int32_t **pp_Var7;

    if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x5e, 0, (char *)0x0, isjson);
        return;
    }
    pcVar5 = strchr(param, 0x2c);
    if (((pcVar5 != (char *)0x0) &&
         (*pcVar5 = '\0', pcVar5 != (char *)0xffffffff)) &&
        (bVar1 = pcVar5[1], bVar1 != 0)) {
        iVar6 = strcasecmp(param, "all");
        if (iVar6 == 0) {
            bVar3 = true;
            bVar4 = false;
        } else {
            iVar6 = strcasecmp(param, "bestshare");
            if (iVar6 != 0) {
                message(io_data, 0x5f, 0, param, isjson);
                return;
            }
            bVar4 = true;
            bVar3 = false;
        }
        pp_Var7 = __ctype_tolower_loc();
        cVar2 = (char)(*pp_Var7)[bVar1];
        pcVar5[1] = cVar2;
        if (cVar2 != 't' && cVar2 != 'f') {
            message(io_data, 0x4c, 0, (char *)0x0, isjson);
            return;
        }
        if (cVar2 == 't') {
            print_summary();
        }
        if (bVar3) {
            zero_stats();
        }
        if (bVar4) {
            zero_bestshare();
        }
        pcVar5 = "BestShare";
        if (bVar3) {
            pcVar5 = "All";
        }
        if (cVar2 == 't') {
            message(io_data, 0x60, 0, pcVar5, isjson);
            return;
        }
        message(io_data, 0x61, 0, pcVar5, isjson);
        return;
    }
    message(io_data, 0x4b, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void usbstats(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    message(io_data, 0x58, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void setconfig(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    char *pcVar4;
    uint paramid;
    int iVar5;

    if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x55, 0, (char *)0x0, isjson);
        return;
    }
    pcVar4 = strchr(param, 0x2c);
    if (pcVar4 == (char *)0x0) {
        message(io_data, 0x56, 0, param, isjson);
        return;
    }
    *pcVar4 = '\0';
    paramid = strtol(pcVar4 + 1, (char **)0x0, 10);
    if (9999 < paramid) {
        message(io_data, 0x54, paramid, param, isjson);
        return;
    }
    iVar5 = strcasecmp(param, "queue");
    uVar1 = paramid;
    uVar2 = opt_scantime;
    uVar3 = opt_expiry;
    if (((iVar5 != 0) &&
         (iVar5 = strcasecmp(param, "scantime"), uVar1 = opt_queue,
          uVar2 = paramid, uVar3 = opt_expiry, iVar5 != 0)) &&
        (iVar5 = strcasecmp(param, "expiry"), uVar1 = opt_queue,
         uVar2 = opt_scantime, uVar3 = paramid, iVar5 != 0)) {
        message(io_data, 0x53, 0, param, isjson);
        return;
    }
    opt_expiry = uVar3;
    opt_scantime = uVar2;
    opt_queue = uVar1;
    message(io_data, 0x52, paramid, param, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void failoveronly(io_data *io_data, long c, char *param, _Bool isjson,
                  char group)

{
    byte bVar1;
    char cVar2;
    __int32_t **pp_Var3;

    if ((param != (char *)0x0) && (bVar1 = *param, bVar1 != 0)) {
        pp_Var3 = __ctype_tolower_loc();
        cVar2 = (char)(*pp_Var3)[bVar1];
        *param = cVar2;
        if (cVar2 == 't' || cVar2 == 'f') {
            opt_fail_only = cVar2 == 't';
            message(io_data, 0x4d, (uint)opt_fail_only, (char *)0x0, isjson);
            return;
        }
        message(io_data, 0x4c, 0, (char *)0x0, isjson);
        return;
    }
    message(io_data, 0x4b, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void removepool(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    pool *ppVar1;
    int messageid;
    long paramid;
    char *param2;
    pool *pool;

    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
        return;
    }
    if ((param == (char *)0x0) || (*param == '\0')) {
        param2 = (char *)0x0;
        paramid = 0;
        messageid = 0x19;
    } else {
        paramid = strtol(param, (char **)0x0, 10);
        if ((paramid < 0) || (total_pools <= paramid)) {
            message(io_data, 0x1a, paramid, (char *)0x0, isjson);
            return;
        }
        if (total_pools < 2) {
            param2 = (char *)0x0;
            messageid = 0x42;
        } else {
            pool = pools[paramid];
            ppVar1 = current_pool();
            if (pool == ppVar1) {
                switch_pools((pool *)0x0);
            }
            ppVar1 = current_pool();
            if (pool == ppVar1) {
                param2 = (char *)0x0;
                messageid = 0x43;
            } else {
                pool->enabled = POOL_DISABLED;
                param2 = escape_string(pool->rpc_url, isjson);
                if (param2 != pool->rpc_url) {
                    remove_pool(pool);
                    message(io_data, 0x44, paramid, param2, isjson);
                    (*(code *)(undefined *)0x0)(param2);
                    return;
                }
                remove_pool(pool);
                messageid = 0x44;
            }
        }
    }
    message(io_data, messageid, paramid, param2, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void disablepool(io_data *io_data, long c, char *param, _Bool isjson,
                 char group)

{
    long paramid;
    pool *ppVar1;
    pool *ppVar2;

    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
        return;
    }
    if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x19, 0, (char *)0x0, isjson);
        return;
    }
    paramid = strtol(param, (char **)0x0, 10);
    if ((paramid < 0) || (total_pools <= paramid)) {
        message(io_data, 0x1a, paramid, (char *)0x0, isjson);
        return;
    }
    ppVar2 = pools[paramid];
    if (ppVar2->enabled == POOL_DISABLED) {
        message(io_data, 0x32, paramid, (char *)0x0, isjson);
        return;
    }
    if (1 < enabled_pools) {
        ppVar2->enabled = POOL_DISABLED;
        ppVar1 = current_pool();
        if (ppVar2 == ppVar1) {
            switch_pools((pool *)0x0);
        }
        message(io_data, 0x30, paramid, (char *)0x0, isjson);
        return;
    }
    message(io_data, 0x33, paramid, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void enablepool(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    long paramid;
    pool *ppVar1;
    pool *selected;
    int iVar2;

    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
        return;
    }
    if ((param != (char *)0x0) && (*param != '\0')) {
        paramid = strtol(param, (char **)0x0, 10);
        if ((-1 < paramid) && (paramid < total_pools)) {
            selected = pools[paramid];
            if (selected->enabled != POOL_ENABLED) {
                iVar2 = selected->prio;
                selected->enabled = POOL_ENABLED;
                ppVar1 = current_pool();
                if (iVar2 < ppVar1->prio) {
                    switch_pools(selected);
                }
                message(io_data, 0x2f, paramid, (char *)0x0, isjson);
                return;
            }
            message(io_data, 0x31, paramid, (char *)0x0, isjson);
            return;
        }
        message(io_data, 0x1a, paramid, (char *)0x0, isjson);
        return;
    }
    message(io_data, 0x19, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void poolquota(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    char *pcVar1;
    long lVar2;
    pool *ppVar3;

    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
        return;
    }
    if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x19, 0, (char *)0x0, isjson);
        return;
    }
    pcVar1 = strchr(param, 0x2c);
    if (pcVar1 == (char *)0x0) {
        message(io_data, 0x56, 0, param, isjson);
        return;
    }
    *pcVar1 = '\0';
    lVar2 = strtol(param, (char **)0x0, 10);
    if ((-1 < lVar2) && (lVar2 < total_pools)) {
        ppVar3 = pools[lVar2];
        lVar2 = strtol(pcVar1 + 1, (char **)0x0, 10);
        if (-1 < lVar2) {
            ppVar3->quota = lVar2;
            adjust_quota_gcd();
            message(io_data, 0x7a, lVar2, ppVar3->rpc_url, isjson);
            return;
        }
        message(io_data, 0x79, lVar2, ppVar3->rpc_url, isjson);
        return;
    }
    message(io_data, 0x1a, lVar2, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void poolpriority(io_data *io_data, long c, char *param, _Bool isjson,
                  char group)

{
    int iVar1;
    int iVar2;
    int iVar3;
    pool **pppVar4;
    char *pcVar5;
    long paramid;
    int iVar6;
    pool *ppVar7;
    char *pcVar8;
    char *pcVar9;
    int iVar10;
    int iVar11;
    char cStack_31;
    io_data *local_30;
    uint local_2c;

    local_2c = (uint)isjson;
    local_30 = io_data;
    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
    } else if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x19, 0, (char *)0x0, isjson);
    } else {
        iVar1 = -(total_pools + 7U & 0xfffffff8);
        iVar2 = -(total_pools * 4 + 10U & 0xfffffff8);
        iVar11 = iVar2 + iVar1 + -0x30;
        if (0 < total_pools) {
            pcVar8 = &cStack_31 + iVar1;
            do {
                pcVar8 = pcVar8 + 1;
                *pcVar8 = '\0';
            } while (pcVar8 != &cStack_31 + total_pools + iVar1);
        }
        iVar6 = 0;
        while (true) {
            pcVar5 = strchr(param, 0x2c);
            pcVar8 = pcVar5;
            if (pcVar5 != (char *)0x0) {
                pcVar8 = pcVar5 + 1;
                *pcVar5 = '\0';
            }
            paramid = strtol(param, (char **)0x0, 10);
            pppVar4 = pools;
            iVar3 = total_pools;
            iVar10 = iVar6 + 1;
            if ((paramid < 0) || (total_pools <= paramid))
                break;
            if (*(char *)((int)&local_30 + paramid + iVar1) != '\0') {
                *(uint *)(&stack0xffffffc8 + iVar2 + iVar1) = local_2c;
                message(local_30, 0x4a, paramid, (char *)0x0,
                        (_Bool)(&stack0xffffffc8)[iVar2 + iVar1]);
                return;
            }
            *(int *)((int)&local_30 + paramid * 4 + iVar11 + 0x30) = iVar6;
            *(undefined1 *)((int)&local_30 + paramid + iVar1) = 1;
            if ((pcVar8 == (char *)0x0) ||
                (iVar6 = iVar10, param = pcVar8, *pcVar8 == '\0')) {
                pcVar5 = &cStack_31 + iVar1;
                pcVar9 = pcVar5 + total_pools;
                iVar6 = 0;
                pcVar8 = pcVar5;
                do {
                    pcVar8 = pcVar8 + 1;
                    if (*pcVar8 != '\0') {
                        pppVar4[iVar6]->prio = *(
                            int *)((int)&local_30 + iVar6 * 4 + iVar11 + 0x30);
                    }
                    iVar6 = iVar6 + 1;
                } while (pcVar8 != pcVar9);
                iVar11 = 0;
                do {
                    iVar6 = 0;
                    pcVar8 = pcVar5;
                    do {
                        pcVar8 = pcVar8 + 1;
                        if ((*pcVar8 == '\0') &&
                            (ppVar7 = pppVar4[iVar6], ppVar7->prio == iVar11)) {
                            ppVar7->prio = iVar10;
                            iVar10 = iVar10 + 1;
                            *(undefined1 *)((int)&local_30 + iVar6 + iVar1) = 1;
                            break;
                        }
                        iVar6 = iVar6 + 1;
                    } while (iVar3 != iVar6);
                    iVar11 = iVar11 + 1;
                    if (iVar3 == iVar11) {
                        ppVar7 = current_pool();
                        if (ppVar7->prio != 0) {
                            switch_pools((pool *)0x0);
                        }
                        *(uint *)(&stack0xffffffc8 + iVar2 + iVar1) = local_2c;
                        message(local_30, 0x49, 0, (char *)0x0,
                                (_Bool)(&stack0xffffffc8)[iVar2 + iVar1]);
                        return;
                    }
                } while (true);
            }
        }
        *(uint *)(&stack0xffffffc8 + iVar2 + iVar1) = local_2c;
        message(local_30, 0x1a, paramid, (char *)0x0,
                (_Bool)(&stack0xffffffc8)[iVar2 + iVar1]);
    }
    return;
}

/* WARNING: Unknown calling convention */

void addpool(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    char *pcVar2;
    pool *pool;
    char *url;
    char *user;
    char *pass;

    if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x34, 0, (char *)0x0, isjson);
    } else {
        _Var1 = pooldetails(param, &url, &user, &pass);
        if (_Var1) {
            pool = add_pool();
            detect_stratum(pool, url);
            add_pool_details(pool, true, url, user, pass);
            pcVar2 = escape_string(url, isjson);
            message(io_data, 0x37, pool->pool_no, pcVar2, isjson);
            if (url != pcVar2) {
                free(pcVar2);
            }
        } else {
            pcVar2 = escape_string(param, isjson);
            message(io_data, 0x35, 0, pcVar2, isjson);
            if (param != pcVar2) {
                free(pcVar2);
            }
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void switchpool(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    long paramid;
    int iVar1;
    int iVar2;
    char *func;
    char *func_00;
    char *func_01;
    char *func_02;
    int line;
    int line_00;
    int line_01;
    int line_02;
    int extraout_r3;
    pool *selected;

    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
        return;
    }
    if ((param != (char *)0x0) && (*param != '\0')) {
        paramid = strtol(param, (char **)0x0, 10);
        iVar1 = pthread_mutex_lock((pthread_mutex_t *)&control_lock);
        iVar2 = line;
        if (iVar1 != 0) {
            _mutex_lock((pthread_mutex_t *)"switchpool", (char *)0xb5b, func,
                        line);
            iVar2 = extraout_r3;
        }
        _rd_lock(&control_lock.rwlock, "switchpool", (char *)0xb5b, iVar2);
        iVar2 = pthread_mutex_unlock((pthread_mutex_t *)&control_lock);
        if (iVar2 != 0) {
            _mutex_unlock_noyield((pthread_mutex_t *)"switchpool",
                                  (char *)0xb5b, func_00, line_00);
        }
        if ((-1 < paramid) && (paramid < total_pools)) {
            selected = pools[paramid];
            selected->enabled = POOL_ENABLED;
            iVar2 =
                pthread_rwlock_unlock((pthread_rwlock_t *)&control_lock.rwlock);
            if (iVar2 != 0) {
                _rw_unlock((pthread_rwlock_t *)"switchpool", (char *)0xb65,
                           func_02, line_02);
            }
            (*selective_yield)();
            switch_pools(selected);
            message(io_data, 0x1b, paramid, (char *)0x0, isjson);
            return;
        }
        iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)&control_lock.rwlock);
        if (iVar2 != 0) {
            _rw_unlock((pthread_rwlock_t *)"switchpool", (char *)0xb5e, func_01,
                       line_01);
        }
        (*selective_yield)();
        message(io_data, 0x1a, paramid, (char *)0x0, isjson);
        return;
    }
    message(io_data, 0x19, 0, (char *)0x0, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void devstatus(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    message(io_data, 10, 0, (char *)0x0, isjson);
    return;
}

void edevstatus(io_data *param_1, undefined4 param_2, undefined4 param_3,
                _Bool param_4)

{
    message(param_1, 10, 0, (char *)0x0, param_4);
    return;
}

/* WARNING: Unknown calling convention */

void asccount(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    api_data *paVar2;
    int count;

    count = 0;
    message(io_data, 0x68, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var1 = io_add(io_data, ",\"ASCS\":[");
        paVar2 =
            api_add_data_full((api_data *)0x0, "Count", API_INT, &count, false);
        print_data(io_data, paVar2, true, false);
        if (_Var1) {
            io_data->close = true;
        }
        return;
    }
    io_add(io_data, "ASCS,");
    paVar2 =
        api_add_data_full((api_data *)0x0, "Count", API_INT, &count, isjson);
    print_data(io_data, paVar2, isjson, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void debugstate(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    __int32_t _Var1;
    _Bool _Var2;
    __int32_t **pp_Var3;
    api_data *paVar4;
    byte bVar5;

    if (param == (char *)0x0)
        goto switchD_0002ef5a_caseD_65;
    pp_Var3 = __ctype_tolower_loc();
    _Var1 = (*pp_Var3)[(byte)*param];
    *param = (char)_Var1;
    switch ((char)_Var1) {
    case 'd':
        opt_log_output = (_Bool)(opt_debug ^ 1);
        opt_debug = opt_log_output;
        if (opt_log_output == false)
            break;
        goto LAB_0002efa2;
    case 'n':
        opt_log_output = false;
        opt_debug = false;
        opt_quiet = false;
        opt_protocol = false;
        want_per_device_stats = false;
        opt_worktime = false;
        break;
    case 'p':
        opt_log_output = (_Bool)(want_per_device_stats ^ 1);
        want_per_device_stats = opt_log_output;
        break;
    case 'q':
        opt_quiet = (_Bool)(opt_quiet ^ 1);
        break;
    case 'r':
        opt_protocol = (_Bool)(opt_protocol ^ 1);
        bVar5 = opt_protocol;
        goto joined_r0x0002f214;
    case 's':
        opt_realquiet = true;
        break;
    case 'v':
        opt_log_output = (_Bool)(opt_log_output ^ 1);
        bVar5 = opt_log_output;
    joined_r0x0002f214:
        if (bVar5 != 0) {
        LAB_0002efa2:
            opt_quiet = false;
        }
        break;
    case 'w':
        opt_worktime = (_Bool)(opt_worktime ^ 1);
    }
switchD_0002ef5a_caseD_65:
    message(io_data, 0x4f, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var2 = io_add(io_data, ",\"DEBUG\":[");
        paVar4 = api_add_data_full((api_data *)0x0, "Silent", API_BOOL,
                                   &opt_realquiet, false);
        paVar4 =
            api_add_data_full(paVar4, "Quiet", API_BOOL, &opt_quiet, false);
        paVar4 = api_add_data_full(paVar4, "Verbose", API_BOOL, &opt_log_output,
                                   false);
        paVar4 =
            api_add_data_full(paVar4, "Debug", API_BOOL, &opt_debug, false);
        paVar4 = api_add_data_full(paVar4, "RPCProto", API_BOOL, &opt_protocol,
                                   false);
        paVar4 = api_add_data_full(paVar4, "PerDevice", API_BOOL,
                                   &want_per_device_stats, false);
        paVar4 = api_add_data_full(paVar4, "WorkTime", API_BOOL, &opt_worktime,
                                   false);
        print_data(io_data, paVar4, true, false);
        if (_Var2) {
            io_data->close = true;
        }
        return;
    }
    io_add(io_data, "DEBUG,");
    paVar4 = api_add_data_full((api_data *)0x0, "Silent", API_BOOL,
                               &opt_realquiet, isjson);
    paVar4 = api_add_data_full(paVar4, "Quiet", API_BOOL, &opt_quiet, isjson);
    paVar4 =
        api_add_data_full(paVar4, "Verbose", API_BOOL, &opt_log_output, isjson);
    paVar4 = api_add_data_full(paVar4, "Debug", API_BOOL, &opt_debug, isjson);
    paVar4 =
        api_add_data_full(paVar4, "RPCProto", API_BOOL, &opt_protocol, isjson);
    paVar4 = api_add_data_full(paVar4, "PerDevice", API_BOOL,
                               &want_per_device_stats, isjson);
    paVar4 =
        api_add_data_full(paVar4, "WorkTime", API_BOOL, &opt_worktime, isjson);
    print_data(io_data, paVar4, isjson, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void checkcommand(io_data *io_data, long c, char *param, _Bool isjson,
                  char group)

{
    _Bool _Var1;
    int iVar2;
    __int32_t **pp_Var3;
    char *pcVar4;
    api_data *paVar5;
    __int32_t *p_Var6;
    undefined1 extraout_r3;
    undefined1 uVar7;
    undefined *puVar8;
    CMDS *pCVar9;
    bool bVar10;
    char cmdbuf[100];

    if ((param == (char *)0x0) || (*param == '\0')) {
        message(io_data, 0x47, 0, (char *)0x0, isjson);
        return;
    }
    if (cmds[0].name == (char *)0x0) {
        message(io_data, 0x48, 0, (char *)0x0, isjson);
    } else {
        pCVar9 = cmds;
        pcVar4 = cmds[0].name;
        do {
            iVar2 = strcmp(pcVar4, param);
            if (iVar2 == 0) {
                sprintf(cmdbuf, "|%s|", param);
                pp_Var3 = __ctype_toupper_loc();
                p_Var6 = *pp_Var3;
                if ((p_Var6[(byte)group] != p_Var6[0x57]) &&
                    (pcVar4 = strstr(
                         apigroups[p_Var6[(byte)group] - p_Var6[0x41]].commands,
                         cmdbuf),
                     pcVar4 == (char *)0x0)) {
                    message(io_data, 0x48, 0, (char *)0x0, isjson);
                    if (isjson) {
                        _Var1 = io_add(io_data, ",\"CHECK\":[");
                        puVar8 = &DAT_00055554;
                    } else {
                        _Var1 = io_add(io_data, "CHECK,");
                        puVar8 = &DAT_00055554;
                    }
                    goto LAB_0002f34a;
                }
                message(io_data, 0x48, 0, (char *)0x0, isjson);
                if (isjson) {
                    _Var1 = io_add(io_data, ",\"CHECK\":[");
                } else {
                    _Var1 = io_add(io_data, "CHECK,");
                }
                paVar5 = api_add_data_full((api_data *)0x0, "Exists", API_CONST,
                                           &DAT_00055554, false);
                puVar8 = &DAT_00055554;
                goto LAB_0002f2e4;
            }
            pCVar9 = pCVar9 + 1;
            pcVar4 = pCVar9->name;
        } while (pcVar4 != (char *)0x0);
        message(io_data, 0x48, 0, (char *)0x0, isjson);
    }
    if (isjson) {
        _Var1 = io_add(io_data, ",\"CHECK\":[");
        puVar8 = &DAT_00055558;
    } else {
        _Var1 = io_add(io_data, "CHECK,");
        puVar8 = &DAT_00055558;
    }
LAB_0002f34a:
    paVar5 =
        api_add_data_full((api_data *)0x0, "Exists", API_CONST, puVar8, false);
    puVar8 = &DAT_00055558;
LAB_0002f2e4:
    paVar5 = api_add_data_full(paVar5, "Access", API_CONST, puVar8, false);
    print_data(io_data, paVar5, isjson, false);
    bVar10 = (isjson & _Var1) != 0;
    uVar7 = extraout_r3;
    if (bVar10) {
        uVar7 = true;
    }
    if (bVar10) {
        io_data->close = (_Bool)uVar7;
    }
    return;
}

/* WARNING: Unknown calling convention */

void devdetails(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    cgpu_info *pcVar2;
    undefined1 precom;
    char *pcVar3;
    int iVar4;
    char *pcVar5;
    api_data *paVar6;
    int i;

    if (total_devices == 0) {
        message(io_data, 10, 0, (char *)0x0, isjson);
        return;
    }
    message(io_data, 0x45, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var1 = io_add(io_data, ",\"DEVDETAILS\":[");
        if (total_devices < 1)
            goto LAB_0002f4f8;
    } else {
        if (total_devices < 1) {
            return;
        }
        _Var1 = false;
    }
    i = 0;
    paVar6 = (api_data *)0x0;
    pcVar5 = "";
    do {
        pcVar2 = get_devices(i);
        paVar6 = api_add_data_full(paVar6, "DEVDETAILS", API_INT, &i, false);
        paVar6 = api_add_data_full(paVar6, "Name", API_STRING,
                                   pcVar2->drv->name, false);
        paVar6 =
            api_add_data_full(paVar6, "ID", API_INT, &pcVar2->device_id, false);
        paVar6 = api_add_data_full(paVar6, "Driver", API_STRING,
                                   pcVar2->drv->dname, false);
        pcVar3 = pcVar2->kname;
        if (pcVar2->kname == (char *)0x0) {
            pcVar3 = pcVar5;
        }
        paVar6 = api_add_data_full(paVar6, "Kernel", API_CONST, pcVar3, false);
        pcVar3 = pcVar2->name;
        if (pcVar2->name == (char *)0x0) {
            pcVar3 = pcVar5;
        }
        paVar6 = api_add_data_full(paVar6, "Model", API_CONST, pcVar3, false);
        pcVar3 = pcVar2->device_path;
        if (pcVar2->device_path == (char *)0x0) {
            pcVar3 = pcVar5;
        }
        paVar6 =
            api_add_data_full(paVar6, "Device Path", API_CONST, pcVar3, false);
        precom = isjson;
        if (isjson) {
            iVar4 = i;
            if (i < 1) {
                iVar4 = 0;
            }
            precom = (undefined1)iVar4;
            if (0 < i) {
                precom = true;
            }
        }
        paVar6 = print_data(io_data, paVar6, isjson, (_Bool)precom);
        i = i + 1;
    } while (i < total_devices);
LAB_0002f4f8:
    if (_Var1 != false) {
        io_data->close = true;
    }
    return;
}

/* WARNING: Unknown calling convention */

void pgacount(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    api_data *paVar2;
    int count;

    count = 0;
    message(io_data, 0x3b, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var1 = io_add(io_data, ",\"PGAS\":[");
        paVar2 =
            api_add_data_full((api_data *)0x0, "Count", API_INT, &count, false);
        print_data(io_data, paVar2, true, false);
        if (_Var1) {
            io_data->close = true;
        }
        return;
    }
    io_add(io_data, "PGAS,");
    paVar2 =
        api_add_data_full((api_data *)0x0, "Count", API_INT, &count, isjson);
    print_data(io_data, paVar2, isjson, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void minerconfig(io_data *io_data, long c, char *param, _Bool isjson,
                 char group)

{
    _Bool _Var1;
    api_data *paVar2;
    char *buf;
    undefined1 extraout_r3;
    undefined1 uVar3;
    _Bool io_open;
    int asccount;
    int pgacount;

    asccount = 0;
    pgacount = 0;
    message(io_data, 0x21, 0, (char *)0x0, isjson);
    buf = ",\"CONFIG\":[";
    if (!isjson) {
        buf = "CONFIG,";
    }
    _Var1 = io_add(io_data, buf);
    paVar2 = api_add_data_full((api_data *)0x0, "ASC Count", API_INT, &asccount,
                               false);
    paVar2 = api_add_data_full(paVar2, "PGA Count", API_INT, &pgacount, false);
    paVar2 =
        api_add_data_full(paVar2, "Pool Count", API_INT, &total_pools, false);
    paVar2 =
        api_add_data_full(paVar2, "Strategy", API_CONST,
                          *(void **)(strategies + pool_strategy * 4), false);
    paVar2 = api_add_data_full(paVar2, "Log Interval", API_INT,
                               &opt_log_interval, false);
    paVar2 = api_add_data_full(paVar2, "Device Code", API_CONST, "", false);
    paVar2 = api_add_data_full(paVar2, "OS", API_CONST, "Linux", false);
    paVar2 = api_add_data_full(paVar2, "Failover-Only", API_BOOL,
                               &opt_fail_only, false);
    paVar2 =
        api_add_data_full(paVar2, "ScanTime", API_INT, &opt_scantime, false);
    paVar2 = api_add_data_full(paVar2, "Queue", API_INT, &opt_queue, false);
    paVar2 = api_add_data_full(paVar2, "Expiry", API_INT, &opt_expiry, false);
    paVar2 =
        api_add_data_full(paVar2, "Hotplug", API_CONST, &DAT_00055678, false);
    print_data(io_data, paVar2, isjson, false);
    uVar3 = extraout_r3;
    if (isjson && _Var1) {
        uVar3 = true;
    }
    if (isjson && _Var1) {
        io_data->close = (_Bool)uVar3;
    }
    return;
}

/* WARNING: Unknown calling convention */

void apiversion(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    api_data *paVar2;

    message(io_data, 0x16, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var1 = io_add(io_data, ",\"VERSION\":[");
        paVar2 = api_add_data_full((api_data *)0x0, "CGMiner", API_STRING,
                                   "4.9.0", false);
        paVar2 =
            api_add_data_full(paVar2, "API", API_CONST, &DAT_000556a0, false);
        paVar2 = api_add_data_full(paVar2, "Miner", API_STRING, g_miner_version,
                                   false);
        paVar2 = api_add_data_full(paVar2, "CompileTime", API_STRING,
                                   g_miner_compiletime, false);
        paVar2 =
            api_add_data_full(paVar2, "Type", API_STRING, g_miner_type, false);
        print_data(io_data, paVar2, true, false);
        if (_Var1) {
            io_data->close = true;
        }
        return;
    }
    io_add(io_data, "VERSION,");
    paVar2 = api_add_data_full((api_data *)0x0, "CGMiner", API_STRING, "4.9.0",
                               isjson);
    paVar2 = api_add_data_full(paVar2, "API", API_CONST, &DAT_000556a0, isjson);
    paVar2 =
        api_add_data_full(paVar2, "Miner", API_STRING, g_miner_version, isjson);
    paVar2 = api_add_data_full(paVar2, "CompileTime", API_STRING,
                               g_miner_compiletime, isjson);
    paVar2 =
        api_add_data_full(paVar2, "Type", API_STRING, g_miner_type, isjson);
    print_data(io_data, paVar2, isjson, isjson);
    return;
}

/* WARNING: Unknown calling convention */

void lcddisplay(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    char cVar1;
    pool *ppVar2;
    api_data *paVar3;
    double ghs;
    char szindex[32];
    char szfan[32];
    char sztemp[32];
    char szpool[32];
    char szuser[32];

    memset(szindex, 0, 0x20);
    memset(szfan, 0, 0x20);
    memset(sztemp, 0, 0x20);
    memset(szpool, 0, 0x20);
    memset(szuser, 0, 0x20);
    ppVar2 = current_pool();
    message(io_data, 7, 0, (char *)0x0, isjson);
    cVar1 = isjson;
    if (isjson) {
        cVar1 = io_add(io_data, ",\"POOLS\":[");
    }
    szindex[0] = '0';
    szindex[1] = '\0';
    ghs = (total_mhashes_done / 1000.0) / total_secs;
    paVar3 =
        api_add_data_full((api_data *)0x0, "LCD", API_STRING, szindex, false);
    paVar3 = api_add_data_full(paVar3, "GHS5s", API_MHS, &g_displayed_rolling,
                               false);
    paVar3 = api_add_data_full(paVar3, "GHSavg", API_MHS, &ghs, false);
    sprintf(szfan, "%d", g_max_fan);
    paVar3 = api_add_data_full(paVar3, "fan", API_STRING, szfan, false);
    sprintf(sztemp, "%d", g_max_temp);
    paVar3 = api_add_data_full(paVar3, "temp", API_STRING, sztemp, false);
    if (ppVar2 == (pool *)0x0) {
        szpool[0] = 'n';
        szpool[1] = 'o';
        szpool[2] = '\0';
        szuser._0_2_ = szpool._0_2_;
        szuser[2] = szpool[2];
        paVar3 = api_add_data_full(paVar3, "pool", API_STRING, szpool, false);
        paVar3 = api_add_data_full(paVar3, "user", API_STRING, szuser, false);
    } else {
        paVar3 = api_add_data_full(paVar3, "pool", API_STRING, ppVar2->rpc_url,
                                   false);
        paVar3 = api_add_data_full(paVar3, "user", API_STRING, ppVar2->rpc_user,
                                   false);
    }
    print_data(io_data, paVar3, isjson, isjson);
    if (cVar1 != '\0') {
        io_data->close = true;
    }
    return;
}

int itemstats(io_data *io_data, int i, char *id, cgminer_stats *stats,
              cgminer_pool_stats *pool_stats, api_data *extra, cgpu_info *cgpu,
              _Bool isjson)

{
    api_data *paVar1;
    cgminer_pool_stats *pcVar2;
    cgminer_pool_stats *root;
    undefined1 precom;
    int iVar3;
    int local_2c;
    double ghs;

    ghs = total_mhashes_done / total_secs;
    local_2c = i;
    paVar1 =
        api_add_data_full((api_data *)0x0, "STATS", API_INT, &local_2c, false);
    paVar1 = api_add_data_full(paVar1, "ID", API_STRING, id, false);
    paVar1 =
        api_add_data_full(paVar1, "Elapsed", API_ELAPSED, &total_secs, false);
    paVar1 = api_add_data_full(paVar1, "Calls", API_UINT32, stats, false);
    paVar1 = api_add_data_full(paVar1, "Wait", API_TIMEVAL,
                               &stats->getwork_wait, false);
    paVar1 = api_add_data_full(paVar1, "Max", API_TIMEVAL,
                               &stats->getwork_wait_max, false);
    paVar1 = api_add_data_full(paVar1, "Min", API_TIMEVAL,
                               &stats->getwork_wait_min, false);
    paVar1 = api_add_data_full(paVar1, "GHS 5s", API_STRING,
                               displayed_hash_rate, false);
    pcVar2 = (cgminer_pool_stats *)api_add_data_full(paVar1, "GHS av", API_MHS,
                                                     &ghs, false);
    root = pcVar2;
    if ((pool_stats != (cgminer_pool_stats *)0x0) &&
        (root = pool_stats, pcVar2 != (cgminer_pool_stats *)0x0)) {
        paVar1 = (api_data *)(pool_stats->getwork_wait_max).tv_sec;
        (pool_stats->getwork_wait_max).tv_sec =
            (__time_t)(pcVar2->getwork_wait_max).tv_sec;
        ((api_data *)(pcVar2->getwork_wait_max).tv_sec)->next =
            (api_data *)pool_stats;
        paVar1->next = (api_data *)pcVar2;
        (pcVar2->getwork_wait_max).tv_sec = (__time_t)paVar1;
        root = pcVar2;
    }
    precom = extra._0_1_;
    if (extra._0_1_ != false) {
        iVar3 = local_2c;
        if (local_2c < 1) {
            iVar3 = 0;
        }
        precom = (undefined1)iVar3;
        if (0 < local_2c) {
            precom = true;
        }
    }
    print_data(io_data, (api_data *)root, extra._0_1_, (_Bool)precom);
    return local_2c + 1;
}

/* WARNING: Unknown calling convention */

void minerestats(io_data *io_data, long c, char *param, _Bool isjson,
                 char group)

{
    _Bool _Var1;
    cgpu_info *pcVar2;
    device_drv *pdVar4;
    int id_00;
    cgminer_pool_stats *pool_stats;
    int i;
    cgpu_info *in_stack_ffffffb8;
    char id[20];
    uint uVar3;

    message(io_data, 0x46, 0, (char *)0x0, isjson);
    if ((api_data *)(uint)isjson == (api_data *)0x0) {
        if (total_devices < 1) {
            return;
        }
        uVar3 = 0;
    } else {
        _Var1 = io_add(io_data, ",\"STATS\":[");
        uVar3 = (uint)_Var1;
        if (total_devices < 1)
            goto LAB_0002fc00;
    }
    id_00 = 0;
    i = 0;
    do {
        pcVar2 = get_devices(id_00);
        if ((pcVar2 != (cgpu_info *)0x0) &&
            (pdVar4 = pcVar2->drv, pdVar4 != (device_drv *)0x0)) {
            pool_stats = (cgminer_pool_stats *)pdVar4->get_api_stats;
            if (pool_stats != (cgminer_pool_stats *)0x0) {
                pool_stats = (cgminer_pool_stats *)(*(code *)pool_stats)();
                pdVar4 = pcVar2->drv;
            }
            sprintf(id, "%s%d", pdVar4->name, pcVar2->device_id);
            i = itemstats(io_data, i, id, &pcVar2->cgminer_stats, pool_stats,
                          (api_data *)(uint)isjson, in_stack_ffffffb8,
                          SUB41(uVar3, 0));
        }
        id_00 = id_00 + 1;
    } while (id_00 < total_devices);
LAB_0002fc00:
    if (uVar3 != 0) {
        io_data->close = true;
    }
    return;
}

/* WARNING: Unknown calling convention */

void minerstats(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    api_data *paVar2;
    cgpu_info *pcVar3;
    device_drv *pdVar5;
    int id_00;
    cgminer_pool_stats *pool_stats;
    int i;
    cgpu_info *in_stack_ffffffb8;
    char id[20];
    uint uVar4;

    message(io_data, 0x46, 0, (char *)0x0, isjson);
    if ((api_data *)(uint)isjson == (api_data *)0x0) {
        paVar2 = api_add_data_full((api_data *)0x0, "CGMiner", API_STRING,
                                   "4.9.0", isjson);
        paVar2 = api_add_data_full(paVar2, "Miner", API_STRING, g_miner_version,
                                   isjson);
        paVar2 = api_add_data_full(paVar2, "CompileTime", API_STRING,
                                   g_miner_compiletime, isjson);
        paVar2 =
            api_add_data_full(paVar2, "Type", API_STRING, g_miner_type, isjson);
        print_data(io_data, paVar2, isjson, isjson);
        if (total_devices < 1) {
            return;
        }
        uVar4 = 0;
    } else {
        _Var1 = io_add(io_data, ",\"STATS\":[");
        uVar4 = (uint)_Var1;
        paVar2 = api_add_data_full((api_data *)0x0, "CGMiner", API_STRING,
                                   "4.9.0", false);
        paVar2 = api_add_data_full(paVar2, "Miner", API_STRING, g_miner_version,
                                   false);
        paVar2 = api_add_data_full(paVar2, "CompileTime", API_STRING,
                                   g_miner_compiletime, false);
        paVar2 =
            api_add_data_full(paVar2, "Type", API_STRING, g_miner_type, false);
        print_data(io_data, paVar2, true, false);
        if (total_devices < 1)
            goto LAB_0002fd1a;
    }
    id_00 = 0;
    i = 0;
    do {
        pcVar3 = get_devices(id_00);
        if ((pcVar3 != (cgpu_info *)0x0) &&
            (pdVar5 = pcVar3->drv, pdVar5 != (device_drv *)0x0)) {
            pool_stats = (cgminer_pool_stats *)pdVar5->get_api_stats;
            if (pool_stats != (cgminer_pool_stats *)0x0) {
                pool_stats = (cgminer_pool_stats *)(*(code *)pool_stats)();
                pdVar5 = pcVar3->drv;
            }
            sprintf(id, "%s%d", pdVar5->name, pcVar3->device_id);
            i = itemstats(io_data, i, id, &pcVar3->cgminer_stats, pool_stats,
                          (api_data *)(uint)isjson, in_stack_ffffffb8,
                          SUB41(uVar4, 0));
        }
        id_00 = id_00 + 1;
    } while (id_00 < total_devices);
LAB_0002fd1a:
    if (uVar4 != 0) {
        io_data->close = true;
    }
    return;
}

/* WARNING: Unknown calling convention */

void minecoin(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    api_data *paVar2;
    int iVar3;
    int iVar4;
    char *buf;
    char *func;
    char *func_00;
    char *func_01;
    int line;
    int line_00;
    int line_01;
    int extraout_r3;
    _Bool io_open;

    message(io_data, 0x4e, 0, (char *)0x0, isjson);
    buf = ",\"COIN\":[";
    if (!isjson) {
        buf = "COIN,";
    }
    _Var1 = io_add(io_data, buf);
    paVar2 = api_add_data_full((api_data *)0x0, "Hash Method", API_CONST,
                               "sha256", false);
    iVar3 = pthread_mutex_lock((pthread_mutex_t *)&ch_lock);
    iVar4 = line;
    if (iVar3 != 0) {
        _mutex_lock((pthread_mutex_t *)"minecoin", (char *)0xe72, func, line);
        iVar4 = extraout_r3;
    }
    _rd_lock(&ch_lock.rwlock, "minecoin", (char *)0xe72, iVar4);
    iVar4 = pthread_mutex_unlock((pthread_mutex_t *)&ch_lock);
    if (iVar4 != 0) {
        _mutex_unlock_noyield((pthread_mutex_t *)"minecoin", (char *)0xe72,
                              func_00, line_00);
    }
    paVar2 = api_add_data_full(paVar2, "Current Block Time", API_TIMEVAL,
                               &block_timeval, true);
    paVar2 = api_add_data_full(paVar2, "Current Block Hash", API_STRING,
                               current_hash, true);
    iVar4 = pthread_rwlock_unlock((pthread_rwlock_t *)&ch_lock.rwlock);
    if (iVar4 != 0) {
        _rw_unlock((pthread_rwlock_t *)"minecoin", (char *)0xe75, func_01,
                   line_01);
    }
    (*selective_yield)();
    paVar2 = api_add_data_full(paVar2, "LP", API_BOOL, &have_longpoll, false);
    paVar2 = api_add_data_full(paVar2, "Network Difficulty", API_DIFF,
                               &current_diff, true);
    print_data(io_data, paVar2, isjson, false);
    if (isjson && _Var1) {
        io_data->close = true;
    }
    return;
}

/* WARNING: Unknown calling convention */

void summary(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    longlong lVar1;
    bool bVar2;
    ulonglong uVar3;
    _Bool _Var4;
    int iVar5;
    undefined4 uVar6;
    api_data *paVar7;
    uint uVar8;
    uint uVar9;
    int iVar10;
    char *buf;
    char *func;
    char *func_00;
    io_data *extraout_r2;
    io_data *piVar11;
    int line;
    int line_00;
    int iVar12;
    DFtype extraout_d0;
    DFtype a;
    DFtype extraout_d0_00;
    double dVar13;
    double dVar14;
    _Bool io_open;
    double utility;
    double ghs;
    double work_utility;
    double hwp;
    double rejp;
    double prejp;
    double stalep;

    message(io_data, 0xb, 0, (char *)0x0, isjson);
    buf = "SUMMARY,";
    if (isjson) {
        buf = ",\"SUMMARY\":[";
    }
    _Var4 = io_add(io_data, buf);
    iVar5 = pthread_mutex_lock((pthread_mutex_t *)&hash_lock);
    a = extraout_d0;
    if (iVar5 != 0) {
        _mutex_lock((pthread_mutex_t *)"summary", (char *)0xae9, func, line);
        a = extraout_d0_00;
    }
    total_diff1 = __fixdfdi(a);
    uVar3 = (ulonglong)total_diff1 >> 0x20;
    uVar6 = (undefined4)total_diff1;
    dVar13 =
        (double)__aeabi_l2d((undefined4)total_accepted, total_accepted._4_4_);
    if (total_secs == 0.0) {
        dVar14 = 1.0;
    } else {
        dVar13 = dVar13 / total_secs;
        dVar14 = total_secs;
    }
    utility = dVar13 * 60.0;
    ghs = total_mhashes_done / total_secs;
    dVar13 = (double)__aeabi_l2d(uVar6, (int)uVar3);
    work_utility = (dVar13 / dVar14) * 60.0;
    if (certification_firmware == false)
        goto LAB_00030010;
    uVar8 = time((time_t *)0x0);
    srand(uVar8);
    if (((*cert_devname == 'z') && (cert_devname[1] == '9')) &&
        (cert_devname[2] == '\0')) {
        iVar5 = rt_chain_num * 0xe;
    LAB_000303f0:
        uVar9 = rand();
        uVar8 = uVar9 & 1;
        if ((int)uVar9 < 0) {
            uVar8 = -uVar8;
        }
        iVar5 = uVar8 + iVar5;
        iVar12 = iVar5 % 5;
    } else {
        iVar12 = 4;
        iVar5 = 0xe;
        iVar10 = strcmp(cert_devname, "z9-mini");
        if (iVar10 == 0) {
            iVar5 = rt_chain_num * 3 + 1;
            goto LAB_000303f0;
        }
    }
    uVar8 = time((time_t *)0x0);
    srand(uVar8);
    iVar10 = rand();
    dVar13 = (double)(longlong)(iVar10 % 99) / 100.0;
    dVar14 = (double)(longlong)iVar5 + dVar13;
    utility = (double)(longlong)iVar12 + dVar13;
    rt_hashrate_total = dVar14;
    ghs = dVar14;
    uVar9 = rand();
    uVar8 = uVar9 & 3;
    if ((int)uVar9 < 1) {
        uVar8 = -(-uVar9 & 3);
    }
    work_utility = (double)(longlong)(int)(uVar8 + 100) + 0.27;
    sprintf(displayed_hash_rate, "%f", SUB84(dVar14 + 0.79, 0),
            (int)((ulonglong)(dVar14 + 0.79) >> 0x20));
LAB_00030010:
    paVar7 = api_add_data_full((api_data *)0x0, "Elapsed", API_ELAPSED,
                               &total_secs, true);
    paVar7 = api_add_data_full(paVar7, "GHS 5s", API_STRING,
                               displayed_hash_rate, false);
    paVar7 = api_add_data_full(paVar7, "GHS av", API_MHS, &ghs, false);
    paVar7 = api_add_data_full(paVar7, "Found Blocks", API_UINT, &found_blocks,
                               true);
    paVar7 =
        api_add_data_full(paVar7, "Getworks", API_INT64, &total_getworks, true);
    paVar7 =
        api_add_data_full(paVar7, "Accepted", API_INT64, &total_accepted, true);
    paVar7 =
        api_add_data_full(paVar7, "Rejected", API_INT64, &total_rejected, true);
    paVar7 =
        api_add_data_full(paVar7, "Hardware Errors", API_INT, &hw_errors, true);
    paVar7 = api_add_data_full(paVar7, "Utility", API_UTILITY, &utility, false);
    paVar7 = api_add_data_full(paVar7, "Discarded", API_INT64, &total_discarded,
                               true);
    paVar7 = api_add_data_full(paVar7, "Stale", API_INT64, &total_stale, true);
    paVar7 =
        api_add_data_full(paVar7, "Get Failures", API_UINT, &total_go, true);
    paVar7 =
        api_add_data_full(paVar7, "Local Work", API_UINT, &local_work, true);
    paVar7 =
        api_add_data_full(paVar7, "Remote Failures", API_UINT, &total_ro, true);
    paVar7 = api_add_data_full(paVar7, "Network Blocks", API_UINT, &new_blocks,
                               true);
    paVar7 = api_add_data_full(paVar7, "Total MH", API_MHTOTAL,
                               &total_mhashes_done, true);
    paVar7 = api_add_data_full(paVar7, "Work Utility", API_UTILITY,
                               &work_utility, false);
    paVar7 = api_add_data_full(paVar7, "Difficulty Accepted", API_DIFF,
                               &total_diff_accepted, true);
    paVar7 = api_add_data_full(paVar7, "Difficulty Rejected", API_DIFF,
                               &total_diff_rejected, true);
    paVar7 = api_add_data_full(paVar7, "Difficulty Stale", API_DIFF,
                               &total_diff_stale, true);
    paVar7 =
        api_add_data_full(paVar7, "Best Share", API_UINT64, &best_diff, true);
    iVar5 = total_diff1._4_4_ + (hw_errors >> 0x1f) +
            (uint)CARRY4((uint)total_diff1, hw_errors);
    if ((uint)total_diff1 + hw_errors == 0 && iVar5 == 0) {
        dVar13 = 0.0;
    } else {
        lVar1 = (longlong)hw_errors;
        dVar13 = (double)__aeabi_l2d((uint)total_diff1 + hw_errors, iVar5);
        dVar13 = (double)lVar1 / dVar13;
    }
    hwp._4_4_ = (undefined4)((ulonglong)dVar13 >> 0x20);
    hwp._0_4_ = SUB84(dVar13, 0);
    paVar7 =
        api_add_data_full(paVar7, "Device Hardware%", API_PERCENT, &hwp, false);
    if ((uint)total_diff1 == 0 && total_diff1._4_4_ == 0) {
        dVar13 = 0.0;
    } else {
        dVar13 = (double)__aeabi_l2d();
        dVar13 = total_diff_rejected / dVar13;
    }
    rejp._4_4_ = (undefined4)((ulonglong)dVar13 >> 0x20);
    rejp._0_4_ = SUB84(dVar13, 0);
    paVar7 = api_add_data_full(paVar7, "Device Rejected%", API_PERCENT, &rejp,
                               false);
    dVar13 = total_diff_rejected + total_diff_accepted + total_diff_stale;
    if (dVar13 == 0.0) {
        dVar13 = 0.0;
    } else {
        dVar13 = total_diff_rejected / dVar13;
    }
    prejp._4_4_ = (undefined4)((ulonglong)dVar13 >> 0x20);
    prejp._0_4_ = SUB84(dVar13, 0);
    paVar7 =
        api_add_data_full(paVar7, "Pool Rejected%", API_PERCENT, &prejp, false);
    dVar13 = total_diff_accepted + total_diff_rejected + total_diff_stale;
    if (dVar13 == 0.0) {
        stalep = 0.0;
    } else {
        stalep = total_diff_stale / dVar13;
    }
    paVar7 =
        api_add_data_full(paVar7, "Pool Stale%", API_PERCENT, &stalep, false);
    paVar7 = api_add_data_full(paVar7, "Last getwork", API_TIME, &last_getwork,
                               false);
    iVar5 = pthread_mutex_unlock((pthread_mutex_t *)&hash_lock);
    if (iVar5 != 0) {
        _mutex_unlock_noyield((pthread_mutex_t *)"summary", (char *)0xb2e,
                              func_00, line_00);
    }
    (*selective_yield)();
    print_data(io_data, paVar7, isjson, false);
    bVar2 = isjson && _Var4;
    piVar11 = extraout_r2;
    if (bVar2) {
        _Var4 = true;
        piVar11 = io_data;
    }
    if (bVar2) {
        piVar11->close = _Var4;
    }
    return;
}

/* WARNING: Unknown calling convention */

void poolstatus(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    time_t tVar2;
    uint uVar3;
    api_data *paVar4;
    undefined1 precom;
    int iVar5;
    pool *ppVar6;
    undefined *data;
    pool_enable pVar7;
    char *pcVar8;
    uint uVar9;
    double dVar10;
    api_data *local_15c;
    undefined *local_154;
    int i;
    double rejp;
    double stalep;
    char lasttime[256];

    memset(lasttime, 0, 0x100);
    if (total_pools == 0) {
        message(io_data, 8, 0, (char *)0x0, isjson);
        return;
    }
    message(io_data, 7, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var1 = io_add(io_data, ",\"POOLS\":[");
        if (total_pools < 1)
            goto LAB_0003099e;
    } else {
        if (total_pools < 1) {
            return;
        }
        _Var1 = false;
    }
    i = 0;
    local_15c = (api_data *)0x0;
    local_154 = &DAT_00055558;
    do {
        ppVar6 = pools[i];
        if (ppVar6->removed == false) {
            pVar7 = ppVar6->enabled;
            if (pVar7 == POOL_ENABLED) {
                pcVar8 = "Alive";
                if (ppVar6->idle != false) {
                    pcVar8 = "Dead";
                }
            } else if (pVar7 == POOL_DISABLED) {
                pcVar8 = "Disabled";
            } else {
                pcVar8 = "Rejecting";
                if (pVar7 != POOL_REJECTING) {
                    pcVar8 = "Unknown";
                }
            }
            data = &DAT_00055554;
            if (ppVar6->hdr_path == (char *)0x0) {
                data = local_154;
            }
            if (ppVar6->last_share_time < 1) {
                lasttime[0] = '0';
                lasttime[1] = '\0';
            } else {
                tVar2 = time((time_t *)0x0);
                uVar3 = tVar2 - ppVar6->last_share_time;
                uVar3 = uVar3 & ~((int)uVar3 >> 0x1f);
                uVar9 = uVar3 % 0xe10;
                sprintf(lasttime, "%d:%02d:%02d", uVar3 / 0xe10, uVar9 / 0x3c,
                        uVar9 % 0x3c);
            }
            paVar4 = api_add_data_full(local_15c, "POOL", API_INT, &i, false);
            paVar4 = api_add_data_full(paVar4, "URL", API_ESCAPE,
                                       ppVar6->rpc_url, false);
            paVar4 =
                api_add_data_full(paVar4, "Status", API_STRING, pcVar8, false);
            paVar4 = api_add_data_full(paVar4, "Priority", API_INT,
                                       &ppVar6->prio, false);
            paVar4 = api_add_data_full(paVar4, "Quota", API_INT, &ppVar6->quota,
                                       false);
            paVar4 =
                api_add_data_full(paVar4, "Long Poll", API_STRING, data, false);
            paVar4 = api_add_data_full(paVar4, "Getworks", API_UINT,
                                       &ppVar6->getwork_requested, false);
            paVar4 = api_add_data_full(paVar4, "Accepted", API_INT64,
                                       &ppVar6->accepted, false);
            paVar4 = api_add_data_full(paVar4, "Rejected", API_INT64,
                                       &ppVar6->rejected, false);
            paVar4 = api_add_data_full(paVar4, "Discarded", API_UINT,
                                       &ppVar6->discarded_work, false);
            paVar4 = api_add_data_full(paVar4, "Stale", API_UINT,
                                       &ppVar6->stale_shares, false);
            paVar4 = api_add_data_full(paVar4, "Get Failures", API_UINT,
                                       &ppVar6->getfail_occasions, false);
            paVar4 = api_add_data_full(paVar4, "Remote Failures", API_UINT,
                                       &ppVar6->remotefail_occasions, false);
            paVar4 = api_add_data_full(paVar4, "User", API_ESCAPE,
                                       ppVar6->rpc_user, false);
            paVar4 = api_add_data_full(paVar4, "Last Share Time", API_STRING,
                                       lasttime, false);
            paVar4 = api_add_data_full(paVar4, "Diff", API_STRING, ppVar6->diff,
                                       false);
            paVar4 = api_add_data_full(paVar4, "Diff1 Shares", API_INT64,
                                       &ppVar6->diff1, false);
            if (ppVar6->rpc_proxy == (char *)0x0) {
                paVar4 = api_add_data_full(paVar4, "Proxy Type", API_CONST, "",
                                           false);
                paVar4 =
                    api_add_data_full(paVar4, "Proxy", API_CONST, "", false);
            } else {
                pcVar8 = proxytype(ppVar6->rpc_proxytype);
                paVar4 = api_add_data_full(paVar4, "Proxy Type", API_CONST,
                                           pcVar8, false);
                paVar4 = api_add_data_full(paVar4, "Proxy", API_ESCAPE,
                                           ppVar6->rpc_proxy, false);
            }
            paVar4 = api_add_data_full(paVar4, "Difficulty Accepted", API_DIFF,
                                       &ppVar6->diff_accepted, false);
            paVar4 = api_add_data_full(paVar4, "Difficulty Rejected", API_DIFF,
                                       &ppVar6->diff_rejected, false);
            paVar4 = api_add_data_full(paVar4, "Difficulty Stale", API_DIFF,
                                       &ppVar6->diff_stale, false);
            paVar4 =
                api_add_data_full(paVar4, "Last Share Difficulty", API_DIFF,
                                  &ppVar6->last_share_diff, false);
            paVar4 = api_add_data_full(paVar4, "Has Stratum", API_BOOL,
                                       &ppVar6->has_stratum, false);
            paVar4 = api_add_data_full(paVar4, "Stratum Active", API_BOOL,
                                       &ppVar6->stratum_active, false);
            if (ppVar6->stratum_active == false) {
                paVar4 = api_add_data_full(paVar4, "Stratum URL", API_CONST, "",
                                           false);
            } else {
                paVar4 = api_add_data_full(paVar4, "Stratum URL", API_ESCAPE,
                                           ppVar6->stratum_url, false);
            }
            paVar4 = api_add_data_full(paVar4, "Has GBT", API_BOOL,
                                       &ppVar6->has_gbt, false);
            paVar4 = api_add_data_full(paVar4, "Best Share", API_UINT64,
                                       &ppVar6->best_diff, true);
            dVar10 = ppVar6->diff_rejected + ppVar6->diff_accepted +
                     ppVar6->diff_stale;
            rejp = 0.0;
            if (dVar10 != 0.0) {
                rejp = ppVar6->diff_rejected / dVar10;
            }
            paVar4 = api_add_data_full(paVar4, "Pool Rejected%", API_PERCENT,
                                       &rejp, false);
            dVar10 = ppVar6->diff_accepted + ppVar6->diff_rejected +
                     ppVar6->diff_stale;
            stalep = 0.0;
            if (dVar10 != 0.0) {
                stalep = ppVar6->diff_stale / dVar10;
            }
            paVar4 = api_add_data_full(paVar4, "Pool Stale%", API_PERCENT,
                                       &stalep, false);
            precom = isjson;
            if (isjson) {
                iVar5 = i;
                if (i < 1) {
                    iVar5 = 0;
                }
                precom = (char)iVar5;
                if (0 < i) {
                    precom = true;
                }
            }
            local_15c = print_data(io_data, paVar4, isjson, (_Bool)precom);
        }
        i = i + 1;
    } while (i < total_pools);
LAB_0003099e:
    if (_Var1 != false) {
        io_data->close = true;
    }
    return;
}

/* WARNING: Unknown calling convention */

api_data *api_add_escape(api_data *root, char *name, char *data,
                         _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_ESCAPE, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_string(api_data *root, char *name, char *data,
                         _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_STRING, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_const(api_data *root, char *name, char *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_CONST, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_uint8(api_data *root, char *name, uint8_t *data,
                        _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_UINT8, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_int16(api_data *root, char *name, int16_t *data,
                        _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_INT16, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_uint16(api_data *root, char *name, uint16_t *data,
                         _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_UINT16, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_int(api_data *root, char *name, int *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_INT, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_uint(api_data *root, char *name, uint *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_UINT, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_uint32(api_data *root, char *name, uint32_t *data,
                         _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_UINT32, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_hex32(api_data *root, char *name, uint32_t *data,
                        _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_HEX32, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_uint64(api_data *root, char *name, uint64_t *data,
                         _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_UINT64, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_int64(api_data *root, char *name, int64_t *data,
                        _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_INT64, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_double(api_data *root, char *name, double *data,
                         _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_DOUBLE, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_elapsed(api_data *root, char *name, double *data,
                          _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_ELAPSED, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_bool(api_data *root, char *name, _Bool *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_BOOL, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_timeval(api_data *root, char *name, timeval *data,
                          _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_TIMEVAL, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_time(api_data *root, char *name, time_t *data,
                       _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_TIME, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_mhs(api_data *root, char *name, double *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_MHS, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_mhtotal(api_data *root, char *name, double *data,
                          _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_MHTOTAL, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_temp(api_data *root, char *name, float *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_TEMP, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_utility(api_data *root, char *name, double *data,
                          _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_UTILITY, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_freq(api_data *root, char *name, double *data,
                       _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_FREQ, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_volts(api_data *root, char *name, float *data,
                        _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_VOLTS, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_hs(api_data *root, char *name, double *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_HS, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_diff(api_data *root, char *name, double *data,
                       _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_DIFF, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_percent(api_data *root, char *name, double *data,
                          _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_PERCENT, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

api_data *api_add_avg(api_data *root, char *name, float *data, _Bool copy_data)

{
    api_data *paVar1;

    paVar1 = api_add_data_full(root, name, API_AVG, data, copy_data);
    return paVar1;
}

/* WARNING: Unknown calling convention */

void notifystatus(io_data *io_data, int device, cgpu_info *cgpu, _Bool isjson,
                  char group)

{
    api_data *paVar1;
    undefined1 precom;
    int iVar2;
    char *reason;
    char *data;
    int local_1c;

    data = "None";
    if (cgpu->device_last_not_well != 0) {
        if (cgpu->device_not_well_reason < REASON_DEV_THROTTLE) {
            data = *(char **)(CSWTCH_747 + cgpu->device_not_well_reason * 4);
        } else {
            data = "Unknown reason - code bug";
        }
    }
    local_1c = device;
    paVar1 =
        api_add_data_full((api_data *)0x0, "NOTIFY", API_INT, &local_1c, false);
    paVar1 =
        api_add_data_full(paVar1, "Name", API_STRING, cgpu->drv->name, false);
    paVar1 = api_add_data_full(paVar1, "ID", API_INT, &cgpu->device_id, false);
    paVar1 = api_add_data_full(paVar1, "Last Well", API_TIME,
                               &cgpu->device_last_well, false);
    paVar1 = api_add_data_full(paVar1, "Last Not Well", API_TIME,
                               &cgpu->device_last_not_well, false);
    paVar1 =
        api_add_data_full(paVar1, "Reason Not Well", API_STRING, data, false);
    paVar1 = api_add_data_full(paVar1, "*Thread Fail Init", API_INT,
                               &cgpu->thread_fail_init_count, false);
    paVar1 = api_add_data_full(paVar1, "*Thread Zero Hash", API_INT,
                               &cgpu->thread_zero_hash_count, false);
    paVar1 = api_add_data_full(paVar1, "*Thread Fail Queue", API_INT,
                               &cgpu->thread_fail_queue_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Sick Idle 60s", API_INT,
                               &cgpu->dev_sick_idle_60_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Dead Idle 600s", API_INT,
                               &cgpu->dev_dead_idle_600_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Nostart", API_INT,
                               &cgpu->dev_nostart_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Over Heat", API_INT,
                               &cgpu->dev_over_heat_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Thermal Cutoff", API_INT,
                               &cgpu->dev_thermal_cutoff_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Comms Error", API_INT,
                               &cgpu->dev_comms_error_count, false);
    paVar1 = api_add_data_full(paVar1, "*Dev Throttle", API_INT,
                               &cgpu->dev_throttle_count, false);
    precom = isjson;
    if (isjson) {
        iVar2 = local_1c;
        if (local_1c < 1) {
            iVar2 = 0;
        }
        precom = (undefined1)iVar2;
        if (0 < local_1c) {
            precom = true;
        }
    }
    print_data(io_data, paVar1, isjson, (_Bool)precom);
    return;
}

/* WARNING: Unknown calling convention */

void notify(io_data *io_data, long c, char *param, _Bool isjson, char group)

{
    _Bool _Var1;
    cgpu_info *cgpu;
    int id;
    int iVar2;

    if (total_devices == 0) {
        message(io_data, 10, 0, (char *)0x0, isjson);
        return;
    }
    message(io_data, 0x3c, 0, (char *)0x0, isjson);
    if (isjson) {
        _Var1 = io_add(io_data, ",\"NOTIFY\":[");
        if (total_devices < 1)
            goto LAB_00030e2e;
    } else {
        if (total_devices < 1) {
            return;
        }
        _Var1 = false;
    }
    id = 0;
    do {
        cgpu = get_devices(id);
        iVar2 = id + 1;
        notifystatus(io_data, id, cgpu, isjson, group);
        id = iVar2;
    } while (iVar2 < total_devices);
LAB_00030e2e:
    if (_Var1 != false) {
        io_data->close = true;
    }
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void mcast_init(void)

{
    undefined4 uVar1;
    thr_info *thr;
    int iVar2;
    char tmp42[4096];

    thr = (thr_info *)calloc(1, 0x40);
    uVar1 = tmp42._24_4_;
    if (thr == (thr_info *)0x0) {
        builtin_strncpy(tmp42, "Failed to calloc mcast thr", 0x1b);
        tmp42[0x1b] = SUB41(uVar1, 3);
        _applog(3, tmp42, true);
        _quit(1);
    }
    iVar2 = thr_info_create(thr, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x2d0a5, thr);
    if (iVar2 != 0) {
        builtin_strncpy(tmp42, "API mcast thread create fail", 0x1c);
        tmp42[0x1c] = 'e';
        tmp42[0x1d] = 'd';
        tmp42[0x1e] = '\0';
        _applog(3, tmp42, true);
        _quit(1);
    }
    return;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void api(int api_thr_id)

{
    bool bVar1;
    io_list *piVar2;
    _Bool _Var3;
    int *arg;
    io_data *io_data;
    char *pcVar4;
    io_list *piVar5;
    int iVar6;
    size_t sVar7;
    byte *pbVar8;
    __int32_t **pp_Var9;
    byte *pbVar10;
    char *pcVar11;
    ushort **ppuVar12;
    int iVar13;
    byte *pbVar14;
    int *piVar15;
    time_t tVar16;
    time_t tVar17;
    size_t sVar18;
    json_t *pjVar19;
    char cVar20;
    uint uVar21;
    uint8_t *puVar22;
    uint8_t *puVar23;
    _Bool isjson;
    __int32_t *p_Var24;
    byte *pbVar25;
    int iVar26;
    char *func;
    char *func_00;
    char *func_01;
    char *func_02;
    byte bVar27;
    bool bVar28;
    undefined1 *puVar29;
    uint8_t *puVar30;
    int line;
    int line_00;
    int line_01;
    int line_02;
    json_type jVar31;
    IPACCESS *__buf;
    addrinfo *paVar32;
    int iVar33;
    io_data *piVar34;
    char *pcVar35;
    byte *pbVar36;
    CMDS *pCVar37;
    double dVar38;
    json_int_t jVar39;
    byte *pbStack_26488;
    char *pcStack_2647c;
    json_t *pjStack_26474;
    short sStack_26468;
    char *pcStack_2644c;
    char *pcStack_26440;
    char group;
    _Bool firstjoin;
    char *connectaddr;
    socklen_t clisiz;
    addrinfo *res;
    int optval;
    char port_s[10];
    char tmp[30];
    addrinfo hints;
    thr_info bye_thr;
    char cmdbuf[100];
    char cmdbuf_1[100];
    sockaddr_storage cli;
    json_error_t json_err;
    __pthread_unwind_buf_t __cancel_buf;
    char tmp42[4096];
    char tmp42_1[4096];
    char tmp42_2[4096];
    char tmp42_3[4096];
    char tmp42_4[4096];
    char tmp42_5[4096];
    char tmp42_6[4096];
    char tmp42_7[4096];
    char tmp42_8[4096];
    char tmp42_9[4096];
    char tmp42_10[4096];
    char tmp42_11[4096];
    char tmp42_12[4096];
    char tmp42_13[4096];
    char tmp42_14[4096];
    char tmp42_15[4096];
    char tmp42_16[4096];
    char tmp42_28[4096];
    char tmp42_29[4096];
    char tmp42_30[4096];
    char tmp42_31[4096];
    char tmp42_25[4096];
    char tmp42_18[4096];
    char tmp42_17[4096];
    char tmp42_22[4096];
    char tmp42_21[4096];
    char tmp42_19[4096];
    char tmp42_20[4096];
    char tmp42_23[4096];
    char tmp42_24[4096];
    char tmp42_27[4096];
    char tmp42_26[4096];
    char buf[8192];
    char param_buf[8192];
    char commands[8192];

    iVar13 = opt_api_port;
    pjStack_26474 = (json_t *)0x0;
    bVar1 = false;
    arg = (int *)malloc(4);
    _Var3 = opt_api_listen;
    *arg = -1;
    if (_Var3 == false) {
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "API not running%s",
                     " - API will not be available");
            _applog(7, tmp42, false);
        }
    LAB_00030f76:
        free(arg);
        return;
    }
    io_data = (io_data *)malloc(0x10);
    pcVar4 = (char *)malloc(0x10000);
    pcVar35 = (char *)0x0;
    io_data->close = false;
    *pcVar4 = '\0';
    io_data->ptr = pcVar4;
    io_data->cur = pcVar4;
    io_data->sock = true;
    io_data->siz = 0x10000;
    piVar5 = (io_list *)malloc(0xc);
    piVar5->io_data = io_data;
    piVar2 = io_head;
    if (io_head == (io_list *)0x0) {
        piVar5->prev = piVar5;
        piVar5->next = piVar5;
        io_head = piVar5;
    } else {
        piVar5->next = io_head;
        piVar5->prev = piVar2->prev;
        piVar2->prev = piVar5;
        piVar5->prev->next = piVar5;
    }
    iVar6 = pthread_mutex_init((pthread_mutex_t *)&quit_restart_lock,
                               (pthread_mutexattr_t *)0x0);
    piVar34 = io_data;
    if (iVar6 != 0) {
        piVar15 = __errno_location();
        snprintf(tmp42_31, 0x1000,
                 "Failed to pthread_mutex_init errno=%d in %s %s():%d",
                 *piVar15, "api.c", "api", 0x14b1);
        _applog(3, tmp42_31, true);
        _quit(1);
        piVar34 = (io_data *)"api";
    }
    iVar6 = __sigsetjmp(&__cancel_buf, 0);
    if (iVar6 != 0) {
        tidyup(arg);
        __pthread_unwind_next((__pthread_unwind_buf_t *)&__cancel_buf);
    LAB_00031f24:
        freeaddrinfo((addrinfo *)res);
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            snprintf(tmp42_6, 0x1000, "API bind to port %d failed (%s)%s",
                     piVar34, pcVar35, " - API will not be available");
            _applog(3, tmp42_6, false);
        }
        goto LAB_00030f76;
    }
    __pthread_register_cancel((__pthread_unwind_buf_t *)&__cancel_buf);
    pcVar4 = opt_api_groups;
    if (opt_api_groups == (char *)0x0) {
        sVar7 = 1;
        pcVar4 = "";
    } else {
        sVar7 = strlen(opt_api_groups);
        sVar7 = sVar7 + 1;
    }
    pbVar8 = (byte *)malloc(sVar7);
    if (pbVar8 == (byte *)0x0) {
        builtin_strncpy(tmp42_25, "Failed to malloc ipgroups bu", 0x1c);
        tmp42_25[0x1c] = 'f';
        tmp42_25[0x1d] = '\0';
        _applog(3, tmp42_25, true);
        _quit(1);
    }
    strcpy((char *)pbVar8, pcVar4);
    bVar27 = *pbVar8;
    pbVar25 = pbVar8;
    while (bVar27 != 0) {
        pcVar4 = strchr((char *)pbVar25, 0x2c);
        if (pcVar4 == (char *)0x0) {
            pbStack_26488 = (byte *)0x0;
        } else {
            pbStack_26488 = (byte *)(pcVar4 + 1);
            *pcVar4 = '\0';
        }
        if (pbVar25[1] != 0x3a) {
            pcVar4 = strchr((char *)pbVar25, 0x3a);
            if (pcVar4 != (char *)0x0) {
                *pcVar4 = '\0';
            }
            snprintf(tmp42_18, 0x1000, "API invalid group name \'%s\'",
                     pbVar25);
            _applog(3, tmp42_18, true);
            _quit(1);
        }
        pp_Var9 = __ctype_toupper_loc();
        p_Var24 = *pp_Var9;
        uVar21 = (uint) * (byte *)(p_Var24 + *pbVar25);
        if ((p_Var24[uVar21] < p_Var24[0x41]) ||
            (p_Var24[0x5a] < p_Var24[uVar21])) {
            snprintf(tmp42_17, 0x1000, "API invalid group name \'%c\'");
            _applog(3, tmp42_17, true);
            _quit(1);
            p_Var24 = *pp_Var9;
        }
        if (uVar21 == p_Var24[0x57]) {
            snprintf(tmp42_22, 0x1000, "API group name can\'t be \'%c\'",
                     uVar21);
            _applog(3, tmp42_22, true);
            _quit(1);
            p_Var24 = *pp_Var9;
        }
        if (uVar21 == p_Var24[0x52]) {
            snprintf(tmp42_21, 0x1000, "API group name can\'t be \'%c\'",
                     uVar21);
            _applog(3, tmp42_21, true);
            _quit(1);
            p_Var24 = *pp_Var9;
        }
        if (apigroups[p_Var24[uVar21] - p_Var24[0x41]].commands !=
            (char *)0x0) {
            snprintf(tmp42_19, 0x1000, "API duplicate group name \'%c\'",
                     (uint)*pbVar25);
            _applog(3, tmp42_19, true);
            _quit(1);
        }
        commands[0] = '|';
        commands[1] = '\0';
        if ((pbVar25 + 2 != (byte *)0x0) && (pbVar25[2] != 0)) {
            bVar28 = false;
            pcStack_2647c = commands + 1;
            pbVar25 = pbVar25 + 2;
            do {
                pbVar10 = (byte *)strchr((char *)pbVar25, 0x3a);
                pbVar36 = pbVar10;
                if (pbVar10 != (byte *)0x0) {
                    pbVar36 = pbVar10 + 1;
                    *pbVar10 = 0;
                }
                if ((*pbVar25 == 0x2a) && (pbVar25[1] == 0)) {
                    bVar28 = true;
                } else {
                    pCVar37 = cmds;
                    iVar6 = 0;
                    pcVar4 = cmds[0].name;
                    while (pcVar4 != (char *)0x0) {
                        iVar33 = strcasecmp((char *)pbVar25, pcVar4);
                        if (iVar33 == 0) {
                            sprintf(cmdbuf_1, "|%s|", pcVar4);
                            pcVar4 = strstr(commands, cmdbuf_1);
                            if (pcVar4 == (char *)0x0) {
                                pcVar4 = cmds[iVar6].name;
                                strcpy(pcStack_2647c, pcVar4);
                                sVar7 = strlen(pcVar4);
                                pcVar4 = pcStack_2647c + sVar7;
                                pcVar4[1] = '\0';
                                pcStack_2647c = pcVar4 + 1;
                                *pcVar4 = '|';
                            }
                            goto LAB_000311e2;
                        }
                        pCVar37 = pCVar37 + 1;
                        iVar6 = iVar6 + 1;
                        pcVar4 = pCVar37->name;
                    }
                    snprintf(tmp42_20, 0x1000,
                             "API unknown command \'%s\' in group \'%c\'",
                             pbVar25, uVar21);
                    _applog(3, tmp42_20, true);
                    _quit(1);
                }
            LAB_000311e2:
            } while ((pbVar36 != (byte *)0x0) &&
                     (pbVar25 = pbVar36, *pbVar36 != 0));
            if ((bVar28) && (cmds[0].name != (char *)0x0)) {
                pCVar37 = cmds;
                do {
                    if (pCVar37->iswritemode == false) {
                        sprintf(cmdbuf_1, "|%s|");
                        pcVar4 = strstr(commands, cmdbuf_1);
                        if (pcVar4 == (char *)0x0) {
                            pcVar4 = pCVar37->name;
                            strcpy(pcStack_2647c, pcVar4);
                            sVar7 = strlen(pcVar4);
                            pcVar4 = pcStack_2647c + sVar7;
                            pcStack_2647c = pcVar4 + 1;
                            pcVar4[1] = '\0';
                            *pcVar4 = '|';
                        }
                    }
                    pCVar37 = pCVar37 + 1;
                } while (pCVar37->name != (char *)0x0);
            }
        }
        sVar7 = strlen(commands);
        iVar33 = (*pp_Var9)[uVar21];
        iVar6 = (*pp_Var9)[0x41];
        pcVar4 = (char *)malloc(sVar7 + 1);
        apigroups[iVar33 - iVar6].commands = pcVar4;
        if (pcVar4 == (char *)0x0) {
            builtin_strncpy(tmp42_23, "Failed to malloc group commands buf",
                            0x24);
            _applog(3, tmp42_23, true);
            _quit(1);
        }
        strcpy(pcVar4, commands);
        if (pbStack_26488 == (byte *)0x0)
            break;
        pbVar25 = pbStack_26488;
        bVar27 = *pbStack_26488;
    }
    pp_Var9 = __ctype_toupper_loc();
    commands[0] = '|';
    commands[1] = '\0';
    if (cmds[0].name != (char *)0x0) {
        pCVar37 = cmds;
        pcVar35 = commands + 1;
        pcVar4 = cmds[0].name;
        do {
            while (pCVar37->iswritemode != false) {
                pCVar37 = pCVar37 + 1;
                pcVar4 = pCVar37->name;
                if (pcVar4 == (char *)0x0)
                    goto LAB_0003129c;
            }
            strcpy(pcVar35, pcVar4);
            sVar7 = strlen(pcVar4);
            pCVar37 = pCVar37 + 1;
            pcVar4 = pCVar37->name;
            pcVar11 = pcVar35 + sVar7;
            pcVar35 = pcVar11 + 1;
            *pcVar11 = '|';
            pcVar11[1] = '\0';
        } while (pcVar4 != (char *)0x0);
    }
LAB_0003129c:
    sVar7 = strlen(commands);
    p_Var24 = *pp_Var9;
    iVar6 = p_Var24[0x52];
    iVar33 = p_Var24[0x41];
    if (iVar6 + 0x80U < 0x180) {
        iVar6 = p_Var24[iVar6];
    }
    pcVar4 = (char *)malloc(sVar7 + 1);
    apigroups[iVar6 - iVar33].commands = pcVar4;
    if (pcVar4 == (char *)0x0) {
        builtin_strncpy(tmp42_24, "Failed to malloc noprivgroup commands bu",
                        0x28);
        tmp42_24[0x28] = 'f';
        tmp42_24[0x29] = '\0';
        _applog(3, tmp42_24, true);
        _quit(1);
    }
    strcpy(pcVar4, commands);
    free(pbVar8);
    pcVar4 = opt_api_allow;
    if (opt_api_allow != (char *)0x0) {
        sVar7 = strlen(opt_api_allow);
        pbVar8 = (byte *)malloc(sVar7 + 1);
        if (pbVar8 == (byte *)0x0) {
            builtin_strncpy(tmp42_27, "Failed to malloc ipaccess bu", 0x1c);
            tmp42_27[0x1c] = 'f';
            tmp42_27[0x1d] = '\0';
            _applog(3, tmp42_27, true);
            _quit(1);
            pcVar4 = opt_api_allow;
        }
        strcpy((char *)pbVar8, pcVar4);
        pbVar25 = pbVar8 + -1;
        sVar7 = 1;
        while (true) {
            pbVar25 = pbVar25 + 1;
            if (*pbVar25 == 0)
                break;
            if (*pbVar25 == 0x2c) {
                sVar7 = sVar7 + 1;
            }
        }
        ipaccess = (IPACCESS *)calloc(sVar7, 0x24);
        if (ipaccess == (IPACCESS *)0x0) {
            builtin_strncpy(tmp42_26, "Failed to calloc ipacces", 0x18);
            tmp42_26[0x18] = 's';
            tmp42_26[0x19] = '\0';
            _applog(3, tmp42_26, true);
            _quit(1);
        }
        iVar6 = 0;
        ips = 0;
        pbVar25 = pbVar8;
        do {
            while (true) {
                bVar27 = *pbVar25;
                pbVar36 = pbVar25;
                if (bVar27 == 0)
                    goto LAB_0003140c;
                while (bVar27 == 9 || bVar27 == 0x20) {
                    pbVar36 = pbVar36 + 1;
                    bVar27 = *pbVar36;
                }
                if (bVar27 == 0x2c) {
                    pbVar25 = pbVar36 + 1;
                    goto LAB_00031408;
                }
                pbVar10 = (byte *)strchr((char *)pbVar36, 0x2c);
                pbVar25 = pbVar10;
                if (pbVar10 != (byte *)0x0) {
                    pbVar25 = pbVar10 + 1;
                    *pbVar10 = 0;
                }
                ppuVar12 = __ctype_b_loc();
                p_Var24 = *pp_Var9;
                cVar20 = (char)p_Var24[0x52];
                if (((int)((uint)(*ppuVar12)[*pbVar36] << 0x15) < 0) &&
                    (pbVar36[1] == 0x3a)) {
                    iVar33 = p_Var24[*pbVar36];
                    if ((iVar33 == p_Var24[0x57]) ||
                        (apigroups[iVar33 - p_Var24[0x41]].commands !=
                         (char *)0x0)) {
                        cVar20 = (char)iVar33;
                    }
                    pbVar36 = pbVar36 + 2;
                }
                __buf = ipaccess + iVar6;
                __buf->group = cVar20;
                bVar27 = *pbVar36;
                if (bVar27 != 0x30)
                    break;
                if (((pbVar36[1] != 0x2f) || (pbVar36[2] != 0x30)) ||
                    (pbVar36[3] != 0)) {
                    pbVar10 = (byte *)strchr((char *)pbVar36, 0x2f);
                    if (pbVar10 == (byte *)0x0)
                        goto LAB_00031630;
                    goto LAB_000313dc;
                }
                puVar22 = (__buf->ip).__in6_u.__u6_addr8 + 0xf;
                puVar30 = &__buf[-1].field_0x23;
                puVar23 = puVar22;
                do {
                    puVar30 = puVar30 + 1;
                    *puVar30 = '\0';
                    puVar23 = puVar23 + 1;
                    *puVar23 = '\0';
                } while (puVar30 != puVar22);
            LAB_00031614:
                iVar6 = iVar6 + 1;
                ips = iVar6;
                if (pbVar25 == (byte *)0x0)
                    goto LAB_0003140c;
            }
            pbVar10 = (byte *)strchr((char *)pbVar36, 0x2f);
            if (pbVar10 == (byte *)0x0) {
            LAB_00031630:
                puVar30 = (__buf->ip).__in6_u.__u6_addr8 + 0xf;
                do {
                    puVar30 = puVar30 + 1;
                    *puVar30 = 0xff;
                } while ((uint8_t *)((int)&(__buf->mask).__in6_u + 0xf) !=
                         puVar30);
                sVar7 = strlen((char *)pbVar36);
                bVar27 = *pbVar36;
                pbVar10 = pbVar36 + sVar7;
            }
            if ((bVar27 == 0x5b) && (pbVar10[-1] == 0x5d)) {
                bVar28 = true;
                *pbVar36 = 0;
                pbVar36 = pbVar36 + 1;
                pbVar10[-1] = 0;
            } else {
            LAB_000313dc:
                bVar28 = false;
            }
            if (*pbVar10 == 0) {
            LAB_0003167e:
                puVar29 = &__buf[-1].field_0x23;
                do {
                    puVar29 = puVar29 + 1;
                    *puVar29 = 0;
                } while ((undefined1 *)((int)&(__buf->ip).__in6_u + 0xf) !=
                         puVar29);
                if (bVar28) {
                    iVar33 = inet_pton(10, (char *)pbVar36, __buf);
                } else {
                    sprintf(tmp, "::ffff:%s", pbVar36);
                    iVar6 = ips;
                    __buf = ipaccess + ips;
                    iVar33 = inet_pton(10, tmp, __buf);
                }
                if (iVar33 == 1) {
                    pbVar14 = (__buf->ip).__in6_u.__u6_addr8 + 0xf;
                    pbVar36 = &__buf[-1].field_0x23;
                    pbVar10 = pbVar14;
                    do {
                        pbVar36 = pbVar36 + 1;
                        pbVar10 = pbVar10 + 1;
                        *pbVar36 = *pbVar36 & *pbVar10;
                    } while (pbVar36 != pbVar14);
                    goto LAB_00031614;
                }
            } else {
                *pbVar10 = 0;
                iVar33 = strtol((char *)(pbVar10 + 1), (char **)0x0, 10);
                if (0 < iVar33) {
                    if (!bVar28) {
                        iVar33 = iVar33 + 0x60;
                    }
                    if (iVar33 < 0x81) {
                        puVar30 = (__buf->ip).__in6_u.__u6_addr8 + 0xf;
                        iVar26 = 0;
                        do {
                            puVar30 = puVar30 + 1;
                            *puVar30 = '\0';
                        } while ((uint8_t *)((int)&(__buf->mask).__in6_u +
                                             0xf) != puVar30);
                        while (uVar21 = 7, iVar33 != 0) {
                            while (true) {
                                iVar33 = iVar33 + -1;
                                (__buf->mask).__in6_u.__u6_addr8[iVar26] =
                                    (__buf->mask).__in6_u.__u6_addr8[iVar26] |
                                    (byte)(1 << (uVar21 & 0xff));
                                if (uVar21 == 0)
                                    break;
                                uVar21 = uVar21 - 1;
                                if (iVar33 == 0)
                                    goto LAB_0003167e;
                            }
                            iVar26 = iVar26 + 1;
                        }
                        goto LAB_0003167e;
                    }
                }
            }
        LAB_00031408:
        } while (pbVar25 != (byte *)0x0);
    LAB_0003140c:
        free(pbVar8);
        if (iVar6 == 0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42_1, 0x1000,
                         "API not running (no valid IPs specified)%s",
                         " - API will not be available");
                _applog(4, tmp42_1, false);
            }
            goto LAB_00030f76;
        }
    }
    sStack_26468 = (short)iVar13;
    piVar34 = (io_data *)(int)sStack_26468;
    cgsleep_ms(opt_log_interval * 1000);
    sprintf(port_s, "%d", piVar34);
    hints.ai_flags = 1;
    hints.ai_family = 0;
    hints.ai_socktype = 0;
    hints.ai_protocol = 0;
    hints.ai_addrlen = 0;
    hints.ai_addr = (sockaddr *)0x0;
    hints.ai_canonname = (char *)0x0;
    hints.ai_next = (addrinfo *)0x0;
    iVar13 = getaddrinfo(opt_api_host, port_s, (addrinfo *)&hints,
                         (addrinfo **)&res);
    if (iVar13 != 0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            snprintf(tmp42_2, 0x1000, "API failed to resolve %s", opt_api_host);
            _applog(3, tmp42_2, false);
        }
        goto LAB_00030f76;
    }
    paVar32 = res;
    if (res == (addrinfo *)0x0) {
        iVar13 = *arg;
    } else {
        do {
            iVar13 = socket(res->ai_family, 1, 0);
            *arg = iVar13;
            if (0 < iVar13)
                goto LAB_00031808;
            paVar32 = paVar32->ai_next;
        } while (paVar32 != (addrinfo *)0x0);
    }
    if (iVar13 == -1) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            piVar15 = __errno_location();
            pcVar4 = strerror(*piVar15);
            snprintf(tmp42_3, 0x1000, "API initialisation failed (%s)%s",
                     pcVar4, " - API will not be available");
            _applog(3, tmp42_3, false);
        }
        freeaddrinfo((addrinfo *)res);
        free(arg);
        return;
    }
    paVar32 = (addrinfo *)0x0;
LAB_00031808:
    optval = 1;
    iVar13 = setsockopt(iVar13, 1, 2, &optval, 4);
    if (((iVar13 < 0) && (opt_debug != false)) &&
        ((use_syslog != false ||
          ((opt_log_output != false || (6 < opt_log_level)))))) {
        piVar15 = __errno_location();
        pcVar4 = strerror(*piVar15);
        snprintf(tmp42_4, 0x1000,
                 "API setsockopt SO_REUSEADDR failed (ignored): %s", pcVar4);
        _applog(7, tmp42_4, false);
    }
    tVar16 = time((time_t *)0x0);
    while (iVar13 =
               bind(*arg, (sockaddr *)paVar32->ai_addr, paVar32->ai_addrlen),
           iVar13 < 0) {
        piVar15 = __errno_location();
        pcVar35 = strerror(*piVar15);
        tVar17 = time((time_t *)0x0);
        if (0x3d < tVar17 - tVar16)
            goto LAB_00031f24;
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            snprintf(tmp42_5, 0x1000,
                     "API bind to port %d failed - trying again in 30sec",
                     piVar34);
            _applog(4, tmp42_5, false);
        }
        cgsleep_ms(30000);
    }
    freeaddrinfo((addrinfo *)res);
    iVar13 = listen(*arg, 100);
    if (iVar13 < 0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            piVar15 = __errno_location();
            pcVar4 = strerror(*piVar15);
            snprintf(tmp42_7, 0x1000, "API3 initialisation failed (%s)%s",
                     pcVar4, " - API will not be available");
            _applog(3, tmp42_7, false);
        }
        close(*arg);
        free(arg);
        return;
    }
    if (opt_api_allow == (char *)0x0) {
        if (opt_api_network == false) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(
                    tmp42_10, 0x1000,
                    "API running in local read access mode on port %d (%d)",
                    piVar34, *arg);
                _applog(4, tmp42_10, false);
            }
        } else if (((use_syslog != false) || (opt_log_output != false)) ||
                   (3 < opt_log_level)) {
            snprintf(
                tmp42_9, 0x1000,
                "API running in UNRESTRICTED read access mode on port %d (%d)",
                piVar34, *arg);
            _applog(4, tmp42_9, false);
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (3 < opt_log_level)) {
        snprintf(tmp42_8, 0x1000,
                 "API running in IP access mode on port %d (%d)", piVar34,
                 *arg);
        _applog(4, tmp42_8, false);
    }
    if (opt_api_mcast != false) {
        mcast_init();
    }
    strbufs = _k_new_list("StrBufs", 0xc, 2, 0, false, "api.c", "api", 0x1521);
    while (bye == false) {
        clisiz = 0x80;
        iVar13 = accept(*arg, (sockaddr *)&cli, &clisiz);
        if (iVar13 < 0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                piVar15 = __errno_location();
                pcVar4 = strerror(*piVar15);
                snprintf(tmp42_11, 0x1000, "API failed (%s)%s (%d)", pcVar4,
                         " - API will not be available", *arg);
                _applog(3, tmp42_11, false);
            }
            break;
        }
        _Var3 = check_connect(&cli, &connectaddr, &group);
        piVar34 = (io_data *)(uint)_Var3;
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            pcVar4 = "Accepted";
            if (piVar34 == (io_data *)0x0) {
                pcVar4 = "Ignored";
            }
            snprintf(tmp42_12, 0x1000, "API: connection from %s - %s",
                     connectaddr, pcVar4);
            _applog(7, tmp42_12, false);
        }
        if (piVar34 != (io_data *)0x0) {
            sVar18 = recv(iVar13, buf, 0x1fff, 0);
            if ((int)sVar18 < 0) {
                buf[0] = '\0';
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    piVar15 = __errno_location();
                    pcVar4 = strerror(*piVar15);
                    snprintf(tmp42_13, 0x1000, "API: recv failed: %s", pcVar4);
                    _applog(7, tmp42_13, false);
                }
            } else {
                buf[sVar18] = '\0';
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < opt_log_level)))) {
                    snprintf(tmp42_14, 0x1000, "API: recv command: (%d) \'%s\'",
                             sVar18, buf);
                    _applog(7, tmp42_14, false);
                }
                pcVar4 = buf;
                when = time((time_t *)0x0);
                io_data->cur = io_data->ptr;
                *io_data->ptr = '\0';
                io_data->close = false;
                _Var3 = SUB41(iVar13, 0);
                if (buf[0] != '{') {
                    pcVar35 = strchr(pcVar4, 0x7c);
                    piVar34 = (io_data *)0x0;
                    if (pcVar35 == (char *)0x0) {
                        pcStack_2644c = (char *)0x0;
                    } else {
                        pcStack_2644c = pcVar35 + 1;
                        *pcVar35 = '\0';
                    }
                LAB_00031b62:
                    pcVar35 = strchr(pcVar4, 0x2b);
                    if (pcVar35 == (char *)0x0) {
                        firstjoin = false;
                        bVar1 = false;
                        pcStack_26440 = (char *)0x0;
                    } else {
                        bVar1 = true;
                        firstjoin = true;
                        sVar7 = strlen(pcVar4);
                        pcStack_26440 = (char *)malloc(sVar7 + 3);
                        if (pcStack_26440 == (char *)0x0) {
                            snprintf(tmp42_15, 0x1000,
                                     "OOM cmdsbuf in %s %s():%d", "api.c",
                                     "api", 0x1590);
                            _applog(3, tmp42_15, true);
                            _quit(1);
                        }
                        pcStack_2644c = (char *)0x0;
                        pcStack_26440[0] = '|';
                        pcStack_26440[1] = '\0';
                    }
                    isjson = SUB41(piVar34, 0);
                    if (!bVar1)
                        goto LAB_00031bd4;
                    do {
                        pcVar11 = strchr(pcVar4, 0x2b);
                        pcVar35 = pcVar11;
                        if (pcVar11 != (char *)0x0) {
                            pcVar35 = pcVar11 + 1;
                            *pcVar11 = '\0';
                        }
                        if (*pcVar4 != '\0') {
                            if (cmds[0].name != (char *)0x0)
                                goto LAB_00031bde;
                            goto LAB_00031dde;
                        }
                    LAB_00031bbc:
                        pcVar4 = pcVar35;
                        bVar28 = bVar1;
                        if (pcVar4 == (char *)0x0) {
                            bVar28 = false;
                        }
                        if (!bVar28)
                            goto LAB_000321c8;
                    } while (bVar1);
                LAB_00031bd4:
                    pcVar35 = pcVar4;
                    if (cmds[0].name != (char *)0x0) {
                    LAB_00031bde:
                        pCVar37 = cmds;
                        iVar6 = 0;
                        pcVar11 = cmds[0].name;
                        do {
                            iVar33 = strcmp(pcVar4, pcVar11);
                            if (iVar33 == 0) {
                                sprintf(cmdbuf, "|%s|", pcVar4);
                                if (bVar1) {
                                    pcVar11 = strstr(pcStack_26440, cmdbuf);
                                    if (pcVar11 != (char *)0x0)
                                        goto LAB_00031bbc;
                                    sVar7 = strlen(pcStack_26440);
                                    pcVar11 =
                                        stpcpy(pcStack_26440 + sVar7, pcVar4);
                                    pcVar11[0] = '|';
                                    pcVar11[1] = '\0';
                                    head_join(io_data, pcVar4, isjson,
                                              &firstjoin);
                                    if (cmds[iVar6].joinable == false) {
                                        message(io_data, 0x2d, 0,
                                                cmds[iVar6].name, isjson);
                                        tail_join(io_data, isjson);
                                        goto LAB_00031ca4;
                                    }
                                }
                                cVar20 = group;
                                p_Var24 = *pp_Var9;
                                if ((p_Var24[(byte)group] == p_Var24[0x57]) ||
                                    (pcVar4 =
                                         strstr(apigroups[p_Var24[(byte)group] -
                                                          p_Var24[0x41]]
                                                    .commands,
                                                cmdbuf),
                                     pcVar4 != (char *)0x0)) {
                                    (*cmds[iVar6].func)(io_data, iVar13,
                                                        pcStack_2644c, isjson,
                                                        cVar20);
                                } else {
                                    message(io_data, 0x2d, 0, cmds[iVar6].name,
                                            isjson);
                                    if ((opt_debug != false) &&
                                        (((use_syslog != false ||
                                           (opt_log_output != false)) ||
                                          (6 < opt_log_level)))) {
                                        snprintf(tmp42_16, 0x1000,
                                                 "API: access denied to \'%s\' "
                                                 "for \'%s\' command",
                                                 connectaddr, cmds[iVar6].name);
                                        _applog(7, tmp42_16, false);
                                    }
                                }
                                goto joined_r0x00031c90;
                            }
                            pCVar37 = pCVar37 + 1;
                            pcVar11 = pCVar37->name;
                            iVar6 = iVar6 + 1;
                        } while (pcVar11 != (char *)0x0);
                        if (bVar1) {
                        LAB_00031dde:
                            head_join(io_data, pcVar4, isjson, &firstjoin);
                        }
                    }
                    message(io_data, 0xe, 0, (char *)0x0, isjson);
                joined_r0x00031c90:
                    if (bVar1) {
                        tail_join(io_data, isjson);
                    } else {
                        send_result((io_data *)io_data->ptr,
                                    (uint)io_data->close, _Var3, piVar34);
                    }
                LAB_00031ca4:
                    if (!bVar1)
                        goto LAB_00031ca8;
                    goto LAB_00031bbc;
                }
                pjStack_26474 = json_loadb(pcVar4, sVar18, 0, &json_err);
                if ((pjStack_26474 == (json_t *)0x0) ||
                    (pjStack_26474->type != JSON_OBJECT)) {
                    iVar6 = 0x17;
                } else {
                    pjVar19 = json_object_get(pjStack_26474, "command");
                    if (pjVar19 == (json_t *)0x0) {
                        iVar6 = 0x18;
                    } else {
                        if (pjVar19->type == JSON_STRING) {
                            pcVar4 = json_string_value(pjVar19);
                            pjVar19 =
                                json_object_get(pjStack_26474, "parameter");
                            if (pjVar19 == (json_t *)0x0) {
                                pcStack_2644c = (char *)0x0;
                            } else {
                                jVar31 = pjVar19->type;
                                if (jVar31 == JSON_STRING) {
                                    pcStack_2644c = json_string_value(pjVar19);
                                } else if (jVar31 == JSON_INTEGER) {
                                    jVar39 = json_integer_value(pjVar19);
                                    pcStack_2644c = param_buf;
                                    sprintf(pcStack_2644c, "%d", (int)jVar39);
                                } else if (jVar31 == JSON_REAL) {
                                    dVar38 = json_real_value(pjVar19);
                                    pcStack_2644c = param_buf;
                                    sprintf(pcStack_2644c, "%f",
                                            SUB84(dVar38, 0),
                                            (int)((ulonglong)dVar38 >> 0x20));
                                } else {
                                    pcStack_2644c = (char *)0x0;
                                }
                            }
                            goto LAB_00031b62;
                        }
                        iVar6 = 0xe;
                    }
                }
                message(io_data, iVar6, 0, (char *)0x0, true);
                send_result((io_data *)io_data->ptr, (uint)io_data->close,
                            _Var3, (io_data *)0x1);
            LAB_000321c8:
                if (bVar1) {
                    send_result((io_data *)io_data->ptr, (uint)io_data->close,
                                _Var3, piVar34);
                }
            LAB_00031ca8:
                if (pjStack_26474 == (json_t *)0x0) {
                    piVar34 = (io_data *)0x0;
                }
                if (((piVar34 != (io_data *)0x0) &&
                     (pjStack_26474->type == JSON_OBJECT)) &&
                    ((pjStack_26474->refcount != 0xffffffff &&
                      (sVar18 = pjStack_26474->refcount - 1,
                       pjStack_26474->refcount = sVar18, sVar18 == 0)))) {
                    json_delete(pjStack_26474);
                }
            }
        }
        close(iVar13);
    }
    __pthread_unregister_cancel((__pthread_unwind_buf_t *)&__cancel_buf);
    tidyup(arg);
    free(arg);
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        if (do_a_quit == false) {
            if (do_a_restart == false) {
                pcVar4 = "UNKNOWN!";
                if (bye != false) {
                    pcVar4 = "BYE";
                }
            } else {
                pcVar4 = "RESTART";
            }
        } else {
            pcVar4 = "QUIT";
        }
        snprintf(tmp42_28, 0x1000, "API: terminating due to: %s", pcVar4);
        _applog(7, tmp42_28, false);
    }
    iVar13 = pthread_mutex_lock((pthread_mutex_t *)&quit_restart_lock);
    if (iVar13 != 0) {
        _mutex_lock((pthread_mutex_t *)"api", (char *)0x15f3, func, line);
    }
    if (do_a_restart == false) {
        if (do_a_quit == false)
            goto LAB_00032174;
        iVar13 = thr_info_create(&bye_thr, (pthread_attr_t *)0x0,
                                 (_func_void_ptr_void_ptr *)0x2d815, &bye_thr);
        if (iVar13 != 0) {
            iVar13 =
                pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
            if (iVar13 != 0) {
                _mutex_unlock_noyield((pthread_mutex_t *)"api", (char *)0x1602,
                                      func_01, line_01);
            }
            (*selective_yield)();
            builtin_strncpy(
                tmp42_30, "API failed to initiate a clean quit - aborti", 0x2c);
            tmp42_30[0x2c] = 'n';
            tmp42_30[0x2d] = 'g';
            tmp42_30[0x2e] = '\0';
            _applog(3, tmp42_30, true);
            _quit(1);
        }
    } else {
        iVar13 = thr_info_create(&bye_thr, (pthread_attr_t *)0x0,
                                 (_func_void_ptr_void_ptr *)0x2d92d, &bye_thr);
        if (iVar13 != 0) {
            iVar13 =
                pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
            if (iVar13 != 0) {
                _mutex_unlock_noyield((pthread_mutex_t *)"api", (char *)0x15f9,
                                      func_02, line_02);
            }
            (*selective_yield)();
            builtin_strncpy(
                tmp42_29, "API failed to initiate a restart - aborting", 0x2c);
            _applog(3, tmp42_29, true);
            _quit(1);
        }
    }
    pthread_detach(bye_thr.pth);
LAB_00032174:
    iVar13 = pthread_mutex_unlock((pthread_mutex_t *)&quit_restart_lock);
    if (iVar13 != 0) {
        _mutex_unlock_noyield((pthread_mutex_t *)"api", (char *)0x1608, func_00,
                              line_00);
    }
    (*selective_yield)();
    return;
}

/* WARNING: Unknown calling convention */

void _applog(int prio, char *str, _Bool force)

{
    FILE *__s;
    tm *ptVar1;
    int iVar2;
    size_t sVar3;
    byte bVar4;
    time_t tmp_time;
    timeval tv;
    char datetime[64];

    tv.tv_sec = (__time_t)use_syslog;
    if (tv.tv_sec != 0) {
        syslog(prio | 0x80, "%s", str);
        return;
    }
    tv.tv_usec = tv.tv_sec;
    cgtime(&tv);
    tmp_time = tv.tv_sec;
    ptVar1 = localtime(&tmp_time);
    snprintf(datetime, 0x40, " [%d-%02d-%02d %02d:%02d:%02d] ",
             ptVar1->tm_year + 0x76c, ptVar1->tm_mon + 1, ptVar1->tm_mday,
             ptVar1->tm_hour, ptVar1->tm_min, ptVar1->tm_sec);
    iVar2 = fileno(stderr);
    iVar2 = isatty(iVar2);
    if (iVar2 == 0) {
        fprintf(stderr, "%s%s\n", datetime, str);
        fflush(stderr);
    }
    if ((g_logfile_enable != false) &&
        ((g_log_file != (FILE *)0x0 ||
          (g_log_file = (FILE *)fopen(g_logfile_path, g_logfile_openflag),
           g_log_file != (FILE *)0x0)))) {
        __s = g_log_file;
        sVar3 = strlen(datetime);
        fwrite(datetime, sVar3, 1, (FILE *)__s);
        sVar3 = strlen(str);
        fwrite(str, sVar3, 1, (FILE *)g_log_file);
        fwrite("\n", 1, 1, (FILE *)g_log_file);
        fflush((FILE *)g_log_file);
    }
    if (prio == 3) {
        bVar4 = 0;
    } else {
        bVar4 = opt_quiet & 1;
    }
    if (bVar4 == 0) {
        my_log_curses((int)datetime, str, (char *)(uint)force, opt_quiet);
    }
    return;
}

void _mutex_unlock_noyield(pthread_mutex_t *lock, char *file, char *func,
                           int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_mutex_unlock((pthread_mutex_t *)&console_lock);
    if (iVar1 == 0) {
        return;
    }
    piVar2 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
             *piVar2, "logging.c", "my_log_curses", lock);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void _mutex_lock(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_mutex_lock((pthread_mutex_t *)&console_lock);
    if (iVar1 == 0) {
        return;
    }
    piVar2 = __errno_location();
    snprintf(tmp42, 0x1000, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
             *piVar2, "logging.c", "my_log_curses", 0x2f);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

void my_log_curses(int prio, char *datetime, char *str, _Bool force)

{
    pthread_mutex_t *lock;
    char *file;
    char *file_00;
    char *file_01;
    char *extraout_r1;
    char *func;
    char *func_00;
    char *func_01;
    char *extraout_r2;
    uint line;
    int line_00;
    int line_01;
    uint extraout_r3;

    line = (uint)force;
    if (str == (char *)0x0) {
        func = (char *)0x0;
        lock = (pthread_mutex_t *)prio;
        file = datetime;
    } else {
        pthread_mutex_trylock((pthread_mutex_t *)&console_lock);
        _mutex_unlock_noyield((pthread_mutex_t *)0x26, file_01, func_01,
                              line_01);
        lock = (pthread_mutex_t *)(*selective_yield)();
        file = extraout_r1;
        func = extraout_r2;
        line = extraout_r3;
    }
    _mutex_lock(lock, file, func, line);
    printf("%s%s%s", prio, datetime, "                    \n");
    _mutex_unlock_noyield((pthread_mutex_t *)0x31, file_00, func_00, line_00);
    /* WARNING: Could not recover jumptable at 0x0003278c. Too many branches */
    /* WARNING: Treating indirect jump as call */
    (*selective_yield)();
    return;
}

/* WARNING: Unknown calling convention */

void _simplelog(int prio, char *str, _Bool force)

{
    byte bVar1;
    int iVar2;
    undefined4 in_r3;

    if (use_syslog) {
        syslog(prio | 0x80, "%s", str, in_r3);
        return;
    }
    iVar2 = fileno(stderr);
    iVar2 = isatty(iVar2);
    if (iVar2 == 0) {
        fprintf(stderr, "%s\n", str);
        fflush(stderr);
    }
    if (prio == 3) {
        bVar1 = 0;
    } else {
        bVar1 = opt_quiet & 1;
    }
    if (bVar1 == 0) {
        my_log_curses(0x59414, str, (char *)(uint)force, SUB41(in_r3, 0));
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void k_alloc_items(K_LIST *list, char *file, char *func, int line)

{
    _Bool _Var1;
    void **ppvVar2;
    k_item *pkVar3;
    void *pvVar4;
    char *pcVar5;
    int iVar6;
    int iVar7;
    k_item *pkVar8;
    size_t __nmemb;
    char tmp42[4096];

    if (list->is_store != false) {
        snprintf(
            tmp42, 0x1000,
            "List %s store can\'t %s() - from %s %s() line %d in %s %s():%d",
            list->name, "k_alloc_items", file, func, line, "klist.c",
            "k_alloc_items", 0x13);
        _applog(3, tmp42, true);
        _quit(1);
    }
    iVar7 = list->limit;
    if (iVar7 < 1) {
        __nmemb = list->allocate;
    } else {
        iVar6 = list->total;
        if (iVar7 <= iVar6) {
            return;
        }
        __nmemb = list->allocate;
        if (iVar7 < (int)(iVar6 + __nmemb)) {
            __nmemb = iVar7 - iVar6;
        }
    }
    iVar7 = list->item_mem_count + 1;
    list->item_mem_count = iVar7;
    ppvVar2 = (void **)realloc(list->item_memory, iVar7 * 4);
    list->item_memory = ppvVar2;
    if (ppvVar2 == (void **)0x0) {
        snprintf(tmp42, 0x1000,
                 "List %s item_memory failed to realloc count=%d in %s %s():%d",
                 list->name, list->item_mem_count, "klist.c", "k_alloc_items",
                 0x21);
        _applog(3, tmp42, true);
        _quit(1);
        pkVar3 = (k_item *)calloc(__nmemb, 0x10);
    } else {
        pkVar3 = (k_item *)calloc(__nmemb, 0x10);
    }
    if (pkVar3 == (k_item *)0x0) {
        snprintf(tmp42, 0x1000,
                 "List %s failed to calloc %d new items - total was %d, limit "
                 "was %d in %s %s():%d",
                 list->name, __nmemb, list->total, list->limit, "klist.c",
                 "k_alloc_items", 0x26);
        _applog(3, tmp42, true);
        _quit(1);
    }
    list->item_memory[list->item_mem_count + 0x3fffffff] = pkVar3;
    pcVar5 = list->name;
    list->count = __nmemb;
    list->count_up = __nmemb;
    list->total = list->total + __nmemb;
    pkVar3->name = pcVar5;
    pkVar3->prev = (k_item *)0x0;
    pkVar3->next = pkVar3 + 1;
    if (2 < (int)__nmemb) {
        pkVar8 = pkVar3 + 2;
        do {
            pkVar8[-1].name = pcVar5;
            pkVar8[-1].prev = pkVar8 + -2;
            pkVar8[-1].next = pkVar8;
            pkVar8 = pkVar8 + 1;
        } while (pkVar8 != pkVar3 + __nmemb);
    }
    _Var1 = list->do_tail;
    list->head = pkVar3;
    pkVar3[__nmemb + 0xfffffff].name = pcVar5;
    pkVar8 = pkVar3 + __nmemb + 0xfffffff;
    pkVar8->prev = pkVar3 + __nmemb + 0xffffffe;
    pkVar8->next = (k_item *)0x0;
    if (_Var1 != false) {
        list->tail = pkVar8;
    }
    do {
        iVar7 = list->data_mem_count + 1;
        list->data_mem_count = iVar7;
        ppvVar2 = (void **)realloc(list->data_memory, iVar7 * 4);
        list->data_memory = ppvVar2;
        if (ppvVar2 == (void **)0x0) {
            snprintf(
                tmp42, 0x1000,
                "List %s data_memory failed to realloc count=%d in %s %s():%d",
                list->name, list->data_mem_count, "klist.c", "k_alloc_items",
                0x45);
            _applog(3, tmp42, true);
            _quit(1);
        }
        pvVar4 = calloc(1, list->siz);
        pkVar3->data = pvVar4;
        if (pvVar4 == (void *)0x0) {
            snprintf(tmp42, 0x1000,
                     "List %s failed to calloc item data in %s %s():%d",
                     list->name, "klist.c", "k_alloc_items", 0x49);
            _applog(3, tmp42, true);
            _quit(1);
            pvVar4 = pkVar3->data;
        }
        list->data_memory[list->data_mem_count + 0x3fffffff] = pvVar4;
        pkVar3 = pkVar3->next;
    } while (pkVar3 != (k_item *)0x0);
    return;
}

/* WARNING: Unknown calling convention */

K_LIST *k_new_store(K_LIST *list)

{
    _Bool _Var1;
    K_LIST *pKVar2;
    char *pcVar3;
    cglock_t *pcVar4;
    char tmp42[4096];

    pKVar2 = (K_LIST *)calloc(1, 0x40);
    pcVar3 = list->name;
    if (pKVar2 == (K_LIST *)0x0) {
        snprintf(tmp42, 0x1000, "Failed to calloc store for %s in %s %s():%d",
                 pcVar3, "klist.c", "k_new_store", 0x55);
        _applog(3, tmp42, true);
        _quit(1);
        pcVar3 = list->name;
    }
    pcVar4 = list->lock;
    _Var1 = list->do_tail;
    pKVar2->name = pcVar3;
    pKVar2->lock = pcVar4;
    pKVar2->do_tail = _Var1;
    pKVar2->is_store = true;
    return pKVar2;
}

/* WARNING: Unknown calling convention */

K_LIST *_k_new_list(char *name, size_t siz, int allocate, int limit,
                    _Bool do_tail, char *file, char *func, int line)

{
    K_LIST *list;
    pthread_mutex_t *__mutex;
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    if (allocate < 1) {
        snprintf(
            tmp42, 0x1000,
            "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
            name, allocate, "klist.c", "_k_new_list", 100);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (limit < 0) {
        snprintf(tmp42, 0x1000,
                 "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
                 name, limit, "klist.c", "_k_new_list", 0x67);
        _applog(3, tmp42, true);
        _quit(1);
        list = (K_LIST *)calloc(1, 0x40);
    } else {
        list = (K_LIST *)calloc(1, 0x40);
    }
    if (list == (K_LIST *)0x0) {
        snprintf(tmp42, 0x1000, "Failed to calloc list %s in %s %s():%d", name,
                 "klist.c", "_k_new_list", 0x6b);
        _applog(3, tmp42, true);
        _quit(1);
    }
    list->is_store = false;
    __mutex = (pthread_mutex_t *)calloc(1, 0x38);
    list->lock = (cglock_t *)__mutex;
    if (__mutex == (pthread_mutex_t *)0x0) {
        snprintf(tmp42, 0x1000,
                 "Failed to calloc lock for list %s in %s %s():%d", name,
                 "klist.c", "_k_new_list", 0x71);
        _applog(3, tmp42, true);
        _quit(1);
        __mutex = (pthread_mutex_t *)list->lock;
        iVar1 = pthread_mutex_init(__mutex, (pthread_mutexattr_t *)0x0);
    } else {
        iVar1 = pthread_mutex_init(__mutex, (pthread_mutexattr_t *)0x0);
    }
    if (iVar1 == 0) {
        iVar1 = pthread_rwlock_init((pthread_rwlock_t *)(__mutex + 1),
                                    (pthread_rwlockattr_t *)0x0);
    } else {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "Failed to pthread_mutex_init errno=%d in %s %s():%d", *piVar2,
                 "klist.c", "_k_new_list", 0x73);
        _applog(3, tmp42, true);
        _quit(1);
        iVar1 = pthread_rwlock_init((pthread_rwlock_t *)(__mutex + 1),
                                    (pthread_rwlockattr_t *)0x0);
    }
    if (iVar1 != 0) {
        piVar2 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
                 *piVar2, "klist.c", "_k_new_list", 0x73);
        _applog(3, tmp42, true);
        _quit(1);
    }
    list->name = name;
    list->siz = siz;
    list->allocate = allocate;
    list->limit = limit;
    list->do_tail = do_tail;
    k_alloc_items(list, file, func, line);
    return list;
}

/* WARNING: Unknown calling convention */

K_ITEM *_k_unlink_head(K_LIST *list, char *file, char *func, int line)

{
    k_item *pkVar1;
    k_item *pkVar2;

    pkVar2 = list->head;
    if (pkVar2 == (k_item *)0x0) {
        if (list->is_store == false) {
            k_alloc_items(list, file, func, line);
            pkVar2 = list->head;
            if (pkVar2 != (k_item *)0x0)
                goto LAB_00032d2c;
        }
        return (K_ITEM *)0x0;
    }
LAB_00032d2c:
    pkVar1 = pkVar2->next;
    list->head = pkVar1;
    if (pkVar1 == (k_item *)0x0) {
        if (list->do_tail != false) {
            list->tail = (k_item *)0x0;
        }
    } else {
        pkVar1->prev = (k_item *)0x0;
    }
    pkVar2->prev = (k_item *)0x0;
    pkVar2->next = (k_item *)0x0;
    list->count = list->count + -1;
    return pkVar2;
}

/* WARNING: Unknown calling convention */

K_ITEM *_k_unlink_head_zero(K_LIST *list, char *file, char *func, int line)

{
    K_ITEM *pKVar1;

    pKVar1 = _k_unlink_head(list, file, func, line);
    if (pKVar1 != (K_ITEM *)0x0) {
        memset(pKVar1->data, 0, list->siz);
    }
    return pKVar1;
}

/* WARNING: Unknown calling convention */

K_ITEM *_k_unlink_tail(K_LIST *list, char *file, char *func, int line)

{
    k_item *pkVar1;
    k_item *pkVar2;
    char tmp42[4096];

    if (list->do_tail == false) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() - do_tail is false - from %s %s() line "
                 "%d in %s %s():%d",
                 list->name, "_k_unlink_tail", file, func, line, "klist.c",
                 "_k_unlink_tail", 0xb5);
        _applog(3, tmp42, true);
        _quit(1);
    }
    pkVar1 = list->tail;
    if (pkVar1 != (k_item *)0x0) {
        pkVar2 = pkVar1->prev;
        list->tail = pkVar2;
        if (pkVar2 == (k_item *)0x0) {
            list->head = (k_item *)0x0;
        } else {
            pkVar2->next = (k_item *)0x0;
        }
        pkVar1->prev = (k_item *)0x0;
        pkVar1->next = (k_item *)0x0;
        list->count = list->count + -1;
    }
    return pkVar1;
}

/* WARNING: Unknown calling convention */

void _k_add_head(K_LIST *list, K_ITEM *item, char *file, char *func, int line)

{
    char tmp42[4096];

    if (item->name != list->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() a %s item - from %s %s() line %d in %s "
                 "%s():%d",
                 list->name, "_k_add_head", item->name, file, func, line,
                 "klist.c", "_k_add_head", 0xcd);
        _applog(3, tmp42, true);
        _quit(1);
    }
    item->prev = (k_item *)0x0;
    item->next = list->head;
    if (list->head != (k_item *)0x0) {
        list->head->prev = item;
    }
    list->head = item;
    if ((list->do_tail != false) && (list->tail == (k_item *)0x0)) {
        list->tail = item;
    }
    list->count = list->count + 1;
    list->count_up = list->count_up + 1;
    return;
}

/* WARNING: Unknown calling convention */

void _k_add_tail(K_LIST *list, K_ITEM *item, char *file, char *func, int line)

{
    char tmp42[4096];

    if (item->name != list->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() a %s item - from %s %s() line %d in %s "
                 "%s():%d",
                 list->name, "_k_add_tail", item->name, file, func, line,
                 "klist.c", "_k_add_tail", 0xec);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (list->do_tail == false) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() - do_tail is false - from %s %s() line "
                 "%d in %s %s():%d",
                 list->name, "_k_add_tail", file, func, line, "klist.c",
                 "_k_add_tail", 0xf1);
        _applog(3, tmp42, true);
        _quit(1);
    }
    item->prev = list->tail;
    item->next = (k_item *)0x0;
    if (list->tail != (k_item *)0x0) {
        list->tail->next = item;
    }
    list->tail = item;
    if (list->head == (k_item *)0x0) {
        list->head = item;
    }
    list->count = list->count + 1;
    list->count_up = list->count_up + 1;
    return;
}

/* WARNING: Unknown calling convention */

void _k_insert_before(K_LIST *list, K_ITEM *item, K_ITEM *before, char *file,
                      char *func, int line)

{
    char tmp42[4096];

    if (item->name != list->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() a %s item - from %s %s() line %d in %s "
                 "%s():%d",
                 list->name, "_k_insert_before", item->name, file, func, line,
                 "klist.c", "_k_insert_before", 0x106);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (before == (K_ITEM *)0x0) {
        snprintf(tmp42, 0x1000,
                 "%s() (%s) can\'t before a null item - from %s %s() line %d "
                 "in %s %s():%d",
                 "_k_insert_before", list->name, file, func, line, "klist.c",
                 "_k_insert_before", 0x10b);
        _applog(3, tmp42, true);
        _quit(1);
    }
    item->next = before;
    item->prev = before->prev;
    if (before->prev == (k_item *)0x0) {
        list->head = item;
    } else {
        before->prev->next = item;
    }
    before->prev = item;
    list->count = list->count + 1;
    list->count_up = list->count_up + 1;
    return;
}

/* WARNING: Unknown calling convention */

void _k_insert_after(K_LIST *list, K_ITEM *item, K_ITEM *after, char *file,
                     char *func, int line)

{
    char tmp42[4096];

    if (item->name != list->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() a %s item - from %s %s() line %d in %s "
                 "%s():%d",
                 list->name, "_k_insert_after", item->name, file, func, line,
                 "klist.c", "_k_insert_after", 0x11e);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (after == (K_ITEM *)0x0) {
        snprintf(tmp42, 0x1000,
                 "%s() (%s) can\'t after a null item - from %s %s() line %d in "
                 "%s %s():%d",
                 "_k_insert_after", list->name, file, func, line, "klist.c",
                 "_k_insert_after", 0x123);
        _applog(3, tmp42, true);
        _quit(1);
    }
    item->prev = after;
    item->next = after->next;
    if (after->next == (k_item *)0x0) {
        if (list->do_tail != false) {
            list->tail = item;
        }
    } else {
        after->next->prev = item;
    }
    after->next = item;
    list->count = list->count + 1;
    list->count_up = list->count_up + 1;
    return;
}

/* WARNING: Unknown calling convention */

void _k_unlink_item(K_LIST *list, K_ITEM *item, char *file, char *func,
                    int line)

{
    k_item *pkVar1;
    bool bVar2;
    char tmp42[4096];

    if (item->name != list->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() a %s item - from %s %s() line %d in %s "
                 "%s():%d",
                 list->name, "_k_unlink_item", item->name, file, func, line,
                 "klist.c", "_k_unlink_item", 0x138);
        _applog(3, tmp42, true);
        _quit(1);
    }
    pkVar1 = item->next;
    if (item->prev != (k_item *)0x0) {
        item->prev->next = pkVar1;
        pkVar1 = item->next;
    }
    if (pkVar1 != (k_item *)0x0) {
        pkVar1->prev = item->prev;
    }
    pkVar1 = list->head;
    bVar2 = pkVar1 == item;
    if (bVar2) {
        pkVar1 = item->next;
    }
    if (bVar2) {
        list->head = pkVar1;
    }
    if (list->do_tail != false) {
        pkVar1 = list->tail;
        bVar2 = pkVar1 == item;
        if (bVar2) {
            pkVar1 = item->prev;
        }
        if (bVar2) {
            list->tail = pkVar1;
        }
    }
    item->prev = (k_item *)0x0;
    item->next = (k_item *)0x0;
    list->count = list->count + -1;
    return;
}

/* WARNING: Unknown calling convention */

void _k_list_transfer_to_head(K_LIST *from, K_LIST *to, char *file, char *func,
                              int line)

{
    k_item *pkVar1;
    char tmp42[4096];

    if (from->name != to->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() to a %s list - from %s %s() line %d in "
                 "%s %s():%d",
                 from->name, "_k_list_transfer_to_head", to->name, file, func,
                 line, "klist.c", "_k_list_transfer_to_head", 0x152);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (from->do_tail == false) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() - do_tail is false - from %s %s() line "
                 "%d in %s %s():%d",
                 from->name, "_k_list_transfer_to_head", file, func, line,
                 "klist.c", "_k_list_transfer_to_head", 0x157);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (from->head != (k_item *)0x0) {
        if (to->head == (k_item *)0x0) {
            to->tail = from->tail;
            pkVar1 = (k_item *)0x0;
        } else {
            to->head->prev = from->tail;
            pkVar1 = to->head;
        }
        from->tail->next = pkVar1;
        to->head = from->head;
        from->tail = (k_item *)0x0;
        from->head = (k_item *)0x0;
        to->count = to->count + from->count;
        from->count = 0;
        to->count_up = to->count_up + from->count_up;
        from->count_up = 0;
    }
    return;
}

/* WARNING: Unknown calling convention */

void _k_list_transfer_to_tail(K_LIST *from, K_LIST *to, char *file, char *func,
                              int line)

{
    k_item *pkVar1;
    char tmp42[4096];

    if (from->name != to->name) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() to a %s list - from %s %s() line %d in "
                 "%s %s():%d",
                 from->name, "_k_list_transfer_to_tail", to->name, file, func,
                 line, "klist.c", "_k_list_transfer_to_tail", 0x170);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (from->do_tail == false) {
        snprintf(tmp42, 0x1000,
                 "List %s can\'t %s() - do_tail is false - from %s %s() line "
                 "%d in %s %s():%d",
                 from->name, "_k_list_transfer_to_tail", file, func, line,
                 "klist.c", "_k_list_transfer_to_tail", 0x175);
        _applog(3, tmp42, true);
        _quit(1);
    }
    pkVar1 = from->head;
    if (pkVar1 != (k_item *)0x0) {
        if (to->tail == (k_item *)0x0) {
            to->head = pkVar1;
            pkVar1 = (k_item *)0x0;
        } else {
            to->tail->next = pkVar1;
            pkVar1 = to->tail;
        }
        from->head->prev = pkVar1;
        to->tail = from->tail;
        from->tail = (k_item *)0x0;
        from->head = (k_item *)0x0;
        to->count = to->count + from->count;
        from->count = 0;
        to->count_up = to->count_up + from->count_up;
        from->count_up = 0;
    }
    return;
}

/* WARNING: Unknown calling convention */

K_LIST *_k_free_list(K_LIST *list, char *file, char *func, int line)

{
    void **ppvVar1;
    int iVar2;
    pthread_mutex_t *__mutex;
    char tmp42[4096];

    if (list->is_store != false) {
        snprintf(
            tmp42, 0x1000,
            "List %s can\'t %s() a store - from %s %s() line %d in %s %s():%d",
            list->name, "_k_free_list", file, func, line, "klist.c",
            "_k_free_list", 400);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (0 < list->item_mem_count) {
        iVar2 = 0;
        do {
            ppvVar1 = list->item_memory + iVar2;
            iVar2 = iVar2 + 1;
            free(*ppvVar1);
        } while (iVar2 < list->item_mem_count);
    }
    free(list->item_memory);
    if (0 < list->data_mem_count) {
        iVar2 = 0;
        do {
            ppvVar1 = list->data_memory + iVar2;
            iVar2 = iVar2 + 1;
            free(*ppvVar1);
        } while (iVar2 < list->data_mem_count);
    }
    free(list->data_memory);
    __mutex = (pthread_mutex_t *)list->lock;
    pthread_rwlock_destroy((pthread_rwlock_t *)(__mutex + 1));
    pthread_mutex_destroy(__mutex);
    free(list->lock);
    free(list);
    return (K_LIST *)0x0;
}

/* WARNING: Unknown calling convention */

K_LIST *_k_free_store(K_LIST *store, char *file, char *func, int line)

{
    char tmp42[4096];

    if (store->is_store == false) {
        snprintf(tmp42, 0x1000,
                 "Store %s can\'t %s() the list - from %s %s() line %d in %s "
                 "%s():%d",
                 store->name, "_k_free_store", file, func, line, "klist.c",
                 "_k_free_store", 0x1a8);
        _applog(3, tmp42, true);
        _quit(1);
    }
    free(store);
    return (K_LIST *)0x0;
}

/* WARNING: Unknown calling convention */

void dupalloc(cgpu_info *cgpu, int timelimit)

{
    int *piVar1;
    K_LIST *pKVar2;
    char tmp42[4096];

    piVar1 = (int *)calloc(1, 0x20);
    if (piVar1 == (int *)0x0) {
        snprintf(tmp42, 0x1000, "Failed to calloc dupdata in %s %s():%d",
                 "noncedup.c", "dupalloc", 0x24);
        _applog(3, tmp42, true);
        _quit(1);
    }
    *piVar1 = timelimit;
    pKVar2 = _k_new_list("Nonces", 0x10, 0x400, 0, true, "noncedup.c",
                         "dupalloc", 0x27);
    piVar1[1] = (int)pKVar2;
    pKVar2 = k_new_store(pKVar2);
    cgpu->dup_data = piVar1;
    piVar1[2] = (int)pKVar2;
    return;
}

/* WARNING: Unknown calling convention */

void dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups)

{
    undefined4 uVar1;
    dupdata *dup;
    void *pvVar2;

    pvVar2 = cgpu->dup_data;
    if (pvVar2 != (void *)0x0) {
        uVar1 = *(undefined4 *)((int)pvVar2 + 0x14);
        *(undefined4 *)checked = *(undefined4 *)((int)pvVar2 + 0x10);
        *(undefined4 *)((int)checked + 4) = uVar1;
        uVar1 = *(undefined4 *)((int)pvVar2 + 0x1c);
        *(undefined4 *)dups = *(undefined4 *)((int)pvVar2 + 0x18);
        *(undefined4 *)((int)dups + 4) = uVar1;
        return;
    }
    *(undefined4 *)checked = 0;
    *(undefined4 *)((int)checked + 4) = 0;
    *(undefined4 *)dups = 0;
    *(undefined4 *)((int)dups + 4) = 0;
    return;
}

/* WARNING: Unknown calling convention */

_Bool isdupnonce(cgpu_info *cgpu, work *work, uint32_t nonce)

{
    bool bVar1;
    int iVar2;
    K_ITEM *pKVar3;
    uint uVar4;
    dupdata *dup;
    int *piVar5;
    pthread_mutex_t *ppVar6;
    int *piVar7;
    bool bVar8;
    void *pvVar9;
    double dVar10;
    timeval now;
    char tmp42[4096];

    piVar5 = (int *)cgpu->dup_data;
    piVar7 = piVar5;
    if (piVar5 == (int *)0x0) {
    LAB_00033720:
        return SUB41(piVar7, 0);
    }
    cgtime(&now);
    uVar4 = piVar5[4];
    piVar5[4] = uVar4 + 1;
    piVar5[5] = piVar5[5] + (uint)(0xfffffffe < uVar4);
    ppVar6 = *(pthread_mutex_t **)(piVar5[1] + 8);
    iVar2 = pthread_mutex_lock(ppVar6);
    if (iVar2 != 0) {
        piVar7 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar7,
                 "noncedup.c", "isdupnonce", 0x46);
        _applog(3, tmp42, true);
        _quit(1);
    }
    iVar2 = pthread_rwlock_wrlock((pthread_rwlock_t *)(ppVar6 + 1));
    if (iVar2 != 0) {
        piVar7 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *piVar7,
                 "noncedup.c", "isdupnonce", 0x46);
        _applog(3, tmp42, true);
        _quit(1);
    }
    iVar2 = *(int *)(piVar5[2] + 0x10);
    bVar8 = true;
    do {
        bVar1 = bVar8;
        if (iVar2 == 0) {
            bVar1 = false;
        }
        while (true) {
            if (!bVar1) {
                if (bVar8) {
                    pKVar3 = _k_unlink_head((K_LIST *)piVar5[1], "noncedup.c",
                                            "isdupnonce", 0x51);
                    *(uint32_t *)pKVar3->data = work->id;
                    *(uint32_t *)((int)pKVar3->data + 4) = nonce;
                    pvVar9 = pKVar3->data;
                    *(__suseconds_t *)((int)pvVar9 + 0xc) = now.tv_usec;
                    *(__time_t *)((int)pvVar9 + 8) = now.tv_sec;
                    _k_add_head((K_LIST *)piVar5[2], pKVar3, "noncedup.c",
                                "isdupnonce", 0x55);
                }
                iVar2 = *(int *)(piVar5[2] + 0x10);
                while ((iVar2 != 0 &&
                        (dVar10 = tdiff((timeval *)(*(int *)(iVar2 + 0xc) + 8),
                                        &now),
                         (double)(longlong)*piVar5 < dVar10))) {
                    pKVar3 = _k_unlink_tail((K_LIST *)piVar5[2], "noncedup.c",
                                            "isdupnonce", 0x59);
                    _k_add_head((K_LIST *)piVar5[1], pKVar3, "noncedup.c",
                                "isdupnonce", 0x5a);
                    iVar2 = *(int *)(piVar5[2] + 0x10);
                }
                ppVar6 = *(pthread_mutex_t **)(piVar5[1] + 8);
                iVar2 = pthread_rwlock_unlock((pthread_rwlock_t *)(ppVar6 + 1));
                if (iVar2 != 0) {
                    piVar7 = __errno_location();
                    snprintf(
                        tmp42, 0x1000,
                        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *piVar7, "noncedup.c", "isdupnonce", 0x5d);
                    _applog(3, tmp42, true);
                    _quit(1);
                }
                iVar2 = pthread_mutex_unlock(ppVar6);
                if (iVar2 != 0) {
                    piVar7 = __errno_location();
                    snprintf(
                        tmp42, 0x1000,
                        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *piVar7, "noncedup.c", "isdupnonce", 0x5d);
                    _applog(3, tmp42, true);
                    _quit(1);
                }
                (*selective_yield)();
                piVar7 = (int *)0x0;
                if (!bVar8) {
                    uVar4 = piVar5[6];
                    piVar7 = (int *)0x1;
                    piVar5[6] = uVar4 + 1;
                    piVar5[7] = piVar5[7] + (uint)(0xfffffffe < uVar4);
                }
                goto LAB_00033720;
            }
            if ((**(uint32_t **)(iVar2 + 0xc) == work->id) &&
                ((*(uint32_t **)(iVar2 + 0xc))[1] == nonce))
                break;
            iVar2 = *(int *)(iVar2 + 4);
            bVar8 = bVar1;
            if (iVar2 == 0) {
                bVar1 = false;
            }
        }
        if ((use_syslog != false) ||
            ((opt_log_output != false || (bVar8 = false, 3 < opt_log_level)))) {
            bVar8 = false;
            snprintf(tmp42, 0x1000, "%s%d: Duplicate nonce %08x",
                     cgpu->drv->name, cgpu->device_id, nonce);
            _applog(4, tmp42, false);
        }
    } while (true);
}

ushort crc16(uchar *buffer, int len)

{
    byte *pbVar1;
    uint uVar3;
    byte *pbVar2;

    if (0 < len) {
        uVar3 = 0;
        pbVar2 = buffer;
        do {
            pbVar1 = pbVar2 + 1;
            uVar3 = (uint)(ushort)crc16_table[(uint)*pbVar2 ^ uVar3 >> 8] ^
                    (uVar3 & 0xff) << 8;
            pbVar2 = pbVar1;
        } while (pbVar1 != buffer + len);
        return (ushort)uVar3;
    }
    return 0;
}

/* WARNING: Unknown calling convention */

void get_bitmain_statline_before(char *buf, size_t bufsiz,
                                 cgpu_info *bitmain_ZCASH)

{
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void reset_all_hash_board_low(void)

{
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s %d", "reset_all_hash_board_low", 0x1128);
        _applog(5, tmp42, false);
    }
    axi_fpga_addr[0xd] = 0xffff;
    return;
}

/* WARNING: Unknown calling convention */

void bitmain_ZCASH_update(cgpu_info *bitmain)

{
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "Updated Work", 0xc);
        tmp42[0xc] = '!';
        tmp42[0xd] = '\0';
        _applog(7, tmp42, false);
    }
    new_block[0] = true;
    new_block[1] = true;
    new_block[2] = true;
    new_block[3] = true;
    return;
}

/* WARNING: Unknown calling convention */

int64_t bitmain_ZCASH_scanhash(thr_info *thr)

{
    pthread_t send_id;

    h._0_4_ = 0;
    h._4_4_ = 0;
    pthread_create(&send_id, (pthread_attr_t *)0x0, (__start_routine *)0x34285,
                   thr);
    pthread_join(send_id, (void **)0x0);
    return CONCAT44(h._4_4_, (undefined4)h);
}

/* WARNING: Unknown calling convention */

api_data *bitmain_api_stats(cgpu_info *cgpu)

{
    api_data *paVar1;
    uint uVar2;
    int iVar3;
    int iVar4;
    uint32_t *data;
    char(*data_00)[19];
    char(*__s)[16];
    DFtype a;
    double dVar5;
    double dVar6;
    double rateideal;
    char chain_freq[16];
    char tmp42[4096];

    rateideal._0_4_ = 0;
    rateideal._4_4_ = 0x41086a00;
    uVar2 = (uint)use_syslog;
    if (((use_syslog != 0) ||
         (uVar2 = (uint)opt_log_output, opt_log_output != 0)) ||
        (uVar2 = opt_log_level, 4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "rateideal = %f\n", uVar2, 0, 0x41086a00);
        _applog(5, tmp42, false);
    }
    data = dev.fan_speed_value;
    paVar1 = api_add_mhs((api_data *)0x0, "total_rateideal", &rateideal, false);
    paVar1 = api_add_uint8(paVar1, "miner_count", &dev.chain_num, false);
    iVar3 = 0;
    paVar1 = api_add_uint8(paVar1, "fan_num", &dev.fan_num, false);
    do {
        iVar3 = iVar3 + 1;
        sprintf(tmp42, "fan%d", iVar3);
        paVar1 = api_add_uint32(paVar1, tmp42, data, false);
        data = data + 1;
    } while (iVar3 != 6);
    paVar1 = api_add_uint8(paVar1, "temp_num", &dev.chain_num, false);
    iVar3 = 0;
    do {
        iVar4 = iVar3 + 1;
        sprintf(tmp42, "temp%d", iVar4);
        paVar1 = api_add_int16(paVar1, tmp42,
                               (int16_t *)(dev.max_local_temp + iVar3), false);
        iVar3 = iVar4;
    } while (iVar4 != 4);
    iVar3 = 0;
    do {
        iVar4 = iVar3 + 1;
        sprintf(tmp42, "temp2_%d", iVar4);
        paVar1 = api_add_int16(paVar1, tmp42,
                               (int16_t *)(dev.max_remote_temp + iVar3), false);
        iVar3 = iVar4;
    } while (iVar4 != 4);
    paVar1 =
        api_add_uint32(paVar1, "temp_max", (uint32_t *)&dev.temp_top1, false);
    total_diff1 = __fixdfdi(a);
    if ((uint)total_diff1 + hw_errors == 0 &&
        (int)((ulonglong)total_diff1 >> 0x20) + (hw_errors >> 0x1f) +
                (uint)CARRY4((uint)total_diff1, hw_errors) ==
            0) {
        dVar6 = 0.0;
    } else {
        dVar6 = (double)FixedToFP(CONCAT44(hw_errors, hw_errors), 0x20, 0x40, 8,
                                  0, 0);
        dVar5 = (double)__aeabi_l2d();
        dVar6 = dVar6 / dVar5;
    }
    hwp._4_4_ = (undefined4)((ulonglong)dVar6 >> 0x20);
    hwp._0_4_ = SUB84(dVar6, 0);
    paVar1 = api_add_percent(paVar1, "Device Hardware%", &hwp, true);
    paVar1 = api_add_int(paVar1, "no_matching_work", &hw_errors, true);
    iVar3 = 0;
    do {
        iVar4 = iVar3 + 1;
        sprintf(tmp42, "chain_acn%d", iVar4);
        paVar1 =
            api_add_uint8(paVar1, tmp42, dev.chain_asic_num + iVar3, false);
        iVar3 = iVar4;
    } while (iVar4 != 4);
    data_00 = dev.chain_asic_status_string;
    iVar3 = 0;
    do {
        iVar3 = iVar3 + 1;
        sprintf(tmp42, "chain_acs%d", iVar3);
        paVar1 = api_add_string(paVar1, tmp42, *data_00, false);
        data_00 = data_00 + 1;
    } while (iVar3 != 4);
    iVar3 = 0;
    do {
        iVar4 = iVar3 + 1;
        sprintf(tmp42, "chain_hw%d", iVar4);
        paVar1 = api_add_uint32(paVar1, tmp42, dev.chain_hw + iVar3, false);
        iVar3 = iVar4;
    } while (iVar4 != 4);
    iVar3 = 0;
    do {
        iVar4 = iVar3 + 1;
        chain_freq[0] = '\0';
        chain_freq[1] = '\0';
        chain_freq[2] = '\0';
        chain_freq[3] = '\0';
        chain_freq[4] = '\0';
        chain_freq[5] = '\0';
        chain_freq[6] = '\0';
        chain_freq[7] = '\0';
        chain_freq[8] = '\0';
        chain_freq[9] = '\0';
        chain_freq[10] = '\0';
        chain_freq[0xb] = '\0';
        chain_freq[0xc] = '\0';
        chain_freq[0xd] = '\0';
        chain_freq[0xe] = '\0';
        chain_freq[0xf] = '\0';
        tmp42[0] = '\0';
        tmp42[1] = '\0';
        tmp42[2] = '\0';
        tmp42[3] = '\0';
        tmp42[4] = '\0';
        tmp42[5] = '\0';
        tmp42[6] = '\0';
        tmp42[7] = '\0';
        tmp42[8] = '\0';
        tmp42[9] = '\0';
        tmp42[10] = '\0';
        tmp42[0xb] = '\0';
        tmp42[0xc] = '\0';
        tmp42[0xd] = '\0';
        tmp42[0xe] = '\0';
        tmp42[0xf] = '\0';
        sprintf(chain_freq, "frequency%d", iVar4);
        sprintf(tmp42, "%u", (uint)dev.freq[iVar3]);
        paVar1 = api_add_uint16(paVar1, chain_freq, dev.freq + iVar3, false);
        iVar3 = iVar4;
    } while (iVar4 != 4);
    __s = displayed_rate;
    iVar3 = 0;
    do {
        iVar3 = iVar3 + 1;
        sprintf(tmp42, "chain_rate%d", iVar3);
        if (certification_firmware != false) {
            sprintf(
                *__s, "%2.2f",
                SUB84(rt_hashrate_total / (double)(longlong)rt_chain_num, 0),
                (int)((ulonglong)(rt_hashrate_total /
                                  (double)(longlong)rt_chain_num) >>
                      0x20));
        }
        paVar1 = api_add_string(paVar1, tmp42, *__s, false);
        __s = __s + 1;
    } while (iVar3 != 4);
    return paVar1;
}

/* WARNING: Unknown calling convention */

void bitmain_ZCASH_reinit_device(cgpu_info *bitmain)

{
    if (!status_error) {
        system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void bitmain_ZCASH_detect(_Bool hotplug)

{
    _Bool _Var1;
    cgpu_info *cgpu;
    void *pvVar2;
    char tmp42[4096];

    cgpu = (cgpu_info *)calloc(1, 0x188);
    if (cgpu == (cgpu_info *)0x0) {
        /* WARNING: Subroutine does not return */
        __assert_fail("cgpu", "driver-btm-zcash.c", 0x1d46,
                      "bitmain_ZCASH_detect");
    }
    cgpu->drv = &bitmainZCASH_drv;
    cgpu->deven = DEV_ENABLED;
    cgpu->threads = 1;
    pvVar2 = calloc(0x4b4, 1);
    cgpu->device_data = pvVar2;
    if (pvVar2 == (void *)0x0) {
        builtin_strncpy(tmp42, "Failed to calloc cgpu_info data", 0x20);
        _applog(3, tmp42, true);
        _quit(1);
    }
    _Var1 = add_cgpu(cgpu);
    if (!_Var1) {
        /* WARNING: Subroutine does not return */
        __assert_fail("add_cgpu(cgpu)", "driver-btm-zcash.c", 0x1d4e,
                      "bitmain_ZCASH_detect");
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s detect new device", "bitmain_ZCASH_detect");
        _applog(7, tmp42, false);
    }
    return;
}

/* WARNING: Unknown calling convention */

void *check_fan_thr(void *arg)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    int iVar5;
    uint data;

LAB_00033edc:
    iVar4 = 2;
    dev.fan_speed_top1 = 0;
    dev.fan_speed_low1 = 0;
    do {
        iVar5 = 6;
        do {
            uVar2 = axi_fpga_addr[1];
            if (uVar2 != 0xffffffff) {
                uVar3 = (uVar2 << 0x15) >> 0x1d;
                uVar1 = (uVar2 & 0xff) * 0x78;
                dev.fan_speed_value[uVar3] = uVar1;
                if ((uVar2 & 0xff) == 0) {
                    if (dev.fan_exist[uVar3] == '\x01') {
                        dev.fan_exist[uVar3] = (uint8_t)uVar2;
                        dev.fan_num = dev.fan_num + 0xff;
                        dev.fan_exist_map = 0;
                    }
                LAB_00033f3a:
                    if (dev.fan_speed_low1 != 0)
                        goto LAB_00033f40;
                } else {
                    if (dev.fan_exist[uVar3] == '\0') {
                        dev.fan_exist[uVar3] = '\x01';
                        dev.fan_exist_map = dev.fan_exist_map | 1 << uVar3;
                        dev.fan_num = dev.fan_num + '\x01';
                    }
                    if (dev.fan_speed_top1 <= uVar1 &&
                        uVar1 - dev.fan_speed_top1 != 0) {
                        dev.fan_speed_top1 = uVar1;
                    }
                    if (uVar1 == 0 || dev.fan_speed_low1 <= uVar1)
                        goto LAB_00033f3a;
                }
                dev.fan_speed_low1 = uVar1;
            }
        LAB_00033f40:
            cgsleep_ms(0x32);
            iVar5 = iVar5 + -1;
        } while (iVar5 != 0);
        if (iVar4 == 1)
            break;
        iVar4 = 1;
    } while (true);
    sleep(1);
    goto LAB_00033edc;
}

/* WARNING: Unknown calling convention */

void *get_hash_rate(void)

{
    int iVar1;
    int iVar2;
    uint uVar3;
    double *pdVar4;
    int extraout_r3;
    int iVar5;
    double *pdVar6;
    int iVar7;
    int iVar8;
    int iVar9;
    double dVar10;
    double dVar11;
    double dVar12;
    timeval old_h;
    timeval new_h;
    int index[4];
    double each_chain_h[4][10];

    memset(each_chain_h, 0, 0x140);
    index[0] = 0;
    index[1] = 0;
    index[2] = 0;
    index[3] = 0;
    cgtime(&old_h);
    cgtime(&new_h);
    do {
        pdVar6 = each_chain_h_avg;
        cgtime(&new_h);
        iVar5 = 0;
        dVar12 = 0.0;
        iVar2 = new_h.tv_sec - old_h.tv_sec;
        iVar9 = new_h.tv_usec - old_h.tv_usec;
        if (iVar9 < 0) {
            iVar2 = iVar2 + -1;
            iVar9 = iVar9 + 1000000;
        }
        do {
            if (dev.chain_exist[iVar5] != '\0') {
                iVar7 = index[iVar5];
                uVar3 = (uint)h_each_chain[iVar5];
                iVar1 = *(int *)((int)h_each_chain + iVar5 * 8 + 4);
                dVar10 = (double)__floatundidf(
                    uVar3 * 0xffff, ((iVar1 << 0x10 | uVar3 >> 0x10) - iVar1) -
                                        (uint)(uVar3 * 0x10000 < uVar3));
                dVar11 = 0.0;
                *(undefined4 *)(h_each_chain + iVar5) = 0;
                *(undefined4 *)((int)h_each_chain + iVar5 * 8 + 4) = 0;
                pdVar4 = each_chain_h[iVar5];
                each_chain_h[iVar5][iVar7] =
                    dVar10 / ((double)(longlong)(iVar9 + 1) / 1000000.0 +
                              (double)(longlong)iVar2);
                do {
                    dVar10 = *pdVar4;
                    pdVar4 = pdVar4 + 1;
                    dVar11 = dVar11 + dVar10;
                } while ((double(*)[10])pdVar4 != each_chain_h + iVar5 + 1);
                *pdVar6 = dVar11;
                iVar8 = iVar7 + 1;
                dVar10 = (dVar11 / 1000.0) / 10.0;
                sprintf(displayed_rate[iVar5], "%.2f", SUB84(dVar10, 0),
                        (int)((ulonglong)dVar10 >> 0x20));
                dVar10 = *pdVar6;
                iVar1 = extraout_r3;
                if (9 < iVar8) {
                    iVar1 = 0;
                }
                if (iVar8 == 9 || iVar7 + -8 < 0 != SBORROW4(iVar8, 9)) {
                    index[iVar5] = iVar8;
                } else {
                    index[iVar5] = iVar1;
                }
                dVar12 = dVar12 + dVar10 / 10.0;
            }
            iVar5 = iVar5 + 1;
            pdVar6 = pdVar6 + 1;
        } while (iVar5 != 4);
        sprintf(displayed_hash_rate, "%.2f", SUB84(dVar12, 0),
                (int)((ulonglong)dVar12 >> 0x20));
        geach_chain_h_all = dVar12;
        copy_time(&old_h, &new_h);
        sleep(5);
    } while (true);
}

void i2c_write(uint config_data)

{
    char tmp42[4096];

    snprintf(tmp42, 0x1000, "%s: i2c always busy, break\n", "i2c_write");
    _applog(5, tmp42, false);
    return;
}

uchar i2c_read(uint config_data)

{
    char tmp42[4096];

    snprintf(tmp42, 0x1000, "%s: i2c always busy, break\n", "i2c_read");
    _applog(5, tmp42, false);
    return 0xff;
}

int bm1740_makeup_work(uint8_t *str, int len)

{
    byte *pbVar1;
    uint uVar3;
    byte *pbVar2;

    uVar3 = 0xffff;
    str[2] = str[2] & 0x1f | 0x20;
    str[0] = 'U';
    str[1] = 0xaa;
    pbVar2 = str + 2;
    do {
        pbVar1 = pbVar2 + 1;
        uVar3 =
            ((uint)crc_itu_t_table[(uint)*pbVar2 ^ uVar3 >> 8] ^ uVar3 << 8) &
            0xffff;
        pbVar2 = pbVar1;
    } while (pbVar1 != str + 0x90);
    *(ushort *)(str + 0x90) = (ushort)(uVar3 << 8) | (ushort)(uVar3 >> 8);
    return 0x92;
}

/* WARNING: Unknown calling convention */

int calculate_asic_number(uint actual_asic_number)

{
    char tmp42[4096];

    snprintf(tmp42, 0x1000, "actual_asic_number = %d, but it is error\n",
             actual_asic_number);
    _applog(7, tmp42, false);
    return -1;
}

void _rwlock_init(pthread_rwlock_t *lock, char *file, char *func, int line)

{
    int iVar1;
    int *piVar2;
    char tmp42[4096];

    iVar1 = pthread_rwlock_init((pthread_rwlock_t *)lock,
                                (pthread_rwlockattr_t *)0x0);
    if (iVar1 == 0) {
        return;
    }
    piVar2 = __errno_location();
    snprintf(tmp42, 0x1000,
             "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *piVar2,
             "driver-btm-zcash.c", "bitmain_ZCASH_prepare", 0x1d59);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void *bitmain_scanhash(void *arg)

{
    uint8_t uVar1;
    uint8_t uVar2;
    uint64_t uVar3;
    uint32_t uVar4;
    byte bVar5;
    byte bVar6;
    int iVar7;
    work *base_work;
    int *piVar8;
    uchar *puVar9;
    int iVar10;
    pthread_rwlock_t *__rwlock;
    blake2b_state *pbVar11;
    pthread_mutex_t *__mutex;
    uint uVar12;
    work *work;
    uint32_t uVar13;
    uint uVar14;
    undefined4 uVar15;
    bool bVar16;
    uint8_t nonce_bin[4];
    timeval current;
    uint8_t tmphash[32];
    uint8_t output[32];
    blake2b_state digest[1];
    uint8_t nonce[1344];
    char tmp42[4096];

    iVar10 = *(int *)((int)arg + 0x24);
    __mutex = *(pthread_mutex_t **)(iVar10 + 0x14);
    memset(nonce, 0, 0x540);
    cgtime(&current);
    h._0_4_ = 0;
    h._4_4_ = 0;
    pthread_mutex_lock((pthread_mutex_t *)&nonce_mutex);
    uVar13 = nonce_fifo.nonce_num;
    pthread_mutex_unlock((pthread_mutex_t *)&nonce_mutex);
    iVar7 = pthread_mutex_lock(__mutex);
    if (iVar7 != 0) {
        piVar8 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *piVar8,
                 "driver-btm-zcash.c", "bitmain_scanhash", 0x18a9);
        _applog(3, tmp42, true);
        _quit(1);
    }
    __rwlock = (pthread_rwlock_t *)(__mutex + 1);
    iVar7 = pthread_rwlock_rdlock(__rwlock);
    if (iVar7 != 0) {
        piVar8 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *piVar8,
                 "driver-btm-zcash.c", "bitmain_scanhash", 0x18a9);
        _applog(3, tmp42, true);
        _quit(1);
    }
    iVar7 = pthread_mutex_unlock(__mutex);
    if (iVar7 != 0) {
        piVar8 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar8,
                 "driver-btm-zcash.c", "bitmain_scanhash", 0x18a9);
        _applog(3, tmp42, true);
        _quit(1);
    }
    if (uVar13 != 0) {
        work = (work *)0x0;
        do {
            while (true) {
                pthread_mutex_lock((pthread_mutex_t *)&nonce_mutex);
                uVar4 = nonce_fifo.p_rd;
                uVar13 = uVar13 - 1;
                nonce_fifo.nonce_num = nonce_fifo.nonce_num - 1;
                bVar5 = nonce_fifo.nonce_buffer[nonce_fifo.p_rd].nonce_id;
                uVar14 = (uint)nonce_fifo.nonce_buffer[nonce_fifo.p_rd].work_id;
                uVar2 = nonce_fifo.nonce_buffer[nonce_fifo.p_rd].chip_addr;
                uVar12 =
                    (uint)nonce_fifo.nonce_buffer[nonce_fifo.p_rd].chain_id;
                memcpy(nonce, nonce_fifo.nonce_buffer + nonce_fifo.p_rd, 0x540);
                uVar15 =
                    *(undefined4 *)nonce_fifo.nonce_buffer[uVar4].chip_nonce;
                if (uVar4 < 99) {
                    nonce_fifo.p_rd = uVar4 + 1;
                } else {
                    nonce_fifo.p_rd = 0;
                }
                pthread_mutex_unlock((pthread_mutex_t *)&nonce_mutex);
                if (4 < uVar12) {
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        snprintf(tmp42, 0x1000, "Error:scanhash chainid=%u\n",
                                 uVar12);
                        _applog(5, tmp42, false);
                        iVar7 = pthread_rwlock_unlock(__rwlock);
                        goto joined_r0x000346ac;
                    }
                    goto LAB_000344bc;
                }
                pthread_mutex_lock((pthread_mutex_t *)&work_queue_mutex);
                base_work = *(work **)((int)__mutex + (uVar14 + 0x1c) * 4 + 6);
                if (base_work != (work *)0x0) {
                    work = copy_work_noffset(base_work, 0);
                }
                pthread_mutex_unlock((pthread_mutex_t *)&work_queue_mutex);
                if (work != (work *)0x0)
                    break;
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "%s %d: work %02x not find error",
                             *(undefined4 *)(*(int *)(iVar10 + 4) + 8),
                             *(undefined4 *)(iVar10 + 8), uVar14);
                    _applog(3, tmp42, false);
                }
            joined_r0x00034546:
                if (uVar13 == 0)
                    goto LAB_000344bc;
            }
            *(undefined4 *)(work->equihash_data + 0x88) = uVar15;
            memcpy(work->equihash_data + 0x8f, nonce, 0x540);
            digestInit(digest, 200, 9);
            blake2b_update(digest, work->equihash_data, 0x8c);
            memset(tmphash, 0, 0x20);
            memset(output, 0, 0x20);
            memcpy(tmp42, work->equihash_data, 0x5cf);
            Sha256_Onestep((uint8_t *)tmp42, 0x5cf, tmphash);
            Sha256_Onestep(tmphash, 0x20, output);
            pbVar11 = digest;
            puVar9 = work->hash;
            do {
                pbVar11 = (blake2b_state *)&pbVar11[-1].field_0x167;
                puVar9 = puVar9 + -1;
                if (*(byte *)pbVar11 < *puVar9)
                    break;
                if (*puVar9 < *(byte *)pbVar11) {
                    iVar7 = IsValidSolution(digest, nonce);
                    if (iVar7 != 0)
                        goto LAB_0003455a;
                    goto LAB_00034444;
                }
            } while ((blake2b_state *)output != pbVar11);
            iVar7 = IsValidSolution(digest, nonce);
            if (iVar7 != 0) {
            LAB_0003455a:
                if (iVar7 == 2) {
                    bVar5 = __udivsi3(uVar2, dev.addrInterval);
                    dev.chain_asic_invalid_nonce[uVar12][bVar5] =
                        dev.chain_asic_invalid_nonce[uVar12][bVar5] + 1;
                }
                if (zero_stats_flag != false) {
                    zero_stats_flag = false;
                    dev.chain_hw[0] = 0;
                    dev.chain_hw[1] = 0;
                    dev.chain_hw[2] = 0;
                    dev.chain_hw[3] = 0;
                }
            LAB_00034596:
                cg_logwork(work, nonce_bin, true);
                _free_work(work);
                work = (work *)0x0;
                goto joined_r0x00034546;
            }
            submit_nonce_direct((thr_info *)arg, work, 1);
        LAB_00034444:
            bVar16 = 0xfffffffe < (uint)h;
            h._0_4_ = (uint)h + 1;
            h._4_4_ = h._4_4_ + (uint)bVar16;
            uVar1 = dev.chain_exist[uVar12];
            uVar3 = h_each_chain[uVar12];
            iVar7 = *(int *)((int)h_each_chain + uVar12 * 8 + 4);
            *(uint *)(h_each_chain + uVar12) = (uint)uVar3 + 1;
            *(uint *)((int)h_each_chain + uVar12 * 8 + 4) =
                iVar7 + (uint)(0xfffffffe < (uint)uVar3);
            if (uVar1 == '\0') {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "ChainID Cause Error! ChainID:[%d]",
                             uVar12);
                    _applog(3, tmp42, false);
                }
                goto joined_r0x00034546;
            }
            bVar6 = __udivsi3(uVar2, dev.addrInterval);
            uVar14 = (uint)bVar6;
            if (uVar14 < 3) {
                update_work_stats((thr_info *)arg, work);
                dev.chain_asic_nonce[uVar12][uVar14] =
                    dev.chain_asic_nonce[uVar12][uVar14] + 1;
                goto LAB_00034596;
            }
            if ((opt_debug == false) ||
                (((use_syslog == false && (opt_log_output == false)) &&
                  (opt_log_level < 7))))
                goto joined_r0x00034546;
            snprintf(tmp42, 0x1000, "Which Nonce Cause Err![%d] %08x", uVar14,
                     (uint)bVar5);
            _applog(7, tmp42, false);
        } while (uVar13 != 0);
    }
LAB_000344bc:
    iVar7 = pthread_rwlock_unlock(__rwlock);
joined_r0x000346ac:
    if (iVar7 != 0) {
        piVar8 = __errno_location();
        snprintf(tmp42, 0x1000,
                 "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *piVar8,
                 "driver-btm-zcash.c", "bitmain_scanhash", 0x1916);
        _applog(3, tmp42, true);
        _quit(1);
    }
    (*selective_yield)();
    uVar12 = (uint)h >> 0x10;
    bVar16 = (uint)h * 0x10000 < (uint)h;
    h._0_4_ = (uint)h * 0xffff;
    h._4_4_ = ((h._4_4_ << 0x10 | uVar12) - h._4_4_) - (uint)bVar16;
    return (void *)0x0;
}

void _mutex_init(pthread_mutex_t *lock, char *file, char *func, int line)

{
    int *piVar1;
    char tmp42[4096];

    piVar1 = __errno_location();
    snprintf(tmp42, 0x1000,
             "Failed to pthread_mutex_init errno=%d in %s %s():%d", *piVar1,
             "driver-btm-zcash.c", "bitmain_ZCASH_prepare", lock);
    _applog(3, tmp42, true);
    _quit(1);
    return;
}

/* WARNING: Unknown calling convention */

int bitmain_axi_init(void)

{
    int iVar1;

    fpga_fd = open("/dev/axi_fpga_dev", 2);
    if (fpga_fd < 0) {
        printf("/dev/axi_fpga_dev open failed. fd = %d\n", fpga_fd);
        iVar1 = -1;
    } else {
        axi_fpga_addr = (uint *)mmap((void *)0x0, 0x1200, 3, 1, fpga_fd, 0);
        if (axi_fpga_addr == (uint *)0x0) {
            printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", 0);
            iVar1 = -1;
        } else {
            printf("mmap axi_fpga_addr = 0x%x\n", axi_fpga_addr);
            printf("axi_fpga_addr data = 0x%x\n", (uint)(ushort)*axi_fpga_addr);
            fd_fpga_mem = open("/dev/fpga_mem", 2);
            if (fd_fpga_mem < 0) {
                printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n",
                       fd_fpga_mem);
                iVar1 = -1;
            } else {
                fpga_mem_addr =
                    (uint *)mmap((void *)0x0, 0x1000000, 3, 1, fd_fpga_mem, 0);
                if (fpga_mem_addr == (uint *)0x0) {
                    printf("mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n",
                           0);
                    iVar1 = -1;
                } else {
                    printf("mmap fpga_mem_addr = 0x%x\n", fpga_mem_addr);
                    iVar1 = 0;
                }
            }
        }
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

int bitmain_axi_close(void)

{
    int iVar1;

    printf("\n\n--- %s\n", "bitmain_axi_close");
    iVar1 = munmap(axi_fpga_addr, 0x1200);
    if (iVar1 < 0) {
        puts("munmap failed!");
    }
    iVar1 = munmap(fpga_mem_addr, 0x1000000);
    if (iVar1 < 0) {
        puts("munmap failed!");
    }
    close(fpga_fd);
    iVar1 = close(fd_fpga_mem);
    return iVar1;
}

/* WARNING: Unknown calling convention */

void print_bin(uint8_t *cmd, size_t len)

{
    char *__ptr;
    char tmp42[4096];

    __ptr = bin2hex(cmd, len);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        free(__ptr);
        return;
    }
    snprintf(tmp42, 0x1000, "%s", __ptr);
    _applog(5, tmp42, false);
    free(__ptr);
    return;
}

/* WARNING: Unknown calling convention */

uint read_axi_fpga(uint address)

{
    uint data;

    return axi_fpga_addr[address];
}

/* WARNING: Unknown calling convention */

void write_axi_fpga(uint address, uint data)

{
    axi_fpga_addr[address] = data;
    return;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void check_fpga_version(void)

{
    char tmp42[4096];
    uint data;

    *axi_fpga_addr = *axi_fpga_addr | 0x60000000;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return;
    }
    snprintf(tmp42, 0x1000, "FPGA version: %04X", *axi_fpga_addr & 0xffff);
    _applog(5, tmp42, false);
    return;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void init_fpga(void)

{
    uint data;

    printf("\n--- %s\n", "init_fpga");
    axi_fpga_addr[0x20] = 0x8080800f;
    do {
        cgsleep_us(10000);
    } while ((int)axi_fpga_addr[0x20] < 0);
    check_fpga_version();
    cgsleep_us(100000);
    return;
}

/* WARNING: Unknown calling convention */

uchar asic_baud_to_fpga_baud(uchar asic_baud)

{
    if ((1 < asic_baud) && (asic_baud != '\x1a')) {
        printf("%s: Don\'t support ASIC baud = %d, error!!!\n",
               "asic_baud_to_fpga_baud");
        return '5';
    }
    return asic_baud;
}

/* WARNING: Unknown calling convention */

void set_fpga_baud(uchar asic_baud)

{
    byte bVar1;
    uint uVar2;

    bVar1 = asic_baud_to_fpga_baud(asic_baud);
    uVar2 = bVar1 & 0x3f;
    axi_fpga_addr[0xf] = uVar2 | uVar2 << 8 | uVar2 << 0x10 | uVar2 << 0x18;
    return;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

uint check_how_many_uart_data_in_fpga(uchar which_uart)

{
    uint uVar1;
    uint data;

    switch ((uint)which_uart) {
    case 0:
        uVar1 = (axi_fpga_addr[0x7c] << 6) >> 0x16;
        break;
    case 1:
        uVar1 = axi_fpga_addr[0x7c] & 0x3ff;
        break;
    case 2:
        uVar1 = (axi_fpga_addr[0x7d] << 6) >> 0x16;
        break;
    case 3:
        uVar1 = axi_fpga_addr[0x7d] & 0x3ff;
        break;
    case 4:
        uVar1 = (axi_fpga_addr[0x7e] << 6) >> 0x16;
        break;
    case 5:
        uVar1 = axi_fpga_addr[0x7e] & 0x3ff;
        break;
    case 6:
        uVar1 = (axi_fpga_addr[0x7f] << 6) >> 0x16;
        break;
    case 7:
        uVar1 = axi_fpga_addr[0x7f] & 0x3ff;
        break;
    case 8:
        uVar1 = (axi_fpga_addr[0x80] << 6) >> 0x16;
        break;
    case 9:
        uVar1 = axi_fpga_addr[0x80] & 0x3ff;
        break;
    default:
        printf("%s: The uart%d is not supported!!!\n",
               "check_how_many_uart_data_in_fpga", (uint)which_uart);
        uVar1 = 0;
    }
    return uVar1;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

uint read_uart_data_in_fpga(uchar which_uart, uchar *buf, uint length)

{
    uchar uVar1;
    uchar uVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    uchar *puVar6;
    uchar *puVar7;
    uint uVar8;
    uint uVar9;
    int iVar10;
    uint data;

    switch (which_uart) {
    case '\0':
        iVar4 = 0x210;
        iVar10 = 0x85;
        break;
    case '\x01':
        iVar4 = 0x218;
        iVar10 = 0x87;
        break;
    case '\x02':
        iVar4 = 0x220;
        iVar10 = 0x89;
        break;
    case '\x03':
        iVar4 = 0x228;
        iVar10 = 0x8b;
        break;
    case '\x04':
        iVar4 = 0x230;
        iVar10 = 0x8d;
        break;
    case '\x05':
        iVar4 = 0x238;
        iVar10 = 0x8f;
        break;
    case '\x06':
        iVar4 = 0x240;
        iVar10 = 0x91;
        break;
    case '\a':
        iVar4 = 0x248;
        iVar10 = 0x93;
        break;
    case '\b':
        iVar4 = 0x250;
        iVar10 = 0x95;
        break;
    case '\t':
        iVar4 = 600;
        iVar10 = 0x97;
        break;
    default:
        printf("%s: The uart%d is not supported!!!\n",
               "read_uart_data_in_fpga");
        return 0;
    }
    uVar9 = length >> 2;
    *(uint *)((int)axi_fpga_addr + iVar4) = length & 0x3ff | 0x80000000;
    if (uVar9 != 0) {
        puVar6 = buf;
        do {
            puVar7 = puVar6 + 4;
            uVar3 = axi_fpga_addr[iVar10];
            puVar6[3] = (uchar)uVar3;
            *puVar6 = (uchar)(uVar3 >> 0x18);
            puVar6[1] = (uchar)(uVar3 >> 0x10);
            puVar6[2] = (uchar)(uVar3 >> 8);
            puVar6 = puVar7;
        } while (puVar7 != buf + uVar9 * 4);
    }
    uVar3 = length & 0xfffffffc;
    uVar5 = length & 3;
    if (uVar5 != 0) {
        uVar8 = axi_fpga_addr[iVar10];
        uVar1 = (uchar)(uVar8 >> 0x10);
        uVar2 = (uchar)(uVar8 >> 0x18);
        if (uVar5 == 2) {
            buf[uVar9 * 4] = uVar2;
            buf[uVar9 * 4 + 1] = uVar1;
            return uVar3 + 2;
        }
        if (uVar5 != 3) {
            buf[uVar9 * 4] = uVar2;
            return uVar3 + 1;
        }
        uVar3 = uVar3 + 3;
        buf[uVar9 * 4] = uVar2;
        buf[uVar9 * 4 + 1] = uVar1;
        buf[uVar9 * 4 + 2] = (uchar)(uVar8 >> 8);
    }
    return uVar3;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

uint clear_uart_send_fifo(uchar which_chain)

{
    uint uVar1;
    pthread_mutex_t *__mutex;
    int iVar2;
    uint uVar3;
    int iVar4;
    int iVar5;
    uint data;

    uVar1 = (uint)which_chain;
    printf("--- %s\n", "clear_uart_send_fifo");
    __mutex = (pthread_mutex_t *)(uart_send_mutex + uVar1);
    pthread_mutex_lock(__mutex);
    switch (uVar1) {
    case 0:
        iVar5 = 0x180;
        iVar4 = 0x18;
        break;
    case 1:
        iVar5 = 0x180;
        iVar4 = 0x10;
        break;
    case 2:
        iVar5 = 0x180;
        iVar4 = 8;
        break;
    case 3:
        iVar5 = 0x180;
        iVar4 = 0;
        break;
    case 4:
        iVar5 = 0x184;
        iVar4 = 0x18;
        break;
    case 5:
        iVar5 = 0x184;
        iVar4 = 0x10;
        break;
    case 6:
        iVar5 = 0x184;
        iVar4 = 8;
        break;
    case 7:
        iVar5 = 0x184;
        iVar4 = 0;
        break;
    case 8:
        iVar5 = 0x188;
        iVar4 = 0x18;
        break;
    case 9:
        iVar5 = 0x188;
        iVar4 = 0x10;
        break;
    default:
        printf("%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo",
               uVar1);
        pthread_mutex_unlock(__mutex);
        return 1;
    }
    iVar2 = 0x15;
    do {
        uVar3 = *(uint *)((int)axi_fpga_addr + iVar5) >> iVar4 & 0xff;
        if (uVar3 == 0xff) {
            pthread_mutex_unlock(__mutex);
            return 0;
        }
        printf("%s: waiting fpga uart%d clear send fifo space ...\n",
               "clear_uart_send_fifo", uVar1);
        usleep(3000);
        iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    printf("%s: uart%d always dose not has enough send fifo space, break\n",
           "clear_uart_send_fifo", uVar1);
    pthread_mutex_unlock(__mutex);
    return uVar3;
}

/* WARNING: Unknown calling convention */

uint clear_uart_rx_fifo(uchar which_chain)

{
    uint __size;
    uchar *buf;
    uint uVar1;
    pthread_mutex_t *__mutex;

    __mutex = (pthread_mutex_t *)(uart_receive_mutex + which_chain);
    pthread_mutex_lock(__mutex);
    __size = check_how_many_uart_data_in_fpga(which_chain);
    if (__size == 0) {
    LAB_00034fd0:
        pthread_mutex_unlock(__mutex);
        return __size;
    }
    buf = (uchar *)malloc(__size);
    if (buf != (uchar *)0x0) {
        uVar1 = read_uart_data_in_fpga(which_chain, buf, __size);
        if (__size == uVar1) {
            __size = 1;
            free(buf);
            usleep(500000);
            goto LAB_00034fd0;
        }
        printf("%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
               "clear_uart_rx_fifo", (uint)which_chain, __size, uVar1);
        free(buf);
    }
    usleep(500000);
    pthread_mutex_unlock(__mutex);
    return 1;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

uint uart_send(uchar which_uart, uchar *buf, uint length)

{
    byte *pbVar1;
    byte *pbVar2;
    uint uVar3;
    char *__format;
    pthread_mutex_t *__mutex;
    uint *puVar4;
    uint send_data_len;
    int iVar5;
    uint uVar6;
    int iVar7;
    int iVar8;
    int local_123c;
    int local_1234;
    uchar send_buf[512];
    char tmp42[4096];
    uint data;

    uVar6 = (uint)which_uart;
    memset(send_buf, 0, 0x200);
    __mutex = (pthread_mutex_t *)(uart_send_mutex + uVar6);
    pthread_mutex_lock(__mutex);
    switch (uVar6) {
    case 0:
        iVar7 = 0x180;
        local_1234 = 0x65;
        iVar5 = 0x18;
        local_123c = 100;
        break;
    case 1:
        iVar7 = 0x180;
        iVar5 = 0x10;
        local_1234 = 0x67;
        local_123c = 0x66;
        break;
    case 2:
        iVar7 = 0x180;
        local_1234 = 0x69;
        iVar5 = 8;
        local_123c = 0x68;
        break;
    case 3:
        iVar7 = 0x180;
        local_1234 = 0x6b;
        iVar5 = 0;
        local_123c = 0x6a;
        break;
    case 4:
        iVar7 = 0x184;
        local_1234 = 0x6d;
        iVar5 = 0x18;
        local_123c = 0x6c;
        break;
    case 5:
        iVar7 = 0x184;
        local_1234 = 0x6f;
        iVar5 = 0x10;
        local_123c = 0x6e;
        break;
    case 6:
        iVar7 = 0x184;
        local_1234 = 0x71;
        iVar5 = 8;
        local_123c = 0x70;
        break;
    case 7:
        iVar7 = 0x184;
        local_1234 = 0x73;
        iVar5 = 0;
        local_123c = 0x72;
        break;
    case 8:
        iVar7 = 0x188;
        local_1234 = 0x75;
        iVar5 = 0x18;
        local_123c = 0x74;
        break;
    case 9:
        iVar7 = 0x188;
        local_1234 = 0x77;
        iVar5 = 0x10;
        local_123c = 0x76;
        break;
    default:
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            return 0;
        }
        snprintf(tmp42, 0x1000, "%s: The uart%d is not supported!!!\n",
                 "uart_send");
        goto LAB_00035230;
    }
    iVar8 = 0x15;
    while ((*(uint *)((int)axi_fpga_addr + iVar7) >> iVar5 & 0xff) < length) {
        usleep(3000);
        iVar8 = iVar8 + -1;
        if (iVar8 == 0)
            goto LAB_000351ec;
    }
    if (-1 < (int)axi_fpga_addr[local_123c])
        goto LAB_000350b8;
    iVar5 = 0x15;
    do {
        usleep(3000);
        if (-1 < (int)axi_fpga_addr[local_123c]) {
        LAB_000350b8:
            puVar4 = axi_fpga_addr;
            memcpy(send_buf, buf, length);
            uVar6 = length >> 2;
            if (uVar6 != 0) {
                pbVar1 = send_buf;
                do {
                    pbVar2 = pbVar1 + 4;
                    puVar4[local_1234] = (uint)pbVar1[1] << 0x10 |
                                         (uint)*pbVar1 << 0x18 |
                                         (uint)pbVar1[3] | (uint)pbVar1[2] << 8;
                    pbVar1 = pbVar2;
                    puVar4 = axi_fpga_addr;
                } while (send_buf + uVar6 * 4 != pbVar2);
            }
            uVar3 = length & 3;
            if (uVar3 != 0) {
                iVar5 = uVar6 * 4;
                uVar6 = (uint)send_buf[uVar6 * 4] << 0x18;
                if (uVar3 == 2) {
                    uVar6 = uVar6 | (uint)send_buf[iVar5 + 1] << 0x10;
                } else if (uVar3 == 3) {
                    uVar6 = uVar6 | (uint)send_buf[iVar5 + 2] << 8 |
                            (uint)send_buf[iVar5 + 1] << 0x10;
                }
                puVar4[local_1234] = uVar6;
                puVar4 = axi_fpga_addr;
            }
            puVar4[local_123c] = length | 0x80000000;
            pthread_mutex_unlock(__mutex);
            return length;
        }
        iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    pthread_mutex_unlock(__mutex);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return 0;
    }
    __format = "%s: uart%d always busy, break\n";
    goto LAB_00035226;
LAB_000351ec:
    pthread_mutex_unlock(__mutex);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return 0;
    }
    __format = "%s: uart%d always dose not has enough send fifo space, break\n";
LAB_00035226:
    snprintf(tmp42, 0x1000, __format, "uart_send", uVar6);
LAB_00035230:
    _applog(5, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

void *ZCASH_fill_work(void *usrdata)

{
    byte which_uart;
    char cVar1;
    pthread_t __th;
    work *base_work;
    work *pwVar2;
    int len;
    int iVar3;
    thr_info *thr;
    int iVar4;
    int iVar5;
    uint8_t chainid;
    uint uVar6;
    uint uVar7;
    timeval send_start;
    timeval last_send;
    bm1740_work workdata;
    char tmp42[4096];

    __th = pthread_self();
    pthread_detach(__th);
    /* WARNING: Load size is inaccurate */
    iVar3 = *usrdata;
    which_uart = *(byte *)((int)usrdata + 4);
    uVar6 = (uint)which_uart;
    thr = *(thr_info **)(iVar3 + 0x276);
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Start To Fill Work!ChainIndex:[%d]", uVar6);
        _applog(7, tmp42, false);
    }
    uVar7 = 0;
    cgtime(&send_start);
    cgtime(&last_send);
LAB_0003536a:
    do {
        cVar1 = reiniting[uVar6];
        while (true) {
            if (cVar1 != '\0') {
                return (void *)0x0;
            }
            if (((start_send[uVar6] == false) || (stop != false)) ||
                (certification_firmware != false)) {
                cgsleep_ms(10);
                goto LAB_0003536a;
            }
            cgtime(&send_start);
            iVar5 = send_start.tv_usec - last_send.tv_usec;
            iVar4 = send_start.tv_sec - last_send.tv_sec;
            if (iVar5 < 0) {
                iVar4 = iVar4 + -1;
                iVar5 = iVar5 + 1000000;
            }
            if ((new_block[uVar6] != false) ||
                (dev.timeout <= (uint)(iVar4 * 1000000 + iVar5)))
                break;
            cgsleep_us(500);
            cVar1 = reiniting[uVar6];
        }
        cgtime(&last_send);
        while (base_work = get_work(thr, thr->id), base_work == (work *)0x0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (2 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Work Error![%d]", uVar7);
                _applog(3, tmp42, false);
            }
        }
        new_block[uVar6] = false;
        uVar7 = base_work->id & 0x7f;
        iVar4 = iVar3 + uVar7 * 4;
        memset(&workdata, 0, 0x92);
        workdata._2_1_ = 0x20;
        workdata.workid = (uint8_t)uVar7;
        memcpy(workdata.work, base_work->equihash_data, 0x8c);
        bm1740_makeup_work(&workdata.header_55, len);
        pthread_mutex_lock((pthread_mutex_t *)&work_queue_mutex);
        if (*(work **)(iVar4 + 0x76) != (work *)0x0) {
            _free_work(*(work **)(iVar4 + 0x76));
            *(undefined4 *)(iVar4 + 0x76) = 0;
        }
        pwVar2 = copy_work_noffset(base_work, 0);
        *(work **)(iVar4 + 0x76) = pwVar2;
        pthread_mutex_unlock((pthread_mutex_t *)&work_queue_mutex);
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000,
                     "ChainID[%d] Wirte Work. workid=%d, jobid=%s", uVar6,
                     uVar7, base_work->job_id);
            _applog(7, tmp42, false);
        }
        uart_send(which_uart, &workdata.header_55, 0x92);
        gBegin_get_nonce = true;
        cgtime(&tv_send_job);
        cgsleep_us(500);
        _free_work(base_work);
    } while (true);
}

/* WARNING: Unknown calling convention */

uint uart_receive(uchar which_uart, uchar *buf, uint buf_length)

{
    uint uVar1;
    pthread_mutex_t *__mutex;

    __mutex = (pthread_mutex_t *)(uart_receive_mutex + which_uart);
    pthread_mutex_lock(__mutex);
    uVar1 = check_how_many_uart_data_in_fpga(which_uart);
    if (buf_length <= uVar1) {
        uVar1 = read_uart_data_in_fpga(which_uart, buf, buf_length);
        pthread_mutex_unlock(__mutex);
        return uVar1;
    }
    if (uVar1 == 0) {
        pthread_mutex_unlock(__mutex);
        return 0;
    }
    uVar1 = read_uart_data_in_fpga(which_uart, buf, uVar1);
    pthread_mutex_unlock(__mutex);
    return uVar1;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

void i2c_write(uint config_data)

{
    uint config_data_00;
    int iVar1;
    uint data;

    iVar1 = 0x16;
    do {
        if ((int)axi_fpga_addr[0xc] < 0) {
            axi_fpga_addr[0xc] = config_data;
            return;
        }
        config_data_00 = usleep(5000);
        iVar1 = iVar1 + -1;
    } while (iVar1 != 0);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return;
    }
    i2c_write(config_data_00);
    return;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

uchar i2c_read(uint config_data)

{
    uchar uVar1;
    uint config_data_00;
    int iVar2;
    uint data;

    iVar2 = 0x16;
    i2c_write(config_data | 0x2000000);
    do {
        usleep(5000);
        config_data_00 = axi_fpga_addr[0xc];
        if ((int)config_data_00 < 0) {
            return (uchar)config_data_00;
        }
        iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return 0xff;
    }
    uVar1 = i2c_read(config_data_00);
    return uVar1;
}

/* WARNING: Unknown calling convention */

void write_pic(uchar data)

{
    i2c_write((uint)data | i2c_slave_addr << 0x10 | 0xa00000);
    return;
}

/* WARNING: Unknown calling convention */

uchar read_pic(void)

{
    uchar uVar1;

    uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    return uVar1;
}

/* WARNING: Unknown calling convention */

int write_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t *data, int len)

{
    uchar uVar1;
    uint8_t uVar2;
    uint uVar3;
    uint uVar4;
    byte *pbVar5;
    uint8_t uVar6;
    uchar *puVar7;
    uchar *puVar8;
    uint8_t read_back_data[16];
    uint8_t send_data[16];
    char tmp42[4096];

    send_data[5] = reg;
    uVar3 = 0;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[4] = i2c_dev_addr << 1;
    send_data[3] = '2';
    send_data[2] = (uint8_t)(len + 6U);
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    read_back_data[6] = '\0';
    read_back_data[7] = '\0';
    send_data[10] = '\0';
    send_data[0xb] = '\0';
    send_data[0xc] = '\0';
    send_data[0xd] = '\0';
    send_data[0xe] = '\0';
    send_data[0xf] = '\0';
    send_data[6] = '\0';
    send_data[7] = '\0';
    send_data[8] = '\0';
    send_data[9] = '\0';
    read_back_data[8] = '\0';
    read_back_data[9] = '\0';
    read_back_data[10] = '\0';
    read_back_data[0xb] = '\0';
    read_back_data[0xc] = '\0';
    read_back_data[0xd] = '\0';
    read_back_data[0xe] = '\0';
    read_back_data[0xf] = '\0';
    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    if (0 < len) {
        do {
            uVar4 = uVar3 + 1 & 0xff;
            send_data[uVar3 + 6] = data[uVar3];
            uVar3 = uVar4;
        } while ((int)uVar4 < len);
    }
    if (len + 3 < 0 == SCARRY4(len, 3)) {
        pbVar5 = send_data + 1;
        uVar3 = 0;
        do {
            pbVar5 = pbVar5 + 1;
            uVar4 = uVar3 + *pbVar5;
            uVar3 = uVar4 & 0xffff;
        } while (send_data + len + 5 != pbVar5);
        uVar2 = (uint8_t)(uVar3 >> 8);
        uVar6 = (uint8_t)uVar4;
    } else {
        uVar6 = '\0';
        uVar2 = '\0';
    }
    send_data[len + 6] = uVar2;
    uVar3 = 0;
    send_data[len + 7] = uVar6;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    do {
        pbVar5 = send_data + uVar3;
        uVar3 = uVar3 + 1 & 0xff;
        i2c_write((uint)*pbVar5 | i2c_slave_addr << 0x10 | 0xa00000);
    } while (uVar3 <= (len + 6U & 0xff) + 1);
    usleep(200000);
    read_back_data[0] = '\0';
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    read_back_data[6] = '\0';
    read_back_data[7] = '\0';
    read_back_data[8] = '\0';
    read_back_data[9] = '\0';
    read_back_data[10] = '\0';
    read_back_data[0xb] = '\0';
    read_back_data[0xc] = '\0';
    read_back_data[0xd] = '\0';
    read_back_data[0xe] = '\0';
    read_back_data[0xf] = '\0';
    puVar7 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar8 = puVar7 + 1;
        *puVar7 = uVar1;
        puVar7 = puVar8;
    } while (read_back_data + 5 != puVar8);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar3 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if ((uVar3 == 0x32) && (read_back_data[2] == '\x01')) {
        return 0;
    }
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] "
                 "= 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = "
                 "0x%02x\n\n",
                 "write_dc_dc", read_back_data._0_4_ & 0xff, uVar3,
                 (uint)read_back_data[2], (uint)read_back_data._0_4_ >> 0x18);
        _applog(5, tmp42, false);
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int read_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t *value, int len)

{
    uchar uVar1;
    int iVar2;
    uint uVar3;
    byte *pbVar4;
    uint unaff_r10;
    uint8_t send_data[9];
    uint8_t read_back_data[16];
    char tmp42[4096];

    send_data[4] = i2c_dev_addr << 1 | 1;
    iVar2 = send_data[4] + 0x39 + (uint)reg + (len & 0xffU);
    send_data[8] = (uint8_t)iVar2;
    send_data[6] = (uint8_t)len;
    send_data[7] = (uint8_t)((uint)iVar2 >> 8);
    pbVar4 = send_data;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\a';
    send_data[3] = '2';
    send_data[5] = reg;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar3 = 0x55;
    while (i2c_write(uVar3 | 0xa00000 | i2c_slave_addr << 0x10),
           pbVar4 != send_data + 8) {
        pbVar4 = pbVar4 + 1;
        uVar3 = (uint)*pbVar4;
    }
    uVar3 = 0;
    cgsleep_ms(200);
    iVar2 = len + 4;
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    read_back_data[6] = '\0';
    read_back_data[7] = '\0';
    if (iVar2 >= 0) {
        unaff_r10 = 0;
    }
    read_back_data[0] = '\0';
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    read_back_data[8] = '\0';
    read_back_data[9] = '\0';
    read_back_data[10] = '\0';
    read_back_data[0xb] = '\0';
    read_back_data[0xc] = '\0';
    read_back_data[0xd] = '\0';
    read_back_data[0xe] = '\0';
    read_back_data[0xf] = '\0';
    if (iVar2 < 0) {
        pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    } else {
        do {
            uVar3 = uVar3 + 1 & 0xff;
            uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
            read_back_data[unaff_r10] = uVar1;
            unaff_r10 = uVar3;
        } while ((int)uVar3 <= iVar2);
        uVar3 = (uint)read_back_data._0_4_ >> 8 & 0xff;
        pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
        if ((uVar3 == 0x32) && (read_back_data[2] == '\x01')) {
            if (0 < len) {
                uVar3 = 0;
                do {
                    value[uVar3] = read_back_data[uVar3 + 3];
                    uVar3 = uVar3 + 1 & 0xff;
                } while ((int)uVar3 < len);
            }
            return 0;
        }
    }
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(
            tmp42, 0x1000,
            "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
            "0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
            "read_dc_dc", read_back_data._0_4_ & 0xff, uVar3,
            (uint)read_back_data._0_4_ >> 0x10 & 0xff,
            (uint)read_back_data._0_4_ >> 0x18);
        _applog(5, tmp42, false);
    }
    return -1;
}

/* WARNING: Removing unreachable block (ram,0x00035a46) */
/* WARNING: Unknown calling convention */

uchar CRC5(uchar *ptr, uchar len)

{
    byte bVar1;
    byte bVar2;
    byte bVar3;
    char cVar4;
    byte bVar5;
    uint uVar6;
    uint uVar7;
    byte bVar8;
    byte bVar9;
    byte bVar10;
    byte bVar11;

    if (len == '\0') {
        return '\x1f';
    }
    bVar8 = 0;
    cVar4 = '\0';
    uVar7 = 0x80;
    bVar1 = 1;
    bVar10 = 1;
    bVar2 = 1;
    bVar11 = 1;
    bVar3 = 1;
    do {
        bVar5 = bVar3;
        bVar3 = bVar11;
        bVar11 = bVar2;
        bVar9 = bVar10;
        bVar10 = bVar1;
        cVar4 = cVar4 + '\x01';
        bVar8 = bVar8 + 1;
        uVar6 = *ptr & uVar7;
        uVar7 = uVar7 >> 1;
        if (uVar6 != 0) {
            bVar5 = bVar5 ^ 1;
        }
        if (cVar4 == '\b') {
            ptr = ptr + 1;
            cVar4 = '\0';
            uVar7 = 0x80;
        }
        bVar1 = bVar5;
        bVar2 = bVar5 ^ bVar9;
    } while (bVar8 < len);
    if (bVar3 != 0) {
        bVar3 = 0x10;
    }
    if (bVar11 != 0) {
        bVar3 = bVar3 | 8;
    }
    if (bVar5 != bVar9) {
        bVar3 = bVar3 | 4;
    }
    if (bVar10 != 0) {
        bVar3 = bVar3 | 2;
    }
    if (bVar5 != 0) {
        bVar3 = bVar3 | 1;
    }
    return bVar3;
}

int bm1740_makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all,
                                 uint8_t chip_addr, uint8_t regaddr)

{
    byte bVar1;
    get_status_cmd_t get_status_cmd;
    undefined1 uStack_19;

    stack0xffffffe4 = CONCAT13(uStack_19, CONCAT12(get_status_cmd._6_1_,
                                                   CONCAT11(chip_addr, all))) &
                      0xff1fffff;
    get_status_cmd._2_1_ = (byte)((str_len & 1) << 4) | 0x42;
    get_status_cmd.header_55 = 'U';
    get_status_cmd.header_aa = 0xaa;
    get_status_cmd.length = '\x05';
    bVar1 = CRC5(&get_status_cmd.field_0x2, ' ');
    str[0] = get_status_cmd.header_55;
    str[1] = get_status_cmd.header_aa;
    str[2] = get_status_cmd._2_1_;
    str[3] = get_status_cmd.length;
    str[4] = get_status_cmd.chip_addr;
    str[5] = get_status_cmd.regaddr;
    str[6] = get_status_cmd._6_1_ & 0xe0 | bVar1 & 0x1f;
    return 7;
}

int bm1740_makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all,
                                 uint8_t chip_addr, uint8_t regaddr)

{
    int iVar1;

    iVar1 =
        bm1740_makeup_get_status_cmd(str, 1, '\0', (uint8_t)str_len, regaddr);
    return iVar1;
}

int bm1740_makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len)

{
    byte bVar1;
    chain_inactive_cmd_t chain_inactive_cmd;

    chain_inactive_cmd._4_1_ = 0;
    chain_inactive_cmd._0_1_ = 0x53;
    chain_inactive_cmd.length = '\x05';
    chain_inactive_cmd.reserve1 = '\0';
    chain_inactive_cmd.reserve2 = '\0';
    bVar1 = CRC5((uchar *)&chain_inactive_cmd, ' ');
    str[0] = 'U';
    str[1] = 0xaa;
    str[2] = chain_inactive_cmd._0_1_;
    str[3] = chain_inactive_cmd.length;
    str[4] = chain_inactive_cmd.reserve1;
    str[5] = chain_inactive_cmd.reserve2;
    str[6] = chain_inactive_cmd._4_1_ & 0xe0 | bVar1 & 0x1f;
    return 7;
}

int bm1740_makeup_set_config_cmd(uint8_t *str, uint32_t str_len, uint8_t all,
                                 uint8_t chip_addr, uint8_t regaddr,
                                 uint32_t regdata)

{
    byte bVar1;
    uint3 in_stack_00000001;
    set_config_cmd_t set_config_cmd;

    set_config_cmd._10_1_ = set_config_cmd._10_1_ & 0x1f;
    set_config_cmd.regdata._2_2_ = (ushort)((uint)(_regaddr << 0x18) >> 0x10) |
                                   (ushort)in_stack_00000001 & 0xff;
    set_config_cmd.regdata._0_2_ =
        (ushort)((((in_stack_00000001 & 0xff00) << 8) >> 0x10) << 8) |
        (ushort)(byte)(in_stack_00000001 >> 0x10);
    set_config_cmd.length = '\0';
    set_config_cmd._2_1_ = (byte)((str_len & 1) << 4) | 0x41;
    set_config_cmd.header_55 = 'U';
    set_config_cmd.header_aa = 0xaa;
    set_config_cmd.length = '\t';
    set_config_cmd.chip_addr = all;
    set_config_cmd.regaddr = chip_addr;
    bVar1 = CRC5(&set_config_cmd.field_0x2, '@');
    str[0] = set_config_cmd.header_55;
    str[1] = set_config_cmd.header_aa;
    str[2] = set_config_cmd._2_1_;
    str[3] = set_config_cmd.length;
    *(uint *)(str + 4) =
        CONCAT22(set_config_cmd.regdata._0_2_,
                 CONCAT11(set_config_cmd.regaddr, set_config_cmd.chip_addr));
    *(undefined2 *)(str + 8) = set_config_cmd.regdata._2_2_;
    str[10] = set_config_cmd._10_1_ & 0xe0 | bVar1 & 0x1f;
    return 0xb;
}

int bm1740_makeup_set_address_cmd(uint8_t *str, uint32_t str_len,
                                  uint8_t chip_addr)

{
    byte bVar1;
    set_address_cmd_t set_address_cmd;

    set_address_cmd._2_2_ = (ushort)str_len & 0xff;
    set_address_cmd._4_1_ = 0;
    set_address_cmd._0_2_ = 0x540;
    bVar1 = CRC5((uchar *)&set_address_cmd, ' ');
    str[0] = 'U';
    str[1] = 0xaa;
    str[2] = set_address_cmd._0_1_;
    str[3] = set_address_cmd.length;
    str[4] = set_address_cmd.chip_addr;
    str[5] = set_address_cmd.reserve1;
    str[6] = set_address_cmd._4_1_ & 0xe0 | bVar1 & 0x1f;
    return 7;
}

ushort CRC16(uchar *buffer, int len)

{
    byte *pbVar1;
    uint uVar3;
    uint uVar4;
    byte *pbVar2;

    if (len != 0) {
        uVar3 = 0xffff;
        pbVar2 = buffer;
        do {
            pbVar1 = pbVar2 + 1;
            uVar4 =
                (uint)crc_itu_t_table[(uint)*pbVar2 ^ uVar3 >> 8] ^ uVar3 << 8;
            uVar3 = uVar4 & 0xffff;
            pbVar2 = pbVar1;
        } while (pbVar1 != buffer + len);
        return (ushort)uVar4;
    }
    return 0xffff;
}

uint16_t crc_itu_t(uint16_t crc, uint8_t *buffer, int len)

{
    uint uVar1;
    uint uVar2;
    byte *pbVar3;
    byte *pbVar4;

    uVar2 = (uint)crc;
    if (len != 0) {
        pbVar4 = buffer;
        do {
            pbVar3 = pbVar4 + 1;
            uVar1 =
                (uint)crc_itu_t_table[(uint)*pbVar4 ^ uVar2 >> 8] ^ uVar2 << 8;
            uVar2 = uVar1 & 0xffff;
            pbVar4 = pbVar3;
        } while (pbVar3 != buffer + len);
        return (uint16_t)uVar1;
    }
    return crc;
}

/* WARNING: Unknown calling convention */

int set_PIC16F1704_flash_pointer_new(uchar flash_addr_h, uchar flash_addr_l)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[8];
    char tmp42[4096];

    iVar3 = flash_addr_l + 7 + (uint)flash_addr_h;
    send_data[7] = (uchar)iVar3;
    send_data[6] = (uchar)((uint)iVar3 >> 8);
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x06';
    send_data[3] = '\x01';
    pbVar5 = send_data;
    send_data[4] = flash_addr_h;
    send_data[5] = flash_addr_l;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (pbVar5 = pbVar5 + 1,
           i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           (byte *)tmp42 != pbVar5) {
        uVar4 = (uint)*pbVar5;
    }
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    if (bVar2 == 1 && bVar1 == 1) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok",
                     "set_PIC16F1704_flash_pointer_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "set_PIC16F1704_flash_pointer_new", i2c_slave_addr,
                 (uint)bVar1, (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int send_data_to_PIC16F1704_new(uchar *buf)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    byte *pbVar4;
    byte *pbVar5;
    byte *pbVar6;
    uint uVar7;
    uint uVar8;
    byte bStack_1029;
    uchar send_data[22];
    char tmp42[4096];

    pbVar4 = buf + -1;
    uVar7 = 0x16;
    send_data[8] = '\0';
    send_data[9] = '\0';
    send_data[10] = '\0';
    send_data[0xb] = '\0';
    send_data[0xc] = '\0';
    send_data[0xd] = '\0';
    send_data[0xe] = '\0';
    send_data[0xf] = '\0';
    send_data[0x10] = '\0';
    send_data[0x11] = '\0';
    send_data[0x12] = '\0';
    send_data[0x13] = '\0';
    send_data[4] = '\0';
    send_data[5] = '\0';
    send_data[6] = '\0';
    send_data[7] = '\0';
    pbVar5 = pbVar4;
    do {
        pbVar5 = pbVar5 + 1;
        uVar8 = uVar7 + *pbVar5;
        uVar7 = uVar8 & 0xffff;
    } while (buf + 0xf != pbVar5);
    send_data[0x15] = (uchar)uVar8;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x14';
    send_data[3] = '\x02';
    pbVar5 = send_data + 4;
    do {
        pbVar4 = pbVar4 + 1;
        pbVar6 = pbVar5 + 1;
        *pbVar5 = *pbVar4;
        pbVar5 = pbVar6;
    } while (send_data + 0x14 != pbVar6);
    send_data[0x14] = (uchar)(uVar7 >> 8);
    pbVar5 = &bStack_1029;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    do {
        pbVar5 = pbVar5 + 1;
        i2c_write((uint)*pbVar5 | i2c_slave_addr << 0x10 | 0xa00000U);
    } while (send_data + 0x15 != pbVar5);
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    if (bVar2 == 1 && bVar1 == 2) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "%s ok", "send_data_to_PIC16F1704_new");
            _applog(5, tmp42, false);
            return 1;
        }
        iVar3 = 1;
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "send_data_to_PIC16F1704_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int read_PIC16F1704_flash_pointer_new(uchar *flash_addr_h, uchar *flash_addr_l)

{
    uchar uVar1;
    uint uVar2;
    uint uVar3;
    byte *pbVar4;
    uchar *puVar5;
    uchar *puVar6;
    uchar read_back_data[6];
    uchar auStack_1022[2];
    uchar send_data[6];
    char tmp42[4096];

    send_data[4] = '\0';
    send_data[5] = '\f';
    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    pbVar4 = send_data;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\b';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = 0x55;
    while (i2c_write(uVar2 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar4) {
        pbVar4 = pbVar4 + 1;
        uVar2 = (uint)*pbVar4;
    }
    usleep(100000);
    puVar5 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar6 = puVar5 + 1;
        *puVar5 = uVar1;
        puVar5 = puVar6;
    } while (auStack_1022 != puVar6);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if ((uVar2 == 8) && (read_back_data[0] == '\x06')) {
        uVar2 = (uint)read_back_data[3];
        uVar3 = read_back_data[2] + uVar2 + 0xe;
        if (((uint)read_back_data[4] == uVar3 >> 8) &&
            ((uint)read_back_data[5] == (uVar3 & 0xff))) {
            *flash_addr_h = read_back_data[2];
            *flash_addr_l = read_back_data[3];
            if ((use_syslog == false) &&
                ((opt_log_output == false && (opt_log_level < 5)))) {
                return 1;
            }
            snprintf(tmp42, 0x1000,
                     "%s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x",
                     "read_PIC16F1704_flash_pointer_new", (uint)*flash_addr_h,
                     uVar2);
            _applog(5, tmp42, false);
            return 1;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return 0;
        }
        snprintf(tmp42, 0x1000,
                 "%s failed!!! read_back_data[0] = 0x%x, read_back_data[1] = "
                 "0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
                 "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n\n",
                 "read_PIC16F1704_flash_pointer_new", 6, 8,
                 (uint)read_back_data[2], uVar2, (uint)read_back_data[4],
                 (uint)read_back_data[5]);
    } else {
        if ((use_syslog == false) &&
            ((opt_log_output == false && (opt_log_level < 3)))) {
            return 0;
        }
        snprintf(
            tmp42, 0x1000,
            "%s chain %d failed! read_back_data[0] = 0x%x, read_back_data[1] = "
            "0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
            "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n\n",
            "read_PIC16F1704_flash_pointer_new", i2c_slave_addr,
            read_back_data._0_4_ & 0xff, uVar2, (uint)read_back_data[2],
            (uint)read_back_data[3], (uint)read_back_data[4],
            (uint)read_back_data[5]);
    }
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

int read_PIC16F1704_flash_data_new(uchar *buf)

{
    uchar uVar1;
    ushort uVar2;
    char *__format;
    byte *pbVar3;
    ushort uVar4;
    uint uVar5;
    uchar *puVar6;
    uchar send_data[6];
    uchar uStack_102d;
    uchar read_back_data[20];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    pbVar3 = send_data;
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    read_back_data[6] = '\0';
    read_back_data[7] = '\0';
    read_back_data[8] = '\0';
    read_back_data[9] = '\0';
    read_back_data[10] = '\0';
    read_back_data[0xb] = '\0';
    read_back_data[0xc] = '\0';
    read_back_data[0xd] = '\0';
    read_back_data[0xe] = '\0';
    read_back_data[0xf] = '\0';
    read_back_data[0x10] = '\0';
    read_back_data[0x11] = '\0';
    read_back_data[0x12] = '\0';
    read_back_data[0x13] = '\0';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x03';
    send_data[4] = '\0';
    send_data[5] = '\a';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar5 = 0x55;
    while (i2c_write(uVar5 | 0xa00000 | i2c_slave_addr << 0x10),
           pbVar3 != send_data + 5) {
        pbVar3 = pbVar3 + 1;
        uVar5 = (uint)*pbVar3;
    }
    puVar6 = &uStack_102d;
    usleep(300000);
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar6 = puVar6 + 1;
        *puVar6 = uVar1;
    } while (puVar6 != read_back_data + 0x13);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar5 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        usleep(100000);
    } else {
        snprintf(
            tmp42, 0x1000,
            "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
            "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
            "\t\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, "
            "read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, "
            "\t\tread_back_data[8] = 0x%x, read_back_data[9] = 0x%x, "
            "read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, "
            "\t\tread_back_data[12] = 0x%x, read_back_data[13] = 0x%x, "
            "read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, "
            "\t\tread_back_data[16] = 0x%x, read_back_data[17] = 0x%x, "
            "read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
            "read_PIC16F1704_flash_data_new", read_back_data._0_4_ & 0xff,
            uVar5, (uint)read_back_data._0_4_ >> 0x10 & 0xff,
            (uint)read_back_data._0_4_ >> 0x18, read_back_data._4_4_ & 0xff,
            (uint)read_back_data._4_4_ >> 8 & 0xff,
            (uint)read_back_data._4_4_ >> 0x10 & 0xff,
            (uint)read_back_data._4_4_ >> 0x18, read_back_data._8_4_ & 0xff,
            (uint)read_back_data._8_4_ >> 8 & 0xff,
            (uint)read_back_data._8_4_ >> 0x10 & 0xff,
            (uint)read_back_data._8_4_ >> 0x18, read_back_data._12_4_ & 0xff,
            (uint)read_back_data._12_4_ >> 8 & 0xff,
            (uint)read_back_data._12_4_ >> 0x10 & 0xff,
            (uint)read_back_data._12_4_ >> 0x18, read_back_data._16_4_ & 0xff,
            (uint)read_back_data._16_4_ >> 8 & 0xff,
            (uint)read_back_data._16_4_ >> 0x10 & 0xff,
            (uint)read_back_data._16_4_ >> 0x18);
        _applog(5, tmp42, false);
        usleep(100000);
    }
    if ((uVar5 == 3) && (read_back_data[0] == '\x14')) {
        uVar2 = (ushort)read_back_data[2];
        uVar4 = (ushort)read_back_data[0x11] + (ushort)read_back_data[0x10] +
                (ushort)read_back_data[0xf] + (ushort)read_back_data[0xe] +
                (ushort)read_back_data[0xd] + (ushort)read_back_data[0xc] +
                (ushort)read_back_data[0xb] + (ushort)read_back_data[10] +
                (ushort)read_back_data[9] + (ushort)read_back_data[8] +
                (ushort)read_back_data[7] + (ushort)read_back_data[6] +
                read_back_data[3] + uVar2 + 0x17 + (ushort)read_back_data[4] +
                (ushort)read_back_data[5];
        uVar5 = (uint)uVar4;
        if (((ushort)read_back_data[0x12] == uVar4 >> 8) &&
            (read_back_data[0x13] == (uchar)uVar4)) {
            puVar6 = buf + -1;
            pbVar3 = read_back_data + 3;
            while (true) {
                puVar6 = puVar6 + 1;
                *puVar6 = (uchar)uVar2;
                if (read_back_data + 0x12 == pbVar3)
                    break;
                uVar2 = (ushort)*pbVar3;
                pbVar3 = pbVar3 + 1;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 5)) {
                return 1;
            }
            snprintf(tmp42, 0x1000, "%s ok", "read_PIC16F1704_flash_data_new");
            _applog(5, tmp42, false);
            return 1;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return 0;
        }
        __format = "%s failed! crc = 0x%04x\n\n";
    } else {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return 0;
        }
        __format = "%s chain %d failed!";
        uVar5 = i2c_slave_addr;
    }
    snprintf(tmp42, 0x1000, __format, "read_PIC16F1704_flash_data_new", uVar5);
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

int erase_PIC16F1704_flash_new(void)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[6];
    char tmp42[4096];

    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x04';
    send_data[4] = '\0';
    send_data[5] = '\b';
    pbVar5 = send_data;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar5) {
        pbVar5 = pbVar5 + 1;
        uVar4 = (uint)*pbVar5;
    }
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    if (bVar2 == 1 && bVar1 == 4) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok", "erase_PIC16F1704_flash_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "erase_PIC16F1704_flash_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int write_data_into_PIC16F1704_flash_new(void)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[6];
    char tmp42[4096];

    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x05';
    send_data[4] = '\0';
    send_data[5] = '\t';
    pbVar5 = send_data;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar5) {
        pbVar5 = pbVar5 + 1;
        uVar4 = (uint)*pbVar5;
    }
    usleep(200000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    if (bVar2 == 1 && bVar1 == 5) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok\n\n",
                     "write_data_into_PIC16F1704_flash_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "write_data_into_PIC16F1704_flash_new", i2c_slave_addr,
                 (uint)bVar1, (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int jump_from_loader_to_app_PIC16F1704_new(void)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[6];
    char tmp42[4096];

    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x06';
    send_data[4] = '\0';
    send_data[5] = '\n';
    pbVar5 = send_data;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar5) {
        pbVar5 = pbVar5 + 1;
        uVar4 = (uint)*pbVar5;
    }
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(300000);
    if (bVar2 == 1 && bVar1 == 6) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok",
                     "jump_from_loader_to_app_PIC16F1704_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x",
                 "jump_from_loader_to_app_PIC16F1704_new", i2c_slave_addr,
                 (uint)bVar1, (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int reset_PIC16F1704_pic_new(void)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[6];
    char tmp42[4096];

    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\a';
    send_data[4] = '\0';
    send_data[5] = '\v';
    pbVar5 = send_data;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar5) {
        pbVar5 = pbVar5 + 1;
        uVar4 = (uint)*pbVar5;
    }
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(1000000);
    if (bVar2 == 1 && bVar1 == 7) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok", "reset_PIC16F1704_pic_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "reset_PIC16F1704_pic_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int PIC16F1704_i2c_forward_send(uint8_t dev_addr, int rw_flag, uint8_t reg_addr,
                                int len, uint8_t *data)

{
    byte bVar1;
    byte *pbVar2;
    int iVar3;
    byte *pbVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    int iVar8;
    uint8_t local_106c;
    uint local_1064;
    uint8_t recv_data[12];
    uint8_t send_data[32];
    char tmp42[4096];

    bVar1 = (byte)rw_flag;
    memset(send_data + 2, 0, 0x1e);
    send_data[5] = reg_addr;
    send_data[4] = bVar1 | dev_addr << 1;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[3] = '&';
    recv_data[4] = '\0';
    recv_data[5] = '\0';
    recv_data[6] = '\0';
    recv_data[7] = '\0';
    recv_data[8] = '\0';
    recv_data[9] = '\0';
    recv_data[10] = '\0';
    recv_data[0xb] = '\0';
    recv_data[0] = '\0';
    recv_data[1] = '\0';
    recv_data[2] = '\0';
    recv_data[3] = '\0';
    if (rw_flag == 0) {
        iVar8 = len + 4;
        memcpy(send_data + 6, data, len);
        local_1064 = len + 6;
        uVar5 = local_1064 & 0xff;
        iVar6 = len + 7;
        send_data[2] = (uint8_t)local_1064;
        if (0 < iVar8)
            goto LAB_000368d4;
        send_data[local_1064] = bVar1;
        send_data[iVar6] = bVar1;
        pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
        if (iVar6 < 0) {
            usleep(200000);
            goto LAB_00036a6a;
        }
        uVar7 = 0;
    LAB_00036902:
        iVar8 = 0;
        pbVar2 = send_data;
        do {
            iVar3 = iVar8 + 1;
            bVar1 = *pbVar2;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "write pic i2c[%d] %02x\n", iVar8,
                         (uint)bVar1);
                _applog(5, tmp42, false);
            }
            i2c_write((uint)bVar1 | i2c_slave_addr << 0x10 | 0xa00000);
            iVar8 = iVar3;
            pbVar2 = pbVar2 + 1;
        } while (iVar3 != iVar6 + 1);
    } else {
        local_106c = (uint8_t)len;
        iVar6 = 8;
        uVar5 = 7;
        iVar8 = 5;
        local_1064 = 7;
        send_data[6] = local_106c;
        send_data[2] = '\a';
    LAB_000368d4:
        iVar3 = 0;
        pbVar2 = send_data + 2;
        uVar7 = 0;
        while (true) {
            iVar3 = iVar3 + 1;
            uVar7 = uVar7 + uVar5 & 0xffff;
            if (iVar8 <= iVar3)
                break;
            pbVar2 = pbVar2 + 1;
            uVar5 = (uint)*pbVar2;
        }
        send_data[local_1064] = (byte)(uVar7 >> 8);
        send_data[iVar6] = (byte)uVar7;
        pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
        if (-1 < iVar6)
            goto LAB_00036902;
    }
    usleep(200000);
    if (rw_flag != 1) {
    LAB_00036a6a:
        pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
        return 0;
    }
    if (len + 4 < 0 == SCARRY4(len, 4)) {
        iVar6 = 0;
        pbVar2 = recv_data;
        do {
            bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
            iVar8 = iVar6 + 1;
            *pbVar2 = bVar1;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "read pic i2c[%d] %02x\n", iVar6,
                         (uint)bVar1);
                _applog(5, tmp42, false);
            }
            iVar6 = iVar8;
            pbVar2 = pbVar2 + 1;
        } while (iVar8 != len + 5);
    }
    if (len + 2 < 0 == SCARRY4(len, 2)) {
        pbVar2 = recv_data;
        do {
            pbVar4 = pbVar2 + 1;
            uVar7 = uVar7 + *pbVar2 & 0xffff;
            pbVar2 = pbVar4;
        } while (pbVar4 != recv_data + len + 3);
    }
    if (*(ushort *)(recv_data + 3 + len) == uVar7) {
        if ((((recv_data._0_4_ & 0xff) == local_1064) &&
             (recv_data[1] == '&')) &&
            (recv_data[2] == '\x01')) {
            memcpy(data, recv_data + 3, len);
            goto LAB_00036a6a;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "pic read failed %d %d %d\n", (uint)*data,
                     (uint)data[1], (uint)data[2]);
            _applog(5, tmp42, false);
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "crc failed 0x%x\n", uVar7);
        _applog(5, tmp42, false);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    return -1;
}

/* WARNING: Unknown calling convention */

int ISL_get_voltage(uint8_t i2c_dev_addr, uint16_t *voltage)

{
    uint8_t vol[2];

    vol[0] = '\0';
    vol[1] = '\0';
    read_dc_dc(i2c_dev_addr, '!', vol, 2);
    *voltage = (uint16_t)vol;
    return 0;
}

/* WARNING: Unknown calling convention */

void every_asic_get_isl_voltage(int which_chain)

{
    _Bool _Var1;
    int iVar2;
    ushort *puVar3;
    uint8_t *puVar4;
    ushort vol;
    char tmp42[4096];

    puVar3 = (ushort *)((int)&i2c_mutex + which_chain * 6 + 0x16);
    iVar2 = 0;
    puVar4 = isl_dev_addr;
    do {
        vol = 0;
        ISL_get_voltage(*puVar4, &vol);
        _Var1 = use_syslog;
        puVar3 = puVar3 + 1;
        *puVar3 = vol;
        if (((_Var1 != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "chain %d asic = %d vol=%u\n", which_chain,
                     iVar2, (uint)vol);
            _applog(5, tmp42, false);
        }
        iVar2 = iVar2 + 1;
        puVar4 = puVar4 + 1;
    } while (iVar2 != 3);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_get_isl_voltage(void)

{
    int which_chain;
    uint8_t *puVar1;

    which_chain = 0;
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = which_chain;
            every_asic_get_isl_voltage(which_chain);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        which_chain = which_chain + 1;
        puVar1 = puVar1 + 1;
    } while (which_chain != 4);
    return;
}

/* WARNING: Unknown calling convention */

int ISL_set_i2c_data(uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len)

{
    uint uVar1;
    int iVar2;
    uint8_t *puVar3;
    int iVar4;
    byte *pbVar5;
    char tmp42[4096];

    iVar2 = 0;
    uVar1 = (uint)i2c_reg_addr;
    puVar3 = dev.chain_exist;
    do {
        if (*puVar3 == '\x01') {
            iVar4 = 0;
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            pbVar5 = isl_dev_addr;
            i2c_slave_addr = iVar2;
            do {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    snprintf(tmp42, 0x1000,
                             "chain%d asic%d, set data slave:%02x addr:%02x "
                             "%02x %02x, len=%d\n",
                             iVar2, iVar4, (uint)*pbVar5, (uint)i2c_reg_addr,
                             (uint)*i2c_reg_data, (uint)i2c_reg_data[1], len);
                    _applog(5, tmp42, false);
                }
                write_dc_dc(*pbVar5, i2c_reg_addr, i2c_reg_data, len);
                iVar4 = iVar4 + 1;
                cgsleep_ms(200);
                pbVar5 = pbVar5 + 1;
            } while (iVar4 != 3);
            uVar1 = pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar2 = iVar2 + 1;
        puVar3 = puVar3 + 1;
    } while (iVar2 != 4);
    return uVar1;
}

/* WARNING: Unknown calling convention */

int ISL_get_i2c_data(uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len)

{
    uint uVar1;
    uint uVar2;
    int iVar3;
    uint8_t *puVar4;
    int iVar5;
    char tmp42[4096];

    uVar1 = (uint)i2c_reg_addr;
    iVar3 = 0;
    uVar2 = uVar1;
    puVar4 = dev.chain_exist;
    do {
        if (*puVar4 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            iVar5 = 0;
            i2c_slave_addr = iVar3;
            do {
                read_dc_dc(isl_dev_addr[iVar5], i2c_reg_addr, i2c_reg_data,
                           len);
                if (len == 1) {
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        snprintf(tmp42, 0x1000,
                                 "chain%d asic%d, slave:%02x, addr:%02x %02x\n",
                                 iVar3, iVar5, (uint)isl_dev_addr[iVar5], uVar1,
                                 (uint)*i2c_reg_data);
                        _applog(5, tmp42, false);
                    }
                } else if (((use_syslog != false) ||
                            (opt_log_output != false)) ||
                           (4 < opt_log_level)) {
                    snprintf(
                        tmp42, 0x1000,
                        "chain%d asic%d, slave:%02x, addr:%02x %02x %02x\n",
                        iVar3, iVar5, (uint)isl_dev_addr[iVar5], uVar1,
                        (uint)*i2c_reg_data, (uint)i2c_reg_data[1]);
                    _applog(5, tmp42, false);
                }
                iVar5 = iVar5 + 1;
                cgsleep_ms(200);
            } while (iVar5 != 3);
            uVar2 = pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar3 = iVar3 + 1;
        puVar4 = puVar4 + 1;
    } while (iVar3 != 4);
    return uVar2;
}

/* WARNING: Unknown calling convention */

int XDPED_update_asics_vol(uint32_t vol)

{
    int iVar1;
    double dVar2;
    char reg_data[4];
    char tmp42[4096];

    reg_data[0] = '\0';
    reg_data[1] = '\0';
    reg_data[2] = '\0';
    reg_data[3] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "xdped set voltage to %d\n", vol);
        _applog(5, tmp42, false);
    }
    reg_data[0] = ' ';
    ISL_set_i2c_data('\0', (uint8_t *)reg_data, 1);
    sleep(1);
    reg_data[0] = '\0';
    reg_data[1] = '@';
    dVar2 = ((double)vol / 1000.0 - 0.25) / 0.005 + 1.0;
    reg_data[0] = (0.0 < dVar2) * (char)(longlong)dVar2;
    iVar1 = ISL_set_i2c_data('\x13', (uint8_t *)reg_data, 2);
    return iVar1;
}

/* WARNING: Unknown calling convention */

uint16_t ISL_set_voltage_dynamic(uint8_t i2c_dev_addr, uint16_t vol)

{
    char cVar1;
    uint uVar2;
    uint uVar3;
    uint local_1034;
    uint8_t which_page;
    uint8_t cmd[2];
    uint16_t r_voltage;
    char tmp42[4096];

    uVar2 = (uint)vol;
    if (uVar2 - 700 < 0x65) {
        local_1034 = uVar2 + 4;
    } else if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        uVar2 = 700;
        snprintf(tmp42, 0x1000,
                 "illegal voltage [%d, %d], set default voltage %d\n", 700, 800,
                 700);
        _applog(5, tmp42, false);
        local_1034 = 0x2c0;
        vol._0_1_ = 0xbc;
        vol._1_1_ = '\x02';
    } else {
        local_1034 = 0x2c0;
        vol._0_1_ = 0xbc;
        vol._1_1_ = '\x02';
        uVar2 = 700;
    }
    r_voltage = 0;
    cVar1 = '\x04';
    do {
        which_page = 0xff;
        write_dc_dc(i2c_dev_addr, '\0', &which_page, 1);
        cgsleep_ms(100);
        cmd = (uint8_t[2])vol;
        write_dc_dc(i2c_dev_addr, '!', cmd, 2);
        cgsleep_ms(200);
        ISL_get_voltage(i2c_dev_addr, &r_voltage);
        uVar3 = (uint)r_voltage;
        if ((uVar3 <= local_1034) && ((int)(uVar2 - 4) <= (int)uVar3)) {
            return r_voltage;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "set vol %d, get vol %d, set again!\n",
                     uVar2, uVar3);
            _applog(5, tmp42, false);
        }
        cgsleep_ms(200);
        cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    return r_voltage;
}

/* WARNING: Unknown calling convention */

uint16_t ISL_set_voltage(uint8_t i2c_dev_addr, uint16_t voltage)

{
    char cVar1;
    uint8_t which_page;
    uint8_t config;
    uint8_t oper;
    uint8_t cmd[2];
    uint16_t r_voltage;

    if (voltage - 700 < 0x65) {
        which_page = 0xff;
        write_dc_dc(i2c_dev_addr, '\0', &which_page, 1);
        config = '\x1a';
        write_dc_dc(i2c_dev_addr, '\x02', &config, 1);
        cgsleep_ms(100);
        oper = '@';
        cVar1 = '\x05';
        write_dc_dc(i2c_dev_addr, '\x01', &oper, 1);
        cgsleep_ms(100);
        cmd = (uint8_t[2])voltage;
        write_dc_dc(i2c_dev_addr, '!', cmd, 2);
        cgsleep_ms(100);
        oper = 0x80;
        write_dc_dc(i2c_dev_addr, '\x01', &oper, 1);
        cgsleep_ms(100);
        r_voltage = 0;
        cgsleep_ms(200);
        ISL_get_voltage(i2c_dev_addr, &r_voltage);
        while (r_voltage == 0) {
            cgsleep_ms(200);
            ISL_get_voltage(i2c_dev_addr, &r_voltage);
            cVar1 = cVar1 + -1;
            if (cVar1 == '\0') {
                return r_voltage;
            }
        }
    } else if (((use_syslog) || (opt_log_output)) ||
               (r_voltage = 0, 4 < opt_log_level)) {
        snprintf((char *)&r_voltage, 0x1000, "illegal voltage [%d, %d]\n", 700,
                 800);
        _applog(5, (char *)&r_voltage, false);
        r_voltage = 0;
    }
    return r_voltage;
}

/* WARNING: Unknown calling convention */

void every_asic_set_isl_voltage(int which_chain)

{
    ushort vol;
    uint16_t uVar1;
    int iVar2;
    byte *pbVar3;
    ushort *local_1030;
    char tmp42[4096];

    iVar2 = 0;
    local_1030 = (ushort *)((int)&i2c_mutex + which_chain * 6 + 0x16);
    pbVar3 = isl_dev_addr;
    do {
        local_1030 = local_1030 + 1;
        vol = *local_1030;
        uVar1 = ISL_set_voltage_dynamic(*pbVar3, vol);
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "chain%d asic%d addr %02x, %s set vol %d, get vol %d",
                     which_chain, iVar2, (uint)*pbVar3,
                     "every_asic_set_isl_voltage", (uint)vol, (uint)uVar1);
            _applog(5, tmp42, false);
        }
        iVar2 = iVar2 + 1;
        cgsleep_ms(200);
        pbVar3 = pbVar3 + 1;
    } while (iVar2 != 3);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_set_isl_voltage(void)

{
    int which_chain;
    uint8_t *puVar1;

    which_chain = 0;
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = which_chain;
            every_asic_set_isl_voltage(which_chain);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        which_chain = which_chain + 1;
        puVar1 = puVar1 + 1;
    } while (which_chain != 4);
    return;
}

/* WARNING: Unknown calling convention */

void update_asic_vol(int which_chain, int which_asic, int vol)

{
    ushort g_vol;

    pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
    g_vol = 0;
    i2c_slave_addr = which_chain;
    ISL_get_voltage(isl_dev_addr[which_asic], &g_vol);
    if ((vol + 5 < (int)(uint)g_vol) || ((int)(uint)g_vol < vol + -5)) {
        ISL_set_voltage_dynamic(isl_dev_addr[which_asic], (uint16_t)vol);
        cgsleep_ms(200);
    }
    pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
    return;
}

/* WARNING: Unknown calling convention */

void update_asics_vol(int vol)

{
    int which_chain;
    uint8_t *puVar1;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "isl set voltage to %d\n", vol);
        _applog(5, tmp42, false);
    }
    which_chain = 0;
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            update_asic_vol(which_chain, 0, vol);
            update_asic_vol(which_chain, 1, vol);
            update_asic_vol(which_chain, 2, vol);
        }
        which_chain = which_chain + 1;
        puVar1 = puVar1 + 1;
    } while (which_chain != 4);
    return;
}

/* WARNING: Unknown calling convention */

void update_asics_voltage(int vol)

{
    char reg_data[4];

    reg_data[0] = '\0';
    reg_data[1] = '\0';
    reg_data[2] = '\0';
    reg_data[3] = '\0';
    ISL_get_i2c_data('\0', (uint8_t *)reg_data, 1);
    if ((((uint)reg_data & 0xff) - 2 & 0xff) < 0xfd) {
        XDPED_update_asics_vol(vol);
        sleep(1);
        return;
    }
    update_asics_vol(vol);
    sleep(1);
    return;
}

/* WARNING: Unknown calling convention */

void init_vol_table(ushort vol)

{
    pthread_mutex_t *ppVar1;
    pthread_mutex_t *ppVar2;

    ppVar1 = (pthread_mutex_t *)isl_vol;
    do {
        *(ushort *)ppVar1 = vol;
        ppVar2 = (pthread_mutex_t *)((int)ppVar1 + 6);
        *(ushort *)((int)ppVar1 + 2) = vol;
        *(ushort *)((int)ppVar1 + 4) = vol;
        ppVar1 = ppVar2;
    } while (ppVar2 != &iic_mutex);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void dump_vol_table(void)

{
    int iVar1;
    int iVar2;
    ushort(*pauVar3)[3];
    char tmp42[4096];

    pauVar3 = isl_vol;
    iVar2 = 0;
    do {
        iVar1 = 0;
        do {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "chain %d asic %d vol %d\n", iVar2,
                         iVar1, (uint)(*pauVar3)[iVar1]);
                _applog(5, tmp42, false);
            }
            iVar1 = iVar1 + 1;
        } while (iVar1 != 3);
        iVar2 = iVar2 + 1;
        pauVar3 = pauVar3 + 1;
    } while (iVar2 != 4);
    return;
}

/* WARNING: Unknown calling convention */

int set_PIC16F1704_voltage_new(uchar voltage)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[7];
    byte bStack_1019;
    char tmp42[4096];

    iVar3 = voltage + 0x15;
    send_data[6] = (uchar)iVar3;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x05';
    send_data[3] = '\x10';
    send_data[5] = (uchar)((uint)iVar3 >> 8);
    send_data[4] = voltage;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    pbVar5 = send_data;
    uVar4 = 0x55;
    while (pbVar5 = pbVar5 + 1,
           i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           &bStack_1019 != pbVar5) {
        uVar4 = (uint)*pbVar5;
    }
    usleep(200000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    if (bVar2 == 1 && bVar1 == 0x10) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok, voltage = 0x%02x",
                     "set_PIC16F1704_voltage_new", (uint)voltage);
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "set_PIC16F1704_voltage_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int write_hash_ID_PIC16F1704_new(uchar *buf)

{
    byte bVar1;
    byte bVar2;
    byte *pbVar3;
    int iVar4;
    byte *pbVar5;
    byte *pbVar6;
    uint uVar7;
    uint uVar8;
    byte bStack_1025;
    uchar send_data[18];
    char tmp42[4096];

    pbVar5 = buf + -1;
    uVar7 = 0x22;
    send_data[8] = '\0';
    send_data[9] = '\0';
    send_data[10] = '\0';
    send_data[0xb] = '\0';
    send_data[0xc] = '\0';
    send_data[0xd] = '\0';
    send_data[0xe] = '\0';
    send_data[0xf] = '\0';
    send_data[4] = '\0';
    send_data[5] = '\0';
    send_data[6] = '\0';
    send_data[7] = '\0';
    pbVar6 = pbVar5;
    do {
        pbVar6 = pbVar6 + 1;
        uVar8 = uVar7 + *pbVar6;
        uVar7 = uVar8 & 0xffff;
    } while (buf + 0xb != pbVar6);
    pbVar3 = send_data + 3;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x10';
    send_data[3] = '\x12';
    do {
        pbVar5 = pbVar5 + 1;
        pbVar3 = pbVar3 + 1;
        *pbVar3 = *pbVar5;
    } while (pbVar5 != pbVar6);
    send_data[0x10] = (uchar)(uVar7 >> 8);
    pbVar6 = &bStack_1025;
    send_data[0x11] = (uchar)uVar8;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    do {
        pbVar6 = pbVar6 + 1;
        i2c_write((uint)*pbVar6 | i2c_slave_addr << 0x10 | 0xa00000U);
    } while (send_data + 0x11 != pbVar6);
    usleep(200000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    if (bVar2 == 1 && bVar1 == 0x12) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar4 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok", "write_hash_ID_PIC16F1704_new");
            _applog(5, tmp42, false);
            iVar4 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar4 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "write_hash_ID_PIC16F1704_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar4 = 0;
    }
    return iVar4;
}

/* WARNING: Unknown calling convention */

int read_hash_id_PIC16F1704_new(uchar *buf)

{
    uchar uVar1;
    byte *pbVar2;
    ushort uVar3;
    char *__format;
    ushort uVar4;
    uint uVar5;
    uchar *puVar6;
    uint uVar7;
    uchar send_data[6];
    uchar uStack_1029;
    uchar read_back_data[16];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    pbVar2 = send_data;
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    read_back_data[6] = '\0';
    read_back_data[7] = '\0';
    read_back_data[8] = '\0';
    read_back_data[9] = '\0';
    read_back_data[10] = '\0';
    read_back_data[0xb] = '\0';
    read_back_data[0xc] = '\0';
    read_back_data[0xd] = '\0';
    read_back_data[0xe] = '\0';
    read_back_data[0xf] = '\0';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x13';
    send_data[4] = '\0';
    send_data[5] = '\x17';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar5 = 0x55;
    while (i2c_write(uVar5 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar2) {
        pbVar2 = pbVar2 + 1;
        uVar5 = (uint)*pbVar2;
    }
    puVar6 = &uStack_1029;
    usleep(200000);
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar6 = puVar6 + 1;
        *puVar6 = uVar1;
    } while (puVar6 != read_back_data + 0xf);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar5 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        if (uVar5 == 0x13) {
            if (read_back_data[0] == '\x10')
                goto LAB_00037946;
        LAB_000378ea:
            if (opt_log_output != false)
                goto LAB_000378fc;
        }
        if (opt_log_level < 3) {
            return 0;
        }
    } else {
        uVar7 = read_back_data._0_4_ & 0xff;
        snprintf(
            tmp42, 0x1000,
            "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
            "read_back_data[2] = 0x%x, read_back_data[3] = "
            "0x%x,\t\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, "
            "read_back_data[6] = 0x%x, read_back_data[7] = "
            "0x%x,\t\tread_back_data[8] = 0x%x, read_back_data[9] = 0x%x, "
            "read_back_data[10] = 0x%x, read_back_data[11] = "
            "0x%x,\t\tread_back_data[12] = 0x%x, read_back_data[13] = 0x%x, "
            "read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
            "read_hash_id_PIC16F1704_new", uVar7, uVar5,
            (uint)read_back_data._0_4_ >> 0x10 & 0xff,
            (uint)read_back_data._0_4_ >> 0x18, read_back_data._4_4_ & 0xff,
            (uint)read_back_data._4_4_ >> 8 & 0xff,
            (uint)read_back_data._4_4_ >> 0x10 & 0xff,
            (uint)read_back_data._4_4_ >> 0x18, read_back_data._8_4_ & 0xff,
            (uint)read_back_data._8_4_ >> 8 & 0xff,
            (uint)read_back_data._8_4_ >> 0x10 & 0xff,
            (uint)read_back_data._8_4_ >> 0x18, read_back_data._12_4_ & 0xff,
            (uint)read_back_data._12_4_ >> 8 & 0xff,
            (uint)read_back_data._12_4_ >> 0x10 & 0xff,
            (uint)read_back_data._12_4_ >> 0x18);
        _applog(5, tmp42, false);
        if ((uVar5 == 0x13) && (uVar7 == 0x10)) {
        LAB_00037946:
            uVar3 = (ushort)read_back_data[2];
            uVar4 = (ushort)read_back_data[0xd] + (ushort)read_back_data[0xc] +
                    (ushort)read_back_data[0xb] + (ushort)read_back_data[10] +
                    (ushort)read_back_data[9] + (ushort)read_back_data[8] +
                    (ushort)read_back_data[7] + (ushort)read_back_data[6] +
                    read_back_data[3] + uVar3 + 0x23 +
                    (ushort)read_back_data[4] + (ushort)read_back_data[5];
            uVar5 = (uint)uVar4;
            if (((ushort)read_back_data[0xe] == uVar4 >> 8) &&
                (read_back_data[0xf] == (uchar)uVar4)) {
                puVar6 = buf + -1;
                pbVar2 = read_back_data + 2;
                while (true) {
                    puVar6 = puVar6 + 1;
                    *puVar6 = (uchar)uVar3;
                    if (buf + 0xb == puVar6)
                        break;
                    pbVar2 = pbVar2 + 1;
                    uVar3 = (ushort)*pbVar2;
                }
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 5)) {
                    return 1;
                }
                snprintf(tmp42, 0x1000, "%s ok", "read_hash_id_PIC16F1704_new");
                _applog(5, tmp42, false);
                return 1;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3)) {
                return 0;
            }
            __format = "%s failed! crc = 0x%04x";
            goto LAB_00037912;
        }
        if (use_syslog == false)
            goto LAB_000378ea;
    }
LAB_000378fc:
    __format = "%s chain %d failed!\n\n";
    uVar5 = i2c_slave_addr;
LAB_00037912:
    snprintf(tmp42, 0x1000, __format, "read_hash_id_PIC16F1704_new", uVar5);
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

int enable_PIC16F1704_dc_dc_new(void)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[7];
    byte bStack_1011;
    char tmp42[4096];

    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x05';
    send_data[3] = '\x15';
    send_data[4] = '\x01';
    send_data[5] = '\0';
    send_data[6] = '\x1b';
    pbVar5 = send_data;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (pbVar5 = pbVar5 + 1,
           i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           &bStack_1011 != pbVar5) {
        uVar4 = (uint)*pbVar5;
    }
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    if (bVar2 == 1 && bVar1 == 0x15) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok", "enable_PIC16F1704_dc_dc_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x",
                 "enable_PIC16F1704_dc_dc_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int disable_PIC16F1704_dc_dc_new(void)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[7];
    byte bStack_1011;
    char tmp42[4096];

    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x05';
    send_data[3] = '\x15';
    send_data[4] = '\0';
    send_data[5] = '\0';
    pbVar5 = send_data;
    send_data[6] = '\x1a';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (pbVar5 = pbVar5 + 1,
           i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           &bStack_1011 != pbVar5) {
        uVar4 = (uint)*pbVar5;
    }
    usleep(100000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    if (bVar2 == 1 && bVar1 == 0x15) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok", "disable_PIC16F1704_dc_dc_new");
            _applog(5, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s chain %d failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x",
                 "disable_PIC16F1704_dc_dc_new", i2c_slave_addr, (uint)bVar1,
                 (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int heart_beat_PIC16F1704_new(void)

{
    uchar uVar1;
    uint uVar2;
    byte *pbVar3;
    uchar *puVar4;
    uchar *puVar5;
    uchar read_back_data[6];
    uchar auStack_101a[2];
    uchar send_data[6];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    pbVar3 = send_data;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x16';
    send_data[4] = '\0';
    send_data[5] = '\x1a';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = 0x55;
    while (i2c_write(uVar2 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar3) {
        pbVar3 = pbVar3 + 1;
        uVar2 = (uint)*pbVar3;
    }
    usleep(100000);
    puVar4 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar5 = puVar4 + 1;
        *puVar4 = uVar1;
        puVar4 = puVar5;
    } while (auStack_101a != puVar5);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if ((uVar2 == 0x16) && (((uint)read_back_data._0_4_ >> 0x10 & 0xff) == 1)) {
        if (opt_debug == false) {
            return 1;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
            return 1;
        }
        snprintf(tmp42, 0x1000, "%s ok", "heart_beat_PIC16F1704_new");
        _applog(7, tmp42, false);
        return 1;
    }
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (2 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s chain %d failed!",
                 "heart_beat_PIC16F1704_new", i2c_slave_addr);
        _applog(3, tmp42, false);
        if ((use_syslog != false) || (opt_log_output != false))
            goto LAB_00037d8a;
    }
    if (opt_log_level < 3) {
        return 0;
    }
LAB_00037d8a:
    snprintf(tmp42, 0x1000,
             "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
             "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
             "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
             "heart_beat_PIC16F1704_new", read_back_data._0_4_ & 0xff, uVar2,
             (uint)read_back_data._0_4_ >> 0x10 & 0xff,
             (uint)read_back_data._0_4_ >> 0x18, (uint)read_back_data[4],
             (uint)read_back_data[5]);
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

void *pic_heart_beat_func_new(void *arg)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "pic_heart_beat_func_new", 0x18);
        _applog(5, tmp42, false);
    }
    do {
        iVar1 = 0;
        sleep(10);
        puVar2 = dev.chain_exist;
        do {
            if ((*puVar2 != '\0') && (send_heart != false)) {
                pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
                i2c_slave_addr = iVar1;
                heart_beat_PIC16F1704_new();
                cgsleep_ms(100);
                pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
            }
            iVar1 = iVar1 + 1;
            puVar2 = puVar2 + 1;
        } while (iVar1 != 4);
    } while (true);
}

/* WARNING: Unknown calling convention */

int get_PIC16F1704_software_version_new(uchar *version)

{
    uchar uVar1;
    ushort uVar2;
    uint uVar3;
    byte *pbVar4;
    uchar *puVar5;
    uchar *puVar6;
    uchar read_back_data[5];
    uchar auStack_1023[3];
    uchar send_data[6];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    pbVar4 = send_data;
    read_back_data[4] = '\0';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x17';
    send_data[4] = '\0';
    send_data[5] = '\x1b';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar3 = 0x55;
    while (i2c_write(uVar3 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar4) {
        pbVar4 = pbVar4 + 1;
        uVar3 = (uint)*pbVar4;
    }
    usleep(400000);
    puVar5 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar6 = puVar5 + 1;
        *puVar5 = uVar1;
        puVar5 = puVar6;
    } while (auStack_1023 != puVar6);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar3 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if (opt_debug == false) {
    LAB_0003806e:
        if ((uVar3 != 0x17) || (read_back_data[0] != '\x05')) {
            if (use_syslog == false) {
            LAB_00038086:
                if (opt_log_output == false)
                    goto LAB_0003810a;
            }
        LAB_0003808c:
            snprintf(tmp42, 0x1000, "%s chain %d failed!",
                     "get_PIC16F1704_software_version_new", i2c_slave_addr);
            _applog(3, tmp42, false);
            if ((use_syslog == false) && (opt_log_output == false)) {
            joined_r0x00038114:
                if (opt_log_level < 3) {
                    return 0;
                }
            }
            snprintf(tmp42, 0x1000,
                     "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
                     "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
                     "read_back_data[4] = 0x%x",
                     "get_PIC16F1704_software_version_new",
                     read_back_data._0_4_ & 0xff, uVar3,
                     (uint)read_back_data._0_4_ >> 0x10 & 0xff,
                     (uint)read_back_data._0_4_ >> 0x18,
                     (uint)read_back_data[4]);
            goto LAB_000380ee;
        }
    } else {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (6 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
                     "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
                     "read_back_data[4] = 0x%x",
                     "get_PIC16F1704_software_version_new",
                     read_back_data._0_4_ & 0xff, uVar3,
                     (uint)read_back_data._0_4_ >> 0x10 & 0xff,
                     (uint)read_back_data._0_4_ >> 0x18,
                     (uint)read_back_data[4]);
            _applog(7, tmp42, false);
            goto LAB_0003806e;
        }
        if (uVar3 != 0x17) {
        LAB_0003810a:
            if (2 < opt_log_level)
                goto LAB_0003808c;
            goto joined_r0x00038114;
        }
        if (read_back_data[0] != '\x05')
            goto LAB_00038086;
    }
    uVar2 = read_back_data[2] + 0x1c;
    if (((ushort)read_back_data[3] == uVar2 >> 8) &&
        (read_back_data[4] == (uchar)uVar2)) {
        *version = read_back_data[2];
        return 1;
    }
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 3)) {
        return 0;
    }
    snprintf(tmp42, 0x1000, "%s failed! crc = 0x%04x",
             "get_PIC16F1704_software_version_new", (uint)uVar2);
LAB_000380ee:
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_get_pic_version(void)

{
    int iVar1;
    int which_chain;
    int iVar2;
    uint8_t *puVar3;
    uchar version[4];
    char tmp42[4096];

    iVar2 = 0;
    version[0] = '\0';
    version[1] = '\0';
    version[2] = '\0';
    version[3] = '\0';
    puVar3 = dev.chain_exist;
    do {
        if (*puVar3 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar2;
            iVar1 = get_PIC16F1704_software_version_new(version + iVar2);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
            if (iVar1 == 1) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "chain%d pic version %02x\n", iVar2,
                             (uint)version[iVar2]);
                    _applog(5, tmp42, false);
                }
            } else if (((use_syslog != false) || (opt_log_output != false)) ||
                       (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "chain%d pic version read failed\n",
                         iVar2);
                _applog(5, tmp42, false);
            }
        }
        iVar2 = iVar2 + 1;
        puVar3 = puVar3 + 1;
    } while (iVar2 != 4);
    return;
}

/* WARNING: Unknown calling convention */

int get_PIC16F1704_voltage_new(uchar *voltage)

{
    uchar uVar1;
    char *__format;
    uint uVar2;
    byte *pbVar3;
    uchar *puVar4;
    uchar *puVar5;
    uint uVar6;
    uchar read_back_data[5];
    uchar auStack_1023[3];
    uchar send_data[6];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    pbVar3 = send_data;
    read_back_data[4] = '\0';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '\x18';
    send_data[4] = '\0';
    send_data[5] = '\x1c';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = 0x55;
    while (i2c_write(uVar2 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar3) {
        pbVar3 = pbVar3 + 1;
        uVar2 = (uint)*pbVar3;
    }
    usleep(200000);
    puVar4 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar5 = puVar4 + 1;
        *puVar4 = uVar1;
        puVar4 = puVar5;
    } while (auStack_1023 != puVar5);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        if (uVar2 == 0x18) {
            if (read_back_data[0] == '\x05')
                goto LAB_0003838c;
        LAB_00038330:
            if (opt_log_output != false)
                goto LAB_00038342;
        }
        if (opt_log_level < 3) {
            return 0;
        }
    } else {
        uVar6 = read_back_data._0_4_ & 0xff;
        snprintf(tmp42, 0x1000,
                 "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
                 "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
                 "read_back_data[4] = 0x%x\n",
                 "get_PIC16F1704_voltage_new", uVar6, uVar2,
                 (uint)read_back_data._0_4_ >> 0x10 & 0xff,
                 (uint)read_back_data._0_4_ >> 0x18, (uint)read_back_data[4]);
        _applog(5, tmp42, false);
        if ((uVar2 == 0x18) && (uVar6 == 5)) {
        LAB_0003838c:
            uVar2 = read_back_data[2] + 0x1d;
            if (((uint)read_back_data._0_4_ >> 0x18 == uVar2 >> 8) &&
                ((uint)read_back_data[4] == (uVar2 & 0xff))) {
                *voltage = read_back_data[2];
                if ((use_syslog == false) &&
                    ((opt_log_output == false && (opt_log_level < 5)))) {
                    return 1;
                }
                snprintf(tmp42, 0x1000, "%s ok, voltage = 0x%02x",
                         "get_PIC16F1704_voltage_new", (uint)read_back_data[2]);
                _applog(5, tmp42, false);
                return 1;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3)) {
                return 0;
            }
            __format = "%s failed! crc = 0x%04x";
            goto LAB_00038358;
        }
        if (use_syslog == false)
            goto LAB_00038330;
    }
LAB_00038342:
    __format = "%s chain %d failed!";
    uVar2 = i2c_slave_addr;
LAB_00038358:
    snprintf(tmp42, 0x1000, __format, "get_PIC16F1704_voltage_new", uVar2);
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

int write_temperature_offset_PIC16F1704_new(uchar *buf)

{
    byte bVar1;
    byte bVar2;
    byte *pbVar3;
    int iVar4;
    byte *pbVar5;
    byte *pbVar6;
    uint uVar7;
    uint uVar8;
    uchar send_data[14];
    char tmp42[4096];

    pbVar5 = buf + -1;
    uVar7 = 0x2e;
    send_data[4] = '\0';
    send_data[5] = '\0';
    send_data[6] = '\0';
    send_data[7] = '\0';
    send_data[8] = '\0';
    send_data[9] = '\0';
    send_data[10] = '\0';
    send_data[0xb] = '\0';
    pbVar6 = pbVar5;
    do {
        pbVar6 = pbVar6 + 1;
        uVar8 = uVar7 + *pbVar6;
        uVar7 = uVar8 & 0xffff;
    } while (buf + 7 != pbVar6);
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\f';
    send_data[3] = '\"';
    pbVar3 = send_data + 4;
    do {
        pbVar5 = pbVar5 + 1;
        *pbVar3 = *pbVar5;
        pbVar3 = pbVar3 + 1;
    } while (pbVar5 != pbVar6);
    send_data[0xc] = (uchar)(uVar7 >> 8);
    pbVar6 = &stack0xffffefdf;
    send_data[0xd] = (uchar)uVar8;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    do {
        pbVar6 = pbVar6 + 1;
        i2c_write((uint)*pbVar6 | i2c_slave_addr << 0x10 | 0xa00000U);
    } while (send_data + 0xd != pbVar6);
    usleep(200000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    if (bVar2 == 1 && bVar1 == 0x22) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar4 = 1;
        } else {
            snprintf(tmp42, 0x1000, "%s ok",
                     "write_temperature_offset_PIC16F1704_new");
            _applog(5, tmp42, false);
            iVar4 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar4 = 0, 2 < opt_log_level)) {
        snprintf(
            tmp42, 0x1000,
            "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
            "write_temperature_offset_PIC16F1704_new", (uint)bVar1,
            (uint)bVar2);
        _applog(3, tmp42, false);
        iVar4 = 0;
    }
    return iVar4;
}

/* WARNING: Unknown calling convention */

int read_temperature_offset_PIC16F1704_new(uchar *buf)

{
    uchar uVar1;
    byte *pbVar2;
    uint uVar3;
    uchar *puVar4;
    uchar *puVar5;
    uint uVar6;
    uchar send_data[6];
    uchar read_back_data[12];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    read_back_data[6] = '\0';
    read_back_data[7] = '\0';
    pbVar2 = send_data;
    read_back_data[8] = '\0';
    read_back_data[9] = '\0';
    read_back_data[10] = '\0';
    read_back_data[0xb] = '\0';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '#';
    send_data[4] = '\0';
    send_data[5] = '\'';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar3 = 0x55;
    while (i2c_write(uVar3 | 0xa00000 | i2c_slave_addr << 0x10),
           pbVar2 != send_data + 5) {
        pbVar2 = pbVar2 + 1;
        uVar3 = (uint)*pbVar2;
    }
    usleep(200000);
    puVar4 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar5 = puVar4 + 1;
        *puVar4 = uVar1;
        puVar4 = puVar5;
    } while ((uchar *)tmp42 != puVar5);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    uVar3 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        if (uVar3 == 0x23) {
            if (read_back_data[0] == '\f')
                goto LAB_0003870c;
        LAB_000386b6:
            if (opt_log_output != false)
                goto LAB_000386c8;
        }
        if (opt_log_level < 3) {
            return 0;
        }
    } else {
        uVar6 = read_back_data._0_4_ & 0xff;
        snprintf(
            tmp42, 0x1000,
            "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
            "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
            "\t\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, "
            "read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, "
            "\t\tread_back_data[8] = 0x%x, read_back_data[9] = 0x%x, "
            "read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
            "read_temperature_offset_PIC16F1704_new", uVar6, uVar3,
            (uint)read_back_data._0_4_ >> 0x10 & 0xff,
            (uint)read_back_data._0_4_ >> 0x18, read_back_data._4_4_ & 0xff,
            (uint)read_back_data._4_4_ >> 8 & 0xff,
            (uint)read_back_data._4_4_ >> 0x10 & 0xff,
            (uint)read_back_data._4_4_ >> 0x18, read_back_data._8_4_ & 0xff,
            (uint)read_back_data._8_4_ >> 8 & 0xff,
            (uint)read_back_data._8_4_ >> 0x10 & 0xff,
            (uint)read_back_data._8_4_ >> 0x18);
        _applog(5, tmp42, false);
        if ((uVar3 == 0x23) && (uVar6 == 0xc)) {
        LAB_0003870c:
            uVar6 = (uint)read_back_data._0_4_ >> 0x10 & 0xff;
            uVar3 = ((uint)read_back_data._8_4_ >> 8 & 0xff) +
                    (read_back_data._8_4_ & 0xff) +
                    ((uint)read_back_data._4_4_ >> 0x18) +
                    ((uint)read_back_data._4_4_ >> 0x10 & 0xff) +
                    ((uint)read_back_data._0_4_ >> 0x18) + uVar6 + 0x2f +
                    (read_back_data._4_4_ & 0xff) +
                    ((uint)read_back_data._4_4_ >> 8 & 0xff);
            if ((((uint)read_back_data._8_4_ >> 0x10 & 0xff) == uVar3 >> 8) &&
                ((uint)read_back_data._8_4_ >> 0x18 == (uVar3 & 0xff))) {
                puVar4 = buf + -1;
                pbVar2 = read_back_data + 3;
                while (true) {
                    puVar4 = puVar4 + 1;
                    *puVar4 = (uchar)uVar6;
                    if (buf + 7 == puVar4)
                        break;
                    uVar6 = (uint)*pbVar2;
                    pbVar2 = pbVar2 + 1;
                }
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 5)) {
                    return 1;
                }
                snprintf(tmp42, 0x1000, "%s ok",
                         "read_temperature_offset_PIC16F1704_new");
                _applog(5, tmp42, false);
                return 1;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3)) {
                return 0;
            }
            snprintf(tmp42, 0x1000, "%s failed! crc = 0x%04x",
                     "read_temperature_offset_PIC16F1704_new", uVar3);
            goto LAB_000386dc;
        }
        if (use_syslog == false)
            goto LAB_000386b6;
    }
LAB_000386c8:
    snprintf(tmp42, 0x1000, "%s failed!",
             "read_temperature_offset_PIC16F1704_new");
LAB_000386dc:
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

uchar erase_PIC16F1704_app_flash_new(void)

{
    int iVar1;
    int iVar2;
    char tmp42[4096];

    set_PIC16F1704_flash_pointer_new('\x06', '\0');
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s: erase_loop = %d\n",
                 "erase_PIC16F1704_app_flash_new", 0x4c);
        _applog(5, tmp42, false);
    }
    iVar2 = 0x4c;
    do {
        iVar1 = erase_PIC16F1704_flash_new();
        iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    return (uchar)iVar1;
}

/* WARNING: Unknown calling convention */

int PIC1704_update_pic_app_program_new(void)

{
    uchar uVar1;
    FILE *__stream;
    ulong uVar2;
    int iVar3;
    char *__format;
    char *unaff_r4;
    uchar *puVar4;
    uchar *puVar5;
    int local_23cc;
    uchar data_read[5];
    uchar buf[16];
    char tmp42[4096];
    uchar program_data[5000];

    memset(program_data, 0, 5000);
    data_read[4] = '\0';
    data_read[0] = '\0';
    data_read[1] = '\0';
    data_read[2] = '\0';
    data_read[3] = '\0';
    buf[0] = '\0';
    buf[1] = '\0';
    buf[2] = '\0';
    buf[3] = '\0';
    buf[4] = '\0';
    buf[5] = '\0';
    buf[6] = '\0';
    buf[7] = '\0';
    buf[8] = '\0';
    buf[9] = '\0';
    buf[10] = '\0';
    buf[0xb] = '\0';
    buf[0xc] = '\0';
    buf[0xd] = '\0';
    buf[0xe] = '\0';
    buf[0xf] = '\0';
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "PIC1704_update_pic_app_program_n", 0x20);
        unaff_r4 = tmp42 + 0x22;
        tmp42[0x20] = 'e';
        tmp42[0x21] = 'w';
        tmp42[0x22] = '\0';
        _applog(5, tmp42, false);
    }
    __stream = fopen("/sbin/pic.txt", "r");
    if (__stream == (FILE *)0x0) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return (int)unaff_r4;
        }
        __format = "%s: open pic16f1704_app_new.txt failed\n";
    } else {
        fseek(__stream, 0, 0);
        memset(program_data, 0, 5000);
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "%s: pic_flash_length = %d\n",
                     "PIC1704_update_pic_app_program_new", 0x980);
            _applog(5, tmp42, false);
        }
        puVar4 = program_data;
        do {
            puVar5 = puVar4 + 2;
            fgets((char *)data_read, 0x3ff, __stream);
            uVar2 = strtoul((char *)data_read, (char **)0x0, 0x10);
            puVar4[1] = (uchar)uVar2;
            *puVar4 = (uchar)(uVar2 >> 8);
            puVar4 = puVar5;
        } while (puVar5 != program_data + 0x1300);
        fclose(__stream);
        unaff_r4 = (char *)reset_PIC16F1704_pic_new();
        if (unaff_r4 != (char *)0x0) {
            uVar1 = erase_PIC16F1704_app_flash_new();
            if (uVar1 == '\0') {
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 3)) {
                    return 0;
                }
                snprintf(tmp42, 0x1000, "%s: erase flash error!\n\n",
                         "PIC1704_update_pic_app_program_new");
                _applog(3, tmp42, false);
                return 0;
            }
            iVar3 = set_PIC16F1704_flash_pointer_new('\x06', '\0');
            if (iVar3 == 0) {
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 3)) {
                    return 0;
                }
                __format = "%s: set flash pointer error!\n\n";
                unaff_r4 = (char *)0x0;
                goto LAB_000389d6;
            }
            local_23cc = 0;
            do {
                iVar3 = local_23cc * 0x10;
                buf._0_4_ = *(undefined4 *)(program_data + iVar3);
                buf._4_4_ = *(undefined4 *)(program_data + iVar3 + 4);
                buf._8_4_ = *(undefined4 *)(program_data + iVar3 + 8);
                buf._12_4_ = *(undefined4 *)(program_data + iVar3 + 0xc);
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "send pic program time: %d",
                             local_23cc);
                    _applog(5, tmp42, false);
                }
                iVar3 = 0;
                do {
                    if ((opt_debug != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000, "buf[%d] = 0x%02x", iVar3,
                                 (uint)buf[iVar3]);
                        _applog(7, tmp42, false);
                    }
                    iVar3 = iVar3 + 1;
                } while (iVar3 != 0x10);
                local_23cc = local_23cc + 1;
                send_data_to_PIC16F1704_new(buf);
                write_data_into_PIC16F1704_flash_new();
            } while (local_23cc != 0x130);
            unaff_r4 = (char *)reset_PIC16F1704_pic_new();
            if (unaff_r4 != (char *)0x0) {
                return 1;
            }
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return 0;
        }
        __format = "%s: reset pic error!\n\n";
    }
LAB_000389d6:
    snprintf(tmp42, 0x1000, __format, "PIC1704_update_pic_app_program_new");
    _applog(3, tmp42, false);
    return (int)unaff_r4;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_reset_PIC16F1704_pic_new(void)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "chain%d %s", iVar1,
                         "every_chain_reset_PIC16F1704_pic_new");
                _applog(5, tmp42, false);
            }
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            reset_PIC16F1704_pic_new();
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_jump_from_loader_to_app_PIC16F1704_new(void)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "chain%d %s", iVar1,
                         "every_chain_jump_from_loader_to_app_PIC16F1704_new");
                _applog(5, tmp42, false);
            }
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            jump_from_loader_to_app_PIC16F1704_new();
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_disable_PIC16F1704_dc_dc_new(void)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "every_chain_disable_PIC16F1704_dc_dc_new",
                        0x28);
        tmp42[0x28] = '\0';
        _applog(5, tmp42, false);
    }
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            disable_PIC16F1704_dc_dc_new();
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention */

void bitmain_ZCASH_shutdown(thr_info *thr)

{
    every_chain_disable_PIC16F1704_dc_dc_new();
    reset_all_hash_board_low();
    cgsleep_ms(100);
    thr_info_cancel(check_miner_status_id);
    thr_info_cancel(check_fan_id);
    thr_info_cancel(read_hash_rate);
    thr_info_cancel(read_temp_id);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_enable_PIC16F1704_dc_dc_new(void)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "every_chain_enable_PIC16F1704_dc_dc_new", 0x28);
        _applog(5, tmp42, false);
    }
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            enable_PIC16F1704_dc_dc_new();
            cgsleep_ms(200);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    return;
}

/* WARNING: Unknown calling convention */

int send_heart_beat_to_every_chain(void)

{
    int iVar1;
    int unaff_r6;
    char tmp42[4096];

    pic_heart_beat = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(pic_heart_beat, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x37e6d, pic_heart_beat);
    if (iVar1 != 0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            snprintf(tmp42, 0x1000,
                     "%s: create thread error for pic_heart_beat_func",
                     "send_heart_beat_to_every_chain");
            _applog(3, tmp42, false);
        }
        return -3;
    }
    pthread_detach(pic_heart_beat->pth);
    return unaff_r6;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void check_whether_need_update_pic_program(void)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    uchar *puVar5;
    bool bVar6;
    uint8_t *local_1030;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "check_whether_need_update_pic_progra", 0x24);
        tmp42[0x24] = 'm';
        tmp42[0x25] = '\0';
        _applog(5, tmp42, false);
    }
    iVar4 = 0;
    local_1030 = dev.chain_exist;
    puVar5 = pic_version;
    do {
        if (*local_1030 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar4;
            reset_PIC16F1704_pic_new();
            cgsleep_ms(100);
            jump_from_loader_to_app_PIC16F1704_new();
            cgsleep_ms(100);
            iVar1 = get_PIC16F1704_software_version_new(pic_version + iVar4);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
            bVar6 = *puVar5 == 0x80;
            if (*puVar5 < 0x81) {
                bVar6 = iVar1 == 1;
            }
            uVar3 = 1;
            if (bVar6) {
                do {
                    pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
                    i2c_slave_addr = iVar4;
                    PIC1704_update_pic_app_program_new();
                    cgsleep_ms(100);
                    jump_from_loader_to_app_PIC16F1704_new();
                    cgsleep_ms(200);
                    iVar1 = get_PIC16F1704_software_version_new(pic_version +
                                                                iVar4);
                    pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
                    cgsleep_ms(100);
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        snprintf(tmp42, 0x1000,
                                 "%s: Chain%d pic update for %d times",
                                 "check_whether_need_update_pic_program", iVar4,
                                 uVar3);
                        _applog(5, tmp42, false);
                    }
                    uVar2 = uVar3 & 0xff;
                    uVar3 = uVar3 + 1;
                } while (uVar2 < 3 && (*puVar5 != 0x81 || iVar1 == 0));
            }
        }
        iVar4 = iVar4 + 1;
        puVar5 = puVar5 + 1;
        local_1030 = local_1030 + 1;
    } while (iVar4 != 4);
    return;
}

/* WARNING: Unknown calling convention */

int save_freq_PIC16F1704_new(ushort freq)

{
    byte bVar1;
    byte bVar2;
    int iVar3;
    uint uVar4;
    byte *pbVar5;
    uchar send_data[8];
    char tmp42[4096];

    send_data[5] = (uchar)freq;
    iVar3 = (uint)send_data[5] + (uint)(freq >> 8) + 0x2a;
    send_data[4] = (uchar)(freq >> 8);
    send_data[7] = (uchar)iVar3;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x06';
    send_data[3] = '$';
    pbVar5 = send_data;
    send_data[6] = (uchar)((uint)iVar3 >> 8);
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (pbVar5 = pbVar5 + 1,
           i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           (byte *)tmp42 != pbVar5) {
        uVar4 = (uint)*pbVar5;
    }
    usleep(300000);
    bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    bVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    if (bVar2 == 1 && bVar1 == 0x24) {
        if ((opt_debug == false) ||
            (((use_syslog == false && (opt_log_output == false)) &&
              (opt_log_level < 7)))) {
            iVar3 = 1;
        } else {
            snprintf(tmp42, 0x1000, "\n--- %s ok\n\n",
                     "save_freq_PIC16F1704_new");
            _applog(7, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "\n--- %s failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x\n\n",
                 "save_freq_PIC16F1704_new", (uint)bVar1, (uint)bVar2);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int get_PIC16F1704_freq_new(ushort *freq)

{
    uchar uVar1;
    uint uVar2;
    byte *pbVar3;
    uchar *puVar4;
    uchar *puVar5;
    uint uVar6;
    uchar read_back_data[6];
    uchar auStack_1022[2];
    uchar send_data[6];
    char tmp42[4096];

    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    pbVar3 = send_data;
    read_back_data[4] = '\0';
    read_back_data[5] = '\0';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x04';
    send_data[3] = '%';
    send_data[4] = '\0';
    send_data[5] = ')';
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar2 = 0x55;
    while (i2c_write(uVar2 | 0xa00000 | i2c_slave_addr << 0x10),
           send_data + 5 != pbVar3) {
        pbVar3 = pbVar3 + 1;
        uVar2 = (uint)*pbVar3;
    }
    usleep(300000);
    puVar4 = read_back_data;
    do {
        uVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar5 = puVar4 + 1;
        *puVar4 = uVar1;
        puVar4 = puVar5;
    } while (auStack_1022 != puVar5);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    usleep(200000);
    uVar2 = (uint)read_back_data._0_4_ >> 8 & 0xff;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        if (uVar2 == 0x25) {
            if (read_back_data[0] == '\x06')
                goto LAB_00039364;
        LAB_00039310:
            if (opt_log_output != false)
                goto LAB_00039322;
        }
        if (opt_log_level < 3) {
            return 0;
        }
    } else {
        uVar6 = read_back_data._0_4_ & 0xff;
        snprintf(tmp42, 0x1000,
                 "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
                 "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
                 "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
                 "get_PIC16F1704_freq_new", uVar6, uVar2,
                 (uint)read_back_data._0_4_ >> 0x10 & 0xff,
                 (uint)read_back_data._0_4_ >> 0x18, (uint)read_back_data[4],
                 (uint)read_back_data[5]);
        _applog(5, tmp42, false);
        if ((uVar2 == 0x25) && (uVar6 == 6)) {
        LAB_00039364:
            uVar2 = (uint)read_back_data[2] + (uint)read_back_data[3] + 0x2b;
            if (((uint)read_back_data[4] == uVar2 >> 8) &&
                ((uint)read_back_data[5] == (uVar2 & 0xff))) {
                *freq = CONCAT11(read_back_data[2], read_back_data[3]);
                if ((use_syslog == false) &&
                    ((opt_log_output == false && (opt_log_level < 5)))) {
                    return 1;
                }
                snprintf(tmp42, 0x1000, "\n--- %s ok, freq = %d\n\n",
                         "get_PIC16F1704_freq_new",
                         (uint)CONCAT11(read_back_data[2], read_back_data[3]));
                _applog(5, tmp42, false);
                return 1;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3)) {
                return 0;
            }
            snprintf(tmp42, 0x1000, "\n--- %s failed! crc = 0x%04x\n\n",
                     "get_PIC16F1704_freq_new", uVar2);
            goto LAB_00039336;
        }
        if (use_syslog == false)
            goto LAB_00039310;
    }
LAB_00039322:
    snprintf(tmp42, 0x1000, "\n--- %s failed!\n\n", "get_PIC16F1704_freq_new");
LAB_00039336:
    _applog(3, tmp42, false);
    return 0;
}

/* WARNING: Unknown calling convention */

int write_data_to_PIC16F1704_flash(uchar *buf, uint offset, int buf_len)

{
    byte *pbVar1;
    uchar uVar2;
    int iVar3;
    uint uVar4;
    uint uVar5;
    undefined2 uVar6;
    uchar *puVar7;
    uchar *puVar8;
    int send_len;
    uchar read_back_data[5];
    uchar auStack_102f[3];
    uchar send_data[17];
    char tmp42[4096];

    uVar5 = 0;
    send_data[6] = '\0';
    send_data[7] = '\0';
    send_data[8] = '\0';
    send_data[9] = '\0';
    uVar4 = buf_len * 2 + 0x39;
    uVar6 = (undefined2)uVar4;
    read_back_data[0] = 0xff;
    read_back_data[1] = '\0';
    read_back_data[2] = '\0';
    read_back_data[3] = '\0';
    read_back_data[4] = '\0';
    send_data[10] = '\0';
    send_data[0xb] = '\0';
    send_data[0xc] = '\0';
    send_data[0xd] = '\0';
    send_data[0xe] = '\0';
    send_data[0xf] = '\0';
    send_data[0x10] = '\0';
    if (0 < buf_len) {
        do {
            pbVar1 = buf + uVar5;
            uVar5 = uVar5 + 1 & 0xff;
            uVar4 = (uint)*pbVar1 + (uVar4 & 0xffff);
            uVar6 = (undefined2)uVar4;
        } while ((int)uVar5 < buf_len);
    }
    send_data[5] = (uchar)buf_len;
    send_data[4] = (uchar)offset;
    send_data[2] = send_data[5] + '\x06';
    send_data[3] = '3';
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    memcpy(send_data + 6, buf, buf_len);
    send_data[buf_len + 7] = (uchar)uVar6;
    send_data[buf_len + 6] = (uchar)((ushort)uVar6 >> 8);
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    if (0 < buf_len + 8) {
        uVar4 = 0;
        do {
            pbVar1 = send_data + uVar4;
            uVar4 = uVar4 + 1 & 0xff;
            i2c_write((uint)*pbVar1 | i2c_slave_addr << 0x10 | 0xa00000);
        } while ((int)uVar4 < buf_len + 8);
    }
    usleep(200000);
    puVar7 = read_back_data;
    do {
        uVar2 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        puVar8 = puVar7 + 1;
        *puVar7 = uVar2;
        puVar7 = puVar8;
    } while (auStack_102f != puVar8);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    if ((((read_back_data._0_4_ & 0xff) == 5) && (read_back_data[1] == '3')) &&
        (read_back_data[2] == '\x01')) {
        iVar3 = 1;
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000, "\n--- %s ok\n\n",
                     "write_data_to_PIC16F1704_flash");
            _applog(7, tmp42, false);
            iVar3 = 1;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (iVar3 = 0, 2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "\n--- %s failed! read_back_data[0] = 0x%02x, "
                 "read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
                 "write_data_to_PIC16F1704_flash", read_back_data._0_4_ & 0xff,
                 (uint)read_back_data[1], (uint)read_back_data[2]);
        _applog(3, tmp42, false);
        iVar3 = 0;
    }
    return iVar3;
}

/* WARNING: Unknown calling convention */

int read_data_from_PIC16F1704_flash(uchar *buf, uchar offset, uchar read_len)

{
    byte bVar1;
    int iVar2;
    uint __n;
    uint uVar3;
    uint uVar4;
    byte *pbVar5;
    uint uVar6;
    uchar send_data[8];
    uchar read_back_data[40];
    char tmp42[4096];

    __n = (uint)read_len;
    memset(read_back_data, 0, 0x28);
    send_data[6] = (uchar)(__n + 0x3a >> 8);
    pbVar5 = send_data;
    send_data[0] = 'U';
    send_data[1] = 0xaa;
    send_data[2] = '\x06';
    send_data[3] = '4';
    send_data[7] = (uchar)(__n + 0x3a);
    read_back_data[0] = 0xff;
    send_data[4] = offset;
    send_data[5] = read_len;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar4 = 0x55;
    while (pbVar5 = pbVar5 + 1,
           i2c_write(uVar4 | 0xa00000 | i2c_slave_addr << 0x10),
           read_back_data != pbVar5) {
        uVar4 = (uint)*pbVar5;
    }
    usleep(200000);
    uVar4 = 0;
    do {
        uVar6 = uVar4 + 1 & 0xff;
        bVar1 = i2c_read(i2c_slave_addr << 0x10 | 0xa00000);
        read_back_data[uVar4] = bVar1;
        uVar4 = uVar6;
    } while (uVar6 <= __n + 4);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    if (((read_back_data[1] == '4') &&
         (uVar4 = (uint)read_back_data[0], uVar4 == __n + 5)) &&
        (read_back_data[2] == '\x01')) {
        uVar3 = 0;
        uVar6 = 0;
        while (true) {
            uVar4 = uVar4 + uVar6;
            uVar3 = uVar3 + 1 & 0xff;
            uVar6 = uVar4 & 0xffff;
            if (__n + 2 < uVar3)
                break;
            uVar4 = (uint)read_back_data[uVar3];
        }
        if (((uint)read_back_data[__n + 3] == uVar6 >> 8) &&
            ((uint)read_back_data[__n + 4] == (uVar4 & 0xff))) {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "\n--- %s ok\n\n",
                         "read_data_from_PIC16F1704_flash");
                _applog(7, tmp42, false);
            }
            memcpy(buf, read_back_data + 3, __n);
            iVar2 = 1;
        } else if (((use_syslog != false) || (opt_log_output != false)) ||
                   (iVar2 = 0, 2 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "\n--- %s failed! crc = 0x%04x\n\n",
                     "read_data_from_PIC16F1704_flash", uVar6);
            _applog(3, tmp42, false);
            iVar2 = 0;
        }
    } else {
        iVar2 = 0;
    }
    return iVar2;
}

/* WARNING: Unknown calling convention */

void every_chain_set_voltage_PIC16F1704_new(ushort voltage)

{
    uint uVar1;
    int iVar2;
    uint8_t *puVar3;
    uint8_t pic_voltage1;
    double dVar4;
    uchar local_101c;
    char tmp42[4096];

    dVar4 = 1609.927422 -
            ((double)(longlong)(int)(uint)voltage * 182.739369) / 100.0;
    local_101c = (0.0 < dVar4) * (char)(longlong)dVar4;
    uVar1 = (uint)use_syslog;
    if (((use_syslog != 0) ||
         (uVar1 = (uint)opt_log_output, opt_log_output != 0)) ||
        (uVar1 = opt_log_level, 4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "set voltage = %.6f  real:%u mv\n", uVar1,
                 dVar4, (uint)voltage);
        _applog(5, tmp42, false);
    }
    iVar2 = 0;
    puVar3 = dev.chain_exist;
    do {
        if (*puVar3 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar2;
            set_PIC16F1704_voltage_new(local_101c);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar2 = iVar2 + 1;
        puVar3 = puVar3 + 1;
    } while (iVar2 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention */

void every_chain_get_voltage_PIC16F1704_new(ushort voltage)

{
    int iVar1;
    uint8_t *puVar2;
    uint8_t pic_voltage1;
    char tmp42[4096];

    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            get_PIC16F1704_voltage_new(&pic_voltage1);
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Chain %u voltage %u", iVar1,
                         (uint)pic_voltage1);
                _applog(5, tmp42, false);
            }
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention */

void every_chain_save_freq_PIC16F1704_new(ushort freq)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s %u", "set freq:", (uint)freq);
        _applog(5, tmp42, false);
    }
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            save_freq_PIC16F1704_new(freq);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void every_chain_get_PIC16F1704_freq_new(void)

{
    int iVar1;
    uint8_t *puVar2;
    ushort freq_read_back[4];
    char tmp42[4096];

    freq_read_back[0] = 0;
    freq_read_back[1] = 0;
    freq_read_back[2] = 0;
    freq_read_back[3] = 0;
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "every_chain_get_PIC16F1704_freq_new", 0x24);
        _applog(5, tmp42, false);
    }
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            get_PIC16F1704_freq_new(freq_read_back + iVar1);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "chain%d pic freq = 0x%08x\n", iVar1,
                         (uint)freq_read_back[iVar1]);
                _applog(5, tmp42, false);
            }
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    cgsleep_ms(500);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void pic_test_new(void)

{
    int iVar1;
    uchar version;
    uchar voltage;
    uchar temp_offset_send[8];
    uchar temp_offset_receive[8];
    uchar hash_id_send[12];
    uchar hash_id_receive[12];

    builtin_memcpy(temp_offset_send, "\x14\x15\x16\x17\x18\x19\x1a\x1b", 8);
    version = '\0';
    builtin_memcpy(hash_id_send, "\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15",
                   0xc);
    voltage = '\0';
    hash_id_receive[0] = '\0';
    hash_id_receive[1] = '\0';
    hash_id_receive[2] = '\0';
    hash_id_receive[3] = '\0';
    temp_offset_receive[0] = '\0';
    temp_offset_receive[1] = '\0';
    temp_offset_receive[2] = '\0';
    temp_offset_receive[3] = '\0';
    hash_id_receive[4] = '\0';
    hash_id_receive[5] = '\0';
    hash_id_receive[6] = '\0';
    hash_id_receive[7] = '\0';
    hash_id_receive[8] = '\0';
    hash_id_receive[9] = '\0';
    hash_id_receive[10] = '\0';
    hash_id_receive[0xb] = '\0';
    temp_offset_receive[4] = '\0';
    temp_offset_receive[5] = '\0';
    temp_offset_receive[6] = '\0';
    temp_offset_receive[7] = '\0';
    iVar1 = 0;
    reset_PIC16F1704_pic_new();
    PIC1704_update_pic_app_program_new();
    jump_from_loader_to_app_PIC16F1704_new();
    get_PIC16F1704_software_version_new(&version);
    write_hash_ID_PIC16F1704_new(hash_id_send);
    read_hash_id_PIC16F1704_new(hash_id_receive);
    write_temperature_offset_PIC16F1704_new(temp_offset_send);
    read_temperature_offset_PIC16F1704_new(temp_offset_receive);
    set_PIC16F1704_voltage_new('x');
    get_PIC16F1704_voltage_new(&voltage);
    enable_PIC16F1704_dc_dc_new();
    enable_PIC16F1704_dc_dc_new();
    heart_beat_PIC16F1704_new();
    usleep(2000000);
    heart_beat_PIC16F1704_new();
    usleep(2000000);
    heart_beat_PIC16F1704_new();
    usleep(2000000);
    do {
        printf("i = %d\n", iVar1);
        iVar1 = iVar1 + 1;
        usleep(2000000);
    } while (iVar1 != 0x23);
    heart_beat_PIC16F1704_new();
    usleep(2000000);
    heart_beat_PIC16F1704_new();
    usleep(2000000);
    heart_beat_PIC16F1704_new();
    usleep(2000000);
    return;
}

/* WARNING: Unknown calling convention */

uchar bit_read(uchar *y, int x)

{
    uint uVar1;
    uint uVar2;

    uVar2 = x & 7;
    if (x < 1) {
        uVar2 = -(-x & 7U);
    }
    if (uVar2 < 8) {
        uVar1 = x >> 0x20;
        switch (uVar2) {
        case 0:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return y[(int)uVar2 >> 3] & 1;
        case 1:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            break;
        case 2:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return (uchar)(((uint)y[(int)uVar2 >> 3] << 0x1d) >> 0x1f);
        case 3:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return (uchar)(((uint)y[(int)uVar2 >> 3] << 0x1c) >> 0x1f);
        case 4:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return (uchar)(((uint)y[(int)uVar2 >> 3] << 0x1b) >> 0x1f);
        case 5:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return (uchar)(((uint)y[(int)uVar2 >> 3] << 0x1a) >> 0x1f);
        case 6:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return (uchar)(((uint)y[(int)uVar2 >> 3] << 0x19) >> 0x1f);
        case 7:
            uVar2 = x & ~uVar1;
            if (x < 0) {
                uVar2 = x + 7;
            }
            return y[(int)uVar2 >> 3] >> 7;
        }
        return (uchar)(((uint)y[(int)uVar2 >> 3] << 0x1e) >> 0x1f);
    }
    return '\0';
}

/* WARNING: Unknown calling convention */

int bm1740_makeup_work(uint8_t *str, int len)

{
    int iVar1;
    char tmp42[4096];

    if (len != 0x92) {
        if (((use_syslog) || (opt_log_output)) || (3 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "%s len error\n", "bm1740_makeup_work");
            _applog(4, tmp42, false);
        }
        return 0;
    }
    iVar1 = bm1740_makeup_work(str, 0x92);
    return iVar1;
}

/* WARNING: Unknown calling convention */

void chain_inactive(int which_chain)

{
    uint length;
    uint32_t in_r1;
    uchar cmd_buf[7];

    cmd_buf[0] = '\0';
    cmd_buf[1] = '\0';
    cmd_buf[2] = '\0';
    cmd_buf[3] = '\0';
    cmd_buf[4] = '\0';
    cmd_buf[5] = '\0';
    cmd_buf[6] = '\0';
    length = bm1740_makeup_chain_inactive_cmd(cmd_buf, in_r1);
    uart_send((uchar)which_chain, cmd_buf, length);
    return;
}

/* WARNING: Unknown calling convention */

void set_address(int which_chain, uchar chip_addr)

{
    uint length;
    uint8_t in_r2;
    uchar cmd_buf[7];

    cmd_buf[0] = '\0';
    cmd_buf[1] = '\0';
    cmd_buf[2] = '\0';
    cmd_buf[3] = '\0';
    cmd_buf[4] = '\0';
    cmd_buf[5] = '\0';
    cmd_buf[6] = '\0';
    length = bm1740_makeup_set_address_cmd(cmd_buf, (uint)chip_addr, in_r2);
    uart_send((uchar)which_chain, cmd_buf, length);
    return;
}

/* WARNING: Unknown calling convention */

void software_set_address_chain(uint which_chain)

{
    char cVar1;
    int iVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s chainID%d asics %d addrInterval %d",
                 "software_set_address_chain", which_chain,
                 (uint)dev.chain_asic_num[which_chain], (uint)dev.addrInterval);
        _applog(5, tmp42, false);
    }
    iVar2 = 0;
    chain_inactive(which_chain);
    cgsleep_ms(0x32);
    do {
        cVar1 = (char)iVar2;
        iVar2 = iVar2 + 1;
        set_address(which_chain, dev.addrInterval * cVar1);
        cgsleep_ms(0x32);
    } while (iVar2 != 3);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void software_set_address(void)

{
    uint which_chain;
    uint8_t *puVar1;

    which_chain = 0;
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            software_set_address_chain(which_chain);
        }
        which_chain = which_chain + 1;
        puVar1 = puVar1 + 1;
    } while (which_chain != 4);
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_core_timeout_chain(uchar which_chain, uint timeout)

{
    uint in_stack_ffffefdc;
    uint8_t cmd[11];
    char tmp42[4096];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        in_stack_ffffefdc = timeout;
        snprintf(tmp42, 0x1000, "chainid%d %s: core timeout = %08x",
                 (uint)which_chain, "set_core_timeout_chain");
        _applog(7, tmp42, false);
    }
    default_core_timeout_reg = timeout;
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', '(', (uint8_t)timeout,
                                 in_stack_ffffefdc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(1);
    return;
}

/* WARNING: Unknown calling convention */

void set_nonce_shift_chain(uchar which_chain, int shift)

{
    uint32_t uVar1;
    uint32_t in_stack_ffffefdc;
    uint8_t cmd[11];
    char tmp42[4096];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    uVar1 = shift << 0x1b;
    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "chainid%d %s: nonce shift = %08x",
                 (uint)which_chain, "set_nonce_shift_chain");
        _applog(7, tmp42, false);
        in_stack_ffffefdc = shift;
    }
    default_nonce_shift_reg = uVar1;
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', 'P', '\0', in_stack_ffffefdc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_core_timeout(uint32_t timeout)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_core_timeout_chain(which_chain, timeout);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_nonce_shift(int shift)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_nonce_shift_chain(which_chain, shift);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_io_drive_strength_chain(uchar which_chain)

{
    uint uVar1;
    uint in_stack_ffffefdc;
    uint8_t cmd[11];
    char tmp42[4096];

    uVar1 = default_io_drive_strength_reg & 0xffff0fff;
    default_io_drive_strength_reg = uVar1 | 0x3000;
    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        in_stack_ffffefdc = default_io_drive_strength_reg;
        snprintf(tmp42, 0x1000, "chainid%d %s: IO drive = %08x",
                 (uint)which_chain, "set_io_drive_strength_chain");
        _applog(5, tmp42, false);
    }
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', '0', (uint8_t)uVar1,
                                 in_stack_ffffefdc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(1);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void set_io_drive_strength(void)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_io_drive_strength_chain(which_chain);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_analog_mux_control_chain(uchar which_chain, uint32_t value)

{
    uint in_stack_ffffefdc;
    uint8_t cmd[11];
    char tmp42[4096];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        in_stack_ffffefdc = value & 7;
        snprintf(tmp42, 0x1000, "chainid%d %s: analog mux = %08x",
                 (uint)which_chain, "set_analog_mux_control_chain");
        _applog(5, tmp42, false);
    }
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', '@', (uint8_t)(value & 7),
                                 in_stack_ffffefdc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(1);
    return;
}

/* WARNING: Unknown calling convention */

void set_analog_mux_control(uint32_t value)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_analog_mux_control_chain(which_chain, value);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_frequency_chain(uchar which_chain, uint frequency)

{
    freq_pll_str *pfVar1;
    uint uVar2;
    int iVar3;
    uint in_stack_ffffefdc;
    uint8_t cmd[11];
    char tmp42[4096];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        in_stack_ffffefdc = frequency;
        snprintf(tmp42, 0x1000, "chainid%d %s freq=%d", (uint)which_chain,
                 "set_frequency_chain");
        _applog(5, tmp42, false);
    }
    pfVar1 = freq_pll;
    uVar2 = 100;
    iVar3 = 0;
    do {
        if (frequency == uVar2) {
            default_pll_reg = freq_pll[iVar3].vilpll;
        LAB_0003a1de:
            bm1740_makeup_set_config_cmd(cmd, 1, '\0', '\f',
                                         (uint8_t)default_pll_reg,
                                         in_stack_ffffefdc);
            uart_send(which_chain, cmd, 0xb);
            dev.freq[which_chain] = (uint16_t)frequency;
            cgsleep_ms(0x32);
            return;
        }
        iVar3 = iVar3 + 1;
        if (iVar3 == 0x77) {
            default_pll_reg = 0x400241;
            goto LAB_0003a1de;
        }
        pfVar1 = pfVar1 + 1;
        uVar2 = pfVar1->freq;
    } while (true);
}

/* WARNING: Unknown calling convention */

void set_freq_asic(uchar which_chain, uchar which_asic, uint frequency)

{
    freq_pll_str *pfVar1;
    uint uVar2;
    uint8_t regaddr;
    int iVar3;
    uint32_t in_stack_ffffefcc;
    uint8_t cmd[11];
    char tmp42[4096];

    uVar2 = (uint)which_asic;
    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s %d %d freq=%d\n", "set_freq_asic",
                 (uint)which_chain, uVar2, frequency);
        _applog(7, tmp42, false);
        in_stack_ffffefcc = uVar2;
    }
    pfVar1 = freq_pll;
    uVar2 = 100;
    iVar3 = 0;
    do {
        if (frequency == uVar2) {
            regaddr = (uint8_t)freq_pll[iVar3].vilpll;
        LAB_0003a2cc:
            bm1740_makeup_set_config_cmd(cmd, 0, dev.addrInterval * which_asic,
                                         '\f', regaddr, in_stack_ffffefcc);
            uart_send(which_chain, cmd, 0xb);
            cgsleep_ms(100);
            return;
        }
        iVar3 = iVar3 + 1;
        if (iVar3 == 0x77) {
            regaddr = 'A';
            goto LAB_0003a2cc;
        }
        pfVar1 = pfVar1 + 1;
        uVar2 = pfVar1->freq;
    } while (true);
}

/* WARNING: Unknown calling convention */

void *turbo_mode_monitor(void)

{
    freq_pll_str *pfVar1;
    uint8_t uVar2;
    uint32_t *puVar3;
    uint32_t(*pauVar4)[3];
    uchar which_chain;
    freq_pll_str *pfVar5;
    int iVar6;
    int iVar7;
    uint uVar8;
    uint32_t uVar9;
    int iVar10;
    int iVar11;
    uint32_t uVar12;
    uint *puVar13;
    uint8_t *puVar14;
    int *piVar15;
    uint32_t(*pauVar16)[3];
    uint *puVar17;
    uint32_t uVar18;
    uint uVar19;
    int local_10d8;
    char *local_10d4;
    int lower_times[4][3];
    int arrive_target_freq[4][3];
    int realtime_freq_table[4][3];
    char tmp42[4096];

    memset(lower_times, 0, 0x30);
    memset(arrive_target_freq, 0, 0x30);
    memset(realtime_freq_table, 0, 0x30);
    iVar11 = 0;
    puVar14 = dev.chain_exist;
    do {
        while (*puVar14 != '\x01') {
            iVar11 = iVar11 + 1;
            puVar14 = puVar14 + 1;
            if (iVar11 == 4)
                goto joined_r0x0003a3da;
        }
        realtime_freq_table[iVar11][0] = 0x307;
        iVar6 = iVar11 + 1;
        uVar9 = g_scan_freq_info.each_asic_freq[iVar11][0];
        uVar18 = g_scan_freq_info.each_asic_freq[iVar11][1];
        uVar12 = g_scan_freq_info.each_asic_freq[iVar11][2];
        realtime_freq_table[iVar11][1] = 0x307;
        realtime_freq_table[iVar11][2] = 0x307;
        iVar10 = uVar9 + uVar18 + uVar12;
        dev.freq[iVar11] =
            (short)((ulonglong)((longlong)iVar10 * 0x55555556) >> 0x20) -
            (short)(iVar10 >> 0x1f);
        iVar11 = iVar6;
        puVar14 = puVar14 + 1;
    } while (iVar6 != 4);
joined_r0x0003a3da:
    do {
        while (start_send[0] == false) {
            cgsleep_ms(500);
        }
        iVar11 = 0;
        local_10d8 = 0;
        puVar14 = dev.chain_exist;
        do {
            if (*puVar14 == '\x01') {
                puVar13 = (uint *)((int)realtime_freq_table[0] + iVar11);
                iVar10 = 0;
                which_chain = (char)(puVar14 + 1) + '\x17';
                puVar17 =
                    (uint *)((int)g_scan_freq_info.each_asic_freq[0] + iVar11);
                piVar15 = (int *)((int)arrive_target_freq[0] + iVar11);
                iVar6 = *piVar15;
                if (iVar6 != 0)
                    goto LAB_0003a4e0;
                do {
                    uVar8 = *puVar17;
                    if ((uVar8 < 0x307) || (uVar8 == 0x307)) {
                        *puVar13 = uVar8;
                        set_freq_asic(which_chain, (uchar)iVar10, uVar8);
                    LAB_0003a4f4:
                        *piVar15 = 1;
                    } else {
                        iVar7 = 1;
                        pfVar5 = freq_pll;
                        do {
                            iVar7 = iVar7 + 1;
                            if (iVar7 == 0x77) {
                                uVar8 = *puVar13;
                                if (uVar8 == 100)
                                    goto LAB_0003a4fa;
                                iVar7 = -1;
                                goto LAB_0003a47e;
                            }
                            pfVar1 = pfVar5 + 2;
                            pfVar5 = pfVar5 + 1;
                        } while (pfVar1->freq != uVar8);
                        uVar8 = *puVar13;
                        if (uVar8 != 100) {
                        LAB_0003a47e:
                            iVar6 = 1;
                            uVar19 = 0x7d;
                            pfVar5 = freq_pll;
                            while (uVar19 != uVar8) {
                                iVar6 = iVar6 + 1;
                                if (iVar6 == 0x77) {
                                    iVar7 = iVar7 + 1;
                                    iVar6 = -1;
                                    goto LAB_0003a4a0;
                                }
                                uVar19 = pfVar5[2].freq;
                                pfVar5 = pfVar5 + 1;
                            }
                            iVar7 = iVar7 - iVar6;
                        }
                    LAB_0003a4a0:
                        if (iVar7 < 2) {
                        LAB_0003a4fa:
                            iVar6 = iVar6 + 1;
                        } else {
                            iVar6 = iVar6 + 2;
                        }
                        uVar8 = freq_pll[iVar6].freq;
                        *puVar13 = uVar8;
                        set_freq_asic(which_chain, (uchar)iVar10, uVar8);
                        if (uVar8 == *puVar17)
                            goto LAB_0003a4f4;
                    }
                    while (true) {
                        iVar10 = iVar10 + 1;
                        puVar13 = puVar13 + 1;
                        puVar17 = puVar17 + 1;
                        if (iVar10 == 3)
                            goto LAB_0003a3f0;
                        piVar15 = piVar15 + 1;
                        iVar6 = *piVar15;
                        if (iVar6 == 0)
                            break;
                    LAB_0003a4e0:
                        local_10d8 = local_10d8 + 1;
                    }
                } while (true);
            }
        LAB_0003a3f0:
            iVar11 = iVar11 + 0xc;
            puVar14 = puVar14 + 1;
        } while (iVar11 != 0x30);
        if ((int)((uint)dev.chain_num * 3) <= local_10d8) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                builtin_strncpy(tmp42, "All asics arrive target freq", 0x1c);
                tmp42[0x1c] = '\n';
                tmp42[0x1d] = '\0';
                _applog(5, tmp42, false);
            }
            local_10d4 = tmp42;
            iVar11 = 0;
            puVar14 = dev.chain_exist;
            do {
                if (*puVar14 == '\x01') {
                    g_scan_freq_info
                        .each_asic_invalid_nonce_each_2min[iVar11][0] = 0;
                    g_scan_freq_info.each_asic_ox_status[iVar11][0] = 0;
                    g_scan_freq_info.each_asic_max_freq[iVar11][0] = 0x32f;
                    g_scan_freq_info.each_asic_min_freq[iVar11][0] = 0x307;
                    g_scan_freq_info
                        .each_asic_invalid_nonce_each_2min[iVar11][1] = 0;
                    g_scan_freq_info.each_asic_ox_status[iVar11][1] = 0;
                    g_scan_freq_info.each_asic_max_freq[iVar11][1] = 0x32f;
                    g_scan_freq_info.each_asic_min_freq[iVar11][1] = 0x307;
                    g_scan_freq_info
                        .each_asic_invalid_nonce_each_2min[iVar11][2] = 0;
                    g_scan_freq_info.each_asic_ox_status[iVar11][2] = 0;
                    g_scan_freq_info.each_asic_max_freq[iVar11][2] = 0x32f;
                    g_scan_freq_info.each_asic_min_freq[iVar11][2] = 0x307;
                }
                iVar11 = iVar11 + 1;
                puVar14 = puVar14 + 1;
            } while (iVar11 != 4);
        LAB_0003a5e2:
            do {
                sleep(1);
                pthread_mutex_lock(
                    (pthread_mutex_t *)&each_chain_err_asic_mutex);
                pthread_cond_wait(
                    (pthread_cond_t *)&each_chain_err_asic_cond,
                    (pthread_mutex_t *)&each_chain_err_asic_mutex);
                pthread_mutex_unlock(
                    (pthread_mutex_t *)&each_chain_err_asic_mutex);
            } while (status_error != false);
            puVar14 = dev.chain_exist;
            iVar11 = 0;
            uVar2 = dev.chain_exist[0];
            do {
                puVar14 = puVar14 + 1;
                if (uVar2 == '\x01') {
                    iVar6 = 0;
                    piVar15 = lower_times[iVar11];
                    pauVar16 =
                        g_scan_freq_info.each_asic_invalid_nonce_each_2min +
                        iVar11;
                    if (g_scan_freq_info.each_asic_ox_status[iVar11][0] != 1) {
                        *piVar15 = 0;
                        goto LAB_0003a640;
                    }
                    do {
                        iVar10 = *piVar15 + 1;
                        *piVar15 = iVar10;
                        if (((use_syslog != false) ||
                             (opt_log_output != false)) ||
                            (4 < opt_log_level)) {
                            snprintf(local_10d4, 0x1000,
                                     "low freq[%d-%d]: cur freq %d, lower "
                                     "times %d\n",
                                     iVar11, iVar6, pauVar16[0x14][0], iVar10);
                            _applog(5, local_10d4, false);
                        }
                        if (3 < iVar10) {
                            uVar9 = pauVar16[0x14][0];
                            uVar8 = pauVar16[0xc][0];
                            if (uVar8 < uVar9) {
                                *piVar15 = 0;
                                if (((use_syslog != false) ||
                                     (opt_log_output != false)) ||
                                    (4 < opt_log_level)) {
                                    snprintf(
                                        local_10d4, 0x1000,
                                        "low freq[%d-%d]: cur freq %d, [%d, "
                                        "%d], invalid nonce %d, ox status %d\n",
                                        iVar11, iVar6, uVar9, uVar8,
                                        pauVar16[0x10][0], (*pauVar16)[0],
                                        pauVar16[8][0]);
                                    _applog(5, local_10d4, false);
                                    uVar9 = pauVar16[0x14][0];
                                }
                                if (uVar9 == 100) {
                                LAB_0003a766:
                                    uVar8 = 0;
                                } else {
                                    iVar10 = 1;
                                    uVar12 = 0x7d;
                                    pfVar5 = freq_pll;
                                    while (uVar9 != uVar12) {
                                        iVar10 = iVar10 + 1;
                                        if (iVar10 == 0x77)
                                            goto LAB_0003a766;
                                        uVar12 = pfVar5[2].freq;
                                        pfVar5 = pfVar5 + 1;
                                    }
                                    uVar8 = *(uint *)("set_frequency_chain" +
                                                      iVar10 * 0x10 + 4);
                                }
                                pauVar16[0x14][0] = uVar8;
                                set_freq_asic((uchar)iVar11, (uchar)iVar6,
                                              uVar8);
                            }
                        }
                    LAB_0003a640:
                        while (true) {
                            iVar6 = iVar6 + 1;
                            puVar3 = *pauVar16;
                            piVar15 = piVar15 + 1;
                            if (iVar6 == 3)
                                goto LAB_0003a614;
                            pauVar4 = pauVar16 + 8;
                            pauVar16 = (uint32_t(*)[3])(puVar3 + 1);
                            if ((*pauVar4)[1] == 1)
                                break;
                            *piVar15 = 0;
                        }
                    } while (true);
                }
            LAB_0003a614:
                iVar11 = iVar11 + 1;
                if (iVar11 == 4)
                    goto LAB_0003a5e2;
                uVar2 = *puVar14;
            } while (true);
        }
        sleep(3);
    } while (true);
}

/* WARNING: Unknown calling convention */

void set_frequency(uint frequency)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_frequency_chain(which_chain, frequency);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_baud_chain(uchar which_chain, uint bt8d)

{
    uint32_t in_stack_ffffffdc;
    uint8_t cmd[11];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    default_misc_reg = default_misc_reg & 0xffffe0ff | (bt8d & 0x1f) << 8 | 4;
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', '\x1c',
                                 (uint8_t)default_misc_reg, in_stack_ffffffdc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(1);
    return;
}

/* WARNING: Unknown calling convention */

void set_baud(uint bt8d)

{
    uchar asic_baud;
    uchar which_chain;
    uint8_t *puVar1;
    char tmp42[4096];

    asic_baud = (uchar)bt8d;
    dev.baud = asic_baud;
    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s: bt8d = %d", "set_baud", bt8d);
        _applog(7, tmp42, false);
    }
    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_baud_chain(which_chain, bt8d);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    sleep(1);
    set_fpga_baud(asic_baud);
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void set_ticket_mask_chain(uchar which_chain, uint32_t ticket_mask)

{
    uint32_t in_stack_ffffefdc;
    uint8_t cmd[11];
    char tmp42[4096];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        in_stack_ffffefdc = ticket_mask;
        snprintf(tmp42, 0x1000, "%s chainID%d ticket_mask = 0x%08x",
                 "set_ticket_mask_chain", (uint)which_chain);
        _applog(5, tmp42, false);
    }
    default_ticket_mask_reg = ticket_mask & 0xff;
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', '\x14', (uint8_t)ticket_mask,
                                 in_stack_ffffefdc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(1);
    return;
}

/* WARNING: Unknown calling convention */

void set_ticket_mask(uint ticket_mask)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_ticket_mask_chain(which_chain, ticket_mask);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    return;
}

/* WARNING: Unknown calling convention */

void set_txn_data_chain(uchar which_chain, int txn_shalow, int txn_zero)

{
    uint32_t in_stack_ffffefcc;
    uint8_t cmd[11];
    char tmp42[4096];

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        in_stack_ffffefcc = txn_shalow;
        snprintf(tmp42, 0x1000, "chainID%d %s txndata %d txnzero %d",
                 (uint)which_chain, "set_txn_data_chain", txn_shalow, txn_zero);
        _applog(5, tmp42, false);
    }
    default_txn_data = (txn_shalow & 1U) << 1 | txn_zero & 1U;
    bm1740_makeup_set_config_cmd(cmd, 1, '\0', 'X', (uint8_t)default_txn_data,
                                 in_stack_ffffefcc);
    uart_send(which_chain, cmd, 0xb);
    cgsleep_ms(1);
    return;
}

/* WARNING: Unknown calling convention */

void set_txn_data(int txn_shalow, int txn_zero)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            set_txn_data_chain(which_chain, txn_shalow, txn_zero);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    return;
}

/* WARNING: Unknown calling convention */

int is_nonce_or_reg_value(uchar data)

{
    return (uint)(data >> 7);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void init_asic_display_status(void)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    uint8_t *puVar7;
    char tmp42[4096];

    iVar6 = 0;
    puVar7 = dev.chain_exist;
    do {
        if (*puVar7 != '\0') {
            uVar5 = (uint)puVar7[0x209];
            if (uVar5 != 0) {
                uVar5 = 0;
                uVar4 = 0;
                do {
                    uVar2 = uVar5 + uVar4;
                    uVar3 = uVar2;
                    if ((uVar4 & 7) == 0) {
                        if ((0x13 < uVar2) && (((use_syslog != false ||
                                                 (opt_log_output != false)) ||
                                                (2 < opt_log_level)))) {
                            snprintf(tmp42, 0x1000, "offset[%d] ERR", uVar2);
                            _applog(3, tmp42, false);
                        }
                        uVar5 = uVar5 + 1 & 0xff;
                        uVar3 = uVar4 + uVar5;
                        dev.chain_asic_status_string[iVar6][uVar2] = ' ';
                    }
                    if ((0x13 < uVar3) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (2 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000, "offset[%d] ERR", uVar3);
                        _applog(3, tmp42, false);
                    }
                    dev.chain_asic_status_string[iVar6][uVar3] = 'o';
                    uVar3 = uVar4 + 1 & 0xff;
                    iVar1 = uVar4 * 4;
                    *(undefined1 *)(dev.chain_asic_nonce[iVar6] + uVar4) = 0;
                    *(undefined1 *)((int)dev.chain_asic_nonce[iVar6] + iVar1 +
                                    1) = 0;
                    *(undefined1 *)((int)dev.chain_asic_nonce[iVar6] + iVar1 +
                                    2) = 0;
                    *(undefined1 *)((int)dev.chain_asic_nonce[iVar6] + iVar1 +
                                    3) = 0;
                    uVar4 = uVar3;
                } while (uVar3 < puVar7[0x209]);
                uVar5 = uVar5 + uVar3;
                if ((0x13 < uVar5) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (2 < opt_log_level)))) {
                    snprintf(tmp42, 0x1000, "offset[%d] ERR", uVar5);
                    _applog(3, tmp42, false);
                }
            }
            dev.chain_asic_status_string[iVar6][uVar5] = '\0';
        }
        iVar6 = iVar6 + 1;
        puVar7 = puVar7 + 1;
    } while (iVar6 != 4);
    return;
}

/* WARNING: Unknown calling convention */

speed_t tiospeed_t(int baud)

{
    if (baud == 0x1c200) {
        return 0x1002;
    }
    if (baud < 0x1c201) {
        if (baud == 0x4b00) {
            return 0xe;
        }
        if (baud < 0x4b01) {
            if (baud == 0x2580) {
                return 0xd;
            }
        } else {
            if (baud == 0x9600) {
                return 0xf;
            }
            if (baud == 0xe100) {
                return 0x1001;
            }
        }
    } else {
        if (baud == 0xe1000) {
            return 0x1007;
        }
        if (baud < 0xe1001) {
            if (baud == 0x38400) {
                return 0x1003;
            }
            if ((_Bool *)baud == update_asic_num) {
                return 0x1004;
            }
        } else {
            if (baud == 1500000) {
                return 0x100a;
            }
            if (baud == 3000000) {
                return 0x100d;
            }
        }
    }
    return 0;
}

/* WARNING: Unknown calling convention */

void tty_init_chain(uint8_t which_chain, bitmain_ZCASH_info *info)

{
    ushort uVar1;
    _Bool _Var2;
    uint uVar3;
    int iVar4;
    char *pcVar5;
    bitmian_ZCASH_info_with_index info_with_index;
    char tmp42[4096];

    _Var2 = use_syslog;
    uVar3 = (uint)which_chain;
    if (dev.chain_exist[uVar3] == '\0') {
        return;
    }
    dev_info[uVar3].chainid = uVar3;
    if (((_Var2) || (opt_log_output != false)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s chainid = %d", "tty_init_chain", uVar3);
        _applog(5, tmp42, false);
    }
    uVar1 = (ushort)which_chain;
    start_recv[uVar3] = true;
    iVar4 = thr_info_create(
        info->uart_rx_t + (short)uVar1, (pthread_attr_t *)0x0,
        (_func_void_ptr_void_ptr *)0x3fb31, dev_info + (short)uVar1);
    if (iVar4 == 0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            pcVar5 = "create rx read thread for chain %d ok";
        LAB_0003ad20:
            snprintf(tmp42, 0x1000, pcVar5, uVar3);
            _applog(3, tmp42, false);
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (2 < opt_log_level)) {
        pcVar5 = "create rx read thread for chain %d failed";
        goto LAB_0003ad20;
    }
    cgsleep_ms(0x32);
    info_with_index.chain_index = which_chain;
    info_with_index.info = info;
    iVar4 =
        thr_info_create(info->uart_tx_t + (short)uVar1, (pthread_attr_t *)0x0,
                        (_func_void_ptr_void_ptr *)0x352d5, &info_with_index);
    cgsleep_ms(200);
    if (iVar4 == 0) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3))
            goto LAB_0003adf6;
        pcVar5 = "create tx read thread for chain %d ok";
    LAB_0003ad80:
        snprintf(tmp42, 0x1000, pcVar5, uVar3);
        _applog(3, tmp42, false);
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0003adf6;
    } else {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (2 < opt_log_level)) {
            pcVar5 = "create tx read thread for chain %d failed";
            goto LAB_0003ad80;
        }
    LAB_0003adf6:
        if (opt_log_level < 5)
            goto LAB_0003adc0;
    }
    builtin_strncpy(tmp42, "open device over", 0x11);
    _applog(5, tmp42, false);
LAB_0003adc0:
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

void tty_init(bitmain_ZCASH_info *info)

{
    int iVar1;
    int iVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "tty_init", 8);
        tmp42[8] = '\0';
        _applog(5, tmp42, false);
    }
    iVar1 = 0;
    do {
        iVar2 = iVar1 + 1;
        tty_init_chain((uint8_t)iVar1, info);
        iVar1 = iVar2;
    } while (iVar2 != 4);
    cgsleep_ms(10);
    return;
}

/* WARNING: Unknown calling convention */

int ZCASH_write(int fd, uint8_t *buf, size_t bufLen)

{
    uint uVar1;

    uVar1 = uart_send((uchar)fd, buf, bufLen);
    return uVar1;
}

/* WARNING: Unknown calling convention */

int ZCASH_read(int uart_fd, uchar *buf, size_t MAX_READ_BYTES)

{
    uint uVar1;

    uVar1 = uart_receive((uchar)uart_fd, buf, MAX_READ_BYTES);
    return uVar1;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void check_chain(void)

{
    uint uVar1;
    uint uVar2;
    char tmp42[4096];
    uint data;

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "check_chain", 0xc);
        _applog(5, tmp42, false);
    }
    uVar2 = 0;
    dev.chain_num = '\0';
    uVar1 = axi_fpga_addr[2];
    do {
        if (((int)uVar1 >> (uVar2 & 0xff) & 1U) == 0) {
            dev.chain_exist[uVar2] = '\0';
        } else {
            dev.chain_exist[uVar2] = '\x01';
            dev.chain_num = dev.chain_num + '\x01';
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "Chain %d existed!", uVar2);
                _applog(5, tmp42, false);
            }
        }
        uVar2 = uVar2 + 1;
    } while (uVar2 != 4);
    return;
}

/* WARNING: Unknown calling convention */

void set_led(_Bool stop)

{
    char cmd[100];

    blink_15605 = blink_15605 ^ 1;
    if (!stop) {
        sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", 0, 0x3ad);
        system(cmd);
        sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value",
                (uint)blink_15605, 0x3ae);
        system(cmd);
        return;
    }
    sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", 0, 0x3ae);
    system(cmd);
    sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", (uint)blink_15605,
            0x3ad);
    system(cmd);
    return;
}

/* WARNING: Type propagation algorithm not settling */
/* WARNING: Unknown calling convention */

void *check_miner_status(void *arg)

{
    uint8_t uVar1;
    uint32_t(*pauVar2)[3];
    int32_t iVar3;
    _Bool _Var4;
    uint uVar5;
    uint32_t uVar6;
    uint8_t *extraout_r2;
    uint8_t *puVar7;
    uint32_t uVar8;
    uint uVar9;
    char *__format;
    int iVar10;
    uint8_t *puVar11;
    uint32_t uVar12;
    uint8_t *puVar13;
    uint32_t(*pauVar14)[3];
    uint uVar15;
    uint32_t(*pauVar16)[3];
    uint8_t *puVar17;
    uint uVar18;
    uint8_t *puVar19;
    int iVar20;
    uint8_t *puVar21;
    undefined1 *puVar22;
    bool bVar23;
    int local_107c;
    uint8_t *local_1074;
    uint local_1070;
    int local_1058;
    timeval tv_start;
    timeval tv_end;
    timeval tv_send;
    uint each_chain_error_asic[4];
    char tmp42[4096];

    puVar13 = (uint8_t *)0x0;
    tv_start.tv_usec = 0;
    tv_start.tv_sec = 0;
    cgtime(&tv_end);
    cgtime(&tv_send);
    copy_time(&tv_start, &tv_end);
    copy_time(&tv_send_job, &tv_send);
    each_chain_error_asic[1] = 0;
    each_chain_error_asic[2] = 0;
    each_chain_error_asic[3] = 0;
    each_chain_error_asic[0] = 0;
LAB_0003b10c:
    while (true) {
        cgtime(&tv_end);
        cgtime(&tv_send);
        iVar10 = tv_end.tv_sec - tv_start.tv_sec;
        if (tv_end.tv_usec - tv_start.tv_usec < 0) {
            iVar10 = iVar10 + -1;
        }
        if (iVar10 < 12000)
            break;
        copy_time(&tv_start, &tv_end);
        cgsleep_ms(3000);
    }
    if (0x78 < iVar10) {
        each_chain_error_asic[0] = 0;
        each_chain_error_asic[1] = 0;
        each_chain_error_asic[2] = 0;
        each_chain_error_asic[3] = 0;
        pauVar14 = dev.chain_asic_invalid_nonce;
        pauVar16 = g_scan_freq_info.each_asic_invalid_nonce_each_2min;
        do {
            uVar12 = pauVar14[1][0];
            pauVar2 = pauVar14 + 1;
            uVar6 = (*pauVar14)[1];
            uVar8 = (*pauVar14)[2];
            (*pauVar16)[0] = (*pauVar14)[0];
            (*pauVar16)[1] = uVar6;
            (*pauVar16)[2] = uVar8;
            pauVar16[1][0] = uVar12;
            pauVar14 = (uint32_t(*)[3])(*pauVar2 + 1);
            pauVar16 = (uint32_t(*)[3])(pauVar16[1] + 1);
        } while ((char(*)[19])(*pauVar2 + 1) != dev.chain_asic_status_string);
        pauVar14 = dev.chain_asic_nonce;
        pauVar16 = g_scan_freq_info.each_asic_valid_nonce_each_2min;
        do {
            uVar12 = pauVar14[1][0];
            pauVar2 = pauVar14 + 1;
            uVar6 = (*pauVar14)[1];
            uVar8 = (*pauVar14)[2];
            (*pauVar16)[0] = (*pauVar14)[0];
            (*pauVar16)[1] = uVar6;
            (*pauVar16)[2] = uVar8;
            pauVar16[1][0] = uVar12;
            pauVar14 = (uint32_t(*)[3])(*pauVar2 + 1);
            pauVar16 = (uint32_t(*)[3])(pauVar16[1] + 1);
        } while ((uint32_t(*)[3])(*pauVar2 + 1) !=
                 dev.chain_asic_invalid_nonce);
        iVar10 = 0;
        iVar20 = 0;
        local_1074 = dev.chain_exist;
        local_107c = 0;
        puVar13 = (uint8_t *)0x72d13;
        puVar7 = dev.chain_exist;
        do {
            if (*puVar7 != '\0') {
                puVar22 = (undefined1 *)(uint)puVar7[0x209];
                local_107c = local_107c + (int)puVar22;
                if (puVar22 != (undefined1 *)0x0) {
                    puVar13 = (uint8_t *)0x0;
                    do {
                        uVar6 = dev.chain_asic_nonce[0][(int)(puVar13 +
                                                              iVar10 * 3)];
                        iVar20 = iVar20 + uVar6;
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            snprintf(tmp42, 0x1000,
                                     "%s: chain %d asic %d asic_nonce_num %d",
                                     "check_miner_status", iVar10, puVar13,
                                     uVar6);
                            _applog(7, tmp42, false);
                            puVar22 = (undefined1 *)(uint)puVar7[0x209];
                        }
                        puVar13 = puVar13 + 1;
                    } while (puVar13 < puVar22);
                }
            }
            iVar10 = iVar10 + 1;
            puVar7 = puVar7 + 1;
        } while (iVar10 != 4);
        if (local_107c == 0) {
            local_1070 = 1;
        } else {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "%s: avg_num %d asic_num %d",
                         "check_miner_status", iVar20, local_107c);
                _applog(7, tmp42, false);
            }
            local_1070 = __udivsi3(iVar20, local_107c);
            local_1070 = local_1070 >> 3;
        }
        iVar10 = 0;
        do {
            if (*local_1074 != '\0') {
                if (local_1074[0x209] == '\0') {
                    local_1058 = iVar10 << 2;
                    uVar5 = 0;
                } else {
                    local_1058 = iVar10 * 4;
                    pauVar14 = g_scan_freq_info.each_asic_ox_status + iVar10;
                    uVar15 = 0;
                    uVar9 = 0;
                    do {
                        uVar18 = uVar9;
                        if (uVar15 == 0) {
                            if ((0x13 < uVar9) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (2 < opt_log_level)))) {
                                snprintf(tmp42, 0x1000, "asic num err![%d]",
                                         uVar9);
                                _applog(3, tmp42, false);
                            }
                            uVar18 = uVar9 + 1;
                            dev.chain_asic_status_string[iVar10][uVar9] = ' ';
                        }
                        uVar5 = uVar18 + uVar15;
                        if (local_1070 < dev.chain_asic_nonce[iVar10][uVar15]) {
                            (*pauVar14)[0] = 0;
                        LAB_0003b8b0:
                            if ((0x13 < uVar5) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (2 < opt_log_level)))) {
                                snprintf(tmp42, 0x1000, "asic num err![%d]",
                                         uVar5);
                                _applog(3, tmp42, false);
                            }
                            puVar13 =
                                dev.chain_exist + uVar5 + iVar10 * 0x13 + -8;
                            puVar13[0x163] = 'o';
                        } else {
                            (*pauVar14)[0] = 1;
                            if (certification_firmware != false)
                                goto LAB_0003b8b0;
                            if ((0x13 < uVar5) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (2 < opt_log_level)))) {
                                snprintf(tmp42, 0x1000, "asic num err![%d]",
                                         uVar5);
                                _applog(3, tmp42, false);
                            }
                            _Var4 = opt_debug;
                            uVar9 = each_chain_error_asic[iVar10];
                            puVar13 =
                                dev.chain_exist + uVar5 + iVar10 * 0x13 + -8;
                            puVar13[0x163] = 'x';
                            each_chain_error_asic[iVar10] = uVar9 + 1;
                            if ((_Var4 != false) &&
                                (((use_syslog != false ||
                                   (opt_log_output != false)) ||
                                  (6 < opt_log_level)))) {
                                puVar13 =
                                    (uint8_t *)
                                        dev.chain_asic_nonce[iVar10][uVar15];
                                snprintf(tmp42, 0x1000,
                                         "x chain%d asic%d nonce_num=%d "
                                         "avg_num=%d\n",
                                         iVar10, uVar15, puVar13, local_1070);
                                _applog(7, tmp42, false);
                            }
                        }
                        pauVar14 = (uint32_t(*)[3])(*pauVar14 + 1);
                        uVar5 = uVar15 + 1;
                        iVar20 = uVar15 * 4;
                        *(undefined1 *)(dev.chain_asic_nonce[iVar10] + uVar15) =
                            0;
                        *(undefined1 *)((int)dev.chain_asic_nonce[iVar10] +
                                        iVar20 + 1) = 0;
                        *(undefined1 *)((int)dev.chain_asic_nonce[iVar10] +
                                        iVar20 + 2) = 0;
                        *(undefined1 *)((int)dev.chain_asic_nonce[iVar10] +
                                        iVar20 + 3) = 0;
                        uVar15 = uVar5;
                        uVar9 = uVar18;
                    } while (uVar5 < local_1074[0x209]);
                    uVar5 = uVar5 + uVar18;
                    if ((0x13 < uVar5) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (2 < opt_log_level)))) {
                        snprintf(tmp42, 0x1000, "asic num err![%d]", uVar5);
                        _applog(3, tmp42, false);
                    }
                }
                dev.chain_asic_status_string[0][uVar5 + local_1058 * 4 +
                                                iVar10 * 3] = '\0';
            }
            iVar10 = iVar10 + 1;
            local_1074 = local_1074 + 1;
        } while (iVar10 != 4);
        pthread_mutex_lock((pthread_mutex_t *)&each_chain_err_asic_mutex);
        pthread_cond_signal((pthread_cond_t *)&each_chain_err_asic_cond);
        pthread_mutex_unlock((pthread_mutex_t *)&each_chain_err_asic_mutex);
        memset(dev.chain_asic_invalid_nonce, 0, 0x30);
        memset(dev.chain_asic_nonce, 0, 0x30);
        copy_time(&tv_start, &tv_end);
    }
    iVar3 = dev.temp_chip_top;
    if ((dev.temp_top1 < 0x51) && (dev.temp_chip_top < 0x6f)) {
        gMinerStatus_High_Temp_Counter = '\0';
        gMinerStatus_High_Temp = false;
    } else {
        gMinerStatus_High_Temp_Counter = gMinerStatus_High_Temp_Counter + 1;
        if (gMinerStatus_High_Temp_Counter < 3) {
            if ((status_error == false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (2 < opt_log_level)))) {
                snprintf(tmp42, 0x1000,
                         "Temperature pcb:%d/chip:%d is higher than %d/%d\'C "
                         "for %d time, PWM is %d",
                         dev.temp_top1, dev.temp_chip_top, 0x50, 0x6e,
                         (uint)gMinerStatus_High_Temp_Counter,
                         (uint)dev.pwm_percent);
                _applog(3, tmp42, false);
                puVar13 = (uint8_t *)iVar3;
            }
        } else {
            gMinerStatus_High_Temp = true;
            if ((status_error == false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (2 < opt_log_level)))) {
                snprintf(tmp42, 0x1000,
                         "%s: the temperature pcb:%d/chip:%d is too high, "
                         "close PIC and need reboot!!!",
                         "check_miner_status", dev.temp_top1,
                         dev.temp_chip_top);
                _applog(3, tmp42, false);
            }
        }
    }
    iVar10 = tv_send.tv_sec - tv_send_job.tv_sec;
    if (tv_send.tv_usec - tv_send_job.tv_usec < 0) {
        iVar10 = iVar10 + -1;
    }
    if (iVar10 < 0x79) {
        gMinerStatus_Lost_connection_to_pool = false;
    } else {
        gMinerStatus_Lost_connection_to_pool = true;
        if (((status_error == false) && (opt_debug != false)) &&
            ((use_syslog != false ||
              ((opt_log_output != false || (6 < opt_log_level)))))) {
            snprintf(tmp42, 0x1000,
                     "%s: We have lost internet for %d seconds, so don\'t send "
                     "work to hashboard anymore",
                     "check_miner_status", iVar10);
            _applog(7, tmp42, false);
        }
    }
    if ((int)(dev.fan_exist_map << 0x1f) < 0) {
        uVar5 = dev.fan_exist_map & 2;
        puVar7 = (uint8_t *)0x0;
        puVar11 = (uint8_t *)0x1;
    joined_r0x0003b980:
        if (uVar5 == 0) {
            puVar13 = (uint8_t *)0x1;
            goto LAB_0003b20a;
        }
        if (1 < dev.fan_num) {
            puVar19 = (uint8_t *)0x1;
            goto LAB_0003b2ec;
        }
        puVar17 = (uint8_t *)0x1;
        puVar19 = puVar17;
        puVar21 = puVar17;
    LAB_0003b3e6:
        fan_error_num = fan_error_num + 1;
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42, 0x1000,
                     "ret:%d [%d:%d]fan_error_num:%d fan_num %d fan_pwm %d "
                     "fan1_speed_value %d fan2_speed_value %d",
                     puVar17, puVar21, puVar19, fan_error_num,
                     (uint)dev.fan_num, (uint)dev.fan_pwm,
                     dev.fan_speed_value[(int)puVar7],
                     dev.fan_speed_value[(int)puVar11]);
            _applog(7, tmp42, false);
            puVar7 = extraout_r2;
        }
        if (fan_error_num < 0x15)
            goto LAB_0003b282;
        gFan_Error = true;
        bVar23 = (int)(dev.fan_exist_map << 0x1f) < 0;
        if (bVar23) {
            puVar7 = (uint8_t *)0x1;
            puVar13 = (uint8_t *)(dev.fan_exist_map & 2);
        }
        puVar19 = (uint8_t *)(uint)!bVar23;
        puVar11 = puVar19;
        if (bVar23) {
        LAB_0003b490:
            if (puVar13 == (uint8_t *)0x0)
                goto LAB_0003b492;
        } else {
            do {
                puVar7 = puVar11 + 1;
                if (((int)puVar19 << ((uint)puVar11 & 0xff) &
                     dev.fan_exist_map) != 0) {
                    puVar13 = puVar19;
                    if (puVar7 == (uint8_t *)0x20)
                        goto LAB_0003b4a4;
                    puVar13 =
                        (uint8_t *)((int)puVar19 << ((uint)puVar7 & 0xff) &
                                    dev.fan_exist_map);
                    goto LAB_0003b490;
                }
                puVar11 = puVar7;
            } while (puVar7 != (uint8_t *)0x20);
            puVar11 = (uint8_t *)0xffffffff;
            puVar7 = (uint8_t *)0x0;
        LAB_0003b492:
            puVar13 = (uint8_t *)0x1;
            do {
                puVar7 = puVar7 + 1;
                if (puVar7 == (uint8_t *)0x20)
                    goto LAB_0003b4a4;
            } while ((1 << ((uint)puVar7 & 0xff) & dev.fan_exist_map) == 0);
        }
        goto LAB_0003b4a8;
    }
    puVar7 = (uint8_t *)0x1;
    do {
        puVar11 = puVar7 + 1;
        puVar13 = (uint8_t *)(1 << ((uint)puVar7 & 0xff) & dev.fan_exist_map);
        if (puVar13 != (uint8_t *)0x0) {
            if (puVar11 != (uint8_t *)0x20) {
                uVar5 = 1 << ((uint)puVar11 & 0xff) & dev.fan_exist_map;
                goto joined_r0x0003b980;
            }
            if (1 < dev.fan_num) {
                puVar11 = (uint8_t *)0xffffffff;
                puVar19 = (uint8_t *)0x0;
                goto LAB_0003b2ec;
            }
            puVar21 = (uint8_t *)0x1;
            puVar11 = (uint8_t *)0xffffffff;
            puVar17 = (uint8_t *)0x1;
            puVar19 = (uint8_t *)0x0;
            goto LAB_0003b3e6;
        }
        puVar7 = puVar11;
    } while (puVar11 != (uint8_t *)0x20);
    puVar7 = (uint8_t *)0xffffffff;
    puVar11 = (uint8_t *)0x0;
LAB_0003b20a:
    do {
        puVar11 = puVar11 + 1;
        if (puVar11 == (uint8_t *)0x20) {
            puVar11 = (uint8_t *)0xffffffff;
            puVar19 = (uint8_t *)0x0;
            goto joined_r0x0003b224;
        }
    } while ((1 << ((uint)puVar11 & 0xff) & dev.fan_exist_map) == 0);
    puVar19 = (uint8_t *)0x1;
joined_r0x0003b224:
    puVar21 = puVar13;
    if (dev.fan_num < 2) {
        puVar17 = (uint8_t *)0x1;
        goto LAB_0003b3e6;
    }
    if (puVar13 != (uint8_t *)0x0) {
    LAB_0003b2ec:
        puVar13 = (uint8_t *)(uint)dev.fan_pwm;
        if (dev.fan_speed_value[(int)puVar7] <
            (uint)((int)puVar13 * 6000) / 0x82) {
            puVar17 = (uint8_t *)0x2;
            puVar21 = (uint8_t *)0x1;
        } else {
            puVar13 = (uint8_t *)(uint)dev.pwm_percent;
            puVar21 = (uint8_t *)(uint)(puVar13 == (uint8_t *)0x64);
            if (0x12bf < dev.fan_speed_value[(int)puVar7]) {
                puVar21 = (uint8_t *)0x0;
            }
            if (puVar21 == (uint8_t *)0x0) {
                puVar21 = (uint8_t *)0x1;
                goto LAB_0003b22e;
            }
        LAB_0003ba86:
            puVar17 = (uint8_t *)0x4;
        }
        goto LAB_0003b3e6;
    }
LAB_0003b22e:
    if (puVar19 != (uint8_t *)0x0) {
        if (dev.fan_speed_value[(int)puVar11] <
            ((uint)dev.fan_pwm * 0x10cc) / 0x82) {
            puVar17 = (uint8_t *)0x3;
            goto LAB_0003b3e6;
        }
        puVar19 = (uint8_t *)(uint)(dev.pwm_percent == 'd');
        if (0xd6f < dev.fan_speed_value[(int)puVar11]) {
            puVar19 = (uint8_t *)0x0;
        }
        if (puVar19 != (uint8_t *)0x0)
            goto LAB_0003ba86;
    }
    fan_error_num = 0;
LAB_0003b282:
    gFan_Error = false;
    goto LAB_0003b288;
LAB_0003b4a4:
    puVar7 = (uint8_t *)0xffffffff;
LAB_0003b4a8:
    if (puVar17 == (uint8_t *)0x3) {
        if ((status_error == false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (2 < opt_log_level)))) {
            __format = "Fan Err! Disable PIC! Fan2 speed is too low %d pwm %d ";
        LAB_0003b9e0:
            snprintf(tmp42, 0x1000, __format, dev.fan_speed_value[(int)puVar7],
                     (uint)dev.pwm_percent);
            _applog(3, tmp42, false);
        }
    } else if (puVar17 == (uint8_t *)0x4) {
        if ((status_error == false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (2 < opt_log_level)))) {
            puVar13 = (uint8_t *)dev.fan_speed_value[(int)puVar7];
            snprintf(tmp42, 0x1000,
                     "Fan Err! Disable PIC! Fan1:%d Fan2:%d pwm %d",
                     dev.fan_speed_value[(int)puVar11], puVar13,
                     (uint)dev.pwm_percent);
            _applog(3, tmp42, false);
        }
    } else if (puVar17 == (uint8_t *)0x2) {
        if ((status_error == false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (2 < opt_log_level)))) {
            __format = "Fan Err! Disable PIC! Fan1 speed is too low %d pwm %d ";
            puVar7 = puVar11;
            goto LAB_0003b9e0;
        }
    } else if ((status_error == false) &&
               (((use_syslog != false || (opt_log_output != false)) ||
                 (2 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "Fan Err! Disable PIC! Fan num is %d",
                 (uint)dev.fan_num);
        _applog(3, tmp42, false);
    }
LAB_0003b288:
    if (certification_firmware == false) {
        if ((gMinerStatus_Low_Hashrate != false) ||
            (gMinerStatus_Lost_connection_to_pool != false))
            goto LAB_0003b344;
    LAB_0003b29e:
        if ((gMinerStatus_High_Temp == false) && (gFan_Error == false)) {
            if (gMinerStatus_Not_read_all_sensor == false) {
                stop = false;
                status_error = false;
                _Var4 = once_error;
                if (once_error != false) {
                    stop = true;
                    status_error = true;
                }
                goto LAB_0003b2cc;
            }
            stop = true;
            _Var4 = stop;
            if (once_error == false)
                goto LAB_0003b2cc;
        } else if (once_error == false) {
        LAB_0003b558:
            stop = true;
            status_error = true;
            puVar13 = (uint8_t *)0x0;
            once_error = true;
            puVar7 = dev.chain_exist;
            uVar1 = dev.chain_exist[0];
            while (true) {
                puVar7 = puVar7 + 1;
                if (uVar1 == '\x01') {
                    pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
                    i2c_slave_addr = (int)puVar13;
                    disable_PIC16F1704_dc_dc_new();
                    cgsleep_ms(100);
                    pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
                }
                puVar13 = puVar13 + 1;
                _Var4 = stop;
                if (puVar13 == (uint8_t *)0x4)
                    break;
                uVar1 = *puVar7;
            }
            goto LAB_0003b2cc;
        }
    } else {
        gMinerStatus_Lost_connection_to_pool = false;
        if (gMinerStatus_Low_Hashrate == false)
            goto LAB_0003b29e;
    LAB_0003b344:
        stop = true;
        if (once_error == false) {
            if ((gMinerStatus_High_Temp == false) &&
                (_Var4 = stop, gFan_Error == false))
                goto LAB_0003b2cc;
            goto LAB_0003b558;
        }
    }
    stop = true;
    _Var4 = true;
LAB_0003b2cc:
    set_led(_Var4);
    cgsleep_ms(1000);
    goto LAB_0003b10c;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention */

int get_fan_speed(uchar *fan_id, uint *fan_speed)

{
    uint uVar1;
    uint data;

    uVar1 = axi_fpga_addr[1];
    *fan_speed = uVar1 & 0xff;
    *fan_id = (byte)((uVar1 << 0x15) >> 0x1d);
    return uVar1;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void fan_power_on(void)

{
    system("echo 1 > /sys/class/gpio/gpio954/value");
    system("echo 1 > /sys/class/gpio/gpio955/value");
    return;
}

/* WARNING: Variable defined which should be unmapped: data */
/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void check_fan_speed(void)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    char tmp42[4096];
    uint data;

    dev.fan_speed_top1 = 0;
    dev.fan_speed_low1 = 0;
    do {
        iVar4 = 6;
        do {
            uVar2 = axi_fpga_addr[1];
            if (uVar2 != 0xffffffff) {
                uVar3 = (uVar2 << 0x15) >> 0x1d;
                uVar1 = (uVar2 & 0xff) * 0x78;
                dev.fan_speed_value[uVar3] = uVar1;
                if ((uVar2 & 0xff) == 0) {
                    if (dev.fan_exist[uVar3] == '\x01') {
                        dev.fan_exist[uVar3] = (uint8_t)uVar2;
                        dev.fan_num = dev.fan_num + 0xff;
                        dev.fan_exist_map = 0;
                    }
                LAB_0003bb90:
                    if (dev.fan_speed_low1 != 0)
                        goto LAB_0003bb96;
                } else {
                    if (dev.fan_exist[uVar3] == '\0') {
                        dev.fan_exist[uVar3] = '\x01';
                        dev.fan_exist_map = dev.fan_exist_map | 1 << uVar3;
                        dev.fan_num = dev.fan_num + '\x01';
                    }
                    if (dev.fan_speed_top1 <= uVar1 &&
                        uVar1 - dev.fan_speed_top1 != 0) {
                        dev.fan_speed_top1 = uVar1;
                    }
                    if (uVar1 == 0 || dev.fan_speed_low1 <= uVar1)
                        goto LAB_0003bb90;
                }
                dev.fan_speed_low1 = uVar1;
            }
        LAB_0003bb96:
            cgsleep_ms(0x32);
            iVar4 = iVar4 + -1;
        } while (iVar4 != 0);
        if (1 < dev.fan_num) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "fan-num %d fan-map %d\n",
                         (uint)dev.fan_num, dev.fan_exist_map);
                _applog(5, tmp42, false);
            }
            return;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "No %d Fan find, check again", 2);
            _applog(5, tmp42, false);
        }
        cgsleep_ms(1000);
    } while (true);
}

/* WARNING: Unknown calling convention */

void set_PWM(uchar pwm_percent)

{
    uint *puVar1;
    uint uVar2;

    puVar1 = axi_fpga_addr;
    uVar2 = (uint)pwm_percent;
    if (uVar2 < 0x28) {
        uVar2 = 0x28;
    } else if (100 < uVar2) {
        uVar2 = 0x640000;
        dev.pwm_percent = 'd';
        goto LAB_0003bc9a;
    }
    if (gMinerStatus_Not_read_all_sensor) {
        uVar2 = 0x640000;
        dev.pwm_percent = 'd';
    } else {
        dev.pwm_percent = (uint8_t)uVar2;
        uVar2 = 100 - uVar2 | uVar2 << 0x10;
    }
LAB_0003bc9a:
    axi_fpga_addr[0x21] = uVar2;
    puVar1[0x28] = uVar2;
    return;
}

/* WARNING: Unknown calling convention */

float adjust_pwm_bm1744_4chips(int temp)

{
    float fVar1;

    if (temp - 0x23U < 7) {
        return (float)(longlong)(int)(temp - 0x23U) * 1.4285715 + 40.0;
    }
    if (temp - 0x2aU < 7) {
        return (float)(longlong)(int)(temp - 0x2aU) * 1.4285715 + 50.0;
    }
    if (temp - 0x31U < 6) {
        return (float)(longlong)(int)(temp - 0x31U) * 3.3333333 + 60.0;
    }
    if (7 < temp - 0x37U) {
        fVar1 = 40.0;
        if (0x22 < temp) {
            fVar1 = 100.0;
        }
        return fVar1;
    }
    return (float)(longlong)(int)(temp - 0x37U) * 2.5 + 80.0;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void set_PWM_according_to_temperature(void)

{
    uint *puVar1;
    int extraout_r1;
    int iVar2;
    uint uVar3;
    uint uVar4;
    float fVar5;
    char tmp42[4096];

    puVar1 = axi_fpga_addr;
    temp_highest = dev.temp_top1;
    if ((dev.fan_eft != '\0') && (uVar4 = (uint)dev.fan_pwm, uVar4 < 0x65)) {
        if (gMinerStatus_Not_read_all_sensor) {
            uVar3 = 0x640000;
            uVar4 = 100;
        } else {
            if (uVar4 < 0x28) {
                uVar4 = 0x28;
            }
            uVar3 = 100 - uVar4 | uVar4 << 0x10;
        }
        dev.pwm_percent = (uint8_t)uVar4;
        axi_fpga_addr[0x21] = uVar3;
        puVar1[0x28] = uVar3;
        return;
    }
    if (0x3e < dev.temp_top1 || dev.temp_top1 == 0) {
        dev.pwm_percent = 'd';
        axi_fpga_addr[0x21] = 0x640000;
        puVar1[0x28] = 0x640000;
        dev.fan_pwm = 'd';
        return;
    }
    if (dev.temp_top1 < 0x24) {
        uVar4 = 0x28003c;
        if (gMinerStatus_Not_read_all_sensor) {
            uVar4 = 0x640000;
            dev.pwm_percent = 'd';
        } else {
            dev.pwm_percent = '(';
        }
        axi_fpga_addr[0x21] = uVar4;
        puVar1[0x28] = uVar4;
        dev.fan_pwm = '(';
        return;
    }
    if ((dev.temp_top1 - last_temperature) + 1U < 3) {
        return;
    }
    fVar5 = adjust_pwm_bm1744_4chips(dev.temp_top1);
    uVar4 = (uint)fVar5;
    if ((int)uVar4 < 0) {
        dev.fan_pwm = '\0';
        iVar2 = extraout_r1;
        if (opt_debug != false) {
            uVar4 = 0;
            uVar3 = 0;
            goto LAB_0003be92;
        }
    LAB_0003bede:
        uVar3 = 0x28;
    LAB_0003bee0:
        if (gMinerStatus_Not_read_all_sensor == false) {
            dev.pwm_percent = (uint8_t)uVar3;
            uVar4 = 100 - uVar3 | uVar3 << 0x10;
            goto LAB_0003be60;
        }
    } else {
        dev.fan_pwm = (uint8_t)uVar4;
        uVar3 = uVar4 & 0xff;
        iVar2 = extraout_r1;
        if (opt_debug != false) {
        LAB_0003be92:
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (iVar2 = extraout_r1, 6 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "%s: Set PWM percent : %d",
                         "set_PWM_according_to_temperature", uVar4);
                _applog(7, tmp42, false);
                iVar2 = temp_highest;
            }
        }
        if (uVar3 < 0x28)
            goto LAB_0003bede;
        if (uVar3 < 0x65)
            goto LAB_0003bee0;
    }
    uVar4 = 0x640000;
    dev.pwm_percent = 'd';
LAB_0003be60:
    puVar1 = axi_fpga_addr;
    last_temperature = iVar2;
    axi_fpga_addr[0x21] = uVar4;
    puVar1[0x28] = uVar4;
    return;
}

/* WARNING: Unknown calling convention */

void enable_read_temperature_from_asic_chain(uint which_chain)

{
    uint uVar1;
    uint8_t *puVar2;
    uint in_stack_ffffefd4;
    uint8_t cmd[11];
    char tmp42[4096];
    uchar *puVar3;

    uVar1 = default_misc_reg | 0x4060;
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    default_misc_reg = uVar1;
    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    if (dev.chain_exist[which_chain] == '\x01') {
        if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
            in_stack_ffffefd4 = which_chain;
            snprintf(tmp42, 0x1000, "%s: reg_value=0x%08x chainid %u",
                     "enable_read_temperature_from_asic_chain", uVar1);
            _applog(5, tmp42, false);
        }
        puVar3 = TempChipAddr;
        do {
            puVar2 = puVar3 + 1;
            bm1740_makeup_set_config_cmd(cmd, 0, *puVar3, '\x1c',
                                         (uint8_t)uVar1, in_stack_ffffefd4);
            uart_send((uchar)which_chain, cmd, 0xb);
            cgsleep_ms(0x32);
            puVar3 = puVar2;
        } while (puVar2 != TempChipAddr + 3);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void enable_read_temperature_from_asic(void)

{
    enable_read_temperature_from_asic_chain(0);
    enable_read_temperature_from_asic_chain(1);
    enable_read_temperature_from_asic_chain(2);
    enable_read_temperature_from_asic_chain(3);
    return;
}

/* WARNING: Unknown calling convention */

void select_core_to_check_temperature_chain(uint which_chain,
                                            uint32_t analog_mux_reg_value)

{
    uint8_t *puVar1;
    uint32_t in_stack_ffffefd4;
    uint8_t cmd[11];
    char tmp42[4096];
    uchar *puVar2;

    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    cmd[7] = '\0';
    cmd[8] = '\0';
    cmd[9] = '\0';
    cmd[10] = '\0';
    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s: analog_mux_reg_value = %08x",
                 "select_core_to_check_temperature_chain",
                 analog_mux_reg_value);
        _applog(5, tmp42, false);
    }
    if (dev.chain_exist[which_chain] == '\x01') {
        puVar2 = TempChipAddr;
        do {
            puVar1 = puVar2 + 1;
            bm1740_makeup_set_config_cmd(cmd, 0, *puVar2, '@',
                                         (byte)analog_mux_reg_value & 0xf8,
                                         in_stack_ffffefd4);
            uart_send((uchar)which_chain, cmd, 0xb);
            cgsleep_ms(2);
            puVar2 = puVar1;
        } while (puVar1 != TempChipAddr + 3);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void select_core_to_check_temperature(uint32_t analog_mux_reg_value)

{
    uint which_chain;
    uint uVar1;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s: analog_mux_reg_value = %08x",
                 "select_core_to_check_temperature", analog_mux_reg_value);
        _applog(5, tmp42, false);
    }
    which_chain = 0;
    do {
        uVar1 = which_chain + 1;
        select_core_to_check_temperature_chain(which_chain,
                                               analog_mux_reg_value);
        which_chain = uVar1;
    } while (uVar1 != 4);
    return;
}

/* WARNING: Unknown calling convention */

void write_i2c_reg(uchar which_chain, uchar which_sensor, uint8_t i2c_dev_addr,
                   uint8_t i2c_reg_addr, uint8_t i2c_reg_data)

{
    uint32_t in_stack_ffffffd4;
    uint8_t cmd_buf[11];

    cmd_buf[0] = '\0';
    cmd_buf[1] = '\0';
    cmd_buf[2] = '\0';
    cmd_buf[3] = '\0';
    cmd_buf[4] = '\0';
    cmd_buf[5] = '\0';
    cmd_buf[6] = '\0';
    cmd_buf[7] = '\0';
    cmd_buf[8] = '\0';
    cmd_buf[9] = '\0';
    cmd_buf[10] = '\0';
    bm1740_makeup_set_config_cmd(cmd_buf, 0, TempChipAddr[which_sensor], ' ',
                                 i2c_reg_data, in_stack_ffffffd4);
    uart_send(which_chain, cmd_buf, 0xb);
    cgsleep_ms(0x32);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void enable_sensor_extend_mode(void)

{
    uchar which_sensor;
    uchar which_chain;
    int iVar1;
    uint8_t *puVar2;

    which_chain = '\0';
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            iVar1 = 0;
            do {
                which_sensor = (uchar)iVar1;
                iVar1 = iVar1 + 1;
                write_i2c_reg(which_chain, which_sensor, 'L', '\t', '\x04');
            } while (iVar1 != 3);
        }
        which_chain = which_chain + '\x01';
        puVar2 = puVar2 + 1;
    } while (which_chain != '\x04');
    return;
}

/* WARNING: Unknown calling convention */

void reset_chain(bitmain_ZCASH_info *info, uint8_t chain)

{
    uint uVar1;
    char tmp42[4096];

    uVar1 = (uint)chain;
    if (((use_syslog) || (opt_log_output)) || (3 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s chainid %d", "reset_chain", uVar1);
        _applog(4, tmp42, false);
    }
    pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
    i2c_slave_addr = uVar1;
    disable_PIC16F1704_dc_dc_new();
    pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
    start_send[uVar1] = false;
    start_recv[uVar1] = false;
    reiniting[uVar1] = true;
    thr_info_join(info->uart_tx_t + uVar1);
    thr_info_join(info->uart_rx_t + uVar1);
    send_heart = false;
    pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
    i2c_slave_addr = uVar1;
    reset_PIC16F1704_pic_new();
    cgsleep_ms(1000);
    jump_from_loader_to_app_PIC16F1704_new();
    cgsleep_ms(1000);
    pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
    send_heart = true;
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s %d", "reset_hash_board_low", uVar1);
        _applog(5, tmp42, false);
    }
    axi_fpga_addr[0xd] = 1 << uVar1;
    cgsleep_ms(100);
    pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
    i2c_slave_addr = uVar1;
    enable_PIC16F1704_dc_dc_new();
    pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
    sleep(1);
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s %d", "reset_hash_board_high", uVar1);
        _applog(5, tmp42, false);
    }
    axi_fpga_addr[0xd] = 0;
    reiniting[uVar1] = false;
    tty_init_chain(chain, info);
    set_fpga_baud('\x1a');
    cgsleep_ms(100);
    set_baud_chain(chain, 0);
    cgsleep_ms(1000);
    set_fpga_baud('\0');
    cgsleep_ms(100);
    return;
}

/* WARNING: Unknown calling convention */

int calculate_asic_number(uint actual_asic_number)

{
    int iVar1;

    if ((actual_asic_number != 1) && (actual_asic_number != 2)) {
        if (actual_asic_number - 3 < 2) {
            return 4;
        }
        if (actual_asic_number - 5 < 4) {
            return 8;
        }
        if (actual_asic_number - 9 < 8) {
            return 0x10;
        }
        if (actual_asic_number - 0x11 < 0x10) {
            return 0x20;
        }
        if (actual_asic_number - 0x21 < 0x20) {
            return 0x40;
        }
        if (actual_asic_number - 0x41 < 0x40) {
            return 0x80;
        }
        if ((opt_debug) &&
            (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
            iVar1 = calculate_asic_number(actual_asic_number);
            return iVar1;
        }
        actual_asic_number = 0xffffffff;
    }
    return actual_asic_number;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void calculate_address_interval(void)

{
    int iVar1;
    uint uVar2;
    char tmp42[4096];

    iVar1 = calculate_asic_number(3);
    dev.addrInterval = __aeabi_idiv(0x100, iVar1);
    uVar2 = (uint)dev.addrInterval;
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s:addrInterval = %d",
                 "calculate_address_interval", uVar2);
        _applog(5, tmp42, false);
        uVar2 = (uint)dev.addrInterval;
    }
    TempChipAddr[1] = (uchar)uVar2;
    TempChipAddr[2] = (uchar)(uVar2 << 1);
    TempChipAddr[0] = '\0';
    return;
}

/* WARNING: Unknown calling convention */

int create_bitmain_scan_freq_pthread(void)

{
    int iVar1;
    int unaff_r5;
    char tmp42[4096];

    auto_freq_id = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(auto_freq_id, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x3ccad, (void *)0x0);
    if (iVar1 == 0) {
        pthread_detach(auto_freq_id->pth);
        cgsleep_ms(500);
        return unaff_r5;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s: create thread for check miner_status",
                 "create_bitmain_scan_freq_pthread");
        _applog(7, tmp42, false);
    }
    return -5;
}

/* WARNING: Unknown calling convention */

int create_bitmain_turbo_mode_monitor_pthread(void)

{
    int iVar1;
    int unaff_r5;
    char tmp42[4096];

    auto_freq_id = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(auto_freq_id, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x3a325, (void *)0x0);
    if (iVar1 == 0) {
        pthread_detach(auto_freq_id->pth);
        cgsleep_ms(500);
        return unaff_r5;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s: create thread for check miner_status",
                 "create_bitmain_turbo_mode_monitor_pthread");
        _applog(7, tmp42, false);
    }
    return -5;
}

/* WARNING: Unknown calling convention */

int every_chain_read_pic_freq_data(uchar (*freq_table)[9])

{
    int iVar1;
    uint8_t *puVar2;
    int iVar3;
    uchar buf[9];
    char tmp42[4096];

    iVar3 = 1;
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            buf[4] = '\0';
            buf[5] = '\0';
            buf[6] = '\0';
            buf[7] = '\0';
            buf[8] = '\0';
            buf[0] = '\0';
            buf[1] = '\0';
            buf[2] = '\0';
            buf[3] = '\0';
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            iVar3 = read_data_from_PIC16F1704_flash(buf, '\0', '\t');
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
            if (iVar3 == 0) {
                if (((use_syslog == false) && (opt_log_output == false)) &&
                    (opt_log_level < 5)) {
                    return 0;
                }
                snprintf(tmp42, 0x1000,
                         "chain%d pic not support flash data storage, adopt "
                         "file mode\n",
                         iVar1);
                _applog(5, tmp42, false);
                return 0;
            }
            if (0 < iVar3) {
                xxtea_decode((uint32_t *)(buf + 1), 2, sec_key[iVar1]);
                *(undefined4 *)freq_table[iVar1] = buf._0_4_;
                *(undefined4 *)(freq_table[iVar1] + 4) = buf._4_4_;
                freq_table[iVar1][8] = buf[8];
            }
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
        if (iVar1 == 4) {
            return iVar3;
        }
    } while (true);
}

/* WARNING: Unknown calling convention */

int every_chain_write_freq_to_pic(uchar (*freq_table)[9])

{
    int iVar1;
    uint8_t *puVar2;
    int iVar3;

    iVar3 = 1;
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            iVar3 = write_data_to_PIC16F1704_flash(freq_table[iVar1], 0, 9);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    return iVar3;
}

/* WARNING: Unknown calling convention */

int clear_every_chain_freq_to_pic(void)

{
    int iVar1;
    uint8_t *puVar2;
    int iVar3;
    uchar freq_table[4][9];

    iVar3 = 1;
    iVar1 = 0;
    memset(freq_table, 0, 0x24);
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            pthread_mutex_lock((pthread_mutex_t *)&iic_mutex);
            i2c_slave_addr = iVar1;
            iVar3 = write_data_to_PIC16F1704_flash(freq_table[iVar1], 0, 9);
            cgsleep_ms(100);
            pthread_mutex_unlock((pthread_mutex_t *)&iic_mutex);
        }
        iVar1 = iVar1 + 1;
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    return iVar3;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void scan_freq_init_freq(void)

{
    FILE *__stream;
    int iVar1;
    uint8_t *puVar2;
    char *pcVar3;
    uint32_t(*pauVar4)[3];
    int iVar5;
    uint uVar6;
    int iVar7;
    uchar *puVar8;
    uchar freq_table[4][9];
    char tmp42[4096];

    freq_table[0][0] = '\0';
    freq_table[0][1] = '\0';
    freq_table[0][2] = '\0';
    freq_table[0][3] = '\0';
    freq_table[0][4] = '\0';
    freq_table[0][5] = '\0';
    freq_table[0][6] = '\0';
    freq_table[0][7] = '\0';
    freq_table[0][8] = '\0';
    freq_table[1][0] = '\0';
    freq_table[1][1] = '\0';
    freq_table[1][2] = '\0';
    every_chain_get_pic_version();
    g_scan_freq_info.scan_freq_store_pos =
        every_chain_read_pic_freq_data(freq_table);
    if (g_scan_freq_info.scan_freq_store_pos < 1) {
        iVar1 = access("/config/chips_freq.config", 0);
        if (iVar1 != 0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                pcVar3 = "2 Goto scan mode and find the best frequency\n";
            LAB_0003c8a0:
                tmp42._0_4_ = *(undefined4 *)pcVar3;
                tmp42._4_4_ = *(undefined4 *)(pcVar3 + 4);
                tmp42._8_4_ = *(undefined4 *)(pcVar3 + 8);
                tmp42._12_4_ = *(undefined4 *)(pcVar3 + 0xc);
                tmp42._16_4_ = *(undefined4 *)(pcVar3 + 0x10);
                tmp42._20_4_ = *(undefined4 *)(pcVar3 + 0x14);
                tmp42._24_4_ = *(undefined4 *)(pcVar3 + 0x18);
                tmp42._28_4_ = *(undefined4 *)(pcVar3 + 0x1c);
                tmp42._32_4_ = *(undefined4 *)(pcVar3 + 0x20);
                tmp42._36_4_ = *(undefined4 *)(pcVar3 + 0x24);
                tmp42._40_4_ = *(undefined4 *)(pcVar3 + 0x28);
                tmp42._44_2_ = (undefined2) * (undefined4 *)(pcVar3 + 0x2c);
                _applog(5, tmp42, false);
            }
        LAB_0003c8bc:
            create_bitmain_scan_freq_pthread();
            return;
        }
        __stream = fopen("/config/chips_freq.config", "r");
        if (__stream == (FILE *)0x0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "open %s failed\n",
                         "/config/chips_freq.config");
                _applog(5, tmp42, false);
                goto LAB_0003c9f8;
            }
        LAB_0003ca12:
            if (opt_log_level < 5)
                goto LAB_0003c866;
        } else {
            iVar1 = 0;
            puVar2 = dev.chain_exist;
            do {
                if (*puVar2 == '\x01') {
                    iVar5 = 0;
                    pcVar3 = (char *)((int)g_scan_freq_info.each_asic_freq[0] +
                                      iVar1);
                    do {
                        tmp42[0] = '\0';
                        tmp42[1] = '\0';
                        tmp42[2] = '\0';
                        tmp42[3] = '\0';
                        fscanf(__stream, "%d", tmp42);
                        if (tmp42._0_4_ - 0x307 < 0x33) {
                            if (tmp42._0_4_ == 0x307) {
                                pcVar3[0] = '\a';
                                pcVar3[1] = '\x03';
                                pcVar3[2] = '\0';
                                pcVar3[3] = '\0';
                            } else {
                                *(undefined4 *)pcVar3 = tmp42._0_4_;
                            }
                        } else {
                            pcVar3[0] = ' ';
                            pcVar3[1] = '\x03';
                            pcVar3[2] = '\0';
                            pcVar3[3] = '\0';
                        }
                        iVar5 = iVar5 + 1;
                        pcVar3 = pcVar3 + 4;
                    } while (iVar5 != 3);
                }
                iVar1 = iVar1 + 0xc;
                puVar2 = puVar2 + 1;
            } while (iVar1 != 0x30);
            fclose(__stream);
        LAB_0003c9f8:
            if ((use_syslog == false) && (opt_log_output == false))
                goto LAB_0003ca12;
        }
        pcVar3 = "2 Goto turbo mode\n";
    } else {
        iVar1 = 0;
        puVar2 = dev.chain_exist;
        do {
            if ((*puVar2 == '\x01') && (freq_table[iVar1][0] != 'N')) {
                if ((use_syslog == false) &&
                    ((opt_log_output == false && (opt_log_level < 5))))
                    goto LAB_0003c8bc;
                pcVar3 = "1 Goto scan mode and find the best frequency\n";
                goto LAB_0003c8a0;
            }
            iVar1 = iVar1 + 1;
            puVar2 = puVar2 + 1;
        } while (iVar1 != 4);
        iVar1 = 0;
        puVar2 = dev.chain_exist;
        do {
            if (*puVar2 == '\x01') {
                puVar8 = freq_table[iVar1];
                pauVar4 = g_scan_freq_info.each_asic_freq + iVar1;
                iVar5 = 0;
                do {
                    puVar8 = puVar8 + 1;
                    iVar7 = iVar5 + 1;
                    uVar6 = freq_pll[*puVar8].freq;
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        snprintf(tmp42, 0x1000,
                                 "pic read chain%d asic%d freq %d\n", iVar1,
                                 iVar5, uVar6);
                        _applog(5, tmp42, false);
                    }
                    if (0x32 < uVar6 - 0x307) {
                        (*pauVar4)[0] = 800;
                    }
                    if (uVar6 - 0x307 < 0x33) {
                        (*pauVar4)[0] = uVar6;
                    }
                    pauVar4 = (uint32_t(*)[3])(*pauVar4 + 1);
                    iVar5 = iVar7;
                } while (iVar7 != 3);
            }
            iVar1 = iVar1 + 1;
            puVar2 = puVar2 + 1;
        } while (iVar1 != 4);
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5))
            goto LAB_0003c866;
        pcVar3 = "1 Goto turbo mode\n";
    }
    tmp42._0_4_ = *(undefined4 *)pcVar3;
    tmp42._4_4_ = *(undefined4 *)(pcVar3 + 4);
    tmp42._8_4_ = *(undefined4 *)(pcVar3 + 8);
    tmp42._12_4_ = *(undefined4 *)(pcVar3 + 0xc);
    tmp42._16_3_ = (undefined3) * (undefined4 *)(pcVar3 + 0x10);
    _applog(5, tmp42, false);
LAB_0003c866:
    create_bitmain_turbo_mode_monitor_pthread();
    return;
}

/* WARNING: Unknown calling convention */

int scan_freq_save_freq(void)

{
    uint32_t uVar1;
    FILE *__stream;
    uint32_t uVar2;
    freq_pll_str *pfVar3;
    uchar uVar4;
    int iVar5;
    int iVar6;
    uint32_t(*pauVar7)[3];
    int iVar8;
    uint8_t *puVar9;
    uchar *puVar10;
    undefined4 *puVar11;
    uchar buf[4][9];
    char tmp42[4096];

    if (g_scan_freq_info.scan_freq_store_pos < 1) {
        __stream = fopen("/config/chips_freq.config", "w+");
        if (__stream != (FILE *)0x0) {
            iVar6 = 0;
            puVar9 = dev.chain_exist;
            do {
                if (*puVar9 == '\x01') {
                    puVar11 = (undefined4 *)((int)g_scan_freq_info
                                                 .each_asic_max_freq[3] +
                                             iVar6 + 8);
                    iVar8 = 3;
                    do {
                        puVar11 = puVar11 + 1;
                        fprintf(__stream, "%d ", *puVar11);
                        iVar8 = iVar8 + -1;
                    } while (iVar8 != 0);
                }
                iVar6 = iVar6 + 0xc;
                puVar9 = puVar9 + 1;
            } while (iVar6 != 0x30);
            fclose(__stream);
            return 0;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 5)) {
            iVar6 = -1;
        } else {
            snprintf(tmp42, 0x1000, "%s open %s failed\n",
                     "scan_freq_save_freq", "/config/chips_freq.config");
            _applog(5, tmp42, false);
            iVar6 = -1;
        }
    } else {
        iVar6 = 0;
        memset(buf, 0, 0x24);
        puVar9 = dev.chain_exist;
        do {
            if (*puVar9 == '\x01') {
                iVar8 = 0;
                pauVar7 = g_scan_freq_info.each_asic_freq + iVar6;
                puVar10 = buf[iVar6];
                buf[iVar6][0] = 'N';
                do {
                    if (((use_syslog == false) && (opt_log_output == false)) &&
                        (opt_log_level < 5)) {
                        uVar1 = (*pauVar7)[0];
                        if (uVar1 != 100)
                            goto LAB_0003cb7a;
                    LAB_0003cbd8:
                        uVar4 = '\0';
                    } else {
                        snprintf(tmp42, 0x1000,
                                 "pic write chain%d asic%d freq %d\n", iVar6,
                                 iVar8, (*pauVar7)[0]);
                        _applog(5, tmp42, false);
                        uVar1 = (*pauVar7)[0];
                        if (uVar1 == 100)
                            goto LAB_0003cbd8;
                    LAB_0003cb7a:
                        iVar5 = 1;
                        uVar2 = 0x7d;
                        pfVar3 = freq_pll;
                        while (uVar1 != uVar2) {
                            iVar5 = iVar5 + 1;
                            if (iVar5 == 0x77) {
                                uVar4 = 0xff;
                                goto LAB_0003cb94;
                            }
                            uVar2 = pfVar3[2].freq;
                            pfVar3 = pfVar3 + 1;
                        }
                        uVar4 = (uchar)iVar5;
                    }
                LAB_0003cb94:
                    pauVar7 = (uint32_t(*)[3])(*pauVar7 + 1);
                    iVar8 = iVar8 + 1;
                    puVar10 = puVar10 + 1;
                    *puVar10 = uVar4;
                } while (iVar8 != 3);
                xxtea_encode((uint32_t *)(buf[iVar6] + 1), 2, sec_key[iVar6]);
            }
            iVar6 = iVar6 + 1;
            puVar9 = puVar9 + 1;
        } while (iVar6 != 4);
        every_chain_write_freq_to_pic(buf);
        iVar6 = 0;
    }
    return iVar6;
}

/* WARNING: Unknown calling convention */

void *scan_freq_handle(void)

{
    undefined **ppuVar1;
    _Bool _Var2;
    int iVar3;
    undefined4 uVar4;
    freq_pll_str *pfVar5;
    uint32_t uVar6;
    scan_freq_status *psVar7;
    int iVar8;
    uint uVar9;
    scan_freq_status *psVar10;
    uint32_t uVar11;
    uint uVar12;
    uint32_t uVar13;
    uint8_t *puVar14;
    uint32_t(*pauVar15)[3];
    uint32_t(*pauVar16)[3];
    int iVar17;
    int iVar18;
    uint32_t uVar19;
    int iVar20;
    uint32_t uVar21;
    uint8_t *local_1064;
    scan_freq_status *local_1040;
    undefined *local_1034;
    undefined *local_1030;
    int *local_102c;
    char tmp42[4096];

    psVar7 = &g_scan_freq_info;
    local_1040 = &g_scan_freq_info;
    set_frequency(800);
    puVar14 = dev.chain_exist;
    do {
        while (*puVar14 == '\x01') {
            iVar3 = 3;
            psVar10 = psVar7;
            do {
                iVar3 = iVar3 + -1;
                psVar10->each_asic_invalid_nonce_each_2min[0][0] = 0;
                psVar10->each_asic_ox_status[0][0] = 0;
                psVar10->each_asic_freq[0][0] = 800;
                psVar10->each_asic_max_freq[0][0] = 0x32f;
                psVar10->each_asic_min_freq[0][0] = 0x307;
                psVar10->is_asic_scan_freq_done[0][0] = 0;
                psVar10 = (scan_freq_status *)
                              psVar10->each_asic_invalid_nonce_each_2min;
            } while (iVar3 != 0);
            psVar7 = (scan_freq_status
                          *)(psVar7->each_asic_invalid_nonce_each_2min[0] + 2);
            puVar14 = puVar14 + 1;
            if (psVar7 ==
                (scan_freq_status *)(g_scan_freq_info
                                         .each_asic_invalid_nonce_each_2min[3] +
                                     2))
                goto LAB_0003cd14;
        }
        psVar7 =
            (scan_freq_status *)(psVar7->each_asic_invalid_nonce_each_2min[0] +
                                 2);
        puVar14 = puVar14 + 1;
    } while (psVar7 !=
             (scan_freq_status *)(g_scan_freq_info
                                      .each_asic_invalid_nonce_each_2min[3] +
                                  2));
LAB_0003cd14:
    local_1034 = &DAT_00059fe0;
    iVar3 = 0;
    local_102c = &opt_log_level;
    local_1030 = &DAT_00059fdc;
    do {
        while (true) {
            do {
                iVar3 = iVar3 + 1;
                sleep(1);
                pthread_mutex_lock(
                    (pthread_mutex_t *)&each_chain_err_asic_mutex);
                pthread_cond_wait(
                    (pthread_cond_t *)&each_chain_err_asic_cond,
                    (pthread_mutex_t *)&each_chain_err_asic_mutex);
                pthread_mutex_unlock(
                    (pthread_mutex_t *)&each_chain_err_asic_mutex);
            } while (status_error != false);
            if (iVar3 != 1)
                break;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < *local_102c)) {
                builtin_strncpy(tmp42, "ignore first 2 minutes\n", 0x18);
                _applog(5, tmp42, false);
            }
        }
        iVar17 = 0;
        puVar14 = dev.chain_exist;
        do {
            if (*puVar14 == '\x01') {
                iVar18 = 0;
                pauVar15 =
                    g_scan_freq_info.each_asic_invalid_nonce_each_2min + iVar17;
                uVar13 = g_scan_freq_info.each_asic_ox_status[iVar17][0];
                uVar6 = g_scan_freq_info.each_asic_freq[iVar17][0];
                if (uVar13 != 0)
                    goto LAB_0003cf6a;
            LAB_0003ce7e:
                if (0x19 < (*pauVar15)[0])
                    goto LAB_0003cf6a;
                uVar21 = pauVar15[0x10][0];
                if (uVar21 == uVar6)
                    goto LAB_0003d0e8;
                pauVar15[0xc][0] = uVar6;
                if (uVar6 == 100) {
                    uVar6 = uVar13;
                    uVar11 = uVar13;
                    if (uVar21 != 100)
                        goto LAB_0003ceb8;
                } else {
                    uVar11 = 1;
                    uVar19 = 0x7d;
                    pfVar5 = freq_pll;
                    while (uVar6 != uVar19) {
                        uVar11 = uVar11 + 1;
                        if (uVar11 == 0x77) {
                            uVar11 = 0xffffffff;
                            uVar6 = 0xffffffff;
                            if (uVar21 == 100)
                                goto LAB_0003d070;
                            goto LAB_0003ceb8;
                        }
                        uVar19 = pfVar5[2].freq;
                        pfVar5 = pfVar5 + 1;
                    }
                    uVar6 = uVar11;
                    if (uVar21 == 100) {
                        iVar20 = 0;
                    } else {
                    LAB_0003ceb8:
                        iVar20 = 1;
                        uVar19 = 0x7d;
                        pfVar5 = freq_pll;
                        while (uVar11 = uVar6, uVar21 != uVar19) {
                            iVar20 = iVar20 + 1;
                            if (iVar20 == 0x77) {
                                iVar20 = -1;
                                break;
                            }
                            uVar19 = pfVar5[2].freq;
                            pfVar5 = pfVar5 + 1;
                        }
                    }
                    uVar6 = iVar20 - uVar11;
                    if (iVar20 - uVar11 == 1) {
                    LAB_0003d070:
                        iVar8 = uVar11 + 1;
                        iVar20 = 1;
                        goto LAB_0003cee4;
                    }
                }
                iVar20 = 1;
                iVar8 = uVar11 + (int)uVar6 / 2;
            LAB_0003cee4:
                do {
                    _Var2 = opt_debug;
                    uVar9 = freq_pll[iVar8].freq;
                    pauVar15[0x14][0] = uVar9;
                    if ((_Var2 != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < *local_102c)))) {
                        ppuVar1 = &local_1034;
                        if (iVar20 == 1) {
                            ppuVar1 = &local_1030;
                        }
                        snprintf(tmp42, 0x1000,
                                 "%s freq[%d-%d]: cur freq %d, [%d, %d], "
                                 "invalid nonce %d, ox status %d\n",
                                 *ppuVar1, iVar17, iVar18, uVar9,
                                 pauVar15[0xc][0], pauVar15[0x10][0],
                                 (*pauVar15)[0], uVar13);
                        _applog(7, tmp42, false);
                        uVar9 = pauVar15[0x14][0];
                    }
                    set_freq_asic((uchar)iVar17, (uchar)iVar18, uVar9);
                    pauVar16 = pauVar15;
                    while (true) {
                        iVar18 = iVar18 + 1;
                        pauVar15 = (uint32_t(*)[3])(*pauVar16 + 1);
                        if (iVar18 == 3)
                            goto LAB_0003cdca;
                        uVar13 = pauVar16[8][1];
                        uVar6 = pauVar16[0x14][1];
                        if (uVar13 == 0)
                            goto LAB_0003ce7e;
                    LAB_0003cf6a:
                        uVar21 = pauVar15[0xc][0];
                        if (uVar6 != uVar21)
                            break;
                    LAB_0003d0e8:
                        pauVar15[0x18][0] = 1;
                        pauVar16 = pauVar15;
                    }
                    if (uVar6 == 100) {
                        if (uVar21 != 100) {
                            iVar20 = -1;
                            uVar9 = 0;
                            goto LAB_0003cfa6;
                        }
                        uVar12 = 0;
                        iVar20 = -1;
                        uVar9 = 0;
                    LAB_0003cfca:
                        iVar8 = uVar12 + iVar20 / 2;
                    } else {
                        iVar20 = 1;
                        uVar11 = 0x7d;
                        pfVar5 = freq_pll;
                        while (uVar6 != uVar11) {
                            iVar20 = iVar20 + 1;
                            if (iVar20 == 0x77) {
                                if (uVar21 != 100) {
                                    iVar20 = -2;
                                    uVar9 = 0;
                                    goto LAB_0003cfa6;
                                }
                                uVar12 = 0;
                                iVar20 = -2;
                                uVar9 = uVar12;
                                goto LAB_0003cfca;
                            }
                            uVar11 = pfVar5[2].freq;
                            pfVar5 = pfVar5 + 1;
                        }
                        iVar20 = iVar20 + -1;
                        uVar9 = freq_pll[iVar20].freq;
                        if (uVar21 == 100) {
                            uVar12 = 0;
                        } else {
                        LAB_0003cfa6:
                            uVar12 = 1;
                            uVar6 = 0x7d;
                            pfVar5 = freq_pll;
                            while (uVar6 != uVar21) {
                                uVar12 = uVar12 + 1;
                                if (uVar12 == 0x77) {
                                    iVar20 = iVar20 + 1;
                                    uVar12 = 0xffffffff;
                                    goto LAB_0003cfc2;
                                }
                                uVar6 = pfVar5[2].freq;
                                pfVar5 = pfVar5 + 1;
                            }
                            iVar20 = iVar20 - uVar12;
                        }
                    LAB_0003cfc2:
                        if (iVar20 != 1)
                            goto LAB_0003cfca;
                        iVar8 = uVar12 + 1;
                    }
                    iVar20 = -1;
                    pauVar15[0x10][0] = uVar9;
                } while (true);
            }
        LAB_0003cdca:
            iVar17 = iVar17 + 1;
            puVar14 = puVar14 + 1;
        } while (iVar17 != 4);
        iVar20 = 0;
        iVar18 = 0;
        iVar17 = 0;
        local_1064 = dev.chain_exist;
        psVar7 = local_1040;
        do {
            if (*local_1064 == '\x01') {
                uVar13 = psVar7->each_asic_freq[0][0];
                uVar6 = psVar7->each_asic_freq[0][1];
                uVar21 = psVar7->each_asic_freq[0][2];
                iVar20 = iVar20 + uVar13 + uVar6 + uVar21;
                iVar18 = iVar18 + psVar7->is_asic_scan_freq_done[0][0] +
                         psVar7->is_asic_scan_freq_done[0][1] +
                         psVar7->is_asic_scan_freq_done[0][2];
                if ((opt_debug != false) &&
                    (((use_syslog != false || (opt_log_output != false)) ||
                      (6 < *local_102c)))) {
                    snprintf(tmp42, 0x1000, "chain%d %d %d %d\n", iVar17,
                             uVar13, uVar6, uVar21);
                    _applog(7, tmp42, false);
                }
            }
            iVar17 = iVar17 + 1;
            psVar7 = (scan_freq_status
                          *)(psVar7->each_asic_invalid_nonce_each_2min[0] + 2);
            local_1064 = local_1064 + 1;
        } while (iVar17 != 4);
        if ((uint)dev.chain_num * 3 == iVar18) {
            scan_freq_save_freq();
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < *local_102c)) {
                uVar4 = __aeabi_idiv(iVar20, iVar18);
                snprintf(tmp42, 0x1000,
                         "scan freq done, avg freq %d max %d, reboot cgminer\n",
                         uVar4, 0x32f);
                _applog(5, tmp42, false);
            }
            system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
        }
    } while (true);
}

/* WARNING: Unknown calling convention */

void *bitmain_ZCASH_reinit_chain(void *usrdata)

{
    byte chain;
    pthread_t __th;
    void *pvVar1;
    void *extraout_r0;
    uint which_chain;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s Begin\n", "bitmain_ZCASH_reinit_chain");
        _applog(5, tmp42, false);
    }
    __th = pthread_self();
    pthread_detach(__th);
    pthread_mutex_lock((pthread_mutex_t *)&reinit_mutex);
    chain = *(byte *)((int)usrdata + 4);
    which_chain = (uint)chain;
    /* WARNING: Load size is inaccurate */
    reset_chain(*usrdata, chain);
    software_set_address_chain(which_chain);
    cgsleep_ms(100);
    set_frequency_chain(chain, (uint)dev.freq[which_chain]);
    cgsleep_ms(100);
    set_core_timeout_chain(chain, 80000);
    cgsleep_ms(100);
    set_ticket_mask_chain(chain, default_ticket_mask_reg);
    cgsleep_ms(100);
    enable_read_temperature_from_asic_chain(which_chain);
    start_send[which_chain] = true;
    sleep(1);
    pvVar1 = (void *)pthread_mutex_unlock((pthread_mutex_t *)&reinit_mutex);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return pvVar1;
    }
    snprintf(tmp42, 0x1000, "%s Done\n", "bitmain_ZCASH_reinit_chain");
    _applog(5, tmp42, false);
    return extraout_r0;
}

void suffix_string_ZCASH(uint64_t val, char *buf, size_t bufsiz, int sigdigits,
                         _Bool display)

{
    uint uVar1;
    int iVar2;
    bool bVar3;
    double dVar4;
    undefined4 uVar5;
    char suffix[2];

    iVar2 = (int)(val >> 0x20);
    uVar1 = (uint)val;
    bVar3 = iVar2 == 0;
    suffix[0] = '\0';
    suffix[1] = '\0';
    if (iVar2 == 0) {
        bVar3 = uVar1 < 1000000000;
    }
    if (bVar3) {
        bVar3 = iVar2 == 0;
        if (iVar2 == 0) {
            bVar3 = uVar1 < 1000000;
        }
        if (bVar3) {
            dVar4 = (double)(longlong)(int)uVar1;
            if (iVar2 == 0 && uVar1 < 1000) {
                if (sigdigits == 0) {
                    snprintf(buf, bufsiz, "%d%s", uVar1, suffix);
                    return;
                }
                goto LAB_0003d2ec;
            }
            suffix[0] = 'K';
            suffix[1] = '\0';
        } else {
            iVar2 = __aeabi_uldivmod(uVar1, iVar2, 1000, 0);
            dVar4 = (double)(longlong)iVar2;
            suffix[0] = 'M';
            suffix[1] = '\0';
        }
    } else {
        __aeabi_uldivmod(uVar1, iVar2, 1000000, 0);
        dVar4 = (double)__floatundidf();
        suffix[0] = 'G';
        suffix[1] = '\0';
    }
    dVar4 = dVar4 / 1000.0;
    if (sigdigits == 0) {
        snprintf(buf, bufsiz, "%.3g%s", suffix, dVar4, suffix);
        return;
    }
LAB_0003d2ec:
    if (0.0 < dVar4) {
        dVar4 = log10(dVar4);
        dVar4 = floor(dVar4);
        uVar5 =
            (undefined4)(longlong)((double)(longlong)(sigdigits + -1) - dVar4);
    } else {
        uVar5 = (undefined4)(longlong)(double)(longlong)(sigdigits + -1);
    }
    if (display) {
        snprintf(buf, bufsiz, "%*.*f%s", sigdigits + 1, uVar5);
        return;
    }
    snprintf(buf, bufsiz, "%*.*f", sigdigits + 1, uVar5);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void calculate_hash_rate(void)

{
    uchar uVar1;
    int iVar2;
    uint uVar3;
    int iVar4;
    char cVar5;
    uint64_t *puVar6;
    uint8_t *puVar7;
    bool bVar8;
    uint local_1058;
    int local_1054;
    uint local_104c;
    int local_1048;
    char tmp42[4096];

    puVar6 = rate;
    iVar2 = 0;
    local_104c = 0;
    local_1048 = 0;
    puVar7 = dev.chain_exist;
    do {
        if (*puVar7 != '\0') {
            if (g_HASH_RATE_reg_value_num[iVar2] == 0) {
                uVar1 = rate_error[iVar2];
                rate_error[iVar2] = uVar1 + 1;
                if ((3 < (byte)(uVar1 + 1)) || (status_error != false)) {
                    *(uint *)puVar6 = 0;
                    *(uint *)((int)puVar6 + 4) = 0;
                    suffix_string_ZCASH(0, displayed_rate[iVar2], 0x10, 6,
                                        true);
                }
            } else {
                if (g_HASH_RATE_reg_value_num[iVar2] < 3) {
                    iVar4 = 0;
                    do {
                        if ((((g_HASH_RATE_reg_value_from_which_asic[iVar2]
                                                                    [0] ==
                               false) &&
                              (status_error == false)) &&
                             (opt_debug != false)) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            snprintf(tmp42, 0x1000,
                                     "%s: Chain%d ASIC%d didn\'t send back "
                                     "HASH_RATE register value",
                                     "calculate_hash_rate", iVar2, iVar4);
                            _applog(7, tmp42, false);
                        }
                        iVar4 = iVar4 + 1;
                    } while (iVar4 != 3);
                    uVar1 = rate_error[iVar2];
                    rate_error[iVar2] = uVar1 + 1;
                    if ((3 < (byte)(uVar1 + 1)) || (status_error != false)) {
                        *(uint *)puVar6 = 0;
                        *(uint *)((int)puVar6 + 4) = 0;
                        suffix_string_ZCASH(0, displayed_rate[iVar2], 0x10, 6,
                                            true);
                    }
                } else if (is_rt == false) {
                    local_1058 = 0;
                    local_1054 = 0;
                    iVar4 = 0;
                    cVar5 = opt_debug;
                    do {
                        uVar3 =
                            g_HASH_RATE_reg_value[iVar2][iVar4] & 0x7fffffff;
                        bVar8 = CARRY4(local_1058, uVar3);
                        local_1058 = local_1058 + uVar3;
                        local_1054 = local_1054 + (uint)bVar8;
                        if ((cVar5 != '\0') && (((use_syslog != false ||
                                                  (opt_log_output != false)) ||
                                                 (6 < opt_log_level)))) {
                            snprintf(tmp42, 0x1000,
                                     "%s: avg g_HASH_RATE_reg_value[%d][%d] = "
                                     "0x%08x",
                                     "calculate_hash_rate", iVar2, iVar4,
                                     uVar3);
                            _applog(7, tmp42, false);
                            cVar5 = opt_debug;
                        }
                        iVar4 = iVar4 + 1;
                    } while (iVar4 != 3);
                    if ((cVar5 != '\0') &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        __floatundidf(local_1058, local_1054);
                        snprintf(tmp42, 0x1000,
                                 "%s: chain%d avg hash rate is %0.2fGHz/s",
                                 "calculate_hash_rate", iVar2);
                        _applog(7, tmp42, false);
                    }
                    rate_error[iVar2] = '\0';
                } else {
                    iVar4 = 0;
                    local_1058 = 0;
                    local_1054 = 0;
                    cVar5 = opt_debug;
                    do {
                        uVar3 =
                            g_HASH_RATE_reg_value[iVar2][iVar4] & 0x7fffffff;
                        bVar8 = CARRY4(local_1058, uVar3);
                        local_1058 = local_1058 + uVar3;
                        local_1054 = local_1054 + (uint)bVar8;
                        if ((cVar5 != '\0') && (((use_syslog != false ||
                                                  (opt_log_output != false)) ||
                                                 (6 < opt_log_level)))) {
                            snprintf(
                                tmp42, 0x1000,
                                "%s: RT g_HASH_RATE_reg_value[%d][%d] = 0x%08x",
                                "calculate_hash_rate", iVar2, iVar4, uVar3);
                            _applog(7, tmp42, false);
                            cVar5 = opt_debug;
                        }
                        iVar4 = iVar4 + 1;
                    } while (iVar4 != 3);
                    if ((cVar5 != '\0') &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        __floatundidf(local_1058, local_1054);
                        snprintf(tmp42, 0x1000,
                                 "%s: chain%d RT hash rate is %0.2fGHz/s",
                                 "calculate_hash_rate", iVar2);
                        _applog(7, tmp42, false);
                    }
                    iVar4 = local_1054 +
                            ((((local_1054 * 0x20 | local_1058 >> 0x1b) -
                               local_1054) -
                              (uint)(local_1058 * 0x20 < local_1058)) *
                                 0x200 |
                             local_1058 * 0x1f >> 0x17) +
                            (uint)CARRY4(local_1058 * 0x3e00, local_1058);
                    *(uint *)puVar6 = local_1058 * 1000000;
                    uVar3 =
                        (((iVar4 * 0x40 | local_1058 * 0x3e01 >> 0x1a) -
                          iVar4) -
                         (uint)(local_1058 * 0xf8040 < local_1058 * 0x3e01)) +
                        local_1054 +
                        (uint)CARRY4(local_1058 * 999999, local_1058);
                    *(uint *)((int)puVar6 + 4) = uVar3;
                    rate_error[iVar2] = '\0';
                    suffix_string_ZCASH(CONCAT44(uVar3, local_1058 * 1000000),
                                        displayed_rate[iVar2], 0x10, 6, false);
                }
                bVar8 = CARRY4(local_104c, (uint)*puVar6);
                local_104c = local_104c + (uint)*puVar6;
                local_1048 =
                    *(uint *)((int)puVar6 + 4) + local_1048 + (uint)bVar8;
            }
        }
        puVar6 = puVar6 + 1;
        iVar2 = iVar2 + 1;
        puVar7 = puVar7 + 1;
    } while (iVar2 != 4);
    suffix_string_ZCASH(CONCAT44(local_1048, local_104c), displayed_hash_rate,
                        0x10, 6, false);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void clear_register_value_buf(void)

{
    pthread_mutex_lock((pthread_mutex_t *)&reg_mutex);
    reg_fifo.p_wr = 0;
    reg_fifo.p_rd = 0;
    reg_fifo.reg_value_num = 0;
    pthread_mutex_unlock((pthread_mutex_t *)&reg_mutex);
    return;
}

/* WARNING: Unknown calling convention */

void check_asic_reg(uchar which_chain, uchar chip_addr, uchar reg, _Bool mode)

{
    uint8_t uVar1;
    byte bVar2;
    uint uVar3;
    uint32_t uVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    _Bool(*pa_Var8)[4];
    uint uVar9;
    char *__format;
    int iVar10;
    uint uVar11;
    char(*pacVar12)[4];
    int iVar13;
    uchar *puVar14;
    bool bVar15;
    uint8_t in_stack_ffffef98;
    short local_103c;
    uchar cmd_buf[7];
    char tmp42[4096];

    uVar9 = (uint)reg;
    uVar5 = (uint)which_chain;
    cmd_buf[0] = '\0';
    cmd_buf[1] = '\0';
    cmd_buf[2] = '\0';
    cmd_buf[3] = '\0';
    cmd_buf[4] = '\0';
    cmd_buf[5] = '\0';
    cmd_buf[6] = '\0';
    clear_register_value_buf();
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        uVar6 = uVar5;
        snprintf(tmp42, 0x1000,
                 "%s: check chain J%d mode %d chipaddr %02x regaddr %02x",
                 "check_asic_reg", uVar5, (uint)mode, (uint)chip_addr, uVar9);
        in_stack_ffffef98 = (uint8_t)uVar6;
        _applog(7, tmp42, false);
    }
    uVar6 = bm1740_makeup_get_status_cmd(cmd_buf, (uint)mode, chip_addr, reg,
                                         in_stack_ffffef98);
    uart_send(which_chain, cmd_buf, uVar6);
    if ((uVar9 == 0) && (update_asic_num[uVar5] != false)) {
        dev.chain_asic_num[uVar5] = reg;
    }
    iVar10 = (short)(ushort)which_chain * 4;
    iVar13 = 0;
    do {
        while (true) {
            usleep(300000);
            pthread_mutex_lock((pthread_mutex_t *)&reg_mutex);
            uVar4 = reg_fifo.reg_value_num;
            pthread_mutex_unlock((pthread_mutex_t *)&reg_mutex);
            if (uVar4 != 0)
                break;
            iVar13 = iVar13 + 1;
            usleep(100000);
            if (iVar13 == 3) {
                if (uVar9 == 0) {
                    bVar2 = dev.chain_asic_num[uVar5];
                    if ((uint)dev.max_asic_num_in_one_chain < (uint)bVar2) {
                        dev.max_asic_num_in_one_chain = bVar2;
                    }
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        snprintf(tmp42, 0x1000, "%s: chain J%d has %d ASIC",
                                 "check_asic_reg", uVar5, (uint)bVar2);
                        _applog(5, tmp42, false);
                    }
                }
                clear_register_value_buf();
                return;
            }
        }
        uVar6 = 0;
        do {
            while (true) {
                pthread_mutex_lock((pthread_mutex_t *)&reg_mutex);
                uVar7 = (uint)reg_fifo.reg_buffer[reg_fifo.p_rd].chain_id;
                if (uVar7 != uVar5)
                    break;
                uVar11 = *(uint *)reg_fifo.reg_buffer[reg_fifo.p_rd].reg_data;
                uVar1 = reg_fifo.reg_buffer[reg_fifo.p_rd].chip_addr;
                uVar7 = uVar11 >> 0x10 & 0xff;
                uVar3 = uVar11 >> 0x18;
                if (uVar9 == 0) {
                    if (update_asic_num[uVar5] == false) {
                        if (((use_syslog != false) ||
                             (opt_log_output != false)) ||
                            (4 < opt_log_level)) {
                            __format = "%s: the asic address is 0x%08x";
                            goto LAB_0003da64;
                        }
                    } else {
                        dev.chain_asic_num[uVar5] =
                            dev.chain_asic_num[uVar5] + '\x01';
                    }
                } else if (uVar9 == 0xc) {
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        __format = "%s: the asic freq is 0x%08x";
                        goto LAB_0003da64;
                    }
                } else if (uVar9 == 0x14) {
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        __format = "%s: the asic tm is 0x%08x";
                        goto LAB_0003da64;
                    }
                } else if (uVar9 == 0x1c) {
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        __format = "%s: the asic misc is 0x%08x";
                        goto LAB_0003da64;
                    }
                } else if (uVar9 == 0x20) {
                    if ((uVar11 << 0x18 & 0xc0000000) == 0) {
                        bVar2 = (byte)(uVar11 >> 0x18);
                        local_103c = bVar2 - 0x40;
                        pa_Var8 =
                            g_chip_temp_return[(short)(ushort)which_chain];
                        iVar13 = iVar10;
                        uVar11 = uVar6;
                        puVar14 = TempChipAddr;
                        do {
                            if (uVar1 == *puVar14) {
                                if (uVar7 == 0) {
                                    (*pa_Var8)[0] = true;
                                    *(short *)((int)&dev +
                                               (iVar13 - uVar5) * 8 + 0x80) =
                                        local_103c;
                                } else if (uVar7 == 1) {
                                    (*pa_Var8)[1] = true;
                                    *(short *)((int)&dev +
                                               (iVar13 - uVar5) * 8 + 0x82) =
                                        local_103c;
                                } else if (uVar7 == 0x11) {
                                    send_back_gTempOffsetValue[0][iVar13] =
                                        bVar2;
                                    (*pa_Var8)[2] = true;
                                    uVar11 = uVar3;
                                } else {
                                    bVar15 = uVar7 == 0xfe;
                                    pacVar12 = (char(*)[4])(uVar7 << 8);
                                    if (bVar15) {
                                        pacVar12 = sensor_id;
                                        uVar11 = uVar3;
                                    }
                                    if (bVar15) {
                                        (*pacVar12)[iVar13] = (char)uVar11;
                                        pacVar12 = (char(*)[4])0x1;
                                    }
                                    if (bVar15) {
                                        (*pa_Var8)[3] = SUB41(pacVar12, 0);
                                    }
                                }
                            }
                            iVar13 = iVar13 + 1;
                            pa_Var8 = pa_Var8 + 1;
                            puVar14 = puVar14 + 1;
                        } while (iVar13 != iVar10 + 3);
                    }
                } else if (uVar9 == 0x54) {
                    if (((use_syslog != false) || (opt_log_output != false)) ||
                        (4 < opt_log_level)) {
                        __format = "%s: the start nonce offset is 0x%08x";
                    LAB_0003da64:
                        snprintf(tmp42, 0x1000, __format, "check_asic_reg",
                                 uVar11 << 0x18 | (uVar11 >> 8 & 0xff) << 0x10 |
                                     uVar7 << 8 | uVar3);
                        _applog(5, tmp42, false);
                    }
                } else if ((uVar9 == 0x30) && (((use_syslog != false ||
                                                 (opt_log_output != false)) ||
                                                (4 < opt_log_level)))) {
                    __format = "%s: the asic IO strength is 0x%08x";
                    goto LAB_0003da64;
                }
                uVar6 = uVar6 + 1;
                reg_fifo.p_rd = reg_fifo.p_rd + 1;
                reg_fifo.reg_value_num = reg_fifo.reg_value_num - 1;
                if (reg_fifo.p_rd == 100) {
                    reg_fifo.p_rd = 0;
                }
                pthread_mutex_unlock((pthread_mutex_t *)&reg_mutex);
                if (uVar4 == uVar6)
                    goto LAB_0003da2a;
            }
            reg_fifo.p_rd = reg_fifo.p_rd + 1;
            if (reg_fifo.p_rd == 100) {
                reg_fifo.p_rd = 0;
            }
            reg_fifo.reg_value_num = reg_fifo.reg_value_num - 1;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000,
                         "%s: the return data is from chain%d, but it should "
                         "be from chain%d chipaddr=0x%02x reg=0x%02x\n",
                         "check_asic_reg", uVar7, uVar5, (uint)chip_addr,
                         uVar9);
                _applog(5, tmp42, false);
            }
            uVar6 = uVar6 + 1;
            pthread_mutex_unlock((pthread_mutex_t *)&reg_mutex);
        } while (uVar4 != uVar6);
    LAB_0003da2a:
        iVar13 = 0;
    } while (true);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void check_every_chain_asic_pll(void)

{
    uchar which_chain;
    uint8_t *puVar1;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "check_every_chain_asic_p", 0x18);
        tmp42[0x18] = 'l';
        tmp42[0x19] = 'l';
        tmp42[0x1a] = '\0';
        _applog(5, tmp42, false);
    }
    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            check_asic_reg(which_chain, '\0', '\f', true);
            cgsleep_ms(100);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    return;
}

/* WARNING: Unknown calling convention */

void check_chain_asic_number(uchar which_chain, _Bool whether_update_asic_num)

{
    if (dev.chain_exist[which_chain] == '\0') {
        return;
    }
    update_asic_num[which_chain] = whether_update_asic_num;
    check_asic_reg(which_chain, '\0', '\0', true);
    return;
}

/* WARNING: Unknown calling convention */

void check_every_chain_asic_number(_Bool whether_update_asic_num)

{
    int iVar1;
    uint8_t *puVar2;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "check_every_chain_asic_numbe", 0x1c);
        tmp42[0x1c] = 'r';
        tmp42[0x1d] = '\0';
        _applog(5, tmp42, false);
    }
    iVar1 = 0;
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 != '\0') {
            update_asic_num[iVar1] = whether_update_asic_num;
            check_asic_reg((uchar)iVar1, '\0', '\0', true);
        }
        iVar1 = iVar1 + 1;
        cgsleep_ms(100);
        puVar2 = puVar2 + 1;
    } while (iVar1 != 4);
    return;
}

/* WARNING: Variable defined which should be unmapped: cmd */
/* WARNING: Unknown calling convention */

void get_reg_value(uint8_t regaddr)

{
    undefined4 in_r2;
    undefined4 extraout_r2;
    undefined4 uVar1;
    undefined4 extraout_r3;
    uchar which_uart;
    uint8_t *puVar2;
    char cmd[7];

    uVar1 = 0;
    which_uart = '\0';
    cmd[0] = '\0';
    cmd[1] = '\0';
    cmd[2] = '\0';
    cmd[3] = '\0';
    cmd[4] = '\0';
    cmd[5] = '\0';
    cmd[6] = '\0';
    puVar2 = dev.chain_exist;
    do {
        if (*puVar2 == '\x01') {
            bm1740_makeup_get_status_cmd((uint8_t *)cmd, (uint)regaddr,
                                         (uint8_t)in_r2, (uint8_t)uVar1,
                                         cmd[0]);
            uart_send(which_uart, (uchar *)cmd, 7);
            cgsleep_ms(200);
            check_asic_reg(which_uart, '\0', regaddr, true);
            in_r2 = extraout_r2;
            uVar1 = extraout_r3;
        }
        which_uart = which_uart + '\x01';
        puVar2 = puVar2 + 1;
    } while (which_uart != '\x04');
    return;
}

/* WARNING: Unknown calling convention */

void read_i2c_reg(uchar which_chain, uchar which_sensor, uint8_t i2c_dev_addr,
                  uint8_t i2c_reg_addr)

{
    int iVar1;
    uint uVar2;
    byte bVar3;
    int iVar4;
    uint uVar5;
    uint32_t in_stack_ffffefcc;
    uint8_t cmd_buf[11];
    char tmp42[4096];

    uVar5 = (uint)i2c_reg_addr;
    uVar2 = (uint)which_sensor;
    cmd_buf[0] = '\0';
    cmd_buf[1] = '\0';
    cmd_buf[2] = '\0';
    cmd_buf[3] = '\0';
    cmd_buf[4] = '\0';
    cmd_buf[5] = '\0';
    cmd_buf[6] = '\0';
    cmd_buf[7] = '\0';
    cmd_buf[8] = '\0';
    cmd_buf[9] = '\0';
    cmd_buf[10] = '\0';
    cgsleep_ms(0x32);
    if ((uVar5 != 0) && (uVar5 != 1)) {
        if (uVar5 == 0x11) {
            uVar5 = 2;
        } else {
            if (uVar5 != 0xfe) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (3 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "%s unknow reg_type %d\n",
                             "read_i2c_reg", uVar5);
                    _applog(4, tmp42, false);
                }
                return;
            }
            uVar5 = 3;
        }
    }
    bm1740_makeup_set_config_cmd(cmd_buf, 0, TempChipAddr[uVar2], ' ', '\0',
                                 in_stack_ffffefcc);
    uart_send(which_chain, cmd_buf, 0xb);
    cgsleep_ms(200);
    iVar4 = 0;
    iVar1 = uVar5 + ((uint)which_chain * 3 + uVar2) * 4;
    *(undefined1 *)((int)&axi_fpga_addr + iVar1 + 0xd84) = 0;
    do {
        iVar4 = iVar4 + 1;
        cgsleep_ms(0x32);
        check_asic_reg(which_chain, TempChipAddr[uVar2], ' ', false);
        if (iVar4 == 3) {
            bVar3 = 0;
        } else {
            bVar3 = (*(byte *)((int)&axi_fpga_addr + iVar1 + 0xd84) ^ 1) & 1;
        }
    } while (bVar3 != 0);
    return;
}

/* WARNING: Unknown calling convention */

void set_temperature_offset_value_chain_sensor(uchar which_chain,
                                               uchar which_sensor)

{
    uint uVar1;
    uint uVar2;
    int iVar3;
    int iVar4;
    char tmp42[4096];

    uVar2 = (uint)which_sensor;
    uVar1 = (uint)which_chain;
    if (((use_syslog) || (opt_log_output)) || (3 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "Chain %d %s", uVar1,
                 "set_temperature_offset_value_chain_sensor");
        _applog(4, tmp42, false);
    }
    iVar3 = uVar2 + uVar1 * 4;
    write_i2c_reg(which_chain, which_sensor, 'L', '\x11',
                  *(uint8_t *)((int)&axi_fpga_addr + iVar3 + 0xdd4));
    cgsleep_ms(0x32);
    read_i2c_reg(which_chain, which_sensor, 'L', '\x11');
    iVar4 = (int)*(char *)((int)&axi_fpga_addr + iVar3 + 0xdb4);
    iVar3 = (int)*(char *)((int)&axi_fpga_addr + iVar3 + 0xdd4);
    if (iVar4 == iVar3) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "%s: Chain%d Sensor%d temp offset : %02d, ",
                     "set_temperature_offset_value_chain_sensor", uVar1, uVar2,
                     iVar4);
            _applog(5, tmp42, false);
            return;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (2 < opt_log_level)) {
        snprintf(tmp42, 0x1000,
                 "%s: Chain%d Sensor%d temp offset value set error. It should "
                 "be %02d, but read back is %02d\n",
                 "set_temperature_offset_value_chain_sensor", uVar1, uVar2,
                 iVar3, iVar4);
        _applog(3, tmp42, false);
    }
    return;
}

/* WARNING: Unknown calling convention */

void calibration_sensor_offset_chain(uchar which_chain)

{
    int iVar1;
    char cVar2;
    uint32_t *puVar3;
    char *pcVar4;
    int local_102c;
    char tmp42[4096];

    if (((use_syslog) || (opt_log_output)) || (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%d %s", (uint)which_chain,
                 "calibration_sensor_offset_chain");
        _applog(5, tmp42, false);
    }
    puVar3 =
        (uint32_t *)(dev.chain_exist + (short)(ushort)which_chain * 0x18 + -8);
    pcVar4 = gTempOffsetValue[(short)(ushort)which_chain];
    local_102c = 0;
    do {
        cVar2 = '\v';
        do {
            read_i2c_reg(which_chain, (uchar)local_102c, 'L', '\x01');
            read_i2c_reg(which_chain, (uchar)local_102c, 'L', '\0');
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "chain:%d local:%d remote:%d",
                         (uint)which_chain,
                         (int)(*(int16_t(*)[4])(puVar3 + 0x20))[0],
                         (int)*(int16_t *)((int)puVar3 + 0x82));
                _applog(5, tmp42, false);
            }
            iVar1 = (int)(*(int16_t(*)[4])(puVar3 + 0x20))[0] -
                    (int)*(int16_t *)((int)puVar3 + 0x82);
            *pcVar4 = (*pcVar4 + (char)(*(int16_t(*)[4])(puVar3 + 0x20))[0]) -
                      (char)*(int16_t *)((int)puVar3 + 0x82);
            if (iVar1 < 0) {
                iVar1 = -iVar1;
            }
            if (iVar1 < 3)
                break;
            cVar2 = cVar2 + -1;
            set_temperature_offset_value_chain_sensor(which_chain,
                                                      (uchar)local_102c);
        } while (cVar2 != '\0');
        pcVar4 = pcVar4 + 1;
        puVar3 = puVar3 + 2;
        local_102c = local_102c + 1;
        if (local_102c == 3) {
            return;
        }
    } while (true);
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void calibration_sensor_offset(void)

{
    uchar which_chain;
    uint8_t *puVar1;

    which_chain = '\0';
    puVar1 = dev.chain_exist;
    do {
        if (*puVar1 == '\x01') {
            calibration_sensor_offset_chain(which_chain);
            cgsleep_ms(200);
        }
        which_chain = which_chain + '\x01';
        puVar1 = puVar1 + 1;
    } while (which_chain != '\x04');
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void check_sensor_ID(void)

{
    int iVar1;
    int iVar2;
    char *pcVar3;
    uint8_t *puVar4;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "check_sensor_ID", 0x10);
        _applog(7, tmp42, false);
    }
    iVar1 = 0;
    puVar4 = dev.chain_exist;
    do {
        if (*puVar4 == '\x01') {
            iVar2 = 0;
            pcVar3 = sensor_id[iVar1];
            do {
                read_i2c_reg((uchar)iVar1, (uchar)iVar2, 'L', 0xfe);
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (2 < opt_log_level)) {
                    snprintf(tmp42, 0x1000,
                             "%s: Chain%d Sensor%d Manufacturer ID = 0x%02x",
                             "check_sensor_ID", iVar1, iVar2, (int)*pcVar3);
                    _applog(3, tmp42, false);
                }
                iVar2 = iVar2 + 1;
                pcVar3 = pcVar3 + 1;
            } while (iVar2 != 3);
        }
        iVar1 = iVar1 + 1;
        puVar4 = puVar4 + 1;
    } while (iVar1 != 4);
    return;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void *read_temp_func(void)

{
    _Bool _Var1;
    uint *puVar2;
    int iVar3;
    int iVar4;
    int iVar5;
    uint8_t *puVar6;
    all_parameters *paVar7;
    int iVar8;
    char cVar9;
    char cVar10;
    int iVar11;
    int iVar12;
    int32_t local_104c;
    char *local_1044;
    char tmp42[4096];

    if ((opt_debug) &&
        (((use_syslog || (opt_log_output)) || (6 < opt_log_level)))) {
        builtin_strncpy(tmp42, "read_temp_fu", 0xc);
        tmp42[0xc] = 'n';
        tmp42[0xd] = 'c';
        tmp42[0xe] = '\0';
        _applog(7, tmp42, false);
    }
    local_1044 = tmp42;
    do {
        while (true) {
            iVar4 = 0;
            sleep(1);
            puVar6 = dev.chain_exist;
            do {
                if ((*puVar6 == '\x01') && (start_send[iVar4] != false)) {
                    iVar5 = 0;
                    do {
                        iVar8 = iVar5 + 1;
                        read_i2c_reg((uchar)iVar4, (uchar)iVar5, 'L', '\x01');
                        read_i2c_reg((uchar)iVar4, (uchar)iVar5, 'L', '\0');
                        iVar5 = iVar8;
                    } while (iVar8 != 3);
                }
                iVar4 = iVar4 + 1;
                cgsleep_ms(200);
                puVar6 = puVar6 + 1;
            } while (iVar4 != 4);
            iVar5 = 0;
            paVar7 = &dev;
            cVar10 = '\0';
            iVar4 = -0x100;
            local_104c = -0x100;
            do {
                if ((dev.chain_exist[iVar5] == '\x01') &&
                    (start_send[iVar5] != false)) {
                    iVar8 = 0;
                    cVar9 = cVar10;
                    do {
                        cVar10 = g_chip_temp_return[iVar5][iVar8][0];
                        if (((_Bool)cVar10 == false) &&
                            (_Var1 = g_chip_temp_return[iVar5][iVar8][1],
                             cVar10 = cVar9, _Var1 != false)) {
                            cVar10 = _Var1;
                        }
                        iVar11 = (int)paVar7->chain_asic_temp[0][iVar8][0];
                        if ((((local_104c < iVar11) &&
                              (local_104c = iVar11, 0x50 < iVar11)) &&
                             (status_error == false)) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (2 < opt_log_level)))) {
                            snprintf(local_1044, 0x1000,
                                     "%s: Chain%d sensor%d local temp is %d "
                                     "`C, higher than MAX_TEMP",
                                     "read_temp_func", iVar5, iVar8, iVar11);
                            _applog(3, local_1044, false);
                        }
                        iVar11 = (int)paVar7->chain_asic_temp[0][iVar8][1];
                        if (((iVar4 < iVar11) &&
                             (iVar4 = iVar11, 0x6e < iVar11)) &&
                            ((status_error == false &&
                              (((use_syslog != false ||
                                 (opt_log_output != false)) ||
                                (2 < opt_log_level)))))) {
                            snprintf(local_1044, 0x1000,
                                     "%s: Chain%d sensor%d remote temp is %d "
                                     "`C, higher than MAX_CHIP_TEMP",
                                     "read_temp_func", iVar5, iVar8, iVar11);
                            _applog(3, local_1044, false);
                        }
                        _Var1 = opt_debug;
                        iVar8 = iVar8 + 1;
                        cVar9 = cVar10;
                    } while (iVar8 != 3);
                    iVar8 = (int)paVar7->chain_asic_temp[0][1][0];
                    iVar3 = (int)paVar7->chain_asic_temp[0][0][0];
                    iVar11 = (int)paVar7->chain_asic_temp[0][1][1];
                    iVar12 = (int)paVar7->chain_asic_temp[0][0][1];
                    if (iVar8 < iVar3) {
                        iVar8 = iVar3;
                    }
                    iVar3 = (int)paVar7->chain_asic_temp[0][2][0];
                    if (iVar8 < -0x100) {
                        iVar8 = -0x100;
                    }
                    if (iVar11 < iVar12) {
                        iVar11 = iVar12;
                    }
                    iVar12 = (int)paVar7->chain_asic_temp[0][2][1];
                    if (iVar11 < -0x100) {
                        iVar11 = -0x100;
                    }
                    if (iVar3 < iVar8) {
                        iVar3 = iVar8;
                    }
                    if (iVar11 < iVar12) {
                        iVar11 = iVar12;
                    }
                    dev.max_local_temp[iVar5] = iVar3;
                    dev.max_remote_temp[iVar5] = iVar11;
                    if ((_Var1 != false) &&
                        (((use_syslog != false || (opt_log_output != false)) ||
                          (6 < opt_log_level)))) {
                        snprintf(
                            local_1044, 0x1000,
                            "chain%d, max local temp :%d, max remote temp: %d",
                            iVar5, iVar3, iVar11);
                        _applog(7, local_1044, false);
                    }
                }
                iVar5 = iVar5 + 1;
                paVar7 = (all_parameters *)&paVar7->temp_sensor_map;
            } while (iVar5 != 4);
            dev.temp_top1 = local_104c;
            dev.temp_chip_top = iVar4;
            if (cVar10 == '\0')
                break;
            gMinerStatus_Not_read_all_sensor = false;
            if (stop == false)
                goto LAB_0003e670;
        LAB_0003e48e:
            puVar2 = axi_fpga_addr;
            dev.pwm_percent = 'd';
            axi_fpga_addr[0x21] = 0x640000;
            puVar2[0x28] = 0x640000;
        }
        gMinerStatus_Not_read_all_sensor = true;
        if (((status_error == false) && (opt_debug != false)) &&
            ((use_syslog != false ||
              ((opt_log_output != false || (6 < opt_log_level)))))) {
            snprintf(local_1044, 0x1000,
                     "%s: can\'t read all sensor\'s temperature, close PIC and "
                     "need reboot!!!",
                     "read_temp_func");
            _applog(7, local_1044, false);
        }
        if (stop != false)
            goto LAB_0003e48e;
    LAB_0003e670:
        set_PWM_according_to_temperature();
    } while (true);
}

/* WARNING: Unknown calling convention */

void recheck_asic_num(bitmain_ZCASH_info *info, uint8_t chain)

{
    char tmp42[4096];

    pthread_mutex_lock((pthread_mutex_t *)&reinit_mutex);
    reset_chain(info, chain);
    pthread_mutex_unlock((pthread_mutex_t *)&reinit_mutex);
    clear_register_value_buf();
    cgsleep_ms(100);
    if (dev.chain_exist[chain] != '\0') {
        update_asic_num[chain] = true;
        check_asic_reg(chain, '\0', '\0', true);
    }
    cgsleep_ms(200);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return;
    }
    snprintf(tmp42, 0x1000, "%s DONE!", "recheck_asic_num");
    _applog(5, tmp42, false);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void clear_nonce_fifo(void)

{
    pthread_mutex_lock((pthread_mutex_t *)&nonce_mutex);
    nonce_fifo.p_wr = 0;
    nonce_fifo.p_rd = 0;
    nonce_fifo.nonce_num = 0;
    clear_uart_rx_fifo('\0');
    clear_uart_rx_fifo('\x01');
    clear_uart_rx_fifo('\x02');
    clear_uart_rx_fifo('\x03');
    pthread_mutex_unlock((pthread_mutex_t *)&nonce_mutex);
    return;
}

/* WARNING: Unknown calling convention */

int target_zero_cal(uint8_t *target)

{
    uchar uVar1;
    uint8_t *puVar2;
    uint8_t *puVar3;
    int x;
    int iVar4;
    int iVar5;
    uchar *y;
    uint8_t uStack_39;
    uint8_t tmphash[32];
    uchar auStack_18[4];

    y = tmphash;
    memset(tmphash, 0, 0x20);
    puVar2 = target + 0x20;
    puVar3 = &uStack_39;
    do {
        puVar2 = puVar2 + -1;
        puVar3 = puVar3 + 1;
        *puVar3 = *puVar2;
    } while (puVar3 != tmphash + 0x1f);
    iVar5 = 0;
    do {
        x = 7;
        do {
            iVar4 = x + -1;
            uVar1 = bit_read(y, x);
            if (uVar1 != '\0') {
                return iVar5;
            }
            iVar5 = iVar5 + 1;
            x = iVar4;
        } while (iVar4 != -1);
        y = y + 1;
    } while (y != auStack_18);
    return iVar5;
}

/* WARNING: Unknown calling convention */

_Bool target_match(uchar *result_value, uchar *target)

{
    byte *pbVar1;
    byte *pbVar2;

    pbVar1 = target + 0x20;
    pbVar2 = result_value + 0x20;
    while (true) {
        pbVar2 = pbVar2 + -1;
        pbVar1 = pbVar1 + -1;
        if (*pbVar2 < *pbVar1) {
            return true;
        }
        if (*pbVar1 < *pbVar2)
            break;
        if (pbVar2 == result_value) {
            return true;
        }
    }
    return false;
}

/* WARNING: Unknown calling convention */

int create_bitmain_check_fan_pthread(void)

{
    int iVar1;
    int unaff_r5;
    char tmp42[4096];

    check_fan_id = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(check_fan_id, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x33ec1, (void *)0x0);
    if (iVar1 == 0) {
        pthread_detach(check_fan_id->pth);
        cgsleep_ms(500);
        return unaff_r5;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s: create thread for check miner_status",
                 "create_bitmain_check_fan_pthread");
        _applog(7, tmp42, false);
    }
    return -8;
}

/* WARNING: Unknown calling convention */

int create_bitmain_check_miner_status_pthread(bitmain_ZCASH_info *info)

{
    int iVar1;
    int unaff_r6;
    char tmp42[4096];

    check_miner_status_id = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(check_miner_status_id, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x3b07d, info);
    if (iVar1 == 0) {
        pthread_detach(check_miner_status_id->pth);
        cgsleep_ms(500);
        return unaff_r6;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s: create thread for check miner_status",
                 "create_bitmain_check_miner_status_pthread");
        _applog(7, tmp42, false);
    }
    return -5;
}

/* WARNING: Unknown calling convention */

int create_bitmain_get_hash_rate_pthread(void)

{
    int iVar1;
    int unaff_r6;
    char tmp42[4096];

    read_hash_rate = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(read_hash_rate, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x33fa1, read_hash_rate);
    if (iVar1 == 0) {
        pthread_detach(read_hash_rate->pth);
        cgsleep_ms(500);
        return unaff_r6;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000,
                 "%s: create thread for get hashrate from asic failed",
                 "create_bitmain_get_hash_rate_pthread");
        _applog(7, tmp42, false);
    }
    return -6;
}

/* WARNING: Unknown calling convention */

uchar read_temperature_through_fpga_iic_register(uchar which_chain)

{
    uchar uVar1;
    uint config_data;

    config_data = (uint)which_chain << 0x10 | 0x1900000;
    pthread_mutex_lock((pthread_mutex_t *)&i2c_mutex);
    uVar1 = i2c_read(config_data);
    i2c_read(config_data);
    cgsleep_ms(100);
    pthread_mutex_unlock((pthread_mutex_t *)&i2c_mutex);
    return uVar1;
}

/* WARNING: Unknown calling convention */

int create_bitmain_read_temp_pthread(void)

{
    int iVar1;
    int unaff_r6;
    char tmp42[4096];

    read_temp_id = (thr_info *)calloc(1, 0x40);
    iVar1 = thr_info_create(read_temp_id, (pthread_attr_t *)0x0,
                            (_func_void_ptr_void_ptr *)0x3e385, read_temp_id);
    if (iVar1 == 0) {
        pthread_detach(read_temp_id->pth);
        cgsleep_ms(500);
        return unaff_r6;
    }
    if ((opt_debug != false) &&
        (((use_syslog != false || (opt_log_output != false)) ||
          (6 < opt_log_level)))) {
        snprintf(tmp42, 0x1000, "%s: create thread for read temp",
                 "create_bitmain_read_temp_pthread");
        _applog(7, tmp42, false);
    }
    return -7;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

int bitmain_ZCASH_init(bitmain_ZCASH_info *info)

{
    byte bVar1;
    uint *puVar2;
    _Bool _Var3;
    undefined4 uVar4;
    undefined4 uVar5;
    init_config *piVar6;
    uint32_t uVar7;
    undefined4 uVar8;
    undefined4 uVar9;
    uint32_t uVar10;
    char *pcVar11;
    int iVar12;
    undefined4 uVar13;
    undefined4 uVar14;
    pool **pppVar15;
    uint uVar17;
    uint uVar18;
    uint uVar19;
    uchar which_chain;
    uint8_t *puVar20;
    int iVar21;
    uint8_t *local_106c;
    init_config config;
    init_config config_parameter;
    char tmp42[4096];
    pool **pppVar16;

    uVar7 = (info->ZCASH_config).baud;
    uVar4._0_1_ = (info->ZCASH_config).token_type;
    uVar4._1_1_ = (info->ZCASH_config).version;
    uVar4._2_2_ = (info->ZCASH_config).length;
    uVar9._0_2_ = *(undefined2 *)&(info->ZCASH_config).field_0x8;
    uVar9._2_1_ = (info->ZCASH_config).reserved2[0];
    uVar9._3_1_ = (info->ZCASH_config).reserved2[1];
    uVar13._0_1_ = (info->ZCASH_config).chain_num;
    uVar13._1_1_ = (info->ZCASH_config).asic_num;
    uVar13._2_1_ = (info->ZCASH_config).fan_pwm_percent;
    uVar13._3_1_ = (info->ZCASH_config).temperature;
    uVar5._0_2_ = (info->ZCASH_config).frequency;
    uVar5._2_1_ = (info->ZCASH_config).voltage[0];
    uVar5._3_1_ = (info->ZCASH_config).voltage[1];
    uVar8._0_1_ = (info->ZCASH_config).chain_check_time_integer;
    uVar8._1_1_ = (info->ZCASH_config).chain_check_time_fractions;
    uVar8._2_1_ = (info->ZCASH_config).timeout_data_integer;
    uVar8._3_1_ = (info->ZCASH_config).timeout_data_fractions;
    uVar10 = (info->ZCASH_config).reg_data;
    uVar14._0_1_ = (info->ZCASH_config).chip_address;
    uVar14._1_1_ = (info->ZCASH_config).reg_address;
    uVar14._2_2_ = (info->ZCASH_config).crc;
    start_http_thread();
    do {
        if (0 < total_pools) {
            iVar21 = 0;
            pppVar15 = pools;
            do {
                while (true) {
                    pppVar16 = pppVar15 + 1;
                    pcVar11 = (*pppVar15)->rpc_url;
                    if ((((pcVar11 == (char *)0x0) || (*pcVar11 == '\0')) ||
                         (pcVar11 = (*pppVar15)->rpc_user,
                          pcVar11 == (char *)0x0)) ||
                        (*pcVar11 == '\0'))
                        break;
                    iVar21 = iVar21 + 1;
                    pppVar15 = pppVar16;
                    if (pools + total_pools == pppVar16)
                        goto LAB_0003ebee;
                }
                pppVar15 = pppVar16;
            } while (pools + total_pools != pppVar16);
            if (iVar21 != 0)
                break;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (3 < opt_log_level)) {
            builtin_strncpy(
                tmp42, "No valid pools, please configure them first!", 0x2c);
            tmp42[0x2c] = '!';
            tmp42[0x2d] = '!';
            tmp42[0x2e] = '\0';
            _applog(4, tmp42, false);
        }
        sleep(5);
    } while (true);
LAB_0003ebee:
    bitmain_axi_init();
    init_fpga();
    set_fpga_baud('\x1a');
    dev.addrInterval = '\x01';
    builtin_strncpy(g_miner_version, "9.0.0.5", 8);
    config_parameter._0_4_ = uVar4;
    config_parameter.baud = uVar7;
    config_parameter._8_4_ = uVar9;
    config_parameter._12_4_ = uVar13;
    config_parameter._16_4_ = uVar5;
    config_parameter._20_4_ = uVar8;
    config_parameter.reg_data = uVar10;
    config_parameter._28_4_ = uVar14;
    system("echo 1 > /sys/class/gpio/gpio954/value");
    system("echo 1 > /sys/class/gpio/gpio955/value");
    puVar2 = axi_fpga_addr;
    uVar17 = (uint)(byte)opt_bitmain_fan_pwm;
    if (uVar17 < 0x28) {
        uVar17 = 0x28;
    LAB_0003ec7a:
        if (gMinerStatus_Not_read_all_sensor == false) {
            uVar18 = 100 - uVar17 | uVar17 << 0x10;
        } else {
            uVar18 = 0x640000;
            uVar17 = 100;
        }
    } else {
        if (uVar17 < 0x65)
            goto LAB_0003ec7a;
        uVar18 = 0x640000;
        uVar17 = 100;
    }
    dev.pwm_percent = (uint8_t)uVar17;
    axi_fpga_addr[0x21] = uVar18;
    puVar2[0x28] = uVar18;
    check_fan_speed();
    if ((config_parameter._0_4_ & 0xff) != 0x51) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return -1;
        }
        snprintf(tmp42, 0x1000,
                 "%s: config_parameter.token_type != 0x%x, it is 0x%x",
                 "bitmain_ZCASH_init", 0x51, config_parameter._0_4_ & 0xff);
        _applog(3, tmp42, false);
        return -1;
    }
    piVar6 = &config_parameter;
    uVar18 = 0xff;
    uVar17 = 0x51;
    while (uVar18 =
               ((uint)crc_itu_t_table[uVar17 ^ uVar18 >> 8] ^ uVar18 << 8) &
               0xffff,
           piVar6 != (init_config *)&config_parameter.reg_address) {
        piVar6 = (init_config *)&piVar6->version;
        uVar17 = (uint) * (byte *)piVar6;
    }
    if ((uint)config_parameter._28_4_ >> 0x10 != uVar18) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 3)) {
            return -2;
        }
        snprintf(tmp42, 0x1000,
                 "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x",
                 "bitmain_ZCASH_init", (uint)config_parameter._28_4_ >> 0x10,
                 uVar18);
        _applog(3, tmp42, false);
        return -2;
    }
    iVar21 = 0;
    do {
        iVar12 = iVar21 + 1;
        *(undefined2 *)(info->work_queue + iVar21) = 0;
        *(undefined2 *)((int)info->work_queue + iVar21 * 4 + 2) = 0;
        iVar21 = iVar12;
    } while (iVar12 != 0x80);
    check_chain();
    if (certification_firmware != false) {
        rt_chain_num = (int)dev.chain_num;
        config_parameter.fan_pwm_percent = '2';
        config_parameter._8_4_ = config_parameter._8_4_ | 2;
    }
    every_chain_reset_PIC16F1704_pic_new();
    every_chain_jump_from_loader_to_app_PIC16F1704_new();
    sleep(1);
    iVar21 = send_heart_beat_to_every_chain();
    if (iVar21 == -3) {
        return -3;
    }
    iVar21 = access("/tmp/delete_freq", 0);
    uVar4 = tmp42._36_4_;
    if (iVar21 == 0) {
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            builtin_strncpy(tmp42, "delete freq data and scan freq again\n",
                            0x26);
            tmp42._38_2_ = SUB42(uVar4, 2);
            _applog(5, tmp42, false);
        }
        memset((uchar(*)[9])tmp42, 0, 0x24);
        every_chain_write_freq_to_pic((uchar(*)[9])tmp42);
        system("rm /tmp/delete_freq");
        sleep(3);
        /* WARNING: Subroutine does not return */
        exit(1);
    }
    uVar17 = config_parameter._8_4_ & 0xff;
    if ((int)(uVar17 << 0x1c) < 0) {
        dev.frequency = config_parameter.frequency;
        if ((config_parameter._16_4_ & 0xffff) == 0 ||
            (config_parameter._16_4_ & 0xffff) == 800)
            goto LAB_0003ee86;
    } else {
    LAB_0003ee86:
        dev.frequency = 800;
    }
    reset_all_hash_board_low();
    cgsleep_ms(100);
    every_chain_disable_PIC16F1704_dc_dc_new();
    cgsleep_ms(200);
    cgsleep_ms(200);
    every_chain_enable_PIC16F1704_dc_dc_new();
    cgsleep_ms(100);
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s %d", "reset_all_hash_board_high", 0x112e);
        _applog(5, tmp42, false);
    }
    iVar21 = 0;
    axi_fpga_addr[0xd] = 0;
    cgsleep_ms(100);
    tty_init(info);
    sleep(3);
    set_baud(config_parameter.baud);
    cgsleep_ms(100);
    calculate_address_interval();
    dev.corenum = '\x01';
    clear_register_value_buf();
    cgsleep_ms(100);
    sleep(2);
    check_every_chain_asic_number(true);
    cgsleep_ms(300);
    local_106c = dev.chain_exist;
    puVar20 = dev.chain_exist;
    do {
        if (*puVar20 == 1) {
            iVar12 = 3;
            need_recheck[iVar21] = true;
            do {
                _Var3 = use_syslog;
                bVar1 = puVar20[0x209];
                if (bVar1 == 3) {
                    need_recheck[iVar21] = false;
                    break;
                }
                need_recheck[iVar21] = true;
                if (((_Var3 != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    snprintf(
                        tmp42, 0x1000,
                        "recheck: chainid %d exist %d asicnum %d realnum %d",
                        iVar21, (uint)*puVar20, (uint)bVar1, 3);
                    _applog(5, tmp42, false);
                    if (need_recheck[iVar21] == false)
                        break;
                }
                recheck_asic_num(info, (uint8_t)iVar21);
                iVar12 = iVar12 + -1;
            } while (iVar12 != 0);
        }
        iVar21 = iVar21 + 1;
        puVar20 = puVar20 + 1;
    } while (iVar21 != 4);
    which_chain = '\0';
    scan_freq_init_freq();
    uVar7 = default_ticket_mask_reg;
    do {
        if (*local_106c == '\x01') {
            set_ticket_mask_chain(which_chain, uVar7);
        }
        which_chain = which_chain + '\x01';
        local_106c = local_106c + 1;
    } while (which_chain != '\x04');
    cgsleep_ms(100);
    software_set_address();
    cgsleep_ms(100);
    set_core_timeout(opt_bitmain_core_timeout);
    cgsleep_ms(100);
    set_nonce_shift(0);
    cgsleep_ms(100);
    enable_read_temperature_from_asic_chain(0);
    enable_read_temperature_from_asic_chain(1);
    enable_read_temperature_from_asic_chain(2);
    enable_read_temperature_from_asic_chain(3);
    enable_sensor_extend_mode();
    set_analog_mux_control(0);
    if ((int)(uVar17 << 0x1d) < 0) {
        dev.timeout = 100000000;
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (4 < opt_log_level)) {
            snprintf(tmp42, 0x1000, "dev.timeout = %d us", 100000000);
            _applog(5, tmp42, false);
            goto LAB_0003f1a0;
        }
        uVar19 = (uint)config_parameter.fan_pwm_percent;
        uVar18 = (uint)(config_parameter._8_4_ << 0x1e) >> 0x1f;
        dev.fan_eft = (uint8_t)((uint)(config_parameter._8_4_ << 0x1e) >> 0x1f);
        dev.fan_pwm = config_parameter.fan_pwm_percent;
    LAB_0003f062:
        if ((opt_log_output == false) && (opt_log_level < 5))
            goto LAB_0003f096;
    } else {
    LAB_0003f1a0:
        dev.fan_pwm = config_parameter.fan_pwm_percent;
        uVar19 = (uint)config_parameter.fan_pwm_percent;
        uVar18 = (uint)(config_parameter._8_4_ << 0x1e) >> 0x1f;
        dev.fan_eft = (uint8_t)((uint)(config_parameter._8_4_ << 0x1e) >> 0x1f);
        if (use_syslog == false)
            goto LAB_0003f062;
    }
    snprintf(tmp42, 0x1000, "%s: fan_eft : %d  fan_pwm : %d",
             "bitmain_ZCASH_init", uVar18, uVar19);
    _applog(5, tmp42, false);
LAB_0003f096:
    puVar2 = axi_fpga_addr;
    if (((int)(uVar17 << 0x1e) < 0) && (uVar19 < 0x65)) {
        if (gMinerStatus_Not_read_all_sensor == false) {
            if (uVar19 < 0x28) {
                uVar19 = 0x28;
            }
            uVar17 = 100 - uVar19 | uVar19 << 0x10;
        } else {
            uVar17 = 0x640000;
            uVar19 = 100;
        }
        dev.pwm_percent = (uint8_t)uVar19;
        axi_fpga_addr[0x21] = uVar17;
        puVar2[0x28] = uVar17;
    } else {
        set_PWM_according_to_temperature();
    }
    iVar21 = create_bitmain_check_fan_pthread();
    if (iVar21 != -8) {
        sleep(1);
        create_bitmain_read_temp_pthread();
        if (((iVar21 != -7) &&
             (iVar21 = create_bitmain_check_miner_status_pthread(info),
              iVar21 != -5)) &&
            (iVar21 = create_bitmain_get_hash_rate_pthread(), iVar21 != -6)) {
            init_asic_display_status();
            start_send[0] = true;
            start_send[1] = true;
            start_send[2] = true;
            start_send[3] = true;
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 5)) {
                iVar21 = 0;
            } else {
                snprintf(tmp42, 0x1000, "%s done", "bitmain_ZCASH_init");
                iVar21 = 0;
                _applog(5, tmp42, false);
            }
        }
    }
    return iVar21;
}

/* WARNING: Unknown calling convention */

_Bool bitmain_ZCASH_prepare(thr_info *thr)

{
    int iVar1;
    int iVar2;
    char *file;
    char *extraout_r1;
    char *file_00;
    char *extraout_r1_00;
    char *extraout_r1_01;
    char *func;
    char *extraout_r2;
    char *func_00;
    init_config *piVar3;
    char *extraout_r2_00;
    char *extraout_r2_01;
    uint16_t uVar4;
    int line;
    int extraout_r3;
    int extraout_r3_00;
    int extraout_r3_01;
    ushort uVar5;
    bitmain_ZCASH_info *info;
    pthread_mutex_t *__mutex;
    init_config ZCASH_config;

    piVar3 = &ZCASH_config;
    __mutex = (pthread_mutex_t *)thr->cgpu->device_data;
    *(thr_info **)((int)__mutex + 0x276) = thr;
    iVar1 = pthread_mutex_init((pthread_mutex_t *)((int)__mutex + 0x47a),
                               (pthread_mutexattr_t *)0x0);
    if (iVar1 == 0) {
        iVar2 = pthread_mutex_init(__mutex, (pthread_mutexattr_t *)0x0);
        file_00 = extraout_r1;
        func_00 = extraout_r2;
        iVar1 = extraout_r3;
    } else {
        _mutex_init((pthread_mutex_t *)0x1d58, file, func, line);
        iVar2 = pthread_mutex_init(__mutex, (pthread_mutexattr_t *)0x0);
        file_00 = extraout_r1_00;
        func_00 = extraout_r2_00;
        iVar1 = extraout_r3_00;
    }
    if (iVar2 != 0) {
        _mutex_init((pthread_mutex_t *)0x1d59, file_00, func_00, iVar1);
        file_00 = extraout_r1_01;
        func_00 = extraout_r2_01;
        iVar1 = extraout_r3_01;
    }
    _rwlock_init((pthread_rwlock_t *)(__mutex + 1), file_00, func_00, iVar1);
    memset(&ZCASH_config, 0, 0x20);
    ZCASH_config.token_type = 'Q';
    ZCASH_config.length = 0x18;
    ZCASH_config._8_2_ = 0x700;
    ZCASH_config.voltage[0] = '\a';
    ZCASH_config.voltage[1] = '%';
    ZCASH_config.frequency = (uint16_t)opt_bitmain_ZCASH_freq;
    ZCASH_config.chain_check_time_integer = '\n';
    ZCASH_config.chain_check_time_fractions = '\n';
    ZCASH_config._8_4_ =
        CONCAT31(ZCASH_config._9_3_, (opt_bitmain_fan_ctrl & 1U) << 1) | 0xfd;
    ZCASH_config.fan_pwm_percent = (uint8_t)opt_bitmain_fan_pwm;
    ZCASH_config.chain_num = '\x06';
    ZCASH_config.asic_num = '\x03';
    ZCASH_config.temperature = 'P';
    uVar4 = 0x4ad4;
    uVar5 = 0xff;
    ZCASH_config.chip_address = '\x04';
    while (uVar5 = uVar4 ^ uVar5 << 8,
           piVar3 != (init_config *)&ZCASH_config.reg_address) {
        piVar3 = (init_config *)((int)piVar3 + 1);
        uVar4 = crc_itu_t_table[(uint) * (byte *)piVar3 ^ (uint)(uVar5 >> 8)];
    }
    ZCASH_config.crc = uVar5;
    *(undefined4 *)((int)__mutex + 0x492) = ZCASH_config._0_4_;
    *(uint32_t *)((int)__mutex + 0x496) = ZCASH_config.baud;
    *(undefined4 *)((int)__mutex + 0x49a) = ZCASH_config._8_4_;
    *(undefined4 *)((int)__mutex + 0x49e) = ZCASH_config._12_4_;
    *(undefined4 *)((int)__mutex + 0x4a2) = ZCASH_config._16_4_;
    *(undefined4 *)((int)__mutex + 0x4a6) = ZCASH_config._20_4_;
    *(uint32_t *)((int)__mutex + 0x4aa) = ZCASH_config.reg_data;
    *(undefined4 *)((int)__mutex + 0x4ae) = ZCASH_config._28_4_;
    bitmain_ZCASH_init((bitmain_ZCASH_info *)&__mutex->__data);
    return true;
}

/* WARNING: Type propagation algorithm not settling */
/* WARNING: Unknown calling convention */

int nonce_handle(nonce_rb_format (*g_nonce)[1],
                 uint8_t (*g_nonce_list)[1][16][91], uint8_t *str, int len,
                 uint32_t chainid)

{
    uint8_t(*paauVar1)[16][91];
    uint8_t(*pauVar2)[91];
    uint32_t uVar3;
    byte bVar4;
    uint8_t *puVar5;
    uint8_t(*pauVar6)[91];
    uint8_t *puVar7;
    uint8_t(*pauVar8)[91];
    uint uVar9;
    uint uVar10;
    char *__format;
    uint uVar11;
    uint8_t *__dest;
    uint8_t(*pauVar12)[91];
    ushort uVar13;
    uint uVar14;
    uint8_t *puVar15;
    int iVar16;
    uint16_t crc16;
    char tmp42[4096];

    bVar4 = __udivsi3(str[3], dev.addrInterval);
    uVar11 = (uint)bVar4;
    if (2 < uVar11) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 4)) {
            return -1;
        }
        snprintf(tmp42, 0x1000, "%s chipid %d is not exist", "nonce_handle",
                 uVar11);
        _applog(4, tmp42, false);
        return -1;
    }
    pauVar12 = (uint8_t(*)[91])(g_nonce_list + uVar11);
    uVar13 = str[2] & 0xf;
    memcpy(pauVar12 + (short)uVar13, str + 2, 0x5b);
    if (uVar13 != 0xf) {
        return 1;
    }
    puVar5 = *pauVar12 + 0x59;
    iVar16 = 0;
    do {
        uVar9 = 0xffff;
        puVar7 = puVar5 + -0x59;
        do {
            puVar15 = puVar7;
            puVar7 = puVar15 + 1;
            uVar14 = uVar9 >> 8;
            uVar10 = (uint)crc_itu_t_table[*puVar15 ^ uVar14] ^ uVar9 << 8;
            uVar9 = uVar10 & 0xffff;
        } while (puVar7 != puVar5);
        if ((uVar9 >> 8 != (uint)*puVar7) ||
            (crc16._1_1_ = (byte)crc_itu_t_table[*puVar15 ^ uVar14],
             crc16._1_1_ != puVar15[2])) {
            if ((use_syslog == false) &&
                ((opt_log_output == false && (opt_log_level < 3))))
                goto LAB_0003f576;
            snprintf(
                tmp42, 0x1000, "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
                "bm1740_verify_nonce_integrality",
                (uVar10 & 0xff) << 8 | uVar9 >> 8, (uint)pauVar12[iVar16][0x59],
                (uint)pauVar12[iVar16][0x5a]);
            goto LAB_0003f560;
        }
        iVar16 = iVar16 + 1;
        puVar5 = puVar15 + 0x5c;
    } while (iVar16 != 0x10);
    uVar9 = 0;
    pauVar6 = pauVar12;
    do {
        paauVar1 = (uint8_t(*)[16][91]) * pauVar6;
        pauVar6 = pauVar6 + 1;
        if (((*paauVar1)[0][0] & 0xf) != uVar9) {
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3))
                goto LAB_0003f582;
            snprintf(tmp42, 0x1000, "nonce is not continous i=%d\n");
            goto LAB_0003f560;
        }
        uVar9 = uVar9 + 1;
    } while (uVar9 != 0x10);
    uVar9 = (uint)(*pauVar12)[1];
    pauVar6 = pauVar12;
    do {
        uVar14 = (uint)pauVar6[1][1];
        pauVar6 = pauVar6 + 1;
        if (uVar14 != uVar9) {
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 3))
                goto LAB_0003f582;
            __format = "chip_addr is different %02x != %02x\n";
            goto LAB_0003f688;
        }
    } while (pauVar12 + 0xf != pauVar6);
    uVar9 = (uint)(*pauVar12)[2];
    pauVar8 = pauVar12;
LAB_0003f6a0:
    uVar14 = (uint)pauVar8[1][2];
    pauVar8 = pauVar8 + 1;
    if (uVar14 == uVar9)
        goto code_r0x0003f6ac;
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (2 < opt_log_level)) {
        __format = "workID is different %02x != %02x\n";
    LAB_0003f688:
        snprintf(tmp42, 0x1000, __format, uVar9, uVar14);
        goto LAB_0003f560;
    }
    goto LAB_0003f582;
code_r0x0003f6ac:
    if (pauVar6 == pauVar8)
        goto code_r0x0003f6b0;
    goto LAB_0003f6a0;
code_r0x0003f6b0:
    pauVar6 = pauVar12;
    while (true) {
        pauVar2 = pauVar6 + 1;
        pauVar6 = pauVar6 + 1;
        if ((uint)(*pauVar2)[3] != (uint)(*pauVar12)[3])
            break;
        if (pauVar8 == pauVar6) {
            puVar15 = *pauVar12 + 4;
            puVar7 = (uint8_t *)(g_nonce + uVar11);
            puVar5 = puVar7;
            do {
                __dest = puVar5 + 0x55;
                memcpy(puVar5, puVar15, 0x55);
                puVar15 = puVar15 + 0x5b;
                puVar5 = __dest;
            } while (__dest != puVar7 + 0x4fb);
            memcpy(__dest, (void *)((int)(pauVar12 + 0xf) + 4), 0x45);
            *(undefined4 *)(puVar7 + 0x548) =
                *(undefined4 *)((int)(pauVar12 + 0xf) + 0x55);
            puVar7[0x540] = *(undefined1 *)((int)(pauVar12 + 0xf) + 1);
            puVar7[0x541] = *(undefined1 *)((int)(pauVar12 + 0xf) + 2);
            puVar7[0x542] = *(undefined1 *)((int)(pauVar12 + 0xf) + 3);
            puVar7[0x543] = *(undefined1 *)((int)(pauVar12 + 0xf) + 0x4c);
            *(undefined4 *)(puVar7 + 0x544) =
                *(undefined4 *)((int)(pauVar12 + 0xf) + 0x4d);
            pthread_mutex_lock((pthread_mutex_t *)&nonce_mutex);
            uVar3 = nonce_fifo.p_wr;
            nonce_fifo.nonce_buffer[nonce_fifo.p_wr].chain_id =
                (uint8_t)chainid;
            nonce_fifo.nonce_buffer[uVar3].chip_addr = puVar7[0x540];
            nonce_fifo.nonce_buffer[uVar3].work_id = puVar7[0x541] & 0x7f;
            nonce_fifo.nonce_buffer[uVar3].nonce_id = puVar7[0x542];
            nonce_fifo.nonce_buffer[uVar3].diff0 = puVar7[0x543];
            *(undefined4 *)nonce_fifo.nonce_buffer[uVar3].sha256 =
                *(undefined4 *)(puVar7 + 0x544);
            *(undefined4 *)nonce_fifo.nonce_buffer[uVar3].chip_nonce =
                *(undefined4 *)(puVar7 + 0x548);
            memcpy(nonce_fifo.nonce_buffer + uVar3, puVar7, 0x540);
            if (nonce_fifo.p_wr < 99) {
                nonce_fifo.p_wr = nonce_fifo.p_wr + 1;
            } else {
                nonce_fifo.p_wr = 0;
            }
            if (nonce_fifo.nonce_num < 100) {
                nonce_fifo.nonce_num = nonce_fifo.nonce_num + 1;
            } else {
                nonce_fifo.nonce_num = 100;
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (3 < opt_log_level)) {
                    snprintf(tmp42, 0x1000, "%s: nonce fifo full!!!",
                             "nonce_handle");
                    _applog(4, tmp42, false);
                }
            }
            pthread_mutex_unlock((pthread_mutex_t *)&nonce_mutex);
            return 0;
        }
    }
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (2 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "nonceID is different %02x != %02x chipid=%d\n",
                 (uint)(*pauVar12)[3], (uint)(*pauVar2)[3], uVar11);
    LAB_0003f560:
        _applog(3, tmp42, false);
        if (use_syslog != false)
            goto LAB_0003f58a;
    LAB_0003f576:
        if (opt_log_output != false)
            goto LAB_0003f58a;
    }
LAB_0003f582:
    if (opt_log_level < 4) {
        return -1;
    }
LAB_0003f58a:
    nonce_handle::total_error = nonce_handle::total_error + 1;
    snprintf(tmp42, 0x1000, "receive a error nonce. total = %u");
    _applog(4, tmp42, false);
    return -1;
}

/* WARNING: Unknown calling convention */

void pm_handle(uint8_t *str, int len, uint8_t chainid)

{
    byte bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    char tmp42[4096];

    bVar1 = CRC5(str + 2, (char)len * '\b' + 0xeb);
    if ((str[8] & 0x1f) == (uint)bVar1) {
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            uVar5 = (uint)str[6];
            uVar2 = (uint)str[3];
            uVar4 = (uint)str[5];
            uVar3 = (uint)str[4];
            bVar1 = __udivsi3(str[7], dev.addrInterval);
            snprintf(tmp42, 0x1000, "chain[%d] asic[%d] %02x %02x %02x %02x\n",
                     (uint)chainid, (uint)bVar1, uVar2, uVar3, uVar4, uVar5);
            _applog(7, tmp42, false);
            return;
        }
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (2 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s chain%d CRC error crc = %02x\n",
                 "pm_handle", (uint)chainid, (uint)bVar1);
        _applog(3, tmp42, false);
    }
    return;
}

/* WARNING: Unknown calling convention */

void reg_handle(uint8_t *str, int len, uint32_t chainid)

{
    uint8_t uVar1;
    uint32_t uVar2;
    byte bVar3;
    char tmp42[4096];

    bVar3 = CRC5(str + 2, '3');
    if ((str[8] & 0x1f) == (uint)bVar3) {
        if ((99 < reg_fifo.reg_value_num) || (99 < reg_fifo.p_wr)) {
            if ((use_syslog != false) ||
                ((opt_log_output != false || (4 < opt_log_level)))) {
                builtin_strncpy(tmp42, "Will Clean!", 0xc);
                _applog(5, tmp42, false);
            }
            clear_register_value_buf();
            return;
        }
        pthread_mutex_lock((pthread_mutex_t *)&reg_mutex);
        uVar2 = reg_fifo.p_wr;
        *(undefined4 *)reg_fifo.reg_buffer[reg_fifo.p_wr].reg_data =
            *(undefined4 *)(str + 3);
        reg_fifo.reg_buffer[uVar2].chip_addr = str[7];
        uVar1 = str[2];
        reg_fifo.reg_buffer[uVar2].chain_id = (uint8_t)chainid;
        reg_fifo.reg_buffer[uVar2].reg_addr = uVar1;
        if (uVar2 < 99) {
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "%s: p_wr = %d reg_value_num = %d",
                         "reg_handle", uVar2, reg_fifo.reg_value_num);
                _applog(7, tmp42, false);
            }
            reg_fifo.p_wr = reg_fifo.p_wr + 1;
        } else {
            reg_fifo.p_wr = 0;
        }
        if (reg_fifo.reg_value_num < 100) {
            reg_fifo.reg_value_num = reg_fifo.reg_value_num + 1;
        } else {
            reg_fifo.reg_value_num = 100;
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (3 < opt_log_level)) {
                snprintf(tmp42, 0x1000, "%s: reg fifo full!!!", "reg_handle");
                _applog(4, tmp42, false);
            }
        }
        pthread_mutex_unlock((pthread_mutex_t *)&reg_mutex);
    } else if (((use_syslog != false) || (opt_log_output != false)) ||
               (2 < opt_log_level)) {
        snprintf(tmp42, 0x1000, "%s CRC error crc = %02x\n", "reg_handle",
                 (uint)bVar3);
        _applog(3, tmp42, false);
    }
    return;
}

/* WARNING: Unknown calling convention */

void *get_asic_response(void *arg)

{
    pthread_t __th;
    uint uVar1;
    uchar *puVar2;
    uchar *puVar3;
    uchar *puVar4;
    int iVar5;
    int iVar6;
    int iVar7;
    int iVar8;
    uint32_t chainid;
    uint32_t chainid_00;
    uchar header[3];
    uchar uStack_149f1;
    uchar tmp[93];
    uint8_t receive_buf[1488];
    nonce_rb_format g_nonce[3][1];
    uint8_t g_nonce_list[3][1][16][91];
    uchar data_buf[74400];

    memset(receive_buf, 0, 0x5d0);
    /* WARNING: Load size is inaccurate */
    chainid_00 = *arg;
    __th = pthread_self();
    pthread_detach(__th);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        if (opt_debug == false)
            goto LAB_0003fb92;
    LAB_0003fd80:
        if (opt_log_level < 7)
            goto LAB_0003fb92;
    } else {
        snprintf((char *)data_buf, 0x1000,
                 "Start A New Asic Response.Chain Id:[%d]", chainid_00);
        _applog(5, (char *)data_buf, false);
        if (opt_debug == false)
            goto LAB_0003fb92;
        if ((use_syslog == false) && (opt_log_output == false))
            goto LAB_0003fd80;
    }
    snprintf((char *)data_buf, 0x1000, "%s %d", "get_asic_response",
             chainid_00);
    _applog(7, (char *)data_buf, false);
LAB_0003fb92:
    iVar8 = 0;
    memset(data_buf, 0, 0x122a0);
    memset(tmp, 0, 0x5d);
    iVar6 = 0;
    do {
        do {
            if (start_recv[chainid_00] == false) {
                return (void *)0x0;
            }
            cgsleep_us(500);
            uVar1 = uart_receive((uchar)chainid_00, receive_buf, 0x5d0);
            if (0 < (int)uVar1) {
                puVar2 = receive_buf;
                do {
                    puVar4 = puVar2 + 1;
                    data_buf[iVar8] = *puVar2;
                    iVar8 = iVar8 + 1;
                    if (0x1229f < iVar8) {
                        iVar8 = 0;
                    }
                    puVar2 = puVar4;
                } while (receive_buf + uVar1 != puVar4);
            }
        } while (iVar8 == iVar6);
        if (iVar6 < iVar8) {
            iVar7 = iVar8 - iVar6;
        } else {
            iVar7 = (0x122a0 - iVar6) + iVar8;
        }
        while (2 < iVar7) {
            header[0] = '\0';
            header[1] = '\0';
            header[2] = '\0';
            puVar2 = header;
            iVar5 = iVar6;
            do {
                puVar4 = data_buf + iVar5;
                iVar5 = iVar5 + 1;
                if (0x1229f < iVar5) {
                    iVar5 = 0;
                }
                puVar3 = puVar2 + 1;
                *puVar2 = *puVar4;
                puVar2 = puVar3;
            } while (&uStack_149f1 != puVar3);
            if ((header[0] == 0xaa) && (header[1] == 'U')) {
                if ((header[2] & 0xf0) == 0xe0) {
                    if (iVar7 < 0x5d)
                        break;
                    puVar2 = &uStack_149f1;
                    do {
                        puVar4 = data_buf + iVar6;
                        iVar6 = iVar6 + 1;
                        if (0x1229f < iVar6) {
                            iVar6 = 0;
                        }
                        puVar2 = puVar2 + 1;
                        *puVar2 = *puVar4;
                    } while (tmp + 0x5c != puVar2);
                    iVar7 = iVar7 + -0x5d;
                    nonce_handle(g_nonce, g_nonce_list, tmp, 0x5d, chainid_00);
                } else if (header[2] == 0xcc) {
                    if (iVar7 < 9)
                        break;
                    puVar2 = &uStack_149f1;
                    do {
                        puVar4 = data_buf + iVar6;
                        iVar6 = iVar6 + 1;
                        if (0x1229f < iVar6) {
                            iVar6 = 0;
                        }
                        puVar2 = puVar2 + 1;
                        *puVar2 = *puVar4;
                    } while (puVar2 != tmp + 8);
                    iVar7 = iVar7 + -9;
                    pm_handle(tmp, 9, (uchar)chainid_00);
                } else {
                    if (iVar7 < 9)
                        break;
                    puVar2 = &uStack_149f1;
                    do {
                        puVar4 = data_buf + iVar6;
                        iVar6 = iVar6 + 1;
                        if (0x1229f < iVar6) {
                            iVar6 = 0;
                        }
                        puVar2 = puVar2 + 1;
                        *puVar2 = *puVar4;
                    } while (tmp + 8 != puVar2);
                    iVar7 = iVar7 + -9;
                    reg_handle(tmp, 9, chainid_00);
                }
            } else {
                iVar6 = iVar6 + 1;
                iVar7 = iVar7 + -1;
                if (0x1229f < iVar6) {
                    iVar6 = 0;
                }
            }
        }
    } while (true);
}

/* WARNING: Unknown calling convention */

void sha2_starts(sha2_context *ctx)

{
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    return;
}

/* WARNING: Unknown calling convention */

void sha2_process(sha2_context *ctx, uchar *data)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    uint uVar12;
    uint uVar13;
    uint uVar14;
    uint uVar15;
    uint uVar16;
    int iVar17;
    uint uVar18;
    uint uVar19;
    uint uVar20;
    uint uVar21;
    uint uVar22;
    uint uVar23;
    uint uVar24;
    uint uVar25;
    uint uVar26;
    uint uVar27;
    uint uVar28;
    uint uVar29;
    uint uVar30;
    uint uVar31;
    uint uVar32;
    uint uVar33;
    uint uVar34;
    uint uVar35;
    uint uVar36;
    uint uVar37;
    uint uVar38;
    uint uVar39;
    uint uVar40;
    uint uVar41;
    uint uVar42;
    uint uVar43;
    uint uVar44;
    uint uVar45;
    uint uVar46;
    uint uVar47;
    uint uVar48;
    uint uVar49;
    uint uVar50;
    uint uVar51;
    uint uVar52;
    uint uVar53;
    uint uVar54;
    uint uVar55;
    uint uVar56;
    uint uVar57;
    uint uVar58;
    uint uVar59;
    uint uVar60;
    uint uVar61;
    uint uVar62;
    uint uVar63;
    uint uVar64;

    uVar14 = ctx->state[6];
    uVar2 = ctx->state[4];
    uVar15 = ctx->state[1];
    uVar23 = ctx->state[0];
    uVar29 = ctx->state[5];
    uVar16 = ctx->state[2];
    uVar54 = *(uint *)data;
    uVar46 = uVar54 << 0x18 | (uVar54 >> 8 & 0xff) << 0x10 |
             (uVar54 >> 0x10 & 0xff) << 8 | uVar54 >> 0x18;
    iVar17 = ((uVar29 ^ uVar14) & uVar2 ^ uVar14) +
             ((uVar2 >> 0xb | uVar2 << 0x15) ^ (uVar2 >> 6 | uVar2 << 0x1a) ^
              (uVar2 >> 0x19 | uVar2 << 7)) +
             ctx->state[7] + 0x428a2f98 + uVar46;
    uVar38 = *(uint *)(data + 4);
    uVar59 = ctx->state[3] + iVar17;
    uVar54 = uVar38 << 0x18 | (uVar38 >> 8 & 0xff) << 0x10;
    uVar39 = uVar54 | (uVar38 >> 0x10 & 0xff) << 8 | uVar38 >> 0x18;
    uVar18 =
        (uVar23 & uVar15 | (uVar23 | uVar15) & uVar16) +
        ((uVar23 >> 0xd | uVar23 << 0x13) ^ (uVar23 >> 2 | uVar23 << 0x1e) ^
         (uVar23 >> 0x16 | uVar23 << 10)) +
        iVar17;
    uVar56 = *(uint *)(data + 8);
    uVar49 = *(uint *)(data + 0xc);
    iVar17 =
        ((uVar29 ^ uVar2) & uVar59 ^ uVar29) + uVar14 + 0x71374491 + uVar39 +
        ((uVar59 >> 0xb | uVar59 * 0x200000) ^
         (uVar59 >> 6 | uVar59 * 0x4000000) ^ (uVar59 >> 0x19 | uVar59 * 0x80));
    uVar27 = uVar56 << 0x18 | (uVar56 >> 8 & 0xff) << 0x10;
    uVar61 = uVar27 | (uVar56 >> 0x10 & 0xff) << 8 | uVar56 >> 0x18;
    uVar1 = ((uVar18 | uVar23) & uVar15 | uVar23 & uVar18) +
            ((uVar18 >> 0xd | uVar18 * 0x80000) ^
             (uVar18 >> 2 | uVar18 * 0x40000000) ^
             (uVar18 >> 0x16 | uVar18 * 0x400)) +
            iVar17;
    uVar47 = uVar16 + iVar17;
    uVar19 = *(uint *)(data + 0x10);
    uVar52 = uVar49 << 0x18 | (uVar49 >> 8 & 0xff) << 0x10;
    uVar50 = uVar52 | (uVar49 >> 0x10 & 0xff) << 8 | uVar49 >> 0x18;
    uVar20 = *(uint *)(data + 0x14);
    iVar17 =
        ((uVar2 ^ uVar59) & uVar47 ^ uVar2) + uVar29 + 0xb5c0fbcf + uVar61 +
        ((uVar47 >> 0xb | uVar47 * 0x200000) ^
         (uVar47 >> 6 | uVar47 * 0x4000000) ^ (uVar47 >> 0x19 | uVar47 * 0x80));
    uVar11 =
        ((uVar18 | uVar1) & uVar23 | uVar18 & uVar1) +
        ((uVar1 >> 0xd | uVar1 * 0x80000) ^ (uVar1 >> 2 | uVar1 * 0x40000000) ^
         (uVar1 >> 0x16 | uVar1 * 0x400)) +
        iVar17;
    uVar30 = *(uint *)(data + 0x18);
    uVar40 = uVar15 + iVar17;
    uVar3 = *(uint *)(data + 0x1c);
    iVar17 =
        ((uVar59 ^ uVar47) & uVar40 ^ uVar59) + uVar2 + 0xe9b5dba5 + uVar50 +
        ((uVar40 >> 0xb | uVar40 * 0x200000) ^
         (uVar40 >> 6 | uVar40 * 0x4000000) ^ (uVar40 >> 0x19 | uVar40 * 0x80));
    uVar21 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^
              (uVar11 >> 2 | uVar11 * 0x40000000) ^
              (uVar11 >> 0x16 | uVar11 * 0x400)) +
             ((uVar1 | uVar11) & uVar18 | uVar1 & uVar11) + iVar17;
    uVar57 = uVar23 + iVar17;
    uVar4 = *(uint *)(data + 0x20);
    uVar45 = uVar19 << 0x18 | (uVar19 >> 8 & 0xff) << 0x10;
    uVar5 = uVar45 | (uVar19 >> 0x10 & 0xff) << 8 | uVar19 >> 0x18;
    uVar6 = *(uint *)(data + 0x24);
    uVar31 = *(uint *)(data + 0x28);
    iVar17 =
        uVar59 + uVar5 + 0x3956c25b + ((uVar47 ^ uVar40) & uVar57 ^ uVar47) +
        ((uVar57 >> 0xb | uVar57 * 0x200000) ^
         (uVar57 >> 6 | uVar57 * 0x4000000) ^ (uVar57 >> 0x19 | uVar57 * 0x80));
    uVar18 = uVar18 + iVar17;
    uVar55 = ((uVar21 >> 0xd | uVar21 * 0x80000) ^
              (uVar21 >> 2 | uVar21 * 0x40000000) ^
              (uVar21 >> 0x16 | uVar21 * 0x400)) +
             ((uVar11 | uVar21) & uVar1 | uVar11 & uVar21) + iVar17;
    uVar24 = *(uint *)(data + 0x2c);
    uVar59 = uVar20 << 0x18 | (uVar20 >> 8 & 0xff) << 0x10;
    uVar32 = uVar59 | (uVar20 >> 0x10 & 0xff) << 8 | uVar20 >> 0x18;
    iVar17 = ((uVar18 >> 0xb | uVar18 * 0x200000) ^
              (uVar18 >> 6 | uVar18 * 0x4000000) ^
              (uVar18 >> 0x19 | uVar18 * 0x80)) +
             uVar47 + uVar32 + 0x59f111f1 +
             ((uVar40 ^ uVar57) & uVar18 ^ uVar40);
    uVar1 = uVar1 + iVar17;
    uVar60 = iVar17 + ((uVar21 | uVar55) & uVar11 | uVar21 & uVar55) +
             ((uVar55 >> 0xd | uVar55 * 0x80000) ^
              (uVar55 >> 2 | uVar55 * 0x40000000) ^
              (uVar55 >> 0x16 | uVar55 * 0x400));
    uVar62 = *(uint *)(data + 0x30);
    uVar47 = uVar30 << 0x18 | (uVar30 >> 8 & 0xff) << 0x10;
    uVar33 = uVar47 | (uVar30 >> 0x10 & 0xff) << 8 | uVar30 >> 0x18;
    iVar17 =
        ((uVar1 >> 0xb | uVar1 * 0x200000) ^ (uVar1 >> 6 | uVar1 * 0x4000000) ^
         (uVar1 >> 0x19 | uVar1 * 0x80)) +
        uVar40 + uVar33 + 0x923f82a4 + ((uVar57 ^ uVar18) & uVar1 ^ uVar57);
    uVar25 = *(uint *)(data + 0x38);
    uVar11 = uVar11 + iVar17;
    uVar48 = ((uVar60 >> 0xd | uVar60 * 0x80000) ^
              (uVar60 >> 2 | uVar60 * 0x40000000) ^
              (uVar60 >> 0x16 | uVar60 * 0x400)) +
             ((uVar55 | uVar60) & uVar21 | uVar55 & uVar60) + iVar17;
    uVar40 = uVar3 << 0x18 | (uVar3 >> 8 & 0xff) << 0x10;
    uVar7 = uVar40 | (uVar3 >> 0x10 & 0xff) << 8 | uVar3 >> 0x18;
    uVar34 = *(uint *)(data + 0x34);
    uVar53 = uVar62 << 0x18 | (uVar62 >> 8 & 0xff) << 0x10;
    uVar63 = uVar53 | (uVar62 >> 0x10 & 0xff) << 8 | uVar62 >> 0x18;
    uVar13 = uVar34 << 0x18 | (uVar34 >> 8 & 0xff) << 0x10;
    uVar35 = uVar13 | (uVar34 >> 0x10 & 0xff) << 8 | uVar34 >> 0x18;
    uVar26 = *(uint *)(data + 0x3c);
    uVar22 = uVar4 << 0x18 | (uVar4 >> 8 & 0xff) << 0x10;
    uVar41 = uVar22 | (uVar4 >> 0x10 & 0xff) << 8 | uVar4 >> 0x18;
    iVar17 = ((uVar11 >> 0xb | uVar11 * 0x200000) ^
              (uVar11 >> 6 | uVar11 * 0x4000000) ^
              (uVar11 >> 0x19 | uVar11 * 0x80)) +
             uVar57 + uVar7 + 0xab1c5ed5 + ((uVar18 ^ uVar1) & uVar11 ^ uVar18);
    uVar21 = uVar21 + iVar17;
    uVar57 = uVar6 << 0x18 | (uVar6 >> 8 & 0xff) << 0x10;
    uVar8 = uVar57 | (uVar6 >> 0x10 & 0xff) << 8 | uVar6 >> 0x18;
    uVar28 = uVar31 << 0x18 | (uVar31 >> 8 & 0xff) << 0x10;
    uVar42 = uVar28 | (uVar31 >> 0x10 & 0xff) << 8 | uVar31 >> 0x18;
    uVar51 = iVar17 +
             ((uVar48 >> 0xd | uVar48 * 0x80000) ^
              (uVar48 >> 2 | uVar48 * 0x40000000) ^
              (uVar48 >> 0x16 | uVar48 * 0x400)) +
             ((uVar60 | uVar48) & uVar55 | uVar60 & uVar48);
    uVar37 = uVar24 << 0x18 | (uVar24 >> 8 & 0xff) << 0x10;
    uVar9 = uVar37 | (uVar24 >> 0x10 & 0xff) << 8 | uVar24 >> 0x18;
    iVar17 = ((uVar21 >> 0xb | uVar21 * 0x200000) ^
              (uVar21 >> 6 | uVar21 * 0x4000000) ^
              (uVar21 >> 0x19 | uVar21 * 0x80)) +
             uVar18 + uVar41 + 0xd807aa98 + ((uVar1 ^ uVar11) & uVar21 ^ uVar1);
    uVar55 = uVar55 + iVar17;
    uVar58 = iVar17 +
             ((uVar51 >> 0xd | uVar51 * 0x80000) ^
              (uVar51 >> 2 | uVar51 * 0x40000000) ^
              (uVar51 >> 0x16 | uVar51 * 0x400)) +
             ((uVar48 | uVar51) & uVar60 | uVar48 & uVar51);
    iVar17 = ((uVar55 >> 0xb | uVar55 * 0x200000) ^
              (uVar55 >> 6 | uVar55 * 0x4000000) ^
              (uVar55 >> 0x19 | uVar55 * 0x80)) +
             uVar1 + uVar8 + 0x12835b01 + ((uVar11 ^ uVar21) & uVar55 ^ uVar11);
    uVar60 = uVar60 + iVar17;
    uVar1 = uVar25 << 0x18 | (uVar25 >> 8 & 0xff) << 0x10;
    uVar10 = uVar1 | (uVar25 >> 0x10 & 0xff) << 8;
    uVar43 = uVar10 | uVar25 >> 0x18;
    uVar64 = ((uVar58 >> 0xd | uVar58 * 0x80000) ^
              (uVar58 >> 2 | uVar58 * 0x40000000) ^
              (uVar58 >> 0x16 | uVar58 * 0x400)) +
             ((uVar51 | uVar58) & uVar48 | uVar51 & uVar58) + iVar17;
    uVar18 = uVar26 << 0x18 | (uVar26 >> 8 & 0xff) << 0x10;
    uVar12 = uVar18 | (uVar26 >> 0x10 & 0xff) << 8;
    uVar44 = uVar12 | uVar26 >> 0x18;
    iVar17 = ((uVar60 >> 0xb | uVar60 * 0x200000) ^
              (uVar60 >> 6 | uVar60 * 0x4000000) ^
              (uVar60 >> 0x19 | uVar60 * 0x80)) +
             uVar11 + uVar42 + 0x243185be +
             ((uVar21 ^ uVar55) & uVar60 ^ uVar21);
    uVar48 = uVar48 + iVar17;
    uVar36 = (uVar58 & uVar64 | (uVar58 | uVar64) & uVar51) +
             ((uVar64 >> 0xd | uVar64 * 0x80000) ^
              (uVar64 >> 2 | uVar64 * 0x40000000) ^
              (uVar64 >> 0x16 | uVar64 * 0x400)) +
             iVar17;
    iVar17 = ((uVar48 >> 0xb | uVar48 * 0x200000) ^
              (uVar48 >> 6 | uVar48 * 0x4000000) ^
              (uVar48 >> 0x19 | uVar48 * 0x80)) +
             uVar21 + uVar9 + 0x550c7dc3 +
             ((uVar55 ^ uVar60) & uVar48 ^ uVar55);
    uVar21 = (uVar64 & uVar36 | (uVar64 | uVar36) & uVar58) +
             ((uVar36 >> 0xd | uVar36 * 0x80000) ^
              (uVar36 >> 2 | uVar36 * 0x40000000) ^
              (uVar36 >> 0x16 | uVar36 * 0x400)) +
             iVar17;
    uVar51 = uVar51 + iVar17;
    iVar17 =
        uVar55 + uVar63 + 0x72be5d74 + ((uVar60 ^ uVar48) & uVar51 ^ uVar60) +
        ((uVar51 >> 0xb | uVar51 * 0x200000) ^
         (uVar51 >> 6 | uVar51 * 0x4000000) ^ (uVar51 >> 0x19 | uVar51 * 0x80));
    uVar55 = ((uVar36 | uVar21) & uVar64 | uVar36 & uVar21) +
             ((uVar21 >> 0xd | uVar21 * 0x80000) ^
              (uVar21 >> 2 | uVar21 * 0x40000000) ^
              (uVar21 >> 0x16 | uVar21 * 0x400)) +
             iVar17;
    uVar58 = uVar58 + iVar17;
    iVar17 =
        uVar60 + uVar35 + 0x80deb1fe + ((uVar48 ^ uVar51) & uVar58 ^ uVar48) +
        ((uVar58 >> 0xb | uVar58 * 0x200000) ^
         (uVar58 >> 6 | uVar58 * 0x4000000) ^ (uVar58 >> 0x19 | uVar58 * 0x80));
    uVar64 = uVar64 + iVar17;
    uVar11 = ((uVar21 | uVar55) & uVar36 | uVar21 & uVar55) +
             ((uVar55 >> 0xd | uVar55 * 0x80000) ^
              (uVar55 >> 2 | uVar55 * 0x40000000) ^
              (uVar55 >> 0x16 | uVar55 * 0x400)) +
             iVar17;
    iVar17 =
        uVar48 + uVar43 + 0x9bdc06a7 + ((uVar51 ^ uVar58) & uVar64 ^ uVar51) +
        ((uVar64 >> 0xb | uVar64 * 0x200000) ^
         (uVar64 >> 6 | uVar64 * 0x4000000) ^ (uVar64 >> 0x19 | uVar64 * 0x80));
    uVar36 = uVar36 + iVar17;
    uVar60 = ((uVar55 | uVar11) & uVar21 | uVar55 & uVar11) +
             ((uVar11 >> 0xd | uVar11 * 0x80000) ^
              (uVar11 >> 2 | uVar11 * 0x40000000) ^
              (uVar11 >> 0x16 | uVar11 * 0x400)) +
             iVar17;
    iVar17 =
        uVar51 + uVar44 + 0xc19bf174 + ((uVar58 ^ uVar64) & uVar36 ^ uVar58) +
        ((uVar36 >> 0xb | uVar36 * 0x200000) ^
         (uVar36 >> 6 | uVar36 * 0x4000000) ^ (uVar36 >> 0x19 | uVar36 * 0x80));
    uVar21 = uVar21 + iVar17;
    uVar48 = (uVar11 & uVar60 | (uVar11 | uVar60) & uVar55) +
             ((uVar60 >> 0xd | uVar60 * 0x80000) ^
              (uVar60 >> 2 | uVar60 * 0x40000000) ^
              (uVar60 >> 0x16 | uVar60 * 0x400)) +
             iVar17;
    uVar46 = ((uVar1 >> 0x13 | uVar43 << 0xd) ^
              (uVar1 >> 0x11 | uVar43 << 0xf) ^ uVar10 >> 10) +
             uVar46 + uVar8 +
             ((uVar54 >> 0x12 | uVar39 << 0xe) ^
              (uVar39 >> 7 | (uVar38 >> 0x18) << 0x19) ^ uVar39 >> 3);
    iVar17 =
        uVar58 + uVar46 + 0xe49b69c1 + ((uVar64 ^ uVar36) & uVar21 ^ uVar64) +
        ((uVar21 >> 0xb | uVar21 * 0x200000) ^
         (uVar21 >> 6 | uVar21 * 0x4000000) ^ (uVar21 >> 0x19 | uVar21 * 0x80));
    uVar38 = ((uVar60 | uVar48) & uVar11 | uVar60 & uVar48) +
             ((uVar48 >> 0xd | uVar48 * 0x80000) ^
              (uVar48 >> 2 | uVar48 * 0x40000000) ^
              (uVar48 >> 0x16 | uVar48 * 0x400)) +
             iVar17;
    uVar55 = uVar55 + iVar17;
    uVar39 = ((uVar27 >> 0x12 | uVar61 << 0xe) ^
              (uVar61 >> 7 | (uVar56 >> 0x18) << 0x19) ^ uVar61 >> 3) +
             ((uVar18 >> 0x13 | uVar44 << 0xd) ^
              (uVar18 >> 0x11 | uVar44 << 0xf) ^ uVar12 >> 10) +
             uVar39 + uVar42;
    iVar17 =
        ((uVar36 ^ uVar21) & uVar55 ^ uVar36) + uVar64 + uVar39 + 0xefbe4786 +
        ((uVar55 >> 0xb | uVar55 * 0x200000) ^
         (uVar55 >> 6 | uVar55 * 0x4000000) ^ (uVar55 >> 0x19 | uVar55 * 0x80));
    uVar11 = uVar11 + iVar17;
    uVar27 = ((uVar48 | uVar38) & uVar60 | uVar48 & uVar38) +
             ((uVar38 >> 0xd | uVar38 * 0x80000) ^
              (uVar38 >> 2 | uVar38 * 0x40000000) ^
              (uVar38 >> 0x16 | uVar38 * 0x400)) +
             iVar17;
    uVar49 = ((uVar52 >> 0x12 | uVar50 << 0xe) ^
              (uVar50 >> 7 | (uVar49 >> 0x18) << 0x19) ^ uVar50 >> 3) +
             uVar61 + uVar9 +
             ((uVar46 >> 0x13 | uVar46 * 0x2000) ^
              (uVar46 >> 0x11 | uVar46 * 0x8000) ^ uVar46 >> 10);
    iVar17 =
        ((uVar21 ^ uVar55) & uVar11 ^ uVar21) + uVar49 + 0xfc19dc6 + uVar36 +
        ((uVar11 >> 0xb | uVar11 * 0x200000) ^
         (uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0x19 | uVar11 * 0x80));
    uVar60 = uVar60 + iVar17;
    uVar54 = ((uVar27 >> 0xd | uVar27 * 0x80000) ^
              (uVar27 >> 2 | uVar27 * 0x40000000) ^
              (uVar27 >> 0x16 | uVar27 * 0x400)) +
             (uVar48 & (uVar38 | uVar27) | uVar38 & uVar27) + iVar17;
    uVar19 = uVar50 + uVar63 +
             ((uVar45 >> 0x12 | uVar5 << 0xe) ^
              (uVar5 >> 7 | (uVar19 >> 0x18) << 0x19) ^ uVar5 >> 3) +
             ((uVar39 >> 0x13 | uVar39 * 0x2000) ^
              (uVar39 >> 0x11 | uVar39 * 0x8000) ^ uVar39 >> 10);
    iVar17 =
        ((uVar55 ^ uVar11) & uVar60 ^ uVar55) + uVar19 + 0x240ca1cc + uVar21 +
        ((uVar60 >> 0xb | uVar60 * 0x200000) ^
         (uVar60 >> 6 | uVar60 * 0x4000000) ^ (uVar60 >> 0x19 | uVar60 * 0x80));
    uVar10 = ((uVar27 | uVar54) & uVar38 | uVar27 & uVar54) +
             ((uVar54 >> 0xd | uVar54 * 0x80000) ^
              (uVar54 >> 2 | uVar54 * 0x40000000) ^
              (uVar54 >> 0x16 | uVar54 * 0x400)) +
             iVar17;
    uVar48 = uVar48 + iVar17;
    uVar21 = ((uVar49 >> 0x13 | uVar49 * 0x2000) ^
              (uVar49 >> 0x11 | uVar49 * 0x8000) ^ uVar49 >> 10) +
             ((uVar59 >> 0x12 | uVar32 << 0xe) ^
              (uVar32 >> 7 | (uVar20 >> 0x18) << 0x19) ^ uVar32 >> 3) +
             uVar5 + uVar35;
    iVar17 =
        uVar55 + uVar21 + 0x2de92c6f + ((uVar11 ^ uVar60) & uVar48 ^ uVar11) +
        ((uVar48 >> 0xb | uVar48 * 0x200000) ^
         (uVar48 >> 6 | uVar48 * 0x4000000) ^ (uVar48 >> 0x19 | uVar48 * 0x80));
    uVar12 = ((uVar54 | uVar10) & uVar27 | uVar54 & uVar10) +
             ((uVar10 >> 0xd | uVar10 * 0x80000) ^
              (uVar10 >> 2 | uVar10 * 0x40000000) ^
              (uVar10 >> 0x16 | uVar10 * 0x400)) +
             iVar17;
    uVar38 = uVar38 + iVar17;
    uVar20 = ((uVar47 >> 0x12 | uVar33 << 0xe) ^
              (uVar33 >> 7 | (uVar30 >> 0x18) << 0x19) ^ uVar33 >> 3) +
             uVar32 + uVar43 +
             ((uVar19 >> 0x13 | uVar19 * 0x2000) ^
              (uVar19 >> 0x11 | uVar19 * 0x8000) ^ uVar19 >> 10);
    iVar17 =
        ((uVar60 ^ uVar48) & uVar38 ^ uVar60) + uVar20 + 0x4a7484aa + uVar11 +
        ((uVar38 >> 0xb | uVar38 * 0x200000) ^
         (uVar38 >> 6 | uVar38 * 0x4000000) ^ (uVar38 >> 0x19 | uVar38 * 0x80));
    uVar27 = uVar27 + iVar17;
    uVar47 = ((uVar10 | uVar12) & uVar54 | uVar10 & uVar12) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar17;
    uVar30 = ((uVar40 >> 0x12 | uVar7 << 0xe) ^
              (uVar7 >> 7 | (uVar3 >> 0x18) << 0x19) ^ uVar7 >> 3) +
             uVar33 + uVar44 +
             ((uVar21 >> 0x13 | uVar21 * 0x2000) ^
              (uVar21 >> 0x11 | uVar21 * 0x8000) ^ uVar21 >> 10);
    iVar17 = ((uVar27 >> 0xb | uVar27 * 0x200000) ^
              (uVar27 >> 6 | uVar27 * 0x4000000) ^
              (uVar27 >> 0x19 | uVar27 * 0x80)) +
             uVar60 + uVar30 + 0x5cb0a9dc +
             ((uVar48 ^ uVar38) & uVar27 ^ uVar48);
    uVar54 = uVar54 + iVar17;
    uVar45 = iVar17 +
             ((uVar47 >> 0xd | uVar47 * 0x80000) ^
              (uVar47 >> 2 | uVar47 * 0x40000000) ^
              (uVar47 >> 0x16 | uVar47 * 0x400)) +
             ((uVar12 | uVar47) & uVar10 | uVar12 & uVar47);
    uVar5 = ((uVar22 >> 0x12 | uVar41 << 0xe) ^
             (uVar41 >> 7 | (uVar4 >> 0x18) << 0x19) ^ uVar41 >> 3) +
            uVar7 + uVar46 +
            ((uVar20 >> 0x13 | uVar20 * 0x2000) ^
             (uVar20 >> 0x11 | uVar20 * 0x8000) ^ uVar20 >> 10);
    iVar17 = ((uVar54 >> 0xb | uVar54 * 0x200000) ^
              (uVar54 >> 6 | uVar54 * 0x4000000) ^
              (uVar54 >> 0x19 | uVar54 * 0x80)) +
             uVar48 + uVar5 + 0x76f988da +
             ((uVar38 ^ uVar27) & uVar54 ^ uVar38);
    uVar10 = uVar10 + iVar17;
    uVar52 = ((uVar45 >> 0xd | uVar45 * 0x80000) ^
              (uVar45 >> 2 | uVar45 * 0x40000000) ^
              (uVar45 >> 0x16 | uVar45 * 0x400)) +
             ((uVar47 | uVar45) & uVar12 | uVar47 & uVar45) + iVar17;
    uVar6 = ((uVar57 >> 0x12 | uVar8 << 0xe) ^
             (uVar8 >> 7 | (uVar6 >> 0x18) << 0x19) ^ uVar8 >> 3) +
            uVar41 + uVar39 +
            ((uVar30 >> 0x13 | uVar30 * 0x2000) ^
             (uVar30 >> 0x11 | uVar30 * 0x8000) ^ uVar30 >> 10);
    iVar17 = ((uVar10 >> 0xb | uVar10 * 0x200000) ^
              (uVar10 >> 6 | uVar10 * 0x4000000) ^
              (uVar10 >> 0x19 | uVar10 * 0x80)) +
             uVar38 + uVar6 + 0x983e5152 +
             ((uVar54 ^ uVar27) & uVar10 ^ uVar27);
    uVar12 = uVar12 + iVar17;
    uVar4 = iVar17 +
            ((uVar52 >> 0xd | uVar52 * 0x80000) ^
             (uVar52 >> 2 | uVar52 * 0x40000000) ^
             (uVar52 >> 0x16 | uVar52 * 0x400)) +
            ((uVar45 | uVar52) & uVar47 | uVar45 & uVar52);
    uVar7 = ((uVar28 >> 0x12 | uVar42 << 0xe) ^
             (uVar42 >> 7 | (uVar31 >> 0x18) << 0x19) ^ uVar42 >> 3) +
            uVar8 + uVar49 +
            ((uVar5 >> 0x13 | uVar5 * 0x2000) ^
             (uVar5 >> 0x11 | uVar5 * 0x8000) ^ uVar5 >> 10);
    iVar17 = ((uVar12 >> 0xb | uVar12 * 0x200000) ^
              (uVar12 >> 6 | uVar12 * 0x4000000) ^
              (uVar12 >> 0x19 | uVar12 * 0x80)) +
             uVar27 + uVar7 + 0xa831c66d +
             ((uVar54 ^ uVar10) & uVar12 ^ uVar54);
    uVar47 = uVar47 + iVar17;
    uVar40 =
        ((uVar4 >> 0xd | uVar4 * 0x80000) ^ (uVar4 >> 2 | uVar4 * 0x40000000) ^
         (uVar4 >> 0x16 | uVar4 * 0x400)) +
        ((uVar52 | uVar4) & uVar45 | uVar52 & uVar4) + iVar17;
    uVar11 = ((uVar6 >> 0x13 | uVar6 * 0x2000) ^
              (uVar6 >> 0x11 | uVar6 * 0x8000) ^ uVar6 >> 10) +
             ((uVar37 >> 0x12 | uVar9 << 0xe) ^
              (uVar9 >> 7 | (uVar24 >> 0x18) << 0x19) ^ uVar9 >> 3) +
             uVar42 + uVar19;
    iVar17 = ((uVar47 >> 0xb | uVar47 * 0x200000) ^
              (uVar47 >> 6 | uVar47 * 0x4000000) ^
              (uVar47 >> 0x19 | uVar47 * 0x80)) +
             uVar54 + uVar11 + 0xb00327c8 +
             ((uVar10 ^ uVar12) & uVar47 ^ uVar10);
    uVar45 = uVar45 + iVar17;
    uVar54 = ((uVar40 >> 0xd | uVar40 * 0x80000) ^
              (uVar40 >> 2 | uVar40 * 0x40000000) ^
              (uVar40 >> 0x16 | uVar40 * 0x400)) +
             ((uVar4 | uVar40) & uVar52 | uVar4 & uVar40) + iVar17;
    uVar3 = ((uVar7 >> 0x13 | uVar7 * 0x2000) ^
             (uVar7 >> 0x11 | uVar7 * 0x8000) ^ uVar7 >> 10) +
            ((uVar53 >> 0x12 | uVar63 << 0xe) ^
             (uVar63 >> 7 | (uVar62 >> 0x18) << 0x19) ^ uVar63 >> 3) +
            uVar9 + uVar21;
    iVar17 = ((uVar45 >> 0xb | uVar45 * 0x200000) ^
              (uVar45 >> 6 | uVar45 * 0x4000000) ^
              (uVar45 >> 0x19 | uVar45 * 0x80)) +
             uVar10 + uVar3 + 0xbf597fc7 +
             ((uVar12 ^ uVar47) & uVar45 ^ uVar12);
    uVar52 = uVar52 + iVar17;
    uVar59 = ((uVar54 >> 0xd | uVar54 * 0x80000) ^
              (uVar54 >> 2 | uVar54 * 0x40000000) ^
              (uVar54 >> 0x16 | uVar54 * 0x400)) +
             ((uVar40 | uVar54) & uVar4 | uVar40 & uVar54) + iVar17;
    uVar10 = ((uVar13 >> 0x12 | uVar35 << 0xe) ^
              (uVar35 >> 7 | (uVar34 >> 0x18) << 0x19) ^ uVar35 >> 3) +
             uVar63 + uVar20 +
             ((uVar11 >> 0x13 | uVar11 * 0x2000) ^
              (uVar11 >> 0x11 | uVar11 * 0x8000) ^ uVar11 >> 10);
    iVar17 = ((uVar52 >> 0xb | uVar52 * 0x200000) ^
              (uVar52 >> 6 | uVar52 * 0x4000000) ^
              (uVar52 >> 0x19 | uVar52 * 0x80)) +
             uVar12 + uVar10 + 0xc6e00bf3 +
             ((uVar47 ^ uVar45) & uVar52 ^ uVar47);
    uVar4 = uVar4 + iVar17;
    uVar57 = iVar17 +
             ((uVar59 >> 0xd | uVar59 * 0x80000) ^
              (uVar59 >> 2 | uVar59 * 0x40000000) ^
              (uVar59 >> 0x16 | uVar59 * 0x400)) +
             ((uVar54 | uVar59) & uVar40 | uVar54 & uVar59);
    uVar8 = ((uVar3 >> 0x13 | uVar3 * 0x2000) ^
             (uVar3 >> 0x11 | uVar3 * 0x8000) ^ uVar3 >> 10) +
            ((uVar1 >> 0x12 | uVar43 << 0xe) ^
             (uVar43 >> 7 | (uVar25 >> 0x18) << 0x19) ^ uVar43 >> 3) +
            uVar35 + uVar30;
    iVar17 =
        ((uVar4 >> 0xb | uVar4 * 0x200000) ^ (uVar4 >> 6 | uVar4 * 0x4000000) ^
         (uVar4 >> 0x19 | uVar4 * 0x80)) +
        uVar47 + uVar8 + 0xd5a79147 + ((uVar45 ^ uVar52) & uVar4 ^ uVar45);
    uVar40 = uVar40 + iVar17;
    uVar22 = ((uVar57 >> 0xd | uVar57 * 0x80000) ^
              (uVar57 >> 2 | uVar57 * 0x40000000) ^
              (uVar57 >> 0x16 | uVar57 * 0x400)) +
             ((uVar59 | uVar57) & uVar54 | uVar59 & uVar57) + iVar17;
    uVar9 = ((uVar18 >> 0x12 | uVar44 << 0xe) ^
             (uVar44 >> 7 | (uVar26 >> 0x18) << 0x19) ^ uVar44 >> 3) +
            uVar43 + uVar5 +
            ((uVar10 >> 0x13 | uVar10 * 0x2000) ^
             (uVar10 >> 0x11 | uVar10 * 0x8000) ^ uVar10 >> 10);
    iVar17 = ((uVar40 >> 0xb | uVar40 * 0x200000) ^
              (uVar40 >> 6 | uVar40 * 0x4000000) ^
              (uVar40 >> 0x19 | uVar40 * 0x80)) +
             uVar45 + uVar9 + 0x6ca6351 + ((uVar52 ^ uVar4) & uVar40 ^ uVar52);
    uVar54 = uVar54 + iVar17;
    uVar37 = iVar17 +
             ((uVar22 >> 0xd | uVar22 * 0x80000) ^
              (uVar22 >> 2 | uVar22 * 0x40000000) ^
              (uVar22 >> 0x16 | uVar22 * 0x400)) +
             ((uVar57 | uVar22) & uVar59 | uVar57 & uVar22);
    uVar18 = ((uVar8 >> 0x13 | uVar8 * 0x2000) ^
              (uVar8 >> 0x11 | uVar8 * 0x8000) ^ uVar8 >> 10) +
             ((uVar46 >> 0x12 | uVar46 * 0x4000) ^
              (uVar46 >> 7 | uVar46 * 0x2000000) ^ uVar46 >> 3) +
             uVar44 + uVar6;
    iVar17 = ((uVar54 >> 0xb | uVar54 * 0x200000) ^
              (uVar54 >> 6 | uVar54 * 0x4000000) ^
              (uVar54 >> 0x19 | uVar54 * 0x80)) +
             uVar52 + uVar18 + 0x14292967 + ((uVar4 ^ uVar40) & uVar54 ^ uVar4);
    uVar59 = uVar59 + iVar17;
    uVar12 = ((uVar39 >> 0x12 | uVar39 * 0x4000) ^
              (uVar39 >> 7 | uVar39 * 0x2000000) ^ uVar39 >> 3) +
             uVar46 + uVar7 +
             ((uVar9 >> 0x13 | uVar9 * 0x2000) ^
              (uVar9 >> 0x11 | uVar9 * 0x8000) ^ uVar9 >> 10);
    uVar1 = iVar17 +
            ((uVar37 >> 0xd | uVar37 * 0x80000) ^
             (uVar37 >> 2 | uVar37 * 0x40000000) ^
             (uVar37 >> 0x16 | uVar37 * 0x400)) +
            ((uVar22 | uVar37) & uVar57 | uVar22 & uVar37);
    iVar17 = ((uVar59 >> 0xb | uVar59 * 0x200000) ^
              (uVar59 >> 6 | uVar59 * 0x4000000) ^
              (uVar59 >> 0x19 | uVar59 * 0x80)) +
             uVar4 + uVar12 + 0x27b70a85 +
             ((uVar40 ^ uVar54) & uVar59 ^ uVar40);
    uVar57 = uVar57 + iVar17;
    uVar45 =
        ((uVar1 >> 0xd | uVar1 * 0x80000) ^ (uVar1 >> 2 | uVar1 * 0x40000000) ^
         (uVar1 >> 0x16 | uVar1 * 0x400)) +
        ((uVar37 | uVar1) & uVar22 | uVar37 & uVar1) + iVar17;
    uVar47 = ((uVar49 >> 0x12 | uVar49 * 0x4000) ^
              (uVar49 >> 7 | uVar49 * 0x2000000) ^ uVar49 >> 3) +
             uVar39 + uVar11 +
             ((uVar18 >> 0x13 | uVar18 * 0x2000) ^
              (uVar18 >> 0x11 | uVar18 * 0x8000) ^ uVar18 >> 10);
    iVar17 = ((uVar57 >> 0xb | uVar57 * 0x200000) ^
              (uVar57 >> 6 | uVar57 * 0x4000000) ^
              (uVar57 >> 0x19 | uVar57 * 0x80)) +
             uVar40 + uVar47 + 0x2e1b2138 +
             ((uVar54 ^ uVar59) & uVar57 ^ uVar54);
    uVar22 = uVar22 + iVar17;
    uVar52 = ((uVar45 >> 0xd | uVar45 * 0x80000) ^
              (uVar45 >> 2 | uVar45 * 0x40000000) ^
              (uVar45 >> 0x16 | uVar45 * 0x400)) +
             ((uVar1 | uVar45) & uVar37 | uVar1 & uVar45) + iVar17;
    uVar48 = ((uVar19 >> 0x12 | uVar19 * 0x4000) ^
              (uVar19 >> 7 | uVar19 * 0x2000000) ^ uVar19 >> 3) +
             uVar49 + uVar3 +
             ((uVar12 >> 0x13 | uVar12 * 0x2000) ^
              (uVar12 >> 0x11 | uVar12 * 0x8000) ^ uVar12 >> 10);
    iVar17 = ((uVar22 >> 0xb | uVar22 * 0x200000) ^
              (uVar22 >> 6 | uVar22 * 0x4000000) ^
              (uVar22 >> 0x19 | uVar22 * 0x80)) +
             uVar54 + uVar48 + 0x4d2c6dfc +
             ((uVar59 ^ uVar57) & uVar22 ^ uVar59);
    uVar37 = uVar37 + iVar17;
    uVar40 = ((uVar52 >> 0xd | uVar52 * 0x80000) ^
              (uVar52 >> 2 | uVar52 * 0x40000000) ^
              (uVar52 >> 0x16 | uVar52 * 0x400)) +
             ((uVar45 | uVar52) & uVar1 | uVar45 & uVar52) + iVar17;
    uVar54 = ((uVar21 >> 0x12 | uVar21 * 0x4000) ^
              (uVar21 >> 7 | uVar21 * 0x2000000) ^ uVar21 >> 3) +
             uVar19 + uVar10 +
             ((uVar47 >> 0x13 | uVar47 * 0x2000) ^
              (uVar47 >> 0x11 | uVar47 * 0x8000) ^ uVar47 >> 10);
    iVar17 =
        uVar54 + 0x53380d13 + uVar59 + ((uVar57 ^ uVar22) & uVar37 ^ uVar57) +
        ((uVar37 >> 0xb | uVar37 * 0x200000) ^
         (uVar37 >> 6 | uVar37 * 0x4000000) ^ (uVar37 >> 0x19 | uVar37 * 0x80));
    uVar1 = uVar1 + iVar17;
    uVar13 = ((uVar52 | uVar40) & uVar45 | uVar52 & uVar40) +
             ((uVar40 >> 0xd | uVar40 * 0x80000) ^
              (uVar40 >> 2 | uVar40 * 0x40000000) ^
              (uVar40 >> 0x16 | uVar40 * 0x400)) +
             iVar17;
    uVar21 = ((uVar20 >> 0x12 | uVar20 * 0x4000) ^
              (uVar20 >> 7 | uVar20 * 0x2000000) ^ uVar20 >> 3) +
             uVar21 + uVar8 +
             ((uVar48 >> 0x13 | uVar48 * 0x2000) ^
              (uVar48 >> 0x11 | uVar48 * 0x8000) ^ uVar48 >> 10);
    iVar17 =
        uVar57 + uVar21 + 0x650a7354 + ((uVar37 ^ uVar22) & uVar1 ^ uVar22) +
        ((uVar1 >> 0xb | uVar1 * 0x200000) ^ (uVar1 >> 6 | uVar1 * 0x4000000) ^
         (uVar1 >> 0x19 | uVar1 * 0x80));
    uVar45 = uVar45 + iVar17;
    uVar28 = ((uVar40 | uVar13) & uVar52 | uVar40 & uVar13) +
             ((uVar13 >> 0xd | uVar13 * 0x80000) ^
              (uVar13 >> 2 | uVar13 * 0x40000000) ^
              (uVar13 >> 0x16 | uVar13 * 0x400)) +
             iVar17;
    uVar19 = ((uVar54 >> 0x13 | uVar54 * 0x2000) ^
              (uVar54 >> 0x11 | uVar54 * 0x8000) ^ uVar54 >> 10) +
             ((uVar30 >> 0x12 | uVar30 * 0x4000) ^
              (uVar30 >> 7 | uVar30 * 0x2000000) ^ uVar30 >> 3) +
             uVar20 + uVar9;
    iVar17 = ((uVar45 >> 0xb | uVar45 * 0x200000) ^
              (uVar45 >> 6 | uVar45 * 0x4000000) ^
              (uVar45 >> 0x19 | uVar45 * 0x80)) +
             uVar22 + uVar19 + 0x766a0abb +
             ((uVar37 ^ uVar1) & uVar45 ^ uVar37);
    uVar52 = uVar52 + iVar17;
    uVar57 = ((uVar13 | uVar28) & uVar40 | uVar13 & uVar28) +
             ((uVar28 >> 0xd | uVar28 * 0x80000) ^
              (uVar28 >> 2 | uVar28 * 0x40000000) ^
              (uVar28 >> 0x16 | uVar28 * 0x400)) +
             iVar17;
    uVar4 = ((uVar5 >> 0x12 | uVar5 * 0x4000) ^
             (uVar5 >> 7 | uVar5 * 0x2000000) ^ uVar5 >> 3) +
            uVar30 + uVar18 +
            ((uVar21 >> 0x13 | uVar21 * 0x2000) ^
             (uVar21 >> 0x11 | uVar21 * 0x8000) ^ uVar21 >> 10);
    iVar17 = ((uVar52 >> 0xb | uVar52 * 0x200000) ^
              (uVar52 >> 6 | uVar52 * 0x4000000) ^
              (uVar52 >> 0x19 | uVar52 * 0x80)) +
             uVar37 + uVar4 + 0x81c2c92e + ((uVar1 ^ uVar45) & uVar52 ^ uVar1);
    uVar40 = uVar40 + iVar17;
    uVar37 = ((uVar28 | uVar57) & uVar13 | uVar28 & uVar57) +
             ((uVar57 >> 0xd | uVar57 * 0x80000) ^
              (uVar57 >> 2 | uVar57 * 0x40000000) ^
              (uVar57 >> 0x16 | uVar57 * 0x400)) +
             iVar17;
    uVar53 = ((uVar6 >> 0x12 | uVar6 * 0x4000) ^
              (uVar6 >> 7 | uVar6 * 0x2000000) ^ uVar6 >> 3) +
             uVar5 + uVar12 +
             ((uVar19 >> 0x13 | uVar19 * 0x2000) ^
              (uVar19 >> 0x11 | uVar19 * 0x8000) ^ uVar19 >> 10);
    iVar17 = ((uVar40 >> 0xb | uVar40 * 0x200000) ^
              (uVar40 >> 6 | uVar40 * 0x4000000) ^
              (uVar40 >> 0x19 | uVar40 * 0x80)) +
             uVar53 + 0x92722c85 + uVar1 +
             ((uVar45 ^ uVar52) & uVar40 ^ uVar45);
    uVar13 = uVar13 + iVar17;
    uVar1 = ((uVar57 | uVar37) & uVar28 | uVar57 & uVar37) +
            ((uVar37 >> 0xd | uVar37 * 0x80000) ^
             (uVar37 >> 2 | uVar37 * 0x40000000) ^
             (uVar37 >> 0x16 | uVar37 * 0x400)) +
            iVar17;
    uVar27 = ((uVar7 >> 0x12 | uVar7 * 0x4000) ^
              (uVar7 >> 7 | uVar7 * 0x2000000) ^ uVar7 >> 3) +
             uVar6 + uVar47 +
             ((uVar4 >> 0x13 | uVar4 * 0x2000) ^
              (uVar4 >> 0x11 | uVar4 * 0x8000) ^ uVar4 >> 10);
    iVar17 = ((uVar13 >> 0xb | uVar13 * 0x200000) ^
              (uVar13 >> 6 | uVar13 * 0x4000000) ^
              (uVar13 >> 0x19 | uVar13 * 0x80)) +
             ((uVar52 ^ uVar40) & uVar13 ^ uVar52) + uVar27 + 0xa2bfe8a1 +
             uVar45;
    uVar28 = uVar28 + iVar17;
    uVar22 =
        ((uVar37 | uVar1) & uVar57 | uVar37 & uVar1) +
        ((uVar1 >> 0xd | uVar1 * 0x80000) ^ (uVar1 >> 2 | uVar1 * 0x40000000) ^
         (uVar1 >> 0x16 | uVar1 * 0x400)) +
        iVar17;
    uVar5 = ((uVar53 >> 0x13 | uVar53 * 0x2000) ^
             (uVar53 >> 0x11 | uVar53 * 0x8000) ^ uVar53 >> 10) +
            ((uVar11 >> 0x12 | uVar11 * 0x4000) ^
             (uVar11 >> 7 | uVar11 * 0x2000000) ^ uVar11 >> 3) +
            uVar7 + uVar48;
    iVar17 = ((uVar28 >> 0xb | uVar28 * 0x200000) ^
              (uVar28 >> 6 | uVar28 * 0x4000000) ^
              (uVar28 >> 0x19 | uVar28 * 0x80)) +
             uVar52 + uVar5 + 0xa81a664b +
             ((uVar40 ^ uVar13) & uVar28 ^ uVar40);
    uVar57 = uVar57 + iVar17;
    uVar45 = (uVar37 & (uVar1 | uVar22) | uVar1 & uVar22) +
             ((uVar22 >> 0xd | uVar22 * 0x80000) ^
              (uVar22 >> 2 | uVar22 * 0x40000000) ^
              (uVar22 >> 0x16 | uVar22 * 0x400)) +
             iVar17;
    uVar20 = ((uVar27 >> 0x13 | uVar27 * 0x2000) ^
              (uVar27 >> 0x11 | uVar27 * 0x8000) ^ uVar27 >> 10) +
             ((uVar3 >> 0x12 | uVar3 * 0x4000) ^
              (uVar3 >> 7 | uVar3 * 0x2000000) ^ uVar3 >> 3) +
             uVar11 + uVar54;
    iVar17 = ((uVar57 >> 0xb | uVar57 * 0x200000) ^
              (uVar57 >> 6 | uVar57 * 0x4000000) ^
              (uVar57 >> 0x19 | uVar57 * 0x80)) +
             ((uVar13 ^ uVar28) & uVar57 ^ uVar13) + uVar20 + 0xc24b8b70 +
             uVar40;
    uVar11 = ((uVar22 | uVar45) & uVar1 | uVar22 & uVar45) +
             ((uVar45 >> 0xd | uVar45 * 0x80000) ^
              (uVar45 >> 2 | uVar45 * 0x40000000) ^
              (uVar45 >> 0x16 | uVar45 * 0x400)) +
             iVar17;
    uVar37 = uVar37 + iVar17;
    uVar59 = ((uVar10 >> 0x12 | uVar10 * 0x4000) ^
              (uVar10 >> 7 | uVar10 * 0x2000000) ^ uVar10 >> 3) +
             uVar3 + uVar21 +
             ((uVar5 >> 0x13 | uVar5 * 0x2000) ^
              (uVar5 >> 0x11 | uVar5 * 0x8000) ^ uVar5 >> 10);
    iVar17 =
        ((uVar28 ^ uVar57) & uVar37 ^ uVar28) + uVar59 + 0xc76c51a3 + uVar13 +
        ((uVar37 >> 0xb | uVar37 * 0x200000) ^
         (uVar37 >> 6 | uVar37 * 0x4000000) ^ (uVar37 >> 0x19 | uVar37 * 0x80));
    uVar1 = uVar1 + iVar17;
    uVar52 = ((uVar45 | uVar11) & uVar22 | uVar45 & uVar11) +
             ((uVar11 >> 0xd | uVar11 * 0x80000) ^
              (uVar11 >> 2 | uVar11 * 0x40000000) ^
              (uVar11 >> 0x16 | uVar11 * 0x400)) +
             iVar17;
    uVar6 = ((uVar20 >> 0x13 | uVar20 * 0x2000) ^
             (uVar20 >> 0x11 | uVar20 * 0x8000) ^ uVar20 >> 10) +
            ((uVar8 >> 0x12 | uVar8 * 0x4000) ^
             (uVar8 >> 7 | uVar8 * 0x2000000) ^ uVar8 >> 3) +
            uVar10 + uVar19;
    iVar17 =
        ((uVar1 >> 0xb | uVar1 * 0x200000) ^ (uVar1 >> 6 | uVar1 * 0x4000000) ^
         (uVar1 >> 0x19 | uVar1 * 0x80)) +
        uVar28 + uVar6 + 0xd192e819 + ((uVar57 ^ uVar37) & uVar1 ^ uVar57);
    uVar28 = ((uVar11 | uVar52) & uVar45 | uVar11 & uVar52) +
             ((uVar52 >> 0xd | uVar52 * 0x80000) ^
              (uVar52 >> 2 | uVar52 * 0x40000000) ^
              (uVar52 >> 0x16 | uVar52 * 0x400)) +
             iVar17;
    uVar7 = ((uVar9 >> 0x12 | uVar9 * 0x4000) ^
             (uVar9 >> 7 | uVar9 * 0x2000000) ^ uVar9 >> 3) +
            uVar8 + uVar4 +
            ((uVar59 >> 0x13 | uVar59 * 0x2000) ^
             (uVar59 >> 0x11 | uVar59 * 0x8000) ^ uVar59 >> 10);
    uVar22 = uVar22 + iVar17;
    iVar17 = ((uVar22 >> 0xb | uVar22 * 0x200000) ^
              (uVar22 >> 6 | uVar22 * 0x4000000) ^
              (uVar22 >> 0x19 | uVar22 * 0x80)) +
             ((uVar37 ^ uVar1) & uVar22 ^ uVar37) + uVar7 + 0xd6990624 + uVar57;
    uVar45 = uVar45 + iVar17;
    uVar8 = ((uVar18 >> 0x12 | uVar18 * 0x4000) ^
             (uVar18 >> 7 | uVar18 * 0x2000000) ^ uVar18 >> 3) +
            uVar9 + uVar53 +
            ((uVar6 >> 0x13 | uVar6 * 0x2000) ^
             (uVar6 >> 0x11 | uVar6 * 0x8000) ^ uVar6 >> 10);
    uVar57 = ((uVar52 | uVar28) & uVar11 | uVar52 & uVar28) +
             ((uVar28 >> 0xd | uVar28 * 0x80000) ^
              (uVar28 >> 2 | uVar28 * 0x40000000) ^
              (uVar28 >> 0x16 | uVar28 * 0x400)) +
             iVar17;
    iVar17 = ((uVar45 >> 0xb | uVar45 * 0x200000) ^
              (uVar45 >> 6 | uVar45 * 0x4000000) ^
              (uVar45 >> 0x19 | uVar45 * 0x80)) +
             ((uVar1 ^ uVar22) & uVar45 ^ uVar1) + uVar37 + uVar8 + 0xf40e3585;
    uVar11 = uVar11 + iVar17;
    uVar13 = ((uVar28 | uVar57) & uVar52 | uVar28 & uVar57) +
             ((uVar57 >> 0xd | uVar57 * 0x80000) ^
              (uVar57 >> 2 | uVar57 * 0x40000000) ^
              (uVar57 >> 0x16 | uVar57 * 0x400)) +
             iVar17;
    uVar37 = ((uVar12 >> 0x12 | uVar12 * 0x4000) ^
              (uVar12 >> 7 | uVar12 * 0x2000000) ^ uVar12 >> 3) +
             uVar18 + uVar27 +
             ((uVar7 >> 0x13 | uVar7 * 0x2000) ^
              (uVar7 >> 0x11 | uVar7 * 0x8000) ^ uVar7 >> 10);
    iVar17 = ((uVar11 >> 0xb | uVar11 * 0x200000) ^
              (uVar11 >> 6 | uVar11 * 0x4000000) ^
              (uVar11 >> 0x19 | uVar11 * 0x80)) +
             ((uVar22 ^ uVar45) & uVar11 ^ uVar22) + uVar37 + 0x106aa070 +
             uVar1;
    uVar52 = uVar52 + iVar17;
    uVar1 = ((uVar57 | uVar13) & uVar28 | uVar57 & uVar13) +
            ((uVar13 >> 0xd | uVar13 * 0x80000) ^
             (uVar13 >> 2 | uVar13 * 0x40000000) ^
             (uVar13 >> 0x16 | uVar13 * 0x400)) +
            iVar17;
    uVar10 = ((uVar8 >> 0x13 | uVar8 * 0x2000) ^
              (uVar8 >> 0x11 | uVar8 * 0x8000) ^ uVar8 >> 10) +
             ((uVar47 >> 0x12 | uVar47 * 0x4000) ^
              (uVar47 >> 7 | uVar47 * 0x2000000) ^ uVar47 >> 3) +
             uVar12 + uVar5;
    iVar17 = ((uVar52 >> 0xb | uVar52 * 0x200000) ^
              (uVar52 >> 6 | uVar52 * 0x4000000) ^
              (uVar52 >> 0x19 | uVar52 * 0x80)) +
             ((uVar45 ^ uVar11) & uVar52 ^ uVar45) + uVar10 + 0x19a4c116 +
             uVar22;
    uVar28 = uVar28 + iVar17;
    uVar12 =
        ((uVar13 | uVar1) & uVar57 | uVar13 & uVar1) +
        ((uVar1 >> 0xd | uVar1 * 0x80000) ^ (uVar1 >> 2 | uVar1 * 0x40000000) ^
         (uVar1 >> 0x16 | uVar1 * 0x400)) +
        iVar17;
    uVar40 = ((uVar37 >> 0x13 | uVar37 * 0x2000) ^
              (uVar37 >> 0x11 | uVar37 * 0x8000) ^ uVar37 >> 10) +
             ((uVar48 >> 0x12 | uVar48 * 0x4000) ^
              (uVar48 >> 7 | uVar48 * 0x2000000) ^ uVar48 >> 3) +
             uVar47 + uVar20;
    iVar17 = ((uVar28 >> 0xb | uVar28 * 0x200000) ^
              (uVar28 >> 6 | uVar28 * 0x4000000) ^
              (uVar28 >> 0x19 | uVar28 * 0x80)) +
             ((uVar11 ^ uVar52) & uVar28 ^ uVar11) + uVar40 + 0x1e376c08 +
             uVar45;
    uVar57 = uVar57 + iVar17;
    uVar22 = (uVar13 & (uVar1 | uVar12) | uVar1 & uVar12) +
             ((uVar12 >> 0xd | uVar12 * 0x80000) ^
              (uVar12 >> 2 | uVar12 * 0x40000000) ^
              (uVar12 >> 0x16 | uVar12 * 0x400)) +
             iVar17;
    uVar18 = ((uVar10 >> 0x13 | uVar10 * 0x2000) ^
              (uVar10 >> 0x11 | uVar10 * 0x8000) ^ uVar10 >> 10) +
             ((uVar54 >> 0x12 | uVar54 * 0x4000) ^
              (uVar54 >> 7 | uVar54 * 0x2000000) ^ uVar54 >> 3) +
             uVar48 + uVar59;
    iVar17 = ((uVar57 >> 0xb | uVar57 * 0x200000) ^
              (uVar57 >> 6 | uVar57 * 0x4000000) ^
              (uVar57 >> 0x19 | uVar57 * 0x80)) +
             ((uVar52 ^ uVar28) & uVar57 ^ uVar52) + uVar11 + uVar18 +
             0x2748774c;
    uVar13 = uVar13 + iVar17;
    uVar45 = iVar17 + ((uVar12 | uVar22) & uVar1 | uVar12 & uVar22) +
             ((uVar22 >> 0xd | uVar22 * 0x80000) ^
              (uVar22 >> 2 | uVar22 * 0x40000000) ^
              (uVar22 >> 0x16 | uVar22 * 0x400));
    uVar9 = ((uVar40 >> 0x13 | uVar40 * 0x2000) ^
             (uVar40 >> 0x11 | uVar40 * 0x8000) ^ uVar40 >> 10) +
            uVar54 +
            ((uVar21 >> 0x12 | uVar21 * 0x4000) ^
             (uVar21 >> 7 | uVar21 * 0x2000000) ^ uVar21 >> 3) +
            uVar6;
    iVar17 = ((uVar13 >> 0xb | uVar13 * 0x200000) ^
              (uVar13 >> 6 | uVar13 * 0x4000000) ^
              (uVar13 >> 0x19 | uVar13 * 0x80)) +
             ((uVar28 ^ uVar57) & uVar13 ^ uVar28) + uVar52 + uVar9 +
             0x34b0bcb5;
    uVar1 = uVar1 + iVar17;
    uVar21 = ((uVar19 >> 0x12 | uVar19 * 0x4000) ^
              (uVar19 >> 7 | uVar19 * 0x2000000) ^ uVar19 >> 3) +
             uVar21 + uVar7 +
             ((uVar18 >> 0x13 | uVar18 * 0x2000) ^
              (uVar18 >> 0x11 | uVar18 * 0x8000) ^ uVar18 >> 10);
    uVar3 = iVar17 +
            ((uVar45 >> 0xd | uVar45 * 0x80000) ^
             (uVar45 >> 2 | uVar45 * 0x40000000) ^
             (uVar45 >> 0x16 | uVar45 * 0x400)) +
            ((uVar22 | uVar45) & uVar12 | uVar22 & uVar45);
    iVar17 =
        ((uVar1 >> 0xb | uVar1 * 0x200000) ^ (uVar1 >> 6 | uVar1 * 0x4000000) ^
         (uVar1 >> 0x19 | uVar1 * 0x80)) +
        ((uVar57 ^ uVar13) & uVar1 ^ uVar57) + uVar28 + uVar21 + 0x391c0cb3;
    uVar12 = uVar12 + iVar17;
    uVar19 = ((uVar4 >> 0x12 | uVar4 * 0x4000) ^
              (uVar4 >> 7 | uVar4 * 0x2000000) ^ uVar4 >> 3) +
             uVar19 + uVar8 +
             ((uVar9 >> 0x13 | uVar9 * 0x2000) ^
              (uVar9 >> 0x11 | uVar9 * 0x8000) ^ uVar9 >> 10);
    uVar11 =
        iVar17 +
        ((uVar3 >> 0xd | uVar3 * 0x80000) ^ (uVar3 >> 2 | uVar3 * 0x40000000) ^
         (uVar3 >> 0x16 | uVar3 * 0x400)) +
        ((uVar45 | uVar3) & uVar22 | uVar45 & uVar3);
    iVar17 = ((uVar12 >> 0xb | uVar12 * 0x200000) ^
              (uVar12 >> 6 | uVar12 * 0x4000000) ^
              (uVar12 >> 0x19 | uVar12 * 0x80)) +
             ((uVar13 ^ uVar1) & uVar12 ^ uVar13) + uVar57 + uVar19 +
             0x4ed8aa4a;
    uVar22 = uVar22 + iVar17;
    uVar52 = iVar17 +
             ((uVar11 >> 0xd | uVar11 * 0x80000) ^
              (uVar11 >> 2 | uVar11 * 0x40000000) ^
              (uVar11 >> 0x16 | uVar11 * 0x400)) +
             ((uVar3 | uVar11) & uVar45 | uVar3 & uVar11);
    uVar4 = ((uVar53 >> 0x12 | uVar53 * 0x4000) ^
             (uVar53 >> 7 | uVar53 * 0x2000000) ^ uVar53 >> 3) +
            uVar4 + uVar37 +
            ((uVar21 >> 0x13 | uVar21 * 0x2000) ^
             (uVar21 >> 0x11 | uVar21 * 0x8000) ^ uVar21 >> 10);
    iVar17 = ((uVar22 >> 0xb | uVar22 * 0x200000) ^
              (uVar22 >> 6 | uVar22 * 0x4000000) ^
              (uVar22 >> 0x19 | uVar22 * 0x80)) +
             ((uVar1 ^ uVar12) & uVar22 ^ uVar1) + uVar4 + 0x5b9cca4f + uVar13;
    uVar45 = uVar45 + iVar17;
    uVar28 = iVar17 +
             ((uVar52 >> 0xd | uVar52 * 0x80000) ^
              (uVar52 >> 2 | uVar52 * 0x40000000) ^
              (uVar52 >> 0x16 | uVar52 * 0x400)) +
             ((uVar11 | uVar52) & uVar3 | uVar11 & uVar52);
    uVar47 = ((uVar27 >> 0x12 | uVar27 * 0x4000) ^
              (uVar27 >> 7 | uVar27 * 0x2000000) ^ uVar27 >> 3) +
             uVar53 + uVar10 +
             ((uVar19 >> 0x13 | uVar19 * 0x2000) ^
              (uVar19 >> 0x11 | uVar19 * 0x8000) ^ uVar19 >> 10);
    iVar17 = ((uVar45 >> 0xb | uVar45 * 0x200000) ^
              (uVar45 >> 6 | uVar45 * 0x4000000) ^
              (uVar45 >> 0x19 | uVar45 * 0x80)) +
             ((uVar12 ^ uVar22) & uVar45 ^ uVar12) + uVar1 + uVar47 +
             0x682e6ff3;
    uVar1 = ((uVar28 >> 0xd | uVar28 * 0x80000) ^
             (uVar28 >> 2 | uVar28 * 0x40000000) ^
             (uVar28 >> 0x16 | uVar28 * 0x400)) +
            (uVar52 & uVar28 | (uVar52 | uVar28) & uVar11) + iVar17;
    uVar57 = ((uVar5 >> 0x12 | uVar5 * 0x4000) ^
              (uVar5 >> 7 | uVar5 * 0x2000000) ^ uVar5 >> 3) +
             uVar27 + uVar40 +
             ((uVar4 >> 0x13 | uVar4 * 0x2000) ^
              (uVar4 >> 0x11 | uVar4 * 0x8000) ^ uVar4 >> 10);
    uVar3 = uVar3 + iVar17;
    iVar17 =
        ((uVar3 >> 0xb | uVar3 * 0x200000) ^ (uVar3 >> 6 | uVar3 * 0x4000000) ^
         (uVar3 >> 0x19 | uVar3 * 0x80)) +
        ((uVar22 ^ uVar45) & uVar3 ^ uVar22) + uVar12 + uVar57 + 0x748f82ee;
    uVar11 = uVar11 + iVar17;
    uVar40 =
        ((uVar28 | uVar1) & uVar52 | uVar28 & uVar1) +
        ((uVar1 >> 0xd | uVar1 * 0x80000) ^ (uVar1 >> 2 | uVar1 * 0x40000000) ^
         (uVar1 >> 0x16 | uVar1 * 0x400)) +
        iVar17;
    uVar54 = uVar18 +
             ((uVar20 >> 0x12 | uVar20 * 0x4000) ^
              (uVar20 >> 7 | uVar20 * 0x2000000) ^ uVar20 >> 3) +
             uVar5 +
             ((uVar47 >> 0x13 | uVar47 * 0x2000) ^
              (uVar47 >> 0x11 | uVar47 * 0x8000) ^ uVar47 >> 10);
    iVar17 =
        ((uVar45 ^ uVar3) & uVar11 ^ uVar45) + uVar54 + 0x78a5636f + uVar22 +
        ((uVar11 >> 0xb | uVar11 * 0x200000) ^
         (uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0x19 | uVar11 * 0x80));
    uVar52 = uVar52 + iVar17;
    uVar13 = ((uVar1 | uVar40) & uVar28 | uVar1 & uVar40) +
             ((uVar40 >> 0xd | uVar40 * 0x80000) ^
              (uVar40 >> 2 | uVar40 * 0x40000000) ^
              (uVar40 >> 0x16 | uVar40 * 0x400)) +
             iVar17;
    uVar18 = ((uVar59 >> 0x12 | uVar59 * 0x4000) ^
              (uVar59 >> 7 | uVar59 * 0x2000000) ^ uVar59 >> 3) +
             uVar20 + uVar9 +
             ((uVar57 >> 0x13 | uVar57 * 0x2000) ^
              (uVar57 >> 0x11 | uVar57 * 0x8000) ^ uVar57 >> 10);
    iVar17 =
        uVar45 + uVar18 + 0x84c87814 + ((uVar3 ^ uVar11) & uVar52 ^ uVar3) +
        ((uVar52 >> 0xb | uVar52 * 0x200000) ^
         (uVar52 >> 6 | uVar52 * 0x4000000) ^ (uVar52 >> 0x19 | uVar52 * 0x80));
    uVar28 = uVar28 + iVar17;
    uVar22 = iVar17 + ((uVar40 | uVar13) & uVar1 | uVar40 & uVar13) +
             ((uVar13 >> 0xd | uVar13 * 0x80000) ^
              (uVar13 >> 2 | uVar13 * 0x40000000) ^
              (uVar13 >> 0x16 | uVar13 * 0x400));
    uVar54 = ((uVar6 >> 0x12 | uVar6 * 0x4000) ^
              (uVar6 >> 7 | uVar6 * 0x2000000) ^ uVar6 >> 3) +
             uVar59 + uVar21 +
             ((uVar54 >> 0x13 | uVar54 * 0x2000) ^
              (uVar54 >> 0x11 | uVar54 * 0x8000) ^ uVar54 >> 10);
    iVar17 =
        ((uVar11 ^ uVar52) & uVar28 ^ uVar11) + uVar54 + 0x8cc70208 + uVar3 +
        ((uVar28 >> 0xb | uVar28 * 0x200000) ^
         (uVar28 >> 6 | uVar28 * 0x4000000) ^ (uVar28 >> 0x19 | uVar28 * 0x80));
    uVar1 = uVar1 + iVar17;
    uVar59 = (uVar13 & uVar22 | (uVar13 | uVar22) & uVar40) +
             ((uVar22 >> 0xd | uVar22 * 0x80000) ^
              (uVar22 >> 2 | uVar22 * 0x40000000) ^
              (uVar22 >> 0x16 | uVar22 * 0x400)) +
             iVar17;
    uVar12 = ((uVar18 >> 0x13 | uVar18 * 0x2000) ^
              (uVar18 >> 0x11 | uVar18 * 0x8000) ^ uVar18 >> 10) +
             ((uVar7 >> 0x12 | uVar7 * 0x4000) ^
              (uVar7 >> 7 | uVar7 * 0x2000000) ^ uVar7 >> 3) +
             uVar6 + uVar19;
    iVar17 =
        uVar12 + 0x90befffa + uVar11 + ((uVar28 ^ uVar52) & uVar1 ^ uVar52) +
        ((uVar1 >> 0xb | uVar1 * 0x200000) ^ (uVar1 >> 6 | uVar1 * 0x4000000) ^
         (uVar1 >> 0x19 | uVar1 * 0x80));
    uVar40 = uVar40 + iVar17;
    uVar45 = ((uVar22 | uVar59) & uVar13 | uVar22 & uVar59) +
             ((uVar59 >> 0xd | uVar59 * 0x80000) ^
              (uVar59 >> 2 | uVar59 * 0x40000000) ^
              (uVar59 >> 0x16 | uVar59 * 0x400)) +
             iVar17;
    uVar18 = ((uVar8 >> 0x12 | uVar8 * 0x4000) ^
              (uVar8 >> 7 | uVar8 * 0x2000000) ^ uVar8 >> 3) +
             uVar7 + uVar4 +
             ((uVar54 >> 0x13 | uVar54 * 0x2000) ^
              (uVar54 >> 0x11 | uVar54 * 0x8000) ^ uVar54 >> 10);
    iVar17 = ((uVar40 >> 0xb | uVar40 * 0x200000) ^
              (uVar40 >> 6 | uVar40 * 0x4000000) ^
              (uVar40 >> 0x19 | uVar40 * 0x80)) +
             ((uVar28 ^ uVar1) & uVar40 ^ uVar28) + uVar18 + 0xa4506ceb +
             uVar52;
    uVar54 = ((uVar59 | uVar45) & uVar22 | uVar59 & uVar45) +
             ((uVar45 >> 0xd | uVar45 * 0x80000) ^
              (uVar45 >> 2 | uVar45 * 0x40000000) ^
              (uVar45 >> 0x16 | uVar45 * 0x400)) +
             iVar17;
    uVar13 = uVar13 + iVar17;
    iVar17 =
        ((uVar1 ^ uVar40) & uVar13 ^ uVar1) + uVar8 + 0xbef9a3f7 +
        ((uVar37 >> 0x12 | uVar37 * 0x4000) ^
         (uVar37 >> 7 | uVar37 * 0x2000000) ^ uVar37 >> 3) +
        uVar47 +
        ((uVar12 >> 0x13 | uVar12 * 0x2000) ^
         (uVar12 >> 0x11 | uVar12 * 0x8000) ^ uVar12 >> 10) +
        uVar28 +
        ((uVar13 >> 0xb | uVar13 * 0x200000) ^
         (uVar13 >> 6 | uVar13 * 0x4000000) ^ (uVar13 >> 0x19 | uVar13 * 0x80));
    uVar22 = uVar22 + iVar17;
    uVar47 = ((uVar45 | uVar54) & uVar59 | uVar45 & uVar54) +
             ((uVar54 >> 0xd | uVar54 * 0x80000) ^
              (uVar54 >> 2 | uVar54 * 0x40000000) ^
              (uVar54 >> 0x16 | uVar54 * 0x400)) +
             iVar17;
    iVar17 =
        uVar37 + 0xc67178f2 +
        ((uVar10 >> 0x12 | uVar10 * 0x4000) ^
         (uVar10 >> 7 | uVar10 * 0x2000000) ^ uVar10 >> 3) +
        uVar57 +
        ((uVar18 >> 0x13 | uVar18 * 0x2000) ^
         (uVar18 >> 0x11 | uVar18 * 0x8000) ^ uVar18 >> 10) +
        uVar1 + ((uVar40 ^ uVar13) & uVar22 ^ uVar40) +
        ((uVar22 >> 0xb | uVar22 * 0x200000) ^
         (uVar22 >> 6 | uVar22 * 0x4000000) ^ (uVar22 >> 0x19 | uVar22 * 0x80));
    ctx->state[7] = uVar40 + ctx->state[7];
    ctx->state[3] = uVar45 + ctx->state[3];
    ctx->state[6] = uVar13 + uVar14;
    ctx->state[1] = uVar47 + uVar15;
    ctx->state[2] = uVar54 + uVar16;
    ctx->state[5] = uVar22 + uVar29;
    ctx->state[0] = ((uVar54 | uVar47) & uVar45 | uVar54 & uVar47) +
                    ((uVar47 >> 0xd | uVar47 * 0x80000) ^
                     (uVar47 >> 2 | uVar47 * 0x40000000) ^
                     (uVar47 >> 0x16 | uVar47 * 0x400)) +
                    uVar23 + iVar17;
    ctx->state[4] = iVar17 + uVar59 + uVar2;
    return;
}

/* WARNING: Unknown calling convention */

void sha2_update(sha2_context *ctx, uchar *input, int ilen)

{
    uint32_t uVar1;
    uint32_t uVar2;
    uchar *data;
    size_t __n;
    uchar *puVar3;
    uint uVar4;
    uint uVar5;
    bool bVar6;

    uVar2 = ctx->total[0];
    bVar6 = CARRY4(uVar2, ilen);
    uVar1 = uVar2 + ilen;
    uVar4 = uVar2 & 0x3f;
    if (bVar6) {
        uVar2 = ctx->total[1];
    }
    __n = 0x40 - uVar4;
    ctx->total[0] = uVar1;
    if (bVar6) {
        uVar2 = uVar2 + 1;
    }
    if (bVar6) {
        ctx->total[1] = uVar2;
    }
    if (uVar4 != 0 && (int)__n <= ilen) {
        ilen = ilen - __n;
        memcpy(ctx->buffer + uVar4, input, __n);
        input = input + __n;
        uVar4 = 0;
        sha2_process(ctx, ctx->buffer);
    }
    if (0x3f < ilen) {
        uVar5 = ilen - 0x40U >> 6;
        puVar3 = input + (uVar5 + 1) * 0x40;
        data = input;
        do {
            input = data + 0x40;
            sha2_process(ctx, data);
            data = input;
        } while (input != puVar3);
        ilen = (ilen - 0x40U) + uVar5 * -0x40;
    }
    if (0 < ilen) {
        memcpy(ctx->buffer + uVar4, input, ilen);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void sha2_update(sha2_context *ctx, uchar *input, int ilen)

{
    if (0 < ilen) {
        sha2_update(ctx, input, ilen);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void sha2_finish(sha2_context *ctx, uchar *output)

{
    int iVar1;
    uint uVar2;
    int ilen;
    uint uVar3;
    int iVar4;
    uchar msglen[8];

    uVar3 = ctx->total[0];
    uVar2 = uVar3 & 0x3f;
    iVar4 = uVar3 << 3;
    iVar1 = ctx->total[1] << 3;
    msglen[3] = (byte)(uVar3 >> 0x1d) | (byte)iVar1;
    msglen[7] = (uchar)iVar4;
    msglen[4] = (uchar)((uint)iVar4 >> 0x18);
    msglen[1] = (uchar)((uint)iVar1 >> 0x10);
    msglen[2] = (uchar)((uint)iVar1 >> 8);
    msglen[5] = (uchar)((uint)iVar4 >> 0x10);
    if (uVar2 < 0x38) {
        ilen = 0x38 - uVar2;
    } else {
        ilen = 0x78 - uVar2;
    }
    msglen[6] = (uchar)((uint)iVar4 >> 8);
    msglen[0] = (uchar)((uint)iVar1 >> 0x18);
    sha2_update(ctx, sha2_padding, ilen);
    sha2_update(ctx, msglen, 8);
    *output = *(uchar *)((int)ctx->state + 3);
    output[1] = (uchar) * (undefined2 *)((int)ctx->state + 2);
    output[2] = (uchar)(ctx->state[0] >> 8);
    output[3] = (uchar)ctx->state[0];
    output[4] = *(uchar *)((int)ctx->state + 7);
    output[5] = (uchar) * (undefined2 *)((int)ctx->state + 6);
    output[6] = (uchar)(ctx->state[1] >> 8);
    output[7] = (uchar)ctx->state[1];
    output[8] = *(uchar *)((int)ctx->state + 0xb);
    output[9] = (uchar) * (undefined2 *)((int)ctx->state + 10);
    output[10] = (uchar)(ctx->state[2] >> 8);
    output[0xb] = (uchar)ctx->state[2];
    output[0xc] = *(uchar *)((int)ctx->state + 0xf);
    output[0xd] = (uchar) * (undefined2 *)((int)ctx->state + 0xe);
    output[0xe] = (uchar)(ctx->state[3] >> 8);
    output[0xf] = (uchar)ctx->state[3];
    output[0x10] = *(uchar *)((int)ctx->state + 0x13);
    output[0x11] = (uchar) * (undefined2 *)((int)ctx->state + 0x12);
    output[0x12] = (uchar)(ctx->state[4] >> 8);
    output[0x13] = (uchar)ctx->state[4];
    output[0x14] = *(uchar *)((int)ctx->state + 0x17);
    output[0x15] = (uchar) * (undefined2 *)((int)ctx->state + 0x16);
    output[0x16] = (uchar)(ctx->state[5] >> 8);
    output[0x17] = (uchar)ctx->state[5];
    output[0x18] = *(uchar *)((int)ctx->state + 0x1b);
    output[0x19] = (uchar) * (undefined2 *)((int)ctx->state + 0x1a);
    output[0x1a] = (uchar)(ctx->state[6] >> 8);
    output[0x1b] = (uchar)ctx->state[6];
    output[0x1c] = *(uchar *)((int)ctx->state + 0x1f);
    output[0x1d] = (uchar) * (undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uchar)(ctx->state[7] >> 8);
    output[0x1f] = (uchar)ctx->state[7];
    return;
}

/* WARNING: Unknown calling convention */

void sha2(uchar *input, int ilen, uchar *output)

{
    sha2_context ctx;

    ctx.state[0] = 0x6a09e667;
    ctx.state[3] = 0xa54ff53a;
    ctx.state[4] = 0x510e527f;
    ctx.state[2] = 0x3c6ef372;
    ctx.state[6] = 0x1f83d9ab;
    ctx.state[7] = 0x5be0cd19;
    ctx.state[5] = 0x9b05688c;
    ctx.state[1] = 0xbb67ae85;
    ctx.total[0] = 0;
    ctx.total[1] = 0;
    if (0 < ilen) {
        sha2_update(&ctx, input, ilen);
    }
    sha2_finish(&ctx, output);
    return;
}

/* WARNING: Unknown calling convention */

int compareSR(void *p1, void *p2)

{
    int iVar1;

    iVar1 = memcmp(p1, p2, compare_size);
    return iVar1;
}

/* WARNING: Unknown calling convention */

void generateHash(blake2b_state *S, uint32_t g, uint8_t *hash, size_t hashLen)

{
    uint32_t le_g;
    blake2b_state digest;

    le_g = g;
    memcpy(&digest, S, 0x168);
    blake2b_update(&digest, (uint8_t *)&le_g, 4);
    blake2b_final(&digest, hash, (uint8_t)hashLen);
    return;
}

/* WARNING: Unknown calling convention */

void expandArray(uchar *in, size_t in_len, uchar *out, size_t out_len,
                 size_t bit_len, size_t byte_pad)

{
    uint uVar1;
    size_t sVar2;
    byte *pbVar3;
    uint uVar4;
    byte *pbVar5;
    uint uVar6;
    uchar *puVar7;
    byte *pbVar9;
    byte *pbVar10;
    uint uVar11;
    uint uVar12;
    uint uVar13;
    int iVar14;
    uchar *puVar8;

    if (bit_len < 8) {
        /* WARNING: Subroutine does not return */
        __assert_fail("bit_len >= 8", "sort-verify.c", 0x40, "expandArray");
    }
    if (bit_len + 7 < 0x21) {
        uVar13 = byte_pad + (bit_len + 7 >> 3);
        sVar2 = __udivsi3(uVar13 * in_len * 8, bit_len);
        if (sVar2 != out_len) {
            /* WARNING: Subroutine does not return */
            __assert_fail("out_len == 8 * out_width * in_len / bit_len",
                          "sort-verify.c", 0x44, "expandArray");
        }
        if (in_len != 0) {
            pbVar3 = in + -1;
            pbVar5 = pbVar3 + in_len;
            iVar14 = 0;
            uVar12 = 0;
            uVar11 = 0;
            do {
                while (true) {
                    pbVar3 = pbVar3 + 1;
                    uVar11 = uVar11 + 8;
                    uVar12 = (uint)*pbVar3 | uVar12 << 8;
                    if (uVar11 < bit_len)
                        break;
                    uVar11 = uVar11 - bit_len;
                    if (byte_pad != 0) {
                        puVar8 = out + iVar14;
                        do {
                            puVar7 = puVar8 + 1;
                            *puVar8 = '\0';
                            puVar8 = puVar7;
                        } while (out + iVar14 + byte_pad != puVar7);
                    }
                    if (byte_pad < uVar13) {
                        uVar4 = uVar11 + ((uVar13 - byte_pad) + 0x1fffffff) * 8;
                        pbVar9 = out + byte_pad + iVar14;
                        do {
                            uVar6 = uVar4 - uVar11;
                            uVar1 = uVar4 & 0xff;
                            uVar4 = uVar4 - 8;
                            pbVar10 = pbVar9 + 1;
                            *pbVar9 = (byte)(uVar12 >> uVar1) &
                                      (byte)((1 << (bit_len & 0xff)) - 1U >>
                                             (uVar6 & 0xff));
                            pbVar9 = pbVar10;
                        } while (out + iVar14 + uVar13 != pbVar10);
                    }
                    iVar14 = iVar14 + uVar13;
                    if (pbVar3 == pbVar5) {
                        return;
                    }
                }
            } while (pbVar3 != pbVar5);
        }
        return;
    }
    /* WARNING: Subroutine does not return */
    __assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "sort-verify.c", 0x41,
                  "expandArray");
}

/* WARNING: Unknown calling convention */

void sort_pair(uint32_t *a, uint32_t len)

{
    uint32_t *puVar1;
    uint32_t *puVar2;
    uint32_t uVar3;
    uint32_t uVar4;
    uint32_t uVar5;

    if (len == 0) {
        return;
    }
    uVar3 = 0;
    puVar1 = a + -1;
    puVar2 = a + (len - 1);
    while (true) {
        puVar1 = puVar1 + 1;
        uVar5 = *puVar1;
        puVar2 = puVar2 + 1;
        uVar4 = *puVar2;
        if (uVar4 < uVar5) {
            puVar1 = a + uVar3;
            puVar2 = a + len + uVar3;
            while (true) {
                uVar3 = uVar3 + 1;
                *puVar1 = uVar4;
                *puVar2 = uVar5;
                if (len <= uVar3)
                    break;
                uVar4 = puVar2[1];
                uVar5 = puVar1[1];
                puVar1 = puVar1 + 1;
                puVar2 = puVar2 + 1;
            }
            return;
        }
        uVar3 = uVar3 + 1;
        if (uVar5 < uVar4)
            break;
        if (len == uVar3) {
            return;
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

int sortValidator(void *data, uchar *soln)

{
    size_t sVar1;
    int iVar2;
    byte *pbVar3;
    char *pcVar4;
    byte *pbVar5;
    uint8_t *puVar6;
    uint uVar7;
    uint32_t uVar8;
    blake2b_state *S;
    uint *puVar9;
    uint32_t uVar10;
    int iVar11;
    byte bVar12;
    uint uVar13;
    uint32_t *puVar14;
    int iVar15;
    byte *pbVar16;
    uint uVar17;
    byte *pbVar18;
    uchar *puVar19;
    int iVar20;
    size_t sVar21;
    uint *puVar22;
    uint *puVar23;
    size_t sVar24;
    uchar *puVar25;
    size_t __size;
    int iVar26;
    byte *pbVar27;
    int iVar28;
    undefined8 uVar29;
    int local_1608;
    int local_15fc;
    uchar *local_15f4;
    uchar *local_15f0;
    size_t local_15e4;
    int local_15dc;
    uint8_t vHash[30];
    byte abStack_15aa[2];
    uint8_t tmp_hash[30];
    uint8_t hash_1[30];
    uint8_t uStack_1569;
    uint8_t tmp_data[1344];
    uint32_t indices[512];
    uint32_t real_indices[512];

    uVar13 = *(uint *)((int)data + 4);
    /* WARNING: Load size is inaccurate */
    iVar26 = *data;
    S = *(blake2b_state **)((int)data + 8);
    iVar20 = uVar13 + 1;
    sVar1 = __aeabi_idiv(iVar26, iVar20);
    uVar7 = sVar1 + 1 << (uVar13 & 0xff);
    uVar13 = uVar7 & ~((int)uVar7 >> 0x20);
    if ((int)uVar7 < 0) {
        uVar13 = uVar7 + 7;
    }
    compare_size = 3;
    expandArray(soln, (int)uVar13 >> 3, (uchar *)indices, 0x800, sVar1 + 1, 1);
    memset(vHash, 0, 0x1e);
    local_15f4 = (uchar *)malloc(0x4400);
    local_15f0 = (uchar *)malloc(0x4400);
    memset(tmp_hash, 0, 0x1e);
    iVar2 = 0;
    puVar14 = indices;
    while (iVar2 = iVar2 + 1, iVar2 != 0x200) {
        uVar8 = *puVar14;
        puVar14 = puVar14 + 1;
        uVar10 = *puVar14;
        iVar11 = iVar2;
        while (true) {
            if (uVar8 == uVar10) {
                iVar20 = 1;
                goto LAB_00041f8a;
            }
            iVar11 = iVar11 + 1;
            if (iVar11 == 0x200)
                break;
            uVar10 = indices[iVar11];
        }
    }
    bVar12 = 0;
    puVar9 = (uint *)(tmp_data + 0x53c);
    iVar2 = sVar1 + 0xe;
    if (-1 < (int)(sVar1 + 7)) {
        iVar2 = sVar1 + 7;
    }
    uVar13 = iVar20 * (iVar2 >> 3);
    iVar11 = __aeabi_idiv(0x200, iVar26);
    iVar2 = iVar11 * iVar26;
    iVar20 = iVar26 + 7;
    if (-1 < iVar26) {
        iVar20 = iVar26;
    }
    if (iVar2 < 0) {
        iVar2 = iVar2 + 7;
    }
    puVar25 = local_15f4;
    do {
        puVar9 = puVar9 + 1;
        uVar7 = *puVar9;
        uVar29 =
            __aeabi_idivmod(uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
                                (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18,
                            iVar11);
        uVar17 = iVar26 * (int)((ulonglong)uVar29 >> 0x20);
        generateHash(S, (uint32_t)uVar29, (uint8_t *)real_indices, iVar2 >> 3);
        uVar7 = uVar17 & ~((int)uVar17 >> 0x20);
        if ((int)uVar17 < 0) {
            uVar7 = uVar17 + 7;
        }
        expandArray((uchar *)((int)real_indices + ((int)uVar7 >> 3)),
                    iVar20 >> 3, tmp_data, uVar13, sVar1, 0);
        if (uVar13 != 0) {
            pbVar18 = vHash;
            pbVar27 = tmp_data;
            while (true) {
                *pbVar18 = bVar12 ^ *pbVar27;
                if (pbVar27 + 1 == tmp_data + uVar13)
                    break;
                bVar12 = pbVar18[1];
                pbVar18 = pbVar18 + 1;
                pbVar27 = pbVar27 + 1;
            }
            bVar12 = vHash[0];
        }
        memcpy(puVar25, tmp_data, uVar13);
        *(uint *)(puVar25 + uVar13) = *puVar9;
        puVar25 = puVar25 + uVar13 + 4;
    } while (puVar9 != indices + 0x1ff);
    pbVar18 = vHash;
    while (true) {
        if (bVar12 != 0)
            goto LAB_00042084;
        if (pbVar18 == vHash + 0x1d)
            break;
        pbVar18 = pbVar18 + 1;
        bVar12 = *pbVar18;
    }
    memset(vHash, 0, 0x1e);
    local_15dc = 9;
    local_15e4 = 0x200;
    sVar24 = 4;
    puVar25 = local_15f4;
    do {
        local_15f4 = puVar25;
        puVar25 = local_15f0;
        __size = uVar13 + sVar24;
        qsort(local_15f4, local_15e4, __size, (__compar_fn_t)0x41d21);
        pbVar18 = local_15f4 + __size + uVar13;
        local_15e4 = (local_15e4 - 1 >> 1) + 1;
        sVar21 = 0;
        puVar19 = local_15f4 + uVar13;
        do {
            iVar28 = sVar21 << 1;
            if (uVar13 != 0) {
                pbVar27 = puVar19 + ~uVar13;
                pbVar5 = pbVar18 + -uVar13;
                pbVar16 = tmp_hash;
                do {
                    pbVar3 = pbVar5 + 1;
                    pbVar27 = pbVar27 + 1;
                    *pbVar16 = *pbVar5 ^ *pbVar27;
                    pbVar5 = pbVar3;
                    pbVar16 = pbVar16 + 1;
                } while (pbVar18 != pbVar3);
            }
            sVar21 = sVar21 + 1;
            iVar28 = (__size + sVar24) * (iVar28 >> 1);
            iVar15 = iVar28 + uVar13;
            memcpy(puVar25 + iVar28, tmp_hash, uVar13);
            memcpy(puVar25 + iVar15, puVar19, sVar24);
            memcpy(puVar25 + iVar15 + sVar24, pbVar18, sVar24);
            pbVar18 = pbVar18 + __size * 2;
            puVar19 = puVar19 + __size * 2;
        } while (sVar21 != local_15e4);
        compare_size = compare_size + 3;
        local_15dc = local_15dc + -1;
        local_15f0 = local_15f4;
        sVar24 = sVar24 << 1;
    } while (local_15dc != 0);
    puVar22 = indices + 0x1ff;
    puVar9 = (uint *)(puVar25 + (uVar13 - 4));
    puVar23 = puVar22;
    do {
        puVar9 = puVar9 + 1;
        uVar7 = *puVar9;
        puVar23 = puVar23 + 1;
        *puVar23 = uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
                   (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
    } while (real_indices + 0x1ff != puVar23);
    uVar7 = 0;
    do {
        puVar14 = real_indices;
        iVar28 = 2 << (uVar7 & 0xff);
        iVar15 = 0;
        do {
            iVar15 = iVar15 + iVar28;
            sort_pair(puVar14, 1 << (uVar7 & 0xff));
            puVar14 = puVar14 + iVar28;
        } while (iVar15 < 0x200);
        uVar7 = uVar7 + 1;
        puVar19 = puVar25;
    } while (uVar7 != 9);
    do {
        puVar22 = puVar22 + 1;
        uVar29 = __aeabi_idivmod(*puVar22, iVar11);
        uVar17 = iVar26 * (int)((ulonglong)uVar29 >> 0x20);
        generateHash(S, (uint32_t)uVar29, tmp_data, iVar2 >> 3);
        uVar7 = uVar17 & ~((int)uVar17 >> 0x20);
        if ((int)uVar17 < 0) {
            uVar7 = uVar17 + 7;
        }
        expandArray(tmp_data + ((int)uVar7 >> 3), iVar20 >> 3, hash_1, uVar13,
                    sVar1, 0);
        uVar7 = *puVar22;
        memcpy(puVar19, hash_1, uVar13);
        *(uint *)(puVar19 + uVar13) =
            uVar7 << 0x18 | (uVar7 >> 8 & 0xff) << 0x10 |
            (uVar7 >> 0x10 & 0xff) << 8 | uVar7 >> 0x18;
        pcVar4 = bin2hex(puVar19, 0x22);
        free(pcVar4);
        puVar19 = puVar19 + uVar13 + 4;
    } while (puVar22 != puVar23);
    local_1608 = 0x200;
    local_15fc = compare_size + 3;
    iVar20 = compare_size + 0x1e;
    sVar24 = 4;
    puVar19 = local_15f4;
    do {
        local_15f0 = puVar25;
        local_15f4 = puVar19;
        iVar26 = 0;
        sVar1 = uVar13 + sVar24 * 2;
        iVar2 = (sVar1 - sVar24) * 2;
        pbVar18 = local_15f0 + uVar13 + (sVar1 - sVar24);
        local_1608 = (local_1608 - 1U >> 1) + 1;
        puVar25 = local_15f0 + uVar13;
        do {
            iVar11 = iVar26 << 1;
            if (uVar13 != 0) {
                pbVar27 = puVar25 + ~uVar13;
                pbVar5 = pbVar18 + -uVar13;
                pbVar16 = tmp_hash;
                do {
                    pbVar3 = pbVar5 + 1;
                    pbVar27 = pbVar27 + 1;
                    *pbVar16 = *pbVar5 ^ *pbVar27;
                    pbVar5 = pbVar3;
                    pbVar16 = pbVar16 + 1;
                } while (pbVar18 != pbVar3);
            }
            iVar26 = iVar26 + 1;
            iVar11 = sVar1 * (iVar11 >> 1);
            iVar28 = iVar11 + uVar13;
            memcpy(local_15f4 + iVar11, tmp_hash, uVar13);
            memcpy(local_15f4 + iVar28, puVar25, sVar24);
            memcpy(local_15f4 + iVar28 + sVar24, pbVar18, sVar24);
            pbVar18 = pbVar18 + iVar2;
            puVar25 = puVar25 + iVar2;
        } while (local_1608 != iVar26);
        compare_size = local_15fc;
        local_15fc = local_15fc + 3;
        sVar24 = sVar24 * 2;
        puVar19 = local_15f0;
        puVar25 = local_15f4;
    } while (iVar20 != local_15fc);
    iVar20 = 0;
    uVar7 = 0;
    uVar17 = 0;
    puVar6 = &uStack_1569;
    do {
        if (uVar17 < 8) {
            iVar26 = iVar20 + uVar13;
            uVar17 = uVar17 + 0x15;
            iVar20 = iVar20 + 4;
            uVar7 = (uint)local_15f4[iVar26 + 3] | uVar7 << 0x15 |
                    (uint)local_15f4[iVar26 + 2] << 8 |
                    (local_15f4[iVar26 + 1] & 0x1f) << 0x10;
        }
        uVar17 = uVar17 - 8;
        puVar6 = puVar6 + 1;
        *puVar6 = (uint8_t)(uVar7 >> (uVar17 & 0xff));
    } while (tmp_data + 0x53f != puVar6);
    pcVar4 = bin2hex(tmp_data, 0x540);
    free(pcVar4);
    pcVar4 = bin2hex(local_15f4, sVar1);
    free(pcVar4);
    vHash._0_4_ = *(undefined4 *)local_15f4;
    vHash._4_4_ = *(undefined4 *)(local_15f4 + 4);
    vHash._8_4_ = *(undefined4 *)(local_15f4 + 8);
    vHash._12_4_ = *(undefined4 *)(local_15f4 + 0xc);
    vHash._16_4_ = *(undefined4 *)(local_15f4 + 0x10);
    vHash._20_4_ = *(undefined4 *)(local_15f4 + 0x14);
    vHash._24_4_ = *(undefined4 *)(local_15f4 + 0x18);
    vHash._28_2_ = (undefined2) * (undefined4 *)(local_15f4 + 0x1c);
    pbVar18 = vHash;
    do {
        pbVar27 = pbVar18 + 1;
        if (*pbVar18 != 0) {
            iVar20 = 3;
            break;
        }
        iVar20 = 0;
        pbVar18 = pbVar27;
    } while (abStack_15aa != pbVar27);
LAB_00041f8a:
    free(local_15f4);
    free(local_15f0);
    return iVar20;
LAB_00042084:
    iVar20 = 2;
    goto LAB_00041f8a;
}

/* WARNING: Unknown calling convention */

_Bool HasCollision(uint8_t *a, uint8_t *b, int l)

{
    uint8_t *puVar1;

    if (l < 1) {
        return true;
    }
    if (*a == *b) {
        puVar1 = a + l + -1;
        do {
            if (a == puVar1) {
                return true;
            }
            a = a + 1;
            b = b + 1;
        } while (*a == *b);
    }
    return false;
}

/* WARNING: Unknown calling convention */

_Bool IndicesBefore(uint8_t *a, uint8_t *b, size_t hashLen, uint32_t indicesLen)

{
    int iVar1;

    iVar1 = memcmp(a + hashLen, b + hashLen, indicesLen);
    return SUB41((uint)iVar1 >> 0x1f, 0);
}

/* WARNING: Unknown calling convention */

_Bool DistinctIndices(uint8_t *a, uint8_t *b, size_t hashLen,
                      uint32_t indicesLen)

{
    int iVar1;
    int iVar2;
    uint uVar3;
    uint8_t *puVar4;

    if (indicesLen == 0) {
        return true;
    }
    puVar4 = a + hashLen;
    do {
        uVar3 = 0;
        do {
            iVar1 = uVar3 + hashLen;
            iVar2 = uVar3 + hashLen;
            uVar3 = uVar3 + 4;
            if ((((*puVar4 == b[iVar1]) && (puVar4[1] == b[iVar2 + 1])) &&
                 (puVar4[2] == b[iVar2 + 2])) &&
                (puVar4[3] == b[iVar2 + 3])) {
                return false;
            }
        } while (uVar3 < indicesLen);
        puVar4 = puVar4 + 4;
        if (indicesLen <= (uint)((int)puVar4 - (int)(a + hashLen))) {
            return true;
        }
    } while (true);
}

/* WARNING: Unknown calling convention */

_Bool IsZero(uint8_t *a, size_t len)

{
    uint8_t *puVar1;

    if (len == 0) {
        return true;
    }
    if (*a == '\0') {
        puVar1 = a + (len - 1);
        do {
            if (a == puVar1) {
                return true;
            }
            a = a + 1;
        } while (*a == '\0');
    }
    return false;
}

/* WARNING: Unknown calling convention */

int IsValidSolution(blake2b_state *base_state, uchar *soln)

{
    _Bool _Var1;
    byte *__dest;
    void *__src;
    char *__ptr;
    int iVar2;
    int iVar3;
    size_t sVar4;
    int iVar5;
    byte *pbVar6;
    byte *pbVar7;
    uint *puVar8;
    int iVar9;
    uint *puVar10;
    byte *pbVar11;
    uint uVar12;
    uint uVar13;
    uint uVar14;
    byte *b;
    byte *__src_00;
    size_t hashLen;
    size_t __n;
    byte *pbVar16;
    size_t local_89c;
    uint8_t hash[30];
    uint8_t tmpHash[50];
    uint32_t indices[512];
    byte *pbVar15;

    __dest = (byte *)malloc(0x4400);
    __src = malloc(0x4400);
    memset(indices, 0, 0x800);
    puVar8 = (uint *)(tmpHash + 0x30);
    expandArray(soln, 0x540, (uchar *)indices, 0x800, 0x15, 1);
    puVar10 = (uint *)(__dest + 0x1e);
    do {
        puVar8 = puVar8 + 1;
        uVar12 = *puVar8;
        uVar14 = uVar12 << 0x18 | (uVar12 >> 8 & 0xff) << 0x10 |
                 (uVar12 >> 0x10 & 0xff) << 8;
        uVar13 = uVar14 | uVar12 >> 0x18;
        generateHash(base_state, (int)(uVar13 - ((int)uVar14 >> 0x1f)) >> 1,
                     tmpHash, 0x32);
        uVar14 = uVar12 >> 0x18 & 1;
        if ((int)uVar13 < 0) {
            uVar14 = -uVar14;
        }
        expandArray(tmpHash + uVar14 * 0x19, 0x19, hash, 0x1e, 0x14, 0);
        uVar14 = *puVar8;
        *(undefined4 *)((int)puVar10 + -0x1e) = hash._0_4_;
        *(undefined4 *)((int)puVar10 + -0x1a) = hash._4_4_;
        *(undefined4 *)((int)puVar10 + -0x16) = hash._8_4_;
        *(undefined4 *)((int)puVar10 + -0x12) = hash._12_4_;
        *(undefined4 *)((int)puVar10 + -0xe) = hash._16_4_;
        *(undefined4 *)((int)puVar10 + -10) = hash._20_4_;
        *(undefined2 *)((int)puVar10 + -2) = hash._28_2_;
        *(undefined4 *)((int)puVar10 + -6) = hash._24_4_;
        *puVar10 = uVar14;
        __ptr = bin2hex((byte *)((int)puVar10 + -0x1e), 0x22);
        free(__ptr);
        puVar10 = (uint *)((int)puVar10 + 0x22);
    } while (puVar8 != indices + 0x1ff);
    hashLen = 0x1e;
    local_89c = 0x1b;
    __n = 4;
    uVar14 = 0x200;
    sVar4 = local_89c;
    do {
        local_89c = sVar4;
        if (uVar14 == 0) {
            sVar4 = __n << 1;
            uVar12 = uVar14;
        } else {
            iVar3 = (hashLen + __n) * 2;
            sVar4 = __n * 2;
            b = __dest + hashLen + __n;
            pbVar11 = __dest;
            uVar13 = 0;
            do {
                iVar5 = uVar13 * 2;
                pbVar7 = b;
                pbVar16 = pbVar11;
                do {
                    pbVar6 = pbVar16 + 1;
                    if (*pbVar16 != *pbVar7) {
                        iVar3 = 2;
                        puts("Invalid solution: invalid collision length "
                             "between StepRows");
                        goto LAB_00042684;
                    }
                    pbVar7 = pbVar7 + 1;
                    pbVar16 = pbVar6;
                } while (pbVar11 + 3 != pbVar6);
                pbVar7 = pbVar11 + hashLen;
                iVar2 = memcmp(b + hashLen, pbVar7, __n);
                if (iVar2 < 0) {
                    iVar3 = 2;
                    puts("Invalid solution: Index tree incorrectly ordered");
                    goto LAB_00042684;
                }
                _Var1 = DistinctIndices(pbVar11, b, hashLen, __n);
                if (!_Var1) {
                    iVar3 = 1;
                    puts("Invalid solution: duplicate indices");
                    goto LAB_00042684;
                }
                memset(tmpHash, 0, 0x1e);
                pbVar16 = pbVar11 + -1;
                pbVar6 = tmpHash;
                pbVar15 = b;
                do {
                    __src_00 = pbVar15 + 1;
                    pbVar16 = pbVar16 + 1;
                    *pbVar6 = *pbVar15 ^ *pbVar16;
                    pbVar6 = pbVar6 + 1;
                    pbVar15 = __src_00;
                } while (__src_00 != b + hashLen);
                uVar12 = uVar13 + 1;
                iVar2 = (local_89c + sVar4) * (uVar13 & 0x7fffffff);
                pbVar11 = pbVar11 + iVar3;
                b = b + iVar3;
                iVar9 = iVar2 + local_89c;
                memcpy((void *)((int)__src + iVar2), tmpHash + 3, local_89c);
                memcpy((void *)((int)__src + iVar9), pbVar7, __n);
                memcpy((void *)(iVar9 + __n + (int)__src), __src_00, __n);
                uVar13 = uVar12;
            } while (iVar5 + 2U < uVar14);
        }
        hashLen = hashLen - 3;
        memcpy(__dest, __src, 0x4400);
        memset(__src, 0, 0x4400);
        __n = sVar4;
        uVar14 = uVar12;
        sVar4 = local_89c - 3;
    } while (hashLen != 3);
    if (*__dest == 0) {
        pbVar11 = __dest;
        do {
            if (__dest + (local_89c - 1) == pbVar11) {
                iVar3 = 0;
                goto LAB_00042684;
            }
            pbVar11 = pbVar11 + 1;
        } while (*pbVar11 == 0);
    }
    iVar3 = 2;
LAB_00042684:
    free(__dest);
    free(__src);
    return iVar3;
}

/* WARNING: Unknown calling convention */

void digestInit(blake2b_state *S, int n, int k)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    blake2b_param P[1];

    memset(P, 0, 0x30);
    P[0].fanout = '\x01';
    P[0].depth = '\x01';
    iVar1 = __aeabi_idiv(0x200, n);
    uVar2 = n * iVar1;
    uVar3 = uVar2 & ~((int)uVar2 >> 0x20);
    if ((int)uVar2 < 0) {
        uVar3 = uVar2 + 7;
    }
    builtin_memcpy(&P[0].digest_length, "ZcashPoW", 8);
    P[0].digest_length = (uint8_t)((int)uVar3 >> 3);
    P[0].personal._8_4_ = n;
    P[0].personal._12_4_ = k;
    blake2b_init_param(S, P);
    return;
}

/* WARNING: Unknown calling convention */

int blake2b_compress(blake2b_state *S, uint8_t *block)

{
    size_t *psVar1;
    size_t *psVar2;
    size_t *psVar3;
    uint uVar4;
    uint64_t *puVar5;
    uint uVar6;
    size_t sVar7;
    uint uVar8;
    uint uVar9;
    uint64_t *puVar10;
    uint uVar11;
    uint uVar12;
    uint uVar13;
    uint uVar14;
    uint uVar15;
    uint uVar16;
    uint uVar17;
    uint uVar18;
    uint uVar19;
    uint uVar20;
    uint uVar21;
    uint uVar22;
    uint uVar23;
    uint uVar24;
    uint uVar25;
    uint uVar26;
    uint uVar27;
    uint uVar28;
    uint uVar29;
    uint uVar30;
    uint uVar31;
    uint uVar32;
    uint uVar33;
    uint uVar34;
    uint uVar35;
    uint uVar36;
    uint uVar37;
    uint uVar38;
    uint uVar39;
    uint uVar40;
    uint uVar41;
    uint uVar42;
    uint uVar43;
    uint uVar44;
    uint uVar45;
    uint uVar46;
    uint uVar47;
    uint uVar48;
    uint uVar49;
    uint64_t local_130;
    uint64_t m[16];
    uint64_t v[16];

    puVar5 = &local_130;
    do {
        sVar7 = *(size_t *)((int)block + 4);
        puVar10 = puVar5 + 1;
        *(size_t *)puVar10 = *(size_t *)block;
        *(size_t *)((int)puVar5 + 0xc) = sVar7;
        block = (uint8_t *)((int)block + 8);
        puVar5 = puVar10;
    } while (m + 0xf != puVar10);
    psVar3 = &S[-1].buflen;
    puVar5 = m + 0xf;
    do {
        psVar2 = psVar3 + 2;
        sVar7 = psVar3[3];
        *(size_t *)(puVar5 + 1) = *psVar2;
        *(size_t *)((int)puVar5 + 0xc) = sVar7;
        psVar3 = psVar2;
        puVar5 = puVar5 + 1;
    } while (S->h + 7 != (uint64_t *)psVar2);
    uVar21 = (uint)v[4] + (uint)v[0] + (uint)m[0];
    uVar32 = v[4]._4_4_ + v[0]._4_4_ + (uint)CARRY4((uint)v[4], (uint)v[0]) +
             m[0]._4_4_ + (uint)CARRY4((uint)v[4] + (uint)v[0], (uint)m[0]);
    uVar23 = uVar32 ^ 0x510e527f ^ *(uint *)((int)S->t + 4);
    uVar4 = uVar23 + 0xf3bcc908;
    uVar19 = uVar21 ^ 0xade682d1 ^ (uint)S->t[0];
    uVar11 = uVar19 + (0xc4336f7 < uVar23) + 0x6a09e667;
    uVar31 = v[4]._4_4_ ^ uVar11;
    uVar6 = ((uint)v[4] ^ uVar4) >> 0x18 | uVar31 << 8;
    uVar15 = uVar31 >> 0x18 | ((uint)v[4] ^ uVar4) << 8;
    uVar8 = uVar21 + (uint)m[1] + uVar6;
    uVar16 = uVar32 + m[1]._4_4_ + (uint)CARRY4(uVar21, (uint)m[1]) + uVar15 +
             CARRY4(uVar21 + (uint)m[1], uVar6);
    uVar19 = uVar16 ^ uVar19;
    uVar33 = (uVar23 ^ uVar8) >> 0x10 | uVar19 << 0x10;
    uVar21 = uVar19 >> 0x10 | (uVar23 ^ uVar8) << 0x10;
    uVar32 = uVar4 + uVar33;
    uVar11 = uVar11 + uVar21 + CARRY4(uVar4, uVar33);
    uVar34 = (uint)v[5] + (uint)v[1] + (uint)m[2];
    uVar23 = m[2]._4_4_ + v[5]._4_4_ + v[1]._4_4_ +
             (uint)CARRY4((uint)v[5], (uint)v[1]) +
             (uint)CARRY4((uint)v[5] + (uint)v[1], (uint)m[2]);
    uVar12 = uVar23 ^ 0x9b05688c ^ *(uint *)((int)S->t + 0xc);
    uVar4 = uVar12 + 0x84caa73b;
    uVar19 = uVar34 ^ 0x2b3e6c1f ^ (uint)S->t[1];
    uVar31 = uVar19 + (0x7b3558c4 < uVar12) + 0xbb67ae85;
    uVar24 = v[5]._4_4_ ^ uVar31;
    uVar25 = ((uint)v[5] ^ uVar4) >> 0x18 | uVar24 << 8;
    uVar27 = uVar24 >> 0x18 | ((uint)v[5] ^ uVar4) << 8;
    uVar35 = uVar34 + (uint)m[3] + uVar25;
    uVar36 = m[3]._4_4_ + uVar23 + CARRY4(uVar34, (uint)m[3]) + uVar27 +
             CARRY4(uVar34 + (uint)m[3], uVar25);
    uVar19 = uVar19 ^ uVar36;
    uVar37 = (uVar12 ^ uVar35) >> 0x10 | uVar19 << 0x10;
    uVar38 = uVar19 >> 0x10 | (uVar12 ^ uVar35) << 0x10;
    uVar39 = uVar4 + uVar37;
    uVar31 = uVar31 + uVar38 + CARRY4(uVar4, uVar37);
    uVar19 = (uint)v[6] + (uint)v[2] + (uint)m[4];
    uVar12 = m[4]._4_4_ + v[6]._4_4_ + v[2]._4_4_ +
             (uint)CARRY4((uint)v[6], (uint)v[2]) +
             (uint)CARRY4((uint)v[6] + (uint)v[2], (uint)m[4]);
    uVar40 = uVar12 ^ 0x1f83d9ab ^ *(uint *)((int)S->f + 4);
    uVar23 = uVar19 ^ 0xfb41bd6b ^ (uint)S->f[0];
    uVar4 = uVar40 + 0xfe94f82b;
    uVar24 = uVar23 + (0x16b07d4 < uVar40) + 0x3c6ef372;
    uVar34 = v[6]._4_4_ ^ uVar24;
    uVar22 = ((uint)v[6] ^ uVar4) >> 0x18 | uVar34 << 8;
    uVar20 = uVar34 >> 0x18 | ((uint)v[6] ^ uVar4) << 8;
    uVar17 = uVar19 + (uint)m[5] + uVar22;
    uVar13 = m[5]._4_4_ + uVar12 + CARRY4(uVar19, (uint)m[5]) + uVar20 +
             CARRY4(uVar19 + (uint)m[5], uVar22);
    uVar23 = uVar23 ^ uVar13;
    uVar41 = uVar23 >> 0x10 | (uVar17 ^ uVar40) << 0x10;
    uVar40 = (uVar17 ^ uVar40) >> 0x10 | uVar23 << 0x10;
    uVar12 = uVar4 + uVar40;
    uVar24 = uVar24 + uVar41 + CARRY4(uVar4, uVar40);
    uVar19 = (uint)v[7] + (uint)v[3] + (uint)m[6];
    uVar42 = v[7]._4_4_ + v[3]._4_4_ + (uint)CARRY4((uint)v[7], (uint)v[3]) +
             m[6]._4_4_ + (uint)CARRY4((uint)v[7] + (uint)v[3], (uint)m[6]);
    uVar23 = uVar42 ^ 0x5be0cd19 ^ *(uint *)((int)S->f + 0xc);
    uVar34 = uVar23 + 0x5f1d36f1;
    uVar9 = uVar19 ^ 0x137e2179 ^ (uint)S->f[1];
    uVar14 = uVar9 + (0xa0e2c90e < uVar23) + 0xa54ff53a;
    uVar4 = v[7]._4_4_ ^ uVar14;
    uVar18 = ((uint)v[7] ^ uVar34) >> 0x18 | uVar4 << 8;
    uVar26 = uVar4 >> 0x18 | ((uint)v[7] ^ uVar34) << 8;
    uVar4 = uVar19 + (uint)m[7] + uVar18;
    uVar43 = uVar42 + m[7]._4_4_ + (uint)CARRY4(uVar19, (uint)m[7]) + uVar26 +
             CARRY4(uVar19 + (uint)m[7], uVar18);
    uVar9 = uVar9 ^ uVar43;
    uVar19 = uVar9 >> 0x10 | (uVar23 ^ uVar4) << 0x10;
    uVar27 = uVar31 ^ uVar27;
    uVar42 = (uVar23 ^ uVar4) >> 0x10 | uVar9 << 0x10;
    uVar9 = uVar34 + uVar42;
    uVar14 = uVar19 + uVar14 + CARRY4(uVar34, uVar42);
    uVar23 = (uVar39 ^ uVar25) << 1 | uVar27 >> 0x1f;
    uVar25 = uVar27 << 1 | (uVar39 ^ uVar25) >> 0x1f;
    uVar26 = uVar14 ^ uVar26;
    uVar34 = uVar8 + (uint)m[8] + uVar23;
    uVar8 = uVar16 + m[8]._4_4_ + (uint)CARRY4(uVar8, (uint)m[8]) + uVar25 +
            CARRY4(uVar8 + (uint)m[8], uVar23);
    uVar19 = uVar8 ^ uVar19;
    uVar27 = uVar12 + uVar19;
    uVar16 = uVar24 + (uVar42 ^ uVar34) + (uint)CARRY4(uVar12, uVar19);
    uVar25 = uVar16 ^ uVar25;
    uVar28 = (uVar27 ^ uVar23) >> 0x18 | uVar25 << 8;
    uVar23 = uVar25 >> 0x18 | (uVar27 ^ uVar23) << 8;
    uVar24 = uVar24 ^ uVar20;
    uVar29 = uVar34 + (uint)m[9] + uVar28;
    uVar44 = uVar8 + m[9]._4_4_ + (uint)CARRY4(uVar34, (uint)m[9]) + uVar23 +
             CARRY4(uVar34 + (uint)m[9], uVar28);
    uVar8 = (uVar12 ^ uVar22) << 1 | uVar24 >> 0x1f;
    uVar34 = uVar42 ^ uVar34 ^ uVar44;
    uVar25 = uVar34 >> 0x10 | (uVar19 ^ uVar29) << 0x10;
    uVar30 = (uVar19 ^ uVar29) >> 0x10 | uVar34 << 0x10;
    uVar45 = uVar27 + uVar30;
    uVar19 = uVar24 << 1 | (uVar12 ^ uVar22) >> 0x1f;
    uVar16 = uVar16 + uVar25 + CARRY4(uVar27, uVar30);
    uVar22 = uVar35 + (uint)m[10] + uVar8;
    uVar24 = uVar19 + uVar36 + m[10]._4_4_ + (uint)CARRY4(uVar35, (uint)m[10]) +
             (uint)CARRY4(uVar35 + (uint)m[10], uVar8);
    uVar21 = uVar24 ^ uVar21;
    uVar12 = uVar9 + uVar21;
    uVar14 = uVar14 + (uVar22 ^ uVar33) + (uint)CARRY4(uVar9, uVar21);
    uVar19 = uVar19 ^ uVar14;
    uVar20 = (uVar8 ^ uVar12) >> 0x18 | uVar19 << 8;
    uVar27 = uVar19 >> 0x18 | (uVar8 ^ uVar12) << 8;
    uVar34 = (uVar18 ^ uVar9) << 1 | uVar26 >> 0x1f;
    uVar35 = uVar22 + (uint)m[0xb] + uVar20;
    uVar36 = m[0xb]._4_4_ + uVar24 + CARRY4(uVar22, (uint)m[0xb]) + uVar27 +
             CARRY4(uVar22 + (uint)m[0xb], uVar20);
    uVar24 = uVar26 << 1 | (uVar18 ^ uVar9) >> 0x1f;
    uVar19 = uVar36 ^ uVar22 ^ uVar33;
    uVar18 = (uVar21 ^ uVar35) >> 0x10 | uVar19 << 0x10;
    uVar9 = uVar19 >> 0x10 | (uVar21 ^ uVar35) << 0x10;
    uVar46 = uVar12 + uVar18;
    uVar14 = uVar14 + uVar9 + CARRY4(uVar12, uVar18);
    uVar8 = uVar17 + (uint)m[0xc] + uVar34;
    uVar19 = uVar13 + m[0xc]._4_4_ + (uint)CARRY4(uVar17, (uint)m[0xc]) +
             uVar24 + CARRY4(uVar17 + (uint)m[0xc], uVar34);
    uVar38 = uVar38 ^ uVar19;
    uVar21 = uVar32 + uVar38;
    uVar12 = uVar11 + (uVar8 ^ uVar37) + (uint)CARRY4(uVar32, uVar38);
    uVar11 = uVar11 ^ uVar15;
    uVar24 = uVar12 ^ uVar24;
    uVar22 = (uVar21 ^ uVar34) >> 0x18 | uVar24 << 8;
    uVar42 = uVar24 >> 0x18 | (uVar21 ^ uVar34) << 8;
    uVar13 = uVar8 + (uint)m[0xd] + uVar22;
    uVar34 = (uVar32 ^ uVar6) << 1 | uVar11 >> 0x1f;
    uVar15 = m[0xd]._4_4_ + uVar19 + CARRY4(uVar8, (uint)m[0xd]) + uVar42 +
             CARRY4(uVar8 + (uint)m[0xd], uVar22);
    uVar11 = uVar11 << 1 | (uVar32 ^ uVar6) >> 0x1f;
    uVar19 = uVar8 ^ uVar37 ^ uVar15;
    uVar37 = (uVar38 ^ uVar13) >> 0x10 | uVar19 << 0x10;
    uVar8 = uVar19 >> 0x10 | (uVar38 ^ uVar13) << 0x10;
    uVar32 = uVar21 + uVar37;
    uVar24 = uVar8 + uVar12 + CARRY4(uVar21, uVar37);
    uVar42 = uVar24 ^ uVar42;
    uVar21 = uVar4 + (uint)m[0xe] + uVar34;
    uVar6 = uVar43 + m[0xe]._4_4_ + (uint)CARRY4(uVar4, (uint)m[0xe]) + uVar11 +
            CARRY4(uVar4 + (uint)m[0xe], uVar34);
    uVar41 = uVar6 ^ uVar41;
    uVar4 = uVar39 + uVar41;
    uVar23 = uVar16 ^ uVar23;
    uVar31 = uVar31 + (uVar21 ^ uVar40) + (uint)CARRY4(uVar39, uVar41);
    uVar11 = uVar31 ^ uVar11;
    uVar12 = (uVar34 ^ uVar4) >> 0x18 | uVar11 << 8;
    uVar19 = uVar11 >> 0x18 | (uVar34 ^ uVar4) << 8;
    uVar33 = uVar21 + (uint)m[0xf] + uVar12;
    uVar11 = uVar6 + m[0xf]._4_4_ + (uint)CARRY4(uVar21, (uint)m[0xf]) +
             uVar19 + CARRY4(uVar21 + (uint)m[0xf], uVar12);
    uVar21 = uVar11 ^ uVar21 ^ uVar40;
    uVar17 = (uVar33 ^ uVar41) >> 0x10 | uVar21 << 0x10;
    uVar27 = uVar14 ^ uVar27;
    uVar6 = uVar21 >> 0x10 | (uVar33 ^ uVar41) << 0x10;
    uVar21 = uVar4 + uVar17;
    uVar4 = uVar6 + uVar31 + CARRY4(uVar4, uVar17);
    uVar19 = uVar19 ^ uVar4;
    uVar40 = (uVar21 ^ uVar12) << 1 | uVar19 >> 0x1f;
    uVar12 = uVar19 << 1 | (uVar21 ^ uVar12) >> 0x1f;
    uVar31 = uVar29 + (uint)m[0xe] + uVar40;
    uVar34 = uVar44 + m[0xe]._4_4_ + (uint)CARRY4(uVar29, (uint)m[0xe]) +
             uVar12 + CARRY4(uVar29 + (uint)m[0xe], uVar40);
    uVar9 = uVar34 ^ uVar9;
    uVar19 = uVar32 + uVar9;
    uVar24 = uVar24 + (uVar31 ^ uVar18) + (uint)CARRY4(uVar32, uVar9);
    uVar12 = uVar12 ^ uVar24;
    uVar38 = (uVar19 ^ uVar40) >> 0x18 | uVar12 << 8;
    uVar39 = (uint)m[10] + uVar31 + uVar38;
    uVar40 = uVar12 >> 0x18 | (uVar19 ^ uVar40) << 8;
    uVar43 = m[10]._4_4_ + uVar34 + CARRY4((uint)m[10], uVar31) + uVar40 +
             CARRY4((uint)m[10] + uVar31, uVar38);
    uVar31 = uVar43 ^ uVar31 ^ uVar18;
    uVar44 = (uVar9 ^ uVar39) >> 0x10 | uVar31 << 0x10;
    uVar26 = uVar31 >> 0x10 | (uVar9 ^ uVar39) << 0x10;
    uVar9 = (uVar45 ^ uVar28) << 1 | uVar23 >> 0x1f;
    uVar31 = uVar23 << 1 | (uVar45 ^ uVar28) >> 0x1f;
    uVar41 = uVar19 + uVar44;
    uVar24 = uVar24 + uVar26 + CARRY4(uVar19, uVar44);
    uVar19 = (uint)m[4] + uVar35 + uVar9;
    uVar34 = uVar31 + m[4]._4_4_ + uVar36 + (uint)CARRY4((uint)m[4], uVar35) +
             (uint)CARRY4((uint)m[4] + uVar35, uVar9);
    uVar8 = uVar8 ^ uVar34;
    uVar40 = uVar24 ^ uVar40;
    uVar23 = uVar21 + uVar8;
    uVar4 = (uVar19 ^ uVar37) + uVar4 + CARRY4(uVar21, uVar8);
    uVar31 = uVar31 ^ uVar4;
    uVar12 = (uVar23 ^ uVar9) >> 0x18 | uVar31 << 8;
    uVar29 = uVar31 >> 0x18 | (uVar23 ^ uVar9) << 8;
    uVar36 = (uint)m[8] + uVar19 + uVar12;
    uVar47 = m[8]._4_4_ + uVar34 + CARRY4((uint)m[8], uVar19) + uVar29 +
             CARRY4((uint)m[8] + uVar19, uVar12);
    uVar19 = uVar19 ^ uVar37 ^ uVar47;
    uVar37 = (uVar8 ^ uVar36) >> 0x10 | uVar19 << 0x10;
    uVar48 = uVar19 >> 0x10 | (uVar8 ^ uVar36) << 0x10;
    uVar49 = uVar23 + uVar37;
    uVar31 = (uVar46 ^ uVar20) << 1 | uVar27 >> 0x1f;
    uVar4 = uVar4 + uVar48 + CARRY4(uVar23, uVar37);
    uVar34 = uVar27 << 1 | (uVar46 ^ uVar20) >> 0x1f;
    uVar21 = (uint)m[9] + uVar13 + uVar31;
    uVar19 = uVar34 + m[9]._4_4_ + uVar15 + CARRY4((uint)m[9], uVar13) +
             (uint)CARRY4((uint)m[9] + uVar13, uVar31);
    uVar6 = uVar19 ^ uVar6;
    uVar29 = uVar4 ^ uVar29;
    uVar23 = uVar45 + uVar6;
    uVar16 = uVar16 + (uVar21 ^ uVar17) + (uint)CARRY4(uVar45, uVar6);
    uVar34 = uVar34 ^ uVar16;
    uVar8 = (uVar31 ^ uVar23) >> 0x18 | uVar34 << 8;
    uVar35 = uVar34 >> 0x18 | (uVar31 ^ uVar23) << 8;
    uVar13 = (uint)m[0xf] + uVar21 + uVar8;
    uVar15 = m[0xf]._4_4_ + uVar19 + CARRY4((uint)m[0xf], uVar21) + uVar35 +
             CARRY4((uint)m[0xf] + uVar21, uVar8);
    uVar19 = uVar21 ^ uVar17 ^ uVar15;
    uVar17 = (uVar6 ^ uVar13) >> 0x10 | uVar19 << 0x10;
    uVar18 = uVar19 >> 0x10 | (uVar6 ^ uVar13) << 0x10;
    uVar6 = uVar42 << 1 | (uVar32 ^ uVar22) >> 0x1f;
    uVar31 = uVar23 + uVar17;
    uVar9 = uVar18 + uVar16 + CARRY4(uVar23, uVar17);
    uVar32 = (uVar32 ^ uVar22) << 1 | uVar42 >> 0x1f;
    uVar35 = uVar9 ^ uVar35;
    uVar21 = (uint)m[0xd] + uVar33 + uVar32;
    uVar23 = m[0xd]._4_4_ + uVar11 + CARRY4((uint)m[0xd], uVar33) + uVar6 +
             CARRY4((uint)m[0xd] + uVar33, uVar32);
    uVar25 = uVar23 ^ uVar25;
    uVar19 = uVar46 + uVar25;
    uVar14 = uVar14 + (uVar21 ^ uVar30) + (uint)CARRY4(uVar46, uVar25);
    uVar6 = uVar14 ^ uVar6;
    uVar11 = (uVar32 ^ uVar19) >> 0x18 | uVar6 << 8;
    uVar42 = (uint)m[6] + uVar21 + uVar11;
    uVar6 = uVar6 >> 0x18 | (uVar32 ^ uVar19) << 8;
    uVar28 = m[6]._4_4_ + uVar23 + CARRY4((uint)m[6], uVar21) + uVar6 +
             CARRY4((uint)m[6] + uVar21, uVar11);
    uVar21 = uVar28 ^ uVar21 ^ uVar30;
    uVar20 = (uVar42 ^ uVar25) >> 0x10 | uVar21 << 0x10;
    uVar34 = uVar21 >> 0x10 | (uVar42 ^ uVar25) << 0x10;
    uVar16 = (uVar49 ^ uVar12) << 1 | uVar29 >> 0x1f;
    uVar23 = uVar19 + uVar20;
    uVar14 = uVar14 + uVar34 + CARRY4(uVar19, uVar20);
    uVar12 = uVar29 << 1 | (uVar49 ^ uVar12) >> 0x1f;
    uVar6 = uVar6 ^ uVar14;
    uVar21 = (uint)m[1] + uVar39 + uVar16;
    uVar19 = m[1]._4_4_ + uVar43 + (uint)CARRY4((uint)m[1], uVar39) + uVar12 +
             CARRY4((uint)m[1] + uVar39, uVar16);
    uVar34 = uVar19 ^ uVar34;
    uVar32 = uVar31 + uVar34;
    uVar9 = uVar9 + (uVar21 ^ uVar20) + (uint)CARRY4(uVar31, uVar34);
    uVar12 = uVar9 ^ uVar12;
    uVar30 = (uVar32 ^ uVar16) >> 0x18 | uVar12 << 8;
    uVar39 = uVar12 >> 0x18 | (uVar32 ^ uVar16) << 8;
    uVar16 = (uint)m[0xc] + uVar21 + uVar30;
    uVar27 = m[0xc]._4_4_ + uVar19 + CARRY4((uint)m[0xc], uVar21) + uVar39 +
             CARRY4((uint)m[0xc] + uVar21, uVar30);
    uVar19 = uVar27 ^ uVar21 ^ uVar20;
    uVar20 = (uVar16 ^ uVar34) >> 0x10 | uVar19 << 0x10;
    uVar22 = uVar19 >> 0x10 | (uVar16 ^ uVar34) << 0x10;
    uVar25 = uVar32 + uVar20;
    uVar21 = uVar35 << 1 | (uVar31 ^ uVar8) >> 0x1f;
    uVar9 = uVar9 + uVar22 + CARRY4(uVar32, uVar20);
    uVar34 = (uVar31 ^ uVar8) << 1 | uVar35 >> 0x1f;
    uVar19 = (uint)m[0] + uVar36 + uVar34;
    uVar12 = uVar21 + m[0]._4_4_ + uVar47 + (uint)CARRY4((uint)m[0], uVar36) +
             (uint)CARRY4((uint)m[0] + uVar36, uVar34);
    uVar26 = uVar12 ^ uVar26;
    uVar32 = uVar23 + uVar26;
    uVar8 = (uVar19 ^ uVar44) + uVar14 + CARRY4(uVar23, uVar26);
    uVar39 = uVar9 ^ uVar39;
    uVar21 = uVar21 ^ uVar8;
    uVar31 = (uVar32 ^ uVar34) >> 0x18 | uVar21 << 8;
    uVar33 = uVar21 >> 0x18 | (uVar32 ^ uVar34) << 8;
    uVar43 = (uint)m[2] + uVar19 + uVar31;
    uVar45 = m[2]._4_4_ + uVar12 + CARRY4((uint)m[2], uVar19) + uVar33 +
             CARRY4((uint)m[2] + uVar19, uVar31);
    uVar19 = uVar19 ^ uVar44 ^ uVar45;
    uVar34 = (uVar43 ^ uVar26) >> 0x10 | uVar19 << 0x10;
    uVar21 = uVar19 >> 0x10 | (uVar43 ^ uVar26) << 0x10;
    uVar44 = uVar32 + uVar34;
    uVar12 = (uVar23 ^ uVar11) << 1 | uVar6 >> 0x1f;
    uVar8 = uVar8 + uVar21 + CARRY4(uVar32, uVar34);
    uVar6 = uVar6 << 1 | (uVar23 ^ uVar11) >> 0x1f;
    uVar33 = uVar8 ^ uVar33;
    uVar32 = (uint)m[0xb] + uVar13 + uVar12;
    uVar19 = m[0xb]._4_4_ + uVar15 + CARRY4((uint)m[0xb], uVar13) + uVar6 +
             CARRY4((uint)m[0xb] + uVar13, uVar12);
    uVar48 = uVar19 ^ uVar48;
    uVar23 = uVar41 + uVar48;
    uVar24 = uVar24 + (uVar32 ^ uVar37) + (uint)CARRY4(uVar41, uVar48);
    uVar6 = uVar24 ^ uVar6;
    uVar11 = (uVar12 ^ uVar23) >> 0x18 | uVar6 << 8;
    uVar12 = uVar6 >> 0x18 | (uVar12 ^ uVar23) << 8;
    uVar35 = (uint)m[7] + uVar32 + uVar11;
    uVar36 = m[7]._4_4_ + uVar19 + CARRY4((uint)m[7], uVar32) + uVar12 +
             CARRY4((uint)m[7] + uVar32, uVar11);
    uVar19 = uVar36 ^ uVar32 ^ uVar37;
    uVar46 = (uVar35 ^ uVar48) >> 0x10 | uVar19 << 0x10;
    uVar26 = uVar19 >> 0x10 | (uVar35 ^ uVar48) << 0x10;
    uVar32 = uVar23 + uVar46;
    uVar14 = uVar26 + uVar24 + CARRY4(uVar23, uVar46);
    uVar13 = (uVar41 ^ uVar38) << 1 | uVar40 >> 0x1f;
    uVar24 = uVar40 << 1 | (uVar41 ^ uVar38) >> 0x1f;
    uVar12 = uVar14 ^ uVar12;
    uVar19 = (uint)m[5] + uVar42 + uVar13;
    uVar6 = m[5]._4_4_ + uVar28 + CARRY4((uint)m[5], uVar42) + uVar24 +
            CARRY4((uint)m[5] + uVar42, uVar13);
    uVar18 = uVar6 ^ uVar18;
    uVar23 = uVar49 + uVar18;
    uVar4 = uVar4 + (uVar19 ^ uVar17) + (uint)CARRY4(uVar49, uVar18);
    uVar24 = uVar4 ^ uVar24;
    uVar40 = (uVar23 ^ uVar13) >> 0x18 | uVar24 << 8;
    uVar24 = uVar24 >> 0x18 | (uVar23 ^ uVar13) << 8;
    uVar13 = (uint)m[3] + uVar19 + uVar40;
    uVar15 = m[3]._4_4_ + uVar6 + CARRY4((uint)m[3], uVar19) + uVar24 +
             CARRY4((uint)m[3] + uVar19, uVar40);
    uVar19 = uVar15 ^ uVar19 ^ uVar17;
    uVar42 = (uVar13 ^ uVar18) >> 0x10 | uVar19 << 0x10;
    uVar28 = uVar19 >> 0x10 | (uVar13 ^ uVar18) << 0x10;
    uVar6 = uVar23 + uVar42;
    uVar4 = uVar4 + uVar28 + CARRY4(uVar23, uVar42);
    uVar24 = uVar4 ^ uVar24;
    uVar38 = (uVar6 ^ uVar40) << 1 | uVar24 >> 0x1f;
    uVar40 = uVar24 << 1 | (uVar6 ^ uVar40) >> 0x1f;
    uVar19 = (uint)m[0xb] + uVar16 + uVar38;
    uVar24 = m[0xb]._4_4_ + uVar27 + CARRY4((uint)m[0xb], uVar16) + uVar40 +
             CARRY4((uint)m[0xb] + uVar16, uVar38);
    uVar21 = uVar21 ^ uVar24;
    uVar23 = uVar32 + uVar21;
    uVar14 = (uVar34 ^ uVar19) + uVar14 + CARRY4(uVar32, uVar21);
    uVar40 = uVar14 ^ uVar40;
    uVar37 = (uVar23 ^ uVar38) >> 0x18 | uVar40 << 8;
    uVar41 = uVar40 >> 0x18 | (uVar23 ^ uVar38) << 8;
    uVar16 = (uint)m[8] + uVar19 + uVar37;
    uVar17 = m[8]._4_4_ + uVar24 + CARRY4((uint)m[8], uVar19) + uVar41 +
             CARRY4((uint)m[8] + uVar19, uVar37);
    uVar19 = uVar34 ^ uVar19 ^ uVar17;
    uVar18 = (uVar21 ^ uVar16) >> 0x10 | uVar19 << 0x10;
    uVar29 = uVar19 >> 0x10 | (uVar21 ^ uVar16) << 0x10;
    uVar34 = (uVar25 ^ uVar30) << 1 | uVar39 >> 0x1f;
    uVar21 = uVar39 << 1 | (uVar25 ^ uVar30) >> 0x1f;
    uVar27 = uVar23 + uVar18;
    uVar14 = uVar14 + uVar29 + CARRY4(uVar23, uVar18);
    uVar19 = (uint)m[0xc] + uVar43 + uVar34;
    uVar38 = uVar21 + m[0xc]._4_4_ + uVar45 +
             (uint)CARRY4((uint)m[0xc], uVar43) +
             (uint)CARRY4((uint)m[0xc] + uVar43, uVar34);
    uVar26 = uVar38 ^ uVar26;
    uVar24 = uVar6 + uVar26;
    uVar40 = (uVar19 ^ uVar46) + uVar4 + CARRY4(uVar6, uVar26);
    uVar41 = uVar14 ^ uVar41;
    uVar21 = uVar21 ^ uVar40;
    uVar23 = (uVar34 ^ uVar24) >> 0x18 | uVar21 << 8;
    uVar6 = uVar21 >> 0x18 | (uVar34 ^ uVar24) << 8;
    uVar39 = (uint)m[0] + uVar19 + uVar23;
    uVar43 = m[0]._4_4_ + uVar38 + CARRY4((uint)m[0], uVar19) + uVar6 +
             CARRY4((uint)m[0] + uVar19, uVar23);
    uVar4 = uVar19 ^ uVar46 ^ uVar43;
    uVar45 = (uVar26 ^ uVar39) >> 0x10 | uVar4 << 0x10;
    uVar21 = uVar4 >> 0x10 | (uVar26 ^ uVar39) << 0x10;
    uVar26 = (uVar44 ^ uVar31) << 1 | uVar33 >> 0x1f;
    uVar34 = uVar33 << 1 | (uVar44 ^ uVar31) >> 0x1f;
    uVar46 = uVar24 + uVar45;
    uVar40 = uVar40 + uVar21 + CARRY4(uVar24, uVar45);
    uVar6 = uVar40 ^ uVar6;
    uVar31 = (uint)m[5] + uVar35 + uVar26;
    uVar4 = uVar34 + m[5]._4_4_ + uVar36 + CARRY4((uint)m[5], uVar35) +
            (uint)CARRY4((uint)m[5] + uVar35, uVar26);
    uVar28 = uVar4 ^ uVar28;
    uVar19 = uVar25 + uVar28;
    uVar9 = uVar9 + (uVar31 ^ uVar42) + (uint)CARRY4(uVar25, uVar28);
    uVar34 = uVar34 ^ uVar9;
    uVar38 = (uVar19 ^ uVar26) >> 0x18 | uVar34 << 8;
    uVar36 = uVar34 >> 0x18 | (uVar19 ^ uVar26) << 8;
    uVar25 = (uint)m[2] + uVar31 + uVar38;
    uVar26 = m[2]._4_4_ + uVar4 + CARRY4((uint)m[2], uVar31) + uVar36 +
             CARRY4((uint)m[2] + uVar31, uVar38);
    uVar4 = uVar26 ^ uVar31 ^ uVar42;
    uVar42 = (uVar25 ^ uVar28) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar25 ^ uVar28) << 0x10;
    uVar31 = uVar19 + uVar42;
    uVar24 = (uVar32 ^ uVar11) << 1 | uVar12 >> 0x1f;
    uVar12 = uVar12 << 1 | (uVar32 ^ uVar11) >> 0x1f;
    uVar9 = uVar28 + uVar9 + CARRY4(uVar19, uVar42);
    uVar36 = uVar9 ^ uVar36;
    uVar32 = (uint)m[0xf] + uVar13 + uVar24;
    uVar4 = m[0xf]._4_4_ + uVar15 + CARRY4((uint)m[0xf], uVar13) + uVar12 +
            CARRY4((uint)m[0xf] + uVar13, uVar24);
    uVar22 = uVar4 ^ uVar22;
    uVar19 = uVar44 + uVar22;
    uVar8 = uVar8 + (uVar32 ^ uVar20) + (uint)CARRY4(uVar44, uVar22);
    uVar12 = uVar8 ^ uVar12;
    uVar11 = (uVar24 ^ uVar19) >> 0x18 | uVar12 << 8;
    uVar12 = uVar12 >> 0x18 | (uVar24 ^ uVar19) << 8;
    uVar30 = (uint)m[0xd] + uVar32 + uVar11;
    uVar33 = m[0xd]._4_4_ + uVar4 + CARRY4((uint)m[0xd], uVar32) + uVar12 +
             CARRY4((uint)m[0xd] + uVar32, uVar11);
    uVar4 = uVar33 ^ uVar32 ^ uVar20;
    uVar15 = (uVar30 ^ uVar22) >> 0x10 | uVar4 << 0x10;
    uVar34 = uVar4 >> 0x10 | (uVar30 ^ uVar22) << 0x10;
    uVar4 = uVar19 + uVar15;
    uVar24 = uVar6 << 1 | (uVar46 ^ uVar23) >> 0x1f;
    uVar8 = uVar8 + uVar34 + CARRY4(uVar19, uVar15);
    uVar6 = (uVar46 ^ uVar23) << 1 | uVar6 >> 0x1f;
    uVar12 = uVar12 ^ uVar8;
    uVar23 = (uint)m[10] + uVar16 + uVar6;
    uVar19 = m[10]._4_4_ + uVar17 + CARRY4((uint)m[10], uVar16) + uVar24 +
             CARRY4((uint)m[10] + uVar16, uVar6);
    uVar34 = uVar19 ^ uVar34;
    uVar32 = uVar31 + uVar34;
    uVar9 = uVar9 + (uVar23 ^ uVar15) + (uint)CARRY4(uVar31, uVar34);
    uVar24 = uVar9 ^ uVar24;
    uVar35 = (uVar32 ^ uVar6) >> 0x18 | uVar24 << 8;
    uVar44 = uVar24 >> 0x18 | (uVar32 ^ uVar6) << 8;
    uVar24 = (uint)m[0xe] + uVar23 + uVar35;
    uVar13 = m[0xe]._4_4_ + uVar19 + CARRY4((uint)m[0xe], uVar23) + uVar44 +
             CARRY4((uint)m[0xe] + uVar23, uVar35);
    uVar19 = uVar13 ^ uVar23 ^ uVar15;
    uVar16 = (uVar24 ^ uVar34) >> 0x10 | uVar19 << 0x10;
    uVar15 = uVar19 >> 0x10 | (uVar24 ^ uVar34) << 0x10;
    uVar17 = uVar32 + uVar16;
    uVar23 = uVar36 << 1 | (uVar31 ^ uVar38) >> 0x1f;
    uVar34 = (uVar31 ^ uVar38) << 1 | uVar36 >> 0x1f;
    uVar9 = uVar9 + uVar15 + CARRY4(uVar32, uVar16);
    uVar19 = (uint)m[3] + uVar39 + uVar34;
    uVar6 = uVar23 + m[3]._4_4_ + uVar43 + CARRY4((uint)m[3], uVar39) +
            (uint)CARRY4((uint)m[3] + uVar39, uVar34);
    uVar29 = uVar6 ^ uVar29;
    uVar44 = uVar9 ^ uVar44;
    uVar32 = uVar4 + uVar29;
    uVar8 = (uVar19 ^ uVar18) + uVar8 + CARRY4(uVar4, uVar29);
    uVar23 = uVar23 ^ uVar8;
    uVar31 = (uVar32 ^ uVar34) >> 0x18 | uVar23 << 8;
    uVar36 = uVar23 >> 0x18 | (uVar32 ^ uVar34) << 8;
    uVar43 = (uint)m[6] + uVar19 + uVar31;
    uVar47 = m[6]._4_4_ + uVar6 + CARRY4((uint)m[6], uVar19) + uVar36 +
             CARRY4((uint)m[6] + uVar19, uVar31);
    uVar19 = uVar19 ^ uVar18 ^ uVar47;
    uVar34 = (uVar43 ^ uVar29) >> 0x10 | uVar19 << 0x10;
    uVar19 = uVar19 >> 0x10 | (uVar43 ^ uVar29) << 0x10;
    uVar49 = uVar32 + uVar34;
    uVar8 = uVar8 + uVar19 + CARRY4(uVar32, uVar34);
    uVar32 = (uVar4 ^ uVar11) << 1 | uVar12 >> 0x1f;
    uVar12 = uVar12 << 1 | (uVar4 ^ uVar11) >> 0x1f;
    uVar23 = (uint)m[7] + uVar25 + uVar32;
    uVar38 = m[7]._4_4_ + uVar26 + CARRY4((uint)m[7], uVar25) + uVar12 +
             CARRY4((uint)m[7] + uVar25, uVar32);
    uVar36 = uVar8 ^ uVar36;
    uVar21 = uVar38 ^ uVar21;
    uVar4 = uVar27 + uVar21;
    uVar14 = uVar14 + (uVar23 ^ uVar45) + (uint)CARRY4(uVar27, uVar21);
    uVar12 = uVar14 ^ uVar12;
    uVar11 = (uVar32 ^ uVar4) >> 0x18 | uVar12 << 8;
    uVar29 = (uint)m[1] + uVar23 + uVar11;
    uVar6 = uVar12 >> 0x18 | (uVar32 ^ uVar4) << 8;
    uVar25 = m[1]._4_4_ + uVar38 + CARRY4((uint)m[1], uVar23) + uVar6 +
             CARRY4((uint)m[1] + uVar23, uVar11);
    uVar23 = uVar25 ^ uVar23 ^ uVar45;
    uVar45 = (uVar21 ^ uVar29) >> 0x10 | uVar23 << 0x10;
    uVar12 = uVar23 >> 0x10 | (uVar21 ^ uVar29) << 0x10;
    uVar18 = uVar41 << 1 | (uVar27 ^ uVar37) >> 0x1f;
    uVar20 = (uVar27 ^ uVar37) << 1 | uVar41 >> 0x1f;
    uVar32 = uVar4 + uVar45;
    uVar38 = uVar12 + uVar14 + CARRY4(uVar4, uVar45);
    uVar4 = (uint)m[9] + uVar30 + uVar20;
    uVar23 = m[9]._4_4_ + uVar33 + CARRY4((uint)m[9], uVar30) + uVar18 +
             CARRY4((uint)m[9] + uVar30, uVar20);
    uVar28 = uVar23 ^ uVar28;
    uVar6 = uVar38 ^ uVar6;
    uVar21 = uVar46 + uVar28;
    uVar40 = uVar40 + (uVar4 ^ uVar42) + (uint)CARRY4(uVar46, uVar28);
    uVar18 = uVar40 ^ uVar18;
    uVar27 = (uVar21 ^ uVar20) >> 0x18 | uVar18 << 8;
    uVar20 = uVar18 >> 0x18 | (uVar21 ^ uVar20) << 8;
    uVar14 = (uint)m[4] + uVar4 + uVar27;
    uVar18 = m[4]._4_4_ + uVar23 + CARRY4((uint)m[4], uVar4) + uVar20 +
             CARRY4((uint)m[4] + uVar4, uVar27);
    uVar4 = uVar18 ^ uVar4 ^ uVar42;
    uVar30 = (uVar14 ^ uVar28) >> 0x10 | uVar4 << 0x10;
    uVar42 = uVar4 >> 0x10 | (uVar14 ^ uVar28) << 0x10;
    uVar23 = uVar21 + uVar30;
    uVar40 = uVar40 + uVar42 + CARRY4(uVar21, uVar30);
    uVar20 = uVar40 ^ uVar20;
    uVar22 = (uVar23 ^ uVar27) << 1 | uVar20 >> 0x1f;
    uVar27 = uVar20 << 1 | (uVar23 ^ uVar27) >> 0x1f;
    uVar4 = (uint)m[7] + uVar24 + uVar22;
    uVar24 = m[7]._4_4_ + uVar13 + CARRY4((uint)m[7], uVar24) + uVar27 +
             CARRY4((uint)m[7] + uVar24, uVar22);
    uVar19 = uVar19 ^ uVar24;
    uVar21 = uVar32 + uVar19;
    uVar38 = (uVar34 ^ uVar4) + uVar38 + CARRY4(uVar32, uVar19);
    uVar27 = uVar38 ^ uVar27;
    uVar39 = (uVar21 ^ uVar22) >> 0x18 | uVar27 << 8;
    uVar46 = uVar27 >> 0x18 | (uVar21 ^ uVar22) << 8;
    uVar13 = (uint)m[9] + uVar4 + uVar39;
    uVar27 = m[9]._4_4_ + uVar24 + CARRY4((uint)m[9], uVar4) + uVar46 +
             CARRY4((uint)m[9] + uVar4, uVar39);
    uVar4 = uVar34 ^ uVar4 ^ uVar27;
    uVar20 = (uVar19 ^ uVar13) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar19 ^ uVar13) << 0x10;
    uVar22 = uVar21 + uVar20;
    uVar34 = (uVar17 ^ uVar35) << 1 | uVar44 >> 0x1f;
    uVar38 = uVar38 + uVar28 + CARRY4(uVar21, uVar20);
    uVar19 = uVar44 << 1 | (uVar17 ^ uVar35) >> 0x1f;
    uVar4 = (uint)m[3] + uVar43 + uVar34;
    uVar26 = uVar19 + m[3]._4_4_ + uVar47 + CARRY4((uint)m[3], uVar43) +
             (uint)CARRY4((uint)m[3] + uVar43, uVar34);
    uVar12 = uVar26 ^ uVar12;
    uVar24 = uVar23 + uVar12;
    uVar21 = (uVar4 ^ uVar45) + uVar40 + CARRY4(uVar23, uVar12);
    uVar46 = uVar38 ^ uVar46;
    uVar19 = uVar19 ^ uVar21;
    uVar23 = (uVar34 ^ uVar24) >> 0x18 | uVar19 << 8;
    uVar34 = uVar19 >> 0x18 | (uVar34 ^ uVar24) << 8;
    uVar37 = (uint)m[1] + uVar4 + uVar23;
    uVar43 = m[1]._4_4_ + uVar26 + CARRY4((uint)m[1], uVar4) + uVar34 +
             CARRY4((uint)m[1] + uVar4, uVar23);
    uVar4 = uVar4 ^ uVar45 ^ uVar43;
    uVar44 = (uVar12 ^ uVar37) >> 0x10 | uVar4 << 0x10;
    uVar40 = uVar4 >> 0x10 | (uVar12 ^ uVar37) << 0x10;
    uVar26 = (uVar49 ^ uVar31) << 1 | uVar36 >> 0x1f;
    uVar4 = uVar36 << 1 | (uVar49 ^ uVar31) >> 0x1f;
    uVar45 = uVar24 + uVar44;
    uVar21 = uVar21 + uVar40 + CARRY4(uVar24, uVar44);
    uVar12 = (uint)m[0xd] + uVar29 + uVar26;
    uVar24 = m[0xd]._4_4_ + uVar25 + CARRY4((uint)m[0xd], uVar29) + uVar4 +
             CARRY4((uint)m[0xd] + uVar29, uVar26);
    uVar34 = uVar21 ^ uVar34;
    uVar42 = uVar24 ^ uVar42;
    uVar31 = uVar17 + uVar42;
    uVar9 = uVar9 + (uVar12 ^ uVar30) + (uint)CARRY4(uVar17, uVar42);
    uVar4 = uVar4 ^ uVar9;
    uVar19 = (uVar31 ^ uVar26) >> 0x18 | uVar4 << 8;
    uVar36 = uVar4 >> 0x18 | (uVar31 ^ uVar26) << 8;
    uVar17 = (uint)m[0xc] + uVar12 + uVar19;
    uVar25 = m[0xc]._4_4_ + uVar24 + CARRY4((uint)m[0xc], uVar12) + uVar36 +
             CARRY4((uint)m[0xc] + uVar12, uVar19);
    uVar4 = uVar25 ^ uVar12 ^ uVar30;
    uVar26 = (uVar17 ^ uVar42) >> 0x10 | uVar4 << 0x10;
    uVar42 = uVar4 >> 0x10 | (uVar17 ^ uVar42) << 0x10;
    uVar24 = (uVar32 ^ uVar11) << 1 | uVar6 >> 0x1f;
    uVar6 = uVar6 << 1 | (uVar32 ^ uVar11) >> 0x1f;
    uVar32 = uVar31 + uVar26;
    uVar9 = uVar42 + uVar9 + CARRY4(uVar31, uVar26);
    uVar36 = uVar9 ^ uVar36;
    uVar4 = (uint)m[0xb] + uVar14 + uVar24;
    uVar31 = m[0xb]._4_4_ + uVar18 + CARRY4((uint)m[0xb], uVar14) + uVar6 +
             CARRY4((uint)m[0xb] + uVar14, uVar24);
    uVar15 = uVar31 ^ uVar15;
    uVar12 = uVar49 + uVar15;
    uVar8 = uVar8 + (uVar4 ^ uVar16) + (uint)CARRY4(uVar49, uVar15);
    uVar6 = uVar8 ^ uVar6;
    uVar14 = (uVar24 ^ uVar12) >> 0x18 | uVar6 << 8;
    uVar6 = uVar6 >> 0x18 | (uVar24 ^ uVar12) << 8;
    uVar29 = (uint)m[0xe] + uVar4 + uVar14;
    uVar33 = m[0xe]._4_4_ + uVar31 + CARRY4((uint)m[0xe], uVar4) + uVar6 +
             CARRY4((uint)m[0xe] + uVar4, uVar14);
    uVar4 = uVar33 ^ uVar4 ^ uVar16;
    uVar18 = (uVar29 ^ uVar15) >> 0x10 | uVar4 << 0x10;
    uVar16 = uVar4 >> 0x10 | (uVar29 ^ uVar15) << 0x10;
    uVar11 = (uVar45 ^ uVar23) << 1 | uVar34 >> 0x1f;
    uVar31 = uVar12 + uVar18;
    uVar24 = uVar34 << 1 | (uVar45 ^ uVar23) >> 0x1f;
    uVar8 = uVar8 + uVar16 + CARRY4(uVar12, uVar18);
    uVar6 = uVar6 ^ uVar8;
    uVar23 = (uint)m[2] + uVar13 + uVar11;
    uVar4 = m[2]._4_4_ + uVar27 + CARRY4((uint)m[2], uVar13) + uVar24 +
            CARRY4((uint)m[2] + uVar13, uVar11);
    uVar16 = uVar4 ^ uVar16;
    uVar12 = uVar32 + uVar16;
    uVar9 = uVar9 + (uVar23 ^ uVar18) + (uint)CARRY4(uVar32, uVar16);
    uVar24 = uVar9 ^ uVar24;
    uVar35 = (uVar12 ^ uVar11) >> 0x18 | uVar24 << 8;
    uVar41 = uVar24 >> 0x18 | (uVar12 ^ uVar11) << 8;
    uVar24 = (uint)m[6] + uVar23 + uVar35;
    uVar11 = m[6]._4_4_ + uVar4 + CARRY4((uint)m[6], uVar23) + uVar41 +
             CARRY4((uint)m[6] + uVar23, uVar35);
    uVar4 = uVar11 ^ uVar23 ^ uVar18;
    uVar13 = (uVar24 ^ uVar16) >> 0x10 | uVar4 << 0x10;
    uVar16 = uVar4 >> 0x10 | (uVar24 ^ uVar16) << 0x10;
    uVar18 = (uVar32 ^ uVar19) << 1 | uVar36 >> 0x1f;
    uVar19 = uVar36 << 1 | (uVar32 ^ uVar19) >> 0x1f;
    uVar15 = uVar12 + uVar13;
    uVar9 = uVar9 + uVar16 + CARRY4(uVar12, uVar13);
    uVar4 = (uint)m[5] + uVar37 + uVar18;
    uVar41 = uVar9 ^ uVar41;
    uVar12 = uVar19 + m[5]._4_4_ + uVar43 + CARRY4((uint)m[5], uVar37) +
             (uint)CARRY4((uint)m[5] + uVar37, uVar18);
    uVar28 = uVar12 ^ uVar28;
    uVar32 = uVar31 + uVar28;
    uVar34 = (uVar4 ^ uVar20) + uVar8 + CARRY4(uVar31, uVar28);
    uVar19 = uVar19 ^ uVar34;
    uVar23 = (uVar32 ^ uVar18) >> 0x18 | uVar19 << 8;
    uVar36 = uVar19 >> 0x18 | (uVar32 ^ uVar18) << 8;
    uVar47 = (uint)m[10] + uVar4 + uVar23;
    uVar49 = m[10]._4_4_ + uVar12 + CARRY4((uint)m[10], uVar4) + uVar36 +
             CARRY4((uint)m[10] + uVar4, uVar23);
    uVar4 = uVar4 ^ uVar20 ^ uVar49;
    uVar8 = (uVar47 ^ uVar28) >> 0x10 | uVar4 << 0x10;
    uVar19 = uVar4 >> 0x10 | (uVar47 ^ uVar28) << 0x10;
    uVar48 = uVar32 + uVar8;
    uVar18 = uVar6 << 1 | (uVar31 ^ uVar14) >> 0x1f;
    uVar12 = (uVar31 ^ uVar14) << 1 | uVar6 >> 0x1f;
    uVar34 = uVar34 + uVar19 + CARRY4(uVar32, uVar8);
    uVar4 = (uint)m[4] + uVar17 + uVar12;
    uVar32 = m[4]._4_4_ + uVar25 + CARRY4((uint)m[4], uVar17) + uVar18 +
             CARRY4((uint)m[4] + uVar17, uVar12);
    uVar36 = uVar34 ^ uVar36;
    uVar40 = uVar32 ^ uVar40;
    uVar31 = uVar22 + uVar40;
    uVar38 = uVar38 + (uVar4 ^ uVar44) + (uint)CARRY4(uVar22, uVar40);
    uVar18 = uVar38 ^ uVar18;
    uVar17 = (uVar12 ^ uVar31) >> 0x18 | uVar18 << 8;
    uVar37 = (uint)m[0] + uVar4 + uVar17;
    uVar12 = uVar18 >> 0x18 | (uVar12 ^ uVar31) << 8;
    uVar28 = m[0]._4_4_ + uVar32 + CARRY4((uint)m[0], uVar4) + uVar12 +
             CARRY4((uint)m[0] + uVar4, uVar17);
    uVar4 = uVar28 ^ uVar4 ^ uVar44;
    uVar44 = (uVar40 ^ uVar37) >> 0x10 | uVar4 << 0x10;
    uVar30 = uVar4 >> 0x10 | (uVar40 ^ uVar37) << 0x10;
    uVar14 = uVar46 << 1 | (uVar22 ^ uVar39) >> 0x1f;
    uVar18 = (uVar22 ^ uVar39) << 1 | uVar46 >> 0x1f;
    uVar32 = uVar31 + uVar44;
    uVar40 = uVar30 + uVar38 + CARRY4(uVar31, uVar44);
    uVar12 = uVar40 ^ uVar12;
    uVar4 = (uint)m[0xf] + uVar29 + uVar18;
    uVar6 = m[0xf]._4_4_ + uVar33 + CARRY4((uint)m[0xf], uVar29) + uVar14 +
            CARRY4((uint)m[0xf] + uVar29, uVar18);
    uVar42 = uVar6 ^ uVar42;
    uVar31 = uVar45 + uVar42;
    uVar21 = uVar21 + (uVar4 ^ uVar26) + (uint)CARRY4(uVar45, uVar42);
    uVar14 = uVar21 ^ uVar14;
    uVar38 = (uVar31 ^ uVar18) >> 0x18 | uVar14 << 8;
    uVar14 = uVar14 >> 0x18 | (uVar31 ^ uVar18) << 8;
    uVar18 = (uint)m[8] + uVar4 + uVar38;
    uVar27 = m[8]._4_4_ + uVar6 + CARRY4((uint)m[8], uVar4) + uVar14 +
             CARRY4((uint)m[8] + uVar4, uVar38);
    uVar4 = uVar27 ^ uVar4 ^ uVar26;
    uVar39 = (uVar18 ^ uVar42) >> 0x10 | uVar4 << 0x10;
    uVar33 = uVar4 >> 0x10 | (uVar18 ^ uVar42) << 0x10;
    uVar6 = uVar31 + uVar39;
    uVar21 = uVar21 + uVar33 + CARRY4(uVar31, uVar39);
    uVar14 = uVar21 ^ uVar14;
    uVar20 = (uVar6 ^ uVar38) << 1 | uVar14 >> 0x1f;
    uVar38 = uVar14 << 1 | (uVar6 ^ uVar38) >> 0x1f;
    uVar4 = (uint)m[9] + uVar24 + uVar20;
    uVar24 = m[9]._4_4_ + uVar11 + CARRY4((uint)m[9], uVar24) + uVar38 +
             CARRY4((uint)m[9] + uVar24, uVar20);
    uVar19 = uVar19 ^ uVar24;
    uVar31 = uVar32 + uVar19;
    uVar14 = (uVar8 ^ uVar4) + uVar40 + CARRY4(uVar32, uVar19);
    uVar38 = uVar14 ^ uVar38;
    uVar43 = (uVar31 ^ uVar20) >> 0x18 | uVar38 << 8;
    uVar45 = uVar38 >> 0x18 | (uVar31 ^ uVar20) << 8;
    uVar11 = (uint)m[0] + uVar4 + uVar43;
    uVar20 = m[0]._4_4_ + uVar24 + CARRY4((uint)m[0], uVar4) + uVar45 +
             CARRY4((uint)m[0] + uVar4, uVar43);
    uVar4 = uVar8 ^ uVar4 ^ uVar20;
    uVar22 = (uVar19 ^ uVar11) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar19 ^ uVar11) << 0x10;
    uVar24 = (uVar15 ^ uVar35) << 1 | uVar41 >> 0x1f;
    uVar19 = uVar41 << 1 | (uVar15 ^ uVar35) >> 0x1f;
    uVar25 = uVar31 + uVar22;
    uVar14 = uVar14 + uVar29 + CARRY4(uVar31, uVar22);
    uVar4 = (uint)m[5] + uVar47 + uVar24;
    uVar8 = uVar19 + m[5]._4_4_ + uVar49 + CARRY4((uint)m[5], uVar47) +
            (uint)CARRY4((uint)m[5] + uVar47, uVar24);
    uVar30 = uVar8 ^ uVar30;
    uVar31 = uVar6 + uVar30;
    uVar38 = (uVar4 ^ uVar44) + uVar21 + CARRY4(uVar6, uVar30);
    uVar45 = uVar14 ^ uVar45;
    uVar19 = uVar19 ^ uVar38;
    uVar21 = (uVar24 ^ uVar31) >> 0x18 | uVar19 << 8;
    uVar6 = uVar19 >> 0x18 | (uVar24 ^ uVar31) << 8;
    uVar46 = (uint)m[7] + uVar4 + uVar21;
    uVar41 = m[7]._4_4_ + uVar8 + CARRY4((uint)m[7], uVar4) + uVar6 +
             CARRY4((uint)m[7] + uVar4, uVar21);
    uVar4 = uVar4 ^ uVar44 ^ uVar41;
    uVar44 = (uVar30 ^ uVar46) >> 0x10 | uVar4 << 0x10;
    uVar8 = uVar4 >> 0x10 | (uVar30 ^ uVar46) << 0x10;
    uVar47 = uVar31 + uVar44;
    uVar40 = (uVar48 ^ uVar23) << 1 | uVar36 >> 0x1f;
    uVar23 = uVar36 << 1 | (uVar48 ^ uVar23) >> 0x1f;
    uVar38 = uVar38 + uVar8 + CARRY4(uVar31, uVar44);
    uVar6 = uVar38 ^ uVar6;
    uVar4 = (uint)m[2] + uVar37 + uVar40;
    uVar31 = m[2]._4_4_ + uVar28 + CARRY4((uint)m[2], uVar37) + uVar23 +
             CARRY4((uint)m[2] + uVar37, uVar40);
    uVar33 = uVar31 ^ uVar33;
    uVar19 = uVar15 + uVar33;
    uVar9 = uVar9 + (uVar4 ^ uVar39) + (uint)CARRY4(uVar15, uVar33);
    uVar23 = uVar23 ^ uVar9;
    uVar24 = (uVar19 ^ uVar40) >> 0x18 | uVar23 << 8;
    uVar36 = uVar23 >> 0x18 | (uVar19 ^ uVar40) << 8;
    uVar15 = (uint)m[4] + uVar4 + uVar24;
    uVar26 = m[4]._4_4_ + uVar31 + CARRY4((uint)m[4], uVar4) + uVar36 +
             CARRY4((uint)m[4] + uVar4, uVar24);
    uVar4 = uVar26 ^ uVar4 ^ uVar39;
    uVar42 = (uVar15 ^ uVar33) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar15 ^ uVar33) << 0x10;
    uVar40 = (uVar32 ^ uVar17) << 1 | uVar12 >> 0x1f;
    uVar32 = uVar12 << 1 | (uVar32 ^ uVar17) >> 0x1f;
    uVar23 = uVar19 + uVar42;
    uVar9 = uVar28 + uVar9 + CARRY4(uVar19, uVar42);
    uVar36 = uVar9 ^ uVar36;
    uVar19 = (uint)m[10] + uVar18 + uVar40;
    uVar4 = m[10]._4_4_ + uVar27 + CARRY4((uint)m[10], uVar18) + uVar32 +
            CARRY4((uint)m[10] + uVar18, uVar40);
    uVar16 = uVar4 ^ uVar16;
    uVar31 = uVar48 + uVar16;
    uVar34 = uVar34 + (uVar19 ^ uVar13) + (uint)CARRY4(uVar48, uVar16);
    uVar32 = uVar34 ^ uVar32;
    uVar17 = (uVar40 ^ uVar31) >> 0x18 | uVar32 << 8;
    uVar30 = (uint)m[0xf] + uVar19 + uVar17;
    uVar12 = uVar32 >> 0x18 | (uVar40 ^ uVar31) << 8;
    uVar33 = m[0xf]._4_4_ + uVar4 + CARRY4((uint)m[0xf], uVar19) + uVar12 +
             CARRY4((uint)m[0xf] + uVar19, uVar17);
    uVar4 = uVar33 ^ uVar19 ^ uVar13;
    uVar13 = uVar6 << 1 | (uVar47 ^ uVar21) >> 0x1f;
    uVar18 = (uVar30 ^ uVar16) >> 0x10 | uVar4 << 0x10;
    uVar40 = uVar4 >> 0x10 | (uVar30 ^ uVar16) << 0x10;
    uVar32 = uVar31 + uVar18;
    uVar6 = (uVar47 ^ uVar21) << 1 | uVar6 >> 0x1f;
    uVar34 = uVar34 + uVar40 + CARRY4(uVar31, uVar18);
    uVar12 = uVar12 ^ uVar34;
    uVar19 = (uint)m[0xe] + uVar11 + uVar6;
    uVar4 = m[0xe]._4_4_ + uVar20 + CARRY4((uint)m[0xe], uVar11) + uVar13 +
            CARRY4((uint)m[0xe] + uVar11, uVar6);
    uVar40 = uVar4 ^ uVar40;
    uVar21 = uVar23 + uVar40;
    uVar9 = uVar9 + (uVar19 ^ uVar18) + (uint)CARRY4(uVar23, uVar40);
    uVar13 = uVar9 ^ uVar13;
    uVar35 = (uVar21 ^ uVar6) >> 0x18 | uVar13 << 8;
    uVar11 = (uint)m[1] + uVar19 + uVar35;
    uVar49 = uVar13 >> 0x18 | (uVar21 ^ uVar6) << 8;
    uVar13 = m[1]._4_4_ + uVar4 + CARRY4((uint)m[1], uVar19) + uVar49 +
             CARRY4((uint)m[1] + uVar19, uVar35);
    uVar4 = uVar13 ^ uVar19 ^ uVar18;
    uVar16 = (uVar11 ^ uVar40) >> 0x10 | uVar4 << 0x10;
    uVar18 = uVar4 >> 0x10 | (uVar11 ^ uVar40) << 0x10;
    uVar19 = uVar36 << 1 | (uVar23 ^ uVar24) >> 0x1f;
    uVar6 = (uVar23 ^ uVar24) << 1 | uVar36 >> 0x1f;
    uVar27 = uVar21 + uVar16;
    uVar9 = uVar9 + uVar18 + CARRY4(uVar21, uVar16);
    uVar4 = (uint)m[0xb] + uVar46 + uVar6;
    uVar31 = uVar19 + m[0xb]._4_4_ + uVar41 + CARRY4((uint)m[0xb], uVar46) +
             (uint)CARRY4((uint)m[0xb] + uVar46, uVar6);
    uVar29 = uVar31 ^ uVar29;
    uVar21 = uVar32 + uVar29;
    uVar40 = (uVar4 ^ uVar22) + uVar34 + CARRY4(uVar32, uVar29);
    uVar49 = uVar9 ^ uVar49;
    uVar19 = uVar19 ^ uVar40;
    uVar23 = (uVar21 ^ uVar6) >> 0x18 | uVar19 << 8;
    uVar36 = uVar19 >> 0x18 | (uVar21 ^ uVar6) << 8;
    uVar46 = (uint)m[0xc] + uVar4 + uVar23;
    uVar41 = m[0xc]._4_4_ + uVar31 + CARRY4((uint)m[0xc], uVar4) + uVar36 +
             CARRY4((uint)m[0xc] + uVar4, uVar23);
    uVar4 = uVar4 ^ uVar22 ^ uVar41;
    uVar34 = (uVar46 ^ uVar29) >> 0x10 | uVar4 << 0x10;
    uVar19 = uVar4 >> 0x10 | (uVar46 ^ uVar29) << 0x10;
    uVar48 = uVar21 + uVar34;
    uVar6 = uVar12 << 1 | (uVar32 ^ uVar17) >> 0x1f;
    uVar31 = (uVar32 ^ uVar17) << 1 | uVar12 >> 0x1f;
    uVar40 = uVar40 + uVar19 + CARRY4(uVar21, uVar34);
    uVar4 = (uint)m[6] + uVar15 + uVar31;
    uVar36 = uVar40 ^ uVar36;
    uVar32 = m[6]._4_4_ + uVar26 + CARRY4((uint)m[6], uVar15) + uVar6 +
             CARRY4((uint)m[6] + uVar15, uVar31);
    uVar8 = uVar32 ^ uVar8;
    uVar21 = uVar25 + uVar8;
    uVar14 = uVar14 + (uVar4 ^ uVar44) + (uint)CARRY4(uVar25, uVar8);
    uVar6 = uVar14 ^ uVar6;
    uVar15 = (uVar31 ^ uVar21) >> 0x18 | uVar6 << 8;
    uVar37 = (uint)m[8] + uVar4 + uVar15;
    uVar12 = uVar6 >> 0x18 | (uVar31 ^ uVar21) << 8;
    uVar26 = m[8]._4_4_ + uVar32 + CARRY4((uint)m[8], uVar4) + uVar12 +
             CARRY4((uint)m[8] + uVar4, uVar15);
    uVar4 = uVar26 ^ uVar4 ^ uVar44;
    uVar44 = (uVar8 ^ uVar37) >> 0x10 | uVar4 << 0x10;
    uVar32 = uVar4 >> 0x10 | (uVar8 ^ uVar37) << 0x10;
    uVar31 = uVar21 + uVar44;
    uVar17 = (uVar25 ^ uVar43) << 1 | uVar45 >> 0x1f;
    uVar8 = uVar32 + uVar14 + CARRY4(uVar21, uVar44);
    uVar24 = uVar45 << 1 | (uVar25 ^ uVar43) >> 0x1f;
    uVar6 = (uint)m[3] + uVar30 + uVar17;
    uVar21 = m[3]._4_4_ + uVar33 + (uint)CARRY4((uint)m[3], uVar30) + uVar24 +
             CARRY4((uint)m[3] + uVar30, uVar17);
    uVar12 = uVar8 ^ uVar12;
    uVar28 = uVar21 ^ uVar28;
    uVar4 = uVar47 + uVar28;
    uVar38 = uVar38 + (uVar6 ^ uVar42) + (uint)CARRY4(uVar47, uVar28);
    uVar24 = uVar38 ^ uVar24;
    uVar14 = (uVar4 ^ uVar17) >> 0x18 | uVar24 << 8;
    uVar24 = uVar24 >> 0x18 | (uVar4 ^ uVar17) << 8;
    uVar17 = (uint)m[0xd] + uVar6 + uVar14;
    uVar20 = m[0xd]._4_4_ + uVar21 + CARRY4((uint)m[0xd], uVar6) + uVar24 +
             CARRY4((uint)m[0xd] + uVar6, uVar14);
    uVar21 = uVar20 ^ uVar6 ^ uVar42;
    uVar42 = (uVar17 ^ uVar28) >> 0x10 | uVar21 << 0x10;
    uVar28 = uVar21 >> 0x10 | (uVar17 ^ uVar28) << 0x10;
    uVar6 = uVar4 + uVar42;
    uVar38 = uVar38 + uVar28 + CARRY4(uVar4, uVar42);
    uVar24 = uVar38 ^ uVar24;
    uVar25 = (uVar6 ^ uVar14) << 1 | uVar24 >> 0x1f;
    uVar22 = uVar24 << 1 | (uVar6 ^ uVar14) >> 0x1f;
    uVar4 = (uint)m[2] + uVar11 + uVar25;
    uVar24 = m[2]._4_4_ + uVar13 + (uint)CARRY4((uint)m[2], uVar11) + uVar22 +
             CARRY4((uint)m[2] + uVar11, uVar25);
    uVar19 = uVar19 ^ uVar24;
    uVar21 = uVar31 + uVar19;
    uVar14 = (uVar34 ^ uVar4) + uVar8 + CARRY4(uVar31, uVar19);
    uVar22 = uVar14 ^ uVar22;
    uVar39 = (uVar21 ^ uVar25) >> 0x18 | uVar22 << 8;
    uVar43 = uVar22 >> 0x18 | (uVar21 ^ uVar25) << 8;
    uVar11 = (uint)m[0xc] + uVar4 + uVar39;
    uVar13 = m[0xc]._4_4_ + uVar24 + CARRY4((uint)m[0xc], uVar4) + uVar43 +
             CARRY4((uint)m[0xc] + uVar4, uVar39);
    uVar4 = uVar34 ^ uVar4 ^ uVar13;
    uVar22 = (uVar19 ^ uVar11) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar19 ^ uVar11) << 0x10;
    uVar34 = (uVar27 ^ uVar35) << 1 | uVar49 >> 0x1f;
    uVar19 = uVar49 << 1 | (uVar27 ^ uVar35) >> 0x1f;
    uVar25 = uVar21 + uVar22;
    uVar14 = uVar14 + uVar29 + CARRY4(uVar21, uVar22);
    uVar4 = (uint)m[6] + uVar46 + uVar34;
    uVar8 = uVar19 + m[6]._4_4_ + uVar41 + (uint)CARRY4((uint)m[6], uVar46) +
            (uint)CARRY4((uint)m[6] + uVar46, uVar34);
    uVar32 = uVar32 ^ uVar8;
    uVar43 = uVar14 ^ uVar43;
    uVar24 = uVar6 + uVar32;
    uVar38 = (uVar4 ^ uVar44) + uVar38 + CARRY4(uVar6, uVar32);
    uVar19 = uVar19 ^ uVar38;
    uVar21 = (uVar34 ^ uVar24) >> 0x18 | uVar19 << 8;
    uVar6 = uVar19 >> 0x18 | (uVar34 ^ uVar24) << 8;
    uVar45 = (uint)m[10] + uVar4 + uVar21;
    uVar46 = m[10]._4_4_ + uVar8 + CARRY4((uint)m[10], uVar4) + uVar6 +
             CARRY4((uint)m[10] + uVar4, uVar21);
    uVar4 = uVar4 ^ uVar44 ^ uVar46;
    uVar44 = (uVar32 ^ uVar45) >> 0x10 | uVar4 << 0x10;
    uVar34 = uVar4 >> 0x10 | (uVar32 ^ uVar45) << 0x10;
    uVar8 = (uVar48 ^ uVar23) << 1 | uVar36 >> 0x1f;
    uVar41 = uVar24 + uVar44;
    uVar23 = uVar36 << 1 | (uVar48 ^ uVar23) >> 0x1f;
    uVar38 = uVar38 + uVar34 + CARRY4(uVar24, uVar44);
    uVar6 = uVar38 ^ uVar6;
    uVar4 = (uint)m[0] + uVar37 + uVar8;
    uVar32 = m[0]._4_4_ + uVar26 + CARRY4((uint)m[0], uVar37) + uVar23 +
             CARRY4((uint)m[0] + uVar37, uVar8);
    uVar28 = uVar32 ^ uVar28;
    uVar19 = uVar27 + uVar28;
    uVar9 = uVar9 + (uVar4 ^ uVar42) + (uint)CARRY4(uVar27, uVar28);
    uVar23 = uVar23 ^ uVar9;
    uVar24 = (uVar19 ^ uVar8) >> 0x18 | uVar23 << 8;
    uVar35 = uVar23 >> 0x18 | (uVar19 ^ uVar8) << 8;
    uVar27 = (uint)m[0xb] + uVar4 + uVar24;
    uVar26 = m[0xb]._4_4_ + uVar32 + CARRY4((uint)m[0xb], uVar4) + uVar35 +
             CARRY4((uint)m[0xb] + uVar4, uVar24);
    uVar4 = uVar26 ^ uVar4 ^ uVar42;
    uVar42 = (uVar27 ^ uVar28) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar27 ^ uVar28) << 0x10;
    uVar8 = uVar12 << 1 | (uVar31 ^ uVar15) >> 0x1f;
    uVar23 = uVar19 + uVar42;
    uVar32 = uVar28 + uVar9 + CARRY4(uVar19, uVar42);
    uVar12 = (uVar31 ^ uVar15) << 1 | uVar12 >> 0x1f;
    uVar35 = uVar32 ^ uVar35;
    uVar19 = (uint)m[8] + uVar17 + uVar12;
    uVar4 = m[8]._4_4_ + uVar20 + CARRY4((uint)m[8], uVar17) + uVar8 +
            CARRY4((uint)m[8] + uVar17, uVar12);
    uVar18 = uVar4 ^ uVar18;
    uVar31 = uVar48 + uVar18;
    uVar40 = uVar40 + (uVar19 ^ uVar16) + (uint)CARRY4(uVar48, uVar18);
    uVar8 = uVar40 ^ uVar8;
    uVar9 = (uVar12 ^ uVar31) >> 0x18 | uVar8 << 8;
    uVar20 = (uint)m[3] + uVar19 + uVar9;
    uVar8 = uVar8 >> 0x18 | (uVar12 ^ uVar31) << 8;
    uVar30 = m[3]._4_4_ + uVar4 + CARRY4((uint)m[3], uVar19) + uVar8 +
             CARRY4((uint)m[3] + uVar19, uVar9);
    uVar4 = uVar30 ^ uVar19 ^ uVar16;
    uVar17 = (uVar20 ^ uVar18) >> 0x10 | uVar4 << 0x10;
    uVar16 = uVar6 << 1 | (uVar41 ^ uVar21) >> 0x1f;
    uVar15 = uVar4 >> 0x10 | (uVar20 ^ uVar18) << 0x10;
    uVar6 = (uVar41 ^ uVar21) << 1 | uVar6 >> 0x1f;
    uVar12 = uVar31 + uVar17;
    uVar40 = uVar40 + uVar15 + CARRY4(uVar31, uVar17);
    uVar8 = uVar8 ^ uVar40;
    uVar19 = (uint)m[4] + uVar11 + uVar6;
    uVar4 = m[4]._4_4_ + uVar13 + (uint)CARRY4((uint)m[4], uVar11) + uVar16 +
            CARRY4((uint)m[4] + uVar11, uVar6);
    uVar15 = uVar4 ^ uVar15;
    uVar21 = uVar23 + uVar15;
    uVar32 = uVar32 + (uVar19 ^ uVar17) + (uint)CARRY4(uVar23, uVar15);
    uVar16 = uVar32 ^ uVar16;
    uVar33 = (uVar21 ^ uVar6) >> 0x18 | uVar16 << 8;
    uVar47 = uVar16 >> 0x18 | (uVar21 ^ uVar6) << 8;
    uVar11 = (uint)m[0xd] + uVar19 + uVar33;
    uVar13 = m[0xd]._4_4_ + uVar4 + CARRY4((uint)m[0xd], uVar19) + uVar47 +
             CARRY4((uint)m[0xd] + uVar19, uVar33);
    uVar4 = uVar13 ^ uVar19 ^ uVar17;
    uVar16 = (uVar11 ^ uVar15) >> 0x10 | uVar4 << 0x10;
    uVar15 = uVar4 >> 0x10 | (uVar11 ^ uVar15) << 0x10;
    uVar6 = (uVar23 ^ uVar24) << 1 | uVar35 >> 0x1f;
    uVar17 = uVar21 + uVar16;
    uVar19 = uVar35 << 1 | (uVar23 ^ uVar24) >> 0x1f;
    uVar32 = uVar32 + uVar15 + CARRY4(uVar21, uVar16);
    uVar4 = (uint)m[7] + uVar45 + uVar6;
    uVar21 = uVar19 + m[7]._4_4_ + uVar46 + CARRY4((uint)m[7], uVar45) +
             (uint)CARRY4((uint)m[7] + uVar45, uVar6);
    uVar29 = uVar21 ^ uVar29;
    uVar31 = uVar12 + uVar29;
    uVar40 = (uVar4 ^ uVar22) + uVar40 + CARRY4(uVar12, uVar29);
    uVar47 = uVar32 ^ uVar47;
    uVar19 = uVar19 ^ uVar40;
    uVar23 = (uVar31 ^ uVar6) >> 0x18 | uVar19 << 8;
    uVar35 = uVar19 >> 0x18 | (uVar31 ^ uVar6) << 8;
    uVar45 = (uint)m[5] + uVar4 + uVar23;
    uVar46 = m[5]._4_4_ + uVar21 + CARRY4((uint)m[5], uVar4) + uVar35 +
             CARRY4((uint)m[5] + uVar4, uVar23);
    uVar19 = uVar4 ^ uVar22 ^ uVar46;
    uVar4 = (uVar45 ^ uVar29) >> 0x10 | uVar19 << 0x10;
    uVar49 = uVar31 + uVar4;
    uVar21 = uVar19 >> 0x10 | (uVar45 ^ uVar29) << 0x10;
    uVar40 = uVar40 + uVar21 + CARRY4(uVar31, uVar4);
    uVar6 = uVar8 << 1 | (uVar12 ^ uVar9) >> 0x1f;
    uVar12 = (uVar12 ^ uVar9) << 1 | uVar8 >> 0x1f;
    uVar19 = (uint)m[0xf] + uVar27 + uVar12;
    uVar8 = m[0xf]._4_4_ + uVar26 + CARRY4((uint)m[0xf], uVar27) + uVar6 +
            CARRY4((uint)m[0xf] + uVar27, uVar12);
    uVar34 = uVar8 ^ uVar34;
    uVar31 = uVar25 + uVar34;
    uVar35 = uVar40 ^ uVar35;
    uVar14 = uVar14 + (uVar19 ^ uVar44) + (uint)CARRY4(uVar25, uVar34);
    uVar6 = uVar14 ^ uVar6;
    uVar18 = (uVar12 ^ uVar31) >> 0x18 | uVar6 << 8;
    uVar24 = uVar6 >> 0x18 | (uVar12 ^ uVar31) << 8;
    uVar36 = (uint)m[0xe] + uVar19 + uVar18;
    uVar29 = m[0xe]._4_4_ + uVar8 + CARRY4((uint)m[0xe], uVar19) + uVar24 +
             CARRY4((uint)m[0xe] + uVar19, uVar18);
    uVar19 = uVar29 ^ uVar19 ^ uVar44;
    uVar44 = (uVar34 ^ uVar36) >> 0x10 | uVar19 << 0x10;
    uVar6 = uVar19 >> 0x10 | (uVar34 ^ uVar36) << 0x10;
    uVar8 = uVar43 << 1 | (uVar25 ^ uVar39) >> 0x1f;
    uVar12 = uVar31 + uVar44;
    uVar27 = (uVar25 ^ uVar39) << 1 | uVar43 >> 0x1f;
    uVar9 = uVar6 + uVar14 + CARRY4(uVar31, uVar44);
    uVar24 = uVar9 ^ uVar24;
    uVar19 = (uint)m[1] + uVar20 + uVar27;
    uVar34 = m[1]._4_4_ + uVar30 + (uint)CARRY4((uint)m[1], uVar20) + uVar8 +
             CARRY4((uint)m[1] + uVar20, uVar27);
    uVar28 = uVar34 ^ uVar28;
    uVar31 = uVar41 + uVar28;
    uVar38 = uVar38 + (uVar19 ^ uVar42) + (uint)CARRY4(uVar41, uVar28);
    uVar8 = uVar38 ^ uVar8;
    uVar14 = (uVar31 ^ uVar27) >> 0x18 | uVar8 << 8;
    uVar8 = uVar8 >> 0x18 | (uVar31 ^ uVar27) << 8;
    uVar27 = (uint)m[9] + uVar19 + uVar14;
    uVar20 = m[9]._4_4_ + uVar34 + CARRY4((uint)m[9], uVar19) + uVar8 +
             CARRY4((uint)m[9] + uVar19, uVar14);
    uVar19 = uVar20 ^ uVar19 ^ uVar42;
    uVar39 = (uVar27 ^ uVar28) >> 0x10 | uVar19 << 0x10;
    uVar37 = uVar19 >> 0x10 | (uVar27 ^ uVar28) << 0x10;
    uVar34 = uVar31 + uVar39;
    uVar38 = uVar38 + uVar37 + CARRY4(uVar31, uVar39);
    uVar8 = uVar38 ^ uVar8;
    uVar22 = (uVar34 ^ uVar14) << 1 | uVar8 >> 0x1f;
    uVar14 = uVar8 << 1 | (uVar34 ^ uVar14) >> 0x1f;
    uVar19 = (uint)m[0xc] + uVar11 + uVar22;
    uVar8 = m[0xc]._4_4_ + uVar13 + CARRY4((uint)m[0xc], uVar11) + uVar14 +
            CARRY4((uint)m[0xc] + uVar11, uVar22);
    uVar21 = uVar21 ^ uVar8;
    uVar31 = uVar12 + uVar21;
    uVar11 = (uVar4 ^ uVar19) + uVar9 + CARRY4(uVar12, uVar21);
    uVar14 = uVar11 ^ uVar14;
    uVar43 = (uVar31 ^ uVar22) >> 0x18 | uVar14 << 8;
    uVar41 = uVar14 >> 0x18 | (uVar31 ^ uVar22) << 8;
    uVar13 = (uint)m[5] + uVar19 + uVar43;
    uVar22 = m[5]._4_4_ + uVar8 + CARRY4((uint)m[5], uVar19) + uVar41 +
             CARRY4((uint)m[5] + uVar19, uVar43);
    uVar4 = uVar4 ^ uVar19 ^ uVar22;
    uVar25 = (uVar21 ^ uVar13) >> 0x10 | uVar4 << 0x10;
    uVar30 = uVar4 >> 0x10 | (uVar21 ^ uVar13) << 0x10;
    uVar26 = uVar31 + uVar25;
    uVar8 = (uVar17 ^ uVar33) << 1 | uVar47 >> 0x1f;
    uVar11 = uVar11 + uVar30 + CARRY4(uVar31, uVar25);
    uVar19 = uVar47 << 1 | (uVar17 ^ uVar33) >> 0x1f;
    uVar4 = (uint)m[1] + uVar45 + uVar8;
    uVar9 = uVar19 + m[1]._4_4_ + uVar46 + CARRY4((uint)m[1], uVar45) +
            (uint)CARRY4((uint)m[1] + uVar45, uVar8);
    uVar6 = uVar6 ^ uVar9;
    uVar41 = uVar11 ^ uVar41;
    uVar31 = uVar34 + uVar6;
    uVar14 = (uVar4 ^ uVar44) + uVar38 + CARRY4(uVar34, uVar6);
    uVar19 = uVar19 ^ uVar14;
    uVar21 = (uVar8 ^ uVar31) >> 0x18 | uVar19 << 8;
    uVar34 = uVar19 >> 0x18 | (uVar8 ^ uVar31) << 8;
    uVar45 = (uint)m[0xf] + uVar4 + uVar21;
    uVar46 = m[0xf]._4_4_ + uVar9 + CARRY4((uint)m[0xf], uVar4) + uVar34 +
             CARRY4((uint)m[0xf] + uVar4, uVar21);
    uVar4 = uVar4 ^ uVar44 ^ uVar46;
    uVar44 = (uVar6 ^ uVar45) >> 0x10 | uVar4 << 0x10;
    uVar8 = uVar4 >> 0x10 | (uVar6 ^ uVar45) << 0x10;
    uVar9 = (uVar49 ^ uVar23) << 1 | uVar35 >> 0x1f;
    uVar47 = uVar31 + uVar44;
    uVar23 = uVar35 << 1 | (uVar49 ^ uVar23) >> 0x1f;
    uVar14 = uVar14 + uVar8 + CARRY4(uVar31, uVar44);
    uVar4 = (uint)m[0xe] + uVar36 + uVar9;
    uVar31 = m[0xe]._4_4_ + uVar29 + CARRY4((uint)m[0xe], uVar36) + uVar23 +
             CARRY4((uint)m[0xe] + uVar36, uVar9);
    uVar37 = uVar31 ^ uVar37;
    uVar34 = uVar14 ^ uVar34;
    uVar19 = uVar17 + uVar37;
    uVar32 = uVar32 + (uVar4 ^ uVar39) + (uint)CARRY4(uVar17, uVar37);
    uVar23 = uVar23 ^ uVar32;
    uVar6 = (uVar19 ^ uVar9) >> 0x18 | uVar23 << 8;
    uVar35 = uVar23 >> 0x18 | (uVar19 ^ uVar9) << 8;
    uVar17 = (uint)m[0xd] + uVar4 + uVar6;
    uVar42 = m[0xd]._4_4_ + uVar31 + CARRY4((uint)m[0xd], uVar4) + uVar35 +
             CARRY4((uint)m[0xd] + uVar4, uVar6);
    uVar4 = uVar42 ^ uVar4 ^ uVar39;
    uVar28 = (uVar17 ^ uVar37) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar17 ^ uVar37) << 0x10;
    uVar38 = (uVar12 ^ uVar18) << 1 | uVar24 >> 0x1f;
    uVar12 = uVar24 << 1 | (uVar12 ^ uVar18) >> 0x1f;
    uVar23 = uVar19 + uVar28;
    uVar9 = uVar29 + uVar32 + CARRY4(uVar19, uVar28);
    uVar35 = uVar9 ^ uVar35;
    uVar19 = (uint)m[4] + uVar27 + uVar38;
    uVar4 = m[4]._4_4_ + uVar20 + CARRY4((uint)m[4], uVar27) + uVar12 +
            CARRY4((uint)m[4] + uVar27, uVar38);
    uVar15 = uVar4 ^ uVar15;
    uVar31 = uVar49 + uVar15;
    uVar40 = uVar40 + (uVar19 ^ uVar16) + (uint)CARRY4(uVar49, uVar15);
    uVar12 = uVar40 ^ uVar12;
    uVar24 = (uVar38 ^ uVar31) >> 0x18 | uVar12 << 8;
    uVar12 = uVar12 >> 0x18 | (uVar38 ^ uVar31) << 8;
    uVar27 = (uint)m[10] + uVar19 + uVar24;
    uVar20 = m[10]._4_4_ + uVar4 + CARRY4((uint)m[10], uVar19) + uVar12 +
             CARRY4((uint)m[10] + uVar19, uVar24);
    uVar4 = uVar20 ^ uVar19 ^ uVar16;
    uVar16 = (uVar27 ^ uVar15) >> 0x10 | uVar4 << 0x10;
    uVar15 = uVar4 >> 0x10 | (uVar27 ^ uVar15) << 0x10;
    uVar38 = (uVar47 ^ uVar21) << 1 | uVar34 >> 0x1f;
    uVar32 = uVar31 + uVar16;
    uVar34 = uVar34 << 1 | (uVar47 ^ uVar21) >> 0x1f;
    uVar40 = uVar40 + uVar15 + CARRY4(uVar31, uVar16);
    uVar12 = uVar12 ^ uVar40;
    uVar19 = (uint)m[0] + uVar13 + uVar38;
    uVar4 = m[0]._4_4_ + uVar22 + CARRY4((uint)m[0], uVar13) + uVar34 +
            CARRY4((uint)m[0] + uVar13, uVar38);
    uVar15 = uVar4 ^ uVar15;
    uVar21 = uVar23 + uVar15;
    uVar9 = uVar9 + (uVar19 ^ uVar16) + (uint)CARRY4(uVar23, uVar15);
    uVar34 = uVar9 ^ uVar34;
    uVar33 = (uVar21 ^ uVar38) >> 0x18 | uVar34 << 8;
    uVar37 = uVar34 >> 0x18 | (uVar21 ^ uVar38) << 8;
    uVar38 = (uint)m[7] + uVar19 + uVar33;
    uVar13 = m[7]._4_4_ + uVar4 + CARRY4((uint)m[7], uVar19) + uVar37 +
             CARRY4((uint)m[7] + uVar19, uVar33);
    uVar4 = uVar13 ^ uVar19 ^ uVar16;
    uVar16 = (uVar38 ^ uVar15) >> 0x10 | uVar4 << 0x10;
    uVar15 = uVar4 >> 0x10 | (uVar38 ^ uVar15) << 0x10;
    uVar18 = uVar21 + uVar16;
    uVar19 = uVar35 << 1 | (uVar23 ^ uVar6) >> 0x1f;
    uVar6 = (uVar23 ^ uVar6) << 1 | uVar35 >> 0x1f;
    uVar9 = uVar9 + uVar15 + CARRY4(uVar21, uVar16);
    uVar4 = (uint)m[6] + uVar45 + uVar6;
    uVar31 = uVar19 + m[6]._4_4_ + uVar46 + CARRY4((uint)m[6], uVar45) +
             (uint)CARRY4((uint)m[6] + uVar45, uVar6);
    uVar30 = uVar31 ^ uVar30;
    uVar21 = uVar32 + uVar30;
    uVar40 = (uVar4 ^ uVar25) + uVar40 + CARRY4(uVar32, uVar30);
    uVar37 = uVar9 ^ uVar37;
    uVar19 = uVar19 ^ uVar40;
    uVar23 = (uVar21 ^ uVar6) >> 0x18 | uVar19 << 8;
    uVar35 = uVar19 >> 0x18 | (uVar21 ^ uVar6) << 8;
    uVar39 = (uint)m[3] + uVar4 + uVar23;
    uVar45 = m[3]._4_4_ + uVar31 + CARRY4((uint)m[3], uVar4) + uVar35 +
             CARRY4((uint)m[3] + uVar4, uVar23);
    uVar4 = uVar4 ^ uVar25 ^ uVar45;
    uVar34 = (uVar39 ^ uVar30) >> 0x10 | uVar4 << 0x10;
    uVar19 = uVar4 >> 0x10 | (uVar39 ^ uVar30) << 0x10;
    uVar46 = uVar21 + uVar34;
    uVar6 = uVar12 << 1 | (uVar32 ^ uVar24) >> 0x1f;
    uVar31 = (uVar32 ^ uVar24) << 1 | uVar12 >> 0x1f;
    uVar40 = uVar40 + uVar19 + CARRY4(uVar21, uVar34);
    uVar35 = uVar40 ^ uVar35;
    uVar4 = (uint)m[9] + uVar17 + uVar31;
    uVar21 = m[9]._4_4_ + uVar42 + CARRY4((uint)m[9], uVar17) + uVar6 +
             CARRY4((uint)m[9] + uVar17, uVar31);
    uVar8 = uVar21 ^ uVar8;
    uVar22 = uVar26 + uVar8;
    uVar11 = uVar11 + (uVar4 ^ uVar44) + (uint)CARRY4(uVar26, uVar8);
    uVar6 = uVar11 ^ uVar6;
    uVar17 = (uVar31 ^ uVar22) >> 0x18 | uVar6 << 8;
    uVar30 = (uint)m[2] + uVar4 + uVar17;
    uVar12 = uVar6 >> 0x18 | (uVar31 ^ uVar22) << 8;
    uVar42 = m[2]._4_4_ + uVar21 + CARRY4((uint)m[2], uVar4) + uVar12 +
             CARRY4((uint)m[2] + uVar4, uVar17);
    uVar4 = uVar42 ^ uVar4 ^ uVar44;
    uVar44 = (uVar8 ^ uVar30) >> 0x10 | uVar4 << 0x10;
    uVar32 = uVar4 >> 0x10 | (uVar8 ^ uVar30) << 0x10;
    uVar24 = uVar41 << 1 | (uVar26 ^ uVar43) >> 0x1f;
    uVar25 = (uVar26 ^ uVar43) << 1 | uVar41 >> 0x1f;
    uVar31 = uVar22 + uVar44;
    uVar8 = uVar32 + uVar11 + CARRY4(uVar22, uVar44);
    uVar12 = uVar8 ^ uVar12;
    uVar4 = (uint)m[8] + uVar27 + uVar25;
    uVar6 = m[8]._4_4_ + uVar20 + (uint)CARRY4((uint)m[8], uVar27) + uVar24 +
            CARRY4((uint)m[8] + uVar27, uVar25);
    uVar29 = uVar6 ^ uVar29;
    uVar21 = uVar47 + uVar29;
    uVar14 = uVar14 + (uVar4 ^ uVar28) + (uint)CARRY4(uVar47, uVar29);
    uVar24 = uVar14 ^ uVar24;
    uVar11 = (uVar21 ^ uVar25) >> 0x18 | uVar24 << 8;
    uVar24 = uVar24 >> 0x18 | (uVar21 ^ uVar25) << 8;
    uVar27 = (uint)m[0xb] + uVar4 + uVar11;
    uVar20 = m[0xb]._4_4_ + uVar6 + CARRY4((uint)m[0xb], uVar4) + uVar24 +
             CARRY4((uint)m[0xb] + uVar4, uVar11);
    uVar4 = uVar20 ^ uVar4 ^ uVar28;
    uVar36 = (uVar27 ^ uVar29) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar27 ^ uVar29) << 0x10;
    uVar6 = uVar21 + uVar36;
    uVar14 = uVar14 + uVar28 + CARRY4(uVar21, uVar36);
    uVar24 = uVar14 ^ uVar24;
    uVar25 = (uVar6 ^ uVar11) << 1 | uVar24 >> 0x1f;
    uVar22 = uVar24 << 1 | (uVar6 ^ uVar11) >> 0x1f;
    uVar4 = (uint)m[0xd] + uVar38 + uVar25;
    uVar24 = m[0xd]._4_4_ + uVar13 + CARRY4((uint)m[0xd], uVar38) + uVar22 +
             CARRY4((uint)m[0xd] + uVar38, uVar25);
    uVar19 = uVar19 ^ uVar24;
    uVar21 = uVar31 + uVar19;
    uVar11 = (uVar34 ^ uVar4) + uVar8 + CARRY4(uVar31, uVar19);
    uVar22 = uVar11 ^ uVar22;
    uVar43 = (uVar21 ^ uVar25) >> 0x18 | uVar22 << 8;
    uVar41 = uVar22 >> 0x18 | (uVar21 ^ uVar25) << 8;
    uVar13 = (uint)m[0xb] + uVar4 + uVar43;
    uVar22 = m[0xb]._4_4_ + uVar24 + CARRY4((uint)m[0xb], uVar4) + uVar41 +
             CARRY4((uint)m[0xb] + uVar4, uVar43);
    uVar4 = uVar34 ^ uVar4 ^ uVar22;
    uVar25 = (uVar19 ^ uVar13) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar19 ^ uVar13) << 0x10;
    uVar34 = (uVar18 ^ uVar33) << 1 | uVar37 >> 0x1f;
    uVar19 = uVar37 << 1 | (uVar18 ^ uVar33) >> 0x1f;
    uVar26 = uVar21 + uVar25;
    uVar11 = uVar11 + uVar29 + CARRY4(uVar21, uVar25);
    uVar4 = (uint)m[7] + uVar39 + uVar34;
    uVar8 = uVar19 + m[7]._4_4_ + uVar45 + CARRY4((uint)m[7], uVar39) +
            (uint)CARRY4((uint)m[7] + uVar39, uVar34);
    uVar41 = uVar11 ^ uVar41;
    uVar32 = uVar32 ^ uVar8;
    uVar24 = uVar6 + uVar32;
    uVar38 = (uVar4 ^ uVar44) + uVar14 + CARRY4(uVar6, uVar32);
    uVar19 = uVar19 ^ uVar38;
    uVar21 = (uVar34 ^ uVar24) >> 0x18 | uVar19 << 8;
    uVar34 = uVar19 >> 0x18 | (uVar34 ^ uVar24) << 8;
    uVar37 = (uint)m[0xe] + uVar4 + uVar21;
    uVar39 = m[0xe]._4_4_ + uVar8 + CARRY4((uint)m[0xe], uVar4) + uVar34 +
             CARRY4((uint)m[0xe] + uVar4, uVar21);
    uVar4 = uVar4 ^ uVar44 ^ uVar39;
    uVar44 = (uVar32 ^ uVar37) >> 0x10 | uVar4 << 0x10;
    uVar8 = uVar4 >> 0x10 | (uVar32 ^ uVar37) << 0x10;
    uVar14 = (uVar46 ^ uVar23) << 1 | uVar35 >> 0x1f;
    uVar45 = uVar24 + uVar44;
    uVar23 = uVar35 << 1 | (uVar46 ^ uVar23) >> 0x1f;
    uVar38 = uVar38 + uVar8 + CARRY4(uVar24, uVar44);
    uVar34 = uVar38 ^ uVar34;
    uVar4 = (uint)m[0xc] + uVar30 + uVar14;
    uVar6 = m[0xc]._4_4_ + uVar42 + CARRY4((uint)m[0xc], uVar30) + uVar23 +
            CARRY4((uint)m[0xc] + uVar30, uVar14);
    uVar28 = uVar6 ^ uVar28;
    uVar19 = uVar18 + uVar28;
    uVar9 = uVar9 + (uVar4 ^ uVar36) + (uint)CARRY4(uVar18, uVar28);
    uVar23 = uVar23 ^ uVar9;
    uVar32 = (uVar19 ^ uVar14) >> 0x18 | uVar23 << 8;
    uVar30 = uVar23 >> 0x18 | (uVar19 ^ uVar14) << 8;
    uVar14 = (uint)m[1] + uVar4 + uVar32;
    uVar18 = m[1]._4_4_ + uVar6 + CARRY4((uint)m[1], uVar4) + uVar30 +
             CARRY4((uint)m[1] + uVar4, uVar32);
    uVar4 = uVar18 ^ uVar4 ^ uVar36;
    uVar42 = (uVar14 ^ uVar28) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar14 ^ uVar28) << 0x10;
    uVar24 = (uVar31 ^ uVar17) << 1 | uVar12 >> 0x1f;
    uVar12 = uVar12 << 1 | (uVar31 ^ uVar17) >> 0x1f;
    uVar23 = uVar19 + uVar42;
    uVar6 = uVar28 + uVar9 + (uint)CARRY4(uVar19, uVar42);
    uVar30 = uVar6 ^ uVar30;
    uVar19 = (uint)m[3] + uVar27 + uVar24;
    uVar4 = m[3]._4_4_ + uVar20 + (uint)CARRY4((uint)m[3], uVar27) + uVar12 +
            CARRY4((uint)m[3] + uVar27, uVar24);
    uVar15 = uVar4 ^ uVar15;
    uVar31 = uVar46 + uVar15;
    uVar40 = uVar40 + (uVar19 ^ uVar16) + (uint)CARRY4(uVar46, uVar15);
    uVar12 = uVar40 ^ uVar12;
    uVar17 = (uVar24 ^ uVar31) >> 0x18 | uVar12 << 8;
    uVar33 = (uint)m[9] + uVar19 + uVar17;
    uVar24 = uVar12 >> 0x18 | (uVar24 ^ uVar31) << 8;
    uVar35 = m[9]._4_4_ + uVar4 + CARRY4((uint)m[9], uVar19) + uVar24 +
             CARRY4((uint)m[9] + uVar19, uVar17);
    uVar4 = uVar35 ^ uVar19 ^ uVar16;
    uVar16 = uVar34 << 1 | (uVar45 ^ uVar21) >> 0x1f;
    uVar27 = (uVar33 ^ uVar15) >> 0x10 | uVar4 << 0x10;
    uVar9 = uVar4 >> 0x10 | (uVar33 ^ uVar15) << 0x10;
    uVar12 = uVar31 + uVar27;
    uVar40 = uVar40 + uVar9 + CARRY4(uVar31, uVar27);
    uVar31 = (uVar45 ^ uVar21) << 1 | uVar34 >> 0x1f;
    uVar24 = uVar24 ^ uVar40;
    uVar19 = (uint)m[5] + uVar13 + uVar31;
    uVar4 = m[5]._4_4_ + uVar22 + (uint)CARRY4((uint)m[5], uVar13) + uVar16 +
            CARRY4((uint)m[5] + uVar13, uVar31);
    uVar9 = uVar4 ^ uVar9;
    uVar21 = uVar23 + uVar9;
    uVar6 = uVar6 + (uVar19 ^ uVar27) + (uint)CARRY4(uVar23, uVar9);
    uVar16 = uVar6 ^ uVar16;
    uVar36 = (uVar21 ^ uVar31) >> 0x18 | uVar16 << 8;
    uVar46 = uVar16 >> 0x18 | (uVar21 ^ uVar31) << 8;
    uVar13 = (uint)m[0] + uVar19 + uVar36;
    uVar16 = m[0]._4_4_ + uVar4 + CARRY4((uint)m[0], uVar19) + uVar46 +
             CARRY4((uint)m[0] + uVar19, uVar36);
    uVar4 = uVar16 ^ uVar19 ^ uVar27;
    uVar15 = (uVar13 ^ uVar9) >> 0x10 | uVar4 << 0x10;
    uVar27 = uVar4 >> 0x10 | (uVar13 ^ uVar9) << 0x10;
    uVar20 = uVar21 + uVar15;
    uVar19 = uVar30 << 1 | (uVar23 ^ uVar32) >> 0x1f;
    uVar31 = (uVar23 ^ uVar32) << 1 | uVar30 >> 0x1f;
    uVar6 = uVar6 + uVar27 + CARRY4(uVar21, uVar15);
    uVar4 = (uint)m[0xf] + uVar37 + uVar31;
    uVar21 = uVar19 + m[0xf]._4_4_ + uVar39 +
             (uint)CARRY4((uint)m[0xf], uVar37) +
             (uint)CARRY4((uint)m[0xf] + uVar37, uVar31);
    uVar29 = uVar21 ^ uVar29;
    uVar23 = uVar12 + uVar29;
    uVar40 = (uVar4 ^ uVar25) + uVar40 + CARRY4(uVar12, uVar29);
    uVar46 = uVar6 ^ uVar46;
    uVar19 = uVar19 ^ uVar40;
    uVar32 = (uVar23 ^ uVar31) >> 0x18 | uVar19 << 8;
    uVar37 = uVar19 >> 0x18 | (uVar23 ^ uVar31) << 8;
    uVar47 = (uint)m[4] + uVar4 + uVar32;
    uVar49 = m[4]._4_4_ + uVar21 + CARRY4((uint)m[4], uVar4) + uVar37 +
             CARRY4((uint)m[4] + uVar4, uVar32);
    uVar4 = uVar4 ^ uVar25 ^ uVar49;
    uVar21 = uVar4 >> 0x10 | (uVar47 ^ uVar29) << 0x10;
    uVar9 = (uVar47 ^ uVar29) >> 0x10 | uVar4 << 0x10;
    uVar48 = uVar23 + uVar9;
    uVar31 = uVar24 << 1 | (uVar12 ^ uVar17) >> 0x1f;
    uVar40 = uVar40 + uVar21 + CARRY4(uVar23, uVar9);
    uVar19 = (uVar12 ^ uVar17) << 1 | uVar24 >> 0x1f;
    uVar37 = uVar40 ^ uVar37;
    uVar4 = (uint)m[8] + uVar14 + uVar19;
    uVar23 = m[8]._4_4_ + uVar18 + CARRY4((uint)m[8], uVar14) + uVar31 +
             CARRY4((uint)m[8] + uVar14, uVar19);
    uVar8 = uVar23 ^ uVar8;
    uVar34 = uVar26 + uVar8;
    uVar11 = uVar11 + (uVar4 ^ uVar44) + (uint)CARRY4(uVar26, uVar8);
    uVar31 = uVar11 ^ uVar31;
    uVar17 = (uVar19 ^ uVar34) >> 0x18 | uVar31 << 8;
    uVar24 = uVar31 >> 0x18 | (uVar19 ^ uVar34) << 8;
    uVar39 = (uint)m[6] + uVar4 + uVar17;
    uVar30 = m[6]._4_4_ + uVar23 + CARRY4((uint)m[6], uVar4) + uVar24 +
             CARRY4((uint)m[6] + uVar4, uVar17);
    uVar4 = uVar30 ^ uVar4 ^ uVar44;
    uVar44 = (uVar8 ^ uVar39) >> 0x10 | uVar4 << 0x10;
    uVar12 = uVar4 >> 0x10 | (uVar8 ^ uVar39) << 0x10;
    uVar19 = uVar34 + uVar44;
    uVar18 = (uVar26 ^ uVar43) << 1 | uVar41 >> 0x1f;
    uVar8 = uVar12 + uVar11 + CARRY4(uVar34, uVar44);
    uVar34 = uVar41 << 1 | (uVar26 ^ uVar43) >> 0x1f;
    uVar31 = (uint)m[2] + uVar33 + uVar18;
    uVar23 = m[2]._4_4_ + uVar35 + CARRY4((uint)m[2], uVar33) + uVar34 +
             CARRY4((uint)m[2] + uVar33, uVar18);
    uVar24 = uVar8 ^ uVar24;
    uVar28 = uVar23 ^ uVar28;
    uVar4 = uVar45 + uVar28;
    uVar38 = uVar38 + (uVar31 ^ uVar42) + (uint)CARRY4(uVar45, uVar28);
    uVar34 = uVar38 ^ uVar34;
    uVar14 = (uVar4 ^ uVar18) >> 0x18 | uVar34 << 8;
    uVar22 = uVar34 >> 0x18 | (uVar4 ^ uVar18) << 8;
    uVar11 = (uint)m[10] + uVar31 + uVar14;
    uVar18 = m[10]._4_4_ + uVar23 + CARRY4((uint)m[10], uVar31) + uVar22 +
             CARRY4((uint)m[10] + uVar31, uVar14);
    uVar23 = uVar18 ^ uVar31 ^ uVar42;
    uVar42 = (uVar11 ^ uVar28) >> 0x10 | uVar23 << 0x10;
    uVar28 = uVar23 >> 0x10 | (uVar11 ^ uVar28) << 0x10;
    uVar34 = uVar4 + uVar42;
    uVar38 = uVar38 + uVar28 + CARRY4(uVar4, uVar42);
    uVar22 = uVar38 ^ uVar22;
    uVar25 = (uVar34 ^ uVar14) << 1 | uVar22 >> 0x1f;
    uVar22 = uVar22 << 1 | (uVar34 ^ uVar14) >> 0x1f;
    uVar4 = (uint)m[6] + uVar13 + uVar25;
    uVar23 = m[6]._4_4_ + uVar16 + (uint)CARRY4((uint)m[6], uVar13) + uVar22 +
             CARRY4((uint)m[6] + uVar13, uVar25);
    uVar21 = uVar21 ^ uVar23;
    uVar31 = uVar19 + uVar21;
    uVar14 = (uVar9 ^ uVar4) + uVar8 + CARRY4(uVar19, uVar21);
    uVar22 = uVar14 ^ uVar22;
    uVar43 = (uVar31 ^ uVar25) >> 0x18 | uVar22 << 8;
    uVar45 = uVar22 >> 0x18 | (uVar31 ^ uVar25) << 8;
    uVar13 = (uint)m[0xf] + uVar4 + uVar43;
    uVar16 = m[0xf]._4_4_ + uVar23 + CARRY4((uint)m[0xf], uVar4) + uVar45 +
             CARRY4((uint)m[0xf] + uVar4, uVar43);
    uVar4 = uVar9 ^ uVar4 ^ uVar16;
    uVar22 = (uVar21 ^ uVar13) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar21 ^ uVar13) << 0x10;
    uVar25 = uVar31 + uVar22;
    uVar8 = (uVar20 ^ uVar36) << 1 | uVar46 >> 0x1f;
    uVar23 = uVar46 << 1 | (uVar20 ^ uVar36) >> 0x1f;
    uVar14 = uVar14 + uVar29 + CARRY4(uVar31, uVar22);
    uVar4 = (uint)m[0xe] + uVar47 + uVar8;
    uVar9 = uVar23 + m[0xe]._4_4_ + uVar49 +
            (uint)CARRY4((uint)m[0xe], uVar47) +
            (uint)CARRY4((uint)m[0xe] + uVar47, uVar8);
    uVar12 = uVar9 ^ uVar12;
    uVar45 = uVar14 ^ uVar45;
    uVar26 = uVar34 + uVar12;
    uVar21 = (uVar4 ^ uVar44) + uVar38 + CARRY4(uVar34, uVar12);
    uVar23 = uVar23 ^ uVar21;
    uVar31 = (uVar8 ^ uVar26) >> 0x18 | uVar23 << 8;
    uVar34 = uVar23 >> 0x18 | (uVar8 ^ uVar26) << 8;
    uVar46 = (uint)m[9] + uVar4 + uVar31;
    uVar41 = m[9]._4_4_ + uVar9 + CARRY4((uint)m[9], uVar4) + uVar34 +
             CARRY4((uint)m[9] + uVar4, uVar31);
    uVar4 = uVar4 ^ uVar44 ^ uVar41;
    uVar44 = (uVar12 ^ uVar46) >> 0x10 | uVar4 << 0x10;
    uVar9 = uVar4 >> 0x10 | (uVar12 ^ uVar46) << 0x10;
    uVar47 = uVar26 + uVar44;
    uVar38 = (uVar48 ^ uVar32) << 1 | uVar37 >> 0x1f;
    uVar32 = uVar37 << 1 | (uVar48 ^ uVar32) >> 0x1f;
    uVar21 = uVar21 + uVar9 + CARRY4(uVar26, uVar44);
    uVar34 = uVar21 ^ uVar34;
    uVar4 = (uint)m[0xb] + uVar39 + uVar38;
    uVar12 = m[0xb]._4_4_ + uVar30 + CARRY4((uint)m[0xb], uVar39) + uVar32 +
             CARRY4((uint)m[0xb] + uVar39, uVar38);
    uVar28 = uVar12 ^ uVar28;
    uVar23 = uVar20 + uVar28;
    uVar6 = uVar6 + (uVar4 ^ uVar42) + (uint)CARRY4(uVar20, uVar28);
    uVar32 = uVar32 ^ uVar6;
    uVar8 = (uVar23 ^ uVar38) >> 0x18 | uVar32 << 8;
    uVar36 = uVar32 >> 0x18 | (uVar23 ^ uVar38) << 8;
    uVar20 = (uint)m[3] + uVar4 + uVar8;
    uVar26 = m[3]._4_4_ + uVar12 + CARRY4((uint)m[3], uVar4) + uVar36 +
             CARRY4((uint)m[3] + uVar4, uVar8);
    uVar4 = uVar26 ^ uVar4 ^ uVar42;
    uVar42 = (uVar20 ^ uVar28) >> 0x10 | uVar4 << 0x10;
    uVar28 = uVar4 >> 0x10 | (uVar20 ^ uVar28) << 0x10;
    uVar12 = (uVar19 ^ uVar17) << 1 | uVar24 >> 0x1f;
    uVar38 = uVar24 << 1 | (uVar19 ^ uVar17) >> 0x1f;
    uVar32 = uVar23 + uVar42;
    uVar24 = uVar28 + uVar6 + CARRY4(uVar23, uVar42);
    uVar19 = (uint)m[0] + uVar11 + uVar12;
    uVar4 = m[0]._4_4_ + uVar18 + CARRY4((uint)m[0], uVar11) + uVar38 +
            CARRY4((uint)m[0] + uVar11, uVar12);
    uVar27 = uVar4 ^ uVar27;
    uVar36 = uVar24 ^ uVar36;
    uVar23 = uVar48 + uVar27;
    uVar40 = uVar40 + (uVar19 ^ uVar15) + (uint)CARRY4(uVar48, uVar27);
    uVar38 = uVar40 ^ uVar38;
    uVar11 = (uVar12 ^ uVar23) >> 0x18 | uVar38 << 8;
    uVar30 = (uint)m[8] + uVar19 + uVar11;
    uVar6 = uVar38 >> 0x18 | (uVar12 ^ uVar23) << 8;
    uVar33 = m[8]._4_4_ + uVar4 + CARRY4((uint)m[8], uVar19) + uVar6 +
             CARRY4((uint)m[8] + uVar19, uVar11);
    uVar4 = uVar33 ^ uVar19 ^ uVar15;
    uVar17 = (uVar30 ^ uVar27) >> 0x10 | uVar4 << 0x10;
    uVar15 = uVar34 << 1 | (uVar47 ^ uVar31) >> 0x1f;
    uVar38 = uVar4 >> 0x10 | (uVar30 ^ uVar27) << 0x10;
    uVar31 = (uVar47 ^ uVar31) << 1 | uVar34 >> 0x1f;
    uVar12 = uVar23 + uVar17;
    uVar40 = uVar40 + uVar38 + CARRY4(uVar23, uVar17);
    uVar6 = uVar6 ^ uVar40;
    uVar19 = (uint)m[0xc] + uVar13 + uVar31;
    uVar4 = m[0xc]._4_4_ + uVar16 + CARRY4((uint)m[0xc], uVar13) + uVar15 +
            CARRY4((uint)m[0xc] + uVar13, uVar31);
    uVar38 = uVar4 ^ uVar38;
    uVar23 = uVar32 + uVar38;
    uVar24 = uVar24 + (uVar19 ^ uVar17) + (uint)CARRY4(uVar32, uVar38);
    uVar15 = uVar24 ^ uVar15;
    uVar35 = (uVar23 ^ uVar31) >> 0x18 | uVar15 << 8;
    uVar13 = (uint)m[2] + uVar19 + uVar35;
    uVar49 = uVar15 >> 0x18 | (uVar23 ^ uVar31) << 8;
    uVar16 = m[2]._4_4_ + uVar4 + CARRY4((uint)m[2], uVar19) + uVar49 +
             CARRY4((uint)m[2] + uVar19, uVar35);
    uVar4 = uVar16 ^ uVar19 ^ uVar17;
    uVar15 = (uVar13 ^ uVar38) >> 0x10 | uVar4 << 0x10;
    uVar17 = uVar4 >> 0x10 | (uVar13 ^ uVar38) << 0x10;
    uVar19 = uVar36 << 1 | (uVar32 ^ uVar8) >> 0x1f;
    uVar34 = (uVar32 ^ uVar8) << 1 | uVar36 >> 0x1f;
    uVar18 = uVar23 + uVar15;
    uVar24 = uVar24 + uVar17 + CARRY4(uVar23, uVar15);
    uVar4 = (uint)m[0xd] + uVar46 + uVar34;
    uVar23 = uVar19 + m[0xd]._4_4_ + uVar41 +
             (uint)CARRY4((uint)m[0xd], uVar46) +
             (uint)CARRY4((uint)m[0xd] + uVar46, uVar34);
    uVar29 = uVar23 ^ uVar29;
    uVar32 = uVar12 + uVar29;
    uVar38 = (uVar4 ^ uVar22) + uVar40 + CARRY4(uVar12, uVar29);
    uVar49 = uVar24 ^ uVar49;
    uVar19 = uVar19 ^ uVar38;
    uVar31 = (uVar32 ^ uVar34) >> 0x18 | uVar19 << 8;
    uVar36 = uVar19 >> 0x18 | (uVar32 ^ uVar34) << 8;
    uVar46 = (uint)m[7] + uVar4 + uVar31;
    uVar41 = m[7]._4_4_ + uVar23 + CARRY4((uint)m[7], uVar4) + uVar36 +
             CARRY4((uint)m[7] + uVar4, uVar31);
    uVar19 = uVar4 ^ uVar22 ^ uVar41;
    uVar4 = (uVar46 ^ uVar29) >> 0x10 | uVar19 << 0x10;
    uVar23 = uVar19 >> 0x10 | (uVar46 ^ uVar29) << 0x10;
    uVar48 = uVar32 + uVar4;
    uVar34 = uVar6 << 1 | (uVar12 ^ uVar11) >> 0x1f;
    uVar38 = uVar38 + uVar23 + CARRY4(uVar32, uVar4);
    uVar12 = (uVar12 ^ uVar11) << 1 | uVar6 >> 0x1f;
    uVar36 = uVar38 ^ uVar36;
    uVar19 = (uint)m[1] + uVar20 + uVar12;
    uVar6 = m[1]._4_4_ + uVar26 + CARRY4((uint)m[1], uVar20) + uVar34 +
            CARRY4((uint)m[1] + uVar20, uVar12);
    uVar9 = uVar6 ^ uVar9;
    uVar32 = uVar25 + uVar9;
    uVar14 = uVar14 + (uVar19 ^ uVar44) + (uint)CARRY4(uVar25, uVar9);
    uVar34 = uVar14 ^ uVar34;
    uVar27 = (uVar12 ^ uVar32) >> 0x18 | uVar34 << 8;
    uVar34 = uVar34 >> 0x18 | (uVar12 ^ uVar32) << 8;
    uVar37 = (uint)m[4] + uVar19 + uVar27;
    uVar29 = m[4]._4_4_ + uVar6 + CARRY4((uint)m[4], uVar19) + uVar34 +
             CARRY4((uint)m[4] + uVar19, uVar27);
    uVar19 = uVar29 ^ uVar19 ^ uVar44;
    uVar44 = (uVar9 ^ uVar37) >> 0x10 | uVar19 << 0x10;
    uVar6 = uVar19 >> 0x10 | (uVar9 ^ uVar37) << 0x10;
    uVar11 = (uVar25 ^ uVar43) << 1 | uVar45 >> 0x1f;
    uVar40 = uVar45 << 1 | (uVar25 ^ uVar43) >> 0x1f;
    uVar12 = uVar32 + uVar44;
    uVar9 = uVar6 + uVar14 + CARRY4(uVar32, uVar44);
    uVar19 = (uint)m[10] + uVar30 + uVar11;
    uVar8 = m[10]._4_4_ + uVar33 + CARRY4((uint)m[10], uVar30) + uVar40 +
            CARRY4((uint)m[10] + uVar30, uVar11);
    uVar34 = uVar9 ^ uVar34;
    uVar28 = uVar8 ^ uVar28;
    uVar32 = uVar47 + uVar28;
    uVar21 = uVar21 + (uVar19 ^ uVar42) + (uint)CARRY4(uVar47, uVar28);
    uVar40 = uVar21 ^ uVar40;
    uVar14 = (uVar32 ^ uVar11) >> 0x18 | uVar40 << 8;
    uVar40 = uVar40 >> 0x18 | (uVar32 ^ uVar11) << 8;
    uVar20 = (uint)m[5] + uVar19 + uVar14;
    uVar22 = m[5]._4_4_ + uVar8 + CARRY4((uint)m[5], uVar19) + uVar40 +
             CARRY4((uint)m[5] + uVar19, uVar14);
    uVar19 = uVar22 ^ uVar19 ^ uVar42;
    uVar39 = (uVar20 ^ uVar28) >> 0x10 | uVar19 << 0x10;
    uVar33 = uVar19 >> 0x10 | (uVar20 ^ uVar28) << 0x10;
    uVar8 = uVar32 + uVar39;
    uVar21 = uVar21 + uVar33 + CARRY4(uVar32, uVar39);
    uVar40 = uVar21 ^ uVar40;
    uVar11 = (uVar8 ^ uVar14) << 1 | uVar40 >> 0x1f;
    uVar14 = uVar40 << 1 | (uVar8 ^ uVar14) >> 0x1f;
    uVar19 = (uint)m[10] + uVar13 + uVar11;
    uVar40 = m[10]._4_4_ + uVar16 + CARRY4((uint)m[10], uVar13) + uVar14 +
             CARRY4((uint)m[10] + uVar13, uVar11);
    uVar23 = uVar23 ^ uVar40;
    uVar32 = uVar12 + uVar23;
    uVar13 = (uVar4 ^ uVar19) + uVar9 + CARRY4(uVar12, uVar23);
    uVar14 = uVar13 ^ uVar14;
    uVar43 = (uVar32 ^ uVar11) >> 0x18 | uVar14 << 8;
    uVar45 = uVar14 >> 0x18 | (uVar32 ^ uVar11) << 8;
    uVar9 = (uint)m[2] + uVar19 + uVar43;
    uVar16 = m[2]._4_4_ + uVar40 + CARRY4((uint)m[2], uVar19) + uVar45 +
             CARRY4((uint)m[2] + uVar19, uVar43);
    uVar4 = uVar4 ^ uVar19 ^ uVar16;
    uVar25 = (uVar23 ^ uVar9) >> 0x10 | uVar4 << 0x10;
    uVar30 = uVar4 >> 0x10 | (uVar23 ^ uVar9) << 0x10;
    uVar26 = uVar32 + uVar25;
    uVar40 = (uVar18 ^ uVar35) << 1 | uVar49 >> 0x1f;
    uVar13 = uVar13 + uVar30 + CARRY4(uVar32, uVar25);
    uVar19 = uVar49 << 1 | (uVar18 ^ uVar35) >> 0x1f;
    uVar4 = (uint)m[8] + uVar46 + uVar40;
    uVar14 = uVar19 + m[8]._4_4_ + uVar41 + (uint)CARRY4((uint)m[8], uVar46) +
             (uint)CARRY4((uint)m[8] + uVar46, uVar40);
    uVar45 = uVar13 ^ uVar45;
    uVar6 = uVar14 ^ uVar6;
    uVar23 = uVar8 + uVar6;
    uVar11 = (uVar4 ^ uVar44) + uVar21 + CARRY4(uVar8, uVar6);
    uVar19 = uVar19 ^ uVar11;
    uVar21 = (uVar40 ^ uVar23) >> 0x18 | uVar19 << 8;
    uVar32 = uVar19 >> 0x18 | (uVar40 ^ uVar23) << 8;
    uVar46 = (uint)m[4] + uVar4 + uVar21;
    uVar41 = m[4]._4_4_ + uVar14 + CARRY4((uint)m[4], uVar4) + uVar32 +
             CARRY4((uint)m[4] + uVar4, uVar21);
    uVar4 = uVar4 ^ uVar44 ^ uVar41;
    uVar44 = (uVar6 ^ uVar46) >> 0x10 | uVar4 << 0x10;
    uVar8 = uVar4 >> 0x10 | (uVar6 ^ uVar46) << 0x10;
    uVar40 = (uVar48 ^ uVar31) << 1 | uVar36 >> 0x1f;
    uVar47 = uVar23 + uVar44;
    uVar31 = uVar36 << 1 | (uVar48 ^ uVar31) >> 0x1f;
    uVar11 = uVar11 + uVar8 + CARRY4(uVar23, uVar44);
    uVar32 = uVar11 ^ uVar32;
    uVar4 = (uint)m[7] + uVar37 + uVar40;
    uVar23 = m[7]._4_4_ + uVar29 + CARRY4((uint)m[7], uVar37) + uVar31 +
             CARRY4((uint)m[7] + uVar37, uVar40);
    uVar33 = uVar23 ^ uVar33;
    uVar19 = uVar18 + uVar33;
    uVar24 = uVar24 + (uVar4 ^ uVar39) + (uint)CARRY4(uVar18, uVar33);
    uVar31 = uVar31 ^ uVar24;
    uVar6 = (uVar19 ^ uVar40) >> 0x18 | uVar31 << 8;
    uVar35 = uVar31 >> 0x18 | (uVar19 ^ uVar40) << 8;
    uVar18 = (uint)m[6] + uVar4 + uVar6;
    uVar42 = m[6]._4_4_ + uVar23 + CARRY4((uint)m[6], uVar4) + uVar35 +
             CARRY4((uint)m[6] + uVar4, uVar6);
    uVar4 = uVar42 ^ uVar4 ^ uVar39;
    uVar28 = (uVar18 ^ uVar33) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar18 ^ uVar33) << 0x10;
    uVar40 = (uVar12 ^ uVar27) << 1 | uVar34 >> 0x1f;
    uVar12 = uVar34 << 1 | (uVar12 ^ uVar27) >> 0x1f;
    uVar23 = uVar19 + uVar28;
    uVar14 = uVar29 + uVar24 + CARRY4(uVar19, uVar28);
    uVar35 = uVar14 ^ uVar35;
    uVar19 = (uint)m[1] + uVar20 + uVar40;
    uVar4 = m[1]._4_4_ + uVar22 + (uint)CARRY4((uint)m[1], uVar20) + uVar12 +
            CARRY4((uint)m[1] + uVar20, uVar40);
    uVar17 = uVar4 ^ uVar17;
    uVar31 = uVar48 + uVar17;
    uVar38 = uVar38 + (uVar19 ^ uVar15) + (uint)CARRY4(uVar48, uVar17);
    uVar12 = uVar38 ^ uVar12;
    uVar24 = (uVar40 ^ uVar31) >> 0x18 | uVar12 << 8;
    uVar20 = (uint)m[5] + uVar19 + uVar24;
    uVar12 = uVar12 >> 0x18 | (uVar40 ^ uVar31) << 8;
    uVar22 = m[5]._4_4_ + uVar4 + CARRY4((uint)m[5], uVar19) + uVar12 +
             CARRY4((uint)m[5] + uVar19, uVar24);
    uVar4 = uVar22 ^ uVar19 ^ uVar15;
    uVar27 = (uVar20 ^ uVar17) >> 0x10 | uVar4 << 0x10;
    uVar15 = uVar32 << 1 | (uVar47 ^ uVar21) >> 0x1f;
    uVar34 = uVar4 >> 0x10 | (uVar20 ^ uVar17) << 0x10;
    uVar32 = (uVar47 ^ uVar21) << 1 | uVar32 >> 0x1f;
    uVar21 = uVar31 + uVar27;
    uVar38 = uVar38 + uVar34 + CARRY4(uVar31, uVar27);
    uVar12 = uVar12 ^ uVar38;
    uVar19 = (uint)m[0xf] + uVar9 + uVar32;
    uVar4 = m[0xf]._4_4_ + uVar16 + (uint)CARRY4((uint)m[0xf], uVar9) + uVar15 +
            CARRY4((uint)m[0xf] + uVar9, uVar32);
    uVar34 = uVar4 ^ uVar34;
    uVar31 = uVar23 + uVar34;
    uVar14 = uVar14 + (uVar19 ^ uVar27) + (uint)CARRY4(uVar23, uVar34);
    uVar15 = uVar14 ^ uVar15;
    uVar33 = (uVar31 ^ uVar32) >> 0x18 | uVar15 << 8;
    uVar40 = (uint)m[0xb] + uVar19 + uVar33;
    uVar39 = uVar15 >> 0x18 | (uVar31 ^ uVar32) << 8;
    uVar16 = m[0xb]._4_4_ + uVar4 + CARRY4((uint)m[0xb], uVar19) + uVar39 +
             CARRY4((uint)m[0xb] + uVar19, uVar33);
    uVar4 = uVar16 ^ uVar19 ^ uVar27;
    uVar15 = (uVar40 ^ uVar34) >> 0x10 | uVar4 << 0x10;
    uVar17 = uVar4 >> 0x10 | (uVar40 ^ uVar34) << 0x10;
    uVar34 = (uVar23 ^ uVar6) << 1 | uVar35 >> 0x1f;
    uVar4 = uVar35 << 1 | (uVar23 ^ uVar6) >> 0x1f;
    uVar27 = uVar31 + uVar15;
    uVar14 = uVar14 + uVar17 + CARRY4(uVar31, uVar15);
    uVar32 = (uint)m[9] + uVar46 + uVar34;
    uVar19 = uVar4 + m[9]._4_4_ + uVar41 + CARRY4((uint)m[9], uVar46) +
             (uint)CARRY4((uint)m[9] + uVar46, uVar34);
    uVar30 = uVar19 ^ uVar30;
    uVar23 = uVar21 + uVar30;
    uVar9 = (uVar32 ^ uVar25) + uVar38 + CARRY4(uVar21, uVar30);
    uVar4 = uVar4 ^ uVar9;
    uVar39 = uVar14 ^ uVar39;
    uVar31 = (uVar23 ^ uVar34) >> 0x18 | uVar4 << 8;
    uVar35 = uVar4 >> 0x18 | (uVar23 ^ uVar34) << 8;
    uVar46 = (uint)m[0xe] + uVar32 + uVar31;
    uVar41 = m[0xe]._4_4_ + uVar19 + CARRY4((uint)m[0xe], uVar32) + uVar35 +
             CARRY4((uint)m[0xe] + uVar32, uVar31);
    uVar4 = uVar32 ^ uVar25 ^ uVar41;
    uVar34 = (uVar46 ^ uVar30) >> 0x10 | uVar4 << 0x10;
    uVar19 = uVar4 >> 0x10 | (uVar46 ^ uVar30) << 0x10;
    uVar49 = uVar23 + uVar34;
    uVar9 = uVar9 + uVar19 + CARRY4(uVar23, uVar34);
    uVar23 = uVar12 << 1 | (uVar21 ^ uVar24) >> 0x1f;
    uVar21 = (uVar21 ^ uVar24) << 1 | uVar12 >> 0x1f;
    uVar12 = (uint)m[3] + uVar18 + uVar21;
    uVar32 = m[3]._4_4_ + uVar42 + CARRY4((uint)m[3], uVar18) + uVar23 +
             CARRY4((uint)m[3] + uVar18, uVar21);
    uVar35 = uVar9 ^ uVar35;
    uVar8 = uVar32 ^ uVar8;
    uVar4 = uVar26 + uVar8;
    uVar13 = uVar13 + (uVar12 ^ uVar44) + (uint)CARRY4(uVar26, uVar8);
    uVar23 = uVar13 ^ uVar23;
    uVar18 = (uVar21 ^ uVar4) >> 0x18 | uVar23 << 8;
    uVar36 = (uint)m[0xc] + uVar12 + uVar18;
    uVar6 = uVar23 >> 0x18 | (uVar21 ^ uVar4) << 8;
    uVar30 = m[0xc]._4_4_ + uVar32 + CARRY4((uint)m[0xc], uVar12) + uVar6 +
             CARRY4((uint)m[0xc] + uVar12, uVar18);
    uVar21 = uVar30 ^ uVar12 ^ uVar44;
    uVar44 = (uVar8 ^ uVar36) >> 0x10 | uVar21 << 0x10;
    uVar12 = uVar21 >> 0x10 | (uVar8 ^ uVar36) << 0x10;
    uVar24 = uVar45 << 1 | (uVar26 ^ uVar43) >> 0x1f;
    uVar25 = (uVar26 ^ uVar43) << 1 | uVar45 >> 0x1f;
    uVar32 = uVar4 + uVar44;
    uVar8 = uVar12 + uVar13 + CARRY4(uVar4, uVar44);
    uVar6 = uVar8 ^ uVar6;
    uVar4 = (uint)m[0xd] + uVar20 + uVar25;
    uVar23 = m[0xd]._4_4_ + uVar22 + CARRY4((uint)m[0xd], uVar20) + uVar24 +
             CARRY4((uint)m[0xd] + uVar20, uVar25);
    uVar29 = uVar23 ^ uVar29;
    uVar21 = uVar47 + uVar29;
    uVar11 = uVar11 + (uVar4 ^ uVar28) + (uint)CARRY4(uVar47, uVar29);
    uVar24 = uVar11 ^ uVar24;
    uVar38 = (uVar21 ^ uVar25) >> 0x18 | uVar24 << 8;
    uVar13 = uVar24 >> 0x18 | (uVar21 ^ uVar25) << 8;
    uVar20 = (uint)m[0] + uVar4 + uVar38;
    uVar22 = m[0]._4_4_ + uVar23 + CARRY4((uint)m[0], uVar4) + uVar13 +
             CARRY4((uint)m[0] + uVar4, uVar38);
    uVar4 = uVar22 ^ uVar4 ^ uVar28;
    uVar28 = (uVar20 ^ uVar29) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar20 ^ uVar29) << 0x10;
    uVar24 = uVar21 + uVar28;
    uVar11 = uVar11 + uVar29 + CARRY4(uVar21, uVar28);
    uVar13 = uVar11 ^ uVar13;
    uVar25 = (uVar24 ^ uVar38) << 1 | uVar13 >> 0x1f;
    uVar38 = uVar13 << 1 | (uVar24 ^ uVar38) >> 0x1f;
    uVar4 = (uint)m[0] + uVar40 + uVar25;
    uVar21 = m[0]._4_4_ + uVar16 + CARRY4((uint)m[0], uVar40) + uVar38 +
             CARRY4((uint)m[0] + uVar40, uVar25);
    uVar19 = uVar19 ^ uVar21;
    uVar23 = uVar32 + uVar19;
    uVar8 = (uVar34 ^ uVar4) + uVar8 + CARRY4(uVar32, uVar19);
    uVar38 = uVar8 ^ uVar38;
    uVar37 = (uVar23 ^ uVar25) >> 0x18 | uVar38 << 8;
    uVar43 = uVar38 >> 0x18 | (uVar23 ^ uVar25) << 8;
    uVar16 = (uint)m[1] + uVar4 + uVar37;
    uVar25 = m[1]._4_4_ + uVar21 + CARRY4((uint)m[1], uVar4) + uVar43 +
             CARRY4((uint)m[1] + uVar4, uVar37);
    uVar4 = uVar34 ^ uVar4 ^ uVar25;
    uVar26 = (uVar19 ^ uVar16) >> 0x10 | uVar4 << 0x10;
    uVar19 = uVar4 >> 0x10 | (uVar19 ^ uVar16) << 0x10;
    uVar40 = (uVar27 ^ uVar33) << 1 | uVar39 >> 0x1f;
    uVar21 = uVar39 << 1 | (uVar27 ^ uVar33) >> 0x1f;
    uVar42 = uVar23 + uVar26;
    uVar8 = uVar8 + uVar19 + CARRY4(uVar23, uVar26);
    uVar43 = uVar8 ^ uVar43;
    uVar4 = (uint)m[2] + uVar46 + uVar40;
    uVar13 = uVar21 + m[2]._4_4_ + uVar41 + (uint)CARRY4((uint)m[2], uVar46) +
             (uint)CARRY4((uint)m[2] + uVar46, uVar40);
    uVar12 = uVar12 ^ uVar13;
    uVar34 = uVar24 + uVar12;
    uVar38 = (uVar4 ^ uVar44) + uVar11 + CARRY4(uVar24, uVar12);
    uVar21 = uVar21 ^ uVar38;
    uVar23 = (uVar40 ^ uVar34) >> 0x18 | uVar21 << 8;
    uVar24 = uVar21 >> 0x18 | (uVar40 ^ uVar34) << 8;
    uVar39 = (uint)m[3] + uVar4 + uVar23;
    uVar45 = m[3]._4_4_ + uVar13 + CARRY4((uint)m[3], uVar4) + uVar24 +
             CARRY4((uint)m[3] + uVar4, uVar23);
    uVar4 = uVar4 ^ uVar44 ^ uVar45;
    uVar44 = (uVar12 ^ uVar39) >> 0x10 | uVar4 << 0x10;
    uVar40 = uVar4 >> 0x10 | (uVar12 ^ uVar39) << 0x10;
    uVar11 = (uVar49 ^ uVar31) << 1 | uVar35 >> 0x1f;
    uVar46 = uVar34 + uVar44;
    uVar31 = uVar35 << 1 | (uVar49 ^ uVar31) >> 0x1f;
    uVar38 = uVar38 + uVar40 + CARRY4(uVar34, uVar44);
    uVar24 = uVar38 ^ uVar24;
    uVar4 = (uint)m[4] + uVar36 + uVar11;
    uVar12 = m[4]._4_4_ + uVar30 + CARRY4((uint)m[4], uVar36) + uVar31 +
             CARRY4((uint)m[4] + uVar36, uVar11);
    uVar29 = uVar12 ^ uVar29;
    uVar21 = uVar27 + uVar29;
    uVar14 = uVar14 + (uVar4 ^ uVar28) + (uint)CARRY4(uVar27, uVar29);
    uVar31 = uVar31 ^ uVar14;
    uVar34 = (uVar21 ^ uVar11) >> 0x18 | uVar31 << 8;
    uVar35 = uVar31 >> 0x18 | (uVar21 ^ uVar11) << 8;
    uVar13 = (uint)m[5] + uVar4 + uVar34;
    uVar27 = m[5]._4_4_ + uVar12 + CARRY4((uint)m[5], uVar4) + uVar35 +
             CARRY4((uint)m[5] + uVar4, uVar34);
    uVar4 = uVar27 ^ uVar4 ^ uVar28;
    uVar28 = (uVar13 ^ uVar29) >> 0x10 | uVar4 << 0x10;
    uVar29 = uVar4 >> 0x10 | (uVar13 ^ uVar29) << 0x10;
    uVar11 = (uVar32 ^ uVar18) << 1 | uVar6 >> 0x1f;
    uVar6 = uVar6 << 1 | (uVar32 ^ uVar18) >> 0x1f;
    uVar31 = uVar21 + uVar28;
    uVar32 = uVar29 + uVar14 + CARRY4(uVar21, uVar28);
    uVar35 = uVar32 ^ uVar35;
    uVar21 = (uint)m[6] + uVar20 + uVar11;
    uVar4 = m[6]._4_4_ + uVar22 + (uint)CARRY4((uint)m[6], uVar20) + uVar6 +
            CARRY4((uint)m[6] + uVar20, uVar11);
    uVar17 = uVar4 ^ uVar17;
    uVar12 = uVar49 + uVar17;
    uVar9 = uVar9 + (uVar21 ^ uVar15) + (uint)CARRY4(uVar49, uVar17);
    uVar6 = uVar9 ^ uVar6;
    uVar18 = (uVar11 ^ uVar12) >> 0x18 | uVar6 << 8;
    uVar30 = (uint)m[7] + uVar21 + uVar18;
    uVar6 = uVar6 >> 0x18 | (uVar11 ^ uVar12) << 8;
    uVar33 = m[7]._4_4_ + uVar4 + CARRY4((uint)m[7], uVar21) + uVar6 +
             CARRY4((uint)m[7] + uVar21, uVar18);
    uVar4 = uVar33 ^ uVar21 ^ uVar15;
    uVar20 = (uVar30 ^ uVar17) >> 0x10 | uVar4 << 0x10;
    uVar15 = uVar24 << 1 | (uVar46 ^ uVar23) >> 0x1f;
    uVar14 = uVar4 >> 0x10 | (uVar30 ^ uVar17) << 0x10;
    uVar17 = (uVar46 ^ uVar23) << 1 | uVar24 >> 0x1f;
    uVar23 = uVar12 + uVar20;
    uVar9 = uVar9 + uVar14 + CARRY4(uVar12, uVar20);
    uVar6 = uVar6 ^ uVar9;
    uVar21 = (uint)m[8] + uVar16 + uVar17;
    uVar4 = m[8]._4_4_ + uVar25 + (uint)CARRY4((uint)m[8], uVar16) + uVar15 +
            CARRY4((uint)m[8] + uVar16, uVar17);
    uVar14 = uVar4 ^ uVar14;
    uVar12 = uVar31 + uVar14;
    uVar32 = uVar32 + (uVar21 ^ uVar20) + (uint)CARRY4(uVar31, uVar14);
    uVar15 = uVar32 ^ uVar15;
    uVar24 = (uVar12 ^ uVar17) >> 0x18 | uVar15 << 8;
    uVar11 = (uint)m[9] + uVar21 + uVar24;
    uVar36 = uVar15 >> 0x18 | (uVar12 ^ uVar17) << 8;
    uVar16 = m[9]._4_4_ + uVar4 + CARRY4((uint)m[9], uVar21) + uVar36 +
             CARRY4((uint)m[9] + uVar21, uVar24);
    uVar4 = uVar16 ^ uVar21 ^ uVar20;
    uVar15 = (uVar11 ^ uVar14) >> 0x10 | uVar4 << 0x10;
    uVar17 = uVar4 >> 0x10 | (uVar11 ^ uVar14) << 0x10;
    uVar20 = uVar12 + uVar15;
    uVar22 = (uVar31 ^ uVar34) << 1 | uVar35 >> 0x1f;
    uVar32 = uVar32 + uVar17 + CARRY4(uVar12, uVar15);
    uVar4 = uVar35 << 1 | (uVar31 ^ uVar34) >> 0x1f;
    uVar21 = (uint)m[10] + uVar39 + uVar22;
    uVar12 = m[10]._4_4_ + uVar45 + CARRY4((uint)m[10], uVar39) + uVar4 +
             CARRY4((uint)m[10] + uVar39, uVar22);
    uVar19 = uVar12 ^ uVar19;
    uVar31 = uVar23 + uVar19;
    uVar9 = uVar9 + (uVar21 ^ uVar26) + (uint)CARRY4(uVar23, uVar19);
    uVar36 = uVar32 ^ uVar36;
    uVar4 = uVar4 ^ uVar9;
    uVar14 = (uVar31 ^ uVar22) >> 0x18 | uVar4 << 8;
    uVar35 = uVar4 >> 0x18 | (uVar31 ^ uVar22) << 8;
    uVar39 = (uint)m[0xb] + uVar21 + uVar14;
    uVar45 = m[0xb]._4_4_ + uVar12 + CARRY4((uint)m[0xb], uVar21) + uVar35 +
             CARRY4((uint)m[0xb] + uVar21, uVar14);
    uVar4 = uVar45 ^ uVar21 ^ uVar26;
    uVar22 = (uVar19 ^ uVar39) >> 0x10 | uVar4 << 0x10;
    uVar48 = uVar4 >> 0x10 | (uVar19 ^ uVar39) << 0x10;
    uVar19 = uVar6 << 1 | (uVar23 ^ uVar18) >> 0x1f;
    uVar41 = uVar31 + uVar22;
    uVar9 = uVar9 + uVar48 + CARRY4(uVar31, uVar22);
    uVar23 = (uVar23 ^ uVar18) << 1 | uVar6 >> 0x1f;
    uVar31 = (uint)m[0xc] + uVar13 + uVar23;
    uVar21 = m[0xc]._4_4_ + uVar27 + CARRY4((uint)m[0xc], uVar13) + uVar19 +
             CARRY4((uint)m[0xc] + uVar13, uVar23);
    uVar35 = uVar9 ^ uVar35;
    uVar40 = uVar40 ^ uVar21;
    uVar4 = uVar42 + uVar40;
    uVar8 = uVar8 + (uVar31 ^ uVar44) + (uint)CARRY4(uVar42, uVar40);
    uVar19 = uVar8 ^ uVar19;
    uVar18 = (uVar23 ^ uVar4) >> 0x18 | uVar19 << 8;
    uVar13 = uVar19 >> 0x18 | (uVar23 ^ uVar4) << 8;
    uVar47 = (uint)m[0xd] + uVar31 + uVar18;
    uVar49 = m[0xd]._4_4_ + uVar21 + CARRY4((uint)m[0xd], uVar31) + uVar13 +
             CARRY4((uint)m[0xd] + uVar31, uVar18);
    uVar19 = uVar31 ^ uVar44 ^ uVar49;
    uVar44 = (uVar47 ^ uVar40) >> 0x10 | uVar19 << 0x10;
    uVar25 = uVar19 >> 0x10 | (uVar47 ^ uVar40) << 0x10;
    uVar19 = uVar4 + uVar44;
    uVar21 = uVar43 << 1 | (uVar42 ^ uVar37) >> 0x1f;
    uVar8 = uVar8 + uVar25 + CARRY4(uVar4, uVar44);
    uVar4 = (uVar42 ^ uVar37) << 1 | uVar43 >> 0x1f;
    uVar31 = (uint)m[0xe] + uVar30 + uVar4;
    uVar6 = m[0xe]._4_4_ + uVar33 + CARRY4((uint)m[0xe], uVar30) + uVar21 +
            CARRY4((uint)m[0xe] + uVar30, uVar4);
    uVar29 = uVar6 ^ uVar29;
    uVar23 = uVar46 + uVar29;
    uVar13 = uVar8 ^ uVar13;
    uVar38 = uVar38 + (uVar31 ^ uVar28) + (uint)CARRY4(uVar46, uVar29);
    uVar21 = uVar21 ^ uVar38;
    uVar12 = (uVar4 ^ uVar23) >> 0x18 | uVar21 << 8;
    uVar21 = uVar21 >> 0x18 | (uVar4 ^ uVar23) << 8;
    uVar4 = (uint)m[0xf] + uVar31 + uVar12;
    uVar42 = m[0xf]._4_4_ + uVar6 + CARRY4((uint)m[0xf], uVar31) + uVar21 +
             CARRY4((uint)m[0xf] + uVar31, uVar12);
    uVar31 = uVar42 ^ uVar31 ^ uVar28;
    uVar28 = (uVar4 ^ uVar29) >> 0x10 | uVar31 << 0x10;
    uVar26 = uVar31 >> 0x10 | (uVar4 ^ uVar29) << 0x10;
    uVar31 = uVar23 + uVar28;
    uVar29 = (uVar20 ^ uVar24) << 1 | uVar36 >> 0x1f;
    uVar34 = uVar26 + uVar38 + CARRY4(uVar23, uVar28);
    uVar21 = uVar21 ^ uVar34;
    uVar40 = (uVar12 ^ uVar31) << 1 | uVar21 >> 0x1f;
    uVar12 = uVar21 << 1 | (uVar12 ^ uVar31) >> 0x1f;
    uVar24 = uVar36 << 1 | (uVar20 ^ uVar24) >> 0x1f;
    uVar23 = (uint)m[0xe] + uVar11 + uVar40;
    uVar27 = (uVar41 ^ uVar14) << 1 | uVar35 >> 0x1f;
    uVar6 = uVar35 << 1 | (uVar41 ^ uVar14) >> 0x1f;
    uVar14 = m[0xe]._4_4_ + uVar16 + CARRY4((uint)m[0xe], uVar11) + uVar12 +
             CARRY4((uint)m[0xe] + uVar11, uVar40);
    uVar48 = uVar14 ^ uVar48;
    uVar21 = uVar19 + uVar48;
    uVar38 = (uVar19 ^ uVar18) << 1 | uVar13 >> 0x1f;
    uVar18 = uVar13 << 1 | (uVar19 ^ uVar18) >> 0x1f;
    uVar8 = uVar8 + (uVar23 ^ uVar22) + (uint)CARRY4(uVar19, uVar48);
    uVar12 = uVar12 ^ uVar8;
    uVar19 = (uVar40 ^ uVar21) >> 0x18 | uVar12 << 8;
    uVar13 = (uint)m[10] + uVar23 + uVar19;
    uVar16 = m[10]._4_4_ + uVar14 + CARRY4((uint)m[10], uVar23) +
             (uVar12 >> 0x18 | (uVar40 ^ uVar21) << 8) +
             (uint)CARRY4((uint)m[10] + uVar23, uVar19);
    uVar40 = uVar16 ^ uVar23 ^ uVar22;
    uVar14 = (uVar13 ^ uVar48) >> 0x10 | uVar40 << 0x10;
    uVar22 = uVar21 + uVar14;
    uVar23 = (uint)m[4] + uVar39 + uVar29;
    uVar11 = m[4]._4_4_ + uVar45 + CARRY4((uint)m[4], uVar39) + uVar24 +
             CARRY4((uint)m[4] + uVar39, uVar29);
    uVar25 = uVar11 ^ uVar25;
    uVar19 = uVar31 + uVar25;
    uVar34 = uVar34 + (uVar23 ^ uVar44) + (uint)CARRY4(uVar31, uVar25);
    uVar24 = uVar24 ^ uVar34;
    uVar31 = (uVar19 ^ uVar29) >> 0x18 | uVar24 << 8;
    uVar12 = uVar24 >> 0x18 | (uVar19 ^ uVar29) << 8;
    uVar25 = (uint)m[8] + uVar23 + uVar31 ^ uVar25;
    uVar23 = m[8]._4_4_ + uVar11 + CARRY4((uint)m[8], uVar23) + uVar12 +
                 CARRY4((uint)m[8] + uVar23, uVar31) ^
             uVar23 ^ uVar44;
    uVar29 = uVar25 >> 0x10 | uVar23 << 0x10;
    uVar11 = uVar23 >> 0x10 | uVar25 << 0x10;
    uVar31 = uVar31 ^ uVar19 + uVar29;
    uVar23 = (uint)m[9] + uVar47 + uVar27;
    uVar24 = m[9]._4_4_ + uVar49 + CARRY4((uint)m[9], uVar47) + uVar6 +
             CARRY4((uint)m[9] + uVar47, uVar27);
    uVar26 = uVar24 ^ uVar26;
    uVar12 = uVar34 + uVar11 + CARRY4(uVar19, uVar29) ^ uVar12;
    uVar19 = uVar20 + uVar26;
    uVar32 = uVar32 + (uVar23 ^ uVar28) + (uint)CARRY4(uVar20, uVar26);
    uVar6 = uVar32 ^ uVar6;
    uVar34 = (uVar19 ^ uVar27) >> 0x18 | uVar6 << 8;
    uVar20 = (uint)m[0xf] + uVar23 + uVar34;
    uVar30 = uVar31 << 1 | uVar12 >> 0x1f;
    uVar25 = m[0xf]._4_4_ + uVar24 + CARRY4((uint)m[0xf], uVar23) +
             (uVar6 >> 0x18 | (uVar19 ^ uVar27) << 8) +
             (uint)CARRY4((uint)m[0xf] + uVar23, uVar34);
    uVar6 = uVar12 << 1 | uVar31 >> 0x1f;
    uVar24 = uVar25 ^ uVar23 ^ uVar28;
    uVar34 = (uVar20 ^ uVar26) >> 0x10 | uVar24 << 0x10;
    uVar23 = uVar19 + uVar34;
    uVar12 = (uint)m[0xd] + uVar4 + uVar38;
    uVar31 = m[0xd]._4_4_ + uVar42 + CARRY4((uint)m[0xd], uVar4) + uVar18 +
             CARRY4((uint)m[0xd] + uVar4, uVar38);
    uVar17 = uVar31 ^ uVar17;
    uVar4 = uVar41 + uVar17;
    uVar9 = uVar9 + (uVar12 ^ uVar15) + (uint)CARRY4(uVar41, uVar17);
    uVar18 = uVar9 ^ uVar18;
    uVar27 = (uVar4 ^ uVar38) >> 0x18 | uVar18 << 8;
    uVar38 = uVar18 >> 0x18 | (uVar4 ^ uVar38) << 8;
    uVar17 = (uint)m[6] + uVar12 + uVar27 ^ uVar17;
    uVar31 = m[6]._4_4_ + uVar31 + CARRY4((uint)m[6], uVar12) + uVar38 +
                 CARRY4((uint)m[6] + uVar12, uVar27) ^
             uVar12 ^ uVar15;
    uVar12 = uVar17 >> 0x10 | uVar31 << 0x10;
    uVar31 = uVar31 >> 0x10 | uVar17 << 0x10;
    uVar27 = uVar4 + uVar12 ^ uVar27;
    uVar38 = uVar31 + uVar9 + CARRY4(uVar4, uVar12) ^ uVar38;
    uVar4 = (uint)m[1] + uVar13 + uVar30;
    uVar9 = m[1]._4_4_ + uVar16 + CARRY4((uint)m[1], uVar13) + uVar6 +
            CARRY4((uint)m[1] + uVar13, uVar30);
    uVar31 = uVar9 ^ uVar31;
    uVar30 = uVar23 + uVar31 ^ uVar30;
    uVar6 = (uVar12 ^ uVar4) + (uVar24 >> 0x10 | (uVar20 ^ uVar26) << 0x10) +
                uVar32 + CARRY4(uVar19, uVar34) + (uint)CARRY4(uVar23, uVar31) ^
            uVar6;
    uVar19 = uVar30 >> 0x18 | uVar6 << 8;
    uVar34 = uVar27 << 1 | uVar38 >> 0x1f;
    uVar32 = (uint)m[0xc] + uVar4 + uVar19;
    uVar24 = uVar38 << 1 | uVar27 >> 0x1f;
    uVar12 = m[0xc]._4_4_ + uVar9 + CARRY4((uint)m[0xc], uVar4) +
             (uVar6 >> 0x18 | uVar30 << 8) +
             (uint)CARRY4((uint)m[0xc] + uVar4, uVar19);
    uVar4 = (uint)m[0xb] + uVar20 + uVar34;
    uVar23 = m[0xb]._4_4_ + uVar25 + CARRY4((uint)m[0xb], uVar20) + uVar24 +
             CARRY4((uint)m[0xb] + uVar20, uVar34);
    uVar11 = uVar23 ^ uVar11;
    uVar31 = uVar22 + uVar11;
    uVar19 = uVar8 + (uVar40 >> 0x10 | (uVar13 ^ uVar48) << 0x10) +
             (uint)CARRY4(uVar21, uVar14) + (uVar4 ^ uVar29) +
             (uint)CARRY4(uVar22, uVar11);
    uVar24 = uVar19 ^ uVar24;
    uVar21 = (uVar31 ^ uVar34) >> 0x18 | uVar24 << 8;
    uVar11 = (uint)m[7] + uVar4 + uVar21 ^ uVar11;
    uVar4 = m[7]._4_4_ + uVar23 + CARRY4((uint)m[7], uVar4) +
                (uVar24 >> 0x18 | (uVar31 ^ uVar34) << 8) +
                (uint)CARRY4((uint)m[7] + uVar4, uVar21) ^
            uVar4 ^ uVar29;
    uVar23 = uVar11 >> 0x10 | uVar4 << 0x10;
    uVar21 = uVar31 + uVar23;
    uVar4 = (uVar4 >> 0x10 | uVar11 << 0x10) + uVar19 + CARRY4(uVar31, uVar23);
    psVar3 = &S[-1].buflen;
    puVar5 = v;
    while (true) {
        puVar10 = puVar5 + 1;
        psVar1 = psVar3 + 2;
        *psVar1 = uVar21 ^ uVar32 ^ *psVar1;
        psVar3[3] = psVar3[3] ^ uVar4 ^ uVar12;
        if (psVar2 == psVar1)
            break;
        uVar32 = (uint)*puVar10;
        uVar12 = *(uint *)((int)puVar5 + 0xc);
        uVar21 = (uint)puVar10[8];
        uVar4 = *(uint *)((int)puVar5 + 0x4c);
        psVar3 = psVar1;
        puVar5 = puVar10;
    }
    return 0;
}

/* WARNING: Unknown calling convention */

int blake2b_init_param(blake2b_state *S, blake2b_param *P)

{
    size_t *psVar1;
    uint64_t *puVar2;
    size_t *psVar3;
    size_t *psVar4;
    uint uVar5;
    size_t sVar6;
    uint uVar7;
    undefined4 uVar8;

    memset(S, 0, 0x168);
    psVar4 = &S[-1].buflen;
    sVar6 = 0xf3bcc908;
    uVar8 = 0x6a09e667;
    psVar3 = psVar4;
    puVar2 = blake2b_IV;
    while (true) {
        psVar1 = psVar3 + 2;
        *psVar1 = sVar6;
        psVar3[3] = uVar8;
        if ((uint64_t *)psVar1 == S->h + 7)
            break;
        sVar6 = (size_t)puVar2[1];
        uVar8 = *(undefined4 *)((int)puVar2 + 0xc);
        psVar3 = psVar1;
        puVar2 = puVar2 + 1;
    }
    do {
        psVar3 = psVar4 + 2;
        uVar7._0_1_ = P->digest_length;
        uVar7._1_1_ = P->key_length;
        uVar7._2_1_ = P->fanout;
        uVar7._3_1_ = P->depth;
        uVar5 = P->leaf_length;
        *psVar3 = *psVar3 ^ uVar7;
        psVar4[3] = psVar4[3] ^ uVar5;
        P = (blake2b_param *)&P->node_offset;
        psVar4 = psVar3;
    } while (psVar3 != psVar1);
    return 0;
}

/* WARNING: Unknown calling convention */

int blake2b_init(blake2b_state *S, uint8_t outlen)

{
    int iVar1;
    blake2b_param P[1];

    if (outlen - 1 < 0x40) {
        P[0].key_length = '\0';
        P[0].leaf_length._0_1_ = 0;
        P[0].leaf_length._1_1_ = 0;
        P[0].leaf_length._2_1_ = 0;
        P[0].leaf_length._3_1_ = 0;
        P[0].node_offset._0_1_ = 0;
        P[0].node_offset._1_1_ = 0;
        P[0].node_offset._2_1_ = 0;
        P[0].node_offset._3_1_ = 0;
        P[0].node_offset._4_1_ = 0;
        P[0].node_offset._5_1_ = 0;
        P[0].node_offset._6_1_ = 0;
        P[0].node_offset._7_1_ = 0;
        P[0].node_depth = '\0';
        P[0].inner_length = '\0';
        P[0].reserved[0] = '\0';
        P[0].reserved[1] = '\0';
        P[0].reserved[2] = '\0';
        P[0].reserved[3] = '\0';
        P[0].salt[0] = '\0';
        P[0].salt[1] = '\0';
        P[0].salt[2] = '\0';
        P[0].salt[3] = '\0';
        P[0].personal[0] = '\0';
        P[0].personal[1] = '\0';
        P[0].personal[2] = '\0';
        P[0].personal[3] = '\0';
        P[0].reserved[4] = '\0';
        P[0].reserved[5] = '\0';
        P[0].reserved[6] = '\0';
        P[0].reserved[7] = '\0';
        P[0].reserved[8] = '\0';
        P[0].reserved[9] = '\0';
        P[0].reserved[10] = '\0';
        P[0].reserved[0xb] = '\0';
        P[0].reserved[0xc] = '\0';
        P[0].reserved[0xd] = '\0';
        P[0].salt[4] = '\0';
        P[0].salt[5] = '\0';
        P[0].salt[6] = '\0';
        P[0].salt[7] = '\0';
        P[0].salt[8] = '\0';
        P[0].salt[9] = '\0';
        P[0].salt[10] = '\0';
        P[0].salt[0xb] = '\0';
        P[0].salt[0xc] = '\0';
        P[0].salt[0xd] = '\0';
        P[0].salt[0xe] = '\0';
        P[0].salt[0xf] = '\0';
        P[0].personal[4] = '\0';
        P[0].personal[5] = '\0';
        P[0].personal[6] = '\0';
        P[0].personal[7] = '\0';
        P[0].personal[8] = '\0';
        P[0].personal[9] = '\0';
        P[0].personal[10] = '\0';
        P[0].personal[0xb] = '\0';
        P[0].personal[0xc] = '\0';
        P[0].personal[0xd] = '\0';
        P[0].personal[0xe] = '\0';
        P[0].personal[0xf] = '\0';
        P[0].fanout = '\x01';
        P[0].depth = '\x01';
        P[0].digest_length = outlen;
        iVar1 = blake2b_init_param(S, P);
        return iVar1;
    }
    return -1;
}

int blake2b_update(blake2b_state *S, uint8_t *in, uint64_t inlen)

{
    size_t sVar1;
    uint uVar2;
    int iVar3;
    int iVar4;
    uint __n;
    uint8_t *__src;
    uint8_t *block;
    uint uVar5;
    uint uVar6;
    bool bVar7;

    iVar3 = (int)(inlen >> 0x20);
    uVar5 = (uint)inlen;
    if (inlen != 0) {
        sVar1 = S->buflen;
        bVar7 = iVar3 == 0;
        block = S->buf;
        __n = 0x100 - sVar1;
        if (iVar3 == 0) {
            bVar7 = uVar5 <= __n;
        }
        if (!bVar7) {
            __src = in;
            do {
                in = __src + __n;
                memcpy(block + sVar1, __src, __n);
                uVar6 = (uint)S->t[0];
                uVar2 = uVar6 + 0x80;
                uVar5 = (uint)S->t[1];
                iVar3 = *(int *)((int)S->t + 0xc);
                iVar4 = *(int *)((int)S->t + 4) + (uint)(0xffffff7f < uVar6);
                *(uint *)S->t = uVar2;
                *(int *)((int)S->t + 4) = iVar4;
                uVar6 = (uint)(iVar4 == 0 && uVar2 < 0x80);
                S->buflen = __n + S->buflen;
                *(uint *)(S->t + 1) = uVar5 + uVar6;
                *(uint *)((int)S->t + 0xc) = iVar3 + (uint)CARRY4(uVar5, uVar6);
                blake2b_compress(S, block);
                memcpy(block, S->buf + 0x80, 0x80);
                uVar5 = (uint)inlen - __n;
                iVar3 = (int)(inlen >> 0x20) - (uint)((uint)inlen < __n);
                inlen = CONCAT44(iVar3, uVar5);
                bVar7 = iVar3 == 0;
                sVar1 = S->buflen - 0x80;
                __n = 0x100 - sVar1;
                S->buflen = sVar1;
                if (iVar3 == 0) {
                    bVar7 = uVar5 <= __n;
                }
                __src = in;
            } while (!bVar7);
        }
        memcpy(block + sVar1, in, uVar5);
        S->buflen = S->buflen + uVar5;
    }
    return 0;
}

/* WARNING: Unknown calling convention */

int blake2b_init_key(blake2b_state *S, uint8_t outlen, void *key,
                     uint8_t keylen)

{
    int iVar1;
    blake2b_param P[1];
    uint8_t block[128];

    if (outlen - 1 < 0x40) {
        P[0].reserved._0_4_ = ZEXT14(key == (void *)0x0);
        if (0x3f < keylen - 1) {
            P[0].reserved._0_4_ = 1;
        }
        if (P[0].reserved._0_4_ == 0) {
            P[0].leaf_length._0_2_ = 0;
            P[0].leaf_length._2_2_ = 0;
            P[0].node_offset._0_2_ = 0;
            P[0].node_offset._2_2_ = 0;
            P[0].node_offset._4_2_ = 0;
            P[0].node_offset._6_2_ = 0;
            P[0].node_depth = '\0';
            P[0].inner_length = '\0';
            P[0].fanout = '\x01';
            P[0].depth = '\x01';
            P[0].reserved[0xc] = '\0';
            P[0].reserved[0xd] = '\0';
            P[0].digest_length = outlen;
            P[0].key_length = keylen;
            P[0].reserved._4_4_ = P[0].reserved._0_4_;
            P[0].reserved._8_4_ = P[0].reserved._0_4_;
            P[0].salt._0_4_ = P[0].reserved._0_4_;
            P[0].salt._4_4_ = P[0].reserved._0_4_;
            P[0].salt._8_4_ = P[0].reserved._0_4_;
            P[0].salt._12_4_ = P[0].reserved._0_4_;
            P[0].personal._0_4_ = P[0].reserved._0_4_;
            P[0].personal._4_4_ = P[0].reserved._0_4_;
            P[0].personal._8_4_ = P[0].reserved._0_4_;
            P[0].personal._12_4_ = P[0].reserved._0_4_;
            iVar1 = blake2b_init_param(S, P);
            if (-1 < iVar1) {
                memset(block, 0, 0x80);
                memcpy(block, key, (uint)keylen);
                blake2b_update(S, block, 0x80);
                (*memset_v_6360)(block, 0, 0x80);
                return 0;
            }
        }
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen)

{
    bool bVar1;
    size_t *psVar2;
    uint8_t uVar3;
    size_t *psVar4;
    int iVar5;
    size_t sVar6;
    undefined4 uVar7;
    size_t __n;
    uint uVar8;
    uint8_t *puVar9;
    uint uVar10;
    uint uVar11;
    uint uVar12;
    uint local_70;
    int iStack_6c;
    uint8_t buffer[64];

    memset(buffer, 0, 0x40);
    if ((outlen - 1 < 0x40 && out != (uint8_t *)0x0) &&
        (*(int *)((int)S->f + 4) == 0 && (int)S->f[0] == 0)) {
        uVar12 = S->buflen;
        puVar9 = S->buf;
        local_70 = (uint)S->t[1];
        iStack_6c = *(int *)((int)S->t + 0xc);
        uVar10 = (uint)S->t[0];
        uVar11 = *(uint *)((int)S->t + 4);
        if (0x80 < uVar12) {
            iVar5 = uVar11 + (0xffffff7f < uVar10);
            *(uint *)S->t = uVar10 + 0x80;
            *(int *)((int)S->t + 4) = iVar5;
            uVar10 = (uint)(iVar5 == 0 && uVar10 + 0x80 < 0x80);
            *(uint *)(S->t + 1) = local_70 + uVar10;
            *(uint *)((int)S->t + 0xc) =
                iStack_6c + (uint)CARRY4(local_70, uVar10);
            blake2b_compress(S, puVar9);
            __n = S->buflen - 0x80;
            S->buflen = __n;
            memcpy(puVar9, S->buf + 0x80, __n);
            local_70 = (uint)S->t[1];
            iStack_6c = *(int *)((int)S->t + 0xc);
            uVar12 = S->buflen;
            uVar10 = (uint)S->t[0];
            uVar11 = *(uint *)((int)S->t + 4);
        }
        bVar1 = CARRY4(uVar11, (uint)CARRY4(uVar12, uVar10));
        uVar8 = (uint)bVar1;
        if (!bVar1) {
            uVar8 = 0;
        }
        uVar3 = S->last_node;
        *(uint *)S->t = uVar12 + uVar10;
        *(uint *)((int)S->t + 4) = uVar11 + CARRY4(uVar12, uVar10);
        *(uint *)(S->t + 1) = local_70 + uVar8;
        *(uint *)((int)S->t + 0xc) = iStack_6c + (uint)CARRY4(local_70, uVar8);
        if (uVar3 != '\0') {
            *(undefined4 *)(S->f + 1) = 0xffffffff;
            *(undefined4 *)((int)S->f + 0xc) = 0xffffffff;
        }
        *(undefined4 *)S->f = 0xffffffff;
        *(undefined4 *)((int)S->f + 4) = 0xffffffff;
        memset(puVar9 + uVar12, 0, 0x100 - uVar12);
        blake2b_compress(S, puVar9);
        psVar4 = &S[-1].buflen;
        puVar9 = buffer;
        do {
            psVar2 = psVar4 + 2;
            sVar6 = *psVar2;
            uVar7 = psVar4[3];
            *puVar9 = (uint8_t)sVar6;
            puVar9[4] = (uint8_t)uVar7;
            puVar9[1] = (uint8_t)(sVar6 >> 8);
            puVar9[5] = (uint8_t)((uint)uVar7 >> 8);
            puVar9[6] = (uint8_t)((uint)uVar7 >> 0x10);
            puVar9[7] = (uint8_t)((uint)uVar7 >> 0x18);
            puVar9[2] = (uint8_t)(sVar6 >> 0x10);
            puVar9[3] = (uint8_t)(sVar6 >> 0x18);
            psVar4 = psVar2;
            puVar9 = puVar9 + 8;
        } while (S->h + 7 != (uint64_t *)psVar2);
        memcpy(out, buffer, (uint)outlen);
        iVar5 = 0;
    } else {
        iVar5 = -1;
    }
    return iVar5;
}

/* WARNING: Unknown calling convention */

int blake2b(uint8_t *out, void *in, void *key, uint8_t outlen, uint64_t inlen,
            uint8_t keylen)

{
    int iVar1;
    uint8_t uVar2;
    bool bVar3;
    bool bVar4;
    blake2b_state S[1];

    if (out != (uint8_t *)0x0 && (in != (void *)0x0 || inlen == 0)) {
        uVar2 = keylen;
        if (keylen != '\0') {
            uVar2 = '\x01';
        }
        if (key != (void *)0x0) {
            uVar2 = '\0';
        }
        if (uVar2 == '\0') {
            bVar4 = 0x3f < keylen;
            bVar3 = keylen == '@';
            if (keylen < 0x41) {
                bVar4 = 0x3e < outlen - 1;
                bVar3 = outlen - 1 == 0x3f;
            }
            if (!bVar4 || bVar3) {
                if (keylen == '\0') {
                    iVar1 = blake2b_init(S, outlen);
                } else {
                    iVar1 = blake2b_init_key(S, outlen, key, keylen);
                }
                if (-1 < iVar1) {
                    blake2b_update(S, (uint8_t *)in, inlen);
                    blake2b_final(S, out, outlen);
                    return 0;
                }
            }
        }
    }
    return -1;
}

/* WARNING: Unknown calling convention */

void Sha256_WriteByteBlock(CSha256 *p)

{
    uint32_t uVar1;
    uint uVar2;
    uint8_t *puVar3;
    uint uVar4;
    int *piVar5;
    int *piVar6;
    uint32_t *puVar7;
    uint uVar8;
    CSha256 *pCVar9;
    uint uVar10;
    uint uVar11;
    uint32_t uVar12;
    uint32_t *puVar13;
    int iVar14;
    uint uVar15;
    uint8_t *puVar16;
    uint uVar17;
    int iVar18;
    int local_cc;
    uint32_t T[8];
    uint32_t data32[16];
    uint32_t W[16];

    puVar7 = T + 7;
    pCVar9 = p;
    do {
        puVar7 = puVar7 + 1;
        *puVar7 = (uint)pCVar9->buffer[1] * 0x10000 +
                  (uint)pCVar9->buffer[0] * 0x1000000 +
                  (uint)pCVar9->buffer[3] + (uint)pCVar9->buffer[2] * 0x100;
        pCVar9 = (CSha256 *)(pCVar9->state + 1);
    } while (data32 + 0xf != puVar7);
    puVar16 = p[-1].buffer + 0x3c;
    piVar5 = &local_cc;
    puVar3 = puVar16;
    piVar6 = piVar5;
    do {
        puVar3 = puVar3 + 4;
        piVar6 = piVar6 + 1;
        *piVar6 = *(int *)puVar3;
    } while (p->state + 7 != (uint32_t *)puVar3);
    puVar7 = K;
    uVar1 = 0x428a2f98;
    iVar14 = 0;
    while (true) {
        iVar18 = 0;
        puVar13 = puVar7;
        while (true) {
            uVar4 = T[4U - iVar18 & 7];
            uVar10 = T[6U - iVar18 & 7];
            uVar2 = T[5U - iVar18 & 7];
            if (iVar14 == 0) {
                uVar12 = data32[iVar18];
                W[iVar18] = uVar12;
            } else {
                uVar11 = W[iVar18 - 2U & 0xf];
                uVar15 = W[iVar18 - 0xfU & 0xf];
                uVar12 = W[iVar18 - 7U & 0xf] + W[iVar18] +
                         ((uVar11 >> 0x13 | uVar11 << 0xd) ^
                          (uVar11 >> 0x11 | uVar11 << 0xf) ^ uVar11 >> 10) +
                         ((uVar15 >> 0x12 | uVar15 << 0xe) ^
                          (uVar15 >> 7 | uVar15 << 0x19) ^ uVar15 >> 3);
                W[iVar18] = uVar12;
            }
            uVar15 = 7U - iVar18 & 7;
            uVar8 = 3U - iVar18 & 7;
            uVar11 = -iVar18;
            uVar17 = 1 - iVar18;
            uVar1 =
                ((uVar2 ^ uVar10) & uVar4 ^ uVar10) +
                ((uVar4 >> 0xb | uVar4 << 0x15) ^ (uVar4 >> 6 | uVar4 << 0x1a) ^
                 (uVar4 >> 0x19 | uVar4 << 7)) +
                T[uVar15] + uVar12 + uVar1;
            uVar4 = 2 - iVar18;
            T[uVar15] = uVar1;
            iVar18 = iVar18 + 1;
            T[uVar8] = uVar1 + T[uVar8];
            uVar2 = T[uVar11 & 7];
            T[uVar15] =
                ((uVar2 | T[uVar17 & 7]) & T[uVar4 & 7] |
                 T[uVar17 & 7] & uVar2) +
                ((uVar2 >> 0xd | uVar2 << 0x13) ^ (uVar2 >> 2 | uVar2 << 0x1e) ^
                 (uVar2 >> 0x16 | uVar2 << 10)) +
                T[uVar15];
            if (iVar18 == 0x10)
                break;
            puVar13 = puVar13 + 1;
            uVar1 = *puVar13;
        }
        iVar14 = iVar14 + 0x10;
        if (iVar14 == 0x40)
            break;
        puVar7 = puVar7 + 0x10;
        uVar1 = *puVar7;
    }
    do {
        puVar16 = puVar16 + 4;
        piVar5 = piVar5 + 1;
        *(int *)puVar16 = *(int *)puVar16 + *piVar5;
    } while (puVar3 != puVar16);
    return;
}

/* WARNING: Unknown calling convention */

void Sha256_Init(CSha256 *p)

{
    p->state[0] = 0x6a09e667;
    p->state[1] = 0xbb67ae85;
    p->state[2] = 0x3c6ef372;
    p->state[3] = 0xa54ff53a;
    p->state[4] = 0x510e527f;
    *(undefined4 *)&p->count = 0;
    *(undefined4 *)((int)&p->count + 4) = 0;
    p->state[5] = 0x9b05688c;
    p->state[6] = 0x1f83d9ab;
    p->state[7] = 0x5be0cd19;
    return;
}

/* WARNING: Unknown calling convention */

void Sha256_Update(CSha256 *p, uint8_t *data, size_t size)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    uint8_t *puVar5;

    iVar4 = *(int *)((int)&p->count + 4);
    uVar1 = (uint)p->count;
    if (size != 0) {
        uVar2 = uVar1 & 0x3f;
        puVar5 = data;
        while (true) {
            uVar3 = uVar2 + 1;
            p->buffer[uVar2] = *puVar5;
            *(uint *)&p->count = uVar1 + 1;
            *(uint *)((int)&p->count + 4) = iVar4 + (uint)(0xfffffffe < uVar1);
            uVar2 = uVar3;
            if (uVar3 == 0x40) {
                Sha256_WriteByteBlock(p);
                uVar2 = 0;
            }
            if (puVar5 + 1 == data + size)
                break;
            uVar1 = (uint)p->count;
            iVar4 = *(int *)((int)&p->count + 4);
            puVar5 = puVar5 + 1;
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

void Sha256_Final(CSha256 *p, uint8_t *digest)

{
    uint8_t *puVar1;
    CSha256 *pCVar2;
    CSha256 *pCVar3;
    uint8_t *puVar4;
    uint uVar5;
    uint8_t *puVar6;
    uint8_t *puVar7;
    int iVar8;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    uint8_t unaff_r10;
    bool bVar12;

    uVar5 = (uint)p->count;
    iVar8 = *(int *)((int)&p->count + 4);
    uVar10 = (uVar5 & 0x3f) + 1;
    bVar12 = uVar10 != 0x38;
    uVar11 = uVar5 << 3;
    p->buffer[uVar5 & 0x3f] = 0x80;
    if (bVar12) {
        unaff_r10 = '\0';
    }
    while (bVar12) {
        while (true) {
            uVar9 = uVar10 & 0x3f;
            uVar10 = uVar9 + 1;
            if (uVar9 != 0)
                break;
            Sha256_WriteByteBlock(p);
            p->buffer[0] = '\0';
        }
        bVar12 = uVar10 != 0x38;
        p->buffer[uVar9] = unaff_r10;
    }
    pCVar2 = (CSha256 *)(p->buffer + 0x38);
    uVar10 = iVar8 << 3 | uVar5 >> 0x1d;
    do {
        uVar5 = uVar11 >> 0x18;
        pCVar3 = (CSha256 *)((int)pCVar2->state + 1);
        *(char *)pCVar2->state = (char)(uVar10 >> 0x18);
        uVar11 = uVar11 << 8;
        pCVar2 = pCVar3;
        uVar10 = uVar10 << 8 | uVar5;
    } while (pCVar3 != p + 1);
    Sha256_WriteByteBlock(p);
    puVar4 = p[-1].buffer + 0x3c;
    puVar6 = digest + 4;
    do {
        puVar1 = puVar4 + 4;
        puVar7 = puVar6 + 4;
        puVar6[-4] = (uint8_t)((uint) * (undefined4 *)puVar1 >> 0x18);
        puVar6[-3] = (uint8_t) * (undefined2 *)(puVar4 + 6);
        puVar6[-2] = (uint8_t)((uint) * (undefined4 *)puVar1 >> 8);
        puVar6[-1] = (uint8_t) * (undefined4 *)puVar1;
        puVar4 = puVar1;
        puVar6 = puVar7;
    } while (puVar7 != digest + 0x24);
    p->state[0] = 0x6a09e667;
    p->state[1] = 0xbb67ae85;
    p->state[2] = 0x3c6ef372;
    p->state[3] = 0xa54ff53a;
    p->state[4] = 0x510e527f;
    p->state[5] = 0x9b05688c;
    p->state[6] = 0x1f83d9ab;
    p->state[7] = 0x5be0cd19;
    *(undefined4 *)&p->count = 0;
    *(undefined4 *)((int)&p->count + 4) = 0;
    return;
}

/* WARNING: Unknown calling convention */

void Sha256_Onestep(uint8_t *data, size_t size, uint8_t *digest)

{
    CSha256 p;

    p.state[0] = 0x6a09e667;
    p.state[1] = 0xbb67ae85;
    p.state[2] = 0x3c6ef372;
    p.state[3] = 0xa54ff53a;
    p.state[4] = 0x510e527f;
    p.state[6] = 0x1f83d9ab;
    p.state[7] = 0x5be0cd19;
    p.state[5] = 0x9b05688c;
    p.count._0_4_ = 0;
    p.count._4_4_ = 0;
    Sha256_Update(&p, data, size);
    Sha256_Final(&p, digest);
    return;
}

/* WARNING: Unknown calling convention */

void *statusServiceThread(void *param)

{
    undefined4 uVar1;
    char *pcVar2;
    char *pcVar3;
    size_t sVar4;
    int iVar5;
    int iVar6;
    size_t sVar7;
    ssize_t sVar8;
    int *piVar9;
    int iVar10;
    void *pvVar11;
    uint uVar12;
    char sendbuf[3];
    int recvlen;
    char endofrequest[5];
    timeval timeout;
    sockaddr_in from;
    char buf[4096];
    char tmp42_10[4096];
    char recvbuf[10240];
    char strSendbuf[10240];

    timeout.tv_sec = 3;
    timeout.tv_usec = 0;
    memset(buf, 0, 0x1000);
    pcVar3 = recvbuf;
    sendbuf[0] = '\r';
    sendbuf[1] = '\n';
    recvlen = 0;
    builtin_strncpy(endofrequest, "\r\n\r\n", 5);
    iVar10 = 0;
    sendbuf[2] = '\0';
    memset(pcVar3, 0, 0x2800);
    do {
        if (ExitServer != false)
            goto LAB_0004711a;
        sVar8 = recvfrom((int)param, pcVar3, 0x27ff - iVar10, 0,
                         (sockaddr *)&from, (socklen_t *)&recvlen);
        iVar10 = iVar10 + sVar8;
        if (sVar8 < 1) {
            close((int)param);
            if (opt_debug == false) {
                return (void *)0x0;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 7)) {
                return (void *)0x0;
            }
            builtin_strncpy(strSendbuf, ":statusServiceThread recvfrom<=0",
                            0x20);
            strSendbuf._32_4_ = strSendbuf._32_4_ & 0xffffff00;
            _applog(7, strSendbuf, false);
            return (void *)0x0;
        }
        pcVar3 = recvbuf + iVar10;
        if (0x27fe < iVar10) {
            close((int)param);
            uVar1 = strSendbuf._20_4_;
            if (opt_debug == false) {
                return (void *)0x0;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 7)) {
                return (void *)0x0;
            }
            builtin_strncpy(strSendbuf, "BUFSIZE is too small!", 0x16);
            strSendbuf._22_2_ = SUB42(uVar1, 2);
            _applog(7, strSendbuf, false);
            return (void *)0x0;
        }
        pcVar2 = strstr(recvbuf, endofrequest);
    } while (pcVar2 == (char *)0x0);
    if (opt_debug != false) {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
        LAB_00047132:
            if ((opt_log_output != false) || (6 < opt_log_level)) {
            LAB_00047144:
                snprintf(strSendbuf, 0x1000, "get http=%s", recvbuf);
                _applog(7, strSendbuf, false);
            }
        } else {
            builtin_strncpy(strSendbuf, "find http request end flag!", 0x1c);
            _applog(7, strSendbuf, false);
        LAB_0004711a:
            if (opt_debug != false) {
                if (use_syslog == false)
                    goto LAB_00047132;
                goto LAB_00047144;
            }
        }
    }
    if ((((recvbuf[0] != 'G') || (recvbuf[1] != 'E')) || (recvbuf[2] != 'T')) ||
        (recvbuf[3] != ' ')) {
        close((int)param);
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            builtin_strncpy(strSendbuf,
                            "statusServiceThread not support http command",
                            0x2c);
            pcVar3 = strSendbuf;
            pcVar2 = strSendbuf;
        LAB_000471da:
            pcVar3[0x2c] = '\0';
            _applog(7, pcVar2, false);
        }
        return (void *)0x0;
    }
    pcVar3 = strstr(recvbuf + 4, "/rate");
    if (pcVar3 == (char *)0x0) {
        pcVar3 = strstr(recvbuf + 4, "/productName");
        if (pcVar3 == (char *)0x0) {
            close((int)param);
            if (opt_debug == false) {
                return (void *)0x0;
            }
            if (((use_syslog == false) && (opt_log_output == false)) &&
                (opt_log_level < 7)) {
                return (void *)0x0;
            }
            builtin_strncpy(strSendbuf,
                            "statusServiceThread exit for Error cmd!", 0x28);
            _applog(7, strSendbuf, false);
            return (void *)0x0;
        }
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            builtin_strncpy(strSendbuf, "cmd : get miner type", 0x14);
            strSendbuf._20_4_ = strSendbuf._20_4_ & 0xffffff00;
            _applog(7, strSendbuf, false);
        }
        snprintf(buf, 0x1000, g_miner_type);
    } else {
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            builtin_strncpy(strSendbuf, "cmd : get ra", 0xc);
            strSendbuf[0xc] = 't';
            strSendbuf[0xd] = 'e';
            strSendbuf[0xe] = '\0';
            _applog(7, strSendbuf, false);
        }
        if (freq_scan_status == 1) {
            snprintf(buf, 0x1000, "%d", 200000);
        } else if (freq_scan_status == 2) {
            snprintf(buf, 0x1000, "%s:%s", "searchfailed",
                     "search_failed_info");
        } else {
            buf[0] = 's';
            buf[1] = 'e';
            buf[2] = 'a';
            buf[3] = 'r';
            buf[4] = 'c';
            buf[5] = 'h';
            buf[6] = 'i';
            buf[7] = 'n';
            buf[8] = 'g';
            buf[9] = '\0';
        }
    }
    iVar10 = setsockopt((int)param, 1, 0x15, &timeout, 8);
    if (iVar10 != 0) {
        close((int)param);
        if (opt_debug == false) {
            return (void *)0x0;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
            return (void *)0x0;
        }
        pcVar3 = "setsockopt SO_SNDTIMEO failed";
    LAB_00047440:
        strSendbuf._0_4_ = *(undefined4 *)pcVar3;
        strSendbuf._4_4_ = *(undefined4 *)(pcVar3 + 4);
        strSendbuf._8_4_ = *(undefined4 *)(pcVar3 + 8);
        strSendbuf._12_4_ = *(undefined4 *)(pcVar3 + 0xc);
        strSendbuf._16_4_ = *(undefined4 *)(pcVar3 + 0x10);
        strSendbuf._20_4_ = *(undefined4 *)(pcVar3 + 0x14);
        strSendbuf._24_4_ = *(undefined4 *)(pcVar3 + 0x18);
        strSendbuf[0x1c] = (char)(short)*(undefined4 *)(pcVar3 + 0x1c);
        strSendbuf[0x1d] =
            (char)((ushort)(short)*(undefined4 *)(pcVar3 + 0x1c) >> 8);
        _applog(7, strSendbuf, false);
        return (void *)0x0;
    }
    iVar10 = setsockopt((int)param, 1, 0x14, &timeout, 8);
    if (iVar10 != 0) {
        close((int)param);
        if (opt_debug == false) {
            return (void *)0x0;
        }
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
            return (void *)0x0;
        }
        pcVar3 = "setsockopt SO_RCVTIMEO failed";
        goto LAB_00047440;
    }
    sVar4 = strlen(buf);
    iVar10 = sprintf(strSendbuf, "HTTP/1.0  200  OK%s", sendbuf);
    iVar5 = sprintf(strSendbuf + iVar10, "Server: SearchFreqServer%s", sendbuf);
    iVar6 = sprintf(strSendbuf + iVar10 + iVar5, "Cache-Control: no-cache%s",
                    sendbuf);
    iVar6 = iVar10 + iVar5 + iVar6;
    iVar10 = sprintf(strSendbuf + iVar6, "Pragma: no-cache%s", sendbuf);
    iVar6 = iVar6 + iVar10;
    iVar10 = sprintf(strSendbuf + iVar6, "Content-Type: text/plain%s", sendbuf);
    iVar6 = iVar6 + iVar10;
    iVar10 =
        sprintf(strSendbuf + iVar6, "Content-Length: %d%s", sVar4, sendbuf);
    sprintf(strSendbuf + iVar10 + iVar6, "Connection: Keep-Alive%s",
            endofrequest);
    uVar1 = tmp42_10._20_4_;
    if (opt_debug == false) {
        if (ExitServer == false)
            goto LAB_00047684;
    } else {
        if (((use_syslog == false) && (opt_log_output == false)) &&
            (opt_log_level < 7)) {
            if (ExitServer == false) {
            LAB_00047684:
                sVar7 = strlen(strSendbuf);
                uVar12 = 0;
                do {
                    sVar8 = send((int)param, strSendbuf + uVar12,
                                 sVar7 - uVar12, 0);
                    if (sVar8 == -1) {
                        piVar9 = __errno_location();
                        if (*piVar9 != 0xb) {
                        LAB_000476ea:
                            close((int)param);
                            if (opt_debug == false) {
                                return (void *)0x0;
                            }
                            if (((use_syslog == false) &&
                                 (opt_log_output == false)) &&
                                (opt_log_level < 7)) {
                                return (void *)0x0;
                            }
                            tmp42_10[0] = 's';
                            tmp42_10[1] = 't';
                            tmp42_10[2] = 'a';
                            tmp42_10[3] = 't';
                            tmp42_10[4] = 'u';
                            tmp42_10[5] = 's';
                            tmp42_10[6] = 'S';
                            tmp42_10[7] = 'e';
                            tmp42_10[8] = 'r';
                            tmp42_10[9] = 'v';
                            tmp42_10[10] = 'i';
                            tmp42_10[0xb] = 'c';
                            tmp42_10[0xc] = 'e';
                            tmp42_10[0xd] = 'T';
                            tmp42_10[0xe] = 'h';
                            tmp42_10[0xf] = 'r';
                            tmp42_10[0x10] = 'e';
                            tmp42_10[0x11] = 'a';
                            tmp42_10[0x12] = 'd';
                            tmp42_10[0x13] = ' ';
                            tmp42_10[0x14] = 's';
                            tmp42_10[0x15] = 'e';
                            tmp42_10[0x16] = 'n';
                            tmp42_10[0x17] = 'd';
                            tmp42_10[0x18] = ' ';
                            tmp42_10[0x19] = 'h';
                            tmp42_10[0x1a] = 't';
                            tmp42_10[0x1b] = 't';
                            tmp42_10[0x1c] = 'p';
                            tmp42_10[0x1d] = ' ';
                            tmp42_10[0x1e] = 'r';
                            tmp42_10[0x1f] = 'e';
                            tmp42_10[0x20] = 's';
                            tmp42_10[0x21] = 'p';
                            tmp42_10[0x22] = 'o';
                            tmp42_10[0x23] = 'n';
                            tmp42_10[0x24] = 's';
                            tmp42_10[0x25] = 'e';
                            tmp42_10[0x26] = ' ';
                            tmp42_10[0x27] = 'e';
                            tmp42_10[0x28] = 'r';
                            tmp42_10[0x29] = 'r';
                            tmp42_10[0x2a] = 'o';
                            tmp42_10[0x2b] = 'r';
                            pcVar3 = tmp42_10;
                            pcVar2 = tmp42_10;
                            goto LAB_000471da;
                        }
                        if ((opt_debug != false) &&
                            (((use_syslog != false ||
                               (opt_log_output != false)) ||
                              (6 < opt_log_level)))) {
                            builtin_strncpy(tmp42_10,
                                            "statusServiceThread send http "
                                            "timeout, try again...",
                                            0x34);
                            _applog(7, tmp42_10, false);
                        }
                        usleep(100000);
                    } else {
                        if (sVar8 < 1)
                            goto LAB_000476ea;
                        uVar12 = uVar12 + sVar8;
                    }
                    sVar7 = strlen(strSendbuf);
                } while ((uVar12 < sVar7) && (ExitServer == false));
                goto LAB_00047744;
            }
        } else {
            builtin_strncpy(tmp42_10, "send http response...\n", 0x17);
            tmp42_10[0x17] = SUB41(uVar1, 3);
            _applog(7, tmp42_10, false);
            if (ExitServer == false)
                goto LAB_00047684;
        LAB_00047744:
            if (opt_debug == false)
                goto LAB_0004774c;
        }
        if (((use_syslog != false) || (opt_log_output != false)) ||
            (6 < opt_log_level)) {
            builtin_strncpy(tmp42_10, "send http data..", 0x10);
            tmp42_10[0x10] = '.';
            tmp42_10[0x11] = '\0';
            _applog(7, tmp42_10, false);
        }
    }
LAB_0004774c:
    pvVar11 = (void *)0x0;
    while (true) {
        sVar8 = send((int)param, buf + (int)pvVar11, sVar4 - (int)pvVar11, 0);
        if ((opt_debug != false) &&
            (((use_syslog != false || (opt_log_output != false)) ||
              (6 < opt_log_level)))) {
            snprintf(tmp42_10, 0x1000, "send http data ret=%d", sVar8);
            _applog(7, tmp42_10, false);
        }
        if (sVar8 < 1)
            break;
        pvVar11 = (void *)((int)pvVar11 + sVar8);
        if (((int)sVar4 <= (int)pvVar11) || (ExitServer != false))
            goto LAB_000477dc;
    }
    if (opt_debug == false)
        goto LAB_0004782e;
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 7))
        goto LAB_000477f4;
    builtin_strncpy(tmp42_10, "statusServiceThread send http data error", 0x28);
    tmp42_10._40_4_ = tmp42_10._40_4_ & 0xffffff00;
    _applog(7, tmp42_10, false);
LAB_000477dc:
    if (opt_debug != false) {
        if (use_syslog == false) {
        LAB_000477f4:
            if ((opt_log_output == false) && (opt_log_level < 7))
                goto LAB_0004782e;
        }
        builtin_strncpy(tmp42_10, "one client disconnected!", 0x18);
        tmp42_10._24_4_ = tmp42_10._24_4_ & 0xffffff00;
        _applog(7, tmp42_10, false);
    }
LAB_0004782e:
    close((int)param);
    return pvVar11;
}

/* WARNING: Restarted to delay deadcode elimination for space: ram */
/* WARNING: Unknown calling convention */

void *httpListenThread(void *param)

{
    undefined4 uVar1;
    int iVar2;
    void *param_00;
    int addr_len;
    undefined4 local_104c;
    sockaddr_in service;
    sockaddr_in client_addr;
    char tmp42[4096];

    sleep(0x1e);
    do {
        listen_sockfd = socket(2, 1, 6);
        uVar1 = tmp42._44_4_;
        if (listen_sockfd < 0) {
            if (((use_syslog != false) || (opt_log_output != false)) ||
                (4 < opt_log_level)) {
                builtin_strncpy(
                    tmp42, "socket creating failed, try again after 10s...",
                    0x2f);
                tmp42[0x2f] = SUB41(uVar1, 3);
                _applog(5, tmp42, false);
            }
            sleep(10);
        } else {
            local_104c = 1;
            iVar2 = setsockopt(listen_sockfd, 1, 2, &local_104c, 4);
            if ((iVar2 < 0) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (3 < opt_log_level)))) {
                builtin_strncpy(
                    tmp42, "*******************setsockopt(SO_REUSEADDR) fail",
                    0x30);
                tmp42[0x30] = 'e';
                tmp42[0x31] = 'd';
                tmp42[0x32] = '\0';
                _applog(4, tmp42, false);
            }
            service.sin_addr.s_addr = 0;
            service.sin_zero[0] = '\0';
            service.sin_zero[1] = '\0';
            service.sin_zero[2] = '\0';
            service.sin_zero[3] = '\0';
            service.sin_zero[4] = '\0';
            service.sin_zero[5] = '\0';
            service.sin_zero[6] = '\0';
            service.sin_zero[7] = '\0';
            service.sin_family = 2;
            service.sin_port = 0xac17;
            iVar2 = bind(listen_sockfd, (sockaddr *)&service, 0x10);
            uVar1 = tmp42._44_4_;
            if (iVar2 < 0) {
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    builtin_strncpy(
                        tmp42, "http port bind failed! try again after 10s...",
                        0x2e);
                    tmp42._46_2_ = SUB42(uVar1, 2);
                    _applog(5, tmp42, false);
                }
            } else {
                iVar2 = listen(listen_sockfd, 100);
                uVar1 = tmp42._40_4_;
                if (-1 < iVar2)
                    break;
                if (((use_syslog != false) || (opt_log_output != false)) ||
                    (4 < opt_log_level)) {
                    builtin_strncpy(
                        tmp42, "http listen failed! try again after 10s...",
                        0x2b);
                    tmp42[0x2b] = SUB41(uVar1, 3);
                    _applog(5, tmp42, false);
                }
            }
            close(listen_sockfd);
            listen_sockfd = -1;
            sleep(10);
        }
    } while (ExitServer == false);
    if (((use_syslog != false) || (opt_log_output != false)) ||
        (4 < opt_log_level)) {
        builtin_strncpy(tmp42, "start listen on 6060 ...", 0x18);
        tmp42._24_4_ = tmp42._24_4_ & 0xffffff00;
        _applog(5, tmp42, false);
    }
    if (ExitServer == false) {
        do {
            while (true) {
                usleep(10000);
                addr_len = 0x10;
                param_00 =
                    (void *)accept(listen_sockfd, (sockaddr *)&client_addr,
                                   (socklen_t *)&addr_len);
                if (param_00 != (void *)0xffffffff)
                    break;
                if (ExitServer != false)
                    goto LAB_00047b42;
            }
            if (ExitServer != false) {
                close((int)param_00);
                break;
            }
            if ((opt_debug != false) &&
                (((use_syslog != false || (opt_log_output != false)) ||
                  (6 < opt_log_level)))) {
                snprintf(tmp42, 0x1000, "one client connected sock=%d",
                         param_00);
                _applog(7, tmp42, false);
            }
            statusServiceThread(param_00);
        } while (ExitServer == false);
    }
LAB_00047b42:
    close(listen_sockfd);
    listen_sockfd = -1;
    return (void *)0x0;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void start_http_thread(void)

{
    int iVar1;
    pthread_t tid_ctrl;
    pthread_attr_t tattr_ctrl;
    char tmp42[4096];

    pthread_attr_init((pthread_attr_t *)&tattr_ctrl);
    pthread_attr_setstacksize((pthread_attr_t *)&tattr_ctrl, 0x200000);
    iVar1 = pthread_create(&tid_ctrl, (pthread_attr_t *)&tattr_ctrl,
                           (__start_routine *)0x479ed, (void *)0x0);
    if (((use_syslog == false) && (opt_log_output == false)) &&
        (opt_log_level < 5)) {
        return;
    }
    snprintf(tmp42, 0x1000, "httpListenThread start ret=%d", iVar1);
    _applog(5, tmp42, false);
    return;
}

/* WARNING: Unknown calling convention */

void xxtea_encode(uint32_t *v, int n, uint32_t *key)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint32_t *puVar6;
    uint uVar7;
    char tmp42[4096];

    if (n < 2) {
        if (((use_syslog) || (opt_log_output)) || (2 < opt_log_level)) {
            builtin_strncpy(tmp42, "XXTEA encode failes, N <= 1 found.\n",
                            0x24);
            _applog(3, tmp42, false);
            return;
        }
    } else {
        uVar4 = v[n + 0x3fffffff];
        iVar1 = __aeabi_idiv(0x34);
        uVar7 = 0;
        do {
            uVar5 = 0;
            uVar7 = uVar7 + 0x9e3779b9;
            puVar6 = v;
            do {
                uVar2 = puVar6[1];
                uVar3 = uVar7 >> 2 ^ uVar5;
                uVar5 = uVar5 + 1;
                uVar4 = *puVar6 +
                        ((key[uVar3 & 3] ^ uVar4) + (uVar7 ^ uVar2) ^
                         (uVar2 << 2 ^ uVar4 >> 5) + (uVar4 << 4 ^ uVar2 >> 3));
                *puVar6 = uVar4;
                puVar6 = puVar6 + 1;
            } while (uVar5 != n - 1U);
            uVar5 = *v;
            uVar4 =
                ((uVar4 ^ key[(uVar7 >> 2 ^ n - 1U) & 3]) + (uVar7 ^ uVar5) ^
                 (uVar5 << 2 ^ uVar4 >> 5) + (uVar4 * 0x10 ^ uVar5 >> 3)) +
                v[n + 0x3fffffff];
            v[n + 0x3fffffff] = uVar4;
        } while (uVar7 != iVar1 * -0x61c88647 + 0xb54cda56U);
    }
    return;
}

/* WARNING: Unknown calling convention */

void xxtea_decode(uint32_t *v, int n, uint32_t *key)

{
    int iVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    uint32_t *puVar7;
    uint uVar8;
    char tmp42[4096];

    if (n < 2) {
        if (((use_syslog) || (opt_log_output)) || (2 < opt_log_level)) {
            builtin_strncpy(tmp42, "XXTEA decode failes, N <= 1 found.\n",
                            0x24);
            _applog(3, tmp42, false);
            return;
        }
    } else {
        iVar1 = __aeabi_idiv(0x34);
        uVar3 = (iVar1 + 6) * -0x61c88647;
        uVar4 = *v;
        iVar1 = iVar1 * 0x61c88647 + uVar3;
        do {
            uVar8 = uVar3 >> 2;
            uVar6 = n - 1;
            puVar7 = v + n + 0x3fffffff;
            do {
                uVar2 = puVar7[-1];
                uVar5 = uVar8 ^ uVar6;
                uVar6 = uVar6 - 1;
                uVar4 = *puVar7 -
                        ((uVar2 ^ key[uVar5 & 3]) + (uVar3 ^ uVar4) ^
                         (uVar4 << 2 ^ uVar2 >> 5) + (uVar2 << 4 ^ uVar4 >> 3));
                *puVar7 = uVar4;
                puVar7 = puVar7 + -1;
            } while (uVar6 != 0);
            uVar6 = v[n + 0x3fffffff];
            uVar2 = uVar4 ^ uVar3;
            uVar3 = uVar3 + 0x61c88647;
            uVar4 = *v - ((uVar6 << 4 ^ uVar4 >> 3) + (uVar4 * 4 ^ uVar6 >> 5) ^
                          (uVar6 ^ key[uVar8 & 3]) + uVar2);
            *v = uVar4;
        } while (uVar3 != iVar1 + 0x4ab325aaU);
    }
    return;
}

/* WARNING: Unknown calling convention */

int object_key_compare_serials(void *key1, void *key2)

{
    size_t a;
    size_t b;

    /* WARNING: Load size is inaccurate */
    a = *key1;
    /* WARNING: Load size is inaccurate */
    if (a < *key2) {
        return -1;
    }
    return (uint)(a != *key2);
}

/* WARNING: Unknown calling convention */

int dump_to_strbuffer(char *buffer, size_t size, void *data)

{
    int iVar1;

    iVar1 = strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
    return iVar1;
}

/* WARNING: Unknown calling convention */

int dump_to_file(char *buffer, size_t size, void *data)

{
    size_t sVar1;
    int iVar2;

    sVar1 = fwrite(buffer, size, 1, (FILE *)data);
    iVar2 = sVar1 - 1;
    if (iVar2 != 0) {
        iVar2 = -1;
    }
    return iVar2;
}

/* WARNING: Unknown calling convention */

int object_key_compare_keys(void *key1, void *key2)

{
    int iVar1;

    iVar1 = strcmp(*(char **)((int)key1 + 4), *(char **)((int)key2 + 4));
    return iVar1;
}

/* WARNING: Unknown calling convention */

int dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump,
                void *data)

{
    int iVar1;
    int iVar2;

    if ((flags & 0x1f) == 0) {
        if ((space != 0) && (-1 < (int)(flags << 0x1a))) {
            /* WARNING: Could not recover jumptable at 0x00048058. Too many
             * branches */
            /* WARNING: Treating indirect jump as call */
            iVar1 = (*dump)(" ", 1, data);
            return iVar1;
        }
    } else {
        iVar1 = (*dump)("\n", 1, data);
        if (iVar1 != 0) {
            return -1;
        }
        if (0 < depth) {
            iVar1 = 0;
            do {
                iVar1 = iVar1 + 1;
                iVar2 = (*dump)("                                ",
                                flags & 0x1f, data);
                if (iVar2 != 0) {
                    return -1;
                }
            } while (depth != iVar1);
        }
    }
    return 0;
}

/* WARNING: Unknown calling convention */

int dump_string(char *str, json_dump_callback_t dump, void *data, size_t flags)

{
    int iVar1;
    char *pcVar2;
    char *pcVar3;
    size_t sVar4;
    uint uVar5;
    int32_t codepoint;
    char seq[13];

    iVar1 = (*dump)("\"", 1, data);
    if (iVar1 == 0) {
        pcVar2 = str;
        do {
            do {
                pcVar3 = pcVar2;
                if (*pcVar3 == '\0') {
                    if ((pcVar3 != str) &&
                        (iVar1 = (*dump)(str, (int)pcVar3 - (int)str, data),
                         iVar1 != 0)) {
                        return -1;
                    }
                LAB_000481e8:
                    iVar1 = (*dump)("\"", 1, data);
                    return iVar1;
                }
                pcVar2 = utf8_iterate(pcVar3, &codepoint);
                if (pcVar2 == (char *)0x0) {
                    return -1;
                }
            } while (((0x1f < codepoint &&
                       (codepoint != 0x22 && codepoint != 0x5c)) &&
                      (((uint)(codepoint == 0x2f) & flags >> 10) == 0)) &&
                     (((uint)(0x7f < codepoint) & flags >> 6) == 0));
            if ((pcVar3 != str) &&
                (iVar1 = (*dump)(str, (int)pcVar3 - (int)str, data),
                 iVar1 != 0)) {
                return -1;
            }
            if (pcVar3 == pcVar2)
                goto LAB_000481e8;
            if (codepoint == 0xc) {
                sVar4 = 2;
                pcVar3 = "\\f";
            } else if (codepoint < 0xd) {
                if (codepoint == 9) {
                    sVar4 = 2;
                    pcVar3 = "\\t";
                } else if (codepoint == 10) {
                    sVar4 = 2;
                    pcVar3 = "\\n";
                } else if (codepoint == 8) {
                    sVar4 = 2;
                    pcVar3 = "\\b";
                } else {
                LAB_00048130:
                    if (codepoint < 0x10000)
                        goto LAB_00048136;
                LAB_0004815a:
                    iVar1 = codepoint + -0x10000;
                    uVar5 = codepoint & 0x3ff;
                    codepoint = iVar1;
                    sprintf(seq, "\\u%04x\\u%04x",
                            (uint)(iVar1 * 0x1000) >> 0x16 | 0xd800,
                            uVar5 | 0xdc00);
                    sVar4 = 0xc;
                    pcVar3 = seq;
                }
            } else if (codepoint == 0x22) {
                sVar4 = 2;
                pcVar3 = "\\\"";
            } else if (codepoint < 0x23) {
                if (codepoint == 0xd) {
                    sVar4 = 2;
                    pcVar3 = "\\r";
                } else {
                    if (0xffff < codepoint)
                        goto LAB_0004815a;
                LAB_00048136:
                    sprintf(seq, "\\u%04x");
                    sVar4 = 6;
                    pcVar3 = seq;
                }
            } else if (codepoint == 0x2f) {
                sVar4 = 2;
                pcVar3 = "\\/";
            } else {
                if (codepoint != 0x5c)
                    goto LAB_00048130;
                sVar4 = 2;
                pcVar3 = "\\\\";
            }
            iVar1 = (*dump)(pcVar3, sVar4, data);
            str = pcVar2;
        } while (iVar1 == 0);
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int do_dump(json_t *json, size_t flags, int depth, json_dump_callback_t dump,
            void *data)

{
    int iVar1;
    void *pvVar2;
    char *pcVar3;
    size_t sVar4;
    size_t sVar5;
    void *pvVar6;
    char *pcVar7;
    json_t *pjVar8;
    __compar_fn_t __compar;
    uint __nmemb;
    size_t sVar9;
    undefined4 *puVar10;
    uint uVar11;
    int iVar12;
    uint uVar13;
    double value;
    char buffer[100];

    if (json == (json_t *)0x0) {
        return -1;
    }
    switch (json->type) {
    case JSON_OBJECT:
        pcVar3 = ": ";
        if ((flags & 0x20) == 0) {
            sVar4 = 2;
        } else {
            sVar4 = 1;
            pcVar3 = ":";
        }
        if (json[4].type == JSON_OBJECT) {
            json[4].type = JSON_ARRAY;
            pvVar2 = json_object_iter(json);
            iVar1 = (*dump)("{", 1, data);
            if (iVar1 == 0) {
                if (pvVar2 == (void *)0x0) {
                    json[4].type = JSON_OBJECT;
                    iVar1 = (*dump)("}", 1, data);
                    return iVar1;
                }
                iVar12 = depth + 1;
                iVar1 = dump_indent(flags, iVar12, 0, dump, data);
                if (iVar1 == 0) {
                    if ((flags & 0x180) == 0) {
                        while (true) {
                            pvVar6 = json_object_iter_next(json, pvVar2);
                            pcVar7 = json_object_iter_key(pvVar2);
                            dump_string(pcVar7, dump, data, flags);
                            iVar1 = (*dump)(pcVar3, sVar4, data);
                            if (iVar1 != 0)
                                break;
                            pjVar8 = json_object_iter_value(pvVar2);
                            iVar1 = do_dump(pjVar8, flags, iVar12, dump, data);
                            if (iVar1 != 0)
                                break;
                            if (pvVar6 == (void *)0x0) {
                                iVar1 =
                                    dump_indent(flags, depth, 0, dump, data);
                                if (iVar1 == 0)
                                    goto LAB_0004860a;
                                break;
                            }
                            iVar1 = (*dump)(",", 1, data);
                            if ((iVar1 != 0) ||
                                (iVar1 =
                                     dump_indent(flags, iVar12, 1, dump, data),
                                 pvVar2 = pvVar6, iVar1 != 0))
                                break;
                        }
                    } else {
                        sVar9 = json_object_size(json);
                        pvVar6 = jsonp_malloc(sVar9 << 3);
                        if (pvVar6 != (void *)0x0) {
                            puVar10 = (undefined4 *)((int)pvVar6 + 4);
                            __nmemb = 0;
                            do {
                                uVar13 = __nmemb;
                                __nmemb = uVar13 + 1;
                                sVar5 = hashtable_iter_serial(pvVar2);
                                puVar10[-1] = sVar5;
                                pcVar7 = json_object_iter_key(pvVar2);
                                *puVar10 = pcVar7;
                                pvVar2 = json_object_iter_next(json, pvVar2);
                                puVar10 = puVar10 + 2;
                            } while (pvVar2 != (void *)0x0);
                            if (sVar9 != __nmemb) {
                                /* WARNING: Subroutine does not return */
                                __assert_fail("i == size", "dump.c", 0x141,
                                              "do_dump");
                            }
                            __compar = (code *)0x47fa9;
                            if ((flags & 0x80) != 0) {
                                __compar = (__compar_fn_t)0x47fe5;
                            }
                            qsort(pvVar6, __nmemb, 8, __compar);
                            uVar11 = 0;
                            pvVar2 = pvVar6;
                            do {
                                pcVar7 = *(char **)((int)pvVar2 + 4);
                                pjVar8 = json_object_get(json, pcVar7);
                                if (pjVar8 == (json_t *)0x0) {
                                    /* WARNING: Subroutine does not return */
                                    __assert_fail("value", "dump.c", 0x151,
                                                  "do_dump");
                                }
                                dump_string(pcVar7, dump, data, flags);
                                iVar1 = (*dump)(pcVar3, sVar4, data);
                                if ((iVar1 != 0) ||
                                    (iVar1 = do_dump(pjVar8, flags, iVar12,
                                                     dump, data),
                                     iVar1 != 0)) {
                                LAB_0004848e:
                                    jsonp_free(pvVar6);
                                    goto LAB_00048496;
                                }
                                if (uVar11 < uVar13) {
                                    iVar1 = (*dump)(",", 1, data);
                                    if (iVar1 != 0)
                                        goto LAB_0004848e;
                                    iVar1 = dump_indent(flags, iVar12, 1, dump,
                                                        data);
                                } else {
                                    iVar1 = dump_indent(flags, depth, 0, dump,
                                                        data);
                                }
                                if (iVar1 != 0)
                                    goto LAB_0004848e;
                                uVar11 = uVar11 + 1;
                                pvVar2 = (void *)((int)pvVar2 + 8);
                            } while (uVar11 != __nmemb);
                            jsonp_free(pvVar6);
                        LAB_0004860a:
                            json[4].type = JSON_OBJECT;
                            iVar1 = (*dump)("}", 1, data);
                            return iVar1;
                        }
                    }
                }
            }
        }
    LAB_00048496:
        iVar1 = -1;
        json[4].type = JSON_OBJECT;
        break;
    case JSON_ARRAY:
        if (json[2].refcount == 0) {
            json[2].refcount = 1;
            sVar4 = json_array_size(json);
            iVar1 = (*dump)("[", 1, data);
            if (iVar1 == 0) {
                if (sVar4 == 0) {
                    json[2].refcount = 0;
                    iVar1 = (*dump)("]", 1, data);
                    return iVar1;
                }
                iVar12 = depth + 1;
                iVar1 = dump_indent(flags, iVar12, 0, dump, data);
                if (iVar1 == 0) {
                    if (0 < (int)sVar4) {
                        sVar9 = 0;
                        do {
                            pjVar8 = json_array_get(json, sVar9);
                            iVar1 = do_dump(pjVar8, flags, iVar12, dump, data);
                            if (iVar1 != 0)
                                goto LAB_0004854e;
                            if ((int)sVar9 < (int)(sVar4 - 1)) {
                                iVar1 = (*dump)(",", 1, data);
                                if (iVar1 != 0)
                                    goto LAB_0004854e;
                                iVar1 =
                                    dump_indent(flags, iVar12, 1, dump, data);
                            } else {
                                iVar1 =
                                    dump_indent(flags, depth, 0, dump, data);
                            }
                            if (iVar1 != 0)
                                goto LAB_0004854e;
                            sVar9 = sVar9 + 1;
                        } while (sVar4 != sVar9);
                    }
                    json[2].refcount = 0;
                    iVar1 = (*dump)("]", 1, data);
                    return iVar1;
                }
            }
        }
    LAB_0004854e:
        iVar1 = -1;
        json[2].refcount = 0;
        break;
    case JSON_STRING:
        pcVar3 = json_string_value(json);
        iVar1 = dump_string(pcVar3, dump, data, flags);
        return iVar1;
    case JSON_INTEGER:
        json_integer_value(json);
        sVar4 = snprintf(buffer, 100, "%lld");
        iVar1 = (*dump)(buffer, sVar4, data);
        return iVar1;
    case JSON_REAL:
        value = json_real_value(json);
        sVar4 = jsonp_dtostr(buffer, 100, value);
        if (-1 < (int)sVar4) {
            iVar1 = (*dump)(buffer, sVar4, data);
            return iVar1;
        }
    default:
        iVar1 = -1;
        break;
    case JSON_TRUE:
        iVar1 = (*dump)("true", 4, data);
        return iVar1;
    case JSON_FALSE:
        iVar1 = (*dump)("false", 5, data);
        return iVar1;
    case JSON_NULL:
        iVar1 = (*dump)("null", 4, data);
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

int json_dump_callback(json_t *json, json_dump_callback_t callback, void *data,
                       size_t flags)

{
    int iVar1;

    if (((int)(flags << 0x16) < 0) ||
        ((json != (json_t *)0x0 && (json->type < JSON_STRING)))) {
        iVar1 = do_dump(json, flags, 0, callback, data);
    } else {
        iVar1 = -1;
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

char *json_dumps(json_t *json, size_t flags)

{
    int iVar1;
    char *pcVar2;
    strbuffer_t strbuff;

    pcVar2 = (char *)0x0;
    iVar1 = strbuffer_init(&strbuff);
    if (iVar1 == 0) {
        iVar1 = json_dump_callback(json, (json_dump_callback_t)0x47fc1,
                                   &strbuff, flags);
        pcVar2 = (char *)0x0;
        if (iVar1 == 0) {
            pcVar2 = strbuffer_value(&strbuff);
            pcVar2 = jsonp_strdup(pcVar2);
        }
        strbuffer_close(&strbuff);
    }
    return pcVar2;
}

/* WARNING: Unknown calling convention */

int json_dumpf(json_t *json, FILE *output, size_t flags)

{
    int iVar1;

    iVar1 =
        json_dump_callback(json, (json_dump_callback_t)0x47fcd, output, flags);
    return iVar1;
}

/* WARNING: Unknown calling convention */

int json_dump_file(json_t *json, char *path, size_t flags)

{
    FILE *__stream;
    int iVar1;

    __stream = fopen(path, "w");
    if (__stream == (FILE *)0x0) {
        iVar1 = -1;
    } else {
        iVar1 = json_dump_callback(json, (json_dump_callback_t)0x47fcd,
                                   __stream, flags);
        fclose(__stream);
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

pair_t *hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, char *key,
                            size_t hash)

{
    int iVar1;
    hashtable_list *phVar2;

    phVar2 = bucket->first;
    if ((phVar2 != &hashtable->list) || (phVar2 != bucket->last)) {
        while (true) {
            if (phVar2[-1].next == (hashtable_list *)hash) {
                iVar1 = strcmp((char *)(phVar2 + 2), key);
                if (iVar1 == 0) {
                    return (pair_t *)&phVar2[-1].next;
                }
            }
            if (bucket->last == phVar2)
                break;
            phVar2 = phVar2->next;
        }
    }
    return (pair_t *)0x0;
}

/* WARNING: Unknown calling convention */

void hashtable_do_clear(hashtable_t *hashtable)

{
    hashtable_list *phVar1;
    hashtable_list *json;
    hashtable_list *phVar2;
    hashtable_list *phVar3;

    phVar3 = (hashtable->list).next;
    while (phVar3 != &hashtable->list) {
        json = phVar3[1].prev;
        phVar1 = phVar3 + -1;
        phVar3 = phVar3->next;
        if (((json != (hashtable_list *)0x0) &&
             (phVar2 = (hashtable_list *)((int)&json->next[-1].next + 3),
              json->next != (hashtable_list *)0xffffffff)) &&
            (json->next = phVar2, phVar2 == (hashtable_list *)0x0)) {
            json_delete((json_t *)json);
        }
        jsonp_free(&phVar1->next);
    }
    return;
}

/* WARNING: Unknown calling convention */

int hashtable_init(hashtable_t *hashtable)

{
    hashtable_bucket *phVar1;
    hashtable_bucket *phVar2;
    hashtable_bucket *phVar3;
    size_t sVar4;
    hashtable_list *phVar5;

    hashtable->size = 0;
    hashtable->num_buckets = 0;
    phVar1 = (hashtable_bucket *)jsonp_malloc(0x28);
    hashtable->buckets = phVar1;
    if (phVar1 != (hashtable_bucket *)0x0) {
        sVar4 = hashtable->num_buckets;
        phVar5 = &hashtable->list;
        (hashtable->list).next = phVar5;
        sVar4 = primes[sVar4];
        (hashtable->list).prev = phVar5;
        if (sVar4 != 0) {
            phVar2 = phVar1;
            do {
                phVar2->last = phVar5;
                phVar3 = phVar2 + 1;
                phVar2->first = phVar5;
                phVar2 = phVar3;
            } while (phVar3 != phVar1 + sVar4);
        }
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

void hashtable_close(hashtable_t *hashtable)

{
    hashtable_do_clear(hashtable);
    jsonp_free(hashtable->buckets);
    return;
}

/* WARNING: Unknown calling convention */

int hashtable_set(hashtable_t *hashtable, char *key, size_t serial,
                  json_t *value)

{
    pair_t *ppVar1;
    json_t *json;
    size_t sVar2;
    size_t *psVar3;
    hashtable_list *phVar4;
    size_t sVar5;
    int extraout_r1;
    int extraout_r1_00;
    byte *pbVar6;
    hashtable_list *phVar7;
    hashtable_bucket *phVar8;
    hashtable_bucket *phVar9;
    uint uVar10;
    size_t sVar11;
    hashtable_list *phVar12;
    size_t sVar13;
    hashtable_list *phVar14;
    hashtable_bucket *ptr;
    bucket_t *bucket;

    sVar5 = primes[hashtable->num_buckets];
    ptr = hashtable->buckets;
    if (sVar5 <= hashtable->size) {
        jsonp_free(ptr);
        sVar5 = hashtable->num_buckets + 1;
        sVar13 = primes[sVar5];
        hashtable->num_buckets = sVar5;
        ptr = (hashtable_bucket *)jsonp_malloc(sVar13 << 3);
        hashtable->buckets = ptr;
        if (ptr == (hashtable_bucket *)0x0) {
            return -1;
        }
        sVar11 = hashtable->num_buckets;
        phVar7 = &hashtable->list;
        sVar5 = primes[sVar11];
        if (sVar5 != 0) {
            phVar8 = ptr;
            do {
                phVar8->last = phVar7;
                phVar9 = phVar8 + 1;
                phVar8->first = phVar7;
                phVar8 = phVar9;
            } while (ptr + sVar5 != phVar9);
        }
        phVar14 = (hashtable->list).next;
        (hashtable->list).prev = phVar7;
        (hashtable->list).next = phVar7;
        if (phVar14 != phVar7) {
            do {
                while (true) {
                    __aeabi_uidivmod(phVar14[-1].next, sVar13);
                    phVar12 = ptr[extraout_r1_00].first;
                    phVar8 = ptr + extraout_r1_00;
                    phVar4 = phVar14->next;
                    if ((phVar12 != phVar7) || (phVar7 != phVar8->last))
                        break;
                    phVar14->prev = (hashtable->list).prev;
                    phVar14->next = phVar7;
                    ((hashtable->list).prev)->next = phVar14;
                    (hashtable->list).prev = phVar14;
                    phVar8->first = phVar14;
                    phVar8->last = phVar14;
                    phVar14 = phVar4;
                    if (phVar4 == phVar7)
                        goto LAB_00048956;
                }
                phVar14->prev = phVar12->prev;
                phVar14->next = phVar12;
                phVar12->prev->next = phVar14;
                phVar12->prev = phVar14;
                phVar8->first = phVar14;
                phVar14 = phVar4;
            } while (phVar4 != phVar7);
        LAB_00048956:
            ptr = hashtable->buckets;
            sVar5 = primes[sVar11];
        }
    }
    uVar10 = (uint)(byte)*key;
    sVar13 = 0x1505;
    if (uVar10 != 0) {
        sVar13 = 0x1505;
        pbVar6 = (byte *)key;
        do {
            sVar13 = uVar10 + sVar13 * 0x21;
            pbVar6 = pbVar6 + 1;
            uVar10 = (uint)*pbVar6;
        } while (uVar10 != 0);
    }
    __aeabi_uidivmod(sVar13, sVar5);
    bucket = ptr + extraout_r1;
    ppVar1 = hashtable_find_pair(hashtable, bucket, key, sVar13);
    if (ppVar1 == (pair_t *)0x0) {
        sVar2 = strlen(key);
        psVar3 = (size_t *)jsonp_malloc(sVar2 + 0x15);
        if (psVar3 == (size_t *)0x0) {
            return -1;
        }
        *psVar3 = sVar13;
        psVar3[4] = serial;
        strcpy((char *)(psVar3 + 5), key);
        phVar7 = bucket->first;
        phVar14 = (hashtable_list *)(psVar3 + 1);
        psVar3[2] = (size_t)phVar14;
        psVar3[3] = (size_t)value;
        psVar3[1] = (size_t)phVar14;
        if ((phVar7 == &hashtable->list) && (phVar7 == bucket->last)) {
            psVar3[1] = (size_t)(hashtable->list).prev;
            psVar3[2] = (size_t)phVar7;
            ((hashtable->list).prev)->next = phVar14;
            (hashtable->list).prev = phVar14;
            bucket->first = phVar14;
            bucket->last = phVar14;
        } else {
            psVar3[1] = (size_t)phVar7->prev;
            psVar3[2] = (size_t)phVar7;
            phVar7->prev->next = phVar14;
            phVar7->prev = phVar14;
            bucket->first = phVar14;
        }
        hashtable->size = hashtable->size + 1;
        return 0;
    }
    json = ppVar1->value;
    if (((json != (json_t *)0x0) && (json->refcount != 0xffffffff)) &&
        (sVar5 = json->refcount - 1, json->refcount = sVar5, sVar5 == 0)) {
        json_delete(json);
    }
    ppVar1->value = value;
    return 0;
}

/* WARNING: Unknown calling convention */

void *hashtable_get(hashtable_t *hashtable, char *key)

{
    pair_t *ppVar1;
    byte *pbVar2;
    int extraout_r1;
    uint uVar3;
    size_t hash;

    uVar3 = (uint)(byte)*key;
    hash = 0x1505;
    if (uVar3 != 0) {
        hash = 0x1505;
        pbVar2 = (byte *)key;
        do {
            hash = uVar3 + hash * 0x21;
            pbVar2 = pbVar2 + 1;
            uVar3 = (uint)*pbVar2;
        } while (uVar3 != 0);
    }
    __aeabi_uidivmod(hash, primes[hashtable->num_buckets]);
    ppVar1 = hashtable_find_pair(hashtable, hashtable->buckets + extraout_r1,
                                 key, hash);
    if (ppVar1 != (pair_t *)0x0) {
        ppVar1 = (pair_t *)ppVar1->value;
    }
    return ppVar1;
}

/* WARNING: Unknown calling convention */

int hashtable_del(hashtable_t *hashtable, char *key)

{
    pair_t *ptr;
    json_t *json;
    int iVar1;
    byte *pbVar2;
    int extraout_r1;
    hashtable_list *phVar3;
    hashtable_list *phVar4;
    uint uVar5;
    hashtable_list *phVar6;
    size_t sVar7;
    bucket_t *bucket;
    hashtable_bucket *phVar8;
    hashtable_list *phVar9;
    bool bVar10;

    uVar5 = (uint)(byte)*key;
    sVar7 = 0x1505;
    if (uVar5 != 0) {
        sVar7 = 0x1505;
        pbVar2 = (byte *)key;
        do {
            sVar7 = uVar5 + sVar7 * 0x21;
            pbVar2 = pbVar2 + 1;
            uVar5 = (uint)*pbVar2;
        } while (uVar5 != 0);
    }
    __aeabi_uidivmod(sVar7, primes[hashtable->num_buckets]);
    phVar8 = hashtable->buckets;
    bucket = phVar8 + extraout_r1;
    ptr = hashtable_find_pair(hashtable, bucket, key, sVar7);
    if (ptr == (pair_t *)0x0) {
        iVar1 = -1;
    } else {
        phVar4 = &ptr->list;
        phVar6 = (ptr->list).prev;
        phVar3 = (ptr->list).next;
        phVar9 = bucket->last;
        if (phVar4 == phVar8[extraout_r1].first) {
            bVar10 = phVar4 == phVar9;
            if (bVar10) {
                phVar4 = &hashtable->list;
            } else {
                phVar8[extraout_r1].first = phVar3;
            }
            if (bVar10) {
                bucket->last = phVar4;
                phVar8[extraout_r1].first = phVar4;
            }
        } else if (phVar4 == phVar9) {
            bucket->last = phVar6;
        }
        json = ptr->value;
        phVar6->next = phVar3;
        ((ptr->list).next)->prev = phVar6;
        if (((json != (json_t *)0x0) && (json->refcount != 0xffffffff)) &&
            (sVar7 = json->refcount - 1, json->refcount = sVar7, sVar7 == 0)) {
            json_delete(json);
        }
        jsonp_free(ptr);
        iVar1 = 0;
        hashtable->size = hashtable->size - 1;
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

void hashtable_clear(hashtable_t *hashtable)

{
    size_t sVar1;
    hashtable_list *phVar2;
    hashtable_bucket *phVar3;
    hashtable_bucket *phVar4;
    hashtable_bucket *phVar5;

    hashtable_do_clear(hashtable);
    phVar2 = &hashtable->list;
    sVar1 = primes[hashtable->num_buckets];
    if (sVar1 != 0) {
        phVar3 = hashtable->buckets;
        phVar4 = phVar3;
        do {
            phVar4->last = phVar2;
            phVar5 = phVar4 + 1;
            phVar4->first = phVar2;
            phVar4 = phVar5;
        } while (phVar3 + sVar1 != phVar5);
    }
    (hashtable->list).prev = phVar2;
    (hashtable->list).next = phVar2;
    hashtable->size = 0;
    return;
}

/* WARNING: Unknown calling convention */

void *hashtable_iter(hashtable_t *hashtable)

{
    hashtable_list *phVar1;

    phVar1 = (hashtable->list).next;
    if (phVar1 == &hashtable->list) {
        phVar1 = (hashtable_list *)0x0;
    }
    return phVar1;
}

/* WARNING: Unknown calling convention */

void *hashtable_iter_at(hashtable_t *hashtable, char *key)

{
    pair_t *ppVar1;
    byte *pbVar2;
    int extraout_r1;
    uint uVar3;
    size_t hash;

    uVar3 = (uint)(byte)*key;
    hash = 0x1505;
    if (uVar3 != 0) {
        hash = 0x1505;
        pbVar2 = (byte *)key;
        do {
            hash = uVar3 + hash * 0x21;
            pbVar2 = pbVar2 + 1;
            uVar3 = (uint)*pbVar2;
        } while (uVar3 != 0);
    }
    __aeabi_uidivmod(hash, primes[hashtable->num_buckets]);
    ppVar1 = hashtable_find_pair(hashtable, hashtable->buckets + extraout_r1,
                                 key, hash);
    if (ppVar1 != (pair_t *)0x0) {
        ppVar1 = (pair_t *)&ppVar1->list;
    }
    return ppVar1;
}

/* WARNING: Unknown calling convention */

void *hashtable_iter_next(hashtable_t *hashtable, void *iter)

{
    undefined1 *puVar1;

    puVar1 = *(undefined1 **)((int)iter + 4);
    if ((hashtable_list *)puVar1 == &hashtable->list) {
        puVar1 = (undefined1 *)0x0;
    }
    return puVar1;
}

/* WARNING: Unknown calling convention */

void *hashtable_iter_key(void *iter)

{
    return (void *)((int)iter + 0x10);
}

/* WARNING: Unknown calling convention */

size_t hashtable_iter_serial(void *iter)

{
    return *(size_t *)((int)iter + 0xc);
}

/* WARNING: Unknown calling convention */

void *hashtable_iter_value(void *iter)

{
    return *(void **)((int)iter + 8);
}

/* WARNING: Unknown calling convention */

void hashtable_iter_set(void *iter, json_t *value)

{
    json_t *json;
    size_t sVar1;

    json = *(json_t **)((int)iter + 8);
    if (((json != (json_t *)0x0) && (json->refcount != 0xffffffff)) &&
        (sVar1 = json->refcount - 1, json->refcount = sVar1, sVar1 == 0)) {
        json_delete(json);
        *(json_t **)((int)iter + 8) = value;
        return;
    }
    *(json_t **)((int)iter + 8) = value;
    return;
}

/* WARNING: Unknown calling convention */

int string_get(void *data)

{
    uint uVar1;

    /* WARNING: Load size is inaccurate */
    uVar1 = (uint) * (byte *)(*data + *(int *)((int)data + 4));
    if (uVar1 == 0) {
        uVar1 = 0xffffffff;
    } else {
        *(int *)((int)data + 4) = *(int *)((int)data + 4) + 1;
    }
    return uVar1;
}

/* WARNING: Unknown calling convention */

int buffer_get(void *data)

{
    uint uVar1;
    char c;
    bool bVar2;

    uVar1 = *(uint *)((int)data + 4);
    _c = *(uint *)((int)data + 8);
    bVar2 = _c < uVar1;
    /* WARNING: Load size is inaccurate */
    if (bVar2) {
        uVar1 = _c + 1;
        _c = (uint) * (byte *)(*data + _c);
    }
    if (bVar2) {
        *(uint *)((int)data + 8) = uVar1;
    } else {
        _c = 0xffffffff;
    }
    return _c;
}

/* WARNING: Unknown calling convention */

int callback_get(void *data)

{
    byte bVar1;
    int iVar2;
    uint uVar3;

    uVar3 = *(uint *)((int)data + 0x404);
    if (*(uint *)((int)data + 0x400) <= uVar3) {
        *(undefined4 *)((int)data + 0x404) = 0;
        iVar2 = (**(code **)((int)data + 0x408))(
            data, 0x400, *(undefined4 *)((int)data + 0x40c));
        *(int *)((int)data + 0x400) = iVar2;
        if (0xfffffffd < iVar2 - 1U) {
            return -1;
        }
        uVar3 = *(uint *)((int)data + 0x404);
    }
    bVar1 = *(byte *)((int)data + uVar3);
    *(uint *)((int)data + 0x404) = uVar3 + 1;
    return (uint)bVar1;
}

void error_set(json_error_t *error, lex_t *lex, char *msg, ...)

{
    char *pcVar1;
    undefined4 in_r3;
    int column;
    int line;
    size_t position;
    va_list ap;
    char msg_text[160];
    char msg_with_context[160];
    char *msg_local;
    undefined4 uStack_4;

    if (error == (json_error_t *)0x0) {
        return;
    }
    uStack_4 = in_r3;
    vsnprintf(msg_text, 0xa0, msg, &uStack_4);
    msg_text[0x9f] = '\0';
    if (lex == (lex_t *)0x0) {
        column = -1;
        pcVar1 = msg_text;
        line = -1;
        position = 0;
    } else {
        pcVar1 = strbuffer_value(&lex->saved_text);
        line = (lex->stream).line;
        column = (lex->stream).column;
        position = (lex->stream).position;
        if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\0')) {
            if ((lex->stream).state != -2) {
                snprintf(msg_with_context, 0xa0, "%s near end of file",
                         msg_text);
                pcVar1 = msg_with_context;
                msg_with_context[0x9f] = '\0';
                goto LAB_00048c2a;
            }
        } else if ((lex->saved_text).length < 0x15) {
            snprintf(msg_with_context, 0xa0, "%s near \'%s\'", msg_text,
                     pcVar1);
            pcVar1 = msg_with_context;
            msg_with_context[0x9f] = '\0';
            goto LAB_00048c2a;
        }
        pcVar1 = msg_text;
    }
LAB_00048c2a:
    jsonp_error_set(error, line, column, position, "%s", pcVar1);
    return;
}

/* WARNING: Unknown calling convention */

void lex_close(lex_t *lex)

{
    if (lex->token != 0x100) {
        strbuffer_close(&lex->saved_text);
        return;
    }
    jsonp_free((lex->value).string);
    strbuffer_close(&lex->saved_text);
    return;
}

/* WARNING: Unknown calling convention */

int32_t decode_unicode_escape(char *str)

{
    int iVar1;
    uint uVar2;
    byte *pbVar3;

    if (*str != 'u') {
        /* WARNING: Subroutine does not return */
        __assert_fail("str[0] == \'u\'", "load.c", 0x120,
                      "decode_unicode_escape");
    }
    iVar1 = 0;
    pbVar3 = (byte *)(str + 4);
    do {
        str = (char *)((byte *)str + 1);
        uVar2 = (uint)(byte)*str;
        iVar1 = iVar1 * 0x10;
        if ((uVar2 - 0x30 & 0xff) < 10) {
            iVar1 = iVar1 + (uVar2 - 0x30);
        } else if (uVar2 - 0x61 < 0x1a) {
            iVar1 = iVar1 + (uVar2 - 0x57);
        } else {
            if (0x19 < uVar2 - 0x41) {
                /* WARNING: Subroutine does not return */
                __assert_fail("0", "load.c", 300, "decode_unicode_escape");
            }
            iVar1 = iVar1 + (uVar2 - 0x37);
        }
    } while ((byte *)str != pbVar3);
    return iVar1;
}

/* WARNING: Unknown calling convention */

void stream_unget(stream_t *stream, int c)

{
    int iVar1;
    size_t sVar2;

    if (1 < c + 2U) {
        stream->position = stream->position - 1;
        if (c == 10) {
            stream->line = stream->line + -1;
            stream->column = stream->last_column;
        } else {
            iVar1 = utf8_check_first((char)c);
            if (iVar1 != 0) {
                stream->column = stream->column + -1;
            }
        }
        sVar2 = stream->buffer_pos;
        if (sVar2 == 0) {
            /* WARNING: Subroutine does not return */
            __assert_fail("stream->buffer_pos > 0", "load.c", 0xe0,
                          "stream_unget");
        }
        stream->buffer_pos = sVar2 - 1;
        if ((uint)(byte)stream->buffer[sVar2 - 1] != c) {
            /* WARNING: Subroutine does not return */
            __assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c",
                          0xe2, "stream_unget");
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

int stream_get(stream_t *stream, json_error_t *error)

{
    byte byte;
    int size;
    int iVar1;
    size_t sVar2;
    stream_t *extraout_r2;
    stream_t *psVar3;
    char *pcVar4;
    char *pcVar5;
    int iVar6;

    psVar3 = (stream_t *)(stream->buffer + (stream->buffer_pos - 8));
    if (psVar3->buffer[0] == '\0') {
        _iVar6 = (*stream->get)(stream->data);
        sVar2 = (size_t)((ulonglong)_iVar6 >> 0x20);
        iVar6 = (int)_iVar6;
        if (iVar6 == -1) {
            stream->state = -1;
            return -1;
        }
        stream->buffer_pos = 0;
        stream->buffer[0] = (char)_iVar6;
        psVar3 = extraout_r2;
        if (0x7f < iVar6 - 0x80U) {
            sVar2 = 1;
            psVar3 = stream;
        }
        if (iVar6 - 0x80U < 0x80) {
            size = utf8_check_first((char)_iVar6);
            if (size != 0) {
                if (size < 2) {
                    /* WARNING: Subroutine does not return */
                    __assert_fail("count >= 2", "load.c", 0xaf, "stream_get");
                }
                pcVar4 = stream->buffer + 1;
                do {
                    iVar1 = (*stream->get)(stream->data);
                    pcVar5 = pcVar4 + 1;
                    *pcVar4 = (char)iVar1;
                    pcVar4 = pcVar5;
                } while (stream->buffer + size != pcVar5);
                iVar1 = utf8_check_full(stream->buffer, size, (int32_t *)0x0);
                if (iVar1 != 0) {
                    stream->buffer[size] = '\0';
                    sVar2 = stream->buffer_pos + 1;
                    psVar3 =
                        (stream_t *)(stream->buffer + (stream->buffer_pos - 8));
                    goto LAB_00048df0;
                }
            }
            stream->state = -2;
            error_set(error, (lex_t *)stream, "unable to decode byte 0x%x",
                      iVar6);
            return -2;
        }
        stream->buffer[1] = '\0';
    } else {
        sVar2 = stream->buffer_pos + 1;
    }
LAB_00048df0:
    stream->buffer_pos = sVar2;
    byte = psVar3->buffer[0];
    stream->position = stream->position + 1;
    if (byte != 10) {
        iVar6 = utf8_check_first(byte);
        if (iVar6 != 0) {
            stream->column = stream->column + 1;
        }
        return (uint)byte;
    }
    iVar6 = stream->column;
    stream->column = 0;
    stream->line = stream->line + 1;
    stream->last_column = iVar6;
    return 10;
}

/* WARNING: Unknown calling convention */

int lex_get_save(lex_t *lex, json_error_t *error)

{
    int iVar1;

    iVar1 = (lex->stream).state;
    if (iVar1 == 0) {
        iVar1 = stream_get(&lex->stream, error);
    }
    if (1 < iVar1 + 2U) {
        strbuffer_append_byte(&lex->saved_text, (char)iVar1);
    }
    return iVar1;
}

/* WARNING: Unknown calling convention */

void lex_unget_unsave(lex_t *lex, int c)

{
    char cVar1;

    if (1 < c + 2U) {
        stream_unget(&lex->stream, c);
        cVar1 = strbuffer_pop(&lex->saved_text);
        if (cVar1 != c) {
            /* WARNING: Subroutine does not return */
            __assert_fail("c == d", "load.c", 0x10c, "lex_unget_unsave");
        }
    }
    return;
}

/* WARNING: Unknown calling convention */

int lex_scan(lex_t *lex, json_error_t *error)

{
    char byte;
    char *pcVar1;
    int iVar2;
    int *piVar3;
    byte *__dest;
    int32_t codepoint;
    int32_t iVar4;
    byte bVar5;
    size_t sVar6;
    uint uVar7;
    uint uVar8;
    strbuffer_t *strbuff;
    byte *pbVar9;
    bool bVar10;
    bool bVar11;
    longlong lVar12;
    char buffer[4];
    char *end;
    undefined4 uStack_2c;

    strbuff = &lex->saved_text;
    strbuffer_clear(strbuff);
    if (lex->token == 0x100) {
        jsonp_free((lex->value).string);
        (lex->value).string = (char *)0x0;
    }
    do {
        uVar8 = (lex->stream).state;
        if (uVar8 == 0) {
            uVar8 = stream_get(&lex->stream, error);
        }
        bVar10 = 0x1f < uVar8;
        if (uVar8 != 0x20) {
            bVar10 = uVar8 != 9;
        }
    } while ((!bVar10 || (uVar8 == 0x20 || uVar8 == 10)) || (uVar8 == 0xd));
    if (uVar8 == 0xffffffff) {
        lex->token = 0;
        return 0;
    }
    if (uVar8 == 0xfffffffe) {
    LAB_00048fac:
        lex->token = -1;
        return -1;
    }
    strbuffer_append_byte(strbuff, (char)uVar8);
    if ((((uVar8 & 0xffffffdf) - 0x5b & 0xfffffffd) == 0) ||
        (uVar8 == 0x2c || uVar8 == 0x3a)) {
    LAB_00048fca:
        lex->token = uVar8;
        return uVar8;
    }
    if (uVar8 == 0x22) {
        lex->token = -1;
        (lex->value).string = (char *)0x0;
    LAB_000490d2:
        do {
            uVar8 = lex_get_save(lex, error);
            while (true) {
                if (uVar8 == 0x22) {
                    __dest = (byte *)jsonp_malloc((lex->saved_text).length + 1);
                    (lex->value).string = (char *)__dest;
                    if (__dest == (byte *)0x0)
                        goto LAB_0004912e;
                    pcVar1 = strbuffer_value(strbuff);
                    pbVar9 = (byte *)(pcVar1 + 1);
                    goto LAB_000491e2;
                }
                if (uVar8 == 0xfffffffe)
                    goto LAB_0004912e;
                if (uVar8 == 0xffffffff) {
                    error_set(error, lex, "premature end of input");
                    goto LAB_0004912e;
                }
                if (uVar8 < 0x20) {
                    lex_unget_unsave(lex, uVar8);
                    if (uVar8 == 10) {
                        pcVar1 = "unexpected newline";
                    } else {
                        pcVar1 = "control character 0x%x";
                    }
                    error_set(error, lex, pcVar1, uVar8);
                    goto LAB_0004912e;
                }
                if (uVar8 != 0x5c)
                    goto LAB_000490d2;
                uVar8 = lex_get_save(lex, error);
                if (uVar8 != 0x75)
                    break;
                uVar8 = lex_get_save(lex, error);
                iVar2 = 4;
                do {
                    uVar7 = (uVar8 & 0xffffffdf) - 0x41;
                    bVar11 = 4 < uVar7;
                    bVar10 = uVar7 == 5;
                    if (5 < uVar7) {
                        bVar11 = 8 < uVar8 - 0x30;
                        bVar10 = uVar8 - 0x30 == 9;
                    }
                    if (bVar11 && !bVar10)
                        goto LAB_0004911e;
                    uVar8 = lex_get_save(lex, error);
                    iVar2 = iVar2 + -1;
                } while (iVar2 != 0);
            }
        } while (((uVar8 == 0x5c || (uVar8 & 0xffffffbf) == 0x22) ||
                  (uVar8 == 0x2f)) ||
                 (((uVar8 & 0xfffffff7) == 0x66 ||
                   ((uVar8 - 0x72 & 0xfffffffd) == 0))));
    LAB_0004911e:
        error_set(error, lex, "invalid escape");
    LAB_0004912e:
        jsonp_free((lex->value).string);
        return lex->token;
    }
    bVar10 = 0x2c < uVar8;
    if (uVar8 != 0x2d) {
        bVar10 = 8 < uVar8 - 0x30;
    }
    if (bVar10 && (uVar8 != 0x2d && uVar8 - 0x30 != 9)) {
        if ((uVar8 & 0xffffffdf) - 0x41 < 0x1a) {
            do {
                uVar8 = lex_get_save(lex, error);
            } while ((uVar8 & 0xffffffdf) - 0x41 < 0x1a);
            lex_unget_unsave(lex, uVar8);
            pcVar1 = strbuffer_value(strbuff);
            iVar2 = strcmp(pcVar1, "true");
            if (iVar2 == 0) {
                lex->token = 0x103;
                return 0x103;
            }
            iVar2 = strcmp(pcVar1, "false");
            if (iVar2 == 0) {
                uVar8 = 0x104;
                goto LAB_00048fca;
            }
            iVar2 = strcmp(pcVar1, "null");
            if (iVar2 == 0) {
                lex->token = 0x105;
                return 0x105;
            }
        } else {
            byte = (lex->stream).buffer[(lex->stream).buffer_pos];
            while (byte != '\0') {
                strbuffer_append_byte(strbuff, byte);
                sVar6 = (lex->stream).buffer_pos;
                (lex->stream).buffer_pos = sVar6 + 1;
                (lex->stream).position = (lex->stream).position + 1;
                byte = (lex->stream).buffer[sVar6 + 1];
            }
        }
        goto LAB_00048fac;
    }
    lex->token = -1;
    if (uVar8 == 0x2d) {
        uVar8 = lex_get_save(lex, error);
        if (uVar8 == 0x30)
            goto LAB_000492ba;
        if (uVar8 - 0x30 < 10)
            goto LAB_00049052;
    LAB_000492b0:
        lex_unget_unsave(lex, uVar8);
        iVar2 = lex->token;
    } else {
        if (uVar8 == 0x30) {
        LAB_000492ba:
            uVar8 = lex_get_save(lex, error);
            if (uVar8 - 0x30 < 10)
                goto LAB_000492b0;
        } else {
        LAB_00049052:
            do {
                uVar8 = lex_get_save(lex, error);
            } while (uVar8 - 0x30 < 10);
        }
        if (uVar8 == 0x2e || uVar8 == 0x45) {
            if (uVar8 == 0x2e) {
                iVar2 = (lex->stream).state;
                if (iVar2 == 0) {
                    iVar2 = stream_get(&lex->stream, error);
                }
                if (9 < iVar2 - 0x30U) {
                    stream_unget(&lex->stream, iVar2);
                    return lex->token;
                }
                strbuffer_append_byte(strbuff, (char)iVar2);
                do {
                    uVar8 = lex_get_save(lex, error);
                } while (uVar8 - 0x30 < 10);
            }
            if ((uVar8 & 0xffffffdf) == 0x45)
                goto LAB_00049188;
        } else {
            if (uVar8 != 0x65) {
                lex_unget_unsave(lex, uVar8);
                pcVar1 = strbuffer_value(strbuff);
                piVar3 = __errno_location();
                *piVar3 = 0;
                lVar12 = strtoll(pcVar1, &end, 10);
                if (*piVar3 == 0x22) {
                    if (lVar12 < 0) {
                        pcVar1 = "too big negative integer";
                    } else {
                        pcVar1 = "too big integer";
                    }
                    error_set(error, lex, pcVar1);
                    return lex->token;
                }
                if (end == pcVar1 + (lex->saved_text).length) {
                    (lex->value).integer = lVar12;
                    lex->token = 0x101;
                    return 0x101;
                }
                /* WARNING: Subroutine does not return */
                __assert_fail("end == saved_text + lex->saved_text.length",
                              "load.c", 0x206, "lex_scan_number");
            }
        LAB_00049188:
            uVar8 = lex_get_save(lex, error);
            if ((uVar8 - 0x2b & 0xfffffffd) == 0) {
                uVar8 = lex_get_save(lex, error);
            }
            if (9 < uVar8 - 0x30)
                goto LAB_000492b0;
            do {
                uVar8 = lex_get_save(lex, error);
            } while (uVar8 - 0x30 < 10);
        }
        lex_unget_unsave(lex, uVar8);
        iVar2 = jsonp_strtod(strbuff, (double *)&end);
        if (iVar2 == 0) {
            iVar2 = 0x102;
            lex->token = 0x102;
            (lex->value).string = end;
            *(undefined4 *)((int)&lex->value + 4) = uStack_2c;
        } else {
            error_set(error, lex, "real number overflow");
            iVar2 = lex->token;
        }
    }
    return iVar2;
LAB_000491e2:
    while (true) {
        bVar5 = *pbVar9;
        if (bVar5 == 0x22) {
            *__dest = 0;
            lex->token = 0x100;
            return 0x100;
        }
        if (bVar5 == 0x5c)
            break;
        *__dest = bVar5;
        __dest = __dest + 1;
        pbVar9 = pbVar9 + 1;
    }
    bVar5 = pbVar9[1];
    if (bVar5 == 0x75) {
        codepoint = decode_unicode_escape((char *)(pbVar9 + 1));
        if (codepoint - 0xd800U < 0x400) {
            if ((pbVar9[6] != 0x5c) || (pbVar9[7] != 0x75)) {
            LAB_00049440:
                error_set(error, lex, "invalid Unicode \'\\u%04X\'");
                goto LAB_0004912e;
            }
            iVar4 = decode_unicode_escape((char *)(pbVar9 + 7));
            if (0x3ff < iVar4 - 0xdc00U) {
                error_set(error, lex, "invalid Unicode \'\\u%04X\\u%04X\'",
                          codepoint, iVar4);
                goto LAB_0004912e;
            }
            codepoint =
                (iVar4 - 0xdc00U) + (codepoint - 0xd800U) * 0x400 + 0x10000;
            pbVar9 = pbVar9 + 0xc;
        } else {
            if (codepoint - 0xdc00U < 0x400)
                goto LAB_00049440;
            pbVar9 = pbVar9 + 6;
            if (codepoint == 0) {
                error_set(error, lex, "\\u0000 is not allowed");
                goto LAB_0004912e;
            }
        }
        iVar2 = utf8_encode(codepoint, buffer, (int *)&end);
        if (iVar2 != 0) {
            /* WARNING: Subroutine does not return */
            __assert_fail("0", "load.c", 0x1ae, "lex_scan_string");
        }
        memcpy(__dest, buffer, (size_t)end);
        __dest = __dest + (int)end;
        goto LAB_000491e2;
    }
    if (bVar5 == 0x62) {
        *__dest = 8;
    } else if (bVar5 < 99) {
        if (((bVar5 != 0x2f) && (bVar5 != 0x5c)) && (bVar5 != 0x22))
            goto LAB_000492f2;
    LAB_000492dc:
        *__dest = bVar5;
    } else if (bVar5 == 0x6e) {
        *__dest = 10;
    } else {
        if (bVar5 < 0x6f) {
            if (bVar5 != 0x66) {
            LAB_000492f2:
                /* WARNING: Subroutine does not return */
                __assert_fail("0", "load.c", 0x1bc, "lex_scan_string");
            }
            bVar5 = 0xc;
            goto LAB_000492dc;
        }
        if (bVar5 == 0x72) {
            *__dest = 0xd;
        } else {
            if (bVar5 != 0x74)
                goto LAB_000492f2;
            *__dest = 9;
        }
    }
    __dest = __dest + 1;
    pbVar9 = pbVar9 + 2;
    goto LAB_000491e2;
}

/* WARNING: Unknown calling convention */

json_t *parse_value(lex_t *lex, size_t flags, json_error_t *error)

{
    json_t *pjVar1;
    json_t *pjVar2;
    int iVar3;
    size_t sVar4;
    char *key;
    bool bVar5;
    double value;

    iVar3 = lex->token;
    if (iVar3 == 0x101) {
        if ((flags & 8) == 0) {
            pjVar1 = json_integer((lex->value).integer);
        } else {
            iVar3 = jsonp_strtod(&lex->saved_text, &value);
            if (iVar3 == 0) {
                pjVar1 = json_real(value);
            } else {
                error_set(error, lex, "real number overflow");
                pjVar1 = (json_t *)0x0;
            }
        }
    } else {
        if (0x101 < iVar3) {
            if (iVar3 == 0x103) {
                pjVar1 = json_true();
                return pjVar1;
            }
            if (iVar3 < 0x103) {
                pjVar1 = json_real((lex->value).real);
                return pjVar1;
            }
            if (iVar3 == 0x104) {
                pjVar1 = json_false();
                return pjVar1;
            }
            if (iVar3 == 0x105) {
                pjVar1 = json_null();
                return pjVar1;
            }
            goto LAB_000495f6;
        }
        if (iVar3 == 0x5b) {
            pjVar1 = json_array();
            if (pjVar1 == (json_t *)0x0) {
                return (json_t *)0x0;
            }
            lex_scan(lex, error);
            iVar3 = lex->token;
            if (iVar3 == 0x5d) {
                return pjVar1;
            }
            while (iVar3 != 0) {
                pjVar2 = parse_value(lex, flags, error);
                if (pjVar2 == (json_t *)0x0)
                    goto LAB_00049684;
                if (pjVar2->refcount != 0xffffffff) {
                    pjVar2->refcount = pjVar2->refcount + 1;
                }
                iVar3 = json_array_append_new(pjVar1, pjVar2);
                sVar4 = pjVar2->refcount;
                if (iVar3 != 0)
                    goto joined_r0x000496f4;
                if ((sVar4 != 0xffffffff) &&
                    (pjVar2->refcount = sVar4 - 1, sVar4 - 1 == 0)) {
                    json_delete(pjVar2);
                }
                lex_scan(lex, error);
                if (lex->token != 0x2c) {
                    if (lex->token == 0x5d) {
                        return pjVar1;
                    }
                    break;
                }
                lex_scan(lex, error);
                iVar3 = lex->token;
            }
            error_set(error, lex, "\']\' expected");
        } else {
            if (iVar3 < 0x5c) {
                if (iVar3 == -1) {
                    error_set(error, lex, "invalid token");
                    return (json_t *)0x0;
                }
            LAB_000495f6:
                error_set(error, lex, "unexpected token");
                return (json_t *)0x0;
            }
            if (iVar3 != 0x7b) {
                if (iVar3 == 0x100) {
                    pjVar1 = json_string_nocheck((lex->value).string);
                    return pjVar1;
                }
                goto LAB_000495f6;
            }
            pjVar1 = json_object();
            if (pjVar1 == (json_t *)0x0) {
                return (json_t *)0x0;
            }
            lex_scan(lex, error);
            if (lex->token == 0x7d) {
                return pjVar1;
            }
            if (lex->token == 0x100) {
                key = (lex->value).string;
                (lex->value).string = (char *)0x0;
                if (key == (char *)0x0) {
                    return (json_t *)0x0;
                }
            LAB_00049506:
                if (((flags & 1) == 0) ||
                    (pjVar2 = json_object_get(pjVar1, key),
                     pjVar2 == (json_t *)0x0)) {
                    lex_scan(lex, error);
                    if (lex->token == 0x3a) {
                        lex_scan(lex, error);
                        pjVar2 = parse_value(lex, flags, error);
                        if (pjVar2 == (json_t *)0x0) {
                            jsonp_free(key);
                        } else {
                            sVar4 = pjVar2->refcount;
                            bVar5 = sVar4 != 0xffffffff;
                            if (bVar5) {
                                sVar4 = sVar4 + 1;
                            }
                            if (bVar5) {
                                pjVar2->refcount = sVar4;
                            }
                            iVar3 = json_object_set_new_nocheck(pjVar1, key,
                                                                pjVar2);
                            if (iVar3 != 0) {
                                jsonp_free(key);
                                sVar4 = pjVar2->refcount;
                            joined_r0x000496f4:
                                if ((sVar4 != 0xffffffff) &&
                                    (pjVar2->refcount = sVar4 - 1,
                                     sVar4 - 1 == 0)) {
                                    json_delete(pjVar2);
                                }
                                goto LAB_00049684;
                            }
                            if ((pjVar2->refcount != 0xffffffff) &&
                                (sVar4 = pjVar2->refcount - 1,
                                 pjVar2->refcount = sVar4, sVar4 == 0)) {
                                json_delete(pjVar2);
                            }
                            jsonp_free(key);
                            lex_scan(lex, error);
                            if (lex->token == 0x2c) {
                                lex_scan(lex, error);
                                if (lex->token == 0x100)
                                    goto code_r0x00049598;
                                goto LAB_00049706;
                            }
                            if (lex->token == 0x7d) {
                                return pjVar1;
                            }
                            error_set(error, lex, "\'}\' expected");
                        }
                    } else {
                        jsonp_free(key);
                        error_set(error, lex, "\':\' expected");
                    }
                } else {
                    jsonp_free(key);
                    error_set(error, lex, "duplicate object key");
                }
                goto LAB_00049684;
            }
        LAB_00049706:
            error_set(error, lex, "string or \'}\' expected");
        }
    LAB_00049684:
        if ((pjVar1->refcount == 0xffffffff) ||
            (sVar4 = pjVar1->refcount - 1, pjVar1->refcount = sVar4,
             sVar4 != 0)) {
            return (json_t *)0x0;
        }
        json_delete(pjVar1);
        pjVar1 = (json_t *)0x0;
    }
    return pjVar1;
code_r0x00049598:
    key = (lex->value).string;
    (lex->value).string = (char *)0x0;
    if (key == (char *)0x0) {
        return (json_t *)0x0;
    }
    goto LAB_00049506;
}

/* WARNING: Unknown calling convention */

json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error)

{
    json_t *json;
    size_t sVar1;

    lex_scan(lex, error);
    if (((flags & 4) == 0) && ((lex->token & 0xffffffdfU) != 0x5b)) {
        error_set(error, lex, "\'[\' or \'{\' expected");
        return (json_t *)0x0;
    }
    json = parse_value(lex, flags, error);
    if (json != (json_t *)0x0) {
        if (((int)(flags << 0x1e) < 0) ||
            (lex_scan(lex, error), lex->token == 0)) {
            if (error == (json_error_t *)0x0) {
                return json;
            }
            error->position = (lex->stream).position;
            return json;
        }
        error_set(error, lex, "end of file expected");
        if ((json->refcount != 0xffffffff) &&
            (sVar1 = json->refcount - 1, json->refcount = sVar1, sVar1 == 0)) {
            json_delete(json);
            return (json_t *)0x0;
        }
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

json_t *json_loads(char *string, size_t flags, json_error_t *error)

{
    int iVar1;
    json_t *pjVar2;
    string_data_t stream_data;
    lex_t lex;

    jsonp_error_init(error, "<string>");
    if (string == (char *)0x0) {
        error_set(error, (lex_t *)0x0, "wrong arguments");
        pjVar2 = (json_t *)0x0;
    } else {
        pjVar2 = (json_t *)0x0;
        stream_data.pos = 0;
        lex.stream.buffer[0] = '\0';
        lex.stream.buffer_pos = 0;
        lex.stream.state = 0;
        lex.stream.column = 0;
        lex.stream.position = 0;
        lex.stream.line = 1;
        stream_data.data = string;
        lex.stream.get = (code *)0x48b61;
        lex.stream.data = &stream_data;
        iVar1 = strbuffer_init(&lex.saved_text);
        if (iVar1 == 0) {
            lex.token = -1;
            pjVar2 = parse_json(&lex, flags, error);
            lex_close(&lex);
        }
    }
    return pjVar2;
}

/* WARNING: Unknown calling convention */

json_t *json_loadb(char *buffer, size_t buflen, size_t flags,
                   json_error_t *error)

{
    int iVar1;
    json_t *pjVar2;
    buffer_data_t stream_data;
    lex_t lex;

    jsonp_error_init(error, "<buffer>");
    if (buffer == (char *)0x0) {
        error_set(error, (lex_t *)0x0, "wrong arguments");
        pjVar2 = (json_t *)0x0;
    } else {
        pjVar2 = (json_t *)0x0;
        lex.stream.data = &stream_data;
        stream_data.pos = 0;
        lex.stream.buffer[0] = '\0';
        lex.stream.buffer_pos = 0;
        lex.stream.state = 0;
        lex.stream.column = 0;
        lex.stream.position = 0;
        lex.stream.line = 1;
        stream_data.data = buffer;
        stream_data.len = buflen;
        lex.stream.get = (code *)0x48b79;
        iVar1 = strbuffer_init(&lex.saved_text);
        if (iVar1 == 0) {
            lex.token = -1;
            pjVar2 = parse_json(&lex, flags, error);
            lex_close(&lex);
        }
    }
    return pjVar2;
}

/* WARNING: Unknown calling convention */

json_t *json_loadf(FILE *input, size_t flags, json_error_t *error)

{
    int iVar1;
    char *source;
    json_t *pjVar2;
    lex_t lex;

    source = "<stdin>";
    if (stdin != input) {
        source = "<stream>";
    }
    jsonp_error_init(error, source);
    if (input == (FILE *)0x0) {
        error_set(error, (lex_t *)0x0, "wrong arguments");
        pjVar2 = (json_t *)0x0;
    } else {
        pjVar2 = (json_t *)0x0;
        lex.stream.get = fgetc;
        lex.stream.buffer[0] = '\0';
        lex.stream.buffer_pos = 0;
        lex.stream.state = 0;
        lex.stream.column = 0;
        lex.stream.position = 0;
        lex.stream.line = 1;
        lex.stream.data = input;
        iVar1 = strbuffer_init(&lex.saved_text);
        if (iVar1 == 0) {
            lex.token = -1;
            pjVar2 = parse_json(&lex, flags, error);
            lex_close(&lex);
        }
    }
    return pjVar2;
}

/* WARNING: Unknown calling convention */

json_t *json_load_file(char *path, size_t flags, json_error_t *error)

{
    FILE *input;
    json_t *pjVar1;
    int *piVar2;
    char *pcVar3;

    jsonp_error_init(error, path);
    if (path == (char *)0x0) {
        error_set(error, (lex_t *)0x0, "wrong arguments");
        pjVar1 = (json_t *)0x0;
    } else {
        input = fopen(path, "rb");
        if (input == (FILE *)0x0) {
            piVar2 = __errno_location();
            pcVar3 = strerror(*piVar2);
            error_set(error, (lex_t *)0x0, "unable to open %s: %s", path,
                      pcVar3);
            pjVar1 = (json_t *)0x0;
        } else {
            pjVar1 = json_loadf((FILE *)input, flags, error);
            fclose(input);
        }
    }
    return pjVar1;
}

/* WARNING: Unknown calling convention */

json_t *json_load_callback(json_load_callback_t callback, void *arg,
                           size_t flags, json_error_t *error)

{
    int iVar1;
    json_t *pjVar2;
    lex_t lex;
    callback_data_t stream_data;

    memset(&stream_data, 0, 0x410);
    stream_data.callback = callback;
    stream_data.arg = arg;
    jsonp_error_init(error, "<callback>");
    if (callback == (json_load_callback_t)0x0) {
        error_set(error, (lex_t *)0x0, "wrong arguments");
        pjVar2 = (json_t *)0x0;
    } else {
        pjVar2 = (json_t *)0x0;
        lex.stream.data = &stream_data;
        lex.stream.line = 1;
        lex.stream.buffer[0] = '\0';
        lex.stream.buffer_pos = 0;
        lex.stream.state = 0;
        lex.stream.column = 0;
        lex.stream.position = 0;
        lex.stream.get = (code *)0x48b95;
        iVar1 = strbuffer_init(&lex.saved_text);
        if (iVar1 == 0) {
            lex.token = -1;
            pjVar2 = parse_json(&lex, flags, error);
            lex_close(&lex);
        }
    }
    return pjVar2;
}

/* WARNING: Unknown calling convention */

void *jsonp_malloc(size_t size)

{
    void *pvVar1;

    if (size != 0) {
        /* WARNING: Could not recover jumptable at 0x00049a90. Too many branches
         */
        /* WARNING: Treating indirect jump as call */
        pvVar1 = (*do_malloc)(size);
        return pvVar1;
    }
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void jsonp_free(void *ptr)

{
    if (ptr != (void *)0x0) {
        /* WARNING: Could not recover jumptable at 0x00049aa0. Too many branches
         */
        /* WARNING: Treating indirect jump as call */
        (*do_free)(ptr);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

char *jsonp_strdup(char *str)

{
    size_t sVar1;
    char *__dest;

    sVar1 = strlen(str);
    __dest = (char *)(*do_malloc)(sVar1 + 1);
    if (__dest != (char *)0x0) {
        memcpy(__dest, str, sVar1 + 1);
    }
    return __dest;
}

/* WARNING: Unknown calling convention */

void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn)

{
    do_malloc = malloc_fn;
    do_free = free_fn;
    return;
}

/* WARNING: Unknown calling convention */

int strbuffer_init(strbuffer_t *strbuff)

{
    char *pcVar1;

    strbuff->length = 0;
    strbuff->size = 0x10;
    pcVar1 = (char *)jsonp_malloc(0x10);
    strbuff->value = pcVar1;
    if (pcVar1 != (char *)0x0) {
        *pcVar1 = '\0';
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

void strbuffer_close(strbuffer_t *strbuff)

{
    if (strbuff->value != (char *)0x0) {
        jsonp_free(strbuff->value);
    }
    strbuff->length = 0;
    strbuff->size = 0;
    strbuff->value = (char *)0x0;
    return;
}

/* WARNING: Unknown calling convention */

void strbuffer_clear(strbuffer_t *strbuff)

{
    strbuff->length = 0;
    *strbuff->value = '\0';
    return;
}

/* WARNING: Unknown calling convention */

char *strbuffer_value(strbuffer_t *strbuff)

{
    return strbuff->value;
}

/* WARNING: Unknown calling convention */

char *strbuffer_steal_value(strbuffer_t *strbuff)

{
    char *pcVar1;

    pcVar1 = strbuff->value;
    strbuff->value = (char *)0x0;
    return pcVar1;
}

/* WARNING: Unknown calling convention */

int strbuffer_append_bytes(strbuffer_t *strbuff, char *data, size_t size)

{
    size_t sVar1;
    int iVar2;
    size_t sVar3;
    uint size_00;
    char *__dest;

    sVar3 = strbuff->size;
    sVar1 = strbuff->length;
    if (size < sVar3 - sVar1) {
        __dest = strbuff->value;
    LAB_00049b94:
        memcpy(__dest + sVar1, data, size);
        iVar2 = 0;
        sVar1 = size + strbuff->length;
        strbuff->length = sVar1;
        strbuff->value[sVar1] = '\0';
    } else {
        if ((size != 0xffffffff && -1 < (int)sVar3) && (sVar1 <= -size - 2)) {
            size_00 = size + 1 + sVar1;
            if (size_00 < sVar3 << 1) {
                size_00 = sVar3 << 1;
            }
            __dest = (char *)jsonp_malloc(size_00);
            if (__dest != (char *)0x0) {
                memcpy(__dest, strbuff->value, strbuff->length);
                jsonp_free(strbuff->value);
                sVar1 = strbuff->length;
                strbuff->value = __dest;
                strbuff->size = size_00;
                goto LAB_00049b94;
            }
        }
        iVar2 = -1;
    }
    return iVar2;
}

/* WARNING: Unknown calling convention */

int strbuffer_append(strbuffer_t *strbuff, char *string)

{
    size_t size;
    int iVar1;

    size = strlen(string);
    iVar1 = strbuffer_append_bytes(strbuff, string, size);
    return iVar1;
}

/* WARNING: Unknown calling convention */

int strbuffer_append_byte(strbuffer_t *strbuff, char byte)

{
    int iVar1;
    char local_9[5];

    local_9[0] = byte;
    iVar1 = strbuffer_append_bytes(strbuff, local_9, 1);
    return iVar1;
}

/* WARNING: Unknown calling convention */

char strbuffer_pop(strbuffer_t *strbuff)

{
    char cVar1;
    size_t sVar2;

    if (strbuff->length != 0) {
        sVar2 = strbuff->length - 1;
        strbuff->length = sVar2;
        cVar1 = strbuff->value[sVar2];
        strbuff->value[sVar2] = '\0';
        return cVar1;
    }
    return '\0';
}

/* WARNING: Unknown calling convention */

int jsonp_strtod(strbuffer_t *strbuffer, double *out)

{
    char cVar1;
    lconv *plVar2;
    char *pcVar3;
    int *piVar4;
    int iVar5;
    char *__s;
    double dVar6;
    char *end;

    plVar2 = localeconv();
    __s = strbuffer->value;
    cVar1 = *plVar2->decimal_point;
    if ((cVar1 != '.') && (pcVar3 = strchr(__s, 0x2e), pcVar3 != (char *)0x0)) {
        *pcVar3 = cVar1;
        __s = strbuffer->value;
    }
    piVar4 = __errno_location();
    *piVar4 = 0;
    dVar6 = strtod(__s, &end);
    if (end != strbuffer->value + strbuffer->length) {
        /* WARNING: Subroutine does not return */
        __assert_fail("end == strbuffer->value + strbuffer->length",
                      "strconv.c", 0x46, "jsonp_strtod");
    }
    if (*piVar4 == 0x22 && dVar6 != 0.0) {
        iVar5 = -1;
    } else {
        *out = dVar6;
        iVar5 = 0;
    }
    return iVar5;
}

int jsonp_dtostr(char *buffer, size_t size, double value)

{
    char cVar1;
    uint uVar2;
    lconv *plVar3;
    char *pcVar4;
    char *pcVar5;
    size_t __n;
    undefined4 in_r3;

    uVar2 = snprintf(buffer, size, "%.17g", in_r3, value);
    if (size <= uVar2) {
        return -1;
    }
    plVar3 = localeconv();
    if (((byte)*plVar3->decimal_point != 0x2e) &&
        (pcVar4 = strchr(buffer, (uint)(byte)*plVar3->decimal_point),
         pcVar4 != (char *)0x0)) {
        *pcVar4 = '.';
    }
    pcVar5 = strchr(buffer, 0x2e);
    pcVar4 = strchr(buffer, 0x65);
    if (pcVar5 == (char *)0x0) {
        if (pcVar4 != (char *)0x0)
            goto LAB_00049cdc;
        if (size <= uVar2 + 3) {
            return -1;
        }
        buffer[uVar2] = '.';
        buffer[uVar2 + 1] = '0';
        buffer[uVar2 + 2] = '\0';
        pcVar4 = strchr(buffer, 0x65);
        uVar2 = uVar2 + 2;
    }
    if (pcVar4 == (char *)0x0) {
        return uVar2;
    }
LAB_00049cdc:
    pcVar5 = pcVar4 + 2;
    cVar1 = pcVar4[2];
    if (pcVar4[1] == '-') {
        pcVar4 = pcVar5;
        if (cVar1 == '0')
            goto LAB_00049cee;
    } else {
        pcVar4 = pcVar4 + 1;
        while (cVar1 == '0') {
        LAB_00049cee:
            pcVar5 = pcVar5 + 1;
            cVar1 = *pcVar5;
        }
        if (pcVar5 != pcVar4) {
            __n = uVar2 - ((int)pcVar5 - (int)buffer);
            uVar2 = uVar2 - ((int)pcVar5 - (int)pcVar4);
            memmove(pcVar4, pcVar5, __n);
        }
    }
    return uVar2;
}

/* WARNING: Unknown calling convention */

int utf8_encode(int32_t codepoint, char *buffer, int *size)

{
    byte bVar1;
    int iVar2;

    if (codepoint < 0) {
        return -1;
    }
    bVar1 = (byte)codepoint;
    if (codepoint < 0x80) {
        *buffer = bVar1;
        *size = 1;
        return 0;
    }
    if (codepoint < 0x800) {
        *buffer = (char)(codepoint >> 6) + -0x40;
        iVar2 = 0;
        buffer[1] = (bVar1 & 0x3f) + 0x80;
        *size = 2;
    } else {
        if (codepoint < 0x10000) {
            *buffer = (char)(codepoint >> 0xc) + -0x20;
            buffer[1] = (byte)((uint)(codepoint << 0x14) >> 0x1a) + 0x80;
            buffer[2] = (bVar1 & 0x3f) + 0x80;
            *size = 3;
            return 0;
        }
        if (codepoint < 0x110000) {
            *buffer = (char)(codepoint >> 0x12) + -0x10;
            buffer[1] = (byte)((uint)(codepoint << 0xe) >> 0x1a) + 0x80;
            buffer[2] = (byte)((uint)(codepoint << 0x14) >> 0x1a) + 0x80;
            buffer[3] = (bVar1 & 0x3f) + 0x80;
            *size = 4;
            return 0;
        }
        iVar2 = -1;
    }
    return iVar2;
}

/* WARNING: Unknown calling convention */

int utf8_check_first(char byte)

{
    uint uVar1;
    int iVar2;

    uVar1 = (uint)byte;
    if (-1 < (int)(uVar1 << 0x18)) {
        return 1;
    }
    if ((uVar1 ^ 0x80) < 0x42) {
        return 0;
    }
    if ((uVar1 + 0x3e & 0xff) < 0x1e) {
        return 2;
    }
    if ((uVar1 + 0x20 & 0xff) < 0x10) {
        return 3;
    }
    if ((uVar1 + 0x10 & 0xff) < 5) {
        iVar2 = 4;
    } else {
        iVar2 = 0;
    }
    return iVar2;
}

/* WARNING: Unknown calling convention */

int utf8_check_full(char *buffer, int size, int32_t *codepoint)

{
    byte *pbVar1;
    uint uVar2;
    int iVar3;
    uint uVar4;
    bool bVar5;

    uVar4 = (uint)(byte)*buffer;
    if (size == 2) {
        uVar4 = uVar4 & 0x1f;
    } else if (size == 3) {
        uVar4 = uVar4 & 0xf;
    } else {
        if (size != 4) {
            return 0;
        }
        uVar4 = uVar4 & 7;
    }
    uVar2 = (uint)(byte)buffer[1];
    if ((uVar2 ^ 0x80) < 0x40) {
        pbVar1 = (byte *)(buffer + 1);
        iVar3 = 1;
        do {
            iVar3 = iVar3 + 1;
            uVar4 = (uVar2 & 0x3f) + uVar4 * 0x40;
            if (size <= iVar3) {
                if (0x10ffff < (int)uVar4) {
                    return 0;
                }
                if (uVar4 - 0xd800 < 0x800) {
                    return 0;
                }
                bVar5 = uVar4 == 0x7f;
                if ((int)uVar4 < 0x80) {
                    bVar5 = size == 2;
                }
                if (bVar5) {
                    return 0;
                }
                if ((int)uVar4 < 0x800 && size == 3) {
                    return 0;
                }
                if ((int)uVar4 < 0x10000 && size == 4) {
                    return 0;
                }
                if (codepoint != (int32_t *)0x0) {
                    *codepoint = uVar4;
                    return 1;
                }
                return 1;
            }
            pbVar1 = pbVar1 + 1;
            uVar2 = (uint)*pbVar1;
        } while ((uVar2 ^ 0x80) < 0x40);
    }
    return 0;
}

/* WARNING: Unknown calling convention */

char *utf8_iterate(char *buffer, int32_t *codepoint)

{
    int32_t iVar1;
    int size;
    char *pcVar2;
    int iVar3;
    int32_t extraout_r2;
    int32_t value;

    if (*buffer != '\0') {
        size = utf8_check_first(*buffer);
        if ((size < 1) ||
            ((iVar1 = extraout_r2,
              size != 1 && (iVar3 = utf8_check_full(buffer, size, &value),
                            iVar1 = value, iVar3 == 0)))) {
            pcVar2 = (char *)0x0;
        } else {
            value = iVar1;
            if (codepoint != (int32_t *)0x0) {
                *codepoint = value;
            }
            pcVar2 = buffer + size;
        }
        return pcVar2;
    }
    return buffer;
}

/* WARNING: Unknown calling convention */

int utf8_check_string(char *string, int length)

{
    int iVar1;
    int size;
    int iVar2;

    if (length == -1) {
        length = strlen(string);
    }
    if (0 < length) {
        iVar2 = 0;
        do {
            size = utf8_check_first(string[iVar2]);
            if (size == 0) {
                return 0;
            }
            if (1 < size) {
                if (length < size + iVar2) {
                    return 0;
                }
                iVar1 = utf8_check_full(string + iVar2, size, (int32_t *)0x0);
                if (iVar1 == 0) {
                    return 0;
                }
                iVar2 = iVar2 + size + -1;
            }
            iVar2 = iVar2 + 1;
        } while (iVar2 < length);
    }
    return 1;
}

/* WARNING: Unknown calling convention */

json_t *json_integer_copy(json_t *integer)

{
    json_t *pjVar1;
    json_type jVar2;
    size_t sVar3;

    if ((integer == (json_t *)0x0) || (integer->type != JSON_INTEGER)) {
        jVar2 = JSON_OBJECT;
        sVar3 = 0;
    } else {
        jVar2 = integer[1].type;
        sVar3 = integer[1].refcount;
    }
    pjVar1 = (json_t *)jsonp_malloc(0x10);
    if (pjVar1 != (json_t *)0x0) {
        pjVar1[1].type = jVar2;
        pjVar1[1].refcount = sVar3;
        pjVar1->type = JSON_INTEGER;
        pjVar1->refcount = 1;
    }
    return pjVar1;
}

/* WARNING: Unknown calling convention */

json_t **json_array_grow(json_array_t *array, size_t amount, int copy)

{
    json_t **__dest;
    size_t new_size;
    uint uVar1;
    uint uVar2;
    json_t **__src;

    uVar1 = array->size;
    __src = array->table;
    if (uVar1 < array->entries + amount) {
        uVar2 = uVar1 + amount;
        if (uVar1 + amount < uVar1 << 1) {
            uVar2 = uVar1 << 1;
        }
        __dest = (json_t **)jsonp_malloc(uVar2 << 2);
        if (__dest == (json_t **)0x0) {
            __src = (json_t **)0x0;
        } else {
            array->size = uVar2;
            array->table = __dest;
            if (copy != 0) {
                memcpy(__dest, __src, array->entries << 2);
                jsonp_free(__src);
                return array->table;
            }
        }
    }
    return __src;
}

/* WARNING: Unknown calling convention */

int json_equal(json_t *json1, json_t *json2)

{
    void *pvVar1;
    char *key;
    int iVar2;
    json_t *pjVar3;
    json_t *pjVar4;
    json_type jVar5;
    json_type jVar6;
    json_array_t *array;
    uint uVar7;
    size_t sVar8;

    jVar5 = json1->type;
    if (jVar5 != json2->type) {
        return 0;
    }
    if (json1 == json2) {
        return 1;
    }
    if (jVar5 == JSON_OBJECT) {
        if (json1[1].type == json2[1].type) {
            pvVar1 = hashtable_iter((hashtable_t *)(json1 + 1));
            if ((pvVar1 != (void *)0x0) &&
                (key = (char *)hashtable_iter_key(pvVar1),
                 key != (char *)0x0)) {
                while (true) {
                    pjVar3 = (json_t *)hashtable_iter_value(key + -0x10);
                    if (pjVar3 == (json_t *)0x0)
                        break;
                    if (json2->type != JSON_OBJECT) {
                        return 0;
                    }
                    pjVar4 = (json_t *)hashtable_get((hashtable_t *)(json2 + 1),
                                                     key);
                    if (pjVar4 == (json_t *)0x0) {
                        return 0;
                    }
                    iVar2 = json_equal(pjVar3, pjVar4);
                    if (iVar2 == 0) {
                        return 0;
                    }
                    if (json1->type != JSON_OBJECT) {
                        return 1;
                    }
                    pvVar1 = hashtable_iter_next((hashtable_t *)(json1 + 1),
                                                 key + -0x10);
                    if (pvVar1 == (void *)0x0) {
                        return 1;
                    }
                    key = (char *)hashtable_iter_key(pvVar1);
                    if (key == (char *)0x0) {
                        return 1;
                    }
                }
            }
            return 1;
        }
    } else if (jVar5 == JSON_ARRAY) {
        sVar8 = json1[1].refcount;
        if (sVar8 == json2[1].refcount) {
            if (sVar8 == 0) {
                return 1;
            }
            uVar7 = 0;
            jVar5 = JSON_ARRAY;
            jVar6 = JSON_ARRAY;
            while (true) {
                if ((jVar6 == JSON_ARRAY) && (uVar7 < json1[1].refcount)) {
                    pjVar3 = *(json_t **)(json1[2].type + uVar7 * 4);
                } else {
                    pjVar3 = (json_t *)0x0;
                }
                if (jVar5 != JSON_ARRAY) {
                    return 0;
                }
                if (json2[1].refcount <= uVar7) {
                    return 0;
                }
                pjVar4 = *(json_t **)(json2[2].type + uVar7 * 4);
                if (pjVar4 == (json_t *)0x0 || pjVar3 == (json_t *)0x0)
                    break;
                iVar2 = json_equal(pjVar3, pjVar4);
                if (iVar2 == 0) {
                    return 0;
                }
                uVar7 = uVar7 + 1;
                if (sVar8 == uVar7) {
                    return 1;
                }
                jVar6 = json1->type;
                jVar5 = json2->type;
            }
            return 0;
        }
    } else {
        if (jVar5 == JSON_STRING) {
            iVar2 = strcmp((char *)json1[1].type, (char *)json2[1].type);
            return (uint)(iVar2 == 0);
        }
        if (jVar5 == JSON_INTEGER) {
            return (uint)(json1[1].refcount == json2[1].refcount &&
                          json1[1].type == json2[1].type);
        }
        if (jVar5 == JSON_REAL) {
            return (uint)((double)json1[1] == (double)json2[1]);
        }
    }
    return 0;
}

/* WARNING: Unknown calling convention */

json_t *json_object(void)

{
    json_t *ptr;
    int iVar1;
    json_t *pjVar2;

    ptr = (json_t *)jsonp_malloc(0x24);
    pjVar2 = ptr;
    if (ptr != (json_t *)0x0) {
        ptr->type = JSON_OBJECT;
        ptr->refcount = 1;
        iVar1 = hashtable_init((hashtable_t *)(ptr + 1));
        if (iVar1 == 0) {
            ptr[3].refcount = 0;
            ptr[4].type = JSON_OBJECT;
        } else {
            pjVar2 = (json_t *)0x0;
            jsonp_free(ptr);
        }
    }
    return pjVar2;
}

/* WARNING: Unknown calling convention */

size_t json_object_size(json_t *json)

{
    if (json != (json_t *)0x0) {
        if (json->type == JSON_OBJECT) {
            return json[1].type;
        }
        json = (json_t *)0x0;
    }
    return (size_t)json;
}

/* WARNING: Unknown calling convention */

json_t *json_object_get(json_t *json, char *key)

{
    json_t *pjVar1;

    if ((json != (json_t *)0x0) && (json->type == JSON_OBJECT)) {
        pjVar1 = (json_t *)hashtable_get((hashtable_t *)(json + 1), key);
        return pjVar1;
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

int json_object_del(json_t *json, char *key)

{
    int iVar1;

    if ((json != (json_t *)0x0) && (json->type == JSON_OBJECT)) {
        iVar1 = hashtable_del((hashtable_t *)(json + 1), key);
        return iVar1;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_object_clear(json_t *json)

{
    if (json == (json_t *)0x0) {
        return -1;
    }
    if (json->type == JSON_OBJECT) {
        hashtable_clear((hashtable_t *)(json + 1));
        json[3].refcount = 0;
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

void *json_object_iter(json_t *json)

{
    void *pvVar1;

    if ((json != (json_t *)0x0) && (json->type == JSON_OBJECT)) {
        pvVar1 = hashtable_iter((hashtable_t *)(json + 1));
        return pvVar1;
    }
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void *json_object_iter_at(json_t *json, char *key)

{
    void *pvVar1;

    if ((json != (json_t *)0x0 && key != (char *)0x0) &&
        (json->type == JSON_OBJECT)) {
        pvVar1 = hashtable_iter_at((hashtable_t *)(json + 1), key);
        return pvVar1;
    }
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

void *json_object_iter_next(json_t *json, void *iter)

{
    void *pvVar1;

    if ((json != (json_t *)0x0) &&
        (json->type == JSON_OBJECT && iter != (void *)0x0)) {
        pvVar1 = hashtable_iter_next((hashtable_t *)(json + 1), iter);
        return pvVar1;
    }
    return (void *)0x0;
}

/* WARNING: Unknown calling convention */

char *json_object_iter_key(void *iter)

{
    char *pcVar1;

    if (iter != (void *)0x0) {
        pcVar1 = (char *)hashtable_iter_key(iter);
        return pcVar1;
    }
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

json_t *json_object_iter_value(void *iter)

{
    json_t *pjVar1;

    if (iter != (void *)0x0) {
        pjVar1 = (json_t *)hashtable_iter_value(iter);
        return pjVar1;
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

int json_object_iter_set_new(json_t *json, void *iter, json_t *value)

{
    if (json == (json_t *)0x0) {
        return -1;
    }
    if ((json->type == JSON_OBJECT) &&
        (iter != (void *)0x0 && value != (json_t *)0x0)) {
        hashtable_iter_set(iter, value);
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

void *json_object_key_to_iter(char *key)

{
    if (key != (char *)0x0) {
        key = key + -0x10;
    }
    return key;
}

/* WARNING: Unknown calling convention */

json_t *json_array(void)

{
    json_t *ptr;
    void *pvVar1;

    ptr = (json_t *)jsonp_malloc(0x18);
    if (ptr != (json_t *)0x0) {
        ptr[1].type = 8;
        ptr->type = JSON_ARRAY;
        ptr->refcount = 1;
        ptr[1].refcount = 0;
        pvVar1 = jsonp_malloc(0x20);
        ptr[2].type = (json_type)pvVar1;
        if (pvVar1 == (void *)0x0) {
            jsonp_free(ptr);
            ptr = (json_t *)0x0;
        } else {
            ptr[2].refcount = 0;
        }
    }
    return ptr;
}

/* WARNING: Unknown calling convention */

size_t json_array_size(json_t *json)

{
    if (json != (json_t *)0x0) {
        if (json->type == JSON_ARRAY) {
            return json[1].refcount;
        }
        json = (json_t *)0x0;
    }
    return (size_t)json;
}

/* WARNING: Unknown calling convention */

json_t *json_array_get(json_t *json, size_t index)

{
    if (json != (json_t *)0x0) {
        if ((json->type == JSON_ARRAY) && (index < json[1].refcount)) {
            return *(json_t **)(json[2].type + index * 4);
        }
        json = (json_t *)0x0;
    }
    return json;
}

/* WARNING: Unknown calling convention */

int json_array_extend(json_t *json, json_t *other_json)

{
    json_t **ppjVar1;
    int *__src;
    size_t sVar2;
    size_t __n;
    int iVar3;
    int *piVar4;
    int *piVar5;

    if (json == (json_t *)0x0) {
        return -1;
    }
    if (((json->type == JSON_ARRAY && other_json != (json_t *)0x0) &&
         (other_json->type == JSON_ARRAY)) &&
        (ppjVar1 =
             json_array_grow((json_array_t *)json, other_json[1].refcount, 1),
         ppjVar1 != (json_t **)0x0)) {
        sVar2 = other_json[1].refcount;
        __src = (int *)other_json[2].type;
        __n = sVar2;
        if (sVar2 != 0) {
            __n = sVar2 * 4;
            piVar4 = __src;
            do {
                piVar5 = piVar4 + 1;
                iVar3 = *piVar4;
                if (iVar3 != 0) {
                    if (*(int *)(iVar3 + 4) != -1) {
                        *(int *)(iVar3 + 4) = *(int *)(iVar3 + 4) + 1;
                    }
                }
                piVar4 = piVar5;
            } while (__src + sVar2 != piVar5);
        }
        memcpy((void *)(json[2].type + json[1].refcount * 4), __src, __n);
        json[1].refcount = json[1].refcount + other_json[1].refcount;
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

json_t *json_string_nocheck(char *value)

{
    json_t *ptr;
    char *pcVar1;

    if ((value != (char *)0x0) &&
        (ptr = (json_t *)jsonp_malloc(0xc), ptr != (json_t *)0x0)) {
        ptr->type = JSON_STRING;
        ptr->refcount = 1;
        pcVar1 = jsonp_strdup(value);
        ptr[1].type = (json_type)pcVar1;
        if (pcVar1 == (char *)0x0) {
            jsonp_free(ptr);
            ptr = (json_t *)0x0;
        }
        return ptr;
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

json_t *json_string(char *value)

{
    int iVar1;
    json_t *pjVar2;

    if (value == (char *)0x0) {
        return (json_t *)0x0;
    }
    iVar1 = utf8_check_string(value, -1);
    if (iVar1 != 0) {
        pjVar2 = json_string_nocheck(value);
        return pjVar2;
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

char *json_string_value(json_t *json)

{
    if (json != (json_t *)0x0) {
        if (json->type == JSON_STRING) {
            return (char *)json[1].type;
        }
        json = (json_t *)0x0;
    }
    return (char *)json;
}

/* WARNING: Unknown calling convention */

int json_string_set_nocheck(json_t *json, char *value)

{
    char *pcVar1;

    if (json == (json_t *)0x0) {
        return -1;
    }
    if ((json->type == JSON_STRING && value != (char *)0x0) &&
        (pcVar1 = jsonp_strdup(value), pcVar1 != (char *)0x0)) {
        jsonp_free((void *)json[1].type);
        json[1].type = (json_type)pcVar1;
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_string_set(json_t *json, char *value)

{
    int iVar1;

    if (value == (char *)0x0) {
        return -1;
    }
    iVar1 = utf8_check_string(value, -1);
    if (iVar1 != 0) {
        iVar1 = json_string_set_nocheck(json, value);
        return iVar1;
    }
    return -1;
}

json_t *json_integer(json_int_t value)

{
    json_t *pjVar1;

    pjVar1 = (json_t *)jsonp_malloc(0x10);
    if (pjVar1 != (json_t *)0x0) {
        pjVar1[1].type = (int)value;
        pjVar1[1].refcount = (int)((ulonglong)value >> 0x20);
        pjVar1->type = JSON_INTEGER;
        pjVar1->refcount = 1;
    }
    return pjVar1;
}

/* WARNING: Unknown calling convention */

json_int_t json_integer_value(json_t *json)

{
    json_int_t jVar1;

    if ((json != (json_t *)0x0) && (json->type == JSON_INTEGER)) {
        jVar1._0_4_ = json[1].type;
        jVar1._4_4_ = json[1].refcount;
        return jVar1;
    }
    return 0;
}

int json_integer_set(json_t *json, json_int_t value)

{
    if ((json != (json_t *)0x0) && (json->type == JSON_INTEGER)) {
        json[1].type = (int)value;
        json[1].refcount = (int)((ulonglong)value >> 0x20);
        return 0;
    }
    return -1;
}

json_t *json_real(double value)

{
    json_t *pjVar1;

    if (!NAN(value)) {
        if (ABS(value) <= 1.79769313486232e+308) {
            pjVar1 = (json_t *)jsonp_malloc(0x10);
            if (pjVar1 != (json_t *)0x0) {
                pjVar1[1] = (json_t)value;
                pjVar1->type = JSON_REAL;
                pjVar1->refcount = 1;
            }
            return pjVar1;
        }
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

double json_real_value(json_t *json)

{
    if ((json != (json_t *)0x0) && (json->type == JSON_REAL)) {
        return (double)json[1];
    }
    return 0.0;
}

int json_real_set(json_t *json, double value)

{
    if (((json != (json_t *)0x0) && (json->type == JSON_REAL && !NAN(value))) &&
        (ABS(value) <= 1.79769313486232e+308)) {
        json[1] = (json_t)value;
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

double json_number_value(json_t *json)

{
    double dVar1;

    if (json == (json_t *)0x0) {
        return 0.0;
    }
    if (json->type != JSON_INTEGER) {
        if (json->type != JSON_REAL) {
            return 0.0;
        }
        return (double)json[1];
    }
    dVar1 = (double)__aeabi_l2d(json[1].type, json[1].refcount);
    return dVar1;
}

/* WARNING: Unknown calling convention */

json_t *json_true(void)

{
    return &json_true::the_true;
}

/* WARNING: Unknown calling convention */

json_t *json_false(void)

{
    return &json_false::the_false;
}

/* WARNING: Unknown calling convention */

json_t *json_null(void)

{
    return &json_null::the_null;
}

/* WARNING: Unknown calling convention */

void json_delete(json_t *json)

{
    json_t *json_00;
    uint uVar1;
    void *ptr;
    json_type jVar2;
    size_t sVar3;
    uint uVar4;

    if (json == (json_t *)0x0) {
        return;
    }
    jVar2 = json->type;
    if (jVar2 == JSON_OBJECT) {
        hashtable_close((hashtable_t *)(json + 1));
        jsonp_free(json);
        return;
    }
    if (jVar2 == JSON_ARRAY) {
        uVar1 = json[1].refcount;
        ptr = (void *)json[2].type;
        if (uVar1 != 0) {
            uVar4 = 0;
            do {
                json_00 = *(json_t **)((int)ptr + uVar4 * 4);
                uVar4 = uVar4 + 1;
                if (((json_00 != (json_t *)0x0) &&
                     (sVar3 = json_00->refcount - 1,
                      json_00->refcount != 0xffffffff)) &&
                    (json_00->refcount = sVar3, sVar3 == 0)) {
                    json_delete(json_00);
                    uVar1 = json[1].refcount;
                    ptr = (void *)json[2].type;
                }
            } while (uVar4 < uVar1);
        }
        jsonp_free(ptr);
        jsonp_free(json);
        return;
    }
    if (jVar2 != JSON_STRING) {
        if (1 < jVar2 - JSON_INTEGER) {
            return;
        }
        jsonp_free(json);
        return;
    }
    jsonp_free((void *)json[1].type);
    jsonp_free(json);
    return;
}

/* WARNING: Unknown calling convention */

int json_array_clear(json_t *json)

{
    json_t *json_00;
    uint uVar1;
    size_t sVar2;
    uint uVar3;

    if (json == (json_t *)0x0) {
        return -1;
    }
    if (json->type == JSON_ARRAY) {
        uVar1 = json[1].refcount;
        if (uVar1 != 0) {
            uVar3 = 0;
            do {
                json_00 = *(json_t **)(json[2].type + uVar3 * 4);
                uVar3 = uVar3 + 1;
                if (((json_00 != (json_t *)0x0) &&
                     (sVar2 = json_00->refcount - 1,
                      json_00->refcount != 0xffffffff)) &&
                    (json_00->refcount = sVar2, sVar2 == 0)) {
                    json_delete(json_00);
                    uVar1 = json[1].refcount;
                }
            } while (uVar3 < uVar1);
        }
        json[1].refcount = 0;
        return 0;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_array_remove(json_t *json, size_t index)

{
    json_t *json_00;
    size_t sVar1;
    size_t sVar2;

    if (((json == (json_t *)0x0) || (json->type != JSON_ARRAY)) ||
        (sVar1 = json[1].refcount, sVar1 <= index)) {
        return -1;
    }
    json_00 = *(json_t **)(json[2].type + index * 4);
    if (((json_00 != (json_t *)0x0) && (json_00->refcount != 0xffffffff)) &&
        (sVar2 = json_00->refcount - 1, json_00->refcount = sVar2,
         sVar2 == 0)) {
        json_delete(json_00);
        sVar1 = json[1].refcount;
    }
    if (sVar1 - 1 <= index) {
        json[1].refcount = sVar1 - 1;
        return 0;
    }
    memmove((void *)(json[2].type + index * 4),
            (void *)(index * 4 + 4 + json[2].type), (sVar1 + ~index) * 4);
    json[1].refcount = json[1].refcount - 1;
    return 0;
}

/* WARNING: Unknown calling convention */

int json_array_set_new(json_t *json, size_t index, json_t *value)

{
    json_t *json_00;
    size_t sVar1;
    json_type jVar2;

    if (value == (json_t *)0x0) {
        return -1;
    }
    if (((json != (json_t *)0x0) &&
         (json->type == JSON_ARRAY && value != json)) &&
        (index < json[1].refcount)) {
        jVar2 = json[2].type;
        json_00 = *(json_t **)(jVar2 + index * 4);
        if (((json_00 == (json_t *)0x0) || (json_00->refcount == 0xffffffff)) ||
            (sVar1 = json_00->refcount - 1, json_00->refcount = sVar1,
             sVar1 != 0)) {
            *(json_t **)(jVar2 + index * 4) = value;
        } else {
            json_delete(json_00);
            *(json_t **)(json[2].type + index * 4) = value;
        }
        return 0;
    }
    if ((value->refcount != 0xffffffff) &&
        (sVar1 = value->refcount - 1, value->refcount = sVar1, sVar1 == 0)) {
        json_delete(value);
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_object_set_new_nocheck(json_t *json, char *key, json_t *value)

{
    int iVar1;
    size_t sVar2;

    if (value == (json_t *)0x0) {
        return -1;
    }
    if ((json != (json_t *)0x0 && key != (char *)0x0) &&
        (json->type == JSON_OBJECT && value != json)) {
        sVar2 = json[3].refcount;
        json[3].refcount = sVar2 + 1;
        iVar1 = hashtable_set((hashtable_t *)(json + 1), key, sVar2, value);
        if (iVar1 == 0) {
            return 0;
        }
    }
    if ((value->refcount != 0xffffffff) &&
        (sVar2 = value->refcount - 1, value->refcount = sVar2, sVar2 == 0)) {
        json_delete(value);
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_object_update(json_t *object, json_t *other)

{
    void *iter;
    int iVar1;
    char *key;
    json_t *value;

    if (object == (json_t *)0x0) {
        return -1;
    }
    if ((object->type != JSON_OBJECT || other == (json_t *)0x0) ||
        (other->type != JSON_OBJECT)) {
        return -1;
    }
    iter = hashtable_iter((hashtable_t *)(other + 1));
    if (iter != (void *)0x0) {
        while (key = (char *)hashtable_iter_key(iter), key != (char *)0x0) {
            value = (json_t *)hashtable_iter_value(key + -0x10);
            if (value == (json_t *)0x0) {
                return 0;
            }
            if (value->refcount != 0xffffffff) {
                value->refcount = value->refcount + 1;
            }
            iVar1 = json_object_set_new_nocheck(object, key, value);
            if (iVar1 != 0) {
                return -1;
            }
            if (other->type != JSON_OBJECT) {
                return 0;
            }
            iter = hashtable_iter_next((hashtable_t *)(other + 1), key + -0x10);
            if (iter == (void *)0x0) {
                return 0;
            }
        }
    }
    return 0;
}

/* WARNING: Unknown calling convention */

int json_object_update_existing(json_t *object, json_t *other)

{
    void *pvVar1;
    char *key;
    json_t *value;
    json_type jVar2;

    if (((object == (json_t *)0x0) ||
         (object->type != JSON_OBJECT || other == (json_t *)0x0)) ||
        (other->type != JSON_OBJECT)) {
        return -1;
    }
    pvVar1 = hashtable_iter((hashtable_t *)(other + 1));
    if ((pvVar1 != (void *)0x0) &&
        (key = (char *)hashtable_iter_key(pvVar1), key != (char *)0x0)) {
        while (true) {
            value = (json_t *)hashtable_iter_value(key + -0x10);
            if (value == (json_t *)0x0)
                break;
            if ((object->type == JSON_OBJECT) &&
                (pvVar1 = hashtable_get((hashtable_t *)(object + 1), key),
                 pvVar1 != (void *)0x0)) {
                if (value->refcount != 0xffffffff) {
                    value->refcount = value->refcount + 1;
                }
                json_object_set_new_nocheck(object, key, value);
                jVar2 = other->type;
            } else {
                jVar2 = other->type;
            }
            if (jVar2 != JSON_OBJECT) {
                return 0;
            }
            pvVar1 =
                hashtable_iter_next((hashtable_t *)(other + 1), key + -0x10);
            if (pvVar1 == (void *)0x0) {
                return 0;
            }
            key = (char *)hashtable_iter_key(pvVar1);
            if (key == (char *)0x0) {
                return 0;
            }
        }
    }
    return 0;
}

/* WARNING: Unknown calling convention */

int json_object_update_missing(json_t *object, json_t *other)

{
    void *pvVar1;
    char *key;
    json_t *value;
    size_t sVar2;
    json_type jVar3;
    bool bVar4;

    if (((object == (json_t *)0x0) ||
         (object->type != JSON_OBJECT || other == (json_t *)0x0)) ||
        (other->type != JSON_OBJECT)) {
        return -1;
    }
    pvVar1 = hashtable_iter((hashtable_t *)(other + 1));
    if ((pvVar1 != (void *)0x0) &&
        (key = (char *)hashtable_iter_key(pvVar1), key != (char *)0x0)) {
        while (true) {
            value = (json_t *)hashtable_iter_value(key + -0x10);
            if (value == (json_t *)0x0)
                break;
            if ((object->type == JSON_OBJECT) &&
                (pvVar1 = hashtable_get((hashtable_t *)(object + 1), key),
                 pvVar1 != (void *)0x0)) {
                jVar3 = other->type;
            } else {
                sVar2 = value->refcount;
                bVar4 = sVar2 != 0xffffffff;
                if (bVar4) {
                    sVar2 = sVar2 + 1;
                }
                if (bVar4) {
                    value->refcount = sVar2;
                }
                json_object_set_new_nocheck(object, key, value);
                jVar3 = other->type;
            }
            if (jVar3 != JSON_OBJECT) {
                return 0;
            }
            pvVar1 =
                hashtable_iter_next((hashtable_t *)(other + 1), key + -0x10);
            if (pvVar1 == (void *)0x0) {
                return 0;
            }
            key = (char *)hashtable_iter_key(pvVar1);
            if (key == (char *)0x0) {
                return 0;
            }
        }
    }
    return 0;
}

/* WARNING: Unknown calling convention */

int json_object_set_new(json_t *json, char *key, json_t *value)

{
    int iVar1;
    size_t sVar2;

    if ((key != (char *)0x0) &&
        (iVar1 = utf8_check_string(key, -1), iVar1 != 0)) {
        iVar1 = json_object_set_new_nocheck(json, key, value);
        return iVar1;
    }
    if ((value != (json_t *)0x0) && ((value->refcount != 0xffffffff &&
                                      (sVar2 = value->refcount - 1,
                                       value->refcount = sVar2, sVar2 == 0)))) {
        json_delete(value);
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_array_insert_new(json_t *json, size_t index, json_t *value)

{
    json_t **__src;
    json_t **__dest;
    size_t sVar1;
    int iVar2;
    size_t __n;

    if (value != (json_t *)0x0) {
        if ((((json == (json_t *)0x0) ||
              (json->type != JSON_ARRAY || value == json)) ||
             (json[1].refcount < index)) ||
            (__src = json_array_grow((json_array_t *)json, 1, 0),
             __src == (json_t **)0x0)) {
            if ((value->refcount != 0xffffffff) &&
                (sVar1 = value->refcount - 1, value->refcount = sVar1,
                 sVar1 == 0)) {
                json_delete(value);
            }
            iVar2 = -1;
        } else {
            __dest = (json_t **)json[2].type;
            iVar2 = (index + 1) * 4;
            __n = iVar2 - 4;
            if (__dest == __src) {
                memmove(__dest + index + 1, __src + index,
                        (json[1].refcount - index) * 4);
            } else {
                memcpy(__dest, __src, __n);
                memcpy((void *)(json[2].type + iVar2), __src + index,
                       (json[1].refcount - index) * 4);
                jsonp_free(__src);
            }
            sVar1 = json[1].refcount;
            iVar2 = 0;
            *(json_t **)(json[2].type + __n) = value;
            json[1].refcount = sVar1 + 1;
        }
        return iVar2;
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_array_append_new(json_t *json, json_t *value)

{
    json_t **ppjVar1;
    size_t sVar2;

    if (value == (json_t *)0x0) {
        return -1;
    }
    if (((json != (json_t *)0x0) &&
         (json->type == JSON_ARRAY && value != json)) &&
        (ppjVar1 = json_array_grow((json_array_t *)json, 1, 1),
         ppjVar1 != (json_t **)0x0)) {
        sVar2 = json[1].refcount;
        *(json_t **)(json[2].type + sVar2 * 4) = value;
        json[1].refcount = sVar2 + 1;
        return 0;
    }
    if ((value->refcount != 0xffffffff) &&
        (sVar2 = value->refcount - 1, value->refcount = sVar2, sVar2 == 0)) {
        json_delete(value);
    }
    return -1;
}

/* WARNING: Unknown calling convention */

int json_equal(json_t *json1, json_t *json2)

{
    int iVar1;

    if (json2 != (json_t *)0x0 && json1 != (json_t *)0x0) {
        iVar1 = json_equal(json1, json2);
        return iVar1;
    }
    return 0;
}

/* WARNING: Unknown calling convention */

json_t *json_copy(json_t *json)

{
    void *iter;
    char *key;
    json_t *pjVar1;
    json_t *pjVar2;
    json_type jVar3;
    uint uVar4;
    uint uVar5;

    if (json != (json_t *)0x0) {
        jVar3 = json->type;
        if (jVar3 == JSON_OBJECT) {
            pjVar1 = json_object();
            if (pjVar1 != (json_t *)0x0) {
                if (json->type != JSON_OBJECT) {
                    return pjVar1;
                }
                iter = hashtable_iter((hashtable_t *)(json + 1));
                if (iter == (void *)0x0) {
                    return pjVar1;
                }
                while (true) {
                    key = (char *)hashtable_iter_key(iter);
                    if (key == (char *)0x0) {
                        return pjVar1;
                    }
                    pjVar2 = (json_t *)hashtable_iter_value(key + -0x10);
                    if (pjVar2 == (json_t *)0x0)
                        break;
                    if (pjVar2->refcount != 0xffffffff) {
                        pjVar2->refcount = pjVar2->refcount + 1;
                    }
                    json_object_set_new_nocheck(pjVar1, key, pjVar2);
                    if (json->type != JSON_OBJECT) {
                        return pjVar1;
                    }
                    iter = hashtable_iter_next((hashtable_t *)(json + 1),
                                               key + -0x10);
                    if (iter == (void *)0x0) {
                        return pjVar1;
                    }
                }
                return pjVar1;
            }
        } else if (jVar3 == JSON_ARRAY) {
            pjVar1 = json_array();
            if (pjVar1 != (json_t *)0x0) {
                if (json->type != JSON_ARRAY) {
                    return pjVar1;
                }
                uVar4 = json[1].refcount;
                if (uVar4 == 0) {
                    return pjVar1;
                }
                uVar5 = 0;
                while (true) {
                    pjVar2 = (json_t *)0x0;
                    if ((uVar5 < uVar4) &&
                        (pjVar2 = *(json_t **)(json[2].type + uVar5 * 4),
                         pjVar2 != (json_t *)0x0)) {
                        if (pjVar2->refcount != 0xffffffff) {
                            pjVar2->refcount = pjVar2->refcount + 1;
                        }
                    }
                    json_array_append_new(pjVar1, pjVar2);
                    if (json->type != JSON_ARRAY)
                        break;
                    uVar4 = json[1].refcount;
                    uVar5 = uVar5 + 1;
                    if (uVar4 <= uVar5) {
                        return pjVar1;
                    }
                }
                return pjVar1;
            }
        } else {
            if (jVar3 == JSON_STRING) {
                pjVar1 = json_string_nocheck((char *)json[1].type);
                return pjVar1;
            }
            if (jVar3 == JSON_INTEGER) {
                pjVar1 = json_integer_copy(json);
                return pjVar1;
            }
            if (jVar3 == JSON_REAL) {
                pjVar1 = json_real((double)json[1]);
                return pjVar1;
            }
            if (jVar3 - JSON_TRUE < 3) {
                return json;
            }
        }
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

json_t *json_deep_copy(json_t *json)

{
    void *iter;
    char *key;
    json_t *pjVar1;
    json_t *pjVar2;
    json_type jVar3;
    uint uVar4;
    uint uVar5;

    if (json != (json_t *)0x0) {
        jVar3 = json->type;
        if (jVar3 == JSON_OBJECT) {
            pjVar2 = json_object();
            if (pjVar2 != (json_t *)0x0) {
                if (json->type != JSON_OBJECT) {
                    return pjVar2;
                }
                iter = hashtable_iter((hashtable_t *)(json + 1));
                while (true) {
                    if (iter == (void *)0x0) {
                        return pjVar2;
                    }
                    key = (char *)hashtable_iter_key(iter);
                    pjVar1 = (json_t *)hashtable_iter_value(iter);
                    pjVar1 = json_deep_copy(pjVar1);
                    json_object_set_new_nocheck(pjVar2, key, pjVar1);
                    if (json->type != JSON_OBJECT)
                        break;
                    iter = hashtable_iter_next((hashtable_t *)(json + 1), iter);
                }
                return pjVar2;
            }
        } else if (jVar3 == JSON_ARRAY) {
            pjVar2 = json_array();
            if (pjVar2 != (json_t *)0x0) {
                if (json->type != JSON_ARRAY) {
                    return pjVar2;
                }
                uVar4 = json[1].refcount;
                if (uVar4 == 0) {
                    return pjVar2;
                }
                uVar5 = 0;
                while (true) {
                    pjVar1 = (json_t *)0x0;
                    if (uVar5 < uVar4) {
                        pjVar1 = *(json_t **)(json[2].type + uVar5 * 4);
                    }
                    pjVar1 = json_deep_copy(pjVar1);
                    json_array_append_new(pjVar2, pjVar1);
                    if (json->type != JSON_ARRAY)
                        break;
                    uVar4 = json[1].refcount;
                    uVar5 = uVar5 + 1;
                    if (uVar4 <= uVar5) {
                        return pjVar2;
                    }
                }
                return pjVar2;
            }
        } else {
            if (jVar3 == JSON_STRING) {
                pjVar2 = json_string_nocheck((char *)json[1].type);
                return pjVar2;
            }
            if (jVar3 == JSON_INTEGER) {
                pjVar2 = json_integer_copy(json);
                return pjVar2;
            }
            if (jVar3 == JSON_REAL) {
                pjVar2 = json_real((double)json[1]);
                return pjVar2;
            }
            if (jVar3 - JSON_TRUE < 3) {
                return json;
            }
        }
    }
    return (json_t *)0x0;
}

/* WARNING: Unknown calling convention */

void jsonp_error_set_source(json_error_t *error, char *source)

{
    size_t sVar1;

    sVar1 = strlen(source);
    if (sVar1 < 0x50) {
        memcpy(error->source, source, sVar1 + 1);
        return;
    }
    builtin_strncpy(error->source, "...", 4);
    strcpy(error->source + 3, source + (sVar1 - 0x4c));
    return;
}

/* WARNING: Unknown calling convention */

void jsonp_error_init(json_error_t *error, char *source)

{
    if (error == (json_error_t *)0x0) {
        return;
    }
    error->text[0] = '\0';
    error->position = 0;
    error->line = -1;
    error->column = -1;
    if (source == (char *)0x0) {
        error->source[0] = '\0';
        return;
    }
    jsonp_error_set_source(error, source);
    return;
}

/* WARNING: Unknown calling convention */

void jsonp_error_set_source(json_error_t *error, char *source)

{
    if (source != (char *)0x0 && error != (json_error_t *)0x0) {
        jsonp_error_set_source(error, source);
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void jsonp_error_set(json_error_t *error, int line, int column, size_t position,
                     char *msg, ...)

{
    va_list ap;

    if ((error != (json_error_t *)0x0) && (error->text[0] == '\0')) {
        error->line = line;
        error->column = column;
        error->position = position;
        vsnprintf(error->text, 0xa0, msg, &stack0x00000004);
        error->text[0x9f] = '\0';
        return;
    }
    return;
}

/* WARNING: Unknown calling convention */

void jsonp_error_vset(json_error_t *error, int line, int column,
                      size_t position, char *msg, va_list ap)

{
    if (error == (json_error_t *)0x0) {
        return;
    }
    if (error->text[0] != '\0') {
        return;
    }
    error->line = line;
    error->column = column;
    error->position = position;
    vsnprintf(error->text, 0xa0, msg, ap.__ap);
    error->text[0x9f] = '\0';
    return;
}

/* WARNING: Unknown calling convention */

char *arg_bad(char *fmt, char *arg)

{
    size_t sVar1;
    size_t sVar2;
    char *__s;

    sVar1 = strlen(fmt);
    sVar2 = strlen(arg);
    __s = (char *)malloc(sVar2 + sVar1);
    sprintf(__s, fmt, arg);
    return __s;
}

/* WARNING: Unknown calling convention */

char *opt_set_bool(_Bool *b)

{
    *b = true;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *opt_set_invbool(_Bool *b)

{
    *b = false;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *opt_set_bool_arg(char *arg, _Bool *b)

{
    int iVar1;
    char *pcVar2;

    iVar1 = strcasecmp(arg, "yes");
    if ((iVar1 == 0) || (iVar1 = strcasecmp(arg, "true"), iVar1 == 0)) {
        *b = true;
        return (char *)0x0;
    }
    iVar1 = strcasecmp(arg, "no");
    if ((iVar1 != 0) && (iVar1 = strcasecmp(arg, "false"), iVar1 != 0)) {
        pcVar2 = opt_invalid_argument(arg);
        return pcVar2;
    }
    *b = false;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *opt_set_invbool_arg(char *arg, _Bool *b)

{
    char *pcVar1;

    pcVar1 = opt_set_bool_arg(arg, b);
    if (pcVar1 != (char *)0x0) {
        return pcVar1;
    }
    *b = (_Bool)(*b ^ 1);
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *opt_set_charp(char *arg, char **p)

{
    *p = arg;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *opt_set_floatval(char *arg, float *f)

{
    int *piVar1;
    char *pcVar2;
    float fVar3;
    char *endp;

    piVar1 = __errno_location();
    *piVar1 = 0;
    fVar3 = strtof(arg, &endp);
    *f = fVar3;
    if ((*endp == '\0') && (*arg != '\0')) {
        pcVar2 = (char *)*piVar1;
        if (pcVar2 != (char *)0x0) {
            pcVar2 = arg_bad("\'%s\' is out of range", arg);
            return pcVar2;
        }
    } else {
        pcVar2 = arg_bad("\'%s\' is not a number", arg);
    }
    return pcVar2;
}

/* WARNING: Unknown calling convention */

char *opt_set_longval(char *arg, long *l)

{
    int *piVar1;
    long lVar2;
    char *pcVar3;
    char *endp;

    piVar1 = __errno_location();
    *piVar1 = 0;
    lVar2 = strtol(arg, &endp, 0);
    *l = lVar2;
    if ((*endp == '\0') && (*arg != '\0')) {
        pcVar3 = (char *)*piVar1;
        if (pcVar3 != (char *)0x0) {
            pcVar3 = arg_bad("\'%s\' is out of range", arg);
            return pcVar3;
        }
    } else {
        pcVar3 = arg_bad("\'%s\' is not a number", arg);
    }
    return pcVar3;
}

/* WARNING: Unknown calling convention */

char *opt_set_intval(char *arg, int *i)

{
    char *pcVar1;
    long l;

    pcVar1 = opt_set_longval(arg, &l);
    if (pcVar1 == (char *)0x0) {
        *i = l;
    }
    return pcVar1;
}

/* WARNING: Variable defined which should be unmapped: l */
/* WARNING: Unknown calling convention */

char *opt_set_uintval(char *arg, uint *ui)

{
    char *pcVar1;
    uint local_14[2];
    long l;

    pcVar1 = opt_set_longval(arg, (long *)local_14);
    if (pcVar1 == (char *)0x0) {
        if ((int)local_14[0] < 0) {
            pcVar1 = arg_bad("\'%s\' is negative", arg);
            return pcVar1;
        }
        *ui = local_14[0];
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *opt_set_ulongval(char *arg, ulong *ul)

{
    char *pcVar1;
    long l;

    pcVar1 = opt_set_longval(arg, &l);
    if ((pcVar1 == (char *)0x0) && (*ul = l, l < 0)) {
        pcVar1 = arg_bad("\'%s\' is negative", arg);
        return pcVar1;
    }
    return pcVar1;
}

/* WARNING: Unknown calling convention */

char *opt_inc_intval(int *i)

{
    *i = *i + 1;
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

char *opt_version_and_exit(char *version)

{
    puts(version);
    fflush(stdout);
    /* WARNING: Subroutine does not return */
    exit(0);
}

/* WARNING: Unknown calling convention */

char *opt_usage_and_exit(char *extra)

{
    char *pcVar1;

    pcVar1 = opt_usage(opt_argv0, extra);
    printf("%s", pcVar1);
    fflush(stdout);
    /* WARNING: Subroutine does not return */
    exit(0);
}

/* WARNING: Unknown calling convention */

void opt_show_bool(char *buf, _Bool *b)

{
    char *__src;

    __src = "true";
    if (*b == false) {
        __src = "false";
    }
    strncpy(buf, __src, 0x50);
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_invbool(char *buf, _Bool *b)

{
    char *__src;

    __src = "false";
    if (*b == false) {
        __src = "true";
    }
    strncpy(buf, __src, 0x50);
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_charp(char *buf, char **p)

{
    size_t __n;

    __n = strlen(*p);
    *buf = '\"';
    if (__n < 0x4f) {
        strncpy(buf + 1, *p, __n);
        buf[__n + 1] = '\"';
        if (__n != 0x4e) {
            buf[__n + 2] = '\0';
        }
        return;
    }
    strncpy(buf + 1, *p, 0x4e);
    buf[0x4f] = '\"';
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_intval(char *buf, int *i)

{
    snprintf(buf, 0x50, "%i", *i);
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_floatval(char *buf, float *f)

{
    undefined4 in_r3;

    snprintf(buf, 0x50, "%.1f", in_r3, (double)*f);
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_uintval(char *buf, uint *ui)

{
    snprintf(buf, 0x50, "%u", *ui);
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_longval(char *buf, long *l)

{
    snprintf(buf, 0x50, "%li", *l);
    return;
}

/* WARNING: Unknown calling convention */

void opt_show_ulongval(char *buf, ulong *ul)

{
    snprintf(buf, 0x50, "%lu", *ul);
    return;
}

/* WARNING: Unknown calling convention */

char *first_opt(uint *i, uint *len)

{
    opt_table *poVar1;
    opt_table *poVar2;
    size_t sVar3;
    opt_table *poVar4;
    char *__s;
    uint uVar5;

    *i = 0;
    if (opt_count == 0) {
    LAB_0004b064:
        __s = (char *)0x0;
    } else {
        poVar4 = opt_table;
        if (opt_table->type == OPT_SUBTABLE) {
            uVar5 = 1;
            poVar1 = opt_table;
            do {
                poVar4 = poVar1 + 1;
                *i = uVar5;
                if (opt_count <= uVar5)
                    goto LAB_0004b064;
                poVar2 = poVar1 + 1;
                uVar5 = uVar5 + 1;
                poVar1 = poVar4;
            } while (poVar2->type == OPT_SUBTABLE);
        }
        __s = poVar4->names + 1;
        sVar3 = strcspn(__s, "|= ");
        *len = sVar3;
    }
    return __s;
}

/* WARNING: Unknown calling convention */

char *next_name(char *names, uint *len)

{
    size_t sVar1;
    char *__s;

    if ((names[*len] & 0xdfU) == 0 || names[*len] == 0x3d) {
        __s = (char *)0x0;
    } else {
        __s = names + *len + 2;
        sVar1 = strcspn(__s, "|= ");
        *len = sVar1;
    }
    return __s;
}

/* WARNING: Unknown calling convention */

char *next_opt(char *p, uint *i, uint *len)

{
    char *pcVar1;
    size_t sVar2;
    uint uVar3;

    uVar3 = *i;
    if (uVar3 < opt_count) {
        do {
            if (opt_table[uVar3].type != OPT_SUBTABLE) {
                if (p == (char *)0x0) {
                    pcVar1 = opt_table[uVar3].names + 1;
                    sVar2 = strcspn(pcVar1, "|= ");
                    *len = sVar2;
                    return pcVar1;
                }
                pcVar1 = next_name(p, len);
                if (pcVar1 != (char *)0x0) {
                    return pcVar1;
                }
                uVar3 = *i;
                p = (char *)0x0;
            }
            uVar3 = uVar3 + 1;
            *i = uVar3;
        } while (uVar3 < opt_count);
    }
    return (char *)0x0;
}

/* WARNING: Unknown calling convention */

void check_opt(opt_table *entry)

{
    uint uVar1;
    undefined4 *puVar2;
    anon_union_4_3_d8f38084_for_u aVar3;
    _func_char_ptr_void_ptr *p_Var4;
    opt_type oVar5;
    _func_char_ptr_char_ptr_void_ptr *p_Var6;
    char *pcVar7;
    opt_table *poVar8;
    opt_type unaff_r5;
    bool bVar9;
    uint len;

    oVar5 = entry->type;
    bVar9 = (OPT_HASARG | OPT_NOARG) < oVar5;
    if (oVar5 != OPT_PROCESSARG) {
        bVar9 = oVar5 != OPT_NOARG;
    }
    if (!bVar9 || (oVar5 == OPT_PROCESSARG || oVar5 == OPT_HASARG)) {
        if (entry->desc != (char *)0x0) {
            if (*entry->names == '-') {
                pcVar7 = entry->names + 1;
                len = strcspn(pcVar7, "|= ");
                while (*pcVar7 == '-') {
                    uVar1 = len;
                    if (len == 1)
                        goto LAB_0004b1e0;
                    unaff_r5 = entry->type;
                    opt_num_long = opt_num_long + 1;
                LAB_0004b180:
                    if ((unaff_r5 == OPT_NOARG) &&
                        (uVar1 = len, pcVar7[len] == '=' || pcVar7[len] == ' '))
                        goto LAB_0004b1cc;
                    pcVar7 = next_name(pcVar7, &len);
                    if (pcVar7 == (char *)0x0) {
                        return;
                    }
                }
                if (len == 1) {
                    unaff_r5 = entry->type;
                    opt_num_short = opt_num_short + 1;
                    if ((unaff_r5 - OPT_HASARG & 0xfffffffd) == 0) {
                        opt_num_short_arg = opt_num_short_arg + 1;
                    }
                    goto LAB_0004b180;
                }
                pcVar7 = pcVar7 + -1;
                uVar1 = errx(1, "Option %s: invalid short option \'%.*s\'",
                             entry->names, len + 1, pcVar7);
            LAB_0004b1cc:
                uVar1 =
                    errx(unaff_r5, "Option %s: does not take arguments \'%s\'",
                         entry->names, pcVar7 + uVar1 + 1);
            LAB_0004b1e0:
                errx(uVar1, "Option %s: invalid long option \'--\'",
                     entry->names);
            }
            errx(1, "Option %s: does not begin with \'-\'");
        }
        errx(1, "Option %s: description cannot be NULL");
    }
    puVar2 = (undefined4 *)errx(1, "Option %s: unknown entry type %u");
    opt_table = (opt_table *)realloc(opt_table, (opt_count + 1) * 0x1c);
    oVar5 = puVar2[1];
    p_Var4 = (_func_char_ptr_void_ptr *)puVar2[2];
    p_Var6 = (_func_char_ptr_char_ptr_void_ptr *)puVar2[3];
    poVar8 = opt_table + opt_count;
    opt_count = opt_count + 1;
    poVar8->names = (char *)*puVar2;
    poVar8->type = oVar5;
    poVar8->cb = p_Var4;
    poVar8->cb_arg = p_Var6;
    aVar3 = *(anon_union_4_3_d8f38084_for_u *)(puVar2 + 5);
    pcVar7 = (char *)puVar2[6];
    poVar8->show = (_func_void_char_ptr_void_ptr *)puVar2[4];
    poVar8->u = aVar3;
    poVar8->desc = pcVar7;
    return;
}

/* WARNING: Unknown calling convention */

void add_opt(opt_table *entry)

{
    opt_type oVar1;
    anon_union_4_3_d8f38084_for_u aVar2;
    _func_char_ptr_void_ptr *p_Var3;
    char *pcVar4;
    _func_char_ptr_char_ptr_void_ptr *p_Var5;
    opt_table *poVar6;

    opt_table = (opt_table *)realloc(opt_table, (opt_count + 1) * 0x1c);
    oVar1 = entry->type;
    p_Var3 = entry->cb;
    p_Var5 = entry->cb_arg;
    poVar6 = opt_table + opt_count;
    opt_count = opt_count + 1;
    poVar6->names = entry->names;
    poVar6->type = oVar1;
    poVar6->cb = p_Var3;
    poVar6->cb_arg = p_Var5;
    aVar2 = entry->u;
    pcVar4 = entry->desc;
    poVar6->show = entry->show;
    poVar6->u = aVar2;
    poVar6->desc = pcVar4;
    return;
}

/* WARNING: Unknown calling convention */

char *first_lopt(uint *i, uint *len)

{
    char *p;

    p = first_opt(i, len);
    while (true) {
        if (p == (char *)0x0) {
            return (char *)0x0;
        }
        if (*p == '-')
            break;
        p = next_opt(p, i, len);
    }
    *len = *len - 1;
    return p + 1;
}

/* WARNING: Unknown calling convention */

char *next_lopt(char *p, uint *i, uint *len)

{
    char *p_00;

    p_00 = next_opt(p, i, len);
    while (true) {
        if (p_00 == (char *)0x0) {
            return (char *)0x0;
        }
        if (*p_00 == '-')
            break;
        p_00 = next_opt(p_00, i, len);
    }
    *len = *len - 1;
    return p_00 + 1;
}

/* WARNING: Unknown calling convention */

char *first_sopt(uint *i)

{
    char *p;
    uint len;

    len = 0;
    p = first_opt(i, &len);
    while (true) {
        if (p == (char *)0x0) {
            return (char *)0x0;
        }
        if (*p != '-')
            break;
        p = next_opt(p, i, &len);
    }
    return p;
}

/* WARNING: Unknown calling convention */

char *next_sopt(char *p, uint *i)

{
    char *p_00;
    uint len;

    len = 1;
    p_00 = next_opt(p, i, &len);
    while (true) {
        if (p_00 == (char *)0x0) {
            return (char *)0x0;
        }
        if (*p_00 != '-')
            break;
        p_00 = next_opt(p_00, i, &len);
    }
    return p_00;
}

/* WARNING: Unknown calling convention */

void _opt_register(char *names, opt_type type, _func_char_ptr_void_ptr *cb,
                   _func_char_ptr_char_ptr_void_ptr *cb_arg,
                   _func_void_char_ptr_void_ptr *show, void *arg, char *desc)

{
    opt_table opt;

    opt.desc = desc;
    opt.show = show;
    opt.u.carg = arg;
    opt.names = names;
    opt.type = type;
    opt.cb = cb;
    opt.cb_arg = cb_arg;
    check_opt(&opt);
    add_opt(&opt);
    return;
}

/* WARNING: Unknown calling convention */

void opt_register_table(opt_table *entry, char *desc)

{
    uint uVar1;
    opt_type oVar2;
    opt_table heading;

    uVar1 = opt_count;
    if (desc == (char *)0x0) {
        oVar2 = entry->type;
        if (oVar2 == OPT_END) {
            return;
        }
    } else {
        heading.names = (char *)0x0;
        heading.cb = (_func_char_ptr_void_ptr *)0x0;
        heading.cb_arg = (_func_char_ptr_char_ptr_void_ptr *)0x0;
        heading.show = (_func_void_char_ptr_void_ptr *)0x0;
        heading.u.carg = (void *)0x0;
        heading.type = OPT_SUBTABLE;
        heading.desc = desc;
        add_opt(&heading);
        oVar2 = entry->type;
        if (oVar2 == OPT_END)
            goto LAB_0004b394;
    }
    do {
        if (oVar2 == OPT_SUBTABLE) {
            opt_register_table((opt_table *)entry->names, entry->desc);
        } else {
            check_opt(entry);
            add_opt(entry);
        }
        oVar2 = entry[1].type;
        entry = entry + 1;
    } while (oVar2 != OPT_END);
    if (desc == (char *)0x0) {
        return;
    }
LAB_0004b394:
    opt_table[uVar1].u.carg = (void *)(opt_count - uVar1);
    return;
}

/* WARNING: Unknown calling convention */

_Bool opt_parse(int *argc, char **argv, _func_void_char_ptr_varargs *errlog)

{
    int iVar1;
    uint offset;

    opt_argv0 = *argv;
    offset = 0;
    do {
        iVar1 = parse_one(argc, argv, &offset, errlog);
    } while (iVar1 == 1);
    return iVar1 == 0;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void opt_free_table(void)

{
    free(opt_table);
    opt_table = (opt_table *)0x0;
    return;
}

void opt_log_stderr(char *fmt, ...)

{
    undefined4 in_r1;
    undefined4 in_r2;
    undefined4 in_r3;
    va_list ap;
    char *fmt_local;
    undefined4 uStack_c;
    undefined4 uStack_8;
    undefined4 uStack_4;

    uStack_c = in_r1;
    uStack_8 = in_r2;
    uStack_4 = in_r3;
    vfprintf(stderr, fmt, &uStack_c);
    fputc(10, stderr);
    return;
}

void opt_log_stderr_exit(char *fmt, ...)

{
    undefined4 in_r1;
    undefined4 in_r2;
    undefined4 in_r3;
    va_list ap;
    char *fmt_local;
    undefined4 uStack_c;
    undefined4 uStack_8;
    undefined4 uStack_4;

    uStack_c = in_r1;
    uStack_8 = in_r2;
    uStack_4 = in_r3;
    vfprintf(stderr, fmt, &uStack_c);
    fputc(10, stderr);
    /* WARNING: Subroutine does not return */
    exit(1);
}

/* WARNING: Unknown calling convention */

char *opt_invalid_argument(char *arg)

{
    size_t sVar1;
    char *__s;

    sVar1 = strlen(arg);
    __s = (char *)malloc(sVar1 + 0x16);
    sprintf(__s, "Invalid argument \'%s\'", arg);
    return __s;
}

/* WARNING: Unknown calling convention */

void consume_option(int *argc, char **argv, uint optnum)

{
    memmove(argv + optnum, argv + optnum + 1, (*argc - optnum) * 4);
    *argc = *argc + -1;
    return;
}

/* WARNING: Type propagation algorithm not settling */
/* WARNING: Unknown calling convention */

int parse_one(int *argc, char **argv, uint *offset,
              _func_void_char_ptr_varargs *errlog)

{
    char cVar1;
    char **ppcVar2;
    char *pcVar3;
    int iVar4;
    opt_type oVar5;
    size_t sVar6;
    uint uVar7;
    uint uVar8;
    opt_table *poVar9;
    uint optnum;
    char **ppcVar10;
    char *arg;
    char *pcVar11;
    char *local_38;
    uint i;
    uint len;

    pcVar3 = getenv("POSIXLY_CORRECT");
    if (pcVar3 == (char *)0x0) {
        pcVar3 = argv[1];
        if (pcVar3 == (char *)0x0) {
            return 0;
        }
        if (*pcVar3 == '-') {
            ppcVar10 = argv + 1;
            optnum = 1;
        } else {
            optnum = 1;
            ppcVar2 = argv + 2;
            do {
                ppcVar10 = ppcVar2;
                pcVar3 = *ppcVar10;
                optnum = optnum + 1;
                if (pcVar3 == (char *)0x0) {
                    return 0;
                }
                ppcVar2 = ppcVar10 + 1;
            } while (*pcVar3 != '-');
        }
        cVar1 = pcVar3[1];
    } else {
        pcVar3 = argv[1];
        ppcVar10 = argv + 1;
        if (pcVar3 == (char *)0x0) {
            return 0;
        }
        if (*pcVar3 != '-') {
            return 0;
        }
        cVar1 = pcVar3[1];
        optnum = 1;
    }
    if (cVar1 == '-') {
        if (pcVar3[2] == '\0') {
            consume_option(argc, argv, optnum);
            return 0;
        }
        if (*offset != 0) {
            /* WARNING: Subroutine does not return */
            __assert_fail("*offset == 0", "opt/parse.c", 0x3b, "parse_one");
        }
        pcVar3 = first_lopt(&i, &len);
        sVar6 = len;
        while (pcVar3 != (char *)0x0) {
            pcVar11 = *ppcVar10;
            len = sVar6;
            iVar4 = strncmp(pcVar11 + 2, pcVar3, sVar6);
            if (iVar4 == 0) {
                uVar7 = sVar6 + 2;
                if (pcVar11[uVar7] == '=') {
                    local_38 = pcVar3 + -2;
                    arg = pcVar11 + sVar6 + 3;
                    poVar9 = opt_table + i;
                    oVar5 = poVar9->type;
                    if (oVar5 == OPT_NOARG) {
                        len = uVar7;
                        if (arg != (char *)0x0) {
                            (*errlog)("%s: %.*s: %s", *argv, uVar7, local_38,
                                      "doesn\'t allow an argument");
                            return -1;
                        }
                        goto LAB_0004b5f0;
                    }
                    len = uVar7;
                    if (arg != (char *)0x0)
                        goto LAB_0004b586;
                } else {
                    if (pcVar11[uVar7] != '\0')
                        goto LAB_0004b668;
                    local_38 = pcVar3 + -2;
                    poVar9 = opt_table + i;
                    oVar5 = poVar9->type;
                    len = uVar7;
                    if (oVar5 == OPT_NOARG)
                        goto LAB_0004b5f0;
                }
                poVar9 = opt_table + i;
                local_38 = pcVar3 + -2;
                uVar8 = *offset;
                len = uVar7;
                goto LAB_0004b56c;
            }
        LAB_0004b668:
            pcVar3 = next_lopt(pcVar3, &i, &len);
            sVar6 = len;
        }
    } else {
        local_38 = first_sopt(&i);
        if (local_38 != (char *)0x0) {
            pcVar11 = *ppcVar10;
            uVar8 = *offset + 1;
            if (*local_38 != pcVar11[uVar8]) {
                do {
                    local_38 = next_sopt(local_38, &i);
                    if (local_38 == (char *)0x0)
                        goto LAB_0004b678;
                    pcVar11 = *ppcVar10;
                    uVar8 = *offset + 1;
                } while (pcVar11[uVar8] != *local_38);
            }
            poVar9 = opt_table;
            local_38 = local_38 + -1;
            *offset = uVar8;
            len = 2;
            poVar9 = poVar9 + i;
            oVar5 = poVar9->type;
            if (oVar5 == OPT_NOARG) {
            LAB_0004b5f0:
                arg = (char *)0x0;
                pcVar3 = (*poVar9->cb)((poVar9->u).carg);
            } else {
            LAB_0004b56c:
                if ((uVar8 == 0) ||
                    (arg = pcVar11 + uVar8 + 1, pcVar11[uVar8 + 1] == '\0')) {
                    arg = argv[optnum + 1];
                    if (arg == (char *)0x0) {
                        (*errlog)("%s: %.*s: %s", *argv, len, local_38,
                                  "requires an argument");
                        return -1;
                    }
                } else {
                    *offset = 0;
                }
            LAB_0004b586:
                if (oVar5 == OPT_PROCESSARG) {
                    opt_set_charp(arg, (char **)(poVar9->u).carg);
                }
                pcVar3 = (*opt_table[i].cb_arg)(arg, opt_table[i].u.carg);
            }
            if (pcVar3 != (char *)0x0) {
                (*errlog)("%s: %.*s: %s", *argv, len, local_38, pcVar3);
                free(pcVar3);
                return -1;
            }
            if (*offset != 0) {
                if ((*ppcVar10)[*offset + 1] != '\0') {
                    return 1;
                }
                *offset = 0;
            }
            consume_option(argc, argv, optnum);
            if ((arg != (char *)0x0) && (*ppcVar10 == arg)) {
                consume_option(argc, argv, optnum);
            }
            return 1;
        }
    }
LAB_0004b678:
    pcVar3 = *ppcVar10;
    sVar6 = strlen(pcVar3);
    (*errlog)("%s: %.*s: %s", *argv, sVar6, pcVar3, "unrecognized option");
    return -1;
}

/* WARNING: Unknown calling convention */

char *opt_usage(char *argv0, char *extra)

{
    size_t sVar1;
    size_t sVar2;
    size_t sVar3;
    int iVar4;
    char *pcVar5;
    int iVar6;
    uint uVar7;
    int iVar8;
    char *__s;
    undefined4 *puVar9;
    char *pcVar10;
    opt_table *poVar11;
    opt_table *poVar12;
    char *pcVar13;
    uint uVar14;
    uint uVar15;
    char *pcVar16;
    char buf[84];

    sVar1 = strlen(argv0);
    uVar15 = opt_count;
    poVar12 = opt_table;
    sVar1 = opt_num_short + 0x14 + sVar1;
    if (extra == (char *)0x0) {
        if (opt_count == 0) {
            extra = "";
            goto LAB_0004b856;
        }
        uVar14 = 0;
        poVar11 = opt_table;
        do {
            uVar14 = uVar14 + 1;
            if ((poVar11->cb == (_func_char_ptr_void_ptr *)0x4aeed) &&
                (extra = (char *)(poVar11->u).carg, extra != (char *)0x0)) {
                sVar2 = strlen(extra);
                sVar1 = sVar1 + sVar2;
                goto LAB_0004b7f2;
            }
            poVar11 = poVar11 + 1;
        } while (uVar14 != opt_count);
        extra = "";
    } else {
        sVar2 = strlen(extra);
        sVar1 = sVar1 + sVar2;
        poVar12 = opt_table;
        if (uVar15 == 0)
            goto LAB_0004b856;
    }
LAB_0004b7f2:
    uVar14 = 0;
    do {
        while (true) {
            pcVar16 = poVar12->desc;
            if (poVar12->type != OPT_SUBTABLE)
                break;
            uVar14 = uVar14 + 1;
            sVar2 = strlen(pcVar16);
            sVar1 = sVar1 + 3 + sVar2;
            poVar12 = poVar12 + 1;
            if (uVar15 <= uVar14)
                goto LAB_0004b856;
        }
        if (pcVar16 != (char *)&opt_hidden) {
            sVar2 = strlen(poVar12->names);
            sVar3 = strlen(pcVar16);
            iVar4 = sVar3 + sVar2 + sVar1 + 6;
            iVar8 = iVar4 + 0x76;
            if (poVar12->show == (_func_void_char_ptr_void_ptr *)0x0) {
                iVar8 = iVar4 + 0x15;
            }
            sVar1 = iVar8 + 1;
        }
        uVar14 = uVar14 + 1;
        poVar12 = poVar12 + 1;
    } while (uVar14 < uVar15);
LAB_0004b856:
    pcVar16 = (char *)malloc(sVar1);
    if (pcVar16 != (char *)0x0) {
        iVar4 = sprintf(pcVar16, "Usage: %s", argv0);
        pcVar13 = pcVar16 + iVar4;
        builtin_strncpy(pcVar16 + iVar4, " [-", 4);
        pcVar5 = first_sopt((uint *)buf);
        pcVar10 = pcVar13;
        if (pcVar5 != (char *)0x0) {
            iVar4 = 0;
            do {
                if (opt_table[buf._0_4_].desc != (char *)&opt_hidden) {
                    pcVar13[iVar4 + 3] = *pcVar5;
                    iVar4 = iVar4 + 1;
                }
                pcVar5 = next_sopt(pcVar5, (uint *)buf);
            } while (pcVar5 != (char *)0x0);
            if (iVar4 != 0) {
                pcVar10 = pcVar13 + iVar4 + 4;
                (pcVar13 + iVar4 + 3)[0] = ']';
                (pcVar13 + iVar4 + 3)[1] = '\0';
            }
        }
        iVar4 = sprintf(pcVar10, " %s", extra);
        uVar15 = opt_count;
        pcVar5 = pcVar10 + iVar4 + 1;
        (pcVar10 + iVar4)[0] = '\n';
        (pcVar10 + iVar4)[1] = '\0';
        if (uVar15 != 0) {
            iVar4 = 0;
            uVar15 = 0;
            do {
                puVar9 = (undefined4 *)((int)&opt_table->names + iVar4);
                if ((undefined4 *)puVar9[6] != &opt_hidden) {
                    if (puVar9[1] == 8) {
                        iVar8 = sprintf(pcVar5, "%s:\n");
                        pcVar5 = pcVar5 + iVar8;
                    } else {
                        uVar7 = sprintf(pcVar5, "%s", *puVar9);
                        pcVar10 = pcVar5 + uVar7;
                        uVar14 = uVar7;
                        if (*(int *)((int)&opt_table->type + iVar4) == 2) {
                            __s = *(char **)((int)&opt_table->names + iVar4);
                            pcVar13 = strchr(__s, 0x20);
                            if ((pcVar13 == (char *)0x0) &&
                                (pcVar13 = strchr(__s, 0x3d),
                                 pcVar13 == (char *)0x0)) {
                                uVar14 = uVar7 + 6;
                                builtin_strncpy(pcVar5 + uVar7, " <arg>", 7);
                                pcVar10 = pcVar5 + uVar14;
                            }
                        }
                        if (uVar14 < 0x14) {
                            iVar8 = 0x14 - uVar14;
                        } else {
                            iVar8 = 1;
                        }
                        iVar8 = sprintf(pcVar10, "%.*s", iVar8,
                                        "                    ");
                        iVar6 = sprintf(
                            pcVar5 + uVar14 + iVar8, "%s",
                            *(undefined4 *)((int)&opt_table->desc + iVar4));
                        iVar6 = uVar14 + iVar8 + iVar6;
                        pcVar10 = pcVar5 + iVar6;
                        if (*(int *)((int)&opt_table->show + iVar4) != 0) {
                            builtin_strncpy(buf + 0x50, "...", 4);
                            (**(code **)((int)&opt_table->show + iVar4))(
                                buf,
                                *(undefined4 *)((int)&opt_table->u + iVar4));
                            iVar8 = sprintf(pcVar10, " (default: %s)", buf);
                            pcVar10 = pcVar5 + iVar6 + iVar8;
                        }
                        pcVar5 = pcVar10 + 1;
                        pcVar10[0] = '\n';
                        pcVar10[1] = '\0';
                    }
                }
                uVar15 = uVar15 + 1;
                iVar4 = iVar4 + 0x1c;
            } while (uVar15 < opt_count);
        }
        *pcVar5 = '\0';
    }
    return pcVar16;
}

uint __udivsi3(uint param_1, uint param_2)

{
    uint uVar1;

    if (param_2 - 1 == 0) {
        return param_1;
    }
    if (param_2 == 0) {
        if (param_1 != 0) {
            param_1 = 0xffffffff;
        }
        uVar1 = __aeabi_idiv0(param_1);
        return uVar1;
    }
    if (param_1 <= param_2) {
        return (uint)(param_1 == param_2);
    }
    if ((param_2 & param_2 - 1) == 0) {
        return param_1 >> (0x1fU - LZCOUNT(param_2) & 0xff);
    }
    /* WARNING: Could not recover jumptable at 0x0004bad8. Too many branches */
    /* WARNING: Treating indirect jump as call */
    uVar1 = (*(code *)(&UNK_0004bae0 +
                       (0x1f - (LZCOUNT(param_2) - LZCOUNT(param_1))) * 0x10))(
        param_1, param_2, 0);
    return uVar1;
}

/* WARNING: Control flow encountered bad instruction data */

void FUN_0004baa9(void)

{
    /* WARNING: Bad instruction - Truncating control flow here */
    halt_baddata();
}

void __aeabi_uidivmod(int param_1, int param_2)

{
    if (param_2 != 0) {
        __udivsi3();
        return;
    }
    if (param_1 != 0) {
        param_1 = -1;
    }
    __aeabi_idiv0(param_1);
    return;
}

uint __aeabi_idiv(uint param_1, uint param_2)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    bool bVar4;

    if (param_2 == 0) {
        bVar4 = (int)param_1 < 0;
        if (0 < (int)param_1) {
            param_1 = 0x7fffffff;
        }
        if (bVar4) {
            param_1 = 0x80000000;
        }
        uVar1 = __aeabi_idiv0(param_1);
        return uVar1;
    }
    uVar3 = param_1 ^ param_2;
    uVar1 = param_2;
    if ((int)param_2 < 0) {
        uVar1 = -param_2;
    }
    if (uVar1 - 1 == 0) {
        if ((int)param_2 < 0) {
            param_1 = -param_1;
        }
        return param_1;
    }
    uVar2 = param_1;
    if ((int)param_1 < 0) {
        uVar2 = -param_1;
    }
    if (uVar2 <= uVar1) {
        if (uVar2 < uVar1) {
            param_1 = 0;
        }
        if (uVar2 == uVar1) {
            param_1 = (int)uVar3 >> 0x1f | 1;
        }
        return param_1;
    }
    if ((uVar1 & uVar1 - 1) == 0) {
        uVar2 = uVar2 >> (0x1fU - LZCOUNT(uVar1) & 0xff);
        if ((int)uVar3 < 0) {
            uVar2 = -uVar2;
        }
        return uVar2;
    }
    /* WARNING: Could not recover jumptable at 0x0004bd60. Too many branches */
    /* WARNING: Treating indirect jump as call */
    uVar1 = (*(code *)(&UNK_0004bd68 +
                       (0x1f - (LZCOUNT(uVar1) - LZCOUNT(uVar2))) * 0x10))(0);
    return uVar1;
}

/* WARNING: Control flow encountered bad instruction data */

void FUN_0004bd21(void)

{
    /* WARNING: Bad instruction - Truncating control flow here */
    halt_baddata();
}

uint _divsi3_skip_div0_test(uint param_1, uint param_2)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    char in_NG;

    uVar3 = param_1 ^ param_2;
    uVar1 = param_2;
    if (in_NG != '\0') {
        uVar1 = -param_2;
    }
    if (uVar1 - 1 == 0) {
        if ((int)param_2 < 0) {
            param_1 = -param_1;
        }
        return param_1;
    }
    uVar2 = param_1;
    if ((int)param_1 < 0) {
        uVar2 = -param_1;
    }
    if (uVar2 <= uVar1) {
        if (uVar2 < uVar1) {
            param_1 = 0;
        }
        if (uVar2 == uVar1) {
            param_1 = (int)uVar3 >> 0x1f | 1;
        }
        return param_1;
    }
    if ((uVar1 & uVar1 - 1) == 0) {
        uVar2 = uVar2 >> (0x1fU - LZCOUNT(uVar1) & 0xff);
        if ((int)uVar3 < 0) {
            uVar2 = -uVar2;
        }
        return uVar2;
    }
    /* WARNING: Could not recover jumptable at 0x0004bd60. Too many branches */
    /* WARNING: Treating indirect jump as call */
    uVar1 = (*(code *)(&UNK_0004bd68 +
                       (0x1f - (LZCOUNT(uVar1) - LZCOUNT(uVar2))) * 0x10))(0);
    return uVar1;
}

void __aeabi_idivmod(int param_1, int param_2)

{
    bool bVar1;

    if (param_2 != 0) {
        _divsi3_skip_div0_test();
        return;
    }
    bVar1 = param_1 < 0;
    if (0 < param_1) {
        param_1 = 0x7fffffff;
    }
    if (bVar1) {
        param_1 = -0x80000000;
    }
    __aeabi_idiv0(param_1);
    return;
}

void __aeabi_drsub(undefined4 param_1, uint param_2)

{
    __aeabi_dadd(param_1, param_2 ^ 0x80000000);
    return;
}

ulonglong __subdf3(uint param_1, uint param_2, uint param_3, uint param_4)

{
    int iVar1;
    byte bVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    int iVar8;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    uint uVar12;
    bool bVar13;
    bool bVar14;
    bool bVar15;

    uVar6 = param_4 ^ 0x80000000;
    uVar9 = param_2 << 1;
    param_4 = param_4 << 1;
    bVar13 = ((param_2 ^ uVar6) & 0x7fffffff) == 0;
    bVar14 = bVar13 && param_1 == param_3;
    if (!bVar13 || param_1 != param_3) {
        bVar14 = uVar9 == 0 && param_1 == 0;
    }
    if (!bVar14) {
        bVar14 = param_4 == 0 && param_3 == 0;
    }
    iVar8 = (int)uVar9 >> 0x15;
    if (!bVar14) {
        bVar14 = iVar8 == -1;
    }
    iVar1 = (int)param_4 >> 0x15;
    if (!bVar14) {
        bVar14 = iVar1 == -1;
    }
    if (bVar14) {
        if (iVar8 == -1 || iVar1 == -1) {
            uVar9 = uVar6;
            uVar11 = param_3;
            if (iVar8 == -1) {
                uVar9 = param_2;
                uVar11 = param_1;
            }
            if (iVar8 != -1 || iVar1 != -1) {
                param_3 = uVar11;
                uVar6 = uVar9;
            }
            bVar14 = (uVar9 & 0xfffff) == 0;
            bVar13 = uVar11 == 0 && bVar14;
            if (uVar11 == 0 && bVar14) {
                bVar13 = param_3 == 0 && (uVar6 & 0xfffff) == 0;
            }
            if (bVar13) {
                bVar13 = uVar9 == uVar6;
            }
            if (!bVar13) {
                uVar9 = uVar9 | 0x80000;
            }
            return CONCAT44(uVar9, uVar11);
        }
        if (((param_2 ^ uVar6) & 0x7fffffff) != 0 || param_1 != param_3) {
            if (uVar9 == 0 && param_1 == 0) {
                param_1 = param_3;
                param_2 = uVar6;
            }
            return CONCAT44(param_2, param_1);
        }
        if (param_2 != uVar6) {
            return 0;
        }
        if (uVar9 >> 0x15 == 0) {
            bVar14 = (param_1 & 0x80000000) != 0;
            uVar6 = param_2 * 2 + (uint)bVar14;
            if (CARRY4(param_2, param_2) || CARRY4(param_2 * 2, (uint)bVar14)) {
                uVar6 = uVar6 | 0x80000000;
            }
            return CONCAT44(uVar6, param_1 << 1);
        }
        if (uVar9 < 0xffc00000) {
            return CONCAT44(param_2 + 0x100000, param_1);
        }
        param_2 = param_2 & 0x80000000;
    LAB_0004c21c:
        return (ulonglong)(param_2 | 0x7ff00000) << 0x20;
    }
    uVar9 = uVar9 >> 0x15;
    param_4 = param_4 >> 0x15;
    uVar11 = param_4 - uVar9;
    bVar14 = uVar11 != 0;
    if (param_4 < uVar9) {
        uVar11 = -uVar11;
    }
    uVar10 = param_1;
    uVar7 = param_2;
    if (bVar14 && uVar9 <= param_4) {
        uVar9 = uVar9 + uVar11;
        uVar10 = param_3;
        uVar7 = uVar6;
        param_3 = param_1;
        uVar6 = param_2;
    }
    if (0x36 < uVar11) {
        return CONCAT44(uVar7, uVar10);
    }
    uVar4 = uVar7 & 0xfffff | 0x100000;
    if ((uVar7 & 0x80000000) != 0) {
        bVar14 = uVar10 != 0;
        uVar10 = -uVar10;
        uVar4 = -uVar4 - (uint)bVar14;
    }
    uVar7 = uVar6 & 0xfffff | 0x100000;
    if ((uVar6 & 0x80000000) != 0) {
        bVar14 = param_3 != 0;
        param_3 = -param_3;
        uVar7 = -uVar7 - (uint)bVar14;
    }
    if (uVar9 == uVar11) {
        uVar7 = uVar7 ^ 0x100000;
        if (uVar9 == 0) {
            uVar4 = uVar4 ^ 0x100000;
            uVar9 = 1;
        } else {
            uVar11 = uVar11 - 1;
        }
    }
    uVar6 = -uVar11 + 0x20;
    if ((int)uVar11 < 0x21) {
        uVar12 = param_3 << (uVar6 & 0xff);
        param_3 = param_3 >> (uVar11 & 0xff);
        uVar3 = uVar10 + param_3;
        uVar5 = uVar7 << (uVar6 & 0xff);
        uVar6 = uVar3 + uVar5;
        uVar4 = uVar4 + CARRY4(uVar10, param_3) +
                ((int)uVar7 >> (uVar11 & 0xff)) + (uint)CARRY4(uVar3, uVar5);
    } else {
        uVar12 = uVar7 << (-uVar11 + 0x40 & 0xff);
        if (param_3 != 0) {
            uVar12 = uVar12 | 2;
        }
        uVar7 = (int)uVar7 >> (uVar11 - 0x20 & 0xff);
        uVar6 = uVar10 + uVar7;
        uVar4 = uVar4 + ((int)uVar7 >> 0x1f) + (uint)CARRY4(uVar10, uVar7);
    }
    param_2 = uVar4 & 0x80000000;
    uVar11 = uVar4;
    if ((int)uVar4 < 0) {
        bVar14 = uVar12 == 0;
        uVar12 = -uVar12;
        uVar11 = -uVar6;
        uVar6 = -(uint)!bVar14 - uVar6;
        uVar11 = -(uint)(bVar14 <= uVar11) - uVar4;
    }
    if (0xfffff < uVar11) {
        uVar10 = uVar9 - 1;
        if (0x1fffff < uVar11) {
            uVar10 = uVar11 & 1;
            uVar11 = uVar11 >> 1;
            bVar2 = (byte)uVar6;
            uVar6 = (uint)(uVar10 != 0) << 0x1f | uVar6 >> 1;
            uVar12 = (uint)(bVar2 & 1) << 0x1f | uVar12 >> 1;
            uVar10 = uVar9;
            if (0xffbfffff < uVar9 * 0x200000)
                goto LAB_0004c21c;
        }
    LAB_0004c0e8:
        bVar14 = 0x7fffffff < uVar12;
        if (uVar12 == 0x80000000) {
            bVar14 = (uVar6 & 1) != 0;
        }
        return CONCAT44(uVar11 + uVar10 * 0x100000 +
                                (uint)CARRY4(uVar6, (uint)bVar14) |
                            param_2,
                        uVar6 + bVar14);
    }
    bVar13 = (uVar12 & 0x80000000) != 0;
    uVar12 = uVar12 << 1;
    uVar10 = uVar6 * 2;
    bVar14 = CARRY4(uVar6, uVar6);
    uVar6 = uVar6 * 2 + (uint)bVar13;
    uVar11 = uVar11 * 2 + (uint)(bVar14 || CARRY4(uVar10, (uint)bVar13));
    uVar10 = uVar9 - 2;
    if ((uVar11 & 0x100000) != 0)
        goto LAB_0004c0e8;
    uVar7 = uVar6;
    uVar9 = uVar11;
    if (uVar11 == 0) {
        uVar7 = 0;
        uVar9 = uVar6;
    }
    iVar8 = LZCOUNT(uVar9);
    if (uVar11 == 0) {
        iVar8 = iVar8 + 0x20;
    }
    uVar11 = iVar8 - 0xb;
    bVar15 = SBORROW4(uVar11, 0x20);
    uVar6 = iVar8 - 0x2b;
    bVar14 = (int)uVar6 < 0;
    bVar13 = uVar6 == 0;
    if ((int)uVar11 < 0x20) {
        bVar15 = SCARRY4(uVar6, 0xc);
        iVar8 = iVar8 + -0x1f;
        bVar14 = iVar8 < 0;
        bVar13 = iVar8 == 0;
        uVar6 = uVar11;
        if (!bVar13 && bVar14 == bVar15) {
            uVar7 = uVar9 << (uVar11 & 0xff);
            uVar9 = uVar9 >> (0xcU - iVar8 & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar13 || bVar14 != bVar15) {
        uVar12 = 0x20 - uVar6;
    }
    uVar9 = uVar9 << (uVar6 & 0xff);
    if (bVar13 || bVar14 != bVar15) {
        uVar9 = uVar9 | uVar7 >> (uVar12 & 0xff);
        uVar7 = uVar7 << (uVar6 & 0xff);
    }
LAB_0004c160:
    if ((int)uVar11 <= (int)uVar10) {
        return CONCAT44(uVar9 + (uVar10 - uVar11) * 0x100000 | param_2, uVar7);
    }
    uVar6 = ~(uVar10 - uVar11);
    if ((int)uVar6 < 0x1f) {
        iVar8 = uVar6 - 0x13;
        if (iVar8 != 0 && iVar8 < 0 == SCARRY4(uVar6 - 0x1f, 0xc)) {
            return CONCAT44(uVar4, uVar7 >> (0x20 - (0xcU - iVar8) & 0xff) |
                                       uVar9 << (0xcU - iVar8 & 0xff)) &
                   0x80000000ffffffff;
        }
        uVar6 = uVar6 + 1;
        return CONCAT44(param_2 | uVar9 >> (uVar6 & 0xff),
                        uVar7 >> (uVar6 & 0xff) | uVar9
                                                      << (0x20 - uVar6 & 0xff));
    }
    return CONCAT44(uVar4, uVar9 >> (uVar6 - 0x1f & 0xff)) & 0x80000000ffffffff;
}

ulonglong __aeabi_dadd(uint param_1, uint param_2, uint param_3, uint param_4)

{
    int iVar1;
    byte bVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    uint uVar12;
    bool bVar13;
    bool bVar14;
    bool bVar15;

    uVar7 = param_2 << 1;
    uVar9 = param_4 << 1;
    bVar13 = ((param_2 ^ param_4) & 0x7fffffff) == 0;
    bVar14 = bVar13 && param_1 == param_3;
    if (!bVar13 || param_1 != param_3) {
        bVar14 = uVar7 == 0 && param_1 == 0;
    }
    if (!bVar14) {
        bVar14 = uVar9 == 0 && param_3 == 0;
    }
    iVar6 = (int)uVar7 >> 0x15;
    if (!bVar14) {
        bVar14 = iVar6 == -1;
    }
    iVar1 = (int)uVar9 >> 0x15;
    if (!bVar14) {
        bVar14 = iVar1 == -1;
    }
    if (bVar14) {
        if (iVar6 == -1 || iVar1 == -1) {
            uVar9 = param_4;
            uVar7 = param_3;
            if (iVar6 == -1) {
                uVar9 = param_2;
                uVar7 = param_1;
            }
            if (iVar6 != -1 || iVar1 != -1) {
                param_3 = uVar7;
                param_4 = uVar9;
            }
            bVar14 = (uVar9 & 0xfffff) == 0;
            bVar13 = uVar7 == 0 && bVar14;
            if (uVar7 == 0 && bVar14) {
                bVar13 = param_3 == 0 && (param_4 & 0xfffff) == 0;
            }
            if (bVar13) {
                bVar13 = uVar9 == param_4;
            }
            if (!bVar13) {
                uVar9 = uVar9 | 0x80000;
            }
            return CONCAT44(uVar9, uVar7);
        }
        if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {
            if (uVar7 == 0 && param_1 == 0) {
                param_1 = param_3;
                param_2 = param_4;
            }
            return CONCAT44(param_2, param_1);
        }
        if (param_2 != param_4) {
            return 0;
        }
        if (uVar7 >> 0x15 == 0) {
            bVar14 = (param_1 & 0x80000000) != 0;
            uVar9 = param_2 * 2 + (uint)bVar14;
            if (CARRY4(param_2, param_2) || CARRY4(param_2 * 2, (uint)bVar14)) {
                uVar9 = uVar9 | 0x80000000;
            }
            return CONCAT44(uVar9, param_1 << 1);
        }
        if (uVar7 < 0xffc00000) {
            return CONCAT44(param_2 + 0x100000, param_1);
        }
        param_2 = param_2 & 0x80000000;
    LAB_0004c21c:
        return (ulonglong)(param_2 | 0x7ff00000) << 0x20;
    }
    uVar7 = uVar7 >> 0x15;
    uVar9 = uVar9 >> 0x15;
    uVar10 = uVar9 - uVar7;
    bVar14 = uVar10 != 0;
    if (uVar9 < uVar7) {
        uVar10 = -uVar10;
    }
    uVar8 = param_1;
    uVar5 = param_2;
    if (bVar14 && uVar7 <= uVar9) {
        uVar7 = uVar7 + uVar10;
        uVar8 = param_3;
        uVar5 = param_4;
        param_3 = param_1;
        param_4 = param_2;
    }
    if (0x36 < uVar10) {
        return CONCAT44(uVar5, uVar8);
    }
    uVar9 = uVar5 & 0xfffff | 0x100000;
    if ((uVar5 & 0x80000000) != 0) {
        bVar14 = uVar8 != 0;
        uVar8 = -uVar8;
        uVar9 = -uVar9 - (uint)bVar14;
    }
    uVar5 = param_4 & 0xfffff | 0x100000;
    if ((param_4 & 0x80000000) != 0) {
        bVar14 = param_3 != 0;
        param_3 = -param_3;
        uVar5 = -uVar5 - (uint)bVar14;
    }
    if (uVar7 == uVar10) {
        uVar5 = uVar5 ^ 0x100000;
        if (uVar7 == 0) {
            uVar9 = uVar9 ^ 0x100000;
            uVar7 = 1;
        } else {
            uVar10 = uVar10 - 1;
        }
    }
    uVar12 = -uVar10 + 0x20;
    if ((int)uVar10 < 0x21) {
        uVar11 = param_3 << (uVar12 & 0xff);
        param_3 = param_3 >> (uVar10 & 0xff);
        uVar3 = uVar8 + param_3;
        uVar4 = uVar5 << (uVar12 & 0xff);
        uVar12 = uVar3 + uVar4;
        uVar9 = uVar9 + CARRY4(uVar8, param_3) +
                ((int)uVar5 >> (uVar10 & 0xff)) + (uint)CARRY4(uVar3, uVar4);
    } else {
        uVar11 = uVar5 << (-uVar10 + 0x40 & 0xff);
        if (param_3 != 0) {
            uVar11 = uVar11 | 2;
        }
        uVar5 = (int)uVar5 >> (uVar10 - 0x20 & 0xff);
        uVar12 = uVar8 + uVar5;
        uVar9 = uVar9 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar8, uVar5);
    }
    param_2 = uVar9 & 0x80000000;
    uVar10 = uVar9;
    if ((int)uVar9 < 0) {
        bVar14 = uVar11 == 0;
        uVar11 = -uVar11;
        uVar10 = -uVar12;
        uVar12 = -(uint)!bVar14 - uVar12;
        uVar10 = -(uint)(bVar14 <= uVar10) - uVar9;
    }
    if (0xfffff < uVar10) {
        uVar8 = uVar7 - 1;
        if (0x1fffff < uVar10) {
            uVar9 = uVar10 & 1;
            uVar10 = uVar10 >> 1;
            bVar2 = (byte)uVar12;
            uVar12 = (uint)(uVar9 != 0) << 0x1f | uVar12 >> 1;
            uVar11 = (uint)(bVar2 & 1) << 0x1f | uVar11 >> 1;
            uVar8 = uVar7;
            if (0xffbfffff < uVar7 * 0x200000)
                goto LAB_0004c21c;
        }
    LAB_0004c0e8:
        bVar14 = 0x7fffffff < uVar11;
        if (uVar11 == 0x80000000) {
            bVar14 = (uVar12 & 1) != 0;
        }
        return CONCAT44(uVar10 + uVar8 * 0x100000 +
                                (uint)CARRY4(uVar12, (uint)bVar14) |
                            param_2,
                        uVar12 + bVar14);
    }
    bVar13 = (uVar11 & 0x80000000) != 0;
    uVar11 = uVar11 << 1;
    uVar8 = uVar12 * 2;
    bVar14 = CARRY4(uVar12, uVar12);
    uVar12 = uVar12 * 2 + (uint)bVar13;
    uVar10 = uVar10 * 2 + (uint)(bVar14 || CARRY4(uVar8, (uint)bVar13));
    uVar8 = uVar7 - 2;
    if ((uVar10 & 0x100000) != 0)
        goto LAB_0004c0e8;
    uVar5 = uVar12;
    uVar7 = uVar10;
    if (uVar10 == 0) {
        uVar5 = 0;
        uVar7 = uVar12;
    }
    iVar6 = LZCOUNT(uVar7);
    if (uVar10 == 0) {
        iVar6 = iVar6 + 0x20;
    }
    uVar12 = iVar6 - 0xb;
    bVar15 = SBORROW4(uVar12, 0x20);
    uVar10 = iVar6 - 0x2b;
    bVar14 = (int)uVar10 < 0;
    bVar13 = uVar10 == 0;
    if ((int)uVar12 < 0x20) {
        bVar15 = SCARRY4(uVar10, 0xc);
        iVar6 = iVar6 + -0x1f;
        bVar14 = iVar6 < 0;
        bVar13 = iVar6 == 0;
        uVar10 = uVar12;
        if (!bVar13 && bVar14 == bVar15) {
            uVar5 = uVar7 << (uVar12 & 0xff);
            uVar7 = uVar7 >> (0xcU - iVar6 & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar13 || bVar14 != bVar15) {
        uVar11 = 0x20 - uVar10;
    }
    uVar7 = uVar7 << (uVar10 & 0xff);
    if (bVar13 || bVar14 != bVar15) {
        uVar7 = uVar7 | uVar5 >> (uVar11 & 0xff);
        uVar5 = uVar5 << (uVar10 & 0xff);
    }
LAB_0004c160:
    if ((int)uVar12 <= (int)uVar8) {
        return CONCAT44(uVar7 + (uVar8 - uVar12) * 0x100000 | param_2, uVar5);
    }
    uVar10 = ~(uVar8 - uVar12);
    if ((int)uVar10 < 0x1f) {
        iVar6 = uVar10 - 0x13;
        if (iVar6 != 0 && iVar6 < 0 == SCARRY4(uVar10 - 0x1f, 0xc)) {
            return CONCAT44(uVar9, uVar5 >> (0x20 - (0xcU - iVar6) & 0xff) |
                                       uVar7 << (0xcU - iVar6 & 0xff)) &
                   0x80000000ffffffff;
        }
        uVar10 = uVar10 + 1;
        return CONCAT44(param_2 | uVar7 >> (uVar10 & 0xff),
                        uVar5 >> (uVar10 & 0xff) |
                            uVar7 << (0x20 - uVar10 & 0xff));
    }
    return CONCAT44(uVar9, uVar7 >> (uVar10 - 0x1f & 0xff)) &
           0x80000000ffffffff;
}

ulonglong __aeabi_ui2d(uint param_1)

{
    uint uVar1;
    uint uVar2;
    int iVar3;
    uint uVar4;
    uint in_r12;
    bool bVar5;
    bool bVar6;
    bool bVar7;

    if (param_1 == 0) {
        return 0;
    }
    uVar1 = 0;
    iVar3 = LZCOUNT(param_1);
    uVar4 = iVar3 + 0x15;
    bVar7 = SBORROW4(uVar4, 0x20);
    uVar2 = iVar3 - 0xb;
    bVar5 = (int)uVar2 < 0;
    bVar6 = uVar2 == 0;
    if (uVar4 < 0x20) {
        bVar7 = SCARRY4(uVar2, 0xc);
        bVar5 = false;
        bVar6 = iVar3 + 1 == 0;
        uVar2 = uVar4;
        if (!bVar6 && !bVar7) {
            uVar1 = param_1 << uVar4;
            param_1 = param_1 >> (0xcU - (iVar3 + 1) & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar6 || bVar5 != bVar7) {
        in_r12 = 0x20 - uVar2;
    }
    param_1 = param_1 << (uVar2 & 0xff);
    if (bVar6 || bVar5 != bVar7) {
        param_1 = param_1 | 0U >> (in_r12 & 0xff);
        uVar1 = 0 << (uVar2 & 0xff);
    }
LAB_0004c160:
    if (uVar4 < 0x433) {
        return CONCAT44(param_1 + (0x432 - uVar4) * 0x100000, uVar1);
    }
    uVar2 = ~(0x432 - uVar4);
    if (0x1e < (int)uVar2) {
        return (ulonglong)(param_1 >> (uVar2 - 0x1f & 0xff));
    }
    iVar3 = uVar2 - 0x13;
    if (iVar3 == 0 || iVar3 < 0 != SCARRY4(uVar2 - 0x1f, 0xc)) {
        uVar2 = uVar2 + 1;
        return CONCAT44(param_1 >> (uVar2 & 0xff),
                        uVar1 >> (uVar2 & 0xff) | param_1
                                                      << (0x20 - uVar2 & 0xff));
    }
    return (ulonglong)(uVar1 >> (0x20 - (0xcU - iVar3) & 0xff) |
                       param_1 << (0xcU - iVar3 & 0xff));
}

ulonglong __floatsidf(uint param_1)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    uint uVar6;
    uint in_r12;
    bool bVar7;
    bool bVar8;
    bool bVar9;

    if (param_1 == 0) {
        return 0;
    }
    uVar6 = param_1 & 0x80000000;
    uVar2 = param_1;
    if ((int)uVar6 < 0) {
        uVar2 = -param_1;
    }
    uVar1 = 0;
    iVar4 = LZCOUNT(uVar2);
    uVar5 = iVar4 + 0x15;
    bVar9 = SBORROW4(uVar5, 0x20);
    uVar3 = iVar4 - 0xb;
    bVar7 = (int)uVar3 < 0;
    bVar8 = uVar3 == 0;
    if (uVar5 < 0x20) {
        bVar9 = SCARRY4(uVar3, 0xc);
        bVar7 = false;
        bVar8 = iVar4 + 1 == 0;
        uVar3 = uVar5;
        if (!bVar8 && !bVar9) {
            uVar1 = uVar2 << uVar5;
            uVar2 = uVar2 >> (0xcU - (iVar4 + 1) & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar8 || bVar7 != bVar9) {
        in_r12 = 0x20 - uVar3;
    }
    uVar2 = uVar2 << (uVar3 & 0xff);
    if (bVar8 || bVar7 != bVar9) {
        uVar2 = uVar2 | 0U >> (in_r12 & 0xff);
        uVar1 = 0 << (uVar3 & 0xff);
    }
LAB_0004c160:
    if (uVar5 < 0x433) {
        return CONCAT44(uVar2 + (0x432 - uVar5) * 0x100000 | uVar6, uVar1);
    }
    uVar3 = ~(0x432 - uVar5);
    if (0x1e < (int)uVar3) {
        return CONCAT44(param_1, uVar2 >> (uVar3 - 0x1f & 0xff)) &
               0x80000000ffffffff;
    }
    iVar4 = uVar3 - 0x13;
    if (iVar4 == 0 || iVar4 < 0 != SCARRY4(uVar3 - 0x1f, 0xc)) {
        uVar3 = uVar3 + 1;
        return CONCAT44(uVar6 | uVar2 >> (uVar3 & 0xff),
                        uVar1 >> (uVar3 & 0xff) | uVar2
                                                      << (0x20 - uVar3 & 0xff));
    }
    return CONCAT44(param_1, uVar1 >> (0x20 - (0xcU - iVar4) & 0xff) |
                                 uVar2 << (0xcU - iVar4 & 0xff)) &
           0x80000000ffffffff;
}

ulonglong __extendsfdf2(uint param_1, undefined4 param_2, undefined4 param_3,
                        uint param_4)

{
    uint uVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    uint uVar5;
    int iVar6;
    uint uVar7;
    uint in_r12;
    bool bVar8;
    bool bVar9;
    bool bVar10;

    uVar5 = param_1 << 1;
    bVar9 = uVar5 == 0;
    uVar1 = (uint)((param_1 & 0x80000000) != 0) << 0x1f;
    uVar4 = (uint)((int)uVar5 >> 3) >> 1;
    uVar3 = uVar1 | uVar4;
    param_1 = param_1 << 0x1d;
    if (!bVar9) {
        param_4 = uVar5 & 0xff000000;
        bVar9 = param_4 == 0;
    }
    if (!bVar9) {
        bVar9 = param_4 == 0xff000000;
    }
    if (!bVar9) {
        return CONCAT44(uVar3, param_1) ^ 0x3800000000000000;
    }
    if ((uVar5 & 0xffffff) == 0) {
        return CONCAT44(uVar3, param_1);
    }
    if (param_4 == 0xff000000) {
        return CONCAT44(uVar3, param_1) | 0x8000000000000;
    }
    uVar2 = param_1;
    uVar5 = uVar4;
    if (uVar4 == 0) {
        uVar2 = 0;
        uVar5 = param_1;
    }
    iVar6 = LZCOUNT(uVar5);
    if (uVar4 == 0) {
        iVar6 = iVar6 + 0x20;
    }
    uVar7 = iVar6 - 0xb;
    bVar10 = SBORROW4(uVar7, 0x20);
    uVar4 = iVar6 - 0x2b;
    bVar9 = (int)uVar4 < 0;
    bVar8 = uVar4 == 0;
    if ((int)uVar7 < 0x20) {
        bVar10 = SCARRY4(uVar4, 0xc);
        iVar6 = iVar6 + -0x1f;
        bVar9 = iVar6 < 0;
        bVar8 = iVar6 == 0;
        uVar4 = uVar7;
        if (!bVar8 && bVar9 == bVar10) {
            uVar2 = uVar5 << (uVar7 & 0xff);
            uVar5 = uVar5 >> (0xcU - iVar6 & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar8 || bVar9 != bVar10) {
        in_r12 = 0x20 - uVar4;
    }
    uVar5 = uVar5 << (uVar4 & 0xff);
    if (bVar8 || bVar9 != bVar10) {
        uVar5 = uVar5 | uVar2 >> (in_r12 & 0xff);
        uVar2 = uVar2 << (uVar4 & 0xff);
    }
LAB_0004c160:
    if ((int)uVar7 < 0x381) {
        return CONCAT44(uVar5 + (0x380 - uVar7) * 0x100000 | uVar1, uVar2);
    }
    uVar4 = ~(0x380 - uVar7);
    if (0x1e < (int)uVar4) {
        return CONCAT44(uVar3, uVar5 >> (uVar4 - 0x1f & 0xff)) &
               0x80000000ffffffff;
    }
    iVar6 = uVar4 - 0x13;
    if (iVar6 == 0 || iVar6 < 0 != SCARRY4(uVar4 - 0x1f, 0xc)) {
        uVar4 = uVar4 + 1;
        return CONCAT44(uVar1 | uVar5 >> (uVar4 & 0xff),
                        uVar2 >> (uVar4 & 0xff) | uVar5
                                                      << (0x20 - uVar4 & 0xff));
    }
    return CONCAT44(uVar3, uVar2 >> (0x20 - (0xcU - iVar6) & 0xff) |
                               uVar5 << (0xcU - iVar6 & 0xff)) &
           0x80000000ffffffff;
}

ulonglong __floatundidf(uint param_1, uint param_2)

{
    byte bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    int iVar5;
    uint uVar6;
    int iVar7;
    uint uVar8;
    bool bVar9;
    bool bVar10;
    bool bVar11;

    if (param_1 == 0 && param_2 == 0) {
        return CONCAT44(param_2, param_1);
    }
    iVar7 = 0x432;
    uVar8 = param_2 >> 0x16;
    if (uVar8 != 0) {
        iVar7 = 3;
        if (param_2 >> 0x19 != 0) {
            iVar7 = 6;
        }
        if (param_2 >> 0x1c != 0) {
            iVar7 = iVar7 + 3;
        }
        uVar4 = iVar7 - ((int)param_2 >> 0x1f);
        uVar8 = param_1 << (0x20 - uVar4 & 0xff);
        param_1 = param_1 >> (uVar4 & 0xff) | param_2 << (0x20 - uVar4 & 0xff);
        param_2 = param_2 >> (uVar4 & 0xff);
        iVar7 = uVar4 + 0x432;
    }
    if (0xfffff < param_2) {
        if (0x1fffff < param_2) {
            uVar4 = param_2 & 1;
            param_2 = param_2 >> 1;
            bVar1 = (byte)param_1;
            param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;
            uVar8 = (uint)(bVar1 & 1) << 0x1f | uVar8 >> 1;
            iVar7 = iVar7 + 1;
            if (0xffbfffff < (uint)(iVar7 * 0x200000)) {
                return 0x7ff0000000000000;
            }
        }
    LAB_0004c0e8:
        bVar10 = 0x7fffffff < uVar8;
        if (uVar8 == 0x80000000) {
            bVar10 = (param_1 & 1) != 0;
        }
        return CONCAT44(param_2 + iVar7 * 0x100000 +
                            (uint)CARRY4(param_1, (uint)bVar10),
                        param_1 + bVar10);
    }
    bVar9 = (uVar8 & 0x80000000) != 0;
    uVar8 = uVar8 << 1;
    uVar4 = param_1 * 2;
    bVar10 = CARRY4(param_1, param_1);
    param_1 = param_1 * 2 + (uint)bVar9;
    param_2 = param_2 * 2 + (uint)(bVar10 || CARRY4(uVar4, (uint)bVar9));
    iVar7 = iVar7 + -1;
    if ((param_2 & 0x100000) != 0)
        goto LAB_0004c0e8;
    uVar2 = param_1;
    uVar4 = param_2;
    if (param_2 == 0) {
        uVar2 = 0;
        uVar4 = param_1;
    }
    iVar5 = LZCOUNT(uVar4);
    if (param_2 == 0) {
        iVar5 = iVar5 + 0x20;
    }
    uVar6 = iVar5 - 0xb;
    bVar11 = SBORROW4(uVar6, 0x20);
    uVar3 = iVar5 - 0x2b;
    bVar10 = (int)uVar3 < 0;
    bVar9 = uVar3 == 0;
    if ((int)uVar6 < 0x20) {
        bVar11 = SCARRY4(uVar3, 0xc);
        iVar5 = iVar5 + -0x1f;
        bVar10 = iVar5 < 0;
        bVar9 = iVar5 == 0;
        uVar3 = uVar6;
        if (!bVar9 && bVar10 == bVar11) {
            uVar2 = uVar4 << (uVar6 & 0xff);
            uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar9 || bVar10 != bVar11) {
        uVar8 = 0x20 - uVar3;
    }
    uVar4 = uVar4 << (uVar3 & 0xff);
    if (bVar9 || bVar10 != bVar11) {
        uVar4 = uVar4 | uVar2 >> (uVar8 & 0xff);
        uVar2 = uVar2 << (uVar3 & 0xff);
    }
LAB_0004c160:
    if ((int)uVar6 <= iVar7) {
        return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000, uVar2);
    }
    uVar8 = ~(iVar7 - uVar6);
    if (0x1e < (int)uVar8) {
        return (ulonglong)(uVar4 >> (uVar8 - 0x1f & 0xff));
    }
    iVar7 = uVar8 - 0x13;
    if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar8 - 0x1f, 0xc)) {
        uVar8 = uVar8 + 1;
        return CONCAT44(uVar4 >> (uVar8 & 0xff),
                        uVar2 >> (uVar8 & 0xff) | uVar4
                                                      << (0x20 - uVar8 & 0xff));
    }
    return (ulonglong)(uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |
                       uVar4 << (0xcU - iVar7 & 0xff));
}

ulonglong __aeabi_l2d(uint param_1, uint param_2)

{
    byte bVar1;
    uint uVar2;
    uint uVar3;
    uint uVar4;
    int iVar5;
    uint uVar6;
    int iVar7;
    uint uVar8;
    uint uVar9;
    bool bVar10;
    bool bVar11;
    bool bVar12;

    if (param_1 == 0 && param_2 == 0) {
        return CONCAT44(param_2, param_1);
    }
    uVar8 = param_2 & 0x80000000;
    uVar3 = param_2;
    if ((int)uVar8 < 0) {
        bVar11 = param_1 != 0;
        param_1 = -param_1;
        uVar3 = -param_2 - (uint)bVar11;
    }
    iVar7 = 0x432;
    uVar9 = uVar3 >> 0x16;
    if (uVar9 != 0) {
        iVar7 = 3;
        if (uVar3 >> 0x19 != 0) {
            iVar7 = 6;
        }
        if (uVar3 >> 0x1c != 0) {
            iVar7 = iVar7 + 3;
        }
        uVar4 = iVar7 - ((int)uVar3 >> 0x1f);
        uVar9 = param_1 << (0x20 - uVar4 & 0xff);
        param_1 = param_1 >> (uVar4 & 0xff) | uVar3 << (0x20 - uVar4 & 0xff);
        uVar3 = uVar3 >> (uVar4 & 0xff);
        iVar7 = uVar4 + 0x432;
    }
    if (0xfffff < uVar3) {
        if (0x1fffff < uVar3) {
            uVar4 = uVar3 & 1;
            uVar3 = uVar3 >> 1;
            bVar1 = (byte)param_1;
            param_1 = (uint)(uVar4 != 0) << 0x1f | param_1 >> 1;
            uVar9 = (uint)(bVar1 & 1) << 0x1f | uVar9 >> 1;
            iVar7 = iVar7 + 1;
            if (0xffbfffff < (uint)(iVar7 * 0x200000)) {
                return (ulonglong)(uVar8 | 0x7ff00000) << 0x20;
            }
        }
    LAB_0004c0e8:
        bVar11 = 0x7fffffff < uVar9;
        if (uVar9 == 0x80000000) {
            bVar11 = (param_1 & 1) != 0;
        }
        return CONCAT44(uVar3 + iVar7 * 0x100000 +
                                (uint)CARRY4(param_1, (uint)bVar11) |
                            uVar8,
                        param_1 + bVar11);
    }
    bVar10 = (uVar9 & 0x80000000) != 0;
    uVar9 = uVar9 << 1;
    uVar4 = param_1 * 2;
    bVar11 = CARRY4(param_1, param_1);
    param_1 = param_1 * 2 + (uint)bVar10;
    uVar3 = uVar3 * 2 + (uint)(bVar11 || CARRY4(uVar4, (uint)bVar10));
    iVar7 = iVar7 + -1;
    if ((uVar3 & 0x100000) != 0)
        goto LAB_0004c0e8;
    uVar2 = param_1;
    uVar4 = uVar3;
    if (uVar3 == 0) {
        uVar2 = 0;
        uVar4 = param_1;
    }
    iVar5 = LZCOUNT(uVar4);
    if (uVar3 == 0) {
        iVar5 = iVar5 + 0x20;
    }
    uVar6 = iVar5 - 0xb;
    bVar12 = SBORROW4(uVar6, 0x20);
    uVar3 = iVar5 - 0x2b;
    bVar11 = (int)uVar3 < 0;
    bVar10 = uVar3 == 0;
    if ((int)uVar6 < 0x20) {
        bVar12 = SCARRY4(uVar3, 0xc);
        iVar5 = iVar5 + -0x1f;
        bVar11 = iVar5 < 0;
        bVar10 = iVar5 == 0;
        uVar3 = uVar6;
        if (!bVar10 && bVar11 == bVar12) {
            uVar2 = uVar4 << (uVar6 & 0xff);
            uVar4 = uVar4 >> (0xcU - iVar5 & 0xff);
            goto LAB_0004c160;
        }
    }
    if (bVar10 || bVar11 != bVar12) {
        uVar9 = 0x20 - uVar3;
    }
    uVar4 = uVar4 << (uVar3 & 0xff);
    if (bVar10 || bVar11 != bVar12) {
        uVar4 = uVar4 | uVar2 >> (uVar9 & 0xff);
        uVar2 = uVar2 << (uVar3 & 0xff);
    }
LAB_0004c160:
    if ((int)uVar6 <= iVar7) {
        return CONCAT44(uVar4 + (iVar7 - uVar6) * 0x100000 | uVar8, uVar2);
    }
    uVar3 = ~(iVar7 - uVar6);
    if (0x1e < (int)uVar3) {
        return CONCAT44(param_2, uVar4 >> (uVar3 - 0x1f & 0xff)) &
               0x80000000ffffffff;
    }
    iVar7 = uVar3 - 0x13;
    if (iVar7 == 0 || iVar7 < 0 != SCARRY4(uVar3 - 0x1f, 0xc)) {
        uVar3 = uVar3 + 1;
        return CONCAT44(uVar8 | uVar4 >> (uVar3 & 0xff),
                        uVar2 >> (uVar3 & 0xff) | uVar4
                                                      << (0x20 - uVar3 & 0xff));
    }
    return CONCAT44(param_2, uVar2 >> (0x20 - (0xcU - iVar7) & 0xff) |
                                 uVar4 << (0xcU - iVar7 & 0xff)) &
           0x80000000ffffffff;
}

undefined4 __aeabi_uldivmod(int param_1, int param_2, int param_3, int param_4)

{
    undefined4 uVar1;
    UDItype UVar2;
    UDItype local_8;

    if ((param_4 == 0) && (param_3 == 0)) {
        if (param_2 != 0 || param_1 != 0) {
            param_2 = -1;
            param_1 = -1;
        }
        uVar1 = __aeabi_idiv0(param_1, param_2);
        return uVar1;
    }
    UVar2 = __udivmoddi4(CONCAT44(param_2, param_1), CONCAT44(param_4, param_3),
                         &local_8);
    return (int)UVar2;
}

void __aeabi_idiv0(void)

{
    raise(8);
    return;
}

/* WARNING: Control flow encountered bad instruction data */

void FUN_0004c379(void)

{
    /* WARNING: Bad instruction - Truncating control flow here */
    halt_baddata();
}

DItype __fixdfdi(DFtype a)

{
    undefined4 in_r0;
    undefined4 in_r1;
    UDItype UVar1;

    if (-1 < (int)((uint)((double)CONCAT44(in_r1, in_r0) < 0.0) << 0x1f)) {
        UVar1 = __fixunsdfdi(a);
        return UVar1;
    }
    UVar1 = __fixunsdfdi(a);
    return CONCAT44(-(int)(UVar1 >> 0x20) - (uint)((int)UVar1 != 0),
                    -(int)UVar1);
}

UDItype __fixunsdfdi(DFtype a)

{
    undefined4 in_r0;
    undefined4 in_r1;
    USItype hi;
    uint uVar1;
    double dVar2;

    dVar2 = (double)CONCAT44(in_r1, in_r0) * 2.3283064365386963e-10;
    uVar1 = (uint)(0.0 < dVar2) * (int)(longlong)dVar2;
    dVar2 = (double)CONCAT44(in_r1, in_r0) - (double)uVar1 * 4294967296.0;
    return CONCAT44(uVar1, (uint)(0.0 < dVar2) * (int)(longlong)dVar2);
}

UDItype __udivmoddi4(UDItype n, UDItype d, UDItype *rp)

{
    longlong lVar1;
    uint uVar2;
    uint uVar3;
    int iVar4;
    uint uVar5;
    uint uVar6;
    uint uVar7;
    uint uVar8;
    uint uVar9;
    uint uVar10;
    uint uVar11;
    uint uVar12;
    int iVar13;
    uint uVar14;
    bool bVar15;

    uVar8 = (uint)(d >> 0x20);
    uVar9 = (uint)d;
    uVar2 = (uint)(n >> 0x20);
    uVar3 = (uint)n;
    bVar15 = uVar8 <= uVar2;
    if (uVar2 == uVar8) {
        bVar15 = uVar9 <= uVar3;
    }
    if (bVar15) {
        iVar13 = LZCOUNT(uVar8);
        if (uVar8 == 0) {
            iVar13 = LZCOUNT(uVar9) + 0x20;
        }
        iVar4 = LZCOUNT(uVar2);
        if (uVar2 == 0) {
            iVar4 = LZCOUNT(uVar3) + 0x20;
        }
        uVar14 = iVar13 - iVar4;
        uVar11 = uVar14 - 0x20;
        uVar12 = 0x20 - uVar14;
        uVar7 = uVar9 << (uVar14 & 0xff);
        uVar9 = uVar8 << (uVar14 & 0xff) | uVar9 << (uVar11 & 0xff) |
                uVar9 >> (uVar12 & 0xff);
        bVar15 = uVar9 <= uVar2;
        if (uVar2 == uVar9) {
            bVar15 = uVar7 <= uVar3;
        }
        if (bVar15) {
            uVar2 = 1 << (uVar14 & 0xff);
            n = n - CONCAT44(uVar9, uVar7);
            uVar3 = 1 << (uVar11 & 0xff) | 1U >> (uVar12 & 0xff);
        } else {
            uVar2 = 0;
            uVar3 = uVar2;
        }
        if (uVar14 != 0) {
            uVar10 = uVar9 >> 1;
            uVar8 = (uint)((uVar9 & 1) != 0) << 0x1f | uVar7 >> 1;
            uVar9 = uVar14;
            do {
                while (true) {
                    uVar6 = (uint)(n >> 0x20);
                    uVar7 = (uint)n;
                    bVar15 = uVar10 <= uVar6;
                    if (uVar6 == uVar10) {
                        bVar15 = uVar8 <= uVar7;
                    }
                    if (bVar15)
                        break;
                    uVar5 = uVar7 * 2;
                    uVar7 = uVar6 * 2 + (uint)CARRY4(uVar7, uVar7);
                    n = CONCAT44(uVar7, uVar5);
                    uVar9 = uVar9 - 1;
                    if (uVar9 == 0)
                        goto LAB_0004c492;
                }
                lVar1 = n - CONCAT44(uVar10, uVar8);
                uVar7 = (uint)lVar1;
                uVar5 = uVar7 * 2 + 1;
                uVar7 = (int)((ulonglong)lVar1 >> 0x20) * 2 +
                        (uint)CARRY4(uVar7, uVar7) +
                        (uint)(0xfffffffe < uVar7 * 2);
                n = CONCAT44(uVar7, uVar5);
                uVar9 = uVar9 - 1;
            } while (uVar9 != 0);
        LAB_0004c492:
            uVar8 = uVar7 >> (uVar14 & 0xff);
            bVar15 = CARRY4(uVar2, uVar5);
            uVar9 = uVar2 + uVar5;
            uVar11 = uVar5 >> (uVar14 & 0xff) | uVar7 << (uVar12 & 0xff) |
                     uVar7 >> (uVar11 & 0xff);
            n = CONCAT44(uVar8, uVar11);
            uVar12 = uVar11 << (uVar14 & 0xff);
            uVar2 = uVar9 - uVar12;
            uVar3 =
                ((uVar7 + uVar3 + bVar15) -
                 (uVar8 << (uVar14 & 0xff) | uVar11 << (uVar14 - 0x20 & 0xff) |
                  uVar11 >> (0x20 - uVar14 & 0xff))) -
                (uint)(uVar9 < uVar12);
        }
    } else {
        uVar2 = 0;
        uVar3 = uVar2;
    }
    if (rp != (UDItype *)0x0) {
        *rp = n;
    }
    return CONCAT44(uVar3, uVar2);
}

/* WARNING: Unknown calling convention */

void __libc_csu_init(int argc, char **argv, char **envp)

{
    int iVar1;
    undefined **ppuVar2;

    _init((EVP_PKEY_CTX *)argc);
    iVar1 = 0;
    ppuVar2 = &__frame_dummy_init_array_entry;
    do {
        iVar1 = iVar1 + 1;
        (*(code *)*ppuVar2)(argc, argv, envp);
        ppuVar2 = ppuVar2 + 1;
    } while (iVar1 != 1);
    return;
}

/* WARNING: Unknown calling convention -- yet parameter storage is locked */

void __libc_csu_fini(void)

{
    return;
}

void _fini(void)

{
    return;
}
