// Data types exported from: cgminer_f7cf46a74876c43b_debug
// Generated by Ghidra

#ifndef CGMINER_F7CF46A74876C43B_DEBUG_TYPES_H
#define CGMINER_F7CF46A74876C43B_DEBUG_TYPES_H

#include <stdint.h>
#include <stdbool.h>

/* ==================== Enumerations ==================== */

typedef enum {
    DT_NULL = 0,
    DT_NEEDED = 1,
    DT_PLTRELSZ = 2,
    DT_PLTGOT = 3,
    DT_HASH = 4,
    DT_STRTAB = 5,
    DT_SYMTAB = 6,
    DT_RELA = 7,
    DT_RELASZ = 8,
    DT_RELAENT = 9,
    DT_STRSZ = 10,
    DT_SYMENT = 11,
    DT_INIT = 12,
    DT_FINI = 13,
    DT_SONAME = 14,
    DT_RPATH = 15,
    DT_SYMBOLIC = 16,
    DT_REL = 17,
    DT_RELSZ = 18,
    DT_RELENT = 19,
    DT_PLTREL = 20,
    DT_DEBUG = 21,
    DT_TEXTREL = 22,
    DT_JMPREL = 23,
    DT_BIND_NOW = 24,
    DT_INIT_ARRAY = 25,
    DT_FINI_ARRAY = 26,
    DT_INIT_ARRAYSZ = 27,
    DT_FINI_ARRAYSZ = 28,
    DT_RUNPATH = 29,
    DT_FLAGS = 30,
    DT_PREINIT_ARRAY = 32,
    DT_PREINIT_ARRAYSZ = 33,
    DT_RELRSZ = 35,
    DT_RELR = 36,
    DT_RELRENT = 37,
    DT_ANDROID_REL = 1610612751,
    DT_ANDROID_RELSZ = 1610612752,
    DT_ANDROID_RELA = 1610612753,
    DT_ANDROID_RELASZ = 1610612754,
    DT_ANDROID_RELR = 1879040000,
    DT_ANDROID_RELRSZ = 1879040001,
    DT_ANDROID_RELRENT = 1879040003,
    DT_GNU_PRELINKED = 1879047669,
    DT_GNU_CONFLICTSZ = 1879047670,
    DT_GNU_LIBLISTSZ = 1879047671,
    DT_CHECKSUM = 1879047672,
    DT_PLTPADSZ = 1879047673,
    DT_MOVEENT = 1879047674,
    DT_MOVESZ = 1879047675,
    DT_FEATURE_1 = 1879047676,
    DT_POSFLAG_1 = 1879047677,
    DT_SYMINSZ = 1879047678,
    DT_SYMINENT = 1879047679,
    DT_GNU_XHASH = 1879047924,
    DT_GNU_HASH = 1879047925,
    DT_TLSDESC_PLT = 1879047926,
    DT_TLSDESC_GOT = 1879047927,
    DT_GNU_CONFLICT = 1879047928,
    DT_GNU_LIBLIST = 1879047929,
    DT_CONFIG = 1879047930,
    DT_DEPAUDIT = 1879047931,
    DT_AUDIT = 1879047932,
    DT_PLTPAD = 1879047933,
    DT_MOVETAB = 1879047934,
    DT_SYMINFO = 1879047935,
    DT_VERSYM = 1879048176,
    DT_RELACOUNT = 1879048185,
    DT_RELCOUNT = 1879048186,
    DT_FLAGS_1 = 1879048187,
    DT_VERDEF = 1879048188,
    DT_VERDEFNUM = 1879048189,
    DT_VERNEED = 1879048190,
    DT_VERNEEDNUM = 1879048191,
    DT_AUXILIARY = 2147483645,
    DT_FILTER = 2147483647,
} Elf32_DynTag_ARM;

typedef enum {
    PT_NULL = 0,
    PT_LOAD = 1,
    PT_DYNAMIC = 2,
    PT_INTERP = 3,
    PT_NOTE = 4,
    PT_SHLIB = 5,
    PT_PHDR = 6,
    PT_TLS = 7,
    PT_GNU_EH_FRAME = 1685382480,
    PT_GNU_STACK = 1685382481,
    PT_GNU_RELRO = 1685382482,
    PT_ARM_EXIDX = 1879048192,
} Elf_ProgramHeaderType_ARM;

typedef enum {
    SHT_NULL = 0,
    SHT_PROGBITS = 1,
    SHT_SYMTAB = 2,
    SHT_STRTAB = 3,
    SHT_RELA = 4,
    SHT_HASH = 5,
    SHT_DYNAMIC = 6,
    SHT_NOTE = 7,
    SHT_NOBITS = 8,
    SHT_REL = 9,
    SHT_SHLIB = 10,
    SHT_DYNSYM = 11,
    SHT_INIT_ARRAY = 14,
    SHT_FINI_ARRAY = 15,
    SHT_PREINIT_ARRAY = 16,
    SHT_GROUP = 17,
    SHT_SYMTAB_SHNDX = 18,
    SHT_ANDROID_REL = 1610612737,
    SHT_ANDROID_RELA = 1610612738,
    SHT_GNU_ATTRIBUTES = 1879048181,
    SHT_GNU_HASH = 1879048182,
    SHT_GNU_LIBLIST = 1879048183,
    SHT_CHECKSUM = 1879048184,
    SHT_SUNW_move = 1879048186,
    SHT_SUNW_COMDAT = 1879048187,
    SHT_SUNW_syminfo = 1879048188,
    SHT_GNU_verdef = 1879048189,
    SHT_GNU_verneed = 1879048190,
    SHT_GNU_versym = 1879048191,
    SHT_ARM_EXIDX = 1879048193,
    SHT_ARM_PREEMPTMAP = 1879048194,
    SHT_ARM_ATTRIBUTES = 1879048195,
    SHT_ARM_DEBUGOVERLAY = 1879048196,
    SHT_ARM_OVERLAYSECTION = 1879048197,
} Elf_SectionHeaderType_ARM;

typedef enum {
    LOCAL = 0,
    REMOTE = 1,
    OFFSET = 2,
    ID = 3,
} I2C_TYPE;

typedef enum {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
} _LIB_VERSION_TYPE;

typedef enum {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_NONBLOCK = 2048,
    SOCK_CLOEXEC = 524288,
} __socket_type;

typedef enum {
    LIFE_WELL = 0,
    LIFE_SICK = 1,
    LIFE_DEAD = 2,
    LIFE_NOSTART = 3,
    LIFE_INIT = 4,
} alive;

typedef enum {
    EH_VERIFY_PASS = 0,
    FREQ_SCAN_NOT_FINISH = 0,
    IPPROTO_IP = 0,
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ENABLE = 0,
    SHUT_RD = 0,
    _SC_ARG_MAX = 0,
    EH_VERIFY_DUPLICATE_INDICES = 1,
    FREQ_SCAN_SUCCESS = 1,
    IPPROTO_ICMP = 1,
    MSG_OOB = 1,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
    PTHREAD_CANCEL_DISABLE = 1,
    SHUT_WR = 1,
    _ISblank = 1,
    _SC_CHILD_MAX = 1,
    EH_VERIFY_XOR_ERR = 2,
    FREQ_SCAN_FAILED = 2,
    IPPROTO_IGMP = 2,
    MSG_PEEK = 2,
    SHUT_RDWR = 2,
    _IScntrl = 2,
    _SC_CLK_TCK = 2,
    EH_VERIFY_INVALID_COLLISION_LENGTH_ERR = 3,
    _SC_NGROUPS_MAX = 3,
    EH_VERIFY_INDEX_TREE_ORDERED_ERR = 4,
    IPPROTO_IPIP = 4,
    MSG_DONTROUTE = 4,
    MSG_TRYHARD = 4,
    _ISpunct = 4,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    IPPROTO_TCP = 6,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    IPPROTO_EGP = 8,
    MSG_CTRUNC = 8,
    _ISalnum = 8,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    IPPROTO_PUP = 12,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    MSG_PROXY = 16,
    _SC_MAPPED_FILES = 16,
    IPPROTO_UDP = 17,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    IPPROTO_IDP = 22,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    IPPROTO_TP = 29,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    MSG_TRUNC = 32,
    _SC_SEM_NSEMS_MAX = 32,
    IPPROTO_DCCP = 33,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    IPPROTO_IPV6 = 41,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    IPPROTO_RSVP = 46,
    _SC_2_VERSION = 46,
    IPPROTO_GRE = 47,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    IPPROTO_ESP = 50,
    _SC_2_FORT_RUN = 50,
    IPPROTO_AH = 51,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_IOV_MAX = 60,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    MSG_DONTWAIT = 64,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    IPPROTO_MTP = 92,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    IPPROTO_BEETPH = 94,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    IPPROTO_ENCAP = 98,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    IPPROTO_PIM = 103,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    IPPROTO_COMP = 108,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    MSG_EOR = 128,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    IPPROTO_SCTP = 132,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    IPPROTO_UDPLITE = 136,
    _SC_C_LANG_SUPPORT_R = 136,
    IPPROTO_MPLS = 137,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
    MSG_WAITALL = 256,
    _ISupper = 256,
    MSG_FIN = 512,
    _ISlower = 512,
    MSG_SYN = 1024,
    _ISalpha = 1024,
    MSG_CONFIRM = 2048,
    _ISdigit = 2048,
    MSG_RST = 4096,
    _ISxdigit = 4096,
    MSG_ERRQUEUE = 8192,
    _ISspace = 8192,
    MSG_NOSIGNAL = 16384,
    _ISprint = 16384,
    MSG_MORE = 32768,
    _ISgraph = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
} anon_enum_32;

typedef enum {
    API_ESCAPE = 0,
    API_STRING = 1,
    API_CONST = 2,
    API_UINT8 = 3,
    API_INT16 = 4,
    API_UINT16 = 5,
    API_INT = 6,
    API_UINT = 7,
    API_UINT32 = 8,
    API_HEX32 = 9,
    API_UINT64 = 10,
    API_INT64 = 11,
    API_DOUBLE = 12,
    API_ELAPSED = 13,
    API_BOOL = 14,
    API_TIMEVAL = 15,
    API_TIME = 16,
    API_MHS = 17,
    API_MHTOTAL = 18,
    API_TEMP = 19,
    API_UTILITY = 20,
    API_FREQ = 21,
    API_VOLTS = 22,
    API_HS = 23,
    API_DIFF = 24,
    API_PERCENT = 25,
    API_AVG = 26,
} api_data_type;

typedef enum {
    ARM_EQ = 0,
    ARM_NE = 1,
    ARM_CS = 2,
    ARM_CC = 3,
    ARM_MI = 4,
    ARM_PL = 5,
    ARM_VS = 6,
    ARM_VC = 7,
    ARM_HI = 8,
    ARM_LS = 9,
    ARM_GE = 10,
    ARM_LT = 11,
    ARM_GT = 12,
    ARM_LE = 13,
    ARM_AL = 14,
    ARM_NV = 15,
} arm_cond_code;

typedef enum {
    ARM_PCS_AAPCS = 0,
    ARM_PCS_AAPCS_VFP = 1,
    ARM_PCS_AAPCS_IWMMXT = 2,
    ARM_PCS_AAPCS_LOCAL = 3,
    ARM_PCS_ATPCS = 4,
    ARM_PCS_APCS = 5,
    ARM_PCS_UNKNOWN = 6,
} arm_pcs;

typedef enum {
    BASE_ARCH_0 = 0,
    BASE_ARCH_2 = 2,
    BASE_ARCH_3 = 3,
    BASE_ARCH_3M = 3,
    BASE_ARCH_4 = 4,
    BASE_ARCH_4T = 4,
    BASE_ARCH_5 = 5,
    BASE_ARCH_5E = 5,
    BASE_ARCH_5T = 5,
    BASE_ARCH_5TE = 5,
    BASE_ARCH_5TEJ = 5,
    BASE_ARCH_6 = 6,
    BASE_ARCH_6J = 6,
    BASE_ARCH_6K = 6,
    BASE_ARCH_6KZ = 6,
    BASE_ARCH_6M = 6,
    BASE_ARCH_6T2 = 6,
    BASE_ARCH_6Z = 6,
    BASE_ARCH_7 = 7,
    BASE_ARCH_7A = 7,
    BASE_ARCH_7EM = 7,
    BASE_ARCH_7M = 7,
    BASE_ARCH_7R = 7,
    BASE_ARCH_8A = 8,
    BASE_ARCH_8M_BASE = 8,
    BASE_ARCH_8M_MAIN = 8,
} base_architecture;

typedef enum {
    BENCHWORK_VERSION = 0,
    BENCHWORK_MERKLEROOT = 1,
    BENCHWORK_PREVHASH = 2,
    BENCHWORK_DIFFBITS = 3,
    BENCHWORK_NONCETIME = 4,
    BENCHWORK_COUNT = 5,
} benchwork;

typedef enum {
    BLAKE2B_PERSONALBYTES = 16,
    BLAKE2B_SALTBYTES = 16,
    BLAKE2B_KEYBYTES = 64,
    BLAKE2B_OUTBYTES = 64,
    BLAKE2B_BLOCKBYTES = 128,
} blake2b_constant;

typedef enum {
    BLAKE2S_PERSONALBYTES = 8,
    BLAKE2S_SALTBYTES = 8,
    BLAKE2S_KEYBYTES = 32,
    BLAKE2S_OUTBYTES = 32,
    BLAKE2S_BLOCKBYTES = 64,
} blake2s_constant;

typedef enum {
    REG_CHIP_ADDRESS = 0,
    REG_HASH_RATE = 8,
    REG_PLL_PARAMETER = 12,
    REG_TICKET_MASK = 20,
    REG_MISC_CONTROL = 28,
    REG_GENERAL_I2C_COMMAND = 32,
    REG_NONCE_TX_OK = 36,
    REG_CORE_TIMEOUT = 40,
    REG_IO_DRIVE_STRENGTH = 48,
    REG_CHIP_STATUS = 52,
    REG_TIME_OUT = 56,
    REG_PMONITOR_CTRL = 60,
    REG_ANALOG_MUX_CONTROL = 64,
    REG_BIST_STATUS = 72,
    REG_NONCE_SHIFT = 80,
    REG_START_NONCE_OFFSET = 84,
    REG_TXN_DATA = 88,
} bm1740_reg_address;

typedef enum {
    PARAM_PGA = 0,
    PARAM_ASC = 1,
    PARAM_PID = 2,
    PARAM_PGAMAX = 3,
    PARAM_ASCMAX = 4,
    PARAM_PMAX = 5,
    PARAM_POOLMAX = 6,
    PARAM_DMAX = 7,
    PARAM_CMD = 8,
    PARAM_POOL = 9,
    PARAM_STR = 10,
    PARAM_BOTH = 11,
    PARAM_BOOL = 12,
    PARAM_SET = 13,
    PARAM_INT = 14,
    PARAM_NONE = 15,
} code_parameters;

typedef enum {
    SEVERITY_ERR = 0,
    SEVERITY_WARN = 1,
    SEVERITY_INFO = 2,
    SEVERITY_SUCC = 3,
    SEVERITY_FAIL = 4,
} code_severity;

typedef enum {
    DEV_ENABLED = 0,
    DEV_DISABLED = 1,
    DEV_RECOVER = 2,
} dev_enable;

typedef enum {
    REASON_THREAD_FAIL_INIT = 0,
    REASON_THREAD_ZERO_HASH = 1,
    REASON_THREAD_FAIL_QUEUE = 2,
    REASON_DEV_SICK_IDLE_60 = 3,
    REASON_DEV_DEAD_IDLE_600 = 4,
    REASON_DEV_NOSTART = 5,
    REASON_DEV_OVER_HEAT = 6,
    REASON_DEV_THERMAL_CUTOFF = 7,
    REASON_DEV_COMMS_ERROR = 8,
    REASON_DEV_THROTTLE = 9,
} dev_reason;

typedef enum {
    DRIVER_bitforce = 0,
    DRIVER_modminer = 1,
    DRIVER_bitmain = 2,
    DRIVER_bitmain_c5 = 3,
    DRIVER_bitmainZCASH = 4,
    DRIVER_bmsc = 5,
    DRIVER_avalon = 6,
    DRIVER_avalon2 = 7,
    DRIVER_avalon4 = 8,
    DRIVER_bflsc = 9,
    DRIVER_bitfury = 10,
    DRIVER_blockerupter = 11,
    DRIVER_cointerra = 12,
    DRIVER_hashfast = 13,
    DRIVER_hashratio = 14,
    DRIVER_icarus = 15,
    DRIVER_klondike = 16,
    DRIVER_knc = 17,
    DRIVER_bitmineA1 = 18,
    DRIVER_drillbit = 19,
    DRIVER_bab = 20,
    DRIVER_minion = 21,
    DRIVER_sp10 = 22,
    DRIVER_sp30 = 23,
    DRIVER_MAX = 24,
} drv_driver;

typedef enum {
    CMD_SINGLE_CHIP = 0,
    CMD_ALL_CHIP = 1,
} input_cmd_allchip_type;

typedef enum {
    INPUT_CMD_LEN_5 = 5,
    INPUT_CMD_LEN_9 = 9,
} input_cmd_length_type;

typedef enum {
    CMD_SET_ADDRESS = 0,
    CMD_SET_CONFIG = 1,
    CMD_GET_STATUS = 2,
    CMD_CHAIN_INACTIVE = 3,
} input_cmd_type;

typedef enum {
    WORK_INPUT = 1,
    COMMAND_INPUT = 2,
    BIST_INPUT = 3,
} input_data_type;

typedef enum {
    isa_nobit = 0,
    isa_bit_ARMv3m = 1,
    isa_bit_mode26 = 2,
    isa_bit_mode32 = 3,
    isa_bit_ARMv4 = 4,
    isa_bit_ARMv5 = 5,
    isa_bit_thumb = 6,
    isa_bit_ARMv5e = 7,
    isa_bit_xscale = 8,
    isa_bit_ARMv6 = 9,
    isa_bit_ARMv6k = 10,
    isa_bit_thumb2 = 11,
    isa_bit_notm = 12,
    isa_bit_tdiv = 13,
    isa_bit_ARMv7em = 14,
    isa_bit_ARMv7 = 15,
    isa_bit_adiv = 16,
    isa_bit_ARMv8 = 17,
    isa_bit_crc32 = 18,
    isa_bit_iwmmxt = 19,
    isa_bit_iwmmxt2 = 20,
    isa_bit_ARMv8_1 = 21,
    isa_bit_ARMv8_2 = 22,
    isa_bit_cmse = 23,
    isa_bit_VFPv2 = 24,
    isa_bit_VFPv3 = 25,
    isa_bit_VFPv4 = 26,
    isa_bit_FPv5 = 27,
    isa_bit_lpae = 28,
    isa_bit_FP_ARMv8 = 29,
    isa_bit_neon = 30,
    isa_bit_fp16conv = 31,
    isa_bit_fp_dbl = 32,
    isa_bit_fp_d32 = 33,
    isa_bit_crypto = 34,
    isa_bit_fp16 = 35,
    isa_quirk_no_volatile_ce = 36,
    isa_quirk_ARMv6kz = 37,
    isa_quirk_cm3_ldrd = 38,
    isa_bit_smallmul = 39,
    isa_tune_co_proc = 40,
    isa_tune_ldsched = 41,
    isa_tune_strong = 42,
    isa_tune_wbuf = 43,
    isa_num_bits = 44,
} isa_feature;

typedef enum {
    JSON_OBJECT = 0,
    JSON_ARRAY = 1,
    JSON_STRING = 2,
    JSON_INTEGER = 3,
    JSON_REAL = 4,
    JSON_TRUE = 5,
    JSON_FALSE = 6,
    JSON_NULL = 7,
} json_type;

typedef enum {
    OPT_NOARG = 1,
    OPT_HASARG = 2,
    OPT_PROCESSARG = 4,
    OPT_SUBTABLE = 8,
    OPT_END = 16,
} opt_type;

typedef enum {
    POOL_DISABLED = 0,
    POOL_ENABLED = 1,
    POOL_REJECTING = 2,
} pool_enable;

typedef enum {
    POOL_FAILOVER = 0,
    POOL_ROUNDROBIN = 1,
    POOL_ROTATE = 2,
    POOL_LOADBALANCE = 3,
    POOL_BALANCE = 4,
} pool_strategy;

typedef enum {
    TARGET_CPU_arm2 = 0,
    TARGET_CPU_arm250 = 1,
    TARGET_CPU_arm3 = 2,
    TARGET_CPU_arm6 = 3,
    TARGET_CPU_arm60 = 4,
    TARGET_CPU_arm600 = 5,
    TARGET_CPU_arm610 = 6,
    TARGET_CPU_arm620 = 7,
    TARGET_CPU_arm7 = 8,
    TARGET_CPU_arm7d = 9,
    TARGET_CPU_arm7di = 10,
    TARGET_CPU_arm70 = 11,
    TARGET_CPU_arm700 = 12,
    TARGET_CPU_arm700i = 13,
    TARGET_CPU_arm710 = 14,
    TARGET_CPU_arm720 = 15,
    TARGET_CPU_arm710c = 16,
    TARGET_CPU_arm7100 = 17,
    TARGET_CPU_arm7500 = 18,
    TARGET_CPU_arm7500fe = 19,
    TARGET_CPU_arm7m = 20,
    TARGET_CPU_arm7dm = 21,
    TARGET_CPU_arm7dmi = 22,
    TARGET_CPU_arm8 = 23,
    TARGET_CPU_arm810 = 24,
    TARGET_CPU_strongarm = 25,
    TARGET_CPU_strongarm110 = 26,
    TARGET_CPU_strongarm1100 = 27,
    TARGET_CPU_strongarm1110 = 28,
    TARGET_CPU_fa526 = 29,
    TARGET_CPU_fa626 = 30,
    TARGET_CPU_arm7tdmi = 31,
    TARGET_CPU_arm7tdmis = 32,
    TARGET_CPU_arm710t = 33,
    TARGET_CPU_arm720t = 34,
    TARGET_CPU_arm740t = 35,
    TARGET_CPU_arm9 = 36,
    TARGET_CPU_arm9tdmi = 37,
    TARGET_CPU_arm920 = 38,
    TARGET_CPU_arm920t = 39,
    TARGET_CPU_arm922t = 40,
    TARGET_CPU_arm940t = 41,
    TARGET_CPU_ep9312 = 42,
    TARGET_CPU_arm10tdmi = 43,
    TARGET_CPU_arm1020t = 44,
    TARGET_CPU_arm9e = 45,
    TARGET_CPU_arm946es = 46,
    TARGET_CPU_arm966es = 47,
    TARGET_CPU_arm968es = 48,
    TARGET_CPU_arm10e = 49,
    TARGET_CPU_arm1020e = 50,
    TARGET_CPU_arm1022e = 51,
    TARGET_CPU_xscale = 52,
    TARGET_CPU_iwmmxt = 53,
    TARGET_CPU_iwmmxt2 = 54,
    TARGET_CPU_fa606te = 55,
    TARGET_CPU_fa626te = 56,
    TARGET_CPU_fmp626 = 57,
    TARGET_CPU_fa726te = 58,
    TARGET_CPU_arm926ejs = 59,
    TARGET_CPU_arm1026ejs = 60,
    TARGET_CPU_arm1136js = 61,
    TARGET_CPU_arm1136jfs = 62,
    TARGET_CPU_arm1176jzs = 63,
    TARGET_CPU_arm1176jzfs = 64,
    TARGET_CPU_mpcorenovfp = 65,
    TARGET_CPU_mpcore = 66,
    TARGET_CPU_arm1156t2s = 67,
    TARGET_CPU_arm1156t2fs = 68,
    TARGET_CPU_cortexm1 = 69,
    TARGET_CPU_cortexm0 = 70,
    TARGET_CPU_cortexm0plus = 71,
    TARGET_CPU_cortexm1smallmultiply = 72,
    TARGET_CPU_cortexm0smallmultiply = 73,
    TARGET_CPU_cortexm0plussmallmultiply = 74,
    TARGET_CPU_genericv7a = 75,
    TARGET_CPU_cortexa5 = 76,
    TARGET_CPU_cortexa7 = 77,
    TARGET_CPU_cortexa8 = 78,
    TARGET_CPU_cortexa9 = 79,
    TARGET_CPU_cortexa12 = 80,
    TARGET_CPU_cortexa15 = 81,
    TARGET_CPU_cortexa17 = 82,
    TARGET_CPU_cortexr4 = 83,
    TARGET_CPU_cortexr4f = 84,
    TARGET_CPU_cortexr5 = 85,
    TARGET_CPU_cortexr7 = 86,
    TARGET_CPU_cortexr8 = 87,
    TARGET_CPU_cortexm7 = 88,
    TARGET_CPU_cortexm4 = 89,
    TARGET_CPU_cortexm3 = 90,
    TARGET_CPU_marvell_pj4 = 91,
    TARGET_CPU_cortexa15cortexa7 = 92,
    TARGET_CPU_cortexa17cortexa7 = 93,
    TARGET_CPU_cortexa32 = 94,
    TARGET_CPU_cortexa35 = 95,
    TARGET_CPU_cortexa53 = 96,
    TARGET_CPU_cortexa57 = 97,
    TARGET_CPU_cortexa72 = 98,
    TARGET_CPU_cortexa73 = 99,
    TARGET_CPU_exynosm1 = 100,
    TARGET_CPU_xgene1 = 101,
    TARGET_CPU_cortexa57cortexa53 = 102,
    TARGET_CPU_cortexa72cortexa53 = 103,
    TARGET_CPU_cortexa73cortexa35 = 104,
    TARGET_CPU_cortexa73cortexa53 = 105,
    TARGET_CPU_cortexm23 = 106,
    TARGET_CPU_cortexm33 = 107,
    TARGET_CPU_arm_none = 108,
} processor_type;

typedef enum {
    SEND_OK = 0,
    SEND_SELECTFAIL = 1,
    SEND_SENDFAIL = 2,
    SEND_INACTIVE = 3,
} send_ret;

/* ==================== Forward Declarations ==================== */

typedef struct APIGROUPS APIGROUPS;
typedef struct CMDS CMDS;
typedef struct CODES CODES;
typedef struct CSha256 CSha256;
typedef struct Elf32_Dyn_ARM Elf32_Dyn_ARM;
typedef struct Elf32_Ehdr Elf32_Ehdr;
typedef struct Elf32_Phdr Elf32_Phdr;
typedef struct Elf32_Rel Elf32_Rel;
typedef struct Elf32_Shdr Elf32_Shdr;
typedef struct Elf32_Sym Elf32_Sym;
typedef struct GnuBuildId GnuBuildId;
typedef struct IPACCESS IPACCESS;
typedef struct JE JE;
typedef struct NoteAbiTag NoteAbiTag;
typedef struct SHA256Context SHA256Context;
typedef struct SHA256state_st SHA256state_st;
typedef struct UT_hash_bucket UT_hash_bucket;
typedef struct UT_hash_handle UT_hash_handle;
typedef struct UT_hash_table UT_hash_table;
typedef struct _IO_FILE _IO_FILE;
typedef struct _IO_FILE _IO_FILE;
typedef struct _IO_FILE_plus _IO_FILE_plus;
typedef struct _IO_marker _IO_marker;
typedef struct _IO_marker _IO_marker;
typedef struct __blake2b_param __blake2b_param;
typedef struct __blake2b_state __blake2b_state;
typedef struct __pthread_internal_slist __pthread_internal_slist;
typedef struct __pthread_internal_slist __pthread_internal_slist;
typedef struct __pthread_mutex_s __pthread_mutex_s;
typedef struct __pthread_mutex_s __pthread_mutex_s;
typedef struct __pthread_unwind_buf_t __pthread_unwind_buf_t;
typedef struct __pthread_unwind_buf_t __pthread_unwind_buf_t;
typedef struct __sigset_t __sigset_t;
typedef struct __sigset_t __sigset_t;
typedef struct __va_list __va_list;
typedef struct _cgpu_devid_counter _cgpu_devid_counter;
typedef struct _dont_use_rtx_here_ _dont_use_rtx_here_;
typedef struct _struct_1032 _struct_1032;
typedef struct _struct_1033 _struct_1033;
typedef struct _struct_1034 _struct_1034;
typedef struct _struct_1035 _struct_1035;
typedef struct _struct_1036 _struct_1036;
typedef struct _struct_1037 _struct_1037;
typedef struct _struct_1439 _struct_1439;
typedef struct _struct_16 _struct_16;
typedef struct _struct_19 _struct_19;
typedef struct addrinfo addrinfo;
typedef struct addrinfo addrinfo;
typedef struct all_parameters all_parameters;
typedef struct anon_struct_12_3_5124685d_for__timer anon_struct_12_3_5124685d_for__timer;
typedef struct anon_struct_12_3_9bedbd60_for__rt anon_struct_12_3_9bedbd60_for__rt;
typedef struct anon_struct_12_3_fe5e7108_for__sigsys anon_struct_12_3_fe5e7108_for__sigsys;
typedef struct anon_struct_20_5_7a025f54_for__sigchld anon_struct_20_5_7a025f54_for__sigchld;
typedef struct anon_struct_264_2_c715bfa2 anon_struct_264_2_c715bfa2;
typedef struct anon_struct_32_11_c699d9f5_for___data anon_struct_32_11_c699d9f5_for___data;
typedef struct anon_struct_48_7_e1bf6e98_for___data anon_struct_48_7_e1bf6e98_for___data;
typedef struct anon_struct_4_8_ad5e9fc5_for_u anon_struct_4_8_ad5e9fc5_for_u;
typedef struct anon_struct_8_2_0a3d7222_for__kill anon_struct_8_2_0a3d7222_for__kill;
typedef struct anon_struct_8_2_30de7609_for___g1_start32 anon_struct_8_2_30de7609_for___g1_start32;
typedef struct anon_struct_8_2_30de7609_for___wseq32 anon_struct_8_2_30de7609_for___wseq32;
typedef struct anon_struct_8_2_686959ae_for__sigpoll anon_struct_8_2_686959ae_for__sigpoll;
typedef struct anon_struct_8_2_895adaa1_for__sigfault anon_struct_8_2_895adaa1_for__sigfault;
typedef struct anon_struct_8_2_f5308dc4 anon_struct_8_2_f5308dc4;
typedef struct api_data api_data;
typedef struct arm_fpu_desc arm_fpu_desc;
typedef struct benchfile_layout benchfile_layout;
typedef struct bitmain_ZCASH_info bitmain_ZCASH_info;
typedef struct bitmian_ZCASH_info_with_index bitmian_ZCASH_info_with_index;
typedef struct block block;
typedef struct bm1740_analog_mux_control bm1740_analog_mux_control;
typedef struct bm1740_chip_addr bm1740_chip_addr;
typedef struct bm1740_chip_status bm1740_chip_status;
typedef struct bm1740_core_timeout bm1740_core_timeout;
typedef struct bm1740_general_i2c_command bm1740_general_i2c_command;
typedef struct bm1740_hash_rate bm1740_hash_rate;
typedef struct bm1740_io_drive_strength bm1740_io_drive_strength;
typedef struct bm1740_misc_control bm1740_misc_control;
typedef struct bm1740_nonce_tx_ok bm1740_nonce_tx_ok;
typedef struct bm1740_pll_parameter bm1740_pll_parameter;
typedef struct bm1740_pmonitor_ctrl bm1740_pmonitor_ctrl;
typedef struct bm1740_start_nonce_offset bm1740_start_nonce_offset;
typedef struct bm1740_ticket_mask bm1740_ticket_mask;
typedef struct bm1740_time_out bm1740_time_out;
typedef struct bm1740_txn_data bm1740_txn_data;
typedef struct bm1740_work bm1740_work;
typedef struct bm1744_nonce_shift bm1744_nonce_shift;
typedef struct buffer_data_t buffer_data_t;
typedef struct callback_data_t callback_data_t;
typedef struct cg_completion cg_completion;
typedef struct cglock cglock;
typedef struct cgminer_pool_stats cgminer_pool_stats;
typedef struct cgminer_stats cgminer_stats;
typedef struct cgpu_info cgpu_info;
typedef struct chain_inactive_cmd_t chain_inactive_cmd_t;
typedef struct curl_ent curl_ent;
typedef struct dev_info dev_info;
typedef struct device_drv device_drv;
typedef struct dupdata dupdata;
typedef struct evp_pkey_ctx_st evp_pkey_ctx_st;
typedef struct fd_set fd_set;
typedef struct fd_set fd_set;
typedef struct freq_pll_str freq_pll_str;
typedef struct get_status_cmd_t get_status_cmd_t;
typedef struct hashtable hashtable;
typedef struct hashtable_bucket hashtable_bucket;
typedef struct hashtable_list hashtable_list;
typedef struct hashtable_pair hashtable_pair;
typedef struct in6_addr in6_addr;
typedef struct in_addr in_addr;
typedef struct init_config init_config;
typedef struct io_data io_data;
typedef struct io_list io_list;
typedef struct ip_mreq ip_mreq;
typedef struct ipv6_mreq ipv6_mreq;
typedef struct json_array_t json_array_t;
typedef struct json_error_t json_error_t;
typedef struct json_integer_t json_integer_t;
typedef struct json_object_t json_object_t;
typedef struct json_real_t json_real_t;
typedef struct json_string_t json_string_t;
typedef struct json_t json_t;
typedef struct k_item k_item;
typedef struct k_list k_list;
typedef struct lconv lconv;
typedef struct lex_t lex_t;
typedef struct list_head list_head;
typedef struct lldiv_t lldiv_t;
typedef struct lldiv_t lldiv_t;
typedef struct nitem nitem;
typedef struct nonce_buf nonce_buf;
typedef struct nonce_rb_format nonce_rb_format;
typedef struct object_key object_key;
typedef struct opt_table opt_table;
typedef struct pmonitor_respond pmonitor_respond;
typedef struct pollfd pollfd;
typedef struct pool pool;
typedef struct reg_buf reg_buf;
typedef struct reg_rb_format reg_rb_format;
typedef struct reg_respond reg_respond;
typedef struct sbitem sbitem;
typedef struct scan_freq_status scan_freq_status;
typedef struct schedtime schedtime;
typedef struct set_address_cmd_t set_address_cmd_t;
typedef struct set_config_cmd_t set_config_cmd_t;
typedef struct sha256_ctx sha256_ctx;
typedef struct sha2_context sha2_context;
typedef struct sigaction sigaction;
typedef struct sigaction sigaction;
typedef struct siginfo siginfo;
typedef struct siginfo_t siginfo_t;
typedef struct sockaddr sockaddr;
typedef struct sockaddr sockaddr;
typedef struct sockaddr_at sockaddr_at;
typedef struct sockaddr_ax25 sockaddr_ax25;
typedef struct sockaddr_dl sockaddr_dl;
typedef struct sockaddr_eon sockaddr_eon;
typedef struct sockaddr_in sockaddr_in;
typedef struct sockaddr_in6 sockaddr_in6;
typedef struct sockaddr_inarp sockaddr_inarp;
typedef struct sockaddr_ipx sockaddr_ipx;
typedef struct sockaddr_iso sockaddr_iso;
typedef struct sockaddr_ns sockaddr_ns;
typedef struct sockaddr_storage sockaddr_storage;
typedef struct sockaddr_un sockaddr_un;
typedef struct sockaddr_x25 sockaddr_x25;
typedef struct stat stat;
typedef struct strategies strategies;
typedef struct stratum_share stratum_share;
typedef struct stratum_work stratum_work;
typedef struct strbuffer_t strbuffer_t;
typedef struct stream_t stream_t;
typedef struct string_data_t string_data_t;
typedef struct thr_info thr_info;
typedef struct thread_q thread_q;
typedef struct timespec timespec;
typedef struct timespec timespec;
typedef struct timeval timeval;
typedef struct timeval timeval;
typedef struct timezone timezone;
typedef struct timezone timezone;
typedef struct tm tm;
typedef struct tm tm;
typedef struct tq_ent tq_ent;
typedef struct validData validData;
typedef struct work work;

/* ==================== Structures ==================== */

struct APIGROUPS {
    char * commands;  // offset: 0x0
}; // size: 0x4

struct CMDS {
    char * name;  // offset: 0x0
    _func_void_io_data_ptr_long_char_ptr__Bool_char * func;  // offset: 0x4
    _Bool iswritemode;  // offset: 0x8
    _Bool joinable;  // offset: 0x9
}; // size: 0xc

struct CODES {
    code_severity severity;  // offset: 0x0
    int code;  // offset: 0x4
    code_parameters params;  // offset: 0x8
    char * description;  // offset: 0xc
}; // size: 0x10

struct CSha256 {
    uint32_t state[8];  // offset: 0x0
    uint64_t count;  // offset: 0x20
    uint8_t buffer[64];  // offset: 0x28
}; // size: 0x68

struct Elf32_Dyn_ARM {
    Elf32_DynTag_ARM d_tag;  // offset: 0x0
    dword d_val;  // offset: 0x4
}; // size: 0x8

struct Elf32_Ehdr {
    byte e_ident_magic_num;  // offset: 0x0
    string e_ident_magic_str;  // offset: 0x1
    byte e_ident_class;  // offset: 0x4
    byte e_ident_data;  // offset: 0x5
    byte e_ident_version;  // offset: 0x6
    byte e_ident_osabi;  // offset: 0x7
    byte e_ident_abiversion;  // offset: 0x8
    byte e_ident_pad[7];  // offset: 0x9
    word e_type;  // offset: 0x10
    word e_machine;  // offset: 0x12
    dword e_version;  // offset: 0x14
    dword e_entry;  // offset: 0x18
    dword e_phoff;  // offset: 0x1c
    dword e_shoff;  // offset: 0x20
    dword e_flags;  // offset: 0x24
    word e_ehsize;  // offset: 0x28
    word e_phentsize;  // offset: 0x2a
    word e_phnum;  // offset: 0x2c
    word e_shentsize;  // offset: 0x2e
    word e_shnum;  // offset: 0x30
    word e_shstrndx;  // offset: 0x32
}; // size: 0x34

struct Elf32_Phdr {
    Elf_ProgramHeaderType_ARM p_type;  // offset: 0x0
    dword p_offset;  // offset: 0x4
    dword p_vaddr;  // offset: 0x8
    dword p_paddr;  // offset: 0xc
    dword p_filesz;  // offset: 0x10
    dword p_memsz;  // offset: 0x14
    dword p_flags;  // offset: 0x18
    dword p_align;  // offset: 0x1c
}; // size: 0x20

struct Elf32_Rel {
    dword r_offset;  // offset: 0x0
    dword r_info;  // offset: 0x4
}; // size: 0x8

struct Elf32_Shdr {
    dword sh_name;  // offset: 0x0
    Elf_SectionHeaderType_ARM sh_type;  // offset: 0x4
    dword sh_flags;  // offset: 0x8
    dword sh_addr;  // offset: 0xc
    dword sh_offset;  // offset: 0x10
    dword sh_size;  // offset: 0x14
    dword sh_link;  // offset: 0x18
    dword sh_info;  // offset: 0x1c
    dword sh_addralign;  // offset: 0x20
    dword sh_entsize;  // offset: 0x24
}; // size: 0x28

struct Elf32_Sym {
    dword st_name;  // offset: 0x0
    dword st_value;  // offset: 0x4
    dword st_size;  // offset: 0x8
    byte st_info;  // offset: 0xc
    byte st_other;  // offset: 0xd
    word st_shndx;  // offset: 0xe
}; // size: 0x10

struct GnuBuildId {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    byte hash[20];  // offset: 0x10
}; // size: 0x24

struct IPACCESS {
    in6_addr ip;  // offset: 0x0
    in6_addr mask;  // offset: 0x10
    char group;  // offset: 0x20
}; // size: 0x24

struct JE {
    char * buf;  // offset: 0x0
    JE * next;  // offset: 0x4
}; // size: 0x8

struct NoteAbiTag {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    dword abiType;  // offset: 0x10
    dword requiredKernelVersion[3];  // offset: 0x14
}; // size: 0x20

struct SHA256Context {
    uint32_t state[8];  // offset: 0x0
    uint32_t buf[16];  // offset: 0x20
}; // size: 0x60

struct SHA256state_st {
    uint h[8];  // offset: 0x0
    uint Nl;  // offset: 0x20
    uint Nh;  // offset: 0x24
    uint data[16];  // offset: 0x28
    uint num;  // offset: 0x68
    uint md_len;  // offset: 0x6c
}; // size: 0x70

struct UT_hash_bucket {
    UT_hash_handle * hh_head;  // offset: 0x0
    uint count;  // offset: 0x4
    uint expand_mult;  // offset: 0x8
}; // size: 0xc

struct UT_hash_handle {
    UT_hash_table * tbl;  // offset: 0x0
    void * prev;  // offset: 0x4
    void * next;  // offset: 0x8
    UT_hash_handle * hh_prev;  // offset: 0xc
    UT_hash_handle * hh_next;  // offset: 0x10
    void * key;  // offset: 0x14
    uint keylen;  // offset: 0x18
    uint hashv;  // offset: 0x1c
}; // size: 0x20

struct UT_hash_table {
    UT_hash_bucket * buckets;  // offset: 0x0
    uint num_buckets;  // offset: 0x4
    uint log2_num_buckets;  // offset: 0x8
    uint num_items;  // offset: 0xc
    UT_hash_handle * tail;  // offset: 0x10
    ptrdiff_t hho;  // offset: 0x14
    uint ideal_chain_maxlen;  // offset: 0x18
    uint nonideal_items;  // offset: 0x1c
    uint ineff_expands;  // offset: 0x20
    uint noexpand;  // offset: 0x24
    uint32_t signature;  // offset: 0x28
}; // size: 0x2c

struct _IO_FILE {
    int _flags;  // offset: 0x0
    char * _IO_read_ptr;  // offset: 0x4
    char * _IO_read_end;  // offset: 0x8
    char * _IO_read_base;  // offset: 0xc
    char * _IO_write_base;  // offset: 0x10
    char * _IO_write_ptr;  // offset: 0x14
    char * _IO_write_end;  // offset: 0x18
    char * _IO_buf_base;  // offset: 0x1c
    char * _IO_buf_end;  // offset: 0x20
    char * _IO_save_base;  // offset: 0x24
    char * _IO_backup_base;  // offset: 0x28
    char * _IO_save_end;  // offset: 0x2c
    _IO_marker * _markers;  // offset: 0x30
    _IO_FILE * _chain;  // offset: 0x34
    int _fileno;  // offset: 0x38
    int _flags2;  // offset: 0x3c
    __off_t _old_offset;  // offset: 0x40
    ushort _cur_column;  // offset: 0x44
    char _vtable_offset;  // offset: 0x46
    char _shortbuf[1];  // offset: 0x47
    _IO_lock_t * _lock;  // offset: 0x48
    __off64_t _offset;  // offset: 0x50
    void * __pad1;  // offset: 0x58
    void * __pad2;  // offset: 0x5c
    void * __pad3;  // offset: 0x60
    void * __pad4;  // offset: 0x64
    size_t __pad5;  // offset: 0x68
    int _mode;  // offset: 0x6c
    char _unused2[40];  // offset: 0x70
}; // size: 0x98

struct _IO_FILE {
    int _flags;  // offset: 0x0
    char * _IO_read_ptr;  // offset: 0x4
    char * _IO_read_end;  // offset: 0x8
    char * _IO_read_base;  // offset: 0xc
    char * _IO_write_base;  // offset: 0x10
    char * _IO_write_ptr;  // offset: 0x14
    char * _IO_write_end;  // offset: 0x18
    char * _IO_buf_base;  // offset: 0x1c
    char * _IO_buf_end;  // offset: 0x20
    char * _IO_save_base;  // offset: 0x24
    char * _IO_backup_base;  // offset: 0x28
    char * _IO_save_end;  // offset: 0x2c
    _IO_marker * _markers;  // offset: 0x30
    _IO_FILE * _chain;  // offset: 0x34
    int _fileno;  // offset: 0x38
    int _flags2;  // offset: 0x3c
    __off_t _old_offset;  // offset: 0x40
    ushort _cur_column;  // offset: 0x44
    char _vtable_offset;  // offset: 0x46
    char _shortbuf[1];  // offset: 0x47
    _IO_lock_t * _lock;  // offset: 0x48
    __off64_t _offset;  // offset: 0x50
    void * __pad1;  // offset: 0x58
    void * __pad2;  // offset: 0x5c
    void * __pad3;  // offset: 0x60
    void * __pad4;  // offset: 0x64
    size_t __pad5;  // offset: 0x68
    int _mode;  // offset: 0x6c
    char _unused2[40];  // offset: 0x70
}; // size: 0x98

struct _IO_FILE_plus {
    // Empty structure
}; // size: 0x1

struct _IO_marker {
    _IO_marker * _next;  // offset: 0x0
    _IO_FILE * _sbuf;  // offset: 0x4
    int _pos;  // offset: 0x8
}; // size: 0xc

struct _IO_marker {
    _IO_marker * _next;  // offset: 0x0
    _IO_FILE * _sbuf;  // offset: 0x4
    int _pos;  // offset: 0x8
}; // size: 0xc

struct __blake2b_param {
    uint8_t digest_length;  // offset: 0x0
    uint8_t key_length;  // offset: 0x1
    uint8_t fanout;  // offset: 0x2
    uint8_t depth;  // offset: 0x3
    uint32_t leaf_length;  // offset: 0x4
    uint64_t node_offset;  // offset: 0x8
    uint8_t node_depth;  // offset: 0x10
    uint8_t inner_length;  // offset: 0x11
    uint8_t reserved[14];  // offset: 0x12
    uint8_t salt[16];  // offset: 0x20
    uint8_t personal[16];  // offset: 0x30
}; // size: 0x40

struct __blake2b_state {
    uint64_t h[8];  // offset: 0x0
    uint64_t t[2];  // offset: 0x40
    uint64_t f[2];  // offset: 0x50
    uint8_t buf[256];  // offset: 0x60
    size_t buflen;  // offset: 0x160
    uint8_t last_node;  // offset: 0x164
}; // size: 0x168

struct __pthread_internal_slist {
    __pthread_internal_slist * __next;  // offset: 0x0
}; // size: 0x4

struct __pthread_internal_slist {
    __pthread_internal_slist * __next;  // offset: 0x0
}; // size: 0x4

struct __pthread_mutex_s {
    int __lock;  // offset: 0x0
    uint __count;  // offset: 0x4
    int __owner;  // offset: 0x8
    int __kind;  // offset: 0xc
    uint __nusers;  // offset: 0x10
    anon_union_4_2_9a799d16_for___pthread_mutex_s_5 field_5;  // offset: 0x14
}; // size: 0x18

struct __pthread_mutex_s {
    int __lock;  // offset: 0x0
    uint __count;  // offset: 0x4
    int __owner;  // offset: 0x8
    int __kind;  // offset: 0xc
    uint __nusers;  // offset: 0x10
    _union_13 field_20;  // offset: 0x14
}; // size: 0x18

struct __pthread_unwind_buf_t {
    anon_struct_264_2_c715bfa2 __cancel_jmp_buf[1];  // offset: 0x0
    void * __pad[4];  // offset: 0x108
}; // size: 0x118

struct __pthread_unwind_buf_t {
    _struct_1439 __cancel_jmp_buf[1];  // offset: 0x0
    void * __pad[4];  // offset: 0x1c
}; // size: 0x2c

struct __sigset_t {
    ulong __val[32];  // offset: 0x0
}; // size: 0x80

struct __sigset_t {
    ulong __val[32];  // offset: 0x0
}; // size: 0x80

struct __va_list {
    void * __ap;  // offset: 0x0
}; // size: 0x4

struct _cgpu_devid_counter {
    char name[4];  // offset: 0x0
    int lastid;  // offset: 0x4
    UT_hash_handle hh;  // offset: 0x8
}; // size: 0x28

struct _dont_use_rtx_here_ {
    // Empty structure
}; // size: 0x1

struct _struct_1032 {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
}; // size: 0x8

struct _struct_1033 {
    int si_tid;  // offset: 0x0
    int si_overrun;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct _struct_1034 {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct _struct_1035 {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    int si_status;  // offset: 0x8
    __clock_t si_utime;  // offset: 0xc
    __clock_t si_stime;  // offset: 0x10
}; // size: 0x14

struct _struct_1036 {
    void * si_addr;  // offset: 0x0
}; // size: 0x4

struct _struct_1037 {
    long si_band;  // offset: 0x0
    int si_fd;  // offset: 0x4
}; // size: 0x8

struct _struct_1439 {
    __jmp_buf __cancel_jmp_buf;  // offset: 0x0
    int __mask_was_saved;  // offset: 0x18
}; // size: 0x1c

struct _struct_16 {
    int __lock;  // offset: 0x0
    uint __futex;  // offset: 0x4
    ulonglong __total_seq;  // offset: 0x8
    ulonglong __wakeup_seq;  // offset: 0x10
    ulonglong __woken_seq;  // offset: 0x18
    void * __mutex;  // offset: 0x20
    uint __nwaiters;  // offset: 0x24
    uint __broadcast_seq;  // offset: 0x28
}; // size: 0x30

struct _struct_19 {
    int __lock;  // offset: 0x0
    uint __nr_readers;  // offset: 0x4
    uint __readers_wakeup;  // offset: 0x8
    uint __writer_wakeup;  // offset: 0xc
    uint __nr_readers_queued;  // offset: 0x10
    uint __nr_writers_queued;  // offset: 0x14
    uchar __flags;  // offset: 0x18
    uchar __shared;  // offset: 0x19
    uchar __pad1;  // offset: 0x1a
    uchar __pad2;  // offset: 0x1b
    int __writer;  // offset: 0x1c
}; // size: 0x20

struct addrinfo {
    int ai_flags;  // offset: 0x0
    int ai_family;  // offset: 0x4
    int ai_socktype;  // offset: 0x8
    int ai_protocol;  // offset: 0xc
    socklen_t ai_addrlen;  // offset: 0x10
    sockaddr * ai_addr;  // offset: 0x14
    char * ai_canonname;  // offset: 0x18
    addrinfo * ai_next;  // offset: 0x1c
}; // size: 0x20

struct addrinfo {
    int ai_flags;  // offset: 0x0
    int ai_family;  // offset: 0x4
    int ai_socktype;  // offset: 0x8
    int ai_protocol;  // offset: 0xc
    socklen_t ai_addrlen;  // offset: 0x10
    sockaddr * ai_addr;  // offset: 0x14
    char * ai_canonname;  // offset: 0x18
    addrinfo * ai_next;  // offset: 0x1c
}; // size: 0x20

struct all_parameters {
    uint32_t pwm_value;  // offset: 0x0
    uint32_t duty_ns;  // offset: 0x4
    uint8_t chain_exist[4];  // offset: 0x8
    uint8_t chain_asic_in_full[4];  // offset: 0xc
    uint32_t timeout;  // offset: 0x10
    uint32_t fan_exist_map;  // offset: 0x14
    uint32_t temp_sensor_map;  // offset: 0x18
    uint32_t nonce_error;  // offset: 0x1c
    uint32_t[3] chain_asic_exist[4];  // offset: 0x20
    uint32_t[3] chain_asic_status[4];  // offset: 0x50
    int16_t[3][4] chain_asic_temp[4];  // offset: 0x80
    char[4] whether_read_out_temp[4];  // offset: 0xe0
    int8_t chain_asic_iic[3];  // offset: 0xf0
    uint32_t chain_hw[4];  // offset: 0xf3
    uint32_t[3] chain_asic_nonce[4];  // offset: 0x103
    uint32_t[3] chain_asic_invalid_nonce[4];  // offset: 0x133
    char[19] chain_asic_status_string[4];  // offset: 0x163
    uint32_t total_nonce_num;  // offset: 0x1af
    uint32_t fan_fd[6];  // offset: 0x1b3
    uint8_t fan_exist[6];  // offset: 0x1cb
    uint32_t fan_event_count[6];  // offset: 0x1d1
    uint32_t fan_speed_value[6];  // offset: 0x1e9
    uint32_t temp[4];  // offset: 0x201
    uint8_t chain_asic_num[4];  // offset: 0x211
    uint8_t check_bit;  // offset: 0x215
    uint8_t pwm_percent;  // offset: 0x216
    uint8_t chain_num;  // offset: 0x217
    uint8_t fan_num;  // offset: 0x218
    uint8_t temp_num;  // offset: 0x219
    uint32_t fan_speed_top1;  // offset: 0x21a
    uint32_t fan_speed_low1;  // offset: 0x21e
    int32_t temp_top1;  // offset: 0x222
    int32_t temp_chip_top;  // offset: 0x226
    uint32_t temp_top_i[4];  // offset: 0x22a
    uint32_t temp_top1_last;  // offset: 0x23a
    uint8_t corenum;  // offset: 0x23e
    uint8_t addrInterval;  // offset: 0x23f
    uint8_t max_asic_num_in_one_chain;  // offset: 0x240
    uint8_t baud;  // offset: 0x241
    uint8_t diff;  // offset: 0x242
    uint8_t fan_eft;  // offset: 0x243
    uint8_t fan_pwm;  // offset: 0x244
    uint16_t frequency;  // offset: 0x245
    char frequency_t[10];  // offset: 0x247
    uint16_t freq[4];  // offset: 0x251
    uint32_t i2c_fd;  // offset: 0x259
    pollfd pfd[6];  // offset: 0x25d
    int max_local_temp[4];  // offset: 0x28d
    int max_remote_temp[4];  // offset: 0x29d
    undefined field_685;  // offset: 0x2ad
    undefined field_686;  // offset: 0x2ae
    undefined field_687;  // offset: 0x2af
}; // size: 0x2b0

struct anon_struct_12_3_5124685d_for__timer {
    int si_tid;  // offset: 0x0
    int si_overrun;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct anon_struct_12_3_9bedbd60_for__rt {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    sigval_t si_sigval;  // offset: 0x8
}; // size: 0xc

struct anon_struct_12_3_fe5e7108_for__sigsys {
    void * _call_addr;  // offset: 0x0
    int _syscall;  // offset: 0x4
    uint _arch;  // offset: 0x8
}; // size: 0xc

struct anon_struct_20_5_7a025f54_for__sigchld {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
    int si_status;  // offset: 0x8
    __clock_t si_utime;  // offset: 0xc
    __clock_t si_stime;  // offset: 0x10
}; // size: 0x14

struct anon_struct_264_2_c715bfa2 {
    __jmp_buf __cancel_jmp_buf;  // offset: 0x0
    int __mask_was_saved;  // offset: 0x100
    undefined field_260;  // offset: 0x104
    undefined field_261;  // offset: 0x105
    undefined field_262;  // offset: 0x106
    undefined field_263;  // offset: 0x107
}; // size: 0x108

struct anon_struct_32_11_c699d9f5_for___data {
    uint __readers;  // offset: 0x0
    uint __writers;  // offset: 0x4
    uint __wrphase_futex;  // offset: 0x8
    uint __writers_futex;  // offset: 0xc
    uint __pad3;  // offset: 0x10
    uint __pad4;  // offset: 0x14
    uchar __flags;  // offset: 0x18
    uchar __shared;  // offset: 0x19
    uchar __pad1;  // offset: 0x1a
    uchar __pad2;  // offset: 0x1b
    int __cur_writer;  // offset: 0x1c
}; // size: 0x20

struct anon_struct_48_7_e1bf6e98_for___data {
    anon_union_8_2_b529f540_for_anon_struct_48_7_e1bf6e98_for___data_0 field_0;  // offset: 0x0
    anon_union_8_2_f207f8a0_for_anon_struct_48_7_e1bf6e98_for___data_1 field_1;  // offset: 0x8
    uint __g_refs[2];  // offset: 0x10
    uint __g_size[2];  // offset: 0x18
    uint __g1_orig_size;  // offset: 0x20
    uint __wrefs;  // offset: 0x24
    uint __g_signals[2];  // offset: 0x28
}; // size: 0x30

struct anon_struct_4_8_ad5e9fc5_for_u {
    uint32_t:6 bt8d_c0;  // offset: 0x0
    uint32_t:2 reserved_0;  // offset: 0x0
    uint32_t:6 bt8d_c1;  // offset: 0x1
    uint32_t:2 reserved_1;  // offset: 0x1
    uint32_t:6 bt8d_c2;  // offset: 0x2
    uint32_t:2 reserved_2;  // offset: 0x2
    uint32_t:6 bt8d_c3;  // offset: 0x3
    uint32_t:2 reserved_3;  // offset: 0x3
}; // size: 0x4

struct anon_struct_8_2_0a3d7222_for__kill {
    __pid_t si_pid;  // offset: 0x0
    __uid_t si_uid;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_30de7609_for___g1_start32 {
    uint __low;  // offset: 0x0
    uint __high;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_30de7609_for___wseq32 {
    uint __low;  // offset: 0x0
    uint __high;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_686959ae_for__sigpoll {
    long si_band;  // offset: 0x0
    int si_fd;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_895adaa1_for__sigfault {
    void * si_addr;  // offset: 0x0
    short si_addr_lsb;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_f5308dc4 {
    char * name;  // offset: 0x0
    proxytypes_t proxytype;  // offset: 0x4
}; // size: 0x8

struct api_data {
    api_data_type type;  // offset: 0x0
    char * name;  // offset: 0x4
    void * data;  // offset: 0x8
    _Bool data_was_malloc;  // offset: 0xc
    api_data * prev;  // offset: 0x10
    api_data * next;  // offset: 0x14
}; // size: 0x18

struct arm_fpu_desc {
    char * name;  // offset: 0x0
    isa_feature isa_bits[44];  // offset: 0x4
}; // size: 0xb4

struct benchfile_layout {
    int length;  // offset: 0x0
    char * name;  // offset: 0x4
}; // size: 0x8

struct bitmain_ZCASH_info {
    cglock_t update_lock;  // offset: 0x0
    uint8_t data_type;  // offset: 0x38
    uint8_t version;  // offset: 0x39
    uint16_t length;  // offset: 0x3a
    uint8_t:1 chip_value_eft;  // offset: 0x3c
    uint8_t:7 reserved1;  // offset: 0x3c
    uint8_t chain_num;  // offset: 0x3d
    uint16_t reserved2;  // offset: 0x3e
    uint8_t fan_num;  // offset: 0x40
    uint8_t temp_num;  // offset: 0x41
    uint8_t reserved3[2];  // offset: 0x42
    uint32_t fan_exist;  // offset: 0x44
    uint32_t temp_exist;  // offset: 0x48
    uint16_t diff;  // offset: 0x4c
    uint16_t reserved4;  // offset: 0x4e
    uint32_t reg_value;  // offset: 0x50
    uint32_t[0] chain_asic_exist[4];  // offset: 0x54
    uint8_t temp[4];  // offset: 0x58
    uint8_t chain_status[4];  // offset: 0x5c
    uint8_t fan_speed_value[6];  // offset: 0x60
    uint16_t freq[4];  // offset: 0x66
    uint32_t i2c_fd;  // offset: 0x6e
    uint32_t timepoint;  // offset: 0x72
    work * work_queue[128];  // offset: 0x76
    thr_info * thr;  // offset: 0x276
    thr_info uart_tx_t[4];  // offset: 0x27a
    thr_info uart_rx_t[4];  // offset: 0x37a
    pthread_mutex_t lock;  // offset: 0x47a
    init_config ZCASH_config;  // offset: 0x492
    uint16_t crc;  // offset: 0x4b2
}; // size: 0x4b4

struct bitmian_ZCASH_info_with_index {
    bitmain_ZCASH_info * info;  // offset: 0x0
    uint8_t chain_index;  // offset: 0x4
}; // size: 0x8

struct block {
    char hash[68];  // offset: 0x0
    UT_hash_handle hh;  // offset: 0x44
    int block_no;  // offset: 0x64
}; // size: 0x68

struct bm1740_analog_mux_control {
    uint32_t:3 diode_vdd_mux_sel;  // offset: 0x0
    uint32_t:29 reserve;  // offset: 0x0
}; // size: 0x4

struct bm1740_chip_addr {
    uint32_t:8 chip_addr;  // offset: 0x0
    uint32_t:5 reserve2;  // offset: 0x1
    uint32_t:3 reserve1;  // offset: 0x1
    uint32_t:16 chip_name;  // offset: 0x2
}; // size: 0x4

struct bm1740_chip_status {
    uint32_t:8 crc5err;  // offset: 0x0
    uint32_t:8 crc16err;  // offset: 0x1
    uint32_t:4 ram_empty;  // offset: 0x2
    uint32_t:11 reserve;  // offset: 0x2
    uint32_t:1 clrerr;  // offset: 0x3
}; // size: 0x4

struct bm1740_core_timeout {
    uint32_t core_timeout;  // offset: 0x0
}; // size: 0x4

struct bm1740_general_i2c_command {
    uint32_t:8 data;  // offset: 0x0
    uint32_t:8 regaddr;  // offset: 0x1
    uint32_t:1 rwctrl;  // offset: 0x2
    uint32_t:7 devaddr;  // offset: 0x2
    uint32_t:1 ravalid;  // offset: 0x3
    uint32_t:5 reserve;  // offset: 0x3
    uint32_t:1 rwfail;  // offset: 0x3
    uint32_t:1 busy;  // offset: 0x3
}; // size: 0x4

struct bm1740_hash_rate {
    uint32_t:31 hash_rate;  // offset: 0x0
    uint32_t:1 hash_rate_flag;  // offset: 0x3
}; // size: 0x4

struct bm1740_io_drive_strength {
    uint32_t:4 co_ds;  // offset: 0x0
    uint32_t:4 bo_ds;  // offset: 0x0
    uint32_t:4 nrsto_ds;  // offset: 0x1
    uint32_t:4 clko_ds;  // offset: 0x1
    uint32_t:4 ro_ds;  // offset: 0x2
    uint32_t:4 tf_df;  // offset: 0x2
    uint32_t:4 rf_ds;  // offset: 0x3
    uint32_t:4 reserve;  // offset: 0x3
}; // size: 0x4

struct bm1740_misc_control {
    uint32_t:2 hashrate_tws;  // offset: 0x0
    uint32_t:1 auto_rst_bp;  // offset: 0x0
    uint32_t:2 reserve4;  // offset: 0x0
    uint32_t:2 tfs;  // offset: 0x0
    uint32_t:1 reserve3;  // offset: 0x0
    uint32_t:5 bt8d;  // offset: 0x1
    uint32_t:1 invclko;  // offset: 0x1
    uint32_t:1 rfs;  // offset: 0x1
    uint32_t:1 reservex;  // offset: 0x1
    uint32_t:8 reserve2;  // offset: 0x2
    uint32_t:2 addrpin;  // offset: 0x3
    uint32_t:1 latch_ci;  // offset: 0x3
    uint32_t:5 reserve1;  // offset: 0x3
}; // size: 0x4

struct bm1740_nonce_tx_ok {
    uint32_t:16 nonce_txok;  // offset: 0x0
    uint32_t:8 nid;  // offset: 0x2
    uint32_t:7 reserve;  // offset: 0x3
    uint32_t:1 txok_en;  // offset: 0x3
}; // size: 0x4

struct bm1740_pll_parameter {
    uint32_t:3 postdiv2;  // offset: 0x0
    uint32_t:1 reserve4;  // offset: 0x0
    uint32_t:3 postdiv1;  // offset: 0x0
    uint32_t:1 reserve3;  // offset: 0x0
    uint32_t:6 refdiv;  // offset: 0x1
    uint32_t:2 reserve2;  // offset: 0x1
    uint32_t:12 fbdiv;  // offset: 0x2
    uint32_t:3 reserve1;  // offset: 0x3
    uint32_t:1 locked;  // offset: 0x3
}; // size: 0x4

struct bm1740_pmonitor_ctrl {
    uint32_t:6 coreid;  // offset: 0x0
    uint32_t:2 vtsel;  // offset: 0x0
    uint32_t:24 reserve;  // offset: 0x1
}; // size: 0x4

struct bm1740_start_nonce_offset {
    uint32_t sno;  // offset: 0x0
}; // size: 0x4

struct bm1740_ticket_mask {
    uint32_t:8 ticket_mask;  // offset: 0x0
    uint32_t:24 reserve;  // offset: 0x1
}; // size: 0x4

struct bm1740_time_out {
    uint32_t:16 timeout;  // offset: 0x0
    uint32_t:16 nonce_tx_timeout;  // offset: 0x2
}; // size: 0x4

struct bm1740_txn_data {
    uint32_t:1 txn_zero;  // offset: 0x0
    uint32_t:1 txn_shalow;  // offset: 0x0
    uint32_t:30 reaseve;  // offset: 0x0
}; // size: 0x4

struct bm1740_work {
    uint8_t header_55;  // offset: 0x0
    uint8_t header_aa;  // offset: 0x1
    uint8_t:1 test_patten;  // offset: 0x2
    uint8_t:3 reserve;  // offset: 0x2
    uint8_t:1 sno_valid;  // offset: 0x2
    uint8_t:3 type;  // offset: 0x2
    uint8_t workid;  // offset: 0x3
    uint8_t work[140];  // offset: 0x4
    uint16_t crc16;  // offset: 0x90
}; // size: 0x92

struct bm1744_nonce_shift {
    uint32_t:27 reserve;  // offset: 0x0
    uint32_t:5 shift;  // offset: 0x3
}; // size: 0x4

struct buffer_data_t {
    char * data;  // offset: 0x0
    size_t len;  // offset: 0x4
    size_t pos;  // offset: 0x8
}; // size: 0xc

struct callback_data_t {
    char data[1024];  // offset: 0x0
    size_t len;  // offset: 0x400
    size_t pos;  // offset: 0x404
    json_load_callback_t callback;  // offset: 0x408
    void * arg;  // offset: 0x40c
}; // size: 0x410

struct cg_completion {
    cgsem_t cgsem;  // offset: 0x0
    _func_void_void_ptr * fn;  // offset: 0x10
    void * fnarg;  // offset: 0x14
}; // size: 0x18

struct cglock {
    pthread_mutex_t mutex;  // offset: 0x0
    pthread_rwlock_t rwlock;  // offset: 0x18
}; // size: 0x38

struct cgminer_pool_stats {
    uint32_t getwork_calls;  // offset: 0x0
    uint32_t getwork_attempts;  // offset: 0x4
    timeval getwork_wait;  // offset: 0x8
    timeval getwork_wait_max;  // offset: 0x10
    timeval getwork_wait_min;  // offset: 0x18
    double getwork_wait_rolling;  // offset: 0x20
    _Bool hadrolltime;  // offset: 0x28
    _Bool canroll;  // offset: 0x29
    _Bool hadexpire;  // offset: 0x2a
    uint32_t rolltime;  // offset: 0x2c
    double min_diff;  // offset: 0x30
    double max_diff;  // offset: 0x38
    double last_diff;  // offset: 0x40
    uint32_t min_diff_count;  // offset: 0x48
    uint32_t max_diff_count;  // offset: 0x4c
    uint64_t times_sent;  // offset: 0x50
    uint64_t bytes_sent;  // offset: 0x58
    uint64_t net_bytes_sent;  // offset: 0x60
    uint64_t times_received;  // offset: 0x68
    uint64_t bytes_received;  // offset: 0x70
    uint64_t net_bytes_received;  // offset: 0x78
}; // size: 0x80

struct cgminer_stats {
    uint32_t getwork_calls;  // offset: 0x0
    timeval getwork_wait;  // offset: 0x4
    timeval getwork_wait_max;  // offset: 0xc
    timeval getwork_wait_min;  // offset: 0x14
}; // size: 0x1c

struct cgpu_info {
    int cgminer_id;  // offset: 0x0
    device_drv * drv;  // offset: 0x4
    int device_id;  // offset: 0x8
    char * name;  // offset: 0xc
    char * device_path;  // offset: 0x10
    void * device_data;  // offset: 0x14
    void * dup_data;  // offset: 0x18
    char * unique_id;  // offset: 0x1c
    dev_enable deven;  // offset: 0x20
    int accepted;  // offset: 0x24
    int rejected;  // offset: 0x28
    int hw_errors;  // offset: 0x2c
    double rolling;  // offset: 0x30
    double rolling1;  // offset: 0x38
    double rolling5;  // offset: 0x40
    double rolling15;  // offset: 0x48
    double total_mhashes;  // offset: 0x50
    double utility;  // offset: 0x58
    alive status;  // offset: 0x60
    char init[40];  // offset: 0x64
    timeval last_message_tv;  // offset: 0x8c
    int threads;  // offset: 0x94
    thr_info * * thr;  // offset: 0x98
    int64_t max_hashes;  // offset: 0xa0
    char * kname;  // offset: 0xa8
    _Bool new_work;  // offset: 0xac
    double temp;  // offset: 0xb0
    int cutofftemp;  // offset: 0xb8
    int64_t diff1;  // offset: 0xc0
    double diff_accepted;  // offset: 0xc8
    double diff_rejected;  // offset: 0xd0
    int last_share_pool;  // offset: 0xd8
    time_t last_share_pool_time;  // offset: 0xdc
    double last_share_diff;  // offset: 0xe0
    time_t last_device_valid_work;  // offset: 0xe8
    uint32_t last_nonce;  // offset: 0xec
    time_t device_last_well;  // offset: 0xf0
    time_t device_last_not_well;  // offset: 0xf4
    dev_reason device_not_well_reason;  // offset: 0xf8
    int thread_fail_init_count;  // offset: 0xfc
    int thread_zero_hash_count;  // offset: 0x100
    int thread_fail_queue_count;  // offset: 0x104
    int dev_sick_idle_60_count;  // offset: 0x108
    int dev_dead_idle_600_count;  // offset: 0x10c
    int dev_nostart_count;  // offset: 0x110
    int dev_over_heat_count;  // offset: 0x114
    int dev_thermal_cutoff_count;  // offset: 0x118
    int dev_comms_error_count;  // offset: 0x11c
    int dev_throttle_count;  // offset: 0x120
    cgminer_stats cgminer_stats;  // offset: 0x124
    pthread_rwlock_t qlock;  // offset: 0x140
    work * queued_work;  // offset: 0x160
    work * unqueued_work;  // offset: 0x164
    uint queued_count;  // offset: 0x168
    _Bool shutdown;  // offset: 0x16c
    timeval dev_start_tv;  // offset: 0x170
    int hidiff;  // offset: 0x178
    int lodiff;  // offset: 0x17c
    int direction;  // offset: 0x180
}; // size: 0x188

struct chain_inactive_cmd_t {
    uint8_t:4 cmd;  // offset: 0x0
    uint8_t:1 all;  // offset: 0x0
    uint8_t:3 type;  // offset: 0x0
    uint8_t length;  // offset: 0x1
    uint8_t reserve1;  // offset: 0x2
    uint8_t reserve2;  // offset: 0x3
    uint8_t:5 crc5;  // offset: 0x4
    uint8_t:3 reserve3;  // offset: 0x4
}; // size: 0x5

struct curl_ent {
    CURL * curl;  // offset: 0x0
    list_head node;  // offset: 0x4
    timeval tv;  // offset: 0xc
}; // size: 0x14

struct dev_info {
    uint32_t chainid;  // offset: 0x0
}; // size: 0x4

struct device_drv {
    drv_driver drv_id;  // offset: 0x0
    char * dname;  // offset: 0x4
    char * name;  // offset: 0x8
    _func_void__Bool * drv_detect;  // offset: 0xc
    _func_void_cgpu_info_ptr * reinit_device;  // offset: 0x10
    _func_void_char_ptr_size_t_cgpu_info_ptr * get_statline_before;  // offset: 0x14
    _func_void_char_ptr_size_t_cgpu_info_ptr * get_statline;  // offset: 0x18
    _func_api_data_ptr_cgpu_info_ptr * get_api_stats;  // offset: 0x1c
    _func__Bool_cgpu_info_ptr * get_stats;  // offset: 0x20
    _func_void_cgpu_info_ptr * identify_device;  // offset: 0x24
    _func_char_ptr_cgpu_info_ptr_char_ptr_char_ptr_char_ptr * set_device;  // offset: 0x28
    _func__Bool_thr_info_ptr * thread_prepare;  // offset: 0x2c
    _func_uint64_t_thr_info_ptr * can_limit_work;  // offset: 0x30
    _func__Bool_thr_info_ptr * thread_init;  // offset: 0x34
    _func__Bool_thr_info_ptr_work_ptr * prepare_work;  // offset: 0x38
    _func_void_thr_info_ptr * hash_work;  // offset: 0x3c
    _func_int64_t_thr_info_ptr_work_ptr_int64_t * scanhash;  // offset: 0x40
    _func_int64_t_thr_info_ptr * scanwork;  // offset: 0x44
    _func__Bool_cgpu_info_ptr * queue_full;  // offset: 0x48
    _func_void_cgpu_info_ptr * flush_work;  // offset: 0x4c
    _func_void_cgpu_info_ptr * update_work;  // offset: 0x50
    _func_void_thr_info_ptr * hw_error;  // offset: 0x54
    _func_void_thr_info_ptr * thread_shutdown;  // offset: 0x58
    _func_void_thr_info_ptr * thread_enable;  // offset: 0x5c
    _func_void_cgpu_info_ptr * zero_stats;  // offset: 0x60
    _Bool copy;  // offset: 0x64
    double max_diff;  // offset: 0x68
    double working_diff;  // offset: 0x70
    double min_diff;  // offset: 0x78
}; // size: 0x80

struct dupdata {
    int timelimit;  // offset: 0x0
    K_LIST * nfree_list;  // offset: 0x4
    K_LIST * nonce_list;  // offset: 0x8
    uint64_t checked;  // offset: 0x10
    uint64_t dups;  // offset: 0x18
}; // size: 0x20

struct evp_pkey_ctx_st {
    // Empty structure
}; // size: 0x1

struct fd_set {
    __fd_mask fds_bits[32];  // offset: 0x0
}; // size: 0x80

struct fd_set {
    __fd_mask fds_bits[32];  // offset: 0x0
}; // size: 0x80

struct freq_pll_str {
    uint freq;  // offset: 0x0
    uint fildiv1;  // offset: 0x4
    uint fildiv2;  // offset: 0x8
    uint vilpll;  // offset: 0xc
}; // size: 0x10

struct get_status_cmd_t {
    uint8_t header_55;  // offset: 0x0
    uint8_t header_aa;  // offset: 0x1
    uint8_t:4 cmd;  // offset: 0x2
    uint8_t:1 all;  // offset: 0x2
    uint8_t:3 type;  // offset: 0x2
    uint8_t length;  // offset: 0x3
    uint8_t chip_addr;  // offset: 0x4
    uint8_t regaddr;  // offset: 0x5
    uint8_t:5 crc5;  // offset: 0x6
    uint8_t:3 reserve;  // offset: 0x6
}; // size: 0x7

struct hashtable {
    size_t size;  // offset: 0x0
    hashtable_bucket * buckets;  // offset: 0x4
    size_t num_buckets;  // offset: 0x8
    hashtable_list list;  // offset: 0xc
}; // size: 0x14

struct hashtable_bucket {
    hashtable_list * first;  // offset: 0x0
    hashtable_list * last;  // offset: 0x4
}; // size: 0x8

struct hashtable_list {
    hashtable_list * prev;  // offset: 0x0
    hashtable_list * next;  // offset: 0x4
}; // size: 0x8

struct hashtable_pair {
    size_t hash;  // offset: 0x0
    hashtable_list list;  // offset: 0x4
    json_t * value;  // offset: 0xc
    size_t serial;  // offset: 0x10
    char key[1];  // offset: 0x14
}; // size: 0x18

struct in6_addr {
    anon_union_16_3_a3f0114d_for___in6_u __in6_u;  // offset: 0x0
}; // size: 0x10

struct in_addr {
    in_addr_t s_addr;  // offset: 0x0
}; // size: 0x4

struct init_config {
    uint8_t token_type;  // offset: 0x0
    uint8_t version;  // offset: 0x1
    uint16_t length;  // offset: 0x2
    uint32_t baud;  // offset: 0x4
    uint8_t:1 reset;  // offset: 0x8
    uint8_t:1 fan_eft;  // offset: 0x8
    uint8_t:1 timeout_eft;  // offset: 0x8
    uint8_t:1 frequency_eft;  // offset: 0x8
    uint8_t:1 voltage_eft;  // offset: 0x8
    uint8_t:1 chain_check_time_eft;  // offset: 0x8
    uint8_t:1 chip_config_eft;  // offset: 0x8
    uint8_t:1 hw_error_eft;  // offset: 0x8
    uint8_t:1 beeper_ctrl;  // offset: 0x9
    uint8_t:1 temp_ctrl;  // offset: 0x9
    uint8_t:1 chain_freq_eft;  // offset: 0x9
    uint8_t:1 auto_read_temp;  // offset: 0x9
    uint8_t:4 reserved1;  // offset: 0x9
    uint8_t reserved2[2];  // offset: 0xa
    uint8_t chain_num;  // offset: 0xc
    uint8_t asic_num;  // offset: 0xd
    uint8_t fan_pwm_percent;  // offset: 0xe
    uint8_t temperature;  // offset: 0xf
    uint16_t frequency;  // offset: 0x10
    uint8_t voltage[2];  // offset: 0x12
    uint8_t chain_check_time_integer;  // offset: 0x14
    uint8_t chain_check_time_fractions;  // offset: 0x15
    uint8_t timeout_data_integer;  // offset: 0x16
    uint8_t timeout_data_fractions;  // offset: 0x17
    uint32_t reg_data;  // offset: 0x18
    uint8_t chip_address;  // offset: 0x1c
    uint8_t reg_address;  // offset: 0x1d
    uint16_t crc;  // offset: 0x1e
}; // size: 0x20

struct io_data {
    size_t siz;  // offset: 0x0
    char * ptr;  // offset: 0x4
    char * cur;  // offset: 0x8
    _Bool sock;  // offset: 0xc
    _Bool close;  // offset: 0xd
}; // size: 0x10

struct io_list {
    io_data * io_data;  // offset: 0x0
    io_list * prev;  // offset: 0x4
    io_list * next;  // offset: 0x8
}; // size: 0xc

struct ip_mreq {
    in_addr imr_multiaddr;  // offset: 0x0
    in_addr imr_interface;  // offset: 0x4
}; // size: 0x8

struct ipv6_mreq {
    in6_addr ipv6mr_multiaddr;  // offset: 0x0
    uint ipv6mr_interface;  // offset: 0x10
}; // size: 0x14

struct json_array_t {
    json_t json;  // offset: 0x0
    size_t size;  // offset: 0x8
    size_t entries;  // offset: 0xc
    json_t * * table;  // offset: 0x10
    int visited;  // offset: 0x14
}; // size: 0x18

struct json_error_t {
    int line;  // offset: 0x0
    int column;  // offset: 0x4
    int position;  // offset: 0x8
    char source[80];  // offset: 0xc
    char text[160];  // offset: 0x5c
}; // size: 0xfc

struct json_integer_t {
    json_t json;  // offset: 0x0
    json_int_t value;  // offset: 0x8
}; // size: 0x10

struct json_object_t {
    json_t json;  // offset: 0x0
    hashtable_t hashtable;  // offset: 0x8
    size_t serial;  // offset: 0x1c
    int visited;  // offset: 0x20
}; // size: 0x24

struct json_real_t {
    json_t json;  // offset: 0x0
    double value;  // offset: 0x8
}; // size: 0x10

struct json_string_t {
    json_t json;  // offset: 0x0
    char * value;  // offset: 0x8
}; // size: 0xc

struct json_t {
    json_type type;  // offset: 0x0
    size_t refcount;  // offset: 0x4
}; // size: 0x8

struct k_item {
    char * name;  // offset: 0x0
    k_item * prev;  // offset: 0x4
    k_item * next;  // offset: 0x8
    void * data;  // offset: 0xc
}; // size: 0x10

struct k_list {
    char * name;  // offset: 0x0
    _Bool is_store;  // offset: 0x4
    cglock_t * lock;  // offset: 0x8
    k_item * head;  // offset: 0xc
    k_item * tail;  // offset: 0x10
    size_t siz;  // offset: 0x14
    int total;  // offset: 0x18
    int count;  // offset: 0x1c
    int count_up;  // offset: 0x20
    int allocate;  // offset: 0x24
    int limit;  // offset: 0x28
    _Bool do_tail;  // offset: 0x2c
    int item_mem_count;  // offset: 0x30
    void * * item_memory;  // offset: 0x34
    int data_mem_count;  // offset: 0x38
    void * * data_memory;  // offset: 0x3c
}; // size: 0x40

struct lconv {
    char * decimal_point;  // offset: 0x0
    char * thousands_sep;  // offset: 0x4
    char * grouping;  // offset: 0x8
    char * int_curr_symbol;  // offset: 0xc
    char * currency_symbol;  // offset: 0x10
    char * mon_decimal_point;  // offset: 0x14
    char * mon_thousands_sep;  // offset: 0x18
    char * mon_grouping;  // offset: 0x1c
    char * positive_sign;  // offset: 0x20
    char * negative_sign;  // offset: 0x24
    char int_frac_digits;  // offset: 0x28
    char frac_digits;  // offset: 0x29
    char p_cs_precedes;  // offset: 0x2a
    char p_sep_by_space;  // offset: 0x2b
    char n_cs_precedes;  // offset: 0x2c
    char n_sep_by_space;  // offset: 0x2d
    char p_sign_posn;  // offset: 0x2e
    char n_sign_posn;  // offset: 0x2f
    char int_p_cs_precedes;  // offset: 0x30
    char int_p_sep_by_space;  // offset: 0x31
    char int_n_cs_precedes;  // offset: 0x32
    char int_n_sep_by_space;  // offset: 0x33
    char int_p_sign_posn;  // offset: 0x34
    char int_n_sign_posn;  // offset: 0x35
}; // size: 0x38

struct lex_t {
    stream_t stream;  // offset: 0x0
    strbuffer_t saved_text;  // offset: 0x28
    int token;  // offset: 0x34
    anon_union_8_3_477c3ef1_for_value value;  // offset: 0x38
}; // size: 0x40

struct list_head {
    list_head * next;  // offset: 0x0
    list_head * prev;  // offset: 0x4
}; // size: 0x8

struct lldiv_t {
    longlong quot;  // offset: 0x0
    longlong rem;  // offset: 0x8
}; // size: 0x10

struct lldiv_t {
    longlong quot;  // offset: 0x0
    longlong rem;  // offset: 0x8
}; // size: 0x10

struct nitem {
    uint32_t work_id;  // offset: 0x0
    uint32_t nonce;  // offset: 0x4
    timeval when;  // offset: 0x8
}; // size: 0x10

struct nonce_buf {
    uint32_t p_wr;  // offset: 0x0
    uint32_t p_rd;  // offset: 0x4
    uint32_t nonce_num;  // offset: 0x8
    nonce_rb_format nonce_buffer[100];  // offset: 0xc
}; // size: 0x21220

struct nonce_rb_format {
    uint8_t Nonce[1344];  // offset: 0x0
    uint8_t chip_addr;  // offset: 0x540
    uint8_t work_id;  // offset: 0x541
    uint8_t nonce_id;  // offset: 0x542
    uint8_t diff0;  // offset: 0x543
    uint8_t sha256[4];  // offset: 0x544
    uint8_t chip_nonce[4];  // offset: 0x548
    uint8_t chain_id;  // offset: 0x54c
}; // size: 0x54d

struct object_key {
    size_t serial;  // offset: 0x0
    char * key;  // offset: 0x4
}; // size: 0x8

struct opt_table {
    char * names;  // offset: 0x0
    opt_type type;  // offset: 0x4
    _func_char_ptr_void_ptr * cb;  // offset: 0x8
    _func_char_ptr_char_ptr_void_ptr * cb_arg;  // offset: 0xc
    _func_void_char_ptr_void_ptr * show;  // offset: 0x10
    anon_union_4_3_d8f38084_for_u u;  // offset: 0x14
    char * desc;  // offset: 0x18
}; // size: 0x1c

struct pmonitor_respond {
    uint8_t header_aa;  // offset: 0x0
    uint8_t header_55;  // offset: 0x1
    uint8_t format;  // offset: 0x2
    uint8_t pm_data[4];  // offset: 0x3
    uint8_t chip_addr;  // offset: 0x7
    uint8_t:5 crc5;  // offset: 0x8
    uint8_t:3 reserve;  // offset: 0x8
}; // size: 0x9

struct pollfd {
    int fd;  // offset: 0x0
    short events;  // offset: 0x4
    short revents;  // offset: 0x6
}; // size: 0x8

struct pool {
    int pool_no;  // offset: 0x0
    int prio;  // offset: 0x4
    int64_t accepted;  // offset: 0x8
    int64_t rejected;  // offset: 0x10
    int seq_rejects;  // offset: 0x18
    int seq_getfails;  // offset: 0x1c
    int solved;  // offset: 0x20
    int64_t diff1;  // offset: 0x28
    char diff[8];  // offset: 0x30
    int quota;  // offset: 0x38
    int quota_gcd;  // offset: 0x3c
    int quota_used;  // offset: 0x40
    int works;  // offset: 0x44
    uint8_t Target[32];  // offset: 0x48
    double diff_accepted;  // offset: 0x68
    double diff_rejected;  // offset: 0x70
    double diff_stale;  // offset: 0x78
    _Bool submit_fail;  // offset: 0x80
    _Bool idle;  // offset: 0x81
    _Bool lagging;  // offset: 0x82
    _Bool probed;  // offset: 0x83
    pool_enable enabled;  // offset: 0x84
    _Bool submit_old;  // offset: 0x88
    _Bool removed;  // offset: 0x89
    _Bool lp_started;  // offset: 0x8a
    _Bool blocking;  // offset: 0x8b
    char * hdr_path;  // offset: 0x8c
    char * lp_url;  // offset: 0x90
    uint getwork_requested;  // offset: 0x94
    uint stale_shares;  // offset: 0x98
    uint discarded_work;  // offset: 0x9c
    uint getfail_occasions;  // offset: 0xa0
    uint remotefail_occasions;  // offset: 0xa4
    timeval tv_idle;  // offset: 0xa8
    double utility;  // offset: 0xb0
    int last_shares;  // offset: 0xb8
    int shares;  // offset: 0xbc
    char * rpc_req;  // offset: 0xc0
    char * rpc_url;  // offset: 0xc4
    char * rpc_userpass;  // offset: 0xc8
    char * rpc_user;  // offset: 0xcc
    char * rpc_pass;  // offset: 0xd0
    proxytypes_t rpc_proxytype;  // offset: 0xd4
    char * rpc_proxy;  // offset: 0xd8
    pthread_mutex_t pool_lock;  // offset: 0xdc
    cglock_t data_lock;  // offset: 0xf4
    thread_q * submit_q;  // offset: 0x12c
    thread_q * getwork_q;  // offset: 0x130
    pthread_t longpoll_thread;  // offset: 0x134
    pthread_t test_thread;  // offset: 0x138
    _Bool testing;  // offset: 0x13c
    int curls;  // offset: 0x140
    pthread_cond_t cr_cond;  // offset: 0x148
    list_head curlring;  // offset: 0x178
    time_t last_share_time;  // offset: 0x180
    double last_share_diff;  // offset: 0x188
    uint64_t best_diff;  // offset: 0x190
    cgminer_stats cgminer_stats;  // offset: 0x198
    cgminer_pool_stats cgminer_pool_stats;  // offset: 0x1b8
    char prev_block[32];  // offset: 0x238
    char * stratum_url;  // offset: 0x258
    _Bool extranonce_subscribe;  // offset: 0x25c
    char * stratum_port;  // offset: 0x260
    long sock;  // offset: 0x264
    char * sockbuf;  // offset: 0x268
    size_t sockbuf_size;  // offset: 0x26c
    char * sockaddr_url;  // offset: 0x270
    char * sockaddr_proxy_url;  // offset: 0x274
    char * sockaddr_proxy_port;  // offset: 0x278
    char * nonce1;  // offset: 0x27c
    uchar * nonce1bin;  // offset: 0x280
    uint64_t nonce2;  // offset: 0x288
    int n2size;  // offset: 0x290
    char * sessionid;  // offset: 0x294
    _Bool has_stratum;  // offset: 0x298
    _Bool stratum_active;  // offset: 0x299
    _Bool stratum_init;  // offset: 0x29a
    _Bool stratum_notify;  // offset: 0x29b
    stratum_work swork;  // offset: 0x2a0
    pthread_t stratum_sthread;  // offset: 0x2d0
    pthread_t stratum_rthread;  // offset: 0x2d4
    pthread_mutex_t stratum_lock;  // offset: 0x2d8
    thread_q * stratum_q;  // offset: 0x2f0
    int sshares;  // offset: 0x2f4
    _Bool has_gbt;  // offset: 0x2f8
    cglock_t gbt_lock;  // offset: 0x2fc
    uchar previousblockhash[32];  // offset: 0x334
    uchar gbt_target[32];  // offset: 0x354
    char * coinbasetxn;  // offset: 0x374
    char * longpollid;  // offset: 0x378
    char * gbt_workid;  // offset: 0x37c
    int gbt_expires;  // offset: 0x380
    uint32_t gbt_version;  // offset: 0x384
    uint32_t curtime;  // offset: 0x388
    uint32_t gbt_bits;  // offset: 0x38c
    uchar * txn_hashes;  // offset: 0x390
    int gbt_txns;  // offset: 0x394
    int height;  // offset: 0x398
    _Bool gbt_solo;  // offset: 0x39c
    uchar merklebin[512];  // offset: 0x39d
    int transactions;  // offset: 0x5a0
    char * txn_data;  // offset: 0x5a4
    uchar scriptsig_base[100];  // offset: 0x5a8
    uchar script_pubkey[28];  // offset: 0x60c
    int nValue;  // offset: 0x628
    CURL * gbt_curl;  // offset: 0x62c
    _Bool gbt_curl_inuse;  // offset: 0x630
    size_t n1_len;  // offset: 0x634
    uchar * coinbase;  // offset: 0x638
    int coinbase_len;  // offset: 0x63c
    int nonce2_offset;  // offset: 0x640
    uchar header_bin[128];  // offset: 0x644
    int merkles;  // offset: 0x6c4
    char prev_hash[68];  // offset: 0x6c8
    char bbversion[12];  // offset: 0x70c
    char nbit[12];  // offset: 0x718
    char ntime[12];  // offset: 0x724
    double sdiff;  // offset: 0x730
    double next_diff;  // offset: 0x738
    int merkle_offset;  // offset: 0x740
    timeval tv_lastwork;  // offset: 0x744
}; // size: 0x750

struct reg_buf {
    uint32_t p_wr;  // offset: 0x0
    uint32_t p_rd;  // offset: 0x4
    uint32_t reg_value_num;  // offset: 0x8
    reg_rb_format reg_buffer[100];  // offset: 0xc
}; // size: 0x2c8

struct reg_rb_format {
    uint8_t reg_addr;  // offset: 0x0
    uint8_t reg_data[4];  // offset: 0x1
    uint8_t chip_addr;  // offset: 0x5
    uint8_t chain_id;  // offset: 0x6
}; // size: 0x7

struct reg_respond {
    uint8_t header_aa;  // offset: 0x0
    uint8_t header_55;  // offset: 0x1
    uint8_t reg_addr;  // offset: 0x2
    uint8_t reg_data[4];  // offset: 0x3
    uint8_t chip_addr;  // offset: 0x7
    uint8_t:5 crc5;  // offset: 0x8
    uint8_t:3 reserve;  // offset: 0x8
}; // size: 0x9

struct sbitem {
    char * buf;  // offset: 0x0
    size_t siz;  // offset: 0x4
    size_t tot;  // offset: 0x8
}; // size: 0xc

struct scan_freq_status {
    int scan_freq_store_pos;  // offset: 0x0
    uint32_t[3] each_asic_invalid_nonce_each_2min[4];  // offset: 0x4
    uint32_t[3] each_asic_valid_nonce_each_2min[4];  // offset: 0x34
    uint32_t[3] each_asic_ox_status[4];  // offset: 0x64
    uint32_t[3] each_asic_min_freq[4];  // offset: 0x94
    uint32_t[3] each_asic_max_freq[4];  // offset: 0xc4
    uint32_t[3] each_asic_freq[4];  // offset: 0xf4
    uint32_t[3] is_asic_scan_freq_done[4];  // offset: 0x124
}; // size: 0x154

struct schedtime {
    _Bool enable;  // offset: 0x0
    tm tm;  // offset: 0x4
}; // size: 0x30

struct set_address_cmd_t {
    uint8_t:4 cmd;  // offset: 0x0
    uint8_t:1 all;  // offset: 0x0
    uint8_t:3 type;  // offset: 0x0
    uint8_t length;  // offset: 0x1
    uint8_t chip_addr;  // offset: 0x2
    uint8_t reserve1;  // offset: 0x3
    uint8_t:5 crc5;  // offset: 0x4
    uint8_t:3 reserve2;  // offset: 0x4
}; // size: 0x5

struct set_config_cmd_t {
    uint8_t header_55;  // offset: 0x0
    uint8_t header_aa;  // offset: 0x1
    uint8_t:4 cmd;  // offset: 0x2
    uint8_t:1 all;  // offset: 0x2
    uint8_t:3 type;  // offset: 0x2
    uint8_t length;  // offset: 0x3
    uint8_t chip_addr;  // offset: 0x4
    uint8_t regaddr;  // offset: 0x5
    uint8_t regdata[4];  // offset: 0x6
    uint8_t:5 crc5;  // offset: 0xa
    uint8_t:3 reserve;  // offset: 0xa
}; // size: 0xb

struct sha256_ctx {
    uint tot_len;  // offset: 0x0
    uint len;  // offset: 0x4
    uchar block[128];  // offset: 0x8
    uint32_t h[8];  // offset: 0x88
}; // size: 0xa8

struct sha2_context {
    uint32_t total[2];  // offset: 0x0
    uint32_t state[8];  // offset: 0x8
    uchar buffer[64];  // offset: 0x28
    uchar ipad[64];  // offset: 0x68
    uchar opad[64];  // offset: 0xa8
}; // size: 0xe8

struct sigaction {
    anon_union_4_2_5ad2d23e_for___sigaction_handler __sigaction_handler;  // offset: 0x0
    __sigset_t sa_mask;  // offset: 0x4
    int sa_flags;  // offset: 0x84
    _func_void * sa_restorer;  // offset: 0x88
}; // size: 0x8c

struct sigaction {
    _union_1051 __sigaction_handler;  // offset: 0x0
    __sigset_t sa_mask;  // offset: 0x4
    int sa_flags;  // offset: 0x84
    _func_4849 * sa_restorer;  // offset: 0x88
}; // size: 0x8c

struct siginfo {
    int si_signo;  // offset: 0x0
    int si_errno;  // offset: 0x4
    int si_code;  // offset: 0x8
    _union_1031 _sifields;  // offset: 0xc
}; // size: 0x80

struct siginfo_t {
    int si_signo;  // offset: 0x0
    int si_errno;  // offset: 0x4
    int si_code;  // offset: 0x8
    anon_union_116_8_26c2b70a_for__sifields _sifields;  // offset: 0xc
}; // size: 0x80

struct sockaddr {
    sa_family_t sa_family;  // offset: 0x0
    char sa_data[14];  // offset: 0x2
}; // size: 0x10

struct sockaddr {
    sa_family_t sa_family;  // offset: 0x0
    char sa_data[14];  // offset: 0x2
}; // size: 0x10

struct sockaddr_at {
    // Empty structure
}; // size: 0x1

struct sockaddr_ax25 {
    // Empty structure
}; // size: 0x1

struct sockaddr_dl {
    // Empty structure
}; // size: 0x1

struct sockaddr_eon {
    // Empty structure
}; // size: 0x1

struct sockaddr_in {
    sa_family_t sin_family;  // offset: 0x0
    in_port_t sin_port;  // offset: 0x2
    in_addr sin_addr;  // offset: 0x4
    uchar sin_zero[8];  // offset: 0x8
}; // size: 0x10

struct sockaddr_in6 {
    sa_family_t sin6_family;  // offset: 0x0
    in_port_t sin6_port;  // offset: 0x2
    uint32_t sin6_flowinfo;  // offset: 0x4
    in6_addr sin6_addr;  // offset: 0x8
    uint32_t sin6_scope_id;  // offset: 0x18
}; // size: 0x1c

struct sockaddr_inarp {
    // Empty structure
}; // size: 0x1

struct sockaddr_ipx {
    // Empty structure
}; // size: 0x1

struct sockaddr_iso {
    // Empty structure
}; // size: 0x1

struct sockaddr_ns {
    // Empty structure
}; // size: 0x1

struct sockaddr_storage {
    sa_family_t ss_family;  // offset: 0x0
    char __ss_padding[122];  // offset: 0x2
    ulong __ss_align;  // offset: 0x7c
}; // size: 0x80

struct sockaddr_un {
    // Empty structure
}; // size: 0x1

struct sockaddr_x25 {
    // Empty structure
}; // size: 0x1

struct stat {
    __dev_t st_dev;  // offset: 0x0
    ushort __pad1;  // offset: 0x8
    __ino_t st_ino;  // offset: 0xc
    __mode_t st_mode;  // offset: 0x10
    __nlink_t st_nlink;  // offset: 0x14
    __uid_t st_uid;  // offset: 0x18
    __gid_t st_gid;  // offset: 0x1c
    __dev_t st_rdev;  // offset: 0x20
    ushort __pad2;  // offset: 0x28
    __off_t st_size;  // offset: 0x2c
    __blksize_t st_blksize;  // offset: 0x30
    __blkcnt_t st_blocks;  // offset: 0x34
    timespec st_atim;  // offset: 0x38
    timespec st_mtim;  // offset: 0x40
    timespec st_ctim;  // offset: 0x48
    ulong __glibc_reserved4;  // offset: 0x50
    ulong __glibc_reserved5;  // offset: 0x54
}; // size: 0x58

struct strategies {
    char * s;  // offset: 0x0
}; // size: 0x4

struct stratum_share {
    UT_hash_handle hh;  // offset: 0x0
    _Bool block;  // offset: 0x20
    work * work;  // offset: 0x24
    int id;  // offset: 0x28
    time_t sshare_time;  // offset: 0x2c
    time_t sshare_sent;  // offset: 0x30
}; // size: 0x34

struct stratum_work {
    char * job_id;  // offset: 0x0
    char * prev_hash;  // offset: 0x4
    uchar * * merkle_bin;  // offset: 0x8
    char * bbversion;  // offset: 0xc
    char * nbit;  // offset: 0x10
    char * ntime;  // offset: 0x14
    _Bool clean;  // offset: 0x18
    size_t cb_len;  // offset: 0x1c
    size_t header_len;  // offset: 0x20
    int merkles;  // offset: 0x24
    double diff;  // offset: 0x28
}; // size: 0x30

struct strbuffer_t {
    char * value;  // offset: 0x0
    size_t length;  // offset: 0x4
    size_t size;  // offset: 0x8
}; // size: 0xc

struct stream_t {
    get_func get;  // offset: 0x0
    void * data;  // offset: 0x4
    char buffer[5];  // offset: 0x8
    size_t buffer_pos;  // offset: 0x10
    int state;  // offset: 0x14
    int line;  // offset: 0x18
    int column;  // offset: 0x1c
    int last_column;  // offset: 0x20
    size_t position;  // offset: 0x24
}; // size: 0x28

struct string_data_t {
    char * data;  // offset: 0x0
    int pos;  // offset: 0x4
}; // size: 0x8

struct thr_info {
    int id;  // offset: 0x0
    int device_thread;  // offset: 0x4
    _Bool primary_thread;  // offset: 0x8
    pthread_t pth;  // offset: 0xc
    cgsem_t sem;  // offset: 0x10
    thread_q * q;  // offset: 0x20
    cgpu_info * cgpu;  // offset: 0x24
    void * cgpu_data;  // offset: 0x28
    timeval last;  // offset: 0x2c
    timeval sick;  // offset: 0x34
    _Bool pause;  // offset: 0x3c
    _Bool getwork;  // offset: 0x3d
    _Bool work_restart;  // offset: 0x3e
    _Bool work_update;  // offset: 0x3f
}; // size: 0x40

struct thread_q {
    list_head q;  // offset: 0x0
    _Bool frozen;  // offset: 0x8
    pthread_mutex_t mutex;  // offset: 0xc
    pthread_cond_t cond;  // offset: 0x28
}; // size: 0x58

struct timespec {
    __time_t tv_sec;  // offset: 0x0
    __syscall_slong_t tv_nsec;  // offset: 0x4
}; // size: 0x8

struct timespec {
    __time_t tv_sec;  // offset: 0x0
    long tv_nsec;  // offset: 0x4
}; // size: 0x8

struct timeval {
    __time_t tv_sec;  // offset: 0x0
    __suseconds_t tv_usec;  // offset: 0x4
}; // size: 0x8

struct timeval {
    __time_t tv_sec;  // offset: 0x0
    __suseconds_t tv_usec;  // offset: 0x4
}; // size: 0x8

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct tm {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long tm_gmtoff;  // offset: 0x24
    char * tm_zone;  // offset: 0x28
}; // size: 0x2c

struct tm {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long tm_gmtoff;  // offset: 0x24
    char * tm_zone;  // offset: 0x28
}; // size: 0x2c

struct tq_ent {
    void * data;  // offset: 0x0
    list_head q_node;  // offset: 0x4
}; // size: 0xc

struct validData {
    int n;  // offset: 0x0
    int k;  // offset: 0x4
    blake2b_state * digest;  // offset: 0x8
}; // size: 0xc

struct work {
    uchar data[128];  // offset: 0x0
    uchar midstate[32];  // offset: 0x80
    uchar target[32];  // offset: 0xa0
    uchar hash[32];  // offset: 0xc0
    uchar equihash_data[1487];  // offset: 0xe0
    double device_diff;  // offset: 0x6b0
    uint64_t share_diff;  // offset: 0x6b8
    int rolls;  // offset: 0x6c0
    int drv_rolllimit;  // offset: 0x6c4
    uint32_t nonce;  // offset: 0x6c8
    thr_info * thr;  // offset: 0x6cc
    int thr_id;  // offset: 0x6d0
    pool * pool;  // offset: 0x6d4
    timeval tv_staged;  // offset: 0x6d8
    _Bool mined;  // offset: 0x6e0
    _Bool clone;  // offset: 0x6e1
    _Bool cloned;  // offset: 0x6e2
    int rolltime;  // offset: 0x6e4
    _Bool longpoll;  // offset: 0x6e8
    _Bool stale;  // offset: 0x6e9
    _Bool mandatory;  // offset: 0x6ea
    _Bool block;  // offset: 0x6eb
    _Bool stratum;  // offset: 0x6ec
    char * job_id;  // offset: 0x6f0
    uint64_t nonce2;  // offset: 0x6f8
    size_t nonce2_len;  // offset: 0x700
    char * ntime;  // offset: 0x704
    double sdiff;  // offset: 0x708
    char * nonce1;  // offset: 0x710
    _Bool gbt;  // offset: 0x714
    char * coinbase;  // offset: 0x718
    int gbt_txns;  // offset: 0x71c
    uint work_block;  // offset: 0x720
    uint32_t id;  // offset: 0x724
    UT_hash_handle hh;  // offset: 0x728
    double work_difficulty;  // offset: 0x748
    int subid;  // offset: 0x750
    _Bool devflag;  // offset: 0x754
    timeval tv_stamp;  // offset: 0x758
    timeval tv_getwork;  // offset: 0x760
    timeval tv_getwork_reply;  // offset: 0x768
    timeval tv_cloned;  // offset: 0x770
    timeval tv_work_start;  // offset: 0x778
    timeval tv_work_found;  // offset: 0x780
    char getwork_mode;  // offset: 0x788
    uchar device_target[32];  // offset: 0x789
}; // size: 0x7b0

/* ==================== Unions ==================== */

union _dont_use_tree_here_ {
}; // size: 0x1

union _fpga_bt8d_t {
    anon_struct_4_8_ad5e9fc5_for_u u;
    uint32_t v;
}; // size: 0x4

union _union_1031 {
    int[29] _pad;
    _struct_1032 _kill;
    _struct_1033 _timer;
    _struct_1034 _rt;
    _struct_1035 _sigchld;
    _struct_1036 _sigfault;
    _struct_1037 _sigpoll;
}; // size: 0x74

union _union_1051 {
    __sighandler_t sa_handler;
    _func_4848 * sa_sigaction;
}; // size: 0x4

union _union_13 {
    int __spins;
    __pthread_slist_t __list;
}; // size: 0x4

union anon_union_116_8_26c2b70a_for__sifields {
    int[29] _pad;
    anon_struct_8_2_0a3d7222_for__kill _kill;
    anon_struct_12_3_5124685d_for__timer _timer;
    anon_struct_12_3_9bedbd60_for__rt _rt;
    anon_struct_20_5_7a025f54_for__sigchld _sigchld;
    anon_struct_8_2_895adaa1_for__sigfault _sigfault;
    anon_struct_8_2_686959ae_for__sigpoll _sigpoll;
    anon_struct_12_3_fe5e7108_for__sigsys _sigsys;
}; // size: 0x74

union anon_union_16_3_a3f0114d_for___in6_u {
    uint8_t[16] __u6_addr8;
    uint16_t[8] __u6_addr16;
    uint32_t[4] __u6_addr32;
}; // size: 0x10

union anon_union_4_2_5ad2d23e_for___sigaction_handler {
    __sighandler_t sa_handler;
    _func_void_int_siginfo_t_ptr_void_ptr * sa_sigaction;
}; // size: 0x4

union anon_union_4_2_9a799d16_for___pthread_mutex_s_5 {
    int __spins;
    __pthread_slist_t __list;
}; // size: 0x4

union anon_union_4_3_d8f38084_for_u {
    void * carg;
    void * arg;
    size_t tlen;
}; // size: 0x4

union anon_union_8_2_b529f540_for_anon_struct_48_7_e1bf6e98_for___data_0 {
    ulonglong __wseq;
    anon_struct_8_2_30de7609_for___wseq32 __wseq32;
}; // size: 0x8

union anon_union_8_2_f207f8a0_for_anon_struct_48_7_e1bf6e98_for___data_1 {
    ulonglong __g1_start;
    anon_struct_8_2_30de7609_for___g1_start32 __g1_start32;
}; // size: 0x8

union anon_union_8_3_477c3ef1_for_value {
    char * string;
    json_int_t integer;
    double real;
}; // size: 0x8

union bm1740_reg {
    bm1740_chip_addr chip_addr;
    bm1740_hash_rate hash_rate;
    bm1740_pll_parameter pll_parameter;
    bm1740_ticket_mask ticket_mask;
    bm1740_misc_control misc_control;
    bm1740_general_i2c_command general_i2c_command;
    bm1740_nonce_tx_ok nonce_tx_ok;
    bm1740_core_timeout core_timeout;
    bm1740_io_drive_strength io_drive_strength;
    bm1740_chip_status chip_status;
    bm1740_time_out time_out;
    bm1740_pmonitor_ctrl pmonitor_ctrl;
    bm1740_analog_mux_control analog_mux_control;
    bm1744_nonce_shift nonce_shift;
    bm1740_start_nonce_offset start_nonce_offset;
    bm1740_txn_data txn_data;
    uint32_t reg_bin;
}; // size: 0x4

union pthread_attr_t {
    char[36] __size;
    long __align;
}; // size: 0x24

union pthread_attr_t {
    char[36] __size;
    long __align;
}; // size: 0x24

union pthread_cond_t {
    anon_struct_48_7_e1bf6e98_for___data __data;
    char[48] __size;
    longlong __align;
}; // size: 0x30

union pthread_cond_t {
    _struct_16 __data;
    char[48] __size;
    longlong __align;
}; // size: 0x30

union pthread_condattr_t {
    char[4] __size;
    int __align;
}; // size: 0x4

union pthread_mutex_t {
    __pthread_mutex_s __data;
    char[24] __size;
    long __align;
}; // size: 0x18

union pthread_mutex_t {
    __pthread_mutex_s __data;
    char[24] __size;
    long __align;
}; // size: 0x18

union pthread_mutexattr_t {
    char[4] __size;
    int __align;
}; // size: 0x4

union pthread_rwlock_t {
    anon_struct_32_11_c699d9f5_for___data __data;
    char[32] __size;
    long __align;
}; // size: 0x20

union pthread_rwlock_t {
    _struct_19 __data;
    char[32] __size;
    long __align;
}; // size: 0x20

union pthread_rwlockattr_t {
    char[8] __size;
    long __align;
}; // size: 0x8

union sem_t {
    char[16] __size;
    long __align;
}; // size: 0x10

union sem_t {
    char[16] __size;
    long __align;
}; // size: 0x10

union sigval {
    int sival_int;
    void * sival_ptr;
}; // size: 0x4

union sigval {
    int sival_int;
    void * sival_ptr;
}; // size: 0x4

/* ==================== Type Definitions ==================== */

typedef uchar CURL;
typedef double DFtype;
typedef longlong DItype;
typedef evp_pkey_ctx_st EVP_PKEY_CTX;
typedef _IO_FILE FILE;
typedef _IO_FILE FILE;
typedef k_item K_ITEM;
typedef k_list K_LIST;
typedef nitem NITEM;
typedef sbitem SBITEM;
typedef SHA256Context SHA256_CTX;
typedef SHA256state_st SHA256_CTX;
typedef ulonglong UDItype;
typedef uchar UQItype;
typedef uint USItype;
typedef bool _Bool;
typedef void _IO_lock_t;
typedef void _IO_lock_t;
typedef int __blkcnt_t;
typedef int __blksize_t;
typedef int __clock_t;
typedef long __clock_t;
typedef int __clockid_t;
typedef __compar_fn_t * __compar_fn_t;
typedef __u_quad_t __dev_t;
typedef int __fd_mask;
typedef long __fd_mask;
typedef uint __gid_t;
typedef __va_list __gnuc_va_list;
typedef void * __gnuc_va_list;
typedef uint __ino_t;
typedef int __int32_t;
typedef int[64] __jmp_buf;
typedef int[6] __jmp_buf;
typedef uint __mode_t;
typedef uint __mode_t;
typedef uint __nlink_t;
typedef __quad_t __off64_t;
typedef __quad_t __off64_t;
typedef int __off_t;
typedef long __off_t;
typedef int __pid_t;
typedef int __pid_t;
typedef __pthread_internal_slist __pthread_slist_t;
typedef __pthread_internal_slist __pthread_slist_t;
typedef longlong __quad_t;
typedef longlong __quad_t;
typedef _func_void_int * __sighandler_t;
typedef __sighandler_t * __sighandler_t;
typedef uint __socklen_t;
typedef uint __socklen_t;
typedef int __ssize_t;
typedef int __ssize_t;
typedef int __suseconds_t;
typedef long __suseconds_t;
typedef int __syscall_slong_t;
typedef int __time_t;
typedef long __time_t;
typedef timezone * __timezone_ptr_t;
typedef ulonglong __u_quad_t;
typedef uint __uid_t;
typedef uint __uid_t;
typedef dword __uint32_t;
typedef qword __uint64_t;
typedef uint __useconds_t;
typedef arm_cond_code arm_cc;
typedef __blake2b_param blake2b_param;
typedef __blake2b_state blake2b_state;
typedef hashtable_bucket bucket_t;
typedef cglock cglock_t;
typedef sem_t cgsem_t;
typedef timespec cgtimer_t;
typedef __clockid_t clockid_t;
typedef undefined[16] complex double;
typedef qword complex float;
typedef uint32_t eh_index;
typedef _fpga_bt8d_t fpga_bt8d_t;
typedef _func_int_void_ptr * get_func;
typedef hashtable hashtable_t;
typedef uint hashval_t;
typedef _func_int_void_ptr_void_ptr * htab_eq;
typedef _func_hashval_t_void_ptr * htab_hash;
typedef uint32_t in_addr_t;
typedef uint32_t in_addr_t;
typedef uint16_t in_port_t;
typedef sword int16_t;
typedef sdword int32_t;
typedef sqword int64_t;
typedef char int8_t;
typedef _func_int_char_ptr_size_t_void_ptr * json_dump_callback_t;
typedef _func_void_void_ptr * json_free_t;
typedef longlong json_int_t;
typedef _func_size_t_void_ptr_size_t_void_ptr * json_load_callback_t;
typedef _func_void_ptr_size_t * json_malloc_t;
typedef hashtable_list list_t;
typedef hashtable_pair pair_t;
typedef int proxytypes_t;
typedef uint pthread_t;
typedef ulong pthread_t;
typedef int ptrdiff_t;
typedef ushort sa_family_t;
typedef ushort sa_family_t;
typedef __sighandler_t sighandler_t;
typedef siginfo siginfo_t;
typedef __sigset_t sigset_t;
typedef sigval sigval_t;
typedef sigval sigval_t;
typedef uint size_t;
typedef ulong size_t;
typedef __socklen_t socklen_t;
typedef __socklen_t socklen_t;
typedef uint speed_t;
typedef __ssize_t ssize_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef __time_t time_t;
typedef word uint16_t;
typedef dword uint32_t;
typedef uint uint32_t;
typedef qword uint64_t;
typedef uchar uint8_t;
typedef uint uintptr_t;
typedef __gnuc_va_list va_list;

/* ==================== Function Prototypes ==================== */

ushort CRC16(uchar * buffer, int len);
uchar CRC5(uchar * ptr, uchar len);
_Bool DistinctIndices(uint8_t * a, uint8_t * b, size_t hashLen, uint32_t indicesLen);
_Bool HasCollision(uint8_t * a, uint8_t * b, int l);
int ISL_get_i2c_data(uint8_t i2c_reg_addr, uint8_t * i2c_reg_data, int len);
int ISL_get_voltage(uint8_t i2c_dev_addr, uint16_t * voltage);
int ISL_set_i2c_data(uint8_t i2c_reg_addr, uint8_t * i2c_reg_data, int len);
uint16_t ISL_set_voltage(uint8_t i2c_dev_addr, uint16_t voltage);
uint16_t ISL_set_voltage_dynamic(uint8_t i2c_dev_addr, uint16_t vol);
_Bool IndicesBefore(uint8_t * a, uint8_t * b, size_t hashLen, uint32_t indicesLen);
int IsValidSolution(blake2b_state * base_state, uchar * soln);
_Bool IsZero(uint8_t * a, size_t len);
int PIC16F1704_i2c_forward_send(uint8_t dev_addr, int rw_flag, uint8_t reg_addr, int len, uint8_t * data);
int PIC1704_update_pic_app_program_new(void);
void RenameThread(char * name);
void SHA256_Transform(uint32_t * state, uint32_t * block, int swap);
void Sha256_Final(CSha256 * p, uint8_t * digest);
void Sha256_Init(CSha256 * p);
void Sha256_Onestep(uint8_t * data, size_t size, uint8_t * digest);
void Sha256_Update(CSha256 * p, uint8_t * data, size_t size);
void Sha256_WriteByteBlock(CSha256 * p);
char * Strcasestr(char * haystack, char * needle);
char * Strsep(char * * stringp, char * delim);
int XDPED_update_asics_vol(uint32_t vol);
void * ZCASH_fill_work(void * usrdata);
int ZCASH_read(int uart_fd, uchar * buf, size_t MAX_READ_BYTES);
int ZCASH_write(int fd, uint8_t * buf, size_t bufLen);
void __add_queued(cgpu_info * cgpu, work * work);
void __bin2hex(char * s, uchar * p, size_t len);
int __compar_fn_t(void * param0, void * param1);
work * __find_work_byid(work * que, uint32_t id);
work * __find_work_bymidstate(work * que, char * midstate, size_t midstatelen, char * data, int offset, size_t datalen);
DItype __fixdfdi(DFtype a);
UDItype __fixunsdfdi(DFtype a);
work * __get_queued(cgpu_info * cgpu);
char * __json_array_string(json_t * val, uint entry);
void __kill_work(void);
void __libc_csu_fini(void);
void __libc_csu_init(int argc, char * * argv, char * * envp);
void __quit(int status, _Bool clean);
void __sighandler_t(int param0);
void * __start_routine(void * param0);
send_ret __stratum_send(pool * pool, char * s, ssize_t len);
void __suspend_stratum(pool * pool);
UDItype __udivmoddi4(UDItype n, UDItype d, UDItype * rp);
void __work_completed(cgpu_info * cgpu, work * work);
void _applog(int prio, char * str, _Bool force);
void _cg_memcpy(void * dest, void * src, uint n, char * file, char * func, int line);
void _cglock_init(cglock_t * lock, char * file, char * func, int line);
void _cgsem_init(cgsem_t * cgsem, char * file, char * func, int line);
int _cgsem_mswait(cgsem_t * cgsem, int ms, char * file, char * func, int line);
void _cgsem_post(cgsem_t * cgsem, char * file, char * func, int line);
void _cgsem_wait(cgsem_t * cgsem, char * file, char * func, int line);
void _copy_work(work * work, work * base_work, int noffset);
void _discard_work(work * work);
void _free_work(work * work);
void _func_4848(int param0, siginfo_t * param1, void * param2);
void _func_4849(void);
_Bool _func__Bool_cgpu_info_ptr(cgpu_info * param0);
_Bool _func__Bool_thr_info_ptr(thr_info * param0);
_Bool _func__Bool_thr_info_ptr_work_ptr(thr_info * param0, work * param1);
api_data * _func_api_data_ptr_cgpu_info_ptr(cgpu_info * param0);
char * _func_char_ptr_cgpu_info_ptr_char_ptr_char_ptr_char_ptr(cgpu_info * param0, char * param1, char * param2, char * param3);
char * _func_char_ptr_char_ptr_void_ptr(char * param0, void * param1);
char * _func_char_ptr_void_ptr(void * param0);
hashval_t _func_hashval_t_void_ptr(void * param0);
int _func_int(void);
int64_t _func_int64_t_thr_info_ptr(thr_info * param0);
int64_t _func_int64_t_thr_info_ptr_work_ptr_int64_t(thr_info * param0, work * param1, int64_t param2);
int _func_int_char_ptr_size_t_void_ptr(char * param0, size_t param1, void * param2);
int _func_int_void_ptr(void * param0);
int _func_int_void_ptr_void_ptr(void * param0, void * param1);
size_t _func_size_t_void_ptr_size_t_void_ptr(void * param0, size_t param1, void * param2);
uint64_t _func_uint64_t_thr_info_ptr(thr_info * param0);
void _func_void(void);
void _func_void__Bool(_Bool param0);
void _func_void_cgpu_info_ptr(cgpu_info * param0);
void _func_void_char_ptr_size_t_cgpu_info_ptr(char * param0, size_t param1, cgpu_info * param2);
void _func_void_char_ptr_varargs(char * param0);
void _func_void_char_ptr_void_ptr(char * param0, void * param1);
void _func_void_int(int param0);
void _func_void_int_char_ptr_ptr_char_ptr_ptr(int param0, char * * param1, char * * param2);
void _func_void_int_siginfo_t_ptr_void_ptr(int param0, siginfo_t * param1, void * param2);
void _func_void_io_data_ptr_long_char_ptr__Bool_char(io_data * param0, long param1, char * param2, _Bool param3, char param4);
void * _func_void_ptr_size_t(size_t param0);
void * _func_void_ptr_void_ptr(void * param0);
void * _func_void_ptr_void_ptr_int_size_t(void * param0, int param1, size_t param2);
void _func_void_thr_info_ptr(thr_info * param0);
void _func_void_void_ptr(void * param0);
void _k_add_head(K_LIST * list, K_ITEM * item, char * file, char * func, int line);
void _k_add_tail(K_LIST * list, K_ITEM * item, char * file, char * func, int line);
K_LIST * _k_free_list(K_LIST * list, char * file, char * func, int line);
K_LIST * _k_free_store(K_LIST * store, char * file, char * func, int line);
void _k_insert_after(K_LIST * list, K_ITEM * item, K_ITEM * after, char * file, char * func, int line);
void _k_insert_before(K_LIST * list, K_ITEM * item, K_ITEM * before, char * file, char * func, int line);
void _k_list_transfer_to_head(K_LIST * from, K_LIST * to, char * file, char * func, int line);
void _k_list_transfer_to_tail(K_LIST * from, K_LIST * to, char * file, char * func, int line);
K_LIST * _k_new_list(char * name, size_t siz, int allocate, int limit, _Bool do_tail, char * file, char * func, int line);
K_ITEM * _k_unlink_head(K_LIST * list, char * file, char * func, int line);
K_ITEM * _k_unlink_head_zero(K_LIST * list, char * file, char * func, int line);
void _k_unlink_item(K_LIST * list, K_ITEM * item, char * file, char * func, int line);
K_ITEM * _k_unlink_tail(K_LIST * list, char * file, char * func, int line);
void _mutex_init(pthread_mutex_t * lock, char * file, char * func, int line);
void _mutex_lock(pthread_mutex_t * lock, char * file, char * func, int line);
void _mutex_unlock_noyield(pthread_mutex_t * lock, char * file, char * func, int line);
void _opt_register(char * names, opt_type type, _func_char_ptr_void_ptr * cb, _func_char_ptr_char_ptr_void_ptr * cb_arg, _func_void_char_ptr_void_ptr * show, void * arg, char * desc);
void _quit(int status);
void _rd_lock(pthread_rwlock_t * lock, char * file, char * func, int line);
void _recalloc(void * * ptr, size_t old, size_t new, char * file, char * func, int line);
void _rw_unlock(pthread_rwlock_t * lock, char * file, char * func, int line);
void _rwlock_init(pthread_rwlock_t * lock, char * file, char * func, int line);
void _simplelog(int prio, char * str, _Bool force);
void _stage_work(work * work);
void _wr_lock(pthread_rwlock_t * lock, char * file, char * func, int line);
_Bool add_cgpu(cgpu_info * cgpu);
void add_item_buf(K_ITEM * item, char * str);
void add_opt(opt_table * entry);
pool * add_pool(void);
_Bool add_pool_details(pool * pool, _Bool live, char * url, char * user, char * pass);
void add_queued(cgpu_info * cgpu, work * work);
pool * add_url(void);
int add_var_int(uint8_t * msg, uint64_t var_int);
void addpool(io_data * io_data, long c, char * param, _Bool isjson, char group);
void address_to_pubkeyhash(uchar * pkh, char * addr);
void addtime(timeval * a, timeval * b);
float adjust_pwm_bm1744_4chips(int temp);
void adjust_quota_gcd(void);
int age_queued_work(cgpu_info * cgpu, double secs);
void api(int api_thr_id);
api_data * api_add_avg(api_data * root, char * name, float * data, _Bool copy_data);
api_data * api_add_bool(api_data * root, char * name, _Bool * data, _Bool copy_data);
api_data * api_add_const(api_data * root, char * name, char * data, _Bool copy_data);
api_data * api_add_data_full(api_data * root, char * name, api_data_type type, void * data, _Bool copy_data);
api_data * api_add_diff(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_double(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_elapsed(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_escape(api_data * root, char * name, char * data, _Bool copy_data);
api_data * api_add_freq(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_hex32(api_data * root, char * name, uint32_t * data, _Bool copy_data);
api_data * api_add_hs(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_int(api_data * root, char * name, int * data, _Bool copy_data);
api_data * api_add_int16(api_data * root, char * name, int16_t * data, _Bool copy_data);
api_data * api_add_int64(api_data * root, char * name, int64_t * data, _Bool copy_data);
api_data * api_add_mhs(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_mhtotal(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_percent(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_string(api_data * root, char * name, char * data, _Bool copy_data);
api_data * api_add_temp(api_data * root, char * name, float * data, _Bool copy_data);
api_data * api_add_time(api_data * root, char * name, time_t * data, _Bool copy_data);
api_data * api_add_timeval(api_data * root, char * name, timeval * data, _Bool copy_data);
api_data * api_add_uint(api_data * root, char * name, uint * data, _Bool copy_data);
api_data * api_add_uint16(api_data * root, char * name, uint16_t * data, _Bool copy_data);
api_data * api_add_uint32(api_data * root, char * name, uint32_t * data, _Bool copy_data);
api_data * api_add_uint64(api_data * root, char * name, uint64_t * data, _Bool copy_data);
api_data * api_add_uint8(api_data * root, char * name, uint8_t * data, _Bool copy_data);
api_data * api_add_utility(api_data * root, char * name, double * data, _Bool copy_data);
api_data * api_add_volts(api_data * root, char * name, float * data, _Bool copy_data);
void * api_thread(void * userdata);
void apiversion(io_data * io_data, long c, char * param, _Bool isjson, char group);
void app_restart(void);
void applog_and_exit(char * fmt);
char * arg_bad(char * fmt, char * arg);
void asccount(io_data * io_data, long c, char * param, _Bool isjson, char group);
uchar asic_baud_to_fpga_baud(uchar asic_baud);
_Bool auth_stratum(pool * pool);
void b58tobin(uchar * b58bin, char * b58);
void benchfile_dspwork(work * work, uint32_t nonce);
_Bool benchfile_get_work(work * work);
char * bin2hex(uchar * p, size_t len);
uchar bit_read(uchar * y, int x);
void bitmain_ZCASH_detect(_Bool hotplug);
int bitmain_ZCASH_init(bitmain_ZCASH_info * info);
_Bool bitmain_ZCASH_prepare(thr_info * thr);
void * bitmain_ZCASH_reinit_chain(void * usrdata);
void bitmain_ZCASH_reinit_device(cgpu_info * bitmain);
int64_t bitmain_ZCASH_scanhash(thr_info * thr);
void bitmain_ZCASH_shutdown(thr_info * thr);
void bitmain_ZCASH_update(cgpu_info * bitmain);
api_data * bitmain_api_stats(cgpu_info * cgpu);
int bitmain_axi_close(void);
int bitmain_axi_init(void);
void * bitmain_scanhash(void * arg);
int blake2b(uint8_t * out, void * in, void * key, uint8_t outlen, uint64_t inlen, uint8_t keylen);
int blake2b_compress(blake2b_state * S, uint8_t * block);
int blake2b_final(blake2b_state * S, uint8_t * out, uint8_t outlen);
int blake2b_init(blake2b_state * S, uint8_t outlen);
int blake2b_init_key(blake2b_state * S, uint8_t outlen, void * key, uint8_t keylen);
int blake2b_init_param(blake2b_state * S, blake2b_param * P);
int blake2b_update(blake2b_state * S, uint8_t * in, uint64_t inlen);
void blank_get_statline_before(char * buf, size_t bufsiz, cgpu_info * cgpu);
void block_socket(long fd);
int bm1740_makeup_chain_inactive_cmd(uint8_t * str, uint32_t str_len);
int bm1740_makeup_get_status_cmd(uint8_t * str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr);
int bm1740_makeup_set_address_cmd(uint8_t * str, uint32_t str_len, uint8_t chip_addr);
int bm1740_makeup_set_config_cmd(uint8_t * str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr, uint32_t regdata);
int bm1740_makeup_work(uint8_t * str, int len);
int buffer_get(void * data);
void calc_diff(work * work, double known);
void calculate_address_interval(void);
int calculate_asic_number(uint actual_asic_number);
void calculate_hash_rate(void);
void calibration_sensor_offset(void);
void calibration_sensor_offset_chain(uchar which_chain);
int callback_get(void * data);
_Bool cg_completion_timeout(void * fn, void * fnarg, int timeout);
void cg_logwork(work * work, uchar * nonce_bin, _Bool ok);
void cg_logwork_uint32(work * work, uint32_t nonce, _Bool ok);
int cg_timeval_subtract(timeval * result, timeval * x, timeval * y);
double cgpu_runtime(cgpu_info * cgpu);
void cgsem_destroy(cgsem_t * cgsem);
void cgsem_reset(cgsem_t * cgsem);
void cgsleep_ms(int ms);
void cgsleep_ms_r(cgtimer_t * ts_start, int ms);
void cgsleep_us(int64_t us);
void cgsleep_us_r(cgtimer_t * ts_start, int64_t us);
void cgtime(timeval * tv);
void cgtimer_sub(cgtimer_t * a, cgtimer_t * b, cgtimer_t * res);
void cgtimer_time(cgtimer_t * ts_start);
int cgtimer_to_ms(cgtimer_t * cgt);
void chain_inactive(int which_chain);
void check_asic_reg(uchar which_chain, uchar chip_addr, uchar reg, _Bool mode);
int check_asicnum(int asic_num, uchar nonce);
void check_chain(void);
void check_chain_asic_number(uchar which_chain, _Bool whether_update_asic_num);
_Bool check_connect(sockaddr_storage * cli, char * * connectaddr, char * group);
void check_every_chain_asic_number(_Bool whether_update_asic_num);
void check_every_chain_asic_pll(void);
void check_extranonce_option(pool * pool, char * url);
void check_fan_speed(void);
void * check_fan_thr(void * arg);
void check_fpga_version(void);
uint check_how_many_uart_data_in_fpga(uchar which_uart);
void * check_miner_status(void * arg);
void check_opt(opt_table * entry);
void check_sensor_ID(void);
void check_whether_need_update_pic_program(void);
void checkcommand(io_data * io_data, long c, char * param, _Bool isjson, char group);
void clean_work(work * work);
int clear_every_chain_freq_to_pic(void);
void clear_nonce_fifo(void);
void clear_pool_work(pool * pool);
void clear_register_value_buf(void);
void clear_sock(pool * pool);
void clear_stratum_shares(pool * pool);
uint clear_uart_rx_fifo(uchar which_chain);
uint clear_uart_send_fifo(uchar which_chain);
work * clone_queued_work_byid(cgpu_info * cgpu, uint32_t id);
work * clone_queued_work_bymidstate(cgpu_info * cgpu, char * midstate, size_t midstatelen, char * data, int offset, size_t datalen);
_Bool cnx_needed(pool * pool);
int compareSR(void * p1, void * p2);
void * completion_thread(void * arg);
void consume_option(int * argc, char * * argv, uint optnum);
device_drv * copy_drv(device_drv * drv);
void copy_time(timeval * dest, timeval * src);
work * copy_work_noffset(work * base_work, int noffset);
void copyadvanceafter(char ch, char * * param, char * * buf);
int cp_prio(void);
ushort crc16(uchar * buffer, int len);
uint16_t crc_itu_t(uint16_t crc, uint8_t * buffer, int len);
int create_bitmain_check_fan_pthread(void);
int create_bitmain_check_miner_status_pthread(bitmain_ZCASH_info * info);
int create_bitmain_get_hash_rate_pthread(void);
int create_bitmain_read_temp_pthread(void);
int create_bitmain_scan_freq_pthread(void);
int create_bitmain_turbo_mode_monitor_pthread(void);
pool * current_pool(void);
void debugstate(io_data * io_data, long c, char * param, _Bool isjson, char group);
void decay_time(double * f, double fadd, double fsecs, double interval);
int32_t decode_unicode_escape(char * str);
void default_save_file(char * filename);
_Bool detect_stratum(pool * pool, char * url);
void dev_error(cgpu_info * dev, dev_reason reason);
int dev_from_id(int thr_id);
void devdetails(io_data * io_data, long c, char * param, _Bool isjson, char group);
void devstatus(io_data * io_data, long c, char * param, _Bool isjson, char group);
void digestInit(blake2b_state * S, int n, int k);
int disable_PIC16F1704_dc_dc_new(void);
void disablepool(io_data * io_data, long c, char * param, _Bool isjson, char group);
void discard_stale(void);
int do_dump(json_t * json, size_t flags, int depth, json_dump_callback_t dump, void * data);
void dohotplug(io_data * io_data, long c, char * param, _Bool isjson, char group);
void doquit(io_data * io_data, long c, char * param, _Bool isjson, char group);
void dorestart(io_data * io_data, long c, char * param, _Bool isjson, char group);
void dosave(io_data * io_data, long c, char * param, _Bool isjson, char group);
void dozero(io_data * io_data, long c, char * param, _Bool isjson, char group);
int dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void * data);
int dump_string(char * str, json_dump_callback_t dump, void * data, size_t flags);
int dump_to_file(char * buffer, size_t size, void * data);
int dump_to_strbuffer(char * buffer, size_t size, void * data);
void dump_vol_table(void);
void dupalloc(cgpu_info * cgpu, int timelimit);
void dupcounters(cgpu_info * cgpu, uint64_t * checked, uint64_t * dups);
int enable_PIC16F1704_dc_dc_new(void);
char * enable_debug(_Bool * flag);
void enable_device(cgpu_info * cgpu);
void enable_pool(pool * pool);
void enable_read_temperature_from_asic(void);
void enable_read_temperature_from_asic_chain(uint which_chain);
void enable_sensor_extend_mode(void);
void enablepool(io_data * io_data, long c, char * param, _Bool isjson, char group);
uchar erase_PIC16F1704_app_flash_new(void);
int erase_PIC16F1704_flash_new(void);
void error_set(json_error_t * error, lex_t * lex, char * msg);
char * escape_string(char * str, _Bool isjson);
void every_asic_get_isl_voltage(int which_chain);
void every_asic_set_isl_voltage(int which_chain);
void every_chain_disable_PIC16F1704_dc_dc_new(void);
void every_chain_enable_PIC16F1704_dc_dc_new(void);
void every_chain_get_PIC16F1704_freq_new(void);
void every_chain_get_isl_voltage(void);
void every_chain_get_pic_version(void);
void every_chain_get_voltage_PIC16F1704_new(ushort voltage);
void every_chain_jump_from_loader_to_app_PIC16F1704_new(void);
int every_chain_read_pic_freq_data(uchar[9] * freq_table);
void every_chain_reset_PIC16F1704_pic_new(void);
void every_chain_save_freq_PIC16F1704_new(ushort freq);
void every_chain_set_isl_voltage(void);
void every_chain_set_voltage_PIC16F1704_new(ushort voltage);
int every_chain_write_freq_to_pic(uchar[9] * freq_table);
void expandArray(uchar * in, size_t in_len, uchar * out, size_t out_len, size_t bit_len, size_t byte_pad);
_Bool extract_sockaddr(char * url, char * * sockaddr_url, char * * sockaddr_port);
void extranonce_subscribe_stratum(pool * pool);
void failoveronly(io_data * io_data, long c, char * param, _Bool isjson, char group);
void fan_power_on(void);
void fill_device_drv(device_drv * drv);
work * find_queued_work_byid(cgpu_info * cgpu, uint32_t id);
work * find_queued_work_bymidstate(cgpu_info * cgpu, char * midstate, size_t midstatelen, char * data, int offset, size_t datalen);
char * first_lopt(uint * i, uint * len);
char * first_opt(uint * i, uint * len);
char * first_sopt(uint * i);
void flush_queue(cgpu_info * cgpu);
_Bool fulltest(uchar * hash, uchar * target);
void gen_stratum_work(pool * pool, work * work);
void generateHash(blake2b_state * S, uint32_t g, uint8_t * hash, size_t hashLen);
int get_PIC16F1704_freq_new(ushort * freq);
int get_PIC16F1704_software_version_new(uchar * version);
int get_PIC16F1704_voltage_new(uchar * voltage);
void * get_asic_response(void * arg);
void get_bitmain_statline_before(char * buf, size_t bufsiz, cgpu_info * bitmain_ZCASH);
void get_datestamp(char * f, size_t fsiz, timeval * tv);
cgpu_info * get_devices(int id);
int get_fan_speed(uchar * fan_id, uint * fan_speed);
void * get_hash_rate(void);
void get_intrange(char * arg, int * val1, int * val2);
char * get_proxy(char * url, pool * pool);
work * get_queue_work(thr_info * thr, cgpu_info * cgpu, int thr_id);
work * get_queued(cgpu_info * cgpu);
void get_reg_value(uint8_t regaddr);
void get_statline(char * buf, size_t bufsiz, cgpu_info * cgpu);
thr_info * get_thread(int thr_id);
work * get_work(thr_info * thr, int thr_id);
void hash_driver_work(thr_info * mythr);
work * hash_pop(_Bool blocking);
void hash_queued_work(thr_info * mythr);
void hash_sole_work(thr_info * mythr);
void hashmeter(int thr_id, uint64_t hashes_done);
void hashtable_clear(hashtable_t * hashtable);
void hashtable_close(hashtable_t * hashtable);
int hashtable_del(hashtable_t * hashtable, char * key);
void hashtable_do_clear(hashtable_t * hashtable);
pair_t * hashtable_find_pair(hashtable_t * hashtable, bucket_t * bucket, char * key, size_t hash);
void * hashtable_get(hashtable_t * hashtable, char * key);
int hashtable_init(hashtable_t * hashtable);
void * hashtable_iter(hashtable_t * hashtable);
void * hashtable_iter_at(hashtable_t * hashtable, char * key);
void * hashtable_iter_key(void * iter);
void * hashtable_iter_next(hashtable_t * hashtable, void * iter);
size_t hashtable_iter_serial(void * iter);
void hashtable_iter_set(void * iter, json_t * value);
void * hashtable_iter_value(void * iter);
int hashtable_set(hashtable_t * hashtable, char * key, size_t serial, json_t * value);
void head_join(io_data * io_data, char * cmdptr, _Bool isjson, _Bool * firstjoin);
int heart_beat_PIC16F1704_new(void);
_Bool hex2bin(uchar * p, char * hexstr, size_t len);
void * httpListenThread(void * param);
_Bool http_negotiate(pool * pool, int sockd, _Bool http0);
uchar i2c_read(uint config_data);
void i2c_write(uint config_data);
void inc_dev_status(int max_fan, int max_temp);
void inc_hw_errors(thr_info * thr);
void inc_hw_errors_with_diff(thr_info * thr, int diff);
void inc_work_stats(thr_info * thr, pool * pool, int diff1);
void init_asic_display_status(void);
void init_fpga(void);
void init_vol_table(ushort vol);
_Bool initiate_stratum(pool * pool);
_Bool io_add(io_data * io_data, char * buf);
int is_nonce_or_reg_value(uchar data);
_Bool isdupnonce(cgpu_info * cgpu, work * work, uint32_t nonce);
int itemstats(io_data * io_data, int i, char * id, cgminer_stats * stats, cgminer_pool_stats * pool_stats, api_data * extra, cgpu_info * cgpu, _Bool isjson);
json_t * json_array(void);
int json_array_append_new(json_t * json, json_t * value);
int json_array_clear(json_t * json);
int json_array_extend(json_t * json, json_t * other_json);
json_t * json_array_get(json_t * json, size_t index);
json_t * * json_array_grow(json_array_t * array, size_t amount, int copy);
int json_array_insert_new(json_t * json, size_t index, json_t * value);
int json_array_remove(json_t * json, size_t index);
int json_array_set_new(json_t * json, size_t index, json_t * value);
size_t json_array_size(json_t * json);
char * json_array_string(json_t * val, uint entry);
json_t * json_copy(json_t * json);
json_t * json_deep_copy(json_t * json);
void json_delete(json_t * json);
int json_dump_callback(json_t * json, json_dump_callback_t callback, void * data, size_t flags);
int json_dump_file(json_t * json, char * path, size_t flags);
int json_dumpf(json_t * json, FILE * output, size_t flags);
char * json_dumps(json_t * json, size_t flags);
int json_equal(json_t * json1, json_t * json2);
char * json_escape(char * str);
json_t * json_false(void);
json_t * json_integer(json_int_t value);
json_t * json_integer_copy(json_t * integer);
int json_integer_set(json_t * json, json_int_t value);
json_int_t json_integer_value(json_t * json);
json_t * json_load_callback(json_load_callback_t callback, void * arg, size_t flags, json_error_t * error);
json_t * json_load_file(char * path, size_t flags, json_error_t * error);
json_t * json_loadb(char * buffer, size_t buflen, size_t flags, json_error_t * error);
json_t * json_loadf(FILE * input, size_t flags, json_error_t * error);
json_t * json_loads(char * string, size_t flags, json_error_t * error);
json_t * json_null(void);
double json_number_value(json_t * json);
json_t * json_object(void);
int json_object_clear(json_t * json);
int json_object_del(json_t * json, char * key);
json_t * json_object_get(json_t * json, char * key);
void * json_object_iter(json_t * json);
void * json_object_iter_at(json_t * json, char * key);
char * json_object_iter_key(void * iter);
void * json_object_iter_next(json_t * json, void * iter);
int json_object_iter_set_new(json_t * json, void * iter, json_t * value);
json_t * json_object_iter_value(void * iter);
void * json_object_key_to_iter(char * key);
int json_object_set_new(json_t * json, char * key, json_t * value);
int json_object_set_new_nocheck(json_t * json, char * key, json_t * value);
size_t json_object_size(json_t * json);
int json_object_update(json_t * object, json_t * other);
int json_object_update_existing(json_t * object, json_t * other);
int json_object_update_missing(json_t * object, json_t * other);
json_t * json_real(double value);
int json_real_set(json_t * json, double value);
double json_real_value(json_t * json);
void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
json_t * json_string(char * value);
json_t * json_string_nocheck(char * value);
int json_string_set(json_t * json, char * value);
int json_string_set_nocheck(json_t * json, char * value);
char * json_string_value(json_t * json);
json_t * json_true(void);
int jsonp_dtostr(char * buffer, size_t size, double value);
void jsonp_error_init(json_error_t * error, char * source);
void jsonp_error_set(json_error_t * error, int line, int column, size_t position, char * msg);
void jsonp_error_set_source(json_error_t * error, char * source);
void jsonp_error_vset(json_error_t * error, int line, int column, size_t position, char * msg, va_list ap);
void jsonp_free(void * ptr);
void * jsonp_malloc(size_t size);
char * jsonp_strdup(char * str);
int jsonp_strtod(strbuffer_t * strbuffer, double * out);
int jump_from_loader_to_app_PIC16F1704_new(void);
void k_alloc_items(K_LIST * list, char * file, char * func, int line);
K_LIST * k_new_store(K_LIST * list);
void kill_mining(void);
void kill_work(void);
void * killall_thread(void * arg);
void lcddisplay(io_data * io_data, long c, char * param, _Bool isjson, char group);
void lex_close(lex_t * lex);
int lex_get_save(lex_t * lex, json_error_t * error);
int lex_scan(lex_t * lex, json_error_t * error);
void lex_unget_unsave(lex_t * lex, int c);
char * load_config(char * arg, void * unused);
void lockstats(io_data * io_data, long c, char * param, _Bool isjson, char group);
int main(int argc, char * * argv);
work * make_clone(work * work);
work * make_work(void);
void mcast(void);
void mcast_init(void);
void * mcast_thread(void * userdata);
void message(io_data * io_data, int messageid, int paramid, char * param2, _Bool isjson);
void minecoin(io_data * io_data, long c, char * param, _Bool isjson, char group);
void * miner_thread(void * userdata);
void minerconfig(io_data * io_data, long c, char * param, _Bool isjson, char group);
void minerestats(io_data * io_data, long c, char * param, _Bool isjson, char group);
void minerstats(io_data * io_data, long c, char * param, _Bool isjson, char group);
int ms_tdiff(timeval * end, timeval * start);
void ms_to_timespec(timespec * spec, int64_t ms);
void ms_to_timeval(timeval * val, int64_t ms);
void mt_disable(thr_info * mythr, int thr_id, device_drv * drv);
void my_log_curses(int prio, char * datetime, char * str, _Bool force);
_Bool new_nonce(thr_info * thr, uint32_t nonce);
char * next_lopt(char * p, uint * i, uint * len);
char * next_name(char * names, uint * len);
char * next_opt(char * p, uint * i, uint * len);
char * next_sopt(char * p, uint * i);
int no_yield(void);
int nonce_handle(nonce_rb_format[1] * g_nonce, uint8_t[1][16][91] * g_nonce_list, uint8_t * str, int len, uint32_t chainid);
uint64_t noop_can_limit_work(thr_info * thr);
void noop_detect(_Bool hotplug);
api_data * noop_get_api_stats(cgpu_info * cgpu);
_Bool noop_get_stats(cgpu_info * cgpu);
_Bool noop_prepare_work(thr_info * thr, work * work);
void noop_reinit_device(cgpu_info * cgpu);
void notify(io_data * io_data, long c, char * param, _Bool isjson, char group);
void notifystatus(io_data * io_data, int device, cgpu_info * cgpu, _Bool isjson, char group);
void null_device_drv(device_drv * drv);
int object_key_compare_keys(void * key1, void * key2);
int object_key_compare_serials(void * key1, void * key2);
void opt_free_table(void);
char * opt_inc_intval(int * i);
char * opt_invalid_argument(char * arg);
void opt_log_stderr(char * fmt);
void opt_log_stderr_exit(char * fmt);
_Bool opt_parse(int * argc, char * * argv, _func_void_char_ptr_varargs * errlog);
void opt_register_table(opt_table * entry, char * desc);
char * opt_set_bool(_Bool * b);
char * opt_set_bool_arg(char * arg, _Bool * b);
char * opt_set_charp(char * arg, char * * p);
char * opt_set_floatval(char * arg, float * f);
char * opt_set_intval(char * arg, int * i);
char * opt_set_invbool(_Bool * b);
char * opt_set_invbool_arg(char * arg, _Bool * b);
char * opt_set_longval(char * arg, long * l);
char * opt_set_uintval(char * arg, uint * ui);
char * opt_set_ulongval(char * arg, ulong * ul);
void opt_show_bool(char * buf, _Bool * b);
void opt_show_charp(char * buf, char * * p);
void opt_show_floatval(char * buf, float * f);
void opt_show_intval(char * buf, int * i);
void opt_show_invbool(char * buf, _Bool * b);
void opt_show_longval(char * buf, long * l);
void opt_show_uintval(char * buf, uint * ui);
void opt_show_ulongval(char * buf, ulong * ul);
char * opt_usage(char * argv0, char * extra);
char * opt_usage_and_exit(char * extra);
char * opt_version_and_exit(char * version);
char * opt_verusage_and_exit(char * extra);
char * parse_config(json_t * config, _Bool fileconf);
_Bool parse_extranonce_equihash(pool * pool, json_t * val, int type);
json_t * parse_json(lex_t * lex, size_t flags, json_error_t * error);
_Bool parse_method(pool * pool, char * s);
int parse_one(int * argc, char * * argv, uint * offset, _func_void_char_ptr_varargs * errlog);
json_t * parse_value(lex_t * lex, size_t flags, json_error_t * error);
void pgacount(io_data * io_data, long c, char * param, _Bool isjson, char group);
void * pic_heart_beat_func_new(void * arg);
void pic_test_new(void);
void pm_handle(uint8_t * str, int len, uint8_t chainid);
_Bool pool_active(pool * pool, _Bool pinging);
void pool_died(pool * pool);
void pool_failed(pool * pool);
void pool_resus(pool * pool);
_Bool pool_tclear(pool * pool, _Bool * var);
_Bool pool_tset(pool * pool, _Bool * var);
_Bool pooldetails(char * param, char * * url, char * * user, char * * pass);
void poolpriority(io_data * io_data, long c, char * param, _Bool isjson, char group);
void poolquota(io_data * io_data, long c, char * param, _Bool isjson, char group);
void poolstatus(io_data * io_data, long c, char * param, _Bool isjson, char group);
void print_bin(uint8_t * cmd, size_t len);
api_data * print_data(io_data * io_data, api_data * root, _Bool isjson, _Bool precom);
void print_summary(void);
pool * priority_pool(int choice);
void privileged(io_data * io_data, long c, char * param, _Bool isjson, char group);
char * proxytype(proxytypes_t proxytype);
void * quit_thread(void * userdata);
int read_PIC16F1704_flash_data_new(uchar * buf);
int read_PIC16F1704_flash_pointer_new(uchar * flash_addr_h, uchar * flash_addr_l);
uint read_axi_fpga(uint address);
int read_data_from_PIC16F1704_flash(uchar * buf, uchar offset, uchar read_len);
int read_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t * value, int len);
int read_hash_id_PIC16F1704_new(uchar * buf);
void read_i2c_reg(uchar which_chain, uchar which_sensor, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr);
uchar read_pic(void);
void * read_temp_func(void);
int read_temperature_offset_PIC16F1704_new(uchar * buf);
uchar read_temperature_through_fpga_iic_register(uchar which_chain);
uint read_uart_data_in_fpga(uchar which_uart, uchar * buf, uint length);
void * realloc_strcat(char * ptr, char * s);
void rebuild_hash(work * work);
void recheck_asic_num(bitmain_ZCASH_info * info, uint8_t chain);
char * recv_line(pool * pool);
void reg_handle(uint8_t * str, int len, uint32_t chainid);
void regen_hash(work * work);
void reinit_device(cgpu_info * cgpu);
void remove_pool(pool * pool);
void removepool(io_data * io_data, long c, char * param, _Bool isjson, char group);
int reset_PIC16F1704_pic_new(void);
void reset_all_hash_board_low(void);
void reset_chain(bitmain_ZCASH_info * info, uint8_t chain);
_Bool restart_stratum(pool * pool);
void * restart_thread(void * arg);
void restart_threads(void);
int restart_wait(thr_info * thr, uint mstime);
void rev(uchar * s, size_t l);
void roll_work(work * work);
int save_freq_PIC16F1704_new(ushort freq);
void * scan_freq_handle(void);
void scan_freq_init_freq(void);
int scan_freq_save_freq(void);
_Bool scanhash_scrypt(thr_info * thr, uchar * pmidstate, uchar * pdata, uchar * phash1, uchar * phash, uchar * ptarget, uint32_t max_nonce, uint32_t * last_nonce, uint32_t n);
void scrypt_1024_1_1_256_sp(uint32_t * input, char * scratchpad, uint32_t * ostate);
void scrypt_regenhash(work * work);
int scrypt_test(uchar * pdata, uchar * ptarget, uint32_t nonce);
pool * select_balanced(pool * cp);
void select_core_to_check_temperature(uint32_t analog_mux_reg_value);
void select_core_to_check_temperature_chain(uint which_chain, uint32_t analog_mux_reg_value);
int send_data_to_PIC16F1704_new(uchar * buf);
int send_heart_beat_to_every_chain(void);
void send_result(io_data * io_data, long c, _Bool isjson, io_data * io_data_1);
int ser_number(uchar * s, int32_t val);
uchar * ser_string(char * s, int * slen);
int set_PIC16F1704_flash_pointer_new(uchar flash_addr_h, uchar flash_addr_l);
int set_PIC16F1704_voltage_new(uchar voltage);
void set_PWM(uchar pwm_percent);
void set_PWM_according_to_temperature(void);
void set_address(int which_chain, uchar chip_addr);
void set_analog_mux_control(uint32_t value);
void set_analog_mux_control_chain(uchar which_chain, uint32_t value);
char * set_balance(pool_strategy * strategy);
void set_baud(uint bt8d);
void set_baud_chain(uchar which_chain, uint bt8d);
void set_core_timeout(uint32_t timeout);
void set_core_timeout_chain(uchar which_chain, uint timeout);
char * set_default_config(char * arg);
char * set_float_100_to_250(char * arg, float * i);
char * set_float_125_to_500(char * arg, float * i);
void set_fpga_baud(uchar asic_baud);
void set_freq_asic(uchar which_chain, uchar which_asic, uint frequency);
void set_frequency(uint frequency);
void set_frequency_chain(uchar which_chain, uint frequency);
char * set_int_0_to_10(char * arg, int * i);
char * set_int_0_to_100(char * arg, int * i);
char * set_int_0_to_200(char * arg, int * i);
char * set_int_0_to_255(char * arg, int * i);
char * set_int_0_to_4(char * arg, int * i);
char * set_int_0_to_9999(char * arg, int * i);
char * set_int_1_to_10(char * arg, int * i);
char * set_int_1_to_65535(char * arg, int * i);
char * set_int_22_to_55(char * arg, int * i);
char * set_int_32_to_63(char * arg, int * i);
char * set_int_42_to_65(char * arg, int * i);
char * set_int_range(char * arg, int * i, int min, int max);
void set_io_drive_strength(void);
void set_io_drive_strength_chain(uchar which_chain);
void set_led(_Bool stop);
char * set_loadbalance(pool_strategy * strategy);
char * set_logfile_openflag(char * arg);
char * set_logfile_path(char * arg);
char * set_logwork_asicnum(char * arg);
char * set_logwork_path(char * arg);
void set_lowprio(void);
void set_miner_name(char * name);
void set_nonce_shift(int shift);
void set_nonce_shift_chain(uchar which_chain, int shift);
char * set_null(char * arg);
char * set_pass(char * arg);
char * set_quota(char * arg);
char * set_rotate(char * arg, char * i);
char * set_rr(pool_strategy * strategy);
char * set_sched_start(char * arg);
char * set_sched_stop(char * arg);
char * set_sharelog(char * arg);
void set_target(uchar * dest_target, double diff);
char * set_temp_cutoff(char * arg);
void set_temperature_offset_value_chain_sensor(uchar which_chain, uchar which_sensor);
void set_ticket_mask(uint ticket_mask);
void set_ticket_mask_chain(uchar which_chain, uint32_t ticket_mask);
void set_txn_data(int txn_shalow, int txn_zero);
void set_txn_data_chain(uchar which_chain, int txn_shalow, int txn_zero);
char * set_url(char * arg);
char * set_user(char * arg);
char * set_userpass(char * arg);
char * set_version_path(char * arg);
void set_work_ntime(work * work, int ntime);
void setconfig(io_data * io_data, long c, char * param, _Bool isjson, char group);
void setup_url(pool * pool, char * arg);
void sha2(uchar * input, int ilen, uchar * output);
void sha256(uchar * message, uint len, uchar * digest);
void sha256_final(sha256_ctx * ctx, uchar * digest);
void sha256_init(sha256_ctx * ctx);
void sha256_transf(sha256_ctx * ctx, uchar * message, uint block_nb);
void sha256_update(sha256_ctx * ctx, uchar * message, uint len);
void sha2_finish(sha2_context * ctx, uchar * output);
void sha2_process(sha2_context * ctx, uchar * data);
void sha2_starts(sha2_context * ctx);
void sha2_update(sha2_context * ctx, uchar * input, int ilen);
uint64_t share_diff(work * work);
uint64_t share_ndiff(work * work);
int share_work_tdiff(cgpu_info * cgpu);
void sharelog(char * disposition, work * work);
_Bool should_run(void);
void sighandler(int sig);
_Bool sock_full(pool * pool);
_Bool socket_full(pool * pool, int wait);
_Bool socks4_negotiate(pool * pool, int sockd, _Bool socks4a);
void software_set_address(void);
void software_set_address_chain(uint which_chain);
int sortValidator(void * data, uchar * soln);
void sort_pair(uint32_t * a, uint32_t len);
_Bool stale_work(work * work, _Bool share);
void start_http_thread(void);
void * statusServiceThread(void * param);
void * str_text(char * ptr);
void stratum_resumed(pool * pool);
void * stratum_rthread(void * userdata);
_Bool stratum_send(pool * pool, char * s, ssize_t len);
void * stratum_sthread(void * userdata);
int strbuffer_append(strbuffer_t * strbuff, char * string);
int strbuffer_append_byte(strbuffer_t * strbuff, char byte);
int strbuffer_append_bytes(strbuffer_t * strbuff, char * data, size_t size);
void strbuffer_clear(strbuffer_t * strbuff);
void strbuffer_close(strbuffer_t * strbuff);
int strbuffer_init(strbuffer_t * strbuff);
char strbuffer_pop(strbuffer_t * strbuff);
char * strbuffer_steal_value(strbuffer_t * strbuff);
char * strbuffer_value(strbuffer_t * strbuff);
int stream_get(stream_t * stream, json_error_t * error);
void stream_unget(stream_t * stream, int c);
int string_get(void * data);
_Bool submit_noffset_nonce(thr_info * thr, work * work_in, uint32_t nonce, int noffset);
_Bool submit_nonce(thr_info * thr, work * work, uint32_t nonce);
_Bool submit_nonce_1(thr_info * thr, work * work, uint32_t nonce, int * nofull);
void submit_nonce_2(work * work);
_Bool submit_nonce_direct(thr_info * thr, work * work, uint32_t nonce);
_Bool submit_tested_work(thr_info * thr, work * work);
void submit_work_async(work * work);
void * submit_work_thread(void * userdata);
_Bool subscribe_extranonce(pool * pool);
void subtime(timeval * a, timeval * b);
void suffix_string(uint64_t val, char * buf, size_t bufsiz, int sigdigits);
void suffix_string_ZCASH(uint64_t val, char * buf, size_t bufsiz, int sigdigits, _Bool display);
void summary(io_data * io_data, long c, char * param, _Bool isjson, char group);
void suspend_stratum(pool * pool);
void switch_pools(pool * selected);
void switchpool(io_data * io_data, long c, char * param, _Bool isjson, char group);
void tail_join(io_data * io_data, _Bool isjson);
work * take_queued_work_bymidstate(cgpu_info * cgpu, char * midstate, size_t midstatelen, char * data, int offset, size_t datalen);
_Bool target_match(uchar * result_value, uchar * target);
int target_zero_cal(uint8_t * target);
double tdiff(timeval * end, timeval * start);
_Bool test_nonce(work * work, uint32_t nonce);
_Bool test_nonce_diff(work * work, uint32_t nonce, double diff);
void * test_pool_thread(void * arg);
_Bool test_work_current(work * work);
void thr_info_cancel(thr_info * thr);
int thr_info_create(thr_info * thr, pthread_attr_t * attr, _func_void_ptr_void_ptr * start, void * arg);
void thr_info_join(thr_info * thr);
void thread_reportin(thr_info * thr);
void thread_reportout(thr_info * thr);
void tidyup(void * arg);
_Bool time_less(timeval * a, timeval * b);
_Bool time_more(timeval * a, timeval * b);
void timeraddspec(timespec * a, timespec * b);
void timespec_to_val(timeval * val, timespec * spec);
void timeval_to_spec(timespec * spec, timeval * val);
speed_t tiospeed_t(int baud);
int total_work_inc(void);
void tq_free(thread_q * tq);
void tq_freeze(thread_q * tq);
void tq_freezethaw(thread_q * tq, _Bool frozen);
thread_q * tq_new(void);
void * tq_pop(thread_q * tq, timespec * abstime);
_Bool tq_push(thread_q * tq, void * data);
void tq_thaw(thread_q * tq);
double tsince_restart(void);
double tsince_update(void);
void tty_init(bitmain_ZCASH_info * info);
void tty_init_chain(uint8_t which_chain, bitmain_ZCASH_info * info);
void * turbo_mode_monitor(void);
uint uart_receive(uchar which_uart, uchar * buf, uint buf_length);
uint uart_send(uchar which_uart, uchar * buf, uint length);
void update_asic_vol(int which_chain, int which_asic, int vol);
void update_asics_vol(int vol);
void update_asics_voltage(int vol);
void update_work_stats(thr_info * thr, work * work);
double us_tdiff(timeval * end, timeval * start);
void us_to_timespec(timespec * spec, int64_t us);
void us_to_timeval(timeval * val, int64_t us);
void usbstats(io_data * io_data, long c, char * param, _Bool isjson, char group);
int utf8_check_first(char byte);
int utf8_check_full(char * buffer, int size, int32_t * codepoint);
int utf8_check_string(char * string, int length);
int utf8_encode(int32_t codepoint, char * buffer, int * size);
char * utf8_iterate(char * buffer, int32_t * codepoint);
void wake_gws(void);
void * watchdog_thread(void * userdata);
void * watchpool_thread(void * userdata);
void work_completed(cgpu_info * cgpu, work * work);
void write_axi_fpga(uint address, uint data);
void write_config(FILE * fcfg);
int write_data_into_PIC16F1704_flash_new(void);
int write_data_to_PIC16F1704_flash(uchar * buf, uint offset, int buf_len);
int write_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t * data, int len);
int write_hash_ID_PIC16F1704_new(uchar * buf);
void write_i2c_reg(uchar which_chain, uchar which_sensor, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, uint8_t i2c_reg_data);
void write_pic(uchar data);
int write_temperature_offset_PIC16F1704_new(uchar * buf);
void xxtea_decode(uint32_t * v, int n, uint32_t * key);
void xxtea_encode(uint32_t * v, int n, uint32_t * key);
void zero_bestshare(void);
void zero_stats(void);

#endif // CGMINER_F7CF46A74876C43B_DEBUG_TYPES_H
