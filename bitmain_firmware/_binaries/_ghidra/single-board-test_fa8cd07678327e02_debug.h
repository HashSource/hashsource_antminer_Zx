// Data types exported from: single-board-test_fa8cd07678327e02_debug
// Generated by Ghidra

#ifndef SINGLE_BOARD_TEST_FA8CD07678327E02_DEBUG_TYPES_H
#define SINGLE_BOARD_TEST_FA8CD07678327E02_DEBUG_TYPES_H

#include <stdint.h>
#include <stdbool.h>

/* ==================== Enumerations ==================== */

typedef enum {
    DT_NULL = 0,
    DT_NEEDED = 1,
    DT_PLTRELSZ = 2,
    DT_PLTGOT = 3,
    DT_HASH = 4,
    DT_STRTAB = 5,
    DT_SYMTAB = 6,
    DT_RELA = 7,
    DT_RELASZ = 8,
    DT_RELAENT = 9,
    DT_STRSZ = 10,
    DT_SYMENT = 11,
    DT_INIT = 12,
    DT_FINI = 13,
    DT_SONAME = 14,
    DT_RPATH = 15,
    DT_SYMBOLIC = 16,
    DT_REL = 17,
    DT_RELSZ = 18,
    DT_RELENT = 19,
    DT_PLTREL = 20,
    DT_DEBUG = 21,
    DT_TEXTREL = 22,
    DT_JMPREL = 23,
    DT_BIND_NOW = 24,
    DT_INIT_ARRAY = 25,
    DT_FINI_ARRAY = 26,
    DT_INIT_ARRAYSZ = 27,
    DT_FINI_ARRAYSZ = 28,
    DT_RUNPATH = 29,
    DT_FLAGS = 30,
    DT_PREINIT_ARRAY = 32,
    DT_PREINIT_ARRAYSZ = 33,
    DT_RELRSZ = 35,
    DT_RELR = 36,
    DT_RELRENT = 37,
    DT_ANDROID_REL = 1610612751,
    DT_ANDROID_RELSZ = 1610612752,
    DT_ANDROID_RELA = 1610612753,
    DT_ANDROID_RELASZ = 1610612754,
    DT_ANDROID_RELR = 1879040000,
    DT_ANDROID_RELRSZ = 1879040001,
    DT_ANDROID_RELRENT = 1879040003,
    DT_GNU_PRELINKED = 1879047669,
    DT_GNU_CONFLICTSZ = 1879047670,
    DT_GNU_LIBLISTSZ = 1879047671,
    DT_CHECKSUM = 1879047672,
    DT_PLTPADSZ = 1879047673,
    DT_MOVEENT = 1879047674,
    DT_MOVESZ = 1879047675,
    DT_FEATURE_1 = 1879047676,
    DT_POSFLAG_1 = 1879047677,
    DT_SYMINSZ = 1879047678,
    DT_SYMINENT = 1879047679,
    DT_GNU_XHASH = 1879047924,
    DT_GNU_HASH = 1879047925,
    DT_TLSDESC_PLT = 1879047926,
    DT_TLSDESC_GOT = 1879047927,
    DT_GNU_CONFLICT = 1879047928,
    DT_GNU_LIBLIST = 1879047929,
    DT_CONFIG = 1879047930,
    DT_DEPAUDIT = 1879047931,
    DT_AUDIT = 1879047932,
    DT_PLTPAD = 1879047933,
    DT_MOVETAB = 1879047934,
    DT_SYMINFO = 1879047935,
    DT_VERSYM = 1879048176,
    DT_RELACOUNT = 1879048185,
    DT_RELCOUNT = 1879048186,
    DT_FLAGS_1 = 1879048187,
    DT_VERDEF = 1879048188,
    DT_VERDEFNUM = 1879048189,
    DT_VERNEED = 1879048190,
    DT_VERNEEDNUM = 1879048191,
    DT_AUXILIARY = 2147483645,
    DT_FILTER = 2147483647,
} Elf32_DynTag_ARM;

typedef enum {
    PT_NULL = 0,
    PT_LOAD = 1,
    PT_DYNAMIC = 2,
    PT_INTERP = 3,
    PT_NOTE = 4,
    PT_SHLIB = 5,
    PT_PHDR = 6,
    PT_TLS = 7,
    PT_GNU_EH_FRAME = 1685382480,
    PT_GNU_STACK = 1685382481,
    PT_GNU_RELRO = 1685382482,
    PT_ARM_EXIDX = 1879048192,
} Elf_ProgramHeaderType_ARM;

typedef enum {
    SHT_NULL = 0,
    SHT_PROGBITS = 1,
    SHT_SYMTAB = 2,
    SHT_STRTAB = 3,
    SHT_RELA = 4,
    SHT_HASH = 5,
    SHT_DYNAMIC = 6,
    SHT_NOTE = 7,
    SHT_NOBITS = 8,
    SHT_REL = 9,
    SHT_SHLIB = 10,
    SHT_DYNSYM = 11,
    SHT_INIT_ARRAY = 14,
    SHT_FINI_ARRAY = 15,
    SHT_PREINIT_ARRAY = 16,
    SHT_GROUP = 17,
    SHT_SYMTAB_SHNDX = 18,
    SHT_ANDROID_REL = 1610612737,
    SHT_ANDROID_RELA = 1610612738,
    SHT_GNU_ATTRIBUTES = 1879048181,
    SHT_GNU_HASH = 1879048182,
    SHT_GNU_LIBLIST = 1879048183,
    SHT_CHECKSUM = 1879048184,
    SHT_SUNW_move = 1879048186,
    SHT_SUNW_COMDAT = 1879048187,
    SHT_SUNW_syminfo = 1879048188,
    SHT_GNU_verdef = 1879048189,
    SHT_GNU_verneed = 1879048190,
    SHT_GNU_versym = 1879048191,
    SHT_ARM_EXIDX = 1879048193,
    SHT_ARM_PREEMPTMAP = 1879048194,
    SHT_ARM_ATTRIBUTES = 1879048195,
    SHT_ARM_DEBUGOVERLAY = 1879048196,
    SHT_ARM_OVERLAYSECTION = 1879048197,
} Elf_SectionHeaderType_ARM;

typedef enum {
    PCBA_IDLE = 0,
    PCBA_HIGH_TEMP_ALARM = 1,
} HARDWARE_EXCEPTION_E;

typedef enum {
    IOCTL_GET_REG = 0,
    IOCTL_SET_REG = 1,
    IOCTL_SEND_WORK = 2,
    IOCTL_SET_ADDRESS = 3,
    IOCTL_CHAIN_INACTIVE = 4,
} IOCTL_TYPE;

typedef enum {
    LOG_ERR = 0,
    LOG_WARNING = 1,
    LOG_NOTICE = 2,
    LOG_INFO = 3,
    LOG_DEBUG = 4,
    LOG_MAX_LEVEL = 5,
} anon_enum_32;

typedef enum {
    BLAKE2B_PERSONALBYTES = 16,
    BLAKE2B_SALTBYTES = 16,
    BLAKE2B_KEYBYTES = 64,
    BLAKE2B_OUTBYTES = 64,
    BLAKE2B_BLOCKBYTES = 128,
} blake2b_constant;

typedef enum {
    BLAKE2S_PERSONALBYTES = 8,
    BLAKE2S_SALTBYTES = 8,
    BLAKE2S_KEYBYTES = 32,
    BLAKE2S_OUTBYTES = 32,
    BLAKE2S_BLOCKBYTES = 64,
} blake2s_constant;

typedef enum {
    REG_CHIP_ADDRESS = 0,
    REG_HASH_RATE = 8,
    REG_PLL_PARAMETER = 12,
    REG_BLAKE_CTRL = 16,
    REG_TICKET_MASK = 20,
    REG_MISC_CONTROL = 28,
    REG_GENERAL_I2C_COMMAND = 32,
    REG_NONCE_TX_OK = 36,
    REG_CORE_TIMEOUT = 40,
    REG_IO_DRIVE_STRENGTH = 48,
    REG_CHIP_STATUS = 52,
    REG_TIME_OUT = 56,
    REG_PMONITOR_CTRL = 60,
    REG_ANALOG_MUX_CONTROL = 64,
    REG_CORE_RESET = 68,
    REG_BIST_STATUS = 72,
    REG_NONCE_SEL = 80,
    REG_START_NONCE_OFFSET = 84,
    REG_TXN_DATA = 88,
    REG_PT_CTRL = 92,
    REG_PT_RESULT = 96,
    REG_RAM_PARA0 = 100,
    REG_RAM_PARA1 = 104,
    REG_CLK_DIV_CNT0 = 108,
    REG_CLK_DIV_CNT1 = 112,
} bm174x_reg_address;

typedef enum {
    CMD_SINGLE_CHIP = 0,
    CMD_ALL_CHIP = 1,
} input_cmd_allchip_type_e;

typedef enum {
    INPUT_CMD_LEN_5 = 5,
    INPUT_CMD_LEN_9 = 9,
} input_cmd_length_type_e;

typedef enum {
    CMD_SET_ADDRESS = 0,
    CMD_SET_CONFIG = 1,
    CMD_GET_STATUS = 2,
    CMD_CHAIN_INACTIVE = 3,
} input_cmd_type_e;

typedef enum {
    WORK_INPUT = 1,
    COMMAND_INPUT = 2,
    BIST_INPUT = 3,
} input_data_type_e;

typedef enum {
    RET_SUCCESS = 0,
    RET_FAIL = 1,
} return_type_e;

typedef enum {
    BLOCK_TYPE = 0,
    POLL_TYPE = 1,
} ringbuffer_type;

typedef enum {
    RT_RINGBUFFER_EMPTY = 0,
    RT_RINGBUFFER_FULL = 1,
    RT_RINGBUFFER_HALFFULL = 2,
} rt_ringbuffer_state;

/* ==================== Forward Declarations ==================== */

typedef struct CSha256 CSha256;
typedef struct Elf32_Dyn_ARM Elf32_Dyn_ARM;
typedef struct Elf32_Ehdr Elf32_Ehdr;
typedef struct Elf32_Phdr Elf32_Phdr;
typedef struct Elf32_Rel Elf32_Rel;
typedef struct Elf32_Shdr Elf32_Shdr;
typedef struct Elf32_Sym Elf32_Sym;
typedef struct GnuBuildId GnuBuildId;
typedef struct NoteAbiTag NoteAbiTag;
typedef struct _IO_FILE _IO_FILE;
typedef struct _IO_FILE _IO_FILE;
typedef struct _IO_marker _IO_marker;
typedef struct _IO_marker _IO_marker;
typedef struct __blake2b_param __blake2b_param;
typedef struct __blake2b_state __blake2b_state;
typedef struct __pthread_internal_slist __pthread_internal_slist;
typedef struct __pthread_internal_slist __pthread_internal_slist;
typedef struct __pthread_mutex_s __pthread_mutex_s;
typedef struct __pthread_mutex_s __pthread_mutex_s;
typedef struct _struct_16 _struct_16;
typedef struct anon_struct_48_8_df74bd48_for___data anon_struct_48_8_df74bd48_for___data;
typedef struct app_config_t app_config_t;
typedef struct asic_data_info_t asic_data_info_t;
typedef struct base_type_t base_type_t;
typedef struct baud_BT8D_value baud_BT8D_value;
typedef struct bm174x_analog_mux_control bm174x_analog_mux_control;
typedef struct bm174x_bist_status bm174x_bist_status;
typedef struct bm174x_blake_ctrl bm174x_blake_ctrl;
typedef struct bm174x_chip_addr bm174x_chip_addr;
typedef struct bm174x_chip_status bm174x_chip_status;
typedef struct bm174x_clk_div_cnt0 bm174x_clk_div_cnt0;
typedef struct bm174x_clk_div_cnt1 bm174x_clk_div_cnt1;
typedef struct bm174x_core_timeout bm174x_core_timeout;
typedef struct bm174x_general_i2c_command bm174x_general_i2c_command;
typedef struct bm174x_hash_rate bm174x_hash_rate;
typedef struct bm174x_io_drive_strength bm174x_io_drive_strength;
typedef struct bm174x_misc_control bm174x_misc_control;
typedef struct bm174x_nonce_shift bm174x_nonce_shift;
typedef struct bm174x_nonce_tx_ok bm174x_nonce_tx_ok;
typedef struct bm174x_pll_parameter bm174x_pll_parameter;
typedef struct bm174x_pmonitor_ctrl bm174x_pmonitor_ctrl;
typedef struct bm174x_pt_ctrl bm174x_pt_ctrl;
typedef struct bm174x_pt_result bm174x_pt_result;
typedef struct bm174x_ram_para0 bm174x_ram_para0;
typedef struct bm174x_ram_para1 bm174x_ram_para1;
typedef struct bm174x_reg_value_t bm174x_reg_value_t;
typedef struct bm174x_start_nonce_offset bm174x_start_nonce_offset;
typedef struct bm174x_ticket_mask bm174x_ticket_mask;
typedef struct bm174x_time_out bm174x_time_out;
typedef struct bm174x_txn_data bm174x_txn_data;
typedef struct cgpu_info cgpu_info;
typedef struct chain_inactive_cmd_t chain_inactive_cmd_t;
typedef struct chain_info chain_info;
typedef struct chain_status_t chain_status_t;
typedef struct evp_pkey_ctx_st evp_pkey_ctx_st;
typedef struct freq_pll_str freq_pll_str;
typedef struct get_status_cmd_t get_status_cmd_t;
typedef struct nonce_buf nonce_buf;
typedef struct nonce_rb_format nonce_rb_format;
typedef struct nonce_verify_info_t nonce_verify_info_t;
typedef struct patten_info patten_info;
typedef struct pattern_test_respond pattern_test_respond;
typedef struct pmonitor_respond pmonitor_respond;
typedef struct reg_list_item_t reg_list_item_t;
typedef struct reg_list_t reg_list_t;
typedef struct reg_respond reg_respond;
typedef struct rt_ringbuffer rt_ringbuffer;
typedef struct runtime_base_t runtime_base_t;
typedef struct set_address_cmd_t set_address_cmd_t;
typedef struct set_config_cmd_t set_config_cmd_t;
typedef struct sha256_ctx sha256_ctx;
typedef struct sha2_context sha2_context;
typedef struct timeval timeval;
typedef struct timeval timeval;
typedef struct timezone timezone;
typedef struct timezone timezone;
typedef struct tm tm;
typedef struct tm tm;
typedef struct validData validData;
typedef struct work_input work_input;
typedef struct work_list_info_t work_list_info_t;
typedef struct work_list_t work_list_t;
typedef struct zcash_work_info zcash_work_info;

/* ==================== Structures ==================== */

struct CSha256 {
    uint32_t state[8];  // offset: 0x0
    uint64_t count;  // offset: 0x20
    uint8_t buffer[64];  // offset: 0x28
}; // size: 0x68

struct Elf32_Dyn_ARM {
    Elf32_DynTag_ARM d_tag;  // offset: 0x0
    dword d_val;  // offset: 0x4
}; // size: 0x8

struct Elf32_Ehdr {
    byte e_ident_magic_num;  // offset: 0x0
    string e_ident_magic_str;  // offset: 0x1
    byte e_ident_class;  // offset: 0x4
    byte e_ident_data;  // offset: 0x5
    byte e_ident_version;  // offset: 0x6
    byte e_ident_osabi;  // offset: 0x7
    byte e_ident_abiversion;  // offset: 0x8
    byte e_ident_pad[7];  // offset: 0x9
    word e_type;  // offset: 0x10
    word e_machine;  // offset: 0x12
    dword e_version;  // offset: 0x14
    dword e_entry;  // offset: 0x18
    dword e_phoff;  // offset: 0x1c
    dword e_shoff;  // offset: 0x20
    dword e_flags;  // offset: 0x24
    word e_ehsize;  // offset: 0x28
    word e_phentsize;  // offset: 0x2a
    word e_phnum;  // offset: 0x2c
    word e_shentsize;  // offset: 0x2e
    word e_shnum;  // offset: 0x30
    word e_shstrndx;  // offset: 0x32
}; // size: 0x34

struct Elf32_Phdr {
    Elf_ProgramHeaderType_ARM p_type;  // offset: 0x0
    dword p_offset;  // offset: 0x4
    dword p_vaddr;  // offset: 0x8
    dword p_paddr;  // offset: 0xc
    dword p_filesz;  // offset: 0x10
    dword p_memsz;  // offset: 0x14
    dword p_flags;  // offset: 0x18
    dword p_align;  // offset: 0x1c
}; // size: 0x20

struct Elf32_Rel {
    dword r_offset;  // offset: 0x0
    dword r_info;  // offset: 0x4
}; // size: 0x8

struct Elf32_Shdr {
    dword sh_name;  // offset: 0x0
    Elf_SectionHeaderType_ARM sh_type;  // offset: 0x4
    dword sh_flags;  // offset: 0x8
    dword sh_addr;  // offset: 0xc
    dword sh_offset;  // offset: 0x10
    dword sh_size;  // offset: 0x14
    dword sh_link;  // offset: 0x18
    dword sh_info;  // offset: 0x1c
    dword sh_addralign;  // offset: 0x20
    dword sh_entsize;  // offset: 0x24
}; // size: 0x28

struct Elf32_Sym {
    dword st_name;  // offset: 0x0
    dword st_value;  // offset: 0x4
    dword st_size;  // offset: 0x8
    byte st_info;  // offset: 0xc
    byte st_other;  // offset: 0xd
    word st_shndx;  // offset: 0xe
}; // size: 0x10

struct GnuBuildId {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    byte hash[20];  // offset: 0x10
}; // size: 0x24

struct NoteAbiTag {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    dword abiType;  // offset: 0x10
    dword requiredKernelVersion[3];  // offset: 0x14
}; // size: 0x20

struct _IO_FILE {
    int _flags;  // offset: 0x0
    char * _IO_read_ptr;  // offset: 0x4
    char * _IO_read_end;  // offset: 0x8
    char * _IO_read_base;  // offset: 0xc
    char * _IO_write_base;  // offset: 0x10
    char * _IO_write_ptr;  // offset: 0x14
    char * _IO_write_end;  // offset: 0x18
    char * _IO_buf_base;  // offset: 0x1c
    char * _IO_buf_end;  // offset: 0x20
    char * _IO_save_base;  // offset: 0x24
    char * _IO_backup_base;  // offset: 0x28
    char * _IO_save_end;  // offset: 0x2c
    _IO_marker * _markers;  // offset: 0x30
    _IO_FILE * _chain;  // offset: 0x34
    int _fileno;  // offset: 0x38
    int _flags2;  // offset: 0x3c
    __off_t _old_offset;  // offset: 0x40
    ushort _cur_column;  // offset: 0x44
    char _vtable_offset;  // offset: 0x46
    char _shortbuf[1];  // offset: 0x47
    _IO_lock_t * _lock;  // offset: 0x48
    __off64_t _offset;  // offset: 0x50
    void * __pad1;  // offset: 0x58
    void * __pad2;  // offset: 0x5c
    void * __pad3;  // offset: 0x60
    void * __pad4;  // offset: 0x64
    size_t __pad5;  // offset: 0x68
    int _mode;  // offset: 0x6c
    char _unused2[40];  // offset: 0x70
}; // size: 0x98

struct _IO_FILE {
    int _flags;  // offset: 0x0
    char * _IO_read_ptr;  // offset: 0x4
    char * _IO_read_end;  // offset: 0x8
    char * _IO_read_base;  // offset: 0xc
    char * _IO_write_base;  // offset: 0x10
    char * _IO_write_ptr;  // offset: 0x14
    char * _IO_write_end;  // offset: 0x18
    char * _IO_buf_base;  // offset: 0x1c
    char * _IO_buf_end;  // offset: 0x20
    char * _IO_save_base;  // offset: 0x24
    char * _IO_backup_base;  // offset: 0x28
    char * _IO_save_end;  // offset: 0x2c
    _IO_marker * _markers;  // offset: 0x30
    _IO_FILE * _chain;  // offset: 0x34
    int _fileno;  // offset: 0x38
    int _flags2;  // offset: 0x3c
    __off_t _old_offset;  // offset: 0x40
    ushort _cur_column;  // offset: 0x44
    char _vtable_offset;  // offset: 0x46
    char _shortbuf[1];  // offset: 0x47
    _IO_lock_t * _lock;  // offset: 0x48
    __off64_t _offset;  // offset: 0x50
    void * __pad1;  // offset: 0x58
    void * __pad2;  // offset: 0x5c
    void * __pad3;  // offset: 0x60
    void * __pad4;  // offset: 0x64
    size_t __pad5;  // offset: 0x68
    int _mode;  // offset: 0x6c
    char _unused2[40];  // offset: 0x70
}; // size: 0x98

struct _IO_marker {
    _IO_marker * _next;  // offset: 0x0
    _IO_FILE * _sbuf;  // offset: 0x4
    int _pos;  // offset: 0x8
}; // size: 0xc

struct _IO_marker {
    _IO_marker * _next;  // offset: 0x0
    _IO_FILE * _sbuf;  // offset: 0x4
    int _pos;  // offset: 0x8
}; // size: 0xc

struct __blake2b_param {
    uint8_t digest_length;  // offset: 0x0
    uint8_t key_length;  // offset: 0x1
    uint8_t fanout;  // offset: 0x2
    uint8_t depth;  // offset: 0x3
    uint32_t leaf_length;  // offset: 0x4
    uint64_t node_offset;  // offset: 0x8
    uint8_t node_depth;  // offset: 0x10
    uint8_t inner_length;  // offset: 0x11
    uint8_t reserved[14];  // offset: 0x12
    uint8_t salt[16];  // offset: 0x20
    uint8_t personal[16];  // offset: 0x30
}; // size: 0x40

struct __blake2b_state {
    uint64_t h[8];  // offset: 0x0
    uint64_t t[2];  // offset: 0x40
    uint64_t f[2];  // offset: 0x50
    uint8_t buf[256];  // offset: 0x60
    size_t buflen;  // offset: 0x160
    uint8_t last_node;  // offset: 0x164
}; // size: 0x168

struct __pthread_internal_slist {
    __pthread_internal_slist * __next;  // offset: 0x0
}; // size: 0x4

struct __pthread_internal_slist {
    __pthread_internal_slist * __next;  // offset: 0x0
}; // size: 0x4

struct __pthread_mutex_s {
    int __lock;  // offset: 0x0
    uint __count;  // offset: 0x4
    int __owner;  // offset: 0x8
    int __kind;  // offset: 0xc
    uint __nusers;  // offset: 0x10
    anon_union_4_2_9a799d16_for___pthread_mutex_s_5 field_5;  // offset: 0x14
}; // size: 0x18

struct __pthread_mutex_s {
    int __lock;  // offset: 0x0
    uint __count;  // offset: 0x4
    int __owner;  // offset: 0x8
    int __kind;  // offset: 0xc
    uint __nusers;  // offset: 0x10
    _union_13 field_20;  // offset: 0x14
}; // size: 0x18

struct _struct_16 {
    int __lock;  // offset: 0x0
    uint __futex;  // offset: 0x4
    ulonglong __total_seq;  // offset: 0x8
    ulonglong __wakeup_seq;  // offset: 0x10
    ulonglong __woken_seq;  // offset: 0x18
    void * __mutex;  // offset: 0x20
    uint __nwaiters;  // offset: 0x24
    uint __broadcast_seq;  // offset: 0x28
}; // size: 0x30

struct anon_struct_48_8_df74bd48_for___data {
    int __lock;  // offset: 0x0
    uint __futex;  // offset: 0x4
    ulonglong __total_seq;  // offset: 0x8
    ulonglong __wakeup_seq;  // offset: 0x10
    ulonglong __woken_seq;  // offset: 0x18
    void * __mutex;  // offset: 0x20
    uint __nwaiters;  // offset: 0x24
    uint __broadcast_seq;  // offset: 0x28
}; // size: 0x30

struct app_config_t {
    FILE * dbg_fp;  // offset: 0x0
    char name[16];  // offset: 0x4
    int asic_num;  // offset: 0x14
    int core_num;  // offset: 0x18
    int baudrate;  // offset: 0x1c
    int work_mode;  // offset: 0x20
    int * comport;  // offset: 0x24
    int comport_num;  // offset: 0x28
    int * sensor_pos;  // offset: 0x2c
    int sensor_num;  // offset: 0x30
    int enable_cp210x;  // offset: 0x34
    int ticket_mask;  // offset: 0x38
    uint32_t core_timeout;  // offset: 0x3c
    int pattern_num;  // offset: 0x40
    int chip_alarm_temp;  // offset: 0x44
    int bringup_freq;  // offset: 0x48
    int bringup_voltage;  // offset: 0x4c
    int bringup_work_interval_s;  // offset: 0x50
    int * bringup_autojh_volt;  // offset: 0x54
    int * bringup_autojh_freq;  // offset: 0x58
    char pcba_repeat_ctrl[16];  // offset: 0x5c
    int pcba_freq;  // offset: 0x6c
    int pcba_voltage;  // offset: 0x70
    int pcba_tempture_high;  // offset: 0x74
    int pcba_tempture_low;  // offset: 0x78
    int pcba_only_find_asic;  // offset: 0x7c
    int pcba_pattern_pass_rate;  // offset: 0x80
    int send_pattern_timeout;  // offset: 0x84
    int pcba_enable_level;  // offset: 0x88
    double * pcba_level_rate;  // offset: 0x8c
    int slt_test_mode;  // offset: 0x90
    char slt_tunel_path[64];  // offset: 0x94
    char slt_cp210x_runtime[64];  // offset: 0xd4
    double * slt_bin_rate;  // offset: 0x114
    int slt_delay;  // offset: 0x118
    int slt_freq;  // offset: 0x11c
    int slt_work_interval_ms;  // offset: 0x120
    int slt_enable_read_temp;  // offset: 0x124
}; // size: 0x128

struct asic_data_info_t {
    int resp_nonce_frame_num;  // offset: 0x0
    int resp_nonce_frame_len;  // offset: 0x4
    int resp_reg_len;  // offset: 0x8
    int resp_pm_len;  // offset: 0xc
    int resp_pt_len;  // offset: 0x10
    int resp_frame_max_len;  // offset: 0x14
    int request_work_len;  // offset: 0x18
}; // size: 0x1c

struct base_type_t {
    uint8_t chip_addr;  // offset: 0x0
    uint8_t all;  // offset: 0x1
    uint8_t addr;  // offset: 0x2
    uint32_t data;  // offset: 0x4
}; // size: 0x8

struct baud_BT8D_value {
    uint32_t baud;  // offset: 0x0
    uint8_t bt8d;  // offset: 0x4
    int divider_value;  // offset: 0x8
}; // size: 0xc

struct bm174x_analog_mux_control {
    uint32_t:3 diode_vdd_mux_sel;  // offset: 0x0
    uint32_t:29 reserve;  // offset: 0x0
}; // size: 0x4

struct bm174x_bist_status {
    uint32_t:1 bist_ok;  // offset: 0x0
    uint32_t:1 bist_crc_error;  // offset: 0x0
    uint32_t:30 reserve;  // offset: 0x0
}; // size: 0x4

struct bm174x_blake_ctrl {
    uint32_t:4 pll_div;  // offset: 0x0
    uint32_t:16 reserve1;  // offset: 0x0
    uint32_t:1 blake_round9_en;  // offset: 0x2
    uint32_t:1 blake_round5_en;  // offset: 0x2
    uint32_t:1 blake_round9_self_en;  // offset: 0x2
    uint32_t:8 reserve2;  // offset: 0x2
    uint32_t:1 blake_icg_bypass;  // offset: 0x3
}; // size: 0x4

struct bm174x_chip_addr {
    uint32_t:8 chip_addr;  // offset: 0x0
    uint32_t:5 reserve2;  // offset: 0x1
    uint32_t:3 reserve1;  // offset: 0x1
    uint32_t:16 chip_name;  // offset: 0x2
}; // size: 0x4

struct bm174x_chip_status {
    uint32_t:8 crc5err;  // offset: 0x0
    uint32_t:8 crc16err;  // offset: 0x1
    uint32_t:4 ram_empty;  // offset: 0x2
    uint32_t:11 reserve;  // offset: 0x2
    uint32_t:1 clrerr;  // offset: 0x3
}; // size: 0x4

struct bm174x_clk_div_cnt0 {
    uint32_t:16 div_cnt0;  // offset: 0x0
    uint32_t:16 div_cnt1;  // offset: 0x2
}; // size: 0x4

struct bm174x_clk_div_cnt1 {
    uint32_t:16 div_cnt2;  // offset: 0x0
    uint32_t:1 rst_clk_chg_en;  // offset: 0x2
    uint32_t:1 ln_clk_chg_en;  // offset: 0x2
    uint32_t:14 reserve;  // offset: 0x2
}; // size: 0x4

struct bm174x_core_timeout {
    uint32_t core_timeout;  // offset: 0x0
}; // size: 0x4

struct bm174x_general_i2c_command {
    uint32_t:8 data;  // offset: 0x0
    uint32_t:8 regaddr;  // offset: 0x1
    uint32_t:1 rwctrl;  // offset: 0x2
    uint32_t:7 devaddr;  // offset: 0x2
    uint32_t:1 ravalid;  // offset: 0x3
    uint32_t:5 reserve;  // offset: 0x3
    uint32_t:1 rwfail;  // offset: 0x3
    uint32_t:1 busy;  // offset: 0x3
}; // size: 0x4

struct bm174x_hash_rate {
    uint32_t:31 hash_rate;  // offset: 0x0
    uint32_t:1 hash_rate_flag;  // offset: 0x3
}; // size: 0x4

struct bm174x_io_drive_strength {
    uint32_t:4 co_ds;  // offset: 0x0
    uint32_t:4 bo_ds;  // offset: 0x0
    uint32_t:4 nrsto_ds;  // offset: 0x1
    uint32_t:4 clko_ds;  // offset: 0x1
    uint32_t:4 ro_ds;  // offset: 0x2
    uint32_t:4 tf_df;  // offset: 0x2
    uint32_t:4 rf_ds;  // offset: 0x3
    uint32_t:4 txo_ds;  // offset: 0x3
}; // size: 0x4

struct bm174x_misc_control {
    uint32_t:2 hashrate_tws;  // offset: 0x0
    uint32_t:1 auto_rst_bp;  // offset: 0x0
    uint32_t:2 reserve4;  // offset: 0x0
    uint32_t:2 tfs;  // offset: 0x0
    uint32_t:1 reserve3;  // offset: 0x0
    uint32_t:5 bt8d;  // offset: 0x1
    uint32_t:1 invclko;  // offset: 0x1
    uint32_t:1 rfs;  // offset: 0x1
    uint32_t:1 reservex;  // offset: 0x1
    uint32_t:8 reserve2;  // offset: 0x2
    uint32_t:2 addrpin;  // offset: 0x3
    uint32_t:1 latch_ci;  // offset: 0x3
    uint32_t:5 reserve1;  // offset: 0x3
}; // size: 0x4

struct bm174x_nonce_shift {
    uint32_t:5 nonce_shift;  // offset: 0x0
    uint32_t:27 reserve;  // offset: 0x0
}; // size: 0x4

struct bm174x_nonce_tx_ok {
    uint32_t:16 nonce_txok;  // offset: 0x0
    uint32_t:8 nid;  // offset: 0x2
    uint32_t:7 reserve;  // offset: 0x3
    uint32_t:1 txok_en;  // offset: 0x3
}; // size: 0x4

struct bm174x_pll_parameter {
    uint32_t:3 postdiv2;  // offset: 0x0
    uint32_t:1 reserve4;  // offset: 0x0
    uint32_t:3 postdiv1;  // offset: 0x0
    uint32_t:1 reserve3;  // offset: 0x0
    uint32_t:6 refdiv;  // offset: 0x1
    uint32_t:2 reserve2;  // offset: 0x1
    uint32_t:12 fbdiv;  // offset: 0x2
    uint32_t:3 reserve1;  // offset: 0x3
    uint32_t:1 locked;  // offset: 0x3
}; // size: 0x4

struct bm174x_pmonitor_ctrl {
    uint32_t:6 coreid;  // offset: 0x0
    uint32_t:2 vtsel;  // offset: 0x0
    uint32_t:24 reserve;  // offset: 0x1
}; // size: 0x4

struct bm174x_pt_ctrl {
    uint32_t:1 pt_en;  // offset: 0x0
    uint32_t:15 reserved1;  // offset: 0x0
    uint32_t:11 pt_num;  // offset: 0x2
    uint32_t:5 reserved2;  // offset: 0x3
}; // size: 0x4

struct bm174x_pt_result {
    uint32_t:1 ptr_rd;  // offset: 0x0
    uint32_t:7 reserved1;  // offset: 0x0
    uint32_t:4 ptr_grp_num;  // offset: 0x1
    uint32_t:4 reserved2;  // offset: 0x1
    uint32_t:12 pt_cur_num;  // offset: 0x2
    uint32_t:4 reserved3;  // offset: 0x3
}; // size: 0x4

struct bm174x_ram_para0 {
    uint32_t:13 subcore_ram_para0;  // offset: 0x0
    uint32_t:3 reserve0;  // offset: 0x1
    uint32_t:13 subcore_ram_para1;  // offset: 0x2
    uint32_t:1 cust_ram_wa;  // offset: 0x3
    uint32_t:2 reserve1;  // offset: 0x3
}; // size: 0x4

struct bm174x_ram_para1 {
    uint32_t:13 subcore_ram_para2;  // offset: 0x0
    uint32_t:3 reserve0;  // offset: 0x1
    uint32_t:13 top_ram_para;  // offset: 0x2
    uint32_t:3 reserve1;  // offset: 0x3
}; // size: 0x4

struct bm174x_reg_value_t {
    uint32_t chip_addr;  // offset: 0x0
    uint32_t hash_rate;  // offset: 0x4
    uint32_t pll_parameter;  // offset: 0x8
    uint32_t blake_ctrl;  // offset: 0xc
    uint32_t ticket_mask;  // offset: 0x10
    uint32_t misc_control;  // offset: 0x14
    uint32_t general_i2c_command;  // offset: 0x18
    uint32_t nonce_tx_ok;  // offset: 0x1c
    uint32_t core_timeout;  // offset: 0x20
    uint32_t io_drive_strength;  // offset: 0x24
    uint32_t chip_status;  // offset: 0x28
    uint32_t time_out;  // offset: 0x2c
    uint32_t pmonitor_ctrl;  // offset: 0x30
    uint32_t analog_mux_control;  // offset: 0x34
    uint32_t core_reset;  // offset: 0x38
    uint32_t bist_status;  // offset: 0x3c
    uint32_t nonce_shift;  // offset: 0x40
    uint32_t start_nonce_offset;  // offset: 0x44
    uint32_t txn_data;  // offset: 0x48
    uint32_t pt_ctrl;  // offset: 0x4c
    uint32_t pt_result;  // offset: 0x50
    uint32_t ram_para0;  // offset: 0x54
    uint32_t ram_para1;  // offset: 0x58
    uint32_t clk_div_cnt0;  // offset: 0x5c
    uint32_t clk_div_cnt1;  // offset: 0x60
}; // size: 0x64

struct bm174x_start_nonce_offset {
    uint32_t sno;  // offset: 0x0
}; // size: 0x4

struct bm174x_ticket_mask {
    uint32_t:8 ticket_mask;  // offset: 0x0
    uint32_t:24 reserve;  // offset: 0x1
}; // size: 0x4

struct bm174x_time_out {
    uint32_t:16 timeout;  // offset: 0x0
    uint32_t:16 nonce_tx_timeout;  // offset: 0x2
}; // size: 0x4

struct bm174x_txn_data {
    uint32_t:1 txn_zero;  // offset: 0x0
    uint32_t:1 txn_shalow;  // offset: 0x0
    uint32_t:30 reaseve;  // offset: 0x0
}; // size: 0x4

struct cgpu_info {
    pthread_t send_id;  // offset: 0x0
    pthread_t receive_id;  // offset: 0x4
    pthread_t show_id;  // offset: 0x8
    pthread_t pic_heart_beat_id;  // offset: 0xc
    pthread_t read_temp;  // offset: 0x10
    pthread_t chain_send_id[3];  // offset: 0x14
    int device_fd;  // offset: 0x20
    int lcd_fd;  // offset: 0x24
    int fpga_fd;  // offset: 0x28
    int key_fd;  // offset: 0x2c
    int red_led_fd;  // offset: 0x30
    int green_led_fd;  // offset: 0x34
    int beep_fd;  // offset: 0x38
    uint real_asic_num;  // offset: 0x3c
    uint asicNum;  // offset: 0x40
    uint core_num;  // offset: 0x44
    uint AsicType;  // offset: 0x48
    uint chain_num;  // offset: 0x4c
    ushort frequency;  // offset: 0x50
    uint chain_exist[1];  // offset: 0x54
    uint timeout;  // offset: 0x58
    runtime_base_t * runtime;  // offset: 0x5c
}; // size: 0x60

struct chain_inactive_cmd_t {
    uint8_t:4 cmd;  // offset: 0x0
    uint8_t:1 all;  // offset: 0x0
    uint8_t:3 type;  // offset: 0x0
    uint8_t length;  // offset: 0x1
    uint8_t reserve1;  // offset: 0x2
    uint8_t reserve2;  // offset: 0x3
    uint8_t:5 crc5;  // offset: 0x4
    uint8_t:3 reserve3;  // offset: 0x4
}; // size: 0x5

struct chain_info {
    uchar which_chain;  // offset: 0x0
    uchar which_i2c;  // offset: 0x1
}; // size: 0x2

struct chain_status_t {
    int fd;  // offset: 0x0
    int comport;  // offset: 0x4
    int baudrate;  // offset: 0x8
    pthread_t p_dispatch;  // offset: 0xc
    int real_asic_num;  // offset: 0x10
    int design_asic_num;  // offset: 0x14
    uint32_t nonce_num_each_asic[3];  // offset: 0x18
    uint32_t nonce_invalid_num_each_asic[3];  // offset: 0x24
    uint32_t[3] nonce_invalid_num_each_asic_type[3];  // offset: 0x30
    uint32_t one_work_nonce_each_asic[3];  // offset: 0x54
    uint32_t one_work_invalid_nonce_each_asic[3];  // offset: 0x60
    uint32_t[3] one_work_invalid_nonce_each_asic_type[3];  // offset: 0x6c
}; // size: 0x90

struct evp_pkey_ctx_st {
    // Empty structure
}; // size: 0x1

struct freq_pll_str {
    uint freq;  // offset: 0x0
    uint fildiv1;  // offset: 0x4
    uint fildiv2;  // offset: 0x8
    uint vilpll;  // offset: 0xc
}; // size: 0x10

struct get_status_cmd_t {
    uint8_t:4 cmd;  // offset: 0x0
    uint8_t:1 all;  // offset: 0x0
    uint8_t:3 type;  // offset: 0x0
    uint8_t length;  // offset: 0x1
    uint8_t chip_addr;  // offset: 0x2
    uint8_t regaddr;  // offset: 0x3
    uint8_t:5 crc5;  // offset: 0x4
    uint8_t:3 reserve;  // offset: 0x4
}; // size: 0x5

struct nonce_buf {
    uint32_t p_wr;  // offset: 0x0
    uint32_t p_rd;  // offset: 0x4
    uint32_t nonce_num;  // offset: 0x8
    nonce_rb_format nonce_buffer[511];  // offset: 0xc
}; // size: 0xa94c0

struct nonce_rb_format {
    uint8_t Nonce[1344];  // offset: 0x0
    uint8_t chip_addr;  // offset: 0x540
    uint8_t work_id;  // offset: 0x541
    uint8_t nonce_id;  // offset: 0x542
    uint8_t diff0;  // offset: 0x543
    uint8_t sha256[4];  // offset: 0x544
    uint8_t chip_nonce[4];  // offset: 0x548
    uint8_t chain_id;  // offset: 0x54c
}; // size: 0x54d

struct nonce_verify_info_t {
    uint8_t work[140];  // offset: 0x0
    uint8_t nonce[4];  // offset: 0x8c
    uint8_t sol[1344];  // offset: 0x90
    uint8_t target[32];  // offset: 0x5d0
    int work_len;  // offset: 0x5f0
    int nonce_len;  // offset: 0x5f4
    int sol_len;  // offset: 0x5f8
    int target_len;  // offset: 0x5fc
}; // size: 0x600

struct patten_info {
    int asic_num;  // offset: 0x0
    int core_num;  // offset: 0x4
    int work_bin_len;  // offset: 0x8
    int nonce_bin_len;  // offset: 0xc
    int sol_bin_len;  // offset: 0x10
    int patten_num;  // offset: 0x14
    char dir_root[16];  // offset: 0x18
    char dir_algo[16];  // offset: 0x28
    char dir_asic[16];  // offset: 0x38
    char file_core[16];  // offset: 0x48
    uchar * patten_start;  // offset: 0x58
    uchar * cur_work;  // offset: 0x5c
    uint32_t cur_asic;  // offset: 0x60
    uint32_t cur_core;  // offset: 0x64
    uint32_t cur_patten;  // offset: 0x68
    uchar * is_nonce_match;  // offset: 0x6c
    int recv_nonces;  // offset: 0x70
    int * asic_recv_nonces;  // offset: 0x74
    int total_pattens;  // offset: 0x78
    float total_rate;  // offset: 0x7c
    int start;  // offset: 0x80
    pthread_mutex_t patten_mutex;  // offset: 0x84
}; // size: 0x9c

struct pattern_test_respond {
    uint8_t header_aa;  // offset: 0x0
    uint8_t header_55;  // offset: 0x1
    uint8_t format;  // offset: 0x2
    uint8_t chip_address;  // offset: 0x3
    uint8_t pt_result_data[1024];  // offset: 0x4
    uint16_t crc16;  // offset: 0x404
}; // size: 0x406

struct pmonitor_respond {
    uint8_t header_aa;  // offset: 0x0
    uint8_t header_55;  // offset: 0x1
    uint8_t format;  // offset: 0x2
    uint8_t pm_data[4];  // offset: 0x3
    uint8_t chip_addr;  // offset: 0x7
    uint8_t:5 crc5;  // offset: 0x8
    uint8_t:3 reserve;  // offset: 0x8
}; // size: 0x9

struct reg_list_item_t {
    uint8_t chainid;  // offset: 0x0
    uint8_t chip_addr;  // offset: 0x1
    uint8_t reg_addr;  // offset: 0x2
    uint32_t reg_data;  // offset: 0x4
    int age;  // offset: 0x8
}; // size: 0xc

struct reg_list_t {
    reg_list_item_t * reg_list_items;  // offset: 0x0
    pthread_mutex_t reg_list_mutex;  // offset: 0x4
    pthread_t p_reg_list;  // offset: 0x1c
    int alive;  // offset: 0x20
}; // size: 0x24

struct reg_respond {
    uint8_t header_aa;  // offset: 0x0
    uint8_t header_55;  // offset: 0x1
    uint8_t reg_addr;  // offset: 0x2
    uint8_t reg_data[4];  // offset: 0x3
    uint8_t chip_addr;  // offset: 0x7
    uint8_t:5 crc5;  // offset: 0x8
    uint8_t:3 reserve;  // offset: 0x8
}; // size: 0x9

struct rt_ringbuffer {
    uchar * buffer_ptr;  // offset: 0x0
    ushort:1 read_mirror;  // offset: 0x4
    ushort:15 read_index;  // offset: 0x4
    ushort:1 write_mirror;  // offset: 0x6
    ushort:15 write_index;  // offset: 0x6
    int block_flag;  // offset: 0x8
    ushort buffer_size;  // offset: 0xc
    pthread_mutex_t ringbuf_lock;  // offset: 0x10
    pthread_cond_t notfull;  // offset: 0x28
    pthread_cond_t notempty;  // offset: 0x58
    ringbuffer_type_t ringbuffer_type;  // offset: 0x88
}; // size: 0x90

struct runtime_base_t {
    chain_status_t chain_status[1];  // offset: 0x0
    asic_data_info_t asic_data_info;  // offset: 0x90
    nonce_verify_info_t nonce_verify_info;  // offset: 0xac
    char asic_name[64];  // offset: 0x6ac
    int chain_id;  // offset: 0x6ec
    int addr_interval;  // offset: 0x6f0
    int sensor_pos[256];  // offset: 0x6f4
    int sensor_num;  // offset: 0xaf4
    int start_recv;  // offset: 0xaf8
    int baudrate;  // offset: 0xafc
    pthread_t p_scanhash;  // offset: 0xb00
    uint8_t total_work;  // offset: 0xb04
    _Bool new_block;  // offset: 0xb05
    uint32_t valid_nonce_total;  // offset: 0xb08
    uint32_t invalid_nonce_total;  // offset: 0xb0c
    uint32_t submit_nonce;  // offset: 0xb10
    uint32_t nonce_shift;  // offset: 0xb14
    int chain_num;  // offset: 0xb18
    _Bool pld_test_txok;  // offset: 0xb1c
    _func_void_runtime_base_t_ptr * init_asic;  // offset: 0xb20
    _func_void_runtime_base_t_ptr * exit_asic;  // offset: 0xb24
    _func_void_runtime_base_t_ptr * init_algo;  // offset: 0xb28
    _func_void_runtime_base_t_ptr * exit_algo;  // offset: 0xb2c
    _func_void_int_int_uint8_t_uint8_t * read_register;  // offset: 0xb30
    _func_void_int_int_uint8_t_uint8_t_uint32_t * write_register;  // offset: 0xb34
    _func_void_int_uint8_t_ptr * send_work;  // offset: 0xb38
    _func_void_int_uint32_t * set_ticket_mask;  // offset: 0xb3c
    _func_void_int_uint32_t * set_core_timeout;  // offset: 0xb40
    _func_void_int_int_int * set_pt_ctrl;  // offset: 0xb44
    _func_void_int_int_int * set_pt_result;  // offset: 0xb48
    _func_void_int_uint32_t * set_txn_data;  // offset: 0xb4c
    _func_void_int_int * set_baud;  // offset: 0xb50
    _func_void_int * chain_inactive;  // offset: 0xb54
    _func_void_int_uint8_t * set_address;  // offset: 0xb58
    _func_void_int_uint32_t * set_frequency;  // offset: 0xb5c
    _func_void_int_uint32_t_uint32_t_ptr * set_nonce_shift;  // offset: 0xb60
    _func_void_int_int * set_vmount;  // offset: 0xb64
    _func_void_int_uint8_t_uint8_t_uint8_t_uint8_t_ptr_int * i2c_send;  // offset: 0xb68
    _func_int_int_uint8_t_uint8_t_uint8_t_int * i2c_recv;  // offset: 0xb6c
    _func_void_int_uint8_t * i2c_enable;  // offset: 0xb70
    _func_void_int_uint8_t * i2c_status;  // offset: 0xb74
    _func_int_nonce_verify_info_t_ptr_int_ptr_uint32_t * nonce_verify;  // offset: 0xb78
    _func__Bool_uchar_ptr_uchar_ptr * nonce_verify_target_match;  // offset: 0xb7c
    _func_void_uint8_t_ptr_uint8_t_ptr_int_char_ptr * nonce_submit;  // offset: 0xb80
    _func_void_uint8_t_ptr_int_uint8_t * pm_handle;  // offset: 0xb84
    _func_void_uint8_t_ptr_int_uint8_t * pt_handle;  // offset: 0xb88
    _func_void_uint8_t_ptr_int_uint8_t * reg_handle;  // offset: 0xb8c
    _func_int_uint8_t_ptr_int_uint32_t_int * nonce_handle;  // offset: 0xb90
}; // size: 0xb94

struct set_address_cmd_t {
    uint8_t:4 cmd;  // offset: 0x0
    uint8_t:1 all;  // offset: 0x0
    uint8_t:3 type;  // offset: 0x0
    uint8_t length;  // offset: 0x1
    uint8_t chip_addr;  // offset: 0x2
    uint8_t reserve1;  // offset: 0x3
    uint8_t:5 crc5;  // offset: 0x4
    uint8_t:3 reserve2;  // offset: 0x4
}; // size: 0x5

struct set_config_cmd_t {
    uint8_t:4 cmd;  // offset: 0x0
    uint8_t:1 all;  // offset: 0x0
    uint8_t:3 type;  // offset: 0x0
    uint8_t length;  // offset: 0x1
    uint8_t chip_addr;  // offset: 0x2
    uint8_t regaddr;  // offset: 0x3
    uint8_t regdata[4];  // offset: 0x4
    uint8_t:5 crc5;  // offset: 0x8
    uint8_t:3 reserve;  // offset: 0x8
}; // size: 0x9

struct sha256_ctx {
    uint tot_len;  // offset: 0x0
    uint len;  // offset: 0x4
    uchar block[128];  // offset: 0x8
    uint32_t h[8];  // offset: 0x88
}; // size: 0xa8

struct sha2_context {
    uint32_t total[2];  // offset: 0x0
    uint32_t state[8];  // offset: 0x8
    uchar buffer[64];  // offset: 0x28
    uchar ipad[64];  // offset: 0x68
    uchar opad[64];  // offset: 0xa8
}; // size: 0xe8

struct timeval {
    __time_t tv_sec;  // offset: 0x0
    __suseconds_t tv_usec;  // offset: 0x4
}; // size: 0x8

struct timeval {
    __time_t tv_sec;  // offset: 0x0
    __suseconds_t tv_usec;  // offset: 0x4
}; // size: 0x8

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct tm {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long tm_gmtoff;  // offset: 0x24
    char * tm_zone;  // offset: 0x28
}; // size: 0x2c

struct tm {
    int tm_sec;  // offset: 0x0
    int tm_min;  // offset: 0x4
    int tm_hour;  // offset: 0x8
    int tm_mday;  // offset: 0xc
    int tm_mon;  // offset: 0x10
    int tm_year;  // offset: 0x14
    int tm_wday;  // offset: 0x18
    int tm_yday;  // offset: 0x1c
    int tm_isdst;  // offset: 0x20
    long tm_gmtoff;  // offset: 0x24
    char * tm_zone;  // offset: 0x28
}; // size: 0x2c

struct validData {
    int n;  // offset: 0x0
    int k;  // offset: 0x4
    blake2b_state * digest;  // offset: 0x8
}; // size: 0xc

struct work_input {
    uint8_t header_55;  // offset: 0x0
    uint8_t header_aa;  // offset: 0x1
    uint8_t:1 test_patten;  // offset: 0x2
    uint8_t:3 reserve;  // offset: 0x2
    uint8_t:1 sno_valid;  // offset: 0x2
    uint8_t:3 type;  // offset: 0x2
    uint8_t workid;  // offset: 0x3
    uint8_t work[140];  // offset: 0x4
    uint16_t crc16;  // offset: 0x90
}; // size: 0x92

struct work_list_info_t {
    work_list_t work_list[10];  // offset: 0x0
    int work_len;  // offset: 0x50
    int work_list_insert_index;  // offset: 0x54
    pthread_mutex_t work_list_mutex;  // offset: 0x58
}; // size: 0x70

struct work_list_t {
    uint8_t workid;  // offset: 0x0
    uint8_t * work;  // offset: 0x4
}; // size: 0x8

struct zcash_work_info {
    uint8_t target[32];  // offset: 0x0
    char job_id[256];  // offset: 0x20
    uint8_t header[140];  // offset: 0x120
    int fixed_nonce_bytes;  // offset: 0x1ac
    pthread_mutex_t work_info_mutex;  // offset: 0x1b0
}; // size: 0x1c8

/* ==================== Unions ==================== */

union _union_13 {
    int __spins;
    __pthread_slist_t __list;
}; // size: 0x4

union anon_union_4_2_9a799d16_for___pthread_mutex_s_5 {
    int __spins;
    __pthread_slist_t __list;
}; // size: 0x4

union bm174x_reg {
    bm174x_chip_addr chip_addr;
    bm174x_hash_rate hash_rate;
    bm174x_pll_parameter pll_parameter;
    bm174x_blake_ctrl blake_ctrl;
    bm174x_ticket_mask ticket_mask;
    bm174x_misc_control misc_control;
    bm174x_general_i2c_command general_i2c_command;
    bm174x_nonce_tx_ok nonce_tx_ok;
    bm174x_core_timeout core_timeout;
    bm174x_io_drive_strength io_drive_strength;
    bm174x_chip_status chip_status;
    bm174x_time_out time_out;
    bm174x_pmonitor_ctrl pmonitor_ctrl;
    bm174x_analog_mux_control analog_mux_control;
    bm174x_bist_status bist_status;
    bm174x_nonce_shift nonce_shift;
    bm174x_start_nonce_offset start_nonce_offset;
    bm174x_txn_data txn_data;
    bm174x_pt_ctrl pt_ctrl;
    bm174x_pt_result pt_result;
    bm174x_ram_para0 ram_para0;
    bm174x_ram_para1 ram_para1;
    bm174x_clk_div_cnt0 clk_div_cnt0;
    bm174x_clk_div_cnt1 clk_div_cnt1;
    uint32_t reg_bin;
}; // size: 0x4

union pthread_attr_t {
    char[36] __size;
    long __align;
}; // size: 0x24

union pthread_cond_t {
    anon_struct_48_8_df74bd48_for___data __data;
    char[48] __size;
    longlong __align;
}; // size: 0x30

union pthread_cond_t {
    _struct_16 __data;
    char[48] __size;
    longlong __align;
}; // size: 0x30

union pthread_condattr_t {
    char[4] __size;
    int __align;
}; // size: 0x4

union pthread_mutex_t {
    __pthread_mutex_s __data;
    char[24] __size;
    long __align;
}; // size: 0x18

union pthread_mutex_t {
    __pthread_mutex_s __data;
    char[24] __size;
    long __align;
}; // size: 0x18

union pthread_mutexattr_t {
    char[4] __size;
    int __align;
}; // size: 0x4

/* ==================== Type Definitions ==================== */

typedef evp_pkey_ctx_st EVP_PKEY_CTX;
typedef _IO_FILE FILE;
typedef _IO_FILE FILE;
typedef rt_ringbuffer_state RINGBUFFER_STATE;
typedef bool _Bool;
typedef void _IO_lock_t;
typedef void _IO_lock_t;
typedef __compar_fn_t * __compar_fn_t;
typedef __quad_t __off64_t;
typedef __quad_t __off64_t;
typedef int __off_t;
typedef long __off_t;
typedef __pthread_internal_slist __pthread_slist_t;
typedef __pthread_internal_slist __pthread_slist_t;
typedef longlong __quad_t;
typedef longlong __quad_t;
typedef int __ssize_t;
typedef int __ssize_t;
typedef int __suseconds_t;
typedef long __suseconds_t;
typedef int __time_t;
typedef long __time_t;
typedef timezone * __timezone_ptr_t;
typedef uint __useconds_t;
typedef __blake2b_param blake2b_param;
typedef __blake2b_state blake2b_state;
typedef sword int16_t;
typedef patten_info patten_info_t;
typedef uint pthread_t;
typedef ulong pthread_t;
typedef ringbuffer_type ringbuffer_type_t;
typedef uint size_t;
typedef ulong size_t;
typedef uint sizetype;
typedef __ssize_t ssize_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef __time_t time_t;
typedef word uint16_t;
typedef dword uint32_t;
typedef qword uint64_t;
typedef uchar uint8_t;

/* ==================== Function Prototypes ==================== */

uint16_t CRC16(uint8_t * p_data, uint16_t w_len);
ushort CRC16_v1(uchar * buffer, int len);
uchar CRC5(uchar * ptr, uchar len);
uchar CRC5_v1(uchar * ptr, uchar len);
int ISL_get_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t * voltage);
int ISL_off(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int ISL_on(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int ISL_page_enable(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t which_page);
int ISL_read_reg_default(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int ISL_set_apply_settings(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int ISL_set_clear_faults(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr);
int ISL_set_on_off_config(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t config);
uint16_t ISL_set_voltage(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage);
int ISL_set_vout_command(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint16_t voltage);
int ISL_set_write_protect(uint8_t which_chain, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t mode);
int PIC16F1704_i2c_forward_send(uint32_t i2c, uint8_t chain, uint8_t dev_addr, int rw_flag, uint8_t reg_addr, int len, uint8_t * data);
int PIC1704_update_pic_app_program(uint which_i2c, uchar which_chain);
void Sha256_Final(CSha256 * p, uint8_t * digest);
void Sha256_Init(CSha256 * p);
void Sha256_Onestep(uint8_t * data, size_t size, uint8_t * digest);
void Sha256_Transform(uint32_t * state, uint32_t * data);
void Sha256_Update(CSha256 * p, uint8_t * data, size_t size);
void Sha256_WriteByteBlock(CSha256 * p);
void V9_print_lcd(void);
void V9_print_lcd_type(int type);
void __bin2hex(char * s, uchar * p, size_t len);
uint __bswap_32(uint __bsx);
int __compar_fn_t(void * param0, void * param1);
void __libc_csu_fini(void);
void __libc_csu_init(int argc, char * * argv, char * * envp);
void * __start_routine(void * param0);
void _applog(int prio, char * str, _Bool force);
_Bool _func__Bool_uchar_ptr_uchar_ptr(uchar * param0, uchar * param1);
int _func_int_int_uint8_t_uint8_t_uint8_t_int(int param0, uint8_t param1, uint8_t param2, uint8_t param3, int param4);
int _func_int_nonce_verify_info_t_ptr_int_ptr_uint32_t(nonce_verify_info_t * param0, int * param1, uint32_t param2);
int _func_int_uint8_t_ptr_int_uint32_t_int(uint8_t * param0, int param1, uint32_t param2, int param3);
void _func_void_int(int param0);
void _func_void_int_char_ptr_ptr_char_ptr_ptr(int param0, char * * param1, char * * param2);
void _func_void_int_int(int param0, int param1);
void _func_void_int_int_int(int param0, int param1, int param2);
void _func_void_int_int_uint8_t_uint8_t(int param0, int param1, uint8_t param2, uint8_t param3);
void _func_void_int_int_uint8_t_uint8_t_uint32_t(int param0, int param1, uint8_t param2, uint8_t param3, uint32_t param4);
void _func_void_int_uint32_t(int param0, uint32_t param1);
void _func_void_int_uint32_t_uint32_t_ptr(int param0, uint32_t param1, uint32_t * param2);
void _func_void_int_uint8_t(int param0, uint8_t param1);
void _func_void_int_uint8_t_ptr(int param0, uint8_t * param1);
void _func_void_int_uint8_t_uint8_t_uint8_t_uint8_t_ptr_int(int param0, uint8_t param1, uint8_t param2, uint8_t param3, uint8_t * param4, int param5);
void * _func_void_ptr_void_ptr_int_size_t(void * param0, int param1, size_t param2);
void _func_void_runtime_base_t_ptr(runtime_base_t * param0);
void _func_void_uint8_t_ptr_int_uint8_t(uint8_t * param0, int param1, uint8_t param2);
void _func_void_uint8_t_ptr_uint8_t_ptr_int_char_ptr(uint8_t * param0, uint8_t * param1, int param2, char * param3);
void _simplelog(int prio, char * str, _Bool force);
void add_point(int * point, int MAX_SIZE);
int add_reg_item(reg_list_item_t item);
void app_config_exit(app_config_t * conf);
int app_config_handle(app_config_t * m_conf, char * config_filename);
app_config_t * app_config_init(char * config_filename);
uchar asic_baud_to_fpga_baud(uchar asic_baud);
int baud2bt8d(uint baud);
char * bin2hex(uchar * p, size_t len);
uchar bit_read(uchar * y, int x);
void bitmain_axi_close(void);
int bitmain_axi_init(void);
int blake2b(uint8_t * out, void * in, void * key, uint8_t outlen, uint64_t inlen, uint8_t keylen);
int blake2b_compress(blake2b_state * S, uint8_t * block);
int blake2b_final(blake2b_state * S, uint8_t * out, uint8_t outlen);
int blake2b_increment_counter(blake2b_state * S, uint64_t inc);
int blake2b_init(blake2b_state * S, uint8_t outlen);
int blake2b_init0(blake2b_state * S);
int blake2b_init_key(blake2b_state * S, uint8_t outlen, void * key, uint8_t keylen);
int blake2b_init_param(blake2b_state * S, blake2b_param * P);
int blake2b_is_lastblock(blake2b_state * S);
int blake2b_set_lastblock(blake2b_state * S);
int blake2b_set_lastnode(blake2b_state * S);
int blake2b_update(blake2b_state * S, uint8_t * in, uint64_t inlen);
int bm1744_hashboard_init(void);
void bm174x_chain_inactive(int fd);
void bm174x_i2c_enable(int fd, uint8_t chip_addr);
int bm174x_i2c_recv(int fd, uint8_t chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, int len);
void bm174x_i2c_send(int fd, uint8_t chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, uint8_t * reg_data, int len);
void bm174x_i2c_status(int fd, uint8_t chip_addr);
int bm174x_init_asic(void * args);
int bm174x_ioctl(int fd, uint32_t oper_type, void * param);
int bm174x_nonce_handle(uint8_t * str, int len, uint32_t chainid, int addr_interval);
int bm174x_nonce_integrality(uint8_t chipid, uint8_t nonce_array_id, int chainid);
int bm174x_pack_ioctl_pkg(uint8_t * str, uint32_t str_len, uint32_t oper_type, void * param);
void bm174x_pm_handle(uint8_t * str, int len, uint8_t chainid);
void bm174x_pt_handle(uint8_t * str, int len, uint8_t chainid);
void bm174x_read_register(int fd, int mode, uint8_t chip_addr, uint8_t reg_addr);
void bm174x_reg_handle(uint8_t * str, int len, uint8_t chainid);
void bm174x_send_work(int fd, uint8_t * buf);
void bm174x_set_address(int fd, uint8_t address);
void bm174x_set_baud(int fd, int baudrate);
void bm174x_set_core_timeout(int fd, uint32_t timeout);
void bm174x_set_frequency(int fd, uint32_t freq);
void bm174x_set_io_drive_strength(int fd, uint32_t value);
void bm174x_set_nonce_shift(int fd, uint32_t nonce_shift, uint32_t * outer_shift);
void bm174x_set_pt_ctrl(int fd, int pt_num, int pt_en);
void bm174x_set_pt_result(int fd, int ptr_grp_num, int ptr_rd);
void bm174x_set_ticket_mask(int fd, uint32_t tm);
void bm174x_set_txn_data(int fd, uint32_t txn_data);
void bm174x_set_vmount(int fd, int vmount);
void bm174x_write_register(int fd, int mode, uint8_t chip_addr, uint8_t reg_addr, uint32_t reg_data);
int calc_asic_addr_interval(int actual_asic_number);
void cgpu_exit(void);
int cgpu_init(runtime_base_t * runtime);
void check_asic_num(runtime_base_t * runtime);
int check_chain(void);
uint check_how_many_uart_data_in_fpga(uchar which_uart);
void * check_nonce(void * args);
void * check_nonce_loop(void * args);
void clear_last_test_results(void);
void clear_nonce_fifo(void);
uint clear_uart_rx_fifo(uchar which_chain);
uint clear_uart_send_fifo(uchar which_chain);
void close_green_led(void);
void close_key(void);
int close_lcd(void);
void close_red_led(void);
int compareSR(void * p1, void * p2);
void compressArray(uchar * in, size_t in_len, uchar * out, size_t out_len, size_t bit_len, size_t byte_pad);
ushort crc_itu_t_byte(ushort crc, uchar data);
void delay(int seconds);
void digestInit(blake2b_state * S, int n, int k);
void display_arguments(void);
void display_single_board_test(void);
void dump_str(void * fdp, char * func, uchar * str, int len);
int enable_PIC16F1704_dc_dc(uint which_chain, uchar which_i2c, uchar enable);
void env_init(runtime_base_t * runtime);
void equihash_init_algo(void * args);
void equihash_miner_init(runtime_base_t * runtime);
void equihash_miner_join(void);
void equihash_miner_start(runtime_base_t * runtime);
void equihash_nonce_submit(uint8_t * nonce, uint8_t * verify, int fixed_nonce_bytes, char * job_id);
int equihash_nonce_verify(nonce_verify_info_t * verify_info, int * tm, uint32_t shift);
_Bool equihash_target_match(uchar * result_value, uchar * target);
int erase_PIC16F1704_app_flash(uint which_i2c, uchar which_chain);
int erase_PIC16F1704_flash(uint which_i2c, uchar which_chain);
void expandArray(uchar * in, size_t in_len, uchar * out, size_t out_len, size_t bit_len, size_t byte_pad);
void fan_control(uchar level);
void flip32(void * dest_p, void * src_p);
void flip_swab(void * dest_p, void * src_p, uint length);
void generateHash(blake2b_state * S, uint32_t g, uint8_t * hash, size_t hashLen);
int getIndices(uint8_t * hash, size_t len, size_t lenIndices, size_t cBitLen, uint8_t * data, size_t maxLen);
uint get_BC_write_command(void);
int get_PIC16F1704_freq(uint which_chain, uchar which_i2c, ushort * freq);
int get_PIC16F1704_software_version(uint which_i2c, uchar which_chain, uchar * version);
int get_PIC16F1704_voltage(uint which_i2c, uchar which_chain, uchar * voltage);
void get_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain);
uint8_t get_bt8d_from_baud(uint32_t baud);
void get_current_time(char * dtime);
uint get_fan_speed(void);
void get_plldata(uint32_t freq, uint32_t * vil_data);
void get_return_nonce(uint * buf);
void green_led_off(void);
void green_led_on(void);
void * handle_asic_response(void * args);
int heart_beat_PIC16F1704(uint which_chain, uchar which_i2c);
int hex2bin(uchar * p, char * hexstr, size_t len);
uint8_t hex2val(char * base, size_t off);
void hexdump(uchar * p, uint len);
uchar i2c_read(uint config_data);
void i2c_write(uint config_data);
void init_fpga(void);
void init_pcba_args(void);
int isZero(uint8_t * hash, size_t len);
int is_asic_pass(int index);
int is_patten_match(int asic_index, uint8_t * nonce, uint8_t * sol);
int jump_from_loader_to_app_PIC16F1704(uint which_chain, uchar which_i2c);
uint64_t load64(void * src);
int main(void);
int makeup_chain_inactive_cmd(uint8_t * str, uint32_t str_len);
int makeup_get_status_cmd(uint8_t * str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr);
int makeup_set_address_cmd(uint8_t * str, uint32_t str_len, uint8_t chip_addr);
int makeup_set_config_cmd(uint8_t * str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr, uint32_t regdata);
int makeup_work_pkg(uint8_t * str, uint8_t * work_str);
void * memrchr(void * s, int c, size_t n);
uint64_t miner_now(void);
void * mining_mode(void * args);
void mining_parse_job(char * str, uint8_t * target, int target_len, char * job_id, int job_id_len, uint8_t * header, int header_len, int * fixed_nonce_bytes);
void my_log_curses(int prio, char * datetime, char * str, _Bool force);
void nonce_fifo_num(int * num);
void * nonce_scanhash(void * args);
void * nonce_scanhash_loop(void * args);
void online_mining(runtime_base_t * runtime);
int open_green_led(void);
int open_key(void);
int open_lcd(void);
int open_red_led(void);
int parse_config_ini_array(char * str, void * * pointer);
void patten_info_destory(void);
void patten_info_init(void);
void patten_load(char * root_path);
int pattern_test(runtime_base_t * runtime, int freq, int * nonce);
int pattern_test_mode2(runtime_base_t * runtime, int freq, int * nonce);
void pcba_app_manual_test(void);
void pcba_runtime_exit(runtime_base_t * runtime);
void pcba_runtime_init(runtime_base_t * runtime);
void * pic_heart_beat_func(void * arg);
void pop_nonce(nonce_rb_format * nonce_tmp);
uint32_t print_solver_line(uint8_t * soln, uint8_t * header, int fixed_nonce_bytes, char * job_id);
void push_nonce(nonce_rb_format * nonce_item);
void randomize(void * p, int l);
int read_PIC16F1704_flash_data(uint which_i2c, uchar which_chain, uchar * buf);
int read_PIC16F1704_flash_pointer(uint which_i2c, uchar which_chain, uchar * flash_addr_h, uchar * flash_addr_l);
int read_PIC16F1705_iic_slave(uint which_i2c, uchar which_chain, uchar * buf, uchar buf_len, uchar * read_back_buf);
void * read_all_sensor(void);
uint read_axi_fpga(uint address);
int read_data_from_PIC16F1704_flash(int which_chain, int which_i2c, uchar * buf, uchar read_len);
int read_dc_dc(void * args, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t reg, uint8_t * value, int len);
int read_hash_id_PIC16F1704(uint which_i2c, uchar which_chain, uchar * buf);
ssize_t read_key(uchar value);
int read_last_line(char * buf, size_t len, int block);
uchar read_pic(uchar which_i2c, uchar which_chain);
int read_reg_item(reg_list_item_t * item, int ms);
int read_temperature_offset_PIC16F1704(uint which_i2c, uchar which_chain, uchar * buf);
uint read_uart_data_in_fpga(uchar which_uart, uchar * buf, uint length);
void red_led_off(void);
void red_led_on(void);
void * reg_list_aging(void);
void reg_list_exit(void);
void reg_list_init(void);
int reset_PIC16F1704_pic(uint which_chain, uchar which_i2c);
uint64_t rotr64(uint64_t w, uint c);
uint16_t rt_ringbuffer_data_len(rt_ringbuffer * rb);
uint32_t rt_ringbuffer_get(rt_ringbuffer * rb, uint8_t * ptr, uint16_t length);
uint16_t rt_ringbuffer_get_size(rt_ringbuffer * rb);
void rt_ringbuffer_init(rt_ringbuffer * rb, uint8_t * pool, int16_t size, ringbuffer_type_t ringbuffer_type);
void rt_ringbuffer_lock_destory(rt_ringbuffer * rb);
uint32_t rt_ringbuffer_prefetch(rt_ringbuffer * rb, uint8_t * ptr, uint16_t length);
uint32_t rt_ringbuffer_put(rt_ringbuffer * rb, uint8_t * ptr, uint16_t length);
uint32_t rt_ringbuffer_put_force(rt_ringbuffer * rb, uint8_t * ptr, uint16_t length);
RINGBUFFER_STATE rt_ringbuffer_status(rt_ringbuffer * rb);
void runtime_exit(runtime_base_t * runtime);
void runtime_init(runtime_base_t * runtime);
char * s_hexdump(void * _a, uint32_t a_len);
int save_freq_PIC16F1704(uint which_chain, uchar which_i2c, ushort freq);
void secure_zero_memory(void * v, size_t n);
int send_data_to_PIC16F1704(uint which_i2c, uchar which_chain, uchar * buf);
void set_BC_command_buffer(uint * value);
void set_BC_write_command(uint value);
int set_PIC16F1704_flash_pointer(uint which_i2c, uchar which_chain, uchar flash_addr_h, uchar flash_addr_l);
int set_PIC16F1704_voltage(uint which_chain, uchar which_i2c, uchar voltage);
void set_PIC16F1704_voltage_z9(uint32_t i2c, uint8_t chain, uint16_t vol);
void set_asic_address(runtime_base_t * runtime, uchar chainid);
void set_blocking_mode(int fd, int block);
void set_fan_speed(uint speed);
void set_fpga_baud(uchar asic_baud);
void set_temperature_offset_value(uint which_i2c, uchar which_chain, uchar * value);
void sha2(uchar * input, int ilen, uchar * output);
void sha256(uchar * message, uint len, uchar * digest);
void sha256_final(sha256_ctx * ctx, uchar * digest);
void sha256_init(sha256_ctx * ctx);
void sha256_transf(sha256_ctx * ctx, uchar * message, uint block_nb);
void sha256_update(sha256_ctx * ctx, uchar * message, uint len);
void sha2_finish(sha2_context * ctx, uchar * output);
void sha2_process(sha2_context * ctx, uchar * data);
void sha2_starts(sha2_context * ctx);
void sha2_update(sha2_context * ctx, uchar * input, int ilen);
void show_result(void);
void * show_stats_func_z15_3chips(void);
int singleBoardTest_Z15_BM1746(void);
void singleboard_pattern_test(void);
int sortValidator(void * data, uchar * soln);
void sort_pair(uint32_t * a, uint32_t len);
void start_read_temp(void);
void start_single_board_test(void);
void stop_read_temp(void);
void store32(void * dst, uint32_t w);
void store64(void * dst, uint64_t w);
void swab256(void * dest_p, void * src_p);
uint32_t swab32(uint32_t v);
uchar swap_bit(uchar chr);
uint32_t targetValidator(uint8_t * work, uint8_t * nonce, uint8_t * target);
uint32_t target_zero_cal(uint8_t * target);
int uart_exit(int fd);
int uart_init(int comport, int baud);
uint uart_receive(uchar which_uart, uchar * buf, uint buf_length);
uint uart_send(uchar which_uart, uchar * buf, uint length);
int user_asic_init(runtime_base_t * runtime);
int user_check_communication(runtime_base_t * runtime);
void user_i2c_enable(runtime_base_t * runtime, uchar chainid);
int user_i2c_state(runtime_base_t * runtime, int chip_addr);
int user_read_iic(runtime_base_t * runtime, int chip_addr, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, uint8_t * i2c_reg_data, int len);
void user_send_work(runtime_base_t * runtime, uint8_t * header, int sno_valid, int test_patten);
int v9_key_read(char * command, int len);
int vol_init(ushort vol);
void work_list_exit(void);
void work_list_find(uint8_t workid, uint8_t * work);
void work_list_init(int work_len);
void work_list_insert(uint8_t workid, uint8_t * work);
int write_PIC16F1705_iic_slave(uint which_i2c, uchar which_chain, uchar * buf, uchar buf_len);
void write_axi_fpga(uint address, uint data);
int write_data_into_PIC16F1704_flash(uint which_i2c, uchar which_chain);
int write_data_to_PIC16F1704_flash(int which_chain, int which_i2c, uchar * buf, int buf_len);
int write_dc_dc(void * args, uint8_t which_i2c, uint8_t i2c_dev_addr, uint8_t reg, uint8_t * data, int len);
int write_hash_ID_PIC16F1704(uint which_chain, uchar which_i2c, uchar * buf);
void write_lcd(uint line, char * buf, uint size);
void write_lcd_no_memset(uint line, char * buf, uint size);
void write_pic(uchar which_i2c, uchar which_chain, uchar data);
int write_temperature_offset_PIC16F1704(uint which_i2c, uchar which_chain, uchar * buf);
void zcashPerson(uint8_t * person, int n, int k);

#endif // SINGLE_BOARD_TEST_FA8CD07678327E02_DEBUG_TYPES_H
