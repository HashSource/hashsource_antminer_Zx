//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t i_a1, int32_t i_a2);
int32_t function_106e8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
void function_10708(void);
int32_t function_10714(int32_t i_a1);
int32_t function_10720(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
void function_1072c(void);
int32_t function_10738(struct _IO_FILE *stream);
int32_t *function_10744(int32_t *s, int32_t c, int32_t n);
int32_t function_10750(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6);
int32_t function_1075c(struct _IO_FILE *stream, int32_t off, int32_t whence);
int32_t function_10768(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10774(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4);
int32_t function_10780(char *s);
int32_t *function_1078c(int32_t *dest, int32_t *src, int32_t n);
struct _IO_FILE *function_10798(char *filename, char *modes);
int32_t function_107a4(int32_t i_a1, int32_t i_a2);
char *function_107b0(char *dest, char *src);
int32_t function_107bc(char *format, ...);
int32_t function_107c8(int32_t i_a1, int32_t i_a2);
int32_t function_107d4(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s);
int32_t function_107e0(int32_t ver, char *filename, struct stat64 *stat_buf);
int32_t function_107f0(char *s);
int32_t function_107fc(int32_t i_a1);
int32_t function_10808(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4);
int32_t function_10814(int32_t i_a1);
int32_t function_10820(int32_t *p_a1);
int32_t function_1082c(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *stream);
int32_t function_1085c(int32_t i_a1);
int32_t function_10868(void);
int32_t function_1088c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4);
int32_t function_108dc(void);
int32_t function_108f4(int32_t i_a1);
int32_t function_109a8(int32_t *p_a1);
int32_t function_10b9c(void);
int32_t function_10c70(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);
int32_t function_10de8(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4,
                       uint32_t i_a5, uint32_t i_a6);
int32_t function_11460(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       uint32_t i_a4, uint32_t i_a5, uint32_t i_a6);
int32_t function_11ec4(uint32_t i_a1, int32_t i_a2);
int32_t function_12230(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_1226c(void);
int32_t function_12270(int32_t i_a1, int32_t *p_a2);
int32_t function_12274(void);
int32_t function_1227c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = -0x1cae0000; // 0x10878
int32_t i_g2 = 0x108f5;     // 0x22f08
int32_t i_g3 = 256;         // 0x2307c
char *p_g4;                 // 0x23838
uint32_t i_g5;
int32_t i_g6;
int32_t i_g7;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t __xstat64(int32_t i_a1, char *p_a2, struct stat64 *p_a3);
int32_t BIO_free(int32_t i_a1);
int32_t BIO_new_mem_buf(int32_t i_a1, int32_t i_a2);
int32_t ERR_error_string(int32_t i_a1, int32_t i_a2);
int32_t ERR_get_error(int32_t i_a1);
struct _IO_FILE *fopen64(char *p_a1, char *p_a2);
int32_t PEM_read_bio_RSA_PUBKEY(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                int32_t i_a4);
int32_t RSA_free(int32_t i_a1);
int32_t RSA_verify(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                   int32_t i_a5, int32_t i_a6);
int32_t SHA256_Final(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                     int32_t *p_a4);
int32_t SHA256_Init(int32_t *p_a1);
int32_t SHA256_Update(int32_t *p_a1, int32_t i_a2, int32_t i_a3, int32_t *p_a4);

// ------------------------ Functions -------------------------

// Address range: 0x106e8 - 0x106f4
int32_t function_106e8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x106e8
    return function_10868();
}

// Address range: 0x10708 - 0x10714
void function_10708(void) {
    // 0x10708
    abort();
}

// Address range: 0x10714 - 0x10720
int32_t function_10714(int32_t i_a1) {
    // 0x10714
    return ERR_get_error(i_a1);
}

// Address range: 0x10720 - 0x1072c
int32_t function_10720(int32_t main, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10720
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x1072c - 0x10738
void function_1072c(void) {
    // 0x1072c
    __gmon_start__();
}

// Address range: 0x10738 - 0x10744
int32_t function_10738(struct _IO_FILE *stream) {
    // 0x10738
    return fclose(stream);
}

// Address range: 0x10744 - 0x10750
int32_t *function_10744(int32_t *s, int32_t c, int32_t n) {
    // 0x10744
    return memset(s, c, n);
}

// Address range: 0x10750 - 0x1075c
int32_t function_10750(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5, int32_t i_a6) {
    // 0x10750
    return RSA_verify(i_a1, p_a2, i_a3, i_a4, i_a5, i_a6);
}

// Address range: 0x1075c - 0x10768
int32_t function_1075c(struct _IO_FILE *stream, int32_t off, int32_t whence) {
    // 0x1075c
    return fseek(stream, off, whence);
}

// Address range: 0x10768 - 0x10774
int32_t function_10768(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10768
    return PEM_read_bio_RSA_PUBKEY(i_a1, i_a2, i_a3, i_a4);
}

// Address range: 0x10774 - 0x10780
int32_t function_10774(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       int32_t *p_a4) {
    // 0x10774
    return SHA256_Final(p_a1, p_a2, p_a3, p_a4);
}

// Address range: 0x10780 - 0x1078c
int32_t function_10780(char *s) {
    // 0x10780
    return strlen(s);
}

// Address range: 0x1078c - 0x10798
int32_t *function_1078c(int32_t *dest, int32_t *src, int32_t n) {
    // 0x1078c
    return memcpy(dest, src, n);
}

// Address range: 0x10798 - 0x107a4
struct _IO_FILE *function_10798(char *filename, char *modes) {
    // 0x10798
    return fopen64(filename, modes);
}

// Address range: 0x107a4 - 0x107b0
int32_t function_107a4(int32_t i_a1, int32_t i_a2) {
    // 0x107a4
    return BIO_new_mem_buf(i_a1, i_a2);
}

// Address range: 0x107b0 - 0x107bc
char *function_107b0(char *dest, char *src) {
    // 0x107b0
    return strcpy(dest, src);
}

// Address range: 0x107bc - 0x107c8
int32_t function_107bc(char *format, ...) {
    // 0x107bc
    return printf(format);
}

// Address range: 0x107c8 - 0x107d4
int32_t function_107c8(int32_t i_a1, int32_t i_a2) {
    // 0x107c8
    return ERR_error_string(i_a1, i_a2);
}

// Address range: 0x107d4 - 0x107e0
int32_t function_107d4(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *s) {
    // 0x107d4
    return fwrite(ptr, size, n, s);
}

// Address range: 0x107e0 - 0x107f0
int32_t function_107e0(int32_t ver, char *filename, struct stat64 *stat_buf) {
    // 0x107e0
    return __xstat64(ver, filename, stat_buf);
}

// Address range: 0x107f0 - 0x107fc
int32_t function_107f0(char *s) {
    // 0x107f0
    return puts(s);
}

// Address range: 0x107fc - 0x10808
int32_t function_107fc(int32_t i_a1) {
    // 0x107fc
    return RSA_free(i_a1);
}

// Address range: 0x10808 - 0x10814
int32_t function_10808(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    // 0x10808
    return SHA256_Update(p_a1, i_a2, i_a3, p_a4);
}

// Address range: 0x10814 - 0x10820
int32_t function_10814(int32_t i_a1) {
    // 0x10814
    return BIO_free(i_a1);
}

// Address range: 0x10820 - 0x1082c
int32_t function_10820(int32_t *p_a1) {
    // 0x10820
    return SHA256_Init(p_a1);
}

// Address range: 0x1082c - 0x10838
int32_t function_1082c(int32_t *ptr, int32_t size, int32_t n,
                       struct _IO_FILE *stream) {
    // 0x1082c
    return fread(ptr, size, n, stream);
}

// Address range: 0x10838 - 0x1085c
int32_t entry_point(int32_t i_a1, int32_t i_a2) {
    // 0x10838
    int32_t i_v1; // 0x10838
    __libc_start_main(0x11ec4, i_a2, (char **)&i_v1, (void (*)())0x12231,
                      (void (*)())0x11ec4, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x1085c - 0x10860
int32_t function_1085c(int32_t i_a1) {
    // 0x1085c
    return i_a1;
}

// Address range: 0x10868 - 0x10884
int32_t function_10868(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g1 + (int32_t) "ent:%x\n" + 112); // 0x10874
    if (i_v1 == 0) {
        int32_t i_v2; // 0x10868
        return i_v2;
    }
    // 0x10880
    __gmon_start__();
    return &i_g7;
}

// Address range: 0x1088c - 0x108dc
int32_t function_1088c(int32_t i_a1, int32_t i_a2, int32_t i_a3, char i_a4) {
    // 0x1088c
    int32_t i_v1; // 0x1088c
    int32_t i_v2 = i_v1;
    bool i_v3; // 0x1088c
    if (i_v3) {
        return i_a1;
    }
    bool i_v4; // 0x1088c
    if (!i_v3) {
        int32_t i_v5 = 0x100001 * i_v2 & -1 - 0x400000 * i_v2; // 0x108c4
        i_v4 = i_v5 < 0;
        if (i_v5 == 0) {
            return unknown_240();
        }
    }
    // 0x108d4
    if (i_v4 != i_v3) {
        __asm_svclt(0x4770);
    }
    return i_a1;
}

// Address range: 0x108dc - 0x108f4
int32_t function_108dc(void) {
    // 0x108dc
    int32_t i_v1; // 0x108dc
    if (*(char *)&p_g4 == 0) {
        // 0x108ea
        int32_t i_v2;                                       // 0x108dc
        int32_t i_v3 = function_1088c(i_v2, i_v2, i_v2, 0); // 0x108ea
        *(char *)&p_g4 = 1;
        i_v1 = i_v3;
    }
    // 0x108f2
    return i_v1;
}

// Address range: 0x108f4 - 0x109a8
int32_t function_108f4(int32_t i_a1) {
    puts("Useage:\r");
    printf("\t%s [option] [paramaters]\n\n", (char *)i_a1);
    puts("\tOption:{-f} {-s} {-p} {-n} {-x} {-q}\n");
    puts("\t\t-f [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tOnly "
         "Check If Filename was Valided.\n");
    puts("\t\t-s [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was Valided, and Splite Bmu To \"/tmp/tmpfw/\"\n");
    puts("\t\t-p [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was Valided, and Dump BmuComments\n");
    puts("\t\t-x [minerType] [fileName] [rootPublicKeyFile]: \n\t\t\tCheck If "
         "Filename Was FullSize BMU\n");
    puts("\t\t-n [nandBinFile]: \n\t\t\tSplite SigImg To Single File To "
         "\"/tmp/tmpNand/\"\n");
    puts("\t\t-q: \n\t\t\tGenerate A 256Bytes 0xff File To \"/tmp/256BFF\"\n");
    puts("\tReturns:");
    puts("\t\t0: \n\t\t\tWell Done!\n");
    return __asm_nop(puts("\t\tOthers: \n\t\t\tSomething Wrong!\n"));
}

// Address range: 0x109a8 - 0x10b9c
int32_t function_109a8(int32_t *p_a1) {
    int32_t i_v1 = 0; // bp-32788, 0x109d0
    int32_t i_v2;     // bp-32784, 0x109a8
    memset(&i_v2, 0, 0x7ffc);
    struct _IO_FILE *p_v3 = fopen64((char *)p_a1, "rb"); // 0x109fc
    int32_t i_v4 = 0;                                    // 0x10a0c
    if (p_v3 == NULL) {
        // 0x10a10
        puts("Load Nand Image File Failed!");
        // 0x10b90
        return 1;
    }
    int32_t i_v5 = 132 * i_v4;                          // 0x10a50
    int32_t *p_v6 = (int32_t *)(i_v5 + (int32_t)&i_g3); // 0x10a58
    fread(&i_v1, *p_v6, 1, p_v3);
    char *p_v7 = (char *)(i_v5 + (int32_t)&i_g3 + 4); // 0x10aa4
    struct _IO_FILE *p_v8 = fopen64(p_v7, "wb");      // 0x10aa4
    int32_t i_v9;                                     // 0x109a8
    while (p_v8 != NULL) {
        // 0x10b08
        fwrite(&i_v1, *p_v6, 1, p_v8);
        fclose(p_v8);
        i_v4++;
        if (i_v4 >= 15) {
            // 0x10b84
            fclose(p_v3);
            i_v9 = 0;
            return i_v9;
        }
        i_v5 = 132 * i_v4;
        p_v6 = (int32_t *)(i_v5 + (int32_t)&i_g3);
        fread(&i_v1, *p_v6, 1, p_v3);
        p_v7 = (char *)(i_v5 + (int32_t)&i_g3 + 4);
        p_v8 = fopen64(p_v7, "wb");
    }
    // 0x10ab8
    printf("Try To Write To File '%s' Failed!\n", p_v7);
    fclose(p_v3);
    i_v9 = 2;
lab_0x10b90:
    // 0x10b90
    return i_v9;
}

// Address range: 0x10b9c - 0x10c70
int32_t function_10b9c(void) {
    struct _IO_FILE *p_v1 = fopen64("/tmp/256BFF", "wb"); // 0x10bb8
    if (p_v1 == NULL) {
        // 0x10bcc
        puts("GenFile Failed!");
        // 0x10c64
        return 1;
    }
    int32_t i_v2 = 0; // bp-272, 0x10be4
    int32_t i_v3;     // bp-268, 0x10b9c
    memset(&i_v3, 0, 252);
    for (int32_t i_v4 = 0; i_v4 < 256; i_v4++) {
        // 0x10c10
        *(char *)(i_v4 + (int32_t)&i_v2) = -1;
    }
    // 0x10c3c
    fwrite(&i_v2, 256, 1, p_v1);
    fclose(p_v1);
    // 0x10c64
    return 0;
}

// Address range: 0x10c70 - 0x10de8
int32_t function_10c70(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                       int32_t *p_a4) {
    int32_t i_v1 = BIO_new_mem_buf((int32_t)p_a4, 1024);   // 0x10ca4
    int32_t i_v2 = PEM_read_bio_RSA_PUBKEY(i_v1, 0, 0, 0); // 0x10cbc
    if (i_v2 == 0) {
        // 0x10cd0
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(0), 0));
        puts("Read Root PubK Failed!");
        // 0x10ddc
        return 12;
    }
    // 0x10d0c
    int32_t i_v3; // bp-164, 0x10c70
    SHA256_Init(&i_v3);
    SHA256_Update(&i_v3, i_a1, i_a2, &i_v3);
    int32_t i_v4; // bp-52, 0x10c70
    SHA256_Final(&i_v4, &i_v3, &i_v3, &i_v4);
    int32_t i_v5 = RSA_verify(672, &i_v4, 32, i_a3, 256, i_v2); // 0x10d60
    int32_t i_v6 = RSA_free(i_v2);                              // 0x10d84
    if (i_v1 != 0) {
        // 0x10d88
        i_v6 = BIO_free(i_v1);
    }
    int32_t i_v7 = 0; // 0x10d98
    if (i_v5 != 1) {
        // 0x10da4
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(i_v6), 0));
        puts("Check miner.pem Failed!");
        i_v7 = 13;
    }
    // 0x10ddc
    return i_v7;
}

// Address range: 0x10de8 - 0x11460
int32_t function_10de8(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4,
                       uint32_t i_a5, uint32_t i_a6) {
    int32_t i_v1 = 0; // bp-1044, 0x10e08
    int32_t i_v2;     // bp-1040, 0x10de8
    memset(&i_v2, 0, 1020);
    int32_t i_v3; // bp-1156, 0x10de8
    SHA256_Init(&i_v3);
    struct _IO_FILE *p_v4 = NULL; // 0x10e5c
    if (i_a6 % 256 != 0) {
        char *p_v5 = (char *)0x706d742f; // bp-1316, 0x10e78
        int32_t i_v6;                    // bp-1304, 0x10de8
        memset(&i_v6, 0, 116);
        i_g5 = i_a4 % 256;
        switch ((char)i_a4) {
        case 0: {
            int32_t i_v7 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10ef4
            *(int32_t *)i_v7 = 0x544f4f42;
            *(int32_t *)(i_v7 + 4) = 0x6e69622e;
            *(char *)(i_v7 + 8) = 0;
            // break -> 0x111b4
            break;
        }
        case 1: {
            int32_t i_v8 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10f40
            *(int32_t *)i_v8 = 0x69766564;
            *(int32_t *)(i_v8 + 4) = 0x72746563;
            *(int32_t *)(i_v8 + 8) = 0x642e6565;
            *(int16_t *)(i_v8 + 12) = 0x6274;
            *(char *)(i_v8 + 14) = 0;
            // break -> 0x111b4
            break;
        }
        case 2: {
            int32_t i_v9 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10f9c
            *(int32_t *)i_v9 = 0x616d4975;
            *(int16_t *)(i_v9 + 4) = 0x6567;
            *(char *)(i_v9 + 6) = 0;
            // break -> 0x111b4
            break;
        }
        case 3: {
            int32_t i_v10 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x10fec
            *(int32_t *)i_v10 = 0x656e696d;
            *(int32_t *)(i_v10 + 4) = 0x2e736672;
            *(int32_t *)(i_v10 + 8) = 0x67616d69;
            *(int32_t *)(i_v10 + 12) = 0x7a672e65;
            *(char *)(i_v10 + 16) = 0;
            // break -> 0x111b4
            break;
        }
        case 4: {
            int32_t i_v11 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x11048
            *(int32_t *)i_v11 = 0x61647075;
            *(int32_t *)(i_v11 + 4) = 0x692e6574;
            *(int32_t *)(i_v11 + 8) = 0x6567616d;
            *(int32_t *)(i_v11 + 12) = 0x7a672e;
            // break -> 0x111b4
            break;
        }
        case 5: {
            int32_t i_v12 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x1109c
            *(int32_t *)i_v12 = 0x2e6c7263;
            *(int32_t *)(i_v12 + 4) = 0x2e726174;
            *(int16_t *)(i_v12 + 8) = 0x7a67;
            *(char *)(i_v12 + 10) = 0;
            // break -> 0x111b4
            break;
        }
        case 6: {
            int32_t i_v13 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x110f0
            *(int32_t *)i_v13 = 0x656e696d;
            *(int32_t *)(i_v13 + 4) = 0x74622e72;
            *(int32_t *)(i_v13 + 8) = 0x61742e6d;
            *(int32_t *)(i_v13 + 12) = 0x7a672e72;
            *(char *)(i_v13 + 16) = 0;
            // break -> 0x111b4
            break;
        }
        case 7: {
            int32_t i_v14 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x1114c
            *(int32_t *)i_v14 = 0x65736572;
            *(int32_t *)(i_v14 + 4) = 0x657672;
            // break -> 0x111b4
            break;
        }
        case 9: {
            int32_t i_v15 = strlen((char *)&p_v5) + (int32_t)&p_v5; // 0x11190
            *(int32_t *)i_v15 = 0x61746164;
            *(int32_t *)(i_v15 + 4) = 0x656c6966;
            *(char *)(i_v15 + 8) = 0;
            __asm_nop(0x61746164);
            // break -> 0x111b4
            break;
        }
        default: {
            // break -> 0x111b4
            break;
        }
        }
        char *p_v16 = (char *)&p_v5;
        if (i_a5 % 256 != 0) {
            int32_t i_v17 = strlen(p_v16) + (int32_t)&p_v5; // 0x111e8
            *(int32_t *)i_v17 = 0x6769732e;
            *(char *)(i_v17 + 4) = 0;
        }
        // 0x11204
        printf("fileName:'%s', size:[%d]\r\n", &p_v5, i_a2);
        struct _IO_FILE *p_v18 = fopen64(p_v16, "wb"); // 0x1123c
        p_v4 = p_v18;
        if (p_v18 == NULL) {
            // 0x11250
            printf("Create File '%s' Failed!\r\n", &p_v5);
            p_v4 = NULL;
        }
    }
    struct _IO_FILE *p_v19 = (struct _IO_FILE *)i_a1;
    int32_t i_v20 = &i_v1;
    int32_t i_v21 = i_a2; // 0x1130c
    if (i_a2 >= 1024 == (i_a2 != 1024)) {
        int32_t i_v22 = 0;                            // 0x1129c
        int32_t i_v23 = fread(&i_v1, 1, 1024, p_v19); // 0x11288
        SHA256_Update(&i_v3, i_v20, 1024, &i_v3);
        if (i_a6 % 256 != 0 && p_v4 != NULL) {
            // 0x112e0
            fwrite(&i_v1, 1, 1024, p_v4);
        }
        // 0x112fc
        i_v22 += i_v23;
        int32_t i_v24 = i_a2 - i_v22; // 0x11304
        i_v21 = i_v24;
        while (i_v24 >= 1024 == (i_v24 != 1024)) {
            // 0x11270
            i_v23 = fread(&i_v1, 1, 1024, p_v19);
            SHA256_Update(&i_v3, i_v20, 1024, &i_v3);
            if (i_a6 % 256 != 0 && p_v4 != NULL) {
                // 0x112e0
                fwrite(&i_v1, 1, 1024, p_v4);
            }
            // 0x112fc
            i_v22 += i_v23;
            i_v24 = i_a2 - i_v22;
            i_v21 = i_v24;
        }
    }
    int32_t i_v25 = fread(&i_v1, 1, i_v21, p_v19); // 0x11330
    SHA256_Update(&i_v3, i_v20, i_v25, &i_v3);
    int32_t i_v26; // bp-1188, 0x10de8
    if (i_a6 % 256 == 0 || p_v4 == NULL) {
        // 0x11394
        i_v26 = 0;
        SHA256_Final(&i_v26, &i_v3, &i_v3, &i_v26);
    } else {
        // 0x11404
        fwrite(&i_v1, 1, i_v25, p_v4);
        i_v26 = 0;
        SHA256_Final(&i_v26, &i_v3, &i_v3, &i_v26);
        fclose(p_v4);
    }
    // 0x11414
    *(int32_t *)i_a3 = i_v26;
    *(int32_t *)(i_a3 + 4) = 0;
    *(int32_t *)(i_a3 + 8) = 0;
    *(int32_t *)(i_a3 + 12) = 0;
    *(int32_t *)(i_a3 + 16) = 0;
    *(int32_t *)(i_a3 + 20) = 0;
    *(int32_t *)(i_a3 + 24) = 0;
    *(int32_t *)(i_a3 + 28) = 0;
    __asm_nop(0);
    return 0;
}

// Address range: 0x11460 - 0x11ec4
int32_t function_11460(int32_t *p_a1, int32_t *p_a2, int32_t *p_a3,
                       uint32_t i_a4, uint32_t i_a5, uint32_t i_a6) {
    // 0x11460
    int32_t i_v1; // bp-192, 0x11460
    function_12270((int32_t)p_a1, &i_v1);
    int64_t i_v2;                                  // 0x11460
    uint32_t i_v3 = (int32_t)(i_v2 / 0x100000000); // 0x11490
    if (i_v3 <= 2047) {
        // 0x114a8
        printf("File '%s' Not Enough %d, Something Wrong!\n", p_a1, 2048);
        // 0x11eb8
        return 6;
    }
    struct _IO_FILE *p_v4 = fopen64((char *)p_a1, "rb"); // 0x114d0
    if (p_v4 == NULL) {
        // 0x114e4
        printf("Read File '%s' Failed!\n", p_a1);
        // 0x11eb8
        return 7;
    }
    // 0x114fc
    fread(p_a3, 2048, 1, p_v4);
    int32_t i_v5; // 0x11460
    if ((char)i_v5 != 38) {
        // 0x11520
        printf("'%s' Not A Btmu File!\n", p_a1);
        fclose(p_v4);
        // 0x11eb8
        return 8;
    }
    int32_t i_v6 = (int32_t)p_a3;
    int32_t i_v7 = __asm_sxth(256 * (int32_t) * (char *)(i_v6 + 11)); // 0x11560
    uint32_t i_v8 = __asm_sxth(__asm_sxth((int32_t) * (char *)(i_v6 + 12)) |
                               i_v7); // 0x11574
    int32_t i_v9;                     // 0x11460
    if (i_a6 % 256 == 0) {
        // 0x1154c
        i_v9 = i_v8 % 0x10000;
    } else {
        int32_t i_v10 = i_v8 % 0x10000;
        printf("content:%x\n", i_v10);
        i_v9 = i_v10;
        if ((int16_t)i_v8 <= 0xfdff) {
            // 0x115ac
            puts("This Package Was Not Full Package!");
            // 0x11eb8
            return 20;
        }
    }
    uint32_t i_v11 = i_a4 % 256;
    unsigned char i_v12 = 0;
    for (int32_t i_v13 = 0; i_v13 < 16; i_v13++) {
        // 0x115cc
        i_v12 += (char)((1 << i_v13 & i_v9) != 0);
    }
    unsigned char i_v14 = *(char *)(i_v6 + 1304); // 0x1160c
    int32_t i_v15 = i_v14;
    if (i_v12 != i_v14) {
        // 0x1161c
        printf("Content Doesn't Match![%d][%d]\n", i_v15, (int32_t)i_v12);
        fclose(p_v4);
        // 0x11eb8
        return 9;
    }
    int32_t i_v16 = 256 * i_v15 + 2304;           // 0x11664
    unsigned char i_v17 = *(char *)(i_v6 + 1305); // 0x11670
    unsigned char i_v18 = *(char *)(i_v6 + 1306); // 0x1167c
    unsigned char i_v19 = *(char *)(i_v6 + 1307); // 0x1168c
    unsigned char i_v20 = *(char *)(i_v6 + 1308); // 0x1169c
    uint32_t i_v21 = (int32_t)i_v12;              // 0x1178c
    int32_t i_v22 = 0;                            // 0x11798
    int32_t i_v23 = i_v16;                        // 0x11798
    int32_t i_v24 = i_v16;                        // 0x11798
    if (i_v12 != 0) {
        int32_t i_v25 = 5 * i_v22 + i_v6;              // 0x116c8
        unsigned char i_v26 = *(char *)(i_v25 + 1310); // 0x116d4
        unsigned char i_v27 = *(char *)(i_v25 + 1311); // 0x116fc
        unsigned char i_v28 = *(char *)(i_v25 + 1312); // 0x11724
        unsigned char i_v29 = *(char *)(i_v25 + 1313); // 0x11750
        int32_t i_v30 = 0x10000 * (int32_t)i_v27 | 0x1000000 * (int32_t)i_v26 |
                        256 * (int32_t)i_v28 | (int32_t)i_v29; // 0x11754
        i_v23 += i_v30;
        printf("file[%d] size:[%d]\n", i_v22, i_v30);
        i_v22++;
        i_v24 = i_v23;
        while (i_v22 < i_v21) {
            // 0x116b4
            i_v25 = 5 * i_v22 + i_v6;
            i_v26 = *(char *)(i_v25 + 1310);
            i_v27 = *(char *)(i_v25 + 1311);
            i_v28 = *(char *)(i_v25 + 1312);
            i_v29 = *(char *)(i_v25 + 1313);
            i_v30 = 0x10000 * (int32_t)i_v27 | 0x1000000 * (int32_t)i_v26 |
                    256 * (int32_t)i_v28 | (int32_t)i_v29;
            i_v23 += i_v30;
            printf("file[%d] size:[%d]\n", i_v22, i_v30);
            i_v22++;
            i_v24 = i_v23;
        }
    }
    // 0x1179c
    if (i_v24 != i_v3) {
        // 0x117ac
        printf("Check FileSize Failed, FileSize Should Be [%d]Bytes, But It "
               "Was [%d] Bytes, And Total Says[%d]\n",
               0x10000 * (int32_t)i_v18 | 0x1000000 * (int32_t)i_v17 |
                   256 * (int32_t)i_v19 | (int32_t)i_v20,
               i_v3, i_v24);
        fclose(p_v4);
        // 0x11eb8
        return 10;
    }
    struct _IO_FILE *p_v31 = fopen64((char *)p_a2, "r"); // 0x117ec
    if (p_v31 == NULL) {
        // 0x11800
        printf("Cannot Open Root PublicKey '%s'!\n", p_a2);
        fclose(p_v4);
        // 0x11eb8
        return 11;
    }
    int32_t i_v32 = 0; // bp-1216, 0x11830
    int32_t i_v33;     // bp-1212, 0x11460
    memset(&i_v33, 0, 1020);
    fread(&i_v32, 1024, 1, p_v31);
    fclose(p_v31);
    unsigned char i_v34 = *(char *)(i_v6 + 23); // 0x1188c
    int32_t i_v35 =
        256 * (int32_t) * (char *)(i_v6 + 22) | (int32_t)i_v34;  // 0x11890
    int32_t i_v36 = i_v6 + 24;                                   // 0x1189c
    int32_t i_v37 = i_v6 + 1048;                                 // 0x118ac
    int32_t i_v38 = function_10c70(i_v36, i_v35, i_v37, &i_v32); // 0x118bc
    if (i_v38 != 0) {
        // 0x118d0
        printf("Check pem payload failed! ret:[%d]\n", i_v38);
        fclose(p_v4);
        // 0x11eb8
        return i_v38;
    }
    if (i_v11 != 0) {
        struct _IO_FILE *p_v39 =
            fopen64("/tmp/tmpfw/miner.pem", "w"); // 0x11918
        if (p_v39 == NULL) {
            // 0x11974
            puts("Dump Miner.pem Failed!\r");
            // 0x11eb8
            return 15;
        }
        // 0x1192c
        fwrite((int32_t *)i_v36, 1, i_v35, p_v39);
        fclose(p_v39);
        struct _IO_FILE *p_v40 =
            fopen64("/tmp/tmpfw/miner.pem.sig", "w"); // 0x1195c
        if (p_v40 == NULL) {
            // 0x119b0
            puts("Dump Miner.pem.sig Failed!\r");
            // 0x11eb8
            return 16;
        }
        // 0x11988
        fwrite((int32_t *)i_v37, 1, 256, p_v40);
        fclose(p_v40);
    }
    // 0x119c4
    int32_t i_v41; // bp-2272, 0x11460
    memset(&i_v41, 0, 1056);
    int32_t i_v42; // bp-2384, 0x11460
    SHA256_Init(&i_v42);
    SHA256_Update(&i_v42, i_v6, 2048, &i_v42);
    SHA256_Final(&i_v41, &i_v42, &i_v42, &i_v41);
    int32_t i_v43 = &i_v41;
    if (i_v12 != 0) {
        int32_t i_v44 = i_v43 + 32;    // 0x11af4
        int32_t i_v45 = (int32_t)p_v4; // 0x11b48
        for (int32_t i_v46 = 0; i_v46 < i_v21; i_v46++) {
            int32_t i_v47 = 5 * i_v46 + i_v6;              // 0x11a54
            unsigned char i_v48 = *(char *)(i_v47 + 1310); // 0x11a60
            unsigned char i_v49 = *(char *)(i_v47 + 1311); // 0x11a88
            unsigned char i_v50 = *(char *)(i_v47 + 1312); // 0x11ab0
            unsigned char i_v51 = *(char *)(i_v47 + 1313); // 0x11adc
            unsigned char i_v52 = *(char *)(i_v47 + 1309); // 0x11b28
            function_10de8(i_v45,
                           0x10000 * (int32_t)i_v49 |
                               0x1000000 * (int32_t)i_v48 |
                               256 * (int32_t)i_v50 | (int32_t)i_v51,
                           i_v44 + 32 * i_v46, (int32_t)i_v52, 0, i_v11);
        }
        int32_t i_v53 = 0;
        int32_t i_v54 = i_v53 + 1;
        unsigned char i_v55 = *(char *)(i_v6 + 1309 + 5 * i_v53); // 0x11bbc
        function_10de8(i_v45, 256, 32 * (i_v54 + i_v21) + i_v43, (int32_t)i_v55,
                       1, i_v11);
        while (i_v54 < i_v21) {
            // 0x11b78
            i_v53 = i_v54;
            i_v54 = i_v53 + 1;
            i_v55 = *(char *)(i_v6 + 1309 + 5 * i_v53);
            function_10de8(i_v45, 256, 32 * (i_v54 + i_v21) + i_v43,
                           (int32_t)i_v55, 1, i_v11);
        }
    }
    int32_t i_v56 = 0; // bp-2640, 0x11c04
    int32_t i_v57;     // bp-2636, 0x11460
    memset(&i_v57, 0, 252);
    fseek(p_v4, -256, SEEK_END);
    fread(&i_v56, 256, 1, p_v4);
    int32_t i_v58 = 0; // bp-2672, 0x11c54
    int32_t i_v59;     // bp-2784, 0x11460
    SHA256_Init(&i_v59);
    SHA256_Update(&i_v59, i_v43, 64 * i_v21 | 32, &i_v59);
    SHA256_Final(&i_v58, &i_v59, &i_v59, &i_v58);
    int32_t i_v60 = BIO_new_mem_buf(i_v36, 1024);            // 0x11d0c
    int32_t i_v61 = PEM_read_bio_RSA_PUBKEY(i_v60, 0, 0, 0); // 0x11d24
    if (i_v61 == 0) {
        // 0x11d38
        printf("OpenSSL error: %s\n",
               (char *)ERR_error_string(ERR_get_error(0), 0));
        puts("Load Pem Failed!");
        // 0x11eb8
        return 17;
    }
    int32_t i_v62 =
        RSA_verify(672, &i_v58, 32, (int32_t)&i_v56, 256, i_v61); // 0x11da4
    RSA_free(i_v61);
    if (i_v60 != 0) {
        // 0x11dcc
        BIO_free(i_v60);
    }
    if (i_v62 != 1) {
        int32_t i_v63 =
            ERR_get_error(puts("Check File Sig failed!\r")); // 0x11dec
        printf("OpenSSL error: %s\n", (char *)ERR_error_string(i_v63, 0));
        // 0x11eb8
        return 18;
    }
    // 0x11e28
    fclose(p_v4);
    puts("All Done!\r");
    if (i_a5 % 256 != 0) {
        // 0x11e50
        puts("This Comment Of This Package:");
        int32_t i_v64 = 0; // bp-3044, 0x11e60
        int32_t i_v65;     // bp-3040, 0x11460
        memset(&i_v65, 0, 253);
        memcpy(&i_v64, (int32_t *)(i_v6 + 1360), 256);
        puts((char *)&i_v64);
    }
    // 0x11eb8
    return 0;
}

// Address range: 0x11ec4 - 0x12230
int32_t function_11ec4(uint32_t i_a1, int32_t i_a2) {
    // 0x11ec4
    if (i_a1 <= 1) {
        // 0x12224
        return 1;
    }
    int32_t *p_v1 = (int32_t *)(i_a2 + 4); // 0x11f04
    if (*(char *)*p_v1 != 45) {
        // 0x12224
        return 2;
    }
    int32_t i_v2 = 0; // bp-144, 0x11f30
    int32_t i_v3;     // bp-140, 0x11ec4
    memset(&i_v3, 0, 124);
    int32_t i_v4 = 0; // bp-272, 0x11f4c
    int32_t i_v5;     // bp-268, 0x11ec4
    memset(&i_v5, 0, 124);
    int32_t i_v6; // bp-2320, 0x11ec4
    memset(&i_v6, 0, 2048);
    int32_t i_v7; // bp-2576, 0x11ec4
    memset(&i_v7, 0, 253);
    switch (i_a1) {
    case 5: {
        int32_t *p_v8 = (int32_t *)(i_a2 + 12); // 0x11fd0
        uint32_t i_v9 = strlen((char *)*p_v8);  // 0x11fd8
        if (i_v9 != 127 && i_v9 >= 127) {
            // 0x11fe8
            puts("fileName Too Long!");
            // 0x12224
            return 3;
        }
        // 0x11ffc
        strcpy((char *)&i_v2, (char *)*p_v8);
        int32_t *p_v10 = (int32_t *)(i_a2 + 16); // 0x12020
        uint32_t i_v11 = strlen((char *)*p_v10); // 0x12028
        if (i_v11 != 127 && i_v11 >= 127) {
            // 0x12038
            puts("pemName Too Long!");
            // 0x12224
            return 4;
        }
        // 0x1204c
        strcpy((char *)&i_v4, (char *)*p_v10);
    }
    case 2: {
    lab_0x120fc:;
        unsigned char i_v12 = *(char *)(*p_v1 + 1); // 0x12114
        i_g6 = (int32_t)i_v12 - 102;
        char i_v13 = 0;    // 0x12120
        char i_v14 = 1;    // 0x12120
        int32_t i_v15 = 0; // 0x12120
        int32_t i_v16 = 0; // 0x12120
        char i_v17 = 0;    // 0x12120
        char i_v18 = 0;    // 0x12120
        int32_t i_v19;     // 0x11ec4
        switch (i_v12) {
        case 120: {
            // 0x12190
            i_v13 = 1;
            i_v14 = 0;
            i_v15 = 1;
        }
        case 112: {
        lab_0x12190:
            // 0x12190
            i_v16 = i_v15;
            i_v17 = i_v14;
            i_v18 = i_v13;
        }
        case 102: {
            int32_t i_v20 =
                function_11460(&i_v2, &i_v4, &i_v6, i_v16, (int32_t)i_v17,
                               (int32_t)i_v18); // 0x121d0
            i_v19 = i_v20;
            // break -> 0x12224
            break;
        }
        case 115: {
            // 0x12190
            i_v13 = 0;
            i_v14 = 0;
            i_v15 = 1;
            // branch (via goto) -> 0x12190
            goto lab_0x12190;
        }
        case 113: {
            // 0x121f0
            i_v19 = function_10b9c();
            // break -> 0x12224
            break;
        }
        case 110: {
            // 0x121dc
            i_v19 = function_109a8(&i_v2);
            // break -> 0x12224
            break;
        }
        default: {
            // 0x121fc
            puts("Command Not Support!");
            i_v19 = 5;
            // break -> 0x12224
            break;
        }
        }
        // 0x12224
        return i_v19;
    }
    case 3: {
        int32_t *p_v21 = (int32_t *)(i_a2 + 8);  // 0x12080
        uint32_t i_v22 = strlen((char *)*p_v21); // 0x12088
        if (i_v22 != 127 && i_v22 >= 127) {
            // 0x12098
            puts("fileName Too Long!");
            // 0x12224
            return 3;
        }
        // 0x120ac
        strcpy((char *)&i_v2, (char *)*p_v21);
        // branch (via goto) -> 0x120fc
        goto lab_0x120fc;
    }
    default: {
        // 0x120d8
        puts("Param Err!");
        // 0x12224
        return 3;
    }
    }
}

// Address range: 0x12230 - 0x12264
int32_t function_12230(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = function_106e8(i_a1, i_a2, i_a3, i_a4); // 0x12240
    return 0x22f0a - (int32_t)&i_g2 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x1226c - 0x1226e
int32_t function_1226c(void) {
    // 0x1226c
    int32_t i_v1; // 0x1226c
    return i_v1;
}

// Address range: 0x12270 - 0x12274
int32_t function_12270(int32_t i_a1, int32_t *p_a2) {
    // 0x12270
    return i_a1;
}

// Address range: 0x12274 - 0x1227a
int32_t function_12274(void) {
    // 0x12274
    int32_t i_v1; // 0x12274
    return __xstat64(3, (char *)i_v1, (struct stat64 *)i_v1);
}

// Address range: 0x1227c - 0x12284
int32_t function_1227c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x1227c
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 43
