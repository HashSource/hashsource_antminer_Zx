/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_AAD8();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int scrollok(WINDOW *, bool);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int open(const char *file, int oflag, ...);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// const __int32_t **_ctype_toupper_loc(void);
// int fileno(FILE *stream);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int nocbreak(void);
// struct tm *localtime(const time_t *timer);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// WINDOW *newwin(int, int, int, int);
// int sysconf(int name);
// void syslog(int pri, const char *fmt, ...);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int _xstat(int ver, const char *filename, struct stat *stat_buf);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int wmove(WINDOW *, int, int);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int _isinf(double value);
// int _gmon_start__(void); weak
// int echo(void);
// int sched_yield(void);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// in_addr_t inet_addr(const char *cp);
// int endwin(void);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// char *fgets(char *s, int n, FILE *stream);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// double strtod(const char *nptr, char **endptr);
// int system(const char *command);
// char *strchr(const char *s, int c);
// int putchar(int c);
// int strcasecmp(const char *s1, const char *s2);
// char *dirname(char *path);
// int leaveok(WINDOW *, bool);
// int listen(int fd, int n);
// void *calloc(size_t nmemb, size_t size);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// void *memset(void *s, int c, size_t n);
// int sem_destroy(sem_t *sem);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// void freeaddrinfo(struct addrinfo *ai);
// void perror(const char *s);
// int delwin(WINDOW *);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int werase(WINDOW *);
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// double exp(double x);
// WINDOW *initscr(void);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int usleep(__useconds_t useconds);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int wclrtoeol(WINDOW *);
// void free(void *ptr);
// ssize_t read(int fd, void *buf, size_t nbytes);
// ssize_t write(int fd, const void *buf, size_t n);
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int inet_pton(int af, const char *cp, void *buf);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sem_trywait(sem_t *sem);
// int fseek(FILE *stream, int off, int whence);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int tcgetattr(int fd, struct termios *termios_p);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int tcflush(int fd, int queue_selector);
// int round(void); weak
// int socket(int domain, int type, int protocol);
// int wtouchln(WINDOW *, int, int, int);
// int execl(const char *path, const char *arg, ...);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// int ioctl(int fd, unsigned int request, ...);
// void immedok(WINDOW *, bool);
// int isatty(int fd);
// int wrefresh(WINDOW *);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// int mvwprintw(WINDOW *, int, int, const char *, ...);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int execv(const char *path, char *const argv[]);
// int __fastcall lldiv(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int halfdelay(int);
// int pthread_cond_signal(pthread_cond_t *cond);
// const __int32_t **_ctype_tolower_loc(void);
// struct lconv *localeconv(void);
// int fgetc(FILE *stream);
// int strtol(const char *nptr, char **endptr, int base);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int cbreak(void);
// char *strncat(char *dest, const char *src, size_t n);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int printf(const char *format, ...);
// int raise(int sig);
// void errx(int status, const char *format, ...);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int shutdown(int fd, int how);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int wresize(WINDOW *, int, int);
// char *strstr(const char *haystack, const char *needle);
// int nice(int inc);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// int wgetch(WINDOW *);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int _isnan(double value);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int wprintw(WINDOW *, const char *, ...);
// time_t time(time_t *timer);
// double log10(double x);
// const unsigned __int16 **_ctype_b_loc(void);
// int fprintf(FILE *stream, const char *format, ...);
// void *malloc(size_t size);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int wgetnstr(WINDOW *, char *, int);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// unsigned int sleep(unsigned int seconds);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// char *strcat(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// void pthread_testcancel(void);
// int dup2(int fd, int fd2);
// int puts(const char *s);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int prctl(int option, ...);
// int fcntl(int fd, int cmd, ...);
// int flock(int fd, int operation);
// int idlok(WINDOW *, bool);
// __pid_t fork(void);
// int wattr_off(WINDOW *, attr_t, void *);
// __off_t lseek(int fd, __off_t offset, int whence);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// __int64 __fastcall llround(_DWORD); weak
// int whline(WINDOW *, chtype, int);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int strncmp(const char *s1, const char *s2, size_t n);
// int kill(__pid_t pid, int sig);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int wclear(WINDOW *);
// int pthread_detach(pthread_t th);
// void *realloc(void *ptr, size_t size);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
// char *_strdup(const char *s);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int noecho(void);
// char *strpbrk(const char *s, const char *accept);
// int sem_wait(sem_t *sem);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int pthread_setcanceltype(int type, int *oldtype);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int pthread_cancel(pthread_t th);
// int mvwin(WINDOW *, int, int);
// int wattr_on(WINDOW *, attr_t, void *);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
int __fastcall sub_B410(int a1);
void __noreturn sub_B498();
void __fastcall sub_B4D4(int a1, int a2, int a3, int a4, int a5);
void __fastcall __noreturn sub_B4E4(const char *a1, int a2);
void __fastcall sub_B53C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B550(const char *a1, int a2);
void __fastcall sub_B5A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B5BC(const char *a1, int a2);
void __fastcall sub_B614(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B628(const char *a1, int a2);
void __fastcall sub_B680(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B694(const char *a1, int a2);
void __fastcall sub_B6EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B700(const char *a1, int a2);
void __fastcall sub_B758(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B76C(const char *a1, int a2);
void __fastcall sub_B7C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B7D8(const char *a1, int a2);
void __fastcall sub_B830(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B844(const char *a1, int a2);
void __fastcall sub_B89C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B8B0(const char *a1, int a2);
void __fastcall sub_B908(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B91C(const char *a1, int a2);
void __fastcall sub_B974(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B988(int a1);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_F20C();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
int __fastcall sub_F308(_DWORD *a1);
int __fastcall sub_F318(_DWORD *a1);
int __fastcall sub_F328(_DWORD *a1);
int __fastcall sub_F338(_BYTE *a1);
int sub_F354();
int nullsub_2(); // weak
int nullsub_1(); // weak
int nullsub_3(); // weak
int sub_F368();
int sub_F370();
__int64 sub_F378();
int sub_F384();
int sub_F38C();
int nullsub_4(); // weak
int nullsub_5(); // weak
int nullsub_6(); // weak
int nullsub_7(); // weak
int sub_F3A4();
int __fastcall sub_F3B0(int a1, int a2);
_BYTE *__fastcall sub_F46C(const char *a1);
int __fastcall sub_F4F8(int a1);
int __fastcall sub_F510(int a1);
int __fastcall sub_F528(int a1);
int __fastcall sub_F540(int a1);
int __fastcall sub_F558(int a1);
int __fastcall sub_F570(int a1);
void __fastcall __noreturn sub_F588(char *a1);
void *__fastcall sub_F7C0(void *a1); // idb
time_t __fastcall sub_F7D4(int a1);
time_t __fastcall sub_F808(int a1);
int __fastcall sub_F840(int *a1, int *a2, int a3);
double __fastcall sub_110C4(double a1);
double __fastcall sub_110F8(double a1);
int __fastcall sub_11130(unsigned __int64 a1, char *a2, size_t a3, int a4);
int __fastcall sub_113C4(int a1);
void __fastcall sub_1155C(char *a1, unsigned int a2);
bool sub_1161C();
_DWORD *__fastcall sub_117A4(int a1);
int __fastcall sub_117F4(int a1);
void __fastcall __noreturn sub_11854(void *a1);
void __noreturn sub_1187C(const char *a1, ...);
int __fastcall sub_118C4(int a1, int a2, int a3);
int __fastcall sub_11A5C(int a1);
int __fastcall sub_11B90(int a1);
void sub_11BFC();
void sub_11C4C();
int __fastcall sub_11CBC(int a1);
char *__fastcall sub_11D08(const char *a1, float *a2);
char *__fastcall sub_11D58(const char *a1, float *a2);
int __fastcall sub_11DA8(int result);
int __fastcall sub_11E40(int *a1, int a2, int *a3);
const char *__fastcall sub_14990(const char *a1);
const char *__fastcall sub_14A0C(const char *a1);
int __fastcall sub_14A88(int a1);
int __fastcall sub_14B28(int a1, int a2, unsigned int a3);
int __fastcall sub_14D9C(char *a1, size_t a2, time_t *a3);
void sub_14E18();
char *__fastcall sub_14F94(const char *a1, _DWORD *a2, int a3, int a4);
char *__fastcall sub_14FD4(const char *a1);
char *__fastcall sub_15000(const char *a1, _DWORD *a2);
char *__fastcall sub_1500C(const char *a1, _DWORD *a2);
char *__fastcall sub_15018(const char *a1, _DWORD *a2);
char *__fastcall sub_15024(const char *a1, _DWORD *a2);
char *__fastcall sub_15030(const char *a1, _DWORD *a2);
char *__fastcall sub_1503C(const char *a1, _DWORD *a2);
char *__fastcall sub_15048(const char *a1, _DWORD *a2);
char *__fastcall sub_15054(const char *a1, _DWORD *a2);
char *__fastcall sub_15060(const char *a1, _DWORD *a2);
char *__fastcall sub_1506C(const char *a1, _DWORD *a2);
char *__fastcall sub_15078(const char *a1, _DWORD *a2);
int __fastcall sub_15084(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_150B4(int a1, char *a2);
const char *__fastcall sub_15128(const char *a1);
void *__fastcall sub_15180(void **a1);
char *__fastcall sub_151BC(int a1, int a2, int a3);
void __fastcall sub_152B8(void **a1);
int __fastcall sub_152D0(double a1);
void __fastcall sub_15324(int a1);
void sub_15378();
void sub_153A0();
int __fastcall sub_153C8(const char *a1);
_BYTE *__fastcall sub_153E4(int a1, unsigned int a2);
__int64 __fastcall sub_1541C(__int64 *a1);
void __fastcall sub_154EC(int a1);
int __fastcall sub_15600(int result);
void __fastcall sub_1569C(FILE *s);
int sub_15BEC();
char *__fastcall sub_15C88(char *a1);
int __fastcall sub_15D7C(int a1);
int __fastcall sub_15FC4(int a1);
bool __fastcall sub_15FDC(int a1, int a2);
bool __fastcall sub_16030(int a1, int a2);
unsigned int __fastcall sub_160B4(int a1, int a2);
int __fastcall sub_16500(int a1, void *s2, size_t n, const void *a4, int a5, size_t a6);
void __fastcall sub_165C0(int a1, _DWORD *a2);
int __fastcall sub_16704(int result);
void __fastcall __noreturn sub_16724(int a1);
char *__fastcall sub_1672C(char *a1);
char *__fastcall sub_16814(char *s);
char *__fastcall sub_16868(_DWORD *a1, int a2);
int __fastcall sub_16B7C(int a1, char *a2);
int sub_16C8C();
int __fastcall sub_16CD0(_BYTE *a1);
int __fastcall sub_1715C(char *a1, size_t a2, int a3);
void __noreturn sub_17328();
void __fastcall sub_17380(int a1, int a2, int a3, int a4, int a5);
void __noreturn sub_1738C();
int __fastcall sub_173C0(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_173EC(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_17418(int a1, const char *a2, int a3);
char *sub_1746C();
const char *__fastcall sub_1767C(char *s);
const char *__fastcall sub_1776C(int a1);
int sub_177E8();
int __fastcall sub_17834(char *a1);
const char *__fastcall sub_17998(int a1);
int __fastcall sub_17A14(int a1);
int __fastcall sub_17E64(int a1, _BYTE *a2);
int sub_17ED8();
int sub_17F48();
void __fastcall sub_17FC4(_DWORD *a1);
int __fastcall sub_1822C(int a1, _BYTE *a2);
int __fastcall sub_182A0(_DWORD *a1, int a2);
int __fastcall sub_189B4(int a1);
int __fastcall sub_18AE8(int a1, int a2);
int __fastcall sub_18C10(int a1, unsigned int a2);
int __fastcall sub_18D10(int a1, int a2);
int *__fastcall sub_18D90(int a1);
int sub_19060();
int sub_19140();
void sub_191C4();
void __fastcall sub_192D4(int a1, int a2);
int sub_19350();
int sub_193CC();
int __fastcall sub_19438(int a1, const char *a2, const char *a3);
int __fastcall sub_1952C(const char *a1);
int __fastcall sub_19598(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_195D4(int a1);
int __fastcall sub_19930(pthread_rwlock_t *a1, int a2);
void __fastcall sub_199A4(pthread_rwlock_t *a1, void **a2);
int __fastcall sub_19A20(pthread_rwlock_t *a1);
_DWORD *__fastcall sub_19B0C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int sub_19BC0();
int __fastcall sub_19C7C(int a1);
_DWORD *sub_19DA0();
_DWORD *__fastcall sub_19E18(int a1, int a2);
_DWORD *__fastcall sub_19E40(int a1);
unsigned __int64 __fastcall sub_19E80(int a1);
int __fastcall sub_1A0F8(int a1, int a2);
int __fastcall sub_1A2DC(int a1, int a2, int a3, _DWORD *a4);
void __fastcall sub_1A3E0(pthread_rwlock_t *a1);
int __fastcall sub_1A4EC(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_1A514(int a1, int a2);
_DWORD *__fastcall sub_1A9F0(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
_DWORD *__fastcall sub_1AAA4(pthread_rwlock_t *a1, int a2);
int __fastcall sub_1AB68(int a1);
int sub_1ABE0();
int sub_1AECC();
void sub_1C028();
void __fastcall __noreturn sub_1C160(int a1, int a2);
int __fastcall sub_1C218(pthread_rwlock_t *a1, int a2);
int __fastcall sub_1C2C8(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_1C36C(int a1);
int sub_1C3E4();
int sub_1C708();
void sub_1C720();
void __fastcall sub_1C834(int a1, __int64 a2);
int __fastcall sub_1D3F4(int a1);
void __fastcall sub_1D408(const char *a1, _DWORD *a2);
int sub_1D644();
int __fastcall sub_1D6F8(int a1);
int __fastcall sub_1ED4C(int a1);
int __fastcall sub_1F500(int a1, int a2, int a3);
void __fastcall sub_1F5DC(int a1);
int sub_1F70C();
void __fastcall sub_1F7C4(_DWORD *a1);
void __fastcall sub_1F8F4(_DWORD *a1);
void *__fastcall start_routine(_DWORD *a1);
int __fastcall sub_1FB7C(int a1);
void *__fastcall sub_1FC10(_DWORD *a1);
void __noreturn sub_21364();
void *__fastcall sub_21AB0(_DWORD *a1);
int __fastcall sub_2282C(int a1, int a2);
void sub_22C60();
void *__fastcall sub_22EC4(void *a1); // idb
void __noreturn sub_23018();
int __fastcall sub_243F8(int a1);
int __fastcall sub_24450(pthread_rwlock_t *a1);
int __fastcall sub_244C4(int a1, int a2);
int __fastcall sub_24A48(int a1, pthread_rwlock_t *a2, int a3);
void __fastcall sub_24A70(int a1);
void __fastcall sub_252E4(int a1);
int __fastcall sub_25A60(int a1, int a2, int a3);
void __fastcall sub_25A80(int a1);
int __fastcall sub_25A94(int a1, int a2);
int __fastcall sub_25B80(int a1, char *a2, unsigned int a3);
char *__fastcall sub_25C14(const char *a1);
int __fastcall sub_25D00(const char *a1);
void sub_25D2C();
void sub_263D4();
int __fastcall sub_267F4(int a1, int a2, char *a3, const char *a4, const char *a5);
void sub_26910();
int __fastcall sub_26934(int a1);
void sub_26B74();
int sub_276A8();
int sub_277B0();
int __fastcall sub_278E0(int result);
int __fastcall sub_27B20(pthread_rwlock_t *a1);
int __fastcall sub_27C18(_DWORD *a1);
int sub_286F0();
int __fastcall sub_286F8(int result);
bool __fastcall sub_2870C(int a1, int a2);
int __fastcall sub_287AC(int a1);
ssize_t __fastcall sub_287D4(int a1);
int __fastcall sub_287FC(const char **a1, int a2, int a3);
int __fastcall sub_28BD0(const char **a1, int a2, int a3);
int __fastcall sub_28E3C(struct timespec *req); // idb
_DWORD *__fastcall sub_28E64(_DWORD *a1, unsigned int a2);
char *__fastcall sub_28EC4(_DWORD *a1, unsigned int a2);
int __fastcall sub_28EDC(const char *a1, const char *a2, int a3);
int __fastcall sub_29018(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_29094(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_29110(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_2918C(int a1, char *s, int a3);
int __fastcall sub_29330(int a1, char a2);
int __fastcall sub_29394(int a1);
const char *__fastcall sub_29418(char *a1);
_BYTE *__fastcall sub_29460(_BYTE *result, char *a2, int a3);
_BYTE *__fastcall sub_294B8(int a1, int a2);
bool __fastcall sub_295B8(_BYTE *a1, unsigned __int8 *a2, int a3);
bool __fastcall sub_29724(int a1, _DWORD *a2);
_BYTE *__fastcall sub_2A5B4(_BYTE *a1, char *s);
int __fastcall sub_2A740(int a1, int a2);
int __fastcall sub_2A898(unsigned int *a1, unsigned int *a2);
char *sub_2AA90();
void __fastcall sub_2AAD0(char *a1);
int __fastcall sub_2AB58(int a1);
int __fastcall sub_2AB60(int a1);
int __fastcall sub_2AB68(int a1, int a2);
int __fastcall sub_2AC28(int a1, const struct timespec *a2);
int __fastcall sub_2AD04(int result);
int __fastcall sub_2AD38(_DWORD *a1, int *a2);
int __fastcall sub_2AD6C(_DWORD *a1, int *a2);
bool __fastcall sub_2ADB8(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_2ADEC(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_2AE20(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_2AE34(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_2AE5C(_DWORD *result, _DWORD *a2);
int __fastcall sub_2AE78(_DWORD *a1);
int __fastcall sub_2AEB0(_DWORD *a1);
int __fastcall sub_2AEF0(_DWORD *a1);
int __fastcall sub_2AF38(_DWORD *a1);
int *__fastcall sub_2AF78(int *result, _DWORD *a2);
const char *__fastcall sub_2B008(const char *a1, const char *a2, int a3, int a4);
const char *__fastcall sub_2B0F0(const char **a1, const char *a2);
int __fastcall sub_2B13C(struct timeval *a1);
int __fastcall sub_2B144(_DWORD *a1);
int __fastcall sub_2B16C(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_2B1A8(struct timespec *tp); // idb
int __fastcall sub_2B1B4(_DWORD *a1);
int __fastcall sub_2B1EC(_DWORD *a1);
int sub_2B21C();
int sub_2B244();
_DWORD *__fastcall sub_2B278(_DWORD *result, _DWORD *a2);
void sub_2B314();
void __fastcall sub_2B358(int a1, char *s);
int __fastcall sub_2B43C(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_2B5C8(char *s1, int a2);
bool __fastcall sub_2B6F8(int a1);
void **__fastcall sub_2B714(void **result, unsigned int a2, size_t size, const char *a4, const char *a5, int a6);
int __fastcall sub_2B7C0(pthread_mutex_t *a1);
char *__fastcall sub_2B920(int a1);
int __fastcall sub_2BEA8(pthread_mutex_t *a1, char *a2, int a3);
int __fastcall sub_2C1C4(int result);
int *__fastcall sub_2C29C(_DWORD *a1);
int __fastcall sub_2DC00(pthread_mutex_t *a1);
int __fastcall sub_2DC70(pthread_mutex_t *a1, int *a2);
int __fastcall sub_2E9B0(pthread_mutex_t *a1);
time_t __fastcall sub_2ED00(_DWORD *a1, int a2);
char *__fastcall sub_2EEDC(const char *a1);
int __fastcall sub_2F02C(const char *a1);
int __fastcall sub_2F06C(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_2F0EC(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_2F134(sem_t *a1, const char *a2, const char *a3, int a4);
void *__fastcall sub_2F1B4(sem_t *a1);
int __fastcall sub_2F1F8(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall sub_2F27C(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
int *__fastcall sub_2F354(sem_t *sem);
int __fastcall sub_2F38C(int a1, int a2, int a3);
char *__fastcall sub_2F560(char *result, int a2);
int __fastcall sub_2F59C(int a1, char a2);
void __fastcall sub_2F884(_DWORD *a1, char *a2, int a3);
void __fastcall sub_2FFB0(_DWORD *a1, int a2, int a3);
unsigned int __fastcall sub_2FFF0(unsigned int result, int a2, int a3);
_DWORD *__fastcall sub_30210(_DWORD *result);
void *__fastcall sub_30244(int *a1, const void *a2, size_t n);
_DWORD *__fastcall sub_302E4(_DWORD *a1, int a2);
_DWORD *__fastcall sub_303DC(const void *a1, size_t n, int a3);
char *__fastcall sub_30440(char *s, int a2);
void sub_305DC();
void *__fastcall sub_305F4(int a1, char *s);
int __fastcall sub_30708(unsigned int *a1, char *s);
void __fastcall sub_3079C(unsigned int *a1, char *s, int a3, _BYTE *a4);
int __fastcall sub_308A8(unsigned int *a1, char *s);
int __fastcall sub_308C0(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_308F4(unsigned int *a1, int a2, int a3, int a4);
bool __fastcall sub_30928(const struct sockaddr *a1, const char **a2, _BYTE *a3);
void __fastcall sub_30AC8(int a1, int a2, int a3);
int sub_30FBC();
int __fastcall sub_31BD4(int a1);
_DWORD *__fastcall sub_31C10(_DWORD *a1, const char *a2, int a3, const char *a4, char a5);
int __fastcall sub_31E94(int result, int a2);
unsigned __int8 **__fastcall sub_31EF4(unsigned __int8 **result, unsigned __int8 **a2);
int __fastcall sub_31F7C(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, _DWORD *a4);
int __fastcall sub_32074(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_320F0(pthread_mutex_t *a1, const char *a2, int a3);
int sub_3212C();
void __noreturn sub_32224(); // weak
int __fastcall sub_32320(int *a1);
int __fastcall sub_32418(unsigned int *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_32CD8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32CFC(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D20(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D44(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D68(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D8C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32DB0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32DD4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32DF8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E1C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E40(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E64(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E88(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32EAC(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32ED0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32EF4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32F18(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_32F3C(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5);
int __fastcall sub_33354(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_33428(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_3343C(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_335F0(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_33604(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_3375C(int a1, int a2, _BYTE *a3, int a4);
int __fastcall sub_33A68(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4);
int __fastcall sub_33B14(int a1, int a2, const char *a3, int a4, unsigned __int8 a5);
int __fastcall sub_33CAC(int a1, int a2, int a3, int a4);
void __fastcall sub_33E50(unsigned int *a1, int a2, char *nptr, int a4, int a5);
int __fastcall sub_33FFC(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34144(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34268(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall sub_343B0(unsigned int *a1, int a2, char *s, int a4);
void __fastcall sub_34608(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_34710(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34970(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_34984(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_34B40(int a1, int a2, int a3, int a4);
void __fastcall sub_34CA0(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_34D7C(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
_DWORD *__fastcall sub_34D90(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_35034(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6);
_DWORD *__fastcall sub_35400(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35424(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35448(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_3546C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35490(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_354B4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_354D8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35684(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_356A8(int a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_360E0(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_36104(unsigned int *a1, int a2, int a3, int a4);
int sub_363A4();
void __fastcall sub_3646C(int a1);
void __fastcall sub_38438(int a1, const char *a2, int a3);
int sub_385EC();
int __fastcall sub_38674(int a1);
int __fastcall sub_386F4(int result, const char *a2, const char *a3, int a4);
void __fastcall sub_387C4(int a1, const char *a2, int a3);
const char *__fastcall sub_38858(const char **a1, const char *a2, const char *a3, int a4);
_BYTE *__fastcall sub_38B8C(int a1);
_BYTE *__fastcall sub_38C34(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall sub_38EEC(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_38F6C(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_38F98(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_39058(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_3913C(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_39284(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_393C8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_3951C(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_39614(const char **a1, int *a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_39784(const char **a1, int *a2, const char *a3, const char *a4, int a5);
int __fastcall sub_398EC(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_39A00(const char **ptr, const char *a2, const char *a3, int a4);
int __fastcall sub_39B54(__int64 a1, _QWORD *a2);
int sub_39FB4();
void sub_39FF4();
int sub_3A0EC();
void sub_3A10C();
int sub_3A268();
void sub_3A2F0();
int __fastcall sub_3A73C(const char *a1);
void __noreturn sub_3A788();
bool __fastcall sub_3A904(int a1, _BYTE *a2);
int __fastcall sub_3AA38(unsigned __int64 a1, char *a2, int a3, char a4);
_DWORD *sub_3AC10();
int __fastcall sub_3B068(pthread_rwlock_t *a1);
void __noreturn sub_3B0EC();
int __fastcall sub_3B268(int a1);
unsigned int __fastcall sub_3B324(unsigned int result, unsigned __int8 *a2, int a3);
int __fastcall sub_3B360(_BYTE *a1, int a2);
int __fastcall sub_3B44C(int a1);
ssize_t __fastcall sub_3BBBC(int a1, const void *a2, size_t a3);
void __fastcall __noreturn sub_3BC80(unsigned __int8 *a1);
int sub_3C338();
ssize_t __fastcall sub_3C604(int a1, void *a2, size_t a3);
int sub_3C69C();
void __noreturn sub_3C6D4();
void __fastcall __noreturn sub_3D2F4(unsigned __int8 *a1);
int __fastcall sub_3D9A4(int a1);
int __fastcall sub_3DA40(int a1);
void sub_3DB30();
int __fastcall sub_3DDB8(char a1);
void __noreturn sub_3DE5C();
void sub_3E8FC();
int __fastcall sub_3EF84(char a1, char a2, int a3);
int __fastcall sub_3F014(int a1);
void __noreturn sub_3F0B0();
void __noreturn sub_3F138();
void __fastcall sub_3F17C(int a1);
void __fastcall sub_3F3B8(int a1, int a2);
ssize_t __fastcall sub_3F864(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_3F9D8(char a1, int a2, int a3);
ssize_t __fastcall sub_3FA48(int a1);
void sub_3FB04();
int __fastcall sub_3FE10(int result, char a2, unsigned __int8 a3);
void __fastcall sub_3FEA4(unsigned __int8 a1, char a2, char a3, unsigned __int8 a4);
int sub_3FFAC();
int __fastcall sub_40064(unsigned __int8 a1);
int sub_40128();
void __fastcall sub_4022C(int a1);
void __fastcall sub_404D8(int a1);
int __fastcall sub_405F0(int a1, int a2, int a3);
int sub_406DC();
void __fastcall sub_40D00(unsigned int a1);
int __fastcall sub_40DEC(char a1, char *a2, int a3);
int __fastcall sub_40E64(char *a1);
int sub_40ED8();
int sub_40F64();
int sub_40FF0();
int __fastcall sub_41040(char a1, char a2);
int __fastcall sub_410B0(void *a1, void *a2);
int __fastcall sub_41118(int a1);
int sub_41178();
int sub_411C4();
int __fastcall sub_41210(int a1);
int sub_41270();
int sub_412D0();
int __fastcall sub_4131C(int a1);
int __fastcall sub_41390(int a1);
int __fastcall sub_413FC(int a1);
int __fastcall sub_41470(int a1);
int __fastcall sub_414DC(int a1);
int __fastcall sub_41550(int a1);
int __fastcall sub_415BC(int a1);
int __fastcall sub_41628(int a1, const void *a2);
int __fastcall sub_41798(void *a1);
int sub_417EC();
int sub_41998();
void __fastcall sub_41A58(int a1);
unsigned int __fastcall sub_41B50(unsigned int result, unsigned __int8 *a2, int a3);
int __fastcall sub_41B8C(int a1);
int __fastcall sub_41C04(int a1, int a2);
int __fastcall sub_41C30(int a1, unsigned __int8 *a2, int a3);
void sub_41CAC();
int sub_41EC4();
int sub_41F18();
int sub_42010();
int __fastcall sub_42584(int a1);
int __fastcall sub_434FC(int a1);
int __fastcall compar(_DWORD *a1, _DWORD *a2);
int __fastcall sub_436E4(char *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4);
int __fastcall sub_43908(int a1, int a2);
int __fastcall sub_43914(const void *a1, size_t a2, FILE *s);
int __fastcall sub_43934(void *src, size_t n, const void **a3);
int __fastcall sub_4394C(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall sub_439F0(_DWORD *a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5);
int __fastcall sub_4401C(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4);
int __fastcall sub_44068(_DWORD *a1, int a2, __int16 a3);
int __fastcall sub_4407C(_DWORD *a1, char *filename, __int16 a3);
void *__fastcall sub_440CC(_DWORD *a1, __int16 a2);
int __fastcall sub_44138(int result, int a2, _DWORD *a3);
int __fastcall sub_44194(int a1, int *a2, char *s2, int a4);
void __fastcall sub_4420C(int a1);
int __fastcall sub_4426C(_DWORD *a1);
void __fastcall sub_442EC(int a1);
int __fastcall sub_44304(int a1, char *a2, int a3, int a4);
int __fastcall sub_4450C(int a1, char *a2);
int __fastcall sub_44584(_DWORD *a1, char *a2);
void __fastcall sub_446A0(_DWORD *a1);
int __fastcall sub_4471C(int a1, char *a2);
int __fastcall sub_447B4(int a1);
void __fastcall sub_447C4(int a1, int a2);
int __fastcall sub_4480C(_DWORD *a1);
int __fastcall sub_4482C(_DWORD *a1);
int __fastcall sub_44850(_DWORD *a1);
int sub_448AC(int result, _DWORD *a2, const char *a3, ...);
int __fastcall sub_449CC(int a1, int a2, int a3);
void __fastcall sub_44A18(int a1);
int __fastcall sub_44A44(_BYTE *a1);
_DWORD *__fastcall sub_44AEC(_DWORD *result, int a2);
int __fastcall sub_44BA4(int a1, int a2);
_DWORD *__fastcall sub_44D28(_DWORD *result, int a2);
int __fastcall sub_44D74(int a1, int a2);
unsigned int __fastcall sub_44DA4(int a1, int a2);
int *__fastcall sub_45578(double a1, int a2);
int *__fastcall sub_459CC(_DWORD *a1, unsigned int a2, int a3);
int *__fastcall sub_45AA8(int *a1, unsigned int a2, char *a3);
int *__fastcall sub_45B3C(int *a1, int a2, unsigned int a3, char *a4);
int *__fastcall sub_45BD8(int *a1, unsigned int a2, char *a3);
int *__fastcall sub_45C84(char *a1, unsigned int a2, char *a3);
void *__fastcall sub_45DE4(size_t a1);
void __fastcall sub_45E0C(void *a1);
void *__fastcall sub_45E2C(const char *a1);
void *(*__fastcall sub_45E84(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
int __fastcall sub_45E94(_DWORD *a1);
void __fastcall sub_45ECC(int a1);
int __fastcall sub_45EF8(int result);
int __fastcall sub_45F0C(int a1);
int __fastcall sub_45F14(int *a1);
int __fastcall sub_45F28(const void **a1, void *src, size_t n);
int __fastcall DataWriter::WriteByte(const void **this, unsigned __int8 a2);
int __fastcall luaL_addstring(const void **a1, char *s);
int __fastcall sub_46038(int *a1, int a2, int a3);
int __fastcall sub_46060(int a1, double *a2);
int __fastcall sub_46120(char *a1, size_t a2);
int __fastcall sub_46254(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_4633C(int a1);
int __fastcall sub_463B8(char *a1, int a2, int *a3);
char *__fastcall sub_46490(char *a1, _DWORD *a2);
int __fastcall sub_46504(const char *a1, signed int a2);
void *__fastcall sub_46598(_DWORD *a1, int a2, int a3);
_DWORD *sub_46620();
_DWORD *__fastcall sub_4667C(_DWORD *result);
int __fastcall sub_46698(_DWORD *a1, char *a2);
int __fastcall sub_466BC(_DWORD *a1, char *a2);
int __fastcall sub_466E0(_DWORD *a1);
_DWORD *__fastcall sub_46714(_DWORD *a1);
int __fastcall sub_46738(_DWORD *a1, char *a2);
int __fastcall sub_46760(_DWORD *a1, int a2);
int __fastcall sub_4678C(int result);
int __fastcall sub_46798(int result);
int __fastcall sub_467A4(_DWORD *a1, int a2, int a3);
int __fastcall sub_467EC(int result);
_DWORD *sub_467F8();
_DWORD *__fastcall sub_46864(_DWORD *result);
_DWORD *__fastcall sub_46880(_DWORD *result, unsigned int a2);
int __fastcall sub_468B4(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_46964(const char *a1);
_DWORD *__fastcall sub_469C0(const char *a1);
_DWORD *__fastcall sub_469F0(_DWORD *result);
int __fastcall sub_46A0C(int a1, const char *a2);
int __fastcall sub_46A58(int a1, const char *a2);
_QWORD *__fastcall sub_46A94(__int64 a1);
__int64 __fastcall sub_46AC0(int a1);
int __fastcall sub_46AEC(int a1, __int64 a2);
_QWORD *__fastcall sub_46B14(double a1);
void sub_46B70();
int __fastcall sub_46BA0(double a1);
int __fastcall sub_46BF0(int result);
void *sub_46C38();
void *sub_46C44();
void *sub_46C50();
void __fastcall sub_46C5C(void **a1);
int __fastcall sub_46D30(_DWORD *a1);
int __fastcall sub_46DAC(_DWORD *a1, unsigned int a2);
int __fastcall sub_46E60(int a1, unsigned int a2, int a3);
int __fastcall sub_46F60(int *a1, int *a2);
int __fastcall sub_46FE4(_DWORD *a1, unsigned int a2, int a3);
int __fastcall sub_47098(_DWORD *a1, char *a2, int a3);
int __fastcall sub_47118(_DWORD *a1, _DWORD *a2);
int __fastcall sub_471D4(_DWORD *a1, char *a2, int a3);
int __fastcall sub_47248(_DWORD *a1, _DWORD *a2);
int __fastcall sub_472F4(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_473A8(int *a1, int *a2);
int *__fastcall sub_4756C(double a1);
int *__fastcall sub_476E0(double a1);
char *__fastcall sub_47828(char *result, char *s);
char *__fastcall sub_4788C(char *result, char *s);
int __fastcall sub_478D0(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg); // idb
int sub_47910(int a1, int a2, int a3, int a4, char *format, ...); // idb
char *__fastcall sub_47938(const char *a1, const char *a2);
int __fastcall sub_47974(_BYTE *a1);
int __fastcall sub_47984(_BYTE *a1);
char *__fastcall sub_47998(const char *a1, _BYTE *a2);
char *__fastcall sub_47A2C(const char *a1, _BYTE *a2);
int __fastcall sub_47A4C(int a1, _DWORD *a2);
char *__fastcall sub_47A58(const char *a1, _DWORD *a2);
char *__fastcall sub_47ADC(const char *a1, int *a2);
char *__fastcall sub_47B60(const char *a1, _DWORD *a2);
int __fastcall sub_47C20(_DWORD *a1);
void __fastcall __noreturn sub_47C38(const char *a1);
void __fastcall __noreturn sub_47C58(int a1);
char *__fastcall sub_47C98(char *a1, unsigned __int8 *a2);
char *__fastcall sub_47CBC(char *a1, unsigned __int8 *a2);
char *__fastcall sub_47CE0(_BYTE *a1, const char **a2);
int __fastcall sub_47D40(char *a1, _DWORD *a2);
int __fastcall sub_47D54(char *a1, float *a2);
int __fastcall sub_47D80(char *a1, _DWORD *a2);
int __fastcall sub_47D94(char *a1, _DWORD *a2);
int __fastcall sub_47DA8(char *a1, _DWORD *a2);
unsigned __int8 *__fastcall sub_47DBC(int a1, _DWORD *a2);
_BYTE *__fastcall sub_47E64(unsigned int *a1, _DWORD *a2);
unsigned __int8 *__fastcall sub_47F4C(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3);
unsigned __int8 *__fastcall sub_48040(const char **a1);
int __fastcall sub_48220(int *a1);
unsigned __int8 *__fastcall sub_48280(unsigned int *a1, unsigned __int8 **a2);
unsigned __int8 *__fastcall sub_482D8(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3);
unsigned __int8 *__fastcall sub_48330(unsigned int *a1);
unsigned __int8 *__fastcall sub_4838C(unsigned __int8 *a1, unsigned int *a2);
int __fastcall sub_48430(int result, int a2);
bool __fastcall sub_484FC(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_48558();
int sub_48578(const char *a1, ...);
void __noreturn sub_485C0(const char *a1, ...);
char *__fastcall sub_48600(const char *a1);
void *__fastcall sub_48630(_DWORD *a1, int a2, int a3);
int __fastcall sub_48664(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_48A84(const char *a1, char *a2);
int __fastcall sub_48F88(int result, unsigned int a2);
int __fastcall sub_49084(__int64 a1, __int64 a2);
int __fastcall sub_493C8(__int64 a1);
int __fastcall sub_493DC(__int64 a1);
int __fastcall sub_4943C(__int64 a1, __int64 a2);
int __fastcall sub_49488(double a1);
unsigned int __fastcall sub_494C0(double a1);
int __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
int __fastcall _gnu_uldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
int __fastcall sub_49580(__int64 a1, __int64 a2);
int __fastcall sub_499D8(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4);
int nullsub_10(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_186A0; // weak
_UNKNOWN loc_1C200; // weak
_UNKNOWN loc_201FC; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN loc_38D7C; // weak
_UNKNOWN init;
_UNKNOWN unk_49E74; // weak
_UNKNOWN unk_49EA0; // weak
int dword_49EC4[16] = { 1, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1568 }; // weak
_UNKNOWN unk_49F24; // weak
char a000000029c6bf4[321] = "000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4"; // weak
char a00000002c01f50[321] = "00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f"; // weak
const char delim[] = { '|', '\0' }; // idb
const char a49[] = "4.9."; // idb
const char word_50574[] = { '0', '\0' }; // idb
_DWORD dword_51788[256] =
{
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
}; // weak
char *off_51BA4 = "http:"; // weak
const char dword_52370[] = { 'n', 'o', '\0', '\0' }; // idb
_UNKNOWN unk_52520; // weak
_UNKNOWN unk_52554; // weak
char aEscapeString[14] = "escape_string"; // weak
const char asc_54E8C[] = "                    "; // idb
const char ptr[] = { '\n', '\0' }; // idb
const char aBitmainL3Detec_0[] = "bitmain_L3_detect"; // idb
_UNKNOWN unk_55464; // weak
char aD_0[2] = "d"; // weak
_UNKNOWN unk_557AC; // weak
_UNKNOWN unk_55A74; // weak
_DWORD dword_55AA0[4] = { 1, 2, 4, 5 }; // weak
const char aDumpIicDataXXX[52] = "Dump IIC Data:[%X][%X][%X][%X]@ChainID:[%d], Chip[%X"; // idb
const char word_56150[] = { ']', '\0' }; // idb
_DWORD dword_56E0C[29] =
{
  5,
  13,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741
}; // weak
int (*off_5F448[2])() = { &frame_dummy, &_do_global_dtors_aux }; // weak
int (*off_5F44C)() = &_do_global_dtors_aux; // weak
int dword_5F890[] = { 1 }; // weak
double dbl_5F898 = 1.0; // weak
char *off_5F8A0 = "--version-file"; // weak
int dword_5F8A4 = 2; // weak
_UNKNOWN unk_5F8BC; // weak
int dword_60064 = 48; // weak
int dword_60068 = 0; // weak
int dword_6006C = 5; // weak
int dword_60070 = 1; // weak
int dword_60074 = 1; // weak
char *off_60078 = ":D"; // weak
char byte_6007C = '\x01'; // weak
double dbl_60080 = 1.84467441e19; // weak
double dbl_60088 = 1.0; // weak
int dword_60090 = -1; // weak
int dword_60094 = 120; // weak
int dword_60098 = 1; // weak
int dword_6009C = 1; // weak
int dword_600A0 = 1; // weak
int dword_600A4 = 1; // weak
int dword_600A8 = 1; // weak
char byte_600AC = '\x01'; // weak
char byte_600AD = '\x01'; // weak
char *off_600C4 = "--config|-c"; // weak
char *off_60150 = "000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000"; // weak
int dword_60154 = 1; // weak
int dword_6015C = 4028; // weak
_UNKNOWN *off_60160 = (_UNKNOWN *)0x5220C; // weak
char *off_60164[3] = { "FTW", "224.0.0.75", "0.0.0.0" }; // weak
char *off_60168[2] = { "224.0.0.75", "0.0.0.0" }; // weak
char *off_6016C = "0.0.0.0"; // weak
int dword_60170 = 4028; // weak
_UNKNOWN *off_60174 = &unk_50568; // weak
int (*off_60178)() = &sub_286F0; // weak
_UNKNOWN unk_6027C; // weak
_UNKNOWN unk_60378; // weak
_UNKNOWN unk_60398; // weak
int dword_6039C[] = { 3 }; // weak
int dword_603A0 = 7; // weak
_UNKNOWN *off_607CC = (_UNKNOWN *)0x51438; // weak
_UNKNOWN unk_607D4; // weak
int dword_60964 = 5; // weak
_UNKNOWN unk_60D68; // weak
void (*off_60D74)() = &sub_3A10C; // weak
char byte_60DE8 = '\x01'; // weak
char byte_60DE9 = '\x01'; // weak
char byte_60DEA = '\x01'; // weak
char byte_60DEB = '\x02'; // weak
_UNKNOWN unk_60DEC; // weak
_UNKNOWN unk_60DF0; // weak
_UNKNOWN unk_60DF4; // weak
_UNKNOWN unk_60DF8; // weak
_UNKNOWN unk_60DFC; // weak
_UNKNOWN unk_60E00; // weak
_UNKNOWN unk_60E04; // weak
_UNKNOWN unk_60E08; // weak
_UNKNOWN unk_60E0C; // weak
_UNKNOWN unk_60E10; // weak
_UNKNOWN unk_60E14; // weak
_UNKNOWN unk_60E18; // weak
_UNKNOWN unk_60E1C; // weak
_UNKNOWN unk_60E20; // weak
_UNKNOWN unk_60E24; // weak
_UNKNOWN unk_60E28; // weak
_UNKNOWN unk_60E2C; // weak
_UNKNOWN unk_60E30; // weak
_UNKNOWN unk_60E34; // weak
_UNKNOWN unk_60E3C; // weak
int dword_60E44 = 30; // weak
void *(*off_60E50)(size_t size) = &malloc; // weak
void (*off_60E54)(void *ptr) = &free; // weak
_UNKNOWN unk_60E58; // weak
_UNKNOWN unk_60E60; // weak
_UNKNOWN unk_60E68; // weak
int stdscr; // weak
int LINES; // weak
int stdin; // weak
int stdout; // weak
int stderr; // weak
char byte_60E84; // weak
int dword_60E88; // weak
int dword_60E8C; // weak
int dword_60E90; // weak
int dword_60E94; // weak
int dword_60E98; // weak
int dword_60E9C; // weak
int dword_60EA0; // weak
char byte_60EA4[256]; // weak
int dword_60FA4; // weak
char byte_60FA8[512]; // idb
int dword_611A8; // weak
int dword_611AC; // weak
int dword_611B0; // weak
struct timeval stru_611B4; // weak
struct timeval stru_611BC; // weak
_UNKNOWN unk_611C4; // weak
__int64 qword_611C8; // weak
char byte_611D0; // weak
int dword_611D4; // weak
int dword_611D8; // weak
char byte_611DC[200]; // idb
int dword_612A4; // weak
int dword_612A8; // weak
int dword_612AC; // weak
int dword_612B0; // weak
int dword_612B4; // weak
int dword_612B8; // weak
int dword_612BC; // weak
int dword_612C0; // weak
int dword_612C4; // weak
int dword_612C8; // weak
int dword_612CC; // weak
char byte_612D0; // weak
char byte_612D1; // weak
char byte_612D2; // weak
int dword_612D4; // weak
char byte_612D8; // weak
pthread_mutex_t stru_612DC; // idb
int dword_612F4; // weak
char byte_612F8; // weak
int dword_612FC; // weak
int dword_61300; // weak
int dword_61304; // weak
int dword_61308; // weak
int dword_6130C; // weak
int dword_61310; // weak
pthread_mutex_t stru_61314; // idb
pthread_cond_t stru_61330; // idb
int dword_61360; // weak
int dword_61364; // weak
int dword_61368; // weak
int dword_6136C; // weak
int dword_61370; // weak
int dword_61374; // weak
_DWORD dword_61378[2]; // weak
double dbl_61380[12]; // weak
int dword_613E0; // weak
int dword_613E4; // weak
int dword_613E8; // weak
char byte_613EC[40]; // weak
int dword_61414; // weak
int dword_61418; // weak
int dword_6141C; // weak
int dword_61420; // weak
int dword_61424; // weak
int dword_61428; // weak
char byte_6142C; // weak
char byte_6142D; // weak
double dbl_61430; // weak
char byte_61438[256]; // weak
pthread_mutex_t stru_61538; // idb
pthread_rwlock_t stru_61550; // idb
int dword_61570; // weak
char byte_61574[8]; // weak
_DWORD dword_6157C[4]; // weak
_UNKNOWN unk_6158C; // weak
_UNKNOWN unk_61590; // weak
_UNKNOWN unk_61594; // weak
_UNKNOWN unk_61598; // weak
char byte_6159C[32]; // weak
char byte_615BC[8]; // idb
char byte_615C4; // weak
char byte_615C8; // weak
char byte_615C9; // weak
struct timeval stru_615CC; // weak
char byte_615D4; // weak
_BYTE byte_615D8[2560]; // weak
_BYTE byte_61FD8[2560]; // weak
char byte_629D8; // weak
int dword_629DC; // weak
int dword_629E0; // weak
int dword_629E4; // weak
int dword_629E8; // weak
_DWORD dword_629EC[4]; // weak
_UNKNOWN unk_629FC; // weak
_UNKNOWN unk_62A00; // weak
_UNKNOWN unk_62A04; // weak
_UNKNOWN unk_62A08; // weak
char s[256]; // idb
char byte_62B0C[256]; // idb
int dword_62C0C; // weak
int dword_62C10; // weak
int dword_62C14[]; // weak
char byte_62D18; // weak
_UNKNOWN unk_62D1C; // weak
int dword_62E20; // weak
int dword_62E24; // weak
int dword_62E28; // weak
int dword_62E30; // weak
int dword_62E34; // weak
char byte_62E38[16]; // weak
int dword_62E48; // weak
unsigned __int8 byte_62E80[204]; // weak
int dword_62F4C; // weak
char byte_62F60; // weak
char byte_62F64; // weak
char byte_62F65; // weak
char byte_62F66; // weak
int dword_62F68; // weak
int dword_62F6C; // weak
pthread_mutex_t stru_62F70; // idb
int dword_62F88; // weak
int dword_62F8C; // weak
int dword_62F90; // weak
int dword_62F94; // weak
char byte_62F98; // weak
int dword_62F9C; // weak
char dword_62FA0[]; // idb
char word_630A0[]; // idb
char byte_630C0; // weak
char byte_630C1; // weak
char byte_630C8[]; // weak
char byte_630C9; // weak
char byte_630CA; // weak
char byte_630CB; // weak
double dbl_630D0; // weak
char byte_630D8; // weak
char byte_630D9; // weak
pthread_mutex_t stru_630DC; // idb
int dword_630F4; // weak
char byte_630F8; // weak
_QWORD qword_63100[4]; // weak
pthread_mutex_t stru_63120; // idb
pthread_mutex_t stru_63138; // idb
char byte_63150; // weak
int dword_63154; // weak
int dword_63158; // weak
pthread_mutex_t stru_6315C; // idb
char byte_63174; // weak
_UNKNOWN unk_63178; // weak
char byte_631E8; // weak
int dword_631EC; // weak
int dword_631F0; // weak
char byte_631F4; // weak
int dword_631F8; // weak
pthread_mutex_t stru_631FC; // idb
pthread_mutex_t stru_63214; // idb
_UNKNOWN unk_6322C; // weak
char byte_63230; // weak
double dbl_63268; // weak
_UNKNOWN unk_63270; // weak
int (__fastcall *off_6327C)(_DWORD); // weak
char byte_632F0; // weak
pthread_mutex_t mutex; // idb
_UNKNOWN unk_63310; // weak
int (__fastcall *off_6331C)(_DWORD); // weak
_UNKNOWN unk_63390; // weak
_UNKNOWN *off_6339C; // weak
int dword_63410; // weak
_UNKNOWN unk_63418; // weak
int (__fastcall *off_63424)(_DWORD); // weak
_UNKNOWN unk_63498; // weak
int (__fastcall *off_634A4)(_DWORD); // weak
_UNKNOWN unk_63518; // weak
int (__fastcall *off_63524)(_DWORD); // weak
_UNKNOWN unk_63598; // weak
int (__fastcall *off_635A4)(_DWORD); // weak
int dword_63618; // weak
_UNKNOWN unk_63620; // weak
int (__fastcall *off_6362C)(_DWORD); // weak
int dword_636A0; // weak
int dword_636A4; // weak
int dword_636A8; // weak
struct sigaction oact; // idb
char byte_6373C; // weak
int dword_63740; // weak
pthread_cond_t stru_63748; // idb
_UNKNOWN unk_63778; // weak
int (__fastcall *off_63784)(_DWORD); // weak
char byte_637F8; // weak
_UNKNOWN unk_63800; // weak
_UNKNOWN *off_6380C; // weak
pthread_rwlock_t stru_63880; // weak
double dbl_638A0; // weak
_UNKNOWN unk_638A8; // weak
int (__fastcall *off_638B4)(_DWORD); // weak
char byte_63928; // weak
pthread_mutex_t stru_6392C; // idb
_UNKNOWN unk_63948; // weak
int (__fastcall *off_63954)(_DWORD); // weak
__int64 qword_639C8; // weak
double dbl_639D0; // weak
int dword_639D8; // weak
int dword_639E0; // weak
int dword_639E4; // weak
int dword_639E8; // weak
int dword_639EC; // weak
_UNKNOWN unk_639F0; // weak
int (__fastcall *off_639FC)(_DWORD); // weak
int dword_63A70; // weak
_UNKNOWN unk_63A78; // weak
int (__fastcall *off_63A84)(_DWORD); // weak
int dword_63AF8; // weak
_UNKNOWN unk_63B00; // weak
_UNKNOWN *off_63B0C; // weak
int dword_63B80; // weak
int dword_63B84; // weak
double dbl_63B88; // weak
char byte_63B90; // weak
int dword_63B98; // weak
int dword_63B9C; // weak
int dword_63BC0; // weak
char byte_63BC4; // weak
char byte_63BC5; // weak
int dword_63BC8; // weak
pthread_mutex_t stru_63BCC; // idb
char byte_63BE4; // weak
int dword_63BE8; // weak
pthread_rwlock_t rwlock; // idb
double dbl_63C10; // weak
_UNKNOWN unk_63C18; // weak
int (__fastcall *off_63C24)(_DWORD); // weak
__int64 qword_63C98; // weak
pthread_rwlock_t stru_63CA0; // idb
int dword_63CC0; // weak
_UNKNOWN unk_63CC8; // weak
pthread_mutex_t stru_63D48; // idb
int dword_63D60; // weak
char byte_63D64; // weak
int dword_63D68; // weak
char byte_63D70; // weak
char byte_63D71; // weak
_UNKNOWN unk_63D78; // weak
int (__fastcall *off_63D84)(_DWORD); // weak
char byte_63DF8; // weak
char byte_63DF9; // weak
char byte_63DFA; // weak
pthread_mutex_t stru_63DFC; // weak
char byte_63E14; // weak
int dword_63E1C; // weak
int dword_63E20; // weak
int dword_63E44; // weak
int dword_63E48; // weak
char byte_63E4C; // weak
int dword_63E50; // weak
int dword_63E54; // weak
int dword_63E58; // weak
_UNKNOWN unk_63E60; // weak
int (__fastcall *off_63E6C)(_DWORD); // weak
char byte_63EE0; // weak
int dword_63EE4; // weak
int dword_63EE8; // weak
struct sigaction stru_63EEC; // idb
pthread_mutex_t stru_63F78; // idb
pthread_rwlock_t stru_63F90; // idb
pthread_mutex_t stru_63FB0; // idb
pthread_rwlock_t stru_63FC8; // idb
_UNKNOWN unk_63FE8; // weak
_UNKNOWN *off_63FF4; // weak
char byte_64068; // weak
int dword_64070; // weak
pthread_cond_t cond; // idb
double dbl_640B0; // weak
char byte_640B8; // weak
int dword_640BC; // weak
int dword_640C0; // weak
int dword_640C4; // weak
char dest[68]; // idb
int dword_6410C; // weak
_UNKNOWN unk_64110; // weak
int (__fastcall *off_6411C)(_DWORD); // weak
_UNKNOWN unk_64190; // weak
int (__fastcall *off_6419C)(_DWORD); // weak
int dword_64214; // weak
char byte_64218; // weak
char byte_64219; // weak
int dword_64220; // weak
double dbl_64228; // weak
int dword_64230; // weak
double dbl_64238; // weak
_UNKNOWN unk_64240; // weak
int (__fastcall *off_6424C)(_DWORD); // weak
char byte_642C0; // weak
_UNKNOWN unk_642C4; // weak
int dword_6432C[]; // weak
int dword_64330; // weak
int dword_64334; // weak
int dword_65E3C; // weak
struct timeval stru_65E40; // weak
int dword_65E48; // weak
_BYTE byte_65E4C[32]; // weak
char byte_65E6C[64]; // weak
_UNKNOWN unk_65EAC; // weak
int dword_66EAC; // weak
_DWORD dword_66EB0[11]; // weak
_UNKNOWN unk_66EDC; // weak
int dword_6A4B0; // weak
int dword_6A4B4; // weak
_DWORD dword_6A4B8[6354]; // weak
_UNKNOWN unk_70800; // weak
_UNKNOWN unk_7A120; // weak
_UNKNOWN unk_7F76D; // weak
_UNKNOWN unk_927C0; // weak
_UNKNOWN unk_C20B8; // weak
int dword_C30B8[]; // weak
int dword_C30BC; // weak
int dword_C30C0; // weak
int dword_C4BC8; // weak
_UNKNOWN unk_C4BCC; // weak
int dword_C4BD0; // weak
int dword_C4BD4; // weak
int dword_C4BD8; // weak
int dword_C4BDC; // weak
int dword_C4BE0; // weak
_UNKNOWN unk_C4BE4; // weak
_UNKNOWN unk_C4BE7; // weak
float flt_C4BEC; // weak
int dword_C544A; // weak
int dword_C544E[5]; // weak
char byte_C5462; // weak
char byte_C5463; // weak
char byte_C5464; // weak
char byte_C5465; // weak
char byte_C5466; // weak
char byte_C5467; // weak
char byte_C5468; // weak
char byte_C5469; // weak
int dword_C546B; // weak
int dword_C546F; // weak
int dword_C5473[6]; // weak
char byte_C548B; // weak
char byte_C548C; // weak
char byte_C548D; // weak
char byte_C5490; // weak
char byte_C5491; // weak
__int16 word_C5492; // weak
char byte_C5494[18]; // weak
int dword_C54A6; // weak
int dword_C54C0; // weak
int dword_C54C4; // weak
int dword_C54C8; // weak
int dword_C54CC; // weak
int dword_C54D0; // weak
int dword_C54D4; // weak
_UNKNOWN unk_C54D8; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0000AACC) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return sub_F20C();
}

//----- (0000AAD8) --------------------------------------------------------
void sub_AAD8()
{
  JUMPOUT(0);
}
// AAE4: control flows out of bounds to 0

//----- (0000B410) --------------------------------------------------------
int __fastcall sub_B410(int a1)
{
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
  {
    snprintf(v3, 0x800u, "WTF No pool %d found!", a1);
    sub_38438(3, v3, 0);
  }
  return *(_DWORD *)(dword_639E0 + 4 * a1);
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 639E0: using guessed type int dword_639E0;

//----- (0000B498) --------------------------------------------------------
void __noreturn sub_B498()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Failed to create restart thread");
  sub_38438(3, v0, 1);
  sub_16724(1);
}

//----- (0000B4D4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B4D4(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// B4DC: positive sp value 804 has been found
// B4DC: unbalanced stack, ignored a potential tail call

//----- (0000B4E4) --------------------------------------------------------
void __fastcall __noreturn sub_B4E4(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B53C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B53C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B544: positive sp value 814 has been found
// B544: unbalanced stack, ignored a potential tail call

//----- (0000B550) --------------------------------------------------------
void __fastcall __noreturn sub_B550(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B5A8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B5A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B5B0: positive sp value 814 has been found
// B5B0: unbalanced stack, ignored a potential tail call

//----- (0000B5BC) --------------------------------------------------------
void __fastcall __noreturn sub_B5BC(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B614) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B614(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B61C: positive sp value 814 has been found
// B61C: unbalanced stack, ignored a potential tail call

//----- (0000B628) --------------------------------------------------------
void __fastcall __noreturn sub_B628(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B680) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B680(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B688: positive sp value 814 has been found
// B688: unbalanced stack, ignored a potential tail call

//----- (0000B694) --------------------------------------------------------
void __fastcall __noreturn sub_B694(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}
// 16724: using guessed type void __fastcall __noreturn sub_16724(_DWORD);

//----- (0000B6EC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B6EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B6F4: positive sp value 814 has been found
// B6F4: unbalanced stack, ignored a potential tail call

//----- (0000B700) --------------------------------------------------------
void __fastcall __noreturn sub_B700(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}
// 16724: using guessed type void __fastcall __noreturn sub_16724(_DWORD);

//----- (0000B758) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B758(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B760: positive sp value 814 has been found
// B760: unbalanced stack, ignored a potential tail call

//----- (0000B76C) --------------------------------------------------------
void __fastcall __noreturn sub_B76C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}
// 16724: using guessed type void __fastcall __noreturn sub_16724(_DWORD);

//----- (0000B7C4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B7C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B7CC: positive sp value 814 has been found
// B7CC: unbalanced stack, ignored a potential tail call

//----- (0000B7D8) --------------------------------------------------------
void __fastcall __noreturn sub_B7D8(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B830) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B830(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B838: positive sp value 814 has been found
// B838: unbalanced stack, ignored a potential tail call

//----- (0000B844) --------------------------------------------------------
void __fastcall __noreturn sub_B844(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B89C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B89C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B8A4: positive sp value 814 has been found
// B8A4: unbalanced stack, ignored a potential tail call

//----- (0000B8B0) --------------------------------------------------------
void __fastcall __noreturn sub_B8B0(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B908) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B908(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B910: positive sp value 814 has been found
// B910: unbalanced stack, ignored a potential tail call

//----- (0000B91C) --------------------------------------------------------
void __fastcall __noreturn sub_B91C(const char *a1, int a2)
{
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B974) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B974(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B97C: positive sp value 814 has been found
// B97C: unbalanced stack, ignored a potential tail call

//----- (0000B988) --------------------------------------------------------
void __fastcall __noreturn sub_B988(int a1)
{
  int *v2; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v2 = _errno_location();
  snprintf(
    s,
    0x800u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v2,
    "driver-btm-L3.c",
    "bitmain_L3_prepare",
    a1);
  sub_38438(3, s, 1);
  sub_16724(1);
}

//----- (0000B9F0) --------------------------------------------------------
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int (**v3)(); // r9
  int v4; // r0
  int (*v5)(void); // r3
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r6
  const char **v11; // r7
  int v12; // r4
  int v13; // r5
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  unsigned int v48; // r3
  int v49; // r2
  unsigned int v50; // r0
  unsigned int v51; // r3
  unsigned int v52; // r2
  unsigned int v53; // r3
  _DWORD *v54; // r2
  int v55; // r3
  int v56; // r2
  _DWORD *v57; // r2
  int v58; // r1
  int v59; // r5
  size_t v60; // r6
  _DWORD *v61; // r0
  _DWORD *v62; // r7
  _DWORD *v63; // r0
  unsigned int v64; // r3
  _DWORD *v65; // r1
  _DWORD *v66; // r5
  unsigned int ii; // r6
  _DWORD *v68; // r9
  int v69; // r6
  char *v70; // r8
  unsigned int v71; // r3
  int v72; // r3
  _DWORD *v73; // r3
  unsigned int v74; // r1
  unsigned int v75; // r2
  bool v76; // cc
  int v77; // r2
  int v78; // r3
  int v79; // r5
  char *v80; // r9
  _DWORD *v81; // r0
  const char *v82; // r2
  _DWORD *v83; // r3
  int v84; // r0
  int v85; // r1
  int v86; // r2
  int v87; // r3
  int v88; // r3
  int v89; // r4
  int v90; // r5
  int v91; // r9
  int *v92; // r9
  FILE *v93; // r4
  signed int v94; // r0
  char *v95; // r0
  const char *v96; // r1
  char *v97; // r4
  char *v98; // r0
  int *v99; // r4
  char *v100; // r3
  char *v101; // r3
  char *v102; // r3
  size_t v103; // r0
  char *v104; // r12
  int v105; // r2
  int v106; // r0
  bool v107; // zf
  char *v108; // r12
  FILE *v109; // r0
  int v110; // r3
  int v111; // r3
  bool v112; // zf
  int *v113; // r6
  int v114; // r10
  char *v115; // r9
  FILE *v116; // r0
  int v117; // r3
  int v118; // r10
  char *v119; // r6
  char *v120; // r9
  char *v121; // r4
  FILE *v122; // r0
  int v123; // r3
  char *v124; // r12
  int v125; // r5
  int v126; // r6
  pthread_rwlock_t *v127; // r0
  char *v128; // r0
  char *v129; // r7
  int v130; // r5
  char *v131; // r8
  unsigned int v132; // r6
  int v133; // r3
  int v134; // r3
  char *v135; // r12
  char *v136; // r12
  int *v137; // r3
  int v138; // r0
  int v139; // t1
  char *v140; // r12
  char *v141; // r12
  int v142; // r6
  int *v143; // r7
  int v144; // r9
  int v145; // r3
  const char *v146; // r10
  size_t v147; // r0
  size_t v148; // r4
  char *v149; // r0
  char *v150; // r12
  int v151; // r2
  __sighandler_t v152; // r7
  __sighandler_t v153; // r0
  bool v154; // zf
  __pid_t v155; // r0
  __pid_t v156; // r7
  char *v157; // r12
  _DWORD *v158; // r0
  _DWORD *v159; // r7
  void *v160; // r0
  FILE *v161; // r0
  int v162; // r3
  char *v163; // r12
  char *v164; // r12
  int v165; // r3
  int v166; // r12
  int v167; // r1
  int v168; // r2
  int j; // r7
  int v170; // r6
  int v171; // r9
  int k; // r8
  int v173; // r7
  _DWORD *v174; // r4
  int v175; // r6
  _DWORD *v176; // r0
  int v177; // r3
  sem_t *v178; // r0
  sem_t *v179; // r6
  int *v180; // r4
  int v181; // r3
  int *v182; // r1
  int v183; // r12
  int v184; // r1
  int v185; // r0
  int v186; // lr
  int v187; // r6
  int v188; // r9
  int v189; // r6
  int v190; // r12
  int v191; // r2
  int v192; // lr
  int v193; // r3
  int v194; // r2
  int v195; // r1
  char *v196; // r1
  char *v197; // r12
  int v198; // r3
  char *v199; // r12
  int v200; // r7
  int v201; // r6
  int v202; // r3
  int v203; // r3
  int *v204; // r0
  int v205; // r0
  int v206; // r8
  int v207; // r0
  int v208; // r2
  int *v209; // lr
  int v210; // r0
  int v211; // r3
  int v212; // t1
  int v213; // r9
  int v214; // t1
  int v215; // r3
  int v216; // r9
  int v217; // r3
  int v218; // r3
  int v219; // r0
  int v220; // r1
  int v221; // r12
  int v222; // r0
  struct timeval *v223; // r6
  int *v224; // r9
  int *v225; // r3
  int *v226; // r0
  const char *v227; // lr
  int v228; // r0
  int v229; // r1
  int v230; // r2
  int v231; // r3
  _DWORD *v232; // lr
  char *v233; // r12
  int v234; // r1
  int v235; // r2
  char *v236; // r12
  int *v237; // r0
  char *v238; // r12
  int *v239; // r3
  int v240; // r1
  int v241; // t1
  int v242; // r9
  int v243; // r2
  int *v244; // lr
  int v245; // r0
  int v246; // r3
  int v247; // t1
  int v248; // r6
  int v249; // t1
  int v250; // r3
  int v251; // r6
  int v252; // r3
  int v253; // r3
  int v254; // r0
  int v255; // r1
  int v256; // r12
  int v257; // r0
  int v258; // r6
  struct timeval *v259; // r9
  __suseconds_t *v260; // r8
  __time_t v261; // r0
  __suseconds_t v262; // r1
  __time_t v263; // r2
  __suseconds_t v264; // r3
  __time_t v265; // r0
  __suseconds_t v266; // r1
  __suseconds_t v267; // r3
  const char **v268; // r12
  char *v269; // r12
  char *v270; // r12
  char *v271; // r12
  char *v272; // r12
  int m; // r6
  int v274; // r3
  int v275; // r8
  char *v276; // r10
  char *v277; // r9
  int n; // r8
  char *v279; // r12
  int v280; // r2
  char *v281; // r12
  char *v282; // r12
  char v283; // [sp+10h] [bp-29FCh] BYREF
  char v284[4088]; // [sp+1018h] [bp-19F4h] BYREF
  const char *v285; // [sp+2024h] [bp-9E8h]
  int *v286; // [sp+2028h] [bp-9E4h]
  void (__fastcall **v287)(); // [sp+202Ch] [bp-9E0h]
  char *v288; // [sp+2030h] [bp-9DCh]
  int *v289; // [sp+2034h] [bp-9D8h]
  char *v290; // [sp+2038h] [bp-9D4h]
  const char **v291; // [sp+203Ch] [bp-9D0h]
  char *s; // [sp+2040h] [bp-9CCh]
  int *v293; // [sp+2044h] [bp-9C8h]
  int *v294; // [sp+2048h] [bp-9C4h]
  int v295; // [sp+204Ch] [bp-9C0h] BYREF
  struct sigaction v296; // [sp+2054h] [bp-9B8h] BYREF
  char v297[256]; // [sp+20E0h] [bp-92Ch] BYREF
  int v298[513]; // [sp+21E0h] [bp-82Ch] BYREF

  v291 = a2;
  v295 = a1;
  strcpy(dword_62FA0, "cgminer.log");
  strcpy(word_630A0, "a+");
  byte_62F98 = 0;
  v4 = sysconf(84);
  v6 = v4 == 1;
  if ( v4 == 1 )
  {
    v5 = sched_yield;
    v3 = &off_60178;
  }
  v7 = 4 * (v295 + 1);
  if ( v6 )
    *v3 = v5;
  v8 = malloc(v7);
  v9 = v295;
  v10 = v8;
  dword_6141C = (int)v8;
  if ( v295 > 0 )
  {
    v11 = v291;
    v12 = 0;
    v13 = 0;
    do
    {
      ++v13;
      v14 = _strdup(v11[v12]);
      v9 = v295;
      v76 = v295 <= v13;
      v10[v12++] = v14;
    }
    while ( !v76 );
  }
  v10[v9] = 0;
  sub_173C0(&stru_6392C, "main", 10697);
  sub_173C0(&stru_63DFC, "main", 10698);
  sub_173C0(&stru_63D48, "main", 10699);
  sub_17418((int)&stru_63FB0, "main", 10700);
  sub_173C0(&mutex, "main", 10701);
  sub_173C0(&stru_61538, "main", 10702);
  sub_17418((int)&stru_63F78, "main", 10703);
  sub_173C0(&stru_612DC, "main", 10704);
  sub_173EC(&stru_61550, "main", 10705);
  sub_173EC(&stru_63880, "main", 10706);
  sub_173EC(&rwlock, "main", 10707);
  sub_173EC(&stru_63CA0, "main", 10708);
  sub_173C0(&stru_61314, "main", 10710);
  if ( pthread_cond_init(&stru_61330, 0) )
  {
    strcpy((char *)v298, "Failed to pthread_cond_init lp_cond");
    sub_38438(3, (const char *)v298, 1);
    sub_1C160(1, 0);
  }
  sub_173C0(&stru_63BCC, "main", 10714);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v298, "Failed to pthread_cond_init restart_cond");
    v196 = (char *)v298;
    goto LABEL_325;
  }
  if ( pthread_cond_init(&stru_63748, 0) )
  {
    strcpy((char *)v298, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2AA90();
    dword_63BC0 = (int)v15;
    if ( v15 )
    {
      dword_612C8 = (int)(v15 + 12);
      snprintf(byte_60EA4, 0x100u, "%s %s", "cgminer", a49);
      v296.sa_flags = 0;
      v296.sa_handler = (__sighandler_t)sub_1738C;
      sigemptyset(&v296.sa_mask);
      sigaction(15, &v296, &oact);
      sigaction(2, &v296, &stru_63EEC);
      signal(13, (__sighandler_t)1);
      dword_64214 = (int)v284;
      strcpy(v284, "/usr/bin");
      dword_63E54 = (int)&v283;
      v16 = _strdup(*v291);
      v17 = (char *)dword_63E54;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_63E54 + strlen((const char *)dword_63E54)) = 47;
      dword_61308 = 8;
      dword_612FC = 9;
      dword_61304 = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        s = (char *)v298;
        strcpy((char *)v298, "main OOM");
        sub_38438(3, (const char *)v298, 1);
        sub_16724(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_61570;
      v6 = dword_61570 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_61570 = (int)v20;
        v158 = malloc(0x2Cu);
        v159 = v158;
        *((_DWORD *)v20 + 17) = v158;
        if ( !v158 )
          goto LABEL_310;
        memset(v158, 0, 0x2Cu);
        v294 = (int *)(v20 + 68);
        v159[1] = 32;
        v159[2] = 5;
        v159[4] = v20 + 68;
        v159[5] = 68;
        v160 = malloc(0x180u);
        *v159 = v160;
        if ( !v160 )
          goto LABEL_310;
        memset(v160, 0, 0x180u);
        v24 = (int)v20;
        v159[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v294 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_31;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 0xAu:
          goto LABEL_22;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_22:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_23:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_24:
          v27 += v22[7] << 24;
LABEL_25:
          v27 += v22[6] << 16;
LABEL_26:
          v27 += v22[5] << 8;
LABEL_27:
          v27 += v22[4];
LABEL_28:
          v28 += v22[3] << 24;
LABEL_29:
          v28 += v22[2] << 16;
LABEL_30:
          v28 += v22[1] << 8;
LABEL_31:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = (v45 - v46 - v47) ^ (v47 >> 13);
      v49 = (v46 - v47 - v48) ^ (v48 >> 12);
      v50 = (v47 - v48 - v49) ^ (v49 << 16);
      v51 = (v48 - v49 - v50) ^ (v50 >> 5);
      v52 = v49 - v50 - v51;
      v53 = (v51 - (v52 ^ (v51 >> 3)) - ((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)))
          ^ (((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v53;
      v54 = *(_DWORD **)(v24 + 68);
      v55 = 12 * (v53 & (v54[1] - 1));
      ++*(_DWORD *)(*v54 + v55 + 4);
      v56 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v55);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v56;
      v57 = *(_DWORD **)(v24 + 68);
      v58 = *(_DWORD *)(*v57 + v55);
      if ( v58 )
      {
        *(_DWORD *)(v58 + 12) = v294;
        v57 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v57 + v55) = v294;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v55 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v55 + 8)
                                                                          + 1))
        || (v59 = *((_DWORD *)v20 + 17), *(_DWORD *)(v59 + 36) == 1) )
      {
LABEL_57:
        strcpy(dest, v20);
        dword_639E8 = (int)&dword_639E8;
        dword_639EC = (int)&dword_639E8;
        sub_48430((int)&off_5F8A0, (int)"Options for both config file and command line");
        sub_48430((int)&off_600C4, (int)"Options for command line only");
        sub_484FC(&v295, v291, (void (*)(const char *, ...))sub_1187C);
        if ( v295 != 1 )
        {
          strcpy((char *)v298, "Unexpected extra commandline arguments");
          sub_38438(3, (const char *)v298, 1);
          sub_1C160(1, 0);
        }
        v79 = (unsigned __int8)byte_611D0;
        if ( !byte_611D0 )
        {
          dword_611D4 = (int)malloc(0x1000u);
          sub_15C88((char *)dword_611D4);
          if ( access((const char *)dword_611D4, 4) )
          {
            free((void *)dword_611D4);
            dword_611D4 = v79;
          }
          else
          {
            sub_16814((char *)dword_611D4);
          }
        }
        if ( byte_615C9 || dword_612AC )
        {
          if ( byte_63DF9 )
          {
            s = (char *)v298;
            strcpy((char *)v298, "Cannot use benchmark mode with scrypt");
            sub_38438(3, (const char *)v298, 1);
            sub_16724(1);
          }
          s = (char *)v298;
          v80 = sub_1746C();
          v81 = malloc(0xFFu);
          if ( dword_612AC )
            v82 = "Benchfile";
          else
            v82 = "Benchmark";
          *((_DWORD *)v80 + 41) = v81;
          v83 = v81;
          v84 = *(_DWORD *)v82;
          v85 = *((_DWORD *)v82 + 1);
          v86 = *((_DWORD *)v82 + 2);
          *v83 = v84;
          v83[1] = v85;
          *((_WORD *)v83 + 4) = v86;
          v87 = *((_DWORD *)v80 + 41);
          *((_DWORD *)v80 + 43) = v87;
          *((_DWORD *)v80 + 44) = v87;
          *((_DWORD *)v80 + 42) = v87;
          *((_DWORD *)v80 + 148) = v87;
          strncpy(v80 + 48, "?", 7u);
          v88 = *((_DWORD *)v80 + 25);
          v80[55] = 0;
          if ( v88 != 1 )
          {
            *((_DWORD *)v80 + 25) = 1;
            ++dword_63B84;
          }
          v89 = 0;
          v80[97] = 0;
          byte_62F60 = 1;
          do
          {
            v90 = 324 * v89;
            v91 = 5 * v89++;
            v92 = (int *)(32 * v91);
            sub_295B8(&byte_615D8[(_DWORD)v92], (unsigned __int8 *)&a000000029c6bf4[v90], 160);
            sub_295B8(&byte_61FD8[(_DWORD)v92], (unsigned __int8 *)&a00000002c01f50[v90], 160);
          }
          while ( v89 != 16 );
          sub_15D7C((int)dword_629EC);
        }
        else
        {
          v92 = v298;
          s = (char *)v298;
        }
        if ( !dword_60EA0 )
        {
          v99 = (int *)byte_62E80;
          v290 = &byte_632F0;
          goto LABEL_103;
        }
        v93 = fopen((const char *)dword_60EA0, "rb");
        memset(v297, 0, sizeof(v297));
        if ( v93 )
        {
          v94 = fread(v297, 1u, 0x100u, v93);
          if ( v94 > 0 )
          {
            v95 = strchr(v297, 10);
            v96 = v297;
            v97 = v95;
            v6 = v95 == 0;
            v98 = ::s;
            if ( !v6 )
            {
              memcpy(::s, v297, v97 - v297);
              v98 = byte_62B0C;
              v96 = v97 + 1;
            }
            strcpy(v98, v96);
            v99 = (int *)byte_62E80;
            v100 = (char *)&byte_62E80[strlen(::s) - 1];
            if ( *(v100 - 1140) == 10 )
              *(v100 - 1140) = 0;
            v101 = (char *)&byte_62E80[strlen(::s) - 1];
            if ( *(v101 - 1140) == 13 )
              *(v101 - 1140) = 0;
            v102 = (char *)&byte_62E80[strlen(byte_62B0C) - 1];
            if ( *(v102 - 884) == 10 )
              *(v102 - 884) = 0;
            v103 = strlen(byte_62B0C) - 1;
            v105 = byte_62E80[v103 - 884];
            if ( v105 == 13 )
            {
              v104 = &byte_632F0;
              byte_62E80[v103 - 884] = 0;
            }
            else
            {
              v92 = (int *)&byte_632F0;
            }
            if ( v105 == 13 )
              v290 = v104;
            else
              v290 = (char *)v92;
            goto LABEL_98;
          }
          v290 = &byte_632F0;
          if ( byte_632F0 || (v288 = &byte_630C0, byte_630C0) || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_60EA0, v94);
            goto LABEL_252;
          }
        }
        else
        {
          v290 = &byte_632F0;
          if ( byte_632F0 || (v288 = &byte_630C0, byte_630C0) || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_60EA0);
LABEL_252:
            v99 = (int *)byte_62E80;
            sub_38438(3, s, 0);
LABEL_98:
            if ( *v290 )
            {
LABEL_102:
              snprintf(s, 0x800u, "Miner compile time: %s type: %s", ::s, byte_62B0C);
              sub_38438(3, s, 0);
              goto LABEL_103;
            }
            v288 = &byte_630C0;
            goto LABEL_100;
          }
        }
        v99 = (int *)byte_62E80;
LABEL_100:
        if ( *v288 || dword_60964 > 2 )
          goto LABEL_102;
LABEL_103:
        if ( dword_60E90 )
        {
          byte_62F98 = 1;
          strcpy(dword_62FA0, (const char *)dword_60E90);
          if ( dword_60E9C )
            strcpy(word_630A0, (const char *)dword_60E9C);
          if ( *v290 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log file path: %s Open flag: %s", dword_62FA0, word_630A0);
            sub_38438(3, s, 0);
          }
        }
        if ( dword_60E98 )
        {
          memset(v297, 0, sizeof(v297));
          if ( dword_60E94 )
          {
            if ( !*(_BYTE *)dword_60E94 )
            {
              v157 = s;
              *(_DWORD *)s = *(_DWORD *)"Log work asic num empty";
              strcpy(v157 + 4, "work asic num empty");
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            v106 = strtol((const char *)dword_60E94, 0, 10);
            v107 = v106 == 32;
            if ( v106 != 32 )
              v107 = v106 == 1;
            dword_62C0C = v106;
            if ( !v107 && v106 != 64 )
            {
              v108 = s;
              *(_DWORD *)s = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy(v108 + 4, "work asic num must be 1, 32, 64");
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            if ( *v290 || byte_630C0 || dword_60964 > 2 )
            {
              snprintf(
                s,
                0x800u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_60E98,
                (const char *)dword_60E94);
              sub_38438(3, s, 0);
            }
          }
          else if ( *v290 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log work path: %s", (const char *)dword_60E98);
            sub_38438(3, s, 0);
          }
          sprintf(v297, "%s.txt", (const char *)dword_60E98);
          v109 = fopen(v297, "a+");
          v110 = (unsigned __int8)*v290;
          dword_62C10 = (int)v109;
          if ( v110 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log work open file %s", v297);
            sub_38438(3, s, 0);
          }
          v111 = dword_62C0C;
          if ( dword_62C0C == 1 )
          {
            sprintf(v297, "%s%02d.txt", (const char *)dword_60E98, 1);
            v161 = fopen(v297, "a+");
            v162 = (unsigned __int8)*v290;
            dword_62C14 = (int)v161;
            if ( v162 || byte_630C0 || dword_60964 > 2 )
            {
              snprintf(s, 0x800u, "Log work open asic %d file %s", dword_62C0C, v297);
              sub_38438(3, s, 0);
            }
          }
          else
          {
            v112 = dword_62C0C == 32;
            if ( dword_62C0C != 32 )
              v112 = dword_62C0C == 64;
            if ( v112 && dword_62C0C >= 0 )
            {
              v113 = &dword_62C10;
              v114 = 0;
              v115 = s;
              do
              {
                sprintf(v297, "%s%02d_%02d.txt", (const char *)dword_60E98, v111, v114);
                v116 = fopen(v297, "a+");
                v117 = (unsigned __int8)*v290;
                v113[1] = (int)v116;
                ++v113;
                if ( v117 || byte_630C0 || dword_60964 > 2 )
                {
                  snprintf(v115, 0x800u, "Log work open asic %d file %s", dword_62C0C, v297);
                  sub_38438(3, v115, 0);
                }
                v111 = dword_62C0C;
                ++v114;
              }
              while ( dword_62C0C >= v114 );
            }
          }
          if ( byte_62D18 )
          {
            v294 = (int *)byte_62E80;
            v118 = 0;
            v119 = &byte_62D18;
            v120 = s;
            v121 = v290;
            do
            {
              sprintf(v297, "%s_diff_%02d.txt", (const char *)dword_60E98, v118);
              v122 = fopen(v297, "a+");
              v123 = (unsigned __int8)*v121;
              *((_DWORD *)v119 + 1) = v122;
              v119 += 4;
              if ( v123 || byte_630C0 || dword_60964 > 2 )
              {
                snprintf(v120, 0x800u, "Log work open diff file %s", v297);
                sub_38438(3, v120, 0);
              }
              ++v118;
            }
            while ( v118 != 65 );
            v99 = v294;
          }
        }
        if ( byte_640B8 )
        {
          v289 = dword_5F890;
          byte_6007C = 0;
        }
        else
        {
          v289 = dword_5F890;
          if ( byte_6007C )
            sub_277B0();
        }
        if ( *v290 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Started %s", byte_60EA4);
          sub_38438(4, s, 0);
        }
        if ( !dword_611D4 )
        {
LABEL_167:
          *(_WORD *)(dword_64214 + strlen((const char *)dword_64214)) = 47;
          if ( byte_63DF8 )
            byte_630C0 = 1;
          if ( v289[512] < 0 )
          {
            if ( byte_63DF9 )
              v134 = 30;
            else
              v134 = 60;
            v289[512] = v134;
          }
          *(int *)((char *)v99 + 0xFFFFFFA0) = 8;
          dword_636A4 = (int)calloc(8u, 0x40u);
          if ( !dword_636A4 )
          {
            v164 = s;
            *(_DWORD *)s = *(_DWORD *)"Failed to calloc control_thr";
            strcpy(v164 + 4, "ed to calloc control_thr");
            sub_38438(3, s, 1);
            sub_1C160(1, 0);
          }
          v125 = 0;
          dword_62E24 = 0;
          v285 = (const char *)&unk_63CC8;
          sub_278E0((int)&unk_63CC8);
          sub_278E0((int)&unk_63270);
          sub_278E0((int)&unk_63D78);
          sub_278E0((int)&unk_639F0);
          sub_278E0((int)&unk_60D68);
          sub_278E0((int)&unk_64240);
          sub_278E0((int)&unk_63A78);
          sub_278E0((int)&unk_63C18);
          sub_278E0((int)&unk_63FE8);
          sub_278E0((int)&unk_63310);
          sub_278E0((int)&unk_64110);
          sub_278E0((int)&unk_63418);
          sub_278E0((int)&unk_638A8);
          sub_278E0((int)&unk_63800);
          sub_278E0((int)&unk_63518);
          sub_278E0((int)&unk_63E60);
          sub_278E0((int)&unk_63620);
          sub_278E0((int)&unk_63598);
          sub_278E0((int)&unk_63B00);
          sub_278E0((int)&unk_63948);
          sub_278E0((int)&unk_63778);
          sub_278E0((int)&unk_64190);
          sub_278E0((int)&unk_63498);
          sub_278E0((int)&unk_63390);
          (*((void (__fastcall **)(_DWORD))v285 + 3))(0);
          off_6327C(0);
          off_63D84(0);
          off_639FC(0);
          off_60D74();
          off_6424C(0);
          off_63A84(0);
          off_63C24(0);
          ((void (__fastcall *)(_DWORD))off_63FF4)(0);
          off_6331C(0);
          off_6411C(0);
          off_63424(0);
          off_638B4(0);
          ((void (__fastcall *)(_DWORD))off_6380C)(0);
          off_63524(0);
          off_63E6C(0);
          off_6362C(0);
          off_635A4(0);
          ((void (__fastcall *)(_DWORD))off_63B0C)(0);
          off_63954(0);
          off_63784(0);
          off_6419C(0);
          off_634A4(0);
          ((void (__fastcall *)(_DWORD))off_6339C)(0);
          v126 = dword_63CC0;
          dword_6410C = 0;
          if ( dword_63CC0 > 0 )
          {
            v294 = &dword_63BC8;
            do
            {
              v127 = *(pthread_rwlock_t **)(dword_63BC8 + 4 * v125++);
              sub_27B20(v127);
              v126 = dword_63CC0;
            }
            while ( dword_63CC0 > v125 );
          }
          if ( !v126 )
          {
            v163 = s;
            *(_DWORD *)s = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy(v163 + 4, "devices disabled, cannot mine!");
            sub_38438(3, s, 1);
            sub_1C160(1, 0);
          }
          dword_6130C = v126;
          if ( dword_611B0 )
          {
            v128 = strtok((char *)dword_611B0, ",");
            v294 = &dword_63BC8;
            v129 = v128;
            if ( v128 )
            {
              v130 = 0;
              v131 = s;
              do
              {
                if ( v130 >= dword_63CC0 )
                {
                  strcpy(v131, "Too many values passed to set temp cutoff");
                  sub_38438(3, v131, 1);
                  sub_16724(1);
                }
                v132 = strtol(v129, 0, 10);
                if ( v132 > 0xC8 )
                {
                  strcpy(v131, "Invalid value passed to set temp cutoff");
                  sub_38438(3, v131, 1);
                  sub_16724(1);
                }
                sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1143);
                v133 = *(_DWORD *)(dword_63BC8 + 4 * v130++);
                *(_DWORD *)(v133 + 184) = v132;
                sub_19598(&stru_63CA0, "load_temp_cutoffs", 1145);
                v129 = strtok(0, ",");
              }
              while ( v129 );
              if ( v130 != 1 )
                goto LABEL_198;
            }
            else
            {
              v130 = 0;
              v132 = 0;
            }
            sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1162);
            v193 = *v294;
            v194 = dword_63CC0;
            while ( v130 < v194 )
            {
              v195 = *(_DWORD *)(v193 + 4 * v130++);
              *(_DWORD *)(v195 + 184) = v132;
            }
            sub_19598(&stru_63CA0, "load_temp_cutoffs", 1165);
            goto LABEL_198;
          }
          v294 = &dword_63BC8;
          sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1150);
          v165 = 0;
          v166 = dword_63BC8;
          v167 = dword_63CC0;
          while ( v165 < v167 )
          {
            v168 = *(_DWORD *)(v166 + 4 * v165++);
            if ( !*(_DWORD *)(v168 + 184) )
              *(_DWORD *)(v168 + 184) = 95;
          }
          sub_19598(&stru_63CA0, "load_temp_cutoffs", 1156);
LABEL_198:
          if ( dword_63CC0 > 0 )
          {
            v137 = (int *)*v294;
            v138 = *v294 + 4 * dword_63CC0;
            do
            {
              v139 = *v137++;
              *(_DWORD *)(v139 + 312) = 99999999;
            }
            while ( v137 != (int *)v138 );
          }
          if ( !byte_63EE0 )
          {
            dword_612FC += dword_6130C;
            dword_61304 = dword_612FC + 1;
            sub_191C4();
          }
          if ( !dword_63740 )
          {
            if ( *v290 || byte_630C0 || dword_60964 > 3 )
            {
              v140 = s;
              *(_DWORD *)s = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy(v140 + 4, " to specify at least one pool server.");
              sub_38438(4, s, 0);
            }
            if ( !*((_BYTE *)v289 + 2028) || !sub_26934(0) )
            {
              v141 = s;
              *(_DWORD *)s = *(_DWORD *)"Pool setup failed";
              strcpy(v141 + 4, " setup failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
          }
          if ( dword_63740 > 0 )
          {
            v142 = 0;
            v143 = v99;
            do
            {
              v144 = *(_DWORD *)(dword_639E0 + 4 * v142);
              v145 = *(_DWORD *)(v144 + 168);
              *(_DWORD *)(v144 + 396) = 99999999;
              *(_DWORD *)(v144 + 432) = 99999999;
              if ( !v145 )
              {
                if ( !*(_DWORD *)(v144 + 176) )
                  *(_DWORD *)(v144 + 176) = calloc(1u, 1u);
                v146 = *(const char **)(v144 + 172);
                if ( !v146 )
                {
                  snprintf(
                    s,
                    0x800u,
                    "No login credentials supplied for pool %u %s",
                    v142,
                    *(const char **)(v144 + 164));
                  sub_38438(3, s, 1);
                  sub_1C160(1, 0);
                }
                v147 = strlen(*(const char **)(v144 + 172));
                v285 = *(const char **)(v144 + 176);
                v148 = v147 + strlen(v285) + 2;
                v149 = (char *)malloc(v148);
                *(_DWORD *)(v144 + 168) = v149;
                if ( !v149 )
                {
                  v282 = s;
                  *(_DWORD *)s = *(_DWORD *)"Failed to malloc userpass";
                  strcpy(v282 + 4, "ed to malloc userpass");
                  sub_38438(3, s, 1);
                  sub_1C160(1, 0);
                }
                snprintf(v149, v148, "%s:%s", v146, v285);
              }
              ++v142;
            }
            while ( dword_63740 > v142 );
            v99 = v143;
          }
          v151 = (unsigned __int8)*v290;
          dword_61310 = *(_DWORD *)dword_639E0;
          if ( v151 )
            openlog("cgminer", 1, 8);
          if ( *(int *)((char *)v99 + 0xFFFFFFA8) )
          {
            if ( pipe((int *)s) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v298[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(v298[1]) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v152 = signal(13, (__sighandler_t)1);
            v153 = signal(13, (__sighandler_t)1);
            v154 = (__sighandler_t)((char *)v153 + 1) == 0;
            if ( v153 != (__sighandler_t)-1 )
              v154 = (__sighandler_t)((char *)v152 + 1) == 0;
            if ( v154 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v155 = fork();
            v156 = v155;
            dword_61418 = v155;
            if ( v155 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v155 )
            {
              if ( dup2(v298[0], v155) >= 0 )
              {
                close(v298[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_62E28, v156);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v298[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          dword_63B80 = (int)calloc(dword_6410C, 4u);
          if ( !dword_63B80 )
          {
            v279 = s;
            *(_DWORD *)s = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy(v279 + 4, "ed to calloc mining_thr");
            goto LABEL_485;
          }
          for ( j = 0; j < dword_6410C; ++j )
          {
            v170 = dword_63B80;
            *(_DWORD *)(v170 + 4 * j) = calloc(1u, 0x40u);
            if ( !*(_DWORD *)(dword_63B80 + 4 * j) )
            {
              snprintf(s, 0x800u, "Failed to calloc mining_thr[%d]", j);
LABEL_485:
              v196 = s;
LABEL_325:
              sub_38438(3, v196, 1);
              sub_1C160(1, 0);
            }
          }
          v171 = 0;
          v293 = v99;
          for ( k = 0; k < dword_63CC0; ++k )
          {
            v173 = 0;
            v174 = *(_DWORD **)(*v294 + 4 * k);
            v175 = v174[37];
            v176 = malloc(4 * (v175 + 1));
            v174[38] = v176;
            v176[v175] = 0;
            v177 = v174[37];
            v174[24] = 4;
            if ( v177 > 0 )
            {
              do
              {
                v178 = (sem_t *)sub_1C36C(v171);
                v178->__align = v171;
                v179 = v178;
                *(&v178[2].__align + 1) = (int)v174;
                *(&v178->__align + 1) = v173;
                if ( (*(int (**)(void))(v174[1] + 44))() )
                {
                  if ( sub_2F0EC((int)v179, 0, (void *(*)(void *))sub_11A5C, v179) )
                  {
                    snprintf(s, 0x800u, "thread %d create failed", v179->__align);
                    sub_38438(3, s, 1);
                    sub_1C160(1, 0);
                  }
                  *(_DWORD *)(v174[38] + 4 * v173) = v179;
                  if ( v174[8] != 1 )
                  {
                    if ( byte_630C1 && (*v290 || byte_630C0 || dword_60964 > 6) )
                    {
                      snprintf(s, 0x800u, "Pushing sem post to thread %d", v179->__align);
                      sub_38438(7, s, 0);
                    }
                    sub_2F134(v179 + 1, "cgminer.c", "main", 11102);
                  }
                }
                ++v173;
                ++v171;
              }
              while ( v174[37] > v173 );
            }
          }
          v180 = v293;
          if ( byte_615C9 || (v181 = dword_612AC) != 0 )
          {
LABEL_298:
            v182 = (int *)dbl_61380;
            dbl_63268 = 0.0;
            do
            {
              *(_QWORD *)v182 = 0;
              v182 += 2;
            }
            while ( v182 != &dword_613E0 );
            v183 = dword_63CC0;
            v184 = 0;
            dword_613E0 = 0;
            v185 = *v294;
            while ( v184 < v183 )
            {
              v186 = *(_DWORD *)(v185 + 4 * v184++);
              *(_QWORD *)(v186 + 80) = 0;
              *(_QWORD *)(v186 + 48) = 0;
            }
            sub_2B13C((struct timeval *)&dword_61370);
            sub_2B13C((struct timeval *)&dword_613E4);
            sub_2B13C((struct timeval *)dword_61378);
            sub_14D9C(byte_613EC, 0x28u, &dword_61370);
            dword_61420 = 2;
            v187 = dword_636A4;
            if ( sub_2F0EC(dword_636A4 + 128, 0, (void *(*)(void *))sub_21364, 0) )
            {
              v271 = s;
              *(_DWORD *)s = *(_DWORD *)"watchpool thread create failed";
              strcpy(v271 + 4, "hpool thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*(_DWORD *)(v187 + 140));
            dword_61424 = 3;
            v285 = (const char *)dword_636A4;
            if ( sub_2F0EC(dword_636A4 + 192, 0, (void *(*)(void *))sub_23018, 0) )
            {
              v197 = s;
              *(_DWORD *)s = *(_DWORD *)"watchdog thread create failed";
              strcpy(v197 + 4, "hdog thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*((_DWORD *)v285 + 51));
            dword_611A8 = 5;
            if ( sub_2F0EC(dword_636A4 + 320, 0, (void *(*)(void *))sub_11CBC, (void *)(dword_636A4 + 320)) )
            {
              v270 = s;
              *(_DWORD *)s = *(_DWORD *)"API thread create failed";
              strcpy(v270 + 4, "thread create failed");
LABEL_309:
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            v188 = dword_636A4;
            *(int *)((char *)v180 + 0xFFFFFFAC) = 7;
            if ( sub_2F0EC(v188 + 448, 0, (void *(*)(void *))sub_276A8, (void *)(v188 + 448)) )
            {
              v269 = s;
              *(_DWORD *)s = *(_DWORD *)"input thread create failed";
              strcpy(v269 + 4, "t thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*(_DWORD *)(v188 + 460));
            if ( dword_62E20 != 8 )
            {
              snprintf(s, 0x800u, "incorrect total_control_threads (%d) should be 8", dword_62E20);
              goto LABEL_309;
            }
            if ( nice(-10) )
            {
              v288 = &byte_630C0;
              v286 = &dword_60964;
              v291 = (const char **)&byte_630C1;
            }
            else
            {
              v291 = (const char **)&byte_630C1;
              if ( byte_630C1 )
              {
                v198 = (unsigned __int8)*v290;
                v288 = &byte_630C0;
                if ( v198 || byte_630C0 )
                {
                  v286 = &dword_60964;
                }
                else
                {
                  v286 = &dword_60964;
                  if ( dword_60964 <= 6 )
                    goto LABEL_333;
                }
                v199 = s;
                *(_DWORD *)s = *(_DWORD *)"Unable to set thread to high priority";
                strcpy(v199 + 4, "le to set thread to high priority");
                sub_38438(7, s, 0);
              }
              else
              {
                v288 = &byte_630C0;
                v286 = &dword_60964;
              }
            }
LABEL_333:
            v293 = 0;
            v287 = (void (__fastcall **)())&off_60178;
            while ( 1 )
            {
              while ( 1 )
              {
                v200 = v289[504];
                if ( byte_63E4C )
                {
                  if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
                  {
                    v238 = s;
                    *(_DWORD *)s = *(_DWORD *)"Work update message received";
                    strcpy(v238 + 4, " update message received");
                    sub_38438(7, s, 0);
                  }
                  sub_2B13C(&stru_611BC);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B76C("signal_work_update", 5292);
                  if ( dword_6410C > 0 )
                  {
                    v239 = (int *)dword_63B80;
                    v240 = dword_63B80 + 4 * dword_6410C;
                    do
                    {
                      v241 = *v239++;
                      *(_BYTE *)(v241 + 63) = 1;
                    }
                    while ( v239 != (int *)v240 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B700("signal_work_update", 5295);
                  (*v287)();
                }
                byte_63E4C = 0;
                sub_1D644();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
                  sub_B4E4("main", 11239);
                v201 = dword_612CC;
                if ( dword_612CC )
                  v201 = *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12);
                if ( v200 < v201 )
                {
                  if ( byte_612D2 )
                  {
                    v202 = v289[504];
                    if ( v202 < v289[505] )
                    {
                      dword_60070 = v202 + 1;
                      byte_612D2 = 0;
                    }
                  }
                  byte_612D1 = 1;
                  pthread_cond_wait(&stru_63748, (pthread_mutex_t *)dword_612C8);
                  v201 = dword_612CC;
                  if ( dword_612CC )
                    v201 = *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
                  sub_B694("main", 11257);
                (*v287)();
                if ( v201 <= v200 )
                  break;
                if ( byte_612D2 )
                {
                  v203 = v289[504];
                  if ( v203 < v289[505] )
                  {
                    dword_60070 = v203 + 1;
                    byte_612D2 = 0;
                  }
                }
                byte_612D1 = 1;
                v204 = (int *)sub_17A14(0);
                v293 = v204;
                if ( v204 )
                {
                  sub_154EC((int)v204);
                  v293 = 0;
                }
              }
              if ( v293 )
                sub_154EC((int)v293);
              v293 = sub_19DA0();
              v205 = sub_1D644();
              v206 = v205;
              if ( dword_611AC == 4 )
              {
                v206 = sub_11DA8(v205);
              }
              else if ( dword_611AC == 3 )
              {
                v243 = dword_63740;
                if ( dword_63740 <= 0 )
                  goto LABEL_436;
                if ( *(_DWORD *)(*(_DWORD *)dword_639E0 + 60) <= *(_DWORD *)(*(_DWORD *)dword_639E0 + 64) )
                {
                  v244 = (int *)dword_639E0;
                  v245 = dword_639E0;
                  v246 = 0;
                  while ( ++v246 != dword_63740 )
                  {
                    v247 = *(_DWORD *)(v245 + 4);
                    v245 += 4;
                    if ( *(_DWORD *)(v247 + 64) < *(_DWORD *)(v247 + 60) )
                      goto LABEL_438;
                  }
                  v248 = dword_639E0 + 4 * dword_63740;
                  do
                  {
                    v249 = *v244++;
                    *(_DWORD *)(v249 + 64) = 0;
                  }
                  while ( v244 != (int *)v248 );
LABEL_436:
                  v250 = *(int *)((char *)v180 + 0xFFFFFFB0) + 1;
                  *(int *)((char *)v180 + 0xFFFFFFB0) = v250;
                  if ( v250 >= v243 )
                    dword_62E30 = 0;
                }
LABEL_438:
                v251 = 0;
                while ( 1 )
                {
                  v76 = v251++ < v243;
                  if ( !v76 )
                    break;
                  v253 = *(int *)((char *)v180 + 0xFFFFFFB0);
                  v254 = *(_DWORD *)(dword_639E0 + 4 * v253);
                  v255 = *(_DWORD *)(v254 + 64);
                  v256 = *(_DWORD *)(v254 + 60);
                  *(_DWORD *)(v254 + 64) = v255 + 1;
                  if ( v255 < v256 )
                  {
                    if ( !*(_BYTE *)(v254 + 97)
                      && *(_DWORD *)(v254 + 100) == 1
                      && (!*(_BYTE *)(v254 + 632) || *(_BYTE *)(v254 + 633)) )
                    {
                      goto LABEL_450;
                    }
                    if ( byte_63BC5 )
                    {
                      v257 = sub_11B90(0);
                      v253 = *(int *)((char *)v180 + 0xFFFFFFB0);
                      v243 = dword_63740;
                      --*(_DWORD *)(v257 + 64);
                    }
                  }
                  v252 = v253 + 1;
                  *(int *)((char *)v180 + 0xFFFFFFB0) = v252;
                  if ( v252 >= v243 )
                    dword_62E30 = 0;
                }
                if ( v243 > 0 )
                {
                  v258 = 0;
                  while ( 1 )
                  {
                    v254 = sub_11B90(v258);
                    if ( !*(_BYTE *)(v254 + 97) && *(_DWORD *)(v254 + 100) == 1 )
                      break;
                    if ( ++v258 >= dword_63740 )
                      goto LABEL_355;
                  }
LABEL_450:
                  v206 = v254;
                }
              }
LABEL_355:
              if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
              {
                snprintf(s, 0x800u, "Selecting pool %d for work", *(_DWORD *)v206);
                sub_38438(7, s, 0);
              }
              if ( *(_BYTE *)(v206 + 632) )
              {
                while ( !*(_BYTE *)(v206 + 633) || !*(_BYTE *)(v206 + 635) )
                {
                  v207 = sub_1D644();
                  v294 = (int *)v207;
                  if ( dword_611AC == 4 )
                  {
                    v294 = (int *)sub_11DA8(v207);
                  }
                  else if ( dword_611AC == 3 || !byte_63BC5 )
                  {
                    v208 = dword_63740;
                    if ( dword_63740 <= 0 )
                      goto LABEL_374;
                    if ( *(_DWORD *)(*(_DWORD *)dword_639E0 + 60) <= *(_DWORD *)(*(_DWORD *)dword_639E0 + 64) )
                    {
                      v209 = (int *)dword_639E0;
                      v210 = dword_639E0;
                      v211 = 0;
                      while ( ++v211 != dword_63740 )
                      {
                        v212 = *(_DWORD *)(v210 + 4);
                        v210 += 4;
                        if ( *(_DWORD *)(v212 + 64) < *(_DWORD *)(v212 + 60) )
                          goto LABEL_376;
                      }
                      v213 = dword_639E0 + 4 * dword_63740;
                      do
                      {
                        v214 = *v209++;
                        *(_DWORD *)(v214 + 64) = 0;
                      }
                      while ( v209 != (int *)v213 );
LABEL_374:
                      v215 = *(int *)((char *)v180 + 0xFFFFFFB0) + 1;
                      *(int *)((char *)v180 + 0xFFFFFFB0) = v215;
                      if ( v215 >= v208 )
                        dword_62E30 = 0;
                    }
LABEL_376:
                    v216 = 0;
                    while ( 1 )
                    {
                      v76 = v216++ < v208;
                      if ( !v76 )
                        break;
                      v218 = *(int *)((char *)v180 + 0xFFFFFFB0);
                      v219 = *(_DWORD *)(dword_639E0 + 4 * v218);
                      v220 = *(_DWORD *)(v219 + 64);
                      v221 = *(_DWORD *)(v219 + 60);
                      *(_DWORD *)(v219 + 64) = v220 + 1;
                      if ( v220 < v221 )
                      {
                        if ( !*(_BYTE *)(v219 + 97)
                          && *(_DWORD *)(v219 + 100) == 1
                          && (!*(_BYTE *)(v219 + 632) || *(_BYTE *)(v219 + 633)) )
                        {
                          goto LABEL_388;
                        }
                        if ( byte_63BC5 )
                        {
                          v222 = sub_11B90(0);
                          v218 = *(int *)((char *)v180 + 0xFFFFFFB0);
                          v208 = dword_63740;
                          --*(_DWORD *)(v222 + 64);
                        }
                      }
                      v217 = v218 + 1;
                      *(int *)((char *)v180 + 0xFFFFFFB0) = v217;
                      if ( v217 >= v208 )
                        dword_62E30 = 0;
                    }
                    if ( v208 > 0 )
                    {
                      v242 = 0;
                      while ( 1 )
                      {
                        v219 = sub_11B90(v242);
                        if ( !*(_BYTE *)(v219 + 97) && *(_DWORD *)(v219 + 100) == 1 )
                          break;
                        if ( ++v242 >= dword_63740 )
                          goto LABEL_389;
                      }
LABEL_388:
                      v294 = (int *)v219;
                    }
                  }
LABEL_389:
                  if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
                  {
                    snprintf(s, 0x800u, "Selecting pool %d for work", *v294);
                    sub_38438(7, s, 0);
                  }
                  sub_2B21C();
                  if ( (int *)v206 != v294 )
                  {
                    v206 = (int)v294;
                    if ( !*((_BYTE *)v294 + 632) )
                      goto LABEL_396;
                  }
                }
                sub_1A514(v206, (int)v293);
                if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
                {
                  v236 = s;
                  *(_DWORD *)s = *(_DWORD *)"Generated stratum work";
                  strcpy(v236 + 4, "rated stratum work");
                  sub_38438(7, s, 0);
                }
LABEL_409:
                v237 = v293;
                v293 = 0;
                sub_1ED4C((int)v237);
              }
              else
              {
LABEL_396:
                if ( dword_612AC )
                {
                  v223 = (struct timeval *)(v293 + 100);
                  sub_16CD0(v293);
                  v224 = v293;
                  v225 = (int *)dword_639E0;
                  *((_BYTE *)v293 + 282) = 1;
                  v224[65] = *v225;
                  sub_2B13C(v223);
                  sub_2AE20(v224 + 102, v223);
                  v226 = v293;
                  *((_BYTE *)v224 + 440) = 66;
                  sub_113C4((int)v226);
                  if ( !*(_BYTE *)v291 || !*v290 && !*v288 && *v286 <= 6 )
                    goto LABEL_409;
                  v227 = "Generated benchfile work";
                  goto LABEL_402;
                }
                if ( byte_615C9 )
                {
                  v259 = (struct timeval *)v293;
                  *((_QWORD *)v293 + 47) = 0x4040000000000000LL;
                  v260 = (__suseconds_t *)dword_639E0;
                  v261 = dword_629EC[0];
                  v262 = dword_629EC[1];
                  v263 = dword_629EC[2];
                  v264 = dword_629EC[3];
                  v259[30].tv_usec = 0;
                  BYTE2(v259[35].tv_sec) = 1;
                  v259[20].tv_sec = v261;
                  v259[20].tv_usec = v262;
                  v259[21].tv_sec = v263;
                  v259[21].tv_usec = v264;
                  v265 = unk_629FC;
                  v266 = unk_62A00;
                  v267 = unk_62A08;
                  v259[23].tv_sec = unk_62A04;
                  v259[22].tv_sec = v265;
                  v259[22].tv_usec = v266;
                  v259[23].tv_usec = v267;
                  v259[32].tv_usec = *v260;
                  sub_2B13C(v259 + 50);
                  sub_2AE20(&v259[51].tv_sec, &v259[50].tv_sec);
                  v268 = v291;
                  LOBYTE(v259[55].tv_sec) = 66;
                  if ( !*(_BYTE *)v268 || !*v290 && !*v288 && *v286 <= 6 )
                    goto LABEL_409;
                  v227 = "Generated benchmark work";
LABEL_402:
                  v228 = *(_DWORD *)v227;
                  v229 = *((_DWORD *)v227 + 1);
                  v230 = *((_DWORD *)v227 + 2);
                  v231 = *((_DWORD *)v227 + 3);
                  v232 = v227 + 16;
                  v233 = s;
                  *(_DWORD *)s = v228;
                  *((_DWORD *)v233 + 1) = v229;
                  *((_DWORD *)v233 + 2) = v230;
                  *((_DWORD *)v233 + 3) = v231;
                  v233 += 16;
                  v234 = v232[1];
                  v235 = v232[2];
                  *(_DWORD *)v233 = *v232;
                  *((_DWORD *)v233 + 1) = v234;
                  v233[8] = v235;
                  sub_38438(7, s, 0);
                  goto LABEL_409;
                }
              }
            }
          }
          v189 = dword_639E0;
          v190 = dword_63740;
          while ( v181 < v190 )
          {
            v191 = *(_DWORD *)(v189 + 4 * v181++);
            v192 = *(_DWORD *)(v191 + 100);
            *(_BYTE *)(v191 + 97) = 1;
            if ( v192 != 1 )
            {
              *(_DWORD *)(v191 + 100) = 1;
              ++dword_63B84;
            }
          }
          if ( byte_630C1 && (*v290 || byte_630C0 || dword_60964 > 6) )
          {
            v272 = s;
            *(_DWORD *)s = *(_DWORD *)"Probing for an alive pool";
            strcpy(v272 + 4, "ing for an alive pool");
            sub_38438(7, s, 0);
          }
          for ( m = 0; m < dword_63740; ++m )
          {
            v274 = *(_DWORD *)(dword_639E0 + 4 * m);
            *(_BYTE *)(v274 + 284) = 1;
            pthread_create((pthread_t *)(v274 + 280), 0, (void *(*)(void *))start_routine, (void *)v274);
          }
          v275 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_615C8 )
              break;
            if ( !--v275 )
              goto LABEL_490;
          }
          v275 = 0;
LABEL_490:
          v276 = s;
          v277 = v290;
          while ( 1 )
          {
            if ( byte_615C8 )
              goto LABEL_298;
            if ( !v275 )
            {
              if ( ((*v277 || byte_630C0 || dword_60964 > 2)
                 && ((strcpy(v276, "No servers were found that could be used to get work from."),
                      sub_38438(3, v276, 0),
                      *v277)
                  || byte_630C0)
                 || dword_60964 > 2)
                && ((strcpy(v276, "Please check the details from the list below of the servers you have input"),
                     sub_38438(3, v276, 0),
                     *v277)
                 || byte_630C0)
                || dword_60964 > 2 )
              {
                strcpy(
                  v276,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_38438(3, v276, 0);
              }
              for ( n = 0; n < dword_63740; ++n )
              {
                if ( *v277 || byte_630C0 || dword_60964 > 3 )
                {
                  snprintf(
                    v276,
                    0x800u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    n,
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 164),
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 172),
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 176));
                  sub_38438(4, v276, 0);
                }
              }
              if ( !*((_BYTE *)v289 + 2028) )
              {
LABEL_524:
                v281 = s;
                *(_DWORD *)s = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy(v281 + 4, "ervers could be used! Exiting.");
                sub_38438(3, s, 1);
                sub_1C160(0, 0);
              }
              if ( !*v277 && !byte_630C0 && dword_60964 <= 2 )
              {
                v275 = 1;
                goto LABEL_518;
              }
              v275 = 1;
              strcpy(v276, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_38438(3, v276, 0);
            }
            if ( !*((_BYTE *)v289 + 2028) )
              goto LABEL_524;
LABEL_518:
            if ( dword_639D8 )
              v280 = *(__int16 *)(dword_639D8 + 4);
            else
              v280 = -1;
            v285 = (const char *)&dword_639D8;
            if ( dword_639D8 )
              ++v280;
            wtouchln((WINDOW *)dword_639D8, 0, v280, 1);
            wrefresh(*(WINDOW **)v285);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_524;
            cbreak();
          }
        }
        if ( byte_630C1 && (*v290 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "Loaded configuration file %s", (const char *)dword_611D4);
          sub_38438(7, s, 0);
        }
        if ( dword_612A4 == -1 )
        {
          if ( *v290 || byte_630C0 || dword_60964 > 3 )
          {
            v135 = s;
            *(_DWORD *)s = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy(v135 + 4, "r in configuration file, partially loaded.");
            sub_38438(4, s, 0);
          }
          if ( *((_BYTE *)v289 + 2028) && (*v290 || byte_630C0 || dword_60964 > 3) )
          {
            v136 = s;
            *(_DWORD *)s = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
            strcpy(v136 + 4, "t cgminer with -T to see what failed to load.");
            sub_38438(4, s, 0);
          }
          goto LABEL_166;
        }
        if ( !dword_612A4 )
        {
          if ( *v290 || byte_630C0 || (v286 = &dword_60964, dword_60964 > 3) )
          {
            v150 = s;
            *(_DWORD *)s = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy(v150 + 4, "l JSON error in configuration file.");
            sub_38438(4, s, 0);
            if ( *v290 || byte_630C0 )
              goto LABEL_165;
            v286 = &dword_60964;
          }
          if ( *v286 > 3 )
          {
LABEL_165:
            v124 = s;
            *(_DWORD *)s = *(_DWORD *)"Configuration file could not be used.";
            strcpy(v124 + 4, "iguration file could not be used.");
            sub_38438(4, s, 0);
          }
        }
LABEL_166:
        free((void *)dword_611D4);
        dword_611D4 = 0;
        goto LABEL_167;
      }
      v60 = 24 * *(_DWORD *)(v59 + 4);
      v61 = malloc(v60);
      v62 = v61;
      if ( v61 )
      {
        memset(v61, 0, v60);
        *(_DWORD *)(v59 + 24) = (((2 * *(_DWORD *)(v59 + 4) - 1) & *(_DWORD *)(v59 + 12)) != 0)
                              + (*(_DWORD *)(v59 + 12) >> (*(_BYTE *)(v59 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v63 = (_DWORD *)*((_DWORD *)v20 + 17);
        v64 = v63[1];
        v65 = v63;
        if ( v64 )
        {
          v294 = 0;
          v293 = 0;
          do
          {
            v66 = *(_DWORD **)((char *)v294 + *v63);
            if ( v66 )
            {
              for ( ii = v64; ; ii = v65[1] )
              {
                v68 = (_DWORD *)v66[4];
                v69 = 3 * ((2 * ii - 1) & v66[7]);
                v70 = (char *)&v62[v69];
                v71 = *((_DWORD *)v70 + 1) + 1;
                *((_DWORD *)v70 + 1) = v71;
                if ( v71 > v65[6] )
                {
                  ++v65[7];
                  *((_DWORD *)v70 + 2) = *((_DWORD *)v70 + 1) / *(_DWORD *)(*((_DWORD *)v20 + 17) + 24);
                }
                v66[3] = 0;
                v66[4] = v62[v69];
                v72 = v62[v69];
                if ( v72 )
                  *(_DWORD *)(v72 + 12) = v66;
                v62[v69] = v66;
                if ( !v68 )
                  break;
                v65 = (_DWORD *)*((_DWORD *)v20 + 17);
                v66 = v68;
              }
              v63 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v63;
            v64 = v63[1];
            v76 = v64 > (unsigned int)v293 + 1;
            v293 = (int *)((char *)v293 + 1);
            v294 += 3;
          }
          while ( v76 );
        }
        free((void *)*v63);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v62;
        v73 = (_DWORD *)*((_DWORD *)v20 + 17);
        v74 = v73[3];
        v75 = v73[7];
        v76 = v75 > v74 >> 1;
        if ( v75 <= v74 >> 1 )
          v77 = 0;
        else
          v77 = v73[8];
        if ( v76 )
          ++v77;
        v73[8] = v77;
        v78 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v78 + 32) > 1u )
          *(_DWORD *)(v78 + 36) = 1;
        goto LABEL_57;
      }
LABEL_310:
      exit(-1);
    }
    strcpy((char *)v298, "Failed to create getq");
  }
  sub_38438(3, (const char *)v298, 1);
  sub_1C160(1, 0);
}
// BF08: control flows out of bounds to BF0C
// BA70: variable 'v5' is possibly undefined
// BA70: variable 'v3' is possibly undefined
// C684: variable 'v104' is possibly undefined
// 5F890: using guessed type int dword_5F890[];
// 5F8A0: using guessed type char *off_5F8A0;
// 60070: using guessed type int dword_60070;
// 6007C: using guessed type char byte_6007C;
// 600C4: using guessed type char *off_600C4;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 60D74: using guessed type void (*off_60D74)();
// 60E70: using guessed type int stdscr;
// 60E80: using guessed type int stderr;
// 60E90: using guessed type int dword_60E90;
// 60E94: using guessed type int dword_60E94;
// 60E98: using guessed type int dword_60E98;
// 60E9C: using guessed type int dword_60E9C;
// 60EA0: using guessed type int dword_60EA0;
// 611A8: using guessed type int dword_611A8;
// 611AC: using guessed type int dword_611AC;
// 611B0: using guessed type int dword_611B0;
// 611BC: using guessed type struct timeval stru_611BC;
// 611D0: using guessed type char byte_611D0;
// 611D4: using guessed type int dword_611D4;
// 612A4: using guessed type int dword_612A4;
// 612AC: using guessed type int dword_612AC;
// 612C8: using guessed type int dword_612C8;
// 612CC: using guessed type int dword_612CC;
// 612D1: using guessed type char byte_612D1;
// 612D2: using guessed type char byte_612D2;
// 612FC: using guessed type int dword_612FC;
// 61304: using guessed type int dword_61304;
// 61308: using guessed type int dword_61308;
// 6130C: using guessed type int dword_6130C;
// 61310: using guessed type int dword_61310;
// 61370: using guessed type int dword_61370;
// 61378: using guessed type _DWORD dword_61378[2];
// 61380: using guessed type double dbl_61380[12];
// 613E0: using guessed type int dword_613E0;
// 613E4: using guessed type int dword_613E4;
// 61418: using guessed type int dword_61418;
// 6141C: using guessed type int dword_6141C;
// 61420: using guessed type int dword_61420;
// 61424: using guessed type int dword_61424;
// 61570: using guessed type int dword_61570;
// 615C8: using guessed type char byte_615C8;
// 615C9: using guessed type char byte_615C9;
// 615D8: using guessed type _BYTE byte_615D8[2560];
// 61FD8: using guessed type _BYTE byte_61FD8[2560];
// 629EC: using guessed type _DWORD dword_629EC[4];
// 62C0C: using guessed type int dword_62C0C;
// 62C10: using guessed type int dword_62C10;
// 62C14: using guessed type int dword_62C14;
// 62D18: using guessed type char byte_62D18;
// 62E20: using guessed type int dword_62E20;
// 62E24: using guessed type int dword_62E24;
// 62E28: using guessed type int dword_62E28;
// 62E30: using guessed type int dword_62E30;
// 62E80: using guessed type unsigned __int8 byte_62E80[204];
// 62F60: using guessed type char byte_62F60;
// 62F98: using guessed type char byte_62F98;
// 62FA4: using guessed type int dword_62FA4;
// 630A2: using guessed type char byte_630A2;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 63268: using guessed type double dbl_63268;
// 6327C: using guessed type int (__fastcall *off_6327C)(_DWORD);
// 632F0: using guessed type char byte_632F0;
// 6331C: using guessed type int (__fastcall *off_6331C)(_DWORD);
// 6339C: using guessed type _UNKNOWN *off_6339C;
// 63424: using guessed type int (__fastcall *off_63424)(_DWORD);
// 634A4: using guessed type int (__fastcall *off_634A4)(_DWORD);
// 63524: using guessed type int (__fastcall *off_63524)(_DWORD);
// 635A4: using guessed type int (__fastcall *off_635A4)(_DWORD);
// 6362C: using guessed type int (__fastcall *off_6362C)(_DWORD);
// 636A4: using guessed type int dword_636A4;
// 63740: using guessed type int dword_63740;
// 63784: using guessed type int (__fastcall *off_63784)(_DWORD);
// 6380C: using guessed type _UNKNOWN *off_6380C;
// 63880: using guessed type pthread_rwlock_t stru_63880;
// 638B4: using guessed type int (__fastcall *off_638B4)(_DWORD);
// 63954: using guessed type int (__fastcall *off_63954)(_DWORD);
// 639D8: using guessed type int dword_639D8;
// 639E0: using guessed type int dword_639E0;
// 639E8: using guessed type int dword_639E8;
// 639EC: using guessed type int dword_639EC;
// 639FC: using guessed type int (__fastcall *off_639FC)(_DWORD);
// 63A84: using guessed type int (__fastcall *off_63A84)(_DWORD);
// 63B0C: using guessed type _UNKNOWN *off_63B0C;
// 63B80: using guessed type int dword_63B80;
// 63B84: using guessed type int dword_63B84;
// 63BC0: using guessed type int dword_63BC0;
// 63BC5: using guessed type char byte_63BC5;
// 63BC8: using guessed type int dword_63BC8;
// 63C24: using guessed type int (__fastcall *off_63C24)(_DWORD);
// 63CC0: using guessed type int dword_63CC0;
// 63D84: using guessed type int (__fastcall *off_63D84)(_DWORD);
// 63DF8: using guessed type char byte_63DF8;
// 63DF9: using guessed type char byte_63DF9;
// 63DFC: using guessed type pthread_mutex_t stru_63DFC;
// 63E4C: using guessed type char byte_63E4C;
// 63E54: using guessed type int dword_63E54;
// 63E6C: using guessed type int (__fastcall *off_63E6C)(_DWORD);
// 63EE0: using guessed type char byte_63EE0;
// 63FF4: using guessed type _UNKNOWN *off_63FF4;
// 640B8: using guessed type char byte_640B8;
// 6410C: using guessed type int dword_6410C;
// 6411C: using guessed type int (__fastcall *off_6411C)(_DWORD);
// 6419C: using guessed type int (__fastcall *off_6419C)(_DWORD);
// 64214: using guessed type int dword_64214;
// 6424C: using guessed type int (__fastcall *off_6424C)(_DWORD);

//----- (0000F1D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_10,
    a1,
    va);
  abort();
}
// F1DC: positive sp value 4 has been found
// F1F8: variable 'v4' is possibly undefined
// 49E1C: using guessed type int nullsub_10();

//----- (0000F20C) --------------------------------------------------------
int sub_F20C()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// AC24: using guessed type int _gmon_start__(void);

//----- (0000F230) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &stdscr;
}
// 60E70: using guessed type int stdscr;

//----- (0000F268) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &stdscr;
  HIDWORD(result) = 0;
  return result;
}
// 60E70: using guessed type int stdscr;

//----- (0000F2A8) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !byte_60E84 )
  {
    result = deregister_tm_clones();
    byte_60E84 = 1;
  }
  return result;
}
// 60E84: using guessed type char byte_60E84;

//----- (0000F2D0) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (0000F308) --------------------------------------------------------
int __fastcall sub_F308(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (0000F318) --------------------------------------------------------
int __fastcall sub_F318(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (0000F328) --------------------------------------------------------
int __fastcall sub_F328(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0000F338) --------------------------------------------------------
int __fastcall sub_F338(_BYTE *a1)
{
  *a1 = 1;
  byte_630C0 = 1;
  return 0;
}
// 630C0: using guessed type char byte_630C0;

//----- (0000F354) --------------------------------------------------------
int sub_F354()
{
  return 0;
}

//----- (0000F368) --------------------------------------------------------
int sub_F368()
{
  return 1;
}

//----- (0000F370) --------------------------------------------------------
int sub_F370()
{
  return 1;
}

//----- (0000F378) --------------------------------------------------------
__int64 sub_F378()
{
  return 0xFFFFFFFFLL;
}

//----- (0000F384) --------------------------------------------------------
int sub_F384()
{
  return 1;
}

//----- (0000F38C) --------------------------------------------------------
int sub_F38C()
{
  return 1;
}

//----- (0000F3A4) --------------------------------------------------------
int sub_F3A4()
{
  return 0;
}

//----- (0000F3B0) --------------------------------------------------------
int __fastcall sub_F3B0(int a1, int a2)
{
  _DWORD *v2; // r3
  int result; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = *(_DWORD **)(a1 + 36);
  if ( v2[59] == a2 )
  {
    result = (unsigned __int8)byte_630C1;
    if ( byte_630C1 )
    {
      if ( byte_632F0 || (result = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6 )
      {
        snprintf(s, 0x800u, "%s %d duplicate share detected as HW error", *(const char **)(v2[1] + 8), v2[2]);
        sub_38438(7, s, 0);
        return 0;
      }
    }
  }
  else
  {
    v2[59] = a2;
    return 1;
  }
  return result;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0000F46C) --------------------------------------------------------
_BYTE *__fastcall sub_F46C(const char *a1)
{
  size_t v2; // r0
  _BYTE *v3; // r4
  _DWORD *v4; // r0
  int v5; // r3
  int v6; // r1
  const char *v7; // r1
  _BYTE *v8; // r2
  bool v9; // zf
  char v10; // t1

  v2 = strlen(a1);
  v3 = malloc(2 * v2 + 1);
  v4 = malloc(8u);
  v5 = *(unsigned __int8 *)a1;
  v6 = dword_60E88;
  *v4 = v3;
  dword_60E88 = (int)v4;
  v4[1] = v6;
  if ( v5 )
  {
    v7 = a1 - 1;
    v8 = v3;
    do
    {
      v9 = v5 == 92;
      if ( v5 != 92 )
        v9 = v5 == 34;
      if ( v9 )
        *v8++ = 92;
      v10 = *++v7;
      *v8++ = v10;
      v5 = *((unsigned __int8 *)v7 + 1);
    }
    while ( v7[1] );
  }
  else
  {
    v8 = v3;
  }
  *v8 = 0;
  return v3;
}
// 60E88: using guessed type int dword_60E88;

//----- (0000F4F8) --------------------------------------------------------
int __fastcall sub_F4F8(int a1)
{
  sub_47A4C(a1, &dword_60E8C);
  return 0;
}
// 60E8C: using guessed type int dword_60E8C;

//----- (0000F510) --------------------------------------------------------
int __fastcall sub_F510(int a1)
{
  sub_47A4C(a1, &dword_60E90);
  return 0;
}
// 60E90: using guessed type int dword_60E90;

//----- (0000F528) --------------------------------------------------------
int __fastcall sub_F528(int a1)
{
  sub_47A4C(a1, &dword_60E94);
  return 0;
}
// 60E94: using guessed type int dword_60E94;

//----- (0000F540) --------------------------------------------------------
int __fastcall sub_F540(int a1)
{
  sub_47A4C(a1, &dword_60E98);
  return 0;
}
// 60E98: using guessed type int dword_60E98;

//----- (0000F558) --------------------------------------------------------
int __fastcall sub_F558(int a1)
{
  sub_47A4C(a1, &dword_60E9C);
  return 0;
}
// 60E9C: using guessed type int dword_60E9C;

//----- (0000F570) --------------------------------------------------------
int __fastcall sub_F570(int a1)
{
  sub_47A4C(a1, &dword_60EA0);
  return 0;
}
// 60EA0: using guessed type int dword_60EA0;

//----- (0000F588) --------------------------------------------------------
void __fastcall __noreturn sub_F588(char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_L3 mining support.\n", byte_60EA4);
  v2 = sub_48A84((const char *)dword_C54D4, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 60E7C: using guessed type int stdout;
// C54D4: using guessed type int dword_C54D4;

//----- (0000F7C0) --------------------------------------------------------
void *__fastcall sub_F7C0(void *a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0000F7D4) --------------------------------------------------------
time_t __fastcall sub_F7D4(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 0;
  sub_2B13C((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0000F808) --------------------------------------------------------
time_t __fastcall sub_F808(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 1;
  sub_2B13C((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0000F840) --------------------------------------------------------
int __fastcall sub_F840(int *a1, int *a2, int a3)
{
  int i; // r3
  _DWORD *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int v13; // r2
  int v14; // r3
  int v15; // r4
  int v16; // r5
  int v17; // r3
  int v18; // r8
  int v19; // r0
  int v20; // r8
  int v21; // r7
  int v22; // r1
  int v23; // r7
  int v24; // r6
  int v25; // r2
  int v26; // r5
  int v27; // r6
  int v28; // r3
  int v29; // r4
  int v30; // r0
  int v31; // r6
  int v32; // r8
  int v33; // r1
  int v34; // r0
  int v35; // r7
  int v36; // r1
  int v37; // r10
  int v38; // r5
  int v39; // r1
  int v40; // r4
  int v41; // r2
  int v42; // r1
  int v43; // r6
  int v44; // r3
  int v45; // r7
  int v46; // r1
  int v47; // r8
  int v48; // r7
  int v49; // r0
  int v50; // r5
  int v51; // r10
  int v52; // r7
  int v53; // r4
  int v54; // r6
  int v55; // r2
  int v56; // r10
  int v57; // r6
  int v58; // r8
  int v59; // r3
  int v60; // r5
  int v61; // r1
  int v62; // r6
  int v63; // r5
  int v64; // r0
  int v65; // r7
  int v66; // r5
  int v67; // r4
  int v68; // r10
  int v69; // r8
  int v70; // r5
  int v71; // r2
  int v72; // r6
  int v73; // r3
  int v74; // r8
  int v75; // r6
  int v76; // r7
  int v77; // r1
  int v78; // r10
  int v79; // r0
  int v80; // r6
  int v81; // r5
  int v82; // r4
  int v83; // r10
  int v84; // r5
  int v85; // r2
  int v86; // r8
  int v87; // r7
  int v88; // r5
  int v89; // r3
  int v90; // r6
  int v91; // r1
  int v92; // r7
  int v93; // r6
  int v94; // r10
  int v95; // r0
  int v96; // r8
  int v97; // r4
  int v98; // r6
  int v99; // r5
  int v100; // r2
  int v101; // r8
  int v102; // r5
  int v103; // r3
  int v104; // r7
  int v105; // r10
  int v106; // r5
  int v107; // r1
  int v108; // r6
  int v109; // r0
  int v110; // r10
  int v111; // r6
  int v112; // r8
  int v113; // r4
  int v114; // r7
  int v115; // r2
  int v116; // r6
  int v117; // r5
  int v118; // r3
  int v119; // r7
  int v120; // r5
  int v121; // r1
  int v122; // r10
  int v123; // r8
  int v124; // r5
  int v125; // r0
  int v126; // r6
  int v127; // r4
  int v128; // r8
  int v129; // r6
  int v130; // r7
  int v131; // r2
  int v132; // r10
  int v133; // r3
  int v134; // r6
  int v135; // r5
  int v136; // r1
  int v137; // r10
  int v138; // r5
  int v139; // r0
  int v140; // r8
  int v141; // r7
  int v142; // r5
  int v143; // r4
  int v144; // r6
  int v145; // r2
  int v146; // r7
  int v147; // r6
  int v148; // r10
  int v149; // r3
  int v150; // r8
  int v151; // r1
  int v152; // r6
  int v153; // r5
  int v154; // r0
  int v155; // r8
  int v156; // r5
  int v157; // r4
  int v158; // r7
  int v159; // r10
  int v160; // r5
  int v161; // r2
  int v162; // r6
  int v163; // r3
  int v164; // r10
  int v165; // r6
  int v166; // r8
  int v167; // r1
  int v168; // r7
  int v169; // r0
  int v170; // r6
  int v171; // r5
  int v172; // r4
  int v173; // r7
  int v174; // r5
  int v175; // r2
  int v176; // r10
  int v177; // r8
  int v178; // r5
  int v179; // r3
  int v180; // r6
  int v181; // r1
  int v182; // r8
  int v183; // r6
  int v184; // r7
  int v185; // r0
  int v186; // r10
  int v187; // r4
  int v188; // r6
  int v189; // r5
  int v190; // r2
  int v191; // r10
  int v192; // r5
  int v193; // r8
  int v194; // r3
  int v195; // r7
  int v196; // r5
  int v197; // r1
  int v198; // r6
  int result; // r0
  int v200; // r10
  int v201; // r6
  int v202; // r7
  int v203; // r2
  int v204; // r10
  int v205; // r8
  int v206; // r4
  int v207; // r2
  int v208; // r3
  _DWORD *v209; // r6
  int *v210; // r7
  int *v211; // r4
  int v212; // r0
  _DWORD *v213; // r5
  int v214; // r1
  int v215; // r2
  int v216; // r3
  int v217; // [sp+0h] [bp-120h]
  int v218; // [sp+4h] [bp-11Ch]
  int v219; // [sp+8h] [bp-118h]
  int v220; // [sp+Ch] [bp-114h]
  int v221; // [sp+10h] [bp-110h]
  int v222; // [sp+14h] [bp-10Ch]
  int v223; // [sp+18h] [bp-108h]
  int v224; // [sp+1Ch] [bp-104h]
  _DWORD v225[14]; // [sp+20h] [bp-100h] BYREF
  _DWORD v226[48]; // [sp+58h] [bp-C8h] BYREF
  _DWORD v227[2]; // [sp+118h] [bp-8h] BYREF

  if ( a3 )
  {
    for ( i = 0; i != 16; ++i )
      v225[i] = bswap32(a2[i]);
  }
  else
  {
    v209 = v225;
    v210 = a2 + 16;
    v211 = a2;
    do
    {
      v212 = *v211;
      v213 = v209;
      v214 = v211[1];
      v209 += 4;
      v215 = v211[2];
      v216 = v211[3];
      v211 += 4;
      *v213 = v212;
      v213[1] = v214;
      v213[2] = v215;
      v213[3] = v216;
    }
    while ( v211 != v210 );
  }
  v5 = v226;
  do
  {
    v6 = *(v5 - 13);
    v7 = *(v5 - 12);
    v8 = v6 + *(v5 - 4) + (__ROR4__(v5[1], 17) ^ __ROR4__(v5[1], 19) ^ (v5[1] >> 10));
    v5[2] = *(v5 - 14)
          + *(v5 - 5)
          + (__ROR4__(*v5, 17) ^ __ROR4__(*v5, 19) ^ (*v5 >> 10))
          + (__ROR4__(v6, 7) ^ __ROR4__(v6, 18) ^ (v6 >> 3));
    v5[3] = v8 + (__ROR4__(v7, 7) ^ __ROR4__(v7, 18) ^ (v7 >> 3));
    v5 += 2;
  }
  while ( v5 != v227 );
  v9 = a1[1];
  v10 = a1[2];
  v11 = a1[3];
  v217 = *a1;
  v218 = v9;
  v219 = v10;
  v220 = v11;
  v12 = a1[4];
  v13 = a1[6];
  v14 = a1[7];
  v15 = v217;
  v16 = v9;
  v222 = a1[5];
  v224 = v14;
  v17 = v12;
  v18 = v224
      + v225[0]
      + 1116352408
      + (__ROR4__(v12, 6) ^ __ROR4__(v12, 11) ^ __ROR4__(v12, 25))
      + ((v13 ^ v222) & v12 ^ v13);
  v19 = v18 + v220;
  v20 = ((v219 | v16) & v217 | v219 & v16) + (__ROR4__(v217, 2) ^ __ROR4__(v217, 13) ^ __ROR4__(v217, 22)) + v18;
  v21 = v13
      + v225[1]
      + 1899447441
      + (v19 & (v222 ^ v17) ^ v222)
      + (__ROR4__(v19, 6) ^ __ROR4__(v19, 11) ^ __ROR4__(v19, 25));
  v22 = v21 + v219;
  v23 = (__ROR4__(v20, 2) ^ __ROR4__(v20, 13) ^ __ROR4__(v20, 22)) + (v20 & (v16 | v15) | v16 & v15) + v21;
  v24 = v222
      + v225[2]
      - 1245643825
      + (v22 & (v19 ^ v17) ^ v17)
      + (__ROR4__(v22, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25));
  v25 = (__ROR4__(v23, 2) ^ __ROR4__(v23, 13) ^ __ROR4__(v23, 22)) + (v23 & (v20 | v15) | v20 & v15) + v24;
  v26 = v24 + v16;
  v27 = v17
      + v225[3]
      - 373957723
      + (v26 & (v22 ^ v19) ^ v19)
      + (__ROR4__(v26, 6) ^ __ROR4__(v26, 11) ^ __ROR4__(v26, 25));
  v28 = (__ROR4__(v25, 2) ^ __ROR4__(v25, 13) ^ __ROR4__(v25, 22)) + (v25 & (v23 | v20) | v23 & v20) + v27;
  v29 = v27 + v217;
  v30 = v225[4]
      + 961987163
      + v19
      + (v29 & (v26 ^ v22) ^ v22)
      + (__ROR4__(v27 + v217, 6) ^ __ROR4__(v29, 11) ^ __ROR4__(v29, 25));
  v31 = (__ROR4__(v28, 2) ^ __ROR4__(v28, 13) ^ __ROR4__(v28, 22)) + (v28 & (v25 | v23) | v25 & v23) + v30;
  v32 = v30 + v20;
  v33 = v225[5]
      + 1508970993
      + v22
      + (v32 & (v29 ^ v26) ^ v26)
      + (__ROR4__(v32, 6) ^ __ROR4__(v32, 11) ^ __ROR4__(v32, 25));
  v34 = (__ROR4__(v31, 2) ^ __ROR4__(v31, 13) ^ __ROR4__(v31, 22)) + (v31 & (v28 | v25) | v28 & v25) + v33;
  v35 = v33 + v23;
  v36 = v225[6]
      - 1841331548
      + v26
      + (v35 & (v32 ^ v29) ^ v29)
      + (__ROR4__(v35, 6) ^ __ROR4__(v35, 11) ^ __ROR4__(v35, 25));
  v37 = v36 + v25;
  v38 = (__ROR4__(v34, 2) ^ __ROR4__(v34, 13) ^ __ROR4__(v34, 22)) + (v34 & (v31 | v28) | v31 & v28) + v36;
  v39 = v225[7]
      - 1424204075
      + v29
      + (v37 & (v35 ^ v32) ^ v32)
      + (__ROR4__(v37, 6) ^ __ROR4__(v37, 11) ^ __ROR4__(v37, 25));
  v40 = v39 + v28;
  v41 = (__ROR4__(v38, 2) ^ __ROR4__(v38, 13) ^ __ROR4__(v38, 22)) + (v38 & (v34 | v31) | v34 & v31) + v39;
  v42 = v225[8]
      - 670586216
      + v32
      + (v40 & (v37 ^ v35) ^ v35)
      + (__ROR4__(v40, 6) ^ __ROR4__(v40, 11) ^ __ROR4__(v40, 25));
  v43 = v42 + v31;
  v44 = (__ROR4__(v41, 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v38 | v34) | v38 & v34) + v42;
  v45 = v225[9]
      + 310598401
      + v35
      + (v43 & (v40 ^ v37) ^ v37)
      + (__ROR4__(v43, 6) ^ __ROR4__(v43, 11) ^ __ROR4__(v43, 25));
  v46 = (__ROR4__(v44, 2) ^ __ROR4__(v44, 13) ^ __ROR4__(v44, 22)) + (v44 & (v41 | v38) | v41 & v38) + v45;
  v47 = v45 + v34;
  v48 = v225[10]
      + 607225278
      + v37
      + ((v45 + v34) & (v43 ^ v40) ^ v40)
      + (__ROR4__(v45 + v34, 6) ^ __ROR4__(v47, 11) ^ __ROR4__(v47, 25));
  v49 = (__ROR4__(v46, 2) ^ __ROR4__(v46, 13) ^ __ROR4__(v46, 22)) + (v46 & (v44 | v41) | v44 & v41) + v48;
  v50 = v48 + v38;
  v51 = v225[11]
      + 1426881987
      + v40
      + (v50 & (v47 ^ v43) ^ v43)
      + (__ROR4__(v50, 6) ^ __ROR4__(v50, 11) ^ __ROR4__(v50, 25));
  v52 = v51 + v41;
  v53 = (__ROR4__(v49, 2) ^ __ROR4__(v49, 13) ^ __ROR4__(v49, 22)) + (v49 & (v46 | v44) | v46 & v44) + v51;
  v54 = v225[12]
      + 1925078388
      + v43
      + (v52 & (v50 ^ v47) ^ v47)
      + (__ROR4__(v51 + v41, 6) ^ __ROR4__(v52, 11) ^ __ROR4__(v52, 25));
  v55 = (__ROR4__(v53, 2) ^ __ROR4__(v53, 13) ^ __ROR4__(v53, 22)) + (v53 & (v49 | v46) | v49 & v46) + v54;
  v56 = v54 + v44;
  v57 = v225[13]
      - 2132889090
      + v47
      + (v56 & (v52 ^ v50) ^ v50)
      + (__ROR4__(v54 + v44, 6) ^ __ROR4__(v56, 11) ^ __ROR4__(v56, 25));
  v58 = v57 + v46;
  v59 = (__ROR4__(v55, 2) ^ __ROR4__(v55, 13) ^ __ROR4__(v55, 22)) + (v55 & (v53 | v49) | v53 & v49) + v57;
  v60 = v226[0]
      - 1680079193
      + v50
      + (v58 & (v56 ^ v52) ^ v52)
      + (__ROR4__(v57 + v46, 6) ^ __ROR4__(v58, 11) ^ __ROR4__(v58, 25));
  v61 = (__ROR4__(v59, 2) ^ __ROR4__(v59, 13) ^ __ROR4__(v59, 22)) + (v59 & (v55 | v53) | v55 & v53) + v60;
  v62 = v60 + v49;
  v63 = v226[1]
      - 1046744716
      + v52
      + (v62 & (v58 ^ v56) ^ v56)
      + (__ROR4__(v60 + v49, 6) ^ __ROR4__(v62, 11) ^ __ROR4__(v62, 25));
  v64 = (__ROR4__(v61, 2) ^ __ROR4__(v61, 13) ^ __ROR4__(v61, 22)) + (v61 & (v59 | v55) | v59 & v55) + v63;
  v65 = v63 + v53;
  v66 = v226[2]
      - 459576895
      + v56
      + ((v63 + v53) & (v62 ^ v58) ^ v58)
      + (__ROR4__(v63 + v53, 6) ^ __ROR4__(v65, 11) ^ __ROR4__(v65, 25));
  v67 = (__ROR4__(v64, 2) ^ __ROR4__(v64, 13) ^ __ROR4__(v64, 22)) + (v64 & (v61 | v59) | v61 & v59) + v66;
  v68 = v66 + v55;
  v69 = v226[3]
      - 272742522
      + v58
      + (v68 & (v65 ^ v62) ^ v62)
      + (__ROR4__(v66 + v55, 6) ^ __ROR4__(v68, 11) ^ __ROR4__(v68, 25));
  v70 = v69 + v59;
  v71 = (__ROR4__(v67, 2) ^ __ROR4__(v67, 13) ^ __ROR4__(v67, 22)) + (v67 & (v64 | v61) | v64 & v61) + v69;
  v72 = v226[4]
      + 264347078
      + v62
      + (v70 & (v68 ^ v65) ^ v65)
      + (__ROR4__(v69 + v59, 6) ^ __ROR4__(v70, 11) ^ __ROR4__(v70, 25));
  v73 = (__ROR4__(v71, 2) ^ __ROR4__(v71, 13) ^ __ROR4__(v71, 22)) + (v71 & (v67 | v64) | v67 & v64) + v72;
  v74 = v72 + v61;
  v75 = v226[5]
      + 604807628
      + v65
      + (v74 & (v70 ^ v68) ^ v68)
      + (__ROR4__(v72 + v61, 6) ^ __ROR4__(v74, 11) ^ __ROR4__(v74, 25));
  v76 = v75 + v64;
  v77 = (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + (v73 & (v71 | v67) | v71 & v67) + v75;
  v78 = v226[6]
      + 770255983
      + v68
      + (v76 & (v74 ^ v70) ^ v70)
      + (__ROR4__(v75 + v64, 6) ^ __ROR4__(v76, 11) ^ __ROR4__(v76, 25));
  v79 = (__ROR4__(v77, 2) ^ __ROR4__(v77, 13) ^ __ROR4__(v77, 22)) + (v77 & (v73 | v71) | v73 & v71) + v78;
  v80 = v78 + v67;
  v81 = v226[7]
      + 1249150122
      + v70
      + (v80 & (v76 ^ v74) ^ v74)
      + (__ROR4__(v78 + v67, 6) ^ __ROR4__(v80, 11) ^ __ROR4__(v80, 25));
  v82 = (__ROR4__(v79, 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v77 | v73) | v77 & v73) + v81;
  v83 = v81 + v71;
  v84 = v226[8]
      + 1555081692
      + v74
      + ((v81 + v71) & (v80 ^ v76) ^ v76)
      + (__ROR4__(v81 + v71, 6) ^ __ROR4__(v83, 11) ^ __ROR4__(v83, 25));
  v85 = (__ROR4__(v82, 2) ^ __ROR4__(v82, 13) ^ __ROR4__(v82, 22)) + (v82 & (v79 | v77) | v79 & v77) + v84;
  v86 = v84 + v73;
  v87 = v226[9]
      + 1996064986
      + v76
      + (v86 & (v83 ^ v80) ^ v80)
      + (__ROR4__(v84 + v73, 6) ^ __ROR4__(v86, 11) ^ __ROR4__(v86, 25));
  v88 = v87 + v77;
  v89 = (__ROR4__(v85, 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v82 | v79) | v82 & v79) + v87;
  v90 = v226[10]
      - 1740746414
      + v80
      + (v88 & (v86 ^ v83) ^ v83)
      + (__ROR4__(v87 + v77, 6) ^ __ROR4__(v88, 11) ^ __ROR4__(v88, 25));
  v91 = (__ROR4__(v89, 2) ^ __ROR4__(v89, 13) ^ __ROR4__(v89, 22)) + (v89 & (v85 | v82) | v85 & v82) + v90;
  v92 = v90 + v79;
  v93 = v226[11]
      - 1473132947
      + v83
      + (v92 & (v88 ^ v86) ^ v86)
      + (__ROR4__(v90 + v79, 6) ^ __ROR4__(v92, 11) ^ __ROR4__(v92, 25));
  v94 = v93 + v82;
  v95 = (__ROR4__(v91, 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v89 | v85) | v89 & v85) + v93;
  v96 = v226[12]
      - 1341970488
      + v86
      + (v94 & (v92 ^ v88) ^ v88)
      + (__ROR4__(v93 + v82, 6) ^ __ROR4__(v94, 11) ^ __ROR4__(v94, 25));
  v97 = (__ROR4__(v95, 2) ^ __ROR4__(v95, 13) ^ __ROR4__(v95, 22)) + (v95 & (v91 | v89) | v91 & v89) + v96;
  v98 = v96 + v85;
  v99 = v226[13]
      - 1084653625
      + v88
      + (v98 & (v94 ^ v92) ^ v92)
      + (__ROR4__(v96 + v85, 6) ^ __ROR4__(v98, 11) ^ __ROR4__(v98, 25));
  v100 = (__ROR4__(v97, 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v95 | v91) | v95 & v91) + v99;
  v101 = v99 + v89;
  v102 = v226[14]
       - 958395405
       + v92
       + ((v99 + v89) & (v98 ^ v94) ^ v94)
       + (__ROR4__(v99 + v89, 6) ^ __ROR4__(v101, 11) ^ __ROR4__(v101, 25));
  v103 = (__ROR4__(v100, 2) ^ __ROR4__(v100, 13) ^ __ROR4__(v100, 22)) + (v100 & (v97 | v95) | v97 & v95) + v102;
  v104 = v102 + v91;
  v105 = v226[15]
       - 710438585
       + v94
       + (v104 & (v101 ^ v98) ^ v98)
       + (__ROR4__(v102 + v91, 6) ^ __ROR4__(v104, 11) ^ __ROR4__(v104, 25));
  v106 = v105 + v95;
  v107 = (__ROR4__(v103, 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v100 | v97) | v100 & v97) + v105;
  v108 = v226[16]
       + 113926993
       + v98
       + (v106 & (v104 ^ v101) ^ v101)
       + (__ROR4__(v105 + v95, 6) ^ __ROR4__(v106, 11) ^ __ROR4__(v106, 25));
  v109 = (__ROR4__(v107, 2) ^ __ROR4__(v107, 13) ^ __ROR4__(v107, 22)) + (v107 & (v103 | v100) | v103 & v100) + v108;
  v110 = v108 + v97;
  v111 = v226[17]
       + 338241895
       + v101
       + (v110 & (v106 ^ v104) ^ v104)
       + (__ROR4__(v108 + v97, 6) ^ __ROR4__(v110, 11) ^ __ROR4__(v110, 25));
  v112 = v111 + v100;
  v113 = (__ROR4__(v109, 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + (v109 & (v107 | v103) | v107 & v103) + v111;
  v114 = v226[18]
       + 666307205
       + v104
       + (v112 & (v110 ^ v106) ^ v106)
       + (__ROR4__(v111 + v100, 6) ^ __ROR4__(v112, 11) ^ __ROR4__(v112, 25));
  v115 = (__ROR4__(v113, 2) ^ __ROR4__(v113, 13) ^ __ROR4__(v113, 22)) + (v113 & (v109 | v107) | v109 & v107) + v114;
  v116 = v114 + v103;
  v117 = v226[19]
       + 773529912
       + v106
       + (v116 & (v112 ^ v110) ^ v110)
       + (__ROR4__(v114 + v103, 6) ^ __ROR4__(v116, 11) ^ __ROR4__(v116, 25));
  v118 = (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + (v115 & (v113 | v109) | v113 & v109) + v117;
  v119 = v117 + v107;
  v120 = v226[20]
       + 1294757372
       + v110
       + ((v117 + v107) & (v116 ^ v112) ^ v112)
       + (__ROR4__(v117 + v107, 6) ^ __ROR4__(v119, 11) ^ __ROR4__(v119, 25));
  v121 = (__ROR4__(v118, 2) ^ __ROR4__(v118, 13) ^ __ROR4__(v118, 22)) + (v118 & (v115 | v113) | v115 & v113) + v120;
  v122 = v120 + v109;
  v123 = v226[21]
       + 1396182291
       + v112
       + (v122 & (v119 ^ v116) ^ v116)
       + (__ROR4__(v120 + v109, 6) ^ __ROR4__(v122, 11) ^ __ROR4__(v122, 25));
  v124 = v123 + v113;
  v125 = (__ROR4__(v121, 2) ^ __ROR4__(v121, 13) ^ __ROR4__(v121, 22)) + (v121 & (v118 | v115) | v118 & v115) + v123;
  v126 = v226[22]
       + 1695183700
       + v116
       + (v124 & (v122 ^ v119) ^ v119)
       + (__ROR4__(v123 + v113, 6) ^ __ROR4__(v124, 11) ^ __ROR4__(v124, 25));
  v127 = (__ROR4__(v125, 2) ^ __ROR4__(v125, 13) ^ __ROR4__(v125, 22)) + (v125 & (v121 | v118) | v121 & v118) + v126;
  v128 = v126 + v115;
  v129 = v226[23]
       + 1986661051
       + v119
       + (v128 & (v124 ^ v122) ^ v122)
       + (__ROR4__(v126 + v115, 6) ^ __ROR4__(v128, 11) ^ __ROR4__(v128, 25));
  v130 = v129 + v118;
  v131 = (__ROR4__(v127, 2) ^ __ROR4__(v127, 13) ^ __ROR4__(v127, 22)) + (v127 & (v125 | v121) | v125 & v121) + v129;
  v132 = v226[24]
       - 2117940946
       + v122
       + (v130 & (v128 ^ v124) ^ v124)
       + (__ROR4__(v129 + v118, 6) ^ __ROR4__(v130, 11) ^ __ROR4__(v130, 25));
  v133 = (__ROR4__(v131, 2) ^ __ROR4__(v131, 13) ^ __ROR4__(v131, 22)) + (v131 & (v127 | v125) | v127 & v125) + v132;
  v134 = v132 + v121;
  v135 = v226[25]
       - 1838011259
       + v124
       + (v134 & (v130 ^ v128) ^ v128)
       + (__ROR4__(v132 + v121, 6) ^ __ROR4__(v134, 11) ^ __ROR4__(v134, 25));
  v136 = (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + (v133 & (v131 | v127) | v131 & v127) + v135;
  v137 = v135 + v125;
  v138 = v226[26]
       - 1564481375
       + v128
       + ((v135 + v125) & (v134 ^ v130) ^ v130)
       + (__ROR4__(v135 + v125, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25));
  v139 = (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + (v136 & (v133 | v131) | v133 & v131) + v138;
  v140 = v138 + v127;
  v141 = v226[27]
       - 1474664885
       + v130
       + (v140 & (v137 ^ v134) ^ v134)
       + (__ROR4__(v138 + v127, 6) ^ __ROR4__(v140, 11) ^ __ROR4__(v140, 25));
  v142 = v141 + v131;
  v143 = (__ROR4__(v139, 2) ^ __ROR4__(v139, 13) ^ __ROR4__(v139, 22)) + (v139 & (v136 | v133) | v136 & v133) + v141;
  v144 = v226[28]
       - 1035236496
       + v134
       + (v142 & (v140 ^ v137) ^ v137)
       + (__ROR4__(v141 + v131, 6) ^ __ROR4__(v142, 11) ^ __ROR4__(v142, 25));
  v145 = (__ROR4__(v143, 2) ^ __ROR4__(v143, 13) ^ __ROR4__(v143, 22)) + (v143 & (v139 | v136) | v139 & v136) + v144;
  v146 = v144 + v133;
  v147 = v226[29]
       - 949202525
       + v137
       + (v146 & (v142 ^ v140) ^ v140)
       + (__ROR4__(v144 + v133, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25));
  v148 = v147 + v136;
  v149 = (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + (v145 & (v143 | v139) | v143 & v139) + v147;
  v150 = v226[30]
       - 778901479
       + v140
       + (v148 & (v146 ^ v142) ^ v142)
       + (__ROR4__(v147 + v136, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25));
  v151 = (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + (v149 & (v145 | v143) | v145 & v143) + v150;
  v152 = v150 + v139;
  v153 = v226[31]
       - 694614492
       + v142
       + (v152 & (v148 ^ v146) ^ v146)
       + (__ROR4__(v150 + v139, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25));
  v154 = (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + (v151 & (v149 | v145) | v149 & v145) + v153;
  v155 = v153 + v143;
  v156 = v226[32]
       - 200395387
       + v146
       + ((v153 + v143) & (v152 ^ v148) ^ v148)
       + (__ROR4__(v153 + v143, 6) ^ __ROR4__(v155, 11) ^ __ROR4__(v155, 25));
  v157 = (__ROR4__(v154, 2) ^ __ROR4__(v154, 13) ^ __ROR4__(v154, 22)) + (v154 & (v151 | v149) | v151 & v149) + v156;
  v158 = v156 + v145;
  v159 = v226[33]
       + 275423344
       + v148
       + (v158 & (v155 ^ v152) ^ v152)
       + (__ROR4__(v156 + v145, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25));
  v160 = v159 + v149;
  v161 = (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + (v157 & (v154 | v151) | v154 & v151) + v159;
  v162 = v226[34]
       + 430227734
       + v152
       + (v160 & (v158 ^ v155) ^ v155)
       + (__ROR4__(v159 + v149, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25));
  v163 = (__ROR4__(v161, 2) ^ __ROR4__(v161, 13) ^ __ROR4__(v161, 22)) + (v161 & (v157 | v154) | v157 & v154) + v162;
  v164 = v162 + v151;
  v165 = v226[35]
       + 506948616
       + v155
       + (v164 & (v160 ^ v158) ^ v158)
       + (__ROR4__(v162 + v151, 6) ^ __ROR4__(v164, 11) ^ __ROR4__(v164, 25));
  v166 = v165 + v154;
  v167 = (__ROR4__(v163, 2) ^ __ROR4__(v163, 13) ^ __ROR4__(v163, 22)) + (v163 & (v161 | v157) | v161 & v157) + v165;
  v168 = v226[36]
       + 659060556
       + v158
       + (v166 & (v164 ^ v160) ^ v160)
       + (__ROR4__(v165 + v154, 6) ^ __ROR4__(v166, 11) ^ __ROR4__(v166, 25));
  v169 = (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + (v167 & (v163 | v161) | v163 & v161) + v168;
  v170 = v168 + v157;
  v171 = v226[37]
       + 883997877
       + v160
       + (v170 & (v166 ^ v164) ^ v164)
       + (__ROR4__(v168 + v157, 6) ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25));
  v172 = (__ROR4__(v169, 2) ^ __ROR4__(v169, 13) ^ __ROR4__(v169, 22)) + (v169 & (v167 | v163) | v167 & v163) + v171;
  v173 = v171 + v161;
  v174 = v226[38]
       + 958139571
       + v164
       + ((v171 + v161) & (v170 ^ v166) ^ v166)
       + (__ROR4__(v171 + v161, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25));
  v175 = (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + (v172 & (v169 | v167) | v169 & v167) + v174;
  v176 = v174 + v163;
  v177 = v226[39]
       + 1322822218
       + v166
       + (v176 & (v173 ^ v170) ^ v170)
       + (__ROR4__(v174 + v163, 6) ^ __ROR4__(v176, 11) ^ __ROR4__(v176, 25));
  v178 = v177 + v167;
  v179 = (__ROR4__(v175, 2) ^ __ROR4__(v175, 13) ^ __ROR4__(v175, 22)) + (v175 & (v172 | v169) | v172 & v169) + v177;
  v180 = v226[40]
       + 1537002063
       + v170
       + (v178 & (v176 ^ v173) ^ v173)
       + (__ROR4__(v177 + v167, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25));
  v181 = (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + (v179 & (v175 | v172) | v175 & v172) + v180;
  v182 = v180 + v169;
  v183 = v226[41]
       + 1747873779
       + v173
       + (v182 & (v178 ^ v176) ^ v176)
       + (__ROR4__(v180 + v169, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25));
  v184 = v183 + v172;
  v185 = (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v179 | v175) | v179 & v175) + v183;
  v186 = v226[42]
       + 1955562222
       + v176
       + (v184 & (v182 ^ v178) ^ v178)
       + (__ROR4__(v183 + v172, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25));
  v187 = (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + (v185 & (v181 | v179) | v181 & v179) + v186;
  v188 = v186 + v175;
  v189 = v226[43]
       + 2024104815
       + v178
       + (v188 & (v184 ^ v182) ^ v182)
       + (__ROR4__(v186 + v175, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25));
  v190 = (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + (v187 & (v185 | v181) | v185 & v181) + v189;
  v191 = v189 + v179;
  v192 = v226[44]
       - 2067236844
       + v182
       + ((v189 + v179) & (v188 ^ v184) ^ v184)
       + (__ROR4__(v189 + v179, 6) ^ __ROR4__(v191, 11) ^ __ROR4__(v191, 25));
  v193 = v192 + v181;
  v194 = (__ROR4__(v190, 2) ^ __ROR4__(v190, 13) ^ __ROR4__(v190, 22)) + (v190 & (v187 | v185) | v187 & v185) + v192;
  v195 = v226[45]
       - 1933114872
       + v184
       + (v193 & (v191 ^ v188) ^ v188)
       + (__ROR4__(v192 + v181, 6) ^ __ROR4__(v193, 11) ^ __ROR4__(v193, 25));
  v196 = v195 + v185;
  v197 = (__ROR4__(v194, 2) ^ __ROR4__(v194, 13) ^ __ROR4__(v194, 22)) + (v194 & (v190 | v187) | v190 & v187) + v195;
  v198 = v226[46]
       - 1866530822
       + v188
       + (v196 & (v193 ^ v191) ^ v191)
       + (__ROR4__(v195 + v185, 6) ^ __ROR4__(v195 + v185, 11) ^ __ROR4__(v196, 25));
  v224 = v198 + v187;
  result = (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + (v197 & (v194 | v190) | v194 & v190) + v198;
  v200 = v226[47]
       - 1538233109
       + v191
       + (v224 & (v196 ^ v193) ^ v193)
       + (__ROR4__(v198 + v187, 6) ^ __ROR4__(v224, 11) ^ __ROR4__(v224, 25));
  v201 = (__ROR4__(result, 2) ^ __ROR4__(result, 13) ^ __ROR4__(result, 22))
       + (result & (v197 | v194) | v197 & v194)
       + v200;
  v202 = v200 + v190;
  v203 = v227[0]
       - 1090935817
       + v193
       + (v202 & (v224 ^ v196) ^ v196)
       + (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25));
  v204 = v203 + v194;
  v205 = (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + (v201 & (result | v197) | result & v197) + v203;
  v206 = v227[1]
       - 965641998
       + v196
       + (v204 & (v202 ^ v224) ^ v224)
       + (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25));
  v207 = (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + (v205 & (v201 | result) | v201 & result) + v206;
  v208 = 0;
  v220 = result;
  v223 = v202;
  v219 = v201;
  v222 = v204;
  v221 = v206 + v197;
  v217 = v207;
  v218 = v205;
  while ( 1 )
  {
    a1[v208++] += v207;
    if ( v208 == 8 )
      break;
    v207 = *(int *)((char *)&v217 + v208 * 4);
  }
  return result;
}

//----- (000110C4) --------------------------------------------------------
double __fastcall sub_110C4(double a1)
{
  float v1; // s0
  _DWORD *v2; // r4
  double result; // r0

  v2 = (_DWORD *)LODWORD(a1);
  result = log10(a1);
  if ( (int)(v1 + 1.0) > *v2 )
    ++*v2;
  return result;
}
// 110C8: variable 'v1' is possibly undefined

//----- (000110F8) --------------------------------------------------------
double __fastcall sub_110F8(double a1)
{
  double v1; // d0
  _DWORD *v2; // r4
  double result; // r0

  v1 = (double)SLODWORD(a1);
  v2 = (_DWORD *)HIDWORD(a1);
  result = log10(a1);
  if ( (int)(v1 + 1.0) > *v2 )
    ++*v2;
  return result;
}

//----- (00011130) --------------------------------------------------------
int __fastcall sub_11130(unsigned __int64 a1, char *a2, size_t a3, int a4)
{
  __int64 v6; // r2
  __int64 v7; // r0
  double v8; // r0
  double v9; // d8
  bool v11; // cf
  __int64 v12; // r0
  double v13; // d0
  double v14; // r0
  __int64 v15; // r0
  __int64 v16; // r0
  __int64 v17; // r0
  __int16 v18; // [sp+1Ch] [bp-4h] BYREF

  v18 = 0;
  if ( a1 > 0xDE0B6B3A763FFFFLL )
  {
    LODWORD(v6) = -1530494976;
    HIDWORD(v6) = (char *)&loc_38D7C + 2;
    LODWORD(v7) = sub_4943C(a1, v6);
    LODWORD(v8) = sub_493C8(v7);
    v18 = 69;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  v11 = (unsigned int)&loc_38D7C + 2 >= HIDWORD(a1);
  if ( (_UNKNOWN *)((char *)&loc_38D7C + 2) == (_UNKNOWN *)HIDWORD(a1) )
    v11 = (unsigned int)a1 <= 0xA4C67FFF;
  if ( !v11 )
  {
    LODWORD(v12) = sub_4943C(a1, 1000000000000LL);
    LODWORD(v8) = sub_493C8(v12);
    v18 = 80;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xE8D4A50FFFLL )
  {
    LODWORD(v16) = sub_4943C(a1, 1000000000);
    LODWORD(v8) = sub_493C8(v16);
    v18 = 84;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3B9AC9FF )
  {
    LODWORD(v15) = sub_4943C(a1, 1000000);
    LODWORD(v8) = sub_493C8(v15);
    v18 = 71;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xF423F )
  {
    LODWORD(v17) = sub_4943C(a1, 1000);
    LODWORD(v8) = sub_493C8(v17);
    v18 = 77;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3E7 )
  {
    LODWORD(v8) = sub_493C8(a1);
    v18 = 75;
    v9 = v8 / 1000.0;
LABEL_3:
    if ( !a4 )
      return snprintf(a2, a3, "%.3g%s", v9, (const char *)&v18);
    goto LABEL_9;
  }
  LODWORD(v8) = sub_493C8(a1);
  v9 = v8;
  if ( !a4 )
    return snprintf(a2, a3, "%d%s", (unsigned int)v8, (const char *)&v18);
LABEL_9:
  if ( v9 <= 0.0 )
  {
    v13 = 0.0;
  }
  else
  {
    v13 = v9;
    v14 = log10(v8);
    floor(v14);
  }
  return snprintf(a2, a3, "%*.*f%s", a4 + 1, (int)((double)(a4 - 1) - v13), v9, (const char *)&v18);
}
// 1118C: variable 'v7' is possibly undefined
// 1119C: variable 'v8' is possibly undefined
// 111F8: variable 'v12' is possibly undefined
// 112E4: variable 'v16' is possibly undefined
// 112B0: variable 'v15' is possibly undefined
// 11354: variable 'v17' is possibly undefined

//----- (000113C4) --------------------------------------------------------
int __fastcall sub_113C4(int a1)
{
  double v1; // d0
  int v3; // r4
  double v4; // d8
  __int64 v5; // r0
  double v6; // d8
  double v7; // r0
  double v8; // d9
  double v9; // r0
  double v10; // d9
  double v11; // r0
  double v12; // d9
  double v13; // r0
  double v14; // d9
  unsigned __int64 v15; // r0
  int result; // r0
  double v17; // d16
  double v18; // d16

  v3 = *(_DWORD *)(a1 + 260);
  v4 = v1;
  if ( v1 == 0.0 )
  {
    v5 = *(_QWORD *)(a1 + 184);
    v6 = 65536.0;
    if ( !byte_63DF9 )
      v6 = 2.69595353e67;
    LODWORD(v7) = sub_493C8(v5);
    v8 = v7 * 6.27710174e57;
    LODWORD(v9) = sub_493C8(*(_QWORD *)(a1 + 176));
    v10 = v8 + v9 * 3.40282367e38;
    LODWORD(v11) = sub_493C8(*(_QWORD *)(a1 + 168));
    v12 = v10 + v11 * 1.84467441e19;
    LODWORD(v13) = sub_493C8(*(_QWORD *)(a1 + 160));
    v14 = v12 + v13;
    if ( v14 == 0.0 )
      v14 = 1.0;
    v4 = v6 / v14;
  }
  *(double *)(a1 + 376) = v4;
  *(double *)(v3 + 472) = v4;
  round();
  LODWORD(v15) = sub_494C0(v4);
  result = sub_11130(v15, (char *)(*(_DWORD *)(a1 + 260) + 48), 8u, 0);
  v17 = *(double *)(v3 + 456);
  if ( v17 == v4 )
  {
    ++*(_DWORD *)(v3 + 480);
    goto LABEL_9;
  }
  if ( v17 <= v4 )
  {
    if ( v17 != 0.0 )
    {
LABEL_9:
      v18 = *(double *)(v3 + 464);
      if ( v18 != v4 )
        goto LABEL_10;
LABEL_16:
      ++*(_DWORD *)(v3 + 484);
      return result;
    }
    *(double *)(v3 + 456) = v4;
    *(_DWORD *)(v3 + 480) = 1;
  }
  else
  {
    *(double *)(v3 + 456) = v4;
    *(_DWORD *)(v3 + 480) = 1;
  }
  v18 = *(double *)(v3 + 464);
  if ( v18 == v4 )
    goto LABEL_16;
LABEL_10:
  if ( v18 < v4 )
  {
    *(double *)(v3 + 464) = v4;
    *(_DWORD *)(v3 + 484) = 1;
  }
  return result;
}
// 113DC: variable 'v1' is possibly undefined
// 11414: variable 'v7' is possibly undefined
// 11428: variable 'v9' is possibly undefined
// 1143C: variable 'v11' is possibly undefined
// 1144C: variable 'v13' is possibly undefined
// 1148C: variable 'v15' is possibly undefined
// AEAC: using guessed type int round(void);
// 63DF9: using guessed type char byte_63DF9;

//----- (0001155C) --------------------------------------------------------
void __fastcall sub_1155C(char *a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  char v4[1016]; // [sp+8h] [bp-C00h] BYREF
  char v5[2048]; // [sp+408h] [bp-800h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    --v2;
    v3 = (unsigned __int8)a2 + (v3 << 8);
    a2 >>= 8;
  }
  while ( v2 );
  sub_29460(v4, a1, 128);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
  {
    snprintf(v5, 0x800u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v4);
    sub_38438(3, v5, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (0001161C) --------------------------------------------------------
bool sub_1161C()
{
  struct tm *v0; // r0
  int v1; // r12
  int v3; // r2
  int tm_hour; // r1
  int v5; // r2
  time_t tv_sec; // [sp+4h] [bp-Ch] BYREF
  struct timeval v7; // [sp+8h] [bp-8h] BYREF

  if ( !byte_63E14 && !byte_63B90 )
    return 1;
  sub_2B13C(&v7);
  tv_sec = v7.tv_sec;
  v0 = localtime(&tv_sec);
  if ( !byte_63E14 )
  {
    tm_hour = v0->tm_hour;
    return tm_hour < dword_63B9C || tm_hour == dword_63B9C && v0->tm_min < dword_63B98;
  }
  if ( !byte_63B90 )
  {
    v1 = v0->tm_hour;
    if ( v1 >= dword_63E20 && (v1 != dword_63E20 || v0->tm_min >= dword_63E1C) )
    {
      byte_63E14 = 0;
      return 1;
    }
    return 0;
  }
  if ( dword_63E20 >= dword_63B9C && (dword_63E20 != dword_63B9C || dword_63E1C >= dword_63B98) )
  {
    v3 = v0->tm_hour;
    if ( dword_63E20 <= v3 )
    {
      if ( dword_63E20 != v3 || v0->tm_min >= dword_63E1C )
        return 1;
    }
    else if ( dword_63B9C > v3 )
    {
      return 1;
    }
    return dword_63B9C == v3 && v0->tm_min < dword_63B98;
  }
  v5 = v0->tm_hour;
  return (dword_63B9C > v5 || dword_63B9C == v5 && v0->tm_min < dword_63B98)
      && dword_63E20 <= v5
      && (dword_63E20 != v5 || v0->tm_min >= dword_63E1C);
}
// 63B90: using guessed type char byte_63B90;
// 63B98: using guessed type int dword_63B98;
// 63B9C: using guessed type int dword_63B9C;
// 63E14: using guessed type char byte_63E14;
// 63E1C: using guessed type int dword_63E1C;
// 63E20: using guessed type int dword_63E20;

//----- (000117A4) --------------------------------------------------------
_DWORD *__fastcall sub_117A4(int a1)
{
  int i; // r1
  _BYTE v4[32]; // [sp+0h] [bp-70h] BYREF
  _BYTE v5[80]; // [sp+20h] [bp-50h] BYREF

  for ( i = 0; i != 80; i += 4 )
    *(_DWORD *)&v5[i] = bswap32(*(_DWORD *)(a1 + i));
  sub_303DC(v5, 0x50u, (int)v4);
  return sub_303DC(v4, 0x20u, a1 + 192);
}

//----- (000117F4) --------------------------------------------------------
int __fastcall sub_117F4(int a1)
{
  int i; // r4
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int result; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  _BYTE v10[64]; // [sp+0h] [bp-ECh] BYREF
  int v11[38]; // [sp+40h] [bp-ACh] BYREF
  int v12; // [sp+D8h] [bp-14h]
  int v13; // [sp+DCh] [bp-10h]
  int v14; // [sp+E0h] [bp-Ch]
  int v15; // [sp+E4h] [bp-8h]

  for ( i = 0; i != 64; i += 4 )
    *(_DWORD *)&v10[i] = bswap32(*(_DWORD *)(a1 + i));
  v2 = (_DWORD *)(a1 + 128);
  sub_30210(v11);
  sub_30244(v11, v10, 0x40u);
  v3 = v11[35];
  v4 = v11[36];
  v5 = v11[37];
  *v2 = v11[34];
  v2[1] = v3;
  v2[2] = v4;
  v2[3] = v5;
  v2 += 4;
  result = v12;
  v7 = v13;
  v8 = v14;
  v9 = v15;
  *v2 = v12;
  v2[1] = v7;
  v2[2] = v8;
  v2[3] = v9;
  return result;
}

//----- (00011854) --------------------------------------------------------
void __fastcall __noreturn sub_11854(void *a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(5u);
  exit(1);
}

//----- (0001187C) --------------------------------------------------------
void __noreturn sub_1187C(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_60FA8, 0x200u, a1, varg_r1);
  sub_38438(3, byte_60FA8, 1);
  exit(1);
}

//----- (000118C4) --------------------------------------------------------
int __fastcall sub_118C4(int a1, int a2, int a3)
{
  int v6; // r3
  char v8[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being disabled", a2);
    sub_38438(4, v8, 0);
  }
  v6 = (unsigned __int8)byte_630C1;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0;
  if ( v6 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    sub_38438(7, v8, 0);
  }
  sub_2F1F8((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 8565);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(v8, 0x800u, "Thread %d being re-enabled", a2);
    sub_38438(4, v8, 0);
  }
  return (*(int (__fastcall **)(int))(a3 + 92))(a1);
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00011A5C) --------------------------------------------------------
int __fastcall sub_11A5C(int a1)
{
  _DWORD *v1; // r6
  int v3; // r5
  char v5[16]; // [sp+0h] [bp-810h] BYREF
  char v6[2048]; // [sp+10h] [bp-800h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v3 = v1[1];
  snprintf(v5, 0x10u, "%d/Miner", *(_DWORD *)a1);
  sub_2F02C(v5);
  sub_F808(a1);
  if ( (*(int (__fastcall **)(int))(v3 + 52))(a1) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(v6, "Waiting on sem in miner thread");
      sub_38438(7, v6, 0);
    }
    sub_2F1F8((sem_t *)(a1 + 16), "cgminer.c", "miner_thread", 9151);
    v1[58] = time(0);
    (*(void (__fastcall **)(int))(v3 + 60))(a1);
    (*(void (__fastcall **)(int))(v3 + 88))(a1);
  }
  else
  {
    sub_2ED00(v1, 0);
  }
  return 0;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00011B90) --------------------------------------------------------
int __fastcall sub_11B90(int a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // t1

  if ( dword_63740 <= 0 )
    return sub_B410(a1);
  v1 = dword_639E0;
  v2 = *(_DWORD *)dword_639E0;
  if ( *(_DWORD *)(*(_DWORD *)dword_639E0 + 4) != a1 )
  {
    v3 = 0;
    while ( ++v3 != dword_63740 )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return sub_B410(a1);
  }
  return v2;
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00011BFC) --------------------------------------------------------
void sub_11BFC()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  strcpy(v0, "Unable to set thread to low priority");
  sub_38438(7, v0, 0);
}

//----- (00011C4C) --------------------------------------------------------
void sub_11C4C()
{
  if ( !nice(10) && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    sub_11BFC();
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00011CBC) --------------------------------------------------------
int __fastcall sub_11CBC(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_2F02C("API");
  sub_11C4C();
  sub_3646C(dword_611A8);
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}
// 611A8: using guessed type int dword_611A8;

//----- (00011D08) --------------------------------------------------------
char *__fastcall sub_11D08(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_47A58(a1, a2);
  if ( !result && (*a2 < 100.0 || *a2 > 250.0) )
    return "Value out of range";
  return result;
}

//----- (00011D58) --------------------------------------------------------
char *__fastcall sub_11D58(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_47A58(a1, a2);
  if ( !result && (*a2 < 125.0 || *a2 > 500.0) )
    return "Value out of range";
  return result;
}

//----- (00011DA8) --------------------------------------------------------
int __fastcall sub_11DA8(int result)
{
  int v1; // r4
  int *v2; // r2
  int v3; // r12
  int v4; // r3
  int v5; // t1

  v1 = *(_DWORD *)(result + 156);
  if ( dword_63740 > 0 )
  {
    v2 = (int *)dword_639E0;
    v3 = dword_639E0 + 4 * dword_63740;
    do
    {
      while ( 1 )
      {
        v5 = *v2++;
        v4 = v5;
        if ( !*(_BYTE *)(v5 + 97) && *(_DWORD *)(v4 + 100) == 1 && (!*(_BYTE *)(v4 + 632) || *(_BYTE *)(v4 + 633)) )
          break;
        if ( v2 == (int *)v3 )
          goto LABEL_11;
      }
      if ( *(_DWORD *)(v4 + 156) < v1 )
      {
        result = v4;
        v1 = *(_DWORD *)(v4 + 156);
      }
    }
    while ( v2 != (int *)v3 );
LABEL_11:
    v1 = *(_DWORD *)(result + 156);
  }
  *(_DWORD *)(result + 156) = v1 + 1;
  return result;
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00011E40) --------------------------------------------------------
int __fastcall sub_11E40(int *a1, int a2, int *a3)
{
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r10
  _DWORD *v8; // r3
  int *v9; // r2
  unsigned int v10; // lr
  unsigned int v11; // r12
  unsigned int v12; // r1
  unsigned int v13; // t1
  int v14; // r3
  int *v15; // r5
  int v16; // r7
  int i; // r3
  int v18; // r4
  int v19; // r3
  int v20; // r9
  int v21; // r7
  int v22; // r11
  int v23; // r0
  int v24; // r8
  int v25; // r2
  int v26; // r10
  int v27; // r1
  int v28; // r5
  bool v29; // zf
  int v30; // r11
  int v31; // r7
  int v32; // r9
  int v33; // r6
  int v34; // r3
  int v35; // r0
  int v36; // r1
  int v37; // r2
  int v38; // r5
  int v39; // r4
  int v40; // r12
  int v41; // lr
  int v42; // r7
  int v43; // lr
  int v44; // r6
  int v45; // r9
  int v46; // r11
  int v47; // r4
  int v48; // r12
  int v49; // r2
  int v50; // r1
  int v51; // r5
  int v52; // r8
  int v53; // r10
  int v54; // r2
  int v55; // r11
  int v56; // r9
  int v57; // lr
  int v58; // r5
  int v59; // r7
  int v60; // r6
  int v61; // r1
  int v62; // r3
  int v63; // r0
  int v64; // r3
  int v65; // r9
  int v66; // r7
  int v67; // r11
  int v68; // r0
  int v69; // r8
  int v70; // r2
  int v71; // r10
  int v72; // r1
  int v73; // r5
  int v74; // r4
  int v75; // r11
  int v76; // r7
  int v77; // r9
  int v78; // r6
  int v79; // r3
  int v80; // r0
  int v81; // r1
  int v82; // r2
  int v83; // r5
  int v84; // r4
  int v85; // r12
  int v86; // lr
  int v87; // lr
  int v88; // r9
  int v89; // r7
  int v90; // r11
  int v91; // r10
  int v92; // r4
  int v93; // r6
  int v94; // r1
  int v95; // r5
  int v96; // r8
  int v97; // r10
  int v98; // r11
  int v99; // r9
  int v100; // r7
  int v101; // lr
  int v102; // r6
  int v103; // r5
  int v104; // r12
  int v105; // r1
  int v106; // r0
  int v107; // r3
  int v108; // r2
  __int16 v109; // r2
  int *v110; // r1
  int v111; // r0
  __int64 v112; // t1
  int v113; // lr
  int v114; // r10
  int v115; // r2
  int v116; // r9
  int v117; // r11
  int v118; // r3
  int v119; // r6
  int v120; // r4
  int v121; // r5
  int v122; // r8
  int v123; // r10
  int v124; // r11
  int v125; // r9
  int v126; // r6
  int v127; // lr
  int v128; // r7
  int v129; // r5
  int v130; // r2
  int v131; // r3
  int v132; // r12
  int v133; // r1
  int v134; // r0
  int v135; // r7
  int v136; // r0
  int v137; // r2
  int v138; // r4
  int v139; // r9
  int v140; // r7
  int v141; // r11
  int v142; // r10
  int v143; // r6
  int v144; // r1
  int v145; // r5
  int v146; // lr
  int v147; // r8
  int v148; // r10
  int v149; // r1
  int v150; // r11
  int v151; // r7
  int v152; // r9
  int v153; // r5
  int v154; // r6
  int v155; // r12
  int v156; // lr
  int v157; // r0
  int v158; // r3
  int v159; // r2
  int *v160; // r12
  int v161; // lr
  __int64 v162; // t1
  int v163; // r10
  int v164; // r2
  int v165; // r9
  int v166; // r11
  int v167; // lr
  int v168; // r6
  int v169; // r3
  int v170; // r4
  int v171; // r5
  int v172; // r8
  int v173; // r10
  int v174; // r11
  int v175; // r9
  int v176; // r3
  int v177; // r6
  int v178; // r7
  int v179; // lr
  int v180; // r5
  int v181; // r2
  int v182; // r12
  int v183; // r1
  int v184; // r0
  int v185; // r7
  int v186; // r0
  int v187; // r12
  int v188; // r2
  int v189; // r5
  int v190; // r12
  int v191; // r9
  int v192; // r7
  int v193; // r11
  int v194; // r10
  int v195; // r4
  int v196; // r6
  int v197; // r1
  int v198; // r8
  int v199; // lr
  int v200; // r10
  int v201; // r9
  int v202; // r11
  int v203; // r7
  int v204; // r1
  int v205; // r5
  int v206; // r6
  int v207; // lr
  int v208; // r12
  int v209; // r0
  int v210; // r3
  int v211; // r2
  int v212; // r6
  int v213; // r1
  int v214; // r2
  int v215; // r3
  int v216; // r0
  int v217; // r1
  int v218; // r2
  int v219; // r3
  int v220; // r0
  int v221; // r1
  int v222; // r2
  int v223; // r3
  int v224; // r12
  int v225; // r3
  int v227; // [sp+4h] [bp-2C8h]
  int v228; // [sp+4h] [bp-2C8h]
  int v229; // [sp+4h] [bp-2C8h]
  int v230; // [sp+4h] [bp-2C8h]
  int v231; // [sp+4h] [bp-2C8h]
  int v232; // [sp+4h] [bp-2C8h]
  int v233; // [sp+4h] [bp-2C8h]
  int v234; // [sp+4h] [bp-2C8h]
  int v235; // [sp+4h] [bp-2C8h]
  int v236; // [sp+4h] [bp-2C8h]
  int v237; // [sp+4h] [bp-2C8h]
  int v238; // [sp+8h] [bp-2C4h]
  int v239; // [sp+8h] [bp-2C4h]
  int v240; // [sp+8h] [bp-2C4h]
  int v241; // [sp+8h] [bp-2C4h]
  int v242; // [sp+8h] [bp-2C4h]
  int v243; // [sp+8h] [bp-2C4h]
  int v244; // [sp+8h] [bp-2C4h]
  int v245; // [sp+8h] [bp-2C4h]
  int v246; // [sp+8h] [bp-2C4h]
  int v247; // [sp+8h] [bp-2C4h]
  int v248; // [sp+Ch] [bp-2C0h]
  int v249; // [sp+Ch] [bp-2C0h]
  int v250; // [sp+Ch] [bp-2C0h]
  int v251; // [sp+Ch] [bp-2C0h]
  int v252; // [sp+Ch] [bp-2C0h]
  int v253; // [sp+Ch] [bp-2C0h]
  int v254; // [sp+Ch] [bp-2C0h]
  int v255; // [sp+Ch] [bp-2C0h]
  int v256; // [sp+10h] [bp-2BCh]
  int v257; // [sp+10h] [bp-2BCh]
  int v258; // [sp+10h] [bp-2BCh]
  int v259; // [sp+10h] [bp-2BCh]
  int v260; // [sp+10h] [bp-2BCh]
  int v261; // [sp+10h] [bp-2BCh]
  int v262; // [sp+10h] [bp-2BCh]
  int v263; // [sp+10h] [bp-2BCh]
  int v264; // [sp+14h] [bp-2B8h]
  int v265; // [sp+14h] [bp-2B8h]
  int v266; // [sp+14h] [bp-2B8h]
  int v267; // [sp+14h] [bp-2B8h]
  int v268; // [sp+14h] [bp-2B8h]
  int v269; // [sp+14h] [bp-2B8h]
  int v270; // [sp+14h] [bp-2B8h]
  int v271; // [sp+14h] [bp-2B8h]
  int v272; // [sp+18h] [bp-2B4h]
  int v273; // [sp+18h] [bp-2B4h]
  int v274; // [sp+18h] [bp-2B4h]
  int v275; // [sp+18h] [bp-2B4h]
  int v276; // [sp+18h] [bp-2B4h]
  int v277; // [sp+18h] [bp-2B4h]
  int v278; // [sp+18h] [bp-2B4h]
  int v279; // [sp+18h] [bp-2B4h]
  int v280; // [sp+1Ch] [bp-2B0h]
  int v281; // [sp+1Ch] [bp-2B0h]
  int v282; // [sp+1Ch] [bp-2B0h]
  int v283; // [sp+1Ch] [bp-2B0h]
  int v284; // [sp+1Ch] [bp-2B0h]
  int v285; // [sp+1Ch] [bp-2B0h]
  int v286; // [sp+1Ch] [bp-2B0h]
  int v287; // [sp+1Ch] [bp-2B0h]
  int v288; // [sp+20h] [bp-2ACh]
  int v289; // [sp+20h] [bp-2ACh]
  int v290; // [sp+20h] [bp-2ACh]
  int v291; // [sp+20h] [bp-2ACh]
  int v292; // [sp+20h] [bp-2ACh]
  int v293; // [sp+20h] [bp-2ACh]
  int v294; // [sp+20h] [bp-2ACh]
  int v295; // [sp+20h] [bp-2ACh]
  int v296; // [sp+24h] [bp-2A8h]
  int v297; // [sp+24h] [bp-2A8h]
  int v298; // [sp+24h] [bp-2A8h]
  int v299; // [sp+24h] [bp-2A8h]
  int v300; // [sp+24h] [bp-2A8h]
  int v301; // [sp+24h] [bp-2A8h]
  int v302; // [sp+24h] [bp-2A8h]
  int v303; // [sp+24h] [bp-2A8h]
  int v304; // [sp+28h] [bp-2A4h]
  int v305; // [sp+28h] [bp-2A4h]
  int v306; // [sp+28h] [bp-2A4h]
  int v307; // [sp+28h] [bp-2A4h]
  int v308; // [sp+28h] [bp-2A4h]
  int v309; // [sp+28h] [bp-2A4h]
  int v310; // [sp+28h] [bp-2A4h]
  int v311; // [sp+28h] [bp-2A4h]
  int v312; // [sp+2Ch] [bp-2A0h]
  int v313; // [sp+2Ch] [bp-2A0h]
  int v314; // [sp+2Ch] [bp-2A0h]
  int v315; // [sp+2Ch] [bp-2A0h]
  int v316; // [sp+2Ch] [bp-2A0h]
  int v317; // [sp+2Ch] [bp-2A0h]
  int v318; // [sp+30h] [bp-29Ch]
  int v319; // [sp+30h] [bp-29Ch]
  int v320; // [sp+30h] [bp-29Ch]
  int v321; // [sp+30h] [bp-29Ch]
  int v322; // [sp+30h] [bp-29Ch]
  int v323; // [sp+30h] [bp-29Ch]
  int v324; // [sp+34h] [bp-298h]
  int v325; // [sp+34h] [bp-298h]
  int v326; // [sp+34h] [bp-298h]
  int v327; // [sp+34h] [bp-298h]
  int v328; // [sp+34h] [bp-298h]
  int v329; // [sp+34h] [bp-298h]
  int v330; // [sp+38h] [bp-294h]
  int v331; // [sp+38h] [bp-294h]
  int v332; // [sp+38h] [bp-294h]
  int v333; // [sp+38h] [bp-294h]
  int v334; // [sp+38h] [bp-294h]
  int v335; // [sp+38h] [bp-294h]
  int v336; // [sp+3Ch] [bp-290h]
  int v337; // [sp+3Ch] [bp-290h]
  int v338; // [sp+3Ch] [bp-290h]
  int v339; // [sp+3Ch] [bp-290h]
  int v340; // [sp+3Ch] [bp-290h]
  int v341; // [sp+3Ch] [bp-290h]
  int v342; // [sp+40h] [bp-28Ch]
  int v343; // [sp+40h] [bp-28Ch]
  int v344; // [sp+40h] [bp-28Ch]
  int v345; // [sp+40h] [bp-28Ch]
  int v346; // [sp+40h] [bp-28Ch]
  int v347; // [sp+40h] [bp-28Ch]
  int v348; // [sp+44h] [bp-288h]
  int v349; // [sp+44h] [bp-288h]
  int v350; // [sp+44h] [bp-288h]
  int v351; // [sp+44h] [bp-288h]
  int v352; // [sp+44h] [bp-288h]
  int v353; // [sp+44h] [bp-288h]
  int v354; // [sp+48h] [bp-284h]
  int v355; // [sp+48h] [bp-284h]
  int v356; // [sp+48h] [bp-284h]
  int v357; // [sp+48h] [bp-284h]
  int v358; // [sp+48h] [bp-284h]
  int v359; // [sp+48h] [bp-284h]
  int v360; // [sp+4Ch] [bp-280h]
  int v361; // [sp+4Ch] [bp-280h]
  int v362; // [sp+4Ch] [bp-280h]
  int v363; // [sp+4Ch] [bp-280h]
  int v364; // [sp+4Ch] [bp-280h]
  int v365; // [sp+4Ch] [bp-280h]
  int v366; // [sp+50h] [bp-27Ch]
  int v367; // [sp+50h] [bp-27Ch]
  int v368; // [sp+50h] [bp-27Ch]
  int v369; // [sp+50h] [bp-27Ch]
  int v370; // [sp+50h] [bp-27Ch]
  int v371; // [sp+50h] [bp-27Ch]
  int v372; // [sp+54h] [bp-278h]
  int v373; // [sp+54h] [bp-278h]
  int v374; // [sp+54h] [bp-278h]
  int v375; // [sp+54h] [bp-278h]
  int v376; // [sp+54h] [bp-278h]
  int v377; // [sp+54h] [bp-278h]
  int v378; // [sp+58h] [bp-274h]
  int v379; // [sp+58h] [bp-274h]
  int v380; // [sp+58h] [bp-274h]
  int v381; // [sp+58h] [bp-274h]
  int v382; // [sp+58h] [bp-274h]
  int v383; // [sp+58h] [bp-274h]
  int v384; // [sp+5Ch] [bp-270h]
  int v385; // [sp+5Ch] [bp-270h]
  int v386; // [sp+5Ch] [bp-270h]
  int v387; // [sp+5Ch] [bp-270h]
  int v388; // [sp+5Ch] [bp-270h]
  int v389; // [sp+5Ch] [bp-270h]
  int v390; // [sp+60h] [bp-26Ch]
  int v391; // [sp+60h] [bp-26Ch]
  int v392; // [sp+60h] [bp-26Ch]
  int v393; // [sp+60h] [bp-26Ch]
  int v394; // [sp+60h] [bp-26Ch]
  int v395; // [sp+60h] [bp-26Ch]
  int v396; // [sp+64h] [bp-268h]
  int v397; // [sp+64h] [bp-268h]
  int v398; // [sp+64h] [bp-268h]
  int v399; // [sp+64h] [bp-268h]
  int v400; // [sp+64h] [bp-268h]
  int v401; // [sp+64h] [bp-268h]
  int v402; // [sp+68h] [bp-264h]
  int v403; // [sp+68h] [bp-264h]
  int v404; // [sp+68h] [bp-264h]
  int v405; // [sp+68h] [bp-264h]
  int v406; // [sp+68h] [bp-264h]
  int v407; // [sp+68h] [bp-264h]
  int v408; // [sp+6Ch] [bp-260h]
  int v409; // [sp+6Ch] [bp-260h]
  int v410; // [sp+6Ch] [bp-260h]
  int v411; // [sp+6Ch] [bp-260h]
  int v412; // [sp+6Ch] [bp-260h]
  int v413; // [sp+6Ch] [bp-260h]
  int v414; // [sp+70h] [bp-25Ch]
  int v415; // [sp+70h] [bp-25Ch]
  int v416; // [sp+70h] [bp-25Ch]
  int v417; // [sp+70h] [bp-25Ch]
  int v418; // [sp+70h] [bp-25Ch]
  int v419; // [sp+70h] [bp-25Ch]
  int v420; // [sp+74h] [bp-258h]
  int v421; // [sp+74h] [bp-258h]
  int v422; // [sp+74h] [bp-258h]
  int v423; // [sp+74h] [bp-258h]
  int v424; // [sp+74h] [bp-258h]
  int v425; // [sp+74h] [bp-258h]
  int v426; // [sp+78h] [bp-254h]
  int v427; // [sp+78h] [bp-254h]
  int v428; // [sp+78h] [bp-254h]
  int v429; // [sp+78h] [bp-254h]
  int v430; // [sp+78h] [bp-254h]
  int v431; // [sp+78h] [bp-254h]
  int v432; // [sp+7Ch] [bp-250h]
  int v433; // [sp+7Ch] [bp-250h]
  int v434; // [sp+7Ch] [bp-250h]
  int v435; // [sp+7Ch] [bp-250h]
  int v436; // [sp+7Ch] [bp-250h]
  int v437; // [sp+7Ch] [bp-250h]
  int v438; // [sp+80h] [bp-24Ch]
  int v439; // [sp+80h] [bp-24Ch]
  int v440; // [sp+80h] [bp-24Ch]
  int v441; // [sp+80h] [bp-24Ch]
  int v442; // [sp+80h] [bp-24Ch]
  int v443; // [sp+80h] [bp-24Ch]
  int v444; // [sp+80h] [bp-24Ch]
  int v445; // [sp+80h] [bp-24Ch]
  int v446; // [sp+84h] [bp-248h]
  int v447; // [sp+84h] [bp-248h]
  int v448; // [sp+84h] [bp-248h]
  int v449; // [sp+84h] [bp-248h]
  int v450; // [sp+84h] [bp-248h]
  int v451; // [sp+84h] [bp-248h]
  int v452; // [sp+88h] [bp-244h]
  int v453; // [sp+88h] [bp-244h]
  int v454; // [sp+88h] [bp-244h]
  int v455; // [sp+88h] [bp-244h]
  int v456; // [sp+88h] [bp-244h]
  int v457; // [sp+88h] [bp-244h]
  int v458; // [sp+88h] [bp-244h]
  int v459; // [sp+88h] [bp-244h]
  int v460; // [sp+8Ch] [bp-240h]
  int v461; // [sp+8Ch] [bp-240h]
  int v462; // [sp+8Ch] [bp-240h]
  int v463; // [sp+8Ch] [bp-240h]
  int v464; // [sp+8Ch] [bp-240h]
  int v465; // [sp+8Ch] [bp-240h]
  int v466; // [sp+90h] [bp-23Ch]
  int v467; // [sp+90h] [bp-23Ch]
  int v468; // [sp+90h] [bp-23Ch]
  int v469; // [sp+90h] [bp-23Ch]
  int v470; // [sp+90h] [bp-23Ch]
  int v471; // [sp+90h] [bp-23Ch]
  int v472; // [sp+94h] [bp-238h]
  int v473; // [sp+94h] [bp-238h]
  int v474; // [sp+94h] [bp-238h]
  int v475; // [sp+94h] [bp-238h]
  int v476; // [sp+98h] [bp-234h]
  int v477; // [sp+98h] [bp-234h]
  int v478; // [sp+98h] [bp-234h]
  int v479; // [sp+98h] [bp-234h]
  int v480; // [sp+98h] [bp-234h]
  int v481; // [sp+98h] [bp-234h]
  int v482; // [sp+9Ch] [bp-230h]
  int v483; // [sp+9Ch] [bp-230h]
  int v484; // [sp+9Ch] [bp-230h]
  int v485; // [sp+9Ch] [bp-230h]
  int v486; // [sp+A0h] [bp-22Ch]
  int v487; // [sp+A0h] [bp-22Ch]
  int v488; // [sp+A0h] [bp-22Ch]
  int v489; // [sp+A0h] [bp-22Ch]
  int v490; // [sp+A0h] [bp-22Ch]
  int v491; // [sp+A0h] [bp-22Ch]
  int v492; // [sp+A4h] [bp-228h]
  int v493; // [sp+A4h] [bp-228h]
  int v494; // [sp+A4h] [bp-228h]
  int v495; // [sp+A4h] [bp-228h]
  int v496; // [sp+A8h] [bp-224h]
  int v497; // [sp+A8h] [bp-224h]
  int v498; // [sp+A8h] [bp-224h]
  int v499; // [sp+A8h] [bp-224h]
  int v500; // [sp+A8h] [bp-224h]
  int v501; // [sp+A8h] [bp-224h]
  char *dest; // [sp+ACh] [bp-220h]
  int desta; // [sp+ACh] [bp-220h]
  int v504; // [sp+B0h] [bp-21Ch]
  char *v505; // [sp+B4h] [bp-218h]
  char *v506; // [sp+B8h] [bp-214h]
  int *v509; // [sp+C0h] [bp-20Ch]
  int v511; // [sp+C8h] [bp-204h] BYREF
  int v512; // [sp+CCh] [bp-200h]
  int v513; // [sp+D0h] [bp-1FCh]
  int v514; // [sp+D4h] [bp-1F8h]
  int v515; // [sp+D8h] [bp-1F4h]
  int v516; // [sp+DCh] [bp-1F0h]
  int v517; // [sp+E0h] [bp-1ECh]
  int v518; // [sp+E4h] [bp-1E8h]
  _DWORD v519[8]; // [sp+E8h] [bp-1E4h]
  int v520; // [sp+108h] [bp-1C4h] BYREF
  int v521; // [sp+10Ch] [bp-1C0h]
  int v522; // [sp+110h] [bp-1BCh]
  int v523; // [sp+114h] [bp-1B8h]
  int v524; // [sp+118h] [bp-1B4h]
  int v525; // [sp+11Ch] [bp-1B0h]
  int v526; // [sp+120h] [bp-1ACh]
  int v527; // [sp+124h] [bp-1A8h]
  int v528[8]; // [sp+128h] [bp-1A4h] BYREF
  int v529; // [sp+148h] [bp-184h] BYREF
  int v530; // [sp+14Ch] [bp-180h]
  int v531; // [sp+150h] [bp-17Ch]
  int v532; // [sp+154h] [bp-178h]
  int v533; // [sp+158h] [bp-174h]
  int v534; // [sp+15Ch] [bp-170h]
  int v535; // [sp+160h] [bp-16Ch]
  int v536; // [sp+164h] [bp-168h]
  _DWORD v537[8]; // [sp+168h] [bp-164h] BYREF
  int v538; // [sp+188h] [bp-144h] BYREF
  int v539; // [sp+18Ch] [bp-140h]
  int v540; // [sp+190h] [bp-13Ch]
  int v541; // [sp+194h] [bp-138h]
  int v542; // [sp+198h] [bp-134h]
  int v543; // [sp+19Ch] [bp-130h]
  int v544; // [sp+1A0h] [bp-12Ch]
  int v545; // [sp+1A4h] [bp-128h]
  int v546[4]; // [sp+1A8h] [bp-124h] BYREF
  int v547; // [sp+1B8h] [bp-114h] BYREF
  int v548; // [sp+1E8h] [bp-E4h] BYREF
  int v549; // [sp+1ECh] [bp-E0h]
  int v550; // [sp+1F0h] [bp-DCh]
  int v551; // [sp+1F4h] [bp-D8h]
  int v552; // [sp+1F8h] [bp-D4h]
  int v553; // [sp+1FCh] [bp-D0h]
  int v554; // [sp+200h] [bp-CCh]
  int v555; // [sp+204h] [bp-C8h]
  int v556[16]; // [sp+208h] [bp-C4h] BYREF
  int src[32]; // [sp+248h] [bp-84h] BYREF
  char v558; // [sp+2C8h] [bp-4h] BYREF

  dest = (char *)((a2 + 63) & 0xFFFFFFC0);
  v511 = 1779033703;
  v512 = -1150833019;
  v513 = 1013904242;
  v514 = -1521486534;
  v515 = 1359893119;
  v516 = -1694144372;
  v517 = 528734635;
  v518 = 1541459225;
  sub_F840(&v511, a1, 1);
  v3 = a1[16];
  v509 = a1 + 16;
  v4 = v509[1];
  v5 = v509[2];
  v6 = v509[3];
  v529 = v3;
  v530 = v4;
  v531 = v5;
  v532 = v6;
  v533 = 128;
  v534 = 0;
  v535 = 0;
  v536 = 0;
  v505 = dest;
  memset(v537, 0, 28);
  v537[7] = -2147352576;
  sub_F840(&v511, &v529, 1);
  v541 = -1521486534;
  v542 = 1359893119;
  v519[0] = v511;
  v519[1] = v512;
  v519[2] = v513;
  v519[3] = v514;
  v538 = 1779033703;
  v7 = 0;
  v539 = -1150833019;
  v540 = 1013904242;
  v543 = -1694144372;
  v544 = 528734635;
  v545 = 1541459225;
  v519[4] = v515;
  v519[5] = v516;
  v519[6] = v517;
  v519[7] = v518;
  do
  {
    *(int *)((char *)&v529 + v7 * 4) = v519[v7] ^ 0x36363636;
    ++v7;
  }
  while ( v7 != 8 );
  memset(v537, 54, sizeof(v537));
  sub_F840(&v538, &v529, 0);
  sub_F840(&v538, a1, 1);
  v8 = &unk_49E74;
  v9 = &v547;
  v10 = a1[17];
  v11 = a1[18];
  v546[0] = bswap32(a1[16]);
  v12 = a1[19];
  v546[1] = bswap32(v10);
  v546[2] = bswap32(v11);
  v546[3] = bswap32(v12);
  do
  {
    v13 = v8[1];
    ++v8;
    v9[1] = bswap32(v13);
    ++v9;
  }
  while ( v8 != (_DWORD *)&unk_49EA0 );
  v14 = 0;
  v548 = 1779033703;
  v549 = -1150833019;
  v550 = 1013904242;
  v551 = -1521486534;
  v552 = 1359893119;
  v553 = -1694144372;
  v554 = 528734635;
  v555 = 1541459225;
  do
  {
    *(int *)((char *)&v529 + v14 * 4) = v519[v14] ^ 0x5C5C5C5C;
    ++v14;
  }
  while ( v14 != 8 );
  memset(v537, 92, sizeof(v537));
  sub_F840(&v548, &v529, 0);
  v15 = src;
  v16 = 0;
  v556[8] = 0x80000000;
  memset(&v556[9], 0, 24);
  v556[15] = 768;
  do
  {
    ++v16;
    v520 = v538;
    v521 = v539;
    v522 = v540;
    v523 = v541;
    v547 = v16;
    v524 = v542;
    v525 = v543;
    v526 = v544;
    v527 = v545;
    sub_F840(&v520, v546, 0);
    v556[0] = v520;
    v556[1] = v521;
    v556[2] = v522;
    v556[3] = v523;
    v556[4] = v524;
    v556[5] = v525;
    v556[6] = v526;
    v556[7] = v527;
    v528[0] = v548;
    v528[1] = v549;
    v528[2] = v550;
    v528[3] = v551;
    v528[4] = v552;
    v528[5] = v553;
    v528[6] = v554;
    v528[7] = v555;
    sub_F840(v528, v556, 0);
    for ( i = 0; i != 8; ++i )
      v15[i] = bswap32(v528[i]);
    v15 += 8;
  }
  while ( v16 != 4 );
  v318 = src[0];
  v506 = dest + 0x20000;
  v312 = src[16];
  v324 = src[1];
  v414 = src[17];
  v330 = src[2];
  v420 = src[18];
  v336 = src[3];
  v426 = src[19];
  v342 = src[4];
  v432 = src[20];
  v348 = src[5];
  v438 = src[21];
  v354 = src[6];
  v446 = src[22];
  v360 = src[7];
  v452 = src[23];
  v366 = src[8];
  v460 = src[24];
  v372 = src[9];
  v466 = src[25];
  v378 = src[10];
  v472 = src[26];
  v384 = src[11];
  v476 = src[27];
  v390 = src[12];
  v482 = src[28];
  v396 = src[13];
  v486 = src[29];
  v402 = src[14];
  v492 = src[30];
  v408 = src[15];
  v496 = src[31];
  do
  {
    memcpy(dest, src, 0x80u);
    v319 = v312 ^ v318;
    v325 = v414 ^ v324;
    v331 = v420 ^ v330;
    v337 = v426 ^ v336;
    v343 = v432 ^ v342;
    v349 = v438 ^ v348;
    v355 = v446 ^ v354;
    v361 = v452 ^ v360;
    v367 = v460 ^ v366;
    v373 = v466 ^ v372;
    v379 = v472 ^ v378;
    v385 = v476 ^ v384;
    v264 = v385;
    v397 = v486 ^ v396;
    v409 = v496 ^ v408;
    v288 = v397;
    v18 = v409;
    v256 = v355;
    v19 = v492 ^ v402;
    v20 = v361;
    v21 = v331;
    v22 = v367;
    v23 = v337;
    v24 = v379;
    v25 = v373;
    v26 = v325;
    v27 = v343;
    v28 = v319;
    v391 = v482 ^ v390;
    v248 = v391;
    v403 = v492 ^ v402;
    v296 = v349;
    v304 = 4;
    do
    {
      v227 = v27 ^ __ROR4__(v248 + v28, 25);
      v272 = v19 ^ __ROR4__(v256 + v24, 25);
      v29 = v304-- == 1;
      v238 = v25 ^ __ROR4__(v26 + v296, 25);
      v280 = v23 ^ __ROR4__(v264 + v18, 25);
      v30 = v22 ^ __ROR4__(v227 + v28, 23);
      v31 = v21 ^ __ROR4__(v272 + v24, 23);
      v32 = v20 ^ __ROR4__(v280 + v18, 23);
      v33 = v248 ^ __ROR4__(v30 + v227, 19);
      v34 = v288 ^ __ROR4__(v238 + v296, 23);
      v35 = v264 ^ __ROR4__(v32 + v280, 19);
      v36 = v256 ^ __ROR4__(v31 + v272, 19);
      v37 = v26 ^ __ROR4__(v34 + v238, 19);
      v38 = v28 ^ __ROR4__(v33 + v30, 14);
      v39 = v18 ^ __ROR4__(v35 + v32, 14);
      v40 = v24 ^ __ROR4__(v36 + v31, 14);
      v41 = v296 ^ __ROR4__(v37 + v34, 14);
      v248 = v33 ^ __ROR4__(v39 + v272, 25);
      v264 = v35 ^ __ROR4__(v40 + v238, 25);
      v256 = v36 ^ __ROR4__(v41 + v227, 25);
      v26 = v37 ^ __ROR4__(v38 + v280, 25);
      v22 = v30 ^ __ROR4__(v264 + v40, 23);
      v20 = v32 ^ __ROR4__(v256 + v41, 23);
      v21 = v31 ^ __ROR4__(v26 + v38, 23);
      v288 = v34 ^ __ROR4__(v248 + v39, 23);
      v23 = v280 ^ __ROR4__(v21 + v26, 19);
      v27 = v227 ^ __ROR4__(v20 + v256, 19);
      v25 = v238 ^ __ROR4__(v22 + v264, 19);
      v19 = v272 ^ __ROR4__(v288 + v248, 19);
      v28 = v38 ^ __ROR4__(v23 + v21, 14);
      v296 = v41 ^ __ROR4__(v27 + v20, 14);
      v24 = v40 ^ __ROR4__(v25 + v22, 14);
      v18 = v39 ^ __ROR4__(v19 + v288, 14);
    }
    while ( !v29 );
    v320 = v28 + v319;
    v326 = v26 + v325;
    v332 = v21 + v331;
    v338 = v23 + v337;
    v344 = v27 + v343;
    v350 = v296 + v349;
    v356 = v256 + v355;
    v362 = v20 + v361;
    v380 = v24 + v379;
    v368 = v22 + v367;
    v374 = v25 + v373;
    v386 = v264 + v385;
    v392 = v248 + v391;
    v398 = v288 + v397;
    v404 = v19 + v403;
    v410 = v18 + v409;
    v415 = v326 ^ v414;
    v421 = v332 ^ v420;
    v427 = v338 ^ v426;
    v433 = v344 ^ v432;
    v504 = v320 ^ v312;
    v439 = v350 ^ v438;
    v447 = v356 ^ v446;
    v453 = v362 ^ v452;
    v461 = v368 ^ v460;
    v467 = v374 ^ v466;
    v473 = v380 ^ v472;
    v493 = v404 ^ v492;
    v42 = v493;
    v257 = v415;
    v313 = 4;
    v483 = v392 ^ v482;
    v497 = v410 ^ v496;
    v43 = v398 ^ v486;
    v477 = v386 ^ v476;
    v487 = v398 ^ v486;
    v265 = v477;
    v281 = v473;
    v44 = v453;
    v45 = v421;
    v46 = v461;
    v47 = v497;
    v48 = v447;
    v49 = v467;
    v273 = v439;
    v50 = v433;
    v51 = v483;
    src[0] = v320;
    v305 = v427;
    v52 = v504;
    src[1] = v326;
    src[2] = v332;
    src[3] = v338;
    src[4] = v344;
    src[5] = v350;
    src[6] = v356;
    src[7] = v362;
    src[8] = v368;
    src[9] = v374;
    src[10] = v380;
    src[11] = v386;
    src[12] = v392;
    src[13] = v398;
    src[14] = v404;
    src[15] = v410;
    do
    {
      v249 = v50 ^ __ROR4__(v51 + v52, 25);
      v239 = v42 ^ __ROR4__(v48 + v281, 25);
      v29 = v313-- == 1;
      v53 = v305 ^ __ROR4__(v265 + v47, 25);
      v228 = v49 ^ __ROR4__(v257 + v273, 25);
      v54 = v44 ^ __ROR4__(v53 + v47, 23);
      v55 = v46 ^ __ROR4__(v249 + v52, 23);
      v56 = v45 ^ __ROR4__(v239 + v281, 23);
      v57 = v43 ^ __ROR4__(v228 + v273, 23);
      v58 = v51 ^ __ROR4__(v55 + v249, 19);
      v59 = v265 ^ __ROR4__(v54 + v53, 19);
      v60 = v48 ^ __ROR4__(v56 + v239, 19);
      v61 = v257 ^ __ROR4__(v57 + v228, 19);
      v297 = v47 ^ __ROR4__(v59 + v54, 14);
      v62 = v281 ^ __ROR4__(v60 + v56, 14);
      v289 = v52 ^ __ROR4__(v58 + v55, 14);
      v63 = v273 ^ __ROR4__(v61 + v57, 14);
      v51 = v58 ^ __ROR4__(v297 + v239, 25);
      v265 = v59 ^ __ROR4__(v62 + v228, 25);
      v48 = v60 ^ __ROR4__(v63 + v249, 25);
      v257 = v61 ^ __ROR4__(v289 + v53, 25);
      v46 = v55 ^ __ROR4__(v265 + v62, 23);
      v44 = v54 ^ __ROR4__(v48 + v63, 23);
      v45 = v56 ^ __ROR4__(v257 + v289, 23);
      v43 = v57 ^ __ROR4__(v51 + v297, 23);
      v305 = v53 ^ __ROR4__(v45 + v257, 19);
      v42 = v239 ^ __ROR4__(v43 + v51, 19);
      v50 = v249 ^ __ROR4__(v44 + v48, 19);
      v49 = v228 ^ __ROR4__(v46 + v265, 19);
      v52 = v289 ^ __ROR4__(v305 + v45, 14);
      v273 = v63 ^ __ROR4__(v50 + v44, 14);
      v281 = v62 ^ __ROR4__(v49 + v46, 14);
      v47 = v297 ^ __ROR4__(v42 + v43, 14);
    }
    while ( !v29 );
    v314 = v52 + v504;
    v416 = v257 + v415;
    v428 = v305 + v427;
    v434 = v50 + v433;
    v422 = v45 + v421;
    v454 = v44 + v453;
    v440 = v273 + v439;
    v448 = v48 + v447;
    v468 = v49 + v467;
    v488 = v43 + v487;
    v462 = v46 + v461;
    v474 = v281 + v473;
    v478 = v265 + v477;
    v484 = v51 + v483;
    v494 = v42 + v493;
    v498 = v47 + v497;
    src[16] = v52 + v504;
    src[17] = v416;
    src[18] = v422;
    src[19] = v428;
    src[20] = v434;
    src[21] = v440;
    src[22] = v448;
    src[23] = v454;
    src[24] = v462;
    src[25] = v468;
    src[26] = v474;
    src[27] = v478;
    src[28] = v484;
    src[29] = v488;
    src[30] = v494;
    src[31] = v498;
    memcpy(dest + 128, src, 0x80u);
    v321 = (v52 + v504) ^ v320;
    v327 = v416 ^ v326;
    v333 = v422 ^ v332;
    v339 = v428 ^ v338;
    v345 = v434 ^ v344;
    v351 = v440 ^ v350;
    v357 = v448 ^ v356;
    v363 = v454 ^ v362;
    v369 = v462 ^ v368;
    v375 = v468 ^ v374;
    v381 = v474 ^ v380;
    v387 = v478 ^ v386;
    v393 = v484 ^ v392;
    v399 = v488 ^ v398;
    v405 = v494 ^ v404;
    v64 = v405;
    v290 = v399;
    v258 = v357;
    v65 = v363;
    v66 = v333;
    v67 = v369;
    v68 = v339;
    v69 = v381;
    v70 = v375;
    v71 = v327;
    v72 = v345;
    v73 = v321;
    v411 = v498 ^ v410;
    v266 = v387;
    v74 = v411;
    v298 = v351;
    v250 = v393;
    v306 = 4;
    do
    {
      v229 = v72 ^ __ROR4__(v250 + v73, 25);
      v274 = v64 ^ __ROR4__(v258 + v69, 25);
      v29 = v306-- == 1;
      v240 = v70 ^ __ROR4__(v71 + v298, 25);
      v282 = v68 ^ __ROR4__(v266 + v74, 25);
      v75 = v67 ^ __ROR4__(v229 + v73, 23);
      v76 = v66 ^ __ROR4__(v274 + v69, 23);
      v77 = v65 ^ __ROR4__(v282 + v74, 23);
      v78 = v250 ^ __ROR4__(v75 + v229, 19);
      v79 = v290 ^ __ROR4__(v240 + v298, 23);
      v80 = v266 ^ __ROR4__(v77 + v282, 19);
      v81 = v258 ^ __ROR4__(v76 + v274, 19);
      v82 = v71 ^ __ROR4__(v79 + v240, 19);
      v83 = v73 ^ __ROR4__(v78 + v75, 14);
      v84 = v74 ^ __ROR4__(v80 + v77, 14);
      v85 = v69 ^ __ROR4__(v81 + v76, 14);
      v86 = v298 ^ __ROR4__(v82 + v79, 14);
      v250 = v78 ^ __ROR4__(v84 + v274, 25);
      v266 = v80 ^ __ROR4__(v85 + v240, 25);
      v258 = v81 ^ __ROR4__(v86 + v229, 25);
      v71 = v82 ^ __ROR4__(v83 + v282, 25);
      v67 = v75 ^ __ROR4__(v266 + v85, 23);
      v65 = v77 ^ __ROR4__(v258 + v86, 23);
      v66 = v76 ^ __ROR4__(v71 + v83, 23);
      v290 = v79 ^ __ROR4__(v250 + v84, 23);
      v68 = v282 ^ __ROR4__(v66 + v71, 19);
      v72 = v229 ^ __ROR4__(v65 + v258, 19);
      v70 = v240 ^ __ROR4__(v67 + v266, 19);
      v64 = v274 ^ __ROR4__(v290 + v250, 19);
      v73 = v83 ^ __ROR4__(v68 + v66, 14);
      v298 = v86 ^ __ROR4__(v72 + v65, 14);
      v69 = v85 ^ __ROR4__(v70 + v67, 14);
      v74 = v84 ^ __ROR4__(v64 + v290, 14);
    }
    while ( !v29 );
    v318 = v73 + v321;
    v324 = v71 + v327;
    v330 = v66 + v333;
    v336 = v68 + v339;
    v342 = v72 + v345;
    v348 = v298 + v351;
    v354 = v258 + v357;
    v360 = v65 + v363;
    v378 = v69 + v381;
    v366 = v67 + v369;
    v372 = v70 + v375;
    v384 = v266 + v387;
    v390 = v250 + v393;
    v396 = v290 + v399;
    v402 = v64 + v405;
    v408 = v74 + v411;
    v417 = v324 ^ v416;
    v423 = v330 ^ v422;
    v429 = v336 ^ v428;
    v435 = v342 ^ v434;
    v315 = v318 ^ v314;
    v441 = v348 ^ v440;
    v449 = v354 ^ v448;
    v455 = v360 ^ v454;
    v463 = v366 ^ v462;
    v469 = v372 ^ v468;
    v475 = v378 ^ v474;
    v485 = v390 ^ v484;
    v495 = v402 ^ v494;
    v499 = v408 ^ v498;
    v87 = v396 ^ v488;
    v479 = v384 ^ v478;
    v489 = v396 ^ v488;
    v267 = v449;
    v291 = v475;
    v259 = v417;
    v88 = v455;
    v89 = v423;
    v90 = v463;
    v91 = v429;
    v92 = v499;
    v93 = v469;
    v283 = v441;
    v94 = v435;
    v307 = 4;
    v251 = v485;
    v95 = v479;
    src[0] = v318;
    src[1] = v324;
    src[2] = v330;
    src[3] = v336;
    src[4] = v342;
    src[5] = v348;
    src[6] = v354;
    src[7] = v360;
    src[8] = v366;
    src[9] = v372;
    src[10] = v378;
    src[11] = v384;
    src[12] = v390;
    src[13] = v396;
    src[14] = v402;
    src[15] = v408;
    v241 = v495;
    v96 = v315;
    do
    {
      v230 = v94 ^ __ROR4__(v251 + v96, 25);
      v29 = v307-- == 1;
      v97 = v91 ^ __ROR4__(v95 + v92, 25);
      v275 = v241 ^ __ROR4__(v267 + v291, 25);
      v242 = v93 ^ __ROR4__(v259 + v283, 25);
      v98 = v90 ^ __ROR4__(v230 + v96, 23);
      v99 = v88 ^ __ROR4__(v97 + v92, 23);
      v100 = v89 ^ __ROR4__(v275 + v291, 23);
      v101 = v87 ^ __ROR4__(v242 + v283, 23);
      v102 = v251 ^ __ROR4__(v98 + v230, 19);
      v103 = v95 ^ __ROR4__(v99 + v97, 19);
      v104 = v267 ^ __ROR4__(v100 + v275, 19);
      v105 = v259 ^ __ROR4__(v101 + v242, 19);
      v106 = v96 ^ __ROR4__(v102 + v98, 14);
      v299 = v92 ^ __ROR4__(v103 + v99, 14);
      v107 = v291 ^ __ROR4__(v104 + v100, 14);
      v108 = v283 ^ __ROR4__(v105 + v101, 14);
      v95 = v103 ^ __ROR4__(v107 + v242, 25);
      v251 = v102 ^ __ROR4__(v299 + v275, 25);
      v267 = v104 ^ __ROR4__(v108 + v230, 25);
      v259 = v105 ^ __ROR4__(v106 + v97, 25);
      v90 = v98 ^ __ROR4__(v95 + v107, 23);
      v88 = v99 ^ __ROR4__(v267 + v108, 23);
      v89 = v100 ^ __ROR4__(v259 + v106, 23);
      v87 = v101 ^ __ROR4__(v251 + v299, 23);
      v91 = v97 ^ __ROR4__(v89 + v259, 19);
      v94 = v230 ^ __ROR4__(v88 + v267, 19);
      v93 = v242 ^ __ROR4__(v90 + v95, 19);
      v241 = v275 ^ __ROR4__(v87 + v251, 19);
      v96 = v106 ^ __ROR4__(v91 + v89, 14);
      v291 = v107 ^ __ROR4__(v93 + v90, 14);
      v283 = v108 ^ __ROR4__(v94 + v88, 14);
      v92 = v299 ^ __ROR4__(v241 + v87, 14);
    }
    while ( !v29 );
    v312 = v96 + v315;
    dest += 256;
    src[16] = v312;
    v420 = v89 + v423;
    v414 = v259 + v417;
    src[17] = v414;
    src[18] = v420;
    v426 = v91 + v429;
    src[19] = v426;
    v438 = v283 + v441;
    src[21] = v438;
    v432 = v94 + v435;
    src[20] = v432;
    v452 = v88 + v455;
    v446 = v267 + v449;
    src[22] = v446;
    v460 = v90 + v463;
    v466 = v93 + v469;
    src[23] = v452;
    v476 = v95 + v479;
    src[27] = v476;
    src[24] = v460;
    v472 = v291 + v475;
    src[25] = v466;
    src[26] = v472;
    v482 = v251 + v485;
    v486 = v87 + v489;
    src[28] = v482;
    v492 = v241 + v495;
    src[29] = v486;
    v496 = v92 + v499;
    src[30] = v492;
    src[31] = v496;
  }
  while ( dest != v506 );
  v109 = v312;
  desta = 512;
  do
  {
    v110 = src;
    v111 = (int)&v505[128 * (v109 & 0x3FF) - 8];
    do
    {
      v112 = *(_QWORD *)(v111 + 8);
      v111 += 8;
      *(_QWORD *)v110 ^= v112;
      v110 += 2;
    }
    while ( v110 != (int *)&v558 );
    v346 = src[18] ^ src[2];
    v334 = src[17] ^ src[1];
    v322 = src[16] ^ src[0];
    v370 = src[20] ^ src[4];
    v358 = src[19] ^ src[3];
    v308 = 4;
    v260 = src[17] ^ src[1];
    v382 = src[21] ^ src[5];
    v113 = src[18] ^ src[2];
    v114 = src[19] ^ src[3];
    v394 = src[22] ^ src[6];
    v406 = src[23] ^ src[7];
    v418 = src[24] ^ src[8];
    v442 = src[26] ^ src[10];
    v268 = src[22] ^ src[6];
    v456 = src[27] ^ src[11];
    v284 = src[21] ^ src[5];
    v115 = src[25] ^ src[9];
    v116 = src[23] ^ src[7];
    v117 = src[24] ^ src[8];
    v292 = src[26] ^ src[10];
    v470 = src[28] ^ src[12];
    v480 = src[29] ^ src[13];
    v118 = src[30] ^ src[14];
    v119 = src[29] ^ src[13];
    v120 = src[31] ^ src[15];
    v252 = src[28] ^ src[12];
    v121 = src[27] ^ src[11];
    v231 = src[20] ^ src[4];
    v122 = src[16] ^ src[0];
    v490 = src[30] ^ src[14];
    v500 = src[31] ^ src[15];
    do
    {
      v29 = v308-- == 1;
      v123 = v114 ^ __ROR4__(v121 + v120, 25);
      v232 = v231 ^ __ROR4__(v252 + v122, 25);
      v276 = v118 ^ __ROR4__(v268 + v292, 25);
      v243 = v115 ^ __ROR4__(v260 + v284, 25);
      v124 = v117 ^ __ROR4__(v232 + v122, 23);
      v125 = v116 ^ __ROR4__(v123 + v120, 23);
      v126 = v119 ^ __ROR4__(v243 + v284, 23);
      v127 = v113 ^ __ROR4__(v276 + v292, 23);
      v128 = v252 ^ __ROR4__(v124 + v232, 19);
      v129 = v121 ^ __ROR4__(v125 + v123, 19);
      v130 = v268 ^ __ROR4__(v127 + v276, 19);
      v131 = v260 ^ __ROR4__(v126 + v243, 19);
      v300 = v120 ^ __ROR4__(v129 + v125, 14);
      v132 = v122 ^ __ROR4__(v128 + v124, 14);
      v133 = v292 ^ __ROR4__(v130 + v127, 14);
      v134 = v284 ^ __ROR4__(v131 + v126, 14);
      v121 = v129 ^ __ROR4__(v133 + v243, 25);
      v252 = v128 ^ __ROR4__(v300 + v276, 25);
      v268 = v130 ^ __ROR4__(v134 + v232, 25);
      v260 = v131 ^ __ROR4__(v132 + v123, 25);
      v117 = v124 ^ __ROR4__(v121 + v133, 23);
      v116 = v125 ^ __ROR4__(v268 + v134, 23);
      v113 = v127 ^ __ROR4__(v260 + v132, 23);
      v119 = v126 ^ __ROR4__(v252 + v300, 23);
      v114 = v123 ^ __ROR4__(v113 + v260, 19);
      v231 = v232 ^ __ROR4__(v116 + v268, 19);
      v115 = v243 ^ __ROR4__(v117 + v121, 19);
      v118 = v276 ^ __ROR4__(v119 + v252, 19);
      v122 = v132 ^ __ROR4__(v114 + v113, 14);
      v135 = v134 ^ __ROR4__(v231 + v116, 14);
      v284 = v135;
      v120 = v300 ^ __ROR4__(v118 + v119, 14);
      v292 = v133 ^ __ROR4__(v115 + v117, 14);
    }
    while ( !v29 );
    src[0] = v122 + v322;
    v136 = v260 + v334;
    src[4] = v231 + v370;
    src[5] = v135 + v382;
    src[6] = v268 + v394;
    src[7] = v116 + v406;
    v137 = v115 + (src[25] ^ src[9]);
    src[10] = v292 + v442;
    src[12] = v252 + v470;
    src[13] = v119 + v480;
    src[8] = v117 + v418;
    src[11] = v121 + v456;
    src[14] = v118 + v490;
    src[15] = v120 + v500;
    v316 = (v122 + v322) ^ src[16];
    v328 = (v260 + v334) ^ src[17];
    v340 = (v113 + v346) ^ src[18];
    v352 = (v114 + v358) ^ src[19];
    v364 = (v231 + v370) ^ src[20];
    v376 = (v135 + v382) ^ src[21];
    v388 = (v268 + v394) ^ src[22];
    v400 = (v116 + v406) ^ src[23];
    v412 = (v117 + v418) ^ src[24];
    v424 = v137 ^ src[25];
    v430 = (v292 + v442) ^ src[26];
    v436 = (v121 + v456) ^ src[27];
    v443 = (v252 + v470) ^ src[28];
    v457 = (v118 + v490) ^ src[30];
    v253 = v436;
    v138 = (v120 + v500) ^ src[31];
    v139 = (v119 + v480) ^ src[29];
    v464 = v138;
    v269 = v388;
    v293 = v430;
    v450 = v139;
    v261 = v328;
    v285 = v376;
    src[3] = v114 + v358;
    v140 = v340;
    v141 = v412;
    v142 = v352;
    v143 = v137 ^ src[25];
    v144 = v364;
    v145 = v443;
    v309 = 4;
    src[1] = v136;
    src[2] = v113 + v346;
    src[9] = v137;
    v244 = v457;
    v146 = v400;
    v147 = v316;
    do
    {
      v233 = v144 ^ __ROR4__(v145 + v147, 25);
      v29 = v309-- == 1;
      v148 = v142 ^ __ROR4__(v253 + v138, 25);
      v277 = v244 ^ __ROR4__(v269 + v293, 25);
      v149 = v146 ^ __ROR4__(v148 + v138, 23);
      v245 = v143 ^ __ROR4__(v261 + v285, 25);
      v150 = v141 ^ __ROR4__(v233 + v147, 23);
      v151 = v140 ^ __ROR4__(v277 + v293, 23);
      v152 = v139 ^ __ROR4__(v245 + v285, 23);
      v153 = v145 ^ __ROR4__(v150 + v233, 19);
      v154 = v253 ^ __ROR4__(v149 + v148, 19);
      v155 = v261 ^ __ROR4__(v152 + v245, 19);
      v156 = v269 ^ __ROR4__(v151 + v277, 19);
      v301 = v138 ^ __ROR4__(v154 + v149, 14);
      v157 = v147 ^ __ROR4__(v153 + v150, 14);
      v158 = v293 ^ __ROR4__(v156 + v151, 14);
      v159 = v285 ^ __ROR4__(v155 + v152, 14);
      v145 = v153 ^ __ROR4__(v301 + v277, 25);
      v253 = v154 ^ __ROR4__(v158 + v245, 25);
      v261 = v155 ^ __ROR4__(v157 + v148, 25);
      v269 = v156 ^ __ROR4__(v159 + v233, 25);
      v141 = v150 ^ __ROR4__(v253 + v158, 23);
      v146 = v149 ^ __ROR4__(v269 + v159, 23);
      v140 = v151 ^ __ROR4__(v261 + v157, 23);
      v139 = v152 ^ __ROR4__(v145 + v301, 23);
      v142 = v148 ^ __ROR4__(v140 + v261, 19);
      v144 = v233 ^ __ROR4__(v146 + v269, 19);
      v143 = v245 ^ __ROR4__(v141 + v253, 19);
      v244 = v277 ^ __ROR4__(v139 + v145, 19);
      v147 = v157 ^ __ROR4__(v142 + v140, 14);
      v293 = v158 ^ __ROR4__(v143 + v141, 14);
      v285 = v159 ^ __ROR4__(v144 + v146, 14);
      v138 = v301 ^ __ROR4__(v244 + v139, 14);
    }
    while ( !v29 );
    v234 = v146;
    src[16] = v147 + v316;
    src[17] = v261 + v328;
    v160 = src;
    src[18] = v140 + v340;
    src[19] = v142 + v352;
    v161 = (int)&v505[128 * ((v147 + v316) & 0x3FF) - 8];
    src[20] = v144 + v364;
    src[21] = v285 + v376;
    src[22] = v269 + v388;
    src[23] = v234 + v400;
    src[24] = v141 + v412;
    src[25] = v143 + v424;
    src[26] = v293 + v430;
    src[27] = v253 + v436;
    src[28] = v145 + v443;
    src[29] = v139 + v450;
    src[30] = v244 + v457;
    src[31] = v138 + v464;
    do
    {
      v162 = *(_QWORD *)(v161 + 8);
      v161 += 8;
      *(_QWORD *)v160 ^= v162;
      v160 += 2;
    }
    while ( v160 != (int *)&v558 );
    v335 = src[17] ^ src[1];
    v323 = src[16] ^ src[0];
    v371 = src[20] ^ src[4];
    v310 = 4;
    v262 = src[17] ^ src[1];
    v163 = src[19] ^ src[3];
    v359 = src[19] ^ src[3];
    v383 = src[21] ^ src[5];
    v347 = src[18] ^ src[2];
    v395 = src[22] ^ src[6];
    v407 = src[23] ^ src[7];
    v419 = src[24] ^ src[8];
    v444 = src[26] ^ src[10];
    v286 = src[21] ^ src[5];
    v270 = src[22] ^ src[6];
    v458 = src[27] ^ src[11];
    v164 = src[25] ^ src[9];
    v294 = src[26] ^ src[10];
    v165 = src[23] ^ src[7];
    v166 = src[24] ^ src[8];
    v471 = src[28] ^ src[12];
    v481 = src[29] ^ src[13];
    v167 = src[28] ^ src[12];
    v168 = src[29] ^ src[13];
    v169 = src[30] ^ src[14];
    v254 = src[27] ^ src[11];
    v170 = src[31] ^ src[15];
    v235 = src[20] ^ src[4];
    v171 = src[18] ^ src[2];
    v172 = src[16] ^ src[0];
    v491 = src[30] ^ src[14];
    v501 = src[31] ^ src[15];
    do
    {
      v278 = v169 ^ __ROR4__(v294 + v270, 25);
      v29 = v310-- == 1;
      v173 = v163 ^ __ROR4__(v170 + v254, 25);
      v236 = v235 ^ __ROR4__(v172 + v167, 25);
      v246 = v164 ^ __ROR4__(v286 + v262, 25);
      v174 = v166 ^ __ROR4__(v236 + v172, 23);
      v175 = v165 ^ __ROR4__(v173 + v170, 23);
      v176 = v171 ^ __ROR4__(v278 + v294, 23);
      v177 = v168 ^ __ROR4__(v246 + v286, 23);
      v178 = v254 ^ __ROR4__(v175 + v173, 19);
      v179 = v167 ^ __ROR4__(v174 + v236, 19);
      v180 = v270 ^ __ROR4__(v176 + v278, 19);
      v181 = v262 ^ __ROR4__(v177 + v246, 19);
      v302 = v170 ^ __ROR4__(v178 + v175, 14);
      v182 = v172 ^ __ROR4__(v179 + v174, 14);
      v183 = v294 ^ __ROR4__(v180 + v176, 14);
      v184 = v286 ^ __ROR4__(v181 + v177, 14);
      v167 = v179 ^ __ROR4__(v302 + v278, 25);
      v254 = v178 ^ __ROR4__(v183 + v246, 25);
      v262 = v181 ^ __ROR4__(v182 + v173, 25);
      v270 = v180 ^ __ROR4__(v184 + v236, 25);
      v165 = v175 ^ __ROR4__(v270 + v184, 23);
      v166 = v174 ^ __ROR4__(v254 + v183, 23);
      v171 = v176 ^ __ROR4__(v262 + v182, 23);
      v168 = v177 ^ __ROR4__(v167 + v302, 23);
      v163 = v173 ^ __ROR4__(v171 + v262, 19);
      v235 = v236 ^ __ROR4__(v165 + v270, 19);
      v164 = v246 ^ __ROR4__(v166 + v254, 19);
      v169 = v278 ^ __ROR4__(v168 + v167, 19);
      v172 = v182 ^ __ROR4__(v163 + v171, 14);
      v185 = v184 ^ __ROR4__(v235 + v165, 14);
      v286 = v185;
      v170 = v302 ^ __ROR4__(v169 + v168, 14);
      v294 = v183 ^ __ROR4__(v164 + v166, 14);
    }
    while ( !v29 );
    src[0] = v172 + v323;
    v186 = v262 + v335;
    v187 = v171 + v347;
    src[3] = v163 + v359;
    src[4] = v235 + v371;
    src[5] = v185 + v383;
    src[7] = v165 + v407;
    v188 = v164 + (src[25] ^ src[9]);
    src[6] = v270 + v395;
    src[10] = v294 + v444;
    src[12] = v167 + v471;
    src[8] = v166 + v419;
    src[11] = v254 + v458;
    src[13] = v168 + v481;
    src[14] = v169 + v491;
    src[15] = v170 + v501;
    v317 = (v172 + v323) ^ src[16];
    v329 = (v262 + v335) ^ src[17];
    v341 = (v171 + v347) ^ src[18];
    v353 = (v163 + v359) ^ src[19];
    v365 = (v235 + v371) ^ src[20];
    v377 = (v185 + v383) ^ src[21];
    v389 = (v270 + v395) ^ src[22];
    v401 = (v165 + v407) ^ src[23];
    v413 = (v166 + v419) ^ src[24];
    v425 = v188 ^ src[25];
    v431 = (v294 + v444) ^ src[26];
    v437 = (v254 + v458) ^ src[27];
    v445 = (v167 + v471) ^ src[28];
    v451 = (v168 + v481) ^ src[29];
    v189 = v437;
    v263 = v389;
    v459 = (v169 + v491) ^ src[30];
    v271 = v329;
    v287 = v377;
    v465 = (v170 + v501) ^ src[31];
    v295 = v317;
    src[2] = v187;
    v190 = v459;
    v191 = v401;
    v192 = v341;
    v193 = v413;
    v194 = v353;
    v195 = v465;
    v196 = v188 ^ src[25];
    v197 = v365;
    v311 = 4;
    src[1] = v186;
    src[9] = v188;
    v255 = v445;
    v198 = v431;
    v199 = v451;
    do
    {
      v237 = v197 ^ __ROR4__(v295 + v255, 25);
      v279 = v190 ^ __ROR4__(v198 + v263, 25);
      v200 = v194 ^ __ROR4__(v195 + v189, 25);
      v29 = v311-- == 1;
      v201 = v191 ^ __ROR4__(v200 + v195, 23);
      v202 = v193 ^ __ROR4__(v237 + v295, 23);
      v247 = v196 ^ __ROR4__(v287 + v271, 25);
      v203 = v192 ^ __ROR4__(v279 + v198, 23);
      v204 = v199 ^ __ROR4__(v247 + v287, 23);
      v205 = v189 ^ __ROR4__(v201 + v200, 19);
      v206 = v255 ^ __ROR4__(v202 + v237, 19);
      v207 = v263 ^ __ROR4__(v203 + v279, 19);
      v208 = v271 ^ __ROR4__(v204 + v247, 19);
      v209 = v295 ^ __ROR4__(v206 + v202, 14);
      v303 = v195 ^ __ROR4__(v205 + v201, 14);
      v210 = v198 ^ __ROR4__(v207 + v203, 14);
      v211 = v287 ^ __ROR4__(v208 + v204, 14);
      v189 = v205 ^ __ROR4__(v210 + v247, 25);
      v255 = v206 ^ __ROR4__(v303 + v279, 25);
      v212 = v208 ^ __ROR4__(v209 + v200, 25);
      v263 = v207 ^ __ROR4__(v211 + v237, 25);
      v191 = v201 ^ __ROR4__(v263 + v211, 23);
      v192 = v203 ^ __ROR4__(v212 + v209, 23);
      v193 = v202 ^ __ROR4__(v189 + v210, 23);
      v271 = v212;
      v199 = v204 ^ __ROR4__(v255 + v303, 23);
      v194 = v200 ^ __ROR4__(v192 + v212, 19);
      v196 = v247 ^ __ROR4__(v193 + v189, 19);
      v197 = v237 ^ __ROR4__(v191 + v263, 19);
      v190 = v279 ^ __ROR4__(v199 + v255, 19);
      v295 = v209 ^ __ROR4__(v194 + v192, 14);
      v287 = v211 ^ __ROR4__(v197 + v191, 14);
      v198 = v210 ^ __ROR4__(v196 + v193, 14);
      v195 = v303 ^ __ROR4__(v190 + v199, 14);
    }
    while ( !v29 );
    v29 = desta-- == 1;
    v109 = v295 + v317;
    src[17] = v271 + v329;
    src[18] = v192 + v341;
    src[19] = v194 + v353;
    src[20] = v197 + v365;
    src[21] = v287 + v377;
    src[23] = v191 + v401;
    src[22] = v263 + v389;
    src[24] = v193 + v413;
    src[25] = v196 + v425;
    src[26] = v198 + v431;
    src[16] = v295 + v317;
    src[27] = v189 + v437;
    src[29] = v199 + v451;
    src[28] = v255 + v445;
    src[30] = v190 + v459;
    src[31] = v195 + v465;
  }
  while ( !v29 );
  v529 = 1779033703;
  v530 = -1150833019;
  v531 = 1013904242;
  v532 = -1521486534;
  v533 = 1359893119;
  v534 = -1694144372;
  v535 = 528734635;
  v536 = 1541459225;
  sub_F840(&v529, a1, 1);
  v213 = v509[1];
  v214 = v509[2];
  v215 = v509[3];
  v548 = *v509;
  v549 = v213;
  v550 = v214;
  v551 = v215;
  v552 = 128;
  v553 = 0;
  v554 = 0;
  v555 = 0;
  memset(v556, 0, 28);
  v556[7] = -2147352576;
  sub_F840(&v529, &v548, 1);
  v216 = v529;
  v217 = v530;
  v218 = v531;
  v219 = v532;
  a3[6] = 528734635;
  v538 = v216;
  v539 = v217;
  v540 = v218;
  v541 = v219;
  v220 = v533;
  v221 = v534;
  v222 = v535;
  v223 = v536;
  *a3 = 1779033703;
  a3[1] = -1150833019;
  a3[2] = 1013904242;
  a3[3] = -1521486534;
  a3[4] = 1359893119;
  a3[5] = -1694144372;
  a3[7] = 1541459225;
  v224 = desta;
  v542 = v220;
  v543 = v221;
  v544 = v222;
  v545 = v223;
  do
  {
    *(int *)((char *)&v548 + v224) = *(int *)((char *)&v538 + v224) ^ 0x5C5C5C5C;
    v224 += 4;
  }
  while ( v224 != 32 );
  memset(v556, 92, 32);
  sub_F840(a3, &v548, 0);
  v225 = 0;
  v529 = 1779033703;
  v530 = -1150833019;
  v531 = 1013904242;
  v532 = -1521486534;
  v533 = 1359893119;
  v534 = -1694144372;
  v535 = 528734635;
  v536 = 1541459225;
  do
  {
    *(int *)((char *)&v548 + v225) = *(int *)((char *)&v538 + v225) ^ 0x36363636;
    v225 += 4;
  }
  while ( v225 != 32 );
  memset(v556, 54, 32);
  sub_F840(&v529, &v548, 0);
  sub_F840(&v529, src, 1);
  sub_F840(&v529, &src[16], 1);
  sub_F840(&v529, dword_49EC4, 0);
  v548 = v529;
  v549 = v530;
  v550 = v531;
  v551 = v532;
  v552 = v533;
  v553 = v534;
  v554 = v535;
  v555 = v536;
  v556[0] = 0x80000000;
  memset(&v556[1], 0, 24);
  v556[7] = 768;
  return sub_F840(a3, &v548, 0);
}
// 49EC4: using guessed type int dword_49EC4[16];

//----- (00014990) --------------------------------------------------------
const char *__fastcall sub_14990(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_63B9C, &dword_63B98) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( dword_63B9C > 23 || dword_63B98 > 59 || dword_63B9C < 0 || dword_63B98 < 0 )
    return "Invalid time set.";
  byte_63B90 = 1;
  return 0;
}
// 63B90: using guessed type char byte_63B90;
// 63B98: using guessed type int dword_63B98;
// 63B9C: using guessed type int dword_63B9C;

//----- (00014A0C) --------------------------------------------------------
const char *__fastcall sub_14A0C(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_63E20, &dword_63E1C) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( dword_63E20 > 23 || dword_63E1C > 59 || dword_63E20 < 0 || dword_63E1C < 0 )
    return "Invalid time set.";
  byte_63E14 = 1;
  return 0;
}
// 63E14: using guessed type char byte_63E14;
// 63E1C: using guessed type int dword_63E1C;
// 63E20: using guessed type int dword_63E20;

//----- (00014A88) --------------------------------------------------------
int __fastcall sub_14A88(int a1)
{
  int i; // r1
  int result; // r0
  unsigned int *v4; // r2
  int v5[20]; // [sp+0h] [bp-20250h] BYREF
  _DWORD v6[32748]; // [sp+50h] [bp-20200h] BYREF

  v6[0] = 0;
  memset(&v6[1], 0, (size_t)&loc_201FC);
  for ( i = 0; i != 19; ++i )
    v5[i] = bswap32(*(_DWORD *)(a1 + i * 4));
  v5[19] = bswap32(*(_DWORD *)(a1 + 76));
  result = sub_11E40(v5, (int)v6, (int *)(a1 + 192));
  v4 = (unsigned int *)(a1 + 192);
  do
  {
    *v4 = bswap32(*v4);
    ++v4;
  }
  while ( v4 != (unsigned int *)(a1 + 224) );
  return result;
}

//----- (00014B28) --------------------------------------------------------
int __fastcall sub_14B28(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // r5
  int i; // r1
  unsigned int v5; // r4
  _BYTE v7[131592]; // [sp+8h] [bp-20A84h] BYREF
  int v8[8]; // [sp+20210h] [bp-87Ch] BYREF
  int v9[20]; // [sp+20230h] [bp-85Ch] BYREF
  char v10[12]; // [sp+20280h] [bp-80Ch] BYREF

  v3 = *(_DWORD *)(a2 + 28);
  for ( i = 0; i != 19; ++i )
    v9[i] = bswap32(*(_DWORD *)(a1 + i * 4));
  v9[19] = bswap32(a3);
  sub_11E40(v9, (int)v7, v8);
  v5 = bswap32(v8[7]);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v10, 0x800u, "htarget %08lx diff1 %08lx hash %08lx", v3, 0xFFFF, v5);
    sub_38438(7, v10, 0);
  }
  if ( v5 >= 0x10000 )
    return -1;
  else
    return v3 >= v5;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00014D9C) --------------------------------------------------------
int __fastcall sub_14D9C(char *a1, size_t a2, time_t *a3)
{
  struct tm *v5; // r0
  time_t v7; // [sp+1Ch] [bp-8h] BYREF

  v7 = *a3;
  v5 = localtime(&v7);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d]",
           v5->tm_year + 1900,
           v5->tm_mon + 1,
           v5->tm_mday,
           v5->tm_hour,
           v5->tm_min,
           v5->tm_sec);
}

//----- (00014E18) --------------------------------------------------------
void sub_14E18()
{
  int v0; // r7
  unsigned int v1; // r4
  int v2; // r8
  int *v3; // r6
  int *v4; // r3
  int v5; // t1
  unsigned int v6; // r2
  int v7; // t1
  unsigned int v8; // r5
  int v9; // r8
  int v10; // r6
  int v11; // r10
  _DWORD *v12; // t1
  char v13[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = dword_63740;
  if ( dword_63740 <= 0 )
  {
    v1 = 1;
  }
  else
  {
    v1 = -1;
    v2 = dword_639E0 + 4 * dword_63740;
    v3 = (int *)dword_639E0;
    v4 = (int *)dword_639E0;
    do
    {
      v5 = *v4++;
      v6 = *(_DWORD *)(v5 + 56);
      if ( v6 && v1 >= v6 )
        v1 = v6;
    }
    while ( v4 != (int *)v2 );
    if ( v1 == -1 )
    {
      v1 = 1;
    }
    else
    {
      do
      {
        while ( 1 )
        {
          v7 = *v3++;
          v8 = *(_DWORD *)(v7 + 56);
          if ( v8 )
            break;
          if ( v3 == (int *)v2 )
            goto LABEL_13;
        }
        while ( v8 % v1 )
          --v1;
      }
      while ( v3 != (int *)v2 );
    }
LABEL_13:
    v9 = dword_639E0 - 4;
    v10 = 0;
    v11 = dword_5F890;
    do
    {
      v12 = *(_DWORD **)(v9 + 4);
      v9 += 4;
      ++v10;
      v12[16] = v12[16] * v11 / v1;
      v12[15] = v12[14] / v1;
    }
    while ( v10 < v0 );
  }
  dword_5F890 = v1;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v13, 0x800u, "Global quota greatest common denominator set to %lu", v1);
    sub_38438(7, v13, 0);
  }
}
// 5F890: using guessed type int dword_5F890;
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00014F94) --------------------------------------------------------
char *__fastcall sub_14F94(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0

  result = sub_47B60(a1, a2);
  if ( !result && (*a2 < a3 || *a2 > a4) )
    return "Value out of range";
  return result;
}

//----- (00014FD4) --------------------------------------------------------
char *__fastcall sub_14FD4(const char *a1)
{
  dword_611AC = 2;
  return sub_14F94(a1, &dword_63AF8, 0, 9999);
}
// 611AC: using guessed type int dword_611AC;
// 63AF8: using guessed type int dword_63AF8;

//----- (00015000) --------------------------------------------------------
char *__fastcall sub_15000(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 0, 9999);
}

//----- (0001500C) --------------------------------------------------------
char *__fastcall sub_1500C(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 0, 100);
}

//----- (00015018) --------------------------------------------------------
char *__fastcall sub_15018(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 1, 0xFFFF);
}

//----- (00015024) --------------------------------------------------------
char *__fastcall sub_15024(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 42, 62);
}

//----- (00015030) --------------------------------------------------------
char *__fastcall sub_15030(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 22, 55);
}

//----- (0001503C) --------------------------------------------------------
char *__fastcall sub_1503C(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 32, 63);
}

//----- (00015048) --------------------------------------------------------
char *__fastcall sub_15048(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 0, 4);
}

//----- (00015054) --------------------------------------------------------
char *__fastcall sub_15054(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 0, 200);
}

//----- (00015060) --------------------------------------------------------
char *__fastcall sub_15060(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 0, 255);
}

//----- (0001506C) --------------------------------------------------------
char *__fastcall sub_1506C(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 1, 10);
}

//----- (00015078) --------------------------------------------------------
char *__fastcall sub_15078(const char *a1, _DWORD *a2)
{
  return sub_14F94(a1, a2, 0, 10);
}

//----- (00015084) --------------------------------------------------------
int __fastcall sub_15084(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (000150B4) --------------------------------------------------------
int __fastcall sub_150B4(int a1, char *a2)
{
  char *v5; // r0
  int v6; // r2

  sub_2B358(a1, a2);
  if ( !sub_2B43C(a2, (_DWORD *)(a1 + 592), (char **)(a1 + 576)) || strncasecmp(a2, "stratum+tcp://", 0xEu) )
    return 0;
  v5 = _strdup(a2);
  v6 = *(_DWORD *)(a1 + 592);
  *(_BYTE *)(a1 + 632) = 1;
  *(_DWORD *)(a1 + 568) = v6;
  *(_DWORD *)(a1 + 164) = v5;
  return 1;
}

//----- (00015128) --------------------------------------------------------
const char *__fastcall sub_15128(const char *a1)
{
  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  dword_611B0 = (int)a1;
  return 0;
}
// 611B0: using guessed type int dword_611B0;

//----- (00015180) --------------------------------------------------------
void *__fastcall sub_15180(void **a1)
{
  free(a1[72]);
  free(a1[77]);
  free(a1[82]);
  free(a1[80]);
  return memset(a1, 0, 0x1E0u);
}

//----- (000151BC) --------------------------------------------------------
char *__fastcall sub_151BC(int a1, int a2, int a3)
{
  int v4; // r7
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  char *result; // r0
  unsigned int v11[2]; // [sp+4h] [bp-8h] BYREF

  v4 = *(_DWORD *)(a1 + 340);
  sub_15180((void **)a1);
  memcpy((void *)a1, (const void *)a2, 0x1E0u);
  *(_DWORD *)(a1 + 340) = v4;
  v7 = *(const char **)(a2 + 288);
  if ( v7 )
    *(_DWORD *)(a1 + 288) = _strdup(v7);
  v8 = *(const char **)(a2 + 320);
  if ( v8 )
    *(_DWORD *)(a1 + 320) = _strdup(v8);
  v9 = *(const char **)(a2 + 308);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
      sub_295B8(v11, *(unsigned __int8 **)(a2 + 308), 4);
      v11[0] = bswap32(bswap32(v11[0]) + a3);
      *(_DWORD *)(a1 + 308) = sub_294B8((int)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 308) = _strdup(v9);
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
  }
  result = *(char **)(a2 + 328);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 328) = result;
  }
  return result;
}

//----- (000152B8) --------------------------------------------------------
void __fastcall sub_152B8(void **a1)
{
  sub_15180(a1);
  free(a1);
}

//----- (000152D0) --------------------------------------------------------
int __fastcall sub_152D0(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4

  v4 = (double *)LODWORD(a1);
  if ( v2 > 0.0 )
  {
    a1 = exp(a1);
    *v4 = (*v4 + (1.0 - 1.0 / (v2 / v3)) * (v1 / v2)) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  }
  return LODWORD(a1);
}
// 152EC: variable 'v2' is possibly undefined
// 152F0: variable 'v3' is possibly undefined
// 15304: variable 'v1' is possibly undefined

//----- (00015324) --------------------------------------------------------
void __fastcall sub_15324(int a1)
{
  struct timeval v1; // [sp+0h] [bp-8h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    sub_2B13C(&v1);
    sub_2B314();
  }
}

//----- (00015378) --------------------------------------------------------
void sub_15378()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_2B13C(&v0);
  sub_2B314();
}

//----- (000153A0) --------------------------------------------------------
void sub_153A0()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_2B13C(&v0);
  sub_2B314();
}

//----- (000153C8) --------------------------------------------------------
int __fastcall sub_153C8(const char *a1)
{
  return wprintw((WINDOW *)dword_639D8, "%s", a1);
}
// 639D8: using guessed type int dword_639D8;

//----- (000153E4) --------------------------------------------------------
_BYTE *__fastcall sub_153E4(int a1, unsigned int a2)
{
  _BYTE *result; // r0

  result = *(_BYTE **)(a1 + 308);
  *(_DWORD *)(a1 + 68) = bswap32(a2);
  if ( result )
  {
    free(result);
    result = sub_294B8(a1 + 68, 4);
    *(_DWORD *)(a1 + 308) = result;
  }
  return result;
}

//----- (0001541C) --------------------------------------------------------
__int64 __fastcall sub_1541C(__int64 *a1)
{
  __int64 v2; // r0
  double v3; // d9
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d8
  double v8; // r0
  double v9; // d17
  double v10; // r0
  double v11; // d8
  int v12; // r1
  __int64 v13; // d16

  if ( !a1 )
    return 0;
  v2 = a1[27];
  v3 = 1.7668201e72;
  if ( !byte_63DF9 )
    v3 = 2.69595353e67;
  LODWORD(v4) = sub_493C8(v2);
  v5 = v4 * 6.27710174e57;
  LODWORD(v6) = sub_493C8(a1[26]);
  v7 = v5 + v6 * 3.40282367e38;
  LODWORD(v8) = sub_493C8(a1[25]);
  v9 = v8;
  LODWORD(v10) = sub_493C8(a1[24]);
  v11 = v7 + v9 * 1.84467441e19 + v10;
  if ( v11 == 0.0 )
    return 0;
  LODWORD(v13) = sub_494C0(v3 / v11);
  HIDWORD(v13) = v12;
  return v13;
}
// 15458: variable 'v4' is possibly undefined
// 1546C: variable 'v6' is possibly undefined
// 15478: variable 'v8' is possibly undefined
// 1548C: variable 'v10' is possibly undefined
// 154A8: variable 'v12' is possibly undefined
// 63DF9: using guessed type char byte_63DF9;

//----- (000154EC) --------------------------------------------------------
void __fastcall sub_154EC(int a1)
{
  int v2; // r3
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( *(_BYTE *)(a1 + 273) || *(_DWORD *)(a1 + 240) || *(_BYTE *)(a1 + 272) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(v3, "Discarded cloned or rolled work");
      sub_38438(7, v3, 0);
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 260);
    if ( v2 )
    {
      ++*(_DWORD *)(v2 + 124);
      --*(_DWORD *)(*(_DWORD *)(a1 + 260) + 64);
      --*(_DWORD *)(*(_DWORD *)(a1 + 260) + 68);
    }
    ++*(_QWORD *)&dword_63D68;
  }
  sub_152B8((void **)a1);
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63D68: using guessed type int dword_63D68;

//----- (00015600) --------------------------------------------------------
int __fastcall sub_15600(int result)
{
  int v1; // r5
  int v2; // r7
  int *v3; // r3
  int v4; // r4
  int v5; // r1
  int v6; // t1
  int v7; // r2
  bool v8; // cc
  int v9; // r2
  int v10; // r3

  v1 = dword_63740;
  v2 = dword_63740 - 1;
  if ( dword_63740 > 0 )
  {
    v3 = (int *)dword_639E0;
    v4 = dword_639E0 + 4 * dword_63740;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= *(_DWORD *)(result + 4);
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != (int *)v4 );
  }
  if ( v2 > *(_DWORD *)result )
  {
    **(_DWORD **)(dword_639E0 + 4 * v2) = *(_DWORD *)result;
    *(_DWORD *)(dword_639E0 + 4 * *(_DWORD *)result) = *(_DWORD *)(dword_639E0 + 4 * v2);
    v1 = dword_63740;
  }
  *(_DWORD *)result = v1;
  v10 = dword_63740;
  *(_BYTE *)(result + 105) = 1;
  dword_63740 = v10 - 1;
  return result;
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (0001569C) --------------------------------------------------------
void __fastcall sub_1569C(FILE *s)
{
  const char *v1; // r11
  int v3; // r5
  const char *v4; // r10
  const char *v5; // r0
  const char *v6; // r9
  const char *v7; // r0
  const char *v8; // r0
  int v9; // r7
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r4
  const char *v15; // r7
  const char *v16; // r0
  const char *v17; // r9
  const char *v18; // r0
  const char *v19; // r0
  int v20; // r3
  const char *v21; // r10
  const char *v22; // r0
  const char **v23; // r5
  char *v24; // r8
  char *v25; // r4
  int v26; // r2
  int (__fastcall *v27)(_BYTE *); // r3
  char *(__fastcall *v28)(const char *, float *); // r3
  const char **v29; // r3
  const char *v30; // r0
  int v31; // r1
  int v32; // r4
  int v33; // r5
  const char *v34; // [sp+14h] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, s);
  if ( dword_63740 > 0 )
  {
    v3 = 0;
    while ( 1 )
    {
      v13 = sub_11B90(v3);
      v9 = *(_DWORD *)(v13 + 56);
      v14 = v13;
      if ( v9 == 1 )
      {
        v15 = ",";
        if ( !v3 )
          v15 = "";
        if ( *(_DWORD *)(v13 + 184) )
        {
          v16 = sub_29418(*(char **)(v13 + 180));
          v17 = sub_F46C(v16);
          v18 = *(const char **)(v14 + 184);
          if ( v18 )
          {
            v19 = sub_F46C(v18);
            v20 = *(_DWORD *)(v14 + 184);
            if ( v20 )
              v1 = delim;
            v21 = v19;
            if ( v20 )
              goto LABEL_20;
            goto LABEL_69;
          }
        }
        else
        {
          v17 = "";
        }
        v21 = "";
LABEL_69:
        v1 = "";
LABEL_20:
        v22 = sub_F46C(*(const char **)(v14 + 164));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v17, v21, v1, v22);
        goto LABEL_11;
      }
      v4 = ",";
      if ( !v3 )
        v4 = "";
      if ( !*(_DWORD *)(v13 + 184) )
        break;
      v5 = sub_29418(*(char **)(v13 + 180));
      v6 = sub_F46C(v5);
      v7 = *(const char **)(v14 + 184);
      if ( !v7 )
      {
        v9 = *(_DWORD *)(v14 + 56);
        goto LABEL_22;
      }
      v8 = sub_F46C(v7);
      v9 = *(_DWORD *)(v14 + 56);
      v1 = v8;
      if ( !*(_DWORD *)(v14 + 184) )
        goto LABEL_23;
      v34 = delim;
LABEL_10:
      v10 = sub_F46C(*(const char **)(v14 + 164));
      fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v4, v6, v1, v34, v9, v10);
LABEL_11:
      ++v3;
      v11 = sub_F46C(*(const char **)(v14 + 172));
      fprintf(s, "\n\t\t\"user\" : \"%s\",", v11);
      v12 = sub_F46C(*(const char **)(v14 + 176));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
      if ( dword_63740 <= v3 )
        goto LABEL_24;
    }
    v6 = "";
LABEL_22:
    v1 = "";
LABEL_23:
    v34 = "";
    goto LABEL_10;
  }
LABEL_24:
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_5F8A4 != 16 )
  {
    v23 = (const char **)&unk_5F8BC;
    while ( 1 )
    {
      v24 = _strdup(*(v23 - 7));
      v25 = strtok(v24, delim);
      if ( v25 )
        break;
LABEL_53:
      v23 += 7;
      free(v24);
      if ( *(v23 - 6) == (const char *)16 )
        goto LABEL_54;
    }
    while ( 1 )
    {
      if ( v25[1] == 45 && *(v23 - 1) != (const char *)&unk_C54D8 )
      {
        v26 = (int)*(v23 - 6);
        if ( (v26 & 1) != 0
          && ((v27 = (int (__fastcall *)(_BYTE *))*(v23 - 5), v27 == sub_47974) || v27 == sub_47984)
          && **(v23 - 2) == (v27 == sub_47974) )
        {
          fprintf(s, ",\n\"%s\" : true", v25 + 2);
        }
        else
        {
          if ( (v26 & 2) == 0 )
            goto LABEL_49;
          v28 = (char *(__fastcall *)(const char *, float *))*(v23 - 4);
          if ( (char *)v28 == (char *)sub_47B60
            || (char *)v28 == (char *)sub_15000
            || (char *)v28 == (char *)sub_15018
            || (char *)v28 == (char *)sub_15078
            || (char *)v28 == (char *)sub_1506C
            || (char *)v28 == (char *)sub_1500C
            || (char *)v28 == (char *)sub_15060
            || (char *)v28 == (char *)sub_15054
            || (char *)v28 == (char *)sub_15048
            || (char *)v28 == (char *)sub_1503C
            || (char *)v28 == (char *)sub_15030
            || (char *)v28 == (char *)sub_15024 )
          {
            fprintf(s, ",\n\"%s\" : \"%d\"", v25 + 2, *(_DWORD *)*(v23 - 2));
          }
          else
          {
            if ( v28 != sub_11D58 && v28 != sub_11D08 )
            {
LABEL_49:
              if ( (v26 & 6) != 0 )
              {
                v29 = (const char **)*(v23 - 2);
                if ( v29 != (const char **)&unk_611C4 )
                {
                  if ( *v29 )
                  {
                    v30 = sub_F46C(*v29);
                    fprintf(s, ",\n\"%s\" : \"%s\"", v25 + 2, v30);
                  }
                }
              }
              goto LABEL_28;
            }
            fprintf(s, ",\n\"%s\" : \"%.1f\"", v25 + 2, *(float *)*(v23 - 2));
          }
        }
      }
LABEL_28:
      v25 = strtok(0, delim);
      if ( !v25 )
        goto LABEL_53;
    }
  }
LABEL_54:
  v31 = dword_611AC;
  if ( dword_611AC == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, s);
    v31 = dword_611AC;
    if ( dword_611AC != 3 )
      goto LABEL_56;
  }
  else if ( dword_611AC != 3 )
  {
    goto LABEL_56;
  }
  fwrite(",\n\"load-balance\" : true", 1u, 0x17u, s);
  v31 = dword_611AC;
LABEL_56:
  if ( v31 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, s);
    v31 = dword_611AC;
  }
  if ( v31 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", dword_63AF8);
  fwrite("\n}\n", 1u, 3u, s);
  v32 = dword_60E88;
  dword_60E88 = 0;
  if ( v32 )
  {
    do
    {
      v33 = *(_DWORD *)(v32 + 4);
      free(*(void **)v32);
      free((void *)v32);
      v32 = v33;
    }
    while ( v33 );
  }
}
// 15820: variable 'v1' is possibly undefined
// 5F8A4: using guessed type int dword_5F8A4;
// 60E88: using guessed type int dword_60E88;
// 611AC: using guessed type int dword_611AC;
// 63740: using guessed type int dword_63740;
// 63AF8: using guessed type int dword_63AF8;

//----- (00015BEC) --------------------------------------------------------
int sub_15BEC()
{
  int result; // r0
  int *v1; // r3
  int v2; // r1
  int v3; // t1

  dword_60064 = 0;
  dword_60068 = 0;
  dword_611C8 = 0;
  dword_611CC = 0;
  result = sub_11130(0, (char *)&dword_60064, 8u, 0);
  if ( dword_63740 > 0 )
  {
    result = 0;
    v1 = (int *)dword_639E0;
    v2 = dword_639E0 + 4 * dword_63740;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 368) = 0;
      *(_DWORD *)(v3 + 372) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 60064: using guessed type int dword_60064;
// 60068: using guessed type int dword_60068;
// 611C8: using guessed type int dword_611C8;
// 611CC: using guessed type int dword_611CC;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00015C88) --------------------------------------------------------
char *__fastcall sub_15C88(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // r5
  char *v6; // r0

  if ( dword_60E8C && *(_BYTE *)dword_60E8C )
    return strcpy(a1, (const char *)dword_60E8C);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    *(_WORD *)stpcpy(a1, v6) = 47;
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".cgminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"cgminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"cgminer.conf";
}
// AD38: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 60E8C: using guessed type int dword_60E8C;

//----- (00015D7C) --------------------------------------------------------
int __fastcall sub_15D7C(int a1)
{
  double v1; // d0
  double v3; // d8
  double v4; // d8
  __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  __int64 v8; // r0
  double v9; // r0
  double v10; // d8
  __int64 v11; // r0
  double v12; // r0
  int v13; // r1
  int v14; // r1
  __int64 v15; // r2
  __int64 v16; // r0
  __int64 v17; // r2
  const char *v18; // r0
  char *v19; // r6
  unsigned int v21; // [sp+0h] [bp-820h] BYREF
  int v22; // [sp+4h] [bp-81Ch]
  __int64 v23; // [sp+8h] [bp-818h]
  __int64 v24; // [sp+10h] [bp-810h]
  __int64 v25; // [sp+18h] [bp-808h]
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      strcpy(s, "Diff zero passed to set_target");
      sub_38438(3, s, 0);
      v1 = 1.0;
    }
    else
    {
      v1 = 1.0;
    }
  }
  v3 = 1.7668201e72;
  if ( !byte_63DF9 )
    v3 = 2.69595353e67;
  v4 = v3 / v1;
  LODWORD(v5) = sub_494C0(v4 * 1.59309191e-58);
  v25 = v5;
  LODWORD(v6) = sub_493C8(v5);
  v7 = v4 - v6 * 6.27710174e57;
  LODWORD(v8) = sub_494C0(v7 * 2.93873588e-39);
  v24 = v8;
  LODWORD(v9) = sub_493C8(v8);
  v10 = v7 - v9 * 3.40282367e38;
  LODWORD(v11) = sub_494C0(v10 * 5.42101086e-20);
  v23 = v11;
  LODWORD(v12) = sub_493C8(v11);
  v21 = sub_494C0(v10 - v12 * 1.84467441e19);
  v22 = v13;
  if ( byte_630C1 )
  {
    v18 = sub_294B8((int)&v21, 32);
    v19 = (char *)v18;
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "Generated target %s", v18);
      sub_38438(7, s, 0);
    }
    free(v19);
  }
  v14 = v22;
  v15 = v23;
  *(_DWORD *)a1 = v21;
  *(_DWORD *)(a1 + 4) = v14;
  *(_QWORD *)(a1 + 8) = v15;
  v16 = v24;
  v17 = v25;
  *(_QWORD *)(a1 + 16) = v24;
  *(_QWORD *)(a1 + 24) = v17;
  return v16;
}
// 15D94: variable 'v1' is possibly undefined
// 15DC8: variable 'v5' is possibly undefined
// 15DDC: variable 'v6' is possibly undefined
// 15DEC: variable 'v8' is possibly undefined
// 15E00: variable 'v9' is possibly undefined
// 15E10: variable 'v11' is possibly undefined
// 15E24: variable 'v12' is possibly undefined
// 15E38: variable 'v13' is possibly undefined
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63DF9: using guessed type char byte_63DF9;

//----- (00015FC4) --------------------------------------------------------
int __fastcall sub_15FC4(int a1)
{
  return dword_63EE8 - *(_DWORD *)(a1 + 232);
}
// 63EE8: using guessed type int dword_63EE8;

//----- (00015FDC) --------------------------------------------------------
bool __fastcall sub_15FDC(int a1, int a2)
{
  unsigned int v3; // r0

  *(_DWORD *)(a1 + 76) = a2;
  if ( byte_63DF9 )
    sub_14A88(a1);
  else
    sub_117A4(a1);
  if ( byte_63DF9 )
    v3 = 0xFFFF;
  else
    v3 = 0;
  return v3 >= *(_DWORD *)(a1 + 220);
}
// 63DF9: using guessed type char byte_63DF9;

//----- (00016030) --------------------------------------------------------
bool __fastcall sub_16030(int a1, int a2)
{
  double v2; // d0
  double v4; // d16
  unsigned __int64 v5; // r0

  *(_DWORD *)(a1 + 76) = a2;
  if ( byte_63DF9 )
    sub_14A88(a1);
  else
    sub_117A4(a1);
  v4 = 2.81470682e14;
  if ( !byte_63DF9 )
    v4 = 4294901760.0;
  LODWORD(v5) = sub_494C0(v4 / v2);
  return v5 >= *(_QWORD *)(a1 + 216);
}
// 16070: variable 'v2' is possibly undefined
// 16084: variable 'v5' is possibly undefined
// 63DF9: using guessed type char byte_63DF9;

//----- (000160B4) --------------------------------------------------------
unsigned int __fastcall sub_160B4(int a1, int a2)
{
  int v4; // r5
  int v5; // r12
  int v6; // r3
  unsigned int v7; // r2
  unsigned int result; // r0
  int v9; // r1
  unsigned int v10; // r2
  unsigned int v11; // r3
  unsigned int v12; // r1
  unsigned int v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r2
  int v17; // r1
  int v18; // r3
  int v19; // r3
  size_t v20; // r4
  _DWORD *v21; // r0
  _DWORD *v22; // r6
  int v23; // r3
  int v24; // r8
  int v25; // r3
  unsigned int v26; // r5
  _DWORD *v27; // r4
  _DWORD *v28; // r9
  int v29; // r5
  char *v30; // r7
  unsigned int v31; // r2
  int v32; // r3
  _DWORD *v33; // r3
  unsigned int v34; // r1
  unsigned int v35; // r2
  bool v36; // cc
  int v37; // r2
  int v38; // r3
  int v39; // r6
  void *v40; // r0
  void **v41; // r6
  void *v42; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  ++*(_DWORD *)(a1 + 360);
  *(_DWORD *)(a2 + 352) = 0;
  *(_DWORD *)(a2 + 364) = a2 + 340;
  *(_DWORD *)(a2 + 368) = 4;
  v4 = *(_DWORD *)(a1 + 352);
  if ( v4 )
  {
    v5 = a2 + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 344) + 16) + 8) = a2;
    *(_DWORD *)(a2 + 348) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16)
                          - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = a2 + 344;
  }
  else
  {
    *(_DWORD *)(a1 + 352) = a2;
    *(_DWORD *)(a2 + 348) = 0;
    v39 = *(_DWORD *)(a1 + 352);
    *(_DWORD *)(v39 + 344) = malloc(0x2Cu);
    v40 = *(void **)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v40 )
      goto LABEL_31;
    memset(v40, 0, 0x2Cu);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 16) = *(_DWORD *)(a1 + 352) + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 20) = 344;
    v41 = *(void ***)(*(_DWORD *)(a1 + 352) + 344);
    *v41 = malloc(0x180u);
    v42 = **(void ***)(*(_DWORD *)(a1 + 352) + 344);
    if ( !v42 )
      goto LABEL_31;
    memset(v42, 0, 0x180u);
    v5 = a2 + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
  v6 = (*(unsigned __int8 *)(a2 + 340)
      + 17973517
      + (*(unsigned __int8 *)(a2 + 343) << 24)
      + (*(unsigned __int8 *)(a2 + 342) << 16)
      + (*(unsigned __int8 *)(a2 + 341) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  result = (-17973517 - v6 - v7) ^ (v7 >> 13);
  *(_DWORD *)(a2 + 344) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 344);
  v9 = (v6 - v7 - result) ^ (result >> 12);
  v10 = (v7 - result - v9) ^ (v9 << 16);
  v11 = (result - v9 - v10) ^ (v10 >> 5);
  v12 = v9 - v10 - v11;
  v13 = (v11 - (v12 ^ (v11 >> 3)) - ((v10 - v11 - (v12 ^ (v11 >> 3))) ^ ((v12 ^ (v11 >> 3)) << 10)))
      ^ (((v10 - v11 - (v12 ^ (v11 >> 3))) ^ ((v12 ^ (v11 >> 3)) << 10)) >> 15);
  *(_DWORD *)(a2 + 372) = v13;
  v14 = 12 * (v13 & (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 4) - 1));
  v15 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v14;
  ++*(_DWORD *)(v15 + 4);
  v16 = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v14);
  *(_DWORD *)(a2 + 356) = 0;
  *(_DWORD *)(a2 + 360) = v16;
  v17 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v14;
  if ( *(_DWORD *)v17 )
  {
    *(_DWORD *)(*(_DWORD *)v17 + 12) = v5;
    v17 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v14;
  }
  *(_DWORD *)v17 = v5;
  v18 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344) + v14;
  if ( *(_DWORD *)(v18 + 4) >= (unsigned int)(10 * (*(_DWORD *)(v18 + 8) + 1)) )
  {
    v19 = *(_DWORD *)(a2 + 344);
    if ( *(_DWORD *)(v19 + 36) != 1 )
    {
      v20 = 24 * *(_DWORD *)(v19 + 4);
      v21 = malloc(v20);
      v22 = v21;
      if ( v21 )
      {
        memset(v21, 0, v20);
        v23 = *(_DWORD *)(a2 + 344);
        v24 = 0;
        *(_DWORD *)(v23 + 24) = (((2 * *(_DWORD *)(v23 + 4) - 1) & *(_DWORD *)(v23 + 12)) != 0)
                              + (*(_DWORD *)(v23 + 12) >> (*(_BYTE *)(v23 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 28) = 0;
        v25 = *(_DWORD *)(a2 + 344);
        v26 = *(_DWORD *)(v25 + 4);
        if ( v26 )
        {
          for ( i = 0; i < v26; ++i )
          {
            v27 = *(_DWORD **)(*(_DWORD *)v25 + v24);
            if ( v27 )
            {
              while ( 1 )
              {
                v28 = (_DWORD *)v27[4];
                v29 = 3 * ((2 * v26 - 1) & v27[7]);
                v30 = (char *)&v22[v29];
                v31 = *((_DWORD *)v30 + 1) + 1;
                *((_DWORD *)v30 + 1) = v31;
                if ( v31 > *(_DWORD *)(v25 + 24) )
                {
                  ++*(_DWORD *)(v25 + 28);
                  *((_DWORD *)v30 + 2) = *((_DWORD *)v30 + 1) / *(_DWORD *)(*(_DWORD *)(a2 + 344) + 24);
                }
                v27[3] = 0;
                v27[4] = v22[v29];
                v32 = v22[v29];
                if ( v32 )
                  *(_DWORD *)(v32 + 12) = v27;
                v22[v29] = v27;
                v25 = *(_DWORD *)(a2 + 344);
                if ( !v28 )
                  break;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = v28;
              }
              v26 = *(_DWORD *)(v25 + 4);
            }
            v24 += 12;
          }
        }
        free(*(void **)v25);
        *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a2 + 344) + 8);
        **(_DWORD **)(a2 + 344) = v22;
        v33 = *(_DWORD **)(a2 + 344);
        v34 = v33[3];
        v35 = v33[7];
        v36 = v35 > v34 >> 1;
        if ( v35 <= v34 >> 1 )
          v37 = 0;
        else
          v37 = v33[8];
        if ( v36 )
          ++v37;
        v33[8] = v37;
        v38 = *(_DWORD *)(a2 + 344);
        if ( *(_DWORD *)(v38 + 32) > 1u )
          *(_DWORD *)(v38 + 36) = 1;
        return result;
      }
LABEL_31:
      exit(-1);
    }
  }
  return result;
}

//----- (00016500) --------------------------------------------------------
int __fastcall sub_16500(int a1, void *s2, size_t n, const void *a4, int a5, size_t a6)
{
  int v6; // r5
  int v10; // r4

  v6 = a1;
  if ( a1 )
  {
    v10 = *(_DWORD *)(a1 + 352);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, a6) )
    {
      v6 = v10;
      if ( !v10 )
        return 0;
      v10 = *(_DWORD *)(v10 + 352);
    }
  }
  return v6;
}

//----- (000165C0) --------------------------------------------------------
void __fastcall sub_165C0(int a1, _DWORD *a2)
{
  int v3; // r3
  int v4; // r2
  int v5; // r0
  bool v6; // zf
  int v7; // r2
  int v8; // r2
  int v9; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r3

  --*(_DWORD *)(a1 + 360);
  v3 = a2[87];
  if ( v3 || a2[88] )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 344);
    v5 = *(_DWORD *)(v4 + 20);
    if ( (_DWORD *)(*(_DWORD *)(v4 + 16) - v5) == a2 )
    {
      *(_DWORD *)(v4 + 16) = v3 + v5;
      v3 = a2[87];
    }
    v6 = v3 == 0;
    if ( v3 )
    {
      v5 = *(_DWORD *)(a1 + 352);
      v4 = a2[88];
    }
    else
    {
      v3 = a2[88];
    }
    if ( v6 )
      *(_DWORD *)(a1 + 352) = v3;
    else
      v5 = *(_DWORD *)(v5 + 344);
    if ( !v6 )
    {
      v3 += *(_DWORD *)(v5 + 20);
      *(_DWORD *)(v3 + 8) = v4;
    }
    v7 = a2[88];
    if ( !v6 )
      v3 = *(_DWORD *)(a1 + 352);
    if ( v7 )
    {
      *(_DWORD *)(v7 + *(_DWORD *)(*(_DWORD *)(v3 + 344) + 20) + 4) = a2[87];
      v3 = *(_DWORD *)(a1 + 352);
    }
    v8 = **(_DWORD **)(v3 + 344);
    v9 = 12 * ((*(_DWORD *)(*(_DWORD *)(v3 + 344) + 4) - 1) & a2[93]);
    --*(_DWORD *)(v8 + v9 + 4);
    v10 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 344);
    if ( *(_DWORD **)(v10 + v9) == a2 + 86 )
      *(_DWORD *)(v10 + v9) = a2[90];
    v11 = a2[89];
    if ( v11 )
      *(_DWORD *)(v11 + 16) = a2[90];
    v12 = a2[90];
    if ( v12 )
      *(_DWORD *)(v12 + 12) = a2[89];
    --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 344) + 12);
  }
  else
  {
    free(**(void ***)(*(_DWORD *)(a1 + 352) + 344));
    free(*(void **)(*(_DWORD *)(a1 + 352) + 344));
    *(_DWORD *)(a1 + 352) = 0;
  }
}

//----- (00016704) --------------------------------------------------------
int __fastcall sub_16704(int result)
{
  if ( *(_DWORD *)(result + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(result + 4) + 16))();
  return result;
}

//----- (00016724) --------------------------------------------------------
void __fastcall __noreturn sub_16724(int a1)
{
  sub_1C160(a1, 1);
}

//----- (0001672C) --------------------------------------------------------
char *__fastcall sub_1672C(char *a1)
{
  int *v2; // r0
  size_t v3; // r6
  size_t v4; // r6
  char *v5; // r0
  char *v6; // r4
  char v8[92]; // [sp+Ch] [bp-8FCh] BYREF
  char s[160]; // [sp+68h] [bp-8A0h] BYREF
  char v10[2048]; // [sp+108h] [bp-800h] BYREF

  v2 = sub_45C84(a1, 0, v8);
  if ( v2 && !*v2 )
  {
    byte_611D0 = 1;
    return sub_16868(v2, 1);
  }
  else
  {
    v3 = strlen(a1);
    v4 = v3 + strlen(s) + 35;
    v5 = (char *)malloc(v4);
    v6 = v5;
    if ( !v5 )
    {
      strcpy(v10, "Malloc failure in json error");
      sub_38438(3, v10, 1);
      sub_16724(1);
    }
    snprintf(v5, v4, "JSON decode of file '%s' failed\n %s", a1, s);
  }
  return v6;
}
// 611D0: using guessed type char byte_611D0;

//----- (00016814) --------------------------------------------------------
char *__fastcall sub_16814(char *s)
{
  if ( !dword_611D4 )
    dword_611D4 = (int)_strdup(s);
  if ( ++dword_611D8 <= 10 )
    return sub_1672C(s);
  else
    return "Too many levels of JSON includes (limit 10) or a loop";
}
// 611D4: using guessed type int dword_611D4;
// 611D8: using guessed type int dword_611D8;

//----- (00016868) --------------------------------------------------------
char *__fastcall sub_16868(_DWORD *a1, int a2)
{
  _DWORD *v4; // r6
  const char *v5; // r0
  char *v6; // r11
  _DWORD *v7; // r0
  _DWORD *v8; // r5
  int v9; // r2
  const char *v10; // r2
  int v11; // r3
  unsigned int v12; // r4
  _DWORD *v13; // r0
  _DWORD *v15; // r11
  _DWORD *v16; // r4
  _DWORD *v17; // r0
  char *v18; // r0
  const char *v19; // [sp+Ch] [bp-810h]
  const char *v20; // [sp+Ch] [bp-810h]
  char *ptr; // [sp+10h] [bp-80Ch]
  char *v22; // [sp+14h] [bp-808h]
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  if ( a2 && !dword_612A4 )
    dword_612A4 = 1;
  if ( dword_5F8A4 == 16 )
    goto LABEL_46;
  if ( (dword_5F8A4 & 8) != 0 )
    goto LABEL_28;
  v4 = &unk_5F8BC;
  while ( 2 )
  {
    v5 = (const char *)*(v4 - 7);
    if ( !v5 )
      goto LABEL_26;
    ptr = _strdup(v5);
    v6 = strtok(ptr, delim);
    if ( !v6 )
      goto LABEL_25;
    while ( 2 )
    {
      if ( v6[1] != 45 )
        goto LABEL_10;
      v7 = (_DWORD *)sub_46698(a1, v6 + 2);
      v8 = v7;
      if ( !v7 )
        goto LABEL_10;
      v9 = *(v4 - 6);
      if ( (v9 & 6) == 0 )
        goto LABEL_17;
      if ( *v7 == 2 )
      {
        v16 = sub_469F0(v7);
        v10 = (const char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v4 - 4))(v16, *(v4 - 2));
        if ( *(v4 - 6) == 4 )
        {
          v20 = v10;
          sub_47A4C((int)v16, (_DWORD *)*(v4 - 2));
          v10 = v20;
        }
        goto LABEL_43;
      }
      if ( *v7 != 1 )
      {
LABEL_17:
        if ( (v9 & 1) == 0 || *v7 != 5 )
        {
          v10 = "Invalid value";
          goto LABEL_19;
        }
        v10 = (const char *)((int (__fastcall *)(_DWORD))*(v4 - 5))(*(v4 - 2));
LABEL_43:
        if ( !v10 )
          goto LABEL_10;
LABEL_19:
        if ( !a2 )
          goto LABEL_38;
        goto LABEL_20;
      }
      v12 = 0;
      v22 = v6;
      while ( 1 )
      {
        if ( v12 >= (unsigned int)sub_46864(v8) )
          goto LABEL_10;
        v13 = sub_46880(v8, v12);
        if ( !v13 )
          goto LABEL_10;
        if ( *v13 == 2 )
        {
          v15 = sub_469F0(v13);
          v10 = (const char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v4 - 4))(v15, *(v4 - 2));
          if ( *(v4 - 6) == 4 )
          {
            v19 = v10;
            sub_47A4C((int)v15, (_DWORD *)*(v4 - 2));
            v10 = v19;
          }
        }
        else
        {
          if ( *v13 )
            goto LABEL_30;
          v10 = (const char *)sub_16868();
        }
        if ( v10 )
          break;
LABEL_30:
        ++v12;
      }
      v6 = v22;
      if ( !a2 )
      {
LABEL_38:
        snprintf(byte_611DC, 0xC8u, "Parsing JSON option %s: %s", v6, v10);
        return byte_611DC;
      }
LABEL_20:
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf(s, 0x800u, "Invalid config option %s: %s", v6, v10);
        sub_38438(3, s, 0);
      }
      dword_612A4 = -1;
LABEL_10:
      v6 = strtok(0, delim);
      if ( v6 )
        continue;
      break;
    }
LABEL_25:
    free(ptr);
LABEL_26:
    v11 = v4[1];
    if ( v11 != 16 )
    {
      v4 += 7;
      if ( (v11 & 8) != 0 )
LABEL_28:
        _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x79Eu, "parse_config");
      continue;
    }
    break;
  }
LABEL_46:
  v17 = (_DWORD *)sub_46698(a1, "include");
  if ( !v17 )
    return 0;
  if ( *v17 != 2 )
    return 0;
  v18 = (char *)sub_469F0(v17);
  return (char *)sub_16814(v18);
}
// 5F8A4: using guessed type int dword_5F8A4;
// 60964: using guessed type int dword_60964;
// 612A4: using guessed type int dword_612A4;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (00016B7C) --------------------------------------------------------
int __fastcall sub_16B7C(int a1, char *a2)
{
  char *v3; // r5
  int result; // r0
  char *v5; // r0
  char *v6; // r6
  char v7[2048]; // [sp+0h] [bp-800h] BYREF

  v3 = sub_2B5C8(a2, a1);
  result = sub_150B4(a1, v3);
  if ( !result )
  {
    sub_47A4C((int)v3, (_DWORD *)(a1 + 164));
    result = strncmp(v3, "http://", 7u);
    if ( result )
    {
      result = strncmp(v3, "https://", 8u);
      if ( result )
      {
        v5 = (char *)malloc(0x100u);
        v6 = v5;
        if ( !v5 )
        {
          strcpy(v7, "Failed to malloc httpinput");
          sub_38438(3, v7, 1);
          sub_16724(1);
        }
        strcpy(v5, "stratum+tcp://");
        strncat(v5, v3, 0xF2u);
        return sub_150B4(a1, v6);
      }
    }
  }
  return result;
}

//----- (00016C8C) --------------------------------------------------------
int sub_16C8C()
{
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  sub_2B13C(&stru_611B4);
  result = pthread_create(newthread, 0, sub_22EC4, 0);
  if ( result )
    sub_B498();
  return result;
}
// 611B4: using guessed type struct timeval stru_611B4;

//----- (00016CD0) --------------------------------------------------------
int __fastcall sub_16CD0(_BYTE *a1)
{
  char *v2; // r0
  bool v3; // zf
  _DWORD *v5; // r7
  int v6; // r8
  int v7; // r11
  char *v8; // r0
  char *v9; // r12
  char *v10; // r8
  signed int v11; // r2
  size_t v12; // r0
  const char *v13; // r7
  size_t v14; // r11
  size_t v15; // r9
  size_t v16; // r5
  char *v17; // r0
  const char *v18; // r7
  char *v19; // r0
  int v20; // r0
  _DWORD v21[4]; // [sp+14h] [bp-C18h] BYREF
  char *v22; // [sp+24h] [bp-C08h]
  char s[1016]; // [sp+28h] [bp-C04h] BYREF
  char v24[2052]; // [sp+428h] [bp-804h] BYREF

  if ( dword_612A8 )
  {
    if ( fgets(s, 1024, (FILE *)dword_612A8) )
      goto LABEL_3;
    if ( !dword_612B4 )
      goto LABEL_22;
LABEL_9:
    fclose((FILE *)dword_612A8);
    dword_612A8 = 0;
    return sub_16CD0(a1);
  }
  else
  {
    if ( !dword_612AC )
    {
      strcpy(v24, "BENCHFILE Invalid benchfile NULL");
      sub_38438(3, v24, 1);
      sub_16724(1);
    }
    dword_612A8 = (int)fopen((const char *)dword_612AC, "r");
    if ( !dword_612A8 )
    {
      snprintf(v24, 0x800u, "BENCHFILE Failed to open benchfile '%s'", (const char *)dword_612AC);
      sub_38438(3, v24, 1);
      sub_16724(1);
    }
    dword_612B0 = 0;
    if ( !fgets(s, 1024, (FILE *)dword_612A8) )
    {
      snprintf(v24, 0x800u, "BENCHFILE Failed to read benchfile '%s'", (const char *)dword_612AC);
      sub_38438(3, v24, 1);
      sub_16724(1);
    }
    dword_612B4 = 0;
    while ( 1 )
    {
LABEL_3:
      v2 = s;
      v3 = s[0] == 35;
      if ( s[0] != 35 )
        v3 = s[0] == 0;
      ++dword_612B0;
      if ( !v3 && s[0] != 47 )
        break;
      if ( !fgets(s, 1024, (FILE *)dword_612A8) )
      {
        if ( dword_612B4 )
          goto LABEL_9;
LABEL_22:
        snprintf(v24, 0x800u, "BENCHFILE No work in benchfile '%s'", dword_612AC);
        sub_38438(3, v24, 1);
        sub_16724(1);
      }
    }
    v5 = v21;
    v6 = 0;
    v7 = 1;
    v21[0] = s;
    do
    {
      v8 = strchr(v2, 44);
      v5[1] = v8;
      if ( !v8 )
      {
        snprintf(
          v24,
          0x800u,
          "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
          dword_612B0,
          v7,
          5);
        sub_38438(3, v24, 1);
        sub_16724(1);
      }
      v9 = *(char **)((char *)&unk_49F24 + v6);
      if ( v9 && &v8[-*v5] != v9 )
      {
        snprintf(
          v24,
          0x800u,
          "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
          dword_612B0,
          v7,
          *(const char **)((char *)&unk_49F24 + v6 + 4),
          &v8[-*v5],
          v9);
        sub_38438(3, v24, 1);
        sub_16724(1);
      }
      ++v7;
      *v8 = 0;
      v6 += 8;
      v5[1] = v8 + 1;
      v2 = v8 + 1;
      ++v5;
    }
    while ( v7 != 5 );
    v10 = v22;
    v11 = strlen(v22);
    if ( v11 <= 9 )
    {
      snprintf(
        v24,
        0x800u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        dword_612B0,
        5,
        "NonceTime",
        v11,
        10);
      sub_38438(3, v24, 1);
      sub_16724(1);
    }
    sprintf(v24, "0000000%c", *(unsigned __int8 *)v21[0]);
    v12 = strlen(v24);
    v13 = (const char *)(v21[2] + 56);
    v14 = v12 + 64;
    v15 = v12;
    v16 = v12;
    do
    {
      v17 = &v24[v16];
      v16 += 8;
      sprintf(v17, "%.8s", v13);
      v13 -= 8;
    }
    while ( v16 != v14 );
    v18 = (const char *)(v21[1] + 56);
    do
    {
      v19 = &v24[v16];
      v16 += 8;
      sprintf(v19, "%.8s", v18);
      v18 -= 8;
    }
    while ( v16 != v15 + 128 );
    v20 = strtol(v10, 0, 10);
    sprintf(&v24[v16], "%08lx", v20);
    strcpy(&v24[v15 + 136], (const char *)v21[3]);
    memset(a1, 0, 0x1E0u);
    sub_295B8(a1, (unsigned __int8 *)v24, (int)(v15 + 144) >> 1);
    sub_117F4((int)a1);
    ++dword_612B4;
    return 1;
  }
}
// 612A8: using guessed type int dword_612A8;
// 612AC: using guessed type int dword_612AC;
// 612B0: using guessed type int dword_612B0;
// 612B4: using guessed type int dword_612B4;

//----- (0001715C) --------------------------------------------------------
int __fastcall sub_1715C(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // r0
  double v8; // d10
  unsigned __int64 v9; // r4
  int v10; // r1
  unsigned __int64 v11; // r0
  size_t v12; // r11
  char v14[16]; // [sp+28h] [bp-864h] BYREF
  char v15[16]; // [sp+38h] [bp-854h] BYREF
  char s[64]; // [sp+48h] [bp-844h] BYREF
  char v17[2052]; // [sp+88h] [bp-804h] BYREF

  sub_15324(a3);
  LODWORD(v7) = sub_493DC(*(_QWORD *)(a3 + 192));
  v8 = v7 / v3;
  LODWORD(v9) = sub_494C0(*(double *)(a3 + 48) * 1000000.0);
  HIDWORD(v9) = v10;
  LODWORD(v11) = sub_494C0(*(double *)(a3 + 80) / v3 * 1000000.0);
  sub_11130(v11, v14, 0x10u, 4);
  sub_11130(v9, v15, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  v12 = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_6006C,
    v15,
    v14,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v8 * 60.0);
  if ( a2 <= strlen(s) + v12 )
  {
    snprintf(v17, 0x800u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3078);
    sub_38438(3, v17, 1);
    sub_16724(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 171A4: variable 'v7' is possibly undefined
// 171A4: variable 'v3' is possibly undefined
// 171C8: variable 'v10' is possibly undefined
// 171E4: variable 'v11' is possibly undefined
// 16724: using guessed type void __fastcall __noreturn sub_16724(_DWORD);
// 6006C: using guessed type int dword_6006C;

//----- (00017328) --------------------------------------------------------
void __noreturn sub_17328()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  sub_2F38C((int)sub_1C708, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  sub_38438(3, v0, 1);
  sub_16724(0);
}

//----- (00017380) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_17380(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 17388: positive sp value 804 has been found
// 17388: unbalanced stack, ignored a potential tail call

//----- (0001738C) --------------------------------------------------------
void __noreturn sub_1738C()
{
  sigaction(15, &oact, 0);
  sigaction(2, &stru_63EEC, 0);
  sub_17328();
}

//----- (000173C0) --------------------------------------------------------
int __fastcall sub_173C0(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_mutex_init(a1, 0);
  if ( result )
    sub_B5BC(a2, a3);
  return result;
}

//----- (000173EC) --------------------------------------------------------
int __fastcall sub_173EC(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_init(a1, 0);
  if ( result )
    sub_B628(a2, a3);
  return result;
}

//----- (00017418) --------------------------------------------------------
int __fastcall sub_17418(int a1, const char *a2, int a3)
{
  int result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_B5BC(a2, a3);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    sub_B628(a2, a3);
  return result;
}

//----- (0001746C) --------------------------------------------------------
char *sub_1746C()
{
  char *v0; // r4
  int v1; // r3
  void *v2; // r0
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r12
  char v7[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = (char *)calloc(0x708u, 1u);
  if ( !v0 )
  {
    strcpy(v7, "Failed to malloc pool in add_pool");
    sub_38438(3, v7, 1);
    sub_16724(1);
  }
  v1 = dword_63740;
  v2 = (void *)dword_639E0;
  v3 = dword_63740 + 2;
  *((_DWORD *)v0 + 1) = dword_63740;
  *(_DWORD *)v0 = v1;
  v4 = realloc(v2, 4 * v3);
  v5 = dword_63740 + 1;
  dword_639E0 = (int)v4;
  v4[dword_63740] = v0;
  dword_63740 = v5;
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 188), 0) )
    sub_B5BC("add_pool", 748);
  if ( pthread_cond_init((pthread_cond_t *)(v0 + 296), 0) )
  {
    strcpy(v7, "Failed to pthread_cond_init in add_pool");
    sub_38438(3, v7, 1);
    sub_16724(1);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 212), 0) )
    sub_B5BC("add_pool", 751);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v0 + 236), 0) )
    sub_B628("add_pool", 751);
  if ( pthread_mutex_init((pthread_mutex_t *)v0 + 28, 0) )
    sub_B5BC("add_pool", 752);
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 708), 0) )
    sub_B5BC("add_pool", 753);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v0 + 732), 0) )
    sub_B628("add_pool", 753);
  *((_DWORD *)v0 + 86) = v0 + 344;
  *((_DWORD *)v0 + 87) = v0 + 344;
  *((_DWORD *)v0 + 40) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v0 + 34) = -1;
  *((_DWORD *)v0 + 46) = 0;
  *((_DWORD *)v0 + 14) = 1;
  sub_14E18();
  return v0;
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (0001767C) --------------------------------------------------------
const char *__fastcall sub_1767C(char *s)
{
  int v2; // r3
  _DWORD *v3; // r4
  char *v4; // r6
  char *v5; // r0
  char *v6; // r5
  int v7; // r3
  void *v8; // r0

  if ( dword_612B8 || dword_612BC )
    return "Use only user + pass or userpass, but not both";
  v2 = dword_612C0 + 1;
  dword_612C0 = v2;
  if ( v2 > dword_63740 )
  {
    sub_1746C();
    v2 = dword_612C0;
  }
  v3 = *(_DWORD **)(dword_639E0 + 4 * (v2 - 1));
  v4 = _strdup(s);
  sub_47A4C((int)s, v3 + 42);
  v5 = strtok(v4, ":");
  v3[43] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[44] = v6;
  if ( v6 )
    return 0;
  v8 = calloc(1u, 1u);
  v7 = 0;
  v3[44] = v8;
  return (const char *)v7;
}
// 612B8: using guessed type int dword_612B8;
// 612BC: using guessed type int dword_612BC;
// 612C0: using guessed type int dword_612C0;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (0001776C) --------------------------------------------------------
const char *__fastcall sub_1776C(int a1)
{
  int v3; // r3

  if ( dword_612C0 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_612B8 + 1;
  dword_612B8 = v3;
  if ( v3 > dword_63740 )
  {
    sub_1746C();
    v3 = dword_612B8;
  }
  sub_47A4C(a1, (_DWORD *)(*(_DWORD *)(dword_639E0 + 4 * (v3 - 1)) + 172));
  return 0;
}
// 612B8: using guessed type int dword_612B8;
// 612C0: using guessed type int dword_612C0;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (000177E8) --------------------------------------------------------
int sub_177E8()
{
  int v0; // r3

  v0 = ++dword_612C4;
  if ( dword_612C4 > dword_63740 )
  {
    sub_1746C();
    v0 = dword_612C4;
  }
  return *(_DWORD *)(dword_639E0 + 4 * (v0 - 1));
}
// 612C4: using guessed type int dword_612C4;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00017834) --------------------------------------------------------
int __fastcall sub_17834(char *a1)
{
  int v2; // r0

  v2 = sub_177E8();
  sub_16B7C(v2, a1);
  return 0;
}

//----- (00017998) --------------------------------------------------------
const char *__fastcall sub_17998(int a1)
{
  int v3; // r3

  if ( dword_612C0 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_612BC + 1;
  dword_612BC = v3;
  if ( v3 > dword_63740 )
  {
    sub_1746C();
    v3 = dword_612BC;
  }
  sub_47A4C(a1, (_DWORD *)(*(_DWORD *)(dword_639E0 + 4 * (v3 - 1)) + 176));
  return 0;
}
// 612BC: using guessed type int dword_612BC;
// 612C0: using guessed type int dword_612C0;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00017A14) --------------------------------------------------------
int __fastcall sub_17A14(int a1)
{
  int v2; // r3
  int v3; // r0
  int v4; // r2
  int v5; // r1
  int v6; // r12
  bool v7; // zf
  int v8; // r2
  int v9; // r1
  int v10; // r0
  int v11; // r2
  int v12; // r2
  struct timespec v14; // [sp+0h] [bp-814h] BYREF
  struct timeval v15; // [sp+8h] [bp-80Ch] BYREF
  char v16[2052]; // [sp+10h] [bp-804h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
    sub_B4E4("hash_pop", 7716);
  if ( dword_612CC && *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12) )
  {
    if ( !byte_612D0 )
      goto LABEL_18;
    goto LABEL_14;
  }
  if ( byte_612D1 && dword_60070 < dword_60074 )
  {
    ++dword_60070;
    byte_612D1 = 0;
  }
  byte_612D2 = 1;
  if ( a1 )
  {
    do
    {
      sub_2B13C(&v15);
      v14.tv_sec = v15.tv_sec + 10;
      v14.tv_nsec = 1000 * v15.tv_usec;
      pthread_cond_signal(&stru_63748);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_63BC0 + 40), (pthread_mutex_t *)dword_612C8, &v14) )
      {
        if ( !byte_612D0 )
        {
          byte_612D0 = 1;
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            strcpy(v16, "Waiting for work to be available from pools.");
            sub_38438(4, v16, 0);
          }
        }
      }
    }
    while ( !dword_612CC || !*(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12) );
    if ( !byte_612D0 )
    {
LABEL_18:
      v2 = dword_612CC;
      if ( dword_612CC )
      {
        v3 = *(_DWORD *)(dword_612CC + 344);
        if ( dword_612D4 < *(_DWORD *)(v3 + 12)
          && (a1 = *(_DWORD *)(dword_612CC + 352), !*(_BYTE *)(dword_612CC + 273))
          && *(_DWORD *)(dword_612CC + 276) )
        {
          while ( a1 )
          {
            if ( *(_BYTE *)(a1 + 273) )
            {
              v4 = *(_DWORD *)(a1 + 348);
              if ( v4 )
                goto LABEL_22;
              goto LABEL_61;
            }
            if ( !*(_DWORD *)(a1 + 276) )
              break;
            a1 = *(_DWORD *)(a1 + 352);
          }
        }
        else
        {
          a1 = dword_612CC;
        }
      }
      else
      {
        v3 = MEMORY[0x158];
        a1 = 0;
      }
      v4 = *(_DWORD *)(a1 + 348);
      if ( !v4 )
      {
LABEL_61:
        if ( !*(_DWORD *)(a1 + 352) )
        {
          free(*(void **)v3);
          free(*(void **)(dword_612CC + 344));
          dword_612CC = 0;
LABEL_43:
          if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
            --dword_612D4;
          pthread_cond_signal(&stru_63748);
          pthread_cond_signal((pthread_cond_t *)(dword_63BC0 + 40));
          dword_63EE8 = time(0);
          goto LABEL_45;
        }
      }
LABEL_22:
      v5 = *(_DWORD *)(v3 + 20);
      v6 = a1 + 344;
      if ( *(_DWORD *)(v3 + 16) - v5 == a1 )
      {
        *(_DWORD *)(v3 + 16) = v4 + v5;
        v4 = *(_DWORD *)(a1 + 348);
      }
      v7 = v4 == 0;
      if ( v4 )
      {
        v3 = *(_DWORD *)(v2 + 344);
        v5 = *(_DWORD *)(a1 + 352);
      }
      else
      {
        v4 = *(_DWORD *)(a1 + 352);
      }
      if ( v7 )
      {
        v2 = v4;
        dword_612CC = v4;
      }
      else
      {
        v4 += *(_DWORD *)(v3 + 20);
      }
      if ( !v7 )
      {
        *(_DWORD *)(v4 + 8) = v5;
        v4 = *(_DWORD *)(a1 + 352);
      }
      if ( v4 )
        *(_DWORD *)(v4 + *(_DWORD *)(*(_DWORD *)(v2 + 344) + 20) + 4) = *(_DWORD *)(a1 + 348);
      v8 = 12 * ((*(_DWORD *)(*(_DWORD *)(v2 + 344) + 4) - 1) & *(_DWORD *)(a1 + 372));
      --*(_DWORD *)(**(_DWORD **)(v2 + 344) + v8 + 4);
      v9 = **(_DWORD **)(v2 + 344);
      v10 = *(_DWORD *)(v9 + v8);
      if ( v10 == v6 )
      {
        v2 = *(_DWORD *)(a1 + 360);
        *(_DWORD *)(v9 + v8) = v2;
      }
      v11 = *(_DWORD *)(a1 + 356);
      if ( v10 == v6 )
        v2 = dword_612CC;
      if ( v11 )
        *(_DWORD *)(v11 + 16) = *(_DWORD *)(a1 + 360);
      v12 = *(_DWORD *)(a1 + 360);
      if ( v12 )
        *(_DWORD *)(v12 + 12) = *(_DWORD *)(a1 + 356);
      --*(_DWORD *)(*(_DWORD *)(v2 + 344) + 12);
      goto LABEL_43;
    }
LABEL_14:
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      strcpy(v16, "Work available from pools, resuming.");
      sub_38438(4, v16, 0);
    }
    byte_612D0 = 0;
    goto LABEL_18;
  }
LABEL_45:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
    sub_B694("hash_pop", 7783);
  off_60178();
  return a1;
}
// 60070: using guessed type int dword_60070;
// 60074: using guessed type int dword_60074;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 612C8: using guessed type int dword_612C8;
// 612CC: using guessed type int dword_612CC;
// 612D0: using guessed type char byte_612D0;
// 612D1: using guessed type char byte_612D1;
// 612D2: using guessed type char byte_612D2;
// 612D4: using guessed type int dword_612D4;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 63BC0: using guessed type int dword_63BC0;
// 63EE8: using guessed type int dword_63EE8;

//----- (00017E64) --------------------------------------------------------
int __fastcall sub_17E64(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r5
  pthread_mutex_t *v4; // r0
  int v5; // r5

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_B4E4("pool_tset", 772);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    sub_B694("pool_tset", 775);
  off_60178();
  return v5;
}
// 60178: using guessed type int (*off_60178)();

//----- (00017ED8) --------------------------------------------------------
int sub_17ED8()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
    sub_B4E4("wake_gws", 5182);
  pthread_cond_signal(&stru_63748);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
    sub_B694("wake_gws", 5184);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();
// 612C8: using guessed type int dword_612C8;

//----- (00017F48) --------------------------------------------------------
int sub_17F48()
{
  int v0; // r5
  int v1; // r3

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
    sub_B4E4("total_staged", 2905);
  if ( dword_612CC )
    v1 = *(_DWORD *)(dword_612CC + 344);
  else
    v0 = 0;
  if ( dword_612CC )
    v0 = *(_DWORD *)(v1 + 12);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
    sub_B694("total_staged", 2907);
  off_60178();
  return v0;
}
// 17F74: variable 'v1' is possibly undefined
// 17F90: variable 'v0' is possibly undefined
// 60178: using guessed type int (*off_60178)();
// 612C8: using guessed type int dword_612C8;
// 612CC: using guessed type int dword_612CC;

//----- (00017FC4) --------------------------------------------------------
void __fastcall sub_17FC4(_DWORD *a1)
{
  int v2; // r4
  int v3; // r8
  int v4; // r5
  int v5; // r1
  int v6; // r2
  int v7; // r0
  int v8; // r3
  int v9; // r12
  bool v10; // zf
  int v11; // r3
  int v12; // r1
  int v13; // r1
  int v14; // r12
  int v15; // r3
  int v16; // r3
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
    sub_B4E4("clear_pool_work", 6994);
  v2 = dword_612CC;
  if ( dword_612CC )
  {
    v4 = *(_DWORD *)(dword_612CC + 352);
    v3 = 0;
    while ( 1 )
    {
      if ( *(_DWORD **)(v2 + 260) == a1 )
      {
        v5 = *(_DWORD *)(v2 + 348);
        if ( v5 || *(_DWORD *)(v2 + 352) )
        {
          v6 = dword_612CC;
          v7 = v2 + 344;
          v8 = *(_DWORD *)(dword_612CC + 344);
          v9 = *(_DWORD *)(v8 + 20);
          if ( *(_DWORD *)(v8 + 16) - v9 == v2 )
          {
            *(_DWORD *)(v8 + 16) = v5 + v9;
            v5 = *(_DWORD *)(v2 + 348);
          }
          v10 = v5 == 0;
          if ( v5 )
          {
            v9 = *(_DWORD *)(v6 + 344);
            v8 = *(_DWORD *)(v2 + 352);
          }
          else
          {
            v6 = *(_DWORD *)(v2 + 352);
          }
          if ( v5 )
          {
            v5 += *(_DWORD *)(v9 + 20);
          }
          else
          {
            dword_612CC = v6;
            v8 = v6;
          }
          if ( !v10 )
          {
            *(_DWORD *)(v5 + 8) = v8;
            v8 = *(_DWORD *)(v2 + 352);
          }
          if ( v8 )
            *(_DWORD *)(v8 + *(_DWORD *)(*(_DWORD *)(v6 + 344) + 20) + 4) = *(_DWORD *)(v2 + 348);
          v11 = 3 * ((*(_DWORD *)(*(_DWORD *)(v6 + 344) + 4) - 1) & *(_DWORD *)(v2 + 372));
          v12 = **(_DWORD **)(v6 + 344) + 12 * ((*(_DWORD *)(*(_DWORD *)(v6 + 344) + 4) - 1) & *(_DWORD *)(v2 + 372));
          --*(_DWORD *)(v12 + 4);
          v13 = **(_DWORD **)(v6 + 344);
          v14 = *(_DWORD *)(v13 + 4 * v11);
          if ( v14 == v7 )
          {
            v6 = *(_DWORD *)(v2 + 360);
            *(_DWORD *)(v13 + 4 * v11) = v6;
          }
          v15 = *(_DWORD *)(v2 + 356);
          if ( v14 == v7 )
            v6 = dword_612CC;
          if ( v15 )
            *(_DWORD *)(v15 + 16) = *(_DWORD *)(v2 + 360);
          v16 = *(_DWORD *)(v2 + 360);
          if ( v16 )
            *(_DWORD *)(v16 + 12) = *(_DWORD *)(v2 + 356);
          --*(_DWORD *)(*(_DWORD *)(v6 + 344) + 12);
        }
        else
        {
          free(**(void ***)(dword_612CC + 344));
          free(*(void **)(dword_612CC + 344));
          dword_612CC = 0;
        }
        ++v3;
        sub_152B8((void **)v2);
        if ( !v4 )
          goto LABEL_31;
      }
      else if ( !v4 )
      {
        goto LABEL_31;
      }
      v2 = v4;
      v4 = *(_DWORD *)(v4 + 352);
    }
  }
  v3 = 0;
LABEL_31:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
    sub_B694("clear_pool_work", 7004);
  off_60178();
  if ( v3 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "Cleared %d work items due to stratum disconnect on pool %d", v3, *a1);
    sub_38438(7, s, 0);
  }
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 612C8: using guessed type int dword_612C8;
// 612CC: using guessed type int dword_612CC;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001822C) --------------------------------------------------------
int __fastcall sub_1822C(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r5
  pthread_mutex_t *v4; // r0
  int v5; // r5

  v2 = (pthread_mutex_t *)(a1 + 188);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 188)) )
    sub_B4E4("pool_tclear", 784);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    sub_B694("pool_tclear", 787);
  off_60178();
  return v5;
}
// 60178: using guessed type int (*off_60178)();

//----- (000182A0) --------------------------------------------------------
int __fastcall sub_182A0(_DWORD *a1, int a2)
{
  char *v4; // r1
  int v6; // r2
  int v7; // r1
  int v8; // r3
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r1
  int v24; // r2
  int v25; // r3
  struct timeval v26; // [sp+8h] [bp-810h] BYREF
  struct timeval v27; // [sp+10h] [bp-808h] BYREF
  _DWORD dest[512]; // [sp+18h] [bp-800h] BYREF

  if ( *((_BYTE *)a1 + 704) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf((char *)dest, 0x800u, "Retrieving block template from pool %s", a1[41]);
      goto LABEL_64;
    }
  }
  else if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf((char *)dest, 0x800u, "Testing pool %s", a1[41]);
LABEL_64:
    sub_38438(7, (const char *)dest, 0);
  }
  if ( *((_BYTE *)a1 + 632) )
    goto LABEL_12;
  if ( !off_60078 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      strcpy((char *)dest, "CURL initialisation failed");
      sub_38438(3, (const char *)dest, 0);
      return 0;
    }
    return 0;
  }
  if ( *((_BYTE *)a1 + 99) )
    goto LABEL_8;
  if ( !byte_630C1 )
  {
    *((_BYTE *)a1 + 99) = 0;
    goto LABEL_8;
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
  {
    strcpy((char *)dest, "Probing for GBT support");
    sub_38438(7, (const char *)dest, 0);
    v7 = *((unsigned __int8 *)a1 + 704);
    v8 = (unsigned __int8)byte_630C1;
    *((_BYTE *)a1 + 99) = 0;
    if ( !v7 )
    {
      if ( !*((_BYTE *)a1 + 868) )
      {
        if ( !v8 )
          goto LABEL_8;
        goto LABEL_46;
      }
      if ( !v8 )
        goto LABEL_8;
LABEL_42:
      if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
      {
        strcpy((char *)dest, "GBT coinbase without append found, switching to GBT solo protocol");
        sub_38438(7, (const char *)dest, 0);
      }
      goto LABEL_8;
    }
    if ( !v8 )
      goto LABEL_8;
LABEL_35:
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      goto LABEL_8;
    v9 = "GBT coinbase + append support found, switching to GBT protocol";
    goto LABEL_39;
  }
  v6 = *((unsigned __int8 *)a1 + 704);
  *((_BYTE *)a1 + 99) = 0;
  if ( v6 )
    goto LABEL_35;
  if ( *((_BYTE *)a1 + 868) )
    goto LABEL_42;
LABEL_46:
  if ( byte_632F0 || byte_630C0 )
  {
    v9 = "No GBT coinbase + append support found, using getwork protocol";
LABEL_39:
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v14 = (int *)(v9 + 16);
    dest[0] = v10;
    dest[1] = v11;
    dest[2] = v12;
    dest[3] = v13;
    v15 = *v14;
    v16 = v14[1];
    v17 = v14[2];
    v18 = v14[3];
    v14 += 4;
    dest[4] = v15;
    dest[5] = v16;
    dest[6] = v17;
    dest[7] = v18;
    v19 = *v14;
    v20 = v14[1];
    v21 = v14[2];
    v22 = v14[3];
    v14 += 4;
    dest[8] = v19;
    dest[9] = v20;
    dest[10] = v21;
    dest[11] = v22;
    v23 = v14[1];
    v24 = v14[2];
    v25 = v14[3];
    dest[12] = *v14;
    dest[13] = v23;
    dest[14] = v24;
    LOWORD(dest[15]) = v25;
    BYTE2(dest[15]) = BYTE2(v25);
    sub_38438(7, (const char *)dest, 0);
    goto LABEL_8;
  }
  if ( dword_60964 > 6 )
  {
    v9 = "No GBT coinbase + append support found, using getwork protocol";
    goto LABEL_39;
  }
LABEL_8:
  sub_2B13C(&v26);
  sub_2B13C(&v27);
  v4 = (char *)a1[142];
  if ( v4 && !byte_612D8 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf((char *)dest, 0x800u, "Testing pool %d stratum %s", *a1, (const char *)a1[142]);
      sub_38438(7, (const char *)dest, 0);
      v4 = (char *)a1[142];
    }
    sub_2B358((int)a1, v4);
    if ( sub_2B43C((const char *)a1[142], a1 + 148, (char **)a1 + 144) )
    {
      if ( sub_2C29C(a1) )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf((char *)dest, 0x800u, "Switching pool %d %s to %s", *a1, (const char *)a1[41], (const char *)a1[142]);
          sub_38438(7, (const char *)dest, 0);
        }
        if ( !a1[41] )
          a1[41] = _strdup((const char *)a1[142]);
        goto LABEL_11;
      }
    }
  }
  if ( !sub_2C29C(a1) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf((char *)dest, 0x800u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[41]);
      sub_38438(7, (const char *)dest, 0);
    }
    if ( !a2 && !*((_BYTE *)a1 + 97) && (byte_632F0 || byte_630C0 || dword_60964 > 3) )
    {
      snprintf((char *)dest, 0x800u, "Pool %u slow/down or URL or credentials invalid", *a1);
      sub_38438(4, (const char *)dest, 0);
    }
    return 0;
  }
LABEL_11:
  *((_BYTE *)a1 + 632) = 1;
LABEL_12:
  if ( sub_17E64((int)a1, (_BYTE *)a1 + 634) )
    return *((unsigned __int8 *)a1 + 633);
  if ( sub_2C29C(a1) && sub_2E9B0((pthread_mutex_t *)a1) )
  {
    sub_2C1C4((int)a1);
    byte_64219 = 1;
    if ( pthread_create(a1 + 166, 0, (void *(*)(void *))sub_21AB0, a1) )
    {
      strcpy((char *)dest, "Failed to create stratum sthread");
      sub_38438(3, (const char *)dest, 1);
      sub_16724(1);
    }
    if ( pthread_create(a1 + 167, 0, (void *(*)(void *))sub_1FC10, a1) )
    {
      strcpy((char *)dest, "Failed to create stratum rthread");
      sub_38438(3, (const char *)dest, 1);
      sub_16724(1);
    }
    return 1;
  }
  else
  {
    sub_2C1C4((int)a1);
    sub_1822C((int)a1, (_BYTE *)a1 + 634);
    return 0;
  }
}
// 60078: using guessed type char *off_60078;
// 60964: using guessed type int dword_60964;
// 612D8: using guessed type char byte_612D8;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 64219: using guessed type char byte_64219;

//----- (000189B4) --------------------------------------------------------
int __fastcall sub_189B4(int a1)
{
  int v2; // r1
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(
      s,
      0x800u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_38438(7, s, 1);
  }
  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("inc_hw_errors", 8298);
  v2 = dword_63E44;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 44);
  dword_63E44 = v2 + 1;
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("inc_hw_errors", 8301);
  off_60178();
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63E44: using guessed type int dword_63E44;

//----- (00018AE8) --------------------------------------------------------
int __fastcall sub_18AE8(int a1, int a2)
{
  int v4; // r1
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
  {
    snprintf(
      s,
      0x800u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_38438(3, s, 0);
  }
  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("inc_hw_errors_with_diff", 8311);
  v4 = dword_63E44;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 44) += a2;
  dword_63E44 = v4 + a2;
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("inc_hw_errors_with_diff", 8314);
  off_60178();
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 63E44: using guessed type int dword_63E44;

//----- (00018C10) --------------------------------------------------------
int __fastcall sub_18C10(int a1, unsigned int a2)
{
  __time_t v5; // r4
  signed int v6; // r1
  int v7; // r4
  struct timeval v9; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  sub_2B13C(&v9);
  v5 = a2 / 0x3E8 + v9.tv_sec;
  v6 = 1000 * a2 - 1000000 * (a2 / 0x3E8) + v9.tv_usec;
  if ( v6 > 999999 )
  {
    ++v5;
    v6 -= 1000000;
  }
  abstime.tv_sec = v5;
  abstime.tv_nsec = 1000 * v6;
  if ( pthread_mutex_lock(&stru_63BCC) )
    sub_B4E4("restart_wait", 5227);
  if ( *(_BYTE *)(a1 + 62) )
    v7 = 0;
  else
    v7 = pthread_cond_timedwait(&cond, &stru_63BCC, &abstime);
  if ( pthread_mutex_unlock(&stru_63BCC) )
    sub_B694("restart_wait", 5232);
  off_60178();
  return v7;
}
// 60178: using guessed type int (*off_60178)();

//----- (00018D10) --------------------------------------------------------
int __fastcall sub_18D10(int a1, int a2)
{
  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("inc_dev_status", 8323);
  dword_63E48 = a1;
  dword_640C0 = a2;
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("inc_dev_status", 8326);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();
// 63E48: using guessed type int dword_63E48;
// 640C0: using guessed type int dword_640C0;

//----- (00018D90) --------------------------------------------------------
int *__fastcall sub_18D90(int a1)
{
  _DWORD *v2; // r4
  int v3; // r6
  _DWORD *v4; // r5
  double v5; // d8
  int v6; // r2
  int **v7; // r3
  int v8; // r1
  int *v9; // r0
  bool v10; // zf
  int v11; // r2
  int v12; // r1
  int v13; // r1
  int v14; // r2
  int v15; // r2
  int v16; // r0
  int *result; // r0
  double v18; // d16
  double v19; // d17
  __int64 v20; // r2
  void **v21; // r11
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_612DC) )
    sub_B4E4("clear_stratum_shares", 6964);
  v2 = (_DWORD *)dword_612F4;
  if ( dword_612F4 )
  {
    v3 = 0;
    v4 = *(_DWORD **)(dword_612F4 + 8);
    v5 = 0.0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v2[9] + 260) == a1 )
      {
        v6 = v2[1];
        if ( v6 || v2[2] )
        {
          v7 = (int **)dword_612F4;
          v8 = *(_DWORD *)dword_612F4;
          v9 = *(int **)(*(_DWORD *)dword_612F4 + 20);
          if ( (_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_612F4 + 16) - (_DWORD)v9) == v2 )
          {
            *(_DWORD *)(v8 + 16) = (char *)v9 + v6;
            v6 = v2[1];
          }
          v10 = v6 == 0;
          if ( v6 )
          {
            v9 = *v7;
            v8 = v2[2];
          }
          else
          {
            v6 = v2[2];
          }
          if ( v10 )
          {
            v7 = (int **)v6;
            dword_612F4 = v6;
          }
          else
          {
            v6 += v9[5];
          }
          if ( !v10 )
          {
            *(_DWORD *)(v6 + 8) = v8;
            v6 = v2[2];
          }
          if ( v6 )
            *(_DWORD *)(v6 + (*v7)[5] + 4) = v2[1];
          v11 = 3 * (((*v7)[1] - 1) & v2[7]);
          v12 = **v7 + 12 * (((*v7)[1] - 1) & v2[7]);
          --*(_DWORD *)(v12 + 4);
          v13 = **v7;
          if ( *(_DWORD **)(v13 + 4 * v11) == v2 )
            *(_DWORD *)(v13 + 4 * v11) = v2[4];
          v14 = v2[3];
          if ( v14 )
            *(_DWORD *)(v14 + 16) = v2[4];
          v15 = v2[4];
          if ( v15 )
            *(_DWORD *)(v15 + 12) = v2[3];
          --(*v7)[3];
        }
        else
        {
          v21 = (void **)dword_612F4;
          free(**(void ***)dword_612F4);
          free(*v21);
          dword_612F4 = 0;
        }
        v16 = v2[9];
        v5 = v5 + *(double *)(v16 + 376);
        sub_152B8((void **)v16);
        v2[9] = 0;
        ++v3;
        --*(_DWORD *)(a1 + 700);
        free(v2);
        if ( !v4 )
          goto LABEL_28;
      }
      else if ( !v4 )
      {
        goto LABEL_28;
      }
      v2 = v4;
      v4 = (_DWORD *)v4[2];
    }
  }
  v3 = 0;
  v5 = 0.0;
LABEL_28:
  if ( pthread_mutex_unlock(&stru_612DC) )
    sub_B694("clear_stratum_shares", 6977);
  result = (int *)off_60178();
  if ( v3 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      snprintf(s, 0x800u, "Lost %d shares due to stratum disconnect on pool %d", v3, *(_DWORD *)a1);
      sub_38438(4, s, 0);
    }
    v18 = *(double *)(a1 + 88) + v5;
    v19 = dbl_639D0;
    result = &dword_64220;
    v20 = *(_QWORD *)&dword_64220;
    *(_DWORD *)(a1 + 120) += v3;
    *(_QWORD *)&dword_64220 = v20 + v3;
    *(double *)(a1 + 88) = v18;
    dbl_639D0 = v19 + v5;
  }
  return result;
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 612F4: using guessed type int dword_612F4;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 639D0: using guessed type double dbl_639D0;
// 64220: using guessed type int dword_64220;

//----- (00019060) --------------------------------------------------------
int sub_19060()
{
  pthread_mutex_trylock(&stru_63D48);
  if ( !byte_612F8 )
  {
    if ( !pthread_mutex_unlock(&stru_63D48) )
      return off_60178();
LABEL_5:
    sub_B694("unlock_curses", 2928);
  }
  byte_6007C = 0;
  byte_612F8 = 0;
  leaveok((WINDOW *)dword_639D8, 0);
  leaveok((WINDOW *)dword_63D60, 0);
  leaveok((WINDOW *)dword_64230, 0);
  nocbreak();
  echo();
  delwin((WINDOW *)dword_639D8);
  delwin((WINDOW *)dword_63D60);
  delwin((WINDOW *)dword_64230);
  endwin();
  if ( pthread_mutex_unlock(&stru_63D48) )
    goto LABEL_5;
  return off_60178();
}
// 6007C: using guessed type char byte_6007C;
// 60178: using guessed type int (*off_60178)();
// 612F8: using guessed type char byte_612F8;
// 639D8: using guessed type int dword_639D8;
// 63D60: using guessed type int dword_63D60;
// 64230: using guessed type int dword_64230;

//----- (00019140) --------------------------------------------------------
int sub_19140()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_63D48) )
    sub_B4E4("lock_curses", 2933);
  v0 = (unsigned __int8)byte_612F8;
  if ( byte_612F8 )
    return (unsigned __int8)byte_612F8;
  if ( pthread_mutex_unlock(&stru_63D48) )
    sub_B694("unlock_curses", 2928);
  off_60178();
  return v0;
}
// B4E4: using guessed type void __fastcall __noreturn sub_B4E4(_DWORD, _DWORD);
// B694: using guessed type void __fastcall __noreturn sub_B694(_DWORD, _DWORD);
// 60178: using guessed type int (*off_60178)();
// 612F8: using guessed type char byte_612F8;

//----- (000191C4) --------------------------------------------------------
void sub_191C4()
{
  int v0; // r2
  int v1; // r3
  int v2; // r1
  int v3; // r3
  int v4; // r2

  if ( byte_6007C && sub_19140() )
  {
    werase((WINDOW *)stdscr);
    if ( dword_63D60 )
      v0 = *(__int16 *)(dword_63D60 + 6);
    else
      v0 = -1;
    v1 = dword_612FC;
    if ( dword_63D60 )
      ++v0;
    if ( LINES - 1 <= dword_612FC )
      v1 = LINES - 2;
    dword_61300 = v1;
    dword_61304 = v1;
    wresize((WINDOW *)dword_63D60, v1, v0);
    v3 = dword_64230;
    if ( dword_64230 )
      v2 = *(__int16 *)(dword_64230 + 4);
    else
      v3 = -1;
    if ( dword_64230 )
      v4 = *(__int16 *)(v3 + 6);
    else
      v4 = v3;
    if ( dword_64230 )
    {
      v3 = v2 + 1;
      ++v4;
    }
    wresize((WINDOW *)dword_639D8, v3 - dword_61304, v4);
    mvwin((WINDOW *)dword_639D8, dword_61304, 0);
    if ( pthread_mutex_unlock(&stru_63D48) )
      sub_B694("unlock_curses", 2928);
    off_60178();
  }
}
// 19258: variable 'v2' is possibly undefined
// 6007C: using guessed type char byte_6007C;
// 60178: using guessed type int (*off_60178)();
// 60E70: using guessed type int stdscr;
// 60E74: using guessed type int LINES;
// 612FC: using guessed type int dword_612FC;
// 61300: using guessed type int dword_61300;
// 61304: using guessed type int dword_61304;
// 639D8: using guessed type int dword_639D8;
// 63D60: using guessed type int dword_63D60;
// 64230: using guessed type int dword_64230;

//----- (000192D4) --------------------------------------------------------
void __fastcall sub_192D4(int a1, int a2)
{
  int v2; // r2

  if ( byte_63EE0 )
  {
    v2 = dword_61308;
  }
  else
  {
    v2 = dword_6130C;
    a2 = dword_61308;
  }
  if ( !byte_63EE0 )
    v2 += a2;
  dword_612FC = v2 + 1;
  dword_61304 = v2 + 2;
  if ( pthread_mutex_unlock(&stru_63D48) )
    sub_B694("unlock_curses", 2928);
  off_60178();
  sub_191C4();
}
// 60178: using guessed type int (*off_60178)();
// 612FC: using guessed type int dword_612FC;
// 61304: using guessed type int dword_61304;
// 61308: using guessed type int dword_61308;
// 6130C: using guessed type int dword_6130C;
// 63EE0: using guessed type char byte_63EE0;

//----- (00019350) --------------------------------------------------------
int sub_19350()
{
  int result; // r0
  int v1; // r2

  result = sub_19140();
  if ( result )
  {
    if ( dword_639D8 )
      v1 = *(__int16 *)(dword_639D8 + 4);
    else
      v1 = -1;
    if ( dword_639D8 )
      ++v1;
    wtouchln((WINDOW *)dword_639D8, 0, v1, 1);
    wrefresh((WINDOW *)dword_639D8);
    if ( pthread_mutex_unlock(&stru_63D48) )
      sub_B694("unlock_curses", 2928);
    return off_60178();
  }
  return result;
}
// 60178: using guessed type int (*off_60178)();
// 639D8: using guessed type int dword_639D8;

//----- (000193CC) --------------------------------------------------------
int sub_193CC()
{
  int result; // r0

  result = sub_19140();
  if ( result )
  {
    werase((WINDOW *)stdscr);
    wclear((WINDOW *)dword_639D8);
    if ( pthread_mutex_unlock(&stru_63D48) )
      sub_B694("unlock_curses", 2928);
    return off_60178();
  }
  return result;
}
// 60178: using guessed type int (*off_60178)();
// 60E70: using guessed type int stdscr;
// 639D8: using guessed type int dword_639D8;

//----- (00019438) --------------------------------------------------------
int __fastcall sub_19438(int a1, const char *a2, const char *a3)
{
  int result; // r0
  _BOOL4 v7; // r4
  int v8; // r2

  result = sub_19140();
  if ( !result )
    return result;
  v7 = (unsigned int)(a1 - 3) <= 1;
  if ( byte_64068 )
  {
    if ( v7 )
    {
      wprintw((WINDOW *)dword_639D8, "%s%s\n", a2, a3);
LABEL_5:
      if ( dword_639D8 )
        v8 = *(__int16 *)(dword_639D8 + 4);
      else
        v8 = -1;
      if ( dword_639D8 )
        ++v8;
      wtouchln((WINDOW *)dword_639D8, 0, v8, 1);
      wrefresh((WINDOW *)dword_639D8);
    }
  }
  else
  {
    wprintw((WINDOW *)dword_639D8, "%s%s\n", a2, a3);
    if ( v7 )
      goto LABEL_5;
  }
  if ( pthread_mutex_unlock(&stru_63D48) )
    sub_B694("unlock_curses", 2928);
  off_60178();
  return 1;
}
// B694: using guessed type void __fastcall __noreturn sub_B694(_DWORD, _DWORD);
// 60178: using guessed type int (*off_60178)();
// 639D8: using guessed type int dword_639D8;
// 64068: using guessed type char byte_64068;

//----- (0001952C) --------------------------------------------------------
int __fastcall sub_1952C(const char *a1)
{
  int result; // r0

  result = sub_19140();
  if ( result )
  {
    wprintw((WINDOW *)dword_639D8, "%s", a1);
    if ( pthread_mutex_unlock(&stru_63D48) )
      sub_B694("unlock_curses", 2928);
    return off_60178();
  }
  return result;
}
// 60178: using guessed type int (*off_60178)();
// 639D8: using guessed type int dword_639D8;

//----- (00019598) --------------------------------------------------------
int __fastcall sub_19598(pthread_rwlock_t *a1, const char *a2, int a3)
{
  if ( pthread_rwlock_unlock(a1) )
    sub_B700(a2, a3);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();

//----- (000195D4) --------------------------------------------------------
int __fastcall sub_195D4(int a1)
{
  _DWORD *v2; // r6
  int v3; // r7
  int v4; // r12
  int *v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // t1
  int v9; // r2
  bool v10; // cc
  int v11; // r2
  char v12; // r3
  int v13; // r3
  int v14; // r4
  int v15; // r0
  int v16; // r0
  int v17; // r4
  int v19; // r3
  int v20; // r2
  int v21; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_63FB0) )
    sub_B4E4("switch_pools", 5079);
  if ( pthread_rwlock_wrlock(&stru_63FC8) )
    sub_B550("switch_pools", 5079);
  v2 = (_DWORD *)dword_61310;
  v3 = *(_DWORD *)dword_61310;
  if ( a1 && (v4 = *(_DWORD *)(a1 + 4)) != 0 )
  {
    if ( dword_63740 > 0 )
    {
      v5 = (int *)dword_639E0;
      v6 = dword_639E0 + 4 * dword_63740;
      while ( 1 )
      {
        v8 = *v5++;
        v7 = v8;
        v9 = *(_DWORD *)(v8 + 4);
        v10 = v9 < v4;
        v11 = v9 + 1;
        if ( v10 )
          *(_DWORD *)(v7 + 4) = v11;
        if ( v5 == (int *)v6 )
          break;
        v4 = *(_DWORD *)(a1 + 4);
      }
    }
    *(_DWORD *)(a1 + 4) = 0;
    v12 = dword_611AC;
    if ( (unsigned int)dword_611AC > 4 )
      goto LABEL_37;
  }
  else
  {
    v12 = dword_611AC;
    if ( (unsigned int)dword_611AC > 4 )
      goto LABEL_37;
  }
  v13 = 1 << v12;
  if ( (v13 & 0x19) != 0 )
  {
    if ( dword_63740 > 0 )
    {
      v14 = 0;
      while ( 1 )
      {
        v15 = v14++;
        v16 = sub_11B90(v15);
        if ( !*(_BYTE *)(v16 + 97) && *(_DWORD *)(v16 + 100) == 1 )
          break;
        if ( dword_63740 <= v14 )
          goto LABEL_37;
      }
      v17 = *(_DWORD *)(dword_639E0 + 4 * *(_DWORD *)v16);
      goto LABEL_21;
    }
LABEL_37:
    v17 = *(_DWORD *)(dword_639E0 + 4 * v3);
    goto LABEL_21;
  }
  if ( (v13 & 6) == 0 )
    goto LABEL_37;
  if ( a1 && !*(_BYTE *)(a1 + 97) )
  {
    v17 = *(_DWORD *)(dword_639E0 + 4 * *(_DWORD *)a1);
    goto LABEL_21;
  }
  if ( dword_63740 <= 1 )
    goto LABEL_37;
  v19 = v3;
  v20 = 1;
  while ( 1 )
  {
    ++v19;
    ++v20;
    v21 = 4 * v19;
    if ( v19 >= dword_63740 )
    {
      v19 = 0;
      v21 = 0;
    }
    v17 = *(_DWORD *)(dword_639E0 + v21);
    if ( !*(_BYTE *)(v17 + 97) && *(_DWORD *)(v17 + 100) == 1 )
      break;
    if ( v20 == dword_63740 )
    {
      v17 = *(_DWORD *)(dword_639E0 + 4 * v3);
      break;
    }
  }
LABEL_21:
  dword_61310 = v17;
  if ( pthread_rwlock_unlock(&stru_63FC8) )
    sub_B700("switch_pools", 5141);
  if ( pthread_mutex_unlock(&stru_63FB0) )
    sub_B694("switch_pools", 5141);
  off_60178();
  if ( byte_63BC5 )
    sub_17E64(v17, (_BYTE *)(v17 + 98));
  if ( v2 != (_DWORD *)v17 && dword_611AC != 3 && dword_611AC != 4 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      snprintf(s, 0x800u, "Switching to pool %d %s", *(_DWORD *)v17, *(const char **)(v17 + 164));
      sub_38438(4, s, 0);
    }
    sub_17FC4(v2);
  }
  if ( pthread_mutex_lock(&stru_61314) )
    sub_B4E4("switch_pools", 5156);
  pthread_cond_broadcast(&stru_61330);
  if ( pthread_mutex_unlock(&stru_61314) )
    sub_B694("switch_pools", 5158);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 611AC: using guessed type int dword_611AC;
// 61310: using guessed type int dword_61310;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;
// 63BC5: using guessed type char byte_63BC5;

//----- (00019930) --------------------------------------------------------
int __fastcall sub_19930(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B550("add_queued", 8829);
  sub_160B4((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_B700("add_queued", 8831);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();

//----- (000199A4) --------------------------------------------------------
void __fastcall sub_199A4(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B550("work_completed", 8973);
  sub_165C0((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_B700("work_completed", 8975);
  off_60178();
  sub_152B8(a2);
}
// 60178: using guessed type int (*off_60178)();

//----- (00019A20) --------------------------------------------------------
int __fastcall sub_19A20(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r8
  int lock; // r5
  int i; // r4
  struct timeval v6; // [sp+0h] [bp-8h] BYREF

  v1 = a1 + 10;
  sub_2B13C(&v6);
  if ( pthread_rwlock_wrlock(v1) )
    sub_B550("age_queued_work", 8954);
  lock = a1[11].__lock;
  if ( lock )
  {
    for ( i = *(_DWORD *)(lock + 352); ; i = *(_DWORD *)(i + 352) )
    {
      sub_2B314();
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(v1) )
    sub_B700("age_queued_work", 8964);
  off_60178();
  return 0;
}
// 60178: using guessed type int (*off_60178)();

//----- (00019B0C) --------------------------------------------------------
_DWORD *__fastcall sub_19B0C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r5
  _DWORD *v11; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B550("take_queued_work_bymidstate", 8986);
  v11 = (_DWORD *)sub_16500(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
    sub_165C0((int)a1, v11);
  if ( pthread_rwlock_unlock(v6) )
    sub_B700("take_queued_work_bymidstate", 8990);
  off_60178();
  return v11;
}
// 60178: using guessed type int (*off_60178)();

//----- (00019BC0) --------------------------------------------------------
int sub_19BC0()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_63FB0) )
    sub_B4E4("total_work_inc", 2271);
  if ( pthread_rwlock_wrlock(&stru_63FC8) )
    sub_B550("total_work_inc", 2271);
  v0 = dword_61360++;
  if ( pthread_rwlock_unlock(&stru_63FC8) )
    sub_B700("total_work_inc", 2273);
  if ( pthread_mutex_unlock(&stru_63FB0) )
    sub_B694("total_work_inc", 2273);
  off_60178();
  return v0;
}
// 60178: using guessed type int (*off_60178)();
// 61360: using guessed type int dword_61360;

//----- (00019C7C) --------------------------------------------------------
int __fastcall sub_19C7C(int a1)
{
  bool v2; // zf
  unsigned int v3; // r0
  int v4; // r2
  _BYTE *v5; // r5
  int result; // r0
  unsigned int v7[513]; // [sp+0h] [bp-804h] BYREF

  v2 = byte_630C1 == 0;
  v3 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v4 = dword_63A70 + 1;
  ++*(_DWORD *)(a1 + 240);
  *(_DWORD *)(a1 + 68) = v3;
  *(_DWORD *)(a1 + 248) = 0;
  dword_63A70 = v4;
  if ( !v2 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy((char *)v7, "Successfully rolled work");
    sub_38438(7, (const char *)v7, 0);
  }
  v5 = *(_BYTE **)(a1 + 308);
  if ( v5 )
  {
    sub_295B8(v7, *(unsigned __int8 **)(a1 + 308), 4);
    v7[0] = bswap32(bswap32(v7[0]) + 1);
    sub_29460(v5, (char *)v7, 4);
  }
  result = sub_19BC0();
  *(_DWORD *)(a1 + 340) = result;
  return result;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63A70: using guessed type int dword_63A70;

//----- (00019DA0) --------------------------------------------------------
_DWORD *sub_19DA0()
{
  _DWORD *v0; // r4
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = calloc(1u, 0x1E0u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc work in make_work");
    sub_38438(3, v2, 1);
    sub_16724(1);
  }
  v0[85] = sub_19BC0();
  return v0;
}

//----- (00019E18) --------------------------------------------------------
_DWORD *__fastcall sub_19E18(int a1, int a2)
{
  _DWORD *v4; // r4

  v4 = sub_19DA0();
  sub_151BC((int)v4, a1, a2);
  return v4;
}

//----- (00019E40) --------------------------------------------------------
_DWORD *__fastcall sub_19E40(int a1)
{
  _DWORD *v1; // r4
  int v3; // r2

  v1 = sub_19E18(a1, 0);
  *((_BYTE *)v1 + 273) = 1;
  sub_2B13C((struct timeval *)v1 + 52);
  v3 = v1[66] - 1;
  *((_BYTE *)v1 + 280) = 0;
  v1[66] = v3;
  *((_BYTE *)v1 + 282) = 0;
  return v1;
}

//----- (00019E80) --------------------------------------------------------
unsigned __int64 __fastcall sub_19E80(int a1)
{
  double v1; // d9
  __int64 v3; // r0
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d8
  double v8; // r0
  double v9; // d8
  double v10; // r0
  double v11; // d0
  int v12; // r1
  unsigned __int64 v13; // r4
  int v14; // r7
  int v15; // r1
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v1 = 1.7668201e72;
  v3 = *(_QWORD *)(a1 + 216);
  if ( !byte_63DF9 )
    v1 = 2.69595353e67;
  LODWORD(v4) = sub_493C8(v3);
  v5 = v4 * 6.27710174e57;
  LODWORD(v6) = sub_493C8(*(_QWORD *)(a1 + 208));
  v7 = v5 + v6 * 3.40282367e38;
  LODWORD(v8) = sub_493C8(*(_QWORD *)(a1 + 200));
  v9 = v7 + v8 * 1.84467441e19;
  LODWORD(v10) = sub_493C8(*(_QWORD *)(a1 + 192));
  v11 = v9 + v10;
  if ( v9 + v10 == 0.0 )
    v11 = 0.0;
  round();
  LODWORD(v13) = sub_494C0(v1 / v11);
  HIDWORD(v13) = v12;
  if ( pthread_mutex_lock(&stru_63FB0) )
    sub_B4E4("share_diff", 4968);
  if ( pthread_rwlock_wrlock(&stru_63FC8) )
    sub_B550("share_diff", 4968);
  if ( qword_611C8 < v13 )
  {
    v14 = 1;
    qword_611C8 = v13;
    sub_11130(v13, (char *)&dword_60064, 8u, 0);
  }
  else
  {
    v14 = 0;
  }
  v15 = *(_DWORD *)(a1 + 260);
  if ( *(_QWORD *)(v15 + 368) < v13 )
    *(_QWORD *)(v15 + 368) = v13;
  if ( pthread_rwlock_unlock(&stru_63FC8) )
    sub_B700("share_diff", 4977);
  if ( pthread_mutex_unlock(&stru_63FB0) )
    sub_B694("share_diff", 4977);
  off_60178();
  if ( v14 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "New best share: %s", (const char *)&dword_60064);
    sub_38438(7, s, 0);
  }
  return v13;
}
// 19EC0: variable 'v4' is possibly undefined
// 19ED4: variable 'v6' is possibly undefined
// 19EE8: variable 'v8' is possibly undefined
// 19EF8: variable 'v10' is possibly undefined
// 19F20: variable 'v12' is possibly undefined
// AEAC: using guessed type int round(void);
// 60064: using guessed type int dword_60064;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 611C8: using guessed type __int64 qword_611C8;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63DF9: using guessed type char byte_63DF9;

//----- (0001A0F8) --------------------------------------------------------
int __fastcall sub_1A0F8(int a1, int a2)
{
  double v2; // d16
  double v5; // d8
  unsigned __int64 v6; // r0
  bool v7; // zf
  double v8; // r0
  double v9; // d8
  double v10; // r0
  __int64 v11; // r0
  int v12; // r6
  double v13; // r0
  __int64 v14; // r0
  int v15; // r6
  double v16; // r0
  __int64 v17; // r0
  int v18; // r4
  int v20; // r2
  int v21; // r0
  int v22; // r12
  int v23; // r0
  char v24[2052]; // [sp+0h] [bp-804h] BYREF

  v5 = dbl_60080;
  v6 = sub_19E80(a2);
  v7 = byte_63DF9 == 0;
  if ( byte_63DF9 )
    v2 = 65536.0;
  *(_QWORD *)(a2 + 232) = v6;
  if ( !v7 )
    v5 = v5 * v2;
  LODWORD(v8) = sub_493C8(v6);
  if ( v5 <= v8 )
  {
    v20 = *(_DWORD *)(a2 + 260);
    v21 = (unsigned __int8)byte_632F0;
    v22 = dword_63E58;
    *(_BYTE *)(a2 + 283) = 1;
    v7 = v21 == 0;
    v23 = *(_DWORD *)(v20 + 32);
    dword_63E58 = v22 + 1;
    *(_DWORD *)(v20 + 32) = v23 + 1;
    *(_BYTE *)(a2 + 282) = 1;
    if ( !v7 || byte_630C0 || dword_60964 > 4 )
    {
      snprintf(v24, 0x800u, "Found block for pool %d!", **(_DWORD **)(a2 + 260));
      sub_38438(5, v24, 0);
    }
  }
  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("update_work_stats", 8387);
  v9 = *(double *)(a2 + 224);
  LODWORD(v10) = sub_493DC(*(__int64 *)&dword_636A8);
  LODWORD(v11) = sub_49488(v10 + v9);
  v12 = *(_DWORD *)(a1 + 36);
  *(_QWORD *)&dword_636A8 = v11;
  LODWORD(v13) = sub_493DC(*(_QWORD *)(v12 + 192));
  LODWORD(v14) = sub_49488(v9 + v13);
  *(_QWORD *)(v12 + 192) = v14;
  v15 = *(_DWORD *)(a2 + 260);
  LODWORD(v16) = sub_493DC(*(_QWORD *)(v15 + 40));
  LODWORD(v17) = sub_49488(v16 + *(double *)(a2 + 224));
  *(_QWORD *)(v15 + 40) = v17;
  v18 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v18 + 232) = time(0);
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("update_work_stats", 8392);
  return off_60178();
}
// 1A134: variable 'v2' is possibly undefined
// 1A148: variable 'v8' is possibly undefined
// 1A174: variable 'v10' is possibly undefined
// 1A180: variable 'v11' is possibly undefined
// 1A194: variable 'v13' is possibly undefined
// 1A19C: variable 'v14' is possibly undefined
// 1A1B8: variable 'v16' is possibly undefined
// 1A1C0: variable 'v17' is possibly undefined
// 60080: using guessed type double dbl_60080;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 636A8: using guessed type int dword_636A8;
// 63DF9: using guessed type char byte_63DF9;
// 63E58: using guessed type int dword_63E58;

//----- (0001A2DC) --------------------------------------------------------
int __fastcall sub_1A2DC(int a1, int a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  int result; // r0
  char v9[2052]; // [sp+0h] [bp-804h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  if ( sub_15FDC(a2, a3) )
  {
    sub_1A0F8(a1, a2);
    if ( sub_2A898((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160)) )
    {
      return 1;
    }
    else
    {
      if ( v5 )
        *v5 = 1;
      result = (unsigned __int8)byte_630C1;
      if ( byte_630C1 )
      {
        if ( byte_632F0 || (result = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6 )
        {
          strcpy(v9, "Share above target");
          sub_38438(7, v9, 0);
          return 0;
        }
      }
    }
  }
  else
  {
    sub_189B4(a1);
    return 0;
  }
  return result;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001A3E0) --------------------------------------------------------
void __fastcall sub_1A3E0(pthread_rwlock_t *a1)
{
  void **nr_readers; // r5
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  if ( a1 && !pthread_rwlock_trywrlock(a1 + 10) )
  {
    nr_readers = (void **)a1[11].__nr_readers;
    a1[11].__nr_readers = 0;
    if ( pthread_rwlock_unlock(a1 + 10) )
      sub_B700("flush_queue", 9008);
    off_60178();
    if ( nr_readers )
    {
      sub_152B8(nr_readers);
      if ( byte_630C1 )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
        {
          strcpy(v3, "Discarded queued work item");
          sub_38438(7, v3, 0);
        }
      }
    }
  }
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001A4EC) --------------------------------------------------------
int __fastcall sub_1A4EC(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_rdlock(a1);
  if ( result )
    sub_B76C(a2, a3);
  return result;
}

//----- (0001A514) --------------------------------------------------------
int __fastcall sub_1A514(int a1, int a2)
{
  pthread_mutex_t *v2; // r11
  size_t v5; // r2
  void *v6; // r0
  __int64 v7; // r4
  int v8; // r1
  int v9; // r5
  int v10; // r5
  int *v11; // r4
  int v12; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r3
  int v16; // r1
  int v17; // r2
  int v18; // r12
  int i; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r0
  int v24; // r2
  int v25; // r3
  time_t v26; // r0
  int v27; // r2
  char *v29; // r9
  const char *v30; // r0
  char *v31; // r6
  __int64 src; // [sp+10h] [bp-86Ch] BYREF
  int v33; // [sp+18h] [bp-864h] BYREF
  int v34; // [sp+1Ch] [bp-860h]
  int v35; // [sp+20h] [bp-85Ch]
  int v36; // [sp+24h] [bp-858h]
  int v37; // [sp+28h] [bp-854h]
  int v38; // [sp+2Ch] [bp-850h]
  int v39; // [sp+30h] [bp-84Ch]
  int v40; // [sp+34h] [bp-848h]
  int v41; // [sp+38h] [bp-844h] BYREF
  int v42; // [sp+3Ch] [bp-840h]
  int v43; // [sp+40h] [bp-83Ch]
  int v44; // [sp+44h] [bp-838h]
  int v45; // [sp+48h] [bp-834h]
  int v46; // [sp+4Ch] [bp-830h]
  int v47; // [sp+50h] [bp-82Ch]
  int v48; // [sp+54h] [bp-828h]
  int v49; // [sp+58h] [bp-824h]
  int v50; // [sp+5Ch] [bp-820h]
  int v51; // [sp+60h] [bp-81Ch]
  int v52; // [sp+64h] [bp-818h]
  int v53; // [sp+68h] [bp-814h]
  int v54; // [sp+6Ch] [bp-810h]
  int v55; // [sp+70h] [bp-80Ch]
  int v56; // [sp+74h] [bp-808h]
  char s[2052]; // [sp+78h] [bp-804h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
    sub_B4E4("gen_stratum_work", 7928);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 236)) )
    sub_B550("gen_stratum_work", 7928);
  v5 = *(_DWORD *)(a1 + 624);
  v6 = (void *)(*(_DWORD *)(a1 + 1536) + *(_DWORD *)(a1 + 1544));
  src = *(_QWORD *)(a1 + 616);
  memcpy(v6, &src, v5);
  v7 = *(_QWORD *)(a1 + 616);
  *(_QWORD *)(a2 + 296) = v7;
  v8 = *(_DWORD *)(a1 + 624);
  *(_QWORD *)(a1 + 616) = v7 + 1;
  *(_DWORD *)(a2 + 304) = v8;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
    sub_B700("gen_stratum_work", 7938);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 236)) )
    sub_B76C("gen_stratum_work", 7938);
  if ( pthread_mutex_unlock(v2) )
    sub_B694("gen_stratum_work", 7938);
  sub_303DC(*(const void **)(a1 + 1536), *(_DWORD *)(a1 + 1540), (int)s);
  sub_303DC(s, 0x20u, (int)&v33);
  v9 = *(_DWORD *)(a1 + 1676);
  v41 = v33;
  v42 = v34;
  v43 = v35;
  v44 = v36;
  v45 = v37;
  v46 = v38;
  v47 = v39;
  v48 = v40;
  if ( v9 > 0 )
  {
    v10 = 0;
    do
    {
      v11 = *(int **)(*(_DWORD *)(a1 + 644) + 4 * v10++);
      v12 = v11[1];
      v13 = v11[2];
      v14 = v11[3];
      v49 = *v11;
      v50 = v12;
      v51 = v13;
      v52 = v14;
      v15 = v11[7];
      v16 = v11[5];
      v17 = v11[6];
      v53 = v11[4];
      v54 = v16;
      v55 = v17;
      v56 = v15;
      sub_303DC(&v41, 0x40u, (int)s);
      sub_303DC(s, 0x20u, (int)&v33);
      v18 = *(_DWORD *)(a1 + 1676);
      v41 = v33;
      v42 = v34;
      v43 = v35;
      v44 = v36;
      v45 = v37;
      v46 = v38;
      v47 = v39;
      v48 = v40;
    }
    while ( v18 > v10 );
  }
  for ( i = 0; i != 32; i += 4 )
    *(int *)((char *)&v33 + i) = bswap32(*(int *)((char *)&v41 + i));
  memcpy((void *)a2, (const void *)(a1 + 1548), 0x70u);
  v20 = v34;
  v21 = v35;
  v22 = v36;
  *(_DWORD *)(a2 + 36) = v33;
  *(_DWORD *)(a2 + 40) = v20;
  *(_DWORD *)(a2 + 44) = v21;
  *(_DWORD *)(a2 + 48) = v22;
  v23 = v37;
  v24 = v39;
  v25 = v40;
  *(_DWORD *)(a2 + 56) = v38;
  *(_DWORD *)(a2 + 52) = v23;
  *(_DWORD *)(a2 + 60) = v24;
  *(_DWORD *)(a2 + 64) = v25;
  *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 1784);
  *(_DWORD *)(a2 + 288) = _strdup(*(const char **)(a1 + 640));
  *(_DWORD *)(a2 + 320) = _strdup(*(const char **)(a1 + 604));
  *(_DWORD *)(a2 + 308) = _strdup((const char *)(a1 + 1772));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 236)) )
    sub_B700("gen_stratum_work", 7965);
  off_60178();
  if ( byte_630C1 )
  {
    v29 = sub_294B8(a2, 112);
    v30 = sub_294B8((int)&v33, 32);
    v31 = (char *)v30;
    if ( byte_630C1 )
    {
      if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
        goto LABEL_28;
      snprintf(s, 0x800u, "Generated stratum merkle %s", v30);
      sub_38438(7, s, 0);
      if ( !byte_630C1 )
        goto LABEL_27;
      if ( !byte_632F0 && !byte_630C0 )
      {
LABEL_28:
        if ( dword_60964 <= 6 )
          goto LABEL_29;
      }
      snprintf(s, 0x800u, "Generated stratum header %s", v29);
      sub_38438(7, s, 0);
      if ( byte_630C1 )
      {
        if ( byte_632F0 || byte_630C0 )
        {
LABEL_26:
          snprintf(
            s,
            0x800u,
            "Work job_id %s nonce2 %llu ntime %s",
            *(const char **)(a2 + 288),
            *(_QWORD *)(a2 + 296),
            *(const char **)(a2 + 308));
          sub_38438(7, s, 0);
          goto LABEL_27;
        }
LABEL_29:
        if ( dword_60964 <= 6 )
          goto LABEL_27;
        goto LABEL_26;
      }
    }
LABEL_27:
    free(v29);
    free(v31);
  }
  sub_117F4(a2);
  sub_15D7C(a2 + 160);
  ++dword_63A70;
  if ( time(0) - dword_61364 > 5 )
  {
    v26 = time(0);
    dword_61368 = dword_63A70;
    dword_61364 = v26;
  }
  v27 = dword_6136C;
  *(_DWORD *)(a2 + 260) = a1;
  *(_BYTE *)(a2 + 284) = 1;
  *(_DWORD *)(a2 + 336) = v27;
  *(_DWORD *)(a2 + 248) = 0;
  *(_BYTE *)(a2 + 280) = 0;
  *(_BYTE *)(a2 + 440) = 83;
  *(_DWORD *)(a2 + 244) = 60;
  sub_113C4(a2);
  return sub_2B13C((struct timeval *)(a2 + 264));
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 61364: using guessed type int dword_61364;
// 61368: using guessed type int dword_61368;
// 6136C: using guessed type int dword_6136C;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63A70: using guessed type int dword_63A70;

//----- (0001A9F0) --------------------------------------------------------
_DWORD *__fastcall sub_1A9F0(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r0
  _DWORD *v12; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B76C("clone_queued_work_bymidstate", 8884);
  v11 = sub_16500(a1[11].__lock, a2, a3, a4, a5, a6);
  v12 = (_DWORD *)v11;
  if ( v11 )
    v12 = sub_19E18(v11, 0);
  if ( pthread_rwlock_unlock(v6) )
    sub_B700("clone_queued_work_bymidstate", 8888);
  off_60178();
  return v12;
}
// 60178: using guessed type int (*off_60178)();

//----- (0001AAA4) --------------------------------------------------------
_DWORD *__fastcall sub_1AAA4(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r5
  int lock; // r2
  _DWORD *v6; // r4
  int v7; // r0

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B76C("clone_queued_work_byid", 8928);
  lock = a1[11].__lock;
  if ( lock )
  {
    v7 = *(_DWORD *)(lock + 352);
    if ( a2 == *(_DWORD *)(lock + 340) )
    {
      v7 = a1[11].__lock;
LABEL_12:
      v6 = sub_19E18(v7, 0);
    }
    else
    {
      while ( v7 )
      {
        if ( a2 == *(_DWORD *)(v7 + 340) )
          goto LABEL_12;
        v7 = *(_DWORD *)(v7 + 352);
      }
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( pthread_rwlock_unlock(v2) )
    sub_B700("clone_queued_work_byid", 8932);
  off_60178();
  return v6;
}
// 60178: using guessed type int (*off_60178)();

//----- (0001AB68) --------------------------------------------------------
int __fastcall sub_1AB68(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_63CA0) )
    sub_B76C("get_devices", 632);
  v2 = *(_DWORD *)(dword_63BC8 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_63CA0) )
    sub_B700("get_devices", 634);
  off_60178();
  return v2;
}
// 60178: using guessed type int (*off_60178)();
// 63BC8: using guessed type int dword_63BC8;

//----- (0001ABE0) --------------------------------------------------------
int sub_1ABE0()
{
  int *v0; // r12
  int *v1; // r2
  int v2; // r0
  int v3; // t1
  int result; // r0
  int v5; // r7
  int v6; // r0
  int v7; // r6

  sub_2B13C((struct timeval *)&dword_61370);
  sub_2AE20(dword_61378, &dword_61370);
  dbl_64238 = 0.0;
  v0 = (int *)&unk_61380;
  dbl_640B0 = 0.0;
  dbl_638A0 = 0.0;
  dbl_64228 = 0.0;
  dbl_63268 = 0.0;
  do
  {
    *(_QWORD *)v0 = 0;
    v0 += 2;
  }
  while ( v0 != &dword_613E0 );
  dword_63E48 = 0;
  dword_640C0 = 0;
  dbl_5F898 = 1.0;
  dbl_60088 = 1.0;
  dword_613E0 = 0;
  qword_639C8 = 0;
  *(_QWORD *)&dword_636A8 = 0;
  dword_63E44 = 0;
  dbl_63B88 = 0.0;
  dword_63A70 = 0;
  dbl_63C10 = 0.0;
  dword_639E4 = 0;
  dbl_639D0 = 0.0;
  dword_63410 = 0;
  dword_63E58 = 0;
  *(_QWORD *)&dword_63BE8 = 0;
  qword_63C98 = 0;
  *(_QWORD *)&dword_64220 = 0;
  *(_QWORD *)&dword_63D68 = 0;
  if ( dword_63740 > 0 )
  {
    v1 = (int *)dword_639E0;
    v2 = dword_639E0 + 4 * dword_63740;
    do
    {
      v3 = *v1++;
      *(_QWORD *)(v3 + 72) = 0;
      *(_QWORD *)(v3 + 80) = 0;
      *(_QWORD *)(v3 + 88) = 0;
      *(_QWORD *)(v3 + 360) = 0;
      *(_DWORD *)(v3 + 116) = 0;
      *(_DWORD *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 12) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 120) = 0;
      *(_DWORD *)(v3 + 124) = 0;
      *(_DWORD *)(v3 + 128) = 0;
      *(_DWORD *)(v3 + 132) = 0;
      *(_DWORD *)(v3 + 352) = 0;
      *(_DWORD *)(v3 + 40) = 0;
      *(_DWORD *)(v3 + 44) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  result = sub_15BEC();
  if ( dword_63CC0 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = v5++;
      v7 = sub_1AB68(v6);
      sub_2AE20((_DWORD *)(v7 + 368), &dword_61370);
      if ( pthread_mutex_lock(&stru_6392C) )
        sub_B4E4("zero_stats", 5852);
      *(_QWORD *)(v7 + 80) = 0;
      *(_DWORD *)(v7 + 36) = 0;
      *(_QWORD *)(v7 + 192) = 0;
      *(_QWORD *)(v7 + 88) = 0;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 200) = 0;
      *(_DWORD *)(v7 + 44) = 0;
      *(_QWORD *)(v7 + 208) = 0;
      *(_DWORD *)(v7 + 220) = 0;
      *(_QWORD *)(v7 + 224) = 0;
      if ( pthread_mutex_unlock(&stru_6392C) )
        sub_B694("zero_stats", 5863);
      off_60178();
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(v7 + 4) + 96))(v7);
    }
    while ( dword_63CC0 > v5 );
  }
  return result;
}
// 5F898: using guessed type double dbl_5F898;
// 60088: using guessed type double dbl_60088;
// 60178: using guessed type int (*off_60178)();
// 61370: using guessed type int dword_61370;
// 61378: using guessed type _DWORD dword_61378[2];
// 613E0: using guessed type int dword_613E0;
// 63268: using guessed type double dbl_63268;
// 63410: using guessed type int dword_63410;
// 636A8: using guessed type int dword_636A8;
// 63740: using guessed type int dword_63740;
// 638A0: using guessed type double dbl_638A0;
// 639C8: using guessed type __int64 qword_639C8;
// 639D0: using guessed type double dbl_639D0;
// 639E0: using guessed type int dword_639E0;
// 639E4: using guessed type int dword_639E4;
// 63A70: using guessed type int dword_63A70;
// 63B88: using guessed type double dbl_63B88;
// 63BE8: using guessed type int dword_63BE8;
// 63C10: using guessed type double dbl_63C10;
// 63C98: using guessed type __int64 qword_63C98;
// 63CC0: using guessed type int dword_63CC0;
// 63D68: using guessed type int dword_63D68;
// 63E44: using guessed type int dword_63E44;
// 63E48: using guessed type int dword_63E48;
// 63E58: using guessed type int dword_63E58;
// 640B0: using guessed type double dbl_640B0;
// 640C0: using guessed type int dword_640C0;
// 64220: using guessed type int dword_64220;
// 64228: using guessed type double dbl_64228;
// 64238: using guessed type double dbl_64238;

//----- (0001AECC) --------------------------------------------------------
int sub_1AECC()
{
  int v0; // r3
  double v1; // d9
  int v2; // r7
  int v3; // r5
  int v4; // r9
  double v5; // r0
  double v6; // d10
  double v7; // r0
  double v8; // d9
  __int64 v9; // r6
  __int64 v10; // r10
  int v11; // r1
  double v12; // d8
  double v13; // r0
  int v14; // r11
  int v15; // r1
  int v16; // r2
  __int64 v17; // r4
  __int64 v18; // kr08_8
  int v19; // r1
  double v20; // d8
  double v21; // r0
  int v22; // r4
  int v23; // r0
  int v24; // r0
  int v25; // r2
  double v26; // d16
  int v27; // r3
  const char *v29; // r2
  int v30; // [sp+18h] [bp-914h]
  char v31[256]; // [sp+28h] [bp-904h] BYREF
  char s[2052]; // [sp+128h] [bp-804h] BYREF

  v0 = dword_613E4 - dword_61370;
  if ( dword_613E8 - dword_61374 < 0 )
    --v0;
  v1 = dbl_5F898;
  v2 = v0 / 3600;
  v3 = v0 % 60;
  v4 = v0 % 3600 / 60;
  LODWORD(v5) = sub_493DC(qword_639C8);
  v6 = v5 / v1 * 60.0;
  LODWORD(v7) = sub_493DC(*(__int64 *)&dword_636A8);
  v8 = v7 / v1 * 60.0;
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    strcpy(s, "\nSummary of runtime statistics:\n");
    sub_38438(4, s, 0);
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      snprintf(s, 0x800u, "Started at %s", byte_613EC);
      sub_38438(4, s, 0);
    }
  }
  if ( dword_63740 == 1 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
      goto LABEL_28;
    snprintf(s, 0x800u, "Pool: %s", *(const char **)(*(_DWORD *)dword_639E0 + 164));
    sub_38438(4, s, 0);
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(s, 0x800u, "Runtime: %d hrs : %d mins : %d secs", v2, v4, v3);
    sub_38438(4, s, 0);
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      snprintf(s, 0x800u, "Average hashrate: %.1f Mhash/s", dbl_63268 / dbl_5F898);
      sub_38438(4, s, 0);
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(s, 0x800u, "Solved blocks: %d", dword_63E58);
        sub_38438(4, s, 0);
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Best share difficulty: %s", (const char *)&dword_60064);
          sub_38438(4, s, 0);
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, "Share submissions: %lld", qword_63C98 + qword_639C8);
            sub_38438(4, s, 0);
            if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
            {
              snprintf(s, 0x800u, "Accepted shares: %lld", qword_639C8);
              sub_38438(4, s, 0);
              if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
              {
                snprintf(s, 0x800u, "Rejected shares: %lld", qword_63C98);
                sub_38438(4, s, 0);
                if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
                {
                  snprintf(s, 0x800u, "Accepted difficulty shares: %1.f", dbl_63B88);
                  sub_38438(4, s, 0);
                  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
                  {
                    snprintf(s, 0x800u, "Rejected difficulty shares: %1.f", dbl_63C10);
                    sub_38438(4, s, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_28:
  v9 = qword_639C8;
  if ( qword_639C8 || qword_63C98 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
      goto LABEL_50;
    v10 = qword_63C98;
    LODWORD(v12) = sub_493DC(100 * qword_63C98);
    HIDWORD(v12) = v11;
    LODWORD(v13) = sub_493DC(v9 + v10);
    snprintf(s, 0x800u, "Reject ratio: %.1f%%", v12 / v13);
    sub_38438(4, s, 0);
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(s, 0x800u, "Hardware errors: %d", dword_63E44);
    sub_38438(4, s, 0);
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      snprintf(s, 0x800u, "Utility (accepted shares / min): %.2f/min", v6);
      sub_38438(4, s, 0);
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(s, 0x800u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v8);
        sub_38438(4, s, 0);
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&dword_64220);
          sub_38438(4, s, 0);
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, "Unable to get work from server occasions: %d", dword_639E4);
            sub_38438(4, s, 0);
            if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
            {
              snprintf(s, 0x800u, "Work items generated locally: %d", dword_63A70);
              sub_38438(4, s, 0);
              if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
              {
                snprintf(s, 0x800u, "Submitting work remotely delay occasions: %d", dword_63410);
                sub_38438(4, s, 0);
                if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
                {
                  snprintf(s, 0x800u, "New blocks detected on network: %d\n", dword_640BC);
                  sub_38438(4, s, 0);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_50:
  if ( dword_63740 > 1 )
  {
    v30 = 0;
    while ( 1 )
    {
      v14 = *(_DWORD *)(dword_639E0 + 4 * v30);
      if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
        break;
      snprintf(s, 0x800u, "Pool: %s", *(const char **)(v14 + 164));
      sub_38438(4, s, 0);
      v15 = *(_DWORD *)(v14 + 32);
      v16 = (unsigned __int8)byte_632F0;
      if ( !v15 )
        goto LABEL_103;
      if ( !byte_632F0 )
        goto LABEL_59;
LABEL_100:
      v29 = "S";
      if ( v15 <= 1 )
        v29 = "";
      snprintf(s, 0x800u, "SOLVED %d BLOCK%s!", v15, v29);
      sub_38438(4, s, 0);
      v16 = (unsigned __int8)byte_632F0;
LABEL_103:
      if ( !v16 )
      {
LABEL_104:
        if ( !byte_630C0 && dword_60964 <= 3 )
          goto LABEL_61;
      }
      snprintf(s, 0x800u, " Share submissions: %lld", *(_QWORD *)(v14 + 16) + *(_QWORD *)(v14 + 8));
      sub_38438(4, s, 0);
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(s, 0x800u, " Accepted shares: %lld", *(_QWORD *)(v14 + 8));
        sub_38438(4, s, 0);
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, " Rejected shares: %lld", *(_QWORD *)(v14 + 16));
          sub_38438(4, s, 0);
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, " Accepted difficulty shares: %1.f", *(double *)(v14 + 72));
            sub_38438(4, s, 0);
            if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
            {
              snprintf(s, 0x800u, " Rejected difficulty shares: %1.f", *(double *)(v14 + 80));
              sub_38438(4, s, 0);
            }
          }
        }
      }
LABEL_61:
      if ( !*(_QWORD *)(v14 + 8) && !*(_QWORD *)(v14 + 16) )
        goto LABEL_67;
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        v17 = *(_QWORD *)(v14 + 16);
        v18 = *(_QWORD *)(v14 + 8);
        LODWORD(v20) = sub_493DC(100 * v17);
        HIDWORD(v20) = v19;
        LODWORD(v21) = sub_493DC(v18 + v17);
        snprintf(s, 0x800u, " Reject ratio: %.1f%%", v20 / v21);
        sub_38438(4, s, 0);
LABEL_67:
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, " Items worked on: %d", *(_DWORD *)(v14 + 68));
          sub_38438(4, s, 0);
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v14 + 120));
            sub_38438(4, s, 0);
            if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
            {
              snprintf(s, 0x800u, " Unable to get work from server occasions: %d", *(_DWORD *)(v14 + 128));
              sub_38438(4, s, 0);
              if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
              {
                snprintf(s, 0x800u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v14 + 132));
                sub_38438(4, s, 0);
              }
            }
          }
        }
      }
      if ( dword_63740 <= ++v30 )
        goto LABEL_77;
    }
    v15 = *(_DWORD *)(v14 + 32);
    if ( !v15 )
      goto LABEL_104;
LABEL_59:
    if ( !byte_630C0 && dword_60964 <= 3 )
      goto LABEL_61;
    goto LABEL_100;
  }
LABEL_77:
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    strcpy(s, "Summary of per device statistics:\n");
    sub_38438(4, s, 0);
  }
  if ( dword_63CC0 > 0 )
  {
    v22 = 0;
    do
    {
      v23 = v22++;
      v24 = sub_1AB68(v23);
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 20) = nullsub_1;
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 24) = nullsub_3;
      sub_1715C(v31, 0xFFu, v24);
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(s, 0x800u, "%s", v31);
        sub_38438(4, s, 0);
      }
    }
    while ( dword_63CC0 > v22 );
  }
  v25 = dword_61414;
  if ( !dword_61414 )
    goto LABEL_95;
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(s, 0x800u, "Mined %.0f accepted shares of %d requested\n", dbl_63B88, dword_61414);
    sub_38438(4, s, 0);
    v25 = dword_61414;
    v26 = dbl_63B88;
    v27 = (unsigned __int8)byte_632F0;
    if ( (double)dword_61414 <= dbl_63B88 )
      goto LABEL_96;
    if ( byte_632F0 )
      goto LABEL_94;
  }
  else
  {
    v26 = dbl_63B88;
    if ( (double)dword_61414 <= dbl_63B88 )
    {
LABEL_97:
      if ( !byte_630C0 && dword_60964 <= 3 )
        goto LABEL_99;
LABEL_98:
      strcpy(s, " ");
      sub_38438(4, s, 0);
      goto LABEL_99;
    }
  }
  if ( byte_630C0 || dword_60964 > 3 )
  {
LABEL_94:
    snprintf(s, 0x800u, "WARNING - Mined only %.0f shares of %d requested.", v26, v25);
    sub_38438(4, s, 0);
LABEL_95:
    v27 = (unsigned __int8)byte_632F0;
LABEL_96:
    if ( v27 )
      goto LABEL_98;
    goto LABEL_97;
  }
LABEL_99:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 1AF7C: variable 'v5' is possibly undefined
// 1AF94: variable 'v7' is possibly undefined
// 1B434: variable 'v11' is possibly undefined
// 1B458: variable 'v13' is possibly undefined
// 1B7D8: variable 'v19' is possibly undefined
// 1B7FC: variable 'v21' is possibly undefined
// F360: using guessed type int nullsub_1();
// F364: using guessed type int nullsub_3();
// 5F898: using guessed type double dbl_5F898;
// 60064: using guessed type int dword_60064;
// 60964: using guessed type int dword_60964;
// 60E7C: using guessed type int stdout;
// 60E80: using guessed type int stderr;
// 61370: using guessed type int dword_61370;
// 61374: using guessed type int dword_61374;
// 613E4: using guessed type int dword_613E4;
// 613E8: using guessed type int dword_613E8;
// 61414: using guessed type int dword_61414;
// 630C0: using guessed type char byte_630C0;
// 63268: using guessed type double dbl_63268;
// 632F0: using guessed type char byte_632F0;
// 63410: using guessed type int dword_63410;
// 636A8: using guessed type int dword_636A8;
// 63740: using guessed type int dword_63740;
// 639C8: using guessed type __int64 qword_639C8;
// 639E0: using guessed type int dword_639E0;
// 639E4: using guessed type int dword_639E4;
// 63A70: using guessed type int dword_63A70;
// 63B88: using guessed type double dbl_63B88;
// 63C10: using guessed type double dbl_63C10;
// 63C98: using guessed type __int64 qword_63C98;
// 63CC0: using guessed type int dword_63CC0;
// 63E44: using guessed type int dword_63E44;
// 63E58: using guessed type int dword_63E58;
// 640BC: using guessed type int dword_640BC;
// 64220: using guessed type int dword_64220;

//----- (0001C028) --------------------------------------------------------
void sub_1C028()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(v0, 0x800u, "Attempting to restart %s", byte_60EA4);
    sub_38438(4, v0, 0);
  }
  sub_2F38C((int)sub_1C708, 0, 5000);
  sub_2B13C((struct timeval *)&dword_613E4);
  sub_19060();
  if ( dword_61418 > 0 )
  {
    kill(dword_61418, 15);
    dword_61418 = 0;
  }
  execv(*(const char **)dword_6141C, (char *const *)dword_6141C);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    strcpy(v0, "Failed to restart application");
    sub_38438(4, v0, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 613E4: using guessed type int dword_613E4;
// 61418: using guessed type int dword_61418;
// 6141C: using guessed type int dword_6141C;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (0001C160) --------------------------------------------------------
void __fastcall __noreturn sub_1C160(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, (void *(*)(void *))sub_11854, 0) )
  {
    if ( a2 )
    {
      sub_2B13C((struct timeval *)&dword_613E4);
      sub_19060();
      if ( !byte_640B8 && byte_62F60 )
        sub_1AECC();
    }
    else
    {
      sub_19060();
    }
    if ( dword_61418 > 0 )
    {
      kill(dword_61418, 15);
      dword_61418 = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}
// 613E4: using guessed type int dword_613E4;
// 61418: using guessed type int dword_61418;
// 62F60: using guessed type char byte_62F60;
// 640B8: using guessed type char byte_640B8;

//----- (0001C218) --------------------------------------------------------
int __fastcall sub_1C218(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r3
  int v6; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B76C("find_queued_work_byid", 8917);
  lock = a1[11].__lock;
  if ( lock && (v6 = *(_DWORD *)(lock + 352), a2 != *(_DWORD *)(lock + 340)) )
  {
    while ( v6 && a2 != *(_DWORD *)(v6 + 340) )
      v6 = *(_DWORD *)(v6 + 352);
  }
  else
  {
    v6 = lock;
  }
  if ( pthread_rwlock_unlock(v2) )
    sub_B700("find_queued_work_byid", 8919);
  off_60178();
  return v6;
}
// 60178: using guessed type int (*off_60178)();

//----- (0001C2C8) --------------------------------------------------------
int __fastcall sub_1C2C8(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B76C("find_queued_work_bymidstate", 8873);
  v11 = sub_16500(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    sub_B700("find_queued_work_bymidstate", 8875);
  off_60178();
  return v11;
}
// 60178: using guessed type int (*off_60178)();

//----- (0001C36C) --------------------------------------------------------
int __fastcall sub_1C36C(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_B76C("get_thread", 614);
  v2 = *(_DWORD *)(dword_63B80 + 4 * a1);
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_B700("get_thread", 616);
  off_60178();
  return v2;
}
// 60178: using guessed type int (*off_60178)();
// 63B80: using guessed type int dword_63B80;

//----- (0001C3E4) --------------------------------------------------------
int sub_1C3E4()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r2
  int v4; // r3
  char v6[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_630C1 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      goto LABEL_31;
    strcpy(v6, "Received kill message");
    sub_38438(7, v6, 1);
    if ( byte_630C1 )
    {
      if ( byte_632F0 || byte_630C0 )
      {
LABEL_7:
        strcpy(v6, "Killing off watchpool thread");
        sub_38438(7, v6, 1);
        goto LABEL_8;
      }
LABEL_31:
      if ( dword_60964 <= 6 )
        goto LABEL_8;
      goto LABEL_7;
    }
  }
LABEL_8:
  sub_2F38C((int)sub_2AD04, dword_636A4 + (dword_61420 << 6), 1000);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v6, "Killing off watchdog thread");
    sub_38438(7, v6, 1);
  }
  sub_2F38C((int)sub_2AD04, dword_636A4 + (dword_61424 << 6), 1000);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v6, "Shutting down mining threads");
    sub_38438(7, v6, 1);
  }
  if ( dword_6410C > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      v2 = sub_1C36C(v1);
      v3 = dword_6410C;
      if ( v2 )
      {
        v4 = *(_DWORD *)(v2 + 36);
        if ( v4 )
          *(_BYTE *)(v4 + 364) = 1;
      }
    }
    while ( v0 < v3 );
  }
  sleep(1u);
  sub_2F38C((int)sub_1C720, 0, 3000);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v6, "Killing off API thread");
    sub_38438(7, v6, 1);
  }
  return sub_2F38C((int)sub_2AD04, dword_636A4 + (dword_611A8 << 6), 1000);
}
// 60964: using guessed type int dword_60964;
// 611A8: using guessed type int dword_611A8;
// 61420: using guessed type int dword_61420;
// 61424: using guessed type int dword_61424;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 636A4: using guessed type int dword_636A4;
// 6410C: using guessed type int dword_6410C;

//----- (0001C708) --------------------------------------------------------
int sub_1C708()
{
  int result; // r0

  if ( byte_62F60 )
    return sub_1C3E4();
  return result;
}
// 62F60: using guessed type char byte_62F60;

//----- (0001C720) --------------------------------------------------------
void sub_1C720()
{
  int v0; // r4
  pthread_t v1; // r0
  int v2; // r0
  int v3; // r5
  char v4[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    sub_38438(7, v4, 1);
  }
  if ( dword_6410C > 0 )
  {
    v0 = 0;
    do
    {
      while ( 1 )
      {
        v2 = sub_1C36C(v0);
        v3 = v2;
        if ( v2 )
        {
          if ( *(_DWORD *)(v2 + 12) )
            break;
        }
        ++v0;
        sub_2AD04(v2);
        if ( dword_6410C <= v0 )
          return;
      }
      sub_2AD04(v2);
      v1 = *(_DWORD *)(v3 + 12);
      if ( v1 )
        pthread_join(v1, 0);
      ++v0;
    }
    while ( dword_6410C > v0 );
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 6410C: using guessed type int dword_6410C;

//----- (0001C834) --------------------------------------------------------
void __fastcall sub_1C834(int a1, __int64 a2)
{
  double v3; // d0
  int v6; // r7
  int v7; // r0
  int v8; // r5
  int v9; // r1
  double v10; // r0
  double v11; // d8
  double v12; // r0
  double v13; // r0
  double v14; // r0
  double v15; // r0
  int v16; // r6
  int v17; // r0
  int v18; // r5
  double v19; // r0
  double v20; // r0
  double v21; // r0
  double v22; // r0
  double v23; // r0
  double v24; // d9
  int v25; // r3
  double v26; // d16
  int v27; // r3
  __int64 v28; // d16
  int v29; // r5
  int *v30; // r11
  double v31; // d8
  double v32; // r0
  int v33; // r1
  __int64 v34; // r0
  double v35; // r0
  double v36; // r0
  double v37; // r0
  double v38; // r0
  int v39; // r0
  __int64 v40; // r0
  unsigned __int64 v41; // r0
  unsigned __int64 v42; // r0
  unsigned __int64 v43; // r0
  unsigned __int64 v44; // r0
  unsigned __int64 v45; // r0
  int v46; // [sp+1Ch] [bp-940h]
  __int64 v47; // [sp+20h] [bp-93Ch]
  char v48[16]; // [sp+28h] [bp-934h] BYREF
  char v49[16]; // [sp+38h] [bp-924h] BYREF
  char v50[16]; // [sp+48h] [bp-914h] BYREF
  char v51[256]; // [sp+58h] [bp-904h] BYREF
  char s[2052]; // [sp+158h] [bp-804h] BYREF

  sub_2B13C((struct timeval *)&dword_613E4);
  sub_2B314();
  v6 = dword_613E4;
  if ( dword_613E4 - dword_61428 < dword_6006C )
  {
    if ( a1 < 0 )
      return;
    v46 = 0;
    sub_2AE20(dword_61378, &dword_613E4);
  }
  else
  {
    dword_61428 = dword_613E4;
    byte_6142C ^= byte_6142D;
    sub_2AE20(dword_61378, &dword_613E4);
    if ( a1 < 0 )
    {
      if ( pthread_mutex_lock(&stru_6392C) )
        sub_B4E4("hashmeter", 6741);
      if ( dword_6410C > 0 )
      {
        v16 = 0;
        do
        {
          v17 = v16++;
          v18 = *(_DWORD *)(sub_1C36C(v17) + 36);
          sub_2B314();
          sub_2AE20((_DWORD *)(v18 + 140), &dword_613E4);
          LODWORD(v19) = v18 + 48;
          sub_152D0(v19);
          LODWORD(v20) = v18 + 56;
          sub_152D0(v20);
          LODWORD(v21) = v18 + 64;
          sub_152D0(v21);
          LODWORD(v22) = v18 + 72;
          v3 = 0.0;
          sub_152D0(v22);
        }
        while ( dword_6410C > v16 );
      }
      if ( pthread_mutex_unlock(&stru_6392C) )
        sub_B694("hashmeter", 6754);
      v46 = 1;
      v47 = a2;
      off_60178();
      goto LABEL_28;
    }
    v46 = 1;
  }
  v7 = sub_1C36C(a1);
  v8 = *(_DWORD *)(v7 + 36);
  sub_2AE20((_DWORD *)(v7 + 44), &dword_613E4);
  *(_DWORD *)(v8 + 240) = v6;
  sub_2B314();
  sub_2AE20((_DWORD *)(v8 + 140), &dword_613E4);
  LODWORD(v47) = sub_4943C(a2, 1000000);
  HIDWORD(v47) = v9;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    LODWORD(v15) = sub_493C8(a2);
    snprintf(s, 0x800u, "[thread %d: %llu hashes, %.1f mhash/sec]", a1, v47, v15 / v3 / 1000000.0);
    sub_38438(7, s, 0);
  }
  if ( pthread_mutex_lock(&stru_6392C) )
    sub_B4E4("hashmeter", 6715);
  LODWORD(v10) = sub_493C8(v47);
  v11 = v10;
  LODWORD(v10) = v8 + 48;
  *(double *)(v8 + 80) = *(double *)(v8 + 80) + v11;
  sub_152D0(v10);
  LODWORD(v12) = v8 + 56;
  sub_152D0(v12);
  LODWORD(v13) = v8 + 64;
  sub_152D0(v13);
  LODWORD(v14) = v8 + 72;
  v3 = v11;
  sub_152D0(v14);
  if ( pthread_mutex_unlock(&stru_6392C) )
    sub_B694("hashmeter", 6721);
  off_60178();
  sub_1715C(v51, 0x100u, v8);
  if ( byte_612F8 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "%s", v51);
      sub_38438(7, s, 0);
    }
  }
  else
  {
    printf("%s          \r", v51);
    fflush((FILE *)stdout);
  }
LABEL_28:
  if ( pthread_mutex_lock(&stru_6392C) )
    sub_B4E4("hashmeter", 6757);
  LODWORD(v23) = sub_493C8(v47);
  v24 = v23;
  dbl_63268 = v23 + dbl_63268;
  if ( v46 )
  {
    v27 = dword_613E0 + 1;
    v28 = 0;
    v29 = 0;
    v30 = (int *)dbl_61380;
    if ( dword_613E0 + 1 > 11 )
      v27 = 0;
    dword_613E0 = v27;
    do
    {
      v31 = *(double *)v30;
      v30 += 2;
      if ( v31 >= 0.0 )
      {
        LODWORD(v32) = sub_493C8(v28);
        ++v29;
        LODWORD(v28) = sub_494C0(v31 + v32);
        HIDWORD(v28) = v33;
      }
    }
    while ( v30 != &dword_613E0 );
    if ( v29 )
    {
      LODWORD(v34) = sub_4943C(v28, v29);
      v47 = v34;
    }
    sub_493C8(v47);
    LODWORD(v35) = &dbl_640B0;
    sub_152D0(v35);
    LODWORD(v36) = &dbl_64238;
    sub_152D0(v36);
    LODWORD(v37) = &dbl_64228;
    sub_152D0(v37);
    LODWORD(v38) = &dbl_638A0;
    v39 = sub_152D0(v38);
    v3 = dbl_640B0;
    v40 = llround(v39);
    v26 = 0.0;
    v25 = dword_613E0;
    dbl_61380[dword_613E0] = 0.0;
    *(_QWORD *)&dword_64070 = 1000000 * v40;
  }
  else
  {
    v25 = dword_613E0;
    v26 = dbl_61380[dword_613E0];
  }
  dbl_61380[v25] = v26 + v24;
  sub_2B314();
  dbl_5F898 = v3;
  if ( v3 - dbl_60088 > 86400.0 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      snprintf(s, 0x800u, "cgminer time error total_secs = %f last_total_secs = %f", v3, dbl_60088);
      sub_38438(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_6392C) )
      sub_B694("hashmeter", 6797);
    off_60178();
    sub_1ABE0();
    if ( pthread_mutex_lock(&stru_6392C) )
      sub_B4E4("hashmeter", 6799);
  }
  else
  {
    dbl_60088 = v3;
  }
  if ( v46 )
  {
    LODWORD(v41) = sub_494C0(dbl_63268 / dbl_5F898 * 1000000.0);
    sub_11130(v41, v48, 0x10u, 4);
    dbl_61430 = dbl_640B0 / 1000.0;
    LODWORD(v42) = sub_494C0(dbl_640B0 * 1000000.0);
    sub_11130(v42, v49, 0x10u, 4);
    LODWORD(v43) = sub_494C0(dbl_64238 * 1000000.0);
    sub_11130(v43, v50, 0x10u, 4);
    LODWORD(v44) = sub_494C0(dbl_64228 * 1000000.0);
    sub_11130(v44, v51, 0x10u, 4);
    LODWORD(v45) = sub_494C0(dbl_638A0 * 1000000.0);
    sub_11130(v45, s, 0x10u, 4);
    snprintf(byte_61438, 0x100u, "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s", dword_6006C, v49, v50, v51, s, v48);
  }
  if ( pthread_mutex_unlock(&stru_6392C) )
    sub_B694("hashmeter", 6828);
  off_60178();
  if ( v46 )
  {
    if ( byte_612F8 )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "%s", byte_61438);
        sub_38438(7, s, 0);
      }
    }
    else
    {
      printf("%s          \r", byte_61438);
      fflush((FILE *)stdout);
    }
  }
}
// 1C928: variable 'v9' is possibly undefined
// 1C960: variable 'v10' is possibly undefined
// 1C988: variable 'v12' is possibly undefined
// 1C99C: variable 'v13' is possibly undefined
// 1C9B0: variable 'v14' is possibly undefined
// 1CAF4: variable 'v15' is possibly undefined
// 1CAF4: variable 'v3' is possibly undefined
// 1CBDC: variable 'v19' is possibly undefined
// 1CBF0: variable 'v20' is possibly undefined
// 1CC04: variable 'v21' is possibly undefined
// 1CC18: variable 'v22' is possibly undefined
// 1CC84: variable 'v23' is possibly undefined
// 1CFD8: variable 'v41' is possibly undefined
// 1D008: variable 'v42' is possibly undefined
// 1D02C: variable 'v43' is possibly undefined
// 1D050: variable 'v44' is possibly undefined
// 1D074: variable 'v45' is possibly undefined
// 1CE44: variable 'v32' is possibly undefined
// 1CE4C: variable 'v33' is possibly undefined
// 1CE70: variable 'v34' is possibly undefined
// 1CEA4: variable 'v35' is possibly undefined
// 1CEB8: variable 'v36' is possibly undefined
// 1CECC: variable 'v37' is possibly undefined
// 1CEE0: variable 'v38' is possibly undefined
// B260: using guessed type __int64 __fastcall llround(_DWORD);
// 5F898: using guessed type double dbl_5F898;
// 6006C: using guessed type int dword_6006C;
// 60088: using guessed type double dbl_60088;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 60E7C: using guessed type int stdout;
// 612F8: using guessed type char byte_612F8;
// 61378: using guessed type _DWORD dword_61378[2];
// 61380: using guessed type double dbl_61380[12];
// 613E0: using guessed type int dword_613E0;
// 613E4: using guessed type int dword_613E4;
// 61428: using guessed type int dword_61428;
// 6142C: using guessed type char byte_6142C;
// 6142D: using guessed type char byte_6142D;
// 61430: using guessed type double dbl_61430;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 63268: using guessed type double dbl_63268;
// 632F0: using guessed type char byte_632F0;
// 638A0: using guessed type double dbl_638A0;
// 64070: using guessed type int dword_64070;
// 640B0: using guessed type double dbl_640B0;
// 6410C: using guessed type int dword_6410C;
// 64228: using guessed type double dbl_64228;
// 64238: using guessed type double dbl_64238;

//----- (0001D3F4) --------------------------------------------------------
int __fastcall sub_1D3F4(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(sub_1C36C(a1) + 36) + 8);
}

//----- (0001D408) --------------------------------------------------------
void __fastcall sub_1D408(const char *a1, _DWORD *a2)
{
  int v4; // r10
  int v5; // r9
  char *v6; // r7
  char *v7; // r6
  char *v8; // r8
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // lr
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // lr
  int v17; // r1
  int v18; // [sp+20h] [bp-C0Ch]
  int v19; // [sp+24h] [bp-C08h]
  char s[1024]; // [sp+28h] [bp-C04h] BYREF
  _DWORD v21[5]; // [sp+428h] [bp-804h] BYREF
  __int16 v22; // [sp+43Ch] [bp-7F0h]

  if ( !dword_60FA4 )
    return;
  v4 = a2[64];
  v5 = *(_DWORD *)(sub_1C36C(v4) + 36);
  v19 = a2[65];
  v18 = a2[108];
  v6 = sub_294B8((int)(a2 + 40), 32);
  v7 = sub_294B8((int)(a2 + 48), 32);
  v8 = sub_294B8((int)a2, 128);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         v18,
         a1,
         v6,
         *(const char **)(v19 + 164),
         *(const char **)(*(_DWORD *)(v5 + 4) + 8),
         *(_DWORD *)(v5 + 8),
         v4,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 < 1024 )
  {
    if ( v9 < 0 )
    {
      if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
        return;
      v11 = "sharelog printf error";
LABEL_11:
      v12 = *(_DWORD *)v11;
      v13 = *((_DWORD *)v11 + 1);
      v14 = *((_DWORD *)v11 + 2);
      v15 = *((_DWORD *)v11 + 3);
      v16 = v11 + 16;
      v21[0] = v12;
      v21[1] = v13;
      v21[2] = v14;
      v21[3] = v15;
      v17 = v16[1];
      v21[4] = *v16;
      v22 = v17;
      sub_38438(3, (const char *)v21, 0);
      return;
    }
  }
  else
  {
    s[1023] = 0;
  }
  if ( pthread_mutex_lock(&stru_61538) )
    sub_B4E4("sharelog", 673);
  v10 = fwrite(s, v9, 1u, (FILE *)dword_60FA4);
  fflush((FILE *)dword_60FA4);
  if ( pthread_mutex_unlock(&stru_61538) )
    sub_B694("sharelog", 676);
  off_60178();
  if ( v10 != 1 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
  {
    v11 = "sharelog fwrite error";
    goto LABEL_11;
  }
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 60FA4: using guessed type int dword_60FA4;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (0001D644) --------------------------------------------------------
int sub_1D644()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_63FB0) )
    sub_B4E4("current_pool", 796);
  if ( pthread_rwlock_rdlock(&stru_63FC8) )
    sub_B76C("current_pool", 796);
  if ( pthread_mutex_unlock(&stru_63FB0) )
    sub_B694("current_pool", 796);
  v0 = dword_61310;
  if ( pthread_rwlock_unlock(&stru_63FC8) )
    sub_B700("current_pool", 798);
  off_60178();
  return v0;
}
// 60178: using guessed type int (*off_60178)();
// 61310: using guessed type int dword_61310;

//----- (0001D6F8) --------------------------------------------------------
int __fastcall sub_1D6F8(int a1)
{
  int v1; // r11
  unsigned __int64 v2; // d17
  int v3; // r5
  int v4; // r4
  int v6; // r8
  int v7; // lr
  int v8; // r12
  int v9; // r7
  int v10; // r6
  int v11; // r4
  int v12; // r3
  int v13; // r10
  size_t v14; // r0
  unsigned int v15; // r12
  unsigned __int8 *v16; // r3
  int v17; // r1
  size_t v18; // r4
  int v19; // r0
  unsigned int v20; // r2
  unsigned int v21; // r12
  int v22; // lr
  int v23; // r8
  int v24; // r7
  int v25; // r6
  unsigned int v26; // r0
  int v27; // r1
  unsigned int v28; // r12
  unsigned int v29; // r0
  int v30; // r1
  unsigned int v31; // r12
  unsigned int v32; // r0
  size_t v33; // r0
  _DWORD *v34; // r6
  int v35; // r1
  unsigned int v36; // r2
  unsigned int v37; // r3
  int v38; // r1
  unsigned int v39; // r2
  unsigned int v40; // r3
  int v41; // r1
  int v42; // r6
  const char *v43; // r3
  char *v44; // r0
  int v45; // r7
  int v46; // r3
  int v47; // r6
  int v48; // r9
  int v49; // r2
  int v50; // r12
  int v51; // lr
  unsigned int v52; // r8
  int v53; // r3
  int v54; // r1
  int v55; // r0
  int v56; // r0
  int v57; // r4
  bool v58; // zf
  int v59; // r3
  bool v60; // zf
  int v61; // r9
  int v62; // r3
  int v63; // r2
  int v64; // r0
  int v65; // r3
  _DWORD *v66; // r2
  int v67; // r3
  int v68; // r2
  int v69; // r3
  int v70; // r3
  _DWORD *v71; // r0
  _DWORD *v72; // r4
  void *v73; // r0
  int v74; // r3
  int v75; // r3
  int v76; // r1
  int v77; // r2
  int v78; // r3
  int v79; // r1
  int v80; // r2
  int v81; // r3
  int v82; // r11
  int v83; // r3
  unsigned int v84; // r10
  size_t v85; // r0
  unsigned int v86; // r9
  unsigned __int8 *v87; // r4
  int v88; // r8
  int v89; // r1
  int v90; // r12
  int v91; // r2
  int v92; // r0
  unsigned int v93; // r3
  unsigned int v94; // r10
  int v95; // r8
  unsigned int v96; // r2
  unsigned int v97; // r3
  int v98; // r1
  unsigned int v99; // r2
  unsigned int v100; // r3
  size_t v101; // r11
  int v102; // r0
  unsigned int v103; // r2
  unsigned int v104; // r3
  int v105; // r0
  unsigned int v106; // r2
  unsigned int v107; // r3
  unsigned int v108; // r0
  unsigned int v109; // r3
  _DWORD *v110; // r2
  int v111; // r3
  int v112; // r2
  int v113; // r2
  int v114; // r4
  size_t v115; // r6
  _DWORD *v116; // r0
  _DWORD *v117; // r8
  int v118; // r1
  unsigned int v119; // r6
  int v120; // r11
  int v121; // r5
  _DWORD *v122; // r4
  _DWORD *v123; // r10
  int v124; // r6
  char *v125; // r7
  unsigned int v126; // r3
  int v127; // r3
  _DWORD *v128; // r3
  unsigned int v129; // r1
  unsigned int v130; // r2
  bool v131; // cc
  int v132; // r2
  int v133; // r3
  signed int v134; // s16
  double v135; // r0
  double v136; // d8
  struct tm *v137; // r0
  int j; // r3
  int v139; // r1
  int v140; // r2
  int v141; // r3
  int v142; // r1
  int v143; // r2
  int v144; // r3
  int v145; // r2
  const char *v146; // r3
  unsigned __int64 v147; // r0
  int v148; // [sp+8h] [bp-87Ch]
  unsigned int i; // [sp+8h] [bp-87Ch]
  _DWORD *v150; // [sp+Ch] [bp-878h]
  int v151; // [sp+10h] [bp-874h]
  int v152; // [sp+14h] [bp-870h]
  time_t timer; // [sp+18h] [bp-86Ch] BYREF
  int s2; // [sp+1Ch] [bp-868h] BYREF
  int v155; // [sp+20h] [bp-864h]
  int v156; // [sp+24h] [bp-860h]
  int v157; // [sp+28h] [bp-85Ch]
  int v158; // [sp+2Ch] [bp-858h]
  int v159; // [sp+30h] [bp-854h]
  int v160; // [sp+34h] [bp-850h]
  int v161; // [sp+38h] [bp-84Ch]
  char s[68]; // [sp+3Ch] [bp-848h] BYREF
  char v163[2052]; // [sp+80h] [bp-804h] BYREF

  v3 = a1;
  v150 = *(_DWORD **)(a1 + 260);
  if ( *(_BYTE *)(a1 + 282) )
    return 1;
  v6 = *(_DWORD *)(a1 + 28);
  v7 = *(_DWORD *)(a1 + 12);
  v8 = *(_DWORD *)(a1 + 8);
  v9 = *(_DWORD *)(a1 + 24);
  v10 = *(_DWORD *)(a1 + 20);
  v11 = *(_DWORD *)(a1 + 16);
  s2 = *(_DWORD *)(a1 + 32);
  v12 = *(_DWORD *)(a1 + 4);
  v159 = v7;
  v160 = v8;
  v161 = v12;
  v155 = v6;
  v156 = v9;
  v157 = v10;
  v158 = v11;
  sub_29460(s, (char *)&s2, 32);
  if ( pthread_rwlock_rdlock(&stru_61550) )
    sub_B76C("block_exists", 5325);
  v13 = dword_61570;
  if ( dword_61570 )
  {
    v14 = strlen(s);
    v15 = -1640531527;
    v16 = (unsigned __int8 *)s;
    v17 = -1640531527;
    v18 = v14;
    v131 = v14 > 0xB;
    v19 = -17973521;
    v20 = v18;
    if ( v131 )
    {
      do
      {
        v20 -= 12;
        v1 = v16[7];
        v21 = (v16[6] << 16) + (v16[5] << 8) + v16[4] + (v1 << 24) + v15;
        v22 = (v16[2] << 16) + (v16[1] << 8) + *v16;
        v23 = v16[3];
        v24 = v16[11];
        v25 = (v16[10] << 16) + (v16[9] << 8) + v16[8];
        v16 += 12;
        v26 = v25 + (v24 << 24) + v19;
        v27 = (v22 + (v23 << 24) - v21 - v26 + v17) ^ (v26 >> 13);
        v28 = (v21 - v26 - v27) ^ (v27 << 8);
        v29 = (v26 - v27 - v28) ^ (v28 >> 13);
        v30 = (v27 - v28 - v29) ^ (v29 >> 12);
        v31 = (v28 - v29 - v30) ^ (v30 << 16);
        v32 = (v29 - v30 - v31) ^ (v31 >> 5);
        v17 = (v30 - v31 - v32) ^ (v32 >> 3);
        v15 = (v31 - v32 - v17) ^ (v17 << 10);
        v19 = (v32 - v17 - v15) ^ (v15 >> 15);
      }
      while ( v20 > 0xB );
    }
    v33 = v19 + v18;
    switch ( v20 )
    {
      case 1u:
        goto LABEL_21;
      case 2u:
        goto LABEL_20;
      case 3u:
        goto LABEL_19;
      case 4u:
        goto LABEL_18;
      case 5u:
        goto LABEL_17;
      case 6u:
        goto LABEL_16;
      case 7u:
        goto LABEL_15;
      case 8u:
        goto LABEL_14;
      case 9u:
        goto LABEL_13;
      case 0xAu:
        goto LABEL_12;
      case 0xBu:
        v33 += v16[10] << 24;
LABEL_12:
        v33 += v16[9] << 16;
LABEL_13:
        v33 += v16[8] << 8;
LABEL_14:
        v15 += v16[7] << 24;
LABEL_15:
        v15 += v16[6] << 16;
LABEL_16:
        v15 += v16[5] << 8;
LABEL_17:
        v15 += v16[4];
LABEL_18:
        v17 += v16[3] << 24;
LABEL_19:
        v17 += v16[2] << 16;
LABEL_20:
        v17 += v16[1] << 8;
LABEL_21:
        v17 += *v16;
        break;
      default:
        break;
    }
    v34 = *(_DWORD **)(dword_61570 + 68);
    v35 = (v17 - v15 - v33) ^ (v33 >> 13);
    v36 = (v15 - v33 - v35) ^ (v35 << 8);
    v37 = (v33 - v35 - v36) ^ (v36 >> 13);
    v38 = (v35 - v36 - v37) ^ (v37 >> 12);
    v39 = (v36 - v37 - v38) ^ (v38 << 16);
    v40 = (v37 - v38 - v39) ^ (v39 >> 5);
    v41 = (v38 - v39 - v40) ^ (v40 >> 3);
    v13 = *(_DWORD *)(*v34
                    + 12
                    * (((v40 - v41 - ((v39 - v40 - v41) ^ (v41 << 10)))
                      ^ (((v39 - v40 - v41) ^ (v41 << 10)) >> 15))
                     & (v34[1] - 1)));
    if ( !v13 )
      goto LABEL_24;
    do
    {
      v13 -= v34[5];
LABEL_24:
      if ( !v13 || v18 == *(_DWORD *)(v13 + 92) && !memcmp(*(const void **)(v13 + 88), s, v18) )
        break;
      v13 = *(_DWORD *)(v13 + 84);
    }
    while ( v13 );
  }
  if ( pthread_rwlock_unlock(&stru_61550) )
    sub_B700("block_exists", 5327);
  off_60178();
  if ( v13 )
  {
    if ( !memcmp(v150 + 134, &s2, 0x20u) )
    {
      v4 = 1;
    }
    else if ( !memcmp(&s2, dword_6157C, 0x20u) )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(v163, 0x800u, "Pool %d now up to date", *v150);
        sub_38438(7, v163, 0);
      }
      v4 = 1;
      v76 = v155;
      v77 = v156;
      v78 = v157;
      v150[134] = s2;
      v150[135] = v76;
      v150[136] = v77;
      v150[137] = v78;
      v79 = v159;
      v80 = v160;
      v81 = v161;
      v150[138] = v158;
      v150[139] = v79;
      v150[140] = v80;
      v150[141] = v81;
    }
    else
    {
      v4 = (unsigned __int8)byte_630C1;
      if ( byte_630C1 )
      {
        if ( byte_632F0 || (v4 = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6 )
        {
          v4 = 0;
          snprintf(v163, 0x800u, "Stale data from pool %d", *v150);
          sub_38438(7, v163, 0);
        }
      }
    }
    if ( *(_BYTE *)(v3 + 280) )
    {
      v131 = (unsigned int)(dword_611AC - 3) > 1;
      *(_DWORD *)(v3 + 336) = ++dword_6136C;
      if ( !v131 || (v42 = *(_DWORD *)(v3 + 260), v42 == sub_1D644()) )
      {
        if ( *(_BYTE *)(v3 + 284) )
        {
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(v163, 0x800u, "Stratum from pool %d requested work restart", *v150);
            sub_38438(7, v163, 0);
          }
        }
        else if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v43 = "";
          if ( *(_BYTE *)(v3 + 324) )
            v43 = "GBT ";
          snprintf(v163, 0x800u, "%sLONGPOLL from pool %d requested work restart", v43, **(_DWORD **)(v3 + 260));
          sub_38438(7, v163, 0);
        }
        sub_16C8C();
      }
    }
    goto LABEL_41;
  }
  v44 = (char *)calloc(0x68u, 1u);
  v45 = (int)v44;
  if ( !v44 )
  {
    strcpy(v163, "test_work_current OOM");
    sub_38438(3, v163, 1);
    sub_16724(1);
  }
  strcpy(v44, s);
  v46 = dword_640BC++;
  *(_DWORD *)(v45 + 100) = v46;
  if ( pthread_rwlock_wrlock(&stru_61550) )
    sub_B550("test_work_current", 5392);
  v47 = dword_61570;
  if ( !dword_61570 )
  {
    *(_DWORD *)(v45 + 76) = 0;
    *(_DWORD *)(v45 + 88) = v45;
    v151 = 0;
    *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
    goto LABEL_105;
  }
  if ( *(_DWORD *)(*(_DWORD *)(dword_61570 + 68) + 12) <= 6u )
  {
    *(_DWORD *)(v45 + 88) = v45;
    *(_DWORD *)(v45 + 76) = 0;
    v151 = 0;
    *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
    goto LABEL_137;
  }
  v48 = dword_61570 + 68;
  v49 = 1;
  while ( 2 )
  {
    v50 = v48;
    v48 = 0;
    v51 = 0;
    v52 = 0;
    do
    {
      ++v52;
      if ( v49 )
      {
        v53 = *(_DWORD *)(v50 + 8);
        if ( v53 )
        {
          v55 = *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
          v54 = 1;
          for ( v53 += v55; v53; v53 += v55 )
          {
            if ( v54 == v49 )
              break;
            v53 = *(_DWORD *)(v53 + 8);
            ++v54;
            if ( !v53 )
              break;
          }
        }
        else
        {
          v54 = 1;
        }
      }
      else
      {
        v53 = v50;
        v54 = 0;
      }
      v56 = v50;
      v57 = v49;
      v50 = v53;
      while ( v54 )
      {
LABEL_69:
        v58 = v57 == 0;
        if ( v57 )
          v58 = v50 == 0;
        if ( v58 )
        {
          if ( !v56 )
            goto LABEL_128;
          v13 = *(_DWORD *)(v56 + 8);
          if ( v13 )
            v13 += *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
LABEL_76:
          --v54;
          if ( !v51 )
            goto LABEL_125;
LABEL_77:
          if ( v56 )
          {
            *(_DWORD *)(v51 + 8) = v56 - *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
            v59 = v51 - *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
            v51 = v56;
            v56 = v13;
            goto LABEL_79;
          }
          *(_DWORD *)(v51 + 8) = 0;
          v51 = 0;
          v56 = v13;
        }
        else
        {
          v75 = *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
          v1 = *(_DWORD *)(v50 - v75 + 100);
          v13 = *(_DWORD *)(v56 - v75 + 100) - v1;
          if ( v13 > 0 )
          {
            v1 = *(_DWORD *)(v50 + 8);
            if ( v1 )
              v1 += v75;
            goto LABEL_113;
          }
          if ( !v56 )
          {
LABEL_128:
            v13 = v56;
            goto LABEL_76;
          }
          v13 = *(_DWORD *)(v56 + 8);
          --v54;
          if ( v13 )
            v13 += v75;
          if ( v51 )
            goto LABEL_77;
LABEL_125:
          if ( v56 )
          {
            v51 = v56;
            v59 = 0;
            v56 = v13;
            v48 = v51;
            goto LABEL_79;
          }
          v48 = 0;
          v56 = v13;
          v51 = 0;
        }
      }
      while ( 1 )
      {
        v60 = v50 == 0;
        if ( v50 )
          v60 = v57 == 0;
        if ( v60 )
          break;
        v74 = *(_DWORD *)(v50 + 8);
        if ( v74 )
          v13 = *(_DWORD *)(v47 + 68);
        else
          v1 = v54;
        if ( v74 )
        {
          v13 = *(_DWORD *)(v13 + 20);
          v1 = v74 + v13;
        }
LABEL_113:
        --v57;
        if ( v51 )
        {
          v13 = v56;
          v56 = v50;
          v50 = v1;
          goto LABEL_77;
        }
        v51 = v50;
        v59 = 0;
        v50 = v1;
        v48 = v51;
LABEL_79:
        *(_DWORD *)(v51 + 4) = v59;
        if ( v54 )
          goto LABEL_69;
      }
    }
    while ( v50 );
    if ( v51 )
      *(_DWORD *)(v51 + 8) = 0;
    if ( v52 > 1 )
    {
      v49 *= 2;
      if ( !v48 )
      {
        v51 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 16) = v51;
  v61 = v48 - *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
  dword_61570 = v61;
  v62 = *(_DWORD *)(v61 + 72);
  v151 = *(_DWORD *)(v61 + 100);
  if ( v62 || *(_DWORD *)(v61 + 76) )
  {
    v63 = *(_DWORD *)(v61 + 68);
    v64 = *(_DWORD *)(v63 + 20);
    if ( v61 == *(_DWORD *)(v63 + 16) - v64 )
    {
      *(_DWORD *)(v63 + 16) = v62 + v64;
      v62 = *(_DWORD *)(v61 + 72);
    }
    if ( v62 )
    {
      v47 = v61;
      *(_DWORD *)(v62 + *(_DWORD *)(*(_DWORD *)(v61 + 68) + 20) + 8) = *(_DWORD *)(v61 + 76);
      v65 = *(_DWORD *)(v61 + 76);
    }
    else
    {
      v65 = *(_DWORD *)(v61 + 76);
      v47 = v65;
      dword_61570 = v65;
    }
    if ( v65 )
      *(_DWORD *)(v65 + *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20) + 4) = *(_DWORD *)(v61 + 72);
    v66 = *(_DWORD **)(v47 + 68);
    v67 = 12 * ((v66[1] - 1) & *(_DWORD *)(v61 + 96));
    --*(_DWORD *)(*v66 + v67 + 4);
    v68 = **(_DWORD **)(v47 + 68);
    if ( *(_DWORD *)(v68 + v67) == v61 + 68 )
      *(_DWORD *)(v68 + v67) = *(_DWORD *)(v61 + 84);
    v69 = *(_DWORD *)(v61 + 80);
    if ( v69 )
      *(_DWORD *)(v69 + 16) = *(_DWORD *)(v61 + 84);
    v70 = *(_DWORD *)(v61 + 84);
    if ( v70 )
      *(_DWORD *)(v70 + 12) = *(_DWORD *)(v61 + 80);
    --*(_DWORD *)(*(_DWORD *)(v47 + 68) + 12);
  }
  else
  {
    v47 = 0;
    free(**(void ***)(v61 + 68));
    free(*(void **)(v61 + 68));
    dword_61570 = 0;
  }
  free((void *)v61);
  *(_DWORD *)(v45 + 88) = v45;
  *(_DWORD *)(v45 + 76) = 0;
  *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
  if ( !v47 )
  {
LABEL_105:
    *(_DWORD *)(v45 + 72) = 0;
    dword_61570 = v45;
    v71 = malloc(0x2Cu);
    v72 = v71;
    *(_DWORD *)(v45 + 68) = v71;
    if ( v71 )
    {
      v148 = v45 + 68;
      *v71 = 0;
      v71[3] = 0;
      v71[4] = 0;
      v71[5] = 0;
      v71[6] = 0;
      v71[7] = 0;
      v71[8] = 0;
      v71[9] = 0;
      v71[10] = 0;
      v71[1] = 32;
      v71[4] = v45 + 68;
      v71[2] = 5;
      v71[5] = 68;
      v73 = malloc(0x180u);
      *v72 = v73;
      if ( v73 )
      {
        memset(v73, 0, 0x180u);
        v47 = v45;
        v72[10] = -1609490463;
        goto LABEL_138;
      }
    }
LABEL_251:
    exit(-1);
  }
LABEL_137:
  v148 = v45 + 68;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v47 + 68) + 16) + 8) = v45;
  *(_DWORD *)(v45 + 72) = *(_DWORD *)(*(_DWORD *)(v47 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v47 + 68) + 20);
  *(_DWORD *)(*(_DWORD *)(v47 + 68) + 16) = v45 + 68;
  v72 = *(_DWORD **)(v47 + 68);
LABEL_138:
  v82 = -17973521;
  ++v72[3];
  v83 = *(_DWORD *)(v47 + 68);
  v84 = -1640531527;
  *(_DWORD *)(v45 + 96) = -17973521;
  *(_DWORD *)(v45 + 68) = v83;
  v85 = strlen((const char *)v45);
  v86 = v85;
  if ( v85 <= 0xB )
  {
    v88 = -1640531527;
    v87 = (unsigned __int8 *)v45;
  }
  else
  {
    v87 = (unsigned __int8 *)v45;
    v88 = -1640531527;
    do
    {
      v86 -= 12;
      v89 = (v87[2] << 16) + (v87[1] << 8) + *v87;
      v90 = v87[3];
      v91 = (v87[6] << 16) + (v87[5] << 8) + v87[4];
      v92 = v87[7];
      v93 = (v87[10] << 16) + (v87[9] << 8) + v87[8] + (v87[11] << 24) + v82;
      v87 += 12;
      v94 = v91 + (v92 << 24) + v84;
      v95 = (v89 + (v90 << 24) - v93 - v94 + v88) ^ (v93 >> 13);
      v96 = (v94 - v93 - v95) ^ (v95 << 8);
      v97 = (v93 - v95 - v96) ^ (v96 >> 13);
      v98 = (v95 - v96 - v97) ^ (v97 >> 12);
      v99 = (v96 - v97 - v98) ^ (v98 << 16);
      v100 = (v97 - v98 - v99) ^ (v99 >> 5);
      v88 = (v98 - v99 - v100) ^ (v100 >> 3);
      v84 = (v99 - v100 - v88) ^ (v88 << 10);
      v82 = (v100 - v88 - v84) ^ (v84 >> 15);
      *(_DWORD *)(v45 + 96) = v82;
    }
    while ( v86 > 0xB );
    v85 = strlen((const char *)v45);
  }
  v101 = v85 + v82;
  *(_DWORD *)(v45 + 96) = v101;
  switch ( v86 )
  {
    case 1u:
      goto LABEL_153;
    case 2u:
      goto LABEL_152;
    case 3u:
      goto LABEL_151;
    case 4u:
      goto LABEL_150;
    case 5u:
      goto LABEL_149;
    case 6u:
      goto LABEL_148;
    case 7u:
      goto LABEL_147;
    case 8u:
      goto LABEL_146;
    case 9u:
      goto LABEL_145;
    case 0xAu:
      goto LABEL_144;
    case 0xBu:
      v101 += v87[10] << 24;
      *(_DWORD *)(v45 + 96) = v101;
LABEL_144:
      v101 += v87[9] << 16;
      *(_DWORD *)(v45 + 96) = v101;
LABEL_145:
      v101 += v87[8] << 8;
      *(_DWORD *)(v45 + 96) = v101;
LABEL_146:
      v84 += v87[7] << 24;
LABEL_147:
      v84 += v87[6] << 16;
LABEL_148:
      v84 += v87[5] << 8;
LABEL_149:
      v84 += v87[4];
LABEL_150:
      v88 += v87[3] << 24;
LABEL_151:
      v88 += v87[2] << 16;
LABEL_152:
      v88 += v87[1] << 8;
LABEL_153:
      v88 += *v87;
      break;
    default:
      break;
  }
  v102 = (v88 - v84 - v101) ^ (v101 >> 13);
  v103 = (v84 - v101 - v102) ^ (v102 << 8);
  v104 = (v101 - v102 - v103) ^ (v103 >> 13);
  v105 = (v102 - v103 - v104) ^ (v104 >> 12);
  v106 = (v103 - v104 - v105) ^ (v105 << 16);
  v107 = (v104 - v105 - v106) ^ (v106 >> 5);
  v108 = v105 - v106 - v107;
  v109 = (v107 - (v108 ^ (v107 >> 3)) - ((v106 - v107 - (v108 ^ (v107 >> 3))) ^ ((v108 ^ (v107 >> 3)) << 10)))
       ^ (((v106 - v107 - (v108 ^ (v107 >> 3))) ^ ((v108 ^ (v107 >> 3)) << 10)) >> 15);
  *(_DWORD *)(v45 + 96) = v109;
  v110 = *(_DWORD **)(v47 + 68);
  v111 = 12 * (v109 & (v110[1] - 1));
  ++*(_DWORD *)(*v110 + v111 + 4);
  v112 = *(_DWORD *)(**(_DWORD **)(v47 + 68) + v111);
  *(_DWORD *)(v45 + 80) = 0;
  *(_DWORD *)(v45 + 84) = v112;
  v113 = **(_DWORD **)(v47 + 68) + v111;
  if ( *(_DWORD *)v113 )
  {
    *(_DWORD *)(*(_DWORD *)v113 + 12) = v148;
    v113 = **(_DWORD **)(v47 + 68) + v111;
  }
  *(_DWORD *)v113 = v148;
  if ( *(_DWORD *)(**(_DWORD **)(v47 + 68) + v111 + 4) >= (unsigned int)(10
                                                                       * (*(_DWORD *)(**(_DWORD **)(v47 + 68) + v111 + 8)
                                                                        + 1)) )
  {
    v114 = *(_DWORD *)(v45 + 68);
    if ( *(_DWORD *)(v114 + 36) != 1 )
    {
      v115 = 24 * *(_DWORD *)(v114 + 4);
      v116 = malloc(v115);
      v117 = v116;
      if ( !v116 )
        goto LABEL_251;
      memset(v116, 0, v115);
      *(_DWORD *)(v114 + 24) = (((2 * *(_DWORD *)(v114 + 4) - 1) & *(_DWORD *)(v114 + 12)) != 0)
                             + (*(_DWORD *)(v114 + 12) >> (*(_BYTE *)(v114 + 8) + 1));
      *(_DWORD *)(*(_DWORD *)(v45 + 68) + 28) = 0;
      v118 = *(_DWORD *)(v45 + 68);
      v119 = *(_DWORD *)(v118 + 4);
      if ( v119 )
      {
        v152 = v3;
        v120 = 0;
        v121 = v45;
        for ( i = 0; i < v119; ++i )
        {
          v122 = *(_DWORD **)(*(_DWORD *)v118 + v120);
          if ( v122 )
          {
            while ( 1 )
            {
              v123 = (_DWORD *)v122[4];
              v124 = 3 * ((2 * v119 - 1) & v122[7]);
              v125 = (char *)&v117[v124];
              v126 = *((_DWORD *)v125 + 1) + 1;
              *((_DWORD *)v125 + 1) = v126;
              if ( v126 > *(_DWORD *)(v118 + 24) )
              {
                ++*(_DWORD *)(v118 + 28);
                *((_DWORD *)v125 + 2) = *((_DWORD *)v125 + 1) / *(_DWORD *)(*(_DWORD *)(v121 + 68) + 24);
              }
              v122[3] = 0;
              v122[4] = v117[v124];
              v127 = v117[v124];
              if ( v127 )
                *(_DWORD *)(v127 + 12) = v122;
              v117[v124] = v122;
              v118 = *(_DWORD *)(v121 + 68);
              if ( !v123 )
                break;
              v119 = *(_DWORD *)(v118 + 4);
              v122 = v123;
            }
            v119 = *(_DWORD *)(v118 + 4);
          }
          v120 += 12;
        }
        v45 = v121;
        v3 = v152;
      }
      free(*(void **)v118);
      *(_DWORD *)(*(_DWORD *)(v45 + 68) + 4) *= 2;
      ++*(_DWORD *)(*(_DWORD *)(v45 + 68) + 8);
      **(_DWORD **)(v45 + 68) = v117;
      v128 = *(_DWORD **)(v45 + 68);
      v129 = v128[3];
      v130 = v128[7];
      v131 = v130 > v129 >> 1;
      if ( v130 <= v129 >> 1 )
        v132 = 0;
      else
        v132 = v128[8];
      if ( v131 )
        ++v132;
      v128[8] = v132;
      v133 = *(_DWORD *)(v45 + 68);
      if ( *(_DWORD *)(v133 + 32) > 1u )
        *(_DWORD *)(v133 + 36) = 1;
    }
  }
  LODWORD(v2) = 8 * (29 - *(unsigned __int8 *)(v3 + 72));
  v134 = bswap32(*(_DWORD *)(v3 + 72)) & 0xFFFFFF;
  LODWORD(v135) = sub_493C8(vshld_u64(0xFFFFu, v2));
  v136 = v135 / (double)v134;
  if ( v136 != dbl_60080 )
  {
    LODWORD(v147) = sub_494C0(v136);
    sub_11130(v147, byte_61574, 8u, 0);
    dbl_60080 = v136;
    if ( byte_630C1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
      {
        snprintf(v163, 0x800u, "Network diff set to %s", byte_61574);
        sub_38438(7, v163, 0);
      }
    }
  }
  if ( pthread_rwlock_unlock(&stru_61550) )
    sub_B700("test_work_current", 5408);
  off_60178();
  if ( v151 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v163, 0x800u, "Deleted block %d from database", v151);
    sub_38438(7, v163, 0);
  }
  if ( pthread_mutex_lock(&stru_63F78) )
    sub_B4E4("set_curblock", 5302);
  if ( pthread_rwlock_wrlock(&stru_63F90) )
    sub_B550("set_curblock", 5302);
  sub_2B13C((struct timeval *)&dword_63618);
  strcpy(dest, s);
  timer = dword_63618;
  dword_6157C[0] = s2;
  dword_6157C[1] = v155;
  dword_6157C[2] = v156;
  dword_6157C[3] = v157;
  unk_6158C = v158;
  unk_61590 = v159;
  unk_61594 = v160;
  unk_61598 = v161;
  v137 = localtime(&timer);
  snprintf(byte_6159C, 0x20u, "[%02d:%02d:%02d]", v137->tm_hour, v137->tm_min, v137->tm_sec);
  if ( pthread_rwlock_unlock(&stru_63F90) )
    sub_B700("set_curblock", 5307);
  if ( pthread_mutex_unlock(&stru_63F78) )
    sub_B694("set_curblock", 5307);
  off_60178();
  for ( j = 0; j != 57; ++j )
  {
    if ( dest[j] != 48 )
      break;
  }
  strncpy(byte_615BC, &dest[j], 8u);
  byte_615C4 = 0;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v163, 0x800u, "New block: %s... diff %s", dest, byte_61574);
    sub_38438(7, v163, 0);
  }
  v139 = v155;
  v140 = v156;
  v141 = v157;
  v58 = dword_640BC == 1;
  v150[134] = s2;
  v150[135] = v139;
  v150[136] = v140;
  v150[137] = v141;
  v142 = v159;
  v143 = v160;
  v144 = v161;
  v150[138] = v158;
  v150[139] = v142;
  v150[140] = v143;
  v150[141] = v144;
  if ( v58 )
  {
    v4 = 0;
LABEL_41:
    *(_BYTE *)(v3 + 280) = 0;
    return v4;
  }
  v145 = *(unsigned __int8 *)(v3 + 280);
  *(_DWORD *)(v3 + 336) = ++dword_6136C;
  if ( v145 )
  {
    if ( *(_BYTE *)(v3 + 284) )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(v163, 0x800u, "Stratum from pool %d detected new block", *v150);
        sub_38438(7, v163, 0);
      }
    }
    else if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      v146 = "";
      if ( *(_BYTE *)(v3 + 324) )
        v146 = "GBT ";
      snprintf(v163, 0x800u, "%sLONGPOLL from pool %d detected new block", v146, **(_DWORD **)(v3 + 260));
      sub_38438(7, v163, 0);
    }
  }
  else if ( byte_64219 )
  {
    if ( !*((_BYTE *)v150 + 868) && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(v163, "New block detected on network before pool notification");
      sub_38438(7, v163, 0);
    }
  }
  else if ( !*((_BYTE *)v150 + 868) && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v163, "New block detected on network");
    sub_38438(7, v163, 0);
  }
  sub_16C8C();
  v4 = 1;
  *(_BYTE *)(v3 + 280) = 0;
  return v4;
}
// 1D8D4: control flows out of bounds to 1D8D8
// 1E274: control flows out of bounds to 1E278
// 1DF7C: variable 'v1' is possibly undefined
// 1E5F8: variable 'v2' is possibly undefined
// 1E610: variable 'v135' is possibly undefined
// 1EC50: variable 'v147' is possibly undefined
// 60080: using guessed type double dbl_60080;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 611AC: using guessed type int dword_611AC;
// 6136C: using guessed type int dword_6136C;
// 61570: using guessed type int dword_61570;
// 6157C: using guessed type _DWORD dword_6157C[4];
// 615C4: using guessed type char byte_615C4;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63618: using guessed type int dword_63618;
// 640BC: using guessed type int dword_640BC;
// 64219: using guessed type char byte_64219;

//----- (0001ED4C) --------------------------------------------------------
int __fastcall sub_1ED4C(int a1)
{
  _DWORD *v1; // r11
  pthread_mutex_t *v3; // r0
  int v4; // r0
  int v5; // r6
  int v6; // r8
  int v7; // r9
  int v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r0
  int v11; // r1
  unsigned int v12; // r2
  unsigned int v13; // r3
  unsigned int v14; // r1
  unsigned int v15; // r3
  _DWORD *v16; // r2
  int v17; // r3
  int v18; // r2
  int v19; // r2
  int v20; // r7
  int v21; // r3
  size_t v22; // r6
  _DWORD *v23; // r0
  _DWORD *v24; // r8
  int v25; // r3
  int v26; // r1
  unsigned int v27; // r3
  _DWORD *v28; // r6
  int v29; // r7
  unsigned int v30; // r0
  int v31; // r3
  _DWORD *v32; // r3
  unsigned int v33; // r1
  unsigned int v34; // r2
  bool v35; // cc
  int v36; // r2
  int v37; // r3
  int v38; // r10
  int v39; // r0
  _DWORD *v40; // r12
  int v41; // lr
  unsigned int v42; // r8
  _DWORD *j; // r3
  int v44; // r2
  int v45; // r1
  int v46; // r1
  int v47; // r6
  bool v48; // zf
  int v49; // r3
  bool v50; // zf
  int v52; // r3
  int v53; // r3
  _DWORD *v54; // r0
  _DWORD *v55; // r7
  void *v56; // r0
  int v57; // r3
  void *v58; // r0
  int v59; // [sp+0h] [bp-80Ch]
  unsigned int i; // [sp+4h] [bp-808h]
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 260));
    sub_38438(7, s, 0);
  }
  *(_DWORD *)(a1 + 336) = dword_6136C;
  sub_1D6F8(a1);
  v3 = (pthread_mutex_t *)dword_612C8;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 260) + 68);
  if ( pthread_mutex_lock(v3) )
    sub_B4E4("hash_push", 5511);
  if ( !*(_BYTE *)(a1 + 273) && *(_DWORD *)(a1 + 276) )
    ++dword_612D4;
  v4 = dword_63BC0;
  if ( *(_BYTE *)(dword_63BC0 + 8) )
    goto LABEL_72;
  v5 = dword_612CC;
  *(_DWORD *)(a1 + 352) = *(unsigned __int8 *)(dword_63BC0 + 8);
  *(_DWORD *)(a1 + 364) = a1 + 340;
  *(_DWORD *)(a1 + 368) = 4;
  if ( v5 )
  {
    v6 = a1 + 344;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) + 8) = a1;
    *(_DWORD *)(a1 + 348) = *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 344) + 20);
    *(_DWORD *)(*(_DWORD *)(v5 + 344) + 16) = a1 + 344;
  }
  else
  {
    *(_DWORD *)(a1 + 348) = 0;
    dword_612CC = a1;
    v54 = malloc(0x2Cu);
    v55 = v54;
    *(_DWORD *)(a1 + 344) = v54;
    if ( !v54 )
      goto LABEL_100;
    *v54 = 0;
    v54[3] = 0;
    v54[4] = 0;
    v6 = a1 + 344;
    v54[5] = 0;
    v54[6] = 0;
    v54[7] = 0;
    v54[8] = 0;
    v54[9] = 0;
    v54[10] = 0;
    v54[4] = a1 + 344;
    v54[1] = 32;
    v54[2] = 5;
    v54[5] = 344;
    v56 = malloc(0x180u);
    v57 = dword_612CC;
    *v55 = v56;
    v58 = **(void ***)(v57 + 344);
    if ( !v58 )
      goto LABEL_100;
    memset(v58, 0, 0x180u);
    v5 = dword_612CC;
    *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(v5 + 344) + 12);
  v7 = *(unsigned __int8 *)(a1 + 342);
  v8 = (*(unsigned __int8 *)(a1 + 340)
      + 17973517
      + (*(unsigned __int8 *)(a1 + 343) << 24)
      + (v7 << 16)
      + (*(unsigned __int8 *)(a1 + 341) << 8))
     ^ 0x7F76D;
  *(_DWORD *)(a1 + 344) = *(_DWORD *)(v5 + 344);
  v9 = (-1622558010 - v8) ^ (v8 << 8);
  v10 = (-17973517 - v8 - v9) ^ (v9 >> 13);
  v11 = (v8 - v9 - v10) ^ (v10 >> 12);
  v12 = (v9 - v10 - v11) ^ (v11 << 16);
  v13 = (v10 - v11 - v12) ^ (v12 >> 5);
  v14 = v11 - v12 - v13;
  v15 = (v13 - (v14 ^ (v13 >> 3)) - ((v12 - v13 - (v14 ^ (v13 >> 3))) ^ ((v14 ^ (v13 >> 3)) << 10)))
      ^ (((v12 - v13 - (v14 ^ (v13 >> 3))) ^ ((v14 ^ (v13 >> 3)) << 10)) >> 15);
  *(_DWORD *)(a1 + 372) = v15;
  v16 = *(_DWORD **)(v5 + 344);
  v17 = 12 * (v15 & (v16[1] - 1));
  ++*(_DWORD *)(*v16 + v17 + 4);
  v18 = *(_DWORD *)(**(_DWORD **)(v5 + 344) + v17);
  *(_DWORD *)(a1 + 356) = 0;
  *(_DWORD *)(a1 + 360) = v18;
  v19 = **(_DWORD **)(v5 + 344) + v17;
  if ( *(_DWORD *)v19 )
  {
    *(_DWORD *)(*(_DWORD *)v19 + 12) = v6;
    v19 = **(_DWORD **)(v5 + 344) + v17;
  }
  *(_DWORD *)v19 = v6;
  v20 = dword_612CC;
  if ( *(_DWORD *)(**(_DWORD **)(dword_612CC + 344) + v17 + 4) >= (unsigned int)(10
                                                                               * (*(_DWORD *)(**(_DWORD **)(dword_612CC + 344)
                                                                                            + v17
                                                                                            + 8)
                                                                                + 1)) )
  {
    v21 = *(_DWORD *)(a1 + 344);
    if ( *(_DWORD *)(v21 + 36) != 1 )
    {
      v22 = 24 * *(_DWORD *)(v21 + 4);
      v23 = malloc(v22);
      v24 = v23;
      if ( v23 )
      {
        memset(v23, 0, v22);
        v25 = *(_DWORD *)(a1 + 344);
        v7 = 0;
        *(_DWORD *)(v25 + 24) = (((2 * *(_DWORD *)(v25 + 4) - 1) & *(_DWORD *)(v25 + 12)) != 0)
                              + (*(_DWORD *)(v25 + 12) >> (*(_BYTE *)(v25 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 28) = 0;
        v26 = *(_DWORD *)(a1 + 344);
        v27 = *(_DWORD *)(v26 + 4);
        if ( v27 )
        {
          v59 = 0;
          for ( i = 0; i < v27; ++i )
          {
            v28 = *(_DWORD **)(*(_DWORD *)v26 + v59);
            if ( v28 )
            {
              while ( 1 )
              {
                v1 = (_DWORD *)v28[4];
                v29 = 3 * ((2 * v27 - 1) & v28[7]);
                v7 = (int)&v24[3 * ((2 * v27 - 1) & v28[7])];
                v30 = *(_DWORD *)(v7 + 4) + 1;
                *(_DWORD *)(v7 + 4) = v30;
                if ( v30 > *(_DWORD *)(v26 + 24) )
                {
                  ++*(_DWORD *)(v26 + 28);
                  *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 4) / *(_DWORD *)(*(_DWORD *)(a1 + 344) + 24);
                }
                v28[3] = 0;
                v28[4] = v24[v29];
                v31 = v24[v29];
                if ( v31 )
                  *(_DWORD *)(v31 + 12) = v28;
                v24[v29] = v28;
                v26 = *(_DWORD *)(a1 + 344);
                if ( !v1 )
                  break;
                v27 = *(_DWORD *)(v26 + 4);
                v28 = v1;
              }
              v27 = *(_DWORD *)(v26 + 4);
            }
            v59 += 12;
          }
        }
        free(*(void **)v26);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8);
        **(_DWORD **)(a1 + 344) = v24;
        v32 = *(_DWORD **)(a1 + 344);
        v20 = dword_612CC;
        v33 = v32[3];
        v34 = v32[7];
        v35 = v34 > v33 >> 1;
        if ( v34 <= v33 >> 1 )
          v36 = 0;
        else
          v36 = v32[8];
        if ( v35 )
          ++v36;
        v32[8] = v36;
        v37 = *(_DWORD *)(a1 + 344);
        if ( *(_DWORD *)(v37 + 32) > 1u )
          *(_DWORD *)(v37 + 36) = 1;
        if ( !v20 )
        {
          v4 = dword_63BC0;
          goto LABEL_72;
        }
        goto LABEL_38;
      }
LABEL_100:
      exit(-1);
    }
  }
LABEL_38:
  v38 = v20 + 344;
  v39 = 1;
  while ( 2 )
  {
    v40 = (_DWORD *)v38;
    v38 = 0;
    v41 = 0;
    v42 = 0;
    do
    {
      ++v42;
      if ( v39 )
      {
        j = (_DWORD *)v40[2];
        if ( j )
        {
          v45 = *(_DWORD *)(*(_DWORD *)(v20 + 344) + 20);
          v44 = 1;
          for ( j = (_DWORD *)((char *)j + v45); j; j = (_DWORD *)((char *)j + v45) )
          {
            if ( v44 == v39 )
              break;
            j = (_DWORD *)j[2];
            ++v44;
            if ( !j )
              break;
          }
        }
        else
        {
          v44 = 1;
        }
      }
      else
      {
        j = v40;
        v44 = 0;
      }
      v46 = (int)v40;
      v47 = v39;
      v40 = j;
      while ( v44 )
      {
LABEL_50:
        v48 = v47 == 0;
        if ( v47 )
          v48 = v40 == 0;
        if ( v48 )
        {
          if ( !v46 )
            goto LABEL_94;
          v7 = *(_DWORD *)(v46 + 8);
          if ( v7 )
            v7 += *(_DWORD *)(*(_DWORD *)(v20 + 344) + 20);
LABEL_57:
          --v44;
          if ( !v41 )
            goto LABEL_91;
LABEL_58:
          if ( v46 )
          {
            *(_DWORD *)(v41 + 8) = v46 - *(_DWORD *)(*(_DWORD *)(v20 + 344) + 20);
            v49 = v41 - *(_DWORD *)(*(_DWORD *)(v20 + 344) + 20);
            v41 = v46;
            v46 = v7;
            goto LABEL_60;
          }
          *(_DWORD *)(v41 + 8) = 0;
          v41 = 0;
          v46 = v7;
        }
        else
        {
          v53 = *(_DWORD *)(*(_DWORD *)(v20 + 344) + 20);
          v1 = *(_DWORD **)((char *)v40 - v53 + 264);
          v7 = *(_DWORD *)(v46 - v53 + 264) - (_DWORD)v1;
          if ( v7 > 0 )
          {
            v1 = (_DWORD *)v40[2];
            if ( v1 )
              v1 = (_DWORD *)((char *)v1 + v53);
            goto LABEL_79;
          }
          if ( !v46 )
          {
LABEL_94:
            v7 = v46;
            goto LABEL_57;
          }
          v7 = *(_DWORD *)(v46 + 8);
          --v44;
          if ( v7 )
            v7 += v53;
          if ( v41 )
            goto LABEL_58;
LABEL_91:
          if ( v46 )
          {
            v41 = v46;
            v49 = 0;
            v46 = v7;
            v38 = v41;
            goto LABEL_60;
          }
          v38 = 0;
          v46 = v7;
          v41 = 0;
        }
      }
      while ( 1 )
      {
        v50 = v40 == 0;
        if ( v40 )
          v50 = v47 == 0;
        if ( v50 )
          break;
        v52 = v40[2];
        if ( v52 )
          v7 = *(_DWORD *)(v20 + 344);
        else
          v1 = (_DWORD *)v44;
        if ( v52 )
        {
          v7 = *(_DWORD *)(v7 + 20);
          v1 = (_DWORD *)(v52 + v7);
        }
LABEL_79:
        --v47;
        if ( v41 )
        {
          v7 = v46;
          v46 = (int)v40;
          v40 = v1;
          goto LABEL_58;
        }
        v41 = (int)v40;
        v49 = 0;
        v40 = v1;
        v38 = v41;
LABEL_60:
        *(_DWORD *)(v41 + 4) = v49;
        if ( v44 )
          goto LABEL_50;
      }
    }
    while ( v40 );
    if ( v41 )
      *(_DWORD *)(v41 + 8) = 0;
    if ( v42 > 1 )
    {
      v39 *= 2;
      if ( !v38 )
      {
        v41 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(*(_DWORD *)(v20 + 344) + 16) = v41;
  v4 = dword_63BC0;
  dword_612CC = v38 - *(_DWORD *)(*(_DWORD *)(v20 + 344) + 20);
LABEL_72:
  pthread_cond_broadcast((pthread_cond_t *)(v4 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
    sub_B694("hash_push", 5522);
  return off_60178();
}
// 1F328: variable 'v1' is possibly undefined
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 612C8: using guessed type int dword_612C8;
// 612CC: using guessed type int dword_612CC;
// 612D4: using guessed type int dword_612D4;
// 6136C: using guessed type int dword_6136C;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63BC0: using guessed type int dword_63BC0;

//----- (0001F500) --------------------------------------------------------
int __fastcall sub_1F500(int a1, int a2, int a3)
{
  int v6; // r1
  __int64 v7; // r2
  int v8; // r4
  int v10; // r0

  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("inc_work_stats", 8397);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_QWORD *)(v6 + 192) + a3;
  *(_QWORD *)&dword_636A8 += a3;
  *(_QWORD *)(v6 + 192) = v7;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v10 = sub_1D644();
    *(_QWORD *)(v10 + 40) += a3;
  }
  v8 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v8 + 232) = time(0);
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("inc_work_stats", 8410);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();
// 636A8: using guessed type int dword_636A8;

//----- (0001F5DC) --------------------------------------------------------
void __fastcall sub_1F5DC(int a1)
{
  int v2; // r0
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  if ( !sub_17E64(a1, (_BYTE *)(a1 + 97)) )
  {
    sub_2B13C((struct timeval *)(a1 + 136));
    v2 = sub_1D644();
    if ( v2 == a1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(s, 0x800u, "Pool %d %s not responding!", *(_DWORD *)v2, *(const char **)(v2 + 164));
        sub_38438(4, s, 0);
      }
      sub_195D4(0);
    }
    else if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 164));
      sub_38438(7, s, 0);
    }
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001F70C) --------------------------------------------------------
int sub_1F70C()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_63FB0) )
    sub_B4E4("cp_prio", 7014);
  if ( pthread_rwlock_rdlock(&stru_63FC8) )
    sub_B76C("cp_prio", 7014);
  if ( pthread_mutex_unlock(&stru_63FB0) )
    sub_B694("cp_prio", 7014);
  v0 = *(_DWORD *)(dword_61310 + 4);
  if ( pthread_rwlock_unlock(&stru_63FC8) )
    sub_B700("cp_prio", 7016);
  off_60178();
  return v0;
}
// 60178: using guessed type int (*off_60178)();
// 61310: using guessed type int dword_61310;

//----- (0001F7C4) --------------------------------------------------------
void __fastcall sub_1F7C4(_DWORD *a1)
{
  int v1; // r3
  int v3; // r5
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v1 = dword_611AC;
  a1[7] = 0;
  if ( v1 || (v3 = a1[1], v3 >= sub_1F70C()) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "Pool %d %s alive", *a1, (const char *)a1[41]);
      sub_38438(7, s, 0);
    }
  }
  else if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(s, 0x800u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[41]);
    sub_38438(4, s, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 611AC: using guessed type int dword_611AC;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001F8F4) --------------------------------------------------------
void __fastcall sub_1F8F4(_DWORD *a1)
{
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  if ( sub_1822C((int)a1, (_BYTE *)a1 + 97) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(v2, 0x800u, "Stratum connection to pool %d resumed", *a1);
      sub_38438(7, v2, 0);
    }
    sub_1F7C4(a1);
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001F99C) --------------------------------------------------------
void *__fastcall start_routine(_DWORD *a1)
{
  _BOOL4 v2; // r5
  int v3; // r5
  pthread_t v5; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  if ( !*((_BYTE *)a1 + 107) )
  {
    v5 = pthread_self();
    pthread_detach(v5);
  }
  while ( !sub_182A0(a1, 0) )
  {
    sub_1F5DC((int)a1);
    sleep(5u);
  }
  sub_17E64((int)a1, (_BYTE *)a1 + 98);
  sub_1822C((int)a1, (_BYTE *)a1 + 97);
  if ( pthread_mutex_lock(&stru_63FB0) )
    sub_B4E4("test_pool_thread", 10012);
  if ( pthread_rwlock_wrlock(&stru_63FC8) )
    sub_B550("test_pool_thread", 10012);
  if ( byte_615C8 )
  {
    v2 = 0;
  }
  else
  {
    v3 = *a1;
    dword_61310 = (int)a1;
    byte_615C8 = 1;
    v2 = v3 != 0;
  }
  if ( pthread_rwlock_unlock(&stru_63FC8) )
    sub_B700("test_pool_thread", 10020);
  if ( pthread_mutex_unlock(&stru_63FB0) )
    sub_B694("test_pool_thread", 10020);
  off_60178();
  if ( v2 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[41]);
    sub_38438(7, s, 0);
  }
  sub_1F7C4(a1);
  sub_195D4(0);
  *((_BYTE *)a1 + 284) = 0;
  return 0;
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 61310: using guessed type int dword_61310;
// 615C8: using guessed type char byte_615C8;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0001FB7C) --------------------------------------------------------
int __fastcall sub_1FB7C(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 100) != 1 )
    return 0;
  if ( dword_611AC == 4 || dword_611AC == 3 || *(_BYTE *)(a1 + 632) && *(_BYTE *)(a1 + 97) )
    return 1;
  if ( a1 == sub_1D644() )
    return 1;
  if ( *(_DWORD *)(a1 + 700) )
    return 1;
  if ( !dword_611AC )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < sub_1F70C() )
      return 1;
  }
  return (unsigned __int8)byte_612D0;
}
// 611AC: using guessed type int dword_611AC;
// 612D0: using guessed type char byte_612D0;

//----- (0001FC10) --------------------------------------------------------
void *__fastcall sub_1FC10(_DWORD *a1)
{
  pthread_t v2; // r0
  fd_set *v3; // r3
  int v4; // r3
  int v5; // r2
  int v6; // r0
  int *v7; // r5
  int *v9; // r0
  _DWORD *v10; // r0
  void **v11; // r6
  int v12; // r4
  unsigned int v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r0
  int v16; // r7
  int v17; // r1
  unsigned int v18; // r2
  unsigned int v19; // r3
  int v20; // r1
  _DWORD *v21; // r8
  int v22; // r7
  time_t v23; // r0
  int v24; // r3
  double v25; // d0
  unsigned int v26; // r8
  int v27; // r1
  __int64 v28; // d8
  const char *v29; // r2
  unsigned int v30; // r3
  _DWORD *v31; // r8
  double v32; // d18
  double v33; // d16
  double v34; // d16
  double v35; // d17
  _DWORD *v36; // r12
  size_t v37; // r0
  size_t v38; // r12
  int v39; // r12
  double v40; // d8
  double v41; // r0
  int v42; // r6
  int v43; // r3
  int v44; // r2
  _DWORD *v45; // r1
  bool v46; // zf
  int v47; // r3
  int v48; // r2
  int v49; // r2
  int v50; // r3
  int v51; // r3
  _DWORD *v52; // r0
  int v53; // r4
  int v54; // r3
  int v55; // r2
  int v56; // r4
  char *v57; // r4
  int v58; // r3
  int v59; // r3
  int v60; // r3
  double v61; // d8
  double v62; // d16
  double v63; // d18
  __int64 v64; // r6
  double v65; // d18
  double v66; // d16
  double v67; // d16
  int v68; // r3
  time_t v69; // r0
  int v70; // r1
  _DWORD *v71; // r0
  const char *v72; // r0
  double v73; // d16
  double v74; // d17
  __int64 v75; // r6
  char *v76; // [sp+18h] [bp-A6Ch]
  size_t na; // [sp+1Ch] [bp-A68h]
  size_t n; // [sp+1Ch] [bp-A68h]
  int *v79; // [sp+3Ch] [bp-A48h]
  int v80; // [sp+44h] [bp-A40h]
  _DWORD *src; // [sp+48h] [bp-A3Ch]
  const char *srca; // [sp+48h] [bp-A3Ch]
  _DWORD *v83; // [sp+4Ch] [bp-A38h]
  int s2; // [sp+50h] [bp-A34h] BYREF
  struct timeval timeout; // [sp+54h] [bp-A30h] BYREF
  char s[16]; // [sp+5Ch] [bp-A28h] BYREF
  char v87[20]; // [sp+6Ch] [bp-A18h] BYREF
  char v88[2]; // [sp+80h] [bp-A04h] BYREF
  char dest[30]; // [sp+82h] [bp-A02h] BYREF
  char v90[36]; // [sp+A0h] [bp-9E4h] BYREF
  char v91[60]; // [sp+C4h] [bp-9C0h] BYREF
  char v92; // [sp+100h] [bp-984h] BYREF
  fd_set readfds; // [sp+104h] [bp-980h] BYREF
  int v94[23]; // [sp+184h] [bp-900h] BYREF
  char v95[160]; // [sp+1E0h] [bp-8A4h] BYREF
  _DWORD v96[513]; // [sp+280h] [bp-804h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 0x10u, "%d/RStratum", *a1);
  sub_2F02C(s);
  while ( !*((_BYTE *)a1 + 105) )
  {
    if ( !sub_2B6F8((int)a1) && !sub_1FB7C((int)a1) )
    {
      sub_2B7C0((pthread_mutex_t *)a1);
      sub_18D90((int)a1);
      sub_17FC4(a1);
      while ( !sub_1FB7C((int)a1) && (!a1[25] || a1 != (_DWORD *)sub_1D644() && dword_611AC != 3 && dword_611AC != 4) )
      {
        if ( pthread_mutex_lock(&stru_61314) )
          sub_B4E4("wait_lpcurrent", 9252);
        pthread_cond_wait(&stru_61330, &stru_61314);
        if ( pthread_mutex_unlock(&stru_61314) )
          sub_B694("wait_lpcurrent", 9254);
        off_60178();
      }
      while ( !sub_2DC00((pthread_mutex_t *)a1) )
      {
        if ( *((_BYTE *)a1 + 105) )
          return 0;
        sub_2B21C();
      }
    }
    v3 = (fd_set *)&v92;
    do
    {
      v3->__fds_bits[1] = 0;
      v3 = (fd_set *)((char *)v3 + 4);
    }
    while ( v3 != (fd_set *)&readfds.__fds_bits[31] );
    v4 = a1[145];
    timeout.tv_usec = 0;
    v5 = v4 + 31;
    timeout.tv_sec = 90;
    if ( v4 >= 0 )
      v5 = v4;
    readfds.__fds_bits[v5 >> 5] |= 1 << (v4 % 32);
    if ( sub_2B6F8((int)a1) || (v6 = select(a1[145] + 1, &readfds, 0, 0, &timeout), v6 > 0) )
    {
      v7 = (int *)sub_2B920((int)a1);
      if ( !v7 )
      {
        v54 = (unsigned __int8)byte_630C1;
        goto LABEL_118;
      }
      sub_1F8F4(a1);
      if ( sub_2DC70((pthread_mutex_t *)a1, v7) )
        goto LABEL_12;
      v9 = sub_45AA8(v7, 0, (char *)v94);
      v79 = v9;
      if ( v9 )
      {
        src = (_DWORD *)sub_46698(v9, "result");
        v83 = (_DWORD *)sub_46698(v79, (char *)"error");
        v10 = (_DWORD *)sub_46698(v79, "id");
        if ( !v10 || *v10 == 7 )
        {
          if ( v83 )
          {
            v57 = (char *)sub_440CC(v83, 3);
          }
          else
          {
            v57 = (char *)malloc(0x11u);
            if ( v57 )
              strcpy(v57, "(unknown reason)");
          }
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf((char *)v96, 0x800u, "JSON-RPC non method decode failed: %s", v57);
            sub_38438(7, (const char *)v96, 0);
          }
          v42 = 0;
          free(v57);
        }
        else
        {
          s2 = sub_46AC0((int)v10);
          if ( pthread_mutex_lock(&stru_612DC) )
            sub_B4E4("parse_stratum_response", 6899);
          v11 = (void **)dword_612F4;
          if ( dword_612F4 )
          {
            v13 = ((unsigned __int8)s2 + 17973517 + (HIBYTE(s2) << 24) + (BYTE2(s2) << 16) + (BYTE1(s2) << 8))
                ^ (unsigned int)&unk_7F76D;
            v14 = (-1622558010 - v13) ^ (v13 << 8);
            v15 = (-17973517 - v13 - v14) ^ (v14 >> 13);
            v16 = *(_DWORD *)dword_612F4;
            v17 = (v13 - v14 - v15) ^ (v15 >> 12);
            v18 = (v14 - v15 - v17) ^ (v17 << 16);
            v19 = (v15 - v17 - v18) ^ (v18 >> 5);
            v20 = (v17 - v18 - v19) ^ (v19 >> 3);
            v21 = **(_DWORD ***)dword_612F4;
            v12 = v21[3
                    * (((v19 - v20 - ((v18 - v19 - v20) ^ (v20 << 10)))
                      ^ (((v18 - v19 - v20) ^ (v20 << 10)) >> 15))
                     & (*(_DWORD *)(*(_DWORD *)dword_612F4 + 4) - 1))];
            if ( !v12 )
              goto LABEL_38;
            while ( 1 )
            {
              v12 -= *(_DWORD *)(v16 + 20);
LABEL_38:
              if ( !v12 )
                goto LABEL_41;
              if ( *(_DWORD *)(v12 + 24) == 4 && !memcmp(*(const void **)(v12 + 20), &s2, 4u) )
                break;
              v12 = *(_DWORD *)(v12 + 16);
              if ( !v12 )
                goto LABEL_41;
            }
            v43 = *(_DWORD *)(v12 + 4);
            if ( v43 || *(_DWORD *)(v12 + 8) )
            {
              v44 = *(_DWORD *)(v16 + 20);
              v45 = (_DWORD *)(*(_DWORD *)(v16 + 16) - v44);
              if ( (_DWORD *)v12 == v45 )
              {
                *(_DWORD *)(v16 + 16) = v43 + v44;
                v43 = *(_DWORD *)(v12 + 4);
              }
              v46 = v43 == 0;
              if ( v43 )
              {
                v45 = *v11;
                v44 = *(_DWORD *)(v12 + 8);
              }
              else
              {
                v43 = *(_DWORD *)(v12 + 8);
              }
              if ( v46 )
              {
                v11 = (void **)v43;
                dword_612F4 = v43;
              }
              else
              {
                v43 += v45[5];
              }
              if ( !v46 )
              {
                *(_DWORD *)(v43 + 8) = v44;
                v43 = *(_DWORD *)(v12 + 8);
              }
              if ( v43 )
                *(_DWORD *)(v43 + *((_DWORD *)*v11 + 5) + 4) = *(_DWORD *)(v12 + 4);
              v47 = 3 * ((*((_DWORD *)*v11 + 1) - 1) & *(_DWORD *)(v12 + 28));
              v48 = *(_DWORD *)*v11 + 12 * ((*((_DWORD *)*v11 + 1) - 1) & *(_DWORD *)(v12 + 28));
              --*(_DWORD *)(v48 + 4);
              v49 = *(_DWORD *)*v11;
              if ( v12 == *(_DWORD *)(v49 + 4 * v47) )
                *(_DWORD *)(v49 + 4 * v47) = *(_DWORD *)(v12 + 16);
              v50 = *(_DWORD *)(v12 + 12);
              if ( v50 )
                *(_DWORD *)(v50 + 16) = *(_DWORD *)(v12 + 16);
              v51 = *(_DWORD *)(v12 + 16);
              if ( v51 )
                *(_DWORD *)(v51 + 12) = *(_DWORD *)(v12 + 12);
              --*((_DWORD *)*v11 + 3);
            }
            else
            {
              free(v21);
              free(*v11);
              dword_612F4 = 0;
            }
            --a1[175];
          }
          else
          {
            v12 = 0;
          }
LABEL_41:
          if ( pthread_mutex_unlock(&stru_612DC) )
            sub_B694("parse_stratum_response", 6906);
          off_60178();
          if ( v12 )
          {
            v22 = *(_DWORD *)(v12 + 36);
            v23 = time(0);
            if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              snprintf(
                (char *)v96,
                0x800u,
                "Pool %d stratum share result lag time %d seconds",
                **(_DWORD **)(v22 + 260),
                v23 - *(_DWORD *)(v12 + 48));
              sub_38438(7, (const char *)v96, 0);
            }
            v24 = 0;
            v96[0] = bswap32(*(_DWORD *)(v22 + 220));
            v96[1] = bswap32(*(_DWORD *)(v22 + 216));
            v96[2] = bswap32(*(_DWORD *)(v22 + 212));
            v96[3] = bswap32(*(_DWORD *)(v22 + 208));
            v96[4] = bswap32(*(_DWORD *)(v22 + 204));
            v96[5] = bswap32(*(_DWORD *)(v22 + 200));
            v96[6] = bswap32(*(_DWORD *)(v22 + 196));
            v96[7] = bswap32(*(_DWORD *)(v22 + 192));
            do
            {
              if ( *((_BYTE *)v96 + v24) )
                break;
              ++v24;
            }
            while ( v24 != 29 );
            v25 = *(double *)(v22 + 376);
            v26 = *(_DWORD *)((char *)v96 + v24);
            round();
            LODWORD(v28) = sub_494C0(v25);
            HIDWORD(v28) = v27;
            sub_11130(*(_QWORD *)(v22 + 232), v90, 0x10u, 0);
            v29 = "";
            v30 = bswap32(v26);
            if ( *(_BYTE *)(v22 + 283) )
              v29 = " BLOCK!";
            snprintf(v91, 0x40u, "%08lx Diff %s/%llu%s", v30, v90, v28, v29);
            v31 = *(_DWORD **)(v22 + 260);
            v80 = *(_DWORD *)(sub_1C36C(*(_DWORD *)(v22 + 256)) + 36);
            if ( src && (*src == 5 || *(_BYTE *)(v22 + 324) && *src == 7) )
            {
              if ( pthread_mutex_lock(&mutex) )
                sub_B4E4("share_result", 3478);
              v65 = dbl_63B88;
              ++*(_DWORD *)(v80 + 36);
              ++*((_QWORD *)v31 + 1);
              v66 = *(double *)(v80 + 200) + *(double *)(v22 + 376);
              ++qword_639C8;
              *(double *)(v80 + 200) = v66;
              v67 = *(double *)(v22 + 376);
              *((double *)v31 + 9) = *((double *)v31 + 9) + v67;
              dbl_63B88 = v67 + v65;
              if ( pthread_mutex_unlock(&mutex) )
                sub_B694("share_result", 3485);
              off_60178();
              v68 = *v31;
              v31[6] = 0;
              *(_DWORD *)(v80 + 216) = v68;
              v69 = time(0);
              v70 = (unsigned __int8)byte_630C1;
              *(_DWORD *)(v80 + 220) = v69;
              *(_QWORD *)(v80 + 224) = *(_QWORD *)(v22 + 376);
              v31[88] = v69;
              *((_QWORD *)v31 + 45) = *(_QWORD *)(v22 + 376);
              if ( v70 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                strcpy((char *)v96, "PROOF OF WORK RESULT: true (yay!!!)");
                sub_38438(7, (const char *)v96, 0);
              }
              if ( !byte_64218 && !byte_640B8 )
              {
                if ( dword_63740 <= 1 )
                {
                  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                  {
                    snprintf(
                      (char *)v96,
                      0x800u,
                      "Accepted %s %s %d %s%s",
                      v91,
                      *(const char **)(*(_DWORD *)(v80 + 4) + 8),
                      *(_DWORD *)(v80 + 8),
                      "",
                      "");
                    sub_38438(7, (const char *)v96, 0);
                  }
                }
                else if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                {
                  snprintf(
                    (char *)v96,
                    0x800u,
                    "Accepted %s %s %d pool %d %s%s",
                    v91,
                    *(const char **)(*(_DWORD *)(v80 + 4) + 8),
                    *(_DWORD *)(v80 + 8),
                    **(_DWORD **)(v22 + 260),
                    "",
                    "");
                  sub_38438(7, (const char *)v96, 0);
                }
              }
              sub_1D408("accept", (_DWORD *)v22);
              if ( dword_61414 && (double)dword_61414 <= dbl_63B88 )
              {
                if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
                {
                  snprintf(
                    (char *)v96,
                    0x800u,
                    "Successfully mined %d accepted shares as requested and exiting.",
                    dword_61414);
                  sub_38438(4, (const char *)v96, 0);
                }
                sub_17328();
              }
              if ( v31[25] == 2 )
              {
                if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3
                  || (snprintf((char *)v96, 0x800u, "Rejecting pool %d now accepting shares, re-enabling!", *v31),
                      sub_38438(4, (const char *)v96, 0),
                      v31[25] != 1) )
                {
                  v31[25] = 1;
                  ++dword_63B84;
                }
                sub_195D4(0);
              }
              if ( *(_BYTE *)(v22 + 283) )
                sub_16C8C();
            }
            else
            {
              if ( pthread_mutex_lock(&mutex) )
                sub_B4E4("share_result", 3528);
              v32 = dbl_63C10;
              ++*(_DWORD *)(v80 + 40);
              ++*((_QWORD *)v31 + 2);
              v33 = *(double *)(v80 + 208) + *(double *)(v22 + 376);
              ++qword_63C98;
              *(double *)(v80 + 208) = v33;
              v34 = *(double *)(v22 + 376);
              v35 = *((double *)v31 + 10) + v34;
              ++v31[6];
              *((double *)v31 + 10) = v35;
              dbl_63C10 = v34 + v32;
              if ( pthread_mutex_unlock(&mutex) )
                sub_B694("share_result", 3536);
              off_60178();
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                strcpy((char *)v96, "PROOF OF WORK RESULT: false (booooo)");
                sub_38438(7, (const char *)v96, 0);
              }
              if ( !byte_64218 && !byte_640B8 )
              {
                strcpy(v90, "reject");
                memset(&v90[7], (unsigned __int8)byte_640B8, 0x1Du);
                v88[0] = byte_640B8;
                if ( dword_63740 > 1 )
                  snprintf(v87, 0x14u, "pool %d", **(_DWORD **)(v22 + 260));
                else
                  v87[0] = byte_640B8;
                if ( *(_BYTE *)(v22 + 324) )
                {
                  v36 = src;
                  if ( src )
                    goto LABEL_70;
LABEL_210:
                  if ( *(_BYTE *)(v22 + 284) && v83 )
                  {
                    if ( *v83 == 1 )
                    {
                      v71 = sub_46880(v83, 1u);
                      if ( v71 && *v71 == 2 )
                      {
LABEL_215:
                        v72 = (const char *)sub_469F0(v71);
                        snprintf(v88, 0x1Fu, " (%s)", v72);
                      }
                    }
                    else if ( *v83 == 2 )
                    {
                      v71 = v83;
                      goto LABEL_215;
                    }
                  }
                }
                else
                {
                  v36 = (_DWORD *)sub_46698(v79, "reject-reason");
                  if ( !v36 )
                    goto LABEL_210;
LABEL_70:
                  srca = (const char *)sub_469F0(v36);
                  v37 = strlen(srca);
                  qmemcpy(v88, " (", sizeof(v88));
                  if ( v37 >= 0x1C )
                    v38 = 28;
                  else
                    v38 = v37;
                  na = v38;
                  v76 = (char *)&v96[512] + v38;
                  memcpy(dest, srca, v38);
                  *((_WORD *)v76 - 1279) = 41;
                  memcpy(&v90[7], srca, na);
                  v90[6] = 58;
                  *(v76 - 2521) = 0;
                }
                if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                {
                  snprintf(
                    (char *)v96,
                    0x800u,
                    "Rejected %s %s %d %s%s %s%s",
                    v91,
                    *(const char **)(*(_DWORD *)(v80 + 4) + 8),
                    *(_DWORD *)(v80 + 8),
                    v87,
                    v88,
                    "",
                    "");
                  sub_38438(7, (const char *)v96, 0);
                }
                sub_1D408(v90, (_DWORD *)v22);
              }
              v39 = v31[6];
              if ( v39 > 10 && !*(_BYTE *)(v22 + 281) )
              {
                if ( byte_637F8 )
                {
                  if ( dword_63B84 > 1 )
                  {
                    v40 = (double)v39;
                    n = v31[6];
                    LODWORD(v41) = sub_493DC(qword_639C8);
                    if ( v40 > v41 / dbl_5F898 * 60.0 * 3.0 )
                    {
                      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
                      {
                        snprintf((char *)v96, 0x800u, "Pool %d rejected %d sequential shares, disabling!", *v31, n);
                        sub_38438(4, (const char *)v96, 0);
                      }
                      if ( v31[25] == 1 )
                        --dword_63B84;
                      v31[25] = 2;
                      if ( v31 == (_DWORD *)sub_1D644() )
                        sub_195D4(0);
                      v31[6] = 0;
                    }
                  }
                }
              }
            }
            v42 = 1;
            sub_152B8(*(void ***)(v12 + 36));
            *(_DWORD *)(v12 + 36) = 0;
            free((void *)v12);
          }
          else if ( src )
          {
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
              sub_B4E4("parse_stratum_response", 6916);
            if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
              sub_B76C("parse_stratum_response", 6916);
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
              sub_B694("parse_stratum_response", 6916);
            v61 = *((double *)a1 + 223);
            if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
              sub_B700("parse_stratum_response", 6918);
            off_60178();
            if ( *src == 5 )
            {
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf((char *)v96, 0x800u, "Accepted untracked stratum share from pool %d", *a1);
                sub_38438(7, (const char *)v96, 0);
              }
              if ( pthread_mutex_lock(&mutex) )
                sub_B4E4("parse_stratum_response", 6926);
              v73 = *((double *)a1 + 9) + v61;
              v74 = dbl_63B88;
              v75 = qword_639C8;
              ++*((_QWORD *)a1 + 1);
              qword_639C8 = v75 + 1;
              *((double *)a1 + 9) = v73;
              dbl_63B88 = v61 + v74;
              if ( pthread_mutex_unlock(&mutex) )
                sub_B694("parse_stratum_response", 6931);
            }
            else
            {
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf((char *)v96, 0x800u, "Rejected untracked stratum share from pool %d", *a1);
                sub_38438(7, (const char *)v96, 0);
              }
              if ( pthread_mutex_lock(&mutex) )
                sub_B4E4("parse_stratum_response", 6937);
              v62 = *((double *)a1 + 10) + v61;
              v63 = dbl_63C10;
              v64 = qword_63C98;
              ++*((_QWORD *)a1 + 2);
              qword_63C98 = v64 + 1;
              *((double *)a1 + 10) = v62;
              dbl_63C10 = v61 + v63;
              if ( pthread_mutex_unlock(&mutex) )
                sub_B694("parse_stratum_response", 6942);
            }
            v42 = 0;
            off_60178();
          }
          else
          {
            v42 = 0;
          }
        }
        v58 = v79[1];
        if ( v58 != -1 )
        {
          v59 = v58 - 1;
          v79[1] = v59;
          if ( !v59 )
            sub_46C5C((void **)v79);
        }
        if ( v42 )
        {
LABEL_12:
          if ( *((_BYTE *)a1 + 648) )
          {
            v52 = sub_19DA0();
            *((_BYTE *)a1 + 648) = 0;
            v53 = (int)v52;
            sub_1A514((int)a1, (int)v52);
            *(_BYTE *)(v53 + 280) = 1;
            sub_1D6F8(v53);
            sub_152B8((void **)v53);
          }
          goto LABEL_14;
        }
        v60 = (unsigned __int8)byte_630C1;
        goto LABEL_153;
      }
      if ( !byte_630C1 )
        goto LABEL_14;
      if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
        goto LABEL_154;
      snprintf((char *)v96, 0x800u, "JSON decode failed(%d): %s", v94[0], v95);
      sub_38438(7, (const char *)v96, 0);
      v60 = (unsigned __int8)byte_630C1;
LABEL_153:
      if ( !v60 )
        goto LABEL_14;
LABEL_154:
      if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
      {
        snprintf((char *)v96, 0x800u, "Unknown stratum msg: %s", (const char *)v7);
        sub_38438(7, (const char *)v96, 0);
      }
LABEL_14:
      free(v7);
    }
    else
    {
      if ( !byte_630C1 )
        goto LABEL_123;
      if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      {
LABEL_119:
        if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
        {
          snprintf((char *)v96, 0x800u, "Stratum connection to pool %d interrupted", *a1);
          sub_38438(7, (const char *)v96, 0);
        }
        goto LABEL_123;
      }
      snprintf((char *)v96, 0x800u, "Stratum select failed on pool %d with value %d", *a1, v6);
      sub_38438(7, (const char *)v96, 0);
      v54 = (unsigned __int8)byte_630C1;
LABEL_118:
      if ( v54 )
        goto LABEL_119;
LABEL_123:
      v55 = dword_639E4;
      ++a1[32];
      dword_639E4 = v55 + 1;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
        sub_B4E4("supports_resume", 7079);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
        sub_B76C("supports_resume", 7079);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
        sub_B694("supports_resume", 7079);
      v56 = a1[157];
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        sub_B700("supports_resume", 7081);
      off_60178();
      if ( !v56 || byte_63BE4 )
        sub_18D90((int)a1);
      sub_17FC4(a1);
      if ( a1 == (_DWORD *)sub_1D644() )
        sub_16C8C();
      while ( !sub_2DC00((pthread_mutex_t *)a1) )
      {
        if ( *((_BYTE *)a1 + 105) )
          return 0;
        sub_2B21C();
      }
    }
  }
  sub_2B7C0((pthread_mutex_t *)a1);
  return 0;
}
// 201AC: variable 'v27' is possibly undefined
// 20570: variable 'v41' is possibly undefined
// AEAC: using guessed type int round(void);
// 5F898: using guessed type double dbl_5F898;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 611AC: using guessed type int dword_611AC;
// 612F4: using guessed type int dword_612F4;
// 61414: using guessed type int dword_61414;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63740: using guessed type int dword_63740;
// 637F8: using guessed type char byte_637F8;
// 639C8: using guessed type __int64 qword_639C8;
// 639E4: using guessed type int dword_639E4;
// 63B84: using guessed type int dword_63B84;
// 63B88: using guessed type double dbl_63B88;
// 63BE4: using guessed type char byte_63BE4;
// 63C10: using guessed type double dbl_63C10;
// 63C98: using guessed type __int64 qword_63C98;
// 640B8: using guessed type char byte_640B8;
// 64218: using guessed type char byte_64218;

//----- (00021364) --------------------------------------------------------
void __noreturn sub_21364()
{
  int v0; // r2
  int v1; // r5
  int v2; // r4
  __int64 v3; // r10
  double v4; // r0
  double v5; // d16
  double v6; // d16
  int v7; // r9
  _DWORD *v8; // r3
  _DWORD *v9; // r2
  int v10; // r11
  int v11; // r3
  int v12; // r9
  int v13; // r5
  int v14; // r3
  _DWORD *v15; // r3
  int v16; // r12
  int v17; // r3
  const char *v18; // r9
  int v19; // r10
  int v20; // r11
  int v21; // r3
  int v22; // r9
  int v23; // r5
  int v24; // r4
  int v25; // r1
  int **v26; // r3
  int v27; // r0
  int *v28; // r12
  bool v29; // zf
  int v30; // r1
  int v31; // r0
  int v32; // r0
  int v33; // r1
  int v34; // r1
  int v35; // r3
  __int64 v36; // r2
  void **v37; // [sp+10h] [bp-824h]
  int v38; // [sp+14h] [bp-820h]
  pthread_mutex_t *mutex; // [sp+18h] [bp-81Ch]
  pthread_mutex_t *mutexa; // [sp+18h] [bp-81Ch]
  int v41; // [sp+1Ch] [bp-818h]
  struct timeval v42; // [sp+20h] [bp-814h] BYREF
  struct timeval v43; // [sp+28h] [bp-80Ch] BYREF
  char s[2052]; // [sp+30h] [bp-804h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2F02C("Watchpool");
  sub_11C4C();
  v38 = 0;
  while ( 1 )
  {
    sub_2B13C(&v42);
    v0 = v38 + 1;
    if ( v38 + 1 > 20 )
      v0 = 0;
    v38 = v0;
    if ( dword_63740 > 0 )
    {
      v1 = 0;
      while ( 1 )
      {
        v2 = *(_DWORD *)(dword_639E0 + 4 * v1);
        if ( byte_615C9 || dword_612AC )
          goto LABEL_11;
        mutex = (pthread_mutex_t *)(v2 + 188);
        sub_2B13C(&v43);
        if ( pthread_mutex_lock((pthread_mutex_t *)(v2 + 188)) )
          sub_B4E4("reap_curl", 9507);
        v8 = *(_DWORD **)(v2 + 344);
        v9 = v8 - 1;
        v10 = *v8 - 4;
        if ( (_DWORD *)(v2 + 344) == v8 )
        {
          v12 = 0;
          if ( pthread_mutex_unlock(mutex) )
            goto LABEL_95;
        }
        else
        {
          v11 = *(_DWORD *)(v2 + 288);
          v12 = 0;
          if ( v11 > 1 )
          {
            v41 = v1;
            v13 = 0;
            do
            {
              if ( v43.tv_sec - v9[3] > 300 )
              {
                *(_DWORD *)(v2 + 288) = v11 - 1;
                v15 = (_DWORD *)v9[2];
                v16 = v9[1];
                ++v13;
                *(_DWORD *)(v16 + 4) = v15;
                *v15 = v16;
                v9[1] = 0;
                v9[2] = 0;
                free(v9);
              }
              v9 = (_DWORD *)v10;
              v14 = v10 + 4;
              v10 = *(_DWORD *)(v10 + 4) - 4;
              if ( v2 + 344 == v14 )
                break;
              v11 = *(_DWORD *)(v2 + 288);
            }
            while ( v11 > 1 );
            v12 = v13;
            v1 = v41;
          }
          if ( pthread_mutex_unlock(mutex) )
LABEL_95:
            sub_B694("reap_curl", 9521);
        }
        off_60178();
        if ( v12 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v17 = v12;
          if ( v12 == 1 )
            v18 = "";
          else
            v18 = "s";
          snprintf(s, 0x800u, "Reaped %d curl%s from pool %d", v17, v18, *(_DWORD *)v2);
          sub_38438(7, s, 0);
        }
        mutexa = (pthread_mutex_t *)time(0);
        if ( pthread_mutex_lock(&stru_612DC) )
          sub_B4E4("prune_stratum_shares", 9536);
        v19 = dword_612F4;
        if ( !dword_612F4 )
        {
          v20 = 0;
          goto LABEL_81;
        }
        v21 = v1;
        v22 = *(_DWORD *)(dword_612F4 + 8);
        v23 = v2;
        v20 = 0;
        v24 = v21;
        while ( v23 != *(_DWORD *)(*(_DWORD *)(v19 + 36) + 260) || (int)mutexa <= *(_DWORD *)(v19 + 44) + 120 )
        {
          if ( !v22 )
            goto LABEL_80;
LABEL_56:
          v19 = v22;
          v22 = *(_DWORD *)(v22 + 8);
        }
        v25 = *(_DWORD *)(v19 + 4);
        if ( v25 || *(_DWORD *)(v19 + 8) )
        {
          v26 = (int **)dword_612F4;
          v27 = *(_DWORD *)dword_612F4;
          v28 = *(int **)(*(_DWORD *)dword_612F4 + 20);
          if ( v19 == *(_DWORD *)(*(_DWORD *)dword_612F4 + 16) - (_DWORD)v28 )
          {
            *(_DWORD *)(v27 + 16) = (char *)v28 + v25;
            v25 = *(_DWORD *)(v19 + 4);
          }
          v29 = v25 == 0;
          if ( v25 )
          {
            v28 = *v26;
            v27 = *(_DWORD *)(v19 + 8);
          }
          else
          {
            v25 = *(_DWORD *)(v19 + 8);
          }
          if ( v29 )
          {
            v26 = (int **)v25;
            dword_612F4 = v25;
          }
          else
          {
            v25 += v28[5];
          }
          if ( !v29 )
          {
            *(_DWORD *)(v25 + 8) = v27;
            v25 = *(_DWORD *)(v19 + 8);
          }
          if ( v25 )
            *(_DWORD *)(v25 + (*v26)[5] + 4) = *(_DWORD *)(v19 + 4);
          v30 = 3 * (((*v26)[1] - 1) & *(_DWORD *)(v19 + 28));
          v31 = **v26 + 12 * (((*v26)[1] - 1) & *(_DWORD *)(v19 + 28));
          --*(_DWORD *)(v31 + 4);
          v32 = **v26;
          if ( v19 == *(_DWORD *)(v32 + 4 * v30) )
            *(_DWORD *)(v32 + 4 * v30) = *(_DWORD *)(v19 + 16);
          v33 = *(_DWORD *)(v19 + 12);
          if ( v33 )
            *(_DWORD *)(v33 + 16) = *(_DWORD *)(v19 + 16);
          v34 = *(_DWORD *)(v19 + 16);
          if ( v34 )
            *(_DWORD *)(v34 + 12) = *(_DWORD *)(v19 + 12);
          --(*v26)[3];
        }
        else
        {
          v37 = (void **)dword_612F4;
          free(**(void ***)dword_612F4);
          free(*v37);
          dword_612F4 = 0;
        }
        ++v20;
        sub_152B8(*(void ***)(v19 + 36));
        *(_DWORD *)(v19 + 36) = 0;
        free((void *)v19);
        if ( v22 )
          goto LABEL_56;
LABEL_80:
        v35 = v24;
        v2 = v23;
        v1 = v35;
LABEL_81:
        if ( pthread_mutex_unlock(&stru_612DC) )
          sub_B694("prune_stratum_shares", 9547);
        off_60178();
        if ( v20 )
        {
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, "Lost %d shares due to no stratum share response from pool %d", v20, *(_DWORD *)v2);
            sub_38438(4, s, 0);
          }
          v36 = *(_QWORD *)&dword_64220;
          *(_DWORD *)(v2 + 120) += v20;
          *(_QWORD *)&dword_64220 = v36 + v20;
        }
LABEL_11:
        if ( v38 == 20 )
        {
          v3 = *(_QWORD *)(v2 + 40);
          LODWORD(v4) = sub_493DC(v3 - *(int *)(v2 + 152));
          v5 = *(double *)(v2 + 144);
          *(_DWORD *)(v2 + 152) = v3;
          v6 = (v5 + v4 * 0.63) / 1.63;
          *(double *)(v2 + 144) = v6;
          *(_DWORD *)(v2 + 156) = (int)v6;
        }
        if ( !*(_DWORD *)(v2 + 100) || *(_BYTE *)(v2 + 284) )
          goto LABEL_8;
        if ( !*(_BYTE *)(v2 + 97) )
        {
LABEL_7:
          if ( !dword_611AC )
          {
            v7 = *(_DWORD *)(v2 + 4);
            if ( v7 < sub_1F70C() && v42.tv_sec - *(_DWORD *)(v2 + 136) > 300 )
            {
              if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
              {
                snprintf(s, 0x800u, "Pool %d %s stable for 5 mins", *(_DWORD *)v2, *(const char **)(v2 + 164));
                sub_38438(4, s, 0);
              }
              sub_195D4(0);
            }
          }
          goto LABEL_8;
        }
        if ( v42.tv_sec - *(_DWORD *)(v2 + 136) <= 30 )
        {
LABEL_8:
          if ( dword_63740 <= ++v1 )
            break;
        }
        else
        {
          if ( sub_182A0((_DWORD *)v2, 1) && sub_1822C(v2, (_BYTE *)(v2 + 97)) )
            sub_1F7C4((_DWORD *)v2);
          else
            sub_2B13C((struct timeval *)(v2 + 136));
          if ( !*(_BYTE *)(v2 + 97) )
            goto LABEL_7;
          if ( dword_63740 <= ++v1 )
            break;
        }
      }
    }
    if ( *(_BYTE *)(sub_1D644() + 97) )
    {
      sub_195D4(0);
      if ( dword_611AC != 2 )
        goto LABEL_24;
    }
    else if ( dword_611AC != 2 )
    {
      goto LABEL_24;
    }
    if ( v42.tv_sec - stru_615CC.tv_sec > 60 * dword_63AF8 )
    {
      sub_2B13C(&stru_615CC);
      sub_195D4(0);
    }
LABEL_24:
    sub_2B21C();
  }
}
// 21458: variable 'v4' is possibly undefined
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 611AC: using guessed type int dword_611AC;
// 612AC: using guessed type int dword_612AC;
// 612F4: using guessed type int dword_612F4;
// 615C9: using guessed type char byte_615C9;
// 615CC: using guessed type struct timeval stru_615CC;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;
// 63AF8: using guessed type int dword_63AF8;
// 64220: using guessed type int dword_64220;

//----- (00021AB0) --------------------------------------------------------
void *__fastcall sub_21AB0(_DWORD *a1)
{
  pthread_t v1; // r0
  char *v2; // r0
  __int64 v3; // r6
  int v4; // r5
  _DWORD *v5; // r12
  const struct timespec *v6; // r1
  int v7; // r0
  int v8; // r4
  __int64 v9; // r2
  int **v10; // r11
  time_t v11; // r0
  int v12; // r3
  int *v13; // r6
  size_t v14; // r0
  int **v15; // r4
  int *v16; // r5
  unsigned int v17; // r3
  unsigned int v18; // r2
  unsigned int v19; // r0
  int v20; // r1
  unsigned int v21; // r2
  unsigned int v22; // r3
  unsigned int v23; // r1
  unsigned int v24; // r3
  int v25; // r2
  int v26; // r3
  int *v27; // r1
  int v28; // r1
  int ***v29; // r0
  int v30; // r2
  int *v31; // r4
  size_t v32; // r5
  _DWORD *v33; // r0
  _DWORD *v34; // r6
  int v35; // r8
  void **v36; // r1
  unsigned int v37; // r5
  void ***v38; // r10
  _DWORD *v39; // r4
  _DWORD *v40; // r11
  int v41; // r5
  char *v42; // r7
  unsigned int v43; // r3
  int v44; // r3
  int *v45; // r3
  unsigned int v46; // r1
  unsigned int v47; // r2
  bool v48; // cc
  int v49; // r2
  time_t v50; // r0
  int *v51; // r2
  bool v52; // zf
  int *v54; // r0
  void *v55; // r0
  __int64 v56; // r2
  const char *v57; // r1
  _BOOL4 v58; // r9
  int v59; // r3
  unsigned int i; // [sp+18h] [bp-C5Ch]
  __int64 v62; // [sp+20h] [bp-C54h]
  int v63; // [sp+28h] [bp-C4Ch]
  int v64; // [sp+34h] [bp-C40h] BYREF
  __int64 v65; // [sp+38h] [bp-C3Ch] BYREF
  char v66[12]; // [sp+40h] [bp-C34h] BYREF
  char s[16]; // [sp+4Ch] [bp-C28h] BYREF
  char v68[20]; // [sp+5Ch] [bp-C18h] BYREF
  char v69[1024]; // [sp+70h] [bp-C04h] BYREF
  char v70[2052]; // [sp+470h] [bp-804h] BYREF

  v1 = pthread_self();
  pthread_detach(v1);
  snprintf(s, 0x10u, "%d/SStratum", *a1);
  sub_2F02C(s);
  v2 = sub_2AA90();
  a1[174] = v2;
  if ( !v2 )
  {
    strcpy(v70, "Failed to create stratum_q in stratum_sthread");
    sub_38438(3, v70, 1);
    sub_16724(1);
  }
  v3 = 0;
  v4 = 0;
LABEL_4:
  v5 = a1;
  v6 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  if ( *((_BYTE *)a1 + 105) )
    goto LABEL_62;
  do
  {
    v7 = sub_2AC28(v5[174], v6);
    v8 = v7;
    if ( !v7 )
    {
      strcpy(v70, "Stratum q returned empty work");
      sub_38438(3, v70, 1);
      sub_16724(1);
    }
    if ( *(_DWORD *)(v7 + 304) > 8u )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf(v70, 0x800u, "Pool %d asking for inappropriately long nonce2 length %d", *a1, *(_DWORD *)(v7 + 304));
        sub_38438(3, v70, 0);
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          strcpy(v70, "Not attempting to submit shares");
          sub_38438(3, v70, 0);
        }
      }
LABEL_108:
      sub_152B8((void **)v8);
      goto LABEL_4;
    }
    v9 = *(_QWORD *)(v7 + 296);
    v63 = *(_DWORD *)(v7 + 76);
    v62 = v9;
    v64 = v63;
    v65 = v9;
    if ( v4 == v63 && v3 == v9 )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(v70, 0x800u, "Filtering duplicate share to pool %d", *a1);
        sub_38438(7, v70, 0);
      }
      goto LABEL_108;
    }
    sub_29460(v66, (char *)&v64, 4);
    sub_29460(v68, (char *)&v65, *(_DWORD *)(v8 + 304));
    v10 = (int **)calloc(0x34u, 1u);
    v11 = time(0);
    v10[9] = (int *)v8;
    v10[11] = (int *)v11;
    memset(v69, 0, sizeof(v69));
    if ( pthread_mutex_lock(&stru_612DC) )
      sub_B4E4("stratum_sthread", 7277);
    v12 = dword_636A0++;
    v10[10] = (int *)v12;
    if ( pthread_mutex_unlock(&stru_612DC) )
      sub_B694("stratum_sthread", 7280);
    off_60178();
    snprintf(
      v69,
      0x400u,
      "{\"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"], \"id\": %d, \"method\": \"mining.submit\"}",
      (const char *)a1[43],
      *(const char **)(v8 + 288),
      v68,
      *(const char **)(v8 + 308),
      v66,
      v10[10]);
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(v70, 0x800u, "Submitting share %08lx to pool %d", *(_DWORD *)(v8 + 216), *a1);
      sub_38438(7, v70, 0);
    }
    while ( 1 )
    {
      v13 = v10[11];
      if ( (int)v13 + 119 < time(0) )
        goto LABEL_71;
      v14 = strlen(v69);
      if ( sub_2BEA8((pthread_mutex_t *)a1, v69, v14) )
      {
        if ( pthread_mutex_lock(&stru_612DC) )
          sub_B4E4("stratum_sthread", 7307);
        v10[2] = 0;
        v10[5] = (int *)(v10 + 10);
        v15 = (int **)dword_612F4;
        v10[6] = (int *)4;
        if ( v15 )
        {
          *(_DWORD *)((*v15)[4] + 8) = v10;
          v10[1] = (int *)((*v15)[4] - (*v15)[5]);
          (*v15)[4] = (int)v10;
          v16 = *v15;
        }
        else
        {
          v10[1] = 0;
          dword_612F4 = (int)v10;
          v54 = (int *)malloc(0x2Cu);
          v16 = v54;
          *v10 = v54;
          if ( !v54 )
            goto LABEL_78;
          *v54 = 0;
          v54[3] = 0;
          v54[4] = 0;
          v54[5] = 0;
          v54[6] = 0;
          v54[7] = 0;
          v54[8] = 0;
          v54[9] = 0;
          v54[10] = 0;
          v54[4] = (int)v10;
          v54[5] = 0;
          v54[1] = 32;
          v54[2] = 5;
          v55 = malloc(0x180u);
          *v16 = (int)v55;
          if ( !v55 )
            goto LABEL_78;
          memset(v55, 0, 0x180u);
          v15 = v10;
          v16[10] = -1609490463;
        }
        ++v16[3];
        v17 = (*((unsigned __int8 *)v10 + 40)
             + 17973517
             + (*((unsigned __int8 *)v10 + 43) << 24)
             + (*((unsigned __int8 *)v10 + 42) << 16)
             + (*((unsigned __int8 *)v10 + 41) << 8))
            ^ (unsigned int)&unk_7F76D;
        *v10 = *v15;
        v18 = (-1622558010 - v17) ^ (v17 << 8);
        v19 = (-17973517 - v17 - v18) ^ (v18 >> 13);
        v20 = (v17 - v18 - v19) ^ (v19 >> 12);
        v21 = (v18 - v19 - v20) ^ (v20 << 16);
        v22 = (v19 - v20 - v21) ^ (v21 >> 5);
        v23 = v20 - v21 - v22;
        v24 = (v22 - (v23 ^ (v22 >> 3)) - ((v21 - v22 - (v23 ^ (v22 >> 3))) ^ ((v23 ^ (v22 >> 3)) << 10)))
            ^ (((v21 - v22 - (v23 ^ (v22 >> 3))) ^ ((v23 ^ (v22 >> 3)) << 10)) >> 15);
        v10[7] = (int *)v24;
        v25 = 3 * (v24 & ((*v15)[1] - 1));
        v26 = 12 * (v24 & ((*v15)[1] - 1));
        ++*(_DWORD *)(**v15 + v26 + 4);
        v27 = *(int **)(**v15 + 4 * v25);
        v10[3] = 0;
        v10[4] = v27;
        v28 = **v15;
        v29 = (int ***)(v28 + v26);
        v30 = *(_DWORD *)(v28 + 4 * v25);
        if ( v30 )
        {
          *(_DWORD *)(v30 + 12) = v10;
          v29 = (int ***)(**v15 + v26);
        }
        *v29 = v10;
        if ( *(_DWORD *)(**v15 + v26 + 4) < (unsigned int)(10 * (*(_DWORD *)(**v15 + v26 + 8) + 1)) )
          goto LABEL_45;
        v31 = *v10;
        if ( (*v10)[9] == 1 )
          goto LABEL_45;
        v32 = 24 * v31[1];
        v33 = malloc(v32);
        v34 = v33;
        if ( v33 )
        {
          memset(v33, 0, v32);
          v35 = 0;
          v31[6] = (((2 * v31[1] - 1) & v31[3]) != 0) + ((unsigned int)v31[3] >> (*((_BYTE *)v31 + 8) + 1));
          (*v10)[7] = 0;
          v36 = (void **)*v10;
          v37 = (*v10)[1];
          if ( v37 )
          {
            v38 = (void ***)v10;
            for ( i = 0; i < v37; ++i )
            {
              v39 = *(_DWORD **)((char *)*v36 + v35);
              if ( v39 )
              {
                while ( 1 )
                {
                  v40 = (_DWORD *)v39[4];
                  v41 = 3 * ((2 * v37 - 1) & v39[7]);
                  v42 = (char *)&v34[v41];
                  v43 = *((_DWORD *)v42 + 1) + 1;
                  *((_DWORD *)v42 + 1) = v43;
                  if ( v43 > (unsigned int)v36[6] )
                  {
                    v36[7] = (char *)v36[7] + 1;
                    *((_DWORD *)v42 + 2) = *((_DWORD *)v42 + 1) / (unsigned int)(*v38)[6];
                  }
                  v39[3] = 0;
                  v39[4] = v34[v41];
                  v44 = v34[v41];
                  if ( v44 )
                    *(_DWORD *)(v44 + 12) = v39;
                  v34[v41] = v39;
                  v36 = *v38;
                  if ( !v40 )
                    break;
                  v37 = (unsigned int)v36[1];
                  v39 = v40;
                }
                v37 = (unsigned int)v36[1];
              }
              v35 += 12;
            }
            v10 = (int **)v38;
          }
          free(*v36);
          (*v10)[1] *= 2;
          ++(*v10)[2];
          **v10 = (int)v34;
          v45 = *v10;
          v46 = (*v10)[3];
          v47 = (*v10)[7];
          v48 = v47 > v46 >> 1;
          if ( v47 <= v46 >> 1 )
            v49 = 0;
          else
            v49 = v45[8];
          if ( v48 )
            ++v49;
          v45[8] = v49;
          if ( (unsigned int)(*v10)[8] > 1 )
            (*v10)[9] = 1;
LABEL_45:
          ++a1[175];
          if ( pthread_mutex_unlock(&stru_612DC) )
            sub_B694("stratum_sthread", 7310);
          off_60178();
          if ( sub_1822C((int)a1, (_BYTE *)a1 + 96) && (byte_632F0 || byte_630C0 || dword_60964 > 3) )
          {
            snprintf(v70, 0x800u, "Pool %d communication resumed, submitting work", *a1);
            sub_38438(4, v70, 0);
          }
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            strcpy(v70, "Successfully submitted, adding to stratum_shares db");
            sub_38438(7, v70, 0);
          }
          v50 = time(0);
          v51 = v10[11];
          v52 = byte_630C1 == 0;
          v10[12] = (int *)v50;
          if ( !v52 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(v70, 0x800u, "Pool %d stratum share submission lag time %d seconds", *a1, v50 - (_DWORD)v51);
            sub_38438(7, v70, 0);
          }
          goto LABEL_61;
        }
LABEL_78:
        exit(-1);
      }
      if ( !sub_17E64((int)a1, (_BYTE *)a1 + 96) && sub_1FB7C((int)a1) )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(v70, 0x800u, "Pool %d stratum share submission failure", *a1);
          sub_38438(4, v70, 0);
        }
        v59 = a1[33];
        ++dword_63410;
        a1[33] = v59 + 1;
      }
      if ( byte_63BE4 )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
        sub_B4E4("stratum_sthread", 7331);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 59)) )
        sub_B76C("stratum_sthread", 7331);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
        sub_B694("stratum_sthread", 7331);
      v57 = (const char *)a1[151];
      if ( v57 )
        v58 = strcmp(*(const char **)(v8 + 320), v57) == 0;
      else
        v58 = 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
        sub_B700("stratum_sthread", 7333);
      off_60178();
      if ( !v58 )
      {
        if ( byte_630C1 )
        {
          if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
            goto LABEL_74;
          strcpy(v70, "No matching session id for resubmitting stratum share");
          sub_38438(7, v70, 0);
LABEL_71:
          if ( byte_630C1 )
          {
            if ( !byte_632F0 )
              goto LABEL_74;
            goto LABEL_76;
          }
        }
        goto LABEL_72;
      }
      sleep(5u);
    }
    if ( byte_630C1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
      {
        strcpy(v70, "Lowmem option prevents resubmitting stratum share");
        sub_38438(7, v70, 0);
        goto LABEL_71;
      }
LABEL_74:
      if ( byte_630C0 || dword_60964 > 6 )
      {
LABEL_76:
        strcpy(v70, "Failed to submit stratum share, discarding");
        sub_38438(7, v70, 0);
      }
    }
LABEL_72:
    sub_152B8((void **)v8);
    free(v10);
    v56 = *(_QWORD *)&dword_64220 + 1LL;
    ++a1[30];
    *(_QWORD *)&dword_64220 = v56;
LABEL_61:
    v5 = a1;
    v4 = v63;
    v3 = v62;
    v6 = (const struct timespec *)*((unsigned __int8 *)a1 + 105);
  }
  while ( !*((_BYTE *)a1 + 105) );
LABEL_62:
  sub_2AB58(a1[174]);
  return 0;
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 612F4: using guessed type int dword_612F4;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63410: using guessed type int dword_63410;
// 636A0: using guessed type int dword_636A0;
// 63BE4: using guessed type char byte_63BE4;
// 64220: using guessed type int dword_64220;

//----- (0002282C) --------------------------------------------------------
int __fastcall sub_2282C(int a1, int a2)
{
  int v5; // r7
  int v6; // r8
  int v7; // r7
  const char *v8; // lr
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // lr
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r9
  struct timeval v21; // [sp+0h] [bp-808h] BYREF
  _DWORD v22[10]; // [sp+8h] [bp-800h] BYREF
  __int16 v23; // [sp+30h] [bp-7D8h]

  if ( byte_615C9 || dword_612AC )
    return 0;
  if ( *(_DWORD *)(a1 + 336) != dword_6136C )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy((char *)v22, "Work stale due to block mismatch");
      sub_38438(7, (const char *)v22, 0);
      return 1;
    }
    return 1;
  }
  v5 = *(_DWORD *)(a1 + 276);
  v6 = *(_DWORD *)(a1 + 260);
  if ( v5 <= dword_60090 )
    v5 = dword_60094;
  if ( !a2 && *(_BYTE *)(v6 + 632) )
  {
    if ( !*(_BYTE *)(v6 + 633) || !*(_BYTE *)(v6 + 635) )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy((char *)v22, "Work stale due to stratum inactive");
        sub_38438(7, (const char *)v22, 0);
        return 1;
      }
      return 1;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(v6 + 212)) )
      sub_B4E4("stale_work", 4917);
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 236)) )
      sub_B76C("stale_work", 4917);
    if ( pthread_mutex_unlock((pthread_mutex_t *)(v6 + 212)) )
      sub_B694("stale_work", 4917);
    v20 = strcmp(*(const char **)(a1 + 288), *(const char **)(v6 + 640));
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 236)) )
      sub_B700("stale_work", 4920);
    off_60178();
    if ( v20 )
    {
      if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
        return 1;
      v8 = "Work stale due to stratum job_id mismatch";
LABEL_42:
      v9 = *(_DWORD *)v8;
      v10 = *((_DWORD *)v8 + 1);
      v11 = *((_DWORD *)v8 + 2);
      v12 = *((_DWORD *)v8 + 3);
      v13 = (int *)(v8 + 16);
      v22[0] = v9;
      v22[1] = v10;
      v22[2] = v11;
      v22[3] = v12;
      v14 = *v13;
      v15 = v13[1];
      v16 = v13[2];
      v17 = v13[3];
      v13 += 4;
      v22[4] = v14;
      v22[5] = v15;
      v22[6] = v16;
      v22[7] = v17;
      v18 = v13[1];
      v19 = v13[2];
      v22[8] = *v13;
      v22[9] = v18;
      v23 = v19;
      sub_38438(7, (const char *)v22, 0);
      return 1;
    }
  }
  v7 = v5 - (int)(*(double *)(v6 + 440) * 5.0 + 1.0);
  sub_2B13C(&v21);
  if ( v7 < 5 )
    v7 = 5;
  if ( v21.tv_sec - *(_DWORD *)(a1 + 264) >= v7 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy((char *)v22, "Work stale due to expiry");
      sub_38438(7, (const char *)v22, 0);
      return 1;
    }
    return 1;
  }
  if ( byte_63BC5 && !a2 && v6 != sub_1D644() && !*(_BYTE *)(a1 + 282) && dword_611AC != 3 && dword_611AC != 4 )
  {
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return 1;
    v8 = "Work stale due to fail only pool mismatch";
    goto LABEL_42;
  }
  return 0;
}
// 60090: using guessed type int dword_60090;
// 60094: using guessed type int dword_60094;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 611AC: using guessed type int dword_611AC;
// 612AC: using guessed type int dword_612AC;
// 6136C: using guessed type int dword_6136C;
// 615C9: using guessed type char byte_615C9;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63BC5: using guessed type char byte_63BC5;

//----- (00022C60) --------------------------------------------------------
void sub_22C60()
{
  _DWORD *v0; // r4
  int v1; // r6
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2
  _DWORD *v5; // r12
  int v6; // r0
  int v7; // r3
  bool v8; // zf
  int v9; // r3
  _DWORD *v10; // r3
  int v11; // r1
  int v12; // r3
  _DWORD *v13; // r0
  int v14; // r3
  int v15; // r3
  char v16[2048]; // [sp+0h] [bp-800h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
    sub_B4E4("discard_stale", 5192);
  v0 = (_DWORD *)dword_612CC;
  if ( dword_612CC )
  {
    v2 = *(_DWORD **)(dword_612CC + 352);
    v1 = 0;
    while ( 1 )
    {
      if ( sub_2282C((int)v0, 0) )
      {
        v3 = v0[87];
        if ( v3 || v0[88] )
        {
          v4 = dword_612CC;
          v5 = v0 + 86;
          v6 = *(_DWORD *)(dword_612CC + 344);
          v7 = *(_DWORD *)(v6 + 20);
          if ( (_DWORD *)(*(_DWORD *)(v6 + 16) - v7) == v0 )
          {
            *(_DWORD *)(v6 + 16) = v3 + v7;
            v3 = v0[87];
          }
          v8 = v3 == 0;
          if ( v3 )
            v6 = *(_DWORD *)(v4 + 344);
          v9 = v0[88];
          if ( v3 )
          {
            v3 += *(_DWORD *)(v6 + 20);
          }
          else
          {
            v4 = v0[88];
            dword_612CC = v4;
          }
          if ( !v8 )
          {
            *(_DWORD *)(v3 + 8) = v9;
            v9 = v0[88];
          }
          if ( v9 )
            *(_DWORD *)(v9 + *(_DWORD *)(*(_DWORD *)(v4 + 344) + 20) + 4) = v0[87];
          v10 = *(_DWORD **)(v4 + 344);
          v11 = 3 * ((v10[1] - 1) & v0[93]);
          --*(_DWORD *)(*v10 + 4 * v11 + 4);
          v12 = **(_DWORD **)(v4 + 344);
          v13 = *(_DWORD **)(v12 + 4 * v11);
          if ( v13 == v5 )
          {
            v4 = v0[90];
            *(_DWORD *)(v12 + 4 * v11) = v4;
          }
          v14 = v0[89];
          if ( v13 == v5 )
            v4 = dword_612CC;
          if ( v14 )
            *(_DWORD *)(v14 + 16) = v0[90];
          v15 = v0[90];
          if ( v15 )
            *(_DWORD *)(v15 + 12) = v0[89];
          --*(_DWORD *)(*(_DWORD *)(v4 + 344) + 12);
        }
        else
        {
          free(**(void ***)(dword_612CC + 344));
          free(*(void **)(dword_612CC + 344));
          dword_612CC = 0;
        }
        ++v1;
        sub_154EC((int)v0);
      }
      if ( !v2 )
        break;
      v0 = v2;
      v2 = (_DWORD *)v2[88];
    }
  }
  else
  {
    v1 = 0;
  }
  pthread_cond_signal(&stru_63748);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
    sub_B694("discard_stale", 5203);
  off_60178();
  if ( v1 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v16, 0x800u, "Discarded %d stales that didn't match current hash", v1);
    sub_38438(7, v16, 0);
  }
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 612C8: using guessed type int dword_612C8;
// 612CC: using guessed type int dword_612CC;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00022EC4) --------------------------------------------------------
void *__fastcall sub_22EC4(void *a1)
{
  int v1; // r4
  pthread_t v2; // r0
  int v3; // r6
  int v4; // r4
  int v5; // r3
  pthread_rwlock_t *v6; // r5

  v1 = sub_1D644();
  v2 = pthread_self();
  pthread_detach(v2);
  sub_17E64(v1, (_BYTE *)(v1 + 98));
  sub_22C60();
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_B76C("restart_thread", 5248);
  v3 = dword_6410C;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_B700("restart_thread", 5250);
  off_60178();
  if ( v3 > 0 )
  {
    v4 = 0;
    do
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(dword_63B80 + 4 * v4++);
        v6 = *(pthread_rwlock_t **)(v5 + 36);
        if ( v6 )
        {
          if ( !v6[1].__lock )
            break;
        }
        if ( v4 == v3 )
          goto LABEL_9;
      }
      *(_BYTE *)(v5 + 62) = 1;
      sub_1A3E0(v6);
      (*(void (__fastcall **)(pthread_rwlock_t *))(v6->__nr_readers + 76))(v6);
    }
    while ( v4 != v3 );
  }
LABEL_9:
  if ( pthread_mutex_lock(&stru_63BCC) )
    sub_B4E4("restart_thread", 5262);
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&stru_63BCC) )
    sub_B694("restart_thread", 5264);
  off_60178();
  return 0;
}
// 60178: using guessed type int (*off_60178)();
// 63B80: using guessed type int dword_63B80;
// 6410C: using guessed type int dword_6410C;

//----- (00023018) --------------------------------------------------------
void __noreturn sub_23018()
{
  double v0; // d0
  int v1; // r4
  int v2; // r0
  int v3; // r5
  int v4; // r3
  int v5; // r5
  int v6; // r3
  int v7; // r0
  int v8; // r4
  int v9; // r6
  int v10; // r3
  int v11; // r1
  int v12; // r4
  int *v13; // r3
  int v14; // r1
  int v15; // t1
  int v16; // r2
  int v17; // r4
  int v18; // r5
  bool v19; // cc
  int v20; // r1
  int v21; // r1
  int v22; // r3
  int v23; // r2
  bool v24; // zf
  int v25; // r0
  int v26; // r5
  int v27; // r10
  int v28; // r8
  int v29; // r0
  int v30; // r7
  const char *v31; // r0
  const char *v32; // r1
  int v33; // r8
  int v34; // r10
  int v35; // r1
  double v36; // d8
  __int64 v37; // d11
  WINDOW *v38; // r0
  const char *v39; // r3
  size_t v40; // r0
  int v41; // r3
  const char *v42; // r3
  int v43; // r3
  double v44; // r0
  double v45; // d11
  unsigned __int64 v46; // r0
  unsigned __int64 v47; // r0
  double v48; // r0
  int v49; // r0
  int v50; // r4
  int v51; // r2
  int v52; // r2
  int v53; // r0
  int v54; // r1
  double v55; // r0
  double v56; // d12
  int v57; // r8
  double v58; // d11
  double v59; // r0
  double v60; // d8
  int v61; // r0
  const char *v62; // r3
  double v63; // r0
  double v64; // r0
  unsigned __int64 v65; // r0
  unsigned __int64 v66; // r0
  double v67; // r0
  double v68; // r0
  double v69; // r0
  double v70; // r0
  double v71; // [sp+0h] [bp-9A4h]
  double v72; // [sp+8h] [bp-99Ch]
  int v73; // [sp+10h] [bp-994h]
  int v74; // [sp+48h] [bp-95Ch]
  struct timeval v75; // [sp+6Ch] [bp-938h] BYREF
  char dest[12]; // [sp+74h] [bp-930h] BYREF
  char v77[16]; // [sp+80h] [bp-924h] BYREF
  struct timeval v78[2]; // [sp+90h] [bp-914h] BYREF
  char v79[256]; // [sp+A0h] [bp-904h] BYREF
  _DWORD v80[512]; // [sp+1A0h] [bp-804h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2F02C("Watchdog");
  sub_11C4C();
  sub_2B13C(&stru_615CC);
LABEL_2:
  while ( 1 )
  {
    sleep(2u);
    sub_22C60();
    sub_1C834(-1, 0);
    if ( sub_19140() )
      break;
LABEL_3:
    sub_2B13C(v78);
    if ( byte_6373C )
      goto LABEL_181;
    if ( !sub_1161C() )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(
          (char *)v80,
          0x800u,
          "Pausing execution as per stop time %02d:%02d scheduled",
          dword_63B9C,
          dword_63B98);
        sub_38438(4, (const char *)v80, 0);
      }
      v12 = (unsigned __int8)byte_63E14;
      if ( !byte_63E14 )
      {
        strcpy((char *)v80, "Terminating execution as planned");
        sub_38438(3, (const char *)v80, 1);
        sub_16724(v12);
      }
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf((char *)v80, 0x800u, "Will restart execution as scheduled at %02d:%02d", dword_63E20, dword_63E1C);
        sub_38438(4, (const char *)v80, 0);
      }
      byte_6373C = 1;
      if ( pthread_rwlock_rdlock(&rwlock) )
        sub_B76C("watchdog_thread", 9725);
      if ( dword_6410C > 0 )
      {
        v13 = (int *)dword_63B80;
        v14 = dword_63B80 + 4 * dword_6410C;
        do
        {
          v15 = *v13++;
          *(_BYTE *)(v15 + 60) = 1;
        }
        while ( v13 != (int *)v14 );
      }
      if ( pthread_rwlock_unlock(&rwlock) )
        sub_B700("watchdog_thread", 9728);
      off_60178();
      goto LABEL_22;
    }
    if ( byte_6373C )
    {
LABEL_181:
      if ( sub_1161C() )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(
            (char *)v80,
            0x800u,
            "Restarting execution as per start time %02d:%02d scheduled",
            dword_63E20,
            dword_63E1C);
          sub_38438(4, (const char *)v80, 0);
        }
        if ( byte_63B90 && (byte_632F0 || byte_630C0 || dword_60964 > 3) )
        {
          snprintf((char *)v80, 0x800u, "Will pause execution as scheduled at %02d:%02d", dword_63B9C, dword_63B98);
          sub_38438(4, (const char *)v80, 0);
        }
        v1 = 0;
        byte_6373C = 0;
        while ( dword_6410C > v1 )
        {
          v2 = v1++;
          v3 = sub_1C36C(v2);
          if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 32) != 1 )
          {
            v4 = (unsigned __int8)byte_630C1;
            *(_BYTE *)(v3 + 60) = 0;
            if ( v4 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              snprintf((char *)v80, 0x800u, "Pushing sem post to thread %d", *(_DWORD *)v3);
              sub_38438(7, (const char *)v80, 0);
            }
            sub_2F134((sem_t *)(v3 + 16), "cgminer.c", "watchdog_thread", 9750);
          }
        }
      }
    }
LABEL_22:
    if ( dword_63CC0 > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        v7 = sub_1AB68(v5);
        v8 = v7;
        v9 = **(_DWORD **)(v7 + 152);
        if ( !v9 )
          goto LABEL_35;
        (*(void (**)(void))(*(_DWORD *)(v7 + 4) + 32))();
        snprintf(v79, 8u, "%s %d", *(const char **)(*(_DWORD *)(v8 + 4) + 8), *(_DWORD *)(v8 + 8));
        if ( *(_BYTE *)(v9 + 61) || *(_DWORD *)(v8 + 32) == 1 )
          goto LABEL_35;
        v10 = *(_DWORD *)(v8 + 96);
        v11 = v78[0].tv_sec - *(_DWORD *)(v9 + 44);
        if ( v10 )
          break;
        if ( v11 <= 120 )
          goto LABEL_48;
        *(_QWORD *)(v8 + 48) = 0;
        v6 = (unsigned __int8)byte_632F0;
        *(_DWORD *)(v8 + 96) = 1;
        if ( v6 || byte_630C0 || dword_60964 > 2 )
        {
          snprintf((char *)v80, 0x800u, "%s: Idle for more than 60 seconds, declaring SICK!", v79);
          sub_38438(3, (const char *)v80, 0);
        }
        sub_2B13C((struct timeval *)(v9 + 52));
        sub_2ED00((_DWORD *)v8, 3);
        if ( !byte_600AC )
          goto LABEL_35;
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          snprintf((char *)v80, 0x800u, "%s: Attempting to restart", v79);
          sub_38438(3, (const char *)v80, 0);
        }
LABEL_34:
        sub_16704(v8);
LABEL_35:
        if ( dword_63CC0 <= ++v5 )
          goto LABEL_2;
      }
      if ( v11 <= 119 )
      {
        if ( v10 != 4 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
        {
          snprintf((char *)v80, 0x800u, "%s: Recovered, declaring WELL!", v79);
          sub_38438(3, (const char *)v80, 0);
        }
        *(_DWORD *)(v8 + 96) = 0;
        *(_DWORD *)(v8 + 240) = time(0);
        goto LABEL_35;
      }
      if ( v10 == 1 && v11 > 600 )
      {
        *(_DWORD *)(v8 + 96) = 2;
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          snprintf((char *)v80, 0x800u, "%s: Not responded for more than 10 minutes, declaring DEAD!", v79);
          sub_38438(3, (const char *)v80, 0);
        }
        sub_2B13C((struct timeval *)(v9 + 52));
        sub_2ED00((_DWORD *)v8, 4);
        goto LABEL_35;
      }
LABEL_48:
      if ( v78[0].tv_sec - *(_DWORD *)(v9 + 52) <= 60 )
        goto LABEL_35;
      if ( (unsigned int)(v10 - 1) > 1 )
        goto LABEL_35;
      sub_2B13C((struct timeval *)(v9 + 52));
      if ( !byte_600AC )
        goto LABEL_35;
      goto LABEL_34;
    }
  }
  if ( dword_64230 )
  {
    v16 = *(__int16 *)(dword_64230 + 4);
    v17 = v16 + 1;
    v18 = *(__int16 *)(dword_64230 + 6) + 1;
    v19 = v18 <= 79;
    if ( v18 > 79 )
      v19 = v17 <= 24;
    if ( !v19 )
    {
      if ( v17 > dword_61300 + 2 )
      {
        v20 = dword_612FC;
        if ( dword_61300 < dword_612FC )
        {
          if ( v16 <= dword_612FC )
            v20 = v16 - 1;
          dword_61300 = v20;
          dword_61304 = v20 + 1;
          mvwin((WINDOW *)dword_639D8, v20 + 1, 0);
          wresize((WINDOW *)dword_63D60, dword_61300, v18);
        }
      }
      v21 = v17 - dword_61304;
      if ( dword_639D8 )
        v22 = *(__int16 *)(dword_639D8 + 4);
      else
        v22 = -1;
      if ( dword_639D8 )
        v23 = *(__int16 *)(dword_639D8 + 6);
      else
        v23 = v22;
      if ( dword_639D8 )
      {
        ++v22;
        ++v23;
      }
      v24 = v18 == v23;
      if ( v18 == v23 )
        v24 = v21 == v22;
      if ( !v24 )
        wresize((WINDOW *)dword_639D8, v21, v18);
    }
  }
  v25 = sub_1D644();
  if ( byte_615D4 )
    v26 = 100;
  else
    v26 = 80;
  v74 = v25;
  wattr_on((WINDOW *)dword_63D60, 0x200000u, 0);
  snprintf((char *)v80, 0x100u, " cgminer version 4.9.0 - Started: %s", byte_613EC);
  mvwprintw((WINDOW *)dword_63D60, 0, 0, "%s", (const char *)v80);
  wattr_off((WINDOW *)dword_63D60, 0x200000u, 0);
  if ( wmove((WINDOW *)dword_63D60, 1, 0) != -1 )
    whline((WINDOW *)dword_63D60, 0x2Du, v26);
  snprintf((char *)v80, 0x100u, " %s", byte_61438);
  mvwprintw((WINDOW *)dword_63D60, 2, 0, "%s", (const char *)v80);
  wclrtoeol((WINDOW *)dword_63D60);
  v27 = (unsigned __int8)byte_615D4;
  if ( byte_615D4 )
  {
    v56 = dbl_63B88;
    v57 = dword_63E44;
    v58 = dbl_63C10;
    LODWORD(v59) = sub_493DC(*(__int64 *)&dword_636A8);
    v60 = v59 / dbl_5F898;
    v61 = sub_17F48();
    snprintf(
      (char *)v80,
      0x100u,
      " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m | ST: %d  SS: %lld  NB: %d  LW: %d  GF: %d  RF: %d",
      v56,
      v58,
      v57,
      v60 * 60.0,
      v61,
      *(_QWORD *)&dword_64220,
      dword_640BC,
      dword_63A70,
      dword_639E4,
      dword_63410);
    mvwprintw((WINDOW *)dword_63D60, 3, 0, "%s", (const char *)v80);
  }
  else
  {
    v28 = (unsigned __int8)byte_6142C;
    if ( byte_6142C )
    {
      v29 = sub_17F48();
      snprintf(
        (char *)v80,
        0x100u,
        " ST: %d  SS: %lld  NB: %d  LW: %d  GF: %d  RF: %d",
        v29,
        *(_QWORD *)&dword_64220,
        dword_640BC,
        dword_63A70,
        dword_639E4,
        dword_63410);
      mvwprintw((WINDOW *)dword_63D60, 3, v27, "%s", (const char *)v80);
    }
    else
    {
      v71 = dbl_63B88;
      v73 = dword_63E44;
      v72 = dbl_63C10;
      LODWORD(v55) = sub_493DC(*(__int64 *)&dword_636A8);
      snprintf((char *)v80, 0x100u, " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m", v71, v72, v73, v55 / dbl_5F898 * 60.0);
      mvwprintw((WINDOW *)dword_63D60, 3, v28, "%s", (const char *)v80);
    }
  }
  wclrtoeol((WINDOW *)dword_63D60);
  if ( (unsigned int)(dword_611AC - 3) > 1 || dword_63740 <= 1 )
  {
    v30 = *(unsigned __int8 *)(v74 + 632);
    if ( !*(_BYTE *)(v74 + 632) )
    {
      v31 = (const char *)(unsigned __int8)byte_64219;
      if ( !byte_64219 )
        v31 = "out";
      v32 = "LP";
      if ( byte_64219 )
        v31 = "";
      if ( *(_BYTE *)(v74 + 704) )
        v32 = "GBT";
      snprintf(
        (char *)v80,
        0x100u,
        " Connected to %s diff %s with%s %s as user %s",
        *(const char **)(v74 + 592),
        (const char *)(v74 + 48),
        v31,
        v32,
        *(const char **)(v74 + 172));
      mvwprintw((WINDOW *)dword_63D60, 4, v30, "%s", (const char *)v80);
      goto LABEL_113;
    }
    snprintf(
      (char *)v80,
      0x100u,
      " Connected to %s diff %s with stratum as user %s",
      *(const char **)(v74 + 592),
      (const char *)(v74 + 48),
      *(const char **)(v74 + 172));
  }
  else
  {
    v62 = "out";
    if ( byte_64219 )
      v62 = "";
    snprintf((char *)v80, 0x100u, " Connected to multiple pools with%s block change notify", v62);
  }
  mvwprintw((WINDOW *)dword_63D60, 4, 0, "%s", (const char *)v80);
LABEL_113:
  wclrtoeol((WINDOW *)dword_63D60);
  snprintf(
    (char *)v80,
    0x100u,
    " Block: %s...  Diff:%s  Started: %s  Best share: %s   ",
    byte_615BC,
    byte_61574,
    byte_6159C,
    (const char *)&dword_60064);
  mvwprintw((WINDOW *)dword_63D60, 5, 0, "%s", (const char *)v80);
  if ( wmove((WINDOW *)dword_63D60, 6, 0) != -1 )
    whline((WINDOW *)dword_63D60, 0x2Du, v26);
  if ( wmove((WINDOW *)dword_63D60, dword_61300 - 1, 0) != -1 )
    whline((WINDOW *)dword_63D60, 0x2Du, v26);
  strcpy((char *)v80, "[P]ool management [S]ettings [D]isplay options [Q]uit");
  mvwprintw((WINDOW *)dword_63D60, dword_61308 - 1, 1, "%s", (const char *)v80);
  if ( dword_63CC0 <= 0 )
  {
LABEL_146:
    if ( dword_63D60 )
      v51 = *(__int16 *)(dword_63D60 + 4) + 1;
    else
      v51 = -1;
    wtouchln((WINDOW *)dword_63D60, 0, v51, 1);
    wrefresh((WINDOW *)dword_63D60);
    if ( dword_639D8 )
      v52 = *(__int16 *)(dword_639D8 + 4);
    else
      v52 = -1;
    if ( dword_639D8 )
      ++v52;
    wtouchln((WINDOW *)dword_639D8, 0, v52, 1);
    wrefresh((WINDOW *)dword_639D8);
    if ( pthread_mutex_unlock(&stru_63D48) )
      sub_B694("unlock_curses", 2928);
    off_60178();
    goto LABEL_3;
  }
  v33 = 0;
  v34 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v49 = sub_1AB68(v34);
      v50 = v49;
      if ( !v49 )
        goto LABEL_142;
      if ( !byte_63EE0 )
      {
        v35 = v33 + dword_61308;
        if ( LINES - 1 > v33 + dword_61308 && dword_6130C > v33 )
          break;
      }
      ++v34;
      ++v33;
      if ( dword_63CC0 <= v34 )
        goto LABEL_146;
    }
    if ( *(_DWORD *)(v49 + 368) )
    {
      sub_2B13C(&v75);
      sub_2B314();
      v35 = v33 + dword_61308;
      v36 = v0;
    }
    else
    {
      v36 = dbl_5F898;
    }
    v37 = *(_QWORD *)(v50 + 192);
    v38 = (WINDOW *)dword_63D60;
    if ( v36 < 1.0 )
      v36 = 1.0;
    *(double *)(v50 + 88) = (double)*(int *)(v50 + 36) / v36 * 60.0;
    wmove(v38, v35, 0);
    sub_110F8(COERCE_DOUBLE(__PAIR64__(&dword_60098, v34)));
    v39 = *(const char **)(v50 + 28);
    if ( v39 )
    {
      strcpy(dest, "        ");
      strncpy(dest, v39, 8u);
    }
    else
    {
      sprintf(dest, "%-8d", *(_DWORD *)(v50 + 8));
    }
    snprintf((char *)v80, 0x100u, " %*d: %s %-8s: ", dword_60098, v34, *(const char **)(*(_DWORD *)(v50 + 4) + 8), dest);
    wprintw((WINDOW *)dword_63D60, "%s", (const char *)v80);
    v79[0] = 0;
    (*(void (__fastcall **)(char *, int, int))(*(_DWORD *)(v50 + 4) + 20))(v79, 256, v50);
    v40 = strlen(v79);
    if ( v40 <= 0x16 )
      strncat(v79, "                                        ", 23 - v40);
    snprintf((char *)v80, 0x100u, "%s | ", v79);
    wprintw((WINDOW *)dword_63D60, "%s", (const char *)v80);
    v41 = *(_DWORD *)(v50 + 96);
    if ( v41 == 2 )
    {
      v42 = "DEAD  ";
    }
    else if ( v41 == 1 )
    {
      v42 = "SICK  ";
    }
    else
    {
      v43 = *(_DWORD *)(v50 + 32);
      if ( v43 == 1 )
      {
        v42 = "OFF   ";
      }
      else
      {
        if ( v43 != 2 )
        {
          LODWORD(v44) = sub_493DC(v37);
          v45 = v44 / v36 * 60.0;
          if ( byte_615D4 )
          {
            LODWORD(v65) = sub_494C0(*(double *)(v50 + 80) / v36 * 1000000.0);
            sub_11130(v65, v77, 0x10u, 4);
            LODWORD(v66) = sub_494C0(*(double *)(v50 + 48) * 1000000.0);
            sub_11130(v66, (char *)v78, 0x10u, 4);
            HIDWORD(v67) = &dword_6009C;
            LODWORD(v67) = (int)v45;
            v68 = sub_110F8(v67);
            LODWORD(v68) = &dword_600A0;
            v69 = sub_110C4(v68);
            LODWORD(v69) = &dword_600A4;
            *(float *)&v0 = *(double *)(v50 + 208);
            sub_110C4(v69);
            LODWORD(v70) = *(_DWORD *)(v50 + 44);
            HIDWORD(v70) = &dword_600A8;
            sub_110F8(v70);
            snprintf(
              (char *)v80,
              0x100u,
              "%6s / %6sh/s WU:%*.1f/m A:%*.0f R:%*.0f HW:%*d",
              (const char *)v78,
              v77,
              dword_6009C + 2,
              v45,
              dword_600A0,
              *(double *)(v50 + 200),
              dword_600A4,
              *(double *)(v50 + 208),
              dword_600A8,
              *(_DWORD *)(v50 + 44));
            wprintw((WINDOW *)dword_63D60, "%s", (const char *)v80);
          }
          else
          {
            if ( byte_6142C )
            {
              LODWORD(v44) = &dword_600A0;
              v63 = sub_110C4(v44);
              LODWORD(v63) = &dword_600A4;
              *(float *)&v0 = *(double *)(v50 + 208);
              sub_110C4(v63);
              LODWORD(v64) = *(_DWORD *)(v50 + 44);
              HIDWORD(v64) = &dword_600A8;
              sub_110F8(v64);
              snprintf(
                (char *)v80,
                0x100u,
                "A:%*.0f R:%*.0f HW:%*d",
                dword_600A0,
                *(double *)(v50 + 200),
                dword_600A4,
                *(double *)(v50 + 208),
                dword_600A8,
                *(_DWORD *)(v50 + 44));
            }
            else
            {
              LODWORD(v46) = sub_494C0(*(double *)(v50 + 80) / v36 * 1000000.0);
              sub_11130(v46, v77, 0x10u, 4);
              LODWORD(v47) = sub_494C0(*(double *)(v50 + 48) * 1000000.0);
              sub_11130(v47, (char *)v78, 0x10u, 4);
              HIDWORD(v48) = &dword_6009C;
              LODWORD(v48) = (int)v45;
              sub_110F8(v48);
              snprintf((char *)v80, 0x100u, "%6s / %6sh/s WU:%*.1f/m", (const char *)v78, v77, dword_6009C + 2, v45);
            }
            wprintw((WINDOW *)dword_63D60, "%s", (const char *)v80);
          }
          goto LABEL_141;
        }
        v42 = "REST  ";
      }
    }
    v53 = *(_DWORD *)v42;
    v54 = *((_DWORD *)v42 + 1);
    LOWORD(v80[1]) = v54;
    v80[0] = v53;
    BYTE2(v80[1]) = BYTE2(v54);
    wprintw((WINDOW *)dword_63D60, "%s", (const char *)v80);
LABEL_141:
    v79[0] = 0;
    ++v33;
    (*(void (__fastcall **)(char *, int, int))(*(_DWORD *)(v50 + 4) + 24))(v79, 256, v50);
    snprintf((char *)v80, 0x100u, "%s", v79);
    wprintw((WINDOW *)dword_63D60, "%s", (const char *)v80);
    wclrtoeol((WINDOW *)dword_63D60);
LABEL_142:
    if ( dword_63CC0 <= ++v34 )
      goto LABEL_146;
  }
}
// 23DA0: variable 'v44' is possibly undefined
// 23DE4: variable 'v46' is possibly undefined
// 23E08: variable 'v47' is possibly undefined
// 2400C: variable 'v55' is possibly undefined
// 2406C: variable 'v59' is possibly undefined
// 24168: variable 'v0' is possibly undefined
// 24278: variable 'v65' is possibly undefined
// 2429C: variable 'v66' is possibly undefined
// 5F898: using guessed type double dbl_5F898;
// 60064: using guessed type int dword_60064;
// 60098: using guessed type int dword_60098;
// 6009C: using guessed type int dword_6009C;
// 600A0: using guessed type int dword_600A0;
// 600A4: using guessed type int dword_600A4;
// 600A8: using guessed type int dword_600A8;
// 600AC: using guessed type char byte_600AC;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 60E74: using guessed type int LINES;
// 611AC: using guessed type int dword_611AC;
// 612FC: using guessed type int dword_612FC;
// 61300: using guessed type int dword_61300;
// 61304: using guessed type int dword_61304;
// 61308: using guessed type int dword_61308;
// 6130C: using guessed type int dword_6130C;
// 6142C: using guessed type char byte_6142C;
// 615CC: using guessed type struct timeval stru_615CC;
// 615D4: using guessed type char byte_615D4;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63410: using guessed type int dword_63410;
// 636A8: using guessed type int dword_636A8;
// 6373C: using guessed type char byte_6373C;
// 63740: using guessed type int dword_63740;
// 639D8: using guessed type int dword_639D8;
// 639E4: using guessed type int dword_639E4;
// 63A70: using guessed type int dword_63A70;
// 63B80: using guessed type int dword_63B80;
// 63B88: using guessed type double dbl_63B88;
// 63B90: using guessed type char byte_63B90;
// 63B98: using guessed type int dword_63B98;
// 63B9C: using guessed type int dword_63B9C;
// 63C10: using guessed type double dbl_63C10;
// 63CC0: using guessed type int dword_63CC0;
// 63D60: using guessed type int dword_63D60;
// 63E14: using guessed type char byte_63E14;
// 63E1C: using guessed type int dword_63E1C;
// 63E20: using guessed type int dword_63E20;
// 63E44: using guessed type int dword_63E44;
// 63EE0: using guessed type char byte_63EE0;
// 640BC: using guessed type int dword_640BC;
// 6410C: using guessed type int dword_6410C;
// 64219: using guessed type char byte_64219;
// 64220: using guessed type int dword_64220;
// 64230: using guessed type int dword_64230;

//----- (000243F8) --------------------------------------------------------
int __fastcall sub_243F8(int a1)
{
  int v2; // r4
  int v4; // r0

  v2 = *(_DWORD *)(a1 + 356);
  if ( v2 )
  {
    if ( sub_2282C(*(_DWORD *)(a1 + 356), 0) )
    {
      v4 = v2;
      v2 = 0;
      sub_154EC(v4);
      sub_17ED8();
    }
    else
    {
      sub_160B4(a1, v2);
    }
    *(_DWORD *)(a1 + 356) = 0;
  }
  return v2;
}

//----- (00024450) --------------------------------------------------------
int __fastcall sub_24450(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  int v3; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B550("get_queued", 8820);
  v3 = sub_243F8((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    sub_B700("get_queued", 8822);
  off_60178();
  return v3;
}
// 60178: using guessed type int (*off_60178)();

//----- (000244C4) --------------------------------------------------------
int __fastcall sub_244C4(int a1, int a2)
{
  _DWORD *v4; // r5
  time_t v5; // r8
  int v6; // r4
  time_t v7; // r0
  int v8; // r3
  int v9; // r8
  double v10; // d17
  double v11; // d16
  int result; // r0
  int v13; // r3
  int v14; // r3
  int v15; // r3
  char v16[2052]; // [sp+0h] [bp-804h] BYREF

  v4 = *(_DWORD **)(a1 + 36);
  sub_F808(a1);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v16, "Popping work from get queue to get work");
    sub_38438(7, v16, 0);
  }
  v5 = time(0);
  do
  {
    while ( 1 )
    {
      v6 = sub_17A14(1);
      if ( !sub_2282C(v6, 0) )
        break;
      sub_154EC(v6);
      sub_17ED8();
    }
  }
  while ( !v6 );
  v7 = time(0);
  v8 = (unsigned __int8)byte_630C1;
  v9 = v7 - v5;
  if ( v9 > 0 )
  {
    if ( byte_630C1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
      {
        snprintf(v16, 0x800u, "Get work blocked for %d seconds", v9);
        sub_38438(7, v16, 0);
        v8 = (unsigned __int8)byte_630C1;
      }
      else
      {
        v8 = 1;
      }
    }
    v4[58] += v9;
  }
  if ( v8 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v16, 0x800u, "Got work from get queue to get work for thread %d", a2);
    sub_38438(7, v16, 0);
  }
  *(_DWORD *)(v6 + 256) = a2;
  if ( byte_615C9 )
  {
    v14 = v4[95] + v4[96];
    v4[95] = v14;
    if ( v14 > 0 )
    {
      if ( v14 > 15 )
      {
        v15 = v4[94] + 1;
        v4[96] = -1;
        if ( v15 > 15 )
          v15 = 0;
        v4[94] = v15;
        memcpy((void *)v6, (char *)&unk_615D8 + 160 * v15, 0xA0u);
        goto LABEL_17;
      }
    }
    else
    {
      v4[96] = 1;
    }
    memcpy((void *)v6, (char *)&unk_61FD8 + 160 * v14, 0xA0u);
  }
LABEL_17:
  sub_F7D4(a1);
  v10 = *(double *)(v6 + 376);
  *(_BYTE *)(v6 + 272) = 1;
  v11 = *(double *)(v4[1] + 104);
  result = v6;
  if ( v11 > v10 )
    v11 = v10;
  *(double *)(v6 + 224) = v11;
  v13 = v4[1];
  if ( v11 < *(double *)(v13 + 120) )
    v11 = *(double *)(v13 + 120);
  *(double *)(v6 + 224) = v11;
  return result;
}
// 60964: using guessed type int dword_60964;
// 615C9: using guessed type char byte_615C9;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00024A48) --------------------------------------------------------
int __fastcall sub_24A48(int a1, pthread_rwlock_t *a2, int a3)
{
  int v4; // r4

  v4 = sub_244C4(a1, a3);
  sub_19930(a2, v4);
  return v4;
}

//----- (00024A70) --------------------------------------------------------
void __fastcall sub_24A70(int a1)
{
  int v2; // r1
  int v3; // r9
  int v4; // r2
  bool v5; // zf
  int v6; // r8
  int v7; // r11
  int v8; // r3
  int v9; // r12
  int v10; // r0
  int v11; // r5
  double v12; // d9
  double v13; // d8
  int v14; // r3
  _DWORD *v15; // r7
  __int64 v16; // kr00_8
  __suseconds_t tv_usec; // r4
  __time_t tv_sec; // r12
  __time_t v19; // r3
  int v20; // r2
  int v21; // r1
  int v22; // r3
  int v23; // r4
  double v24; // r0
  double v25; // d16
  double v26; // d8
  int v27; // r1
  unsigned int v28; // r0
  int v29; // r2
  __time_t v30; // [sp+Ch] [bp-880h]
  __time_t v31; // [sp+Ch] [bp-880h]
  unsigned int v32; // [sp+10h] [bp-87Ch]
  int v33; // [sp+14h] [bp-878h]
  int v34; // [sp+14h] [bp-878h]
  int v35; // [sp+14h] [bp-878h]
  int v36; // [sp+14h] [bp-878h]
  __int64 v37; // [sp+28h] [bp-864h]
  int v38; // [sp+3Ch] [bp-850h]
  _DWORD *v39; // [sp+40h] [bp-84Ch]
  _DWORD *v40; // [sp+44h] [bp-848h]
  struct timeval *v41; // [sp+48h] [bp-844h]
  int *v42; // [sp+4Ch] [bp-840h]
  int v43; // [sp+50h] [bp-83Ch]
  unsigned int v44; // [sp+54h] [bp-838h]
  int v45; // [sp+58h] [bp-834h]
  int remaining; // [sp+60h] [bp-82Ch]
  unsigned int v47; // [sp+64h] [bp-828h]
  struct timeval v48; // [sp+68h] [bp-824h] BYREF
  struct timeval v49; // [sp+70h] [bp-81Ch] BYREF
  struct timeval v50; // [sp+78h] [bp-814h] BYREF
  struct timeval v51; // [sp+80h] [bp-80Ch] BYREF
  struct timespec s[256]; // [sp+88h] [bp-804h] BYREF

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 36);
  v45 = *(_DWORD *)a1;
  v38 = *(_DWORD *)(v3 + 4);
  v4 = dword_6006C / 5;
  if ( (int)((unsigned __int64)(1717986919LL * dword_6006C) >> 32) >> 1 == dword_6006C >> 31 )
    v4 = 1;
  v5 = v2 == 0;
  if ( v2 )
    v2 = *(unsigned __int8 *)(a1 + 8);
  v43 = v4;
  if ( v5 )
    remaining = 1;
  else
    remaining = v2;
  v44 = (*(int (__fastcall **)(int, int))(v38 + 48))(a1, v2);
  sub_2B13C(&v48);
  sub_2B13C(&v51);
  if ( !*(_BYTE *)(v3 + 364) )
  {
    v6 = *(unsigned __int8 *)(v3 + 364);
    v37 = 0;
    v7 = v6;
    v8 = 1000000 * v43 + 1023;
    if ( 1000000 * v43 >= 0 )
      v8 = 1000000 * v43;
    v47 = v8 >> 10;
    while ( 1 )
    {
      v10 = sub_244C4(a1, v45);
      *(_BYTE *)(a1 + 62) = 0;
      *(_BYTE *)(v3 + 172) = 1;
      v11 = v10;
      sub_2B13C(&v50);
      *(_DWORD *)(v11 + 248) = 0;
      *(_QWORD *)(v3 + 160) = 0;
      if ( !(*(int (__fastcall **)(int, int))(v38 + 56))(a1, v11) )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          snprintf((char *)s, 0x800u, "work prepare failed, exiting mining thread %d", v45);
          sub_38438(3, (const char *)s, 0);
        }
        goto LABEL_81;
      }
      v12 = *(double *)(v11 + 376);
      v13 = *(double *)(v38 + 104);
      if ( v13 > v12 )
        v13 = *(double *)(v11 + 376);
      *(double *)(v11 + 224) = v13;
      v14 = (unsigned __int8)byte_63DF9;
      if ( v13 < *(double *)(v38 + 120) )
        v13 = *(double *)(v38 + 120);
      *(double *)(v11 + 224) = v13;
      if ( !v14 )
      {
        v42 = (int *)(v3 + 296);
        v39 = (_DWORD *)(v3 + 304);
        v40 = (_DWORD *)(v3 + 312);
        v41 = (struct timeval *)(v11 + 424);
        goto LABEL_29;
      }
      LODWORD(v24) = sub_493DC(*(__int64 *)&dword_636A8);
      if ( v24 / dbl_5F898 * 60.0 <= 30.0 )
        break;
      v25 = *(double *)(v38 + 112);
      if ( v25 >= *(double *)(v38 + 104) || v12 <= v25 )
        goto LABEL_74;
      v5 = byte_630C1 == 0;
      v26 = v25 + 1.0;
      *(double *)(v38 + 112) = v25 + 1.0;
      if ( !v5 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf((char *)s, 0x800u, "Driver %s working diff changed to %.0f", *(const char **)(v38 + 4), v25 + 1.0);
        sub_38438(7, (const char *)s, 0);
        v26 = *(double *)(v38 + 112);
      }
      if ( *(double *)(v11 + 376) < v26 )
        v26 = *(double *)(v11 + 376);
      *(double *)(v11 + 224) = v26;
LABEL_72:
      sub_15D7C(v11 + 441);
      v42 = (int *)(v3 + 296);
      v39 = (_DWORD *)(v3 + 304);
      v40 = (_DWORD *)(v3 + 312);
      v41 = (struct timeval *)(v11 + 424);
      while ( 1 )
      {
LABEL_29:
        sub_2B13C(&v49);
        sub_2AD38(&v49, &v48.tv_sec);
        sub_2AD6C(&v48, v42);
        if ( sub_2ADB8(&v48, v39) )
          sub_2AE20(v39, &v48);
        if ( sub_2ADEC(&v48, v40) )
          sub_2AE20(v40, &v48);
        ++*(_DWORD *)(v3 + 292);
        v15 = *(_DWORD **)(v11 + 260);
        sub_2AD6C(&v48, v15 + 95);
        if ( sub_2ADB8(&v48, v15 + 97) )
          sub_2AE20(v15 + 97, &v48);
        if ( sub_2ADEC(&v48, v15 + 99) )
          sub_2AE20(v15 + 99, &v48);
        ++v15[94];
        sub_2B13C(v41);
        pthread_setcancelstate(1, 0);
        sub_F7D4(a1);
        v16 = ((__int64 (__fastcall *)(int, int, unsigned int, _DWORD))*(_DWORD *)(v38 + 64))(
                a1,
                v11,
                v44 + *(_DWORD *)(v11 + 248),
                0);
        sub_F808(a1);
        pthread_setcancelstate(0, 0);
        pthread_testcancel();
        sub_2B13C(&v48);
        if ( v16 == -1 )
          break;
        tv_usec = v48.tv_usec;
        tv_sec = v50.tv_sec;
        v37 += v16;
        if ( *(_QWORD *)(v3 + 160) < v16 )
          *(_QWORD *)(v3 + 160) = v16;
        v19 = v48.tv_sec;
        v20 = tv_usec - v49.tv_usec + (tv_usec - v49.tv_usec < 0 ? 0xF4000 : 0);
        v9 = v48.tv_sec - tv_sec;
        if ( tv_usec - v49.tv_usec < 0 )
          v20 += 576;
        v21 = v48.tv_sec - v49.tv_sec;
        v6 += v20;
        if ( tv_usec - v49.tv_usec < 0 )
          --v21;
        v7 += v21;
        if ( v6 > 1000000 )
        {
          ++v7;
          v6 -= 1000000;
        }
        if ( tv_usec - v50.tv_usec < 0 )
          --v9;
        if ( v43 > v7 )
        {
          if ( v44 == -1 )
            goto LABEL_19;
          v27 = v6 + 1024;
          v30 = v48.tv_sec;
          if ( v6 + 1024 < 0 )
            v27 = v6 + 2047;
          v35 = v9;
          v32 = (sub_48F88(1000000, v27 >> 10) + 16) * v43;
          v19 = v30;
          v9 = v35;
          if ( v44 <= 0xFFFFFC00 / v32 )
            v44 = (v44 * v32) >> 10;
          else
            v44 = -1;
        }
        else if ( v43 < v7 )
        {
          v19 = v48.tv_sec;
          v44 = v43 * v44 / v7;
        }
        else if ( v6 > (int)&loc_186A0 )
        {
          v31 = v48.tv_sec;
          v36 = v9;
          v28 = sub_48F88(1000000 * v43 + v6, v47);
          v19 = v31;
          v9 = v36;
          v44 = (v44 << 10) / v28;
        }
        v22 = v19 - v51.tv_sec;
        v23 = tv_usec - v51.tv_usec;
        if ( v23 < 0 )
        {
          --v22;
          v23 += 1000000;
        }
        if ( v37 && (v22 > 0 || v23 > (int)&loc_30D40) || dword_6006C <= v22 )
        {
          v33 = v9;
          sub_1C834(v45, v37);
          sub_2AE20(&v51, &v48);
          v9 = v33;
          v37 = 0;
        }
        if ( *(_BYTE *)(a1 + 62) )
        {
          if ( !remaining )
          {
            v29 = *(_DWORD *)(a1 + 4);
            s[0].tv_sec = 0;
            s[0].tv_nsec = 250000000 * v29;
            nanosleep(s, 0);
          }
          goto LABEL_21;
        }
        if ( *(_BYTE *)(a1 + 60) || (v7 = *(_DWORD *)(v3 + 32)) != 0 )
        {
          v7 = 0;
          v34 = v9;
          v6 = 0;
          sub_118C4(a1, v45, v38);
          v9 = v34;
        }
        else
        {
          v6 = 0;
        }
LABEL_19:
        if ( v9 > dword_60090 || *(_QWORD *)(v3 + 160) > 0xFFFFFFFD || sub_2282C(v11, 0) )
          goto LABEL_21;
      }
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf((char *)s, 0x800u, "%s %d failure, disabling!", *(const char **)(v38 + 8), *(_DWORD *)(v3 + 8));
        sub_38438(3, (const char *)s, 0);
      }
      *(_DWORD *)(v3 + 32) = 1;
      sub_2ED00((_DWORD *)v3, 1);
      *(_BYTE *)(v3 + 364) = 1;
LABEL_21:
      sub_152B8((void **)v11);
      if ( *(_BYTE *)(v3 + 364) )
        goto LABEL_81;
    }
    v25 = *(double *)(v38 + 112);
LABEL_74:
    if ( v12 < v25 )
      *(double *)(v38 + 112) = v12;
    goto LABEL_72;
  }
LABEL_81:
  *(_DWORD *)(v3 + 32) = 1;
}
// 24F74: variable 'v24' is possibly undefined
// 5F898: using guessed type double dbl_5F898;
// 6006C: using guessed type int dword_6006C;
// 60090: using guessed type int dword_60090;
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 636A8: using guessed type int dword_636A8;
// 63DF9: using guessed type char byte_63DF9;

//----- (000252E4) --------------------------------------------------------
void __fastcall sub_252E4(int a1)
{
  _DWORD *v2; // r5
  int v3; // r6
  double v4; // d16
  double v5; // d16
  double v6; // d17
  double v7; // d16
  int v8; // r2
  double v9; // d18
  double v10; // d16
  double v11; // d17
  double v12; // d16
  pthread_t v13; // [sp+Ch] [bp-808h] BYREF
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( !*(_DWORD *)(a1 + 76) )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      strcpy(s, "Get A Error Data To Push!DROP!\r\n");
      sub_38438(4, s, 0);
    }
    return;
  }
  v2 = *(_DWORD **)(a1 + 260);
  sub_2B13C((struct timeval *)(a1 + 432));
  if ( byte_615C9 )
  {
    v3 = *(_DWORD *)(sub_1C36C(*(_DWORD *)(a1 + 256)) + 36);
    if ( pthread_mutex_lock(&mutex) )
      sub_B4E4("submit_work_async", 8238);
    ++*(_DWORD *)(v3 + 36);
    ++*((_QWORD *)v2 + 1);
    v4 = *(double *)(v3 + 200) + *(double *)(a1 + 376);
    ++qword_639C8;
    *(double *)(v3 + 200) = v4;
    v5 = *(double *)(a1 + 376);
    v6 = *((double *)v2 + 9) + v5;
    v7 = v5 + dbl_63B88;
    *((double *)v2 + 9) = v6;
    dbl_63B88 = v7;
    if ( pthread_mutex_unlock(&mutex) )
      sub_B694("submit_work_async", 8245);
    off_60178();
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(
        s,
        0x800u,
        "Accepted %s %d benchmark share nonce %08x",
        *(const char **)(*(_DWORD *)(v3 + 4) + 8),
        *(_DWORD *)(v3 + 8),
        *(_DWORD *)(a1 + 76));
      sub_38438(7, s, 0);
    }
    return;
  }
  if ( !sub_2282C(a1, 1) )
  {
    v8 = (unsigned __int8)byte_630C1;
    goto LABEL_17;
  }
  if ( byte_600AD )
  {
    v8 = (unsigned __int8)byte_630C1;
    if ( !byte_630C1 )
      goto LABEL_37;
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      goto LABEL_36;
    snprintf(s, 0x800u, "Pool %d stale share detected, submitting as user requested", *v2);
    goto LABEL_48;
  }
  if ( *((_BYTE *)v2 + 104) )
  {
    v8 = (unsigned __int8)byte_630C1;
    if ( !byte_630C1 )
    {
LABEL_37:
      *(_BYTE *)(a1 + 281) = 1;
LABEL_17:
      if ( *(_BYTE *)(a1 + 284) )
      {
        if ( v8 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "Pushing pool %d work to stratum queue", *v2);
          sub_38438(7, s, 0);
        }
        if ( !sub_2AB68(v2[174], a1) )
        {
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            strcpy(s, "Discarding work from removed pool");
            sub_38438(7, s, 0);
          }
          sub_152B8((void **)a1);
        }
      }
      else
      {
        if ( v8 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          strcpy(s, "Pushing submit work to work thread");
          sub_38438(7, s, 0);
        }
        if ( pthread_create(&v13, 0, sub_F7C0, (void *)a1) )
        {
          strcpy(s, "Failed to create submit_work_thread");
          sub_38438(3, s, 1);
          sub_16724(1);
        }
      }
      return;
    }
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
    {
LABEL_36:
      v8 = 1;
      goto LABEL_37;
    }
    snprintf(s, 0x800u, "Pool %d stale share detected, submitting as pool requested", *v2);
LABEL_48:
    sub_38438(7, s, 0);
    v8 = (unsigned __int8)byte_630C1;
    goto LABEL_37;
  }
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "Pool %d stale share detected, discarding", *v2);
    sub_38438(7, s, 0);
  }
  sub_1D408("discard", (_DWORD *)a1);
  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("submit_work_async", 8263);
  v9 = *((double *)v2 + 11);
  ++v2[30];
  v10 = *(double *)(a1 + 376);
  v11 = v9 + v10;
  ++*(_QWORD *)&dword_64220;
  v12 = v10 + dbl_639D0;
  *((double *)v2 + 11) = v11;
  dbl_639D0 = v12;
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("submit_work_async", 8268);
  off_60178();
  sub_152B8((void **)a1);
}
// 600AD: using guessed type char byte_600AD;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 615C9: using guessed type char byte_615C9;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 639C8: using guessed type __int64 qword_639C8;
// 639D0: using guessed type double dbl_639D0;
// 63B88: using guessed type double dbl_63B88;
// 64220: using guessed type int dword_64220;

//----- (00025A60) --------------------------------------------------------
int __fastcall sub_25A60(int a1, int a2, int a3)
{
  _DWORD *v3; // r0

  *(_DWORD *)(a2 + 76) = a3;
  v3 = sub_19E18(a2, 0);
  sub_252E4((int)v3);
  return 1;
}

//----- (00025A80) --------------------------------------------------------
void __fastcall sub_25A80(int a1)
{
  _DWORD *v1; // r0

  v1 = sub_19E18(a1, 0);
  sub_252E4((int)v1);
}

//----- (00025A94) --------------------------------------------------------
int __fastcall sub_25A94(int a1, int a2)
{
  int result; // r0
  _DWORD *v5; // r0
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  sub_1A0F8(a1, a2);
  if ( sub_2A898((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160)) )
  {
    v5 = sub_19E18(a2, 0);
    sub_252E4((int)v5);
    return 1;
  }
  else if ( byte_630C1 )
  {
    if ( byte_632F0 || (result = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6 )
    {
      snprintf(
        s,
        0x800u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      sub_38438(7, s, 0);
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return result;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00025B80) --------------------------------------------------------
int __fastcall sub_25B80(int a1, char *a2, unsigned int a3)
{
  if ( sub_F3B0(a1, a3) && sub_15FDC((int)a2, a3) )
  {
    sub_25A94(a1, (int)a2);
    if ( dword_612AC && byte_629D8 )
    {
      sub_1155C(a2, a3);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_189B4(a1);
    return 0;
  }
}
// 612AC: using guessed type int dword_612AC;
// 629D8: using guessed type char byte_629D8;

//----- (00025C14) --------------------------------------------------------
char *__fastcall sub_25C14(const char *a1)
{
  char *v2; // r4
  char v4[2052]; // [sp+0h] [bp-804h] BYREF

  echo();
  v2 = (char *)malloc(0xFFu);
  if ( !v2 )
  {
    strcpy(v4, "Failed to malloc input");
    sub_38438(3, v4, 1);
    sub_16724(1);
  }
  leaveok((WINDOW *)dword_639D8, 0);
  snprintf(v4, 0x800u, "%s:\n", a1);
  sub_1952C(v4);
  wgetnstr((WINDOW *)dword_639D8, v2, 255);
  if ( !*v2 )
    strcpy(v2, "-1");
  leaveok((WINDOW *)dword_639D8, 1);
  noecho();
  return v2;
}
// 639D8: using guessed type int dword_639D8;

//----- (00025D00) --------------------------------------------------------
int __fastcall sub_25D00(const char *a1)
{
  char *v1; // r4
  int v2; // r5

  v1 = sub_25C14(a1);
  v2 = strtol(v1, 0, 10);
  free(v1);
  return v2;
}

//----- (00025D2C) --------------------------------------------------------
void sub_25D2C()
{
  const char *v0; // r3
  char *v1; // r11
  char *v2; // r12
  char *v3; // lr
  const char *v4; // r11
  char *v5; // r12
  const char *v6; // lr
  const char *v7; // r12
  const char *v8; // r2
  const char *v9; // r2
  int v10; // r3
  char *v11; // r3
  int v12; // r3
  int v13; // r3
  const char *v14; // r3
  int v15; // r3
  char *v16; // r3
  int v17; // r0
  int v18; // r1
  int v19; // r12
  int v20; // r3
  bool v21; // zf
  unsigned int v22; // r0
  const char *v23; // [sp+0h] [bp-834h]
  const char *v24; // [sp+4h] [bp-830h]
  const char *v25; // [sp+8h] [bp-82Ch]
  const char *v26; // [sp+10h] [bp-824h]
  char s1; // [sp+2Fh] [bp-805h] BYREF
  char s[2052]; // [sp+30h] [bp-804h] BYREF

  byte_64068 = 1;
  immedok((WINDOW *)dword_639D8, 1);
  sub_193CC();
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            strcpy(s, "[N]ormal [C]lear [S]ilent mode (disable all output)\n");
            sub_1952C(s);
            v0 = "off";
            if ( byte_63DF8 )
              v1 = (char *)"on";
            else
              v1 = "off";
            v23 = v1;
            if ( byte_64218 )
              v2 = (char *)"on";
            else
              v2 = "off";
            v24 = v2;
            if ( byte_630C0 )
              v3 = (char *)"on";
            else
              v3 = "off";
            v25 = v3;
            if ( byte_63928 )
              v4 = "on";
            else
              v4 = "off";
            if ( byte_63DFA )
              v5 = (char *)"on";
            else
              v5 = "off";
            v26 = v5;
            if ( byte_63EE0 )
              v6 = "on";
            else
              v6 = "off";
            if ( byte_630C1 )
              v0 = "on";
            if ( byte_6142D )
              v7 = "enabled";
            else
              v7 = "disabled";
            if ( byte_615D4 )
              v8 = "enabled";
            else
              v8 = "disabled";
            snprintf(
              s,
              0x800u,
              "[D]ebug:%s\n"
              "[P]er-device:%s\n"
              "[Q]uiet:%s\n"
              "[V]erbose:%s\n"
              "[R]PC debug:%s\n"
              "[W]orkTime details:%s\n"
              "co[M]pact: %s\n"
              "[T]oggle status switching:%s\n"
              "w[I]descreen:%s\n"
              "[Z]ero statistics\n"
              "[L]og interval:%d\n",
              v0,
              v23,
              v24,
              v25,
              v4,
              v26,
              v6,
              v7,
              v8,
              dword_6006C);
            sub_1952C(s);
            strcpy(s, "Select an option or any other key to return\n");
            sub_1952C(s);
            sub_19350();
            s1 = wgetch((WINDOW *)stdscr);
            if ( !strncasecmp(&s1, "q", 1u) )
            {
              v9 = "Quiet mode %s\n";
              v10 = (unsigned __int8)byte_64218 ^ 1;
              byte_64218 ^= 1u;
              if ( v10 )
                v11 = "enabled";
              else
                v11 = "disabled";
              goto LABEL_64;
            }
            if ( !strncasecmp(&s1, "v", 1u) )
            {
              v9 = "Verbose mode %s\n";
              v12 = (unsigned __int8)byte_630C0 ^ 1;
              byte_630C0 ^= 1u;
              if ( v12 )
              {
                byte_64218 = 0;
                v11 = "enabled";
              }
              else
              {
                v11 = "disabled";
              }
              goto LABEL_64;
            }
            if ( strncasecmp(&s1, "n", 1u) )
              break;
            byte_630C1 = 0;
            byte_630C0 = 0;
            byte_64218 = 0;
            byte_63928 = 0;
            strcpy(s, "Output mode reset to normal\n");
            byte_63EE0 = 0;
            byte_63DF8 = 0;
            sub_1952C(s);
            v17 = sub_19140();
            if ( v17 )
              goto LABEL_47;
          }
          if ( strncasecmp(&s1, "d", 1u) )
            break;
          v13 = (unsigned __int8)byte_630C1 ^ 1;
          byte_630C1 ^= 1u;
          byte_630C0 = v13;
          if ( v13 )
          {
            byte_64218 = 0;
            v14 = "enabled";
          }
          else
          {
            v14 = "disabled";
          }
          snprintf(s, 0x800u, "Debug mode %s\n", v14);
          sub_1952C(s);
        }
        if ( strncasecmp(&s1, "m", 1u) )
          break;
        v15 = (unsigned __int8)byte_63EE0 ^ 1;
        byte_63EE0 ^= 1u;
        if ( v15 )
          v16 = "enabled";
        else
          v16 = "disabled";
        snprintf(s, 0x800u, "Compact mode %s\n", v16);
        sub_1952C(s);
        v17 = sub_19140();
        if ( v17 )
LABEL_47:
          sub_192D4(v17, v18);
      }
      if ( !strncasecmp(&s1, "p", 1u) )
      {
        v9 = "Per-device stats %s\n";
        v19 = (unsigned __int8)byte_63DF8 ^ 1;
        byte_63DF8 ^= 1u;
        byte_630C0 = v19;
        if ( v19 )
          v11 = "enabled";
        else
          v11 = "disabled";
        goto LABEL_64;
      }
      if ( !strncasecmp(&s1, "r", 1u) )
      {
        v20 = (unsigned __int8)byte_63928 ^ 1;
        byte_63928 ^= 1u;
        v9 = "RPC protocol debugging %s\n";
        if ( v20 )
        {
          byte_64218 = 0;
          v11 = "enabled";
        }
        else
        {
          v11 = "disabled";
        }
        goto LABEL_64;
      }
      if ( !strncasecmp(&s1, "c", 1u) )
        goto LABEL_75;
      if ( strncasecmp(&s1, "l", 1u) )
        break;
      v22 = sub_25D00("Interval in seconds");
      if ( v22 <= 0x270F )
      {
        dword_6006C = v22;
        snprintf(s, 0x800u, "Log interval set to %d seconds\n", v22);
      }
      else
      {
        strcpy(s, "Invalid selection\n");
      }
      sub_1952C(s);
    }
    if ( !strncasecmp(&s1, "s", 1u) )
      break;
    if ( !strncasecmp(&s1, "w", 1u) )
    {
      v11 = "enabled";
      v21 = byte_63DFA == 1;
      byte_63DFA ^= 1u;
      v9 = "WorkTime details %s\n";
      if ( v21 )
        v11 = "disabled";
LABEL_64:
      snprintf(s, 0x800u, v9, v11);
      sub_1952C(s);
    }
    else if ( !strncasecmp(&s1, "t", 1u) )
    {
      byte_6142D ^= 1u;
    }
    else if ( !strncasecmp(&s1, "i", 1u) )
    {
      byte_615D4 ^= 1u;
    }
    else
    {
      if ( strncasecmp(&s1, "z", 1u) )
      {
LABEL_75:
        sub_193CC();
        goto LABEL_76;
      }
      sub_1ABE0();
    }
  }
  byte_640B8 = 1;
LABEL_76:
  immedok((WINDOW *)dword_639D8, 0);
  byte_64068 = 0;
}
// 26058: variable 'v18' is possibly undefined
// 6006C: using guessed type int dword_6006C;
// 60E70: using guessed type int stdscr;
// 6142D: using guessed type char byte_6142D;
// 615D4: using guessed type char byte_615D4;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 63928: using guessed type char byte_63928;
// 639D8: using guessed type int dword_639D8;
// 63DF8: using guessed type char byte_63DF8;
// 63DFA: using guessed type char byte_63DFA;
// 63EE0: using guessed type char byte_63EE0;
// 64068: using guessed type char byte_64068;
// 640B8: using guessed type char byte_640B8;
// 64218: using guessed type char byte_64218;

//----- (000263D4) --------------------------------------------------------
void sub_263D4()
{
  int v0; // r3
  unsigned int v1; // r0
  int i; // r2
  char *v3; // r0
  char *v4; // r4
  FILE *v5; // r0
  FILE *v6; // r4
  int v7; // r0
  unsigned int v8; // r0
  char s1; // [sp+Fh] [bp-2891h] BYREF
  struct stat stat_buf; // [sp+10h] [bp-2890h] BYREF
  char v11[2036]; // [sp+6Ch] [bp-2834h] BYREF
  char v12[4052]; // [sp+86Ch] [bp-2034h] BYREF
  char v13[4116]; // [sp+186Ch] [bp-1034h] BYREF

  byte_64068 = 1;
  immedok((WINDOW *)dword_639D8, 1);
  sub_193CC();
  v0 = dword_60074;
  v1 = dword_60090;
  for ( i = dword_60094; ; i = dword_60094 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          snprintf(
            v13,
            0x800u,
            "[Q]ueue: %d\n[S]cantime: %d\n[E]xpiry: %d\n[W]rite config file\n[C]gminer restart\n",
            v0,
            v1,
            i);
          sub_1952C(v13);
          strcpy(v13, "Select an option or any other key to return\n");
          sub_1952C(v13);
          sub_19350();
          s1 = wgetch((WINDOW *)stdscr);
          if ( strncasecmp(&s1, "q", 1u) )
            break;
          v7 = sub_25D00("Extra work items to queue");
          v0 = v7;
          if ( (unsigned int)v7 > 0x270F )
            goto LABEL_18;
          dword_60074 = v7;
          if ( v7 >= dword_60070 )
          {
            v1 = dword_60090;
            i = dword_60094;
          }
          else
          {
            dword_60070 = v7;
            i = dword_60094;
            v1 = dword_60090;
          }
        }
        if ( strncasecmp(&s1, "s", 1u) )
          break;
        v1 = sub_25D00("Set scantime in seconds");
        if ( v1 > 0x270F )
          goto LABEL_18;
        dword_60090 = v1;
        v0 = dword_60074;
        i = dword_60094;
      }
      if ( strncasecmp(&s1, "e", 1u) )
        break;
      v8 = sub_25D00("Set expiry time in seconds");
      i = v8;
      if ( v8 > 0x270F )
      {
LABEL_18:
        strcpy(v13, "Invalid selection\n");
        sub_1952C(v13);
        v0 = dword_60074;
        v1 = dword_60090;
        i = dword_60094;
      }
      else
      {
        dword_60094 = v8;
        v0 = dword_60074;
        v1 = dword_60090;
      }
    }
    if ( strncasecmp(&s1, "w", 1u) )
      break;
    sub_15C88(v12);
    snprintf(v13, 0x1032u, "Config filename to write (Enter for default) [%s]", v12);
    v3 = sub_25C14(v13);
    v4 = v3;
    if ( *v3 == 45 && v3[1] == 49 && !v3[2] )
    {
      free(v3);
LABEL_10:
      v5 = fopen(v12, "w");
      v6 = v5;
      if ( v5 )
      {
        sub_1569C(v5);
        fclose(v6);
      }
      else
      {
        strcpy(v11, "Cannot open or create file\n");
        sub_1952C(v11);
      }
      goto LABEL_12;
    }
    strcpy(v12, v3);
    free(v4);
    if ( _xstat(3, v12, &stat_buf) )
      goto LABEL_10;
    strcpy(v11, "File exists, overwrite?\n");
    sub_1952C(v11);
    s1 = wgetch((WINDOW *)stdscr);
    if ( !strncasecmp(&s1, "y", 1u) )
      goto LABEL_10;
LABEL_12:
    v0 = dword_60074;
    v1 = dword_60090;
  }
  if ( !strncasecmp(&s1, "c", 1u)
    && (strcpy(v13, "Are you sure?\n"), sub_1952C(v13), s1 = wgetch((WINDOW *)stdscr), !strncasecmp(&s1, "y", 1u)) )
  {
    sub_1C028();
  }
  else
  {
    sub_193CC();
  }
  immedok((WINDOW *)dword_639D8, 0);
  byte_64068 = 0;
}
// 60070: using guessed type int dword_60070;
// 60074: using guessed type int dword_60074;
// 60090: using guessed type int dword_60090;
// 60094: using guessed type int dword_60094;
// 60E70: using guessed type int stdscr;
// 639D8: using guessed type int dword_639D8;
// 64068: using guessed type char byte_64068;

//----- (000267F4) --------------------------------------------------------
int __fastcall sub_267F4(int a1, int a2, char *a3, const char *a4, const char *a5)
{
  char *v8; // r0
  size_t v9; // r8
  size_t v10; // r8
  char *v11; // r0
  int v12; // r1
  int *v13; // r2
  char v15[2048]; // [sp+8h] [bp-800h] BYREF

  v8 = sub_2B5C8(a3, a1);
  *(_DWORD *)(a1 + 172) = a4;
  *(_DWORD *)(a1 + 176) = a5;
  *(_DWORD *)(a1 + 164) = v8;
  v9 = strlen(a4);
  v10 = v9 + strlen(a5) + 2;
  v11 = (char *)malloc(v10);
  *(_DWORD *)(a1 + 168) = v11;
  if ( !v11 )
  {
    strcpy(v15, "Failed to malloc userpass");
    sub_38438(3, v15, 1);
    sub_16724(1);
  }
  snprintf(v11, v10, "%s:%s", a4, a5);
  v12 = *(_DWORD *)(a1 + 100);
  v13 = (int *)(a2 ^ 1);
  *(_BYTE *)(a1 + 107) = a2 ^ 1;
  if ( v12 != 1 )
  {
    *(_DWORD *)(a1 + 100) = 1;
    v13 = &dword_63B84;
  }
  *(_BYTE *)(a1 + 284) = 1;
  *(_BYTE *)(a1 + 97) = 1;
  if ( v12 != 1 )
    ++*v13;
  pthread_create((pthread_t *)(a1 + 280), 0, (void *(*)(void *))start_routine, (void *)a1);
  if ( a2 )
    return 1;
  pthread_join(*(_DWORD *)(a1 + 280), 0);
  return (unsigned __int8)byte_615C8;
}
// 615C8: using guessed type char byte_615C8;
// 63B84: using guessed type int dword_63B84;

//----- (00026910) --------------------------------------------------------
void sub_26910()
{
  JUMPOUT(0x26858);
}
// 2691C: control flows out of bounds to 26858

//----- (00026934) --------------------------------------------------------
int __fastcall sub_26934(int a1)
{
  char *v2; // r0
  char *v3; // r4
  char *v4; // r0
  char *v5; // r8
  char *v6; // r0
  void *v7; // r7
  char *v8; // r10
  char *v9; // r0
  char *v10; // r9
  int v11; // r6
  char v13[2048]; // [sp+8h] [bp-800h] BYREF

  immedok((WINDOW *)dword_639D8, 1);
  strcpy(v13, "Input server details.\n");
  sub_1952C(v13);
  v2 = sub_25C14("URL");
  v3 = v2;
  if ( *v2 == 45 && v2[1] == 49 && (v5 = (char *)(unsigned __int8)v2[2], !v2[2])
    || (v4 = sub_25C14("Username"), v5 = v4, *v4 == 45) && v4[1] == 49 && !v4[2] )
  {
    immedok((WINDOW *)dword_639D8, 0);
    v7 = 0;
LABEL_19:
    v11 = 0;
    free(v3);
    free(v5);
    free(v7);
    return v11;
  }
  v6 = sub_25C14("Password");
  v7 = v6;
  if ( *v6 == 45 && v6[1] == 49 && !v6[2] )
  {
    free(v6);
    v7 = calloc(1u, 1u);
  }
  v8 = sub_1746C();
  if ( !sub_150B4((int)v8, v3) && strncmp(v3, "http://", 7u) && strncmp(v3, "https://", 8u) )
  {
    v9 = (char *)malloc(0x100u);
    v10 = v9;
    if ( !v9 )
    {
      strcpy(v13, "Failed to malloc httpinput");
      sub_38438(3, v13, 1);
      sub_16724(1);
    }
    strcpy(v9, "http://");
    strncat(v9, v3, 0xF8u);
    free(v3);
    v3 = v10;
  }
  v11 = sub_267F4((int)v8, a1, v3, v5, (const char *)v7);
  immedok((WINDOW *)dword_639D8, 0);
  if ( !v11 )
    goto LABEL_19;
  return v11;
}
// 639D8: using guessed type int dword_639D8;

//----- (00026B74) --------------------------------------------------------
void sub_26B74()
{
  int v0; // r9
  char *v1; // r3
  const char *v2; // lr
  int v3; // r0
  int v4; // r0
  int v5; // r11
  int v6; // r11
  int v7; // r3
  const char *v8; // r3
  char *v9; // r11
  int i; // r9
  const char *v11; // t1
  int v12; // r3
  unsigned int v13; // r0
  int v14; // r9
  int v15; // r0
  int v16; // r9
  int v17; // r0
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // lr
  int v23; // r1
  int v24; // r0
  int v25; // r0
  int v26; // r11
  int v27; // r0
  int v28; // r9
  int v29; // r11
  int v30; // r0
  int v31; // r9
  int v32; // r2
  const char *v33; // r2
  const char *v34; // r3
  __int64 v35; // r10
  __int64 v36; // r2
  int v37; // r1
  double v38; // d8
  double v39; // r0
  int v40; // r3
  unsigned int v41; // [sp+10h] [bp-81Ch]
  unsigned int v42; // [sp+14h] [bp-818h]
  char s1; // [sp+27h] [bp-805h] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  byte_64068 = 1;
  immedok((WINDOW *)dword_639D8, 1);
  sub_193CC();
  v0 = 0;
LABEL_2:
  while ( 2 )
  {
    while ( v0 < dword_63740 )
    {
LABEL_23:
      v6 = *(_DWORD *)(dword_639E0 + 4 * v0);
      if ( v6 == sub_1D644() )
        wattr_on((WINDOW *)dword_639D8, 0x200000u, 0);
      if ( *(_DWORD *)(v6 + 100) != 1 )
        wattr_on((WINDOW *)dword_639D8, 0x100000u, 0);
      snprintf(s, 0x800u, "%d: ", *(_DWORD *)v6);
      sub_1952C(s);
      v7 = *(_DWORD *)(v6 + 100);
      if ( v7 == 1 )
      {
        strcpy(s, "Enabled ");
        sub_1952C(s);
      }
      else if ( v7 )
      {
        if ( v7 == 2 )
        {
          strcpy(s, "Rejecting ");
          sub_1952C(s);
        }
      }
      else
      {
        strcpy(s, "Disabled ");
        sub_1952C(s);
      }
      ++v0;
      v8 = "Alive";
      if ( *(_BYTE *)(v6 + 97) )
        v8 = "Dead";
      snprintf(
        s,
        0x800u,
        "%s Quota %d Prio %d: %s  User:%s\n",
        v8,
        *(_DWORD *)(v6 + 56),
        *(_DWORD *)(v6 + 4),
        *(const char **)(v6 + 164),
        *(const char **)(v6 + 172));
      sub_1952C(s);
      wattr_off((WINDOW *)dword_639D8, 0x300000u, 0);
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              snprintf(
                s,
                0x800u,
                "\nCurrent pool management strategy: %s\n",
                (const char *)dword_5F890[dword_611AC + 520]);
              sub_1952C(s);
              if ( dword_611AC == 2 )
              {
                snprintf(s, 0x800u, "Set to rotate every %d minutes\n", dword_63AF8);
                sub_1952C(s);
              }
              v1 = "disabled";
              if ( byte_63BC5 )
                v1 = "enabled";
              snprintf(s, 0x800u, "[F]ailover only %s\n", v1);
              sub_1952C(s);
              strcpy(s, "Pool [A]dd [R]emove [D]isable [E]nable [Q]uota change\n");
              sub_1952C(s);
              strcpy(s, "[C]hange management strategy [S]witch pool [I]nformation\n");
              sub_1952C(s);
              strcpy(s, "Or press any other key to continue\n");
              sub_1952C(s);
              sub_19350();
              s1 = wgetch((WINDOW *)stdscr);
              if ( !strncasecmp(&s1, "a", 1u) )
              {
                v0 = 0;
                sub_26934(1);
                goto LABEL_2;
              }
              if ( strncasecmp(&s1, "r", 1u) )
                break;
              if ( dword_63740 <= 1 )
              {
                v2 = "Cannot remove last pool";
                goto LABEL_47;
              }
              v3 = sub_25D00("Select pool number");
              if ( v3 >= 0 && v3 < dword_63740 )
              {
                v26 = *(_DWORD *)(dword_639E0 + 4 * v3);
                if ( v26 == sub_1D644() )
                {
                  sub_195D4(0);
                  if ( v26 != sub_1D644() )
                  {
LABEL_82:
                    v40 = *(_DWORD *)(v26 + 100);
                    v0 = 0;
                    *(_DWORD *)(v26 + 100) = 0;
                    if ( v40 == 1 )
                      --dword_63B84;
                    sub_15600(v26);
                    goto LABEL_2;
                  }
                }
                else if ( v26 != sub_1D644() )
                {
                  goto LABEL_82;
                }
                strcpy(s, "Unable to remove pool due to activity\n");
                sub_1952C(s);
              }
              else
              {
LABEL_13:
                strcpy(s, "Invalid selection\n");
                sub_1952C(s);
              }
            }
            if ( !strncasecmp(&s1, "s", 1u) )
            {
              v24 = sub_25D00("Select pool number");
              if ( v24 >= 0 && v24 < dword_63740 )
              {
                v25 = *(_DWORD *)(dword_639E0 + 4 * v24);
                if ( *(_DWORD *)(v25 + 100) != 1 )
                {
                  *(_DWORD *)(v25 + 100) = 1;
                  ++dword_63B84;
                }
                goto LABEL_52;
              }
              goto LABEL_13;
            }
            if ( strncasecmp(&s1, "d", 1u) )
              break;
            if ( dword_63B84 > 1 )
            {
              v4 = sub_25D00("Select pool number");
              if ( v4 < 0 || v4 >= dword_63740 )
                goto LABEL_13;
              v5 = *(_DWORD *)(dword_639E0 + 4 * v4);
              if ( *(_DWORD *)(v5 + 100) == 1 )
                --dword_63B84;
              v0 = 0;
              *(_DWORD *)(v5 + 100) = 0;
              if ( v5 == sub_1D644() )
              {
                sub_195D4(0);
                goto LABEL_2;
              }
              goto LABEL_22;
            }
            strcpy(s, "Cannot disable last pool");
            sub_1952C(s);
          }
          if ( strncasecmp(&s1, "e", 1u) )
            break;
          v27 = sub_25D00("Select pool number");
          if ( v27 < 0 || v27 >= dword_63740 )
            goto LABEL_13;
          v28 = *(_DWORD *)(dword_639E0 + 4 * v27);
          if ( *(_DWORD *)(v28 + 100) != 1 )
          {
            *(_DWORD *)(v28 + 100) = 1;
            ++dword_63B84;
          }
          v29 = *(_DWORD *)(v28 + 4);
          if ( v29 < *(_DWORD *)(sub_1D644() + 4) )
          {
            v25 = v28;
LABEL_52:
            v0 = 0;
            sub_195D4(v25);
            goto LABEL_2;
          }
LABEL_22:
          v0 = 0;
          if ( dword_63740 > 0 )
            goto LABEL_23;
        }
        if ( !strncasecmp(&s1, "c", 1u) )
        {
          v9 = &byte_600AC;
          for ( i = 0; i != 5; ++i )
          {
            v11 = (const char *)*((_DWORD *)v9 + 1);
            v9 += 4;
            v12 = i;
            snprintf(s, 0x800u, "%d: %s\n", v12, v11);
            sub_1952C(s);
          }
          v13 = sub_25D00("Select strategy number type");
          v14 = v13;
          if ( v13 <= 4 )
          {
            if ( v13 != 2
              || (dword_63AF8 = sub_25D00("Select interval in minutes"), (unsigned int)dword_63AF8 <= 0x270F) )
            {
              dword_611AC = v14;
              v0 = 0;
              sub_195D4(0);
              goto LABEL_2;
            }
            dword_63AF8 = 0;
          }
          goto LABEL_13;
        }
        if ( strncasecmp(&s1, "i", 1u) )
          break;
        v30 = sub_25D00("Select pool number");
        if ( v30 < 0 || v30 >= dword_63740 )
          goto LABEL_13;
        v31 = *(_DWORD *)(dword_639E0 + 4 * v30);
        if ( sub_19140() )
        {
          snprintf(s, 0x800u, "Pool: %s\n", *(const char **)(v31 + 164));
          sub_153C8(s);
          v32 = *(_DWORD *)(v31 + 32);
          if ( v32 )
          {
            if ( v32 > 1 )
              v33 = "S";
            else
              v33 = "";
            snprintf(s, 0x800u, "SOLVED %d BLOCK%s!\n", *(_DWORD *)(v31 + 32), v33);
            sub_153C8(s);
          }
          if ( !*(_BYTE *)(v31 + 632) )
          {
            v34 = "Does not have";
            if ( *(_DWORD *)(v31 + 108) )
              v34 = "Has";
            snprintf(s, 0x800u, "%s own long-poll support\n", v34);
            sub_153C8(s);
          }
          snprintf(s, 0x800u, " Queued work requests: %d\n", *(_DWORD *)(v31 + 116));
          sub_153C8(s);
          snprintf(s, 0x800u, " Share submissions: %lld\n", *(_QWORD *)(v31 + 8) + *(_QWORD *)(v31 + 16));
          sub_153C8(s);
          snprintf(s, 0x800u, " Accepted shares: %lld\n", *(_QWORD *)(v31 + 8));
          sub_153C8(s);
          snprintf(s, 0x800u, " Rejected shares: %lld\n", *(_QWORD *)(v31 + 16));
          sub_153C8(s);
          snprintf(s, 0x800u, " Accepted difficulty shares: %1.f\n", *(double *)(v31 + 72));
          sub_153C8(s);
          snprintf(s, 0x800u, " Rejected difficulty shares: %1.f\n", *(double *)(v31 + 80));
          sub_153C8(s);
          v35 = *(_QWORD *)(v31 + 8);
          v36 = *(_QWORD *)(v31 + 16);
          if ( v35 || v36 )
          {
            v42 = *(_DWORD *)(v31 + 16);
            v41 = *(_DWORD *)(v31 + 20);
            LODWORD(v38) = sub_493DC(100 * v36);
            HIDWORD(v38) = v37;
            LODWORD(v39) = sub_493DC(v35 + __PAIR64__(v41, v42));
            snprintf(s, 0x800u, " Reject ratio: %.1f%%\n", v38 / v39);
            sub_153C8(s);
          }
          snprintf(s, 0x800u, " Items worked on: %d\n", *(_DWORD *)(v31 + 68));
          sub_153C8(s);
          snprintf(s, 0x800u, " Discarded work due to new blocks: %d\n", *(_DWORD *)(v31 + 124));
          sub_153C8(s);
          snprintf(s, 0x800u, " Stale submissions discarded due to new blocks: %d\n", *(_DWORD *)(v31 + 120));
          sub_153C8(s);
          snprintf(s, 0x800u, " Unable to get work from server occasions: %d\n", *(_DWORD *)(v31 + 128));
          sub_153C8(s);
          snprintf(s, 0x800u, " Submitting work remotely delay occasions: %d\n\n", *(_DWORD *)(v31 + 132));
          sub_153C8(s);
          if ( pthread_mutex_unlock(&stru_63D48) )
            sub_B694("unlock_curses", 2928);
          off_60178();
        }
      }
      if ( strncasecmp(&s1, "q", 1u) )
        break;
      v15 = sub_25D00("Select pool number");
      if ( v15 < 0 || v15 >= dword_63740 )
        goto LABEL_13;
      v16 = *(_DWORD *)(dword_639E0 + 4 * v15);
      v17 = sub_25D00("Set quota");
      if ( v17 >= 0 )
      {
        *(_DWORD *)(v16 + 56) = v17;
        v0 = 0;
        sub_14E18();
        goto LABEL_2;
      }
      v2 = "Invalid negative quota\n";
LABEL_47:
      v18 = *(_DWORD *)v2;
      v19 = *((_DWORD *)v2 + 1);
      v20 = *((_DWORD *)v2 + 2);
      v21 = *((_DWORD *)v2 + 3);
      v22 = v2 + 16;
      *(_DWORD *)s = v18;
      *(_DWORD *)&s[4] = v19;
      *(_DWORD *)&s[8] = v20;
      *(_DWORD *)&s[12] = v21;
      v23 = v22[1];
      *(_DWORD *)&s[16] = *v22;
      *(_DWORD *)&s[20] = v23;
      sub_1952C(s);
    }
    if ( !strncasecmp(&s1, "f", 1u) )
    {
      v0 = 0;
      byte_63BC5 ^= 1u;
      continue;
    }
    break;
  }
  sub_193CC();
  immedok((WINDOW *)dword_639D8, 0);
  byte_64068 = 0;
}
// 27378: variable 'v37' is possibly undefined
// 2739C: variable 'v39' is possibly undefined
// 5F890: using guessed type int dword_5F890[];
// 600AC: using guessed type char byte_600AC;
// 60178: using guessed type int (*off_60178)();
// 60E70: using guessed type int stdscr;
// 611AC: using guessed type int dword_611AC;
// 63740: using guessed type int dword_63740;
// 639D8: using guessed type int dword_639D8;
// 639E0: using guessed type int dword_639E0;
// 63AF8: using guessed type int dword_63AF8;
// 63B84: using guessed type int dword_63B84;
// 63BC5: using guessed type char byte_63BC5;
// 64068: using guessed type char byte_64068;

//----- (000276A8) --------------------------------------------------------
int sub_276A8()
{
  char s1[5]; // [sp+7h] [bp-5h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2F02C("Input");
  if ( byte_612F8 )
  {
    do
    {
      while ( 1 )
      {
        s1[0] = wgetch((WINDOW *)stdscr);
        if ( !strncasecmp(s1, "q", 1u) )
          sub_17328();
        if ( strncasecmp(s1, "d", 1u) )
          break;
        sub_25D2C();
        if ( byte_640B8 )
          goto LABEL_10;
      }
      if ( !strncasecmp(s1, "p", 1u) )
      {
        sub_26B74();
      }
      else if ( !strncasecmp(s1, "s", 1u) )
      {
        sub_263D4();
      }
    }
    while ( !byte_640B8 );
LABEL_10:
    sub_19060();
  }
  return 0;
}
// 60E70: using guessed type int stdscr;
// 612F8: using guessed type char byte_612F8;
// 640B8: using guessed type char byte_640B8;

//----- (000277B0) --------------------------------------------------------
int sub_277B0()
{
  int maxy; // r6
  WINDOW *v1; // r0
  int maxx; // r1

  if ( pthread_mutex_lock(&stru_63D48) )
    sub_B4E4("lock_curses", 2933);
  if ( byte_612F8 )
  {
    if ( !pthread_mutex_unlock(&stru_63D48) )
      return off_60178();
LABEL_14:
    sub_B694("unlock_curses", 2928);
  }
  v1 = initscr();
  dword_64230 = (int)v1;
  if ( v1 )
    maxx = v1->_maxx;
  else
    maxy = -1;
  if ( v1 )
    maxy = v1->_maxy;
  else
    maxx = maxy;
  if ( v1 )
  {
    ++maxx;
    ++maxy;
  }
  dword_63D60 = (int)newwin(dword_612FC, maxx, 0, 0);
  leaveok((WINDOW *)dword_63D60, 1);
  dword_639D8 = (int)newwin(maxy - dword_61304, 0, dword_61304, 0);
  idlok((WINDOW *)dword_639D8, 1);
  scrollok((WINDOW *)dword_639D8, 1);
  leaveok((WINDOW *)dword_639D8, 1);
  cbreak();
  noecho();
  byte_612F8 = 1;
  dword_61300 = dword_612FC;
  if ( pthread_mutex_unlock(&stru_63D48) )
    goto LABEL_14;
  return off_60178();
}
// 277FC: variable 'maxy' is possibly undefined
// 27800: variable 'maxx' is possibly undefined
// 60178: using guessed type int (*off_60178)();
// 612F8: using guessed type char byte_612F8;
// 612FC: using guessed type int dword_612FC;
// 61300: using guessed type int dword_61300;
// 61304: using guessed type int dword_61304;
// 639D8: using guessed type int dword_639D8;
// 63D60: using guessed type int dword_63D60;
// 64230: using guessed type int dword_64230;

//----- (000278E0) --------------------------------------------------------
int __fastcall sub_278E0(int result)
{
  if ( !*(_DWORD *)(result + 12) )
    *(_DWORD *)(result + 12) = nullsub_7;
  if ( !*(_DWORD *)(result + 16) )
    *(_DWORD *)(result + 16) = nullsub_2;
  if ( !*(_DWORD *)(result + 20) )
    *(_DWORD *)(result + 20) = nullsub_1;
  if ( !*(_DWORD *)(result + 24) )
    *(_DWORD *)(result + 24) = nullsub_3;
  if ( !*(_DWORD *)(result + 32) )
    *(_DWORD *)(result + 32) = sub_F368;
  if ( !*(_DWORD *)(result + 44) )
    *(_DWORD *)(result + 44) = sub_F370;
  if ( !*(_DWORD *)(result + 48) )
    *(_DWORD *)(result + 48) = sub_F378;
  if ( !*(_DWORD *)(result + 52) )
    *(_DWORD *)(result + 52) = sub_F384;
  if ( !*(_DWORD *)(result + 56) )
    *(_DWORD *)(result + 56) = sub_F38C;
  if ( !*(_DWORD *)(result + 84) )
    *(_DWORD *)(result + 84) = nullsub_4;
  if ( !*(_DWORD *)(result + 88) )
    *(_DWORD *)(result + 88) = nullsub_5;
  if ( !*(_DWORD *)(result + 92) )
    *(_DWORD *)(result + 92) = nullsub_6;
  if ( !*(_DWORD *)(result + 60) )
    *(_DWORD *)(result + 60) = sub_24A70;
  if ( !*(_DWORD *)(result + 76) )
    *(_DWORD *)(result + 76) = nullsub_2;
  if ( !*(_DWORD *)(result + 80) )
    *(_DWORD *)(result + 80) = nullsub_2;
  if ( !*(_DWORD *)(result + 72) )
    *(_DWORD *)(result + 72) = sub_F368;
  if ( !*(_DWORD *)(result + 96) )
    *(_DWORD *)(result + 96) = nullsub_2;
  if ( *(double *)(result + 104) == 0.0 )
    *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  return result;
}
// F35C: using guessed type int nullsub_2();
// F360: using guessed type int nullsub_1();
// F364: using guessed type int nullsub_3();
// F394: using guessed type int nullsub_4();
// F398: using guessed type int nullsub_5();
// F39C: using guessed type int nullsub_6();
// F3A0: using guessed type int nullsub_7();

//----- (00027B20) --------------------------------------------------------
int __fastcall sub_27B20(pthread_rwlock_t *a1)
{
  int v2; // r2
  int v3; // r3
  unsigned int v4; // r1
  bool v5; // zf
  int *v6; // r3
  unsigned int nr_writers_queued; // r2
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_63CA0) )
    sub_B550("enable_device", 10392);
  v2 = dword_63BC8;
  v3 = dword_629DC++;
  a1->__lock = v3;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  if ( pthread_rwlock_unlock(&stru_63CA0) )
    sub_B700("enable_device", 10394);
  off_60178();
  v5 = byte_63D70 == 0;
  if ( byte_63D70 )
    v6 = (int *)dword_629E0;
  else
    v6 = &dword_6410C;
  if ( byte_63D70 )
  {
    nr_writers_queued = a1[4].__nr_writers_queued;
  }
  else
  {
    v4 = a1[4].__nr_writers_queued;
    nr_writers_queued = *v6;
  }
  if ( byte_63D70 )
    v6 = (int *)((char *)v6 + nr_writers_queued);
  else
    *v6 = v4 + nr_writers_queued;
  if ( !v5 )
    dword_629E0 = (int)v6;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    sub_B628("enable_device", 10401);
  a1[11].__lock = 0;
  return result;
}
// 27BA0: variable 'v4' is possibly undefined
// 60178: using guessed type int (*off_60178)();
// 629DC: using guessed type int dword_629DC;
// 629E0: using guessed type int dword_629E0;
// 63BC8: using guessed type int dword_63BC8;
// 63D70: using guessed type char byte_63D70;
// 6410C: using guessed type int dword_6410C;

//----- (00027C18) --------------------------------------------------------
int __fastcall sub_27C18(_DWORD *a1)
{
  int v1; // r4
  const char *v2; // r6
  size_t v3; // r0
  unsigned int v4; // lr
  int v5; // r1
  unsigned __int8 *v6; // r3
  int v7; // r12
  size_t v8; // r5
  unsigned int i; // r2
  unsigned int v10; // lr
  int v11; // r0
  int v12; // r10
  int v13; // r8
  int v14; // r7
  unsigned int v15; // r1
  int v16; // r12
  unsigned int v17; // r0
  unsigned int v18; // r1
  int v19; // r12
  unsigned int v20; // r0
  unsigned int v21; // r1
  size_t v22; // r1
  _DWORD *v23; // r8
  int v24; // r0
  unsigned int v25; // r2
  unsigned int v26; // r3
  int v27; // r1
  unsigned int v28; // r2
  unsigned int v29; // r3
  int v30; // r1
  int v31; // r7
  int v32; // r3
  _DWORD *v33; // r5
  int v34; // r0
  char *v35; // r6
  _DWORD *v36; // r7
  int v37; // r9
  int v38; // r3
  unsigned int v39; // r10
  size_t v40; // r0
  unsigned int v41; // r11
  unsigned __int8 *v42; // r7
  int v43; // r8
  int v44; // r1
  int v45; // r12
  int v46; // r2
  int v47; // r0
  unsigned int v48; // r3
  unsigned int v49; // r10
  int v50; // r8
  unsigned int v51; // r2
  unsigned int v52; // r3
  int v53; // r1
  unsigned int v54; // r2
  unsigned int v55; // r3
  size_t v56; // r9
  int v57; // r3
  int v58; // r3
  int v59; // r2
  int v60; // r2
  int result; // r0
  int v62; // r1
  unsigned int v63; // r2
  unsigned int v64; // r3
  int v65; // r1
  unsigned int v66; // r2
  unsigned int v67; // r3
  unsigned int v68; // r1
  unsigned int v69; // r3
  _DWORD *v70; // r2
  int v71; // r3
  int v72; // r2
  int v73; // r1
  int v74; // r4
  size_t v75; // r6
  _DWORD *v76; // r0
  _DWORD *v77; // r7
  int v78; // r8
  int v79; // r2
  unsigned int v80; // r6
  _DWORD *v81; // r11
  _DWORD *v82; // r4
  _DWORD *v83; // r5
  int v84; // r6
  char *v85; // r9
  unsigned int v86; // r3
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r1
  unsigned int v90; // r2
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  int v94; // r0
  size_t v95; // r0
  _DWORD *v96; // r0
  void *v97; // r0
  unsigned int j; // [sp+4h] [bp-8h]

  v1 = dword_629E4;
  if ( dword_629E4 )
  {
    v2 = *(const char **)(a1[1] + 8);
    v3 = strlen(v2);
    v4 = -1640531527;
    v5 = -17973521;
    v6 = *(unsigned __int8 **)(a1[1] + 8);
    v7 = -1640531527;
    v8 = v3;
    for ( i = v3; i > 0xB; v5 = (v21 - v7 - v4) ^ (v4 >> 15) )
    {
      i -= 12;
      v10 = (v6[6] << 16) + (v6[5] << 8) + v6[4] + (v6[7] << 24) + v4;
      v11 = (v6[2] << 16) + (v6[1] << 8) + *v6;
      v12 = v6[3];
      v13 = v6[11];
      v14 = (v6[10] << 16) + (v6[9] << 8) + v6[8];
      v6 += 12;
      v15 = v14 + (v13 << 24) + v5;
      v16 = (v11 + (v12 << 24) - v10 - v15 + v7) ^ (v15 >> 13);
      v17 = (v10 - v15 - v16) ^ (v16 << 8);
      v18 = (v15 - v16 - v17) ^ (v17 >> 13);
      v19 = (v16 - v17 - v18) ^ (v18 >> 12);
      v20 = (v17 - v18 - v19) ^ (v19 << 16);
      v21 = (v18 - v19 - v20) ^ (v20 >> 5);
      v7 = (v19 - v20 - v21) ^ (v21 >> 3);
      v4 = (v20 - v21 - v7) ^ (v7 << 10);
    }
    v22 = v5 + v8;
    switch ( i )
    {
      case 1u:
        goto LABEL_15;
      case 2u:
        goto LABEL_14;
      case 3u:
        goto LABEL_13;
      case 4u:
        goto LABEL_12;
      case 5u:
        goto LABEL_11;
      case 6u:
        goto LABEL_10;
      case 7u:
        goto LABEL_9;
      case 8u:
        goto LABEL_8;
      case 9u:
        goto LABEL_7;
      case 0xAu:
        goto LABEL_6;
      case 0xBu:
        v22 += v6[10] << 24;
LABEL_6:
        v22 += v6[9] << 16;
LABEL_7:
        v22 += v6[8] << 8;
LABEL_8:
        v4 += v6[7] << 24;
LABEL_9:
        v4 += v6[6] << 16;
LABEL_10:
        v4 += v6[5] << 8;
LABEL_11:
        v4 += v6[4];
LABEL_12:
        v7 += v6[3] << 24;
LABEL_13:
        v7 += v6[2] << 16;
LABEL_14:
        v7 += v6[1] << 8;
LABEL_15:
        v7 += *v6;
        break;
      default:
        break;
    }
    v23 = *(_DWORD **)(dword_629E4 + 8);
    v24 = (v7 - v4 - v22) ^ (v22 >> 13);
    v25 = (v4 - v22 - v24) ^ (v24 << 8);
    v26 = (v22 - v24 - v25) ^ (v25 >> 13);
    v27 = (v24 - v25 - v26) ^ (v26 >> 12);
    v28 = (v25 - v26 - v27) ^ (v27 << 16);
    v29 = (v26 - v27 - v28) ^ (v28 >> 5);
    v30 = (v27 - v28 - v29) ^ (v29 >> 3);
    v31 = *(_DWORD *)(*v23
                    + 12
                    * (((v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10)))
                      ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15))
                     & (v23[1] - 1)));
    if ( v31 )
      v31 -= v23[5];
    while ( v31 )
    {
      if ( v8 == *(_DWORD *)(v31 + 32) && !memcmp(*(const void **)(v31 + 28), v2, v8) )
      {
        v57 = *(_DWORD *)(v31 + 4) + 1;
        *(_DWORD *)(v31 + 4) = v57;
        a1[2] = v57;
        goto LABEL_29;
      }
      v32 = *(_DWORD *)(v31 + 24);
      if ( !v32 )
        break;
      v31 = v32 - v23[5];
    }
    v33 = malloc(0x28u);
    v34 = *(_DWORD *)v2;
    v33[1] = 0;
    v35 = (char *)(v33 + 2);
    *v33 = v34;
    a1[2] = 0;
    v33[4] = 0;
    v33[7] = v33;
    v33[8] = strlen((const char *)v33);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) + 8) = v33;
    v33[3] = *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) - *(_DWORD *)(*(_DWORD *)(v1 + 8) + 20);
    *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) = v33 + 2;
    v36 = *(_DWORD **)(v1 + 8);
  }
  else
  {
    v33 = malloc(0x28u);
    v94 = **(_DWORD **)(a1[1] + 8);
    v33[1] = 0;
    *v33 = v94;
    a1[2] = 0;
    v33[4] = 0;
    v33[7] = v33;
    v95 = strlen((const char *)v33);
    v33[3] = 0;
    dword_629E4 = (int)v33;
    v33[8] = v95;
    v96 = malloc(0x2Cu);
    v36 = v96;
    v33[2] = v96;
    if ( !v96 )
      goto LABEL_81;
    *v96 = 0;
    v96[3] = 0;
    v35 = (char *)(v33 + 2);
    v96[4] = 0;
    v96[5] = 0;
    v96[6] = 0;
    v96[7] = 0;
    v96[8] = 0;
    v96[9] = 0;
    v96[10] = 0;
    v96[4] = v33 + 2;
    v96[1] = 32;
    v96[2] = 5;
    v96[5] = 8;
    v97 = malloc(0x180u);
    *v36 = v97;
    if ( !v97 )
      goto LABEL_81;
    memset(v97, 0, 0x180u);
    v1 = (int)v33;
    v36[10] = -1609490463;
  }
  v37 = -17973521;
  ++v36[3];
  v38 = *(_DWORD *)(v1 + 8);
  v39 = -1640531527;
  v33[9] = -17973521;
  v33[2] = v38;
  v40 = strlen((const char *)v33);
  v41 = v40;
  if ( v40 <= 0xB )
  {
    v43 = -1640531527;
    v42 = (unsigned __int8 *)v33;
  }
  else
  {
    v42 = (unsigned __int8 *)v33;
    v43 = -1640531527;
    do
    {
      v41 -= 12;
      v44 = (v42[2] << 16) + (v42[1] << 8) + *v42;
      v45 = v42[3];
      v46 = (v42[6] << 16) + (v42[5] << 8) + v42[4];
      v47 = v42[7];
      v48 = (v42[10] << 16) + (v42[9] << 8) + v42[8] + (v42[11] << 24) + v37;
      v42 += 12;
      v49 = v46 + (v47 << 24) + v39;
      v50 = (v44 + (v45 << 24) - v48 - v49 + v43) ^ (v48 >> 13);
      v51 = (v49 - v48 - v50) ^ (v50 << 8);
      v52 = (v48 - v50 - v51) ^ (v51 >> 13);
      v53 = (v50 - v51 - v52) ^ (v52 >> 12);
      v54 = (v51 - v52 - v53) ^ (v53 << 16);
      v55 = (v52 - v53 - v54) ^ (v54 >> 5);
      v43 = (v53 - v54 - v55) ^ (v55 >> 3);
      v39 = (v54 - v55 - v43) ^ (v43 << 10);
      v37 = (v55 - v43 - v39) ^ (v39 >> 15);
      v33[9] = v37;
    }
    while ( v41 > 0xB );
    v40 = strlen((const char *)v33);
  }
  v56 = v40 + v37;
  v33[9] = v56;
  switch ( v41 )
  {
    case 1u:
      goto LABEL_49;
    case 2u:
      goto LABEL_48;
    case 3u:
      goto LABEL_47;
    case 4u:
      goto LABEL_46;
    case 5u:
      goto LABEL_45;
    case 6u:
      goto LABEL_44;
    case 7u:
      goto LABEL_43;
    case 8u:
      goto LABEL_42;
    case 9u:
      goto LABEL_41;
    case 0xAu:
      goto LABEL_40;
    case 0xBu:
      v56 += v42[10] << 24;
      v33[9] = v56;
LABEL_40:
      v56 += v42[9] << 16;
      v33[9] = v56;
LABEL_41:
      v56 += v42[8] << 8;
      v33[9] = v56;
LABEL_42:
      v39 += v42[7] << 24;
LABEL_43:
      v39 += v42[6] << 16;
LABEL_44:
      v39 += v42[5] << 8;
LABEL_45:
      v39 += v42[4];
LABEL_46:
      v43 += v42[3] << 24;
LABEL_47:
      v43 += v42[2] << 16;
LABEL_48:
      v43 += v42[1] << 8;
LABEL_49:
      v43 += *v42;
      break;
    default:
      break;
  }
  v62 = (v43 - v39 - v56) ^ (v56 >> 13);
  v63 = (v39 - v56 - v62) ^ (v62 << 8);
  v64 = (v56 - v62 - v63) ^ (v63 >> 13);
  v65 = (v62 - v63 - v64) ^ (v64 >> 12);
  v66 = (v63 - v64 - v65) ^ (v65 << 16);
  v67 = (v64 - v65 - v66) ^ (v66 >> 5);
  v68 = v65 - v66 - v67;
  v69 = (v67 - (v68 ^ (v67 >> 3)) - ((v66 - v67 - (v68 ^ (v67 >> 3))) ^ ((v68 ^ (v67 >> 3)) << 10)))
      ^ (((v66 - v67 - (v68 ^ (v67 >> 3))) ^ ((v68 ^ (v67 >> 3)) << 10)) >> 15);
  v33[9] = v69;
  v70 = *(_DWORD **)(v1 + 8);
  v71 = 12 * (v69 & (v70[1] - 1));
  ++*(_DWORD *)(*v70 + v71 + 4);
  v72 = *(_DWORD *)(**(_DWORD **)(v1 + 8) + v71);
  v33[5] = 0;
  v33[6] = v72;
  v73 = **(_DWORD **)(v1 + 8) + v71;
  if ( *(_DWORD *)v73 )
  {
    *(_DWORD *)(*(_DWORD *)v73 + 12) = v35;
    v73 = **(_DWORD **)(v1 + 8) + v71;
  }
  *(_DWORD *)v73 = v35;
  if ( *(_DWORD *)(**(_DWORD **)(v1 + 8) + v71 + 4) >= (unsigned int)(10
                                                                    * (*(_DWORD *)(**(_DWORD **)(v1 + 8) + v71 + 8) + 1)) )
  {
    v74 = v33[2];
    if ( *(_DWORD *)(v74 + 36) != 1 )
    {
      v75 = 24 * *(_DWORD *)(v74 + 4);
      v76 = malloc(v75);
      v77 = v76;
      if ( v76 )
      {
        memset(v76, 0, v75);
        v78 = 0;
        *(_DWORD *)(v74 + 24) = (((2 * *(_DWORD *)(v74 + 4) - 1) & *(_DWORD *)(v74 + 12)) != 0)
                              + (*(_DWORD *)(v74 + 12) >> (*(_BYTE *)(v74 + 8) + 1));
        *(_DWORD *)(v33[2] + 28) = 0;
        v79 = v33[2];
        v80 = *(_DWORD *)(v79 + 4);
        if ( v80 )
        {
          v81 = v33;
          for ( j = 0; j < v80; ++j )
          {
            v82 = *(_DWORD **)(*(_DWORD *)v79 + v78);
            if ( v82 )
            {
              while ( 1 )
              {
                v83 = (_DWORD *)v82[4];
                v84 = 3 * ((2 * v80 - 1) & v82[7]);
                v85 = (char *)&v77[v84];
                v86 = *((_DWORD *)v85 + 1) + 1;
                *((_DWORD *)v85 + 1) = v86;
                if ( v86 > *(_DWORD *)(v79 + 24) )
                {
                  ++*(_DWORD *)(v79 + 28);
                  *((_DWORD *)v85 + 2) = *((_DWORD *)v85 + 1) / *(_DWORD *)(v81[2] + 24);
                }
                v82[3] = 0;
                v82[4] = v77[v84];
                v87 = v77[v84];
                if ( v87 )
                  *(_DWORD *)(v87 + 12) = v82;
                v77[v84] = v82;
                v79 = v81[2];
                if ( !v83 )
                  break;
                v80 = *(_DWORD *)(v79 + 4);
                v82 = v83;
              }
              v80 = *(_DWORD *)(v79 + 4);
            }
            v78 += 12;
          }
          v33 = v81;
        }
        free(*(void **)v79);
        *(_DWORD *)(v33[2] + 4) *= 2;
        ++*(_DWORD *)(v33[2] + 8);
        *(_DWORD *)v33[2] = v77;
        v88 = (_DWORD *)v33[2];
        v89 = v88[3];
        v90 = v88[7];
        v91 = v90 > v89 >> 1;
        if ( v90 <= v89 >> 1 )
          v92 = 0;
        else
          v92 = v88[8];
        if ( v91 )
          ++v92;
        v88[8] = v92;
        v93 = v33[2];
        if ( *(_DWORD *)(v93 + 32) > 1u )
          *(_DWORD *)(v93 + 36) = 1;
        goto LABEL_29;
      }
LABEL_81:
      exit(-1);
    }
  }
LABEL_29:
  if ( pthread_rwlock_wrlock(&stru_63CA0) )
    sub_B550("add_cgpu", 10448);
  dword_63BC8 = (int)realloc((void *)dword_63BC8, 4 * (dword_63CC0 + dword_629E8 + 2));
  if ( pthread_rwlock_unlock(&stru_63CA0) )
    sub_B700("add_cgpu", 10450);
  off_60178();
  if ( pthread_mutex_lock(&mutex) )
    sub_B4E4("add_cgpu", 10452);
  a1[58] = time(0);
  if ( pthread_mutex_unlock(&mutex) )
    sub_B694("add_cgpu", 10454);
  off_60178();
  if ( byte_63D70 )
  {
    v58 = dword_629E8 + dword_63CC0;
    ++dword_629E8;
    *(_DWORD *)(dword_63BC8 + 4 * v58) = a1;
    v59 = dword_63CC0;
  }
  else
  {
    v59 = dword_63CC0 + 1;
    *(_DWORD *)(dword_63BC8 + 4 * dword_63CC0) = a1;
    dword_63CC0 = v59;
  }
  v60 = v59 - dword_63E50;
  result = 1;
  if ( v60 > dword_6130C )
    dword_6130C = v60;
  return result;
}
// 27D6C: control flows out of bounds to 27D70
// 2805C: control flows out of bounds to 28060
// 60178: using guessed type int (*off_60178)();
// 6130C: using guessed type int dword_6130C;
// 629E4: using guessed type int dword_629E4;
// 629E8: using guessed type int dword_629E8;
// 63BC8: using guessed type int dword_63BC8;
// 63CC0: using guessed type int dword_63CC0;
// 63D70: using guessed type char byte_63D70;
// 63E50: using guessed type int dword_63E50;

//----- (000286F0) --------------------------------------------------------
int sub_286F0()
{
  return 0;
}

//----- (000286F8) --------------------------------------------------------
int __fastcall sub_286F8(int result)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(result + 584);
  if ( v1 )
    *v1 = 0;
  return result;
}

//----- (0002870C) --------------------------------------------------------
bool __fastcall sub_2870C(int a1, int a2)
{
  int v2; // lr
  fd_set *p_tv_usec; // r3
  int v4; // r0
  _DWORD *v5; // r4
  int v6; // r6
  int v7; // lr
  struct timeval timeout; // [sp+8h] [bp-88h] BYREF
  fd_set readfds; // [sp+10h] [bp-80h] BYREF
  _DWORD vars0[6]; // [sp+90h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 580);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( p_tv_usec != (fd_set *)&readfds.__fds_bits[31] );
  v4 = v2 + 1;
  v5 = &vars0[v2 / 32];
  v6 = v2 % 32;
  v7 = *(v5 - 32);
  timeout.tv_usec = 0;
  *(v5 - 32) = v7 | (1 << v6);
  timeout.tv_sec = a2 & ~(a2 >> 31);
  return select(v4, &readfds, 0, 0, &timeout) > 0;
}

//----- (000287AC) --------------------------------------------------------
int __fastcall sub_287AC(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return fcntl(a1, 4, v2);
}

//----- (000287D4) --------------------------------------------------------
ssize_t __fastcall sub_287D4(int a1)
{
  ssize_t result; // r0
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  result = recv(a1, buf, 1u, 0);
  if ( result != -1 )
    return buf[0];
  return result;
}

//----- (000287FC) --------------------------------------------------------
int __fastcall sub_287FC(const char **a1, int a2, int a3)
{
  const char *v5; // r3
  const char *v6; // r12
  size_t v7; // r0
  ssize_t v8; // r0
  int v9; // r2
  unsigned __int8 *v10; // r6
  unsigned __int8 v11; // r0
  char v13; // [sp+Fh] [bp-C05h] BYREF
  char s; // [sp+10h] [bp-C04h] BYREF
  char v15; // [sp+11h] [bp-C03h]
  char v16; // [sp+12h] [bp-C02h]
  unsigned __int8 v17; // [sp+13h] [bp-C01h] BYREF
  char v18[2048]; // [sp+410h] [bp-804h] BYREF

  v5 = a1[148];
  v6 = a1[144];
  if ( a3 )
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, v6);
  else
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, v6, v5, v6);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v18, 0x800u, "Sending proxy %s:%s - %s", a1[149], a1[150], &s);
    sub_38438(7, v18, 0);
  }
  v7 = strlen(&s);
  send(a2, &s, v7, 0);
  v8 = recv(a2, &s, 0xCu, 0);
  if ( v8 <= 0 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
      return 0;
    snprintf(v18, 0x800u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[149], a1[150]);
LABEL_22:
    sub_38438(4, v18, 0);
    return 0;
  }
  v9 = (unsigned __int8)byte_630C1;
  *(&s + v8) = 0;
  if ( v9 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v18, 0x800u, "Received from proxy %s:%s - %s", a1[149], a1[150], &s);
    sub_38438(7, v18, 0);
  }
  if ( strcmp(&s, "HTTP/1.1 200") && strcmp(&s, "HTTP/1.0 200") )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
      return 0;
    snprintf(v18, 0x800u, "HTTP Error from proxy %s:%s - %s", a1[149], a1[150], &s);
    goto LABEL_22;
  }
  v10 = (unsigned __int8 *)&v13;
  while ( 1 )
  {
    v11 = sub_287D4(a2);
    *++v10 = v11;
    if ( v11 == 255 )
      break;
    if ( v10 == &v17 )
    {
      while ( strncmp(&s, "\r\n\r\n", 4u) )
      {
        s = v15;
        v15 = v16;
        v16 = v17;
        v17 = sub_287D4(a2);
        if ( v17 == 255 )
          goto LABEL_18;
      }
      if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
        return 1;
      snprintf(v18, 0x800u, "Success negotiating with %s:%s HTTP proxy", a1[149], a1[150]);
      sub_38438(7, v18, 0);
      return 1;
    }
  }
LABEL_18:
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(v18, 0x800u, "Couldn't read HTTP byte from proxy %s:%s", a1[149], a1[150]);
    goto LABEL_22;
  }
  return 0;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00028BD0) --------------------------------------------------------
int __fastcall sub_28BD0(const char **a1, int a2, int a3)
{
  const char *v6; // r0
  __int16 v7; // kr00_2
  unsigned int v8; // r6
  int v10; // r4
  const char *v11; // r0
  const char *v12; // r8
  signed int v13; // r0
  const char *v14; // r1
  size_t v15; // r8
  unsigned int v16; // r6
  struct addrinfo *pai; // [sp+8h] [bp-A28h] BYREF
  char v18; // [sp+Ch] [bp-A24h] BYREF
  _BYTE buf[4]; // [sp+2Ch] [bp-A04h] BYREF
  char v20; // [sp+30h] [bp-A00h]
  char v21; // [sp+31h] [bp-9FFh]
  char v22; // [sp+32h] [bp-9FEh]
  char v23; // [sp+33h] [bp-9FDh]
  char v24[8]; // [sp+34h] [bp-9FCh] BYREF
  _BYTE v25[500]; // [sp+3Ch] [bp-9F4h] BYREF
  struct addrinfo s[64]; // [sp+230h] [bp-800h] BYREF

  v6 = a1[144];
  buf[0] = 4;
  buf[1] = 1;
  v7 = strtol(v6, 0, 10);
  buf[2] = HIBYTE(v7);
  buf[3] = v7;
  strcpy(v24, "CGMINER");
  v8 = bswap32(inet_addr(a1[148]));
  if ( v8 != -1 )
    goto LABEL_2;
  v11 = a1[148];
  s[0].ai_socktype = 0;
  s[0].ai_protocol = 0;
  s[0].ai_addrlen = 0;
  pai = (struct addrinfo *)&v18;
  s[0].ai_addr = 0;
  s[0].ai_flags = 0;
  s[0].ai_canonname = 0;
  s[0].ai_family = 2;
  s[0].ai_next = 0;
  if ( !getaddrinfo(v11, 0, s, &pai) )
  {
    v16 = *(_DWORD *)&pai->ai_addr->sa_data[2];
    freeaddrinfo(pai);
    v8 = bswap32(v16);
    if ( v8 != -1 )
    {
LABEL_2:
      v23 = v8;
      v20 = HIBYTE(v8);
      v21 = BYTE2(v8);
      v22 = BYTE1(v8);
      send(a2, buf, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_22:
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
      return 0;
    snprintf((char *)s, 0x800u, "Invalid IP address specified for socks4 proxy: %s", a1[148]);
    goto LABEL_8;
  }
  if ( !a3 )
    goto LABEL_22;
  v12 = a1[148];
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 1;
  v13 = strlen(v12);
  v14 = v12;
  if ( v13 >= 255 )
    v15 = 255;
  else
    v15 = v13;
  memcpy(v25, v14, v15);
  v25[v15] = 0;
  send(a2, buf, v15 + 17, 0);
LABEL_3:
  if ( sub_287D4(a2) || sub_287D4(a2) != 90 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
      return 0;
    snprintf((char *)s, 0x800u, "Bad response from %s:%s SOCKS4 server", a1[149], a1[150]);
LABEL_8:
    sub_38438(4, (const char *)s, 0);
    return 0;
  }
  v10 = 6;
  do
  {
    sub_287D4(a2);
    --v10;
  }
  while ( v10 );
  return 1;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (00028E3C) --------------------------------------------------------
int __fastcall sub_28E3C(struct timespec *req)
{
  int result; // r0

  do
    result = clock_nanosleep(1, 1, req, 0);
  while ( result == 4 );
  return result;
}

//----- (00028E64) --------------------------------------------------------
_DWORD *__fastcall sub_28E64(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( a1 && *a1 == 1 && (unsigned int)sub_46864(a1) >= a2 && (v4 = sub_46880(a1, a2)) != 0 && *v4 == 2 )
    return sub_469F0(v4);
  else
    return 0;
}

//----- (00028EC4) --------------------------------------------------------
char *__fastcall sub_28EC4(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)sub_28E64(a1, a2);
  if ( result )
    return _strdup(result);
  return result;
}

//----- (00028EDC) --------------------------------------------------------
int __fastcall sub_28EDC(const char *a1, const char *a2, int a3)
{
  const char *v3; // r4
  signed int v6; // r0
  int v7; // r3
  int v8; // r12
  int v9; // t1
  int result; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  v3 = a1;
  if ( a1 )
  {
    v6 = strlen(a1);
    if ( v6 <= 0 )
      return 1;
    v7 = *(unsigned __int8 *)v3;
    if ( (int)dword_51788[v7] >= 0 )
    {
      v8 = 0;
      while ( v6 != ++v8 )
      {
        v9 = *(unsigned __int8 *)++v3;
        v7 = v9;
        if ( (int)dword_51788[v9] < 0 )
          goto LABEL_10;
      }
      return 1;
    }
LABEL_10:
    if ( byte_632F0 || (result = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 2 )
    {
      snprintf(s, 0x800u, "Invalid char 0x%x passed to valid_hex from in %s %s():%d", v7, "util.c", a2, a3);
LABEL_14:
      sub_38438(3, s, 0);
      return 0;
    }
  }
  else if ( byte_632F0 || (result = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 2 )
  {
    snprintf(s, 0x800u, "Null string passed to valid_hex from in %s %s():%d", "util.c", a2, a3);
    goto LABEL_14;
  }
  return result;
}
// 51788: using guessed type _DWORD dword_51788[256];
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (00029018) --------------------------------------------------------
int __fastcall sub_29018(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (00029094) --------------------------------------------------------
int __fastcall sub_29094(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_wrlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (00029110) --------------------------------------------------------
int __fastcall sub_29110(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (0002918C) --------------------------------------------------------
int __fastcall sub_2918C(int a1, char *s, int a3)
{
  size_t v5; // r0
  signed int v6; // r10
  int v7; // r3
  int v8; // r5
  unsigned int v9; // r9
  _BYTE *v10; // r4
  int v11; // r8
  unsigned int v12; // r12
  int *v13; // r0
  _BYTE *v14; // r3
  ssize_t v15; // r0
  __int64 v16; // d16
  __int64 v18; // r2
  struct timeval timeout; // [sp+18h] [bp-8Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-84h] BYREF
  _BYTE v22[4]; // [sp+A0h] [bp-4h] BYREF

  v5 = strlen(s);
  v6 = a3 + 1;
  v7 = *(_DWORD *)(a1 + 580);
  *(_WORD *)&s[v5] = 10;
  if ( v6 <= 0 )
  {
    v16 = 0;
    goto LABEL_11;
  }
  v8 = v7 + 1;
  v9 = 0;
  v10 = &v22[4 * (v7 / 32)];
  v11 = 1 << (v7 % 32);
  while ( 2 )
  {
    v12 = 0;
    timeout.tv_usec = 0;
    timeout.tv_sec = 1;
    while ( 1 )
    {
      if ( v12 <= 0x1F )
        goto LABEL_7;
      *((_DWORD *)v10 - 32) |= v11;
      if ( select(v8, 0, &writefds, 0, &timeout) > 0 )
        break;
      v13 = _errno_location();
      v12 = 0;
      if ( *v13 != 4 )
        return 1;
LABEL_7:
      v14 = &v22[4 * v12++];
      *((_DWORD *)v14 - 32) = 0;
    }
    v15 = send(*(_DWORD *)(a1 + 580), &s[v9], v6, 0x4000);
    if ( v15 >= 0 )
      goto LABEL_9;
    if ( *_errno_location() != 11 )
      return 2;
    v15 = 0;
LABEL_9:
    v6 -= v15;
    v9 += v15;
    if ( v6 > 0 )
      continue;
    break;
  }
  v16 = vshrd_n_s64(vdup_n_s32(v9).n64_i64[0], 0x20u);
LABEL_11:
  *(_QWORD *)(a1 + 496) += v16;
  v18 = *(_QWORD *)(a1 + 488);
  *(_QWORD *)(a1 + 504) += v16;
  *(_QWORD *)(a1 + 488) = v18 + 1;
  return 0;
}

//----- (00029330) --------------------------------------------------------
int __fastcall sub_29330(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B7D8("tq_freezethaw", 1148);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_29110(v2, "tq_freezethaw", 1151);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();

//----- (00029394) --------------------------------------------------------
int __fastcall sub_29394(int a1)
{
  pthread_mutex_t *v1; // r5
  int v3; // r0

  v1 = (pthread_mutex_t *)(a1 + 672);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 672)) )
    sub_B7D8("clear_sock", 1831);
  do
    v3 = *(_DWORD *)(a1 + 580);
  while ( v3 && recv(v3, *(void **)(a1 + 584), 0x1FFCu, 0) > 0 );
  sub_29110(v1, "clear_sock", 1838);
  off_60178();
  return sub_286F8(a1);
}
// 60178: using guessed type int (*off_60178)();

//----- (00029418) --------------------------------------------------------
const char *__fastcall sub_29418(char *a1)
{
  char **v2; // r3
  const char *result; // r0

  if ( !a1 )
    return "http:";
  v2 = &off_51BA4;
  while ( 1 )
  {
    result = v2[2];
    v2 += 2;
    if ( !result )
      break;
    if ( v2[1] == a1 )
      return result;
  }
  return "invalid";
}
// 51BA4: using guessed type char *off_51BA4;

//----- (00029460) --------------------------------------------------------
_BYTE *__fastcall sub_29460(_BYTE *result, char *a2, int a3)
{
  _BYTE *v3; // r12
  char v4; // t1

  if ( a3 <= 0 )
  {
    v3 = result;
  }
  else
  {
    v3 = &result[2 * a3];
    do
    {
      *result = *((_BYTE *)&unk_51788 + ((unsigned __int8)*a2 >> 4) + 1108);
      v4 = *a2++;
      result[1] = *((_BYTE *)&unk_51788 + (v4 & 0xF) + 1108);
      result += 2;
    }
    while ( v3 != result );
  }
  *v3 = 0;
  return result;
}

//----- (000294B8) --------------------------------------------------------
_BYTE *__fastcall sub_294B8(int a1, int a2)
{
  int v2; // r8
  _BYTE *result; // r0
  _BYTE *v6; // r3
  _BYTE *v7; // r2
  int v8; // r3
  unsigned int v9; // r12
  char v10; // r1
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v2 = 2 * a2;
  result = calloc(4 - (v2 + 1) % 4 + v2 + 1, 1u);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc in %s %s():%d", "util.c", "bin2hex", 857);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v6 = result;
  if ( a2 > 0 )
  {
    v7 = result;
    v8 = 0;
    do
    {
      v9 = *(unsigned __int8 *)(a1 + v8++);
      v10 = *((_BYTE *)&unk_51788 + (v9 & 0xF) + 1108);
      LOBYTE(v9) = *((_BYTE *)&unk_51788 + (v9 >> 4) + 1108);
      v7[1] = v10;
      *v7 = v9;
      v7 += 2;
    }
    while ( v8 != a2 );
    v6 = &result[v2];
  }
  *v6 = 0;
  return result;
}

//----- (000295B8) --------------------------------------------------------
bool __fastcall sub_295B8(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  int v4; // r12
  unsigned __int8 *v5; // r1
  int v6; // r3
  int v7; // r12
  char v9[2052]; // [sp+0h] [bp-804h] BYREF

  v3 = *a2;
  if ( !*a2 )
    return a3 == 0;
  if ( a3 )
  {
    v4 = a2[1];
    if ( a2[1] )
    {
      v5 = a2 + 2;
      while ( 1 )
      {
        v6 = dword_51788[v3];
        v7 = dword_51788[v4];
        if ( (v7 | v6) < 0 )
          break;
        --a3;
        *a1++ = v7 | (16 * v6);
        v3 = *v5;
        if ( !*v5 )
          return a3 == 0;
        if ( !a3 )
          return 0;
        v4 = v5[1];
        v5 += 2;
        if ( !v4 )
          goto LABEL_11;
      }
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        strcpy(v9, "hex2bin scan failed");
        sub_38438(3, v9, 0);
        return 0;
      }
    }
    else
    {
LABEL_11:
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        strcpy(v9, "hex2bin str truncated");
        sub_38438(3, v9, 0);
      }
    }
  }
  return 0;
}
// 51788: using guessed type _DWORD dword_51788[256];
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (00029724) --------------------------------------------------------
bool __fastcall sub_29724(int a1, _DWORD *a2)
{
  int v2; // r10
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  _BOOL4 v6; // r9
  char *v8; // r6
  char *v9; // r7
  char *v10; // r8
  signed int v11; // r0
  int v12; // r3
  char *v13; // r1
  int v14; // r2
  int v15; // t1
  const char *v16; // r3
  int v17; // r1
  size_t v18; // r3
  bool v19; // r12
  int v20; // r2
  void *v21; // r0
  bool v22; // zf
  void *v23; // r0
  const char *v24; // r3
  __int64 v25; // r2
  int *v26; // lr
  int v27; // r0
  int v28; // r1
  int v29; // r2
  int v30; // r3
  int *v31; // lr
  int v32; // r0
  int v33; // r1
  int v34; // r2
  int v35; // r3
  int v36; // r0
  int v37; // r1
  int v38; // r2
  int v39; // r3
  int v40; // lr
  const char *v41; // r0
  char *v42; // r4
  bool v43; // cc
  unsigned int v44; // r9
  char *v45; // r0
  unsigned __int8 *v46; // r4
  const char *v47; // lr
  int v48; // r0
  int v49; // r1
  int v50; // r2
  int v51; // r3
  int *v52; // lr
  int v53; // r0
  int v54; // r1
  int v55; // r2
  int v56; // r3
  int v57; // r0
  int v58; // r1
  int v59; // r2
  int v60; // r3
  int v61; // r1
  _BYTE v62[4]; // [sp+18h] [bp-95Ch] BYREF
  _DWORD *v63; // [sp+1Ch] [bp-958h]
  int v64; // [sp+20h] [bp-954h]
  int v65; // [sp+24h] [bp-950h]
  pthread_rwlock_t *v66; // [sp+28h] [bp-94Ch]
  pthread_mutex_t *v67; // [sp+2Ch] [bp-948h]
  char *v68; // [sp+30h] [bp-944h]
  char *v69; // [sp+34h] [bp-940h]
  char *s; // [sp+38h] [bp-93Ch]
  char *v71; // [sp+3Ch] [bp-938h]
  char *v72; // [sp+40h] [bp-934h]
  size_t v73; // [sp+44h] [bp-930h]
  size_t nmemb; // [sp+48h] [bp-92Ch]
  size_t n; // [sp+4Ch] [bp-928h]
  _BOOL4 v76; // [sp+50h] [bp-924h]
  const char *v77; // [sp+54h] [bp-920h]
  const char *v78; // [sp+58h] [bp-91Ch]
  const char *v79; // [sp+5Ch] [bp-918h]
  void *src; // [sp+60h] [bp-914h]
  const char *v81; // [sp+64h] [bp-910h]
  unsigned __int8 v82[8]; // [sp+6Ch] [bp-908h] BYREF
  _DWORD v83[12]; // [sp+150h] [bp-824h] BYREF
  int v84; // [sp+180h] [bp-7F4h]
  __int16 v85; // [sp+184h] [bp-7F0h]
  char v86; // [sp+186h] [bp-7EEh]

  v2 = (int)a2;
  v4 = sub_46880(a2, 4u);
  v5 = v4;
  if ( !v4 )
    return 0;
  if ( *v4 != 1 )
    return 0;
  src = sub_46864(v4);
  v8 = sub_28EC4((_DWORD *)v2, 0);
  v81 = (const char *)sub_28E64((_DWORD *)v2, 1u);
  v9 = sub_28EC4((_DWORD *)v2, 2u);
  v10 = sub_28EC4((_DWORD *)v2, 3u);
  v79 = (const char *)sub_28E64((_DWORD *)v2, 5u);
  v78 = (const char *)sub_28E64((_DWORD *)v2, 6u);
  v77 = (const char *)sub_28E64((_DWORD *)v2, 7u);
  if ( sub_46880((_DWORD *)v2, 8u) )
    v76 = *sub_46880((_DWORD *)v2, 8u) == 5;
  else
    v76 = 0;
  if ( !v8 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
      goto LABEL_18;
    snprintf(
      (char *)v83,
      0x800u,
      "Null string passed to valid_ascii from in %s %s():%d",
      "util.c",
      "parse_notify",
      2005);
LABEL_84:
    sub_38438(3, (const char *)v83, 0);
LABEL_18:
    v6 = 0;
    free(v8);
    free(v9);
    free(v10);
    return v6;
  }
  v11 = strlen(v8);
  if ( !v11 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
      goto LABEL_18;
    snprintf(
      (char *)v83,
      0x800u,
      "Zero length string passed to valid_ascii from in %s %s():%d",
      "util.c",
      "parse_notify",
      2005);
    goto LABEL_84;
  }
  if ( v11 <= 0 )
    goto LABEL_17;
  v12 = (unsigned __int8)*v8;
  if ( (unsigned int)(v12 - 32) > 0x5E )
  {
LABEL_80:
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
      goto LABEL_18;
    snprintf(
      (char *)v83,
      0x800u,
      "Invalid char 0x%x passed to valid_ascii from in %s %s():%d",
      v12,
      "util.c",
      "parse_notify",
      2005);
    goto LABEL_84;
  }
  v13 = v8;
  v14 = 0;
  while ( v11 != ++v14 )
  {
    v15 = (unsigned __int8)*++v13;
    v12 = v15;
    if ( (unsigned int)(v15 - 32) > 0x5E )
      goto LABEL_80;
  }
LABEL_17:
  if ( !sub_28EDC(v81, "parse_notify", 2005)
    || !sub_28EDC(v9, "parse_notify", 2005)
    || !sub_28EDC(v10, "parse_notify", 2006)
    || !sub_28EDC(v79, "parse_notify", 2006)
    || !sub_28EDC(v78, "parse_notify", 2006)
    || !sub_28EDC(v77, "parse_notify", 2007) )
  {
    goto LABEL_18;
  }
  v67 = (pthread_mutex_t *)(a1 + 212);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 212)) )
    sub_B7D8("parse_notify", 2015);
  v66 = (pthread_rwlock_t *)(a1 + 236);
  s = (char *)(a1 + 1680);
  v71 = (char *)(a1 + 1760);
  sub_29094((pthread_rwlock_t *)(a1 + 236), "parse_notify", 2015);
  free(*(void **)(a1 + 640));
  v16 = v81;
  *(_DWORD *)(a1 + 640) = v8;
  snprintf(s, 0x41u, "%s", v16);
  v68 = v71 + 12;
  n = strlen(v9) >> 1;
  v69 = (char *)(a1 + 1748);
  v73 = strlen(v10) >> 1;
  snprintf((char *)(a1 + 1748), 9u, "%s", v79);
  snprintf(v71, 9u, "%s", v78);
  snprintf(v71 + 12, 9u, "%s", v77);
  v17 = *(_DWORD *)(a1 + 1676);
  v18 = n + *(_DWORD *)(a1 + 1532);
  v19 = v76;
  v20 = *(_DWORD *)(a1 + 624);
  *(_DWORD *)(a1 + 1544) = v18;
  *(_BYTE *)(a1 + 648) = v19;
  if ( v17 > 0 )
    v2 = 0;
  nmemb = v73 + v20 + v18;
  *(_DWORD *)(a1 + 1540) = nmemb;
  if ( v17 > 0 )
  {
    do
    {
      v21 = *(void **)(*(_DWORD *)(a1 + 644) + 4 * v2++);
      free(v21);
    }
    while ( *(_DWORD *)(a1 + 1676) > v2 );
  }
  if ( src )
  {
    v43 = (int)src <= 0;
    *(_DWORD *)(a1 + 644) = realloc(*(void **)(a1 + 644), 4 * (_DWORD)src + 1);
    if ( !v43 )
    {
      v44 = 0;
      v63 = v5;
      v72 = &byte_63928;
      while ( 1 )
      {
        v45 = sub_28EC4(v63, v44);
        v64 = *(_DWORD *)(a1 + 644);
        v46 = (unsigned __int8 *)v45;
        v65 = 4 * v44;
        *(_DWORD *)(v64 + 4 * v44) = malloc(0x20u);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 644) + 4 * v44) )
        {
          strcpy((char *)v83, "Failed to malloc pool swork merkle_bin");
          sub_38438(3, (const char *)v83, 1);
          sub_16724(1);
        }
        if ( *v72 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf((char *)v83, 0x800u, "merkle %d: %s", v44, v46);
          sub_38438(7, (const char *)v83, 0);
        }
        ++v44;
        v64 = sub_295B8(*(_BYTE **)(*(_DWORD *)(a1 + 644) + v65), v46, 32);
        free(v46);
        if ( !v64 )
          break;
        if ( src == (void *)v44 )
          goto LABEL_32;
      }
      v6 = 0;
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        v47 = "Failed to convert merkle to merkle_bin in parse_notify";
        goto LABEL_127;
      }
      goto LABEL_91;
    }
  }
  v72 = &byte_63928;
LABEL_32:
  v22 = !v76;
  *(_DWORD *)(a1 + 1676) = src;
  if ( !v22 )
    *(_QWORD *)(a1 + 616) = 0;
  snprintf(
    (char *)v82,
    0xE1u,
    "%s%s%s%s%s%s%s",
    v69,
    s,
    "0000000000000000000000000000000000000000000000000000000000000000",
    v68,
    v71,
    "00000000",
    off_60150);
  v6 = sub_295B8((_BYTE *)(a1 + 1548), v82, 112);
  if ( !v6 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      v47 = "Failed to convert header to header_bin in parse_notify";
LABEL_127:
      v48 = *(_DWORD *)v47;
      v49 = *((_DWORD *)v47 + 1);
      v50 = *((_DWORD *)v47 + 2);
      v51 = *((_DWORD *)v47 + 3);
      v52 = (int *)(v47 + 16);
      v83[0] = v48;
      v83[1] = v49;
      v83[2] = v50;
      v83[3] = v51;
      v53 = *v52;
      v54 = v52[1];
      v55 = v52[2];
      v56 = v52[3];
      v52 += 4;
      v83[4] = v53;
      v83[5] = v54;
      v83[6] = v55;
      v83[7] = v56;
      v57 = *v52;
      v58 = v52[1];
      v59 = v52[2];
      v60 = v52[3];
      v52 += 4;
      v83[8] = v57;
      v83[9] = v58;
      v83[10] = v59;
      v83[11] = v60;
      v61 = v52[1];
      v84 = *v52;
      v85 = v61;
      v86 = BYTE2(v61);
      sub_38438(3, (const char *)v83, 0);
      goto LABEL_41;
    }
    goto LABEL_91;
  }
  v6 = sub_295B8(v62, (unsigned __int8 *)v9, n);
  if ( !v6 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      v26 = (int *)&unk_52520;
      goto LABEL_90;
    }
LABEL_91:
    v6 = 0;
    goto LABEL_41;
  }
  src = v62;
  v6 = sub_295B8(v62, (unsigned __int8 *)v10, v73);
  if ( !v6 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      v26 = (int *)&unk_52554;
LABEL_90:
      v27 = *v26;
      v28 = v26[1];
      v29 = v26[2];
      v30 = v26[3];
      v31 = v26 + 4;
      v83[0] = v27;
      v83[1] = v28;
      v83[2] = v29;
      v83[3] = v30;
      v32 = *v31;
      v33 = v31[1];
      v34 = v31[2];
      v35 = v31[3];
      v31 += 4;
      v83[4] = v32;
      v83[5] = v33;
      v83[6] = v34;
      v83[7] = v35;
      v36 = *v31;
      v37 = v31[1];
      v38 = v31[2];
      v39 = v31[3];
      v40 = v31[4];
      v83[8] = v36;
      v83[9] = v37;
      v83[10] = v38;
      v83[11] = v39;
      LOBYTE(v84) = v40;
      sub_38438(3, (const char *)v83, 0);
      goto LABEL_41;
    }
    goto LABEL_91;
  }
  free(*(void **)(a1 + 1536));
  if ( (nmemb & 3) != 0 )
    nmemb = (nmemb & 0xFFFFFFFC) + 4;
  v23 = calloc(nmemb, 1u);
  *(_DWORD *)(a1 + 1536) = v23;
  if ( !v23 )
  {
    strcpy((char *)v83, "Failed to calloc pool coinbase in parse_notify");
    sub_38438(3, (const char *)v83, 1);
    sub_16724(1);
  }
  memcpy(*(void **)(a1 + 1536), v62, n);
  memcpy((void *)(*(_DWORD *)(a1 + 1536) + n), *(const void **)(a1 + 608), *(_DWORD *)(a1 + 1532));
  memcpy((void *)(*(_DWORD *)(a1 + 1536) + *(_DWORD *)(a1 + 624) + *(_DWORD *)(a1 + 1532) + n), src, v73);
  if ( byte_630C1 )
  {
    v41 = sub_294B8(*(_DWORD *)(a1 + 1536), *(_DWORD *)(a1 + 1540));
    v42 = (char *)v41;
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf((char *)v83, 0x800u, "Pool %d coinbase %s", *(_DWORD *)a1, v41);
      sub_38438(7, (const char *)v83, 0);
    }
    free(v42);
  }
LABEL_41:
  sub_29018(v66, "parse_notify", 2103);
  sub_29110(v67, "parse_notify", 2103);
  off_60178();
  if ( *v72 && byte_630C1 )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
    {
      snprintf((char *)v83, 0x800u, "job_id: %s", v8);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
        goto LABEL_51;
    }
    if ( byte_630C0 || dword_60964 > 6 )
    {
LABEL_51:
      snprintf((char *)v83, 0x800u, "prev_hash: %s", v81);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
        goto LABEL_55;
    }
    if ( byte_630C0 || dword_60964 > 6 )
    {
LABEL_55:
      snprintf((char *)v83, 0x800u, "coinbase1: %s", v9);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
        goto LABEL_59;
    }
    if ( byte_630C0 || dword_60964 > 6 )
    {
LABEL_59:
      snprintf((char *)v83, 0x800u, "coinbase2: %s", v10);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
        goto LABEL_63;
    }
    if ( byte_630C0 || dword_60964 > 6 )
    {
LABEL_63:
      snprintf((char *)v83, 0x800u, "bbversion: %s", v79);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
        goto LABEL_67;
    }
    if ( byte_630C0 || dword_60964 > 6 )
    {
LABEL_67:
      snprintf((char *)v83, 0x800u, "nbit: %s", v78);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
        goto LABEL_70;
    }
    if ( byte_630C0 || dword_60964 > 6 )
    {
LABEL_70:
      snprintf((char *)v83, 0x800u, "ntime: %s", v77);
      sub_38438(7, (const char *)v83, 0);
      if ( !byte_630C1 )
        goto LABEL_77;
      if ( byte_632F0 )
      {
LABEL_74:
        v24 = "yes";
        if ( !v76 )
          v24 = dword_52370;
        snprintf((char *)v83, 0x800u, "clean: %s", v24);
        sub_38438(7, (const char *)v83, 0);
        goto LABEL_77;
      }
    }
    if ( byte_630C0 || dword_60964 > 6 )
      goto LABEL_74;
  }
LABEL_77:
  free(v9);
  free(v10);
  v25 = *(_QWORD *)&dword_63BE8;
  ++*(_DWORD *)(a1 + 116);
  *(_QWORD *)&dword_63BE8 = v25 + 1;
  if ( a1 == sub_1D644() )
    byte_63E4C = 1;
  return v6;
}
// 60150: using guessed type char *off_60150;
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63928: using guessed type char byte_63928;
// 63BE8: using guessed type int dword_63BE8;
// 63E4C: using guessed type char byte_63E4C;

//----- (0002A5B4) --------------------------------------------------------
_BYTE *__fastcall sub_2A5B4(_BYTE *a1, char *s)
{
  unsigned int v2; // r4
  signed int v4; // r0
  int v5; // r9
  int *v6; // r12
  int v7; // r8
  int v8; // r3
  __int64 v9; // r2
  char v10; // r12
  unsigned int v11; // r2
  unsigned int *v12; // r1
  _BYTE *result; // r0
  _BYTE *v14; // r3
  unsigned int v15; // t1
  int v17; // [sp+Ch] [bp-20h] BYREF
  unsigned int v18[5]; // [sp+10h] [bp-1Ch] BYREF
  unsigned int v19; // [sp+24h] [bp-8h]

  v2 = 0;
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  v4 = strlen(s);
  if ( v4 <= 0 )
  {
    v11 = 0;
    v10 = 0;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = &v17;
      v7 = 6;
      v8 = *((_DWORD *)&unk_51788 + (unsigned __int8)s[v5] + 287);
      while ( 1 )
      {
        v9 = 58LL * v2 + (unsigned int)v8;
        --v7;
        v8 = BYTE4(v9) & 0x3F;
        v6[6] = v9;
        --v6;
        if ( v7 == -1 )
          break;
        v2 = v6[6];
      }
      if ( v4 == ++v5 )
        break;
      v2 = v19;
    }
    v10 = v17;
    v11 = bswap32(v18[0]);
  }
  v12 = v18;
  result = a1 + 29;
  *a1 = v10;
  v14 = a1 + 5;
  while ( 1 )
  {
    *((_DWORD *)v14 - 1) = v11;
    v14 += 4;
    if ( v14 == result )
      break;
    v15 = v12[1];
    ++v12;
    v11 = bswap32(v15);
  }
  return result;
}

//----- (0002A740) --------------------------------------------------------
int __fastcall sub_2A740(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    LOWORD(v5) = 16511;
    if ( a2 > 16511 )
    {
      HIWORD(v5) = 32;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (0002A898) --------------------------------------------------------
int __fastcall sub_2A898(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r12
  unsigned int *v3; // r2
  int v4; // r3
  unsigned int v5; // r5
  unsigned int v6; // t1
  unsigned int v7; // t1
  bool v8; // cf
  int v9; // r5
  unsigned int v11; // r8
  unsigned int v12; // lr
  unsigned int v13; // r12
  unsigned int v14; // r9
  unsigned int v15; // r2
  unsigned int v16; // r11
  unsigned int v17; // r3
  unsigned int v18; // r7
  unsigned int v19; // r10
  unsigned int v20; // r8
  unsigned int v21; // lr
  unsigned int v22; // r12
  unsigned int v23; // r2
  unsigned int v24; // r3
  unsigned int v25; // r6
  char *v26; // r7
  const char *v27; // r0
  char *v28; // r6
  const char *v29; // r3
  _DWORD v30[8]; // [sp+8h] [bp-844h] BYREF
  _DWORD v31[8]; // [sp+28h] [bp-824h] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  v4 = 7;
  while ( 1 )
  {
    v6 = *--v2;
    v5 = v6;
    --v4;
    v7 = *--v3;
    v8 = v5 >= v7;
    if ( v5 > v7 )
      break;
    if ( !v8 || v4 == -1 )
    {
      v9 = 1;
      goto LABEL_7;
    }
  }
  v9 = 0;
LABEL_7:
  if ( byte_630C1 )
  {
    v11 = bswap32(a1[6]);
    v12 = bswap32(a1[5]);
    v13 = bswap32(a1[4]);
    v14 = a1[1];
    v15 = bswap32(a1[3]);
    v16 = *a1;
    v17 = bswap32(a1[2]);
    v18 = a2[7];
    v30[0] = bswap32(a1[7]);
    v19 = a2[6];
    v30[1] = v11;
    v30[2] = v12;
    v20 = a2[5];
    v21 = a2[4];
    v30[3] = v13;
    v22 = a2[3];
    v30[4] = v15;
    v30[5] = v17;
    v23 = a2[2];
    v24 = a2[1];
    v25 = *a2;
    v31[0] = bswap32(v18);
    v31[6] = bswap32(v24);
    v31[3] = bswap32(v21);
    v31[4] = bswap32(v22);
    v31[5] = bswap32(v23);
    v31[7] = bswap32(v25);
    v30[6] = bswap32(v14);
    v30[7] = bswap32(v16);
    v31[1] = bswap32(v19);
    v31[2] = bswap32(v20);
    v26 = sub_294B8((int)v30, 32);
    v27 = sub_294B8((int)v31, 32);
    v28 = (char *)v27;
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      v29 = "YES (hash <= target)";
      if ( !v9 )
        v29 = "no (false positive; hash > target)";
      snprintf(s, 0x800u, " Proof: %s\nTarget: %s\nTrgVal? %s", v26, v27, v29);
      sub_38438(7, s, 0);
    }
    free(v26);
    free(v28);
  }
  return v9;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0002AA90) --------------------------------------------------------
char *sub_2AA90()
{
  char *v0; // r0
  char *v1; // r4

  v0 = (char *)calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = v0;
    *((_DWORD *)v0 + 1) = v0;
    pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
    pthread_cond_init((pthread_cond_t *)(v1 + 40), 0);
  }
  return v1;
}

//----- (0002AAD0) --------------------------------------------------------
void __fastcall sub_2AAD0(char *a1)
{
  int v1; // r5
  _DWORD *v3; // r3
  int v4; // r2
  _DWORD *v5; // r4
  _DWORD *v6; // r1
  bool v7; // zf

  if ( a1 )
  {
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = **(_DWORD **)a1;
    if ( a1 != *(char **)a1 )
      v1 = 0;
    v5 = (_DWORD *)(v4 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v6 = (_DWORD *)v3[2];
        *(_DWORD *)(v4 + 4) = v6;
        *v6 = v4;
        v3[1] = v1;
        v3[2] = v1;
        free(v3);
        v4 = v5[1];
        v3 = v5;
        v7 = v5 + 1 == (_DWORD *)a1;
        v5 = (_DWORD *)(v4 - 4);
      }
      while ( !v7 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    memset(a1, 0, 0x58u);
    free(a1);
  }
}
// 2AB08: variable 'v1' is possibly undefined

//----- (0002AB58) --------------------------------------------------------
int __fastcall sub_2AB58(int a1)
{
  return sub_29330(a1, 1);
}

//----- (0002AB60) --------------------------------------------------------
int __fastcall sub_2AB60(int a1)
{
  return sub_29330(a1, 0);
}

//----- (0002AB68) --------------------------------------------------------
int __fastcall sub_2AB68(int a1, int a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r6
  int v6; // r8
  _DWORD *v7; // r4
  _DWORD *v8; // r3

  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( !v4 )
    return 0;
  *v4 = a2;
  v7 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B7D8("tq_push", 1176);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v6 = 0;
    free(v5);
  }
  else
  {
    v8 = *(_DWORD **)(a1 + 4);
    v6 = 1;
    *(_DWORD *)(a1 + 4) = v7;
    v5[1] = a1;
    v5[2] = v8;
    *v8 = v7;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_29110((pthread_mutex_t *)(a1 + 12), "tq_push", 1184);
  off_60178();
  return v6;
}
// 60178: using guessed type int (*off_60178)();

//----- (0002AC28) --------------------------------------------------------
int __fastcall sub_2AC28(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r5
  int *v5; // r3
  _DWORD *v6; // r1
  int v7; // r12
  int v8; // r4
  int v10; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B7D8("tq_pop", 1195);
  v5 = *(int **)a1;
  if ( a1 != *(_DWORD *)a1 )
    goto LABEL_3;
  if ( a2 )
    v10 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), v2, a2);
  else
    v10 = pthread_cond_wait((pthread_cond_t *)(a1 + 40), v2);
  if ( v10 )
  {
    v8 = 0;
    goto LABEL_4;
  }
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v8 = 0;
  }
  else
  {
LABEL_3:
    v6 = (_DWORD *)v5[1];
    v7 = *v5;
    v8 = *(v5 - 1);
    *(_DWORD *)(v7 + 4) = v6;
    *v6 = v7;
    *v5 = 0;
    v5[1] = 0;
    free(v5 - 1);
  }
LABEL_4:
  sub_29110(v2, "tq_pop", 1214);
  off_60178();
  return v8;
}
// 60178: using guessed type int (*off_60178)();

//----- (0002AD04) --------------------------------------------------------
int __fastcall sub_2AD04(int result)
{
  int v1; // r4
  pthread_t v2; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      *(_DWORD *)(v1 + 12) = 0;
    }
    return sem_destroy((sem_t *)(v1 + 16));
  }
  return result;
}

//----- (0002AD38) --------------------------------------------------------
int __fastcall sub_2AD38(_DWORD *a1, int *a2)
{
  int v2; // r3
  int v3; // r2
  int result; // r0
  int v5; // r3

  v2 = a2[1];
  v3 = *a1 - *a2;
  *a2 = v3;
  result = a1[1];
  v5 = result - v2;
  a2[1] = v5;
  if ( v5 < 0 )
  {
    *a2 = v3 - 1;
    a2[1] = v5 + 1000000;
  }
  return result;
}

//----- (0002AD6C) --------------------------------------------------------
int __fastcall sub_2AD6C(_DWORD *a1, int *a2)
{
  int v2; // r3
  int v3; // r12
  int result; // r0
  int v5; // r3

  v2 = a2[1];
  v3 = *a1 + *a2;
  *a2 = v3;
  result = a1[1];
  v5 = result + v2;
  a2[1] = v5;
  if ( v5 > 999999 )
  {
    *a2 = v3 + 1;
    a2[1] = v5 - 1000000;
  }
  return result;
}

//----- (0002ADB8) --------------------------------------------------------
bool __fastcall sub_2ADB8(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (0002ADEC) --------------------------------------------------------
bool __fastcall sub_2ADEC(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (0002AE20) --------------------------------------------------------
_DWORD *__fastcall sub_2AE20(_DWORD *result, _DWORD *a2)
{
  int v2; // r3

  v2 = a2[1];
  *result = *a2;
  result[1] = v2;
  return result;
}

//----- (0002AE34) --------------------------------------------------------
_DWORD *__fastcall sub_2AE34(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (0002AE5C) --------------------------------------------------------
_DWORD *__fastcall sub_2AE5C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (0002AE78) --------------------------------------------------------
int __fastcall sub_2AE78(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AF78: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002AEB0) --------------------------------------------------------
int __fastcall sub_2AEB0(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AF78: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002AEF0) --------------------------------------------------------
int __fastcall sub_2AEF0(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AF78: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002AF38) --------------------------------------------------------
int __fastcall sub_2AF38(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AF78: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002AF78) --------------------------------------------------------
int *__fastcall sub_2AF78(int *result, _DWORD *a2)
{
  int v2; // r4
  int v3; // r2
  int v4; // r3
  int v5; // r2
  int v6; // r1
  int v7; // r2
  int v8; // r1

  v2 = result[1];
  v3 = *result + *a2;
  *result = v3;
  v4 = v2 + a2[1];
  result[1] = v4;
  if ( v4 > 999999999 )
  {
    v5 = v3 + 1;
    do
    {
      v6 = v5++;
      v4 -= 1000000000;
    }
    while ( v4 > 999999999 );
    *result = v6;
    result[1] = v4;
  }
  if ( v4 < 0 )
  {
    v7 = *result - 1;
    do
    {
      v8 = v7--;
      v4 += 1000000000;
    }
    while ( v4 < 0 );
    *result = v8;
    result[1] = v4;
  }
  return result;
}

//----- (0002B008) --------------------------------------------------------
const char *__fastcall sub_2B008(const char *a1, const char *a2, int a3, int a4)
{
  bool v4; // zf
  signed int v7; // r10
  size_t v8; // r0
  bool v9; // zf
  int v10; // r4
  const __int32_t **v11; // r0
  int v12; // r3
  const __int32_t *v13; // r1
  const __int32_t **v14; // r0
  int v15; // r3
  const __int32_t *v16; // r1
  char *v17; // r0
  int v19; // [sp+0h] [bp-24h] BYREF

  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  v19 = a4;
  if ( v4 )
    return 0;
  v7 = strlen(a1);
  v8 = strlen(a2);
  v9 = v7 == 0;
  if ( v7 )
    v9 = v8 == 0;
  v10 = v8;
  if ( v9 )
    return 0;
  if ( v7 > 0 )
  {
    v11 = _ctype_tolower_loc();
    v12 = 0;
    v13 = *v11;
    do
    {
      *((_BYTE *)&v19 + v12) = v13[(unsigned __int8)a1[v12]];
      ++v12;
    }
    while ( v7 != v12 );
  }
  if ( v10 > 0 )
  {
    v14 = _ctype_tolower_loc();
    v15 = 0;
    v16 = *v14;
    do
    {
      *((_BYTE *)&v19 + v15) = v16[(unsigned __int8)a2[v15]];
      ++v15;
    }
    while ( v10 != v15 );
  }
  v17 = strstr((const char *)&v19, (const char *)&v19);
  if ( !v17 )
    return 0;
  else
    return &a1[v17 - (char *)&v19];
}

//----- (0002B0F0) --------------------------------------------------------
const char *__fastcall sub_2B0F0(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (0002B13C) --------------------------------------------------------
int __fastcall sub_2B13C(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (0002B144) --------------------------------------------------------
int __fastcall sub_2B144(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (0002B16C) --------------------------------------------------------
int __fastcall sub_2B16C(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r12
  int result; // r0
  int v5; // r3

  v3 = *a1 - *a2;
  *a3 = v3;
  result = a1[1];
  v5 = result - a2[1];
  if ( v5 < 0 )
  {
    *a3 = v3 - 1;
    a3[1] = v5 + 1000000000;
  }
  else
  {
    a3[1] = v5;
  }
  return result;
}

//----- (0002B1A8) --------------------------------------------------------
int __fastcall sub_2B1A8(struct timespec *tp)
{
  return clock_gettime(1, tp);
}

//----- (0002B1B4) --------------------------------------------------------
int __fastcall sub_2B1B4(_DWORD *a1)
{
  struct timespec v3; // [sp+0h] [bp-8h] BYREF

  sub_2AEF0(&v3);
  sub_2AF78(&v3.tv_sec, a1);
  return sub_28E3C(&v3);
}

//----- (0002B1EC) --------------------------------------------------------
int __fastcall sub_2B1EC(_DWORD *a1)
{
  struct timespec v3; // [sp+0h] [bp-8h] BYREF

  sub_2AEB0(&v3);
  sub_2AF78(&v3.tv_sec, a1);
  return sub_28E3C(&v3);
}

//----- (0002B21C) --------------------------------------------------------
int sub_2B21C()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  sub_2B1A8(&v1);
  return sub_2B1B4(&v1);
}

//----- (0002B244) --------------------------------------------------------
int sub_2B244()
{
  struct timespec tp; // [sp+8h] [bp-Ch] BYREF

  sub_2B1A8(&tp);
  return sub_2B1EC(&tp);
}

//----- (0002B278) --------------------------------------------------------
_DWORD *__fastcall sub_2B278(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return (_DWORD *)result[1];
  return result;
}

//----- (0002B314) --------------------------------------------------------
void sub_2B314()
{
  ;
}

//----- (0002B358) --------------------------------------------------------
void __fastcall sub_2B358(int a1, char *s)
{
  char *v3; // r0
  char *v4; // r6
  char v5[16]; // [sp+0h] [bp-810h] BYREF
  char sa[2048]; // [sp+10h] [bp-800h] BYREF

  v3 = strchr(s, 35);
  v4 = v3;
  if ( v3 )
  {
    if ( !*(_BYTE *)(a1 + 572) )
    {
      strcpy(v5, v3);
      *v4 = 0;
      if ( !strcmp(v5, "#xnsub") )
      {
        *(_BYTE *)(a1 + 572) = 1;
        if ( byte_630C1 )
        {
          if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
          {
            snprintf(sa, 0x800u, "Pool %d extranonce subscribing enabled.", *(_DWORD *)a1);
            sub_38438(7, sa, 0);
          }
        }
      }
    }
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0002B43C) --------------------------------------------------------
int __fastcall sub_2B43C(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r5
  char *v8; // r0
  bool v9; // zf
  char *v10; // r8
  int v11; // r9
  char *v12; // r11
  int v13; // r6
  signed int v14; // r12
  const char *v15; // r11
  char *v16; // r0
  int v17; // r3
  char *v19; // r0
  size_t v20; // r0
  signed int v21; // [sp+Ch] [bp-110h]
  char v22[8]; // [sp+10h] [bp-10Ch] BYREF
  char s[260]; // [sp+18h] [bp-104h] BYREF

  *a2 = a1;
  v4 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = v8 == 0;
  if ( v8 )
    v9 = v7 == 0;
  v10 = v8;
  v11 = !v9;
  if ( v9 || v7 >= v8 )
    v8 = (char *)v4;
  v12 = strchr(v8, 58);
  if ( v12 )
  {
    v13 = v12 - v4;
    v14 = ~(v12 - v4) + strlen(v4);
    if ( v14 <= 0 )
      return 0;
    v15 = v12 + 1;
  }
  else
  {
    v20 = strlen(v4);
    v14 = 0;
    v15 = 0;
    v13 = v20;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v11 && v7 < v10 )
  {
    v13 -= 2;
    ++v4;
  }
  v21 = v14;
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v21 )
  {
    snprintf(v22, 6u, "%.*s", v21, v15);
    v19 = strchr(v22, 47);
    if ( v19 )
      *v19 = 0;
  }
  else
  {
    strcpy(v22, "80");
  }
  *a3 = _strdup(v22);
  v16 = _strdup(s);
  v17 = 1;
  *a2 = v16;
  return v17;
}

//----- (0002B5C8) --------------------------------------------------------
char *__fastcall sub_2B5C8(char *s1, int a2)
{
  const char *v2; // r4
  int v5; // r5
  size_t v6; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v2 = "http:";
  v5 = 0;
  v6 = 5;
  *(_DWORD *)(a2 + 184) = 0;
  while ( strncmp(s1, v2, v6) )
  {
    ++v5;
    v2 = (&off_51BA4)[2 * v5];
    if ( !v2 )
      return s1;
    v6 = strlen((&off_51BA4)[2 * v5]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)malloc(v7 - s1 + 1 - v6);
    *(_DWORD *)(a2 + 184) = v9;
    if ( !v9 )
    {
      snprintf(s, 0x800u, "Failed to malloc rpc_proxy in %s %s():%d", "util.c", "get_proxy", 819);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    v10 = &s1[v6];
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_2B43C(*(const char **)(a2 + 184), (_DWORD *)(a2 + 596), (char **)(a2 + 600));
    *(_DWORD *)(a2 + 180) = dword_51788[2 * v5 + 264];
  }
  return s1;
}
// 51788: using guessed type _DWORD dword_51788[256];
// 51BA4: using guessed type char *off_51BA4;

//----- (0002B6F8) --------------------------------------------------------
bool __fastcall sub_2B6F8(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 584);
  return *v1 || sub_2870C(a1, (unsigned __int8)*v1);
}

//----- (0002B714) --------------------------------------------------------
void **__fastcall sub_2B714(void **result, unsigned int a2, size_t size, const char *a4, const char *a5, int a6)
{
  void **v8; // r6
  char s[2052]; // [sp+8h] [bp-804h] BYREF

  v8 = result;
  if ( size != a2 )
  {
    result = (void **)realloc(*result, size);
    *v8 = result;
    if ( !result )
    {
      snprintf(s, 0x800u, "Failed to realloc in %s %s():%d", a4, a5, a6);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    if ( size > a2 )
      return (void **)memset((char *)*v8 + a2, 0, size - a2);
  }
  return result;
}

//----- (0002B7C0) --------------------------------------------------------
int __fastcall sub_2B7C0(pthread_mutex_t *a1)
{
  int count; // r0
  int *v4; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "Closing socket for stratum pool %d", a1->__lock);
    sub_38438(7, s, 0);
  }
  if ( pthread_mutex_lock(a1 + 28) )
    sub_B7D8("suspend_stratum", 2878);
  sub_286F8((int)a1);
  count = a1[24].__count;
  a1[26].__size[11] = 0;
  a1[26].__size[9] = 0;
  if ( count )
    close(count);
  a1[24].__count = 0;
  if ( pthread_mutex_unlock(a1 + 28) )
  {
    v4 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 2880);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0002B920) --------------------------------------------------------
char *__fastcall sub_2B920(int a1)
{
  char *v1; // r4
  signed int v3; // r5
  char *v4; // r0
  char *v5; // r7
  size_t v6; // r0
  signed int v7; // r4
  __int64 v8; // r0
  __int64 v9; // r8
  char *v11; // r10
  size_t v12; // r11
  size_t v13; // r9
  unsigned int v14; // r0
  bool v15; // cc
  ssize_t v16; // r4
  bool v17; // nf
  int v18; // r4
  size_t v19; // r11
  char *v20; // r0
  struct timeval v21; // [sp+8h] [bp-2814h] BYREF
  struct timeval v22; // [sp+10h] [bp-280Ch] BYREF
  char s[2040]; // [sp+18h] [bp-2804h] BYREF
  char v24[8196]; // [sp+818h] [bp-2004h] BYREF

  v1 = *(char **)(a1 + 584);
  if ( !strchr(v1, 10) )
  {
    sub_2B13C(&v21);
    if ( !sub_2870C(a1, 60) )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy(v24, "Timed out waiting for data on socket_full");
        sub_38438(7, v24, 0);
      }
      goto LABEL_18;
    }
    while ( 1 )
    {
      memset(v24, 0, 0x2000u);
      v16 = recv(*(_DWORD *)(a1 + 580), v24, 0x1FFCu, 0);
      if ( !v16 )
        break;
      sub_2B13C(&v22);
      v17 = v16 < 0;
      v18 = (int)((double)(v22.tv_sec - v21.tv_sec) + (double)(v22.tv_usec - v21.tv_usec) / 1000000.0);
      if ( v17 )
      {
        if ( *_errno_location() != 11 || !sub_2870C(a1, 60 - v18) )
        {
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            strcpy(s, "Failed to recv sock in recv_line");
            sub_38438(7, s, 0);
          }
          goto LABEL_38;
        }
      }
      else
      {
        v11 = *(char **)(a1 + 584);
        v12 = strlen(v24);
        v13 = strlen(v11);
        v14 = v12 + v13 + 1;
        if ( v14 >= *(_DWORD *)(a1 + 588) )
        {
          v19 = (v14 & 0xFFFFE000) + 0x2000;
          v20 = (char *)realloc(v11, v19);
          *(_DWORD *)(a1 + 584) = v20;
          if ( !v20 )
          {
            snprintf(s, 0x800u, "Failed to realloc pool sockbuf in %s %s():%d", "util.c", "recalloc_sock", 1871);
            sub_38438(3, s, 1);
            sub_16724(1);
          }
          memset(&v20[v13], 0, v19 - v13);
          v11 = *(char **)(a1 + 584);
          *(_DWORD *)(a1 + 588) = v19;
        }
        strcat(v11, v24);
      }
      v15 = v18 <= 59;
      v1 = *(char **)(a1 + 584);
      if ( !v15 || strchr(*(const char **)(a1 + 584), 10) )
        goto LABEL_2;
    }
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(s, "Socket closed waiting in recv_line");
      sub_38438(7, s, 0);
    }
LABEL_38:
    sub_2B7C0((pthread_mutex_t *)a1);
    v1 = *(char **)(a1 + 584);
  }
LABEL_2:
  v3 = strlen(v1);
  v4 = strtok(v1, ptr);
  if ( !v4 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(v24, "Failed to parse a \\n terminated string in recv_line");
      sub_38438(7, v24, 0);
    }
    goto LABEL_18;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( v3 > (int)(v6 + 1) )
    memmove(*(void **)(a1 + 584), (const void *)(*(_DWORD *)(a1 + 584) + v6 + 1), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 584) = 0;
  v8 = *(_QWORD *)(a1 + 528);
  v9 = *(_QWORD *)(a1 + 520) + v7;
  ++*(_QWORD *)(a1 + 512);
  *(_QWORD *)(a1 + 520) = v9;
  *(_QWORD *)(a1 + 528) = v7 + v8;
  if ( !v5 )
  {
LABEL_18:
    v5 = 0;
    sub_29394(a1);
    return v5;
  }
  if ( byte_63928 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v24, 0x800u, "RECVD: %s", v5);
    sub_38438(7, v24, 0);
  }
  return v5;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63928: using guessed type char byte_63928;

//----- (0002BEA8) --------------------------------------------------------
int __fastcall sub_2BEA8(pthread_mutex_t *a1, char *a2, int a3)
{
  int v6; // r7
  int v7; // r5
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_63928 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "SEND: %s", a2);
    sub_38438(7, s, 0);
  }
  if ( pthread_mutex_lock(a1 + 28) )
    sub_B7D8("stratum_send", 1770);
  if ( a1[26].__size[9] )
  {
    v7 = sub_2918C((int)a1, a2, a3);
    v6 = v7 == 0;
  }
  else
  {
    v6 = (unsigned __int8)a1[26].__size[9];
    v7 = 3;
  }
  if ( pthread_mutex_unlock(a1 + 28) )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1773);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  off_60178();
  if ( v7 == 2 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(s, "Failed to send in stratum_send");
      sub_38438(7, s, 0);
      sub_2B7C0(a1);
      return v6;
    }
    goto LABEL_21;
  }
  if ( v7 != 3 )
  {
    if ( v7 != 1 )
      return v6;
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "Write select failed on pool %d sock", a1->__lock);
      sub_38438(7, s, 0);
    }
LABEL_21:
    sub_2B7C0(a1);
    return v6;
  }
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(s, "Stratum send failed due to no pool stratum_active");
    sub_38438(7, s, 0);
  }
  return v6;
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63928: using guessed type char byte_63928;

//----- (0002C1C4) --------------------------------------------------------
int __fastcall sub_2C1C4(int result)
{
  pthread_mutex_t *v1; // r4
  int v2; // r2
  size_t v3; // r0
  char v4[2048]; // [sp+0h] [bp-2800h] BYREF
  char s[8192]; // [sp+800h] [bp-2000h] BYREF

  v1 = (pthread_mutex_t *)result;
  if ( *(_BYTE *)(result + 572) )
  {
    v2 = dword_636A0++;
    sprintf(s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v2);
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(v4, 0x800u, "Send extranonce.subscribe for stratum pool %d", v1->__lock);
      sub_38438(7, v4, 0);
    }
    v3 = strlen(s);
    return sub_2BEA8(v1, s, v3);
  }
  return result;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 636A0: using guessed type int dword_636A0;

//----- (0002C29C) --------------------------------------------------------
int *__fastcall sub_2C29C(_DWORD *a1)
{
  int i; // r0
  int v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r0
  bool v7; // zf
  int v8; // r0
  struct addrinfo *v9; // r4
  char *v10; // r12
  int v11; // r0
  int v12; // r1
  int v13; // r2
  __int16 v14; // r3
  int v15; // r0
  int v16; // r7
  int v17; // r0
  int *v18; // r10
  unsigned int v19; // lr
  int *v20; // r5
  int v21; // r0
  char *v22; // r3
  int v23; // r0
  const char *v24; // r3
  int v25; // r2
  size_t v26; // r0
  void *v27; // r0
  const char *v28; // r0
  int v29; // r3
  int v30; // r2
  int v31; // r4
  int v32; // r3
  int v33; // r3
  int *v35; // r0
  int *v36; // r6
  _DWORD *v37; // r6
  _DWORD *v38; // r0
  char *v39; // r4
  char *v40; // r0
  ssize_t v41; // r0
  const char *v42; // r8
  signed int v43; // r0
  size_t v44; // r5
  __int16 v45; // r0
  char *v46; // r12
  ssize_t v47; // r4
  char v48; // r0
  ssize_t v49; // r5
  _DWORD *v50; // r0
  unsigned int v51; // r5
  _DWORD *v52; // r0
  _DWORD *v53; // r8
  char *v54; // r10
  const char *v55; // r0
  _DWORD *v56; // r0
  int v57; // r0
  int v58; // r8
  int *v59; // r0
  size_t v60; // r3
  void *v61; // r0
  size_t v62; // r9
  _BYTE *v63; // r0
  int *v64; // r0
  int v65; // r0
  int v66; // r2
  size_t v67; // r0
  int *v68; // r0
  int *v69; // r0
  int *v70; // r0
  int *v71; // r0
  _DWORD *ptr; // [sp+14h] [bp-2B60h]
  char *ptra; // [sp+14h] [bp-2B60h]
  int *v74; // [sp+18h] [bp-2B5Ch]
  char *name; // [sp+1Ch] [bp-2B58h]
  char *namea; // [sp+1Ch] [bp-2B58h]
  char *service; // [sp+20h] [bp-2B54h]
  int v78; // [sp+24h] [bp-2B50h]
  pthread_mutex_t *mutex; // [sp+2Ch] [bp-2B48h]
  int v80; // [sp+30h] [bp-2B44h]
  struct addrinfo *pai; // [sp+38h] [bp-2B3Ch] BYREF
  int v82; // [sp+3Ch] [bp-2B38h] BYREF
  socklen_t optlen; // [sp+40h] [bp-2B34h] BYREF
  int optval; // [sp+44h] [bp-2B30h] BYREF
  struct timeval timeout; // [sp+48h] [bp-2B2Ch] BYREF
  addrinfo req; // [sp+50h] [bp-2B24h] BYREF
  char v87[92]; // [sp+70h] [bp-2B04h] BYREF
  char v88[160]; // [sp+CCh] [bp-2AA8h] BYREF
  fd_set writefds; // [sp+16Ch] [bp-2A08h] BYREF
  char s[2048]; // [sp+370h] [bp-2804h] BYREF
  char v91[8196]; // [sp+B70h] [bp-2004h] BYREF

  v74 = 0;
  v78 = 0;
  mutex = (pthread_mutex_t *)(a1 + 168);
  v80 = 0;
  for ( i = pthread_mutex_lock((pthread_mutex_t *)a1 + 28); ; i = pthread_mutex_lock(mutex) )
  {
    if ( i )
      sub_B7D8("setup_stratum_socket", 2711);
    v6 = a1[145];
    *((_BYTE *)a1 + 633) = 0;
    if ( v6 )
      close(v6);
    a1[145] = 0;
    if ( pthread_mutex_unlock(mutex) )
    {
      v70 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v70,
        "util.c",
        "setup_stratum_socket",
        2716);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    off_60178();
    v7 = a1[46] == 0;
    req.ai_family = 0;
    req.ai_flags = 0;
    memset(&req.ai_protocol, 0, 20);
    req.ai_socktype = 1;
    if ( !v7
      || (v28 = (const char *)dword_62E34) != 0
      && (a1[46] = dword_62E34, sub_2B43C(v28, a1 + 149, (char **)a1 + 150), v29 = a1[46], a1[45] = 3, v29) )
    {
      name = (char *)a1[149];
      service = (char *)a1[150];
      v8 = getaddrinfo(name, service, &req, &pai);
    }
    else
    {
      name = (char *)a1[148];
      service = (char *)a1[144];
      v8 = getaddrinfo(name, service, &req, &pai);
    }
    if ( v8 )
    {
      if ( *((_BYTE *)a1 + 99) )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "Failed to getaddrinfo for %s:%s", name, service);
          sub_38438(7, s, 0);
        }
      }
      else
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Failed to resolve (?wrong URL) %s:%s", name, service);
          sub_38438(4, s, 0);
        }
        *((_BYTE *)a1 + 99) = 1;
      }
      goto LABEL_8;
    }
    v9 = pai;
    if ( !pai )
    {
LABEL_60:
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "Failed to connect to stratum on %s:%s", name, service);
        sub_38438(7, s, 0);
      }
      freeaddrinfo(pai);
      goto LABEL_8;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v15 = socket(v9->ai_family, v9->ai_socktype, v9->ai_protocol);
        v16 = v15;
        if ( v15 != -1 )
          break;
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v10 = s;
          v11 = *(_DWORD *)"Failed socket";
          v12 = *(_DWORD *)"ed socket";
          v13 = *(_DWORD *)"ocket";
          v14 = *(_WORD *)"t";
          goto LABEL_38;
        }
LABEL_39:
        v9 = v9->ai_next;
        if ( !v9 )
          goto LABEL_60;
      }
      v17 = fcntl(v15, 3, 0);
      fcntl(v16, 4, v17 | 0x800);
      if ( connect(v16, v9->ai_addr, v9->ai_addrlen) != -1 )
        break;
      timeout.tv_sec = 1;
      timeout.tv_usec = 0;
      v18 = _errno_location();
      if ( *v18 == 115 )
      {
        v19 = 0;
        v20 = &writefds.__fds_bits[v16 / 32];
        while ( 1 )
        {
          if ( v19 > 0x1F )
          {
            *v20 |= 1 << (v16 % 32);
            v21 = select(v16 + 1, 0, &writefds, 0, &timeout);
            if ( v21 > 0 )
            {
              if ( ((*v20 >> (v16 % 32)) & 1) != 0 )
              {
                optlen = 4;
                if ( !getsockopt(v16, 1, 4, &optval, &optlen) && !optval )
                {
                  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                  {
                    strcpy(s, "Succeeded delayed connect");
                    sub_38438(7, s, 0);
                  }
                  goto LABEL_71;
                }
              }
LABEL_47:
              close(v16);
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                qmemcpy(s, "Select timeout/f", 16);
                v10 = &s[16];
                v11 = *(_DWORD *)"ailed connect";
                v12 = *(_DWORD *)"d connect";
                v13 = *(_DWORD *)"nnect";
                v14 = *(_WORD *)"t";
LABEL_38:
                *(_DWORD *)v10 = v11;
                *((_DWORD *)v10 + 1) = v12;
                *((_DWORD *)v10 + 2) = v13;
                *((_WORD *)v10 + 6) = v14;
                sub_38438(7, s, 0);
              }
              goto LABEL_39;
            }
            v19 = 0;
            if ( !v21 || *v18 != 4 )
              goto LABEL_47;
          }
          v22 = &v91[4 * v19++ + 0x2000];
          *((_DWORD *)v22 - 2689) = 0;
        }
      }
      close(v16);
      if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
        goto LABEL_39;
      strcpy(s, "Failed sock connect");
      sub_38438(7, s, 0);
      v9 = v9->ai_next;
      if ( !v9 )
        goto LABEL_60;
    }
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      strcpy(s, "Succeeded immediate connect");
      sub_38438(4, s, 0);
    }
LABEL_71:
    sub_287AC(v16);
    freeaddrinfo(pai);
    if ( a1[46] )
    {
      switch ( a1[45] )
      {
        case 0:
          if ( !sub_287FC((const char **)a1, v16, 0) )
            break;
          if ( !a1[146] )
            goto LABEL_108;
          goto LABEL_84;
        case 1:
          if ( !sub_287FC((const char **)a1, v16, 1) )
            break;
          goto LABEL_83;
        case 2:
          if ( !sub_28BD0((const char **)a1, v16, 0) )
            break;
          goto LABEL_83;
        case 3:
        case 5:
          LOBYTE(writefds.__fds_bits[0]) = 5;
          *(_WORD *)((char *)writefds.__fds_bits + 1) = 1;
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(
              s,
              0x800u,
              "Attempting to negotiate with %s:%s SOCKS5 proxy",
              (const char *)a1[149],
              (const char *)a1[150]);
            sub_38438(7, s, 0);
          }
          send(v16, &writefds, 3u, 0);
          if ( sub_287D4(v16) != 5 )
            goto LABEL_100;
          v41 = sub_287D4(v16);
          if ( v41 != BYTE2(writefds.__fds_bits[0]) )
            goto LABEL_100;
          v42 = (const char *)a1[148];
          writefds.__fds_bits[0] = 50331909;
          v43 = strlen(v42);
          v44 = v43 >= 255 ? 255 : v43;
          LOBYTE(writefds.__fds_bits[1]) = v44;
          memcpy((char *)&writefds.__fds_bits[1] + 1, v42, v44);
          v45 = strtol((const char *)a1[144], 0, 10);
          v46 = (char *)&writefds.__fds_bits[1] + v44;
          v46[2] = v45;
          v46[1] = HIBYTE(v45);
          send(v16, &writefds, v44 + 7, 0);
          if ( sub_287D4(v16) != 5 )
            goto LABEL_100;
          v47 = sub_287D4(v16);
          if ( v47 )
            goto LABEL_100;
          sub_287D4(v16);
          v48 = sub_287D4(v16);
          if ( v48 == 1 )
          {
            sub_287D4(v16);
            sub_287D4(v16);
            sub_287D4(v16);
            sub_287D4(v16);
LABEL_178:
            sub_287D4(v16);
            sub_287D4(v16);
            if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              snprintf(
                s,
                0x800u,
                "Success negotiating with %s:%s SOCKS5 proxy",
                (const char *)a1[149],
                (const char *)a1[150]);
              sub_38438(7, s, 0);
            }
            goto LABEL_83;
          }
          if ( v48 == 3 )
          {
            v49 = sub_287D4(v16);
            if ( v49 > 0 )
            {
              do
              {
                ++v47;
                sub_287D4(v16);
              }
              while ( v47 != v49 );
            }
            goto LABEL_178;
          }
LABEL_100:
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, "Bad response from %s:%s SOCKS5 server", (const char *)a1[149], (const char *)a1[150]);
            sub_38438(4, s, 0);
          }
          break;
        case 4:
          if ( sub_28BD0((const char **)a1, v16, 1) )
            goto LABEL_83;
          break;
        default:
          if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
          {
            snprintf(s, 0x800u, "Unsupported proxy type for %s:%s", (const char *)a1[149], (const char *)a1[150]);
            sub_38438(4, s, 0);
          }
          break;
      }
LABEL_8:
      v3 = 0;
      goto LABEL_9;
    }
LABEL_83:
    if ( !a1[146] )
    {
LABEL_108:
      v27 = calloc(0x2000u, 1u);
      a1[146] = v27;
      if ( !v27 )
      {
        snprintf(s, 0x800u, "Failed to calloc pool sockbuf in %s %s():%d", "util.c", "setup_stratum_socket", 2837);
        sub_38438(3, s, 1);
        sub_16724(1);
      }
      a1[147] = 0x2000;
    }
LABEL_84:
    a1[145] = v16;
    v82 = 1;
    optlen = 45;
    optval = 30;
    v23 = fcntl(v16, 3, 0);
    fcntl(v16, 4, v23 | 0x800);
    setsockopt(v16, 1, 9, &v82, 4u);
    if ( !byte_642C0 )
      fcntl(v16, 2, 1);
    setsockopt(v16, 6, 1, &v82, 4u);
    setsockopt(v16, 6, 6, &v82, 4u);
    setsockopt(v16, 6, 4, &optlen, 4u);
    setsockopt(v16, 6, 5, &optval, 4u);
    if ( v80 )
    {
      sub_29394((int)a1);
      v30 = dword_636A0++;
      sprintf(v91, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v30);
    }
    else
    {
      v24 = (const char *)a1[157];
      v25 = dword_636A0++;
      if ( v24 )
        sprintf(
          v91,
          "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/4.9.0\", \"%s\"]}",
          v25,
          v24);
      else
        sprintf(v91, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/4.9.0\"]}", v25);
    }
    v26 = strlen(v91);
    if ( sub_2918C((int)a1, v91, v26) )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        v3 = 1;
        strcpy(s, "Failed to send s in initiate_stratum");
        sub_38438(7, s, 0);
        goto LABEL_9;
      }
LABEL_121:
      v3 = 1;
      goto LABEL_9;
    }
    if ( sub_2870C((int)a1, 60) )
      break;
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      goto LABEL_121;
    v3 = 1;
    strcpy(s, "Timed out waiting for response in initiate_stratum");
    sub_38438(7, s, 0);
LABEL_9:
    if ( (v80 & (v78 ^ 1)) == 0 )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy(s, "Initiate stratum failed");
        sub_38438(7, s, 0);
      }
      if ( v3 )
      {
        sub_2B7C0((pthread_mutex_t *)a1);
        if ( v74 )
          goto LABEL_133;
      }
      else if ( v74 )
      {
LABEL_133:
        v31 = 0;
        goto LABEL_134;
      }
      return v74;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
      sub_B7D8("initiate_stratum", 3015);
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v71 = _errno_location();
      snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v71, "util.c", "initiate_stratum", 3015);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    free((void *)a1[157]);
    free((void *)a1[151]);
    a1[151] = 0;
    a1[157] = 0;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
    {
      v69 = _errno_location();
      snprintf(
        s,
        0x800u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v69,
        "util.c",
        "initiate_stratum",
        3019);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 53)) )
    {
      v68 = _errno_location();
      snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v68, "util.c", "initiate_stratum", 3019);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    off_60178();
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(s, "Failed to resume stratum, trying afresh");
      sub_38438(7, s, 0);
    }
    if ( v74 )
    {
      v4 = v74[1];
      if ( v4 != -1 )
      {
        v5 = v4 - 1;
        v74[1] = v5;
        if ( !v5 )
          sub_46C5C((void **)v74);
      }
    }
    v78 = 1;
  }
  v35 = (int *)sub_2B920((int)a1);
  v36 = v35;
  if ( !v35 )
  {
    v3 = 1;
    goto LABEL_9;
  }
  v74 = sub_45AA8(v35, 0, v87);
  free(v36);
  if ( !v74 )
  {
    if ( byte_630C1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
      {
        v3 = 1;
        snprintf(s, 0x800u, "JSON decode failed(%d): %s", *(_DWORD *)v87, v88);
        sub_38438(7, s, 0);
        v80 = 1;
      }
      else
      {
        v80 = 1;
        v3 = 1;
      }
    }
    else
    {
      v80 = 1;
      v3 = 1;
    }
    goto LABEL_9;
  }
  v37 = (_DWORD *)sub_46698(v74, "result");
  v38 = (_DWORD *)sub_46698(v74, (char *)"error");
  if ( !v37 || *v37 == 7 )
  {
    if ( v38 )
    {
LABEL_150:
      v39 = (char *)sub_440CC(v38, 3);
    }
    else
    {
      v39 = (char *)malloc(0x11u);
      if ( v39 )
        strcpy(v39, "(unknown reason)");
    }
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "JSON-RPC decode failed: %s", v39);
      sub_38438(7, s, 0);
    }
    v40 = v39;
    v3 = 1;
    free(v40);
    v80 = 1;
    goto LABEL_9;
  }
  if ( v38 && *v38 != 7 )
    goto LABEL_150;
  v50 = sub_46880(v37, 0);
  ptr = v50;
  if ( v50 )
  {
    if ( *v50 == 1 )
    {
      namea = (char *)sub_46864(v50);
      if ( (int)namea > 0 )
      {
        v51 = 0;
        do
        {
          v52 = sub_46880(ptr, v51);
          v53 = v52;
          if ( !v52 || *v52 != 1 )
            break;
          ++v51;
          v55 = (const char *)sub_28E64(v52, 0);
          if ( v55 && !strncasecmp(v55, "mining.notify", 0xDu) )
          {
            v54 = sub_28EC4(v53, 1u);
            if ( v54 )
              goto LABEL_194;
            break;
          }
        }
        while ( namea != (char *)v51 );
      }
    }
  }
  v54 = (char *)(unsigned __int8)byte_630C1;
  if ( byte_630C1 )
  {
    if ( byte_632F0 || (v54 = (char *)(unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6 )
    {
      v54 = 0;
      strcpy(s, "Failed to get sessionid in initiate_stratum");
      sub_38438(7, s, 0);
    }
  }
LABEL_194:
  ptra = sub_28EC4(v37, 1u);
  if ( !sub_28EDC(ptra, "initiate_stratum", 2967) )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(s, "Failed to get valid nonce1 in initiate_stratum");
      sub_38438(7, s, 0);
    }
    v3 = 1;
    free(v54);
    v80 = 1;
    goto LABEL_9;
  }
  v56 = sub_46880(v37, 2u);
  v57 = sub_46AC0((int)v56);
  if ( (unsigned int)(v57 - 2) > 0xE )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      strcpy(s, "Failed to get valid n2size in initiate_stratum");
      sub_38438(7, s, 0);
    }
    v3 = 1;
    free(v54);
    free(ptra);
    v80 = 1;
    goto LABEL_9;
  }
  v58 = v57;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 53)) )
    sub_B7D8("initiate_stratum", 2980);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 59)) )
  {
    v59 = _errno_location();
    snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v59, "util.c", "initiate_stratum", 2980);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  a1[157] = v54;
  a1[151] = ptra;
  v60 = strlen(ptra) >> 1;
  v61 = (void *)a1[152];
  a1[383] = v60;
  free(v61);
  v62 = a1[383];
  v63 = calloc(v62, 1u);
  a1[152] = v63;
  if ( !v63 )
  {
    snprintf(s, 0x800u, "Failed to calloc pool->nonce1bin in %s %s():%d", "util.c", "initiate_stratum", 2987);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  sub_295B8(v63, (unsigned __int8 *)a1[151], v62);
  a1[156] = v58;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 59)) )
  {
    v64 = _errno_location();
    snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v64, "util.c", "initiate_stratum", 2990);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  sub_29110((pthread_mutex_t *)(a1 + 53), "initiate_stratum", 2990);
  off_60178();
  if ( v54 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "Pool %d stratum session id: %s", *a1, (const char *)a1[157]);
    sub_38438(7, s, 0);
  }
  if ( !a1[142] )
    a1[142] = a1[148];
  v65 = (unsigned __int8)byte_63928;
  *((_BYTE *)a1 + 633) = 1;
  *((_QWORD *)a1 + 223) = 0x3FF0000000000000LL;
  if ( v65 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(
      s,
      0x800u,
      "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
      *a1,
      (const char *)a1[151],
      a1[156]);
    sub_38438(7, s, 0);
  }
  if ( *((_BYTE *)a1 + 572) )
  {
    v66 = dword_636A0++;
    sprintf(v91, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v66);
    v67 = strlen(v91);
    sub_2BEA8((pthread_mutex_t *)a1, v91, v67);
  }
  v31 = 1;
LABEL_134:
  v32 = v74[1];
  if ( v32 != -1 )
  {
    v33 = v32 - 1;
    v74[1] = v33;
    if ( !v33 )
      sub_46C5C((void **)v74);
  }
  return (int *)v31;
}
// 2C978: control flows out of bounds to 2C97C
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 62E34: using guessed type int dword_62E34;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 636A0: using guessed type int dword_636A0;
// 63928: using guessed type char byte_63928;
// 642C0: using guessed type char byte_642C0;

//----- (0002DC00) --------------------------------------------------------
int __fastcall sub_2DC00(pthread_mutex_t *a1)
{
  if ( a1[26].__size[9] )
  {
    sub_2B7C0(a1);
    if ( !sub_2C29C(a1) )
      goto LABEL_3;
  }
  else if ( !sub_2C29C(a1) )
  {
LABEL_3:
    sub_1F5DC((int)a1);
    return 0;
  }
  if ( !sub_2E9B0(a1) )
    goto LABEL_3;
  sub_2C1C4((int)a1);
  sub_1F8F4(a1);
  return 1;
}

//----- (0002DC70) --------------------------------------------------------
int __fastcall sub_2DC70(pthread_mutex_t *a1, int *a2)
{
  double v2; // d0
  int *v4; // r0
  int *v5; // r4
  _DWORD *v6; // r7
  int v7; // r5
  _DWORD *v8; // r8
  const char *v9; // r0
  char *v10; // r5
  char *v11; // r0
  int v12; // r3
  int v13; // r3
  const char *v15; // r0
  const char *v16; // r7
  int v17; // r0
  int v18; // r0
  int v19; // r0
  size_t v20; // r0
  _DWORD *v21; // r0
  double v22; // d9
  _BOOL4 v23; // r0
  _DWORD *v24; // r0
  const char *nusers; // r5
  const char *v26; // r7
  char *v27; // r10
  char *v28; // r1
  const char *v29; // r2
  const char *v30; // r3
  int v31; // r0
  int v32; // r0
  _DWORD *v33; // r0
  int v34; // r7
  _DWORD *v35; // r0
  _DWORD *v36; // r0
  _DWORD *v37; // r0
  _DWORD *lock; // r0
  int count; // r0
  void *v40; // r0
  unsigned int v41; // r3
  void *v42; // r0
  size_t v43; // r3
  void *owner; // r0
  size_t spins; // r5
  _BYTE *v46; // r0
  int *v47; // r0
  int *v48; // r0
  int *v49; // r0
  int *v50; // r0
  unsigned int v51; // [sp+14h] [bp-2204h] BYREF
  char *v52; // [sp+18h] [bp-2200h] BYREF
  int v53[23]; // [sp+1Ch] [bp-21FCh] BYREF
  char v54[160]; // [sp+78h] [bp-21A0h] BYREF
  char v55[256]; // [sp+118h] [bp-2100h] BYREF
  char s[8168]; // [sp+218h] [bp-2000h] BYREF

  if ( !a2 )
    return 0;
  v4 = sub_45AA8(a2, 0, (char *)v53);
  v5 = v4;
  if ( !v4 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      v7 = 0;
      snprintf(s, 0x800u, "JSON decode failed(%d): %s", v53[0], v54);
      sub_38438(7, s, 0);
      return v7;
    }
    return 0;
  }
  v6 = (_DWORD *)sub_46698(v4, "method");
  if ( !v6 )
    goto LABEL_17;
  v7 = sub_46698(v5, (char *)"error");
  v8 = (_DWORD *)sub_46698(v5, "params");
  if ( !v7 || *(_DWORD *)v7 == 7 )
  {
    v15 = (const char *)sub_469F0(v6);
    v16 = v15;
    if ( !v15 )
      goto LABEL_17;
    if ( !strncasecmp(v15, "mining.notify", 0xDu) )
    {
      v23 = sub_29724((int)a1, v8);
      if ( v23 )
        v7 = 1;
      else
        a1[26].__size[11] = 0;
      if ( v23 )
        a1[26].__size[11] = v7;
      else
        v7 = 0;
      goto LABEL_8;
    }
    if ( !strncasecmp(v16, "mining.set_extranonce", 0x15u) )
    {
      v10 = sub_28EC4(v8, 0);
      if ( !sub_28EDC(v10, "parse_extranonce", 2172) )
      {
        v7 = (unsigned __int8)byte_630C1;
        if ( byte_630C1 )
        {
          if ( byte_632F0 || (v7 = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6 )
          {
            v7 = 0;
            strcpy(s, "Failed to get valid nonce1 in parse_extranonce");
            sub_38438(7, s, 0);
          }
        }
        goto LABEL_8;
      }
      v33 = sub_46880(v8, 1u);
      v34 = sub_46AC0((int)v33);
      if ( (unsigned int)(v34 - 2) <= 0xE )
      {
        if ( pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 212)) )
          sub_B7D8("parse_extranonce", 2183);
        sub_29094((pthread_rwlock_t *)(&a1[9].__align + 5), "parse_extranonce", 2183);
        a1[25].__count = (unsigned int)v10;
        v43 = strlen(v10) >> 1;
        owner = (void *)a1[25].__owner;
        a1[63].__spins = v43;
        free(owner);
        spins = a1[63].__spins;
        v46 = calloc(spins, 1u);
        a1[25].__owner = (int)v46;
        if ( !v46 )
        {
          snprintf(s, 0x800u, "Failed to calloc pool->nonce1bin in %s %s():%d", "util.c", "parse_extranonce", 2189);
          sub_38438(3, s, 1);
          sub_16724(1);
        }
        sub_295B8(v46, (unsigned __int8 *)a1[25].__count, spins);
        a1[26].__lock = v34;
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(
            s,
            0x800u,
            "Pool %d confirmed mining.extranonce.subscribe with extranonce1 %s extran2size %d",
            a1->__lock,
            (const char *)a1[25].__count,
            v34);
          sub_38438(7, s, 0);
        }
        v7 = 1;
        sub_29018((pthread_rwlock_t *)(&a1[9].__align + 5), "parse_extranonce", 2194);
        sub_29110((pthread_mutex_t *)((char *)a1 + 212), "parse_extranonce", 2194);
        off_60178();
        goto LABEL_8;
      }
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy(s, "Failed to get valid n2size in parse_extranonce");
        sub_38438(7, s, 0);
      }
      goto LABEL_7;
    }
    v7 = strncasecmp(v16, "mining.set_difficulty", 0x15u);
    if ( !v7 )
    {
      v21 = sub_46880(v8, 0);
      sub_46BF0((int)v21);
      if ( v2 == 0.0 )
        goto LABEL_8;
      if ( pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 212)) )
        sub_B7D8("parse_diff", 2145);
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(&a1[9].__align + 5)) )
      {
        v48 = _errno_location();
        snprintf(s, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v48, "util.c", "parse_diff", 2145);
        sub_38438(3, s, 1);
        sub_16724(1);
      }
      v22 = *((double *)&a1[74].__align + 1);
      *((double *)&a1[74].__align + 1) = v2;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(&a1[9].__align + 5)) )
      {
        v50 = _errno_location();
        snprintf(s, 0x800u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v50, "util.c", "parse_diff", 2148);
        sub_38438(3, s, 1);
        sub_16724(1);
      }
      if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 212)) )
      {
        v49 = _errno_location();
        snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v49, "util.c", "parse_diff", 2148);
        sub_38438(3, s, 1);
        sub_16724(1);
      }
      off_60178();
      if ( v2 == v22 )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v7 = 1;
          snprintf(s, 0x800u, "Pool %d difficulty set to %f", a1->__lock, v2);
          sub_38438(7, s, 0);
          goto LABEL_8;
        }
        goto LABEL_53;
      }
      if ( v2 == (double)(int)v2 )
      {
        if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
          goto LABEL_53;
        snprintf(s, 0x800u, "Pool %d difficulty changed to %d", a1->__lock, (int)v2);
      }
      else
      {
        if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
          goto LABEL_53;
        snprintf(s, 0x800u, "Pool %d difficulty changed to %.1f", a1->__lock, v2);
      }
      goto LABEL_52;
    }
    if ( strncasecmp(v16, "client.reconnect", 0x10u) )
    {
      if ( !strncasecmp(v16, "client.get_version", 0x12u) )
      {
        v17 = sub_46698(v5, "id");
        if ( v17 )
        {
          v31 = sub_46698(v5, "id");
          v32 = sub_46AC0(v31);
          sprintf(s, "{\"id\": %d, \"result\": \"cgminer/4.9.0\", \"error\": null}", v32);
          goto LABEL_37;
        }
LABEL_104:
        v7 = v17;
        goto LABEL_8;
      }
      if ( strncasecmp(v16, "client.show_message", 0x13u) )
      {
        if ( !strncasecmp(v16, "mining.ping", 0xBu) )
        {
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(s, 0x800u, "Pool %d ping", a1->__lock);
            sub_38438(7, s, 0);
          }
          v17 = sub_46698(v5, "id");
          if ( v17 )
          {
            v18 = sub_46698(v5, "id");
            v19 = sub_46AC0(v18);
            sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v19);
LABEL_37:
            v20 = strlen(s);
            v7 = sub_2BEA8(a1, s, v20);
            goto LABEL_8;
          }
          goto LABEL_104;
        }
LABEL_17:
        v7 = 0;
        goto LABEL_8;
      }
      if ( !v8 )
        goto LABEL_17;
      if ( *v8 != 1 )
        goto LABEL_17;
      v35 = sub_46880(v8, 0);
      v36 = sub_469F0(v35);
      if ( !v36 )
        goto LABEL_17;
      if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      {
LABEL_53:
        v7 = 1;
        goto LABEL_8;
      }
      snprintf(s, 0x800u, "Pool %d message: %s", a1->__lock, v36);
LABEL_52:
      sub_38438(7, s, 0);
      goto LABEL_53;
    }
    memset(v55, 0, 0xFFu);
    v24 = sub_46880(v8, 0);
    nusers = (const char *)sub_469F0(v24);
    if ( !nusers )
    {
      nusers = (const char *)a1[24].__nusers;
      goto LABEL_92;
    }
    v26 = (const char *)a1[24].__nusers;
    v27 = strchr(v26, 46);
    if ( v27 )
    {
      v28 = strchr(nusers, 46);
      if ( v28 )
      {
        if ( !strcmp(v27, v28) )
        {
LABEL_92:
          v37 = sub_46880(v8, 1u);
          lock = sub_469F0(v37);
          if ( !lock )
            lock = (_DWORD *)a1[24].__lock;
          snprintf(v55, 0xFEu, "%s:%s", nusers, lock);
          if ( sub_2B43C(v55, &v51, &v52) )
          {
            if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
            {
              snprintf(s, 0x800u, "Stratum reconnect requested from pool %d to %s", a1->__lock, v55);
              sub_38438(4, s, 0);
            }
            sub_17FC4(a1);
            if ( pthread_mutex_lock(a1 + 28) )
              sub_B7D8("parse_reconnect", 2252);
            sub_286F8((int)a1);
            count = a1[24].__count;
            a1[26].__size[11] = 0;
            a1[26].__size[9] = 0;
            if ( count )
              close(count);
            v40 = (void *)a1[24].__nusers;
            v41 = v51;
            a1[24].__count = 0;
            a1[23].__nusers = v41;
            a1[24].__nusers = v41;
            free(v40);
            v42 = (void *)a1[24].__lock;
            a1[24].__lock = (int)v52;
            free(v42);
            if ( pthread_mutex_unlock(a1 + 28) )
            {
              v47 = _errno_location();
              snprintf(
                s,
                0x800u,
                "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v47,
                "util.c",
                "parse_reconnect",
                2261);
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            off_60178();
            v7 = sub_2DC00(a1);
            goto LABEL_8;
          }
          goto LABEL_17;
        }
        if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
          goto LABEL_17;
        v29 = "Denied stratum reconnect request to non-matching domain url '%s'";
        v30 = v26;
      }
      else
      {
        if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
          goto LABEL_17;
        v30 = nusers;
        v29 = "Denied stratum reconnect request to url without domain '%s'";
      }
    }
    else
    {
      if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
        goto LABEL_17;
      v30 = v26;
      v29 = "Denied stratum reconnect request for pool without domain '%s'";
    }
    v7 = 0;
    snprintf(s, 0x800u, v29, v30);
    sub_38438(3, s, 0);
    goto LABEL_8;
  }
  v9 = (const char *)sub_440CC((_DWORD *)v7, 3);
  v10 = (char *)v9;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "JSON-RPC method decode failed: %s", v9);
    sub_38438(7, s, 0);
  }
LABEL_7:
  v11 = v10;
  v7 = 0;
  free(v11);
LABEL_8:
  v12 = v5[1];
  if ( v12 != -1 )
  {
    v13 = v12 - 1;
    v5[1] = v13;
    if ( !v13 )
      sub_46C5C((void **)v5);
  }
  return v7;
}
// 2DFC4: variable 'v2' is possibly undefined
// 2DC00: using guessed type int __fastcall sub_2DC00(_DWORD);
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0002E9B0) --------------------------------------------------------
int __fastcall sub_2E9B0(pthread_mutex_t *a1)
{
  const char *owner; // r12
  const char *count; // r3
  int v4; // r2
  size_t v5; // r0
  int *v6; // r4
  int v7; // r4
  int *v9; // r7
  _DWORD *v10; // r4
  _DWORD *v11; // r0
  char *v12; // r4
  char *v13; // r0
  int v14; // r3
  int v15; // r3
  int v16; // r2
  size_t v17; // r0
  int v18; // r2
  size_t v19; // r0
  char v20[252]; // [sp+Ch] [bp-2900h] BYREF
  char s[2040]; // [sp+108h] [bp-2804h] BYREF
  char v22[8196]; // [sp+908h] [bp-2004h] BYREF

  owner = (const char *)a1[7].__owner;
  count = (const char *)a1[7].__count;
  v4 = dword_636A0++;
  sprintf(v22, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v4, count, owner);
  v5 = strlen(v22);
  if ( sub_2BEA8(a1, v22, v5) )
  {
    while ( 1 )
    {
      v6 = (int *)sub_2B920((int)a1);
      if ( !v6 )
        return 0;
      if ( !sub_2DC70(a1, v6) )
        break;
      free(v6);
    }
    v9 = sub_45AA8(v6, 0, v20);
    free(v6);
    v10 = (_DWORD *)sub_46698(v9, "result");
    v11 = (_DWORD *)sub_46698(v9, (char *)"error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "Stratum authorisation success for pool %d", a1->__lock);
        sub_38438(7, s, 0);
      }
      a1[4].__size[3] = 1;
      byte_62F60 = 1;
      if ( dword_640C4 )
      {
        v18 = dword_636A0++;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v18, dword_640C4);
        v19 = strlen(v22);
        sub_2BEA8(a1, v22, v19);
      }
      if ( dword_60154 )
      {
        v16 = dword_636A0++;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.multi_version\", \"params\": [%d]}", v16, dword_60154);
        v7 = 1;
        v17 = strlen(v22);
        sub_2BEA8(a1, v22, v17);
      }
      else
      {
        v7 = 1;
      }
      goto LABEL_18;
    }
    v12 = (char *)sub_440CC(v11, 3);
LABEL_13:
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "pool %d JSON stratum auth failed: %s", a1->__lock, v12);
      sub_38438(7, s, 0);
    }
    v13 = v12;
    v7 = 0;
    free(v13);
    sub_2B7C0(a1);
LABEL_18:
    if ( v9 )
    {
      v14 = v9[1];
      if ( v14 != -1 )
      {
        v15 = v14 - 1;
        v9[1] = v15;
        if ( !v15 )
          sub_46C5C((void **)v9);
      }
    }
    return v7;
  }
  return 0;
}
// 60154: using guessed type int dword_60154;
// 60964: using guessed type int dword_60964;
// 62F60: using guessed type char byte_62F60;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 636A0: using guessed type int dword_636A0;
// 640C4: using guessed type int dword_640C4;

//----- (0002ED00) --------------------------------------------------------
time_t __fastcall sub_2ED00(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}
// 2ED24: control flows out of bounds to 2ED28

//----- (0002EEDC) --------------------------------------------------------
char *__fastcall sub_2EEDC(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  char *v3; // r0
  char *v4; // r6
  char *v5; // r5
  char v6; // r3
  int v7; // r2
  int v8; // t1
  char *v10; // r3
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v1 = a1;
  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(s, 0x800u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3132);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(v1);
  v3 = (char *)malloc(4 * v2 + 5);
  v4 = v3;
  if ( !v3 )
  {
    snprintf(s, 0x800u, "Failed to malloc txt in %s %s():%d", "util.c", "str_text", 3139);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v5 = v3;
  do
  {
    while ( 1 )
    {
      v8 = *(unsigned __int8 *)v1++;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x", v7);
      v6 = *(v1 - 1);
      v5 += 4;
      if ( !v6 )
        goto LABEL_9;
    }
    *v5++ = v7;
    v6 = *(v1 - 1);
  }
  while ( v6 );
LABEL_9:
  *v5 = v6;
  return v4;
}

//----- (0002F02C) --------------------------------------------------------
int __fastcall sub_2F02C(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (0002F06C) --------------------------------------------------------
int __fastcall sub_2F06C(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r7
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (0002F0EC) --------------------------------------------------------
int __fastcall sub_2F0EC(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_2F06C((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1221);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (0002F134) --------------------------------------------------------
int __fastcall sub_2F134(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int *v9; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = sem_post(a1);
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x800u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v9, a1, a2, a3, a4);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (0002F1B4) --------------------------------------------------------
void *__fastcall sub_2F1B4(sem_t *a1)
{
  pthread_setcanceltype(1, 0);
  ((void (__fastcall *)(_DWORD))a1[1].__align)(*(&a1[1].__align + 1));
  sub_2F134(a1, "util.c", "completion_thread", 3352);
  return 0;
}

//----- (0002F1F8) --------------------------------------------------------
int __fastcall sub_2F1F8(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
  }
  return result;
}

//----- (0002F27C) --------------------------------------------------------
int __fastcall sub_2F27C(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  int result; // r0
  int v9; // r3
  struct timespec abstime; // [sp+10h] [bp-81Ch] BYREF
  _DWORD v11[2]; // [sp+18h] [bp-814h] BYREF
  struct timeval v12; // [sp+20h] [bp-80Ch] BYREF
  char s[2052]; // [sp+28h] [bp-804h] BYREF

  sub_2B13C(&v12);
  v11[0] = v12.tv_sec;
  v11[1] = 1000 * v12.tv_usec;
  sub_2AEF0(&abstime);
  while ( 1 )
  {
    sub_2AF78(&abstime.tv_sec, v11);
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 == 110 )
      return 110;
    if ( v9 != 4 )
    {
      snprintf(s, 0x800u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", v9, a1, a3, a4, a5);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
  }
  return result;
}

//----- (0002F354) --------------------------------------------------------
int *__fastcall sub_2F354(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (0002F38C) --------------------------------------------------------
int __fastcall sub_2F38C(int a1, int a2, int a3)
{
  sem_t *v6; // r0
  sem_t *v7; // r4
  _BOOL4 v8; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)malloc(0x18u);
  v7 = v6;
  if ( !v6 )
    return 0;
  sub_2F06C(v6, "util.c", "cg_completion_timeout", 3366);
  v7[1].__align = a1;
  *(&v7[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_2F1B4, v7);
  v8 = sub_2F27C(v7, a3, "util.c", "cg_completion_timeout", 3372) != 0;
  if ( v8 )
  {
    pthread_cancel(newthread[0]);
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v7);
  }
  return !v8;
}

//----- (0002F560) --------------------------------------------------------
char *__fastcall sub_2F560(char *result, int a2)
{
  unsigned int v2; // r1
  char *v3; // r2
  unsigned int v4; // r3
  char v5; // r12

  v2 = a2 - 1;
  if ( v2 )
  {
    v3 = result;
    v4 = 0;
    do
    {
      ++v4;
      v5 = *v3;
      *v3++ = result[v2];
      result[v2--] = v5;
    }
    while ( v4 < v2 );
  }
  return result;
}

//----- (0002F59C) --------------------------------------------------------
int __fastcall sub_2F59C(int a1, char a2)
{
  int v3; // r1
  unsigned int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1
  unsigned int v7; // r1

  switch ( a1 )
  {
    case 1:
      return 1;
    case 2:
      if ( (a2 & 0x80) == 0 )
        return 1;
      return 2;
    case 4:
      v3 = a2 & 0xC0;
      switch ( v3 )
      {
        case 128:
          return 3;
        case 192:
          return 4;
        case 64:
          return 2;
        default:
          return 1;
      }
    case 8:
      v4 = a2 & 0xE0;
      if ( v4 == 128 )
        return 5;
      if ( v4 > 0x80 )
      {
        if ( v4 == 192 )
          return 7;
        if ( v4 == 224 )
          return 8;
        if ( v4 != 160 )
          return 1;
        return 6;
      }
      if ( v4 == 64 )
        return 3;
      if ( v4 == 96 )
        return 4;
      if ( v4 != 32 )
        return 1;
      return 2;
    case 16:
      v5 = a2 & 0xF0;
      if ( v5 == 128 )
        return 9;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
        {
          return 5;
        }
        else if ( v5 > 0x40 )
        {
          switch ( v5 )
          {
            case '`':
              return 7;
            case 'p':
              return 8;
            case 'P':
              return 6;
            default:
              return 1;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 0x20u:
              return 3;
            case 0x30u:
              return 4;
            case 0x10u:
              return 2;
            default:
              return 1;
          }
        }
      }
      else if ( v5 == 192 )
      {
        return 13;
      }
      else if ( v5 > 0xC0 )
      {
        switch ( v5 )
        {
          case 0xE0u:
            return 15;
          case 0xF0u:
            return 16;
          case 0xD0u:
            return 14;
          default:
            return 1;
        }
      }
      else
      {
        switch ( v5 )
        {
          case 0xA0u:
            return 11;
          case 0xB0u:
            return 12;
          case 0x90u:
            return 10;
          default:
            return 1;
        }
      }
    case 32:
      v6 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v6 > 0xF0 )
        return 1;
      return *((char *)&unk_51788 + v6 + 1896);
    case 64:
      v7 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v7 > 0xF8 )
        return 1;
      return *((char *)&unk_51788 + v7 + 2140);
    default:
      return 0;
  }
}
// 2F5A8: control flows out of bounds to 2F5AC

//----- (0002F884) --------------------------------------------------------
void __fastcall sub_2F884(_DWORD *a1, char *a2, int a3)
{
  int v4; // r12
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // lr
  int v12; // r1
  int v13; // r2
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r3
  char v20; // r3
  _DWORD *v21; // r2
  int i; // r3
  char v23; // r1
  _DWORD *v24; // r2
  int j; // r3
  char v26; // r1
  unsigned int *v27; // r2
  int k; // r3
  char v29; // r1
  char *v30; // r8
  char *v31; // r5
  char *v32; // r4
  char *v33; // r10
  char *v34; // r7
  char *v35; // r6
  __int64 v36; // kr00_8
  size_t v37; // r0
  bool v38; // zf
  unsigned __int64 v39; // r2
  int m; // r11
  size_t v41; // r0
  size_t v42; // r0
  size_t v43; // r0
  int v44; // r11
  size_t v45; // r0
  size_t v46; // r0
  _DWORD v49[8]; // [sp+30h] [bp-CB4h] BYREF
  _DWORD v50[2]; // [sp+50h] [bp-C94h] BYREF
  int v51; // [sp+58h] [bp-C8Ch]
  int v52; // [sp+5Ch] [bp-C88h]
  int v53; // [sp+60h] [bp-C84h]
  int v54; // [sp+64h] [bp-C80h]
  int v55; // [sp+68h] [bp-C7Ch]
  int v56; // [sp+6Ch] [bp-C78h]
  _DWORD v57[8]; // [sp+70h] [bp-C74h] BYREF
  unsigned int v58[20]; // [sp+90h] [bp-C54h] BYREF
  char s[1024]; // [sp+E0h] [bp-C04h] BYREF
  char v60[2052]; // [sp+4E0h] [bp-804h] BYREF

  if ( dword_60E98 )
  {
    memset(s, 0, sizeof(s));
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    memset(v58, 0, sizeof(v58));
    v4 = 0;
    v5 = a1[33];
    v6 = a1[34];
    v7 = a1[35];
    v49[0] = a1[32];
    v49[1] = v5;
    v49[2] = v6;
    v49[3] = v7;
    v8 = a1[37];
    v9 = a1[38];
    v10 = a1[39];
    v49[4] = a1[36];
    v49[5] = v8;
    v49[6] = v9;
    v49[7] = v10;
    v11 = v49;
    v12 = a1[17];
    v13 = a1[18];
    v50[0] = a1[16];
    v50[1] = v12;
    v51 = v13;
    v14 = a1[49];
    v15 = a1[50];
    v16 = a1[51];
    v57[0] = a1[48];
    v57[1] = v14;
    v57[2] = v15;
    v57[3] = v16;
    v17 = a1[53];
    v18 = a1[54];
    v19 = a1[55];
    v57[4] = a1[52];
    v57[5] = v17;
    v57[6] = v18;
    v57[7] = v19;
    do
    {
      v20 = *((_BYTE *)v49 + v4);
      *((_BYTE *)v49 + v4++) = *((_BYTE *)v11 + 31);
      *((_BYTE *)v11 + 31) = v20;
      v11 = (_DWORD *)((char *)v11 - 1);
    }
    while ( v4 != 16 );
    v21 = v50;
    for ( i = 0; i != 6; ++i )
    {
      v23 = *((_BYTE *)v50 + i);
      *((_BYTE *)v50 + i) = *((_BYTE *)v21 + 11);
      *((_BYTE *)v21 + 11) = v23;
      v21 = (_DWORD *)((char *)v21 - 1);
    }
    v24 = v57;
    for ( j = 0; j != 16; ++j )
    {
      v26 = *((_BYTE *)v57 + j);
      *((_BYTE *)v57 + j) = *((_BYTE *)v24 + 31);
      *((_BYTE *)v24 + 31) = v26;
      v24 = (_DWORD *)((char *)v24 - 1);
    }
    if ( byte_63DF9 )
    {
      memcpy(v58, a1, sizeof(v58));
      v27 = v58;
      for ( k = 0; k != 40; ++k )
      {
        v29 = *((_BYTE *)v58 + k);
        *((_BYTE *)v58 + k) = *((_BYTE *)v27 + 79);
        *((_BYTE *)v27 + 79) = v29;
        v27 = (unsigned int *)((char *)v27 - 1);
      }
      v58[0] = bswap32(16 * bswap32(v58[0]));
      v30 = sub_294B8((int)v58, 80);
    }
    else
    {
      v30 = sub_294B8((int)a1, 128);
    }
    v31 = sub_294B8((int)v49, 32);
    v32 = sub_294B8((int)v50, 12);
    v33 = sub_294B8((int)a2, 4);
    v34 = sub_294B8((int)a2, 5);
    v35 = sub_294B8((int)v57, 32);
    v36 = sub_1541C((__int64 *)a1);
    if ( !strcmp((const char *)dword_60E98, "screen") )
    {
      if ( a3 )
      {
        sprintf(s, "work %s nonce %s", v30, v33);
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          snprintf(v60, 0x800u, s);
          sub_38438(3, v60, 0);
        }
        v43 = strlen(s);
        fwrite(s, v43, 1u, (FILE *)dword_62C10);
        fwrite(ptr, 1u, 1u, (FILE *)dword_62C10);
        fflush((FILE *)dword_62C10);
      }
    }
    else
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf(v60, 0x800u, s);
        sub_38438(3, v60, 0);
      }
      if ( dword_62C10 )
      {
        if ( a3 )
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
            "o",
            a1[85],
            v30,
            v31,
            v32,
            v34,
            v35,
            v36);
          v37 = strlen(s);
          fwrite(s, v37, 1u, (FILE *)dword_62C10);
          fwrite(ptr, 1u, 1u, (FILE *)dword_62C10);
          fflush((FILE *)dword_62C10);
          if ( dword_62C0C == 1 )
          {
            sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
            v46 = strlen(s);
            fwrite(s, v46, 1u, (FILE *)dword_62C14[0]);
            fwrite(ptr, 1u, 1u, (FILE *)dword_62C14[0]);
            fflush((FILE *)dword_62C14[0]);
          }
          else
          {
            v38 = dword_62C0C == 32;
            if ( dword_62C0C != 32 )
              v38 = dword_62C0C == 64;
            if ( v38 )
            {
              sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
              v44 = sub_2F59C(dword_62C0C, *a2);
              v45 = strlen(s);
              fwrite(s, v45, 1u, (FILE *)dword_62C14[v44]);
              fwrite(ptr, 1u, 1u, (FILE *)dword_62C14[v44]);
              fflush((FILE *)dword_62C14[v44]);
            }
          }
          if ( byte_62D18 )
          {
            v39 = v36;
            for ( m = 0; m != 64; ++m )
            {
              v39 >>= 1;
              if ( !v39 )
                break;
            }
            if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              snprintf(v60, 0x800u, "work diff %lld diffnum %d", v36, m);
              sub_38438(7, v60, 0);
            }
            sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
            v41 = strlen(s);
            fwrite(s, v41, 1u, *((FILE **)&unk_62D1C + m));
            fwrite(ptr, 1u, 1u, *((FILE **)&unk_62D1C + m));
            fflush(*((FILE **)&unk_62D1C + m));
          }
        }
        else
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
            "x",
            a1[85],
            v30,
            v31,
            v32,
            v34,
            v35,
            v36);
          v42 = strlen(s);
          fwrite(s, v42, 1u, (FILE *)dword_62C10);
          fwrite(ptr, 1u, 1u, (FILE *)dword_62C10);
          fflush((FILE *)dword_62C10);
        }
      }
    }
    if ( v30 )
      free(v30);
    if ( v31 )
      free(v31);
    if ( v32 )
      free(v32);
    if ( v33 )
      free(v33);
    if ( v34 )
      free(v34);
    if ( v35 )
      free(v35);
  }
}
// 60964: using guessed type int dword_60964;
// 60E98: using guessed type int dword_60E98;
// 62C0C: using guessed type int dword_62C0C;
// 62C10: using guessed type int dword_62C10;
// 62C14: using guessed type int dword_62C14[];
// 62D18: using guessed type char byte_62D18;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63DF9: using guessed type char byte_63DF9;

//----- (0002FFB0) --------------------------------------------------------
void __fastcall sub_2FFB0(_DWORD *a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-Ch] BYREF
  char v4; // [sp+4h] [bp-8h]

  if ( dword_60E98 )
  {
    v4 = 0;
    v3 = a2;
    sub_2F884(a1, (char *)&v3, a3);
  }
}
// 60E98: using guessed type int dword_60E98;

//----- (0002FFF0) --------------------------------------------------------
unsigned int __fastcall sub_2FFF0(unsigned int result, int a2, int a3)
{
  int *v3; // r1
  int v4; // r0
  int i; // r3
  unsigned int *v6; // r2
  _DWORD *v7; // r3
  int j; // r2
  int v9; // r12
  int *v10; // r2
  unsigned int v11; // r3
  int v12; // r1
  int *v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r5
  int v17; // r4
  int v18; // r9
  unsigned int v19; // r2
  unsigned int v20; // r12
  unsigned int v21; // r6
  int v22; // r11
  int v23; // r8
  int v24; // r7
  int v25; // r8
  unsigned int v26; // r10
  int v27; // r1
  unsigned int v28; // r3
  int *v29; // [sp+0h] [bp-138h] BYREF
  int v30; // [sp+4h] [bp-134h]
  unsigned int v31; // [sp+8h] [bp-130h]
  unsigned int v32; // [sp+Ch] [bp-12Ch]
  int v33; // [sp+10h] [bp-128h]
  int v34; // [sp+14h] [bp-124h] BYREF
  _DWORD *v35; // [sp+18h] [bp-120h]
  _DWORD *v36; // [sp+1Ch] [bp-11Ch]
  _DWORD *v37; // [sp+20h] [bp-118h]
  unsigned int v38; // [sp+24h] [bp-114h]
  int v39; // [sp+28h] [bp-110h]
  int v40; // [sp+2Ch] [bp-10Ch]
  int v41; // [sp+30h] [bp-108h]
  int v42; // [sp+34h] [bp-104h] BYREF
  _BYTE v43[256]; // [sp+38h] [bp-100h] BYREF

  v33 = a3;
  v31 = result;
  v34 = a2;
  if ( a3 > 0 )
  {
    v29 = &v42;
    v30 = 0;
    do
    {
      v3 = &v42;
      v4 = v34 + (v30 << 6);
      for ( i = 0; i != 16; ++i )
      {
        v6 = (unsigned int *)(v4 + 4 * i);
        v3[1] = _byteswap_ulong(*v6);
        ++v3;
      }
      v7 = v43;
      for ( j = 0; j != 192; j += 4 )
      {
        v9 = *(_DWORD *)&v43[j];
        v7[16] = v7[9]
               + v9
               + (__ROR4__(v7[14], 17) ^ __ROR4__(v7[14], 19) ^ (v7[14] >> 10))
               + (__ROR4__(v7[1], 7) ^ __ROR4__(v7[1], 18) ^ (v7[1] >> 3));
        ++v7;
      }
      v10 = &v34;
      v11 = v31;
      v32 = v31;
      do
      {
        v12 = *(_DWORD *)(v11 + 136);
        v11 += 4;
        v13 = v29;
        v10[1] = v12;
        ++v10;
      }
      while ( v10 != v13 );
      v14 = 0;
      v15 = v39;
      v16 = v40;
      v17 = v41;
      v18 = v42;
      v19 = (unsigned int)v35;
      v20 = (unsigned int)v36;
      result = (unsigned int)v37;
      v21 = v38;
      while ( 1 )
      {
        v22 = *(_DWORD *)&v43[v14];
        v23 = *(_DWORD *)((char *)&unk_6027C + v14);
        v14 += 4;
        v24 = v22 + v23 + (__ROR4__(v15, 6) ^ __ROR4__(v15, 11) ^ __ROR4__(v15, 25)) + (v17 & ~v15 ^ v16 & v15) + v18;
        v18 = v17;
        v25 = v21 + v24;
        v26 = ((v20 ^ result) & v19 ^ result & v20) + (__ROR4__(v19, 2) ^ __ROR4__(v19, 13) ^ __ROR4__(v19, 22)) + v24;
        v21 = result;
        if ( v14 == 256 )
          break;
        result = v20;
        v17 = v16;
        v20 = v19;
        v16 = v15;
        v19 = v26;
        v15 = v25;
      }
      v40 = v15;
      v27 = 0;
      v42 = v17;
      v39 = v25;
      v41 = v16;
      v35 = (_DWORD *)v26;
      v36 = (_DWORD *)v19;
      v37 = (_DWORD *)v20;
      v38 = result;
      v28 = v32;
      while ( 1 )
      {
        ++v27;
        *(_DWORD *)(v28 + 136) += v26;
        v28 += 4;
        if ( v27 == 8 )
          break;
        result = (unsigned int)&v29;
        v26 = (unsigned int)(&v29)[v27 + 6];
      }
      ++v30;
    }
    while ( v33 != v30 );
  }
  return result;
}

//----- (00030210) --------------------------------------------------------
_DWORD *__fastcall sub_30210(_DWORD *result)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r2
  int v3; // t1

  v1 = &unk_60378;
  v2 = result;
  do
  {
    v3 = v1[1];
    ++v1;
    v2[34] = v3;
    ++v2;
  }
  while ( v1 != (_DWORD *)&unk_60398 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00030244) --------------------------------------------------------
void *__fastcall sub_30244(int *a1, const void *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r6
  int v8; // r0
  void *result; // r0
  unsigned int v10; // r3
  unsigned int v11; // r5
  size_t v12; // r8
  int v13; // r6
  int v14; // r3

  v4 = a1[1];
  v7 = 64 - v4;
  v8 = v4 + 8;
  if ( n < v7 )
    v7 = n;
  result = memcpy((char *)a1 + v8, a2, v7);
  v10 = n + a1[1];
  if ( v10 > 0x3F )
  {
    v11 = n - v7;
    v12 = v11 & 0x3F;
    v13 = (int)a2 + v7;
    v11 >>= 6;
    sub_2FFF0((unsigned int)a1, (int)(a1 + 2), 1);
    sub_2FFF0((unsigned int)a1, v13, v11);
    result = memcpy(a1 + 2, (const void *)(v13 + (v11 << 6)), v12);
    v14 = *a1;
    a1[1] = v12;
    *a1 = v14 + ((v11 + 1) << 6);
  }
  else
  {
    a1[1] = v10;
  }
  return result;
}

//----- (000302E4) --------------------------------------------------------
_DWORD *__fastcall sub_302E4(_DWORD *a1, int a2)
{
  int v3; // r3
  int v5; // r6
  char *v6; // r0
  int v7; // r6
  int v8; // r2
  size_t v9; // r2
  int v10; // r8
  int v11; // r10
  int v12; // r9
  int v13; // r11
  int v14; // r7
  int v15; // r6
  _DWORD *result; // r0
  int i; // r3
  _BYTE *v18; // r2

  v3 = a1[1];
  v5 = *a1;
  v6 = (char *)a1 + v3 + 8;
  v7 = v3 + v5;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v8 = 128;
  else
    v8 = 64;
  v9 = v8 - v3;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v10 = 31;
  else
    v10 = 15;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v11 = 125;
  else
    v11 = 61;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v12 = 126;
  else
    v12 = 62;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v13 = 127;
  else
    v13 = 63;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v14 = 2;
  else
    v14 = 1;
  memset(v6, 0, v9);
  v15 = 8 * v7;
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  *((_BYTE *)a1 + v13 + 8) = v15;
  *((_BYTE *)a1 + v12 + 8) = BYTE1(v15);
  *((_BYTE *)a1 + v11 + 8) = BYTE2(v15);
  LOBYTE(a1[v10 + 2]) = HIBYTE(v15);
  sub_2FFF0((unsigned int)a1, (int)(a1 + 2), v14);
  result = a1;
  for ( i = 0; i != 8; ++i )
  {
    v18 = (_BYTE *)(a2 + 4 * i);
    v18[3] = result[34];
    v18[2] = BYTE1(result[34]);
    v18[1] = *((_WORD *)result + 69);
    LOBYTE(v18) = *((_BYTE *)result++ + 139);
    *(_BYTE *)(a2 + 4 * i) = (_BYTE)v18;
  }
  return result;
}

//----- (000303DC) --------------------------------------------------------
_DWORD *__fastcall sub_303DC(const void *a1, size_t n, int a3)
{
  _DWORD *v3; // r3
  char *v4; // r12
  int v6; // t1
  int v8[33]; // [sp+0h] [bp-A8h] BYREF
  char v9; // [sp+84h] [bp-24h] BYREF

  v3 = &unk_60378;
  v4 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *((_DWORD *)v4 + 1) = v6;
    v4 += 4;
  }
  while ( v3 != (_DWORD *)&unk_60398 );
  v8[0] = 0;
  v8[1] = 0;
  sub_30244(v8, a1, n);
  return sub_302E4(v8, a3);
}

//----- (00030440) --------------------------------------------------------
char *__fastcall sub_30440(char *s, int a2)
{
  unsigned int v2; // r4
  char *v3; // r8
  char *v5; // r6
  char *v6; // r2
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // t1
  unsigned int v10; // t1
  size_t v12; // r5
  _BYTE *v13; // r0
  _BYTE *v14; // r3
  char *v15; // r2
  unsigned int v16; // t1
  char sa[2052]; // [sp+10h] [bp-804h] BYREF

  v2 = (unsigned __int8)*s;
  v3 = s;
  if ( *s )
  {
    v5 = s;
    v6 = s;
    v7 = (unsigned __int8)*s;
    v8 = 0;
    while ( 1 )
    {
      if ( v7 == 61 )
        goto LABEL_10;
      if ( v7 <= 0x3D )
      {
        if ( v7 == 34 )
        {
          if ( a2 )
            goto LABEL_11;
          goto LABEL_5;
        }
        if ( v7 != 44 )
          goto LABEL_5;
LABEL_10:
        if ( !a2 )
          goto LABEL_11;
LABEL_5:
        v9 = (unsigned __int8)*++v6;
        v7 = v9;
        if ( !v9 )
          goto LABEL_12;
      }
      else
      {
        if ( v7 != 92 )
        {
          if ( v7 != 124 )
            goto LABEL_5;
          goto LABEL_10;
        }
LABEL_11:
        v10 = (unsigned __int8)*++v6;
        v7 = v10;
        ++v8;
        if ( !v10 )
        {
LABEL_12:
          if ( !v8 )
            return v3;
          v12 = v8 + 1 + strlen(s);
          v13 = malloc(v12);
          if ( !v13 )
          {
            snprintf(sa, 0x800u, "Failed to malloc escape buf %d in %s %s():%d", v12, "api.c", "escape_string", 835);
            sub_38438(3, sa, 1);
            sub_16724(1);
          }
          v14 = v13;
          v15 = v3 + 1;
          while ( 2 )
          {
            if ( !v2 )
            {
              v3 = v13;
              *v14 = 0;
              return v3;
            }
            if ( v2 == 61 )
            {
LABEL_28:
              if ( a2 )
                goto LABEL_21;
            }
            else
            {
              if ( v2 > 0x3D )
              {
                if ( v2 == 92 )
                {
                  *v14 = 92;
                  v14[1] = *(v15 - 1);
                  v14 += 2;
                }
                else
                {
                  if ( v2 == 124 )
                    goto LABEL_28;
LABEL_21:
                  *v14++ = v2;
                }
                v16 = (unsigned __int8)*++v5;
                v2 = v16;
                ++v15;
                continue;
              }
              if ( v2 != 34 )
              {
                if ( v2 == 44 )
                  goto LABEL_28;
                goto LABEL_21;
              }
              if ( !a2 )
                goto LABEL_21;
            }
            break;
          }
          *v14++ = 92;
          LOBYTE(v2) = *(v15 - 1);
          goto LABEL_21;
        }
      }
    }
  }
  return v3;
}

//----- (000305DC) --------------------------------------------------------
void sub_305DC()
{
  JUMPOUT(0x3050C);
}
// 305E4: control flows out of bounds to 3050C

//----- (000305F4) --------------------------------------------------------
void *__fastcall sub_305F4(int a1, char *s)
{
  void **v2; // r5
  size_t v5; // r0
  char *v6; // r10
  unsigned int v7; // r1
  char *v8; // r6
  size_t v9; // r4
  size_t v10; // r9
  void *result; // r0
  int v12; // r11
  char sa[2052]; // [sp+18h] [bp-804h] BYREF

  v2 = *(void ***)(a1 + 12);
  v5 = strlen(s);
  v6 = (char *)v2[1];
  v7 = (unsigned int)v2[2];
  v8 = (char *)*v2;
  v9 = v5;
  v10 = v5 + 1;
  if ( (unsigned int)&v6[v5 + 1] > v7 )
  {
    v12 = v5 + 4097 - (v10 & 0xFFF);
    v8 = (char *)realloc(*v2, v12 + v7);
    *v2 = v8;
    if ( !v8 )
    {
      snprintf(
        sa,
        0x800u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v9,
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8),
        v12,
        "api.c",
        "add_item_buf",
        1174);
      sub_38438(3, sa, 1);
      sub_16724(1);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8) += v12;
  }
  result = memcpy(&v6[(_DWORD)v8], s, v10);
  *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) += v9;
  return result;
}

//----- (00030708) --------------------------------------------------------
int __fastcall sub_30708(unsigned int *a1, char *s)
{
  size_t v4; // r5
  _BYTE *v5; // r0
  char *v6; // r3
  int v7; // r8
  unsigned int v8; // r2
  size_t v9; // r7
  char *v10; // r0

  v4 = strlen(s);
  v5 = (_BYTE *)a1[1];
  v6 = (char *)a1[2];
  v7 = v6 - v5;
  v8 = v6 - v5 + 12 + v4;
  if ( v8 > *a1 )
  {
    v9 = *a1 + 0x20000;
    if ( v8 > v9 )
      v9 = ((unsigned int)vcvts_n_f32_u32(v8, 0x10u) + 2) << 16;
    v10 = (char *)realloc(v5, v9);
    *a1 = v9;
    v6 = &v10[v7];
    a1[1] = (unsigned int)v10;
    a1[2] = (unsigned int)&v10[v7];
  }
  memcpy(v6, s, v4 + 1);
  a1[2] += v4;
  return 1;
}

//----- (0003079C) --------------------------------------------------------
void __fastcall sub_3079C(unsigned int *a1, char *s, int a3, _BYTE *a4)
{
  char *v6; // r5

  if ( *a4 )
  {
    if ( !a3 )
    {
      *a4 = 0;
      goto LABEL_5;
    }
    sub_30708(a1, "{");
    *a4 = 0;
    v6 = sub_30440(s, 1);
  }
  else
  {
    if ( !a3 )
    {
LABEL_5:
      v6 = sub_30440(s, a3);
      sub_30708(a1, "CMD=");
      sub_30708(a1, v6);
      sub_30708(a1, (char *)delim);
      if ( v6 == s )
        return;
      goto LABEL_6;
    }
    sub_30708(a1, (char *)",");
    v6 = sub_30440(s, 1);
  }
  sub_30708(a1, (char *)"\"");
  sub_30708(a1, v6);
  sub_30708(a1, "\":[");
  if ( v6 != s )
LABEL_6:
    free(v6);
}

//----- (000308A8) --------------------------------------------------------
int __fastcall sub_308A8(unsigned int *a1, char *s)
{
  _BYTE *v2; // r12

  v2 = (_BYTE *)a1[1];
  a1[2] = (unsigned int)v2;
  *v2 = 0;
  *((_BYTE *)a1 + 13) = 0;
  return sub_30708(a1, s);
}

//----- (000308C0) --------------------------------------------------------
int __fastcall sub_308C0(unsigned int *a1, int a2, int a3, int a4)
{
  char *v4; // r1
  int result; // r0

  if ( a4 )
    v4 = "{\"STATUS\":\"RESTART\"";
  else
    v4 = "RESTART";
  result = sub_308A8(a1, v4);
  byte_62F64 = 1;
  byte_62F65 = 1;
  return result;
}
// 62F64: using guessed type char byte_62F64;
// 62F65: using guessed type char byte_62F65;

//----- (000308F4) --------------------------------------------------------
int __fastcall sub_308F4(unsigned int *a1, int a2, int a3, int a4)
{
  char *v4; // r1
  int result; // r0

  if ( a4 )
    v4 = "{\"STATUS\":\"BYE\"";
  else
    v4 = "BYE";
  result = sub_308A8(a1, v4);
  byte_62F64 = 1;
  byte_62F66 = 1;
  return result;
}
// 62F64: using guessed type char byte_62F64;
// 62F66: using guessed type char byte_62F66;

//----- (00030928) --------------------------------------------------------
bool __fastcall sub_30928(const struct sockaddr *a1, const char **a2, _BYTE *a3)
{
  char *v6; // r0
  int v7; // r7
  int v8; // r2
  char *v9; // r1
  int v10; // r3
  int v11; // r4
  int v12; // r0
  int v13; // t1
  int v14; // t1
  _BOOL4 result; // r0
  int v16; // r5
  char v17; // [sp+Fh] [bp-35h] BYREF
  _BOOL4 buf; // [sp+10h] [bp-34h] BYREF
  int v19; // [sp+14h] [bp-30h]
  int v20; // [sp+18h] [bp-2Ch]
  int v21; // [sp+1Ch] [bp-28h] BYREF
  char s[36]; // [sp+20h] [bp-24h] BYREF

  v6 = (char *)malloc(0x2Eu);
  *a2 = v6;
  getnameinfo(a1, 0x80u, v6, 0x2Eu, 0, 0, 1u);
  if ( a1->sa_family == 2 )
  {
    sprintf(s, "::ffff:%s", *a2);
    inet_pton(10, s, &buf);
  }
  else
  {
    inet_pton(10, *a2, &buf);
  }
  *a3 = (*_ctype_toupper_loc())[82];
  if ( dword_62F4C )
  {
    if ( dword_62F68 > 0 )
    {
      v7 = 0;
      v8 = dword_62F6C - 1;
      do
      {
        v9 = &v17;
        v10 = v8;
        while ( 1 )
        {
          v11 = *(unsigned __int8 *)(v10 + 17);
          v13 = (unsigned __int8)*++v9;
          v12 = v13;
          v14 = *(unsigned __int8 *)++v10;
          if ( v14 != (v11 & v12) )
            break;
          if ( v9 == (char *)&v21 + 3 )
          {
            result = 1;
            *a3 = *(_BYTE *)(v8 + 33);
            return result;
          }
        }
        ++v7;
        v8 += 36;
      }
      while ( v7 != dword_62F68 );
    }
    return 0;
  }
  else
  {
    v16 = (unsigned __int8)byte_63D64;
    if ( byte_63D64 || !strcmp(*a2, "127.0.0.1") )
    {
      return 1;
    }
    else
    {
      result = buf;
      if ( buf )
      {
        return v16;
      }
      else if ( !v19 )
      {
        if ( v20 )
          return v19;
        else
          return v21 == 0x1000000;
      }
    }
  }
  return result;
}
// 62F4C: using guessed type int dword_62F4C;
// 62F68: using guessed type int dword_62F68;
// 62F6C: using guessed type int dword_62F6C;
// 63D64: using guessed type char byte_63D64;

//----- (00030AC8) --------------------------------------------------------
void __fastcall sub_30AC8(int a1, int a2, int a3)
{
  char *v4; // r7
  signed int v5; // r0
  const char *v6; // r3
  signed int v7; // r4
  int v8; // r5
  int v9; // r10
  _BOOL4 v10; // r3
  fd_set *p_tv_usec; // r3
  int v12; // r0
  ssize_t v13; // r0
  ssize_t v14; // r12
  int v15; // r0
  char *v16; // r0
  ssize_t v17; // [sp+8h] [bp-894h]
  ssize_t v18; // [sp+8h] [bp-894h]
  signed int v20; // [sp+Ch] [bp-890h]
  struct timeval timeout; // [sp+10h] [bp-88Ch] BYREF
  fd_set writefds; // [sp+18h] [bp-884h] BYREF
  char s[2040]; // [sp+98h] [bp-804h] BYREF

  v4 = *(char **)(a1 + 4);
  if ( *(_BYTE *)(a1 + 13) )
  {
    *(_WORD *)&v4[strlen(*(const char **)(a1 + 4))] = 93;
    if ( !a3 )
      goto LABEL_3;
  }
  else if ( !a3 )
  {
    goto LABEL_3;
  }
  strcat(v4, ",\"id\":1}");
LABEL_3:
  v5 = strlen(v4);
  v20 = v5 + 1;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    if ( v5 > 10 )
      v6 = "...";
    else
      v6 = "";
    snprintf(s, 0x800u, "API: send reply: (%d) '%.10s%s'", v20, v4, v6);
    sub_38438(7, s, 0);
  }
  v7 = v20;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = v7 > 0;
    if ( v9 > 4 )
      v10 = 0;
    if ( !v10 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&writefds.__fds_bits[31] );
    writefds.__fds_bits[a2 / 32] |= 1 << (a2 % 32);
    v12 = select(a2 + 1, 0, &writefds, 0, &timeout);
    if ( v12 <= 0 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(s, 0x800u, "API: send select failed (%d)", v12);
        sub_38438(4, s, 0);
      }
      return;
    }
    v13 = send(a2, v4, v7, 0);
    ++v8;
    v14 = v13;
    if ( v13 < 0 )
    {
      v15 = *_errno_location();
      if ( v15 != 11 )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          v16 = strerror(v15);
          snprintf(s, 0x800u, "API: send (%d:%d) failed: %s", v20, v20 - v7, v16);
          sub_38438(4, s, 0);
        }
        return;
      }
LABEL_25:
      ++v9;
    }
    else if ( v8 == 1 )
    {
      if ( v13 != v7 )
      {
        if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
          goto LABEL_24;
        v17 = v13;
        snprintf(s, 0x800u, "API: sent %d of %d first go", v13, v7);
        goto LABEL_23;
      }
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        v18 = v13;
        snprintf(s, 0x800u, "API: sent all of %d first go", v13);
        goto LABEL_41;
      }
LABEL_42:
      v7 -= v14;
      v4 += v14;
    }
    else
    {
      if ( v13 == v7 )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v18 = v13;
          snprintf(s, 0x800u, "API: sent all of remaining %d (sendc=%d)", v13, v8);
LABEL_41:
          sub_38438(7, s, 0);
          v14 = v18;
          goto LABEL_42;
        }
        goto LABEL_42;
      }
      if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
        goto LABEL_24;
      v17 = v13;
      snprintf(s, 0x800u, "API: sent %d of remaining %d (sendc=%d)", v13, v7, v8);
LABEL_23:
      sub_38438(7, s, 0);
      v14 = v17;
LABEL_24:
      v7 -= v14;
      v4 += v14;
      if ( !v14 )
        goto LABEL_25;
    }
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00030FBC) --------------------------------------------------------
int sub_30FBC()
{
  struct addrinfo *v0; // r4
  struct addrinfo *i; // r3
  int v2; // r0
  int v3; // r9
  time_t v4; // r7
  int ai_family; // r3
  const char *v6; // r7
  size_t v7; // r0
  size_t v8; // r4
  int v9; // r5
  ssize_t v10; // r4
  _BOOL4 v11; // r12
  const char *v12; // r2
  int *v13; // r0
  char *v14; // r8
  struct addrinfo *v15; // r0
  int *v16; // r0
  char *v17; // r0
  int *v19; // r0
  char *v20; // r0
  const char *v21; // r4
  int v22; // r0
  struct addrinfo *v23; // r4
  int v24; // r0
  int v25; // r12
  size_t v26; // r0
  ssize_t v27; // r4
  int *v28; // r0
  char *v29; // r0
  int *v30; // r0
  char *v31; // r0
  int v32; // r1
  int v33; // r2
  int v34; // r3
  _BOOL4 v35; // [sp+14h] [bp-10F0h]
  int v36; // [sp+14h] [bp-10F0h]
  size_t n; // [sp+18h] [bp-10ECh]
  char *v38; // [sp+1Ch] [bp-10E8h]
  int fd; // [sp+20h] [bp-10E4h]
  char v40; // [sp+2Bh] [bp-10D9h] BYREF
  socklen_t addr_len; // [sp+2Ch] [bp-10D8h] BYREF
  const char *v42; // [sp+30h] [bp-10D4h] BYREF
  struct addrinfo *pai; // [sp+34h] [bp-10D0h] BYREF
  int optval; // [sp+38h] [bp-10CCh] BYREF
  char v45[12]; // [sp+3Ch] [bp-10C8h] BYREF
  char s[12]; // [sp+48h] [bp-10BCh] BYREF
  char serv[12]; // [sp+54h] [bp-10B0h] BYREF
  struct addrinfo req; // [sp+60h] [bp-10A4h] BYREF
  struct sockaddr v49[8]; // [sp+80h] [bp-1084h] BYREF
  char v50[1024]; // [sp+100h] [bp-1004h] BYREF
  int v51; // [sp+500h] [bp-C04h] BYREF
  int v52; // [sp+504h] [bp-C00h]
  int v53; // [sp+508h] [bp-BFCh]
  int v54; // [sp+50Ch] [bp-BF8h]
  int v55; // [sp+510h] [bp-BF4h]
  char v56[2052]; // [sp+900h] [bp-804h] BYREF

  strcpy(v45, "cgminer-");
  sprintf(s, "%d", dword_6015C);
  memset(&req, 0, sizeof(req));
  if ( getaddrinfo(off_60168[0], s, &req, &pai) )
  {
    strcpy(v56, "Invalid API Multicast Address");
    sub_38438(3, v56, 1);
    sub_16724(1);
  }
  v0 = pai;
  if ( !pai )
  {
    v15 = 0;
LABEL_43:
    freeaddrinfo(v15);
    strcpy(v56, "API mcast could not open socket");
    sub_38438(3, v56, 1);
    sub_16724(1);
  }
  for ( i = pai; ; i = pai )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      v3 = v2;
      goto LABEL_8;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  v3 = v2;
  if ( v2 == -1 )
  {
    v15 = pai;
    goto LABEL_43;
  }
LABEL_8:
  optval = 1;
  if ( setsockopt(v3, 1, 2, &optval, 4u) < 0 )
  {
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
      return close(v3);
    v16 = _errno_location();
    v17 = strerror(*v16);
    snprintf(
      v56,
      0x800u,
      "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
      v17,
      " - API multicast listener will not be available");
LABEL_48:
    sub_38438(3, v56, 0);
    return close(v3);
  }
  v4 = time(0);
  while ( 1 )
  {
    if ( bind(v3, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        v51 = 0;
        v52 = 0;
        v51 = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(v3, 0, 35, &v51, 8u) < 0 )
        {
LABEL_97:
          if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
            return close(v3);
          v30 = _errno_location();
          v31 = strerror(*v30);
          snprintf(v56, 0x800u, "API mcast join failed (%s)%s", v31, " - API multicast listener will not be available");
          goto LABEL_48;
        }
      }
      else if ( ai_family == 10 )
      {
        v32 = *(_DWORD *)&v0->ai_addr->sa_data[10];
        v33 = *(_DWORD *)&v0->ai_addr[1].sa_family;
        v34 = *(_DWORD *)&v0->ai_addr[1].sa_data[2];
        v51 = *(_DWORD *)&v0->ai_addr->sa_data[6];
        v52 = v32;
        v53 = v33;
        v54 = v34;
        v55 = 0;
        if ( setsockopt(v3, 41, 20, &v51, 0x14u) < 0 )
          goto LABEL_97;
      }
      freeaddrinfo(pai);
      v6 = off_60164[0];
      v7 = strlen(off_60164[0]);
      v8 = v7 + 10;
      n = v7 + 9;
      v38 = (char *)malloc(v7 + 10);
      if ( !v38 )
      {
        strcpy(v56, "Failed to malloc mcast expect_code");
        sub_38438(3, v56, 1);
        sub_16724(1);
      }
      v9 = 0;
      snprintf(v38, v8, "%s%s-", v45, v6);
      fd = -1;
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              do
              {
                while ( 1 )
                {
                  ++v9;
                  sub_2B21C();
                  addr_len = 128;
                  v10 = recvfrom(v3, v50, 0x3FFu, 0, v49, &addr_len);
                  if ( v10 >= 0 )
                    break;
                  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                  {
                    v19 = _errno_location();
                    v20 = strerror(*v19);
                    snprintf(v56, 0x800u, "API mcast failed count=%d (%s) (%d)", v9, v20, v3);
                    sub_38438(7, v56, 0);
                  }
                }
                v11 = sub_30928(v49, &v42, &v40);
                if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                {
                  v12 = "Ignored";
                  v35 = v11;
                  if ( v11 )
                    v12 = "Accepted";
                  snprintf(v56, 0x800u, "API mcast from %s - %s", v42, v12);
                  sub_38438(7, v56, 0);
                  v11 = v35;
                }
              }
              while ( !v11 );
              v50[v10] = 0;
              if ( v10 && v49[7].sa_data[v10 + 13] == 10 )
                v50[--v10] = 0;
              getnameinfo(v49, addr_len, 0, 0, serv, 0xAu, 1u);
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf(v56, 0x800u, "API mcast request rep=%d (%s) from [%s]:%s", v10, v50, v42, serv);
                sub_38438(7, v56, 0);
              }
              if ( n < v10 && !memcmp(v50, v38, n) )
                break;
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                strcpy(v56, "API mcast request was no good");
                sub_38438(7, v56, 0);
              }
            }
            v21 = &v50[n];
            v22 = strtol(&v50[n], 0, 10);
            if ( (unsigned int)(v22 - 1) <= 0xFFFE )
              break;
            if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              snprintf(v56, 0x800u, "API mcast request ignored - invalid port (%s)", v21);
              sub_38438(7, v56, 0);
            }
          }
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(v56, 0x800u, "API mcast request OK port %s=%d", v21, v22);
            sub_38438(7, v56, 0);
          }
          if ( !getaddrinfo(v42, v21, &req, &pai) )
            break;
          if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(v56, 0x800u, "Invalid client address %s", v42);
            goto LABEL_71;
          }
        }
        v23 = pai;
        if ( pai && (v24 = socket(pai->ai_family, 2, 0), v25 = -4300, fd = v24, v3 <= 0) )
        {
          while ( 1 )
          {
            v23 = v23->ai_next;
            if ( !v23 )
              break;
            v36 = v25;
            v24 = socket(*(_DWORD *)(*(_DWORD *)&v56[v25 + 2048] + 4), 2, 0);
            v25 = v36;
          }
          fd = v24;
          if ( v24 == -1 )
            goto LABEL_85;
LABEL_75:
          snprintf((char *)&v51, 0x400u, "cgm-FTW-%d-%s", dword_60170, (const char *)off_60160);
          v26 = strlen((const char *)&v51);
          v27 = sendto(fd, &v51, v26 + 1, 0, v23->ai_addr, v23->ai_addrlen);
          freeaddrinfo(pai);
          if ( v27 < 0 )
          {
            if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              v28 = _errno_location();
              v29 = strerror(*v28);
              snprintf(v56, 0x800u, "API mcast send reply failed (%s) (%d)", v29, fd);
              sub_38438(7, v56, 0);
            }
          }
          else if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(v56, 0x800u, "API mcast send reply (%s) succeeded (%d) (%d)", (const char *)&v51, v27, fd);
            sub_38438(7, v56, 0);
          }
          close(fd);
        }
        else
        {
          if ( fd != -1 )
            goto LABEL_75;
LABEL_85:
          freeaddrinfo(pai);
          if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(v56, 0x800u, "API mcast could not open socket to client %s", v42);
LABEL_71:
            sub_38438(3, v56, 0);
          }
        }
      }
    }
    v13 = _errno_location();
    v14 = strerror(*v13);
    if ( time(0) - v4 > 61 )
      break;
    sub_2B21C();
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
  {
    snprintf(
      v56,
      0x800u,
      "API mcast bind to port %d failed (%s)%s",
      dword_6015C,
      v14,
      " - API multicast listener will not be available");
    sub_38438(3, v56, 0);
  }
  return close(v3);
}
// 6015C: using guessed type int dword_6015C;
// 60160: using guessed type _UNKNOWN *off_60160;
// 60164: using guessed type char *off_60164[3];
// 60168: using guessed type char *off_60168[2];
// 60170: using guessed type int dword_60170;
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00031BD4) --------------------------------------------------------
int __fastcall sub_31BD4(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_2F02C("APIMcast");
  sub_30FBC();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}

//----- (00031C10) --------------------------------------------------------
_DWORD *__fastcall sub_31C10(_DWORD *a1, const char *a2, int a3, const char *a4, char a5)
{
  _DWORD *v9; // r4
  char *v10; // r0
  bool v11; // zf
  int v12; // r3
  _DWORD *v14; // r0
  _QWORD *v15; // r0
  _WORD *v16; // r0
  _BYTE *v17; // r0
  _BYTE *v18; // r0
  _DWORD *v19; // r0
  int v20; // r1
  size_t v21; // r0
  char *v22; // r0
  char v23[2052]; // [sp+0h] [bp-804h] BYREF

  v9 = malloc(0x18u);
  v10 = _strdup(a2);
  v11 = a1 == 0;
  *v9 = a3;
  if ( !a1 )
  {
    v9[4] = v9;
    a1 = v9;
    v9[5] = v9;
  }
  v9[1] = v10;
  if ( !v11 )
  {
    v9[4] = a1[4];
    a1[4] = v9;
    v12 = v9[4];
    v9[5] = a1;
    *(_DWORD *)(v12 + 20) = v9;
  }
  *((_BYTE *)v9 + 12) = a5;
  if ( !a4 )
  {
    *((_BYTE *)v9 + 12) = 0;
    a4 = "(null)";
    *v9 = 2;
    goto LABEL_9;
  }
  if ( !a5 )
  {
LABEL_9:
    v9[2] = a4;
    return a1;
  }
  switch ( a3 )
  {
    case 0:
    case 1:
    case 2:
      v21 = strlen(a4);
      v22 = (char *)malloc(v21 + 1);
      v9[2] = v22;
      strcpy(v22, a4);
      break;
    case 3:
      v17 = malloc(4u);
      v9[2] = v17;
      *v17 = *a4;
      break;
    case 4:
    case 5:
      v16 = malloc(4u);
      v9[2] = v16;
      *v16 = *(_WORD *)a4;
      break;
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      v14 = malloc(4u);
      v9[2] = v14;
      *v14 = *(_DWORD *)a4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      v15 = malloc(8u);
      v9[2] = v15;
      *v15 = *(_QWORD *)a4;
      break;
    case 14:
      v18 = malloc(1u);
      v9[2] = v18;
      *v18 = *a4;
      break;
    case 15:
      v19 = malloc(8u);
      v9[2] = v19;
      v20 = *((_DWORD *)a4 + 1);
      *v19 = *(_DWORD *)a4;
      v19[1] = v20;
      break;
    default:
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf(v23, 0x800u, "API: unknown1 data type %d ignored", a3);
        sub_38438(3, v23, 0);
      }
      *v9 = 1;
      *((_BYTE *)v9 + 12) = 0;
      v9[2] = "Unknown";
      break;
  }
  return a1;
}
// 31C90: control flows out of bounds to 31C94
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (00031E94) --------------------------------------------------------
int __fastcall sub_31E94(int result, int a2)
{
  int v2; // r4

  v2 = result;
  if ( !*(_BYTE *)(result + 13) )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  result = sub_30708((unsigned int *)result, (char *)word_56150);
  *(_BYTE *)(v2 + 13) = 0;
  if ( a2 )
  {
LABEL_3:
    sub_30708((unsigned int *)v2, ",\"id\":1}");
    return sub_30708((unsigned int *)v2, (char *)word_56150);
  }
  return result;
}

//----- (00031EF4) --------------------------------------------------------
unsigned __int8 **__fastcall sub_31EF4(unsigned __int8 **result, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // r3
  int v3; // r2
  unsigned __int8 *v4; // r12
  unsigned __int8 *v5; // r2
  unsigned __int8 *v6; // r3

  v2 = *result;
  v3 = **result;
  if ( **result )
  {
    while ( v3 != 44 )
    {
      if ( v3 == 92 && (v4 = v2 + 1, v2[1]) )
        *result = v4;
      else
        v4 = *result;
      v5 = *a2;
      v2 = v4 + 1;
      *v5 = *v4;
      *a2 = v5 + 1;
      *result = v4 + 1;
      v3 = v4[1];
      if ( !v4[1] )
        goto LABEL_11;
    }
    *result = v2 + 1;
  }
LABEL_11:
  v6 = *a2;
  *v6 = 0;
  *a2 = v6 + 1;
  return result;
}

//----- (00031F7C) --------------------------------------------------------
int __fastcall sub_31F7C(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, _DWORD *a4)
{
  size_t v7; // r0
  unsigned __int8 *v8; // r0
  unsigned __int8 *v9; // r4
  unsigned __int8 *v11[2]; // [sp+4h] [bp-80Ch] BYREF
  unsigned __int8 *v12; // [sp+Ch] [bp-804h] BYREF
  char v13[2048]; // [sp+10h] [bp-800h] BYREF

  v11[0] = a1;
  v7 = strlen((const char *)a1);
  v8 = (unsigned __int8 *)malloc(v7 + 1);
  v9 = v8;
  v12 = v8;
  if ( !v8 )
  {
    strcpy(v13, "Failed to malloc pooldetails buf");
    sub_38438(3, v13, 1);
    sub_16724(1);
  }
  *a2 = v8;
  sub_31EF4(v11, &v12);
  if ( *v11[0] && (*a3 = v12, sub_31EF4(v11, &v12), *v11[0]) )
  {
    *a4 = v12;
    sub_31EF4(v11, &v12);
    return 1;
  }
  else
  {
    free(v9);
    return 0;
  }
}

//----- (00032074) --------------------------------------------------------
int __fastcall sub_32074(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_rdlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x800u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "api.c", a2, a3);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (000320F0) --------------------------------------------------------
int __fastcall sub_320F0(pthread_mutex_t *a1, const char *a2, int a3)
{
  if ( pthread_mutex_unlock(a1) )
    sub_B91C(a2, a3);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();

//----- (0003212C) --------------------------------------------------------
int sub_3212C()
{
  char v1[2052]; // [sp+0h] [bp-804h] BYREF

  if ( pthread_mutex_lock(&stru_62F70) )
    sub_B844("restart_thread", 4933);
  if ( pthread_mutex_unlock(&stru_62F70) )
    sub_B91C("restart_thread", 4934);
  off_60178();
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v1, "API: restarting cgminer");
    sub_38438(7, v1, 0);
  }
  sub_1C028();
  return 0;
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00032224) --------------------------------------------------------
void __noreturn sub_32224()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( !pthread_mutex_lock(&stru_62F70) )
  {
    if ( !pthread_mutex_unlock(&stru_62F70) )
    {
      off_60178();
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy(v0, "API: killing cgminer");
        sub_38438(7, v0, 0);
      }
      sub_17328();
    }
    sub_B91C("quit_thread", 4920);
  }
  sub_B844("quit_thread", 4919);
}
// 32224: using guessed type void __noreturn sub_32224();
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00032320) --------------------------------------------------------
int __fastcall sub_32320(int *a1)
{
  int v2; // r0
  bool v3; // zf
  int v4; // r6
  void **v5; // r4
  void **v6; // r5

  if ( pthread_mutex_lock(&stru_62F70) )
    sub_B844("tidyup", 4602);
  v2 = *a1;
  v3 = *a1 == -1;
  byte_62F64 = 1;
  if ( !v3 )
  {
    shutdown(v2, 2);
    close(*a1);
    *a1 = -1;
  }
  if ( dword_62F6C )
  {
    free((void *)dword_62F6C);
    dword_62F6C = 0;
  }
  v4 = dword_62F88;
  if ( dword_62F88 )
  {
    v5 = (void **)dword_62F88;
    do
    {
      v6 = (void **)v5[2];
      free(*((void **)*v5 + 1));
      free(*v5);
      free(v5);
      v5 = v6;
    }
    while ( (void **)v4 != v6 );
    dword_62F88 = 0;
  }
  if ( pthread_mutex_unlock(&stru_62F70) )
    sub_B91C("tidyup", 4623);
  return off_60178();
}
// 60178: using guessed type int (*off_60178)();
// 62F64: using guessed type char byte_62F64;
// 62F6C: using guessed type int dword_62F6C;
// 62F88: using guessed type int dword_62F88;

//----- (00032418) --------------------------------------------------------
int __fastcall sub_32418(unsigned int *a1, int a2, int a3, int a4)
{
  int v8; // r5
  int v9; // r0
  int v10; // r8
  int v11; // r5
  int v12; // r0
  int v13; // r3
  int v14; // r2
  void *v15; // r0
  char *v16; // r1
  int v17; // r4
  int v18; // r4
  const char *v20; // r3
  char *v21; // r11
  char *v22; // r3
  int *v23; // r0
  int *v24; // r0
  char *ptr; // [sp+10h] [bp-84Ch]
  char s[64]; // [sp+18h] [bp-844h] BYREF
  char v27[2052]; // [sp+58h] [bp-804h] BYREF

  v8 = *(_DWORD *)(dword_62F8C + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v8) )
    sub_B844("print_data", 1191);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v8 + 24)) )
  {
    v24 = _errno_location();
    snprintf(v27, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1191);
    sub_38438(3, v27, 1);
    sub_16724(1);
  }
  v9 = sub_38EEC(dword_62F8C, "api.c", "print_data", 1192);
  v10 = *(_DWORD *)(dword_62F8C + 8);
  v11 = v9;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 24)) )
    sub_B8B0("print_data", 1193);
  if ( pthread_mutex_unlock((pthread_mutex_t *)v10) )
    sub_B91C("print_data", 1193);
  off_60178();
  *(_DWORD *)(*(_DWORD *)(v11 + 12) + 4) = 0;
  if ( a4 )
    sub_305F4(v11, (char *)",");
  if ( a3 )
    sub_305F4(v11, "{");
  if ( a2 )
  {
    v12 = v11;
    if ( a3 )
      goto LABEL_18;
LABEL_11:
    sub_305F4(v12, *(char **)(a2 + 4));
    sub_305F4(v11, "=");
    while ( 1 )
    {
      switch ( *(_DWORD *)a2 )
      {
        case 0:
          v21 = *(char **)(a2 + 8);
          v22 = sub_30440(v21, a3);
          ptr = v22;
          if ( a3 )
          {
            sub_305F4(v11, (char *)"\"");
            sub_305F4(v11, ptr);
            sub_305F4(v11, (char *)"\"");
          }
          else
          {
            sub_305F4(v11, v22);
          }
          if ( ptr != v21 )
            free(ptr);
          break;
        case 1:
        case 2:
          if ( a3 )
          {
            sub_305F4(v11, (char *)"\"");
            sub_305F4(v11, *(char **)(a2 + 8));
            sub_305F4(v11, (char *)"\"");
          }
          else
          {
            sub_305F4(v11, *(char **)(a2 + 8));
          }
          break;
        case 3:
          snprintf(s, 0x40u, "%u", **(unsigned __int8 **)(a2 + 8));
          goto LABEL_14;
        case 4:
          snprintf(s, 0x40u, "%d", **(__int16 **)(a2 + 8));
          goto LABEL_14;
        case 5:
          snprintf(s, 0x40u, "%u", **(unsigned __int16 **)(a2 + 8));
          goto LABEL_14;
        case 6:
          snprintf(s, 0x40u, "%d", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 7:
        case 8:
          snprintf(s, 0x40u, "%u", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 9:
          if ( a3 )
          {
            sub_305F4(v11, (char *)"\"");
            snprintf(s, 0x40u, "0x%08x", **(_DWORD **)(a2 + 8));
            sub_305F4(v11, s);
            sub_305F4(v11, (char *)"\"");
          }
          else
          {
            snprintf(s, 0x40u, "0x%08x", **(_DWORD **)(a2 + 8));
            sub_305F4(v11, s);
          }
          break;
        case 0xA:
          snprintf(s, 0x40u, "%llu", *(_QWORD *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xB:
          snprintf(s, 0x40u, "%lld", *(_QWORD *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xC:
          snprintf(s, 0x40u, "%f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xD:
          snprintf(s, 0x40u, "%.0f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xE:
          v20 = "false";
          if ( **(_BYTE **)(a2 + 8) )
            v20 = "true";
          snprintf(s, 0x40u, "%s", v20);
          goto LABEL_14;
        case 0xF:
          snprintf(s, 0x40u, "%ld.%06ld", **(_DWORD **)(a2 + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4));
          goto LABEL_14;
        case 0x10:
          snprintf(s, 0x40u, "%lu", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 0x11:
        case 0x14:
        case 0x15:
          snprintf(s, 0x40u, "%.2f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x12:
          snprintf(s, 0x40u, "%.4f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x13:
          snprintf(s, 0x40u, "%.2f", **(float **)(a2 + 8));
          goto LABEL_14;
        case 0x16:
        case 0x1A:
          snprintf(s, 0x40u, "%.3f", **(float **)(a2 + 8));
          goto LABEL_14;
        case 0x17:
          snprintf(s, 0x40u, "%.15f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x18:
          snprintf(s, 0x40u, "%.8f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x19:
          snprintf(s, 0x40u, "%.4f", *(double *)*(_DWORD *)(a2 + 8) * 100.0);
LABEL_14:
          sub_305F4(v11, s);
          break;
        default:
          if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(v27, 0x800u, "API: unknown2 data type %d ignored", *(_DWORD *)a2);
            sub_38438(3, v27, 0);
          }
          if ( a3 )
          {
            sub_305F4(v11, (char *)"\"");
            sub_305F4(v11, "Unknown");
            sub_305F4(v11, (char *)"\"");
          }
          else
          {
            sub_305F4(v11, "Unknown");
          }
          break;
      }
      free(*(void **)(a2 + 4));
      if ( *(_BYTE *)(a2 + 12) )
      {
        free(*(void **)(a2 + 8));
        v13 = *(_DWORD *)(a2 + 20);
        if ( v13 == a2 )
        {
LABEL_20:
          free((void *)a2);
          break;
        }
      }
      else
      {
        v13 = *(_DWORD *)(a2 + 20);
        if ( v13 == a2 )
          goto LABEL_20;
      }
      v14 = *(_DWORD *)(a2 + 16);
      v15 = (void *)a2;
      a2 = v13;
      *(_DWORD *)(v13 + 16) = v14;
      *(_DWORD *)(v14 + 20) = v13;
      free(v15);
      sub_305F4(v11, (char *)",");
      v12 = v11;
      if ( !a3 )
        goto LABEL_11;
LABEL_18:
      sub_305F4(v12, (char *)"\"");
      sub_305F4(v11, *(char **)(a2 + 4));
      sub_305F4(v11, (char *)"\"");
      sub_305F4(v11, (char *)":");
    }
  }
  if ( a3 )
    v16 = (char *)"}";
  else
    v16 = (char *)delim;
  sub_305F4(v11, v16);
  sub_30708(a1, **(char ***)(v11 + 12));
  v17 = *(_DWORD *)(dword_62F8C + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v17) )
    sub_B844("print_data", 1363);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v17 + 24)) )
  {
    v23 = _errno_location();
    snprintf(v27, 0x800u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "api.c", "print_data", 1363);
    sub_38438(3, v27, 1);
    sub_16724(1);
  }
  sub_39058(dword_62F8C, v11, "api.c", "print_data", 1364);
  v18 = *(_DWORD *)(dword_62F8C + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v18 + 24)) )
    sub_B8B0("print_data", 1365);
  if ( pthread_mutex_unlock((pthread_mutex_t *)v18) )
    sub_B91C("print_data", 1365);
  off_60178();
  return 0;
}
// 32510: control flows out of bounds to 32514
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 62F8C: using guessed type int dword_62F8C;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (00032CD8) --------------------------------------------------------
_DWORD *__fastcall sub_32CD8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 0, a3, a4);
}

//----- (00032CFC) --------------------------------------------------------
_DWORD *__fastcall sub_32CFC(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 1, a3, a4);
}

//----- (00032D20) --------------------------------------------------------
_DWORD *__fastcall sub_32D20(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 2, a3, a4);
}

//----- (00032D44) --------------------------------------------------------
_DWORD *__fastcall sub_32D44(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 3, a3, a4);
}

//----- (00032D68) --------------------------------------------------------
_DWORD *__fastcall sub_32D68(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 4, a3, a4);
}

//----- (00032D8C) --------------------------------------------------------
_DWORD *__fastcall sub_32D8C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 5, a3, a4);
}

//----- (00032DB0) --------------------------------------------------------
_DWORD *__fastcall sub_32DB0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 6, a3, a4);
}

//----- (00032DD4) --------------------------------------------------------
_DWORD *__fastcall sub_32DD4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 7, a3, a4);
}

//----- (00032DF8) --------------------------------------------------------
_DWORD *__fastcall sub_32DF8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 8, a3, a4);
}

//----- (00032E1C) --------------------------------------------------------
_DWORD *__fastcall sub_32E1C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 9, a3, a4);
}

//----- (00032E40) --------------------------------------------------------
_DWORD *__fastcall sub_32E40(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 10, a3, a4);
}

//----- (00032E64) --------------------------------------------------------
_DWORD *__fastcall sub_32E64(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 11, a3, a4);
}

//----- (00032E88) --------------------------------------------------------
_DWORD *__fastcall sub_32E88(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 12, a3, a4);
}

//----- (00032EAC) --------------------------------------------------------
_DWORD *__fastcall sub_32EAC(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 13, a3, a4);
}

//----- (00032ED0) --------------------------------------------------------
_DWORD *__fastcall sub_32ED0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 14, a3, a4);
}

//----- (00032EF4) --------------------------------------------------------
_DWORD *__fastcall sub_32EF4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 15, a3, a4);
}

//----- (00032F18) --------------------------------------------------------
_DWORD *__fastcall sub_32F18(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 16, a3, a4);
}

//----- (00032F3C) --------------------------------------------------------
int __fastcall sub_32F3C(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  int v8; // r12
  int *v9; // r1
  int v10; // lr
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r4
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  int result; // r0
  int v18; // lr
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  char *v21; // r2
  int v22; // [sp+4h] [bp-200Ch] BYREF
  char v23[4]; // [sp+8h] [bp-2008h] BYREF
  int v24; // [sp+Ch] [bp-2004h] BYREF
  char s[8176]; // [sp+10h] [bp-2000h] BYREF

  v22 = a2;
  if ( a5 )
    sub_30708(a1, "{\"STATUS\":[");
  v8 = dword_6039C[0];
  if ( dword_6039C[0] == 4 )
  {
LABEL_9:
    v11 = sub_32CFC(0, "STATUS", "F", 0);
    v12 = sub_32F18(v11, "When", (const char *)&dword_62F90, 0);
    v24 = -1;
    v13 = sub_32DB0(v12, "Code", (const char *)&v24, 0);
    sprintf(s, "%d", v22);
    v14 = v13;
    goto LABEL_10;
  }
  if ( dword_603A0 != v22 )
  {
    v9 = dword_6039C;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[4];
      ++v10;
      v9 += 4;
      if ( v8 == 4 )
        goto LABEL_9;
      if ( v9[1] == v22 )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case 2:
      v23[0] = 73;
      break;
    case 3:
      v23[0] = 83;
      break;
    case 1:
      v23[0] = 87;
      break;
    default:
      v23[0] = 69;
      break;
  }
  v18 = 4 * v10;
  v23[1] = 0;
  switch ( dword_6039C[v18 + 2] )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      sprintf(s, (const char *)dword_6039C[v18 + 3], a3);
      break;
    case 5:
      sprintf(s, (const char *)dword_6039C[v18 + 3], dword_63740);
      break;
    case 6:
      sprintf(s, (const char *)dword_6039C[v18 + 3], a3, dword_63740 - 1);
      break;
    case 7:
      sprintf(s, (const char *)dword_6039C[v18 + 3]);
      break;
    case 8:
      sprintf(s, (const char *)dword_6039C[v18 + 3], "command");
      break;
    case 9:
      sprintf(s, (const char *)dword_6039C[v18 + 3], a3, *(_DWORD *)(*(_DWORD *)(dword_639E0 + 4 * a3) + 164));
      break;
    case 10:
      sprintf(s, (const char *)dword_6039C[v18 + 3], a4);
      break;
    case 11:
      sprintf(s, (const char *)dword_6039C[v18 + 3], a3, a4);
      break;
    case 12:
      v21 = "false";
      if ( a3 )
        v21 = "true";
      sprintf(s, (const char *)dword_6039C[v18 + 3], v21);
      break;
    case 13:
      sprintf(s, (const char *)dword_6039C[v18 + 3], a4, a3);
      break;
    default:
      strcpy(s, (const char *)dword_6039C[v18 + 3]);
      break;
  }
  v19 = sub_32CFC(0, "STATUS", v23, 0);
  v20 = sub_32F18(v19, "When", (const char *)&dword_62F90, 0);
  v14 = sub_32DB0(v20, "Code", (const char *)&v22, 0);
LABEL_10:
  v15 = sub_32CD8(v14, "Msg", s, 0);
  v16 = sub_32CD8(v15, "Description", (const char *)off_60174, 0);
  result = sub_32418(a1, (int)v16, a5, 0);
  if ( a5 )
    return sub_30708(a1, (char *)word_56150);
  return result;
}
// 330F0: control flows out of bounds to 330F4
// 60174: using guessed type _UNKNOWN *off_60174;
// 6039C: using guessed type int dword_6039C[];
// 603A0: using guessed type int dword_603A0;
// 62F90: using guessed type int dword_62F90;
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00033354) --------------------------------------------------------
int __fastcall sub_33354(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32F3C(a1, 124, 0, 0, a4);
}

//----- (00033428) --------------------------------------------------------
int __fastcall sub_33428(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32F3C(a1, 102, 0, 0, a4);
}

//----- (0003343C) --------------------------------------------------------
int __fastcall sub_3343C(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r5
  char *v7; // r0
  char *v8; // r7
  int v9; // r8
  int v10; // r10
  int v11; // r9
  int v12; // r2
  bool v13; // zf
  _BOOL4 v14; // r4
  const char *v16; // r3
  int v17; // r1
  unsigned __int8 v18; // [sp+20h] [bp+20h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = strchr(a3, 44);
    v8 = v7;
    if ( v7 && (*v7 = 0, v7 != (char *)-1) && (v9 = (unsigned __int8)v7[1], v7[1]) )
    {
      if ( !strcasecmp(a3, "all") )
      {
        v11 = 0;
        v10 = 1;
      }
      else
      {
        if ( strcasecmp(a3, "bestshare") )
        {
          v18 = a4;
          a1 = v5;
          v16 = a3;
          v17 = 95;
          return sub_32F3C(a1, v17, 0, (int)v16, v18);
        }
        v10 = 0;
        v11 = 1;
      }
      v12 = LOBYTE((*_ctype_tolower_loc())[v9]);
      v13 = v12 == 102;
      if ( v12 != 102 )
        v13 = v12 == 116;
      v8[1] = v12;
      if ( v13 )
      {
        v14 = v12 == 116;
        if ( v12 == 116 )
          sub_1AECC();
        if ( v10 )
          sub_1ABE0();
        if ( v11 )
          sub_15BEC();
        a1 = v5;
        v16 = "All";
        if ( v14 )
        {
          v17 = 96;
          v18 = a4;
          if ( !v10 )
            v16 = "BestShare";
        }
        else
        {
          v18 = a4;
          v17 = 97;
          if ( !v10 )
            v16 = "BestShare";
        }
      }
      else
      {
        v18 = a4;
        a1 = v5;
        v16 = 0;
        v17 = 76;
      }
    }
    else
    {
      v18 = a4;
      a1 = v5;
      v16 = 0;
      v17 = 75;
    }
  }
  else
  {
    v18 = a4;
    v16 = 0;
    v17 = 94;
  }
  return sub_32F3C(a1, v17, 0, (int)v16, v18);
}

//----- (000335F0) --------------------------------------------------------
int __fastcall sub_335F0(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32F3C(a1, 88, 0, 0, a4);
}

//----- (00033604) --------------------------------------------------------
int __fastcall sub_33604(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r5
  char *v7; // r0
  int v8; // r2
  unsigned int v9; // r7
  int v10; // r3
  int v11; // r1
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = strchr(a3, 44);
    v8 = (int)v7;
    if ( v7 )
    {
      *v7 = 0;
      v9 = strtol(v7 + 1, 0, 10);
      if ( v9 > 0x270F )
      {
        v13 = a4;
        a1 = v5;
        v8 = v9;
        v10 = (int)a3;
        v11 = 84;
      }
      else
      {
        if ( !strcasecmp(a3, "queue") )
        {
          dword_60074 = v9;
        }
        else if ( !strcasecmp(a3, "scantime") )
        {
          dword_60090 = v9;
        }
        else
        {
          if ( strcasecmp(a3, "expiry") )
          {
            v13 = a4;
            a1 = v5;
            v8 = 0;
            v10 = (int)a3;
            v11 = 83;
            return sub_32F3C(a1, v11, v8, v10, v13);
          }
          dword_60094 = v9;
        }
        v13 = a4;
        a1 = v5;
        v8 = v9;
        v10 = (int)a3;
        v11 = 82;
      }
    }
    else
    {
      v13 = a4;
      a1 = v5;
      v10 = (int)a3;
      v11 = 86;
    }
  }
  else
  {
    v8 = 0;
    v13 = a4;
    v10 = 0;
    v11 = 85;
  }
  return sub_32F3C(a1, v11, v8, v10, v13);
}
// 60074: using guessed type int dword_60074;
// 60090: using guessed type int dword_60090;
// 60094: using guessed type int dword_60094;

//----- (0003375C) --------------------------------------------------------
int __fastcall sub_3375C(int a1, int a2, _BYTE *a3, int a4)
{
  int v7; // r2
  int v8; // r3
  int v9; // r4
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  int result; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r1
  char *v25; // r2
  int v26; // r3

  if ( a3 )
  {
    v7 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*a3]);
    *a3 = v7;
    switch ( v7 )
    {
      case 'd':
        v8 = (unsigned __int8)byte_630C1 ^ 1;
        byte_630C1 ^= 1u;
        byte_630C0 = v8;
        if ( v8 )
          goto LABEL_4;
        break;
      case 'n':
        byte_630C0 = 0;
        byte_630C1 = 0;
        byte_64218 = 0;
        byte_63928 = 0;
        byte_63DF8 = 0;
        byte_63DFA = 0;
        break;
      case 'p':
        byte_63DF8 ^= 1u;
        byte_630C0 = byte_63DF8;
        break;
      case 'q':
        byte_64218 ^= 1u;
        break;
      case 'r':
        v25 = &byte_63928;
        goto LABEL_15;
      case 's':
        byte_640B8 = 1;
        break;
      case 'v':
        v25 = &byte_630C0;
LABEL_15:
        v26 = (unsigned __int8)*v25 ^ 1;
        *v25 = v26;
        if ( v26 )
LABEL_4:
          byte_64218 = 0;
        break;
      case 'w':
        byte_63DFA ^= 1u;
        break;
      default:
        break;
    }
  }
  sub_32F3C((unsigned int *)a1, 79, 0, 0, a4);
  if ( a4 )
  {
    v9 = sub_30708((unsigned int *)a1, ",\"DEBUG\":[");
    v10 = sub_32ED0(0, "Silent", &byte_640B8, 0);
    v11 = sub_32ED0(v10, "Quiet", &byte_64218, 0);
    v12 = sub_32ED0(v11, "Verbose", &byte_630C0, 0);
    v13 = sub_32ED0(v12, "Debug", &byte_630C1, 0);
    v14 = sub_32ED0(v13, "RPCProto", &byte_63928, 0);
    v15 = sub_32ED0(v14, "PerDevice", &byte_63DF8, 0);
    v16 = sub_32ED0(v15, "WorkTime", &byte_63DFA, 0);
    result = sub_32418((unsigned int *)a1, (int)v16, 1, 0);
    if ( v9 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_30708((unsigned int *)a1, "DEBUG,");
    v18 = sub_32ED0(0, "Silent", &byte_640B8, 0);
    v19 = sub_32ED0(v18, "Quiet", &byte_64218, 0);
    v20 = sub_32ED0(v19, "Verbose", &byte_630C0, 0);
    v21 = sub_32ED0(v20, "Debug", &byte_630C1, 0);
    v22 = sub_32ED0(v21, "RPCProto", &byte_63928, 0);
    v23 = sub_32ED0(v22, "PerDevice", &byte_63DF8, 0);
    v24 = sub_32ED0(v23, "WorkTime", &byte_63DFA, 0);
    return sub_32418((unsigned int *)a1, (int)v24, 0, 0);
  }
  return result;
}
// 33794: control flows out of bounds to 33798
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 63928: using guessed type char byte_63928;
// 63DF8: using guessed type char byte_63DF8;
// 63DFA: using guessed type char byte_63DFA;
// 640B8: using guessed type char byte_640B8;
// 64218: using guessed type char byte_64218;

//----- (00033A68) --------------------------------------------------------
int __fastcall sub_33A68(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r6
  int v7; // r5
  int v8; // r1
  bool v9; // zf
  _BOOL4 v10; // r12
  int v11; // r1
  int v12; // r2
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = (unsigned __int8)*a3;
    v8 = LOBYTE((*_ctype_tolower_loc())[v7]);
    v9 = v8 == 102;
    if ( v8 != 102 )
      v9 = v8 == 116;
    *a3 = v8;
    if ( v9 )
    {
      v14 = a4;
      v10 = v8 == 116;
      a1 = v5;
      v11 = 77;
      byte_63BC5 = v10;
      v12 = v10;
    }
    else
    {
      v12 = 0;
      v14 = a4;
      a1 = v5;
      v11 = 76;
    }
  }
  else
  {
    v12 = 0;
    v14 = a4;
    v11 = 75;
  }
  return sub_32F3C(a1, v11, v12, 0, v14);
}
// 63BC5: using guessed type char byte_63BC5;

//----- (00033B14) --------------------------------------------------------
int __fastcall sub_33B14(int a1, int a2, const char *a3, int a4, unsigned __int8 a5)
{
  const char *v8; // r0
  _UNKNOWN **v9; // r4
  const char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r2
  int v13; // r8
  int v14; // r9
  char *v15; // r1
  int v16; // r10
  const char *v17; // r2
  _DWORD *v18; // r0
  const char *v19; // r2
  _DWORD *v20; // r0
  int result; // r0
  char s[100]; // [sp+Ch] [bp-64h] BYREF

  if ( !a3 || !*a3 )
    return sub_32F3C((unsigned int *)a1, 71, 0, 0, a4);
  v8 = (const char *)off_607CC;
  if ( off_607CC )
  {
    v9 = &off_607CC;
    while ( strcmp(v8, a3) )
    {
      v10 = (const char *)v9[3];
      v9 += 3;
      v8 = v10;
      if ( !v10 )
        goto LABEL_23;
    }
    sprintf(s, "|%s|", a3);
    v11 = _ctype_toupper_loc();
    v12 = (*v11)[a5];
    if ( v12 == (*v11)[87] || strstr(*((const char **)&unk_642C4 + v12 - (*v11)[65]), s) )
    {
      v13 = 1;
      v14 = 1;
    }
    else
    {
      v13 = 0;
      v14 = 1;
    }
  }
  else
  {
LABEL_23:
    v13 = (int)v8;
    v14 = (int)v8;
  }
  sub_32F3C((unsigned int *)a1, 72, 0, 0, a4);
  v15 = "CHECK,";
  if ( a4 )
    v15 = ",\"CHECK\":[";
  v16 = sub_30708((unsigned int *)a1, v15);
  if ( v14 )
    v17 = "Y";
  else
    v17 = "N";
  v18 = sub_32D20(0, "Exists", v17, 0);
  if ( v13 )
    v19 = "Y";
  else
    v19 = "N";
  v20 = sub_32D20(v18, "Access", v19, 0);
  result = sub_32418((unsigned int *)a1, (int)v20, a4, 0);
  if ( (v16 & a4) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 607CC: using guessed type _UNKNOWN *off_607CC;

//----- (00033CAC) --------------------------------------------------------
int __fastcall sub_33CAC(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r10
  _DWORD *v8; // r9
  int v9; // r4
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  const char *v14; // r2
  _DWORD *v15; // r0
  const char *v16; // r2
  _DWORD *v17; // r0
  const char *v18; // r2
  _DWORD *v19; // r0
  _BOOL4 v20; // r3
  int v21; // [sp+Ch] [bp-4h] BYREF

  if ( !dword_63CC0 )
    return sub_32F3C((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_32F3C((unsigned int *)a1, 69, 0, 0, a4);
  if ( a4 )
  {
    result = sub_30708((unsigned int *)a1, ",\"DEVDETAILS\":[");
    v7 = result;
  }
  else
  {
    v7 = 0;
  }
  v8 = 0;
  v21 = 0;
  if ( dword_63CC0 > 0 )
  {
    result = 0;
    do
    {
      v9 = sub_1AB68(result);
      v10 = sub_32DB0(v8, "DEVDETAILS", (const char *)&v21, 0);
      v11 = sub_32CFC(v10, "Name", *(const char **)(*(_DWORD *)(v9 + 4) + 8), 0);
      v12 = sub_32DB0(v11, "ID", (const char *)(v9 + 8), 0);
      v13 = sub_32CFC(v12, "Driver", *(const char **)(*(_DWORD *)(v9 + 4) + 4), 0);
      v14 = *(const char **)(v9 + 168);
      if ( !v14 )
        v14 = "";
      v15 = sub_32D20(v13, "Kernel", v14, 0);
      v16 = *(const char **)(v9 + 12);
      if ( !v16 )
        v16 = "";
      v17 = sub_32D20(v15, "Model", v16, 0);
      v18 = *(const char **)(v9 + 16);
      if ( !v18 )
        v18 = "";
      v19 = sub_32D20(v17, "Device Path", v18, 0);
      v20 = a4;
      if ( a4 )
        v20 = v21 > 0;
      v8 = (_DWORD *)sub_32418((unsigned int *)a1, (int)v19, a4, v20);
      result = ++v21;
    }
    while ( v21 < dword_63CC0 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 63CC0: using guessed type int dword_63CC0;

//----- (00033E50) --------------------------------------------------------
void __fastcall sub_33E50(unsigned int *a1, int a2, char *nptr, int a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r0
  int v11; // r7
  int v12; // r4
  char *v13; // r0
  char *v14; // r8
  unsigned __int8 v15; // [sp+20h] [bp+18h]

  v6 = a1;
  if ( !dword_63740 )
  {
    v15 = a4;
    v7 = 0;
    v8 = 0;
    v9 = 8;
    goto LABEL_5;
  }
  if ( !nptr || !*nptr )
  {
    v7 = 0;
    v15 = a4;
    v8 = 0;
    v9 = 25;
LABEL_5:
    sub_32F3C(a1, v9, v7, v8, v15);
    return;
  }
  v10 = strtol(nptr, 0, 10);
  v11 = v10;
  if ( v10 < 0 || v10 >= dword_63740 )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 26;
    v8 = 0;
    goto LABEL_5;
  }
  if ( dword_63740 <= 1 )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 66;
    v8 = 0;
    goto LABEL_5;
  }
  v12 = *(_DWORD *)(dword_639E0 + 4 * v10);
  if ( v12 == sub_1D644() )
    sub_195D4(0);
  if ( v12 == sub_1D644() )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 67;
    v8 = 0;
    goto LABEL_5;
  }
  v13 = *(char **)(v12 + 164);
  *(_DWORD *)(v12 + 100) = 0;
  v14 = sub_30440(v13, a4);
  if ( v14 == *(char **)(v12 + 164) )
  {
    sub_15600(v12);
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v8 = (int)v14;
    v9 = 68;
    goto LABEL_5;
  }
  sub_15600(v12);
  sub_32F3C(v6, 68, v11, (int)v14, a4);
  free(v14);
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00033FFC) --------------------------------------------------------
int __fastcall sub_33FFC(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_63740 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_63740 )
      {
        v13 = a4;
        a1 = v6;
        v7 = v10;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_639E0 + 4 * v9);
        if ( *(_DWORD *)(v11 + 100) )
        {
          if ( dword_63B84 <= 1 )
          {
            v13 = a4;
            a1 = v6;
            v7 = v10;
            v8 = 51;
          }
          else
          {
            *(_DWORD *)(v11 + 100) = 0;
            if ( v11 == sub_1D644() )
              sub_195D4(0);
            v13 = a4;
            a1 = v6;
            v7 = v10;
            v8 = 48;
          }
        }
        else
        {
          v13 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 50;
        }
      }
    }
    else
    {
      v7 = 0;
      v13 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v13 = a4;
    v8 = 8;
  }
  return sub_32F3C(a1, v8, v7, 0, v13);
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;
// 63B84: using guessed type int dword_63B84;

//----- (00034144) --------------------------------------------------------
int __fastcall sub_34144(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  int v12; // r8
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_63740 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_63740 )
      {
        v14 = a4;
        a1 = v6;
        v7 = v10;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_639E0 + 4 * v9);
        if ( *(_DWORD *)(v11 + 100) == 1 )
        {
          v14 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 49;
        }
        else
        {
          *(_DWORD *)(v11 + 100) = 1;
          v12 = *(_DWORD *)(v11 + 4);
          if ( v12 < *(_DWORD *)(sub_1D644() + 4) )
            sub_195D4(v11);
          v14 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 47;
        }
      }
    }
    else
    {
      v7 = 0;
      v14 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v14 = a4;
    v8 = 8;
  }
  return sub_32F3C(a1, v8, v7, 0, v14);
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00034268) --------------------------------------------------------
int __fastcall sub_34268(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  unsigned int *v7; // r7
  int v8; // r2
  char *v9; // r10
  int v10; // r0
  int v11; // r1
  char *v12; // r3
  int v14; // r4
  int v15; // r0
  int v16; // r5
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  v7 = a1;
  v8 = dword_63740;
  if ( dword_63740 )
  {
    if ( s && *s )
    {
      v9 = strchr(s, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol(s, 0, 10);
        if ( v10 >= 0 && v10 < dword_63740 )
        {
          v14 = *(_DWORD *)(dword_639E0 + 4 * v10);
          v15 = strtol(v9 + 1, 0, 10);
          v16 = v15;
          if ( v15 < 0 )
          {
            v12 = *(char **)(v14 + 164);
            a1 = v7;
            v17 = a4;
            v8 = v16;
            v11 = 121;
          }
          else
          {
            *(_DWORD *)(v14 + 56) = v15;
            sub_14E18();
            v12 = *(char **)(v14 + 164);
            a1 = v7;
            v17 = a4;
            v8 = v16;
            v11 = 122;
          }
        }
        else
        {
          v8 = v10;
          v17 = a4;
          a1 = v7;
          v11 = 26;
          v12 = 0;
        }
      }
      else
      {
        v17 = a4;
        a1 = v7;
        v8 = 0;
        v12 = s;
        v11 = 86;
      }
    }
    else
    {
      v8 = 0;
      v17 = a4;
      v12 = 0;
      v11 = 25;
    }
  }
  else
  {
    v17 = a4;
    v11 = 8;
    v12 = 0;
  }
  return sub_32F3C(a1, v11, v8, (int)v12, v17);
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (000343B0) --------------------------------------------------------
int __fastcall sub_343B0(unsigned int *a1, int a2, char *s, int a4)
{
  const char *v4; // r8
  _BYTE *v6; // r2
  _BYTE *v7; // r3
  int v8; // r5
  char *v9; // r10
  int v10; // r0
  int v11; // r1
  _BYTE *v12; // r2
  int v13; // r3
  int v14; // lr
  int v15; // r12
  int v16; // t1
  bool v17; // zf
  int v18; // lr
  int v19; // r12
  int v20; // r3
  int v21; // r2
  int v22; // [sp+0h] [bp-3Ch] BYREF
  _BYTE v23[4]; // [sp+8h] [bp-34h] BYREF
  unsigned int *v24; // [sp+Ch] [bp-30h]
  int v25; // [sp+10h] [bp-2Ch]
  int *v26; // [sp+14h] [bp-28h]

  v4 = s;
  v25 = a4;
  v24 = a1;
  v26 = &v22;
  if ( !dword_63740 )
    return sub_32F3C(a1, 8, 0, 0, a4);
  if ( !s || !*s )
    return sub_32F3C(v24, 25, 0, 0, v25);
  if ( dword_63740 > 0 )
  {
    v6 = &v23[dword_63740];
    v7 = v23;
    do
      *v7++ = 0;
    while ( v7 != v6 );
  }
  v8 = 0;
  while ( 1 )
  {
    v9 = strchr(v4, 44);
    if ( v9 )
      *v9++ = 0;
    v10 = strtol(v4, 0, 10);
    v4 = v9;
    if ( v10 < 0 )
      return sub_32F3C(v24, 26, v10, 0, v25);
    v11 = dword_63740;
    if ( dword_63740 <= v10 )
      return sub_32F3C(v24, 26, v10, 0, v25);
    if ( v23[v10] )
      return sub_32F3C(v24, 74, v10, 0, v25);
    *(_DWORD *)&v23[4 * v10] = v8;
    v23[v10] = 1;
    ++v8;
    if ( !v9 )
      break;
    if ( !*v9 )
    {
      if ( v11 <= 0 )
        goto LABEL_29;
      break;
    }
  }
  v12 = v23;
  v13 = 0;
  v14 = dword_639E0;
  do
  {
    v16 = (unsigned __int8)*v12++;
    v15 = v16;
    v17 = v16 == 0;
    if ( v16 )
    {
      v15 = *(_DWORD *)(v14 + v13);
      v4 = *(const char **)&v23[v13];
    }
    v13 += 4;
    if ( !v17 )
      *(_DWORD *)(v15 + 4) = v4;
  }
  while ( v12 != &v23[v11] );
  v18 = dword_639E0;
  v19 = 0;
LABEL_24:
  while ( 2 )
  {
    v20 = 0;
    while ( 1 )
    {
      if ( !v23[v20] )
      {
        v21 = *(_DWORD *)(v18 + 4 * v20);
        if ( *(_DWORD *)(v21 + 4) == v19 )
          break;
      }
      if ( ++v20 == v11 )
      {
        if ( ++v19 != v11 )
          goto LABEL_24;
        goto LABEL_29;
      }
    }
    ++v19;
    *(_DWORD *)(v21 + 4) = v8++;
    v23[v20] = 1;
    if ( v19 != v11 )
      continue;
    break;
  }
LABEL_29:
  if ( *(_DWORD *)(sub_1D644() + 4) )
    sub_195D4(0);
  return sub_32F3C(v24, 73, 0, 0, v25);
}
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00034608) --------------------------------------------------------
void __fastcall sub_34608(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v7; // r7
  int *v8; // r7
  char *v9; // r4
  char *s; // [sp+Ch] [bp-Ch] BYREF
  const char *v11; // [sp+10h] [bp-8h] BYREF
  const char *v12; // [sp+14h] [bp-4h] BYREF

  if ( a3 && *a3 )
  {
    if ( sub_31F7C((unsigned __int8 *)a3, (unsigned __int8 **)&s, &v11, &v12) )
    {
      v8 = (int *)sub_1746C();
      sub_150B4((int)v8, s);
      sub_267F4((int)v8, 1, s, v11, v12);
      v9 = sub_30440(s, a4);
      sub_32F3C(a1, 55, *v8, (int)v9, a4);
      if ( v9 != s )
        free(v9);
    }
    else
    {
      v7 = sub_30440(a3, a4);
      sub_32F3C(a1, 53, 0, (int)v7, a4);
      if ( v7 != a3 )
        free(v7);
    }
  }
  else
  {
    sub_32F3C(a1, 52, 0, 0, a4);
  }
}

//----- (00034710) --------------------------------------------------------
int __fastcall sub_34710(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r7
  int v11; // r4
  unsigned __int8 v12; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_63740 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      if ( pthread_mutex_lock(&stru_63FB0) )
        sub_B844("switchpool", 2887);
      sub_32074(&stru_63FC8, "switchpool", 2887);
      if ( pthread_mutex_unlock(&stru_63FB0) )
        sub_B91C("switchpool", 2887);
      if ( v9 >= 0 && v9 < dword_63740 )
      {
        v11 = *(_DWORD *)(dword_639E0 + 4 * v9);
        *(_DWORD *)(v11 + 100) = 1;
        if ( pthread_rwlock_unlock(&stru_63FC8) )
          sub_B8B0("switchpool", 2897);
        off_60178();
        sub_195D4(v11);
        v12 = a4;
        a1 = v6;
        v7 = v9;
        v8 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&stru_63FC8) )
          sub_B8B0("switchpool", 2890);
        off_60178();
        v12 = a4;
        a1 = v6;
        v7 = v9;
        v8 = 26;
      }
    }
    else
    {
      v7 = 0;
      v12 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v12 = a4;
    v8 = 8;
  }
  return sub_32F3C(a1, v8, v7, 0, v12);
}
// 60178: using guessed type int (*off_60178)();
// 63740: using guessed type int dword_63740;
// 639E0: using guessed type int dword_639E0;

//----- (00034970) --------------------------------------------------------
int __fastcall sub_34970(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32F3C(a1, 10, 0, 0, a4);
}

//----- (00034984) --------------------------------------------------------
int __fastcall sub_34984(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32F3C(a1, 10, 0, 0, a4);
}

//----- (00034B40) --------------------------------------------------------
int __fastcall sub_34B40(int a1, int a2, int a3, int a4)
{
  int v6; // r4
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  int result; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r1

  sub_32F3C((unsigned int *)a1, 22, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_30708((unsigned int *)a1, ",\"VERSION\":[");
    v7 = sub_32CFC(0, "CGMiner", a49, 0);
    v8 = sub_32D20(v7, "API", "3.1", 0);
    v9 = sub_32CFC(v8, "Miner", (const char *)&dword_62E48, 0);
    v10 = sub_32CFC(v9, "CompileTime", s, 0);
    v11 = sub_32CFC(v10, "Type", byte_62B0C, 0);
    result = sub_32418((unsigned int *)a1, (int)v11, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_30708((unsigned int *)a1, "VERSION,");
    v13 = sub_32CFC(0, "CGMiner", a49, 0);
    v14 = sub_32D20(v13, "API", "3.1", 0);
    v15 = sub_32CFC(v14, "Miner", (const char *)&dword_62E48, 0);
    v16 = sub_32CFC(v15, "CompileTime", s, 0);
    v17 = sub_32CFC(v16, "Type", byte_62B0C, 0);
    return sub_32418((unsigned int *)a1, (int)v17, 0, 0);
  }
  return result;
}
// 62E48: using guessed type int dword_62E48;

//----- (00034CA0) --------------------------------------------------------
void __fastcall sub_34CA0(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v4; // r4
  FILE *v7; // r0
  FILE *v8; // r5
  char *v9; // r5
  char *v10; // r8
  char v11[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = a3;
  if ( !a3 || !*a3 )
  {
    v4 = v11;
    sub_15C88(v11);
  }
  v7 = fopen(v4, "w");
  v8 = v7;
  if ( v7 )
  {
    sub_1569C(v7);
    fclose(v8);
    v9 = sub_30440(v4, a4);
    sub_32F3C(a1, 44, 0, (int)v9, a4);
    if ( v9 != v4 )
      free(v9);
  }
  else
  {
    v10 = sub_30440(v4, a4);
    sub_32F3C(a1, 43, 0, (int)v10, a4);
    if ( v10 != v4 )
      free(v10);
  }
}

//----- (00034D7C) --------------------------------------------------------
int __fastcall sub_34D7C(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32F3C(a1, 46, 0, 0, a4);
}

//----- (00034D90) --------------------------------------------------------
_DWORD *__fastcall sub_34D90(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 17, a3, a4);
}

//----- (00035034) --------------------------------------------------------
int __fastcall sub_35034(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6)
{
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  int v18; // r2
  int v19; // r1
  int v20; // r3
  _BOOL4 v21; // r3
  int v23; // [sp+4h] [bp-10h] BYREF
  double v24; // [sp+8h] [bp-Ch] BYREF

  v23 = a2;
  v24 = dbl_63268 / dbl_5F898;
  v9 = sub_32DB0(0, "STATS", (const char *)&v23, 0);
  v10 = sub_32CFC(v9, "ID", a3, 0);
  v11 = sub_32EAC(v10, "Elapsed", (const char *)&dbl_5F898, 0);
  v12 = sub_32DF8(v11, "Calls", a4, 0);
  v13 = sub_32EF4(v12, "Wait", a4 + 4, 0);
  v14 = sub_32EF4(v13, "Max", a4 + 12, 0);
  v15 = sub_32EF4(v14, "Min", a4 + 20, 0);
  v16 = sub_32CFC(v15, "GHS 5s", byte_62E38, 0);
  v17 = sub_34D90(v16, "GHS av", (const char *)&v24, 0);
  v19 = (int)v17;
  if ( a5 )
  {
    if ( v17 )
      v18 = v17[4];
    else
      v19 = a5;
    if ( v17 )
    {
      v20 = *(_DWORD *)(a5 + 16);
      *(_DWORD *)(a5 + 16) = v18;
      *(_DWORD *)(v17[4] + 20) = a5;
      *(_DWORD *)(v20 + 20) = v17;
      v17[4] = v20;
    }
  }
  if ( a6 )
    v21 = v23 > 0;
  else
    v21 = 0;
  sub_32418(a1, v19, a6, v21);
  return v23 + 1;
}
// 35034: too many cbuild loops
// 3511C: variable 'v18' is possibly undefined
// 5F898: using guessed type double dbl_5F898;
// 63268: using guessed type double dbl_63268;

//----- (00035400) --------------------------------------------------------
_DWORD *__fastcall sub_35400(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 18, a3, a4);
}

//----- (00035424) --------------------------------------------------------
_DWORD *__fastcall sub_35424(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 19, a3, a4);
}

//----- (00035448) --------------------------------------------------------
_DWORD *__fastcall sub_35448(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 20, a3, a4);
}

//----- (0003546C) --------------------------------------------------------
_DWORD *__fastcall sub_3546C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 21, a3, a4);
}

//----- (00035490) --------------------------------------------------------
_DWORD *__fastcall sub_35490(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 22, a3, a4);
}

//----- (000354B4) --------------------------------------------------------
_DWORD *__fastcall sub_354B4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 23, a3, a4);
}

//----- (000354D8) --------------------------------------------------------
_DWORD *__fastcall sub_354D8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 24, a3, a4);
}

//----- (00035684) --------------------------------------------------------
_DWORD *__fastcall sub_35684(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 25, a3, a4);
}

//----- (000356A8) --------------------------------------------------------
int __fastcall sub_356A8(int a1, int a2, int a3, int a4)
{
  char *v5; // r1
  int v6; // r9
  __int64 v7; // r0
  __int64 v8; // d9
  double v9; // r0
  double v10; // d8
  int v11; // r1
  double v12; // d16
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r12
  __int64 v34; // r0
  double v35; // d8
  double v36; // r0
  double v37; // d16
  _DWORD *v38; // r11
  double v39; // r0
  double v40; // d16
  _DWORD *v41; // r0
  double v42; // d16
  double v43; // d16
  _DWORD *v44; // r0
  double v45; // d16
  double v46; // d16
  _DWORD *v47; // r0
  _DWORD *v48; // r5
  int result; // r0
  _DWORD *v51; // [sp+Ch] [bp-40h]
  double v52; // [sp+10h] [bp-3Ch] BYREF
  double v53; // [sp+18h] [bp-34h] BYREF
  double v54; // [sp+20h] [bp-2Ch] BYREF
  double v55; // [sp+28h] [bp-24h] BYREF
  double v56; // [sp+30h] [bp-1Ch] BYREF
  double v57; // [sp+38h] [bp-14h] BYREF
  double v58; // [sp+40h] [bp-Ch] BYREF

  sub_32F3C((unsigned int *)a1, 11, 0, 0, a4);
  v5 = "SUMMARY,";
  if ( a4 )
    v5 = ",\"SUMMARY\":[";
  v6 = sub_30708((unsigned int *)a1, v5);
  if ( pthread_mutex_lock(&stru_6392C) )
    sub_B844("summary", 2788);
  LODWORD(v7) = sub_49488(dbl_63B88 + dbl_63C10 + dbl_639D0);
  *(_QWORD *)&dword_636A8 = v7;
  v8 = v7;
  LODWORD(v9) = sub_493DC(qword_639C8);
  v10 = dbl_5F898;
  v53 = dbl_63268 / dbl_5F898;
  if ( dbl_5F898 == 0.0 )
  {
    v52 = v9 * 60.0;
    v10 = 1.0;
  }
  else
  {
    v52 = v9 / dbl_5F898 * 60.0;
  }
  LODWORD(v12) = sub_493DC(v8);
  HIDWORD(v12) = v11;
  v54 = v12 / v10 * 60.0;
  v13 = sub_32EAC(0, "Elapsed", (const char *)&dbl_5F898, 1);
  v14 = sub_32CFC(v13, "GHS 5s", byte_62E38, 0);
  v15 = sub_34D90(v14, "GHS av", (const char *)&v53, 0);
  v16 = sub_32DD4(v15, "Found Blocks", (const char *)&dword_63E58, 1);
  v17 = sub_32E64(v16, "Getworks", (const char *)&dword_63BE8, 1);
  v18 = sub_32E64(v17, "Accepted", (const char *)&qword_639C8, 1);
  v19 = sub_32E64(v18, "Rejected", (const char *)&qword_63C98, 1);
  v20 = sub_32DB0(v19, "Hardware Errors", (const char *)&dword_63E44, 1);
  v21 = sub_35448(v20, "Utility", (const char *)&v52, 0);
  v22 = sub_32E64(v21, "Discarded", (const char *)&dword_63D68, 1);
  v23 = sub_32E64(v22, "Stale", (const char *)&dword_64220, 1);
  v24 = sub_32DD4(v23, "Get Failures", (const char *)&dword_639E4, 1);
  v25 = sub_32DD4(v24, "Local Work", (const char *)&dword_63A70, 1);
  v26 = sub_32DD4(v25, "Remote Failures", (const char *)&dword_63410, 1);
  v27 = sub_32DD4(v26, "Network Blocks", (const char *)&dword_640BC, 1);
  v28 = sub_35400(v27, "Total MH", (const char *)&dbl_63268, 1);
  v29 = sub_35448(v28, "Work Utility", (const char *)&v54, 0);
  v30 = sub_354D8(v29, "Difficulty Accepted", (const char *)&dbl_63B88, 1);
  v31 = sub_354D8(v30, "Difficulty Rejected", (const char *)&dbl_63C10, 1);
  v32 = sub_354D8(v31, "Difficulty Stale", (const char *)&dbl_639D0, 1);
  v33 = sub_32E40(v32, "Best Share", (const char *)&qword_611C8, 1);
  v34 = *(_QWORD *)&dword_636A8 + dword_63E44;
  if ( v34 )
  {
    v51 = v33;
    v35 = (double)dword_63E44;
    LODWORD(v36) = sub_493DC(v34);
    v33 = v51;
    v37 = v35 / v36;
  }
  else
  {
    v37 = 0.0;
  }
  v55 = v37;
  v38 = sub_35684(v33, "Device Hardware%", (const char *)&v55, 0);
  if ( *(_QWORD *)&dword_636A8 )
  {
    LODWORD(v39) = sub_493DC(*(__int64 *)&dword_636A8);
    v40 = dbl_63C10 / v39;
  }
  else
  {
    v40 = 0.0;
  }
  v56 = v40;
  v41 = sub_35684(v38, "Device Rejected%", (const char *)&v56, 0);
  v42 = dbl_63C10 + dbl_63B88 + dbl_639D0;
  if ( v42 == 0.0 )
    v43 = 0.0;
  else
    v43 = dbl_63C10 / v42;
  v57 = v43;
  v44 = sub_35684(v41, "Pool Rejected%", (const char *)&v57, 0);
  v45 = dbl_63B88 + dbl_63C10 + dbl_639D0;
  if ( v45 == 0.0 )
    v46 = 0.0;
  else
    v46 = dbl_639D0 / v45;
  v58 = v46;
  v47 = sub_35684(v44, "Pool Stale%", (const char *)&v58, 0);
  v48 = sub_32F18(v47, "Last getwork", (const char *)&dword_63EE8, 0);
  if ( pthread_mutex_unlock(&stru_6392C) )
    sub_B91C("summary", 2842);
  off_60178();
  result = sub_32418((unsigned int *)a1, (int)v48, a4, 0);
  if ( (v6 & a4) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 3572C: variable 'v7' is possibly undefined
// 35754: variable 'v9' is possibly undefined
// 3577C: variable 'v11' is possibly undefined
// 3591C: variable 'v36' is possibly undefined
// 35958: variable 'v39' is possibly undefined
// 5F898: using guessed type double dbl_5F898;
// 60178: using guessed type int (*off_60178)();
// 611C8: using guessed type __int64 qword_611C8;
// 63268: using guessed type double dbl_63268;
// 63410: using guessed type int dword_63410;
// 636A8: using guessed type int dword_636A8;
// 639C8: using guessed type __int64 qword_639C8;
// 639D0: using guessed type double dbl_639D0;
// 639E4: using guessed type int dword_639E4;
// 63A70: using guessed type int dword_63A70;
// 63B88: using guessed type double dbl_63B88;
// 63BE8: using guessed type int dword_63BE8;
// 63C10: using guessed type double dbl_63C10;
// 63C98: using guessed type __int64 qword_63C98;
// 63D68: using guessed type int dword_63D68;
// 63E44: using guessed type int dword_63E44;
// 63E58: using guessed type int dword_63E58;
// 63EE8: using guessed type int dword_63EE8;
// 640BC: using guessed type int dword_640BC;
// 64220: using guessed type int dword_64220;

//----- (000360E0) --------------------------------------------------------
_DWORD *__fastcall sub_360E0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31C10(a1, a2, 26, a3, a4);
}

//----- (00036104) --------------------------------------------------------
int __fastcall sub_36104(unsigned int *a1, int a2, int a3, int a4)
{
  int v5; // r2
  unsigned int v8; // r3
  const char *v9; // r7
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _BOOL4 v26; // r3
  char v28[8]; // [sp+4h] [bp-8h] BYREF

  v5 = *(_DWORD *)(a3 + 244);
  *(_DWORD *)v28 = a2;
  if ( v5 )
  {
    v8 = *(_DWORD *)(a3 + 248);
    if ( v8 <= 8 )
      v9 = *(const char **)&aEscapeString[4 * v8 + 112];
    else
      v9 = "Unknown reason - code bug";
  }
  else
  {
    v9 = "None";
  }
  v10 = sub_32DB0(0, "NOTIFY", v28, 0);
  v11 = sub_32CFC(v10, "Name", *(const char **)(*(_DWORD *)(a3 + 4) + 8), 0);
  v12 = sub_32DB0(v11, "ID", (const char *)(a3 + 8), 0);
  v13 = sub_32F18(v12, "Last Well", (const char *)(a3 + 240), 0);
  v14 = sub_32F18(v13, "Last Not Well", (const char *)(a3 + 244), 0);
  v15 = sub_32CFC(v14, "Reason Not Well", v9, 0);
  v16 = sub_32DB0(v15, "*Thread Fail Init", (const char *)(a3 + 252), 0);
  v17 = sub_32DB0(v16, "*Thread Zero Hash", (const char *)(a3 + 256), 0);
  v18 = sub_32DB0(v17, "*Thread Fail Queue", (const char *)(a3 + 260), 0);
  v19 = sub_32DB0(v18, "*Dev Sick Idle 60s", (const char *)(a3 + 264), 0);
  v20 = sub_32DB0(v19, "*Dev Dead Idle 600s", (const char *)(a3 + 268), 0);
  v21 = sub_32DB0(v20, "*Dev Nostart", (const char *)(a3 + 272), 0);
  v22 = sub_32DB0(v21, "*Dev Over Heat", (const char *)(a3 + 276), 0);
  v23 = sub_32DB0(v22, "*Dev Thermal Cutoff", (const char *)(a3 + 280), 0);
  v24 = sub_32DB0(v23, "*Dev Comms Error", (const char *)(a3 + 284), 0);
  v25 = sub_32DB0(v24, "*Dev Throttle", (const char *)(a3 + 288), 0);
  if ( a4 )
    v26 = *(_DWORD *)v28 > 0;
  else
    v26 = 0;
  return sub_32418(a1, (int)v25, a4, v26);
}

//----- (000363A4) --------------------------------------------------------
int sub_363A4()
{
  void *v0; // r0
  int result; // r0
  char v2[2048]; // [sp+0h] [bp-800h] BYREF

  v0 = calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc mcast thr");
    sub_38438(3, v2, 1);
    sub_16724(1);
  }
  result = sub_2F0EC((int)v0, 0, (void *(*)(void *))sub_31BD4, v0);
  if ( result )
  {
    strcpy(v2, "API mcast thread create failed");
    sub_38438(3, v2, 1);
    sub_16724(1);
  }
  return result;
}

//----- (0003646C) --------------------------------------------------------
void __fastcall sub_3646C(int a1)
{
  double v1; // d0
  int *v2; // r0
  _BYTE *v3; // r0
  _DWORD *v4; // r0
  char *v5; // r3
  int v6; // r2
  bool v7; // zf
  const char *v8; // r4
  size_t v9; // r5
  char *v10; // r0
  unsigned __int8 *v11; // r4
  char *v12; // r0
  char *v13; // r0
  int v14; // r3
  const __int32_t *v15; // r2
  int v16; // r8
  __int32_t v17; // r1
  unsigned __int8 *v18; // r6
  int v19; // r10
  char *v20; // r0
  char *v21; // r7
  const char *v22; // r9
  _UNKNOWN **v23; // r5
  int v24; // r4
  const char *v25; // t1
  const char *v26; // r4
  char *v27; // r3
  const char *v28; // r2
  _BYTE *v29; // r6
  char *v30; // r7
  const char *v31; // r9
  size_t v32; // r0
  int v33; // r5
  size_t v34; // r0
  char *v35; // r0
  int *v36; // r4
  const char *v37; // r5
  char *v38; // r7
  const char *v39; // t1
  size_t v40; // r0
  const char *v41; // t1
  const __int32_t *v42; // r2
  __int32_t v43; // r3
  int v44; // r5
  size_t v45; // r0
  char *v46; // r0
  const char *v47; // r5
  size_t v48; // r0
  char *v49; // r0
  char *v50; // r11
  char *v51; // r2
  size_t v52; // r0
  int v53; // r3
  int v54; // t1
  int v55; // r7
  int v56; // r3
  char *v57; // r6
  bool v58; // zf
  unsigned __int8 *v59; // r6
  int v60; // t1
  bool v61; // zf
  char *v62; // r0
  const unsigned __int16 **v63; // r0
  int v64; // r1
  const __int32_t *v65; // r3
  char v66; // r2
  char *v67; // r5
  int v68; // r9
  int v69; // r3
  char *v70; // r5
  unsigned __int8 v71; // r2
  char *v72; // r0
  int v73; // r9
  int i; // r3
  int j; // r3
  char v76; // t1
  int v77; // r0
  int v78; // r2
  int v79; // r2
  int v80; // r3
  char *v81; // r1
  int v82; // r0
  int v83; // r3
  char *v84; // r1
  int v85; // r12
  __int32_t v86; // r1
  unsigned __int8 *v87; // r4
  int v88; // r2
  char *v89; // r3
  struct addrinfo *v90; // r12
  struct addrinfo *v91; // r4
  int v92; // r0
  time_t v93; // r9
  int v94; // r9
  int *v95; // r11
  int v96; // r0
  _BOOL4 v97; // r5
  const char *v98; // r2
  ssize_t v99; // r0
  int v100; // r6
  int v101; // r3
  int v102; // r5
  time_t v103; // r0
  _BYTE *v104; // r1
  char *v105; // r0
  char *v106; // r10
  const char *v107; // r8
  size_t v108; // r0
  char *v109; // r7
  char *v110; // r0
  const char *v111; // r1
  _UNKNOWN **v112; // r10
  int v113; // r6
  const char *v114; // t1
  int v115; // r3
  int v116; // r6
  int v117; // r3
  int v118; // r3
  int *v119; // r0
  char *v120; // r10
  int *v121; // r0
  char *v122; // r0
  int *v123; // r0
  char *v124; // r0
  int v125; // r0
  int v126; // r12
  __int32_t v127; // r2
  char *v128; // r0
  int *v129; // r0
  char *v130; // r0
  const char *v131; // r3
  int *v132; // r0
  int *v133; // r0
  char *v134; // r0
  int *v135; // r0
  int *v136; // r0
  char *v137; // r0
  _DWORD *v138; // r0
  size_t v139; // r0
  int *v140; // r3
  char *v141; // r0
  int v142; // r3
  int v143; // r0
  int v144; // [sp+10h] [bp-4B9Ch]
  unsigned __int8 *v145; // [sp+14h] [bp-4B98h]
  const __int32_t **v146; // [sp+20h] [bp-4B8Ch]
  char *dest; // [sp+28h] [bp-4B84h]
  int *ptr; // [sp+2Ch] [bp-4B80h]
  int fd; // [sp+34h] [bp-4B78h]
  _DWORD *v150; // [sp+38h] [bp-4B74h]
  char *haystack; // [sp+3Ch] [bp-4B70h]
  __int16 v152; // [sp+40h] [bp-4B6Ch]
  char *s; // [sp+48h] [bp-4B64h]
  char *v155; // [sp+6Ch] [bp-4B40h]
  unsigned __int8 v156; // [sp+72h] [bp-4B3Ah] BYREF
  char v157; // [sp+73h] [bp-4B39h] BYREF
  const char *v158; // [sp+74h] [bp-4B38h] BYREF
  socklen_t addr_len; // [sp+78h] [bp-4B34h] BYREF
  struct addrinfo *v160; // [sp+7Ch] [bp-4B30h] BYREF
  int optval; // [sp+80h] [bp-4B2Ch] BYREF
  char service[12]; // [sp+84h] [bp-4B28h] BYREF
  struct addrinfo req; // [sp+90h] [bp-4B1Ch] BYREF
  char v164[100]; // [sp+B0h] [bp-4AFCh] BYREF
  struct sockaddr addr; // [sp+114h] [bp-4A98h] BYREF
  char v166[252]; // [sp+194h] [bp-4A18h] BYREF
  struct __jmp_buf_tag env; // [sp+290h] [bp-491Ch] BYREF
  char needle[2040]; // [sp+3A8h] [bp-4804h] BYREF
  int v169[2038]; // [sp+BA8h] [bp-4004h] BYREF
  char v170[8024]; // [sp+2BA8h] [bp-2004h] BYREF

  v152 = dword_60170;
  v2 = (int *)malloc(4u);
  v7 = byte_63D71 == 0;
  ptr = v2;
  *v2 = -1;
  if ( v7 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(v170, 0x800u, "API not running%s", " - API will not be available");
      sub_38438(7, v170, 0);
    }
    goto LABEL_7;
  }
  v150 = malloc(0x10u);
  v3 = malloc(0x10000u);
  v150[1] = v3;
  v150[2] = v3;
  *((_BYTE *)v150 + 12) = 1;
  *v150 = 0x10000;
  *v3 = 0;
  *((_BYTE *)v150 + 13) = 0;
  v4 = malloc(0xCu);
  v5 = &byte_62F64;
  v6 = dword_62F88;
  v7 = dword_62F88 == 0;
  *v4 = v150;
  if ( v7 )
  {
    v4[1] = v4;
    v4[2] = v4;
  }
  else
  {
    v4[2] = v6;
    v5 = *(char **)(v6 + 4);
  }
  if ( v7 )
  {
    *((_DWORD *)v5 + 9) = v4;
  }
  else
  {
    v4[1] = v5;
    *(_DWORD *)(v6 + 4) = v4;
    v5 = (char *)v4[1];
  }
  if ( !v7 )
    *((_DWORD *)v5 + 2) = v4;
  if ( pthread_mutex_init(&stru_62F70, 0) )
  {
    v132 = _errno_location();
    snprintf(v170, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v132, "api.c", "api", 5279);
    sub_38438(3, v170, 1);
    sub_16724(1);
  }
  if ( _sigsetjmp(&env, 0) )
  {
    sub_32320(ptr);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
    goto LABEL_308;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
  v8 = (const char *)dword_63EE4;
  dword_62F94 = a1;
  if ( dword_63EE4 )
  {
    v9 = strlen((const char *)dword_63EE4) + 1;
  }
  else
  {
    v8 = "";
    v9 = 1;
  }
  v10 = (char *)malloc(v9);
  s = v10;
  if ( !v10 )
  {
    strcpy(v170, "Failed to malloc ipgroups buf");
    sub_38438(3, v170, 1);
    sub_16724(1);
  }
  memcpy(v10, v8, v9);
  if ( !*s )
  {
    v146 = _ctype_toupper_loc();
    goto LABEL_69;
  }
  v11 = (unsigned __int8 *)s;
  v146 = _ctype_toupper_loc();
  while ( 2 )
  {
    v12 = strchr((const char *)v11, 44);
    v145 = (unsigned __int8 *)v12;
    if ( v12 )
    {
      *v12 = 0;
      v145 = (unsigned __int8 *)(v12 + 1);
    }
    if ( v11[1] != 58 )
    {
      v13 = strchr((const char *)v11, 58);
      if ( v13 )
        *v13 = 0;
      snprintf((char *)v169, 0x800u, "API invalid group name '%s'", v11);
      sub_38438(3, (const char *)v169, 1);
      sub_16724(1);
    }
    v14 = *v11;
    v15 = *v146;
    v16 = LOBYTE((*v146)[v14]);
    v17 = (*v146)[v16];
    if ( v17 < (*v146)[65] || v17 > v15[90] )
    {
      snprintf((char *)v169, 0x800u, "API invalid group name '%c'", v14);
      sub_38438(3, (const char *)v169, 1);
      sub_16724(1);
    }
    if ( v16 == v15[87] )
    {
      snprintf((char *)v169, 0x800u, "API group name can't be '%c'", v16);
      sub_38438(3, (const char *)v169, 1);
      sub_16724(1);
    }
    if ( v16 == v15[82] )
    {
      snprintf((char *)v169, 0x800u, "API group name can't be '%c'", v16);
      sub_38438(3, (const char *)v169, 1);
      sub_16724(1);
    }
    if ( *((_DWORD *)&unk_642C4 + v15[v16] - v15[65]) )
    {
      snprintf((char *)v169, 0x800u, "API duplicate group name '%c'", *v11);
      sub_38438(3, (const char *)v169, 1);
      sub_16724(1);
    }
    v18 = v11 + 2;
    v19 = 0;
    strcpy(v170, "|");
    if ( v11 == (unsigned __int8 *)-2 || !v11[2] )
      goto LABEL_61;
    dest = &v170[1];
    while ( 1 )
    {
      v20 = strchr((const char *)v18, 58);
      v21 = v20;
      if ( v20 )
      {
        *v20 = 0;
        v21 = v20 + 1;
      }
      if ( *v18 == 42 && !v18[1] )
      {
        v19 = 1;
        goto LABEL_42;
      }
      v22 = (const char *)off_607CC;
      if ( !off_607CC )
      {
LABEL_65:
        snprintf((char *)v169, 0x800u, "API unknown command '%s' in group '%c'", v18, v16);
        sub_38438(3, (const char *)v169, 1);
        sub_16724(1);
      }
      v23 = &off_607CC;
      v24 = 0;
      while ( strcasecmp((const char *)v18, v22) )
      {
        v25 = (const char *)v23[3];
        v23 += 3;
        v22 = v25;
        ++v24;
        if ( !v25 )
          goto LABEL_65;
      }
      sprintf(needle, "|%s|", v22);
      if ( !strstr(v170, needle) )
        break;
LABEL_42:
      if ( !v21 )
        goto LABEL_54;
LABEL_43:
      if ( !*v21 )
        goto LABEL_54;
      v18 = (unsigned __int8 *)v21;
    }
    v26 = (const char *)dword_6039C[3 * v24 + 268];
    strcpy(dest, v26);
    v27 = &dest[strlen(v26)];
    *v27 = 124;
    dest = v27 + 1;
    v27[1] = 0;
    if ( v21 )
      goto LABEL_43;
LABEL_54:
    if ( v19 )
    {
      v28 = (const char *)off_607CC;
      if ( off_607CC )
      {
        v29 = &unk_607D4;
        v30 = dest;
        do
        {
          while ( 1 )
          {
            if ( !*v29 )
            {
              sprintf(needle, "|%s|", v28);
              if ( !strstr(v170, needle) )
                break;
            }
            v29 += 12;
            v28 = (const char *)*((_DWORD *)v29 - 2);
            if ( !v28 )
              goto LABEL_61;
          }
          v31 = (const char *)*((_DWORD *)v29 - 2);
          v29 += 12;
          strcpy(v30, v31);
          v32 = strlen(v31);
          v30[v32] = 124;
          v30 += v32 + 1;
          *v30 = 0;
          v28 = (const char *)*((_DWORD *)v29 - 2);
        }
        while ( v28 );
      }
    }
LABEL_61:
    v33 = (*v146)[v16] - (*v146)[65];
    v34 = strlen(v170);
    v35 = (char *)malloc(v34 + 1);
    *((_DWORD *)&unk_642C4 + v33) = v35;
    if ( !v35 )
    {
      strcpy((char *)v169, "Failed to malloc group commands buf");
      sub_38438(3, (const char *)v169, 1);
      sub_16724(1);
    }
    strcpy(v35, v170);
    if ( v145 && *v145 )
    {
      v11 = v145;
      continue;
    }
    break;
  }
LABEL_69:
  v36 = dword_6039C;
  v37 = (const char *)off_607CC;
  if ( off_607CC )
    v36 = (int *)&off_607CC;
  strcpy(v170, "|");
  if ( off_607CC )
  {
    v38 = &v170[1];
    do
    {
      while ( *((_BYTE *)v36 + 8) )
      {
        v39 = (const char *)v36[3];
        v36 += 3;
        v37 = v39;
        if ( !v39 )
          goto LABEL_77;
      }
      strcpy(v38, v37);
      v40 = strlen(v37);
      v38[v40] = 124;
      v38 += v40 + 1;
      *v38 = 0;
      v41 = (const char *)v36[3];
      v36 += 3;
      v37 = v41;
    }
    while ( v41 );
  }
LABEL_77:
  v42 = *v146;
  v43 = (*v146)[82];
  if ( (unsigned int)(v43 + 128) < 0x180 )
    v43 = v42[v43];
  v44 = v43 - v42[65];
  v45 = strlen(v170);
  v46 = (char *)malloc(v45 + 1);
  *((_DWORD *)&unk_642C4 + v44) = v46;
  if ( !v46 )
  {
LABEL_308:
    strcpy((char *)v169, "Failed to malloc noprivgroup commands buf");
    sub_38438(3, (const char *)v169, 1);
    sub_16724(1);
  }
  strcpy(v46, v170);
  free(s);
  v47 = (const char *)dword_62F4C;
  if ( !dword_62F4C )
    goto LABEL_114;
  v48 = strlen((const char *)dword_62F4C);
  v49 = (char *)malloc(v48 + 1);
  v50 = v49;
  if ( !v49 )
  {
    strcpy(v170, "Failed to malloc ipaccess buf");
    sub_38438(3, v170, 1);
    sub_16724(1);
  }
  strcpy(v49, v47);
  v51 = v50 - 1;
  v52 = 1;
  while ( 1 )
  {
    v54 = (unsigned __int8)*++v51;
    v53 = v54;
    if ( !v54 )
      break;
    if ( v53 == 44 )
      ++v52;
  }
  dword_62F6C = (int)calloc(v52, 0x24u);
  if ( !dword_62F6C )
  {
    strcpy(v170, "Failed to calloc ipaccess");
    sub_38438(3, v170, 1);
    sub_16724(1);
  }
  v55 = 0;
  dword_62F68 = 0;
  if ( !v50 || (v56 = (unsigned __int8)*v50, !*v50) )
  {
    free(v50);
    goto LABEL_158;
  }
  v57 = v50;
  do
  {
    v58 = v56 == 32;
    if ( v56 != 32 )
      v58 = v56 == 9;
    if ( v58 )
    {
      v59 = (unsigned __int8 *)(v57 + 1);
      do
      {
        v87 = v59;
        v60 = *v59++;
        v56 = v60;
        v61 = v60 == 32;
        if ( v60 != 32 )
          v61 = v56 == 9;
      }
      while ( v61 );
    }
    else
    {
      v87 = (unsigned __int8 *)v57;
    }
    if ( v56 == 44 )
    {
      v57 = (char *)(v87 + 1);
    }
    else
    {
      v62 = strchr((const char *)v87, 44);
      v57 = v62;
      if ( v62 )
      {
        *v62 = 0;
        v57 = v62 + 1;
      }
      v63 = _ctype_b_loc();
      v64 = *v87;
      v65 = *v146;
      v66 = *((_BYTE *)*v146 + 328);
      if ( ((*v63)[v64] & 0x400) != 0 && v87[1] == 58 )
      {
        v86 = v65[v64];
        if ( v86 == v65[87] || *((_DWORD *)&unk_642C4 + v86 - v65[65]) )
          v66 = v86;
        v87 += 2;
      }
      v67 = (char *)(dword_62F6C + 36 * v55);
      v67[32] = v66;
      v68 = *v87;
      if ( v68 == 48 && v87[1] == 47 && v87[2] == 48 )
      {
        v69 = v87[3];
        if ( !v87[3] )
        {
          v70 = v67 - 1;
          v71 = v87[3];
          do
          {
            ++v69;
            *++v70 = v71;
            v70[16] = v71;
          }
          while ( v69 != 16 );
          goto LABEL_110;
        }
      }
      v72 = strchr((const char *)v87, 47);
      if ( !v72 )
      {
        v88 = 0;
        v89 = v67;
        do
        {
          ++v88;
          v89[16] = -1;
          ++v89;
        }
        while ( v88 != 16 );
        v68 = *v87;
        v72 = (char *)&v87[strlen((const char *)v87)];
      }
      if ( v68 == 91 && *(v72 - 1) == 93 )
      {
        v73 = 1;
        *v87++ = 0;
        *(v72 - 1) = 0;
      }
      else
      {
        v73 = 0;
      }
      if ( !*v72 )
        goto LABEL_124;
      *v72 = 0;
      v77 = strtol(v72 + 1, 0, 10);
      if ( v77 > 0 )
      {
        v78 = v73 ? 0 : 96;
        v79 = v77 + v78;
        if ( v79 <= 128 )
        {
          v80 = 0;
          v81 = v67;
          v82 = 0;
          do
          {
            ++v80;
            v81[16] = 0;
            ++v81;
          }
          while ( v80 != 16 );
          v83 = 7;
          while ( v79 > 0 )
          {
            v84 = &v67[v82];
            if ( !v83 )
              ++v82;
            --v79;
            v85 = (unsigned __int8)v84[16] | (1 << v83);
            if ( v83 )
              --v83;
            else
              v83 = 7;
            v84[16] = v85;
          }
LABEL_124:
          for ( i = 0; i != 16; ++i )
            v67[i] = 0;
          if ( v73 )
          {
            if ( inet_pton(10, (const char *)v87, v67) != 1 )
              goto LABEL_111;
          }
          else
          {
            sprintf(v170, "::ffff:%s", v87);
            v55 = dword_62F68;
            v67 = (char *)(dword_62F6C + 36 * dword_62F68);
            if ( inet_pton(10, v170, v67) != 1 )
              goto LABEL_111;
          }
          for ( j = 0; j != 16; ++j )
          {
            v76 = *v67++;
            *(v67 - 1) = v76 & v67[15];
          }
LABEL_110:
          dword_62F68 = ++v55;
        }
      }
    }
LABEL_111:
    if ( !v57 )
      break;
    v56 = (unsigned __int8)*v57;
  }
  while ( *v57 );
  free(v50);
  if ( !v55 )
  {
LABEL_158:
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      snprintf(v170, 0x800u, "API not running (no valid IPs specified)%s", " - API will not be available");
      sub_38438(4, v170, 0);
    }
    goto LABEL_7;
  }
LABEL_114:
  sub_2B21C();
  sprintf(service, "%d", v152);
  req.ai_flags = 1;
  memset(&req.ai_family, 0, 28);
  if ( getaddrinfo(off_6016C, service, &req, &v160) )
  {
    if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
    {
      snprintf(v170, 0x800u, "API failed to resolve %s", off_6016C);
LABEL_119:
      sub_38438(3, v170, 0);
    }
    goto LABEL_7;
  }
  v90 = v160;
  if ( v160 )
  {
    v91 = v160;
    while ( 1 )
    {
      v92 = socket(v90->ai_family, 1, 0);
      *ptr = v92;
      if ( v92 > 0 )
        break;
      v91 = v91->ai_next;
      if ( !v91 )
        goto LABEL_240;
      v90 = v160;
    }
  }
  else
  {
    v92 = *ptr;
LABEL_240:
    if ( v92 == -1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        v121 = _errno_location();
        v122 = strerror(*v121);
        snprintf(v170, 0x800u, "API initialisation failed (%s)%s", v122, " - API will not be available");
        sub_38438(3, v170, 0);
      }
      freeaddrinfo(v160);
      free(ptr);
      return;
    }
    v91 = 0;
  }
  optval = 1;
  if ( setsockopt(v92, 1, 2, &optval, 4u) < 0 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    v123 = _errno_location();
    v124 = strerror(*v123);
    snprintf(v170, 0x800u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v124);
    sub_38438(7, v170, 0);
  }
  v93 = time(0);
  while ( 2 )
  {
    if ( bind(*ptr, v91->ai_addr, v91->ai_addrlen) >= 0 )
    {
      freeaddrinfo(v160);
      if ( listen(*ptr, 100) < 0 )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          v133 = _errno_location();
          v134 = strerror(*v133);
          snprintf(v170, 0x800u, "API3 initialisation failed (%s)%s", v134, " - API will not be available");
          sub_38438(3, v170, 0);
        }
        close(*ptr);
        goto LABEL_7;
      }
      if ( !dword_62F4C )
      {
        if ( byte_63D64 )
        {
          if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
            goto LABEL_180;
          snprintf(v170, 0x800u, "API running in UNRESTRICTED read access mode on port %d (%d)", v152, *ptr);
        }
        else
        {
          if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 3 )
            goto LABEL_180;
          snprintf(v170, 0x800u, "API running in local read access mode on port %d (%d)", v152, *ptr);
        }
LABEL_179:
        sub_38438(4, v170, 0);
        goto LABEL_180;
      }
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(v170, 0x800u, "API running in IP access mode on port %d (%d)", v152, *ptr);
        goto LABEL_179;
      }
LABEL_180:
      if ( byte_63BC4 )
        sub_363A4();
      dword_62F8C = (int)sub_38C34("StrBufs", 12, 2, 0, 0, "api.c", "api", 5391);
      if ( !byte_62F64 )
      {
        v94 = 0;
        v95 = 0;
        while ( 1 )
        {
          v96 = *ptr;
          addr_len = 128;
          fd = accept(v96, &addr, &addr_len);
          if ( fd < 0 )
            break;
          v97 = sub_30928(&addr, &v158, &v156);
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            if ( v97 )
              LOWORD(v98) = 14040;
            else
              LOWORD(v98) = 14052;
            HIWORD(v98) = 5;
            snprintf(needle, 0x800u, "API: connection from %s - %s", v158, v98);
            sub_38438(7, needle, 0);
          }
          if ( v97 )
          {
            v99 = recv(fd, v169, 0x1FFFu, 0);
            v100 = v99;
            if ( v99 < 0 )
            {
              LOBYTE(v169[0]) = 0;
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                v136 = _errno_location();
                v137 = strerror(*v136);
                snprintf(needle, 0x800u, "API: recv failed: %s", v137);
                sub_38438(7, needle, 0);
              }
            }
            else
            {
              v101 = (unsigned __int8)byte_630C1;
              *((_BYTE *)v169 + v99) = 0;
              if ( v101 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf(needle, 0x800u, "API: recv command: (%d) '%s'", v99, (const char *)v169);
                sub_38438(7, needle, 0);
              }
              v102 = 0;
              v103 = time(0);
              v104 = (_BYTE *)v150[1];
              v150[2] = v104;
              dword_62F90 = v103;
              *v104 = 0;
              *((_BYTE *)v150 + 13) = 0;
              if ( LOBYTE(v169[0]) != 123 )
              {
                v105 = strchr((const char *)v169, 124);
                v106 = v105;
                if ( v105 )
                {
                  *v105 = 0;
                  v106 = v105 + 1;
                }
                else
                {
                  v102 = 0;
                }
                v107 = (const char *)v169;
LABEL_205:
                if ( strchr(v107, 43) )
                {
                  v157 = 1;
                  v108 = strlen(v107);
                  haystack = (char *)malloc(v108 + 3);
                  if ( !haystack )
                  {
                    snprintf(needle, 0x800u, "OOM cmdsbuf in %s %s():%d", "api.c", "api", 5502);
                    sub_38438(3, needle, 1);
                    sub_16724(1);
                  }
                  v94 = 1;
                  v106 = 0;
                  *(_WORD *)haystack = 124;
                }
                else
                {
                  haystack = 0;
                  v94 = 0;
                  v157 = 0;
                }
                v109 = (char *)v107;
                v155 = v106;
                while ( 2 )
                {
                  if ( !v94 )
                    goto LABEL_214;
                  v110 = strchr(v109, 43);
                  v107 = v110;
                  if ( v110 )
                  {
                    *v110 = 0;
                    v107 = v110 + 1;
                  }
                  if ( !*v109 )
                  {
LABEL_220:
                    v109 = (char *)v107;
                  }
                  else
                  {
LABEL_214:
                    v111 = (const char *)off_607CC;
                    if ( off_607CC )
                    {
                      v112 = &off_607CC;
                      v113 = 0;
                      while ( strcmp(v109, v111) )
                      {
                        v114 = (const char *)v112[3];
                        v112 += 3;
                        v111 = v114;
                        ++v113;
                        if ( !v114 )
                          goto LABEL_253;
                      }
                      sprintf(v164, "|%s|", v109);
                      if ( v94 )
                      {
                        if ( strstr(haystack, v164) )
                          goto LABEL_220;
                        v139 = strlen(haystack);
                        *(_WORD *)stpcpy(&haystack[v139], v109) = 124;
                        sub_3079C(v150, v109, v102, &v157);
                        v140 = &dword_6039C[3 * v113];
                        if ( !*((_BYTE *)v140 + 1081) )
                        {
                          sub_32F3C(v150, 45, *((unsigned __int8 *)v140 + 1081), v140[268], v102);
                          sub_31E94((int)v150, v102);
                          goto LABEL_220;
                        }
                      }
                      v126 = v156;
                      v127 = (*v146)[v156];
                      if ( v127 == (*v146)[87]
                        || (v144 = v156,
                            v128 = strstr(*((const char **)&unk_642C4 + v127 - (*v146)[65]), v164),
                            v126 = v144,
                            v128) )
                      {
                        ((void (__fastcall *)(_DWORD *, int, char *, int, int))dword_6039C[3 * v113 + 269])(
                          v150,
                          fd,
                          v155,
                          v102,
                          v126);
                      }
                      else
                      {
                        sub_32F3C(v150, 45, 0, dword_6039C[3 * v113 + 268], v102);
                        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                        {
                          snprintf(
                            needle,
                            0x800u,
                            "API: access denied to '%s' for '%s' command",
                            v158,
                            (const char *)dword_6039C[3 * v113 + 268]);
                          sub_38438(7, needle, 0);
                        }
                      }
                      v125 = (int)v150;
                      if ( v94 )
                      {
LABEL_260:
                        sub_31E94(v125, v102);
                        goto LABEL_220;
                      }
                    }
                    else
                    {
LABEL_253:
                      if ( v94 )
                      {
                        sub_3079C(v150, v109, v102, &v157);
                        sub_32F3C(v150, 14, 0, 0, v102);
                        v125 = (int)v150;
                        goto LABEL_260;
                      }
                      sub_32F3C(v150, 14, 0, 0, v102);
                      v125 = (int)v150;
                    }
                    sub_30AC8(v125, fd, v102);
                  }
                  if ( v109 )
                    v115 = v94 & 1;
                  else
                    v115 = 0;
                  if ( !v115 )
                  {
                    v116 = v102;
                    goto LABEL_226;
                  }
                  continue;
                }
              }
              v135 = sub_45B3C(v169, v100, 0, v166);
              v95 = v135;
              if ( v135 && !*v135 )
              {
                v138 = (_DWORD *)sub_46698(v135, "command");
                if ( v138 )
                {
                  if ( *v138 == 2 )
                  {
                    v107 = (const char *)sub_469F0(v138);
                    v141 = (char *)sub_46698(v95, "parameter");
                    v106 = v141;
                    if ( v141 )
                    {
                      v142 = *(_DWORD *)v141;
                      if ( *(_DWORD *)v141 == 2 )
                      {
                        v102 = 1;
                        v106 = (char *)sub_469F0(v141);
                        goto LABEL_205;
                      }
                      if ( v142 == 3 )
                      {
                        v143 = sub_46AC0((int)v141);
                        v102 = 1;
                        v106 = v170;
                        sprintf(v170, "%d", v143);
                        goto LABEL_205;
                      }
                      if ( v142 == 4 )
                      {
                        sub_46B70();
                        v102 = 1;
                        v106 = v170;
                        sprintf(v170, "%f", v1);
                        goto LABEL_205;
                      }
                      v106 = 0;
                    }
                    v102 = 1;
                    goto LABEL_205;
                  }
                  sub_32F3C(v150, 14, 0, 0, 1u);
                }
                else
                {
                  sub_32F3C(v150, 24, 0, 0, 1u);
                }
              }
              else
              {
                sub_32F3C(v150, 23, 0, 0, 1u);
              }
              sub_30AC8((int)v150, fd, 1);
              v116 = (int)v95;
              v102 = 1;
              if ( v95 )
                v116 = 1;
LABEL_226:
              if ( v94 )
                sub_30AC8((int)v150, fd, v102);
              if ( v116 )
              {
                if ( !*v95 )
                {
                  v117 = v95[1];
                  if ( v117 != -1 )
                  {
                    v118 = v117 - 1;
                    v95[1] = v118;
                    if ( !v118 )
                      sub_46C5C((void **)v95);
                  }
                }
              }
            }
          }
          close(fd);
          if ( byte_62F64 )
            goto LABEL_265;
        }
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          v129 = _errno_location();
          v130 = strerror(*v129);
          snprintf(needle, 0x800u, "API failed (%s)%s (%d)", v130, " - API will not be available", *ptr);
          sub_38438(3, needle, 0);
        }
      }
LABEL_265:
      _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
      sub_32320(ptr);
      free(ptr);
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        if ( byte_62F66 )
        {
          v131 = "QUIT";
        }
        else if ( byte_62F65 )
        {
          v131 = "RESTART";
        }
        else if ( byte_62F64 )
        {
          v131 = "BYE";
        }
        else
        {
          v131 = "UNKNOWN!";
        }
        snprintf(needle, 0x800u, "API: terminating due to: %s", v131);
        sub_38438(7, needle, 0);
      }
      if ( pthread_mutex_lock(&stru_62F70) )
        sub_B844("api", 5601);
      if ( byte_62F65 )
      {
        if ( sub_2F0EC((int)&env, 0, (void *(*)(void *))sub_3212C, &env) )
        {
          sub_320F0(&stru_62F70, "api", 5607);
          strcpy(needle, "API failed to initiate a restart - aborting");
          sub_38438(3, needle, 1);
          sub_16724(1);
        }
      }
      else
      {
        if ( !byte_62F66 )
        {
LABEL_280:
          if ( pthread_mutex_unlock(&stru_62F70) )
            sub_B91C("api", 5622);
          off_60178();
          return;
        }
        if ( sub_2F0EC(
               (int)&env,
               (const pthread_attr_t *)(unsigned __int8)byte_62F65,
               (void *(*)(void *))sub_32224,
               &env) )
        {
          sub_320F0(&stru_62F70, "api", 5616);
          strcpy(needle, "API failed to initiate a clean quit - aborting");
          sub_38438(3, needle, 1);
          sub_16724(1);
        }
      }
      pthread_detach(env.__jmpbuf[3]);
      goto LABEL_280;
    }
    v119 = _errno_location();
    v120 = strerror(*v119);
    if ( time(0) - v93 <= 61 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        snprintf(v170, 0x800u, "API bind to port %d failed - trying again in 30sec", v152);
        sub_38438(4, v170, 0);
      }
      sub_2B21C();
      continue;
    }
    break;
  }
  freeaddrinfo(v160);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
  {
    snprintf(v170, 0x800u, "API bind to port %d failed (%s)%s", v152, v120, " - API will not be available");
    goto LABEL_119;
  }
LABEL_7:
  free(ptr);
}
// 383F4: variable 'v1' is possibly undefined
// AD38: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 32224: using guessed type void __noreturn sub_32224();
// 6006C: using guessed type int dword_6006C;
// 6016C: using guessed type char *off_6016C;
// 60170: using guessed type int dword_60170;
// 60178: using guessed type int (*off_60178)();
// 6039C: using guessed type int dword_6039C[];
// 607CC: using guessed type _UNKNOWN *off_607CC;
// 60964: using guessed type int dword_60964;
// 62F4C: using guessed type int dword_62F4C;
// 62F64: using guessed type char byte_62F64;
// 62F65: using guessed type char byte_62F65;
// 62F66: using guessed type char byte_62F66;
// 62F68: using guessed type int dword_62F68;
// 62F6C: using guessed type int dword_62F6C;
// 62F88: using guessed type int dword_62F88;
// 62F8C: using guessed type int dword_62F8C;
// 62F90: using guessed type int dword_62F90;
// 62F94: using guessed type int dword_62F94;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 63BC4: using guessed type char byte_63BC4;
// 63D64: using guessed type char byte_63D64;
// 63D71: using guessed type char byte_63D71;
// 63EE4: using guessed type int dword_63EE4;

//----- (00038438) --------------------------------------------------------
void __fastcall sub_38438(int a1, const char *a2, int a3)
{
  struct tm *v6; // r0
  int v7; // r0
  FILE *v8; // r8
  size_t v9; // r0
  size_t v10; // r0
  time_t tv_sec; // [sp+1Ch] [bp-4Ch] BYREF
  struct timeval v12; // [sp+20h] [bp-48h] BYREF
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_632F0 )
  {
    syslog(a1 | 0x80, "%s", a2);
    return;
  }
  v12.tv_sec = 0;
  v12.tv_usec = 0;
  sub_2B13C(&v12);
  tv_sec = v12.tv_sec;
  v6 = localtime(&tv_sec);
  snprintf(
    s,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d] ",
    v6->tm_year + 1900,
    v6->tm_mon + 1,
    v6->tm_mday,
    v6->tm_hour,
    v6->tm_min,
    v6->tm_sec);
  v7 = fileno((FILE *)stderr);
  if ( isatty(v7) )
  {
    if ( byte_62F98 )
    {
LABEL_4:
      v8 = (FILE *)dword_62F9C;
      if ( dword_62F9C || (v8 = fopen(dword_62FA0, word_630A0), (dword_62F9C = (int)v8) != 0) )
      {
        v9 = strlen(s);
        fwrite(s, v9, 1u, v8);
        v10 = strlen(a2);
        fwrite(a2, v10, 1u, (FILE *)dword_62F9C);
        fwrite(ptr, 1u, 1u, (FILE *)dword_62F9C);
        fflush((FILE *)dword_62F9C);
      }
    }
  }
  else
  {
    fprintf((FILE *)stderr, "%s%s\n", s, a2);
    fflush((FILE *)stderr);
    if ( byte_62F98 )
      goto LABEL_4;
  }
  sub_386F4(a1, s, a2, a3);
}
// 60E80: using guessed type int stderr;
// 62F98: using guessed type char byte_62F98;
// 62F9C: using guessed type int dword_62F9C;
// 632F0: using guessed type char byte_632F0;

//----- (000385EC) --------------------------------------------------------
int sub_385EC()
{
  int result; // r0
  int *v1; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_mutex_lock(&stru_63D48);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 47);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}
// 16724: using guessed type void __fastcall __noreturn sub_16724(_DWORD);
// 38438: using guessed type int __fastcall sub_38438(_DWORD, _DWORD, _DWORD);

//----- (00038674) --------------------------------------------------------
int __fastcall sub_38674(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  result = pthread_mutex_unlock(&stru_63D48);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x800u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}
// 16724: using guessed type void __fastcall __noreturn sub_16724(_DWORD);
// 38438: using guessed type int __fastcall sub_38438(_DWORD, _DWORD, _DWORD);

//----- (000386F4) --------------------------------------------------------
int __fastcall sub_386F4(int result, const char *a2, const char *a3, int a4)
{
  int v4; // r6

  v4 = result;
  if ( !byte_64218 || result == 3 )
  {
    if ( a4 )
    {
      pthread_mutex_trylock(&stru_63D48);
      sub_38674(38);
      off_60178();
      if ( byte_6007C )
      {
LABEL_5:
        result = sub_19438(v4, a2, a3);
        if ( result )
          return result;
      }
    }
    else if ( byte_6007C )
    {
      goto LABEL_5;
    }
    sub_385EC();
    printf("%s%s%s", a2, a3, asc_54E8C);
    sub_38674(49);
    return off_60178();
  }
  return result;
}
// 6007C: using guessed type char byte_6007C;
// 60178: using guessed type int (*off_60178)();
// 64218: using guessed type char byte_64218;

//----- (000387C4) --------------------------------------------------------
void __fastcall sub_387C4(int a1, const char *a2, int a3)
{
  int v6; // r0

  if ( byte_632F0 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    sub_386F4(a1, "", a2, a3);
  }
}
// 60E80: using guessed type int stderr;
// 632F0: using guessed type char byte_632F0;

//----- (00038858) --------------------------------------------------------
const char *__fastcall sub_38858(const char **a1, const char *a2, const char *a3, int a4)
{
  const char *result; // r0
  int v6; // r3
  const char *v7; // r2
  size_t v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  const char **v12; // r0
  const char **v13; // r5
  size_t v14; // lr
  const char *v15; // r1
  const char *v16; // r0
  const char **v17; // r3
  int v18; // r2
  const char *v19; // r1
  const char **v20; // r3
  int v21; // r2
  char *v22; // r0
  int v23; // r1
  const char *v24; // r0
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = (const char *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x800u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (size_t)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (size_t)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x800u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v12 = (const char **)calloc(v8, 0x10u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(
      s,
      0x800u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v14 = v8 - 1;
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] - 1)] = v12;
  v15 = *a1;
  v16 = a1[6];
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v16[v8];
  *v13 = v15;
  v13[1] = 0;
  v13[2] = (const char *)(v13 + 4);
  if ( (int)(v8 - 1) > 1 )
  {
    v17 = v13;
    v18 = 1;
    do
    {
      v19 = *a1;
      ++v18;
      v17[5] = (const char *)v17;
      v17[6] = (const char *)(v17 + 8);
      v17[4] = v19;
      v17 += 4;
    }
    while ( v18 != v14 );
  }
  v20 = &v13[4 * v14];
  *v20 = *a1;
  v20[1] = (const char *)&v13[4 * v8 - 8];
  v20[2] = 0;
  v21 = *((unsigned __int8 *)a1 + 44);
  a1[3] = (const char *)v13;
  if ( v21 )
    a1[4] = (const char *)v20;
  do
  {
    v22 = (char *)a1[15];
    v23 = (int)(a1[14] + 1);
    a1[14] = (const char *)v23;
    v24 = (const char *)realloc(v22, 4 * v23);
    a1[15] = v24;
    if ( !v24 )
    {
      snprintf(
        s,
        0x800u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    result = (const char *)calloc(1u, (size_t)a1[5]);
    v13[3] = result;
    if ( !result )
    {
      snprintf(s, 0x800u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_38438(3, s, 1);
      sub_16724(1);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] - 1)] = result;
    v13 = (const char **)v13[2];
  }
  while ( v13 );
  return result;
}

//----- (00038B8C) --------------------------------------------------------
_BYTE *__fastcall sub_38B8C(int a1)
{
  _BYTE *result; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = calloc(1u, 0x40u);
  if ( !result )
  {
    snprintf(s, 0x800u, "Failed to calloc store for %s in %s %s():%d", *(const char **)a1, "klist.c", "k_new_store", 85);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  result[4] = 1;
  *((_DWORD *)result + 2) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)result = *(_DWORD *)a1;
  result[44] = *(_BYTE *)(a1 + 44);
  return result;
}

//----- (00038C34) --------------------------------------------------------
_BYTE *__fastcall sub_38C34(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r4
  pthread_mutex_t *v13; // r0
  pthread_mutex_t *v14; // r10
  int *v16; // r0
  int *v17; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      0x800u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v12 = calloc(1u, 0x40u);
  if ( !v12 )
  {
    snprintf(s, 0x800u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v12[4] = 0;
  v13 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v14 = v13;
  *((_DWORD *)v12 + 2) = v13;
  if ( !v13 )
  {
    snprintf(s, 0x800u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( pthread_mutex_init(v13, 0) )
  {
    v17 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v14[1], 0) )
  {
    v16 = _errno_location();
    snprintf(s, 0x800u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v16, "klist.c", "_k_new_list", 115);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  *(_DWORD *)v12 = a1;
  *((_DWORD *)v12 + 5) = a2;
  *((_DWORD *)v12 + 9) = a3;
  *((_DWORD *)v12 + 10) = a4;
  v12[44] = a5;
  sub_38858((const char **)v12, a6, a7, a8);
  return v12;
}

//----- (00038EEC) --------------------------------------------------------
int __fastcall sub_38EEC(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r4
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return v5;
    sub_38858((const char **)a1, a2, a3, a4);
    if ( !*(_DWORD *)(a1 + 12) )
      return v5;
    v5 = *(_DWORD *)(a1 + 12);
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (00038F6C) --------------------------------------------------------
int __fastcall sub_38F6C(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_38EEC(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (00038F98) --------------------------------------------------------
int __fastcall sub_38F98(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}

//----- (00039058) --------------------------------------------------------
const char *__fastcall sub_39058(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r3
  int v10; // r3
  int v11; // r3
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_head",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v9 = *(_DWORD *)(a1 + 12);
  if ( v9 )
    *(_DWORD *)(v9 + 4) = a2;
  v10 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v10 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v11 = *(_DWORD *)(a1 + 32);
  ++*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 32) = v11 + 1;
  return result;
}

//----- (0003913C) --------------------------------------------------------
const char *__fastcall sub_3913C(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  const char *v9; // r3
  const char *v10; // r3
  bool v11; // zf
  const char *v12; // r3
  int v13; // r2
  const char *v14; // r3
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_tail",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v9 = a1[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v9;
  v10 = a1[4];
  if ( v10 )
    *((_DWORD *)v10 + 2) = a2;
  v11 = a1[3] == 0;
  v12 = a1[8];
  v13 = (int)(a1[7] + 1);
  a1[4] = (const char *)a2;
  v14 = v12 + 1;
  if ( v11 )
    a1[3] = (const char *)a2;
  a1[7] = (const char *)v13;
  a1[8] = v14;
  return result;
}

//----- (00039284) --------------------------------------------------------
const char **__fastcall sub_39284(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  const char *v9; // r3
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 )
    *(_DWORD *)(v8 + 8) = a2;
  else
    result[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v9 = result[8];
  ++result[7];
  result[8] = v9 + 1;
  return result;
}

//----- (000393C8) --------------------------------------------------------
const char **__fastcall sub_393C8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  const char *v9; // r3
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x800u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a2;
  }
  else if ( *((_BYTE *)result + 44) )
  {
    result[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v9 = result[8];
  ++result[7];
  result[8] = v9 + 1;
  return result;
}

//----- (0003951C) --------------------------------------------------------
const char *__fastcall sub_3951C(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r3
  int v10; // r3
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  result = *(const char **)a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_unlink_item",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v9 = *(_DWORD *)(a2 + 4);
  if ( v9 )
    *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(a2 + 8);
  if ( v10 )
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (00039614) --------------------------------------------------------
const char *__fastcall sub_39614(const char **a1, int *a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *result; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r2
  const char *v12; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  v7 = *a1;
  result = (const char *)*a2;
  if ( v7 != (const char *)*a2 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v7,
      "_k_list_transfer_to_head",
      (const char *)*a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v9 = *((unsigned __int8 *)a1 + 44);
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( a1[3] )
  {
    v10 = a2[3];
    v11 = a1[4];
    if ( v10 )
    {
      *(_DWORD *)(v10 + 4) = v11;
    }
    else
    {
      v9 = 0;
      a2[4] = (int)v11;
    }
    if ( v10 )
      v9 = a2[3];
    *((_DWORD *)a1[4] + 2) = v9;
    a2[3] = (int)a1[3];
    a1[4] = 0;
    v12 = a1[7];
    a1[3] = 0;
    a2[7] += (int)v12;
    a1[7] = 0;
    a2[8] += (int)a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00039784) --------------------------------------------------------
const char *__fastcall sub_39784(const char **a1, int *a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *result; // r0
  const char *v9; // r3
  int v10; // r2
  const char *v11; // r2
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  v7 = *a1;
  result = (const char *)*a2;
  if ( v7 != (const char *)*a2 )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v7,
      "_k_list_transfer_to_tail",
      (const char *)*a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = a2[4];
    if ( v10 )
      *(_DWORD *)(v10 + 8) = v9;
    else
      a2[3] = (int)v9;
    if ( v10 )
      v10 = a2[4];
    *((_DWORD *)a1[3] + 1) = v10;
    a2[4] = (int)a1[4];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    a2[7] += (int)v11;
    a1[7] = 0;
    a2[8] += (int)a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (000398EC) --------------------------------------------------------
int __fastcall sub_398EC(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x800u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (00039A00) --------------------------------------------------------
int __fastcall sub_39A00(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[2048]; // [sp+20h] [bp-800h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x800u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  free(ptr);
  return 0;
}

//----- (00039B54) --------------------------------------------------------
int __fastcall sub_39B54(__int64 a1, _QWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    *(_QWORD *)HIDWORD(a1) = *(_QWORD *)(v2 + 16);
    a1 = *(_QWORD *)(v2 + 24);
    *a2 = a1;
  }
  else
  {
    *(_QWORD *)HIDWORD(a1) = 0;
    *a2 = 0;
  }
  return a1;
}

//----- (00039FB4) --------------------------------------------------------
int sub_39FB4()
{
  sub_2AD04(dword_65E48);
  sub_2AD04(dword_66EAC);
  sub_2AD04(dword_65E3C);
  return sub_2AD04(dword_66EAC);
}
// 65E3C: using guessed type int dword_65E3C;
// 65E48: using guessed type int dword_65E48;
// 66EAC: using guessed type int dword_66EAC;

//----- (00039FF4) --------------------------------------------------------
void sub_39FF4()
{
  char v0[2052]; // [sp+0h] [bp-804h] BYREF

  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    strcpy(v0, "Updated Work!");
    sub_38438(7, v0, 0);
  }
  byte_630C8 = 1;
  byte_630C9 = 1;
  byte_630CA = 1;
  byte_630CB = 1;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630C8: using guessed type char byte_630C8;
// 630C9: using guessed type char byte_630C9;
// 630CA: using guessed type char byte_630CA;
// 630CB: using guessed type char byte_630CB;
// 632F0: using guessed type char byte_632F0;

//----- (0003A0EC) --------------------------------------------------------
int sub_3A0EC()
{
  int result; // r0

  if ( !byte_630D8 )
    return system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
  return result;
}
// 630D8: using guessed type char byte_630D8;

//----- (0003A10C) --------------------------------------------------------
void sub_3A10C()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  v0 = calloc(1u, 0x188u);
  v1 = v0;
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-L3.c", 0xEEEu, "bitmain_L3_detect");
  v0[37] = 1;
  v0[1] = &unk_60D68;
  v0[8] = 0;
  v2 = calloc(0x328u, 1u);
  v1[5] = v2;
  if ( !v2 )
  {
    strcpy(v3, "Failed to calloc cgpu_info data");
    sub_38438(3, v3, 1);
    sub_16724(1);
  }
  if ( !sub_27C18(v1) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-L3.c", 0xEF6u, "bitmain_L3_detect");
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v3, 0x800u, "%s detect new device", "bitmain_L3_detect");
    sub_38438(7, v3, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0003A268) --------------------------------------------------------
int sub_3A268()
{
  char *v0; // r4
  char *v1; // r5
  int v2; // t1
  int v3; // t1
  int result; // r0
  _DWORD v5[32]; // [sp+0h] [bp-80h] BYREF

  memset(v5, 0, sizeof(v5));
  v0 = "t";
  v1 = "t";
  do
  {
    v2 = *((_DWORD *)v1 + 1);
    v1 += 4;
    sprintf((char *)v5, "echo 0 > /sys/class/gpio/gpio%d/value", v2);
    system((const char *)v5);
  }
  while ( v1 != (char *)&unk_55464 );
  sub_2B21C();
  do
  {
    v3 = *((_DWORD *)v0 + 1);
    v0 += 4;
    sprintf((char *)v5, "echo 1 > /sys/class/gpio/gpio%d/value", v3);
    result = system((const char *)v5);
  }
  while ( v0 != (char *)&unk_55464 );
  return result;
}

//----- (0003A2F0) --------------------------------------------------------
void sub_3A2F0()
{
  int v0; // r9
  int *v1; // r12
  int v2; // r4
  bool v3; // cc
  int *v4; // r3
  unsigned int v5; // r1
  unsigned int v6; // r0
  unsigned int v7; // r6
  int v8; // r8
  int v9; // r3
  unsigned int v10; // r7
  unsigned int v11; // r0
  int v12; // r3
  unsigned int v13; // lr
  bool v14; // zf
  unsigned int v15; // r1
  double v16; // d16
  const char *v17; // r3
  int v18; // [sp+18h] [bp-81Ch]
  int v19; // [sp+1Ch] [bp-818h]
  unsigned int v20; // [sp+20h] [bp-814h]
  int v21; // [sp+24h] [bp-810h]
  char s[2052]; // [sp+30h] [bp-804h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(s, "receive_func");
    sub_38438(5, s, 0);
  }
  if ( byte_630D9 )
  {
    v0 = 0;
    do
    {
      pthread_mutex_lock(&stru_630DC);
      v2 = dword_C30C0;
      while ( v2 )
      {
        while ( 1 )
        {
          --v2;
          v3 = (unsigned int)dword_C30BC > 0x35E;
          ++v0;
          dword_C30C0 = v2;
          v4 = &dword_C30B8[2 * dword_C30BC + 2];
          if ( (unsigned int)dword_C30BC > 0x35E )
            v1 = dword_C30B8;
          v5 = (unsigned __int8)byte_C548C;
          v6 = *(int *)((char *)v4 + 6);
          v7 = *((unsigned __int8 *)v4 + 11);
          v8 = *((unsigned __int8 *)v4 + 13);
          if ( (unsigned int)dword_C30BC > 0x35E )
          {
            v9 = 0;
          }
          else
          {
            v9 = 798904;
            ++dword_C30BC;
          }
          if ( v3 )
            v1[1] = v9;
          v10 = bswap32(v6);
          if ( v7 > 0x30 )
            break;
          v11 = (unsigned __int8)(v10 >> 20) / v5;
          if ( v10 != dword_6A4B8[1248 * (unsigned __int8)v11 + 1 + 26 * v7] )
            break;
          v12 = dword_6A4B8[1248 * (unsigned __int8)v11 + 22 + 26 * v7 + v8];
          if ( v12 > 0 )
            break;
          v13 = v10 >> 28;
          if ( v10 >> 28 > 5 )
            v20 = v13 - 2;
          v21 = v12 + 1;
          if ( v10 >> 28 <= 5 )
            v20 = v10 >> 28;
          v14 = byte_630C1 == 0;
          v15 = 864 * v8 + 12 * (unsigned __int8)v11 + v20;
          v18 = dword_630F4;
          v19 = dword_66EB0[v15];
          dword_6A4B8[1248 * (unsigned __int8)v11 + 22 + 26 * v7 + v8] = v21;
          v1 = dword_66EB0;
          dword_66EB0[v15] = v19 + 1;
          dword_630F4 = v18 + 1;
          if ( v14 )
            break;
          if ( !byte_632F0 )
          {
            v1 = (int *)&byte_630C0;
            if ( !byte_630C0 && dword_60964 <= 6 )
              break;
          }
          if ( v10 >> 28 > 5 )
            v13 -= 2;
          snprintf(
            s,
            0x800u,
            "wc %d chian %d asic %d core %d nonce %08x times %d nonce %08x",
            v7,
            v8,
            (unsigned __int8)v11,
            v13,
            v10,
            v21,
            dword_6A4B8[1248 * (unsigned __int8)v11 + 1 + 26 * v7]);
          sub_38438(7, s, 0);
          v2 = dword_C30C0;
          if ( !dword_C30C0 )
            goto LABEL_28;
        }
      }
LABEL_28:
      pthread_mutex_unlock(&stru_630DC);
      sub_2B21C();
    }
    while ( byte_630D9 );
  }
  else
  {
    v0 = 0;
  }
  v16 = (double)(3456 * (unsigned __int8)byte_C5468);
  if ( (int)v16 - 20 > dword_630F4 )
    byte_60DE8 = 0;
  byte_630F8 = 0;
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    snprintf(s, 0x800u, "total_nonce : %d total_value_nonce : %d need %d", v0, dword_630F4, (int)v16 - 20);
    sub_38438(5, s, 0);
    if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
    {
      v17 = "TRUE";
      if ( !byte_60DE8 )
        v17 = "FALSE";
      snprintf(s, 0x800u, "test result : %s ", v17);
      sub_38438(5, s, 0);
    }
  }
}
// 3A3D0: variable 'v1' is possibly undefined
// 3A494: variable 'v20' is possibly undefined
// 60964: using guessed type int dword_60964;
// 60DE8: using guessed type char byte_60DE8;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630D9: using guessed type char byte_630D9;
// 630F4: using guessed type int dword_630F4;
// 630F8: using guessed type char byte_630F8;
// 632F0: using guessed type char byte_632F0;
// 66EB0: using guessed type _DWORD dword_66EB0[11];
// 6A4B8: using guessed type _DWORD dword_6A4B8[6354];
// C30B8: using guessed type int dword_C30B8[];
// C30BC: using guessed type int dword_C30BC;
// C30C0: using guessed type int dword_C30C0;
// C5468: using guessed type char byte_C5468;
// C548C: using guessed type char byte_C548C;

//----- (0003A73C) --------------------------------------------------------
int __fastcall sub_3A73C(const char *a1)
{
  char *v1; // r3
  const char *v2; // r0
  char *v3; // r2

  v1 = strchr(a1, 58) + 1;
  do
    v2 = v1++;
  while ( *v2 == 32 );
  do
    v3 = v1++;
  while ( *v3 != 32 );
  *v3 = 0;
  return strtol(v2, 0, 10);
}

//----- (0003A788) --------------------------------------------------------
void __noreturn sub_3A788()
{
  char v0; // r9
  char v1; // r8
  unsigned int v2; // r7
  unsigned int v3; // r4
  FILE *v4; // r6
  unsigned int v5; // r0
  unsigned int v6; // r4
  unsigned int v7; // r3
  unsigned int v8; // r0
  unsigned int v9; // r7
  unsigned int v10; // r3
  _DWORD v11[65]; // [sp+0h] [bp-104h] BYREF

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = fopen("/proc/interrupts", "r");
  while ( 1 )
  {
    fseek(v4, 0, 0);
    memset(v11, 0, 256);
    while ( fgets((char *)v11, 256, v4) )
    {
      if ( strstr((const char *)v11, "256:") && strstr((const char *)v11, "gpiolib") )
      {
        v5 = sub_3A73C((const char *)v11);
        if ( v3 > v5 )
          v6 = v5 + ~v3;
        else
          v6 = v5 - v3;
        v7 = (60 * v6) >> 1;
        if ( v7 )
        {
          v1 = 1;
          if ( v7 > 0x19C8 )
            v7 = 6600;
        }
        else
        {
          v1 = 0;
        }
        dword_C544A = v7;
        v3 = v5;
        dword_C546B = v7;
      }
      else if ( strstr((const char *)v11, "254:") && strstr((const char *)v11, "gpiolib") )
      {
        v8 = sub_3A73C((const char *)v11);
        if ( v2 > v8 )
          v9 = v8 + ~v2;
        else
          v9 = v8 - v2;
        v10 = (60 * v9) >> 1;
        if ( v10 )
        {
          v0 = 1;
          if ( v10 > 0x19C8 )
            v10 = 6600;
        }
        else
        {
          v0 = 0;
        }
        v2 = v8;
        dword_C544E[0] = v10;
        dword_C546F = v10;
      }
    }
    byte_C5469 = v1 + v0;
    sleep(1u);
  }
}
// C544A: using guessed type int dword_C544A;
// C544E: using guessed type int dword_C544E[5];
// C5469: using guessed type char byte_C5469;
// C546B: using guessed type int dword_C546B;
// C546F: using guessed type int dword_C546F;

//----- (0003A904) --------------------------------------------------------
bool __fastcall sub_3A904(int a1, _BYTE *a2)
{
  int v2; // r2
  size_t v4; // r0
  _BOOL4 result; // r0
  char v6[32]; // [sp+0h] [bp-824h] BYREF
  char s[2048]; // [sp+20h] [bp-804h] BYREF

  v2 = *(_DWORD *)&aBitmainL3Detec_0[8 * a1 + 76];
  memset(v6, 0, sizeof(v6));
  sprintf(v6, "%08x", v2);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "regdata: %s", v6);
    sub_38438(7, s, 0);
  }
  v4 = strlen(v6);
  result = sub_295B8(a2, (unsigned __int8 *)v6, v4 >> 1);
  if ( !result )
  {
    snprintf(s, 0x800u, "Invalid vil plldata for reg data, hex2bin error now: %s", v6);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0003AA38) --------------------------------------------------------
int __fastcall sub_3AA38(unsigned __int64 a1, char *a2, int a3, char a4)
{
  __int64 v6; // r0
  double v7; // r0
  double v8; // d8
  __int64 v10; // r0
  double v11; // d0
  double v12; // r0
  int v13; // r3
  int v14; // [sp+0h] [bp-20h]
  __int16 v15; // [sp+1Ch] [bp-4h] BYREF

  v15 = 0;
  if ( a1 > 0x3B9AC9FF )
  {
    LODWORD(v6) = sub_4943C(a1, 1000000);
    LODWORD(v7) = sub_493C8(v6);
    v15 = 71;
    v8 = v7 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xF423F )
  {
    LODWORD(v10) = sub_4943C(a1, 1000);
    LODWORD(v7) = sub_493C8(v10);
    v15 = 77;
    v8 = v7 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3E7 )
  {
    LODWORD(v7) = sub_493C8(a1);
    v15 = 75;
    v8 = v7 / 1000.0;
LABEL_3:
    if ( !a3 )
      return snprintf(a2, 0x10u, "%.3g%s", v8, (const char *)&v15);
    goto LABEL_7;
  }
  LODWORD(v7) = sub_493C8(a1);
  v8 = v7;
  if ( !a3 )
    return snprintf(a2, 0x10u, "%d%s", (unsigned int)v7, (const char *)&v15);
LABEL_7:
  if ( v8 <= 0.0 )
  {
    v11 = 0.0;
  }
  else
  {
    v11 = v8;
    v12 = log10(v7);
    floor(v12);
  }
  v13 = a3 + 1;
  v14 = (int)((double)(a3 - 1) - v11);
  if ( a4 )
    return snprintf(a2, 0x10u, "%*.*f%s", v13, v14, v8, (const char *)&v15);
  else
    return snprintf(a2, 0x10u, "%*.*f", v13, v14, v8);
}
// 3AA8C: variable 'v6' is possibly undefined
// 3AA9C: variable 'v7' is possibly undefined
// 3AAF0: variable 'v10' is possibly undefined

//----- (0003AC10) --------------------------------------------------------
_DWORD *sub_3AC10()
{
  _DWORD *v0; // r0
  int v1; // r6
  _DWORD *v2; // r0
  _DWORD *v3; // r4
  _DWORD *v4; // r4
  _DWORD *v5; // r0
  _DWORD *v6; // r4
  _DWORD *v7; // r0
  int i; // r6
  const char *v9; // r2
  int j; // r6
  _DWORD *v11; // r0
  int k; // r6
  const char *v13; // r2
  _DWORD *v14; // r0
  _DWORD *v15; // r4
  __int64 v16; // r0
  __int64 v17; // r0
  double v18; // d8
  double v19; // r0
  double v20; // d16
  int v21; // r6
  _DWORD *v22; // r0
  _DWORD *v23; // r4
  const char *v24; // r2
  int m; // r6
  char *v26; // r2
  int n; // r6
  _DWORD *v28; // r0
  int ii; // r5
  const char *v30; // r2
  int v31; // r3
  unsigned __int64 v32; // d16
  _QWORD *v33; // r2
  int v34; // t1
  double v36; // [sp+8h] [bp-18h] BYREF
  char s[16]; // [sp+10h] [bp-10h] BYREF

  v0 = sub_32D44(0, "miner_count", &byte_C5468, 0);
  v1 = 0;
  v2 = sub_32CFC(v0, "frequency", byte_C5494, 0);
  v3 = sub_32D44(v2, "fan_num", &byte_C5469, 0);
  sprintf(s, "fan%d", 1);
  v4 = sub_32DF8(v3, s, (const char *)&dword_C544A, 0);
  sprintf(s, "fan%d", 2);
  v5 = sub_32DF8(v4, s, (const char *)dword_C544E, 0);
  v6 = sub_32D44(v5, "temp_num", &byte_C5468, 0);
  do
  {
    sprintf(s, "temp%d", v1 + 1);
    v7 = sub_32D68(v6, s, (const char *)&unk_C4BCC + 64 * v1++ + 320, 0);
    v6 = v7;
  }
  while ( v1 != 4 );
  for ( i = 0; i != 4; ++i )
  {
    sprintf(s, "temp2_%d", i + 1);
    v9 = (char *)&unk_C4BCC + 64 * i + 322;
    v6 = sub_32D68(v6, s, v9, 0);
  }
  for ( j = 0; j != 4; ++j )
  {
    sprintf(s, "temp3%d", j + 1);
    v11 = sub_32D68(v6, s, (const char *)&unk_C4BCC + 64 * j + 312, 0);
    v6 = v11;
  }
  for ( k = 0; k != 4; ++k )
  {
    sprintf(s, "temp4_%d", k + 1);
    v13 = (char *)&unk_C4BCC + 64 * k + 314;
    v14 = sub_32D68(v6, s, v13, 0);
    v6 = v14;
  }
  v15 = sub_32DF8(v14, "temp_max", (const char *)dword_C5473, 0);
  LODWORD(v16) = sub_49488(dbl_63B88 + dbl_63C10 + dbl_639D0);
  *(_QWORD *)&dword_636A8 = v16;
  v17 = v16 + dword_63E44;
  if ( v17 )
  {
    v18 = (double)dword_63E44;
    LODWORD(v19) = sub_493DC(v17);
    v20 = v18 / v19;
  }
  else
  {
    v20 = 0.0;
  }
  v36 = v20;
  v21 = 0;
  v22 = sub_35684(v15, "Device Hardware%", (const char *)&v36, 0);
  v23 = sub_32DB0(v22, "no_matching_work", (const char *)&dword_63E44, 0);
  do
  {
    sprintf(s, "chain_acn%d", v21 + 1);
    v24 = (char *)&unk_C4BCC + v21++ + 2198;
    v23 = sub_32D44(v23, s, v24, 0);
  }
  while ( v21 != 4 );
  for ( m = 0; m != 4; ++m )
  {
    sprintf(s, "chain_acs%d", m + 1);
    v26 = (char *)&unk_C4BCC + 88 * m;
    v23 = sub_32CFC(v23, s, v26 + 1800, 0);
  }
  for ( n = 0; n != 4; ++n )
  {
    sprintf(s, "chain_hw%d", n + 1);
    v28 = sub_32DF8(v23, s, (const char *)&unk_C4BCC + 4 * n + 632, 0);
    v23 = v28;
  }
  for ( ii = 0; ii != 4; ++ii )
  {
    sprintf(s, "chain_rate%d", ii + 1);
    v30 = (char *)&unk_65E6C + 16 * ii;
    v23 = sub_32CFC(v23, s, v30, 0);
  }
  v31 = 805859;
  v32 = 0;
  v33 = &unk_63100;
  do
  {
    v34 = *(unsigned __int8 *)++v31;
    if ( v34 == 1 )
      v32 += *v33;
    ++v33;
  }
  while ( v31 != 805863 );
  sub_3AA38(v32, byte_62E38, 6, 0);
  return v23;
}
// 3AE1C: variable 'v16' is possibly undefined
// 3AE40: variable 'v19' is possibly undefined
// 636A8: using guessed type int dword_636A8;
// 639D0: using guessed type double dbl_639D0;
// 63B88: using guessed type double dbl_63B88;
// 63C10: using guessed type double dbl_63C10;
// 63E44: using guessed type int dword_63E44;
// C544A: using guessed type int dword_C544A;
// C544E: using guessed type int dword_C544E[5];
// C5468: using guessed type char byte_C5468;
// C5469: using guessed type char byte_C5469;
// C5473: using guessed type int dword_C5473[6];

//----- (0003B068) --------------------------------------------------------
int __fastcall sub_3B068(pthread_rwlock_t *a1)
{
  int result; // r0
  int *v2; // r0
  char s[2052]; // [sp+10h] [bp-804h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v2 = _errno_location();
    snprintf(
      s,
      0x800u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v2,
      "driver-btm-L3.c",
      "bitmain_L3_prepare",
      3757);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  return result;
}

//----- (0003B0EC) --------------------------------------------------------
void __noreturn sub_3B0EC()
{
  int v0; // r10
  char buf; // [sp+8h] [bp-804h] BYREF
  char v2[2051]; // [sp+9h] [bp-803h] BYREF

  v0 = 0;
  while ( 1 )
  {
    if ( *((_BYTE *)&unk_C4BCC + v0 + 24) && byte_60DE9 )
    {
      pthread_mutex_lock(&stru_63120);
      if ( ioctl(dword_C54A6, 0x703u, *(int *)&aBitmainL3Detec_0[4 * v0 + 892] >> 1) < 0
        && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
      {
        snprintf(&buf, 0x800u, " %d ioctl error in %s", v0, "pic_heart_beat_func");
        sub_38438(3, &buf, 0);
      }
      buf = 85;
      v2[0] = -86;
      write(dword_C54A6, &buf, 1u);
      sub_2B244();
      write(dword_C54A6, v2, 1u);
      sub_2B244();
      buf = 22;
      write(dword_C54A6, &buf, 1u);
      pthread_mutex_unlock(&stru_63120);
      sub_2B21C();
    }
    if ( ++v0 > 3 )
    {
      v0 = 0;
      sleep(0xAu);
    }
  }
}
// 60964: using guessed type int dword_60964;
// 60DE9: using guessed type char byte_60DE9;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// C54A6: using guessed type int dword_C54A6;

//----- (0003B268) --------------------------------------------------------
int __fastcall sub_3B268(int a1)
{
  if ( a1 == 115200 )
    return 4098;
  if ( a1 <= 115200 )
  {
    if ( a1 == 19200 )
      return 14;
    if ( a1 > 19200 )
    {
      if ( a1 != 38400 )
      {
        if ( a1 == 57600 )
          return 4097;
        return 0;
      }
      return 15;
    }
    if ( a1 == 9600 )
      return 13;
    return 0;
  }
  if ( (_UNKNOWN *)a1 == &unk_70800 )
    return 4100;
  if ( a1 <= (int)&unk_70800 )
  {
    if ( a1 == 230400 )
      return 4099;
    return 0;
  }
  if ( a1 != 921600 )
  {
    if ( a1 == 3000000 )
      return 4109;
    return 0;
  }
  return 4103;
}

//----- (0003B324) --------------------------------------------------------
unsigned int __fastcall sub_3B324(unsigned int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r2
  int v4; // t1

  if ( a3 )
  {
    v3 = &a2[a3];
    do
    {
      v4 = *a2++;
      result = (unsigned __int16)(*(_WORD *)&aBitmainL3Detec_0[2 * (v4 ^ (result >> 8)) + 928] ^ ((_WORD)result << 8));
    }
    while ( a2 != v3 );
  }
  return result;
}

//----- (0003B360) --------------------------------------------------------
int __fastcall sub_3B360(_BYTE *a1, int a2)
{
  int v2; // r5
  int v3; // r3
  char v4; // r8
  int v5; // r9
  int v6; // r6
  char v7; // r7
  unsigned __int8 v8; // r12
  unsigned int v9; // r2
  int v10; // r4
  unsigned __int8 v11; // r8
  int v12; // r10
  int result; // r0

  if ( a2 )
  {
    v2 = 1;
    LOBYTE(v3) = 0;
    v4 = 1;
    v5 = 1;
    v6 = 1;
    v7 = 1;
    v8 = 0;
    v9 = 128;
    while ( 1 )
    {
      ++v8;
      v3 = (unsigned __int8)(v3 + 1);
      if ( ((unsigned __int8)v9 & *a1) != 0 )
        LOBYTE(v10) = v7 ^ 1;
      else
        LOBYTE(v10) = v7;
      v9 >>= 1;
      v10 = (unsigned __int8)v10;
      if ( v3 == 8 )
        ++a1;
      v11 = v4 ^ v10;
      if ( v3 == 8 )
      {
        LOBYTE(v3) = 0;
        v9 = 128;
      }
      v12 = v11;
      v7 = v6;
      v4 = v2;
      if ( v8 == a2 )
        break;
      v6 = v5;
      v2 = (unsigned __int8)v10;
      v5 = v12;
    }
    if ( !v6 )
    {
      result = 0;
      goto LABEL_15;
    }
  }
  else
  {
    v10 = 1;
    v2 = 1;
    v12 = 1;
    v5 = 1;
  }
  result = 16;
LABEL_15:
  if ( v5 )
    result = (unsigned __int8)result | 8;
  if ( v12 )
    result = (unsigned __int8)result | 4;
  if ( v2 )
    result = (unsigned __int8)result | 2;
  if ( v10 )
    return (unsigned __int8)result | 1;
  return result;
}

//----- (0003B44C) --------------------------------------------------------
int __fastcall sub_3B44C(int a1)
{
  _DWORD *v1; // r6
  int v2; // r10
  unsigned __int8 *v3; // r2
  unsigned int v4; // r8
  int *v5; // r9
  int v6; // r0
  int v7; // r3
  unsigned int v8; // r0
  int v9; // r10
  unsigned int v10; // r9
  unsigned int v11; // r9
  unsigned int v12; // r9
  _DWORD *v13; // r8
  unsigned int v14; // r9
  __int64 v15; // r4
  int v17; // r2
  int *v18; // r0
  int *v19; // r0
  int *v20; // r0
  int *v21; // r0
  pthread_mutex_t *mutex; // [sp+20h] [bp-82Ch]
  unsigned int v23; // [sp+24h] [bp-828h]
  pthread_rwlock_t *rwlock; // [sp+28h] [bp-824h]
  int v26; // [sp+34h] [bp-818h]
  unsigned int v27; // [sp+38h] [bp-814h] BYREF
  int v28; // [sp+3Ch] [bp-810h] BYREF
  struct timeval v29; // [sp+40h] [bp-80Ch] BYREF
  char s[2052]; // [sp+48h] [bp-804h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v2 = v1[5];
  v28 = 0;
  mutex = (pthread_mutex_t *)v2;
  sub_2B13C(&v29);
  dbl_630D0 = 0.0;
  pthread_mutex_lock(&stru_630DC);
  if ( pthread_mutex_lock((pthread_mutex_t *)v2) )
  {
    v21 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v21,
      "driver-btm-L3.c",
      "bitmain_scanhash",
      433);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  rwlock = (pthread_rwlock_t *)(v2 + 24);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v2 + 24)) )
  {
    v20 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v20,
      "driver-btm-L3.c",
      "bitmain_scanhash",
      433);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)v2) )
  {
    v19 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v19,
      "driver-btm-L3.c",
      "bitmain_scanhash",
      433);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  v26 = 0;
  while ( dword_C30C0 )
  {
    v4 = dword_C30BC;
    --dword_C30C0;
    v5 = &dword_C30B8[2 * dword_C30BC + 2];
    v6 = sub_3B360((_BYTE *)v5 + 6, 51);
    v7 = v5[3] & 0x1F;
    if ( v6 == v7 )
    {
      v8 = *(int *)((char *)v5 + 6);
      v9 = *((unsigned __int8 *)v5 + 11);
      v10 = *((unsigned __int8 *)v5 + 13);
      v27 = v8;
      v23 = v10;
      v11 = v8;
      pthread_mutex_lock(&stru_63138);
      v12 = bswap32(v11);
      v13 = *(_DWORD **)&mutex[7].__size[4 * v9 + 23];
      pthread_mutex_unlock(&stru_63138);
      if ( !v13 )
      {
        if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
        {
          v4 = dword_C30BC;
          goto LABEL_8;
        }
        snprintf(s, 0x800u, "%s%d: work %02x not find error", *(const char **)(v1[1] + 8), v1[2], v9);
        goto LABEL_35;
      }
      v28 = 0;
      if ( sub_1A2DC(a1, (int)v13, v12, &v28) )
      {
        sub_25A80((int)v13);
      }
      else if ( !v28 )
      {
        if ( v23 > 4 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
        {
          snprintf(s, 0x800u, "Chain_ID [%d] Error!", v23);
          sub_38438(3, s, 0);
        }
        v17 = 0;
        ++*((_DWORD *)&unk_C4BCC + v23 + 158);
        goto LABEL_54;
      }
      v14 = (unsigned __int8)(v12 >> 20) / (unsigned int)(unsigned __int8)byte_C548C;
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "%s: chain %d which_asic_nonce %d ", "bitmain_scanhash", v23, v14);
        sub_38438(7, s, 0);
      }
      if ( v23 <= 4 && *((_BYTE *)&unk_C4BCC + v23 + 24) )
      {
        if ( (unsigned __int8)v14 <= 0x47u )
        {
          v17 = 1;
          *(_QWORD *)&dbl_630D0 += 256LL;
          ++*((_DWORD *)&unk_C4BCC + 72 * v23 + v14 + 162);
LABEL_54:
          sub_2F884(v13, (char *)&v27, v17);
          v4 = dword_C30BC;
          goto LABEL_8;
        }
        if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
          goto LABEL_36;
        snprintf(s, 0x800u, "Which Nonce Cause Err![%d]", v14);
LABEL_35:
        sub_38438(3, s, 0);
LABEL_36:
        v4 = dword_C30BC;
        goto LABEL_8;
      }
      if ( v26 )
        goto LABEL_36;
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf(s, 0x800u, "ChainID Cause Error! ChainID:[%d]", v23);
        sub_38438(3, s, 0);
        v4 = dword_C30BC;
        v26 = 1;
      }
      else
      {
        v4 = dword_C30BC;
        v26 = 1;
      }
    }
    else
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        snprintf(s, 0x800u, "crc5 error,should be %02x,but check as %02x", v7, v6);
        sub_38438(3, s, 0);
        if ( byte_632F0 )
        {
          v4 = dword_C30BC;
LABEL_7:
          v3 = (unsigned __int8 *)&dword_C30B8[2 * v4 + 2];
          snprintf(
            s,
            0x800u,
            "get nonce %02x%02x%02x%02x wc %02x diff %02x crc5 %02x chainid %02x",
            v3[6],
            HIBYTE(dword_C30B8[2 * v4 + 3]),
            LOBYTE(dword_C30B8[2 * v4 + 4]),
            BYTE1(dword_C30B8[2 * v4 + 4]),
            v3[10],
            v3[11],
            v3[12],
            v3[13]);
          sub_38438(5, s, 0);
          v4 = dword_C30BC;
          goto LABEL_8;
        }
        v4 = dword_C30BC;
        if ( byte_630C0 )
          goto LABEL_7;
      }
      if ( dword_60964 > 4 )
        goto LABEL_7;
    }
LABEL_8:
    if ( v4 > 0x35E )
      dword_C30BC = 0;
    else
      dword_C30BC = v4 + 1;
  }
  if ( pthread_rwlock_unlock(rwlock) )
  {
    v18 = _errno_location();
    snprintf(
      s,
      0x800u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v18,
      "driver-btm-L3.c",
      "bitmain_scanhash",
      524);
    sub_38438(3, s, 1);
    sub_16724(1);
  }
  off_60178();
  pthread_mutex_unlock(&stru_630DC);
  sub_2B21C();
  v15 = *(_QWORD *)&dbl_630D0;
  if ( *(_QWORD *)&dbl_630D0 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(
      s,
      0x800u,
      "%s: hashes %llu...",
      "bitmain_scanhash",
      vshld_n_s64(*(__int64 *)&dbl_630D0, 0x10u) - *(_QWORD *)&dbl_630D0);
    sub_38438(7, s, 0);
    v15 = *(_QWORD *)&dbl_630D0;
  }
  *(_QWORD *)&dbl_630D0 = vshld_n_s64(v15, 0x10u) - v15;
  return 0;
}
// 60178: using guessed type int (*off_60178)();
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630D0: using guessed type double dbl_630D0;
// 632F0: using guessed type char byte_632F0;
// C30B8: using guessed type int dword_C30B8[];
// C30BC: using guessed type int dword_C30BC;
// C30C0: using guessed type int dword_C30C0;
// C548C: using guessed type char byte_C548C;

//----- (0003BBBC) --------------------------------------------------------
ssize_t __fastcall sub_3BBBC(int a1, const void *a2, size_t a3)
{
  ssize_t v6; // r6
  char v8[2048]; // [sp+0h] [bp-800h] BYREF

  flock(a1, 2);
  v6 = write(a1, a2, a3);
  if ( a3 != v6 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
  {
    strcpy(v8, "write error!!");
    sub_38438(3, v8, 0);
  }
  flock(a1, 8);
  sub_2B244();
  return v6;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (0003BC80) --------------------------------------------------------
void __fastcall __noreturn sub_3BC80(unsigned __int8 *a1)
{
  pthread_t v1; // r0
  int v2; // r3
  int v3; // r2
  int v4; // r3
  void **v5; // r6
  void *v6; // r4
  int v7; // r4
  _WORD *v8; // r2
  int v9; // r1
  unsigned int v10; // r3
  int v11; // t1
  int v12; // r4
  unsigned __int8 *v13; // r5
  int v14; // r3
  int v15; // r10
  int v16; // r2
  int i; // r3
  int v18; // r3
  char *v19; // r2
  unsigned int v20; // r1
  int v21; // r1
  _BYTE *v22; // r12
  unsigned int v23; // r2
  char *v24; // r0
  unsigned int v25; // r3
  char v26; // r6
  char v27; // lr
  int v28; // [sp+10h] [bp-94Ch]
  void **src; // [sp+30h] [bp-92Ch]
  int v31; // [sp+34h] [bp-928h]
  int *v32; // [sp+48h] [bp-914h]
  struct timeval v33; // [sp+54h] [bp-908h] BYREF
  struct timeval v34; // [sp+5Ch] [bp-900h] BYREF
  char v35[80]; // [sp+64h] [bp-8F8h] BYREF
  char v36[4]; // [sp+B4h] [bp-8A8h] BYREF
  _BYTE v37[20]; // [sp+F0h] [bp-86Ch] BYREF
  _WORD v38[42]; // [sp+104h] [bp-858h] BYREF
  char v39[2052]; // [sp+158h] [bp-804h] BYREF

  v1 = pthread_self();
  pthread_detach(v1);
  if ( !byte_630C1 )
  {
    v28 = a1[156];
    v32 = *(int **)(a1 + 703);
    v31 = v28 + 40;
    goto LABEL_10;
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
  {
    strcpy(v39, "Start To Fill Work!");
    sub_38438(7, v39, 0);
    v2 = a1[156];
    v32 = *(int **)(a1 + 703);
    if ( !byte_630C1 )
      goto LABEL_9;
    if ( byte_632F0 || byte_630C0 )
    {
LABEL_54:
      v28 = v2;
      v31 = v2 + 40;
      snprintf(v39, 0x800u, "Start To Fill Work!ChainIndex:[%d]", v2);
      sub_38438(7, v39, 0);
      goto LABEL_10;
    }
  }
  else
  {
    v2 = a1[156];
    v32 = *(int **)(a1 + 703);
  }
  if ( dword_60964 <= 6 )
  {
LABEL_9:
    v28 = v2;
    v31 = v2 + 40;
LABEL_10:
    if ( !byte_63150 )
      goto LABEL_50;
    while ( 1 )
    {
      sub_2B13C(&v33);
      v3 = v33.tv_sec - v34.tv_sec;
      v4 = v33.tv_usec - v34.tv_usec;
      if ( v33.tv_usec - v34.tv_usec < 0 )
      {
        --v3;
        v4 += 1000000;
      }
      if ( !byte_630C8[v28] && v4 / 1000 + 1000 * v3 < (unsigned int)(1000 * LODWORD(flt_C4BEC)) )
      {
LABEL_50:
        sub_2B21C();
        goto LABEL_10;
      }
      sub_2B13C(&v34);
      do
      {
        pthread_mutex_lock(&stru_63138);
        v5 = (void **)sub_244C4((int)v32, *v32);
        pthread_mutex_unlock(&stru_63138);
      }
      while ( !v5 );
      v6 = v5[85];
      byte_630C8[v28] = 0;
      src = v5;
      memset(v38, 0, 0x52u);
      v7 = (unsigned __int8)v6 & 0x7F;
      memcpy(v35, v5, sizeof(v35));
      sub_2F560(v35, 80);
      memcpy(&v38[2], &v35[4], 0x4Cu);
      v8 = v38;
      v9 = 32;
      v10 = 0xFFFF;
      LOBYTE(v38[1]) = v7;
      qmemcpy(v38, " P", 2);
      while ( 1 )
      {
        v10 = (unsigned __int16)(*(_WORD *)&aBitmainL3Detec_0[2 * (v9 ^ (v10 >> 8)) + 928] ^ ((_WORD)v10 << 8));
        if ( v8 == (_WORD *)((char *)&v38[39] + 1) )
          break;
        v11 = *((unsigned __int8 *)v8 + 1);
        v8 = (_WORD *)((char *)v8 + 1);
        v9 = v11;
      }
      v12 = v7 + 46;
      v13 = &a1[4 * v12];
      v38[40] = (v10 >> 8) | ((_WORD)v10 << 8);
      pthread_mutex_lock(&stru_63138);
      if ( *(_DWORD *)(v13 + 7) )
      {
        sub_152B8(*(void ***)(v13 + 7));
        v14 = *((_DWORD *)v13 + 2);
        v13[7] = 0;
        *((_DWORD *)v13 + 2) = v14 & 0xFF000000;
      }
      *(_DWORD *)&a1[4 * v12 + 7] = sub_19E18((int)v5, 0);
      pthread_mutex_unlock(&stru_63138);
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(v39, 0x800u, "ChainID[%d] Wirte Work", v28);
        sub_38438(7, v39, 0);
      }
      v15 = 0;
      sub_3BBBC(*(_DWORD *)&a1[4 * v31 + 1], v38, 0x52u);
      byte_630F8 = 1;
      do
      {
        v16 = 1;
        for ( i = 0; i != 60 && i != 77; ++i )
        {
          if ( i == 78 )
          {
            v37[18] = 0;
          }
          else
          {
            v36[i] = 32;
            if ( v16 == 80 )
              goto LABEL_36;
          }
LABEL_33:
          ++v16;
        }
        v36[i] = 124;
        if ( v16 != 80 )
          goto LABEL_33;
LABEL_36:
        v18 = 28;
        v19 = &v35[79];
        do
        {
          v20 = (unsigned int)(v15 * 2) >> v18;
          v18 -= 4;
          *++v19 = aBitmainL3Detec_0[(v20 & 0xF) + 1480];
        }
        while ( v18 != -4 );
        v21 = 0;
        v22 = v37;
        v23 = 0;
        do
        {
          v24 = &v39[(v23 >> 3) + 2048 + v21];
          v21 += 3;
          if ( v23 + v15 * 2 > 0x51 )
            break;
          v25 = *((unsigned __int8 *)&v38[v15] + v23++);
          v26 = aBitmainL3Detec_0[(v25 & 0xF) + 1480];
          v27 = aBitmainL3Detec_0[(v25 >> 4) + 1480];
          if ( v25 - 32 > 0x5E )
            LOBYTE(v25) = 46;
          *(v24 - 2200) = v26;
          *(v24 - 2201) = v27;
          *++v22 = v25;
        }
        while ( v23 != 16 );
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(v39, 0x800u, "%s", v36);
          sub_38438(7, v39, 0);
        }
        v15 += 8;
      }
      while ( v15 != 48 );
      sub_2B13C((struct timeval *)&dword_63154);
      sub_2B21C();
      sub_152B8(src);
      if ( !byte_63150 )
        goto LABEL_50;
    }
  }
  goto LABEL_54;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630F8: using guessed type char byte_630F8;
// 63150: using guessed type char byte_63150;
// 63154: using guessed type int dword_63154;
// 632F0: using guessed type char byte_632F0;
// C4BEC: using guessed type float flt_C4BEC;

//----- (0003C338) --------------------------------------------------------
int sub_3C338()
{
  int v0; // r11
  int i; // r9
  unsigned __int8 *v2; // r5
  int v3; // r6
  int v4; // r7
  int v5; // t1
  char *v7; // r0
  char v8; // r2
  _WORD *v9; // r3
  char v10; // lr
  char v11; // lr
  char v12; // r12
  _WORD *v13; // r1
  char v14; // t1
  _WORD *v15; // r0
  int v16; // r12
  unsigned int v17; // r1
  int v18; // t1
  unsigned int v19; // r12
  int v20; // r0
  unsigned int v21; // r1
  int v22; // t1
  int v23; // r0
  int v24; // [sp+Ch] [bp-860h]
  _WORD v25[44]; // [sp+10h] [bp-85Ch] BYREF
  char s[2040]; // [sp+68h] [bp-804h] BYREF

  sub_2B13C(&stru_65E40);
  byte_630F8 = 1;
  if ( byte_C548D )
  {
    v0 = 0;
    v24 = 0;
    do
    {
      for ( i = 0; i != 48; ++i )
      {
        v2 = (_BYTE *)(&dword_C4BE0 + 3);
        v3 = 4992 * v24 + 104 * i;
        v4 = 805836;
        do
        {
          v5 = *++v2;
          if ( v5 == 1 )
          {
            sub_2B21C();
            memset(v25, 0, 0x56u);
            v7 = (char *)&dword_6A4B8[2] + v3 + 3;
            v8 = *v7;
            v9 = v25;
            v10 = *((_BYTE *)&dword_6A4B8[2] + v3);
            LOBYTE(v25[1]) = *(_DWORD *)((char *)dword_6A4B8 + v3);
            LOBYTE(v25[2]) = v10;
            v11 = *((_BYTE *)&dword_6A4B8[2] + v3 + 1);
            HIBYTE(v25[3]) = v8;
            v12 = *((_BYTE *)&dword_6A4B8[2] + v3 + 2);
            v13 = (_WORD *)((char *)&v25[3] + 1);
            HIBYTE(v25[2]) = v11;
            LOBYTE(v25[3]) = v12;
            qmemcpy(v25, "!T", 2);
            do
            {
              v14 = *++v7;
              *((_BYTE *)v13 + 1) = v14;
              v13 = (_WORD *)((char *)v13 + 1);
            }
            while ( v13 != (_WORD *)((char *)&v25[41] + 1) );
            v15 = v25;
            v16 = 33;
            v17 = 0xFFFF;
            while ( 1 )
            {
              v17 = (unsigned __int16)(*(_WORD *)&aBitmainL3Detec_0[2 * (v16 ^ (v17 >> 8)) + 928] ^ ((_WORD)v17 << 8));
              if ( v15 == (_WORD *)((char *)&v25[41] + 1) )
                break;
              v18 = *((unsigned __int8 *)v15 + 1);
              v15 = (_WORD *)((char *)v15 + 1);
              v16 = v18;
            }
            v19 = v17 >> 8;
            v20 = 33;
            v21 = 0xFFFF;
            while ( 1 )
            {
              LOWORD(v21) = *(_WORD *)&aBitmainL3Detec_0[2 * (v20 ^ (v21 >> 8)) + 928] ^ ((_WORD)v21 << 8);
              if ( v9 == (_WORD *)((char *)&v25[41] + 1) )
                break;
              v22 = *((unsigned __int8 *)v9 + 1);
              v9 = (_WORD *)((char *)v9 + 1);
              v20 = v22;
            }
            v23 = *(_DWORD *)(v4 + 8);
            v25[42] = v19 | ((_WORD)v21 << 8);
            if ( sub_3BBBC(v23, v25, 0x56u) != 86 )
            {
              tcflush(*(_DWORD *)(v4 + 8), 2);
              if ( sub_3BBBC(*(_DWORD *)(v4 + 8), v25, 0x56u) != 86 )
              {
                tcflush(*(_DWORD *)(v4 + 8), 2);
                if ( sub_3BBBC(*(_DWORD *)(v4 + 8), v25, 0x56u) != 86 )
                  perror("Send work error!");
              }
            }
            ++v0;
          }
          v4 += 4;
        }
        while ( v2 != (unsigned __int8 *)&unk_C4BE7 );
      }
      ++v24;
    }
    while ( (unsigned __int8)byte_C548D > v24 );
  }
  else
  {
    v0 = 0;
  }
  sub_2B21C();
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    snprintf(s, 0x800u, "send_work : %d ", v0);
    sub_38438(5, s, 0);
  }
  return 0;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630F8: using guessed type char byte_630F8;
// 632F0: using guessed type char byte_632F0;
// 65E40: using guessed type struct timeval stru_65E40;
// 6A4B8: using guessed type _DWORD dword_6A4B8[6354];
// C4BE0: using guessed type int dword_C4BE0;
// C548D: using guessed type char byte_C548D;

//----- (0003C604) --------------------------------------------------------
ssize_t __fastcall sub_3C604(int a1, void *a2, size_t a3)
{
  ssize_t v4; // r4
  char v6[2052]; // [sp+0h] [bp-804h] BYREF

  v4 = read(a1, a2, a3);
  if ( a3 != v4 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
  {
    strcpy(v6, "read error!!");
    sub_38438(3, v6, 0);
  }
  return v4;
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (0003C69C) --------------------------------------------------------
int sub_3C69C()
{
  pthread_mutex_lock(&stru_6315C);
  dword_6432C = 0;
  dword_64330 = 0;
  dword_64334 = 0;
  return pthread_mutex_unlock(&stru_6315C);
}
// 6432C: using guessed type int dword_6432C;
// 64330: using guessed type int dword_64330;
// 64334: using guessed type int dword_64334;

//----- (0003C6D4) --------------------------------------------------------
void __noreturn sub_3C6D4()
{
  unsigned __int64 v0; // d8
  unsigned int v1; // r8
  int v2; // r6
  unsigned int v3; // r2
  unsigned int v4; // r3
  int v5; // r1
  int v6; // r9
  int *v7; // r5
  int v8; // r0
  int v9; // r7
  int v10; // r2
  int v11; // r11
  int v12; // r5
  unsigned __int8 *v13; // r9
  char v14; // r11
  int v15; // r9
  char v16; // r12
  char *v17; // r3
  char *v18; // r2
  int v19; // r3
  char *v20; // r5
  char *v21; // r2
  unsigned int v22; // r3
  char *v23; // r3
  char *v24; // r3
  int i; // r7
  char *v26; // r0
  int v27; // r2
  bool v28; // zf
  int v29; // r3
  unsigned __int64 v30; // d16
  _QWORD *v31; // r2
  int v32; // t1
  __int16 v33; // r11
  __int16 v34; // r9
  char *v35; // r2
  char *v36; // r2
  char v37; // [sp+18h] [bp-824h]
  int v38; // [sp+1Ch] [bp-820h]
  int v39; // [sp+20h] [bp-81Ch]
  unsigned int v40; // [sp+24h] [bp-818h]
  int v41; // [sp+28h] [bp-814h]
  char nptr[12]; // [sp+2Ch] [bp-810h] BYREF
  char s[2052]; // [sp+38h] [bp-804h] BYREF

  v40 = 0;
  v39 = 1;
  v41 = 0;
  while ( 1 )
  {
    v0 = 0;
    sub_3C69C();
    v38 = 0;
    while ( 1 )
    {
LABEL_3:
      sub_2B21C();
      pthread_mutex_lock(&stru_6315C);
      v1 = dword_64334;
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "%s: reg_value_num = %d", "bitmain_scanreg", dword_64334);
        sub_38438(7, s, 0);
      }
      pthread_mutex_unlock(&stru_6315C);
      if ( v1 > 0x35F || (unsigned int)dword_64330 > 0x35F )
        break;
      if ( v1 )
      {
        v2 = 0;
        while ( 1 )
        {
          pthread_mutex_lock(&stru_6315C);
          v6 = dword_64330 + 1;
          v7 = &dword_6432C[2 * dword_64330 + 2];
          v8 = sub_3B360((_BYTE *)v7 + 6, 51);
          v9 = *((unsigned __int8 *)v7 + 10);
          v10 = v7[3] & 0x1F;
          v11 = *((unsigned __int8 *)v7 + 11);
          v12 = *((unsigned __int8 *)v7 + 13);
          if ( v8 != v10 )
          {
            if ( (byte_632F0 || byte_630C0 || dword_60964 > 2)
              && ((snprintf(
                     s,
                     0x800u,
                     "%s,crc5 error,should be %02x,but check as %02x %d %d",
                     "bitmain_scanreg",
                     v10,
                     v8,
                     v2,
                     v1),
                   sub_38438(3, s, 0),
                   byte_632F0)
               || byte_630C0
               || dword_60964 > 2) )
            {
              snprintf(
                s,
                0x800u,
                "%s: reg_value = 0x%02x%02x%02x%02x",
                "bitmain_scanreg",
                (unsigned __int8)v41,
                BYTE1(v41),
                BYTE2(v41),
                HIBYTE(v41));
              sub_38438(3, s, 0);
              v6 = dword_64330 + 1;
            }
            else
            {
              v6 = dword_64330 + 1;
            }
          }
          v41 = *(int *)((char *)&dword_6432C[2 * v6 + 1] + 2);
          pthread_mutex_unlock(&stru_6315C);
          if ( !v11 )
            break;
          if ( v11 == 64 )
          {
            v13 = (unsigned __int8 *)&dword_6432C[2 * dword_64330 + 2];
            v9 = v13[10];
            v11 = v13[11];
            v12 = v13[13];
          }
          switch ( v11 )
          {
            case 8:
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf(
                  s,
                  0x800u,
                  "%s: reg_value = 0x%02x0x%02x0x%02x0x%02x",
                  "bitmain_scanreg",
                  (unsigned __int8)v41,
                  BYTE1(v41),
                  BYTE2(v41),
                  HIBYTE(v41));
                sub_38438(7, s, 0);
              }
              break;
            case 24:
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf(
                  s,
                  0x800u,
                  "Dump MISC Data:[%X][%X][%X][%X]@Chain[%d] -- Chip[%X]",
                  (unsigned __int8)v41,
                  BYTE1(v41),
                  BYTE2(v41),
                  HIBYTE(v41),
                  v12,
                  v9);
                sub_38438(7, s, 0);
              }
              break;
            case 28:
              if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
              {
                v14 = v41;
                v15 = BYTE2(v41);
                v37 = HIBYTE(v41);
                snprintf(s, 0x800u, aDumpIicDataXXX, (unsigned __int8)v41, BYTE1(v41), BYTE2(v41), HIBYTE(v41), v12, v9);
                sub_38438(5, s, 0);
                v16 = v37;
              }
              else
              {
                v14 = v41;
                v15 = BYTE2(v41);
                v16 = HIBYTE(v41);
              }
              if ( v15 != 17 && (v14 & 0xC0) == 0 )
              {
                switch ( v9 )
                {
                  case 105:
                    v23 = &byte_630C8[24 * v12];
                    if ( *((_DWORD *)v23 + 48) == 4 )
                    {
                      v23[196] = v16;
                      *((_DWORD *)v23 + 48) = 1;
                    }
                    break;
                  case 201:
                    v24 = &byte_630C8[24 * v12];
                    if ( *((_DWORD *)v24 + 46) == 4 )
                    {
                      v24[188] = v16;
                      *((_DWORD *)v24 + 46) = 1;
                    }
                    break;
                  case 12:
                    v17 = &byte_630C8[24 * v12];
                    if ( *((_DWORD *)v17 + 44) == 4 )
                    {
                      v17[180] = v16;
                      *((_DWORD *)v17 + 44) = 1;
                    }
                    break;
                }
              }
              break;
            case 4:
              for ( i = 0; i != 4; ++i )
              {
                v26 = &nptr[2 * i];
                v27 = (unsigned __int8)nptr[i - 4];
                sprintf(v26, "%02x", v27);
              }
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf(s, 0x800u, "%s: hashrate is %s", "bitmain_scanreg", nptr);
                sub_38438(7, s, 0);
              }
              ++v38;
              v0 += vshld_n_s64(vshrd_n_s64(vdup_n_s32(strtol(nptr, 0, 16)).n64_i64[0], 0x20u), 8u);
              if ( v38 == 72 )
              {
                qword_63100[v12] = v0;
                sub_3AA38(v0, &byte_65E6C[16 * v12], 5, 0);
                v28 = byte_630C1 == 0;
                *(_DWORD *)&byte_630C8[4 * v12 + 272] = 0;
                if ( !v28 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
                {
                  snprintf(s, 0x800u, "%s: chain %d hashrate is %s", "bitmain_scanreg", v12, &byte_65E6C[16 * v12]);
                  sub_38438(7, s, 0);
                }
                v29 = 805859;
                v30 = 0;
                v31 = qword_63100;
                do
                {
                  v32 = *(unsigned __int8 *)++v29;
                  if ( v32 == 1 )
                    v30 += *v31;
                  ++v31;
                }
                while ( v29 != 805863 );
                v0 = 0;
                v38 = 0;
                sub_3AA38(v30, byte_62E38, 5, 0);
              }
              break;
            case 68:
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                v33 = BYTE1(v41);
                v34 = HIBYTE(v41);
                snprintf(
                  s,
                  0x800u,
                  "TEMP DATA @ Chain[%d]:local[%d] remote[%d] On Chip[%X]",
                  v12,
                  BYTE1(v41),
                  HIBYTE(v41),
                  v9);
                sub_38438(7, s, 0);
                if ( v9 == 105 )
                  goto LABEL_132;
              }
              else
              {
                v33 = BYTE1(v41);
                v34 = HIBYTE(v41);
                if ( v9 == 105 )
                {
LABEL_132:
                  v35 = (char *)&unk_C4BCC + 64 * v12;
                  *((_WORD *)v35 + 152) = v33;
                  *((_WORD *)v35 + 153) = v34;
                  break;
                }
              }
              if ( v9 == 201 )
              {
                v36 = (char *)&unk_C4BCC + 64 * v12;
                *((_WORD *)v36 + 156) = v33;
                *((_WORD *)v36 + 157) = v34;
              }
              else if ( v9 == 12 )
              {
                *((_WORD *)&unk_C4BCC + 32 * v12 + 160) = v33;
                *((_WORD *)&unk_C4BCC + 32 * v12 + 161) = v34;
              }
              break;
            default:
              if ( v11 )
                break;
              goto LABEL_23;
          }
LABEL_32:
          if ( byte_630D8 )
          {
            ++*(_DWORD *)&byte_630C8[4 * v12 + 272];
LABEL_34:
            qword_63100[v12] = 0;
            sub_3AA38(0, &byte_65E6C[16 * v12], 3, 1);
            goto LABEL_35;
          }
          if ( !v38 )
          {
            if ( byte_631E8 )
            {
              v18 = &byte_630C8[4 * v12];
              v19 = *((_DWORD *)v18 + 68) + 1;
              *((_DWORD *)v18 + 68) = v19;
              if ( v19 > 3 )
                goto LABEL_34;
            }
          }
LABEL_35:
          ++v2;
          ++dword_64330;
          --dword_64334;
          if ( (unsigned int)dword_64330 >= 0x360 )
            dword_64330 = 0;
          if ( v2 == v1 )
            goto LABEL_3;
        }
        if ( byte_63174 )
        {
          if ( v39 )
            *((_BYTE *)&unk_C4BCC + v12 + 2198) = 0;
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(
              s,
              0x800u,
              "%s: reg_value = 0x%02x0x%02x0x%02x0x%02x",
              "bitmain_scanreg",
              (unsigned __int8)v41,
              BYTE1(v41),
              BYTE2(v41),
              HIBYTE(v41));
            sub_38438(7, s, 0);
          }
          v3 = (unsigned __int8)(*((_BYTE *)&unk_C4BCC + v12 + 2198) + 1);
          *((_BYTE *)&unk_C4BCC + v12 + 2198) = v3;
          if ( v3 > 0x48 )
            *((_BYTE *)&unk_C4BCC + v12 + 2198) = 1;
          v39 = 0;
        }
LABEL_23:
        v4 = *((unsigned __int8 *)&unk_C4BCC + v12 + 2198);
        if ( v4 == 72 )
        {
          v5 = (unsigned __int8)byte_630C1;
          if ( byte_630C1 )
          {
            if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
            {
              snprintf(s, 0x800u, "chian %d get asicnum %d", v12, 72);
              sub_38438(7, s, 0);
              v4 = *((unsigned __int8 *)&unk_C4BCC + v12 + 2198);
              v5 = (unsigned __int8)byte_630C1;
            }
            else
            {
              v5 = 1;
            }
          }
        }
        else
        {
          v5 = (unsigned __int8)byte_630C1;
        }
        if ( (unsigned __int8)byte_C548D < v4 )
          byte_C548D = v4;
        if ( v5 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "%s: chain J%d has %d ASIC", "bitmain_scanreg", v12 + 1, v4);
          sub_38438(7, s, 0);
        }
        goto LABEL_32;
      }
      if ( byte_630D8 )
      {
        v20 = &byte_630F8;
        do
        {
          v21 = &byte_65E6C[16 * v1++];
          *((_QWORD *)v20 + 1) = 0;
          v20 += 8;
          sub_3AA38(0, v21, 3, 1);
        }
        while ( v1 != 4 );
      }
      v22 = v40 + 1;
      if ( v40 > 3 )
      {
        sub_3C69C();
        v22 = 0;
        byte_631E8 = 0;
      }
      v40 = v22;
      sub_2B21C();
    }
    if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
    {
      strcpy(s, "reg fifo is full !!");
      sub_38438(4, s, 0);
    }
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630D8: using guessed type char byte_630D8;
// 630F8: using guessed type char byte_630F8;
// 63100: using guessed type _QWORD qword_63100[4];
// 63174: using guessed type char byte_63174;
// 631E8: using guessed type char byte_631E8;
// 632F0: using guessed type char byte_632F0;
// 6432C: using guessed type int dword_6432C[];
// 64330: using guessed type int dword_64330;
// 64334: using guessed type int dword_64334;
// C548D: using guessed type char byte_C548D;

//----- (0003D2F4) --------------------------------------------------------
void __fastcall __noreturn sub_3D2F4(unsigned __int8 *a1)
{
  pthread_t v2; // r0
  int v3; // r9
  int v4; // r8
  int v5; // r5
  int v6; // r1
  unsigned int v7; // r2
  int v8; // r12
  int *v9; // r3
  char v10; // lr
  int v11; // r3
  bool v12; // cc
  int v13; // r3
  int *v14; // r0
  int v15; // r2
  int *v16; // r1
  int *v17; // r3
  unsigned __int8 v18; // r12
  int v19; // r3
  bool v20; // cf
  unsigned __int8 v21; // [sp+20h] [bp-844h]
  int v22; // [sp+30h] [bp-834h]
  char v23; // [sp+3Ch] [bp-828h]
  char v24; // [sp+3Ch] [bp-828h]
  char v25; // [sp+48h] [bp-81Ch]
  int v26; // [sp+54h] [bp-810h] BYREF
  int *v27; // [sp+58h] [bp-80Ch] BYREF
  __int16 v28; // [sp+5Ch] [bp-808h]
  unsigned __int8 v29; // [sp+5Eh] [bp-806h]
  char s[2052]; // [sp+60h] [bp-804h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *a1;
  v22 = a1[4];
  tcflush(v3, 2);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    snprintf(s, 0x800u, "Start A New Asic Response.Chain Id:[%d]", v22);
    sub_38438(5, s, 0);
  }
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "%s %d", "get_asic_response", v22);
    sub_38438(7, s, 0);
  }
  while ( 1 )
  {
    while ( ioctl(v3, 0x541Bu, &v26) )
    {
      perror("ioctl error");
      sub_2B21C();
    }
    v4 = v26 / 7;
    if ( (int)((unsigned __int64)(2454267027LL * v26) >> 32) >> 2 != v26 >> 31 )
      break;
LABEL_51:
    sub_2B21C();
  }
  v5 = 0;
  while ( 1 )
  {
    v27 = 0;
    v28 = 0;
    v29 = 0;
    sub_3C604(v3, &v27, 7u);
    if ( !byte_630C1 )
      goto LABEL_28;
    if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      goto LABEL_26;
    snprintf(s, 0x800u, "Chain [%d] Read Data", v22);
    sub_38438(7, s, 0);
    if ( byte_630C1 )
      break;
LABEL_28:
    if ( (v29 & 0x80u) == 0 )
    {
      if ( (unsigned int)dword_64334 <= 0x35F && dword_6432C[0] <= 0x35Fu )
      {
        pthread_mutex_lock(&stru_6315C);
        v14 = v27;
        v15 = dword_6432C[0];
        v16 = (int *)(dword_6432C[0] + 1);
        v24 = v28;
        v25 = HIBYTE(v28);
        v12 = dword_6432C[0] > 0x35Eu;
        v17 = &dword_6432C[2 * dword_6432C[0] + 2];
        v18 = v29;
        *(int *)((char *)v17 + 6) = (int)v27;
        *((_BYTE *)v17 + 13) = v22;
        *((_BYTE *)v17 + 12) = v18;
        *((_BYTE *)v17 + 10) = v24;
        *((_BYTE *)v17 + 11) = v25;
        if ( v12 )
        {
          dword_6432C[0] = 0;
        }
        else
        {
          if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
          {
            snprintf(s, 0x800u, "%s: p_wr = %d reg_value_num = %d", "get_asic_response", v15, dword_64334);
            sub_38438(7, s, 0);
            v16 = (int *)(dword_6432C[0] + 1);
          }
          dword_6432C[0] = (int)v16;
        }
        v19 = dword_64334;
        v20 = (unsigned int)dword_64334 >= 0x360;
        if ( (unsigned int)dword_64334 >= 0x360 )
        {
          v16 = dword_6432C;
        }
        else
        {
          v19 = dword_64334 + 1;
          v14 = dword_6432C;
        }
        if ( (unsigned int)dword_64334 >= 0x360 )
          v19 = 864;
        else
          v14[2] = v19;
        if ( v20 )
          v16[2] = v19;
        pthread_mutex_unlock(&stru_6315C);
      }
      else
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          strcpy(s, "Will Clean!");
          sub_38438(7, s, 0);
        }
        sub_3C69C();
      }
      goto LABEL_21;
    }
    if ( byte_630F8 )
    {
      pthread_mutex_lock(&stru_630DC);
      v6 = (unsigned __int8)byte_630C1;
      v7 = dword_C30B8[0];
      v23 = v28;
      v8 = dword_C30B8[0] + 1;
      v9 = &dword_C30B8[2 * dword_C30B8[0] + 2];
      v10 = HIBYTE(v28);
      *(int *)((char *)v9 + 6) = (int)v27;
      v21 = v29;
      *((_BYTE *)v9 + 13) = v22;
      *((_BYTE *)v9 + 10) = v23;
      *((_BYTE *)v9 + 11) = v10;
      *((_BYTE *)v9 + 12) = v21;
      if ( v6 )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 6 )
        {
          snprintf(
            s,
            0x800u,
            "get nonce %02x%02x%02x%02x wc %02x diff %02x crc5 %02x chainid %02x",
            BYTE2(dword_C30B8[2 * v8 + 1]),
            HIBYTE(dword_C30B8[2 * v7 + 3]),
            LOBYTE(dword_C30B8[2 * v7 + 4]),
            BYTE1(dword_C30B8[2 * v7 + 4]),
            BYTE2(dword_C30B8[2 * v8 + 2]),
            HIBYTE(dword_C30B8[2 * v8 + 2]),
            LOBYTE(dword_C30B8[2 * v8 + 3]),
            v22);
          sub_38438(7, s, 0);
          v6 = (unsigned __int8)byte_630C1;
          v7 = dword_C30B8[0];
        }
        else
        {
          v6 = 1;
        }
      }
      v11 = 862;
      v12 = v7 > 0x35E;
      if ( v7 > 0x35E )
        v11 = 0;
      else
        ++v7;
      if ( v12 )
        dword_C30B8[0] = v11;
      else
        dword_C30B8[0] = v7;
      if ( (unsigned int)dword_C30C0 >= 0x360 )
        v13 = 864;
      else
        v13 = dword_C30C0 + 1;
      dword_C30C0 = v13;
      if ( v6 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "get nonce num %d", dword_C30C0);
        sub_38438(7, s, 0);
      }
      ++v5;
      pthread_mutex_unlock(&stru_630DC);
      if ( v4 == v5 )
        goto LABEL_51;
    }
    else
    {
LABEL_21:
      if ( v4 == ++v5 )
        goto LABEL_51;
    }
  }
  if ( !byte_632F0 && !byte_630C0 )
  {
LABEL_26:
    if ( dword_60964 <= 6 )
      goto LABEL_28;
  }
  snprintf(
    s,
    0x800u,
    "get sth %02x%02x%02x%02x%02x%02x%02x",
    (unsigned __int8)v27,
    BYTE1(v27),
    BYTE2(v27),
    HIBYTE(v27),
    (unsigned __int8)v28,
    HIBYTE(v28),
    v29);
  sub_38438(7, s, 0);
  goto LABEL_28;
}
// 3D8AC: variable 'v14' is possibly undefined
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630F8: using guessed type char byte_630F8;
// 632F0: using guessed type char byte_632F0;
// 6432C: using guessed type int dword_6432C[];
// 64334: using guessed type int dword_64334;
// C30B8: using guessed type int dword_C30B8[];
// C30C0: using guessed type int dword_C30C0;

//----- (0003D9A4) --------------------------------------------------------
int __fastcall sub_3D9A4(int a1)
{
  char s[100]; // [sp+4h] [bp-64h] BYREF

  byte_60DEA ^= 1u;
  if ( a1 )
  {
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", 0, 23);
    system(s);
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)byte_60DEA, 45);
  }
  else
  {
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", 0, 45);
    system(s);
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)byte_60DEA, 23);
  }
  return system(s);
}
// 60DEA: using guessed type char byte_60DEA;

//----- (0003DA40) --------------------------------------------------------
int __fastcall sub_3DA40(int a1)
{
  int v1; // r2
  char v3[2052]; // [sp+0h] [bp-804h] BYREF

  if ( a1 > 19 )
  {
    if ( a1 > 100 )
      v1 = 34464;
    else
      v1 = 1000;
    if ( a1 > 100 )
    {
      HIWORD(v1) = 1;
      LOBYTE(a1) = 100;
    }
    else
    {
      v1 *= a1;
    }
  }
  else
  {
    LOBYTE(a1) = 20;
    v1 = 20000;
  }
  dword_C4BD0 = v1;
  byte_C5467 = a1;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v3, 0x800u, "set pwm duty_ns %d", v1);
    sub_38438(7, v3, 0);
    v1 = dword_C4BD0;
  }
  sprintf(v3, "echo %u > /sys/class/pwm/pwm1/duty_ns", v1);
  return system(v3);
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// C4BD0: using guessed type int dword_C4BD0;
// C5467: using guessed type char byte_C5467;

//----- (0003DB30) --------------------------------------------------------
void sub_3DB30()
{
  _BOOL4 v0; // r2
  int v1; // r3
  int v2; // r6
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  dword_631EC = dword_C5473[0];
  if ( dword_C5473[0] > 74 && byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "%s: Temperature is higher than %d 'C", "set_PWM_according_to_temperature", dword_C5473[0]);
    sub_38438(7, s, 0);
  }
  if ( byte_C5490 && (unsigned __int8)byte_C5491 <= 0x64u )
  {
    sub_3DA40((unsigned __int8)byte_C5491);
    return;
  }
  v0 = dword_631EC > 74;
  if ( !dword_631EC )
    v0 = 1;
  if ( v0 )
  {
    sub_3DA40(100);
    byte_C5491 = 100;
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return;
    snprintf(s, 0x800u, "%s: Set PWM percent : MAX_PWM_PERCENT", "set_PWM_according_to_temperature");
LABEL_25:
    sub_38438(7, s, 0);
    return;
  }
  if ( dword_631EC <= 35 )
  {
    sub_3DA40(20);
    byte_C5491 = 20;
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return;
    snprintf(s, 0x800u, "%s: Set PWM percent : MIN_PWM_PERCENT", "set_PWM_according_to_temperature");
    goto LABEL_25;
  }
  if ( (unsigned int)(dword_631EC - dword_631F0 + 1) > 2 )
  {
    v1 = 2 * (dword_631EC - 25);
    v2 = (unsigned __int8)v1;
    byte_C5491 = 2 * (dword_631EC - 25);
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "%s: Set PWM percent : %d", "set_PWM_according_to_temperature", v1);
      sub_38438(7, s, 0);
    }
    sub_3DA40(v2);
    dword_631F0 = dword_631EC;
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 631EC: using guessed type int dword_631EC;
// 631F0: using guessed type int dword_631F0;
// 632F0: using guessed type char byte_632F0;
// C5473: using guessed type int dword_C5473[6];
// C5490: using guessed type char byte_C5490;
// C5491: using guessed type char byte_C5491;

//----- (0003DDB8) --------------------------------------------------------
int __fastcall sub_3DDB8(char a1)
{
  char v2; // [sp+0h] [bp-8h] BYREF
  _BYTE v3[3]; // [sp+1h] [bp-7h] BYREF
  char buf; // [sp+4h] [bp-4h] BYREF
  char v5[3]; // [sp+5h] [bp-3h] BYREF

  v3[0] = a1;
  buf = 85;
  v2 = 21;
  v5[0] = -86;
  write(dword_C54A6, &buf, 1u);
  sub_2B244();
  write(dword_C54A6, v5, 1u);
  sub_2B244();
  write(dword_C54A6, &v2, 1u);
  sub_2B244();
  write(dword_C54A6, v3, 1u);
  return sub_2B244();
}
// C54A6: using guessed type int dword_C54A6;

//----- (0003DE5C) --------------------------------------------------------
void __noreturn sub_3DE5C()
{
  int v0; // r3
  int v1; // r5
  int v2; // r7
  int v3; // r9
  int v5; // r4
  char *v6; // r6
  int v7; // r12
  int v8; // t1
  unsigned int v9; // r3
  int v11; // r4
  int v12; // r4
  int v13; // r6
  int v14; // r4
  char *v15; // r7
  char *v16; // r5
  int v17; // r12
  int v18; // r12
  int v19; // r2
  int v20; // r1
  int v21; // r4
  int v22; // r0
  int v23; // r5
  int v24; // r6
  int v25; // r4
  int v26; // t1
  const char *v27; // r2
  int v28; // r12
  int v29; // r3
  int v30; // [sp+4h] [bp-858h]
  int v31; // [sp+2Ch] [bp-830h]
  int v32; // [sp+30h] [bp-82Ch]
  unsigned int v33; // [sp+30h] [bp-82Ch]
  int i; // [sp+34h] [bp-828h]
  int v35; // [sp+38h] [bp-824h]
  int v36; // [sp+3Ch] [bp-820h]
  int v37; // [sp+40h] [bp-81Ch] BYREF
  int v38; // [sp+44h] [bp-818h]
  struct timeval v39; // [sp+48h] [bp-814h] BYREF
  struct timeval v40; // [sp+50h] [bp-80Ch] BYREF
  char s[2052]; // [sp+58h] [bp-804h] BYREF

  v37 = 0;
  v36 = 0;
  v38 = 0;
  sub_2B13C(&v39);
  sub_2B13C(&v40);
  sub_2AE20(&v37, &v39);
  sub_2AE20(&dword_63154, &v40);
  while ( 1 )
  {
    sub_2B13C(&v39);
    sub_2B13C(&v40);
    v0 = v39.tv_sec - v37;
    if ( v39.tv_usec - v38 < 0 )
      --v0;
    if ( v0 > 600 )
    {
      v1 = 0;
      v2 = 0;
      v32 = 0;
      v3 = 805859;
      v31 = 805859;
      do
      {
        if ( *(unsigned __int8 *)++v3 )
        {
          v32 += *(unsigned __int8 *)(v3 + 2174);
          if ( *(_BYTE *)(v3 + 2174) )
          {
            v5 = 0;
            v6 = (char *)&unk_C4BCC + 288 * v2 + 644;
            do
            {
              v8 = *((_DWORD *)v6 + 1);
              v6 += 4;
              v7 = v8;
              v1 += v8;
              if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
              {
                snprintf(s, 0x800u, "%s: chain %d asic %d asic_nonce_num %d", "check_miner_status", v2, v5, v7);
                sub_38438(7, s, 0);
              }
              ++v5;
            }
            while ( *(unsigned __int8 *)(v3 + 2174) > v5 );
          }
        }
        ++v2;
      }
      while ( v2 != 4 );
      if ( v32 )
      {
        v9 = (unsigned __int8)byte_630C1;
        if ( byte_630C1 && (byte_632F0 || (v9 = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 6) )
        {
          v30 = v32;
          v33 = 0;
          snprintf(s, 0x800u, "%s: avg_num %d asic_num %d", "check_miner_status", v1, v30);
          sub_38438(7, s, 0);
        }
        else
        {
          v33 = v9;
        }
      }
      else
      {
        v33 = 1;
      }
      for ( i = 0; i != 4; ++i )
      {
        v11 = v31 + 1;
        if ( *(unsigned __int8 *)++v31 )
        {
          v12 = *(unsigned __int8 *)(v11 + 2174);
          if ( v12 )
          {
            v13 = 0;
            v14 = 0;
            v15 = (char *)&unk_C4BCC + 88 * i;
            v16 = (char *)&unk_C4BCC + 288 * i + 644;
            do
            {
              if ( (v14 & 7) == 0 )
              {
                v18 = v14 + v13;
                if ( v14 + v13 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
                {
                  snprintf(s, 0x800u, "asic num err![%d]", v14 + v13);
                  sub_38438(3, s, 0);
                  v18 = v14 + v13;
                }
                ++v13;
                v15[v18 + 1800] = 32;
              }
              v17 = v14 + v13;
              if ( *((_DWORD *)v16 + 1) > v33 )
              {
                if ( v17 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
                {
                  snprintf(s, 0x800u, "asic num err![%d]", v14 + v13);
                  sub_38438(3, s, 0);
                  v17 = v14 + v13;
                }
                v15[v17 + 1800] = 111;
              }
              else
              {
                if ( v17 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
                {
                  snprintf(s, 0x800u, "asic num err![%d]", v14 + v13);
                  sub_38438(3, s, 0);
                  v17 = v14 + v13;
                }
                v15[v17 + 1800] = 120;
              }
              if ( v14 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
              {
                snprintf(s, 0x800u, "asic num err![%d]", v14);
                sub_38438(3, s, 0);
              }
              ++v14;
              *((_DWORD *)v16 + 1) = 0;
              v16 += 4;
            }
            while ( *(unsigned __int8 *)(v31 + 2174) > v14 );
            v12 = v13 + v14;
            if ( v12 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
            {
              snprintf(s, 0x800u, "asic num err![%d]", v12);
              sub_38438(3, s, 0);
            }
          }
          *((_BYTE *)&unk_C4BCC + 88 * i + v12 + 1800) = 0;
        }
      }
      if ( dbl_63268 / dbl_5F898 < (double)((unsigned __int8)byte_C548B
                                          * (unsigned __int16)word_C5492
                                          * 72
                                          * (unsigned __int8)byte_C5468)
                                 * 0.95
                                 / 2500.0
                                 * 0.8
        && !byte_630D8 )
      {
        system("echo \"Rate too low, reboot!!\" >> /usr/bin/already_reboot");
      }
      sub_2AE20(&v37, &v39);
    }
    sub_3DB30();
    v19 = v40.tv_sec - dword_63154;
    if ( v40.tv_usec - dword_63158 < 0 )
      --v19;
    if ( !byte_C5469 )
    {
      v20 = 1;
      goto LABEL_94;
    }
    if ( dword_C546B < (unsigned int)((unsigned __int64)(9092115387700LL * (unsigned __int8)byte_C5491) >> 32) >> 6 )
    {
      v20 = 2;
      goto LABEL_94;
    }
    if ( dword_C546F < (unsigned int)((unsigned __int64)(7612003580400LL * (unsigned __int8)byte_C5491) >> 32) >> 6 )
      break;
    if ( byte_C5467 == 100 && ((unsigned int)dword_C546B <= 0xF1D || (unsigned int)dword_C546F <= 0xCA7) )
    {
      v20 = 4;
LABEL_94:
      if ( ++dword_631F8 <= 10 )
        goto LABEL_72;
      goto LABEL_71;
    }
    v20 = 0;
    dword_631F8 = 0;
LABEL_71:
    v35 = v20;
LABEL_72:
    if ( v19 > 120 || dword_C5473[0] > 0x55u || (v21 = v35) != 0 )
    {
      byte_630D8 = 1;
      if ( byte_631F4 || dword_C5473[0] <= 0x55u && !v35 )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          strcpy(s, "Net Err! lastest job more than 2 mins! waiting ...");
          sub_38438(3, s, 0);
          v22 = 1;
        }
        else
        {
          v22 = 1;
        }
      }
      else
      {
        v23 = 805859;
        v24 = v36;
        v25 = 0;
        byte_631F4 = 1;
        do
        {
          v26 = *(unsigned __int8 *)++v23;
          if ( v26 == 1 )
          {
            pthread_mutex_lock(&stru_63120);
            if ( ioctl(dword_C54A6, 0x703u, *(int *)((char *)&unk_557AC + v25) >> 1) < 0
              && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
            {
              snprintf(s, 0x800u, "ioctl error @ line %d", 1032);
              sub_38438(3, s, 0);
            }
            if ( !v24 )
            {
              if ( dword_C5473[0] > 0x55u && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
              {
                strcpy(s, "Temp Err! Disable PIC!");
                sub_38438(3, s, 0);
              }
              switch ( v35 )
              {
                case 1:
                  if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
                    goto LABEL_105;
                  v24 = 1;
                  snprintf(s, 0x800u, "Fan Err! Disable PIC! Fan num is %d", (unsigned __int8)byte_C5469);
                  sub_38438(3, s, 0);
                  break;
                case 2:
                  if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
                    goto LABEL_105;
                  v27 = "Fan Err! Disable PIC! Fan1 speed is too low %d pwm %d ";
                  v28 = (unsigned __int8)byte_C5467;
                  goto LABEL_111;
                case 3:
                  if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
                    goto LABEL_105;
                  v27 = "Fan Err! Disable PIC! Fan2 speed is too low %d pwm %d ";
                  v28 = (unsigned __int8)byte_C5467;
                  v29 = dword_C546F;
                  goto LABEL_112;
                case 4:
                  if ( !byte_632F0 && !byte_630C0 && dword_60964 <= 2 )
                    goto LABEL_105;
                  v27 = "Fan Err! Disable PIC! MAX:%d MIN:%d";
                  v28 = dword_C546F;
LABEL_111:
                  v29 = dword_C546B;
LABEL_112:
                  v24 = 1;
                  snprintf(s, 0x800u, v27, v29, v28);
                  sub_38438(3, s, 0);
                  break;
                default:
LABEL_105:
                  v24 = 1;
                  break;
              }
            }
            sub_3DDB8(0);
            pthread_mutex_unlock(&stru_63120);
          }
          v25 += 4;
        }
        while ( v25 != 16 );
        v36 = v24;
        v22 = 1;
      }
    }
    else
    {
      v22 = (int)byte_630C8;
      if ( byte_631F4 )
        v22 = 0;
      else
        v21 = 0;
      if ( !byte_631F4 )
      {
        v22 = v21;
        byte_630D8 = v21;
      }
    }
    sub_3D9A4(v22);
    sub_2B21C();
  }
  v20 = 3;
  goto LABEL_94;
}
// 3E6B8: control flows out of bounds to 3E6BC
// 3E4AC: variable 'v35' is possibly undefined
// 5F898: using guessed type double dbl_5F898;
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 630D8: using guessed type char byte_630D8;
// 63154: using guessed type int dword_63154;
// 63158: using guessed type int dword_63158;
// 631F4: using guessed type char byte_631F4;
// 631F8: using guessed type int dword_631F8;
// 63268: using guessed type double dbl_63268;
// 632F0: using guessed type char byte_632F0;
// C5467: using guessed type char byte_C5467;
// C5468: using guessed type char byte_C5468;
// C5469: using guessed type char byte_C5469;
// C546B: using guessed type int dword_C546B;
// C546F: using guessed type int dword_C546F;
// C5473: using guessed type int dword_C5473[6];
// C548B: using guessed type char byte_C548B;
// C5491: using guessed type char byte_C5491;
// C5492: using guessed type __int16 word_C5492;
// C54A6: using guessed type int dword_C54A6;

//----- (0003E8FC) --------------------------------------------------------
void sub_3E8FC()
{
  unsigned int v0; // r6
  FILE *v1; // r0
  FILE *v2; // r8
  unsigned int v3; // r7
  unsigned int v4; // r9
  unsigned int v5; // r0
  unsigned int v6; // r12
  unsigned int v7; // r7
  int v8; // r7
  unsigned int v9; // s15
  unsigned int v10; // r0
  unsigned int v11; // r12
  unsigned int v12; // r6
  int v13; // r6
  unsigned int v14; // s15
  bool v15; // cc
  unsigned int v16; // [sp+0h] [bp-90Ch]
  unsigned int v17; // [sp+0h] [bp-90Ch]
  unsigned int v18; // [sp+4h] [bp-908h]
  char haystack[4]; // [sp+8h] [bp-904h] BYREF
  _BYTE s[252]; // [sp+Ch] [bp-900h] BYREF
  char v21[2052]; // [sp+108h] [bp-804h] BYREF

  v0 = 0;
  *(_DWORD *)haystack = 0;
  memset(s, 0, sizeof(s));
  v1 = fopen("/proc/interrupts", "r");
  v2 = v1;
  if ( !v1 )
  {
    while ( 1 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
      {
        strcpy(v21, "open /proc/interrupt error");
        sub_38438(3, v21, 0);
      }
      sleep(3u);
    }
  }
  fseek(v1, 0, 0);
  v3 = 0;
  while ( fgets(haystack, 256, v2) )
  {
    if ( strstr(haystack, "256:") && strstr(haystack, "gpiolib") )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy(v21, "find fan1.");
        sub_38438(7, v21, 0);
      }
      v3 = sub_3A73C(haystack);
    }
    if ( strstr(haystack, "254:") && strstr(haystack, "gpiolib") )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        strcpy(v21, "find fan2.");
        sub_38438(7, v21, 0);
      }
      v0 = sub_3A73C(haystack);
    }
  }
  sub_2B21C();
  v4 = 0;
  v18 = 0;
  while ( 1 )
  {
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(v21, 0x800u, "test_loop = %d", 0);
      sub_38438(7, v21, 0);
    }
    fseek(v2, 0, 0);
    while ( fgets(haystack, 256, v2) )
    {
      if ( strstr(haystack, "256:") && strstr(haystack, "gpiolib") )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          strcpy(v21, "find fan1");
          sub_38438(7, v21, 0);
        }
        v5 = sub_3A73C(haystack);
        v6 = v5;
        if ( v3 > v5 )
          v7 = v5 + ~v3;
        else
          v7 = v5 - v3;
        v8 = 60 * v7;
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v16 = v5;
          snprintf(v21, 0x800u, "fan1Speed = %d", v8);
          sub_38438(7, v21, 0);
          v6 = v16;
        }
        v9 = v8;
        v3 = v6;
        if ( (double)v9 > 3655.0 )
          ++v18;
      }
      if ( strstr(haystack, "254:") && strstr(haystack, "gpiolib") )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          strcpy(v21, "find fan2");
          sub_38438(7, v21, 0);
        }
        v10 = sub_3A73C(haystack);
        v11 = v10;
        if ( v0 > v10 )
          v12 = v10 + ~v0;
        else
          v12 = v10 - v0;
        v13 = 60 * v12;
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          v17 = v10;
          snprintf(v21, 0x800u, "fan2Speed = %d", v13);
          sub_38438(7, v21, 0);
          v11 = v17;
        }
        v14 = v13;
        v0 = v11;
        if ( (double)v14 > 3060.0 )
          ++v4;
      }
    }
    v15 = v4 > 2;
    if ( v4 > 2 )
      v15 = v18 > 2;
    if ( v15 )
      break;
    sub_2B21C();
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
  {
    snprintf(v21, 0x800u, "%s OK", "check_fan_speed");
    sub_38438(4, v21, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0003EF84) --------------------------------------------------------
int __fastcall sub_3EF84(char a1, char a2, int a3)
{
  char v3; // r3
  int v4; // r4
  int v5; // r5
  int result; // r0
  _BYTE v8[4]; // [sp+0h] [bp-8h] BYREF
  char v9; // [sp+4h] [bp-4h]

  v8[2] = a1;
  v8[3] = a2;
  v9 = 0;
  if ( a3 )
    v3 = 82;
  else
    v3 = 66;
  v8[0] = v3;
  v8[1] = 4;
  v4 = 805859;
  v5 = 805836;
  v9 = sub_3B360(v8, 32);
  do
  {
    if ( *(unsigned __int8 *)++v4 )
      sub_3BBBC(*(_DWORD *)(v5 + 8), v8, 5u);
    v5 += 4;
    result = sub_2B21C();
  }
  while ( v4 != 805863 );
  return result;
}

//----- (0003F014) --------------------------------------------------------
int __fastcall sub_3F014(int a1)
{
  int v1; // r4
  char *v2; // r7
  char v3; // r6
  int v4; // r2
  int v5; // r3
  int v6; // r5
  int v7; // r12
  int v8; // t1

  v1 = 4;
  v2 = (char *)&unk_63178 + 8 * a1;
  v3 = aBitmainL3Detec_0[a1 + 1604];
  while ( 1 )
  {
    sub_3EF84(v3, 28, 0);
    sub_2B21C();
    v4 = 805863;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *(unsigned __int8 *)++v4;
      if ( v8 == 1 )
      {
        ++v7;
        if ( *(_DWORD *)&v2[v5] == 1 )
          ++v6;
      }
      v5 += 24;
    }
    while ( v5 != 96 );
    if ( v7 == v6 )
      break;
    if ( !--v1 )
      return -1;
  }
  return 0;
}

//----- (0003F0B0) --------------------------------------------------------
void __noreturn sub_3F0B0()
{
  int v0; // r2
  int v1; // r3
  int v2; // r12
  int v3; // t1
  __int16 v4; // r1

  while ( 1 )
  {
    sub_3EF84(12, 68, 0);
    sub_3EF84(201, 68, 0);
    sub_2B21C();
    v0 = 805859;
    v1 = 0;
    v2 = 0;
    do
    {
      v3 = *(unsigned __int8 *)++v0;
      if ( v3 == 1 )
      {
        v4 = *(_WORD *)((char *)&unk_C4BCC + v1 + 320);
        if ( v4 > v2 )
          v2 = (unsigned __int8)v4;
      }
      v1 += 64;
    }
    while ( v1 != 256 );
    dword_C5473[0] = v2;
    sleep(0xAu);
  }
}
// C5473: using guessed type int dword_C5473[6];

//----- (0003F138) --------------------------------------------------------
void __noreturn sub_3F138()
{
  while ( 1 )
  {
    pthread_mutex_lock(&stru_631FC);
    sub_3EF84(0, 4, 1);
    byte_631E8 = 1;
    pthread_mutex_unlock(&stru_631FC);
    sub_2B21C();
  }
}
// 631E8: using guessed type char byte_631E8;

//----- (0003F17C) --------------------------------------------------------
void __fastcall sub_3F17C(int a1)
{
  _DWORD *v1; // r7
  int v3; // r6
  char *v4; // r5
  int i; // r4
  int v6; // t1
  int v7; // r11
  int v8; // r2
  _BYTE buf[4]; // [sp+Ch] [bp-1808h] BYREF
  char v10[2048]; // [sp+10h] [bp-1804h] BYREF
  char s[4080]; // [sp+810h] [bp-1004h] BYREF

  v1 = &unk_55A74;
  v3 = a1;
  v4 = (char *)&unk_C4BCC;
  for ( i = 0; i != 4; ++i )
  {
    v6 = v1[1];
    ++v1;
    sprintf(s, "/sys/class/gpio/gpio%d/value", v6);
    v7 = open(s, 0);
    if ( v7 < 0 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
    {
      snprintf(v10, 0x800u, "%s :open %s failed", "check_chain", s);
      sub_38438(3, v10, 0);
    }
    if ( lseek(v7, 0, 0) < 0 )
      perror(s);
    if ( read(v7, buf, 2u) > 0 && buf[0] == 49 )
    {
      ++*(_BYTE *)(a1 + 61);
      *(_BYTE *)(v3 + 157) = 1;
      v8 = (unsigned __int8)byte_632F0;
      v4[24] = 1;
      ++byte_C5468;
      if ( v8 || byte_630C0 || dword_60964 > 4 )
      {
        snprintf(v10, 0x800u, " detected at %s  chain %d", s, i);
        sub_38438(5, v10, 0);
      }
    }
    else
    {
      *(_BYTE *)(v3 + 157) = 0;
      v4[24] = 0;
    }
    ++v3;
    ++v4;
  }
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    snprintf(v10, 0x800u, "detect total chain num %d", *(unsigned __int8 *)(a1 + 61));
    sub_38438(5, v10, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// C5468: using guessed type char byte_C5468;

//----- (0003F3B8) --------------------------------------------------------
void __fastcall sub_3F3B8(int a1, int a2)
{
  int v4; // r6
  int v5; // r4
  int v6; // r5
  int v7; // r0
  speed_t v8; // r3
  int *v9; // r10
  int v10; // t1
  bool v11; // zf
  int v12; // r10
  speed_t speed; // [sp+Ch] [bp-1848h]
  struct termios termios_p; // [sp+14h] [bp-1840h] BYREF
  char s[2048]; // [sp+50h] [bp-1804h] BYREF
  char file[4100]; // [sp+850h] [bp-1004h] BYREF

  memset(file, 0, 4096);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    snprintf(s, 0x800u, "in %s", "tty_init");
    sub_38438(5, s, 0);
  }
  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( *(_BYTE *)(v6 + 157) == 1 )
    {
      sprintf(file, "/dev/ttyO%d", dword_55AA0[v5]);
      v7 = open(file, 258);
      *(_DWORD *)(a1 + 4 * (v5 + 40) + 1) = v7;
      tcgetattr(v7, &termios_p);
      v8 = sub_3B268(a2);
      if ( !v8 )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Unrecognized baud rate: %d,set default baud", a2);
          sub_38438(4, s, 0);
          v8 = 4098;
        }
        else
        {
          v8 = 4098;
        }
      }
      speed = v8;
      cfsetispeed(&termios_p, v8);
      v9 = (int *)(a1 + 4 * (v5 + 40));
      cfsetospeed(&termios_p, speed);
      termios_p.c_cc[5] = 0;
      v10 = *(int *)((char *)v9 + 1);
      v9 = (int *)((char *)v9 + 1);
      termios_p.c_iflag &= 0xFFFFFA14;
      termios_p.c_lflag &= 0xFFFF7FB4;
      termios_p.c_cflag = termios_p.c_cflag & 0xFFFFF64F | 0x8B0;
      termios_p.c_oflag &= ~1u;
      termios_p.c_cc[6] = 7;
      tcsetattr(v10, 0, &termios_p);
      tcflush(*v9, 2);
      v11 = byte_632F0 == 0;
      *(_DWORD *)&byte_65E4C[v4 + 4] = v5;
      *(_BYTE *)(a1 + 156) = v5;
      byte_65E4C[v4] = *v9;
      if ( !v11 || byte_630C0 || dword_60964 > 4 )
      {
        snprintf(s, 0x800u, "%s %d", "tty_init", *(_DWORD *)&byte_65E4C[v4 + 4]);
        sub_38438(5, s, 0);
      }
      if ( pthread_create((pthread_t *)(a1 + 4 * v5 + 727), 0, (void *(*)(void *))sub_3D2F4, &byte_65E4C[8 * v5])
        && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
      {
        snprintf(s, 0x800u, "create rx read thread for %s failed", file);
        sub_38438(3, s, 0);
      }
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "Will Create Pthread @ ChainId[%d]\r", *(unsigned __int8 *)(a1 + 156));
        sub_38438(7, s, 0);
      }
      v12 = pthread_create((pthread_t *)(a1 + 4 * v5 + 711), 0, (void *(*)(void *))sub_3BC80, (void *)a1);
      sub_2B21C();
      if ( v12 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
      {
        snprintf(s, 0x800u, "create tx read thread for %s failed", file);
        sub_38438(3, s, 0);
      }
    }
    ++v5;
    ++v6;
    v4 += 8;
  }
  while ( v5 != 4 );
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(s, "open device over");
    sub_38438(5, s, 0);
  }
  dword_C4BD4 = *(_DWORD *)(a1 + 161);
  dword_C4BD8 = *(_DWORD *)(a1 + 165);
  dword_C4BDC = *(_DWORD *)(a1 + 169);
  dword_C4BE0 = *(_DWORD *)(a1 + 173);
}
// 55AA0: using guessed type _DWORD dword_55AA0[4];
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// 65E4C: using guessed type _BYTE byte_65E4C[32];
// C4BD4: using guessed type int dword_C4BD4;
// C4BD8: using guessed type int dword_C4BD8;
// C4BDC: using guessed type int dword_C4BDC;
// C4BE0: using guessed type int dword_C4BE0;

//----- (0003F864) --------------------------------------------------------
ssize_t __fastcall sub_3F864(int a1, int a2, int a3, int a4, int a5)
{
  char v8; // r3
  int v9; // r2
  _BYTE v11[4]; // [sp+34h] [bp-80Ch] BYREF
  int v12; // [sp+38h] [bp-808h]
  char v13; // [sp+3Ch] [bp-804h]
  char s[2048]; // [sp+40h] [bp-800h] BYREF

  v12 = 0;
  v13 = 0;
  if ( a2 )
    v8 = 81;
  else
    v8 = 65;
  v11[0] = v8;
  v11[2] = a3;
  v11[3] = a4;
  v11[1] = 8;
  if ( a4 == 24 || a4 == 28 || a4 == 32 || a4 == 52 || a4 == 60 || a4 == 20 || a4 == 16 || a4 == 12 || a4 == 8 )
    v12 = a5;
  v9 = sub_3B360(v11, 64);
  v13 = v9;
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(
      s,
      0x800u,
      "Set config reg %02x : %02x%02x%02x%02x%02x%02x%02x%02x%02x",
      a4,
      v11[0],
      8,
      a3,
      a4,
      (unsigned __int8)v12,
      BYTE1(v12),
      BYTE2(v12),
      HIBYTE(v12),
      v9);
    sub_38438(7, s, 0);
  }
  return sub_3BBBC(a1, v11, 9u);
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (0003F9D8) --------------------------------------------------------
int __fastcall sub_3F9D8(char a1, int a2, int a3)
{
  int v4; // [sp+Ch] [bp-8h]

  HIBYTE(v4) = a1;
  LOWORD(v4) = -26367;
  BYTE2(v4) = 17;
  sub_3F864(*((_DWORD *)&unk_C4BCC + a3 + 2), 0, (unsigned __int8)aBitmainL3Detec_0[a2 + 1604], 28, v4);
  return usleep(0x7D0u);
}

//----- (0003FA48) --------------------------------------------------------
ssize_t __fastcall sub_3FA48(int a1)
{
  int v1; // r4
  int v3; // [sp+0h] [bp-8h] BYREF
  char v4; // [sp+4h] [bp-4h]

  v1 = *((_DWORD *)&unk_C4BCC + a1 + 2);
  v4 = 0;
  v3 = 1107;
  v4 = sub_3B360(&v3, 32);
  return sub_3BBBC(v1, &v3, 5u);
}

//----- (0003FB04) --------------------------------------------------------
void sub_3FB04()
{
  int v0; // r0
  int v1; // r12
  unsigned int v2; // r3
  char i; // r2
  int v4; // r8
  int v5; // r6
  int v6; // r7
  int v7; // t1
  char v8; // r5
  unsigned int v9; // r11
  char v10; // r0
  int v11; // r3
  char s[4]; // [sp+10h] [bp-804h] BYREF
  char v13; // [sp+14h] [bp-800h]

  if ( byte_C548D )
  {
    v0 = (unsigned __int8)sub_48F88(256, (unsigned __int8)byte_C548D);
    byte_C548C = v0;
    if ( byte_632F0 || (v1 = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 4 )
    {
      snprintf(s, 0x800u, "addrInterval = '%d'", (unsigned __int8)v0);
      sub_38438(5, s, 0);
      v0 = (unsigned __int8)byte_C548C;
      v1 = (unsigned __int8)byte_632F0;
    }
    v2 = (unsigned __int8)(v0 - 1);
    if ( (_BYTE)v0 != 1 )
    {
      for ( i = byte_C5466 + 1; ; ++i )
      {
        v2 >>= 1;
        if ( !v2 )
          break;
      }
      byte_C5466 = i;
    }
    if ( byte_630C1 && (v1 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "--- %s interval %d", "software_set_address", v0);
      sub_38438(7, s, 0);
      v1 = (unsigned __int8)byte_632F0;
    }
    v4 = 805859;
    v5 = 0;
    v6 = 805836;
    if ( !v1 )
      goto LABEL_13;
LABEL_15:
    snprintf(
      s,
      0x800u,
      "%s: chain %d has %d ASIC, and addrInterval is %d",
      "software_set_address",
      v5,
      *(unsigned __int8 *)(v4 + 2175),
      (unsigned __int8)byte_C548C);
    sub_38438(5, s, 0);
    while ( 1 )
    {
      v7 = *(unsigned __int8 *)++v4;
      if ( v7 == 1 )
      {
        sub_3FA48(v5);
        sub_2B21C();
        if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
        {
          snprintf(s, 0x800u, "Now Set [%d] Chain Address", v5);
          sub_38438(5, s, 0);
        }
        if ( sub_48F88(256, (unsigned __int8)byte_C548C) )
        {
          v8 = 0;
          v9 = 0;
          do
          {
            s[3] = 0;
            s[0] = 64;
            s[1] = 4;
            ++v9;
            s[2] = v8;
            v13 = 0;
            v10 = sub_3B360(s, 32);
            v11 = *(_DWORD *)(v6 + 8);
            v13 = v10;
            sub_3BBBC(v11, s, 5u);
            v8 += byte_C548C;
            sub_2B21C();
          }
          while ( sub_48F88(256, (unsigned __int8)byte_C548C) > v9 );
        }
      }
      ++v5;
      v6 += 4;
      if ( v5 == 4 )
        break;
      if ( byte_632F0 )
        goto LABEL_15;
LABEL_13:
      if ( byte_630C0 || dword_60964 > 4 )
        goto LABEL_15;
    }
  }
  else
  {
    byte_C548C = 7;
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;
// C5466: using guessed type char byte_C5466;
// C548C: using guessed type char byte_C548C;
// C548D: using guessed type char byte_C548D;

//----- (0003FE10) --------------------------------------------------------
int __fastcall sub_3FE10(int result, char a2, unsigned __int8 a3)
{
  int v3; // r7
  int v4; // r6
  int v5; // r5
  int v6; // t1
  int v7; // r4
  char v8; // r3

  v3 = 805859;
  v4 = 805836;
  v5 = ((a2 & 1) << 7) | ((unsigned __int8)result << 16) & 0xFFFFFF | (a3 << 24);
  do
  {
    v6 = *(unsigned __int8 *)++v3;
    if ( v6 == 1 )
    {
      v7 = 0;
LABEL_6:
      v8 = v7;
      while ( 1 )
      {
        v5 = v5 & 0xFFFFF0FF | ((v8 & 0xF) << 8);
        ++v7;
        sub_3F864(*(_DWORD *)(v4 + 8), 1, 0, 60, v5);
        result = sub_2B21C();
        v8 = v7 + 2;
        if ( v7 == 12 )
          break;
        if ( v7 <= 5 )
          goto LABEL_6;
      }
    }
    v4 += 4;
  }
  while ( v3 != 805863 );
  return result;
}

//----- (0003FEA4) --------------------------------------------------------
void __fastcall sub_3FEA4(unsigned __int8 a1, char a2, char a3, unsigned __int8 a4)
{
  int v4; // r7
  int v5; // r4
  int v6; // r5
  int v7; // t1
  char s[2048]; // [sp+8h] [bp-800h] BYREF

  v4 = ((a3 & 1) << 7) | ((a2 & 0xF) << 8) | (a1 << 16) & 0xFFFFFF | (a4 << 24);
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    snprintf(s, 0x800u, "opt_bitmain_L3_core_temp : %x", byte_60DEB);
    sub_38438(5, s, 0);
  }
  v5 = 805859;
  v6 = 805836;
  do
  {
    v7 = *(unsigned __int8 *)++v5;
    if ( v7 == 1 )
    {
      sub_3F864(*(_DWORD *)(v6 + 8), 0, 12, 60, v4);
      sub_2B21C();
      sub_3F864(*(_DWORD *)(v6 + 8), 0, 201, 60, v4);
      sub_2B21C();
    }
    v6 += 4;
  }
  while ( v5 != 805863 );
}
// 60964: using guessed type int dword_60964;
// 60DEB: using guessed type char byte_60DEB;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;

//----- (0003FFAC) --------------------------------------------------------
int sub_3FFAC()
{
  int v0; // r4
  _DWORD *v1; // r6
  int v2; // r5
  int v3; // t1
  int result; // r0

  v0 = 805859;
  v1 = &unk_63178;
  v2 = 805836;
  do
  {
    v3 = *(unsigned __int8 *)++v0;
    if ( v3 == 1 )
    {
      sub_3F864(*(_DWORD *)(v2 + 8), 0, 12, 28, 38915);
      *v1 = 4;
      usleep(0xC8u);
      sub_3F864(*(_DWORD *)(v2 + 8), 0, 201, 28, 38915);
      v1[2] = 4;
      result = usleep(0xC8u);
    }
    v2 += 4;
    v1 += 6;
  }
  while ( v0 != 805863 );
  return result;
}

//----- (00040064) --------------------------------------------------------
int __fastcall sub_40064(unsigned __int8 a1)
{
  int v1; // r4
  _DWORD *v2; // r6
  int v3; // r5
  int v4; // t1
  int v6; // [sp+Ch] [bp-4h]

  v1 = 805859;
  v2 = &unk_63178;
  v3 = 805836;
  HIWORD(v6) = a1;
  LOWORD(v6) = -26623;
  do
  {
    v4 = *(unsigned __int8 *)++v1;
    if ( v4 == 1 )
    {
      sub_3F864(*(_DWORD *)(v3 + 8), 0, 12, 28, v6);
      *v2 = 4;
      usleep(0xC8u);
      sub_3F864(*(_DWORD *)(v3 + 8), 0, 201, 28, v6);
      v2[2] = 4;
      usleep(0xC8u);
    }
    v3 += 4;
    v2 += 6;
  }
  while ( v1 != 805863 );
  return sub_2B21C();
}

//----- (00040128) --------------------------------------------------------
int sub_40128()
{
  int v0; // r4
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // t1
  int v5; // t1

  v0 = 805859;
  v1 = 805836;
  v2 = 805859;
  v3 = 805836;
  do
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
    {
      sub_3F864(*(_DWORD *)(v3 + 8), 1, 0, 24, 272252993);
      sub_2B21C();
    }
    v3 += 4;
  }
  while ( v2 != 805863 );
  do
  {
    v5 = *(unsigned __int8 *)++v0;
    if ( v5 == 1 )
    {
      sub_3F864(*(_DWORD *)(v1 + 8), 0, 12, 24, 1887060033);
      sub_2B21C();
      sub_3F864(*(_DWORD *)(v1 + 8), 0, 201, 24, 1887060033);
      sub_2B21C();
    }
    v1 += 4;
  }
  while ( v0 != 805863 );
  sub_2B21C();
  return sub_3EF84(0, 24, 1);
}

//----- (0004022C) --------------------------------------------------------
void __fastcall sub_4022C(int a1)
{
  int v2; // r3
  int v3; // r2
  int v4; // r1
  size_t v5; // r0
  int v6; // r6
  int v7; // r5
  int v8; // r8
  int v9; // r7
  int v10; // t1
  int v11; // [sp+14h] [bp-828h] BYREF
  char s[4]; // [sp+18h] [bp-824h] BYREF
  int v13; // [sp+1Ch] [bp-820h]
  int v14; // [sp+20h] [bp-81Ch]
  int v15; // [sp+24h] [bp-818h]
  int v16; // [sp+28h] [bp-814h]
  int v17; // [sp+2Ch] [bp-810h]
  int v18; // [sp+30h] [bp-80Ch]
  int v19; // [sp+34h] [bp-808h]
  char v20[2052]; // [sp+38h] [bp-804h] BYREF

  v2 = 0;
  v13 = 0;
  v11 = 0;
  v14 = 0;
  *(_DWORD *)s = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)&aD_0[8 * v2];
    v4 = 8 * v2++;
    if ( a1 == v3 )
      break;
    if ( v2 == 100 )
    {
      if ( byte_632F0 || byte_630C0 || dword_60964 > 3 )
      {
        strcpy(v20, "error freq,set default instead");
        sub_38438(4, v20, 0);
        v4 = 32;
      }
      else
      {
        v4 = 32;
      }
      break;
    }
  }
  sprintf(s, "%08x", *(_DWORD *)&aBitmainL3Detec_0[v4 + 76]);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v20, 0x800u, "regdata: %s", s);
    sub_38438(7, v20, 0);
  }
  v5 = strlen(s);
  if ( !sub_295B8(&v11, (unsigned __int8 *)s, v5 >> 1) )
  {
    snprintf(v20, 0x800u, "Invalid vil plldata for reg data, hex2bin error now: %s", s);
    sub_38438(3, v20, 1);
    sub_16724(1);
  }
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(v20, 0x800u, "%s: frequency = %d", "set_frequency", a1);
    sub_38438(7, v20, 0);
  }
  v6 = 805859;
  v7 = 0;
  v8 = v11;
  v9 = 805836;
  do
  {
    v10 = *(unsigned __int8 *)++v6;
    if ( v10 == 1 )
    {
      sub_3F864(*(_DWORD *)(v9 + 8), 1, 0, 8, v8);
      *(_WORD *)(v7 + 808094) = a1;
      sub_2B244();
    }
    v7 += 2;
    v9 += 4;
  }
  while ( v7 != 8 );
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (000404D8) --------------------------------------------------------
void __fastcall sub_404D8(int a1)
{
  int v2; // r5
  int v3; // r4
  int v4; // r7
  int v5; // r6
  int v6; // t1
  int v7; // [sp+14h] [bp-808h] BYREF
  char s[2052]; // [sp+18h] [bp-804h] BYREF

  v7 = 0;
  sub_3A904(a1, &v7);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "%s: frequency = %d", "set_frequency_i", a1);
    sub_38438(7, s, 0);
  }
  v2 = 805859;
  v3 = 0;
  v4 = v7;
  v5 = 805836;
  do
  {
    v6 = *(unsigned __int8 *)++v2;
    if ( v6 == 1 )
    {
      sub_3F864(*(_DWORD *)(v5 + 8), 1, 0, 8, v4);
      *(_WORD *)(v3 + 808094) = a1;
      sub_2B244();
    }
    v3 += 2;
    v5 += 4;
  }
  while ( v3 != 8 );
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (000405F0) --------------------------------------------------------
int __fastcall sub_405F0(int a1, int a2, int a3)
{
  int v7; // [sp+14h] [bp-804h] BYREF
  char s[2048]; // [sp+18h] [bp-800h] BYREF

  v7 = 0;
  sub_3A904(a2, &v7);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "%s: frequency = %d", "set_frequency_with_addr_i", a2);
    sub_38438(7, s, 0);
  }
  sub_3F864(*((_DWORD *)&unk_C4BCC + a1 + 2), 0, a3, 8, v7);
  return sub_2B21C();
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (000406DC) --------------------------------------------------------
int sub_406DC()
{
  int v0; // r7
  char *v1; // r5
  int v2; // r8
  int v3; // r4
  int v4; // t1
  int v5; // r5
  int v6; // r4
  int v7; // r7
  char *v8; // r6
  int v9; // t1
  int i; // r5
  int v11; // r7
  int v12; // r4
  _BYTE *v13; // r6
  int v14; // t1
  int v15; // r8
  int v16; // r4
  int v17; // t1
  int result; // r0
  unsigned __int8 *v19; // r9
  _BYTE *v20; // r7
  char *v21; // r10
  char *v22; // r6
  int j; // r5
  int v24; // r3
  int v25; // t1
  int v26; // r12
  int v27; // t1
  int v28; // r2
  char v29; // r0
  int v30; // r3
  char v31; // r0
  int v32; // r12
  int v33; // lr
  bool v34; // zf
  char v35; // r12
  int v36; // [sp+14h] [bp-830h]
  int v37; // [sp+18h] [bp-82Ch]
  int v38; // [sp+1Ch] [bp-828h]
  _DWORD v39[2]; // [sp+20h] [bp-824h] BYREF
  _DWORD v40[2]; // [sp+28h] [bp-81Ch] BYREF
  _DWORD v41[2]; // [sp+30h] [bp-814h] BYREF
  _BYTE v42[8]; // [sp+38h] [bp-80Ch] BYREF
  char s[2052]; // [sp+40h] [bp-804h] BYREF

  v0 = 805863;
  v1 = v42;
  v2 = 0;
  v3 = 0;
  v39[0] = 0;
  v39[1] = 0;
  v40[0] = 0;
  v40[1] = 0;
  v41[0] = 0;
  v41[1] = 0;
  sub_3FEA4(3u, byte_60DEB, 0, 0);
  v42[0] = -40;
  v42[1] = -40;
  v42[2] = -40;
  v42[3] = -40;
  v42[4] = -40;
  v42[5] = -40;
  v42[6] = -40;
  v42[7] = -40;
  do
  {
    v4 = *(unsigned __int8 *)++v0;
    if ( v4 == 1 )
    {
      ++v2;
      sub_3F9D8(*v1, 0, v3);
      sub_3F9D8(v1[1], 1, v3);
    }
    ++v3;
    v1 += 2;
  }
  while ( v3 != 4 );
  v38 = 2 * v2;
  sub_2B21C();
  v37 = 11;
  do
  {
    v5 = 0;
    sub_40064(0);
    do
    {
      if ( sub_3F014(v5) )
      {
        if ( byte_632F0 || byte_630C0 || dword_60964 > 2 )
        {
          snprintf(s, 0x800u, "Get [%d]Temp Data Failed!", v5);
          sub_38438(3, s, 0);
        }
      }
      else
      {
        v6 = 0;
        v7 = 805863;
        v8 = (char *)&unk_63178 + 8 * v5;
        do
        {
          v9 = *(unsigned __int8 *)++v7;
          if ( v9 == 1 )
          {
            v34 = byte_630C1 == 0;
            v35 = v8[4];
            *((_BYTE *)v39 + 2 * v6 + v5) = v35;
            if ( !v34 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
            {
              snprintf(s, 0x800u, "Chain %d chip %d LocalTemp 0x%x ", v6, v5, v35);
              sub_38438(7, s, 0);
            }
            *(_DWORD *)v8 = 4;
          }
          ++v6;
          v8 += 24;
        }
        while ( v6 != 4 );
      }
      ++v5;
      sub_2B21C();
    }
    while ( v5 != 2 );
    sub_40064(1u);
    for ( i = 0; i != 2; ++i )
    {
      if ( sub_3F014(i) )
      {
        if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "Get [%d]Temp Data Failed!", i);
          sub_38438(7, s, 0);
        }
      }
      else
      {
        v11 = 805863;
        v12 = 0;
        v13 = (char *)&unk_63178 + 8 * i + 4;
        do
        {
          v14 = *(unsigned __int8 *)++v11;
          if ( v14 == 1 )
          {
            v32 = (unsigned __int8)byte_632F0;
            *((_DWORD *)v13 - 1) = 4;
            v33 = (char)*v13;
            *((_BYTE *)v40 + 2 * v12 + i) = *v13;
            if ( v32 || byte_630C0 || dword_60964 > 4 )
            {
              snprintf(s, 0x800u, "Chain %d chip %d RemoteTemp 0x%x", v12, i, v33);
              sub_38438(5, s, 0);
            }
          }
          ++v12;
          v13 += 24;
        }
        while ( v12 != 4 );
      }
      sub_2B21C();
    }
    v15 = 805863;
    v16 = 0;
    v36 = 0;
    do
    {
      v17 = *(unsigned __int8 *)++v15;
      if ( v17 == 1 )
      {
        v19 = (unsigned __int8 *)v40 + 2 * v16;
        v20 = (char *)v41 + 2 * v16;
        v21 = (char *)v39 + 2 * v16;
        v22 = &v42[2 * v16];
        for ( j = 0; j != 2; ++j )
        {
          v25 = *v19++;
          v24 = v25;
          v27 = *v21++;
          v26 = v27;
          v28 = (char)v24;
          if ( v24 || *v20 == 1 )
          {
            v30 = (char)v24 - v26;
            if ( v28 - v26 < 0 )
              v30 = v26 - v28;
            if ( v30 <= 2 )
            {
              if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
              {
                snprintf(s, 0x800u, "OK Chain %d chip %d local 0x%x remote 0x%x offset 0x%x ", v16, j, v26, v28, *v22);
                sub_38438(5, s, 0);
              }
              if ( *v20 != 1 )
              {
                *v20 = 1;
                ++v36;
              }
            }
            else
            {
              if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
              {
                snprintf(s, 0x800u, "2 Chain %d chip %d local 0x%x remote 0x%x offset 0x%x ", v16, j, v26, v28, *v22);
                sub_38438(5, s, 0);
              }
              v31 = *(v21 - 1) + *v22 - *(v19 - 1);
              *v22 = v31;
              sub_3F9D8(v31, j, v16);
            }
          }
          else
          {
            if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
            {
              snprintf(
                s,
                0x800u,
                "Remote = 0 Chain %d chip %d local 0x%x remote 0x%x offset 0x%x ",
                v16,
                j,
                v26,
                (char)v24,
                *v22);
              sub_38438(5, s, 0);
            }
            v29 = *v22 + 30;
            *v22 = v29;
            sub_3F9D8(v29, j, v16);
          }
          ++v22;
          ++v20;
        }
      }
      ++v16;
    }
    while ( v16 != 4 );
    sub_2B21C();
    sub_40064(0x11u);
    result = sub_3EF84(12, 28, 0);
    if ( v38 == v36 )
      break;
    --v37;
  }
  while ( v37 );
  return result;
}
// 60964: using guessed type int dword_60964;
// 60DEB: using guessed type char byte_60DEB;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00040D00) --------------------------------------------------------
void __fastcall sub_40D00(unsigned int a1)
{
  int v1; // r8
  int v2; // r4
  int v3; // r5
  int v4; // t1
  char s[2048]; // [sp+10h] [bp-800h] BYREF

  v1 = bswap32(a1);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "%s tm=%d", "set_asic_ticket_mask", v1);
    sub_38438(7, s, 0);
  }
  v2 = 805859;
  v3 = 805836;
  do
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
    {
      sub_3F864(*(_DWORD *)(v3 + 8), 1, 0, 20, v1);
      sub_2B21C();
    }
    v3 += 4;
  }
  while ( v2 != 805863 );
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 632F0: using guessed type char byte_632F0;

//----- (00040DEC) --------------------------------------------------------
int __fastcall sub_40DEC(char a1, char *a2, int a3)
{
  int result; // r0
  int v6; // r6
  char *v7; // r1
  char v8[4]; // [sp+4h] [bp-4h] BYREF

  v8[0] = a1;
  write(dword_C54A6, v8, 1u);
  result = sub_2B21C();
  if ( a3 )
  {
    v6 = (int)&a2[(unsigned __int8)(a3 - 1) + 1];
    do
    {
      v7 = a2++;
      read(dword_C54A6, v7, 1u);
      result = sub_2B21C();
    }
    while ( a2 != (char *)v6 );
  }
  return result;
}
// C54A6: using guessed type int dword_C54A6;

//----- (00040E64) --------------------------------------------------------
int __fastcall sub_40E64(char *a1)
{
  char buf; // [sp+4h] [bp-8h] BYREF
  char v4[7]; // [sp+5h] [bp-7h] BYREF

  buf = 85;
  v4[0] = -86;
  write(dword_C54A6, &buf, 1u);
  sub_2B244();
  write(dword_C54A6, v4, 1u);
  sub_2B244();
  return sub_40DEC(19, a1, 12);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00040ED8) --------------------------------------------------------
int sub_40ED8()
{
  char v1[4]; // [sp+0h] [bp-8h] BYREF
  char buf; // [sp+4h] [bp-4h] BYREF
  char v3[3]; // [sp+5h] [bp-3h] BYREF

  v1[0] = 6;
  buf = 85;
  v3[0] = -86;
  write(dword_C54A6, &buf, 1u);
  sub_2B244();
  write(dword_C54A6, v3, 1u);
  sub_2B244();
  write(dword_C54A6, v1, 1u);
  sub_2B244();
  return 0;
}
// C54A6: using guessed type int dword_C54A6;

//----- (00040F64) --------------------------------------------------------
int sub_40F64()
{
  char v1[4]; // [sp+0h] [bp-8h] BYREF
  char buf; // [sp+4h] [bp-4h] BYREF
  char v3[3]; // [sp+5h] [bp-3h] BYREF

  v1[0] = 7;
  buf = 85;
  v3[0] = -86;
  write(dword_C54A6, &buf, 1u);
  sub_2B244();
  write(dword_C54A6, v3, 1u);
  sub_2B244();
  write(dword_C54A6, v1, 1u);
  sub_2B244();
  return 0;
}
// C54A6: using guessed type int dword_C54A6;

//----- (00040FF0) --------------------------------------------------------
int sub_40FF0()
{
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60DEC, 1u);
  write(dword_C54A6, &unk_60DF0, 1u);
  return pthread_mutex_unlock(&stru_63214);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041040) --------------------------------------------------------
int __fastcall sub_41040(char a1, char a2)
{
  char v3; // [sp+6h] [bp-6h] BYREF
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  buf[0] = a1;
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60DF4, 1u);
  write(dword_C54A6, buf, 1u);
  write(dword_C54A6, &v3, 1u);
  return pthread_mutex_unlock(&stru_63214);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000410B0) --------------------------------------------------------
int __fastcall sub_410B0(void *a1, void *a2)
{
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60DF8, 1u);
  read(dword_C54A6, a1, 1u);
  read(dword_C54A6, a2, 1u);
  return pthread_mutex_unlock(&stru_63214);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041118) --------------------------------------------------------
int __fastcall sub_41118(int a1)
{
  int v2; // r4
  const void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60DFC, 1u);
  do
  {
    v3 = (const void *)(a1 + v2++);
    write(dword_C54A6, v3, 1u);
  }
  while ( v2 != 16 );
  return pthread_mutex_unlock(&stru_63214);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041178) --------------------------------------------------------
int sub_41178()
{
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E00, 1u);
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000411C4) --------------------------------------------------------
int sub_411C4()
{
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E04, 1u);
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041210) --------------------------------------------------------
int __fastcall sub_41210(int a1)
{
  int v2; // r4
  void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E08, 1u);
  do
  {
    v3 = (void *)(a1 + v2++);
    read(dword_C54A6, v3, 1u);
  }
  while ( v2 != 16 );
  return pthread_mutex_unlock(&stru_63214);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041270) --------------------------------------------------------
int sub_41270()
{
  sub_40FF0();
  printf("\n--- %s\n", "pic_reset");
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E0C, 1u);
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_927C0);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000412D0) --------------------------------------------------------
int sub_412D0()
{
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E10, 1u);
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (0004131C) --------------------------------------------------------
int __fastcall sub_4131C(int a1)
{
  int v2; // r4
  const void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E14, 1u);
  do
  {
    v3 = (const void *)(a1 + v2++);
    write(dword_C54A6, v3, 1u);
    usleep(0x1388u);
  }
  while ( v2 != 8 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041390) --------------------------------------------------------
int __fastcall sub_41390(int a1)
{
  int v2; // r4
  void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E18, 1u);
  do
  {
    v3 = (void *)(a1 + v2++);
    read(dword_C54A6, v3, 1u);
  }
  while ( v2 != 8 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000413FC) --------------------------------------------------------
int __fastcall sub_413FC(int a1)
{
  int v2; // r4
  const void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E1C, 1u);
  do
  {
    v3 = (const void *)(a1 + v2++);
    write(dword_C54A6, v3, 1u);
    usleep(0x1388u);
  }
  while ( v2 != 6 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041470) --------------------------------------------------------
int __fastcall sub_41470(int a1)
{
  int v2; // r4
  void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E20, 1u);
  do
  {
    v3 = (void *)(a1 + v2++);
    read(dword_C54A6, v3, 1u);
  }
  while ( v2 != 6 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000414DC) --------------------------------------------------------
int __fastcall sub_414DC(int a1)
{
  int v2; // r4
  const void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E24, 1u);
  do
  {
    v3 = (const void *)(a1 + v2++);
    write(dword_C54A6, v3, 1u);
    usleep(0x1388u);
  }
  while ( v2 != 12 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041550) --------------------------------------------------------
int __fastcall sub_41550(int a1)
{
  int v2; // r4
  void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E28, 1u);
  do
  {
    v3 = (void *)(a1 + v2++);
    read(dword_C54A6, v3, 1u);
  }
  while ( v2 != 12 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000415BC) --------------------------------------------------------
int __fastcall sub_415BC(int a1)
{
  int v2; // r4
  const void *v3; // r1

  sub_40FF0();
  v2 = 0;
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E2C, 1u);
  do
  {
    v3 = (const void *)(a1 + v2++);
    write(dword_C54A6, v3, 1u);
  }
  while ( v2 != 12 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041628) --------------------------------------------------------
int __fastcall sub_41628(int a1, const void *a2)
{
  int v4; // r4
  void *v5; // r1

  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E30, 1u);
  write(dword_C54A6, a2, 1u);
  pthread_mutex_unlock(&stru_63214);
  v4 = 0;
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E34, 1u);
  do
  {
    v5 = (void *)(a1 + v4++);
    read(dword_C54A6, v5, 1u);
  }
  while ( v4 != 16 );
  pthread_mutex_unlock(&stru_63214);
  return usleep((__useconds_t)&unk_7A120);
}
// C54A6: using guessed type int dword_C54A6;

//----- (00041798) --------------------------------------------------------
int __fastcall sub_41798(void *a1)
{
  sub_40FF0();
  pthread_mutex_lock(&stru_63214);
  write(dword_C54A6, &unk_60E3C, 1u);
  read(dword_C54A6, a1, 1u);
  return pthread_mutex_unlock(&stru_63214);
}
// C54A6: using guessed type int dword_C54A6;

//----- (000417EC) --------------------------------------------------------
int sub_417EC()
{
  int v0; // r4
  int result; // r0

  v0 = 100;
  sub_41040(3, 0);
  printf("%s: erase_loop = %d\n", "pic_erase_flash_all", 100);
  do
  {
    result = sub_411C4();
    --v0;
  }
  while ( v0 );
  return result;
}

//----- (00041998) --------------------------------------------------------
int sub_41998()
{
  printf("--- %s\n", "clear_freq_value_in_pic");
  sub_41270();
  sub_41040(15, 160);
  usleep(0x186A0u);
  sub_411C4();
  return sub_411C4();
}

//----- (00041A58) --------------------------------------------------------
void __fastcall sub_41A58(int a1)
{
  int v2; // r0
  int v3; // r5
  int v4; // r4
  char v5[2052]; // [sp+0h] [bp-804h] BYREF

  v2 = open("/dev/i2c-0", 2050);
  v3 = a1;
  v4 = 0;
  *(_DWORD *)(a1 + 187) = v2;
  do
  {
    if ( *(_BYTE *)(v3 + 157) )
    {
      if ( ioctl(v2, 0x703u, *(int *)((char *)&unk_557AC + v4) >> 1) < 0 )
        perror("set i2c slave addr  error");
      v2 = *(_DWORD *)(a1 + 187);
    }
    v4 += 4;
    ++v3;
  }
  while ( v4 != 16 );
  dword_C54A6 = v2;
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(v5, "i2c init ok");
    sub_38438(5, v5, 0);
  }
}
// 60964: using guessed type int dword_60964;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// C54A6: using guessed type int dword_C54A6;

//----- (00041B50) --------------------------------------------------------
unsigned int __fastcall sub_41B50(unsigned int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r2
  int v4; // t1

  if ( a3 )
  {
    v3 = &a2[a3];
    do
    {
      v4 = *a2++;
      result = (unsigned __int16)(*(_WORD *)&aBitmainL3Detec_0[2 * (v4 ^ (result >> 8)) + 928] ^ ((_WORD)result << 8));
    }
    while ( a2 != v3 );
  }
  return result;
}

//----- (00041B8C) --------------------------------------------------------
int __fastcall sub_41B8C(int a1)
{
  int v1; // r0

  if ( (unsigned int)(a1 - 48) <= 9 )
    return a1 & 0xF;
  v1 = a1 & 0xDF;
  switch ( v1 )
  {
    case 'A':
      return 10;
    case 'B':
      return 11;
    case 'C':
      return 12;
    case 'D':
      return 13;
    case 'E':
      return 14;
    case 'F':
      return 15;
  }
  return 255;
}

//----- (00041C04) --------------------------------------------------------
int __fastcall sub_41C04(int a1, int a2)
{
  char v3; // r4

  v3 = sub_41B8C(a1);
  return (unsigned __int8)(16 * v3) ^ (unsigned __int8)sub_41B8C(a2);
}

//----- (00041C30) --------------------------------------------------------
int __fastcall sub_41C30(int a1, unsigned __int8 *a2, int a3)
{
  bool v3; // cc
  int v6; // r8
  int v7; // r9
  int v8; // r5
  unsigned __int8 *v9; // r6
  unsigned __int8 *v10; // r4
  int v11; // r0
  int v12; // r1

  v3 = (int)a2 <= 0;
  if ( a2 )
    v3 = a3 <= 0;
  if ( v3 || !a1 )
    return -1;
  v6 = a3 >> 1;
  v7 = a3 & 1;
  if ( a3 >> 1 )
  {
    v8 = a1 - 1;
    v9 = &a2[2 * v6];
    v10 = a2;
    do
    {
      v11 = *v10;
      v12 = v10[1];
      v10 += 2;
      *(_BYTE *)++v8 = sub_41C04(v11, v12);
    }
    while ( v10 != v9 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + v6) = sub_41C04(a2[2 * v6], 0);
  return v6 + v7;
}

//----- (00041CAC) --------------------------------------------------------
void sub_41CAC()
{
  char *v0; // r10
  int v1; // r5
  int v2; // r4
  int v3; // r2
  int v4; // r7
  int v5; // r6
  int *v6; // r8
  _DWORD *v7; // r5
  int v8; // r4
  _DWORD *v9; // r3
  int v10; // t1
  int v11; // t1
  int v12; // r3
  bool v13; // nf
  int v14; // r3
  int v15; // [sp+0h] [bp-814h]
  int v16; // [sp+4h] [bp-810h]
  char *v17; // [sp+8h] [bp-80Ch]
  int v18; // [sp+Ch] [bp-808h]
  char v19[2052]; // [sp+10h] [bp-804h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(v19, "print_result");
    sub_38438(5, v19, 0);
  }
  v0 = (char *)&unk_C20B8;
  v17 = (char *)&unk_66EDC;
  v16 = 0;
  v18 = 805859;
  do
  {
    v1 = v16;
    v2 = *(unsigned __int8 *)(v18 + 1);
    v3 = ++v16;
    ++v18;
    if ( v2 == 1 )
    {
      printf("Chain %d result\n", v3);
      v4 = 0;
      v5 = 0;
      v15 = 864 * v1;
      v6 = (int *)((char *)&unk_65EAC + 1024 * v1);
      v7 = v17;
      do
      {
        v8 = 0;
        v9 = &dword_66EB0[12 * v5 - 1 + v15];
        do
        {
          v10 = v9[1];
          ++v9;
          v8 += v10;
        }
        while ( v9 != v7 );
        v11 = *v6++;
        printf("A%02d=%d %d ", v5, v8, *(_DWORD *)&aBitmainL3Detec_0[8 * v11 + 72]);
        if ( v8 == 48 )
        {
          if ( !*(_DWORD *)&v0[v4] )
          {
            v14 = *(v6 - 1) + 4;
            if ( v14 > 65 )
            {
              v14 = 65;
              *(_DWORD *)&v0[v4] = 1;
            }
            *(v6 - 1) = v14;
            byte_60DE8 = 0;
          }
        }
        else
        {
          if ( v8 <= 45 )
          {
            v12 = *(v6 - 1) - 1;
            v13 = *(v6 - 1) - 31 < 0;
            byte_60DE8 = 0;
            if ( v13 != __OFSUB__(v12, 30) )
              v12 = 30;
            *(v6 - 1) = v12;
          }
          *(_DWORD *)&v0[v4] = 1;
        }
        if ( (++v5 & 7) == 0 )
          putchar(10);
        v4 += 4;
        v7 += 12;
      }
      while ( v5 != 72 );
      putchar(10);
    }
    v0 += 1024;
    v17 += 3456;
  }
  while ( v16 != 4 );
}
// 60964: using guessed type int dword_60964;
// 60DE8: using guessed type char byte_60DE8;
// 630C0: using guessed type char byte_630C0;
// 632F0: using guessed type char byte_632F0;
// 66EB0: using guessed type _DWORD dword_66EB0[11];

//----- (00041EC4) --------------------------------------------------------
int sub_41EC4()
{
  int *v0; // r4
  int v1; // t1

  v0 = &dword_C4BD0;
  pthread_mutex_lock(&stru_630DC);
  dword_C30B8 = 0;
  dword_C30BC = 0;
  dword_C30C0 = 0;
  do
  {
    v1 = v0[1];
    ++v0;
    tcflush(v1, 2);
  }
  while ( v0 != &dword_C4BE0 );
  return pthread_mutex_unlock(&stru_630DC);
}
// C30B8: using guessed type int dword_C30B8;
// C30BC: using guessed type int dword_C30BC;
// C30C0: using guessed type int dword_C30C0;
// C4BD0: using guessed type int dword_C4BD0;
// C4BE0: using guessed type int dword_C4BE0;

//----- (00041F18) --------------------------------------------------------
int sub_41F18()
{
  int result; // r0
  _DWORD *v1; // r3
  int v2; // r1
  char v3[2048]; // [sp+0h] [bp-800h] BYREF

  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(v3, "reset_patten_stats");
    sub_38438(5, v3, 0);
  }
  memset(dword_66EB0, 0, 0x3600u);
  byte_60DE8 = 1;
  result = 0;
  dword_630F4 = 0;
  do
  {
    v1 = &dword_6A4B8[1248 * result];
    v2 = 48;
    do
    {
      --v2;
      v1[22] = 0;
      v1[23] = 0;
      v1[24] = 0;
      v1[25] = 0;
      v1 += 26;
    }
    while ( v2 );
    ++result;
  }
  while ( result != 72 );
  return result;
}
// 60964: using guessed type int dword_60964;
// 60DE8: using guessed type char byte_60DE8;
// 630C0: using guessed type char byte_630C0;
// 630F4: using guessed type int dword_630F4;
// 632F0: using guessed type char byte_632F0;
// 66EB0: using guessed type _DWORD dword_66EB0[11];
// 6A4B8: using guessed type _DWORD dword_6A4B8[6354];

//----- (00042010) --------------------------------------------------------
int sub_42010()
{
  if ( access("/usr/bin/need_reboot", 0) != -1 )
    return system("echo 2 >> /usr/bin/already_reboot");
  system("touch /usr/bin/need_reboot");
  system("echo 1 >> /usr/bin/already_reboot");
  return system("/etc/init.d/cgminer.sh restart");
}

//----- (00042584) --------------------------------------------------------
int __fastcall sub_42584(int a1)
{
  int *v1; // r12
  int *v2; // r6
  int *v3; // r5
  int v5; // r0
  int *v6; // lr
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int v10; // r1
  int *v12; // r2
  unsigned int v13; // r3
  int v14; // t1
  int v15; // r3
  int v16; // r2
  int v17; // r2
  int v18; // r1
  int v19; // r5
  int v20; // r6
  int v21; // t1
  int v22; // r6
  int i; // r5
  int v24; // t1
  int v25; // r5
  int v26; // r6
  int v27; // t1
  int v28; // r10
  unsigned __int8 *v29; // r6
  char v30; // r8
  int v31; // r5
  int v32; // t1
  int v34; // r1
  const char *v35; // r2
  int v36; // r3
  char v37; // r6
  unsigned int v38; // r5
  int v39; // r5
  unsigned int v40; // r3
  int v41; // r9
  int v42; // r1
  int v44; // r4
  int v45; // r5
  char *v46; // r6
  int v47; // r4
  char *v48; // r9
  char *v49; // r10
  int v50; // r6
  int v51; // r6
  int v52; // [sp+8h] [bp-854h]
  int v53; // [sp+Ch] [bp-850h]
  _DWORD v54[9]; // [sp+10h] [bp-84Ch] BYREF
  int v55; // [sp+34h] [bp-828h] BYREF
  int v56; // [sp+38h] [bp-824h]
  int v57; // [sp+3Ch] [bp-820h]
  int v58; // [sp+40h] [bp-81Ch]
  int v59; // [sp+44h] [bp-818h]
  int v60; // [sp+48h] [bp-814h]
  int v61; // [sp+4Ch] [bp-810h]
  int v62; // [sp+50h] [bp-80Ch]
  int v63; // [sp+54h] [bp-808h] BYREF
  char s[2040]; // [sp+58h] [bp-804h] BYREF

  v1 = (int *)(a1 + 767);
  v2 = (int *)(a1 + 799);
  v3 = v54;
  do
  {
    v5 = *v1;
    v6 = v3;
    v7 = v1[1];
    v3 += 4;
    v8 = v1[2];
    v9 = v1[3];
    v1 += 4;
    *v6 = v5;
    v6[1] = v7;
    v6[2] = v8;
    v6[3] = v9;
  }
  while ( v1 != v2 );
  *v3 = *v1;
  v55 = v54[0];
  v56 = v54[1];
  v57 = v54[2];
  v58 = v54[3];
  v59 = v54[4];
  v60 = v54[5];
  v61 = v54[6];
  v62 = v54[7];
  strcpy((char *)&dword_62E48, "1.0.1.3");
  v63 = v54[8];
  sub_3DA40(100);
  v10 = (unsigned __int8)v55;
  if ( (unsigned __int8)v55 != 81 )
  {
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return -1;
    snprintf(
      s,
      0x800u,
      "%s: config_parameter.token_type != 0x%x, it is 0x%x",
      "bitmain_L3_init",
      81,
      (unsigned __int8)v55);
    sub_38438(7, s, 0);
    return -1;
  }
  v12 = &v55;
  v13 = 255;
  while ( 1 )
  {
    v13 = (unsigned __int16)(*(_WORD *)&aBitmainL3Detec_0[2 * (v10 ^ (v13 >> 8)) + 928] ^ ((_WORD)v13 << 8));
    if ( v12 == (int *)((char *)&v63 + 1) )
      break;
    v14 = *((unsigned __int8 *)v12 + 1);
    v12 = (int *)((char *)v12 + 1);
    v10 = v14;
  }
  if ( HIWORD(v63) != v13 )
  {
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return -2;
    snprintf(
      s,
      0x800u,
      "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x",
      "bitmain_L3_init",
      HIWORD(v63),
      v13);
    sub_38438(7, s, 0);
    return -2;
  }
  v15 = 0;
  do
  {
    v16 = v15 + 46;
    ++v15;
    v17 = a1 + 4 * v16;
    v18 = *(_DWORD *)(v17 + 8);
    *(_BYTE *)(v17 + 7) = 0;
    *(_DWORD *)(v17 + 8) = v18 & 0xFF000000;
  }
  while ( v15 != 128 );
  v19 = 0;
  v52 = 805859;
  sub_3F17C(a1);
  sub_2B21C();
  sub_41A58(a1);
  sub_2B21C();
  v20 = 805859;
  do
  {
    v21 = *(unsigned __int8 *)++v20;
    if ( v21 == 1 )
    {
      pthread_mutex_lock(&stru_63120);
      if ( ioctl(*(_DWORD *)(a1 + 187), 0x703u, *(int *)((char *)&unk_557AC + v19) >> 1) < 0
        && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
      {
        snprintf(s, 0x800u, "ioctl error @ line %d", 3443);
        sub_38438(3, s, 0);
      }
      sub_40F64();
      pthread_mutex_unlock(&stru_63120);
    }
    v19 += 4;
  }
  while ( v19 != 16 );
  v22 = 805859;
  sub_2B21C();
  for ( i = 0; i != 16; i += 4 )
  {
    v24 = *(unsigned __int8 *)++v22;
    if ( v24 == 1 )
    {
      pthread_mutex_lock(&stru_63120);
      if ( ioctl(*(_DWORD *)(a1 + 187), 0x703u, *(int *)((char *)&unk_557AC + i) >> 1) < 0
        && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
      {
        snprintf(s, 0x800u, "ioctl error @ line %d", 3457);
        sub_38438(3, s, 0);
      }
      sub_40ED8();
      pthread_mutex_unlock(&stru_63120);
    }
  }
  sub_2B21C();
  dword_C4BC8 = (int)calloc(1u, 0x40u);
  if ( sub_2F0EC(dword_C4BC8, 0, (void *(*)(void *))sub_3B0EC, (void *)dword_C4BC8) )
  {
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return -3;
    snprintf(s, 0x800u, "%s: create thread error for pic_heart_beat_func", "bitmain_L3_init");
LABEL_34:
    sub_38438(7, s, 0);
    return -3;
  }
  v25 = 0;
  v26 = 805859;
  pthread_detach(*(_DWORD *)(dword_C4BC8 + 12));
  do
  {
    v27 = *(unsigned __int8 *)++v26;
    if ( v27 == 1 )
    {
      pthread_mutex_lock(&stru_63120);
      if ( ioctl(*(_DWORD *)(a1 + 187), 0x703u, *(int *)((char *)&unk_557AC + v25) >> 1) < 0
        && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
      {
        snprintf(s, 0x800u, "ioctl error @ line %d", 3536);
        sub_38438(3, s, 0);
      }
      sub_3DDB8(1);
      pthread_mutex_unlock(&stru_63120);
    }
    v25 += 4;
  }
  while ( v25 != 16 );
  sub_2B21C();
  sub_3A268();
  sub_3A268();
  sub_2B21C();
  sub_3F3B8(a1, v56);
  sub_2B21C();
  sub_3C69C();
  sub_2B21C();
  dword_6A4B4 = (int)calloc(1u, 0x40u);
  if ( sub_2F0EC(dword_6A4B4, 0, (void *(*)(void *))sub_3C6D4, (void *)dword_6A4B4) )
  {
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return -3;
    snprintf(s, 0x800u, "%s: create thread error for bitmain_scanreg", "bitmain_L3_init");
    goto LABEL_34;
  }
  pthread_detach(*(_DWORD *)(dword_6A4B4 + 12));
  sub_2B21C();
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(s, "send cmd to get chip address");
    sub_38438(5, s, 0);
  }
  v28 = 0;
  while ( 1 )
  {
    byte_63174 = 1;
    sub_3EF84(0, 0, 1);
    v29 = (unsigned __int8 *)&unk_C4BE4;
    sleep(2u);
    v30 = 0;
    v31 = 0;
    byte_63174 = 0;
    do
    {
      v32 = *v29++;
      if ( v32 == 1 )
      {
        v34 = 2048;
        v35 = "Chain %d ASIC %d !!!";
        if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
        {
          snprintf(s, 0x800u, "Chain %d ASIC %d !!!", v31, v29[2173]);
          sub_38438(5, s, 0);
        }
        v36 = v29[2173];
        if ( v36 == 72 )
        {
          v29[3] = 1;
        }
        else
        {
          v29[3] = 0;
          ++v28;
        }
        if ( v36 == 72 )
        {
          v35 = (const char *)&unk_6322C;
        }
        else
        {
          v34 = (int)&unk_6322C;
          v30 = 1;
        }
        if ( v36 == 72 )
          v35[v31] = 0;
        else
          *(_BYTE *)(v31 + v34) = 1;
      }
      ++v31;
    }
    while ( v31 != 4 );
    if ( v28 > 5 || !(v30 & 1) )
      break;
    if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
    {
      strcpy(s, "Need to recheck asic num !!!");
      sub_38438(5, s, 0);
    }
    byte_C5462 = 0;
    byte_C5463 = 0;
    byte_C5464 = 0;
    byte_C5465 = 0;
    sub_42010();
  }
  if ( access("/usr/bin/need_reboot", 0) != -1 )
    system("rm /usr/bin/need_reboot");
  byte_C548B = 12;
  sub_3FB04();
  sub_2B21C();
  sub_3EF84(0, 0, 1);
  sub_2B21C();
  v37 = v57;
  if ( (v57 & 8) != 0 )
  {
    word_C5492 = v59;
    sub_4022C((unsigned __int16)v59);
    sprintf(byte_C5494, "%u", (unsigned __int16)word_C5492);
  }
  sub_2B21C();
  v38 = BYTE2(v58);
  byte_C5490 = (v57 & 2) != 0;
  byte_C5491 = BYTE2(v58);
  if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
  {
    snprintf(s, 0x800u, "%s: fan_eft : %d  fan_pwm : %d", "bitmain_L3_init", (v57 & 2) != 0, BYTE2(v58));
    sub_38438(7, s, 0);
  }
  if ( (v37 & 2) != 0 && v38 <= 0x64 )
    sub_3DA40(v38);
  else
    sub_3DB30();
  if ( (v37 & 4) != 0 )
  {
    if ( HIWORD(v60) )
    {
      LODWORD(flt_C4BEC) = HIBYTE(v60) + 1000 * BYTE2(v60);
    }
    else
    {
      if ( byte_632F0 || (v39 = (unsigned __int8)byte_630C0, byte_630C0) || dword_60964 > 4 )
      {
        snprintf(s, 0x800u, "frequency = '%d'", (unsigned __int16)word_C5492);
        sub_38438(5, s, 0);
        v39 = (unsigned __int8)byte_632F0;
      }
      v40 = (unsigned int)(268435456.0
                         / (double)sub_48F88(256, (unsigned __int8)byte_C548C)
                         / (double)(1000000 * (unsigned __int16)word_C5492)
                         * 0.95
                         * 2500.0);
      LODWORD(flt_C4BEC) = v40;
      if ( v39 || byte_630C0 || dword_60964 > 4 )
      {
        snprintf(s, 0x800u, "dev.timeout = %d", v40);
        sub_38438(5, s, 0);
      }
    }
  }
  sub_40128();
  sub_406DC();
  sub_3FFAC();
  if ( byte_632F0 || byte_630C0 || dword_60964 > 4 )
  {
    strcpy(s, "send cmd to open block");
    sub_38438(5, s, 0);
  }
  sub_3FE10(0, 0, 1u);
  sub_40D00(0xFFu);
  sub_2B21C();
  dword_6A4B0 = (int)calloc(1u, 0x40u);
  if ( sub_2F0EC(dword_6A4B0, 0, (void *(*)(void *))sub_3A788, (void *)dword_6A4B0) )
    goto LABEL_111;
  dword_66EAC = (int)calloc(1u, 0x40u);
  if ( sub_2F0EC(dword_66EAC, 0, (void *(*)(void *))sub_3F0B0, (void *)dword_66EAC) )
  {
    if ( !byte_630C1 || !byte_632F0 && !byte_630C0 && dword_60964 <= 6 )
      return -7;
    snprintf(s, 0x800u, "%s: create thread for read temp", "bitmain_L3_init");
    sub_38438(7, s, 0);
    return -7;
  }
  pthread_detach(*(_DWORD *)(dword_66EAC + 12));
  sleep(2u);
  dword_65E48 = (int)calloc(1u, 0x40u);
  if ( sub_2F0EC(dword_65E48, 0, (void *(*)(void *))sub_3DE5C, (void *)dword_65E48) )
  {
LABEL_111:
    if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
    {
      snprintf(s, 0x800u, "%s: create thread for check miner_status", "bitmain_L3_init");
      sub_38438(7, s, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_65E48 + 12));
    dword_65E3C = (int)calloc(1u, 0x40u);
    if ( sub_2F0EC(dword_65E3C, 0, (void *(*)(void *))sub_3F138, (void *)dword_65E3C) )
    {
      if ( byte_630C1 && (byte_632F0 || byte_630C0 || dword_60964 > 6) )
      {
        snprintf(s, 0x800u, "%s: create thread for get hashrate from asic failed", "bitmain_L3_init");
        sub_38438(7, s, 0);
        return -6;
      }
      else
      {
        return -6;
      }
    }
    else
    {
      v41 = 0;
      pthread_detach(*(_DWORD *)(dword_65E3C + 12));
      do
      {
        v42 = v52 + 1;
        if ( *(unsigned __int8 *)++v52 )
        {
          v44 = *(unsigned __int8 *)(v42 + 2174);
          if ( *(_BYTE *)(v42 + 2174) )
          {
            v45 = 0;
            v53 = v41;
            v46 = (char *)&unk_C4BCC + 288 * v41 + 644;
            v47 = 0;
            v48 = (char *)&unk_C4BCC + 88 * v41;
            v49 = v46;
            do
            {
              if ( (v47 & 7) == 0 )
              {
                v50 = v47 + v45;
                if ( v47 + v45 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
                {
                  snprintf(s, 0x800u, "offset[%d] ERR", v47 + v45);
                  sub_38438(3, s, 0);
                }
                ++v45;
                v48[v50 + 1800] = 32;
              }
              v51 = v47 + v45;
              if ( v47 + v45 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
              {
                snprintf(s, 0x800u, "offset[%d] ERR", v47 + v45);
                sub_38438(3, s, 0);
              }
              ++v47;
              v48[v51 + 1800] = 111;
              *((_DWORD *)v49 + 1) = 0;
              v49 += 4;
            }
            while ( *(unsigned __int8 *)(v52 + 2174) > v47 );
            v44 = v45 + v47;
            v41 = v53;
            if ( v44 > 88 && (byte_632F0 || byte_630C0 || dword_60964 > 2) )
            {
              snprintf(s, 0x800u, "offset[%d] ERR", v44);
              sub_38438(3, s, 0);
            }
          }
          *((_BYTE *)&unk_C4BCC + 88 * v41 + v44 + 1800) = 0;
        }
        ++v41;
      }
      while ( v41 != 4 );
      byte_63150 = 1;
      return 0;
    }
  }
}
// 42C4C: variable 'v34' is possibly undefined
// 42C50: variable 'v35' is possibly undefined
// 60964: using guessed type int dword_60964;
// 62E48: using guessed type int dword_62E48;
// 630C0: using guessed type char byte_630C0;
// 630C1: using guessed type char byte_630C1;
// 63150: using guessed type char byte_63150;
// 63174: using guessed type char byte_63174;
// 632F0: using guessed type char byte_632F0;
// 65E3C: using guessed type int dword_65E3C;
// 65E48: using guessed type int dword_65E48;
// 66EAC: using guessed type int dword_66EAC;
// 6A4B0: using guessed type int dword_6A4B0;
// 6A4B4: using guessed type int dword_6A4B4;
// C4BC8: using guessed type int dword_C4BC8;
// C4BEC: using guessed type float flt_C4BEC;
// C5462: using guessed type char byte_C5462;
// C5463: using guessed type char byte_C5463;
// C5464: using guessed type char byte_C5464;
// C5465: using guessed type char byte_C5465;
// C548B: using guessed type char byte_C548B;
// C548C: using guessed type char byte_C548C;
// C5490: using guessed type char byte_C5490;
// C5491: using guessed type char byte_C5491;
// C5492: using guessed type __int16 word_C5492;

//----- (000434FC) --------------------------------------------------------
int __fastcall sub_434FC(int a1)
{
  int v1; // r4
  int v2; // r1
  _DWORD *v3; // r2
  unsigned int v4; // r3
  int v5; // t1
  _DWORD *v6; // r12
  _DWORD *v7; // r5
  _DWORD *v8; // lr
  int v9; // r1
  int v10; // r2
  int v11; // r3
  _DWORD v13[2]; // [sp+4h] [bp-28h] BYREF
  char v14; // [sp+Ch] [bp-20h]
  char v15; // [sp+Dh] [bp-1Fh]
  __int16 v16; // [sp+Eh] [bp-1Eh]
  char v17; // [sp+10h] [bp-1Ch]
  char v18; // [sp+11h] [bp-1Bh]
  char v19; // [sp+12h] [bp-1Ah]
  char v20[4]; // [sp+13h] [bp-19h] BYREF
  char v21[5]; // [sp+17h] [bp-15h] BYREF
  int v22; // [sp+1Ch] [bp-10h]
  int v23; // [sp+20h] [bp-Ch]
  _DWORD v24[2]; // [sp+24h] [bp-8h] BYREF

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20);
  *(_DWORD *)(v1 + 703) = a1;
  if ( pthread_mutex_init((pthread_mutex_t *)(v1 + 743), 0) )
    sub_B988(3756);
  if ( pthread_mutex_init((pthread_mutex_t *)v1, 0) )
    sub_B988(3757);
  sub_3B068((pthread_rwlock_t *)(v1 + 24));
  v2 = 81;
  v16 = 0;
  v3 = v13;
  v19 = dword_60E44;
  v4 = 255;
  v14 = ~(~(((2 * (byte_63230 & 1)) | 1u) << 30) >> 30);
  v22 = 0;
  v13[1] = &loc_1C200;
  v13[0] = 1572945;
  v15 = 15;
  v17 = 6;
  v18 = 72;
  strcpy(v20, "Pd");
  v20[3] = 7;
  strcpy(v21, "%\n\n");
  v21[4] = 0;
  v23 = 26214404;
  v24[0] = 600;
  while ( 1 )
  {
    LOWORD(v4) = *(_WORD *)&aBitmainL3Detec_0[2 * (v2 ^ (v4 >> 8)) + 928] ^ ((_WORD)v4 << 8);
    if ( v3 == (_DWORD *)((char *)v24 + 1) )
      break;
    v5 = *((unsigned __int8 *)v3 + 1);
    v3 = (_DWORD *)((char *)v3 + 1);
    v2 = v5;
  }
  v6 = (_DWORD *)(v1 + 767);
  v7 = v13;
  HIWORD(v24[0]) = v4;
  do
  {
    v8 = v7;
    v7 += 4;
    v9 = v8[1];
    v10 = v8[2];
    v11 = v8[3];
    *v6 = *v8;
    v6[1] = v9;
    v6[2] = v10;
    v6[3] = v11;
    v6 += 4;
  }
  while ( v8 + 4 != v24 );
  *v6 = *v7;
  sub_42584(v1);
  return 1;
}
// 60E44: using guessed type int dword_60E44;
// 63230: using guessed type char byte_63230;

//----- (000436C0) --------------------------------------------------------
int __fastcall compar(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 < *a2 )
    return -1;
  else
    return *a1 != *a2;
}

//----- (000436E4) --------------------------------------------------------
int __fastcall sub_436E4(char *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4)
{
  char *v8; // r0
  int v9; // r1
  char *v10; // r6
  char *v11; // r5
  char *v13; // r0
  bool v14; // zf
  unsigned int v15; // r2
  int v16; // r3
  int v17; // [sp+4h] [bp-18h] BYREF
  char s[20]; // [sp+8h] [bp-14h] BYREF

  if ( !((int (__fastcall *)(const char *, int))a2)("\"", 1) )
  {
    while ( 1 )
    {
      v10 = a1;
      while ( *a1 )
      {
        v13 = sub_46490(a1, &v17);
        v11 = v13;
        if ( !v13 )
          return -1;
        v14 = v17 == 92;
        if ( v17 != 92 )
          v14 = v17 == 34;
        if ( v14 || v17 <= 31 || (a4 & 0x400) != 0 && v17 == 47 || (a4 & 0x40) != 0 && v17 > 127 )
          goto LABEL_13;
        a1 = v13;
      }
      v11 = a1;
LABEL_13:
      if ( a1 != v10 && a2(v10, a1 - v10, a3) )
        return -1;
      if ( v11 == a1 )
        return a2((char *)"\"", 1, a3);
      if ( v17 == 12 )
      {
        v9 = 2;
        v8 = "\\f";
        goto LABEL_8;
      }
      if ( v17 <= 12 )
        break;
      if ( v17 == 34 )
      {
        v8 = "\\\"";
        v9 = 2;
        goto LABEL_8;
      }
      if ( v17 > 34 )
      {
        if ( v17 == 47 )
        {
          v9 = 2;
          v8 = "\\/";
        }
        else
        {
          if ( v17 == 92 )
          {
            v9 = 2;
            v8 = "\\\\";
            goto LABEL_8;
          }
LABEL_6:
          if ( v17 >= 0x10000 )
          {
            v15 = ((unsigned int)(v17 - 0x10000) >> 10) & 0x3FF | 0xD800;
            v16 = (v17 - 0x10000) & 0x3FF | 0xDC00;
            v17 -= 0x10000;
            sprintf(s, "\\u%04x\\u%04x", v15, v16);
            v8 = s;
            v9 = 12;
          }
          else
          {
            sprintf(s, "\\u%04x", v17);
            v8 = s;
            v9 = 6;
          }
        }
        goto LABEL_8;
      }
      if ( v17 != 13 )
        goto LABEL_6;
      if ( a2("\\r", 2, a3) )
        return -1;
LABEL_9:
      a1 = v11;
    }
    switch ( v17 )
    {
      case 9:
        v9 = 2;
        v8 = "\\t";
        break;
      case 10:
        v9 = 2;
        v8 = "\\n";
        break;
      case 8:
        v9 = 2;
        v8 = "\\b";
        break;
      default:
        goto LABEL_6;
    }
LABEL_8:
    if ( !a2(v8, v9, a3) )
      goto LABEL_9;
  }
  return -1;
}

//----- (00043908) --------------------------------------------------------
int __fastcall sub_43908(int a1, int a2)
{
  return strcmp(*(const char **)(a1 + 4), *(const char **)(a2 + 4));
}

//----- (00043914) --------------------------------------------------------
int __fastcall sub_43914(const void *a1, size_t a2, FILE *s)
{
  if ( fwrite(a1, a2, 1u, s) == 1 )
    return 0;
  else
    return -1;
}

//----- (00043934) --------------------------------------------------------
int __fastcall sub_43934(void *src, size_t n, const void **a3)
{
  return sub_45F28(a3, src, n);
}

//----- (0004394C) --------------------------------------------------------
int __fastcall sub_4394C(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int v5; // r8
  int v9; // r4

  v5 = a1 & 0x1F;
  if ( (a1 & 0x1F) != 0 )
  {
    if ( !a4(ptr, 1, a5) )
    {
      if ( a2 <= 0 )
        return 0;
      v9 = 0;
      while ( 1 )
      {
        ++v9;
        if ( a4("                                ", v5, a5) )
          break;
        if ( v9 == a2 )
          return 0;
      }
    }
    return -1;
  }
  else
  {
    if ( !a3 || (a1 & 0x20) != 0 )
      return 0;
    return a4(" ", 1, a5);
  }
}

//----- (000439F0) --------------------------------------------------------
int __fastcall sub_439F0(_DWORD *a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5)
{
  int (__fastcall *v7)(char *, int, int); // r4
  int v8; // r5
  __int64 v9; // r0
  int v10; // r1
  int result; // r0
  const char *v12; // r2
  int v13; // r11
  _DWORD *v14; // r8
  int v15; // r9
  int v16; // r10
  int v17; // r10
  char *v18; // r0
  int v19; // r0
  _DWORD *v20; // r9
  int v21; // r10
  signed int i; // r8
  _DWORD *v23; // r0
  char *v24; // r0
  char *v25; // r0
  int v26; // r5
  unsigned int v27; // r11
  char *v28; // r4
  char *v29; // r6
  unsigned int v30; // r8
  int (*v31)(const void *, const void *); // r3
  char *v32; // r11
  int v33; // r10
  char *v35; // [sp+Ch] [bp-88h]
  size_t nmemb; // [sp+10h] [bp-84h]
  void *base; // [sp+14h] [bp-80h]
  int v38; // [sp+18h] [bp-7Ch]
  unsigned int v39; // [sp+1Ch] [bp-78h]
  int v40; // [sp+20h] [bp-74h]
  int (__fastcall *v41)(char *, int, int); // [sp+24h] [bp-70h]
  char s[104]; // [sp+2Ch] [bp-68h] BYREF

  v7 = a4;
  v8 = a5;
  if ( !a1 )
    return -1;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v35 = (char *)v12;
      if ( a1[8] )
        goto LABEL_22;
      a1[8] = 1;
      v14 = sub_46714(a1);
      if ( v7("{", 1, a5) )
        goto LABEL_22;
      if ( v14 )
      {
        v15 = a3 + 1;
        v16 = sub_4394C(a2, a3 + 1, 0, (int (__fastcall *)(const char *, int, int))v7, a5);
        if ( !v16 )
        {
          if ( (a2 & 0x180) != 0 )
          {
            nmemb = (size_t)sub_4667C(a1);
            v25 = (char *)sub_45DE4(8 * nmemb);
            base = v25;
            if ( v25 )
            {
              v38 = v13;
              v41 = v7;
              v26 = (int)v14;
              v27 = 0;
              v40 = a2;
              v28 = v25;
              while ( 1 )
              {
                *(_DWORD *)&v28[v16] = sub_447B4(v26);
                v29 = &v28[v16];
                v16 += 8;
                *((_DWORD *)v29 + 1) = sub_4678C(v26);
                v26 = sub_46760(a1, v26);
                if ( !v26 )
                  break;
                ++v27;
              }
              v30 = 0;
              v8 = a5;
              v39 = v27;
              v7 = v41;
              if ( nmemb != v27 + 1 )
                _assert_fail("i == size", "dump.c", 0x141u, "do_dump");
              v31 = (int (*)(const void *, const void *))sub_43908;
              if ( (v40 & 0x80) == 0 )
                v31 = (int (*)(const void *, const void *))compar;
              qsort(base, nmemb, 8u, v31);
              if ( !nmemb )
              {
LABEL_65:
                sub_45E0C(base);
LABEL_43:
                a1[8] = 0;
                return v7((char *)"}", 1, v8);
              }
              while ( 1 )
              {
                v32 = (char *)*((_DWORD *)base + 2 * v30 + 1);
                v33 = sub_46698(a1, v32);
                if ( !v33 )
                  _assert_fail("value", "dump.c", 0x151u, "do_dump");
                sub_436E4(v32, v41, a5, v40);
                if ( v41(v35, v38, a5) || sub_439F0(v33, v40, v15, v41, a5) )
                  break;
                if ( v39 > v30 )
                {
                  if ( v41((char *)",", 1, a5)
                    || sub_4394C(v40, v15, 1, (int (__fastcall *)(const char *, int, int))v41, a5) )
                  {
                    break;
                  }
                }
                else if ( sub_4394C(v40, a3, 0, (int (__fastcall *)(const char *, int, int))v41, a5) )
                {
                  break;
                }
                if ( nmemb == ++v30 )
                  goto LABEL_65;
              }
              sub_45E0C(base);
            }
          }
          else
          {
            while ( 1 )
            {
              v17 = sub_46760(a1, (int)v14);
              v18 = (char *)sub_4678C((int)v14);
              sub_436E4(v18, v7, a5, a2);
              if ( v7(v35, v13, a5) )
                goto LABEL_22;
              v19 = sub_46798((int)v14);
              if ( sub_439F0(v19, a2, v15, v7, a5) )
                goto LABEL_22;
              if ( !v17 )
                break;
              if ( !v7((char *)",", 1, a5) )
              {
                v14 = (_DWORD *)v17;
                if ( !sub_4394C(a2, v15, 1, (int (__fastcall *)(const char *, int, int))v7, a5) )
                  continue;
              }
              goto LABEL_22;
            }
            if ( !sub_4394C(a2, a3, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
              goto LABEL_43;
          }
        }
LABEL_22:
        a1[8] = 0;
        return -1;
      }
      a1[8] = 0;
      result = v7((char *)"}", 1, a5);
      break;
    case 1:
      if ( a1[5] )
        goto LABEL_36;
      a1[5] = 1;
      v20 = sub_46864(a1);
      if ( v7("[", 1, a5) )
        goto LABEL_36;
      if ( !v20 )
        goto LABEL_44;
      v21 = a3 + 1;
      if ( sub_4394C(a2, a3 + 1, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
        goto LABEL_36;
      if ( (int)v20 <= 0 )
        goto LABEL_44;
      for ( i = 0; (_DWORD *)i != v20; ++i )
      {
        v23 = sub_46880(a1, i);
        if ( sub_439F0(v23, a2, v21, v7, a5) )
        {
LABEL_36:
          a1[5] = 0;
          return -1;
        }
        if ( (int)v20 - 1 > i )
        {
          if ( v7((char *)",", 1, a5) || sub_4394C(a2, v21, 1, (int (__fastcall *)(const char *, int, int))v7, a5) )
            goto LABEL_36;
        }
        else if ( sub_4394C(a2, a3, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
        {
          goto LABEL_36;
        }
      }
LABEL_44:
      a1[5] = 0;
      return v7((char *)word_56150, 1, a5);
    case 2:
      v24 = (char *)sub_469F0(a1);
      return sub_436E4(v24, v7, a5, a2);
    case 3:
      v9 = sub_46AC0((int)a1);
      v10 = snprintf(s, 0x64u, "%lld", v9);
      if ( (unsigned int)v10 > 0x63 )
        return -1;
      return v7(s, v10, a5);
    case 4:
      sub_46B70();
      v10 = sub_46120(s, 0x64u);
      if ( v10 < 0 )
        return -1;
      return v7(s, v10, a5);
    case 5:
      return a4("true", 4, a5);
    case 6:
      return a4("false", 5, a5);
    case 7:
      return a4("null", 4, a5);
    default:
      return -1;
  }
  return result;
}
// 43A1C: control flows out of bounds to 43A20

//----- (0004401C) --------------------------------------------------------
int __fastcall sub_4401C(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4)
{
  if ( (a4 & 0x200) != 0 || a1 && *a1 <= 1u )
    return sub_439F0(a1, a4, 0, a2, a3);
  else
    return -1;
}

//----- (00044068) --------------------------------------------------------
int __fastcall sub_44068(_DWORD *a1, int a2, __int16 a3)
{
  return sub_4401C(a1, (int (__fastcall *)(char *, int, int))sub_43914, a2, a3);
}

//----- (0004407C) --------------------------------------------------------
int __fastcall sub_4407C(_DWORD *a1, char *filename, __int16 a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = fopen(filename, "w");
  if ( !v5 )
    return -1;
  v6 = sub_44068(a1, (int)v5, a3);
  fclose(v5);
  return v6;
}

//----- (000440CC) --------------------------------------------------------
void *__fastcall sub_440CC(_DWORD *a1, __int16 a2)
{
  void *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (void *)sub_45E94(v7);
  if ( v4 )
    return 0;
  if ( !sub_4401C(a1, (int (__fastcall *)(char *, int, int))sub_43934, (int)v7, a2) )
  {
    v6 = (const char *)sub_45F0C((int)v7);
    v4 = sub_45E2C(v6);
  }
  sub_45ECC((int)v7);
  return v4;
}

//----- (00044138) --------------------------------------------------------
int __fastcall sub_44138(int result, int a2, _DWORD *a3)
{
  _DWORD *v3; // r3
  int v4; // r12
  int v5; // r3

  v3 = *(_DWORD **)a2;
  if ( *(_DWORD *)a2 == result + 12 && v3 == *(_DWORD **)(a2 + 4) )
  {
    v4 = *(_DWORD *)(result + 12);
    a3[1] = v3;
    *a3 = v4;
    v5 = *(_DWORD *)(result + 12);
    *(_DWORD *)(result + 12) = a3;
    *(_DWORD *)(v5 + 4) = a3;
    *(_DWORD *)(a2 + 4) = a3;
    *(_DWORD *)a2 = a3;
  }
  else
  {
    *a3 = *v3;
    a3[1] = v3;
    result = *v3;
    *v3 = a3;
    *(_DWORD *)(result + 4) = a3;
    *(_DWORD *)a2 = a3;
  }
  return result;
}

//----- (00044194) --------------------------------------------------------
int __fastcall sub_44194(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 - 4) != a4 || strcmp((const char *)(v4 + 16), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4 - 4;
}

//----- (0004420C) --------------------------------------------------------
void __fastcall sub_4420C(int a1)
{
  int v1; // r3
  int v2; // r6
  int v3; // r0
  void *v4; // r5
  int v5; // r4
  int v6; // r1

  v1 = *(_DWORD *)(a1 + 16);
  v2 = a1 + 12;
  if ( v1 != a1 + 12 )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 8);
      v4 = (void *)(v1 - 4);
      v5 = *(_DWORD *)(v1 + 4);
      if ( v3 )
      {
        v6 = *(_DWORD *)(v3 + 4);
        if ( v6 != -1 )
        {
          *(_DWORD *)(v3 + 4) = v6 - 1;
          if ( v6 == 1 )
            sub_46C5C();
        }
      }
      sub_45E0C(v4);
      v1 = v5;
    }
    while ( v5 != v2 );
  }
}
// 46C5C: using guessed type int sub_46C5C(void);

//----- (0004426C) --------------------------------------------------------
int __fastcall sub_4426C(_DWORD *a1)
{
  char *v2; // r2
  _DWORD *v3; // r1
  int v4; // r0
  int v5; // r12
  int v6; // r12
  int v7; // r3

  *a1 = 0;
  a1[2] = 0;
  v2 = (char *)sub_45DE4(0x28u);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1 + 3;
  v4 = a1[2];
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  v5 = dword_56E0C[v4];
  if ( v5 )
  {
    v6 = 8 * v5;
    v7 = 0;
    do
    {
      *(_DWORD *)&v2[v7 + 4] = v3;
      *(_DWORD *)&v2[v7] = v3;
      v7 += 8;
    }
    while ( v7 != v6 );
  }
  return 0;
}
// 56E0C: using guessed type _DWORD dword_56E0C[29];

//----- (000442EC) --------------------------------------------------------
void __fastcall sub_442EC(int a1)
{
  sub_4420C(a1);
  sub_45E0C(*(void **)(a1 + 4));
}

//----- (00044304) --------------------------------------------------------
int __fastcall sub_44304(int a1, char *a2, int a3, int a4)
{
  unsigned int v6; // r1
  char *v7; // r9
  int v8; // r12
  char *v9; // lr
  unsigned int v10; // r4
  int v11; // r5
  int v12; // t1
  int *v13; // r9
  int v14; // r0
  int v15; // r5
  int v16; // r0
  int v17; // r3
  int v18; // r3
  int v20; // r3
  unsigned int v21; // r4
  int v22; // r11
  int v23; // r3
  _DWORD *v24; // r10
  int v25; // r1
  _DWORD *v26; // r2
  size_t v27; // r0
  void *v28; // r0
  _DWORD *v29; // r11

  v6 = dword_56E0C[*(_DWORD *)(a1 + 8)];
  if ( *(_DWORD *)a1 >= v6 )
  {
    sub_45E0C(*(void **)(a1 + 4));
    v20 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v20;
    v21 = dword_56E0C[v20];
    v7 = (char *)sub_45DE4(8 * v21);
    *(_DWORD *)(a1 + 4) = v7;
    if ( !v7 )
      return -1;
    v6 = dword_56E0C[*(_DWORD *)(a1 + 8)];
    if ( v6 )
    {
      v22 = a1 + 12;
      v23 = 0;
      do
      {
        *(_DWORD *)&v7[v23 + 4] = v22;
        *(_DWORD *)&v7[v23] = v22;
        v23 += 8;
      }
      while ( v23 != 8 * v6 );
    }
    else
    {
      v22 = a1 + 12;
    }
    v24 = *(_DWORD **)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v22;
    *(_DWORD *)(a1 + 16) = v22;
    if ( v24 != (_DWORD *)v22 )
    {
      while ( 1 )
      {
        v25 = *(v24 - 1) % v21;
        v26 = v24;
        v24 = (_DWORD *)v24[1];
        sub_44138(a1, (int)&v7[8 * v25], v26);
        if ( (_DWORD *)v22 == v24 )
          break;
        v7 = *(char **)(a1 + 4);
      }
      v7 = *(char **)(a1 + 4);
      v6 = dword_56E0C[*(_DWORD *)(a1 + 8)];
    }
  }
  else
  {
    v7 = *(char **)(a1 + 4);
  }
  v8 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v9 = a2;
    v10 = 5381;
    do
    {
      v11 = v8 + 32 * v10;
      v12 = (unsigned __int8)*++v9;
      v8 = v12;
      v10 += v11;
    }
    while ( v12 );
  }
  else
  {
    v10 = 5381;
  }
  v13 = (int *)&v7[8 * (v10 % v6)];
  v14 = sub_44194(a1, v13, a2, v10);
  v15 = v14;
  if ( !v14 )
  {
    v27 = strlen(a2);
    v28 = sub_45DE4(v27 + 21);
    v29 = v28;
    if ( v28 )
    {
      *(_DWORD *)v28 = v10;
      *((_DWORD *)v28 + 4) = a3;
      strcpy((char *)v28 + 20, a2);
      v29[2] = v29 + 1;
      v29[3] = a4;
      v29[1] = v29 + 1;
      sub_44138(a1, (int)v13, v29 + 1);
      ++*(_DWORD *)a1;
      return 0;
    }
    return -1;
  }
  v16 = *(_DWORD *)(v14 + 12);
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4);
    if ( v17 != -1 )
    {
      v18 = v17 - 1;
      *(_DWORD *)(v16 + 4) = v18;
      if ( !v18 )
        sub_46C5C((void **)v16);
    }
  }
  *(_DWORD *)(v15 + 12) = a4;
  return 0;
}
// 56E0C: using guessed type _DWORD dword_56E0C[29];

//----- (0004450C) --------------------------------------------------------
int __fastcall sub_4450C(int a1, char *a2)
{
  int v2; // r3
  char *v3; // r12
  unsigned int v4; // r4
  int v5; // lr
  int v6; // t1
  int result; // r0

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v3 = a2;
    v4 = 5381;
    do
    {
      v5 = v2 + 32 * v4;
      v6 = (unsigned __int8)*++v3;
      v2 = v6;
      v4 += v5;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  result = sub_44194(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v4 % dword_56E0C[*(_DWORD *)(a1 + 8)])), a2, v4);
  if ( result )
    return *(_DWORD *)(result + 12);
  return result;
}
// 56E0C: using guessed type _DWORD dword_56E0C[29];

//----- (00044584) --------------------------------------------------------
int __fastcall sub_44584(_DWORD *a1, char *a2)
{
  int v2; // r3
  char *v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  int v7; // t1
  int v8; // r7
  int *v9; // r6
  int v10; // r8
  _DWORD *v11; // r0
  _DWORD *v12; // r4
  _DWORD *v13; // r3
  int v14; // r2
  int v15; // r3
  int v16; // r0
  int v17; // r3
  int v18; // r3
  _DWORD *v20; // r3

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v4 = a2;
    v5 = 5381;
    do
    {
      v6 = v2 + 32 * v5;
      v7 = (unsigned __int8)*++v4;
      v2 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  else
  {
    v5 = 5381;
  }
  v8 = a1[1];
  v9 = (int *)(v8 + 8 * (v5 % dword_56E0C[a1[2]]));
  v10 = v5 % dword_56E0C[a1[2]];
  v11 = (_DWORD *)sub_44194((int)a1, v9, a2, v5);
  v12 = v11;
  if ( !v11 )
    return -1;
  v13 = v11 + 1;
  v14 = v9[1];
  if ( v11 + 1 == *(_DWORD **)(v8 + 8 * v10) )
  {
    if ( v13 == (_DWORD *)v14 )
    {
      v20 = a1 + 3;
      v9[1] = (int)(a1 + 3);
    }
    else
    {
      v20 = (_DWORD *)v11[2];
    }
    *(_DWORD *)(v8 + 8 * v10) = v20;
  }
  else if ( v13 == (_DWORD *)v14 )
  {
    v9[1] = v11[1];
  }
  v15 = v11[1];
  v16 = v11[3];
  *(_DWORD *)(v15 + 4) = v12[2];
  *(_DWORD *)v12[2] = v15;
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4);
    if ( v17 != -1 )
    {
      v18 = v17 - 1;
      *(_DWORD *)(v16 + 4) = v18;
      if ( !v18 )
        sub_46C5C((void **)v16);
    }
  }
  sub_45E0C(v12);
  --*a1;
  return 0;
}
// 56E0C: using guessed type _DWORD dword_56E0C[29];

//----- (000446A0) --------------------------------------------------------
void __fastcall sub_446A0(_DWORD *a1)
{
  int v2; // r4
  int v3; // r1
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r3

  sub_4420C((int)a1);
  v2 = dword_56E0C[a1[2]];
  if ( v2 )
  {
    v3 = a1[1];
    v4 = 8 * v2;
    v5 = a1 + 3;
    v6 = 0;
    do
    {
      *(_DWORD *)(v3 + v6 + 4) = v5;
      *(_DWORD *)(v3 + v6) = v5;
      v6 += 8;
    }
    while ( v6 != v4 );
  }
  else
  {
    v5 = a1 + 3;
  }
  a1[4] = v5;
  a1[3] = v5;
  *a1 = 0;
}
// 56E0C: using guessed type _DWORD dword_56E0C[29];

//----- (0004471C) --------------------------------------------------------
int __fastcall sub_4471C(int a1, char *a2)
{
  int v2; // r3
  char *v3; // r12
  unsigned int v4; // r4
  int v5; // lr
  int v6; // t1
  int result; // r0

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v3 = a2;
    v4 = 5381;
    do
    {
      v5 = v2 + 32 * v4;
      v6 = (unsigned __int8)*++v3;
      v2 = v6;
      v4 += v5;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  result = sub_44194(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v4 % dword_56E0C[*(_DWORD *)(a1 + 8)])), a2, v4);
  if ( result )
    result += 4;
  return result;
}
// 56E0C: using guessed type _DWORD dword_56E0C[29];

//----- (000447B4) --------------------------------------------------------
int __fastcall sub_447B4(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000447C4) --------------------------------------------------------
void __fastcall sub_447C4(int a1, int a2)
{
  int v3; // r0
  int v5; // r2
  int v6; // r2

  v3 = *(_DWORD *)(a1 + 8);
  if ( !v3 || (v5 = *(_DWORD *)(v3 + 4), v5 == -1) || (v6 = v5 - 1, (*(_DWORD *)(v3 + 4) = v6) != 0) )
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  else
  {
    sub_46C5C((void **)v3);
    *(_DWORD *)(a1 + 8) = a2;
  }
}

//----- (0004480C) --------------------------------------------------------
int __fastcall sub_4480C(_DWORD *a1)
{
  int v1; // r2
  int result; // r0

  v1 = a1[1];
  result = *(unsigned __int8 *)(*a1 + v1);
  if ( !result )
    return -1;
  a1[1] = v1 + 1;
  return result;
}

//----- (0004482C) --------------------------------------------------------
int __fastcall sub_4482C(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r2
  int v3; // r3

  v1 = a1[2];
  if ( v1 >= a1[1] )
    return -1;
  v2 = v1 + 1;
  v3 = *(unsigned __int8 *)(*a1 + v1);
  a1[2] = v2;
  return v3;
}

//----- (00044850) --------------------------------------------------------
int __fastcall sub_44850(_DWORD *a1)
{
  unsigned int v1; // r3
  int result; // r0
  int (__fastcall *v4)(_DWORD *, int, _DWORD); // r3
  int v5; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_2;
  v4 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v5 = v4(a1, 1024, a1[259]);
  a1[256] = v5;
  if ( (unsigned int)(v5 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_2:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (000448AC) --------------------------------------------------------
int sub_448AC(int result, _DWORD *a2, const char *a3, ...)
{
  int v3; // r5
  const char *v5; // r0
  int v6; // r10
  int v7; // r6
  int v8; // r8
  char *v9; // r3
  char s[160]; // [sp+10h] [bp-144h] BYREF
  char v11[159]; // [sp+B0h] [bp-A4h] BYREF
  char v12; // [sp+14Fh] [bp-5h]
  const char *varg_r2; // [sp+170h] [bp+1Ch]
  va_list varg_r3; // [sp+174h] [bp+20h] BYREF

  va_start(varg_r3, a3);
  varg_r2 = a3;
  v3 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r2, varg_r3);
    s[159] = 0;
    if ( a2 )
    {
      v5 = (const char *)sub_45F0C((int)(a2 + 10));
      v6 = a2[6];
      v7 = a2[7];
      v8 = a2[9];
      if ( v5 && *v5 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v11, 0xA0u, "%s near '%s'", s, v5);
          v9 = v11;
          v12 = 0;
        }
        else
        {
          v9 = s;
        }
      }
      else
      {
        v9 = s;
        if ( a2[5] != -2 )
        {
          snprintf(v11, 0xA0u, "%s near end of file", s);
          v9 = v11;
          v12 = 0;
        }
      }
    }
    else
    {
      v7 = -1;
      v9 = s;
      v8 = 0;
      v6 = -1;
    }
    return sub_47910(v3, v6, v7, v8, (char *)"%s", v9);
  }
  return result;
}

//----- (000449CC) --------------------------------------------------------
int __fastcall sub_449CC(int a1, int a2, int a3)
{
  int result; // r0
  int v5; // r3
  bool v6; // zf

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 24) = 1;
  result = sub_45E94((_DWORD *)(a1 + 40));
  v6 = result == 0;
  if ( result )
    result = -1;
  else
    v5 = -1;
  if ( v6 )
    *(_DWORD *)(a1 + 52) = v5;
  return result;
}
// 44A10: variable 'v5' is possibly undefined

//----- (00044A18) --------------------------------------------------------
void __fastcall sub_44A18(int a1)
{
  if ( *(_DWORD *)(a1 + 52) == 256 )
    sub_45E0C(*(void **)(a1 + 56));
  sub_45ECC(a1 + 40);
}

//----- (00044A44) --------------------------------------------------------
int __fastcall sub_44A44(_BYTE *a1)
{
  int v1; // r1
  int i; // r3
  int v3; // r2
  int v4; // r4
  int v5; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x120u, "decode_unicode_escape");
  v1 = 0;
  for ( i = 1; i != 5; ++i )
  {
    v3 = (unsigned __int8)a1[i];
    v4 = 16 * v1;
    v5 = v3 - 48;
    if ( (unsigned __int8)(v3 - 48) <= 9u )
      goto LABEL_7;
    if ( (unsigned int)(v3 - 97) <= 0x19 )
    {
      v5 = v3 - 87;
LABEL_7:
      v1 = v5 + v4;
      continue;
    }
    if ( (unsigned int)(v3 - 65) > 0x19 )
      _assert_fail(word_50574, "load.c", 0x12Cu, "decode_unicode_escape");
    v1 = v3 - 55 + v4;
  }
  return v1;
}

//----- (00044AEC) --------------------------------------------------------
_DWORD *__fastcall sub_44AEC(_DWORD *result, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r3

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      v6 = result[6];
      result[7] = result[8];
      result[6] = v6 - 1;
    }
    else
    {
      result = (_DWORD *)sub_4633C((unsigned __int8)a2);
      if ( result )
        --v3[7];
    }
    v4 = v3[4];
    if ( !v4 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xE0u, "stream_unget");
    v5 = v4 - 1;
    v3[4] = v5;
    if ( *((unsigned __int8 *)v3 + v5 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (00044BA4) --------------------------------------------------------
int __fastcall sub_44BA4(int a1, int a2)
{
  int v3; // r5
  int v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r7
  bool v13; // cc
  int v14; // r0
  int v15; // r10
  int v16; // r5
  int v17; // r8
  int v18; // r1
  int v19; // r3

  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
    return v3;
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(unsigned __int8 *)(a1 + v5 + 8);
  if ( v6 )
  {
    v7 = v5 + 1;
    goto LABEL_5;
  }
  v6 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v12 = v6;
  if ( v6 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return -1;
  }
  *(_DWORD *)(a1 + 16) = 0;
  v13 = (unsigned int)(v6 - 128) > 0x7F;
  v6 = (unsigned __int8)v6;
  if ( v13 )
    *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 8) = v6;
  if ( v13 )
  {
    v7 = 1;
  }
  else
  {
    v14 = sub_4633C((unsigned __int8)v6);
    v15 = v14;
    if ( !v14 )
      goto LABEL_23;
    if ( v14 <= 1 )
      _assert_fail("count >= 2", "load.c", 0xAFu, "stream_get");
    v16 = a1;
    v17 = a1 - 1 + v14;
    do
    {
      *(_BYTE *)(v16 + 9) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
      ++v16;
    }
    while ( v16 != v17 );
    if ( !sub_463B8((char *)(a1 + 8), v15, 0) )
    {
LABEL_23:
      v3 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_448AC(a2, (_DWORD *)a1, "unable to decode byte 0x%x", v12);
      return v3;
    }
    v18 = *(_DWORD *)(a1 + 16);
    v19 = a1 + v18;
    *(_BYTE *)(a1 + v15 + 8) = 0;
    v7 = v18 + 1;
    v6 = *(unsigned __int8 *)(v19 + 8);
  }
LABEL_5:
  v8 = *(_DWORD *)(a1 + 36);
  v3 = v6;
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 36) = v8 + 1;
  if ( v6 != 10 )
  {
    if ( sub_4633C(v6) )
      ++*(_DWORD *)(a1 + 28);
    return v3;
  }
  v10 = *(_DWORD *)(a1 + 28);
  v11 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = v10;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  return 10;
}

//----- (00044D28) --------------------------------------------------------
_DWORD *__fastcall sub_44D28(_DWORD *result, int a2)
{
  _DWORD *v3; // r5
  int v4; // r1
  int v5; // r2

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    sub_44AEC(result, a2);
    result = (_DWORD *)sub_46038(v3 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}
// 44D48: variable 'v4' is possibly undefined
// 44D48: variable 'v5' is possibly undefined

//----- (00044D74) --------------------------------------------------------
int __fastcall sub_44D74(int a1, int a2)
{
  int v3; // r4

  v3 = sub_44BA4(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    DataWriter::WriteByte((const void **)(a1 + 40), v3);
  return v3;
}

//----- (00044DA4) --------------------------------------------------------
unsigned int __fastcall sub_44DA4(int a1, int a2)
{
  const void **v2; // r7
  int v5; // r0
  bool v6; // zf
  unsigned int v7; // r4
  bool v8; // zf
  bool v9; // zf
  bool v10; // zf
  bool v11; // zf
  bool v12; // cc
  unsigned __int8 i; // r1
  int v14; // r2
  int v15; // r3
  int v17; // r0
  const char *v18; // r4
  int v19; // r0
  bool v20; // zf
  const char *v21; // r4
  int *v22; // r7
  __int64 v23; // r2
  int v24; // r0
  int v25; // r1
  unsigned int v26; // r4
  int v27; // r0
  bool v28; // zf
  bool v29; // zf
  bool v30; // zf
  double v31; // r2
  bool v32; // zf
  int v33; // r8
  bool v34; // cc
  _BYTE *v35; // r0
  _BYTE *v36; // r8
  unsigned __int8 *v37; // r7
  int v38; // r2
  unsigned int v39; // r2
  int v40; // r0
  int v41; // r2
  int v42; // r0
  int v43; // r0
  int v44; // [sp+8h] [bp-24h]
  int v45; // [sp+Ch] [bp-20h]
  _BYTE src[4]; // [sp+14h] [bp-18h] BYREF
  size_t n; // [sp+18h] [bp-14h] BYREF
  char *endptr; // [sp+1Ch] [bp-10h] BYREF
  double v49; // [sp+20h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  sub_45EF8(a1 + 40);
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    sub_45E0C(*(void **)(a1 + 56));
    *(_DWORD *)(a1 + 56) = 0;
  }
  while ( 1 )
  {
    v5 = sub_44BA4(a1, a2);
    v6 = v5 == 32;
    if ( v5 != 32 )
      v6 = v5 == 9;
    v7 = v5;
    if ( !v6 )
    {
      v8 = v5 == 10;
      if ( v5 != 10 )
        v8 = v5 == 13;
      if ( !v8 )
        break;
    }
  }
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 52) = 0;
    return 0;
  }
  if ( v5 == -2 )
  {
LABEL_33:
    v7 = -1;
LABEL_34:
    *(_DWORD *)(a1 + 52) = v7;
    return v7;
  }
  DataWriter::WriteByte(v2, v5);
  v9 = v7 == 123;
  if ( v7 != 123 )
    v9 = v7 == 125;
  if ( v9 )
    goto LABEL_34;
  v10 = v7 == 91;
  if ( v7 != 91 )
    v10 = v7 == 93;
  if ( v10 )
    goto LABEL_34;
  v11 = v7 == 58;
  if ( v7 != 58 )
    v11 = v7 == 44;
  if ( v11 )
    goto LABEL_34;
  if ( v7 != 34 )
  {
    v12 = v7 > 0x2D;
    if ( v7 != 45 )
      v12 = v7 - 48 > 9;
    if ( !v12 )
    {
      *(_DWORD *)(a1 + 52) = -1;
      if ( v7 == 45 )
        v7 = sub_44D74(a1, a2);
      if ( v7 == 48 )
      {
        v19 = sub_44D74(a1, a2);
        if ( (unsigned int)(v19 - 48) <= 9 )
          goto LABEL_97;
      }
      else
      {
        if ( v7 - 48 > 9 )
        {
          sub_44D28((_DWORD *)a1, v7);
          return *(_DWORD *)(a1 + 52);
        }
        do
          v19 = sub_44D74(a1, a2);
        while ( (unsigned int)(v19 - 48) <= 9 );
      }
      v20 = v19 == 69;
      if ( v19 != 69 )
        v20 = v19 == 46;
      if ( v20 )
      {
        if ( v19 == 46 )
        {
          v43 = sub_44BA4(a1, a2);
          if ( (unsigned int)(v43 - 48) > 9 )
          {
            sub_44AEC((_DWORD *)a1, v43);
            return *(_DWORD *)(a1 + 52);
          }
          DataWriter::WriteByte(v2, v43);
          do
            v19 = sub_44D74(a1, a2);
          while ( (unsigned int)(v19 - 48) <= 9 );
        }
        if ( (v19 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_79;
      }
      else if ( v19 != 101 )
      {
        sub_44D28((_DWORD *)a1, v19);
        v21 = (const char *)sub_45F0C((int)v2);
        v22 = _errno_location();
        *v22 = 0;
        v23 = strtoll(v21, &endptr, 10);
        if ( *v22 == 34 )
        {
          if ( v23 >= 0 )
            sub_448AC(a2, (_DWORD *)a1, "too big integer");
          else
            sub_448AC(a2, (_DWORD *)a1, "too big negative integer");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          if ( endptr != &v21[*(_DWORD *)(a1 + 44)] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x206u, "lex_scan_number");
          *(_QWORD *)(a1 + 56) = v23;
          v7 = 257;
          *(_DWORD *)(a1 + 52) = 257;
        }
        return v7;
      }
      v19 = sub_44D74(a1, a2);
      v32 = v19 == 43;
      if ( v19 != 43 )
        v32 = v19 == 45;
      if ( v32 )
        v19 = sub_44D74(a1, a2);
      if ( (unsigned int)(v19 - 48) <= 9 )
      {
        do
          v19 = sub_44D74(a1, a2);
        while ( (unsigned int)(v19 - 48) <= 9 );
LABEL_79:
        sub_44D28((_DWORD *)a1, v19);
        if ( sub_46060((int)v2, &v49) )
        {
          sub_448AC(a2, (_DWORD *)a1, "real number overflow");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          v31 = v49;
          v7 = 258;
          *(_DWORD *)(a1 + 52) = 258;
          *(double *)(a1 + 56) = v31;
        }
        return v7;
      }
LABEL_97:
      sub_44D28((_DWORD *)a1, v19);
      return *(_DWORD *)(a1 + 52);
    }
    if ( (v7 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v17 = sub_44D74(a1, a2);
      while ( (v17 & 0xFFFFFFDF) - 65 <= 0x19 );
      sub_44D28((_DWORD *)a1, v17);
      v18 = (const char *)sub_45F0C((int)v2);
      if ( !strcmp(v18, "true") )
      {
        v7 = 259;
        *(_DWORD *)(a1 + 52) = 259;
        return v7;
      }
      if ( !strcmp(v18, "false") )
      {
        v7 = 260;
        *(_DWORD *)(a1 + 52) = 260;
        return v7;
      }
      if ( !strcmp(v18, "null") )
      {
        v7 = 261;
        *(_DWORD *)(a1 + 52) = 261;
        return v7;
      }
    }
    else
    {
      for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v15 + 8) )
      {
        DataWriter::WriteByte(v2, i);
        v14 = *(_DWORD *)(a1 + 36);
        v15 = *(_DWORD *)(a1 + 16) + 1;
        *(_DWORD *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) = v14 + 1;
      }
    }
    goto LABEL_33;
  }
  v24 = a1;
  v25 = a2;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 52) = -1;
LABEL_58:
  v26 = sub_44D74(v24, v25);
LABEL_59:
  while ( v26 != 34 )
  {
    if ( v26 == -2 )
      goto LABEL_104;
    if ( v26 == -1 )
    {
      sub_448AC(a2, (_DWORD *)a1, "premature end of input");
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v24 = a1;
    if ( v26 <= 0x1F )
    {
      sub_44D28((_DWORD *)a1, v26);
      if ( v26 == 10 )
        sub_448AC(a2, (_DWORD *)a1, "unexpected newline");
      else
        sub_448AC(a2, (_DWORD *)a1, "control character 0x%x", v26);
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v25 = a2;
    if ( v26 != 92 )
      goto LABEL_58;
    v27 = sub_44D74(a1, a2);
    if ( v27 == 117 )
    {
      v33 = 4;
      v26 = sub_44D74(a1, a2);
      while ( 1 )
      {
        v34 = v26 - 65 > 5;
        if ( v26 - 65 > 5 )
          v34 = v26 - 48 > 9;
        if ( v34 && v26 - 97 > 5 )
          break;
        --v33;
        v26 = sub_44D74(a1, a2);
        if ( !v33 )
          goto LABEL_59;
      }
LABEL_149:
      sub_448AC(a2, (_DWORD *)a1, "invalid escape");
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v28 = v27 == 34;
    if ( v27 != 34 )
      v28 = v27 == 92;
    if ( !v28 )
    {
      v29 = v27 == 47;
      if ( v27 != 47 )
        v29 = v27 == 98;
      if ( !v29 && (v27 & 0xFFFFFFF7) != 0x66 )
      {
        v30 = v27 == 114;
        if ( v27 != 114 )
          v30 = v27 == 116;
        if ( !v30 )
          goto LABEL_149;
      }
    }
    v26 = sub_44D74(a1, a2);
  }
  v35 = sub_45DE4(*(_DWORD *)(a1 + 44) + 1);
  v36 = v35;
  *(_DWORD *)(a1 + 56) = v35;
  if ( !v35 )
    goto LABEL_102;
  v37 = (unsigned __int8 *)(sub_45F0C((int)v2) + 1);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v38 = *v37;
        if ( v38 == 34 )
        {
          v7 = 256;
          *v36 = 0;
          *(_DWORD *)(a1 + 52) = 256;
          return v7;
        }
        if ( v38 == 92 )
          break;
        *v36++ = v38;
        ++v37;
      }
      v39 = v37[1];
      if ( v39 == 117 )
        break;
      if ( v39 == 102 )
      {
        *v36 = 12;
        goto LABEL_122;
      }
      if ( v39 > 0x66 )
      {
        switch ( v39 )
        {
          case 'r':
            *v36 = 13;
            break;
          case 't':
            *v36 = 9;
            break;
          case 'n':
            *v36 = 10;
            break;
          default:
            goto LABEL_117;
        }
      }
      else
      {
        if ( v39 == 92 )
          goto LABEL_135;
        if ( v39 <= 0x5C )
        {
          if ( v39 != 34 && v39 != 47 )
LABEL_117:
            _assert_fail(word_50574, "load.c", 0x1BCu, "lex_scan_string");
LABEL_135:
          *v36 = v39;
          goto LABEL_122;
        }
        if ( v39 != 98 )
          goto LABEL_117;
        *v36 = 8;
      }
LABEL_122:
      ++v36;
      v37 += 2;
    }
    v40 = sub_44A44(v37 + 1);
    v41 = v40;
    if ( (unsigned int)(v40 - 55296) > 0x3FF )
      break;
    if ( v37[6] != 92 || v37[7] != 117 )
    {
LABEL_103:
      sub_448AC(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X'", v40);
      goto LABEL_104;
    }
    v44 = v40 - 55296;
    v45 = v40;
    v42 = sub_44A44(v37 + 7);
    v37 += 12;
    if ( (unsigned int)(v42 - 56320) > 0x3FF )
    {
      sub_448AC(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X\\u%04X'", v45, v42);
      goto LABEL_104;
    }
    v41 = v42 - 56320 + (v44 << 10) + 0x10000;
LABEL_131:
    if ( sub_46254(v41, src, &n) )
      _assert_fail(word_50574, "load.c", 0x1AEu, "lex_scan_string");
    memcpy(v36, src, n);
    v36 += n;
  }
  if ( (unsigned int)(v40 - 56320) <= 0x3FF )
    goto LABEL_103;
  if ( v40 )
  {
    v37 += 6;
    goto LABEL_131;
  }
  sub_448AC(a2, (_DWORD *)a1, "\\u0000 is not allowed");
LABEL_104:
  v35 = *(_BYTE **)(a1 + 56);
LABEL_102:
  sub_45E0C(v35);
  return *(_DWORD *)(a1 + 52);
}
// 44DA4: too many cbuild loops

//----- (00045578) --------------------------------------------------------
int *__fastcall sub_45578(double a1, int a2)
{
  int v2; // r4
  int v3; // r3
  int v4; // r8
  int *v6; // r7
  int v8; // r3
  void *v9; // r10
  int v10; // r0
  int *v11; // r6
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int *v19; // r0
  int v20; // r3
  int v21; // r3
  void **v22; // r0
  double v23; // r0
  int v24; // r3
  int v25; // r3
  double v26; // [sp+0h] [bp-Ch] BYREF

  v2 = LODWORD(a1);
  v3 = *(_DWORD *)(LODWORD(a1) + 52);
  LODWORD(a1) = 257;
  v4 = HIDWORD(a1);
  if ( v3 != 257 )
  {
    if ( v3 > 257 )
    {
      if ( v3 == 259 )
        return (int *)sub_46C38();
      if ( v3 < 259 )
        return (int *)sub_46B14(a1);
      if ( v3 == 260 )
        return (int *)sub_46C44();
      if ( v3 == 261 )
        return (int *)sub_46C50();
LABEL_7:
      v6 = 0;
      sub_448AC(a2, (_DWORD *)v2, "unexpected token");
      return v6;
    }
    if ( v3 == 91 )
    {
      v6 = sub_467F8();
      if ( v6 )
      {
        sub_44DA4(v2, a2);
        v16 = *(_DWORD *)(v2 + 52);
        if ( v16 == 93 )
          return v6;
        if ( v16 )
        {
          while ( 1 )
          {
            v19 = (int *)sub_45578(v2, v4, a2);
            v11 = v19;
            if ( !v19 )
              break;
            if ( v19[1] != -1 )
              ++v19[1];
            if ( sub_46F60(v6, v19) )
            {
              v24 = v11[1];
              if ( v24 != -1 )
              {
LABEL_60:
                v25 = v24 - 1;
                v11[1] = v25;
                if ( !v25 )
                  sub_46C5C((void **)v11);
              }
              goto LABEL_49;
            }
            v17 = v11[1];
            if ( v17 != -1 )
            {
              v11[1] = v17 - 1;
              if ( v17 == 1 )
                sub_46C5C((void **)v11);
            }
            sub_44DA4(v2, a2);
            v18 = *(_DWORD *)(v2 + 52);
            if ( v18 != 44 )
            {
              if ( v18 == 93 )
                return v6;
              goto LABEL_63;
            }
            sub_44DA4(v2, a2);
            if ( !*(_DWORD *)(v2 + 52) )
              goto LABEL_63;
          }
        }
        else
        {
LABEL_63:
          sub_448AC(a2, (_DWORD *)v2, "']' expected");
        }
        goto LABEL_49;
      }
    }
    else
    {
      if ( v3 <= 91 )
      {
        if ( v3 == -1 )
        {
          v6 = 0;
          sub_448AC(a2, (_DWORD *)v2, "invalid token");
          return v6;
        }
        goto LABEL_7;
      }
      if ( v3 != 123 )
      {
        if ( v3 == 256 )
          return sub_46964(*(const char **)(v2 + 56));
        goto LABEL_7;
      }
      v6 = sub_46620();
      if ( v6 )
      {
        sub_44DA4(v2, a2);
        v8 = *(_DWORD *)(v2 + 52);
        if ( v8 == 125 )
          return v6;
        if ( v8 != 256 )
        {
LABEL_64:
          sub_448AC(a2, (_DWORD *)v2, "string or '}' expected");
          goto LABEL_49;
        }
        v9 = *(void **)(v2 + 56);
        *(_DWORD *)(v2 + 56) = 0;
        if ( v9 )
        {
          while ( 1 )
          {
            if ( (v4 & 1) != 0 && sub_46698(v6, (char *)v9) )
            {
              sub_45E0C(v9);
              sub_448AC(a2, (_DWORD *)v2, "duplicate object key");
              goto LABEL_49;
            }
            sub_44DA4(v2, a2);
            if ( *(_DWORD *)(v2 + 52) != 58 )
            {
              sub_45E0C(v9);
              sub_448AC(a2, (_DWORD *)v2, "':' expected");
              goto LABEL_49;
            }
            sub_44DA4(v2, a2);
            v10 = sub_45578(v2, v4, a2);
            v11 = (int *)v10;
            if ( !v10 )
            {
              sub_45E0C(v9);
              goto LABEL_49;
            }
            v12 = *(_DWORD *)(v10 + 4);
            if ( v12 != -1 )
              *(_DWORD *)(v10 + 4) = v12 + 1;
            if ( sub_47098(v6, (char *)v9, v10) )
            {
              sub_45E0C(v9);
              v24 = v11[1];
              if ( v24 != -1 )
                goto LABEL_60;
              goto LABEL_49;
            }
            v13 = v11[1];
            if ( v13 != -1 )
            {
              v14 = v13 - 1;
              v11[1] = v14;
              if ( !v14 )
                sub_46C5C((void **)v11);
            }
            sub_45E0C(v9);
            sub_44DA4(v2, a2);
            v15 = *(_DWORD *)(v2 + 52);
            if ( v15 != 44 )
              break;
            sub_44DA4(v2, a2);
            if ( *(_DWORD *)(v2 + 52) != 256 )
              goto LABEL_64;
            v9 = *(void **)(v2 + 56);
            *(_DWORD *)(v2 + 56) = 0;
            if ( !v9 )
              return 0;
          }
          if ( v15 == 125 )
            return v6;
          sub_448AC(a2, (_DWORD *)v2, "'}' expected");
LABEL_49:
          v20 = v6[1];
          if ( v20 != -1 )
          {
            v21 = v20 - 1;
            v6[1] = v21;
            if ( !v21 )
            {
              v22 = (void **)v6;
              v6 = 0;
              sub_46C5C(v22);
              return v6;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( (BYTE4(a1) & 8) == 0 )
    return (int *)sub_46A94(*(_QWORD *)(v2 + 56));
  LODWORD(v23) = sub_46060(v2 + 40, &v26);
  if ( !LODWORD(v23) )
    return (int *)sub_46B14(v23);
  v6 = 0;
  sub_448AC(a2, (_DWORD *)v2, "real number overflow");
  return v6;
}
// 45578: too many cbuild loops
// 4589C: variable 'v23' is possibly undefined

//----- (000459CC) --------------------------------------------------------
int *__fastcall sub_459CC(_DWORD *a1, unsigned int a2, int a3)
{
  int *v6; // r7
  int v8; // r3
  int v9; // r3
  void **v10; // r0

  sub_44DA4((int)a1, a3);
  v6 = (int *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[13] & 0xFFFFFFDF) != 0x5B )
  {
    sub_448AC(a3, a1, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_45578(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), a3);
  if ( !v6 )
    return 0;
  if ( (a2 & 2) == 0 )
  {
    sub_44DA4((int)a1, a3);
    if ( a1[13] )
    {
      sub_448AC(a3, a1, "end of file expected");
      v8 = v6[1];
      if ( v8 != -1 )
      {
        v9 = v8 - 1;
        v6[1] = v9;
        if ( !v9 )
        {
          v10 = (void **)v6;
          v6 = 0;
          sub_46C5C(v10);
          return v6;
        }
      }
      return 0;
    }
  }
  if ( a3 )
    *(_DWORD *)(a3 + 8) = a1[9];
  return v6;
}

//----- (00045AA8) --------------------------------------------------------
int *__fastcall sub_45AA8(int *a1, unsigned int a2, char *a3)
{
  _DWORD v7[2]; // [sp+0h] [bp-48h] BYREF
  _DWORD v8[16]; // [sp+8h] [bp-40h] BYREF

  sub_4788C(a3, "<string>");
  if ( a1 )
  {
    v7[0] = a1;
    a1 = 0;
    v7[1] = 0;
    if ( !sub_449CC((int)v8, (int)sub_4480C, (int)v7) )
    {
      a1 = sub_459CC(v8, a2, (int)a3);
      sub_44A18((int)v8);
    }
  }
  else
  {
    sub_448AC((int)a3, 0, "wrong arguments");
  }
  return a1;
}

//----- (00045B3C) --------------------------------------------------------
int *__fastcall sub_45B3C(int *a1, int a2, unsigned int a3, char *a4)
{
  _DWORD v9[3]; // [sp+4h] [bp-50h] BYREF
  _DWORD v10[17]; // [sp+10h] [bp-44h] BYREF

  sub_4788C(a4, "<buffer>");
  if ( a1 )
  {
    v9[0] = a1;
    v9[1] = a2;
    a1 = 0;
    v9[2] = 0;
    if ( !sub_449CC((int)v10, (int)sub_4482C, (int)v9) )
    {
      a1 = sub_459CC(v10, a3, (int)a4);
      sub_44A18((int)v10);
    }
  }
  else
  {
    sub_448AC((int)a4, 0, "wrong arguments");
  }
  return a1;
}

//----- (00045BD8) --------------------------------------------------------
int *__fastcall sub_45BD8(int *a1, unsigned int a2, char *a3)
{
  int *v5; // r4
  char *v6; // r1
  _DWORD v8[16]; // [sp+0h] [bp-40h] BYREF

  v5 = a1;
  if ( a1 == (int *)stdin )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_4788C(a3, v6);
  if ( v5 )
  {
    if ( sub_449CC((int)v8, (int)fgetc, (int)v5) )
    {
      return 0;
    }
    else
    {
      v5 = sub_459CC(v8, a2, (int)a3);
      sub_44A18((int)v8);
    }
  }
  else
  {
    sub_448AC((int)a3, 0, "wrong arguments");
  }
  return v5;
}
// 60E78: using guessed type int stdin;

//----- (00045C84) --------------------------------------------------------
int *__fastcall sub_45C84(char *a1, unsigned int a2, char *a3)
{
  FILE *v6; // r0
  FILE *v7; // r7
  int *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_4788C(a3, a1);
  if ( a1 )
  {
    v6 = fopen(a1, "rb");
    v7 = v6;
    if ( v6 )
    {
      v8 = sub_45BD8(&v6->_flags, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_448AC((int)a3, 0, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_448AC((int)a3, 0, "wrong arguments");
  }
  return v8;
}

//----- (00045DE4) --------------------------------------------------------
void *__fastcall sub_45DE4(size_t a1)
{
  if ( a1 )
    return off_60E50(a1);
  else
    return 0;
}
// 60E50: using guessed type void *(*off_60E50)(size_t size);

//----- (00045E0C) --------------------------------------------------------
void __fastcall sub_45E0C(void *a1)
{
  if ( a1 )
    off_60E54(a1);
}
// 60E54: using guessed type void (*off_60E54)(void *ptr);

//----- (00045E2C) --------------------------------------------------------
void *__fastcall sub_45E2C(const char *a1)
{
  size_t v2; // r0
  size_t v3; // r4
  void *v5; // r0
  void *v6; // r5

  v2 = strlen(a1);
  if ( v2 == -1 )
    return 0;
  v3 = v2 + 1;
  v5 = off_60E50(v2 + 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  memcpy(v5, a1, v3);
  return v6;
}
// 60E50: using guessed type void *(*off_60E50)(size_t size);

//----- (00045E84) --------------------------------------------------------
void *(*__fastcall sub_45E84(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  off_60E50 = result;
  off_60E54 = a2;
  return result;
}
// 60E50: using guessed type void *(*off_60E50)(size_t size);
// 60E54: using guessed type void (*off_60E54)(void *ptr);

//----- (00045E94) --------------------------------------------------------
int __fastcall sub_45E94(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = sub_45DE4(0x10u);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (00045ECC) --------------------------------------------------------
void __fastcall sub_45ECC(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    sub_45E0C(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (00045EF8) --------------------------------------------------------
int __fastcall sub_45EF8(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (00045F0C) --------------------------------------------------------
int __fastcall sub_45F0C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00045F14) --------------------------------------------------------
int __fastcall sub_45F14(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (00045F28) --------------------------------------------------------
int __fastcall sub_45F28(const void **a1, void *src, size_t n)
{
  size_t v4; // r3
  int v6; // r0
  char *v8; // r6
  unsigned int v9; // r0
  size_t v10; // r8
  char *v11; // r0
  char *v12; // r2
  size_t v13; // r5

  v4 = (size_t)a1[1];
  v6 = (int)a1[2];
  if ( v6 - v4 > n )
  {
    v8 = (char *)*a1;
LABEL_10:
    memcpy(&v8[v4], src, n);
    v12 = (char *)*a1;
    v13 = (size_t)a1[1] + n;
    a1[1] = (const void *)v13;
    v12[v13] = 0;
    return 0;
  }
  if ( v6 >= 0 && n != -1 && v4 <= -2 - n )
  {
    v9 = 2 * v6;
    v10 = v4 + 1 + n;
    if ( v10 < v9 )
      v10 = v9;
    v11 = (char *)sub_45DE4(v10);
    v8 = v11;
    if ( v11 )
    {
      memcpy(v11, *a1, (size_t)a1[1]);
      sub_45E0C((void *)*a1);
      v4 = (size_t)a1[1];
      *a1 = v8;
      a1[2] = (const void *)v10;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (00045FEC) --------------------------------------------------------
int __fastcall DataWriter::WriteByte(const void **this, unsigned __int8 a2)
{
  unsigned __int8 v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return sub_45F28(this, &v3, 1u);
}

//----- (00046010) --------------------------------------------------------
int __fastcall luaL_addstring(const void **a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  return sub_45F28(a1, s, v4);
}

//----- (00046038) --------------------------------------------------------
int __fastcall sub_46038(int *a1, int a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = v3 - 1;
    a1[1] = v3 - 1;
    a2 = *a1;
    LOBYTE(v3) = 0;
    result = *(unsigned __int8 *)(*a1 + a3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a2 + a3) = v3;
  return result;
}

//----- (00046060) --------------------------------------------------------
int __fastcall sub_46060(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x46u, "jsonp_strtod");
  if ( *v9 == 34 && v2 != 0.0 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 460E0: variable 'v2' is possibly undefined

//----- (00046120) --------------------------------------------------------
int __fastcall sub_46120(char *a1, size_t a2)
{
  double v2; // d0
  int v5; // r0
  int v6; // r4
  int v7; // r6
  int v8; // r1
  char *v9; // r0
  char *v10; // r3
  char *v11; // r4
  char *v12; // r7
  char *v13; // r3

  v5 = snprintf(a1, a2, "%.17g", v2);
  v6 = v5;
  if ( v5 >= 0 )
  {
    v7 = v5;
    if ( a2 > v5 )
    {
      v8 = *(unsigned __int8 *)localeconv()->decimal_point;
      if ( v8 != 46 )
      {
        v9 = strchr(a1, v8);
        if ( v9 )
          *v9 = 46;
      }
      if ( strchr(a1, 46) )
      {
LABEL_7:
        v10 = strchr(a1, 101);
        if ( !v10 )
          return v7;
LABEL_8:
        v11 = v10 + 2;
        if ( v10[1] == 45 )
          v12 = v10 + 2;
        else
          v12 = v10 + 1;
        if ( v10[2] == 48 )
        {
          v13 = v10 + 3;
          do
            v11 = v13++;
          while ( *v11 == 48 );
        }
        if ( v11 != v12 )
        {
          memmove(v12, v11, a1 - v11 + v7);
          v7 += v12 - v11;
        }
        return v7;
      }
      v10 = strchr(a1, 101);
      if ( v10 )
        goto LABEL_8;
      if ( a2 > v6 + 3 )
      {
        v7 = v6 + 2;
        a1[v6] = 46;
        a1[v6 + 1] = 48;
        a1[v6 + 2] = 0;
        goto LABEL_7;
      }
    }
  }
  return -1;
}
// 46138: variable 'v2' is possibly undefined

//----- (00046254) --------------------------------------------------------
int __fastcall sub_46254(int a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r12
  int v5; // r3

  if ( a1 >= 0 )
  {
    if ( a1 <= 127 )
    {
      *a2 = a1;
      *a3 = 1;
      return 0;
    }
    if ( a1 < 2048 )
    {
      *a2 = (((unsigned int)a1 >> 6) & 0x1F) - 64;
      a2[1] = (a1 & 0x3F) + 0x80;
      *a3 = 2;
      return 0;
    }
    if ( a1 < 0x10000 )
    {
      a2[1] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
      a2[2] = (a1 & 0x3F) + 0x80;
      *a2 = ((unsigned __int16)a1 >> 12) - 32;
      *a3 = 3;
      return 0;
    }
    if ( a1 < 1114112 )
    {
      v3 = ((unsigned int)a1 >> 18) & 7;
      v4 = ((unsigned int)a1 >> 12) & 0x3F;
      v5 = ((unsigned int)a1 >> 6) & 0x3F;
      a2[3] = (a1 & 0x3F) + 0x80;
      a2[2] = v5 + 0x80;
      *a2 = v3 - 16;
      a2[1] = v4 + 0x80;
      *a3 = 4;
      return 0;
    }
  }
  return -1;
}

//----- (0004633C) --------------------------------------------------------
int __fastcall sub_4633C(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x3F || (unsigned __int8)(a1 + 64) <= 1u )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) > 4u )
    return 0;
  return 4;
}

//----- (000463B8) --------------------------------------------------------
int __fastcall sub_463B8(char *a1, int a2, int *a3)
{
  char v3; // r4
  int v4; // r4
  int result; // r0
  int v6; // r12
  int v7; // r3
  bool v8; // zf
  bool v9; // zf
  _BOOL4 v10; // r0

  v3 = *a1;
  switch ( a2 )
  {
    case 2:
      v4 = v3 & 0x1F;
      break;
    case 3:
      v4 = v3 & 0xF;
      break;
    case 4:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = 1;
  while ( 1 )
  {
    ++v7;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v7 )
      break;
    v6 = (unsigned __int8)a1[v7];
    if ( (v6 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) <= 0x7FF )
    return 0;
  v8 = v4 == 127;
  if ( v4 <= 127 )
    v8 = a2 == 2;
  if ( v8 )
    return 0;
  result = 0;
  v9 = v4 == 2047;
  if ( v4 <= 2047 )
    v9 = a2 == 3;
  if ( !v9 )
  {
    v10 = v4 < 0x10000;
    if ( a2 != 4 )
      v10 = 0;
    if ( !v10 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00046490) --------------------------------------------------------
char *__fastcall sub_46490(char *a1, _DWORD *a2)
{
  char *v2; // r4
  int v3; // r5
  int v5; // r0
  int v6; // r6
  int v8; // [sp+4h] [bp-8h] BYREF

  v2 = a1;
  v3 = (unsigned __int8)*a1;
  if ( !*a1 )
    return v2;
  v5 = sub_4633C((unsigned __int8)*a1);
  v6 = v5;
  if ( v5 <= 0 )
    return 0;
  if ( v5 == 1 )
  {
    v8 = v3;
    goto LABEL_6;
  }
  if ( !sub_463B8(v2, v5, &v8) )
    return 0;
LABEL_6:
  v2 += v6;
  if ( a2 )
    *a2 = v8;
  return v2;
}

//----- (00046504) --------------------------------------------------------
int __fastcall sub_46504(const char *a1, signed int a2)
{
  signed int v2; // r8
  int v4; // r4
  int v5; // r5
  char *v6; // r0

  v2 = a2;
  if ( a2 == -1 )
    v2 = strlen(a1);
  if ( v2 <= 0 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_4633C((unsigned __int8)a1[v4]);
    v6 = (char *)&a1[v4];
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( v2 < v4 + v5 )
        break;
      v4 += v5 - 1;
      if ( !sub_463B8(v6, v5, 0) )
        break;
    }
    if ( v2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (00046598) --------------------------------------------------------
void *__fastcall sub_46598(_DWORD *a1, int a2, int a3)
{
  unsigned int v5; // r3
  void *v6; // r5
  unsigned int v8; // r1
  unsigned int v9; // r3
  unsigned int v10; // r7
  void *v11; // r0

  v5 = a1[2];
  if ( a2 + a1[3] <= v5 )
    return (void *)a1[4];
  v8 = a2 + v5;
  v9 = 2 * v5;
  if ( v8 < v9 )
    v10 = v9;
  else
    v10 = v8;
  v6 = (void *)a1[4];
  v11 = sub_45DE4(4 * v10);
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( a3 )
  {
    memcpy(v11, v6, 4 * a1[3]);
    sub_45E0C(v6);
    return (void *)a1[4];
  }
  return v6;
}

//----- (00046620) --------------------------------------------------------
_DWORD *sub_46620()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4

  v0 = sub_45DE4(0x24u);
  v1 = v0;
  if ( !v0 )
    return 0;
  v0[1] = 1;
  *v0 = 0;
  if ( sub_4426C(v0 + 2) )
  {
    sub_45E0C(v1);
    return 0;
  }
  else
  {
    v1[7] = 0;
    v1[8] = 0;
    return v1;
  }
}

//----- (0004667C) --------------------------------------------------------
_DWORD *__fastcall sub_4667C(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (00046698) --------------------------------------------------------
int __fastcall sub_46698(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_4450C((int)(a1 + 2), a2);
}

//----- (000466BC) --------------------------------------------------------
int __fastcall sub_466BC(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return -1;
  else
    return sub_44584(a1 + 2, a2);
}

//----- (000466E0) --------------------------------------------------------
int __fastcall sub_466E0(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  sub_446A0(a1 + 2);
  a1[7] = 0;
  return 0;
}

//----- (00046714) --------------------------------------------------------
_DWORD *__fastcall sub_46714(_DWORD *a1)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r0
  _DWORD *result; // r0

  if ( !a1 || *a1 )
    return 0;
  v2 = a1 + 2;
  v1 = v2 + 3;
  result = (_DWORD *)v2[4];
  if ( result == v1 )
    return 0;
  return result;
}

//----- (00046738) --------------------------------------------------------
int __fastcall sub_46738(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_4471C((int)(a1 + 2), a2);
}

//----- (00046760) --------------------------------------------------------
int __fastcall sub_46760(_DWORD *a1, int a2)
{
  if ( !a1 || *a1 || !a2 )
    return 0;
  if ( *(_DWORD **)(a2 + 4) == a1 + 5 )
    return 0;
  return *(_DWORD *)(a2 + 4);
}

//----- (0004678C) --------------------------------------------------------
int __fastcall sub_4678C(int result)
{
  if ( result )
    result += 16;
  return result;
}

//----- (00046798) --------------------------------------------------------
int __fastcall sub_46798(int result)
{
  if ( result )
    return *(_DWORD *)(result + 8);
  return result;
}

//----- (000467A4) --------------------------------------------------------
int __fastcall sub_467A4(_DWORD *a1, int a2, int a3)
{
  bool v3; // zf

  if ( !a1 || *a1 )
    return -1;
  v3 = a2 == 0;
  if ( a2 )
    v3 = a3 == 0;
  if ( v3 )
    return -1;
  sub_447C4(a2, a3);
  return 0;
}

//----- (000467EC) --------------------------------------------------------
int __fastcall sub_467EC(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (000467F8) --------------------------------------------------------
_DWORD *sub_467F8()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r5

  v0 = sub_45DE4(0x18u);
  v1 = v0;
  if ( !v0 )
    return 0;
  *v0 = 1;
  v0[1] = 1;
  v0[3] = 0;
  v0[2] = 8;
  v2 = sub_45DE4(0x20u);
  v1[4] = v2;
  if ( v2 )
  {
    v1[5] = 0;
    return v1;
  }
  else
  {
    sub_45E0C(v1);
    return 0;
  }
}

//----- (00046864) --------------------------------------------------------
_DWORD *__fastcall sub_46864(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (00046880) --------------------------------------------------------
_DWORD *__fastcall sub_46880(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (000468B4) --------------------------------------------------------
int __fastcall sub_468B4(_DWORD *a1, _DWORD *a2)
{
  size_t v4; // r2
  char *v5; // r1
  char *v6; // r0
  int v7; // r3
  int v8; // t1

  if ( !a1 || *a1 != 1 || !a2 || *a2 != 1 || !sub_46598(a1, a2[3], 1) )
    return -1;
  v4 = a2[3];
  v5 = (char *)a2[4];
  if ( v4 )
  {
    v4 *= 4;
    v6 = (char *)a2[4];
    do
    {
      v8 = *(_DWORD *)v6;
      v6 += 4;
      v7 = v8;
      if ( v8 )
      {
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
      }
    }
    while ( v6 != &v5[v4] );
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), v5, v4);
  a1[3] += a2[3];
  return 0;
}

//----- (00046964) --------------------------------------------------------
_DWORD *__fastcall sub_46964(const char *a1)
{
  _DWORD *v2; // r4
  void *v3; // r5
  _DWORD *result; // r0

  if ( !a1 )
    return 0;
  v2 = sub_45DE4(0xCu);
  if ( !v2 )
    return 0;
  *v2 = 2;
  v2[1] = 1;
  v3 = sub_45E2C(a1);
  result = v2;
  v2[2] = v3;
  if ( !v3 )
  {
    sub_45E0C(v2);
    return 0;
  }
  return result;
}

//----- (000469C0) --------------------------------------------------------
_DWORD *__fastcall sub_469C0(const char *a1)
{
  if ( a1 && sub_46504(a1, -1) )
    return sub_46964(a1);
  else
    return 0;
}

//----- (000469F0) --------------------------------------------------------
_DWORD *__fastcall sub_469F0(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (00046A0C) --------------------------------------------------------
int __fastcall sub_46A0C(int a1, const char *a2)
{
  void *v3; // r5

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 )
    return -1;
  if ( !a2 )
    return -1;
  v3 = sub_45E2C(a2);
  if ( !v3 )
    return -1;
  sub_45E0C(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v3;
  return 0;
}

//----- (00046A58) --------------------------------------------------------
int __fastcall sub_46A58(int a1, const char *a2)
{
  if ( a2 && sub_46504(a2, -1) )
    return sub_46A0C(a1, a2);
  else
    return -1;
}

//----- (00046A94) --------------------------------------------------------
_QWORD *__fastcall sub_46A94(__int64 a1)
{
  _QWORD *result; // r0

  result = sub_45DE4(0x10u);
  if ( result )
  {
    result[1] = a1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00046AC0) --------------------------------------------------------
__int64 __fastcall sub_46AC0(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (00046AEC) --------------------------------------------------------
int __fastcall sub_46AEC(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (00046B14) --------------------------------------------------------
_QWORD *__fastcall sub_46B14(double a1)
{
  __int64 v1; // d0
  double v2; // r0
  _QWORD *result; // r0

  LODWORD(v2) = _isnan(a1);
  if ( LODWORD(v2) )
    return 0;
  if ( _isinf(v2) )
    return 0;
  result = sub_45DE4(0x10u);
  if ( !result )
    return 0;
  result[1] = v1;
  *(_DWORD *)result = 4;
  *((_DWORD *)result + 1) = 1;
  return result;
}
// 46B30: variable 'v2' is possibly undefined
// 46B58: variable 'v1' is possibly undefined

//----- (00046B70) --------------------------------------------------------
void sub_46B70()
{
  ;
}

//----- (00046BA0) --------------------------------------------------------
int __fastcall sub_46BA0(double a1)
{
  __int64 v1; // d0
  int v2; // r4
  double v3; // r0
  int result; // r0

  v2 = LODWORD(a1);
  if ( !LODWORD(a1) )
    return -1;
  if ( *(_DWORD *)LODWORD(a1) != 4 )
    return -1;
  LODWORD(v3) = _isnan(a1);
  if ( LODWORD(v3) )
    return -1;
  result = _isinf(v3);
  if ( result )
    return -1;
  *(_QWORD *)(v2 + 8) = v1;
  return result;
}
// 46BD0: variable 'v3' is possibly undefined
// 46BDC: variable 'v1' is possibly undefined

//----- (00046BF0) --------------------------------------------------------
int __fastcall sub_46BF0(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_493DC(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (00046C38) --------------------------------------------------------
void *sub_46C38()
{
  return &unk_60E58;
}

//----- (00046C44) --------------------------------------------------------
void *sub_46C44()
{
  return &unk_60E60;
}

//----- (00046C50) --------------------------------------------------------
void *sub_46C50()
{
  return &unk_60E68;
}

//----- (00046C5C) --------------------------------------------------------
void __fastcall sub_46C5C(void **a1)
{
  void *v2; // r3
  void *v3; // r1
  _DWORD *v4; // r12
  unsigned int i; // r5
  int v6; // r0
  int v7; // r3

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
    {
      if ( v2 == (void *)1 )
      {
        v3 = a1[3];
        v4 = a1[4];
        if ( v3 )
        {
          for ( i = 0; i < (unsigned int)v3; ++i )
          {
            v6 = v4[i];
            if ( v6 )
            {
              v7 = *(_DWORD *)(v6 + 4);
              if ( v7 != -1 )
              {
                *(_DWORD *)(v6 + 4) = v7 - 1;
                if ( v7 == 1 )
                {
                  sub_46C5C();
                  v4 = a1[4];
                  v3 = a1[3];
                }
              }
            }
          }
        }
        sub_45E0C(v4);
        sub_45E0C(a1);
      }
      else if ( v2 == (void *)2 )
      {
        sub_45E0C(a1[2]);
        sub_45E0C(a1);
      }
      else if ( v2 == (void *)3 || v2 == (void *)4 )
      {
        sub_45E0C(a1);
      }
    }
    else
    {
      sub_442EC((int)(a1 + 2));
      sub_45E0C(a1);
    }
  }
}

//----- (00046D30) --------------------------------------------------------
int __fastcall sub_46D30(_DWORD *a1)
{
  unsigned int v2; // r1
  unsigned int i; // r4
  int v4; // r0
  int v5; // r3

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD *)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 4);
        if ( v5 != -1 )
        {
          *(_DWORD *)(v4 + 4) = v5 - 1;
          if ( v5 == 1 )
          {
            sub_46C5C((void **)v4);
            v2 = a1[3];
          }
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (00046DAC) --------------------------------------------------------
int __fastcall sub_46DAC(_DWORD *a1, unsigned int a2)
{
  unsigned int v4; // r3
  int v5; // r6
  int v6; // r0
  int v7; // r2
  int v8; // r2
  unsigned int v9; // r3

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v4 = a1[3];
      if ( v4 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD *)(a1[4] + 4 * a2);
        if ( !v6 || (v7 = *(_DWORD *)(v6 + 4), v7 == -1) || (v8 = v7 - 1, (*(_DWORD *)(v6 + 4) = v8) != 0) )
        {
          v9 = v4 - 1;
          if ( a2 >= v9 )
          {
LABEL_8:
            a1[3] = v9;
            return 0;
          }
        }
        else
        {
          sub_46C5C((void **)v6);
          v9 = a1[3] - 1;
          if ( a2 >= v9 )
            goto LABEL_8;
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + 4 * (a2 + 1)), 4 * (v9 - a2));
        v9 = a1[3] - 1;
        goto LABEL_8;
      }
    }
  }
  return -1;
}

//----- (00046E60) --------------------------------------------------------
int __fastcall sub_46E60(int a1, unsigned int a2, int a3)
{
  char *v6; // r0
  char *v7; // r6
  char *v8; // r1
  int v10; // r3
  int v11; // r3
  int v12; // r3

  if ( !a3 )
    return -1;
  if ( !a1
    || *(_DWORD *)a1 != 1
    || a1 == a3
    || *(_DWORD *)(a1 + 12) < a2
    || (v6 = (char *)sub_46598((_DWORD *)a1, 1, 0), (v7 = v6) == 0) )
  {
    v11 = *(_DWORD *)(a3 + 4);
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      *(_DWORD *)(a3 + 4) = v12;
      if ( !v12 )
        sub_46C5C((void **)a3);
    }
    return -1;
  }
  v8 = *(char **)(a1 + 16);
  if ( v8 == v6 )
  {
    memmove(&v8[4 * a2 + 4], &v8[4 * a2], 4 * (*(_DWORD *)(a1 + 12) - a2));
  }
  else
  {
    memcpy(*(void **)(a1 + 16), v6, 4 * a2);
    memcpy((void *)(*(_DWORD *)(a1 + 16) + 4 * (a2 + 1)), &v7[4 * a2], 4 * (*(_DWORD *)(a1 + 12) - a2));
    sub_45E0C(v7);
  }
  v10 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * a2) = a3;
  *(_DWORD *)(a1 + 12) = v10 + 1;
  return 0;
}

//----- (00046F60) --------------------------------------------------------
int __fastcall sub_46F60(int *a1, int *a2)
{
  int v4; // r3
  int v6; // r3
  int v7; // r3

  if ( a2 )
  {
    if ( a1 && *a1 == 1 && a1 != a2 && sub_46598(a1, 1, *a1) )
    {
      v4 = a1[3];
      *(_DWORD *)(a1[4] + 4 * v4) = a2;
      a1[3] = v4 + 1;
      return 0;
    }
    v6 = a2[1];
    if ( v6 != -1 )
    {
      v7 = v6 - 1;
      a2[1] = v7;
      if ( !v7 )
        sub_46C5C((void **)a2);
    }
  }
  return -1;
}

//----- (00046FE4) --------------------------------------------------------
int __fastcall sub_46FE4(_DWORD *a1, unsigned int a2, int a3)
{
  int v5; // r6
  int *v6; // r2
  int v7; // r0
  int v8; // r3
  int v9; // r3
  int v11; // r3
  int v12; // r3

  if ( !a3 )
    return -1;
  if ( !a1 || *a1 != 1 || a1 == (_DWORD *)a3 || a1[3] <= a2 )
  {
    v11 = *(_DWORD *)(a3 + 4);
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      *(_DWORD *)(a3 + 4) = v12;
      if ( !v12 )
        sub_46C5C((void **)a3);
    }
    return -1;
  }
  v5 = 4 * a2;
  v6 = (int *)(a1[4] + 4 * a2);
  v7 = *v6;
  if ( *v6 )
  {
    v8 = *(_DWORD *)(v7 + 4);
    if ( v8 != -1 )
    {
      v9 = v8 - 1;
      *(_DWORD *)(v7 + 4) = v9;
      if ( !v9 )
      {
        sub_46C5C((void **)v7);
        v6 = (int *)(a1[4] + v5);
      }
    }
  }
  *v6 = a3;
  return 0;
}

//----- (00047098) --------------------------------------------------------
int __fastcall sub_47098(_DWORD *a1, char *a2, int a3)
{
  bool v4; // zf
  int v5; // r2
  int result; // r0
  int v7; // r3
  int v8; // r3

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( v4
    || *a1
    || a1 == (_DWORD *)a3
    || (v5 = a1[7], a1[7] = v5 + 1, (result = sub_44304((int)(a1 + 2), a2, v5, a3)) != 0) )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_46C5C((void **)a3);
    }
    return -1;
  }
  return result;
}

//----- (00047118) --------------------------------------------------------
int __fastcall sub_47118(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r0
  int v7; // r8

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_46714(a2);
  for ( i = (char *)sub_4678C((int)v4); i; i = (char *)sub_4678C(v6) )
  {
    v7 = sub_46798((int)(i - 16));
    if ( !v7 )
      break;
    if ( !sub_46698(a1, i) )
    {
      if ( *(_DWORD *)(v7 + 4) != -1 )
        ++*(_DWORD *)(v7 + 4);
      sub_47098(a1, i, v7);
    }
    v6 = sub_46760(a2, (int)(i - 16));
  }
  return 0;
}

//----- (000471D4) --------------------------------------------------------
int __fastcall sub_471D4(_DWORD *a1, char *a2, int a3)
{
  int v7; // r3
  int v8; // r3

  if ( a2 && sub_46504(a2, -1) )
    return sub_47098(a1, a2, a3);
  if ( a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_46C5C((void **)a3);
    }
  }
  return -1;
}

//----- (00047248) --------------------------------------------------------
int __fastcall sub_47248(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r0
  int v7; // r0

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_46714(a2);
  for ( i = (char *)sub_4678C((int)v4); i; i = (char *)sub_4678C(v6) )
  {
    v7 = sub_46798((int)(i - 16));
    if ( !v7 )
      break;
    if ( *(_DWORD *)(v7 + 4) != -1 )
      ++*(_DWORD *)(v7 + 4);
    if ( sub_47098(a1, i, v7) )
      return -1;
    v6 = sub_46760(a2, (int)(i - 16));
  }
  return 0;
}

//----- (000472F4) --------------------------------------------------------
int __fastcall sub_472F4(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r5
  int v7; // r0

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_46714(a2);
  for ( i = (char *)sub_4678C((int)v4); i; i = (char *)sub_4678C(v7) )
  {
    v6 = sub_46798((int)(i - 16));
    if ( !v6 )
      break;
    if ( sub_46698(a1, i) )
    {
      if ( *(_DWORD *)(v6 + 4) != -1 )
        ++*(_DWORD *)(v6 + 4);
      sub_47098(a1, i, v6);
    }
    v7 = sub_46760(a2, (int)(i - 16));
  }
  return 0;
}

//----- (000473A8) --------------------------------------------------------
bool __fastcall sub_473A8(int *a1, int *a2)
{
  bool v2; // zf
  int v3; // r2
  int v6; // r3
  _DWORD *v8; // r0
  int v9; // r7
  int v10; // r0
  int v11; // r5
  int v12; // r0
  char *v13; // r1
  int v14; // r7
  int v15; // r0
  int v16; // r7
  unsigned int v17; // r5
  int v18; // r2
  int v19; // r1
  int v20; // r0

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  v3 = v2;
  if ( v2 )
    return 0;
  v6 = *a1;
  if ( *a1 != *a2 )
    return v3;
  if ( a1 == a2 )
    return 1;
  switch ( v6 )
  {
    case 0:
      if ( a1[2] == a2[2] )
      {
        v8 = sub_46714(a1);
        v9 = sub_4678C((int)v8);
        if ( v9 )
        {
          while ( 1 )
          {
            v11 = v9 - 16;
            v12 = sub_46798(v9 - 16);
            v13 = (char *)v9;
            v14 = v12;
            if ( !v12 )
              break;
            v15 = sub_46698(a2, v13);
            if ( !sub_473A8(v14, v15) )
              return 0;
            v10 = sub_46760(a1, v11);
            v9 = sub_4678C(v10);
            if ( !v9 )
              return 1;
          }
        }
        return 1;
      }
      return 0;
    case 1:
      v16 = a1[3];
      if ( v16 == a2[3] )
      {
        if ( v16 )
        {
          v17 = v3;
          v18 = *a1;
          while ( 1 )
          {
            v20 = v18 == 1 && a1[3] > v17 ? *(_DWORD *)(a1[4] + 4 * v17) : 0;
            v19 = v6 == 1 && a2[3] > v17 ? *(_DWORD *)(a2[4] + 4 * v17) : 0;
            if ( !sub_473A8(v20, v19) )
              break;
            if ( ++v17 == v16 )
              return 1;
            v18 = *a1;
            v6 = *a2;
          }
          return 0;
        }
        return 1;
      }
      return 0;
    case 2:
      return strcmp((const char *)a1[2], (const char *)a2[2]) == 0;
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
  }
  if ( v6 != 4 )
    return v3;
  return *((double *)a1 + 1) == *((double *)a2 + 1);
}

//----- (0004756C) --------------------------------------------------------
int *__fastcall sub_4756C(double a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  _DWORD *v4; // r7
  _DWORD *v5; // r0
  char *j; // r5
  int v7; // r3
  int v8; // r0
  int *v9; // r6
  unsigned int v10; // r3
  unsigned int i; // r5
  int *v12; // r1

  v1 = (_DWORD *)LODWORD(a1);
  if ( !LODWORD(a1) )
    return 0;
  v2 = *(_DWORD *)LODWORD(a1);
  if ( *(_DWORD *)LODWORD(a1) )
  {
    switch ( v2 )
    {
      case 1:
        v9 = sub_467F8();
        if ( v9 )
        {
          if ( *v1 == 1 )
          {
            v10 = v1[3];
            if ( v10 )
            {
              for ( i = 0; i < v10; ++i )
              {
                v12 = 0;
                if ( v10 > i )
                {
                  v12 = *(int **)(v1[4] + 4 * i);
                  if ( v12 )
                  {
                    if ( v12[1] != -1 )
                      ++v12[1];
                  }
                }
                sub_46F60(v9, v12);
                if ( *v1 != 1 )
                  break;
                v10 = v1[3];
              }
            }
          }
        }
        return v9;
      case 2:
        return sub_46964(*(const char **)(LODWORD(a1) + 8));
      case 3:
        return (int *)sub_46A94(*(_QWORD *)(LODWORD(a1) + 8));
      case 4:
        return (int *)sub_46B14(a1);
      default:
        if ( (unsigned int)(v2 - 5) <= 2 )
          return v1;
        return 0;
    }
  }
  else
  {
    v4 = sub_46620();
    if ( v4 )
    {
      v5 = sub_46714(v1);
      for ( j = (char *)sub_4678C((int)v5); j; j = (char *)sub_4678C(v8) )
      {
        v7 = sub_46798((int)(j - 16));
        if ( !v7 )
          break;
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
        sub_47098(v4, j, v7);
        v8 = sub_46760(v1, (int)(j - 16));
      }
    }
    return v4;
  }
}

//----- (000476E0) --------------------------------------------------------
int *__fastcall sub_476E0(double a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  _DWORD *v4; // r7
  _DWORD *j; // r5
  char *v6; // r6
  int v7; // r0
  int v8; // r0
  int *v9; // r6
  unsigned int v10; // r3
  unsigned int i; // r5
  int v12; // r0
  int *v13; // r0

  v1 = (_DWORD *)LODWORD(a1);
  if ( !LODWORD(a1) )
    return v1;
  v2 = *(_DWORD *)LODWORD(a1);
  if ( *(_DWORD *)LODWORD(a1) )
  {
    switch ( v2 )
    {
      case 1:
        v9 = sub_467F8();
        if ( v9 )
        {
          if ( *v1 == 1 )
          {
            v10 = v1[3];
            if ( v10 )
            {
              for ( i = 0; i < v10; ++i )
              {
                v12 = 0;
                if ( i < v10 )
                  v12 = *(_DWORD *)(v1[4] + 4 * i);
                v13 = (int *)sub_476E0(v12);
                sub_46F60(v9, v13);
                if ( *v1 != 1 )
                  break;
                v10 = v1[3];
              }
            }
          }
        }
        return v9;
      case 2:
        return sub_46964(*(const char **)(LODWORD(a1) + 8));
      case 3:
        return (int *)sub_46A94(*(_QWORD *)(LODWORD(a1) + 8));
      case 4:
        return (int *)sub_46B14(a1);
      default:
        if ( (unsigned int)(v2 - 5) > 2 )
          return 0;
        return v1;
    }
  }
  else
  {
    v4 = sub_46620();
    if ( v4 )
    {
      for ( j = sub_46714(v1); j; j = (_DWORD *)sub_46760(v1, (int)j) )
      {
        v6 = (char *)sub_4678C((int)j);
        v7 = sub_46798((int)j);
        v8 = sub_476E0(v7);
        sub_47098(v4, v6, v8);
      }
    }
    return v4;
  }
}

//----- (00047828) --------------------------------------------------------
char *__fastcall sub_47828(char *result, char *s)
{
  bool v2; // zf
  int v4; // r5
  size_t v5; // r0

  v2 = result == 0;
  if ( result )
    v2 = s == 0;
  v4 = (int)result;
  if ( !v2 )
  {
    v5 = strlen(s);
    if ( v5 <= 0x4F )
    {
      return (char *)memcpy((void *)(v4 + 12), s, v5 + 1);
    }
    else
    {
      strcpy((char *)(v4 + 12), "...");
      return strcpy((char *)(v4 + 15), &s[v5 - 76]);
    }
  }
  return result;
}

//----- (0004788C) --------------------------------------------------------
char *__fastcall sub_4788C(char *result, char *s)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( s )
      return sub_47828(result, s);
    else
      result[12] = 0;
  }
  return result;
}

//----- (000478D0) --------------------------------------------------------
int __fastcall sub_478D0(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg)
{
  int v6; // r4

  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0xA0u, format, arg);
      *(_BYTE *)(v6 + 251) = 0;
    }
  }
  return result;
}

//----- (00047910) --------------------------------------------------------
int sub_47910(int a1, int a2, int a3, int a4, char *format, ...)
{
  va_list __varargs; // [sp+1Ch] [bp+8h] BYREF

  va_start(__varargs, format);
  return sub_478D0(a1, a2, a3, a4, format, __varargs);
}

//----- (00047938) --------------------------------------------------------
char *__fastcall sub_47938(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v5 + v4);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (00047974) --------------------------------------------------------
int __fastcall sub_47974(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (00047984) --------------------------------------------------------
int __fastcall sub_47984(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00047998) --------------------------------------------------------
char *__fastcall sub_47998(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, dword_52370) || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_48600(a1);
  }
}

//----- (00047A2C) --------------------------------------------------------
char *__fastcall sub_47A2C(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_47998(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (00047A4C) --------------------------------------------------------
int __fastcall sub_47A4C(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (00047A58) --------------------------------------------------------
char *__fastcall sub_47A58(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return sub_47938("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return sub_47938("'%s' is out of range", a1);
  return result;
}
// 47A88: variable 'v2' is possibly undefined
// B044: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (00047ADC) --------------------------------------------------------
char *__fastcall sub_47ADC(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_47938("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_47938("'%s' is out of range", a1);
  return result;
}

//----- (00047B60) --------------------------------------------------------
char *__fastcall sub_47B60(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_47ADC(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (00047C20) --------------------------------------------------------
int __fastcall sub_47C20(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (00047C38) --------------------------------------------------------
void __fastcall __noreturn sub_47C38(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 60E7C: using guessed type int stdout;

//----- (00047C58) --------------------------------------------------------
void __fastcall __noreturn sub_47C58(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_48A84(dword_C54D4, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 48A84: using guessed type int __fastcall sub_48A84(_DWORD, _DWORD);
// 60E7C: using guessed type int stdout;
// C54D4: using guessed type int dword_C54D4;

//----- (00047C98) --------------------------------------------------------
char *__fastcall sub_47C98(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (00047CBC) --------------------------------------------------------
char *__fastcall sub_47CBC(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (00047CE0) --------------------------------------------------------
char *__fastcall sub_47CE0(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  const char *v5; // r1
  bool v6; // cc
  size_t v7; // r5
  char *v8; // r0
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  *a1 = 34;
  v5 = *a2;
  v6 = v4 > 0x4E;
  v7 = v4;
  v8 = a1 + 1;
  if ( v6 )
  {
    result = strncpy(v8, v5, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v7];
    result = strncpy(v8, v5, v7);
    v9[1] = 34;
    if ( v7 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (00047D40) --------------------------------------------------------
int __fastcall sub_47D40(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (00047D54) --------------------------------------------------------
int __fastcall sub_47D54(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (00047D80) --------------------------------------------------------
int __fastcall sub_47D80(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (00047D94) --------------------------------------------------------
int __fastcall sub_47D94(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (00047DA8) --------------------------------------------------------
int __fastcall sub_47DA8(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (00047DBC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_47DBC(int a1, _DWORD *a2)
{
  unsigned __int8 *v2; // r4
  int v3; // r3
  bool v4; // zf
  int v5; // r2
  int v6; // r12
  unsigned __int8 *v7; // r12
  int v8; // r3
  int v9; // t1
  unsigned __int8 *result; // r0

  v2 = (unsigned __int8 *)(a1 + *a2);
  v3 = *v2;
  v4 = v3 == 32;
  if ( v3 != 32 )
    v4 = v3 == 61;
  if ( v4 )
    return 0;
  v5 = 0;
  if ( !*(_BYTE *)(a1 + *a2) )
    return 0;
  v6 = v2[2];
  result = v2 + 2;
  if ( v2[2] )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v7 = v2 + 2;
      do
      {
        v9 = *++v7;
        v8 = v9;
        ++v5;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  else
  {
    v5 = v2[2];
  }
  *a2 = v5;
  return result;
}

//----- (00047E64) --------------------------------------------------------
_BYTE *__fastcall sub_47E64(unsigned int *a1, _DWORD *a2)
{
  _DWORD *v2; // r3
  int v3; // r4
  unsigned int v4; // r12
  _BYTE *result; // r0
  int v6; // r2
  int v7; // r12
  int v8; // r3
  int v9; // t1

  *a1 = 0;
  if ( !dword_C54C8 )
    return 0;
  v2 = (_DWORD *)dword_C54D0;
  if ( *(_DWORD *)(dword_C54D0 + 4) == 8 )
  {
    v3 = dword_C54D0 + 28;
    v4 = 1;
    do
    {
      *a1 = v4;
      v2 = (_DWORD *)v3;
      v3 += 28;
      if ( dword_C54C8 <= v4++ )
        return 0;
    }
    while ( v2[1] == 8 );
  }
  result = (_BYTE *)(*v2 + 1);
  v6 = (unsigned __int8)*result;
  if ( *result )
  {
    if ( v6 == 124 || v6 == 61 || v6 == 32 )
    {
      v6 = 0;
    }
    else
    {
      v7 = *v2 + 1;
      v6 = 0;
      do
      {
        v9 = *(unsigned __int8 *)++v7;
        v8 = v9;
        ++v6;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  *a2 = v6;
  return result;
}
// C54C8: using guessed type int dword_C54C8;
// C54D0: using guessed type int dword_C54D0;

//----- (00047F4C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_47F4C(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3)
{
  unsigned int i; // r3
  _DWORD *v7; // r4
  _BYTE *v9; // r1
  int v10; // r3
  int v11; // r2
  int v12; // r3
  int v13; // t1

  for ( i = *a2; dword_C54C8 > i; *a2 = ++i )
  {
    v7 = (_DWORD *)(dword_C54D0 + 28 * i);
    if ( v7[1] != 8 )
    {
      if ( !a1 )
      {
        v9 = (_BYTE *)(*v7 + 1);
        v10 = (unsigned __int8)*v9;
        if ( *v9 && v10 != 124 && v10 != 61 && v10 != 32 )
        {
          v11 = *v7 + 1;
          do
          {
            v13 = *(unsigned __int8 *)++v11;
            v12 = v13;
            ++a1;
          }
          while ( v13 && v12 != 124 && v12 != 61 && v12 != 32 );
        }
        *a3 = a1;
        return v9;
      }
      a1 = sub_47DBC((int)a1, a3);
      if ( a1 )
        return a1;
      i = *a2;
    }
  }
  return 0;
}
// C54C8: using guessed type int dword_C54C8;
// C54D0: using guessed type int dword_C54D0;

//----- (00048040) --------------------------------------------------------
unsigned __int8 *__fastcall sub_48040(const char **a1)
{
  unsigned int v1; // r1
  bool v2; // cc
  int v4; // r3
  const char *v5; // r2
  int v6; // r1
  unsigned __int8 *v7; // r12
  const char *v8; // r1
  int v9; // r2
  int v10; // t1
  const char *v11; // r2
  bool v12; // zf
  int v13; // r1
  const char *v14; // r0
  int v15; // r1
  bool v16; // zf
  unsigned __int8 *result; // r0
  int i; // [sp+Ch] [bp-4h] BYREF

  v1 = (unsigned int)a1[1];
  v2 = v1 > 4;
  if ( v1 != 4 )
    v2 = v1 - 1 > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", *a1, a1[1]);
  v4 = 0;
  v5 = *a1;
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", v5);
  if ( *v5 != 45 )
    errx(1, "Option %s: does not begin with '-'", v5);
  v6 = *((unsigned __int8 *)v5 + 1);
  v7 = (unsigned __int8 *)(v5 + 1);
  if ( v5[1] )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v8 = v5 + 1;
      do
      {
        v10 = *(unsigned __int8 *)++v8;
        v9 = v10;
        ++v4;
      }
      while ( v10 && v9 != 124 && v9 != 61 && v9 != 32 );
    }
  }
  else
  {
    v4 = *((unsigned __int8 *)v5 + 1);
  }
  for ( i = v4; ; v4 = i )
  {
    if ( *v7 == 45 )
    {
      if ( v4 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v14 = a1[1];
      ++dword_C54C0;
    }
    else
    {
      if ( v4 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v4 + 1, (const char *)v7 - 1);
      v11 = a1[1];
      v12 = v11 == (const char *)2;
      if ( v11 != (const char *)2 )
        v12 = v11 == (const char *)4;
      v13 = ++dword_C54C4;
      if ( v12 )
        v13 = dword_C54CC;
      v14 = v11;
      if ( v12 )
        dword_C54CC = v13 + 1;
    }
    if ( v14 == (const char *)1 )
    {
      v15 = v7[v4];
      v16 = v15 == 32;
      if ( v15 != 32 )
        v16 = v15 == 61;
      if ( v16 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, (const char *)&v7[v4 + 1]);
    }
    result = sub_47DBC((int)v7, &i);
    v7 = result;
    if ( !result )
      break;
  }
  return result;
}
// C54C0: using guessed type int dword_C54C0;
// C54C4: using guessed type int dword_C54C4;
// C54CC: using guessed type int dword_C54CC;

//----- (00048220) --------------------------------------------------------
int __fastcall sub_48220(int *a1)
{
  char *v2; // r0
  int v3; // r10
  int v4; // r8
  char *v5; // r12
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int result; // r0
  int v11; // r1
  int v12; // r2

  v2 = (char *)realloc((void *)dword_C54D0, 28 * (dword_C54C8 + 1));
  v3 = dword_C54C8 + 1;
  v4 = (int)v2;
  v5 = &v2[28 * dword_C54C8];
  v6 = *a1;
  v7 = a1[1];
  v8 = a1[2];
  v9 = a1[3];
  a1 += 4;
  dword_C54D0 = v4;
  *(_DWORD *)v5 = v6;
  *((_DWORD *)v5 + 1) = v7;
  *((_DWORD *)v5 + 2) = v8;
  *((_DWORD *)v5 + 3) = v9;
  v5 += 16;
  result = *a1;
  v11 = a1[1];
  v12 = a1[2];
  dword_C54C8 = v3;
  *(_DWORD *)v5 = result;
  *((_DWORD *)v5 + 1) = v11;
  *((_DWORD *)v5 + 2) = v12;
  return result;
}
// C54C8: using guessed type int dword_C54C8;
// C54D0: using guessed type int dword_C54D0;

//----- (00048280) --------------------------------------------------------
unsigned __int8 *__fastcall sub_48280(unsigned int *a1, unsigned __int8 **a2)
{
  unsigned __int8 *v4; // r0

  v4 = sub_47E64(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = sub_47F4C(v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (000482D8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_482D8(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3)
{
  unsigned __int8 *v5; // r0

  v5 = sub_47F4C(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = sub_47F4C(v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (00048330) --------------------------------------------------------
unsigned __int8 *__fastcall sub_48330(unsigned int *a1)
{
  unsigned __int8 *result; // r0
  unsigned __int8 *v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_47E64(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = sub_47F4C(result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0004838C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_4838C(unsigned __int8 *a1, unsigned int *a2)
{
  unsigned __int8 *result; // r0
  int v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = sub_47F4C(a1, a2, (unsigned __int8 **)&v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = sub_47F4C(result, a2, (unsigned __int8 **)&v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00048430) --------------------------------------------------------
int __fastcall sub_48430(int result, int a2)
{
  const char **v3; // r5
  int v4; // r6
  const char *v5; // r3
  const char **v6; // r4
  int v7[7]; // [sp+4h] [bp-1Ch] BYREF

  v3 = (const char **)result;
  v4 = dword_C54C8;
  if ( a2 )
  {
    v7[6] = a2;
    v7[0] = 0;
    memset(&v7[2], 0, 16);
    v7[1] = 8;
    result = sub_48220(v7);
  }
  v5 = v3[1];
  if ( v5 != (const char *)16 )
  {
    v6 = v3 + 7;
    do
    {
      if ( v5 == (const char *)8 )
      {
        result = sub_48430(*v3, v3[6]);
      }
      else
      {
        sub_48040(v3);
        result = sub_48220((int *)v3);
      }
      v3 = v6;
      v6 += 7;
      v5 = *(v6 - 6);
    }
    while ( v5 != (const char *)16 );
  }
  if ( a2 )
    *(_DWORD *)(dword_C54D0 + 28 * v4 + 20) = dword_C54C8 - v4;
  return result;
}
// C54C8: using guessed type int dword_C54C8;
// C54D0: using guessed type int dword_C54D0;

//----- (000484FC) --------------------------------------------------------
bool __fastcall sub_484FC(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  const char *v4; // r1
  int v7; // r0
  int v9; // [sp+4h] [bp-8h] BYREF

  v4 = *a2;
  v9 = 0;
  dword_C54D4 = (int)v4;
  do
    v7 = sub_48664(a1, a2, &v9, a3);
  while ( v7 == 1 );
  return v7 == 0;
}
// C54D4: using guessed type int dword_C54D4;

//----- (00048558) --------------------------------------------------------
void sub_48558()
{
  free((void *)dword_C54D0);
  dword_C54D0 = 0;
}
// C54D0: using guessed type int dword_C54D0;

//----- (00048578) --------------------------------------------------------
int sub_48578(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 60E80: using guessed type int stderr;

//----- (000485C0) --------------------------------------------------------
void __noreturn sub_485C0(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 60E80: using guessed type int stderr;

//----- (00048600) --------------------------------------------------------
char *__fastcall sub_48600(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (00048630) --------------------------------------------------------
void *__fastcall sub_48630(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * (a3 + 1)), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (00048664) --------------------------------------------------------
int __fastcall sub_48664(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  char *v8; // r0
  const char *v9; // r12
  const char **v10; // r6
  int v12; // r5
  unsigned __int8 *v13; // r11
  const char *v14; // r3
  int v15; // r0
  size_t v16; // r0
  int v17; // r4
  unsigned __int8 *i; // r11
  int v19; // r0
  unsigned int v20; // r1
  const char *v21; // r11
  int v22; // lr
  int v23; // r12
  char *v24; // r4
  const char *v25; // r12
  const char **v26; // r4
  const char *v27; // t1
  _BYTE *ptr; // [sp+8h] [bp-14h]
  char *ptra; // [sp+8h] [bp-14h]
  const char *v30; // [sp+Ch] [bp-10h]
  unsigned int v31; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT");
  v9 = a2[1];
  if ( !v8 )
  {
    if ( v9 )
    {
      if ( *v9 == 45 )
      {
        v10 = a2 + 1;
        v12 = 1;
        goto LABEL_6;
      }
      v26 = a2 + 2;
      v12 = 1;
      while ( 1 )
      {
        v10 = v26;
        v27 = *v26++;
        v9 = v27;
        ++v12;
        if ( !v27 )
          break;
        if ( *v9 == 45 )
          goto LABEL_6;
      }
    }
    return 0;
  }
  v10 = a2 + 1;
  if ( !v9 || *v9 != 45 )
    return 0;
  v12 = 1;
LABEL_6:
  if ( v9[1] == 45 )
  {
    v17 = *((unsigned __int8 *)v9 + 2);
    if ( !v9[2] )
    {
      sub_48630(a1, (int)a2, v12);
      return v17;
    }
    if ( *a3 )
      _assert_fail("*offset == 0", "opt/parse.c", 0x3Bu, "parse_one");
    for ( i = sub_48280(&v31, (unsigned __int8 **)n); i; i = sub_482D8(i, &v31, (unsigned __int8 **)n) )
    {
      v30 = *v10;
      ptr = (_BYTE *)n[0];
      v19 = strncmp(*v10 + 2, (const char *)i, n[0]);
      v14 = v30;
      if ( !v19 )
      {
        if ( ptr[(_DWORD)v30 + 2] == 61 )
        {
          v20 = v31;
          v24 = &ptr[(_DWORD)v30 + 3];
          v21 = (const char *)(i - 2);
          n[0] = (size_t)(ptr + 2);
          v22 = dword_C54D0 + 28 * v31;
          v23 = *(_DWORD *)(v22 + 4);
          if ( v23 != 1 )
          {
            if ( v24 )
              goto LABEL_39;
            goto LABEL_48;
          }
          if ( v24 )
          {
            a4("%s: %.*s: %s", *a2, (int)(ptr + 2), v21, "doesn't allow an argument");
            return -1;
          }
LABEL_18:
          v24 = 0;
          v25 = (const char *)(*(int (__fastcall **)(_DWORD))(v22 + 8))(*(_DWORD *)(v22 + 20));
LABEL_19:
          if ( v25 )
          {
            ptra = (char *)v25;
            a4("%s: %.*s: %s", *a2, n[0], v21, v25);
            free(ptra);
            return -1;
          }
          if ( *a3 )
          {
            if ( !(*v10)[*a3 + 1] )
            {
              *a3 = 0;
              goto LABEL_23;
            }
          }
          else
          {
LABEL_23:
            sub_48630(a1, (int)a2, v12);
            if ( v24 )
            {
              if ( *v10 == v24 )
                sub_48630(a1, (int)a2, v12);
            }
          }
          return 1;
        }
        if ( !ptr[(_DWORD)v30 + 2] )
        {
          v20 = v31;
          v21 = (const char *)(i - 2);
          n[0] = (size_t)(ptr + 2);
          v22 = dword_C54D0 + 28 * v31;
          v23 = *(_DWORD *)(v22 + 4);
          if ( v23 == 1 )
            goto LABEL_18;
LABEL_48:
          v15 = *a3;
          goto LABEL_37;
        }
      }
    }
LABEL_10:
    v16 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v16, *v10, "unrecognized option");
    return -1;
  }
  v13 = sub_48330(&v31);
  if ( !v13 )
    goto LABEL_10;
  while ( 1 )
  {
    v14 = *v10;
    v15 = *a3 + 1;
    if ( (unsigned __int8)(*v10)[v15] == *v13 )
      break;
    v13 = sub_4838C(v13, &v31);
    if ( !v13 )
      goto LABEL_10;
  }
  v20 = v31;
  v21 = (const char *)(v13 - 1);
  *a3 = v15;
  n[0] = 2;
  v22 = dword_C54D0 + 28 * v20;
  v23 = *(_DWORD *)(v22 + 4);
  if ( v23 == 1 )
    goto LABEL_18;
LABEL_37:
  if ( v15 )
  {
    v24 = (char *)&v14[v15 + 1];
    if ( *v24 )
    {
      *a3 = 0;
      goto LABEL_39;
    }
  }
  v24 = (char *)a2[v12 + 1];
  if ( v24 )
  {
LABEL_39:
    if ( v23 == 4 )
    {
      sub_47A4C((int)v24, *(_DWORD **)(v22 + 20));
      v20 = v31;
    }
    v25 = (const char *)(*(int (__fastcall **)(char *, _DWORD))(dword_C54D0 + 28 * v20 + 12))(
                          v24,
                          *(_DWORD *)(dword_C54D0 + 28 * v20 + 20));
    goto LABEL_19;
  }
  a4("%s: %.*s: %s", *a2, n[0], v21, "requires an argument");
  return -1;
}
// C54D0: using guessed type int dword_C54D0;

//----- (00048A84) --------------------------------------------------------
char *__fastcall sub_48A84(const char *a1, char *a2)
{
  size_t v2; // r4
  unsigned int v3; // r11
  size_t v4; // r8
  int v5; // r4
  unsigned int v6; // r5
  const char *v7; // r7
  size_t v8; // r8
  size_t v9; // r0
  size_t v10; // r8
  size_t v11; // r9
  size_t v12; // r0
  char *v13; // r0
  char *v14; // r4
  char *v15; // r5
  unsigned __int8 *v16; // r2
  int v17; // r9
  int v18; // r0
  char *v19; // r5
  int v20; // r4
  unsigned int v21; // r7
  unsigned int v22; // r9
  int v23; // r2
  unsigned int v24; // r9
  unsigned int v25; // r9
  int v26; // r3
  const char *v27; // r2
  char *v29; // r2
  int v30; // r2
  int v31; // r3
  size_t v32; // r5
  char *v33; // [sp+0h] [bp-6Ch]
  char *v34; // [sp+4h] [bp-68h]
  char *s; // [sp+8h] [bp-64h]
  unsigned int v37; // [sp+10h] [bp-5Ch] BYREF
  char v38[80]; // [sp+14h] [bp-58h] BYREF
  int v39; // [sp+64h] [bp-8h]

  s = a2;
  if ( a2 )
  {
    v2 = strlen(a1);
    v3 = dword_C54C8;
    v4 = dword_C54C4 + 20 + v2 + strlen(s);
    if ( !dword_C54C8 )
      goto LABEL_12;
    v5 = dword_C54D0;
  }
  else
  {
    v3 = dword_C54C8;
    if ( !dword_C54C8 )
    {
      s = (char *)"";
      v4 = dword_C54C4 + 20 + strlen(a1);
      goto LABEL_12;
    }
    v30 = 0;
    v5 = dword_C54D0;
    v31 = dword_C54D0;
    do
    {
      ++v30;
      if ( *(void (__fastcall __noreturn **)(int))(v31 + 8) == sub_47C58 && *(_DWORD *)(v31 + 20) )
      {
        s = *(char **)(v31 + 20);
        v32 = strlen(s);
        goto LABEL_45;
      }
      v31 += 28;
    }
    while ( v30 != dword_C54C8 );
    v32 = 0;
    s = (char *)"";
LABEL_45:
    v4 = dword_C54C4 + 20 + strlen(a1) + v32;
  }
  v6 = 0;
  do
  {
    while ( 1 )
    {
      v11 = v4 + 6;
      if ( *(_DWORD *)(v5 + 4) != 8 )
        break;
      ++v6;
      v12 = strlen(*(const char **)(v5 + 24));
      v5 += 28;
      v4 += 3 + v12;
      if ( v3 <= v6 )
        goto LABEL_12;
    }
    v7 = *(const char **)(v5 + 24);
    if ( v7 != (const char *)&unk_C54D8 )
    {
      v8 = strlen(*(const char **)v5);
      v9 = v11 + v8 + strlen(v7);
      v10 = v9 + 21;
      if ( *(_DWORD *)(v5 + 16) )
        v10 = v9 + 118;
      v4 = v10 + 1;
    }
    ++v6;
    v5 += 28;
  }
  while ( v3 > v6 );
LABEL_12:
  v13 = (char *)malloc(v4);
  v34 = v13;
  if ( v13 )
  {
    v14 = &v13[sprintf(v13, "Usage: %s", a1)];
    v15 = v14 + 3;
    strcpy(v14, " [-");
    v16 = sub_48330(&v37);
    if ( v16 )
    {
      v17 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_C54D0 + 28 * v37 + 24) != &unk_C54D8 )
          v15[v17++] = *v16;
        v16 = sub_4838C(v16, &v37);
      }
      while ( v16 );
      if ( v17 )
      {
        v14 = &v15[v17 + 1];
        *(_WORD *)&v15[v17] = 93;
      }
    }
    v18 = sprintf(v14, " %s", s);
    *(_WORD *)&v14[v18] = 10;
    v19 = &v14[v18 + 1];
    if ( dword_C54C8 )
    {
      v20 = 0;
      v21 = 0;
      do
      {
        v26 = dword_C54D0 + v20;
        v27 = *(const char **)(dword_C54D0 + v20 + 24);
        if ( v27 != (const char *)&unk_C54D8 )
        {
          if ( *(_DWORD *)(v26 + 4) == 8 )
          {
            v19 += sprintf(v19, "%s:\n", v27);
          }
          else
          {
            v22 = sprintf(v19, "%s", *(const char **)v26);
            if ( *(_DWORD *)(dword_C54D0 + v20 + 4) == 2 )
            {
              v33 = *(char **)(dword_C54D0 + v20);
              if ( !strchr(v33, 32) && !strchr(v33, 61) )
              {
                v29 = &v19[v22];
                *(_DWORD *)&v19[v22] = *(_DWORD *)" <arg>";
                v22 += 6;
                strcpy(v29 + 4, "g>");
              }
            }
            if ( v22 > 0x13 )
              v23 = 1;
            else
              v23 = 20 - v22;
            v24 = sprintf(&v19[v22], "%.*s", v23, "                    ", v33) + v22;
            v25 = v24 + sprintf(&v19[v24], "%s", *(const char **)(dword_C54D0 + v20 + 24));
            if ( *(_DWORD *)(dword_C54D0 + v20 + 16) )
            {
              v39 = 3026478;
              (*(void (__fastcall **)(char *, _DWORD))(dword_C54D0 + v20 + 16))(
                v38,
                *(_DWORD *)(dword_C54D0 + v20 + 20));
              v25 += sprintf(&v19[v25], " (default: %s)", v38);
            }
            *(_WORD *)&v19[v25] = 10;
            v19 += v25 + 1;
          }
        }
        ++v21;
        v20 += 28;
      }
      while ( dword_C54C8 > v21 );
    }
    *v19 = 0;
  }
  return v34;
}
// 48CA0: variable 'v33' is possibly undefined
// C54C4: using guessed type int dword_C54C4;
// C54C8: using guessed type int dword_C54C8;
// C54D0: using guessed type int dword_C54D0;

//----- (00048F88) --------------------------------------------------------
int __fastcall sub_48F88(int result, unsigned int a2)
{
  int v2; // r12
  unsigned int v3; // r3
  char v4; // r0
  unsigned int v5; // r1
  unsigned int v6; // r2
  bool v7; // zf

  if ( !a2 )
    JUMPOUT(0x49478);
  v2 = result ^ a2;
  if ( (a2 & 0x80000000) != 0 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v2 ^ result) < 0 )
      return -result;
  }
  else
  {
    v3 = result;
    if ( result < 0 )
      v3 = -result;
    if ( v3 <= a2 )
    {
      if ( v3 < a2 )
        result = 0;
      if ( v3 == a2 )
        return (v2 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      v4 = __clz(a2) - __clz(v3);
      v5 = a2 << v4;
      v6 = 1 << v4;
      result = 0;
      while ( 1 )
      {
        if ( v3 >= v5 )
        {
          v3 -= v5;
          result |= v6;
        }
        if ( v3 >= v5 >> 1 )
        {
          v3 -= v5 >> 1;
          result |= v6 >> 1;
        }
        if ( v3 >= v5 >> 2 )
        {
          v3 -= v5 >> 2;
          result |= v6 >> 2;
        }
        if ( v3 >= v5 >> 3 )
        {
          v3 -= v5 >> 3;
          result |= v6 >> 3;
        }
        v7 = v3 == 0;
        if ( v3 )
        {
          v6 >>= 4;
          v7 = v6 == 0;
        }
        if ( v7 )
          break;
        v5 >>= 4;
      }
      if ( v2 < 0 )
        return -result;
    }
    else
    {
      result = v3 >> (31 - __clz(a2));
      if ( v2 < 0 )
        return -result;
    }
  }
  return result;
}
// 49060: control flows out of bounds to 49478

//----- (00049084) --------------------------------------------------------
int __fastcall sub_49084(__int64 a1, __int64 a2)
{
  int v2; // r4
  int v3; // r5
  bool v4; // zf
  int v5; // r4
  bool v6; // vf
  char v7; // cc
  int v8; // r5
  __int64 v9; // r2
  int v10; // r4
  char v11; // lr
  unsigned int v12; // r12
  __int64 v13; // r0
  bool v14; // nf
  char v15; // r5
  _BOOL1 v16; // off
  _BOOL1 v17; // cf
  int v18; // off
  int v19; // r4
  bool v20; // zf
  unsigned int v21; // r3
  int v22; // r3
  bool v23; // cc
  int v24; // r2
  int v25; // r4
  int v26; // r4
  char v27; // r4
  bool v28; // zf
  bool v29; // zf

  HIDWORD(a1) ^= 0x80000000;
  v2 = 2 * HIDWORD(a1);
  v3 = 2 * HIDWORD(a2);
  v4 = 2 * HIDWORD(a1) == 2 * HIDWORD(a2);
  if ( 2 * HIDWORD(a1) == 2 * HIDWORD(a2) )
    v4 = (unsigned int)a1 == (unsigned int)a2;
  if ( !v4 )
  {
    v4 = (v2 | (unsigned int)a1) == 0;
    if ( v2 | (unsigned int)a1 )
    {
      v4 = (v3 | (unsigned int)a2) == 0;
      if ( v3 | (unsigned int)a2 )
      {
        v4 = v2 >> 21 == -1;
        if ( v2 >> 21 != -1 )
          v4 = v3 >> 21 == -1;
      }
    }
  }
  if ( v4 )
  {
    v28 = v2 >> 21 == -1;
    if ( v2 >> 21 != -1 )
      v28 = v3 >> 21 == -1;
    if ( v28 )
    {
      if ( v2 >> 21 != -1 )
        return a2;
    }
    else
    {
      v29 = v2 == v3;
      if ( v2 == v3 )
        v29 = (unsigned int)a1 == (unsigned int)a2;
      if ( v29 )
      {
        if ( HIDWORD(a1) != HIDWORD(a2) )
        {
          LODWORD(a1) = 0;
          return a1;
        }
        if ( !((unsigned int)v2 >> 21) )
        {
          LODWORD(a1) = 2 * a1;
          return a1;
        }
        if ( (unsigned int)v2 < 0xFFC00000 )
          return a1;
        goto LABEL_68;
      }
      if ( !(v2 | (unsigned int)a1) )
        LODWORD(a1) = a2;
    }
  }
  else
  {
    v5 = (unsigned int)v2 >> 21;
    v6 = __OFSUB__((unsigned int)v3 >> 21, v5);
    v8 = ((unsigned int)v3 >> 21) - v5;
    v7 = (v8 < 0) ^ v6 | (v8 == 0);
    if ( v8 < 0 != v6 )
      v8 = -v8;
    if ( !v7 )
    {
      v5 += v8;
      v9 = a1 ^ a2;
      a1 ^= v9;
      a2 = a1 ^ v9;
    }
    if ( (unsigned int)v8 <= 0x36 )
    {
      v4 = a1 >= 0;
      HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
      if ( !v4 )
        a1 = -a1;
      v4 = a2 >= 0;
      HIDWORD(a2) = HIDWORD(a2) & 0xFFFFF | 0x100000;
      if ( !v4 )
        a2 = -a2;
      if ( v5 == v8 )
      {
        HIDWORD(a2) ^= 0x100000u;
        if ( v5 )
        {
          --v8;
        }
        else
        {
          HIDWORD(a1) ^= 0x100000u;
          v5 = 1;
        }
      }
      v10 = v5 - 1;
      v11 = 32 - v8;
      if ( v8 > 32 )
      {
        v15 = v8 - 32;
        v12 = HIDWORD(a2) << (v11 + 32);
        if ( (_DWORD)a2 )
          v12 |= 2u;
        LODWORD(a1) = a1 + (SHIDWORD(a2) >> v15);
        HIDWORD(a1) += (SHIDWORD(a2) >> 31) + __CFSHR__(HIDWORD(a2), 31);
        v14 = a1 < 0;
      }
      else
      {
        v12 = (_DWORD)a2 << v11;
        v13 = a1 + ((unsigned int)a2 >> v8);
        LODWORD(a1) = v13 + (HIDWORD(a2) << v11);
        HIDWORD(a1) = (SHIDWORD(a2) >> v8) + __CFSHR__(HIDWORD(a2), v8) + HIDWORD(v13);
        v14 = a1 < 0;
      }
      if ( v14 )
      {
        v17 = v12 == 0;
        v12 = -v12;
        v16 = v17;
        v17 = __CFSUB__(0, (_DWORD)a1, v17);
        LODWORD(a1) = -(a1 + !v16);
        HIDWORD(a1) = -(HIDWORD(a1) + !v17);
      }
      if ( HIDWORD(a1) >= 0x100000 )
      {
        if ( HIDWORD(a1) < 0x200000 )
          goto LABEL_30;
        v17 = a1 & 1;
        LODWORD(a1) = a1 >> 1;
        v12 = (v12 >> 1) | (v17 << 31);
        if ( (unsigned int)((v10 + 1) << 21) < 0xFFC00000 )
          goto LABEL_30;
LABEL_68:
        JUMPOUT(0x49300);
      }
      v17 = __CFSHL__(v12, 1);
      v12 *= 2;
      v18 = v17 + (_DWORD)a1;
      v17 = __CFADD__(v17, (_DWORD)a1) | __CFADD__((_DWORD)a1, v18);
      LODWORD(a1) = a1 + v18;
      HIDWORD(a1) += v17 + HIDWORD(a1);
      v19 = v10 - 1;
      if ( (a1 & 0x10000000000000LL) != 0 )
      {
LABEL_30:
        v17 = v12 >= 0x80000000;
        if ( v12 == 0x80000000 )
          v17 = a1 & 1;
        LODWORD(a1) = v17 + (_DWORD)a1;
        return a1;
      }
      v20 = HIDWORD(a1) == 0;
      if ( !HIDWORD(a1) )
      {
        HIDWORD(a1) = a1;
        LODWORD(a1) = 0;
      }
      v21 = __clz(HIDWORD(a1));
      if ( v20 )
        v21 += 32;
      v22 = v21 - 11;
      v24 = v22 - 32;
      v23 = v22 <= 32;
      if ( v22 < 32 )
      {
        v23 = v24 <= -12;
        if ( v24 > -12 )
        {
          LODWORD(a1) = HIDWORD(a1) << v22;
          HIDWORD(a1) >>= 32 - v22;
LABEL_46:
          v7 = v19 < v22;
          v25 = v19 - v22;
          if ( v7 )
          {
            v26 = ~v25;
            v7 = v26 < 31;
            v27 = v26 - 31;
            if ( v7 )
              LODWORD(a1) = ((unsigned int)a1 >> (v27 + 32)) | (HIDWORD(a1) << -v27);
            else
              LODWORD(a1) = HIDWORD(a1) >> v27;
          }
          return a1;
        }
        LOBYTE(v24) = v22;
      }
      if ( v23 )
        LOBYTE(v12) = 32 - v24;
      HIDWORD(a1) <<= v24;
      if ( v23 )
      {
        HIDWORD(a1) |= (unsigned int)a1 >> v12;
        LODWORD(a1) = (_DWORD)a1 << v24;
      }
      goto LABEL_46;
    }
  }
  return a1;
}
// 492FC: control flows out of bounds to 49300

//----- (000493C8) --------------------------------------------------------
int __fastcall sub_493C8(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x493F8);
  return a1;
}
// 493D8: control flows out of bounds to 493F8

//----- (000493DC) --------------------------------------------------------
int __fastcall sub_493DC(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  int v9; // r4
  int v10; // r4
  char v11; // r4
  int v12; // r4
  unsigned int v13; // r12
  int v14; // r2
  int v15; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
    a1 = -a1;
  v12 = 1074;
  v13 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v14 = 3;
    if ( HIDWORD(a1) >> 25 )
      v14 = 6;
    if ( HIDWORD(a1) >> 28 )
      v14 += 3;
    v15 = v14 + (HIDWORD(a1) >> 31);
    v13 = (_DWORD)a1 << (32 - v15);
    LODWORD(a1) = ((unsigned int)a1 >> v15) | (HIDWORD(a1) << (32 - v15));
    HIDWORD(a1) >>= v15;
    v12 = v15 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v13 = (v13 >> 1) | (v1 << 31);
      if ( (unsigned int)((v12 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v13, 1);
  v13 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v12 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v13 >= 0x80000000;
    if ( v13 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v13) = 32 - v8;
    HIDWORD(a1) <<= v8;
    if ( v7 )
    {
      HIDWORD(a1) |= (unsigned int)a1 >> v13;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v9 = v3 - v6;
  if ( v7 )
  {
    v10 = ~v9;
    v7 = v10 < 31;
    v11 = v10 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v11 + 32)) | (HIDWORD(a1) << -v11);
    else
      LODWORD(a1) = HIDWORD(a1) >> v11;
  }
  return a1;
}

//----- (0004943C) --------------------------------------------------------
int __fastcall sub_4943C(__int64 a1, __int64 a2)
{
  __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _gnu_uldivmod_helper(a1, a2, &v3);
  else
    return raise(8);
}

//----- (00049488) --------------------------------------------------------
int __fastcall sub_49488(double a1)
{
  __int64 v1; // r0
  __int64 v2; // r0

  if ( a1 >= 0.0 )
  {
    LODWORD(v2) = sub_494C0(a1);
  }
  else
  {
    HIDWORD(a1) ^= 0x80000000;
    LODWORD(v1) = sub_494C0(a1);
    return -v1;
  }
  return v2;
}
// 494B0: variable 'v1' is possibly undefined

//----- (000494C0) --------------------------------------------------------
unsigned int __fastcall sub_494C0(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (00049508) --------------------------------------------------------
int __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r0

  LODWORD(v5) = sub_49580(a1, a2);
  *a3 = a1 - a2 * v5;
  return v5;
}
// 4952C: variable 'v5' is possibly undefined

//----- (00049544) --------------------------------------------------------
int __fastcall _gnu_uldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r0

  LODWORD(v5) = sub_499D8(a1, HIDWORD(a1), a2, HIDWORD(a2));
  *a3 = a1 - v5 * a2;
  return v5;
}
// 49564: variable 'v5' is possibly undefined

//----- (00049580) --------------------------------------------------------
int __fastcall sub_49580(__int64 a1, __int64 a2)
{
  __int64 v2; // kr00_8
  __int64 v3; // kr08_8
  int v4; // r4
  unsigned int v5; // r6
  unsigned int v6; // r9
  __int64 v7; // r10
  unsigned int v8; // r3
  unsigned int v9; // r5
  int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r8
  unsigned int v14; // r0
  unsigned int v15; // r10
  unsigned int v16; // r7
  unsigned int v17; // r12
  unsigned int v18; // r6
  int v19; // r12
  unsigned int v20; // r3
  unsigned int v21; // r7
  int v22; // r5
  unsigned int v23; // r8
  unsigned int v24; // r7
  int v25; // r0
  unsigned int v26; // r3
  unsigned int v27; // r2
  int v28; // r11
  unsigned int v29; // r0
  unsigned int v30; // r1
  unsigned int v31; // r9
  unsigned int v32; // r5
  unsigned int v33; // r8
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r2
  int v37; // r7
  unsigned int v38; // r0
  unsigned int v39; // r10
  unsigned int v40; // r9
  unsigned int v41; // r12
  unsigned int v42; // r6
  unsigned int v43; // r10
  bool v44; // cf
  unsigned int v45; // r6
  unsigned int v46; // r7
  unsigned int v47; // r9
  int v48; // r0
  unsigned int v49; // r1
  unsigned int v50; // r2
  int v51; // r3
  unsigned int v52; // r0
  unsigned int v53; // r1
  unsigned int v54; // r11
  unsigned int v55; // r12
  unsigned int v56; // r11
  unsigned __int64 v57; // r2
  bool v58; // r3
  __int64 v59; // r0
  unsigned int v61; // [sp+4h] [bp-8h]

  v2 = a1;
  v3 = a2;
  if ( a1 < 0 )
  {
    v4 = -1;
    v2 = -a1;
  }
  else
  {
    v4 = 0;
  }
  if ( a2 < 0 )
  {
    v4 = ~v4;
    v3 = -a2;
  }
  v5 = v3;
  v6 = HIDWORD(v2);
  LODWORD(v7) = v2;
  if ( !HIDWORD(v3) )
  {
    if ( (unsigned int)v3 > HIDWORD(v2) )
    {
      v8 = __clz(v3);
      if ( v8 )
      {
        v5 = (_DWORD)v3 << v8;
        LODWORD(v7) = (_DWORD)v2 << v8;
        v6 = ((unsigned int)v2 >> (32 - v8)) | (HIDWORD(v2) << v8);
      }
      v9 = HIWORD(v5);
      v10 = v6 / HIWORD(v5);
      v11 = WORD1(v7) | ((v6 % HIWORD(v5)) << 16);
      v12 = (unsigned __int16)v5 * v10;
      if ( v11 < v12 )
      {
        v44 = __CFADD__(v11, v5);
        v11 += v5;
        v13 = v10 - 1;
        if ( !v44 && v11 < v12 )
        {
          v13 = v10 - 2;
          v11 += v5;
        }
      }
      else
      {
        v13 = v6 / v9;
      }
      v14 = (v11 - v12) / v9;
      v15 = (unsigned __int16)v7 | (((v11 - v12) % v9) << 16);
      v16 = (unsigned __int16)v5 * v14;
      if ( v15 < v16 )
      {
        v44 = __CFADD__(v15, v5);
        v18 = v15 + v5;
        v17 = v14 - 1;
        if ( !v44 && v18 < v16 )
          v17 = v14 - 2;
      }
      else
      {
        v17 = (v11 - v12) / v9;
      }
      v19 = v17 | (v13 << 16);
      goto LABEL_70;
    }
    if ( !(_DWORD)v3 )
      v5 = 1 / 0u;
    v20 = __clz(v5);
    if ( v20 )
    {
      v5 <<= v20;
      HIDWORD(v7) = HIDWORD(v2) >> (32 - v20);
      v23 = HIWORD(v5);
      v24 = ((unsigned int)v2 >> (32 - v20)) | (HIDWORD(v2) << v20);
      LODWORD(v7) = (_DWORD)v2 << v20;
      v25 = HIDWORD(v7) / HIWORD(v5);
      v26 = HIWORD(v24) | ((HIDWORD(v7) % HIWORD(v5)) << 16);
      v27 = (unsigned __int16)v5 * v25;
      if ( v26 < v27 )
      {
        v44 = __CFADD__(v26, v5);
        v26 += v5;
        v28 = v25 - 1;
        if ( !v44 && v26 < v27 )
        {
          v28 = v25 - 2;
          v26 += v5;
        }
      }
      else
      {
        v28 = HIDWORD(v7) / v23;
      }
      v29 = (v26 - v27) / v23;
      v30 = (unsigned __int16)v24 | (((v26 - v27) % v23) << 16);
      v31 = (unsigned __int16)v5 * v29;
      if ( v30 < v31 )
      {
        v44 = __CFADD__(v30, v5);
        v30 += v5;
        v32 = v29 - 1;
        if ( !v44 && v30 < v31 )
        {
          v32 = v29 - 2;
          v30 += v5;
        }
      }
      else
      {
        v32 = (v26 - v27) / v23;
      }
      v21 = v30 - v31;
      v22 = v32 | (v28 << 16);
    }
    else
    {
      v21 = HIDWORD(v2) - v5;
      v22 = 1;
    }
    v33 = HIWORD(v5);
    v34 = v21 / HIWORD(v5);
    HIDWORD(v7) = v21 % HIWORD(v5);
    v35 = v7 >> 16;
    v36 = (unsigned __int16)v5 * v34;
    if ( v35 < v36 )
    {
      v44 = __CFADD__(v35, v5);
      v35 += v5;
      v37 = v34 - 1;
      if ( !v44 && v35 < v36 )
      {
        v37 = v34 - 2;
        v35 += v5;
      }
    }
    else
    {
      v37 = v21 / v33;
    }
    v38 = (v35 - v36) / v33;
    v39 = (unsigned __int16)v7 | (((v35 - v36) % v33) << 16);
    v40 = (unsigned __int16)v5 * v38;
    if ( v39 < v40 )
    {
      v44 = __CFADD__(v39, v5);
      v42 = v39 + v5;
      v41 = v38 - 1;
      if ( !v44 && v42 < v40 )
        v41 = v38 - 2;
    }
    else
    {
      v41 = (v35 - v36) / v33;
    }
    v19 = v41 | (v37 << 16);
    goto LABEL_73;
  }
  if ( HIDWORD(v3) > HIDWORD(v2) )
  {
    v22 = 0;
LABEL_72:
    v19 = 0;
    goto LABEL_73;
  }
  v43 = __clz(HIDWORD(v3));
  if ( !v43 )
  {
    v44 = HIDWORD(v2) >= HIDWORD(v3);
    if ( HIDWORD(v2) <= HIDWORD(v3) )
      v44 = (unsigned int)v2 >= (unsigned int)v3;
    if ( v44 )
    {
      v19 = 1;
      v22 = 0;
      goto LABEL_73;
    }
    v22 = 0;
    goto LABEL_72;
  }
  v45 = ((unsigned int)v3 >> (32 - v43)) | (HIDWORD(v3) << v43);
  v46 = ((unsigned int)v2 >> (32 - v43)) | (HIDWORD(v2) << v43);
  v47 = HIWORD(v45);
  v61 = HIDWORD(v2) >> (32 - v43);
  v48 = v61 / HIWORD(v45);
  v49 = HIWORD(v46) | ((v61 % HIWORD(v45)) << 16);
  v50 = (unsigned __int16)v45 * v48;
  if ( v49 < v50 )
  {
    v44 = __CFADD__(v49, v45);
    v49 += v45;
    v51 = v48 - 1;
    if ( !v44 && v49 < v50 )
    {
      v51 = v48 - 2;
      v49 += v45;
    }
  }
  else
  {
    v51 = v61 / v47;
  }
  v52 = (v49 - v50) / v47;
  v53 = (unsigned __int16)v46 | (((v49 - v50) % v47) << 16);
  v54 = (unsigned __int16)v45 * v52;
  if ( v53 < v54 )
  {
    v44 = __CFADD__(v53, v45);
    v53 += v45;
    v55 = v52 - 1;
    if ( !v44 && v53 < v54 )
    {
      v55 = v52 - 2;
      v53 += v45;
    }
  }
  else
  {
    v55 = v52;
  }
  v19 = v55 | (v51 << 16);
  v56 = v53 - v54;
  v57 = (unsigned int)v19 * (unsigned __int64)(unsigned int)((_DWORD)v3 << v43);
  if ( HIDWORD(v57) > v56
    || ((v58 = HIDWORD(v57) == v56, (unsigned int)v57 > (_DWORD)v2 << v43) ? (v22 = v58) : (v22 = 0), v22) )
  {
    --v19;
LABEL_70:
    v22 = 0;
  }
LABEL_73:
  LODWORD(v59) = v19;
  if ( v4 )
    return -__SPAIR64__(v22, v19);
  return v59;
}

//----- (000499D8) --------------------------------------------------------
int __fastcall sub_499D8(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // r4
  unsigned int v6; // r7
  unsigned int v7; // r10
  unsigned int v8; // r3
  unsigned int v9; // r5
  int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r6
  unsigned int v14; // r0
  unsigned int v15; // r7
  unsigned int v16; // r8
  unsigned int v17; // r3
  unsigned int v18; // r4
  int result; // r0
  unsigned int v20; // r3
  unsigned int v21; // r10
  unsigned int v22; // r6
  unsigned int v23; // r8
  int v24; // r0
  unsigned int v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r1
  unsigned int v28; // r10
  unsigned int v29; // r6
  int v30; // r0
  unsigned int v31; // r3
  unsigned int v32; // r2
  int v33; // r10
  unsigned int v34; // r0
  unsigned int v35; // r7
  unsigned int v36; // r8
  unsigned int v37; // r3
  unsigned int v38; // r4
  unsigned int v39; // r7
  bool v40; // cf
  unsigned int v41; // r11
  unsigned int v42; // r4
  unsigned int v43; // r5
  unsigned int v44; // r10
  int v45; // r0
  unsigned int v46; // r12
  unsigned int v47; // r3
  int v48; // r11
  unsigned int v49; // r0
  unsigned int v50; // r1
  unsigned int v51; // r9
  unsigned int v52; // r3
  unsigned int v53; // r9
  unsigned __int64 v54; // r2
  _BOOL4 v55; // r5

  v5 = a3;
  v6 = a1;
  v7 = a2;
  if ( !a4 )
  {
    if ( a3 <= a2 )
    {
      if ( !a3 )
        v5 = 1 / 0u;
      v20 = __clz(v5);
      if ( v20 )
      {
        v5 <<= v20;
        v6 = a1 << v20;
        v22 = HIWORD(v5);
        v23 = (a1 >> (32 - v20)) | (a2 << v20);
        v24 = (a2 >> (32 - v20)) / HIWORD(v5);
        v25 = HIWORD(v23) | (((a2 >> (32 - v20)) % HIWORD(v5)) << 16);
        v26 = (unsigned __int16)v5 * v24;
        if ( v25 < v26 )
        {
          v40 = __CFADD__(v25, v5);
          v25 += v5;
          if ( !v40 && v25 < v26 )
            v25 += v5;
        }
        v27 = (unsigned __int16)v23 | (((v25 - v26) % v22) << 16);
        v28 = (unsigned __int16)v5 * ((v25 - v26) / v22);
        if ( v27 < v28 )
        {
          v40 = __CFADD__(v27, v5);
          v27 += v5;
          if ( !v40 && v27 < v28 )
            v27 += v5;
        }
        v21 = v27 - v28;
      }
      else
      {
        v21 = a2 - v5;
      }
      v29 = HIWORD(v5);
      v30 = v21 / HIWORD(v5);
      v31 = HIWORD(v6) | ((v21 % HIWORD(v5)) << 16);
      v32 = (unsigned __int16)v5 * v30;
      if ( v31 < v32 )
      {
        v40 = __CFADD__(v31, v5);
        v31 += v5;
        v33 = v30 - 1;
        if ( !v40 && v31 < v32 )
        {
          v33 = v30 - 2;
          v31 += v5;
        }
      }
      else
      {
        v33 = v21 / v29;
      }
      v34 = (v31 - v32) / v29;
      v35 = (unsigned __int16)v6 | (((v31 - v32) % v29) << 16);
      v36 = (unsigned __int16)v5 * v34;
      if ( v35 < v36 )
      {
        v40 = __CFADD__(v35, v5);
        v38 = v35 + v5;
        v37 = v34 - 1;
        if ( !v40 && v38 < v36 )
          v37 = v34 - 2;
      }
      else
      {
        v37 = (v31 - v32) / v29;
      }
      return v37 | (v33 << 16);
    }
    else
    {
      v8 = __clz(a3);
      if ( v8 )
      {
        v5 = a3 << v8;
        v6 = a1 << v8;
        v7 = (a1 >> (32 - v8)) | (a2 << v8);
      }
      v9 = HIWORD(v5);
      v10 = v7 / HIWORD(v5);
      v11 = HIWORD(v6) | ((v7 % HIWORD(v5)) << 16);
      v12 = (unsigned __int16)v5 * v10;
      if ( v11 < v12 )
      {
        v40 = __CFADD__(v11, v5);
        v11 += v5;
        v13 = v10 - 1;
        if ( !v40 && v11 < v12 )
        {
          v13 = v10 - 2;
          v11 += v5;
        }
      }
      else
      {
        v13 = v7 / v9;
      }
      v14 = (v11 - v12) / v9;
      v15 = (unsigned __int16)v6 | (((v11 - v12) % v9) << 16);
      v16 = (unsigned __int16)v5 * v14;
      if ( v15 < v16 )
      {
        v40 = __CFADD__(v15, v5);
        v18 = v15 + v5;
        v17 = v14 - 1;
        if ( !v40 && v18 < v16 )
          v17 = v14 - 2;
      }
      else
      {
        v17 = (v11 - v12) / v9;
      }
      return v17 | (v13 << 16);
    }
  }
  if ( a4 > a2 )
    return 0;
  v39 = __clz(a4);
  if ( !v39 )
  {
    v40 = a2 >= a4;
    if ( a2 <= a4 )
      return a1 >= a3;
    return v40;
  }
  v41 = a2 >> (32 - v39);
  v42 = (a3 >> (32 - v39)) | (a4 << v39);
  v43 = (a1 >> (32 - v39)) | (a2 << v39);
  v44 = HIWORD(v42);
  v45 = v41 / HIWORD(v42);
  v46 = HIWORD(v43) | ((v41 % HIWORD(v42)) << 16);
  v47 = (unsigned __int16)v42 * v45;
  if ( v46 < v47 )
  {
    v40 = __CFADD__(v46, v42);
    v46 += v42;
    v48 = v45 - 1;
    if ( !v40 && v46 < v47 )
    {
      v48 = v45 - 2;
      v46 += v42;
    }
  }
  else
  {
    v48 = v41 / v44;
  }
  v49 = (v46 - v47) / v44;
  v50 = (unsigned __int16)v43 | (((v46 - v47) % v44) << 16);
  v51 = (unsigned __int16)v42 * v49;
  if ( v50 < v51 )
  {
    v40 = __CFADD__(v50, v42);
    v50 += v42;
    v52 = v49 - 1;
    if ( !v40 && v50 < v51 )
    {
      v52 = v49 - 2;
      v50 += v42;
    }
  }
  else
  {
    v52 = (v46 - v47) / v44;
  }
  result = v52 | (v48 << 16);
  v53 = v50 - v51;
  v54 = (unsigned int)result * (unsigned __int64)(a3 << v39);
  if ( HIDWORD(v54) > v53 || ((unsigned int)v54 > a1 << v39 ? (v55 = HIDWORD(v54) == v53) : (v55 = 0), v55) )
    --result;
  return result;
}

//----- (00049DB8) --------------------------------------------------------
void __fastcall init(int a1, int a2, int a3)
{
  int v6; // r6
  unsigned int v7; // r5
  int v8; // r4
  void (__fastcall *v9)(int, int, int); // t1

  init_proc();
  v6 = &off_5F44C - off_5F448;
  if ( v6 )
  {
    v7 = 0x5F444u;
    v8 = 0;
    do
    {
      ++v8;
      v9 = *(void (__fastcall **)(int, int, int))(v7 + 4);
      v7 += 4;
      v9(a1, a2, a3);
    }
    while ( v8 != v6 );
  }
}
// 5F448: using guessed type int (*off_5F448[2])();
// 5F44C: using guessed type int (*off_5F44C)();

//----- (00049E20) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=1079 queued=670 decompiled=670 lumina nreq=0 worse=0 better=0
// ALL OK, 670 function(s) have been successfully decompiled
