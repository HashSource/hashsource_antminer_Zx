void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int (**v3)(); // r9
  int v4; // r0
  int (*v5)(void); // r3
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r6
  const char **v11; // r7
  int v12; // r4
  int v13; // r5
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  unsigned int v48; // r3
  int v49; // r2
  unsigned int v50; // r0
  unsigned int v51; // r3
  unsigned int v52; // r2
  unsigned int v53; // r3
  _DWORD *v54; // r2
  int v55; // r3
  int v56; // r2
  _DWORD *v57; // r2
  int v58; // r1
  int v59; // r5
  size_t v60; // r6
  _DWORD *v61; // r0
  _DWORD *v62; // r7
  _DWORD *v63; // r0
  unsigned int v64; // r3
  _DWORD *v65; // r1
  _DWORD *v66; // r5
  unsigned int ii; // r6
  _DWORD *v68; // r9
  int v69; // r6
  char *v70; // r8
  unsigned int v71; // r3
  int v72; // r3
  _DWORD *v73; // r3
  unsigned int v74; // r1
  unsigned int v75; // r2
  bool v76; // cc
  int v77; // r2
  int v78; // r3
  int v79; // r5
  char *v80; // r9
  _DWORD *v81; // r0
  const char *v82; // r2
  _DWORD *v83; // r3
  int v84; // r0
  int v85; // r1
  int v86; // r2
  int v87; // r3
  int v88; // r3
  int v89; // r4
  int v90; // r5
  int v91; // r9
  char *v92; // r9
  FILE *v93; // r4
  signed int v94; // r0
  char *v95; // r0
  const char *v96; // r1
  char *v97; // r4
  char *v98; // r0
  unsigned __int8 *v99; // r4
  unsigned __int8 *v100; // r3
  unsigned __int8 *v101; // r3
  unsigned __int8 *v102; // r3
  size_t v103; // r0
  char *v104; // r12
  int v105; // r2
  int v106; // r0
  bool v107; // zf
  char *v108; // r12
  FILE *v109; // r0
  int v110; // r3
  int v111; // r3
  bool v112; // zf
  int *v113; // r6
  int v114; // r10
  char *v115; // r9
  FILE *v116; // r0
  int v117; // r3
  int v118; // r10
  char *v119; // r6
  char *v120; // r9
  char *v121; // r4
  FILE *v122; // r0
  int v123; // r3
  char *v124; // r12
  int v125; // r5
  int v126; // r6
  pthread_rwlock_t *v127; // r0
  char *v128; // r0
  char *v129; // r7
  int v130; // r5
  char *v131; // r8
  unsigned int v132; // r6
  int v133; // r3
  int v134; // r3
  char *v135; // r12
  char *v136; // r12
  int *v137; // r3
  int v138; // r0
  int v139; // t1
  char *v140; // r12
  char *v141; // r12
  int v142; // r6
  unsigned __int8 *v143; // r7
  int v144; // r9
  int v145; // r3
  const char *v146; // r10
  size_t v147; // r0
  size_t v148; // r4
  char *v149; // r0
  char *v150; // r12
  int v151; // r2
  __sighandler_t v152; // r7
  __sighandler_t v153; // r0
  bool v154; // zf
  __pid_t v155; // r0
  __pid_t v156; // r7
  char *v157; // r12
  _DWORD *v158; // r0
  _DWORD *v159; // r7
  void *v160; // r0
  FILE *v161; // r0
  int v162; // r3
  char *v163; // r12
  char *v164; // r12
  int v165; // r3
  int v166; // r12
  int v167; // r1
  int v168; // r2
  int j; // r7
  int v170; // r6
  int v171; // r9
  int k; // r8
  int v173; // r7
  _DWORD *v174; // r4
  int v175; // r6
  _DWORD *v176; // r0
  int v177; // r3
  sem_t *v178; // r0
  sem_t *v179; // r6
  _BYTE *v180; // r4
  int v181; // r3
  int *v182; // r1
  int v183; // r12
  int v184; // r1
  int v185; // r0
  int v186; // lr
  int v187; // r6
  int v188; // r9
  int v189; // r6
  int v190; // r12
  int v191; // r2
  int v192; // lr
  int v193; // r3
  int v194; // r2
  int v195; // r1
  const char *v196; // r1
  char *v197; // r12
  int v198; // r3
  char *v199; // r12
  int v200; // r7
  int v201; // r6
  int v202; // r3
  int v203; // r3
  _BYTE *v204; // r0
  int v205; // r0
  int v206; // r8
  int v207; // r0
  int v208; // r2
  int *v209; // lr
  int v210; // r0
  int v211; // r3
  int v212; // t1
  int v213; // r9
  int v214; // t1
  int v215; // r3
  int v216; // r9
  int v217; // r3
  int v218; // r3
  int v219; // r0
  int v220; // r1
  int v221; // r12
  int v222; // r0
  struct timeval *v223; // r6
  _BYTE *v224; // r9
  _DWORD *v225; // r3
  _BYTE *v226; // r0
  const char *v227; // lr
  int v228; // r0
  int v229; // r1
  int v230; // r2
  int v231; // r3
  _DWORD *v232; // lr
  char *v233; // r12
  int v234; // r1
  int v235; // r2
  char *v236; // r12
  _BYTE *v237; // r0
  char *v238; // r12
  int *v239; // r3
  int v240; // r1
  int v241; // t1
  int v242; // r9
  int v243; // r2
  int *v244; // lr
  int v245; // r0
  int v246; // r3
  int v247; // t1
  int v248; // r6
  int v249; // t1
  int v250; // r3
  int v251; // r6
  int v252; // r3
  int v253; // r3
  int v254; // r0
  int v255; // r1
  int v256; // r12
  int v257; // r0
  int v258; // r6
  struct timeval *v259; // r9
  __suseconds_t *v260; // r8
  __time_t v261; // r0
  __suseconds_t v262; // r1
  __time_t v263; // r2
  __suseconds_t v264; // r3
  __time_t v265; // r0
  __suseconds_t v266; // r1
  __suseconds_t v267; // r3
  const char **v268; // r12
  char *v269; // r12
  char *v270; // r12
  char *v271; // r12
  char *v272; // r12
  int m; // r6
  int v274; // r3
  int v275; // r8
  char *v276; // r10
  char *v277; // r9
  int n; // r8
  char *v279; // r12
  int v280; // r2
  char *v281; // r12
  char *v282; // r12
  char v283; // [sp+10h] [bp-29FCh] BYREF
  char v284[4088]; // [sp+1018h] [bp-19F4h] BYREF
  const char *v285; // [sp+2024h] [bp-9E8h]
  int *v286; // [sp+2028h] [bp-9E4h]
  void (__fastcall **v287)(); // [sp+202Ch] [bp-9E0h]
  char *v288; // [sp+2030h] [bp-9DCh]
  int *v289; // [sp+2034h] [bp-9D8h]
  char *v290; // [sp+2038h] [bp-9D4h]
  const char **v291; // [sp+203Ch] [bp-9D0h]
  char *s; // [sp+2040h] [bp-9CCh]
  _BYTE *v293; // [sp+2044h] [bp-9C8h]
  int *v294; // [sp+2048h] [bp-9C4h]
  int v295; // [sp+204Ch] [bp-9C0h] BYREF
  struct sigaction v296; // [sp+2054h] [bp-9B8h] BYREF
  char v297[256]; // [sp+20E0h] [bp-92Ch] BYREF
  int v298[513]; // [sp+21E0h] [bp-82Ch] BYREF

  v291 = a2;
  v295 = a1;
  strcpy(dword_62FA0, "cgminer.log");
  strcpy(word_630A0, "a+");
  byte_62F98 = 0;
  v4 = sysconf(84);
  v6 = v4 == 1;
  if ( v4 == 1 )
  {
    v5 = sched_yield;
    v3 = &off_60178;
  }
  v7 = 4 * (v295 + 1);
  if ( v6 )
    *v3 = v5;
  v8 = malloc(v7);
  v9 = v295;
  v10 = v8;
  dword_6141C = (int)v8;
  if ( v295 > 0 )
  {
    v11 = v291;
    v12 = 0;
    v13 = 0;
    do
    {
      ++v13;
      v14 = _strdup(v11[v12]);
      v9 = v295;
      v76 = v295 <= v13;
      v10[v12++] = v14;
    }
    while ( !v76 );
  }
  v10[v9] = 0;
  sub_173C0(&stru_6392C, "main", 10697);
  sub_173C0(&stru_63DFC, "main", 10698);
  sub_173C0(&stru_63D48, "main", 10699);
  sub_17418((int)&stru_63FB0, "main", 10700);
  sub_173C0(&mutex, "main", 10701);
  sub_173C0(&stru_61538, "main", 10702);
  sub_17418((int)&stru_63F78, "main", 10703);
  sub_173C0(&stru_612DC, "main", 10704);
  sub_173EC(&stru_61550, "main", 10705);
  sub_173EC(&stru_63880, "main", 10706);
  sub_173EC(&rwlock, "main", 10707);
  sub_173EC(&stru_63CA0, "main", 10708);
  sub_173C0(&stru_61314, "main", 10710);
  if ( pthread_cond_init(&stru_61330, 0) )
  {
    strcpy((char *)v298, "Failed to pthread_cond_init lp_cond");
    sub_38438(3, (const char *)v298, 1);
    sub_1C160(1, 0);
  }
  sub_173C0(&stru_63BCC, "main", 10714);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v298, "Failed to pthread_cond_init restart_cond");
    v196 = (const char *)v298;
    goto LABEL_325;
  }
  if ( pthread_cond_init(&stru_63748, 0) )
  {
    strcpy((char *)v298, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2AA90();
    dword_63BC0 = (int)v15;
    if ( v15 )
    {
      dword_612C8 = (int)(v15 + 12);
      snprintf(byte_60EA4, 0x100u, "%s %s", "cgminer", a49);
      v296.sa_flags = 0;
      v296.sa_handler = (__sighandler_t)sub_1738C;
      sigemptyset(&v296.sa_mask);
      sigaction(15, &v296, &oact);
      sigaction(2, &v296, &stru_63EEC);
      signal(13, (__sighandler_t)1);
      dword_64214 = (int)v284;
      strcpy(v284, "/usr/bin");
      dword_63E54 = (int)&v283;
      v16 = _strdup(*v291);
      v17 = (char *)dword_63E54;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_63E54 + strlen((const char *)dword_63E54)) = 47;
      dword_61308 = 8;
      dword_612FC = 9;
      dword_61304 = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        s = (char *)v298;
        strcpy((char *)v298, "main OOM");
        sub_38438(3, (const char *)v298, 1);
        sub_16724(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_61570;
      v6 = dword_61570 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_61570 = (int)v20;
        v158 = malloc(0x2Cu);
        v159 = v158;
        *((_DWORD *)v20 + 17) = v158;
        if ( !v158 )
          goto LABEL_310;
        memset(v158, 0, 0x2Cu);
        v294 = (int *)(v20 + 68);
        v159[1] = 32;
        v159[2] = 5;
        v159[4] = v20 + 68;
        v159[5] = 68;
        v160 = malloc(0x180u);
        *v159 = v160;
        if ( !v160 )
          goto LABEL_310;
        memset(v160, 0, 0x180u);
        v24 = (int)v20;
        v159[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v294 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_31;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 0xAu:
          goto LABEL_22;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_22:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_23:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_24:
          v27 += v22[7] << 24;
LABEL_25:
          v27 += v22[6] << 16;
LABEL_26:
          v27 += v22[5] << 8;
LABEL_27:
          v27 += v22[4];
LABEL_28:
          v28 += v22[3] << 24;
LABEL_29:
          v28 += v22[2] << 16;
LABEL_30:
          v28 += v22[1] << 8;
LABEL_31:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = (v45 - v46 - v47) ^ (v47 >> 13);
      v49 = (v46 - v47 - v48) ^ (v48 >> 12);
      v50 = (v47 - v48 - v49) ^ (v49 << 16);
      v51 = (v48 - v49 - v50) ^ (v50 >> 5);
      v52 = v49 - v50 - v51;
      v53 = (v51 - (v52 ^ (v51 >> 3)) - ((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)))
          ^ (((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v53;
      v54 = *(_DWORD **)(v24 + 68);
      v55 = 12 * (v53 & (v54[1] - 1));
      ++*(_DWORD *)(*v54 + v55 + 4);
      v56 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v55);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v56;
      v57 = *(_DWORD **)(v24 + 68);
      v58 = *(_DWORD *)(*v57 + v55);
      if ( v58 )
      {
        *(_DWORD *)(v58 + 12) = v294;
        v57 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v57 + v55) = v294;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v55 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v55 + 8)
                                                                          + 1))
        || (v59 = *((_DWORD *)v20 + 17), *(_DWORD *)(v59 + 36) == 1) )
      {
LABEL_57:
        strcpy(dest, v20);
        dword_639E8 = (int)&dword_639E8;
        dword_639EC = (int)&dword_639E8;
        sub_48430((int)&off_5F8A0, (int)"Options for both config file and command line");
        sub_48430((int)&off_600C4, (int)"Options for command line only");
        sub_484FC(&v295, v291, (void (*)(const char *, ...))sub_1187C);
        if ( v295 != 1 )
        {
          strcpy((char *)v298, "Unexpected extra commandline arguments");
          sub_38438(3, (const char *)v298, 1);
          sub_1C160(1, 0);
        }
        v79 = (unsigned __int8)byte_611D0;
        if ( !byte_611D0 )
        {
          dword_611D4 = (int)malloc(0x1000u);
          sub_15C88((char *)dword_611D4);
          if ( access((const char *)dword_611D4, 4) )
          {
            free((void *)dword_611D4);
            dword_611D4 = v79;
          }
          else
          {
            sub_16814((char *)dword_611D4);
          }
        }
        if ( byte_615C9 || dword_612AC )
        {
          if ( byte_63DF9 )
          {
            s = (char *)v298;
            strcpy((char *)v298, "Cannot use benchmark mode with scrypt");
            sub_38438(3, (const char *)v298, 1);
            sub_16724(1);
          }
          s = (char *)v298;
          v80 = sub_1746C();
          v81 = malloc(0xFFu);
          if ( dword_612AC )
            v82 = "Benchfile";
          else
            v82 = "Benchmark";
          *((_DWORD *)v80 + 41) = v81;
          v83 = v81;
          v84 = *(_DWORD *)v82;
          v85 = *((_DWORD *)v82 + 1);
          v86 = *((_DWORD *)v82 + 2);
          *v83 = v84;
          v83[1] = v85;
          *((_WORD *)v83 + 4) = v86;
          v87 = *((_DWORD *)v80 + 41);
          *((_DWORD *)v80 + 43) = v87;
          *((_DWORD *)v80 + 44) = v87;
          *((_DWORD *)v80 + 42) = v87;
          *((_DWORD *)v80 + 148) = v87;
          strncpy(v80 + 48, "?", 7u);
          v88 = *((_DWORD *)v80 + 25);
          v80[55] = 0;
          if ( v88 != 1 )
          {
            *((_DWORD *)v80 + 25) = 1;
            ++dword_63B84;
          }
          v89 = 0;
          v80[97] = 0;
          byte_62F60 = 1;
          do
          {
            v90 = 324 * v89;
            v91 = 5 * v89++;
            v92 = (char *)(32 * v91);
            sub_295B8(&byte_615D8[(_DWORD)v92], (unsigned __int8 *)&a000000029c6bf4[v90], 160);
            sub_295B8(&byte_61FD8[(_DWORD)v92], (unsigned __int8 *)&a00000002c01f50[v90], 160);
          }
          while ( v89 != 16 );
          sub_15D7C((int)dword_629EC);
        }
        else
        {
          v92 = (char *)v298;
          s = (char *)v298;
        }
        if ( !dword_60EA0 )
        {
          v99 = byte_62E80;
          v290 = &byte_632F0;
          goto LABEL_103;
        }
        v93 = fopen((const char *)dword_60EA0, "rb");
        memset(v297, 0, sizeof(v297));
        if ( v93 )
        {
          v94 = fread(v297, 1u, 0x100u, v93);
          if ( v94 > 0 )
          {
            v95 = strchr(v297, 10);
            v96 = v297;
            v97 = v95;
            v6 = v95 == 0;
            v98 = ::s;
            if ( !v6 )
            {
              memcpy(::s, v297, v97 - v297);
              v98 = byte_62B0C;
              v96 = v97 + 1;
            }
            strcpy(v98, v96);
            v99 = byte_62E80;
            v100 = &byte_62E80[strlen(::s) - 1];
            if ( *(v100 - 1140) == 10 )
              *(v100 - 1140) = 0;
            v101 = &byte_62E80[strlen(::s) - 1];
            if ( *(v101 - 1140) == 13 )
              *(v101 - 1140) = 0;
            v102 = &byte_62E80[strlen(byte_62B0C) - 1];
            if ( *(v102 - 884) == 10 )
              *(v102 - 884) = 0;
            v103 = strlen(byte_62B0C) - 1;
            v105 = byte_62E80[v103 - 884];
            if ( v105 == 13 )
            {
              v104 = &byte_632F0;
              byte_62E80[v103 - 884] = 0;
            }
            else
            {
              v92 = &byte_632F0;
            }
            if ( v105 == 13 )
              v290 = v104;
            else
              v290 = v92;
            goto LABEL_98;
          }
          v290 = &byte_632F0;
          if ( byte_632F0 || (v288 = &byte_630C0, byte_630C0) || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_60EA0, v94);
            goto LABEL_252;
          }
        }
        else
        {
          v290 = &byte_632F0;
          if ( byte_632F0 || (v288 = &byte_630C0, byte_630C0) || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_60EA0);
LABEL_252:
            v99 = byte_62E80;
            sub_38438(3, s, 0);
LABEL_98:
            if ( *v290 )
            {
LABEL_102:
              snprintf(s, 0x800u, "Miner compile time: %s type: %s", ::s, byte_62B0C);
              sub_38438(3, s, 0);
              goto LABEL_103;
            }
            v288 = &byte_630C0;
            goto LABEL_100;
          }
        }
        v99 = byte_62E80;
LABEL_100:
        if ( *v288 || dword_60964 > 2 )
          goto LABEL_102;
LABEL_103:
        if ( dword_60E90 )
        {
          byte_62F98 = 1;
          strcpy(dword_62FA0, (const char *)dword_60E90);
          if ( dword_60E9C )
            strcpy(word_630A0, (const char *)dword_60E9C);
          if ( *v290 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log file path: %s Open flag: %s", dword_62FA0, word_630A0);
            sub_38438(3, s, 0);
          }
        }
        if ( dword_60E98 )
        {
          memset(v297, 0, sizeof(v297));
          if ( dword_60E94 )
          {
            if ( !*(_BYTE *)dword_60E94 )
            {
              v157 = s;
              *(_DWORD *)s = *(_DWORD *)"Log work asic num empty";
              strcpy(v157 + 4, "work asic num empty");
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            v106 = strtol((const char *)dword_60E94, 0, 10);
            v107 = v106 == 32;
            if ( v106 != 32 )
              v107 = v106 == 1;
            dword_62C0C = v106;
            if ( !v107 && v106 != 64 )
            {
              v108 = s;
              *(_DWORD *)s = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy(v108 + 4, "work asic num must be 1, 32, 64");
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            if ( *v290 || byte_630C0 || dword_60964 > 2 )
            {
              snprintf(
                s,
                0x800u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_60E98,
                (const char *)dword_60E94);
              sub_38438(3, s, 0);
            }
          }
          else if ( *v290 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log work path: %s", (const char *)dword_60E98);
            sub_38438(3, s, 0);
          }
          sprintf(v297, "%s.txt", (const char *)dword_60E98);
          v109 = fopen(v297, "a+");
          v110 = (unsigned __int8)*v290;
          dword_62C10 = (int)v109;
          if ( v110 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log work open file %s", v297);
            sub_38438(3, s, 0);
          }
          v111 = dword_62C0C;
          if ( dword_62C0C == 1 )
          {
            sprintf(v297, "%s%02d.txt", (const char *)dword_60E98, 1);
            v161 = fopen(v297, "a+");
            v162 = (unsigned __int8)*v290;
            dword_62C14[0] = (int)v161;
            if ( v162 || byte_630C0 || dword_60964 > 2 )
            {
              snprintf(s, 0x800u, "Log work open asic %d file %s", dword_62C0C, v297);
              sub_38438(3, s, 0);
            }
          }
          else
          {
            v112 = dword_62C0C == 32;
            if ( dword_62C0C != 32 )
              v112 = dword_62C0C == 64;
            if ( v112 && dword_62C0C >= 0 )
            {
              v113 = &dword_62C10;
              v114 = 0;
              v115 = s;
              do
              {
                sprintf(v297, "%s%02d_%02d.txt", (const char *)dword_60E98, v111, v114);
                v116 = fopen(v297, "a+");
                v117 = (unsigned __int8)*v290;
                v113[1] = (int)v116;
                ++v113;
                if ( v117 || byte_630C0 || dword_60964 > 2 )
                {
                  snprintf(v115, 0x800u, "Log work open asic %d file %s", dword_62C0C, v297);
                  sub_38438(3, v115, 0);
                }
                v111 = dword_62C0C;
                ++v114;
              }
              while ( dword_62C0C >= v114 );
            }
          }
          if ( byte_62D18 )
          {
            v294 = (int *)byte_62E80;
            v118 = 0;
            v119 = &byte_62D18;
            v120 = s;
            v121 = v290;
            do
            {
              sprintf(v297, "%s_diff_%02d.txt", (const char *)dword_60E98, v118);
              v122 = fopen(v297, "a+");
              v123 = (unsigned __int8)*v121;
              *((_DWORD *)v119 + 1) = v122;
              v119 += 4;
              if ( v123 || byte_630C0 || dword_60964 > 2 )
              {
                snprintf(v120, 0x800u, "Log work open diff file %s", v297);
                sub_38438(3, v120, 0);
              }
              ++v118;
            }
            while ( v118 != 65 );
            v99 = (unsigned __int8 *)v294;
          }
        }
        if ( byte_640B8 )
        {
          v289 = dword_5F890;
          byte_6007C = 0;
        }
        else
        {
          v289 = dword_5F890;
          if ( byte_6007C )
            sub_277B0();
        }
        if ( *v290 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Started %s", byte_60EA4);
          sub_38438(4, s, 0);
        }
        if ( !dword_611D4 )
        {
LABEL_167:
          *(_WORD *)(dword_64214 + strlen((const char *)dword_64214)) = 47;
          if ( byte_63DF8 )
            byte_630C0 = 1;
          if ( v289[512] < 0 )
          {
            if ( byte_63DF9 )
              v134 = 30;
            else
              v134 = 60;
            v289[512] = v134;
          }
          *(_DWORD *)&v99[-96] = 8;
          dword_636A4 = (int)calloc(8u, 0x40u);
          if ( !dword_636A4 )
          {
            v164 = s;
            *(_DWORD *)s = *(_DWORD *)"Failed to calloc control_thr";
            strcpy(v164 + 4, "ed to calloc control_thr");
            sub_38438(3, s, 1);
            sub_1C160(1, 0);
          }
          v125 = 0;
          dword_62E24 = 0;
          v285 = (const char *)&unk_63CC8;
          sub_278E0((int)&unk_63CC8);
          sub_278E0((int)&unk_63270);
          sub_278E0((int)&unk_63D78);
          sub_278E0((int)&unk_639F0);
          sub_278E0((int)&unk_60D68);
          sub_278E0((int)&unk_64240);
          sub_278E0((int)&unk_63A78);
          sub_278E0((int)&unk_63C18);
          sub_278E0((int)&unk_63FE8);
          sub_278E0((int)&unk_63310);
          sub_278E0((int)&unk_64110);
          sub_278E0((int)&unk_63418);
          sub_278E0((int)&unk_638A8);
          sub_278E0((int)&unk_63800);
          sub_278E0((int)&unk_63518);
          sub_278E0((int)&unk_63E60);
          sub_278E0((int)&unk_63620);
          sub_278E0((int)&unk_63598);
          sub_278E0((int)&unk_63B00);
          sub_278E0((int)&unk_63948);
          sub_278E0((int)&unk_63778);
          sub_278E0((int)&unk_64190);
          sub_278E0((int)&unk_63498);
          sub_278E0((int)&unk_63390);
          (*((void (__fastcall **)(_DWORD))v285 + 3))(0);
          off_6327C(0);
          off_63D84(0);
          off_639FC(0);
          off_60D74();
          off_6424C(0);
          off_63A84(0);
          off_63C24(0);
          ((void (__fastcall *)(_DWORD))off_63FF4)(0);
          off_6331C(0);
          off_6411C(0);
          off_63424(0);
          off_638B4(0);
          ((void (__fastcall *)(_DWORD))off_6380C)(0);
          off_63524(0);
          off_63E6C(0);
          off_6362C(0);
          off_635A4(0);
          ((void (__fastcall *)(_DWORD))off_63B0C)(0);
          off_63954(0);
          off_63784(0);
          off_6419C(0);
          off_634A4(0);
          ((void (__fastcall *)(_DWORD))off_6339C)(0);
          v126 = dword_63CC0;
          dword_6410C = 0;
          if ( dword_63CC0 > 0 )
          {
            v294 = &dword_63BC8;
            do
            {
              v127 = *(pthread_rwlock_t **)(dword_63BC8 + 4 * v125++);
              sub_27B20(v127);
              v126 = dword_63CC0;
            }
            while ( dword_63CC0 > v125 );
          }
          if ( !v126 )
          {
            v163 = s;
            *(_DWORD *)s = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy(v163 + 4, "devices disabled, cannot mine!");
            sub_38438(3, s, 1);
            sub_1C160(1, 0);
          }
          dword_6130C = v126;
          if ( dword_611B0 )
          {
            v128 = strtok((char *)dword_611B0, ",");
            v294 = &dword_63BC8;
            v129 = v128;
            if ( v128 )
            {
              v130 = 0;
              v131 = s;
              do
              {
                if ( v130 >= dword_63CC0 )
                {
                  strcpy(v131, "Too many values passed to set temp cutoff");
                  sub_38438(3, v131, 1);
                  sub_16724(1);
                }
                v132 = strtol(v129, 0, 10);
                if ( v132 > 0xC8 )
                {
                  strcpy(v131, "Invalid value passed to set temp cutoff");
                  sub_38438(3, v131, 1);
                  sub_16724(1);
                }
                sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1143);
                v133 = *(_DWORD *)(dword_63BC8 + 4 * v130++);
                *(_DWORD *)(v133 + 184) = v132;
                sub_19598(&stru_63CA0, "load_temp_cutoffs", 1145);
                v129 = strtok(0, ",");
              }
              while ( v129 );
              if ( v130 != 1 )
                goto LABEL_198;
            }
            else
            {
              v130 = 0;
              v132 = 0;
            }
            sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1162);
            v193 = *v294;
            v194 = dword_63CC0;
            while ( v130 < v194 )
            {
              v195 = *(_DWORD *)(v193 + 4 * v130++);
              *(_DWORD *)(v195 + 184) = v132;
            }
            sub_19598(&stru_63CA0, "load_temp_cutoffs", 1165);
            goto LABEL_198;
          }
          v294 = &dword_63BC8;
          sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1150);
          v165 = 0;
          v166 = dword_63BC8;
          v167 = dword_63CC0;
          while ( v165 < v167 )
          {
            v168 = *(_DWORD *)(v166 + 4 * v165++);
            if ( !*(_DWORD *)(v168 + 184) )
              *(_DWORD *)(v168 + 184) = 95;
          }
          sub_19598(&stru_63CA0, "load_temp_cutoffs", 1156);
LABEL_198:
          if ( dword_63CC0 > 0 )
          {
            v137 = (int *)*v294;
            v138 = *v294 + 4 * dword_63CC0;
            do
            {
              v139 = *v137++;
              *(_DWORD *)(v139 + 312) = 99999999;
            }
            while ( v137 != (int *)v138 );
          }
          if ( !byte_63EE0 )
          {
            dword_612FC += dword_6130C;
            dword_61304 = dword_612FC + 1;
            sub_191C4();
          }
          if ( !dword_63740 )
          {
            if ( *v290 || byte_630C0 || dword_60964 > 3 )
            {
              v140 = s;
              *(_DWORD *)s = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy(v140 + 4, " to specify at least one pool server.");
              sub_38438(4, s, 0);
            }
            if ( !*((_BYTE *)v289 + 2028) || !sub_26934(0) )
            {
              v141 = s;
              *(_DWORD *)s = *(_DWORD *)"Pool setup failed";
              strcpy(v141 + 4, " setup failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
          }
          if ( dword_63740 > 0 )
          {
            v142 = 0;
            v143 = v99;
            do
            {
              v144 = *(_DWORD *)(dword_639E0 + 4 * v142);
              v145 = *(_DWORD *)(v144 + 168);
              *(_DWORD *)(v144 + 396) = 99999999;
              *(_DWORD *)(v144 + 432) = 99999999;
              if ( !v145 )
              {
                if ( !*(_DWORD *)(v144 + 176) )
                  *(_DWORD *)(v144 + 176) = calloc(1u, 1u);
                v146 = *(const char **)(v144 + 172);
                if ( !v146 )
                {
                  snprintf(
                    s,
                    0x800u,
                    "No login credentials supplied for pool %u %s",
                    v142,
                    *(const char **)(v144 + 164));
                  sub_38438(3, s, 1);
                  sub_1C160(1, 0);
                }
                v147 = strlen(*(const char **)(v144 + 172));
                v285 = *(const char **)(v144 + 176);
                v148 = v147 + strlen(v285) + 2;
                v149 = (char *)malloc(v148);
                *(_DWORD *)(v144 + 168) = v149;
                if ( !v149 )
                {
                  v282 = s;
                  *(_DWORD *)s = *(_DWORD *)"Failed to malloc userpass";
                  strcpy(v282 + 4, "ed to malloc userpass");
                  sub_38438(3, s, 1);
                  sub_1C160(1, 0);
                }
                snprintf(v149, v148, "%s:%s", v146, v285);
              }
              ++v142;
            }
            while ( dword_63740 > v142 );
            v99 = v143;
          }
          v151 = (unsigned __int8)*v290;
          dword_61310 = *(_DWORD *)dword_639E0;
          if ( v151 )
            openlog("cgminer", 1, 8);
          if ( *(_DWORD *)&v99[-88] )
          {
            if ( pipe((int *)s) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v298[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(v298[1]) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v152 = signal(13, (__sighandler_t)1);
            v153 = signal(13, (__sighandler_t)1);
            v154 = (__sighandler_t)((char *)v153 + 1) == 0;
            if ( v153 != (__sighandler_t)-1 )
              v154 = (__sighandler_t)((char *)v152 + 1) == 0;
            if ( v154 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v155 = fork();
            v156 = v155;
            dword_61418 = v155;
            if ( v155 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v155 )
            {
              if ( dup2(v298[0], v155) >= 0 )
              {
                close(v298[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_62E28, v156);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v298[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          dword_63B80 = (int)calloc(dword_6410C, 4u);
          if ( !dword_63B80 )
          {
            v279 = s;
            *(_DWORD *)s = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy(v279 + 4, "ed to calloc mining_thr");
            goto LABEL_485;
          }
          for ( j = 0; j < dword_6410C; ++j )
          {
            v170 = dword_63B80;
            *(_DWORD *)(v170 + 4 * j) = calloc(1u, 0x40u);
            if ( !*(_DWORD *)(dword_63B80 + 4 * j) )
            {
              snprintf(s, 0x800u, "Failed to calloc mining_thr[%d]", j);
LABEL_485:
              v196 = s;
LABEL_325:
              sub_38438(3, v196, 1);
              sub_1C160(1, 0);
            }
          }
          v171 = 0;
          v293 = v99;
          for ( k = 0; k < dword_63CC0; ++k )
          {
            v173 = 0;
            v174 = *(_DWORD **)(*v294 + 4 * k);
            v175 = v174[37];
            v176 = malloc(4 * (v175 + 1));
            v174[38] = v176;
            v176[v175] = 0;
            v177 = v174[37];
            v174[24] = 4;
            if ( v177 > 0 )
            {
              do
              {
                v178 = (sem_t *)sub_1C36C(v171);
                v178->__align = v171;
                v179 = v178;
                *(&v178[2].__align + 1) = (int)v174;
                *(&v178->__align + 1) = v173;
                if ( (*(int (**)(void))(v174[1] + 44))() )
                {
                  if ( sub_2F0EC((int)v179, 0, (void *(*)(void *))sub_11A5C, v179) )
                  {
                    snprintf(s, 0x800u, "thread %d create failed", v179->__align);
                    sub_38438(3, s, 1);
                    sub_1C160(1, 0);
                  }
                  *(_DWORD *)(v174[38] + 4 * v173) = v179;
                  if ( v174[8] != 1 )
                  {
                    if ( byte_630C1 && (*v290 || byte_630C0 || dword_60964 > 6) )
                    {
                      snprintf(s, 0x800u, "Pushing sem post to thread %d", v179->__align);
                      sub_38438(7, s, 0);
                    }
                    sub_2F134(v179 + 1, "cgminer.c", "main", 11102);
                  }
                }
                ++v173;
                ++v171;
              }
              while ( v174[37] > v173 );
            }
          }
          v180 = v293;
          if ( byte_615C9 || (v181 = dword_612AC) != 0 )
          {
LABEL_298:
            v182 = (int *)dbl_61380;
            dbl_63268 = 0.0;
            do
            {
              *(_QWORD *)v182 = 0;
              v182 += 2;
            }
            while ( v182 != &dword_613E0 );
            v183 = dword_63CC0;
            v184 = 0;
            dword_613E0 = 0;
            v185 = *v294;
            while ( v184 < v183 )
            {
              v186 = *(_DWORD *)(v185 + 4 * v184++);
              *(_QWORD *)(v186 + 80) = 0;
              *(_QWORD *)(v186 + 48) = 0;
            }
            sub_2B13C((struct timeval *)&dword_61370);
            sub_2B13C((struct timeval *)&dword_613E4);
            sub_2B13C((struct timeval *)dword_61378);
            sub_14D9C(byte_613EC, 0x28u, &dword_61370);
            dword_61420 = 2;
            v187 = dword_636A4;
            if ( sub_2F0EC(dword_636A4 + 128, 0, (void *(*)(void *))sub_21364, 0) )
            {
              v271 = s;
              *(_DWORD *)s = *(_DWORD *)"watchpool thread create failed";
              strcpy(v271 + 4, "hpool thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*(_DWORD *)(v187 + 140));
            dword_61424 = 3;
            v285 = (const char *)dword_636A4;
            if ( sub_2F0EC(dword_636A4 + 192, 0, (void *(*)(void *))sub_23018, 0) )
            {
              v197 = s;
              *(_DWORD *)s = *(_DWORD *)"watchdog thread create failed";
              strcpy(v197 + 4, "hdog thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*((_DWORD *)v285 + 51));
            dword_611A8 = 5;
            if ( sub_2F0EC(dword_636A4 + 320, 0, (void *(*)(void *))sub_11CBC, (void *)(dword_636A4 + 320)) )
            {
              v270 = s;
              *(_DWORD *)s = *(_DWORD *)"API thread create failed";
              strcpy(v270 + 4, "thread create failed");
LABEL_309:
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            v188 = dword_636A4;
            *(_DWORD *)&v180[-84] = 7;
            if ( sub_2F0EC(v188 + 448, 0, (void *(*)(void *))sub_276A8, (void *)(v188 + 448)) )
            {
              v269 = s;
              *(_DWORD *)s = *(_DWORD *)"input thread create failed";
              strcpy(v269 + 4, "t thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*(_DWORD *)(v188 + 460));
            if ( dword_62E20 != 8 )
            {
              snprintf(s, 0x800u, "incorrect total_control_threads (%d) should be 8", dword_62E20);
              goto LABEL_309;
            }
            if ( nice(-10) )
            {
              v288 = &byte_630C0;
              v286 = &dword_60964;
              v291 = (const char **)&byte_630C1;
            }
            else
            {
              v291 = (const char **)&byte_630C1;
              if ( byte_630C1 )
              {
                v198 = (unsigned __int8)*v290;
                v288 = &byte_630C0;
                if ( v198 || byte_630C0 )
                {
                  v286 = &dword_60964;
                }
                else
                {
                  v286 = &dword_60964;
                  if ( dword_60964 <= 6 )
                    goto LABEL_333;
                }
                v199 = s;
                *(_DWORD *)s = *(_DWORD *)"Unable to set thread to high priority";
                strcpy(v199 + 4, "le to set thread to high priority");
                sub_38438(7, s, 0);
              }
              else
              {
                v288 = &byte_630C0;
                v286 = &dword_60964;
              }
            }
LABEL_333:
            v293 = 0;
            v287 = (void (__fastcall **)())&off_60178;
            while ( 1 )
            {
              while ( 1 )
              {
                v200 = v289[504];
                if ( byte_63E4C )
                {
                  if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
                  {
                    v238 = s;
                    *(_DWORD *)s = *(_DWORD *)"Work update message received";
                    strcpy(v238 + 4, " update message received");
                    sub_38438(7, s, 0);
                  }
                  sub_2B13C(&stru_611BC);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B76C("signal_work_update", 5292);
                  if ( dword_6410C > 0 )
                  {
                    v239 = (int *)dword_63B80;
                    v240 = dword_63B80 + 4 * dword_6410C;
                    do
                    {
                      v241 = *v239++;
                      *(_BYTE *)(v241 + 63) = 1;
                    }
                    while ( v239 != (int *)v240 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B700("signal_work_update", 5295);
                  (*v287)();
                }
                byte_63E4C = 0;
                sub_1D644();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
                  sub_B4E4("main", 11239);
                v201 = dword_612CC;
                if ( dword_612CC )
                  v201 = *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12);
                if ( v200 < v201 )
                {
                  if ( byte_612D2 )
                  {
                    v202 = v289[504];
                    if ( v202 < v289[505] )
                    {
                      dword_60070 = v202 + 1;
                      byte_612D2 = 0;
                    }
                  }
                  byte_612D1 = 1;
                  pthread_cond_wait(&stru_63748, (pthread_mutex_t *)dword_612C8);
                  v201 = dword_612CC;
                  if ( dword_612CC )
                    v201 = *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
                  sub_B694("main", 11257);
                (*v287)();
                if ( v201 <= v200 )
                  break;
                if ( byte_612D2 )
                {
                  v203 = v289[504];
                  if ( v203 < v289[505] )
                  {
                    dword_60070 = v203 + 1;
                    byte_612D2 = 0;
                  }
                }
                byte_612D1 = 1;
                v204 = (_BYTE *)sub_17A14(0);
                v293 = v204;
                if ( v204 )
                {
                  sub_154EC((int)v204);
                  v293 = 0;
                }
              }
              if ( v293 )
                sub_154EC((int)v293);
              v293 = sub_19DA0();
              v205 = sub_1D644();
              v206 = v205;
              if ( dword_611AC == 4 )
              {
                v206 = sub_11DA8(v205);
              }
              else if ( dword_611AC == 3 )
              {
                v243 = dword_63740;
                if ( dword_63740 <= 0 )
                  goto LABEL_436;
                if ( *(_DWORD *)(*(_DWORD *)dword_639E0 + 60) <= *(_DWORD *)(*(_DWORD *)dword_639E0 + 64) )
                {
                  v244 = (int *)dword_639E0;
                  v245 = dword_639E0;
                  v246 = 0;
                  while ( ++v246 != dword_63740 )
                  {
                    v247 = *(_DWORD *)(v245 + 4);
                    v245 += 4;
                    if ( *(_DWORD *)(v247 + 64) < *(_DWORD *)(v247 + 60) )
                      goto LABEL_438;
                  }
                  v248 = dword_639E0 + 4 * dword_63740;
                  do
                  {
                    v249 = *v244++;
                    *(_DWORD *)(v249 + 64) = 0;
                  }
                  while ( v244 != (int *)v248 );
LABEL_436:
                  v250 = *(_DWORD *)&v180[-80] + 1;
                  *(_DWORD *)&v180[-80] = v250;
                  if ( v250 >= v243 )
                    dword_62E30 = 0;
                }
LABEL_438:
                v251 = 0;
                while ( 1 )
                {
                  v76 = v251++ < v243;
                  if ( !v76 )
                    break;
                  v253 = *(_DWORD *)&v180[-80];
                  v254 = *(_DWORD *)(dword_639E0 + 4 * v253);
                  v255 = *(_DWORD *)(v254 + 64);
                  v256 = *(_DWORD *)(v254 + 60);
                  *(_DWORD *)(v254 + 64) = v255 + 1;
                  if ( v255 < v256 )
                  {
                    if ( !*(_BYTE *)(v254 + 97)
                      && *(_DWORD *)(v254 + 100) == 1
                      && (!*(_BYTE *)(v254 + 632) || *(_BYTE *)(v254 + 633)) )
                    {
                      goto LABEL_450;
                    }
                    if ( byte_63BC5 )
                    {
                      v257 = sub_11B90(0);
                      v253 = *(_DWORD *)&v180[-80];
                      v243 = dword_63740;
                      --*(_DWORD *)(v257 + 64);
                    }
                  }
                  v252 = v253 + 1;
                  *(_DWORD *)&v180[-80] = v252;
                  if ( v252 >= v243 )
                    dword_62E30 = 0;
                }
                if ( v243 > 0 )
                {
                  v258 = 0;
                  while ( 1 )
                  {
                    v254 = sub_11B90(v258);
                    if ( !*(_BYTE *)(v254 + 97) && *(_DWORD *)(v254 + 100) == 1 )
                      break;
                    if ( ++v258 >= dword_63740 )
                      goto LABEL_355;
                  }
LABEL_450:
                  v206 = v254;
                }
              }
LABEL_355:
              if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
              {
                snprintf(s, 0x800u, "Selecting pool %d for work", *(_DWORD *)v206);
                sub_38438(7, s, 0);
              }
              if ( *(_BYTE *)(v206 + 632) )
              {
                while ( !*(_BYTE *)(v206 + 633) || !*(_BYTE *)(v206 + 635) )
                {
                  v207 = sub_1D644();
                  v294 = (int *)v207;
                  if ( dword_611AC == 4 )
                  {
                    v294 = (int *)sub_11DA8(v207);
                  }
                  else if ( dword_611AC == 3 || !byte_63BC5 )
                  {
                    v208 = dword_63740;
                    if ( dword_63740 <= 0 )
                      goto LABEL_374;
                    if ( *(_DWORD *)(*(_DWORD *)dword_639E0 + 60) <= *(_DWORD *)(*(_DWORD *)dword_639E0 + 64) )
                    {
                      v209 = (int *)dword_639E0;
                      v210 = dword_639E0;
                      v211 = 0;
                      while ( ++v211 != dword_63740 )
                      {
                        v212 = *(_DWORD *)(v210 + 4);
                        v210 += 4;
                        if ( *(_DWORD *)(v212 + 64) < *(_DWORD *)(v212 + 60) )
                          goto LABEL_376;
                      }
                      v213 = dword_639E0 + 4 * dword_63740;
                      do
                      {
                        v214 = *v209++;
                        *(_DWORD *)(v214 + 64) = 0;
                      }
                      while ( v209 != (int *)v213 );
LABEL_374:
                      v215 = *(_DWORD *)&v180[-80] + 1;
                      *(_DWORD *)&v180[-80] = v215;
                      if ( v215 >= v208 )
                        dword_62E30 = 0;
                    }
LABEL_376:
                    v216 = 0;
                    while ( 1 )
                    {
                      v76 = v216++ < v208;
                      if ( !v76 )
                        break;
                      v218 = *(_DWORD *)&v180[-80];
                      v219 = *(_DWORD *)(dword_639E0 + 4 * v218);
                      v220 = *(_DWORD *)(v219 + 64);
                      v221 = *(_DWORD *)(v219 + 60);
                      *(_DWORD *)(v219 + 64) = v220 + 1;
                      if ( v220 < v221 )
                      {
                        if ( !*(_BYTE *)(v219 + 97)
                          && *(_DWORD *)(v219 + 100) == 1
                          && (!*(_BYTE *)(v219 + 632) || *(_BYTE *)(v219 + 633)) )
                        {
                          goto LABEL_388;
                        }
                        if ( byte_63BC5 )
                        {
                          v222 = sub_11B90(0);
                          v218 = *(_DWORD *)&v180[-80];
                          v208 = dword_63740;
                          --*(_DWORD *)(v222 + 64);
                        }
                      }
                      v217 = v218 + 1;
                      *(_DWORD *)&v180[-80] = v217;
                      if ( v217 >= v208 )
                        dword_62E30 = 0;
                    }
                    if ( v208 > 0 )
                    {
                      v242 = 0;
                      while ( 1 )
                      {
                        v219 = sub_11B90(v242);
                        if ( !*(_BYTE *)(v219 + 97) && *(_DWORD *)(v219 + 100) == 1 )
                          break;
                        if ( ++v242 >= dword_63740 )
                          goto LABEL_389;
                      }
LABEL_388:
                      v294 = (int *)v219;
                    }
                  }
LABEL_389:
                  if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
                  {
                    snprintf(s, 0x800u, "Selecting pool %d for work", *v294);
                    sub_38438(7, s, 0);
                  }
                  sub_2B21C();
                  if ( (int *)v206 != v294 )
                  {
                    v206 = (int)v294;
                    if ( !*((_BYTE *)v294 + 632) )
                      goto LABEL_396;
                  }
                }
                sub_1A514(v206, (int)v293);
                if ( *(_BYTE *)v291 && (*v290 || *v288 || *v286 > 6) )
                {
                  v236 = s;
                  *(_DWORD *)s = *(_DWORD *)"Generated stratum work";
                  strcpy(v236 + 4, "rated stratum work");
                  sub_38438(7, s, 0);
                }
LABEL_409:
                v237 = v293;
                v293 = 0;
                sub_1ED4C((int)v237);
              }
              else
              {
LABEL_396:
                if ( dword_612AC )
                {
                  v223 = (struct timeval *)(v293 + 400);
                  sub_16CD0(v293);
                  v224 = v293;
                  v225 = (_DWORD *)dword_639E0;
                  v293[282] = 1;
                  *((_DWORD *)v224 + 65) = *v225;
                  sub_2B13C(v223);
                  sub_2AE20((_DWORD *)v224 + 102, v223);
                  v226 = v293;
                  v224[440] = 66;
                  sub_113C4((int)v226);
                  if ( !*(_BYTE *)v291 || !*v290 && !*v288 && *v286 <= 6 )
                    goto LABEL_409;
                  v227 = "Generated benchfile work";
                  goto LABEL_402;
                }
                if ( byte_615C9 )
                {
                  v259 = (struct timeval *)v293;
                  *((_QWORD *)v293 + 47) = 0x4040000000000000LL;
                  v260 = (__suseconds_t *)dword_639E0;
                  v261 = dword_629EC[0];
                  v262 = dword_629EC[1];
                  v263 = dword_629EC[2];
                  v264 = dword_629EC[3];
                  v259[30].tv_usec = 0;
                  BYTE2(v259[35].tv_sec) = 1;
                  v259[20].tv_sec = v261;
                  v259[20].tv_usec = v262;
                  v259[21].tv_sec = v263;
                  v259[21].tv_usec = v264;
                  v265 = unk_629FC;
                  v266 = unk_62A00;
                  v267 = unk_62A08;
                  v259[23].tv_sec = unk_62A04;
                  v259[22].tv_sec = v265;
                  v259[22].tv_usec = v266;
                  v259[23].tv_usec = v267;
                  v259[32].tv_usec = *v260;
                  sub_2B13C(v259 + 50);
                  sub_2AE20(&v259[51].tv_sec, &v259[50].tv_sec);
                  v268 = v291;
                  LOBYTE(v259[55].tv_sec) = 66;
                  if ( !*(_BYTE *)v268 || !*v290 && !*v288 && *v286 <= 6 )
                    goto LABEL_409;
                  v227 = "Generated benchmark work";
LABEL_402:
                  v228 = *(_DWORD *)v227;
                  v229 = *((_DWORD *)v227 + 1);
                  v230 = *((_DWORD *)v227 + 2);
                  v231 = *((_DWORD *)v227 + 3);
                  v232 = v227 + 16;
                  v233 = s;
                  *(_DWORD *)s = v228;
                  *((_DWORD *)v233 + 1) = v229;
                  *((_DWORD *)v233 + 2) = v230;
                  *((_DWORD *)v233 + 3) = v231;
                  v233 += 16;
                  v234 = v232[1];
                  v235 = v232[2];
                  *(_DWORD *)v233 = *v232;
                  *((_DWORD *)v233 + 1) = v234;
                  v233[8] = v235;
                  sub_38438(7, s, 0);
                  goto LABEL_409;
                }
              }
            }
          }
          v189 = dword_639E0;
          v190 = dword_63740;
          while ( v181 < v190 )
          {
            v191 = *(_DWORD *)(v189 + 4 * v181++);
            v192 = *(_DWORD *)(v191 + 100);
            *(_BYTE *)(v191 + 97) = 1;
            if ( v192 != 1 )
            {
              *(_DWORD *)(v191 + 100) = 1;
              ++dword_63B84;
            }
          }
          if ( byte_630C1 && (*v290 || byte_630C0 || dword_60964 > 6) )
          {
            v272 = s;
            *(_DWORD *)s = *(_DWORD *)"Probing for an alive pool";
            strcpy(v272 + 4, "ing for an alive pool");
            sub_38438(7, s, 0);
          }
          for ( m = 0; m < dword_63740; ++m )
          {
            v274 = *(_DWORD *)(dword_639E0 + 4 * m);
            *(_BYTE *)(v274 + 284) = 1;
            pthread_create((pthread_t *)(v274 + 280), 0, (void *(*)(void *))start_routine, (void *)v274);
          }
          v275 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_615C8 )
              break;
            if ( !--v275 )
              goto LABEL_490;
          }
          v275 = 0;
LABEL_490:
          v276 = s;
          v277 = v290;
          while ( 1 )
          {
            if ( byte_615C8 )
              goto LABEL_298;
            if ( !v275 )
            {
              if ( ((*v277 || byte_630C0 || dword_60964 > 2)
                 && ((strcpy(v276, "No servers were found that could be used to get work from."),
                      sub_38438(3, v276, 0),
                      *v277)
                  || byte_630C0)
                 || dword_60964 > 2)
                && ((strcpy(v276, "Please check the details from the list below of the servers you have input"),
                     sub_38438(3, v276, 0),
                     *v277)
                 || byte_630C0)
                || dword_60964 > 2 )
              {
                strcpy(
                  v276,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_38438(3, v276, 0);
              }
              for ( n = 0; n < dword_63740; ++n )
              {
                if ( *v277 || byte_630C0 || dword_60964 > 3 )
                {
                  snprintf(
                    v276,
                    0x800u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    n,
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 164),
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 172),
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 176));
                  sub_38438(4, v276, 0);
                }
              }
              if ( !*((_BYTE *)v289 + 2028) )
              {
LABEL_524:
                v281 = s;
                *(_DWORD *)s = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy(v281 + 4, "ervers could be used! Exiting.");
                sub_38438(3, s, 1);
                sub_1C160(0, 0);
              }
              if ( !*v277 && !byte_630C0 && dword_60964 <= 2 )
              {
                v275 = 1;
                goto LABEL_518;
              }
              v275 = 1;
              strcpy(v276, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_38438(3, v276, 0);
            }
            if ( !*((_BYTE *)v289 + 2028) )
              goto LABEL_524;
LABEL_518:
            if ( dword_639D8 )
              v280 = *(__int16 *)(dword_639D8 + 4);
            else
              v280 = -1;
            v285 = (const char *)&dword_639D8;
            if ( dword_639D8 )
              ++v280;
            wtouchln((WINDOW *)dword_639D8, 0, v280, 1);
            wrefresh(*(WINDOW **)v285);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_524;
            cbreak();
          }
        }
        if ( byte_630C1 && (*v290 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "Loaded configuration file %s", (const char *)dword_611D4);
          sub_38438(7, s, 0);
        }
        if ( dword_612A4 == -1 )
        {
          if ( *v290 || byte_630C0 || dword_60964 > 3 )
          {
            v135 = s;
            *(_DWORD *)s = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy(v135 + 4, "r in configuration file, partially loaded.");
            sub_38438(4, s, 0);
          }
          if ( *((_BYTE *)v289 + 2028) && (*v290 || byte_630C0 || dword_60964 > 3) )
          {
            v136 = s;
            *(_DWORD *)s = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
            strcpy(v136 + 4, "t cgminer with -T to see what failed to load.");
            sub_38438(4, s, 0);
          }
          goto LABEL_166;
        }
        if ( !dword_612A4 )
        {
          if ( *v290 || byte_630C0 || (v286 = &dword_60964, dword_60964 > 3) )
          {
            v150 = s;
            *(_DWORD *)s = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy(v150 + 4, "l JSON error in configuration file.");
            sub_38438(4, s, 0);
            if ( *v290 || byte_630C0 )
              goto LABEL_165;
            v286 = &dword_60964;
          }
          if ( *v286 > 3 )
          {
LABEL_165:
            v124 = s;
            *(_DWORD *)s = *(_DWORD *)"Configuration file could not be used.";
            strcpy(v124 + 4, "iguration file could not be used.");
            sub_38438(4, s, 0);
          }
        }
LABEL_166:
        free((void *)dword_611D4);
        dword_611D4 = 0;
        goto LABEL_167;
      }
      v60 = 24 * *(_DWORD *)(v59 + 4);
      v61 = malloc(v60);
      v62 = v61;
      if ( v61 )
      {
        memset(v61, 0, v60);
        *(_DWORD *)(v59 + 24) = (((2 * *(_DWORD *)(v59 + 4) - 1) & *(_DWORD *)(v59 + 12)) != 0)
                              + (*(_DWORD *)(v59 + 12) >> (*(_BYTE *)(v59 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v63 = (_DWORD *)*((_DWORD *)v20 + 17);
        v64 = v63[1];
        v65 = v63;
        if ( v64 )
        {
          v294 = 0;
          v293 = 0;
          do
          {
            v66 = *(_DWORD **)((char *)v294 + *v63);
            if ( v66 )
            {
              for ( ii = v64; ; ii = v65[1] )
              {
                v68 = (_DWORD *)v66[4];
                v69 = 3 * ((2 * ii - 1) & v66[7]);
                v70 = (char *)&v62[v69];
                v71 = *((_DWORD *)v70 + 1) + 1;
                *((_DWORD *)v70 + 1) = v71;
                if ( v71 > v65[6] )
                {
                  ++v65[7];
                  *((_DWORD *)v70 + 2) = *((_DWORD *)v70 + 1) / *(_DWORD *)(*((_DWORD *)v20 + 17) + 24);
                }
                v66[3] = 0;
                v66[4] = v62[v69];
                v72 = v62[v69];
                if ( v72 )
                  *(_DWORD *)(v72 + 12) = v66;
                v62[v69] = v66;
                if ( !v68 )
                  break;
                v65 = (_DWORD *)*((_DWORD *)v20 + 17);
                v66 = v68;
              }
              v63 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v63;
            v64 = v63[1];
            v76 = v64 > (unsigned int)++v293;
            v294 += 3;
          }
          while ( v76 );
        }
        free((void *)*v63);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v62;
        v73 = (_DWORD *)*((_DWORD *)v20 + 17);
        v74 = v73[3];
        v75 = v73[7];
        v76 = v75 > v74 >> 1;
        if ( v75 <= v74 >> 1 )
          v77 = 0;
        else
          v77 = v73[8];
        if ( v76 )
          ++v77;
        v73[8] = v77;
        v78 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v78 + 32) > 1u )
          *(_DWORD *)(v78 + 36) = 1;
        goto LABEL_57;
      }
LABEL_310:
      exit(-1);
    }
    strcpy((char *)v298, "Failed to create getq");
  }
  sub_38438(3, (const char *)v298, 1);
  sub_1C160(1, 0);
}
