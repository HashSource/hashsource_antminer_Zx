/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_AA28();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int scrollok(WINDOW *, bool);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int open(const char *file, int oflag, ...);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// const __int32_t **_ctype_toupper_loc(void);
// int fileno(FILE *stream);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int nocbreak(void);
// void srand(unsigned int seed);
// struct tm *localtime(const time_t *timer);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// WINDOW *newwin(int, int, int, int);
// int sysconf(int name);
// void syslog(int pri, const char *fmt, ...);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int _xstat(int ver, const char *filename, struct stat *stat_buf);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int wmove(WINDOW *, int, int);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int _isinf(double value);
// int _gmon_start__(void); weak
// int echo(void);
// int sched_yield(void);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// in_addr_t inet_addr(const char *cp);
// int endwin(void);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// char *fgets(char *s, int n, FILE *stream);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// double strtod(const char *nptr, char **endptr);
// int system(const char *command);
// char *strchr(const char *s, int c);
// int strcasecmp(const char *s1, const char *s2);
// char *dirname(char *path);
// int leaveok(WINDOW *, bool);
// int listen(int fd, int n);
// void *calloc(size_t nmemb, size_t size);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// void *memset(void *s, int c, size_t n);
// int sem_destroy(sem_t *sem);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// void freeaddrinfo(struct addrinfo *ai);
// void perror(const char *s);
// int delwin(WINDOW *);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int werase(WINDOW *);
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// double exp(double x);
// WINDOW *initscr(void);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int usleep(__useconds_t useconds);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int wclrtoeol(WINDOW *);
// void free(void *ptr);
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int inet_pton(int af, const char *cp, void *buf);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sem_trywait(sem_t *sem);
// int fseek(FILE *stream, int off, int whence);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int __fastcall round(_DWORD); weak
// int socket(int domain, int type, int protocol);
// int wtouchln(WINDOW *, int, int, int);
// int execl(const char *path, const char *arg, ...);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// void immedok(WINDOW *, bool);
// int isatty(int fd);
// int wrefresh(WINDOW *);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// int mvwprintw(WINDOW *, int, int, const char *, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int execv(const char *path, char *const argv[]);
// int __fastcall lldiv(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int halfdelay(int);
// int pthread_cond_signal(pthread_cond_t *cond);
// const __int32_t **_ctype_tolower_loc(void);
// struct lconv *localeconv(void);
// int fgetc(FILE *stream);
// int strtol(const char *nptr, char **endptr, int base);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int cbreak(void);
// char *strncat(char *dest, const char *src, size_t n);
// int settimeofday(const struct timeval *tv, const struct timezone *tz);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int printf(const char *format, ...);
// int raise(int sig);
// void errx(int status, const char *format, ...);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int shutdown(int fd, int how);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int wresize(WINDOW *, int, int);
// char *strstr(const char *haystack, const char *needle);
// int nice(int inc);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// int wgetch(WINDOW *);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int _isnan(double value);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int wprintw(WINDOW *, const char *, ...);
// time_t time(time_t *timer);
// double log10(double x);
// const unsigned __int16 **_ctype_b_loc(void);
// int fprintf(FILE *stream, const char *format, ...);
// void *malloc(size_t size);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int pthread_attr_init(pthread_attr_t *attr);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int wgetnstr(WINDOW *, char *, int);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// unsigned int sleep(unsigned int seconds);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// char *strcat(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// void pthread_testcancel(void);
// int dup2(int fd, int fd2);
// int puts(const char *s);
// int prctl(int option, ...);
// int fcntl(int fd, int cmd, ...);
// int idlok(WINDOW *, bool);
// __pid_t fork(void);
// int wattr_off(WINDOW *, attr_t, void *);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int rand(void);
// int munmap(void *addr, size_t len);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// __int64 __fastcall llround(_DWORD); weak
// int whline(WINDOW *, chtype, int);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int strncmp(const char *s1, const char *s2, size_t n);
// int kill(__pid_t pid, int sig);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int wclear(WINDOW *);
// int pthread_detach(pthread_t th);
// void *realloc(void *ptr, size_t size);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
// char *_strdup(const char *s);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int noecho(void);
// char *strpbrk(const char *s, const char *accept);
// int sem_wait(sem_t *sem);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int pthread_setcanceltype(int type, int *oldtype);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int pthread_cancel(pthread_t th);
// int mvwin(WINDOW *, int, int);
// int wattr_on(WINDOW *, attr_t, void *);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
// int fscanf(FILE *stream, const char *format, ...);
int __fastcall sub_B340(int a1);
void __noreturn sub_B3C8();
void __fastcall sub_B404(int a1, int a2, int a3, int a4, int a5);
void __fastcall __noreturn sub_B414(const char *a1, int a2);
void __fastcall sub_B46C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B480(const char *a1, int a2);
void __fastcall sub_B4D8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B4EC(const char *a1, int a2);
void __fastcall sub_B544(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B558(const char *a1, int a2);
void __fastcall sub_B5B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B5C4(const char *a1, int a2);
void __fastcall sub_B61C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B630(const char *a1, int a2);
void __fastcall sub_B688(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B69C(const char *a1, int a2);
void __fastcall sub_B6F4(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B708(const char *a1, int a2);
void __fastcall sub_B760(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B774(const char *a1, int a2);
void __fastcall sub_B7CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B7E0(const char *a1, int a2);
void __fastcall sub_B838(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B84C(const char *a1, int a2);
void __fastcall sub_B8A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B8B8(int a1);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_F644();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
int __fastcall sub_F740(_DWORD *a1);
int __fastcall sub_F750(_DWORD *a1);
int __fastcall sub_F760(_DWORD *a1);
int __fastcall sub_F770(_BYTE *a1);
int sub_F78C();
int nullsub_3(); // weak
int nullsub_2(); // weak
int nullsub_4(); // weak
int sub_F7A0();
int sub_F7A8();
__int64 sub_F7B0();
int sub_F7BC();
int sub_F7C4();
int nullsub_5(); // weak
int nullsub_6(); // weak
int nullsub_7(); // weak
int nullsub_8(); // weak
int sub_F7DC();
int __fastcall sub_F7E8(int a1, int a2);
_BYTE *__fastcall sub_F8A4(const char *a1);
int __fastcall sub_F930(int a1);
int __fastcall sub_F948(int a1);
int __fastcall sub_F960(int a1);
int __fastcall sub_F978(int a1);
int __fastcall sub_F990(int a1);
int __fastcall sub_F9A8(int a1);
void __fastcall __noreturn sub_F9C0(char *a1);
void *__fastcall sub_FC10(void *a1); // idb
time_t __fastcall sub_FC24(int a1);
time_t __fastcall sub_FC58(int a1);
int __fastcall sub_FC90(int *a1, int *a2, int a3);
double __fastcall sub_11514(double a1);
double __fastcall sub_11548(double a1);
int __fastcall sub_11580(unsigned __int64 a1, char *a2, size_t a3, int a4);
void __fastcall sub_11814(char *a1, unsigned int a2);
bool sub_118D4();
int __fastcall sub_11A5C(int a1);
void __fastcall __noreturn sub_11C1C(void *a1);
void __noreturn sub_11C44(const char *a1, ...);
int __fastcall sub_11C8C(int a1, int a2, int a3);
int __fastcall sub_11E24(int a1);
void __fastcall sub_11F60(int a1);
int __fastcall sub_12038(int a1);
void sub_120A4();
void sub_120F4();
int __fastcall sub_12164(int a1);
char *__fastcall sub_121B0(const char *a1, float *a2);
char *__fastcall sub_12200(const char *a1, float *a2);
int __fastcall sub_12250(int result);
int __fastcall sub_122E8(int *a1, int a2, int *a3);
const char *__fastcall sub_14E38(const char *a1);
const char *__fastcall sub_14EB4(const char *a1);
int __fastcall sub_14F30(int a1);
int __fastcall sub_14FD0(int a1, int a2, unsigned int a3);
int __fastcall sub_15264(char *a1, size_t a2, time_t *a3);
void sub_152E0();
char *__fastcall sub_1545C(const char *a1, _DWORD *a2, int a3, int a4);
char *__fastcall sub_1549C(const char *a1);
char *__fastcall sub_154C8(const char *a1, _DWORD *a2);
char *__fastcall sub_154D4(const char *a1, _DWORD *a2);
char *__fastcall sub_154E0(const char *a1, _DWORD *a2);
char *__fastcall sub_154EC(const char *a1, _DWORD *a2);
char *__fastcall sub_154F8(const char *a1, _DWORD *a2);
char *__fastcall sub_15504(const char *a1, _DWORD *a2);
char *__fastcall sub_15510(const char *a1, _DWORD *a2);
char *__fastcall sub_1551C(const char *a1, _DWORD *a2);
char *__fastcall sub_15528(const char *a1, _DWORD *a2);
char *__fastcall sub_15534(const char *a1, _DWORD *a2);
char *__fastcall sub_15540(const char *a1, _DWORD *a2);
int __fastcall sub_1554C(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_1557C(int a1, char *a2);
const char *__fastcall sub_155F0(const char *a1);
void *__fastcall sub_15648(void **a1);
char *__fastcall sub_15684(int a1, int a2, int a3);
void __fastcall sub_15780(void **a1);
int __fastcall sub_15798(double a1);
void __fastcall sub_157EC(int a1);
void sub_15840();
void sub_15868();
int __fastcall sub_15890(const char *a1);
_BYTE *__fastcall sub_158AC(int a1, unsigned int a2);
__int64 __fastcall sub_158E4(__int64 *a1);
void __fastcall sub_159B4(int a1);
int __fastcall sub_15AC8(int result);
void __fastcall sub_15B64(FILE *s);
int sub_160B4();
char *__fastcall sub_16150(char *a1);
int __fastcall sub_16244(int a1);
int __fastcall sub_16494(char *a1, unsigned __int64 a2);
int __fastcall sub_16534(int a1);
bool __fastcall sub_1654C(int a1, int a2);
bool __fastcall sub_165A0(int a1, int a2);
unsigned int __fastcall sub_16624(int a1, int a2);
int __fastcall sub_16A80(int a1, void *s2, size_t n, const void *a4, int a5, size_t a6);
void __fastcall sub_16B40(int a1, _DWORD *a2);
int __fastcall sub_16C88(int result);
void __fastcall __noreturn sub_16CA8(int a1);
char *__fastcall sub_16CB0(char *a1);
char *__fastcall sub_16D98(char *s);
char *__fastcall sub_16DEC(_DWORD *a1, int a2);
int __fastcall sub_17100(int a1, char *a2);
int sub_17210();
int __fastcall sub_17254(char *a1);
int __fastcall sub_17744(char *a1, size_t a2, int a3);
void __noreturn sub_178F8();
void __fastcall sub_17950(int a1, int a2, int a3, int a4, int a5);
void __noreturn sub_1795C();
int __fastcall sub_17990(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_179BC(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_179E8(int a1, const char *a2, int a3);
char *sub_17A3C();
const char *__fastcall sub_17C4C(char *s);
const char *__fastcall sub_17D3C(int a1);
int sub_17DB8();
int __fastcall sub_17E04(char *a1);
const char *__fastcall sub_17F68(int a1);
int sub_17FE4();
void sub_18068();
void __fastcall sub_18178(int a1, int a2);
int __fastcall sub_181F4(int a1, unsigned int a2);
int *__fastcall sub_182F4(int a1);
void __fastcall sub_185C8(_DWORD *a1);
int __fastcall sub_18834(int a1, _BYTE *a2);
int sub_188A8();
int __fastcall sub_18924(int a1, int a2);
int __fastcall sub_189A4(int a1);
int sub_18AD8();
int sub_18B44();
int __fastcall sub_18BC0(const char *a1);
int __fastcall sub_18C2C(int a1, _BYTE *a2);
int __fastcall sub_18CA0(_DWORD *a1, int a2);
int __fastcall sub_193B4(int a1);
int sub_19840();
int __fastcall sub_198B0(int a1, int a2);
int __fastcall sub_199E8(int a1, const char *a2, const char *a3);
int sub_19ADC();
int __fastcall sub_19BBC(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_19BF8(int a1);
int __fastcall sub_19F54(pthread_rwlock_t *a1, int a2);
int __fastcall sub_19FC8(pthread_rwlock_t *a1);
void __fastcall sub_1A0B8(pthread_rwlock_t *a1, void **a2);
_DWORD *__fastcall sub_1A134(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int sub_1A1E8();
int __fastcall sub_1A2A4(int a1);
_DWORD *sub_1A3D4();
_DWORD *__fastcall sub_1A44C(int a1, int a2);
_DWORD *__fastcall sub_1A474(int a1);
unsigned __int64 __fastcall sub_1A4B4(int a1);
int __fastcall sub_1A730(int a1, int a2);
int __fastcall sub_1A914(int a1, int a2, int a3, _DWORD *a4);
void __fastcall sub_1AA18(pthread_rwlock_t *a1);
int __fastcall sub_1AB24(pthread_rwlock_t *a1, const char *a2, int a3);
_DWORD *__fastcall sub_1AB4C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
_DWORD *__fastcall sub_1AC00(pthread_rwlock_t *a1, int a2);
int __fastcall sub_1ACC4(int a1, int a2);
int __fastcall sub_1B074(pthread_rwlock_t *a1, int a2);
int __fastcall sub_1B124(int a1);
int sub_1B19C();
int sub_1B4C0();
void sub_1B4D8();
int __fastcall sub_1B5EC(int a1);
void __fastcall sub_1B600(const char *a1, _DWORD *a2);
int __fastcall sub_1B83C(int a1);
int sub_1B8B4();
void __fastcall sub_1BBA4(int a1, __int64 a2);
int sub_1C668();
void sub_1D7C8();
void __fastcall __noreturn sub_1D8FC(int a1, int a2);
int __fastcall sub_1D9B4(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int sub_1DA58();
int __fastcall sub_1DB0C(int a1);
int __fastcall sub_1F17C(int a1);
int __fastcall sub_1F938(int a1, int a2, int a3);
void __fastcall sub_1FA14(int a1);
int __fastcall sub_1FB44(int a1);
int sub_1FB7C();
void __fastcall sub_1FC34(_DWORD *a1);
void __fastcall sub_1FD64(_DWORD *a1);
void *__fastcall start_routine(_DWORD *a1);
int __fastcall sub_1FFEC(int a1);
void *__fastcall sub_20088(_DWORD *a1);
void __noreturn sub_21850();
void *__fastcall sub_21FE8(_DWORD *a1);
int __fastcall sub_22B44(int a1, int a2);
void sub_22F88();
void *__fastcall sub_231F0(void *a1); // idb
void __noreturn sub_23344();
int __fastcall sub_24708(int a1);
int __fastcall sub_24760(pthread_rwlock_t *a1);
int __fastcall sub_247D4(int a1, int a2);
int __fastcall sub_24D88(int a1, pthread_rwlock_t *a2, int a3);
void __fastcall sub_24DB0(int a1);
void __fastcall sub_256A4(int a1);
int __fastcall sub_25E28(int a1, int a2, int a3);
void __fastcall sub_25E48(int a1);
int __fastcall sub_25E5C(int a1, int a2);
int __fastcall sub_25F48(int a1, char *a2, unsigned int a3);
char *__fastcall sub_25FDC(const char *a1);
int __fastcall sub_260D0(const char *a1);
void sub_260FC();
void sub_267B0();
int __fastcall sub_26BCC(int a1, int a2, char *a3, const char *a4, const char *a5);
void sub_26CEC();
int __fastcall sub_26D10(int a1);
void sub_26F50();
int sub_27A98();
int sub_27BA0();
int __fastcall sub_27CD0(int result);
int __fastcall sub_27F10(pthread_rwlock_t *a1);
int __fastcall sub_28008(_DWORD *a1);
int sub_28AE0();
int __fastcall sub_28AE8(int result);
bool __fastcall sub_28AFC(int a1, int a2);
int __fastcall sub_28B9C(int a1);
ssize_t __fastcall sub_28BC4(int a1);
int __fastcall sub_28BEC(const char **a1, int a2, int a3);
int __fastcall sub_28FC8(const char **a1, int a2, int a3);
int __fastcall sub_2926C(struct timespec *req); // idb
_DWORD *__fastcall sub_29294(_DWORD *a1, unsigned int a2);
char *__fastcall sub_292F4(_DWORD *a1, unsigned int a2);
int __fastcall sub_2930C(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_29388(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_29404(int a1, char *s, int a3);
int __fastcall sub_295A8(int a1);
int __fastcall sub_2962C(int a1, char a2);
const char *__fastcall sub_29690(char *a1);
_BYTE *__fastcall sub_296D8(_BYTE *result, char *a2, int a3);
_BYTE *__fastcall sub_29730(int a1, int a2);
bool __fastcall sub_29830(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_299AC(int a1, _DWORD *a2, unsigned int a3);
_BYTE *__fastcall sub_29C70(_BYTE *a1, char *s);
int __fastcall sub_29DFC(int a1, int a2);
int __fastcall sub_29F54(unsigned int *a1, unsigned int *a2);
char *sub_2A168();
void __fastcall sub_2A1A8(char *a1);
int __fastcall sub_2A230(int a1);
int __fastcall sub_2A238(int a1);
int __fastcall sub_2A240(int a1, int a2);
int __fastcall sub_2A300(int a1, const struct timespec *a2);
int __fastcall sub_2A3DC(int result);
int __fastcall sub_2A414(int result);
int __fastcall sub_2A448(_DWORD *a1, int *a2);
int __fastcall sub_2A47C(_DWORD *a1, int *a2);
bool __fastcall sub_2A4C8(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_2A4FC(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_2A530(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_2A544(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_2A56C(_DWORD *result, _DWORD *a2);
int __fastcall sub_2A588(_DWORD *a1);
int __fastcall sub_2A5C0(_DWORD *a1);
int __fastcall sub_2A600(_DWORD *a1);
int __fastcall sub_2A648(_DWORD *a1);
int *__fastcall sub_2A688(int *result, _DWORD *a2);
const char *__fastcall sub_2A718(const char *a1, const char *a2, int a3, int a4);
const char *__fastcall sub_2A800(const char **a1, const char *a2);
int __fastcall sub_2A84C(struct timeval *a1);
int __fastcall sub_2A854(_DWORD *a1);
int __fastcall sub_2A87C(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_2A8B8(struct timespec *tp); // idb
int __fastcall sub_2A8C4(_DWORD *a1);
int __fastcall sub_2A8FC(_DWORD *a1);
int sub_2A92C();
int sub_2A954();
_DWORD *__fastcall sub_2A988(_DWORD *result, _DWORD *a2);
void sub_2AA24();
void __fastcall sub_2AA68(int a1, char *s);
int __fastcall sub_2AB54(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_2ACE0(char *s1, int a2);
bool __fastcall sub_2AE10(int a1);
void **__fastcall sub_2AE2C(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6);
int __fastcall sub_2AEE0(int a1);
char *__fastcall sub_2B040(int a1);
int __fastcall sub_2B5C8(int a1, char *a2, int a3);
int __fastcall nullsub_1(_DWORD); // weak
int *__fastcall sub_2B8E8(_DWORD *a1);
int __fastcall sub_2CEC8(int a1);
int __fastcall sub_2CF40(_DWORD *a1, int *a2);
int __fastcall sub_2E69C(int *a1);
int __fastcall sub_2EA38(_DWORD *a1);
time_t __fastcall sub_2ED88(_DWORD *a1, int a2);
char *__fastcall sub_2EF64(const char *a1);
int __fastcall sub_2F0B4(const char *a1);
int __fastcall sub_2F0F4(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_2F174(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_2F1BC(sem_t *a1, const char *a2, const char *a3, int a4);
void *__fastcall sub_2F23C(sem_t *a1);
int __fastcall sub_2F280(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall sub_2F304(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
int *__fastcall sub_2F400(sem_t *sem);
int __fastcall sub_2F438(int a1, int a2, int a3);
int __fastcall sub_2F64C(int a1, char a2);
void __fastcall sub_2F934(_DWORD *a1, char *a2, int a3);
void __fastcall sub_30074(_DWORD *a1, int a2, int a3);
unsigned int __fastcall sub_300B0(unsigned int result, int a2, int a3);
_DWORD *__fastcall sub_302D0(_DWORD *result);
void *__fastcall sub_30304(int *a1, const void *a2, size_t n);
_DWORD *__fastcall sub_303A4(_DWORD *a1, int a2);
_DWORD *__fastcall sub_3049C(const void *a1, size_t n, int a3);
char *__fastcall sub_30500(char *s, int a2);
void sub_3069C();
void *__fastcall sub_306B4(int a1, char *s);
int __fastcall sub_307C8(unsigned int *a1, char *s);
void __fastcall sub_3085C(unsigned int *a1, char *s, int a3, _BYTE *a4);
int __fastcall sub_30968(unsigned int *a1, char *s);
int __fastcall sub_30980(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_309B4(unsigned int *a1, int a2, int a3, int a4);
bool __fastcall sub_309E8(const struct sockaddr *a1, const char **a2, _BYTE *a3);
void __fastcall sub_30B88(int a1, int a2, int a3);
int sub_3107C();
int __fastcall sub_31CA0(int a1);
_DWORD *__fastcall sub_31CDC(_DWORD *a1, const char *a2, int a3, const char *a4, char a5);
int __fastcall sub_31F64(int result, int a2);
unsigned __int8 **__fastcall sub_31FC4(unsigned __int8 **result, unsigned __int8 **a2);
int __fastcall sub_3204C(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, _DWORD *a4);
int __fastcall sub_32190(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_3220C(pthread_mutex_t *a1, const char *a2, int a3);
int sub_32248();
void __noreturn sub_32340(); // weak
int __fastcall sub_3243C(int *a1);
int __fastcall sub_32534(unsigned int *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_32DF8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E1C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E40(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E64(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E88(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32EAC(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32ED0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32EF4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32F18(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32F3C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32F60(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32F84(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32FA8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32FCC(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32FF0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_33014(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_33038(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_3305C(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5);
int __fastcall sub_33474(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_33548(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_3355C(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_33710(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_33724(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_3387C(int a1, int a2, _BYTE *a3, int a4);
int __fastcall sub_33B88(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4);
int __fastcall sub_33C34(int a1, int a2, const char *a3, int a4, unsigned __int8 a5);
int __fastcall sub_33DCC(int a1, int a2, int a3, int a4);
void __fastcall sub_33F70(unsigned int *a1, int a2, char *nptr, int a4, int a5);
int __fastcall sub_3411C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34264(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34388(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall sub_344D0(unsigned int *a1, int a2, char *s, int a4);
void __fastcall sub_34728(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_34830(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34A90(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_34AA4(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_34C60(int a1, int a2, int a3, int a4);
void __fastcall sub_34DC0(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_34E9C(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
_DWORD *__fastcall sub_34EB0(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_35154(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6);
_DWORD *__fastcall sub_35520(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35544(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35568(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_3558C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_355B0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_355D4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_355F8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_357A4(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_357C8(int a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_363D8(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_363FC(unsigned int *a1, int a2, int a3, int a4);
int sub_3669C();
void __fastcall sub_36764(int a1);
void __fastcall sub_38730(int a1, const char *a2, int a3);
int sub_388E4();
int __fastcall sub_3896C(int a1);
int __fastcall sub_389F4(int result, const char *a2, const char *a3, int a4);
void __fastcall sub_38AC4(int a1, const char *a2, int a3);
const char *__fastcall sub_38B58(const char **a1, const char *a2, const char *a3, int a4);
_BYTE *__fastcall sub_38E94(int a1);
_BYTE *__fastcall sub_38F3C(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall sub_391FC(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_3927C(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_392A8(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_39370(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_39460(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_395B8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_39714(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_39880(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_39984(const char **a1, int *a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_39B04(const char **a1, int *a2, const char *a3, const char *a4, int a5);
int __fastcall sub_39C7C(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_39D98(const char **ptr, const char *a2, const char *a3, int a4);
int __fastcall sub_39EF4(__int64 a1, _QWORD *a2);
void sub_3A354();
void sub_3A3F4();
_DWORD *sub_3A4EC();
int sub_3A920();
void sub_3A940();
void __noreturn sub_3AA9C();
void __noreturn sub_3ABF4();
void sub_3ADE0();
int sub_3AE24();
int sub_3AE6C();
int sub_3AEBC();
int __fastcall sub_3AF0C(pthread_rwlock_t *a1);
int __fastcall sub_3AF90(int a1);
int sub_3B704();
int sub_3B844();
int __fastcall sub_3B954(int a1);
int __fastcall sub_3B980(int result, int a2);
void sub_3B994();
int sub_3BA70();
int __fastcall sub_3BB00(int result);
int __fastcall sub_3BB44(int a1);
int __fastcall sub_3BB78(int a1);
int __fastcall sub_3BD44(int a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_3BF0C(int a1);
int __fastcall sub_3C0A0(int a1);
size_t __fastcall sub_3C150(int a1, const void *a2, size_t a3);
int __fastcall sub_3C5E8(int a1, _BYTE *a2, unsigned int a3);
void __fastcall sub_3C66C(int a1);
int __fastcall sub_3C708(int a1);
void __fastcall sub_3C7B0(int a1);
int sub_3C7C8();
int __fastcall sub_3C7E0(char a1, char a2, int a3, int a4);
int __fastcall sub_3CA38(char a1, __int16 a2, int a3, int a4);
int __fastcall sub_3CC6C(_BYTE *a1, int a2);
int __fastcall sub_3CD58(int a1);
int __fastcall sub_3CDCC(int a1, char a2, char a3, char a4, unsigned int a5);
int __fastcall sub_3CE7C(int a1, unsigned __int8 a2);
int __fastcall sub_3CEF0(int a1, char a2, char a3, char a4);
unsigned int __fastcall sub_3CFC4(unsigned int result, unsigned __int8 *a2, int a3);
int __fastcall sub_3D000(__int16 a1, __int16 a2);
int __fastcall sub_3D1AC(int a1);
int sub_3DA84();
int sub_3DC28();
int sub_3DDD0();
int sub_3DF78();
int __fastcall sub_3E564(char a1, _WORD *a2);
void __fastcall sub_3E5A4(int a1);
int sub_3E688();
int __fastcall sub_3E6E0(int result, unsigned __int8 *a2, int a3);
int __fastcall sub_3E814(int result, unsigned __int8 *a2, int a3);
int __fastcall sub_3E9AC(unsigned int a1);
int __fastcall sub_3EA50(char a1, unsigned int a2);
int __fastcall sub_3ECB8(char a1, int a2);
int __fastcall sub_3EEC8(int a1);
int sub_3EFB0();
int __fastcall sub_3F010(int a1, int a2, int a3);
void __fastcall sub_3F0A4(int a1);
int __fastcall sub_3F308(int a1);
int __fastcall sub_3F4BC(int a1);
int __fastcall sub_3F6CC(int a1);
int sub_3FA7C();
int sub_3FC24();
int sub_3FDC4();
void __noreturn sub_40034();
int __fastcall sub_40128(_BYTE *a1);
void sub_40454();
int __fastcall sub_405AC(_BYTE *a1);
int __fastcall sub_40888(int a1);
int __fastcall sub_40A84(int a1);
int sub_40DEC();
void sub_40E94();
int sub_41308();
int sub_413F0();
int sub_414D8();
int sub_415BC();
void sub_41614();
int sub_416EC();
pthread_mutex_t *sub_417B0();
int __fastcall sub_419C8(unsigned int a1);
int __fastcall sub_41B8C(_WORD *a1);
int __fastcall sub_41E7C(unsigned __int8 *src, char a2, signed int n);
int __fastcall sub_42100(void *a1, char a2, size_t a3);
int __fastcall sub_425C0(unsigned int a1);
int sub_42820();
int __fastcall sub_42958(int a1, int a2);
int __fastcall sub_42A60(_BYTE *a1, int a2);
int __fastcall sub_42B54(unsigned __int8 *a1);
size_t __fastcall sub_42F04(unsigned __int8 a1);
size_t __fastcall sub_42F40(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall sub_42F7C(int a1);
int sub_43060();
int __fastcall sub_430A0(int a1, unsigned int a2);
int __fastcall sub_431AC(int a1, int a2);
int __fastcall sub_432C0(unsigned int a1);
int __fastcall sub_4330C(int a1);
int __fastcall sub_43358(int a1);
int sub_4345C();
int __fastcall sub_434A0(int a1, char a2);
int __fastcall sub_43594(char a1);
int __fastcall sub_435E0(int a1, int a2);
int __fastcall sub_43734(int a1, int a2, int a3);
void __noreturn sub_4388C();
int __fastcall sub_43E4C(int a1);
int __fastcall sub_43E98(int a1, char a2);
int __fastcall sub_43F04(int a1);
int __fastcall sub_44004(int a1, int a2);
int __fastcall sub_44104(int result);
int __fastcall sub_44148(int a1, int a2, int a3);
int __fastcall sub_4425C(int result, int a2);
unsigned int __fastcall sub_442A8(unsigned int a1);
void sub_442B0();
int __fastcall sub_445E8(int result, int a2);
int __fastcall sub_448BC(int a1);
size_t __fastcall sub_44968(unsigned __int8 a1, const void *a2, size_t a3);
int __fastcall sub_44970(unsigned __int8 a1, _BYTE *a2, unsigned int a3);
void sub_44978();
int __fastcall sub_44AC0(int a1);
void __noreturn sub_44B5C();
int __fastcall sub_45AF0(_BYTE *a1, _DWORD *a2);
int sub_45B30();
void sub_45B50();
int __fastcall sub_45D88(int a1);
void sub_45DEC();
int sub_45EC0();
int __fastcall sub_4601C(int a1);
int sub_4614C();
void __fastcall sub_46174(int a1, int a2);
void __fastcall sub_46294(int a1);
int __fastcall sub_4633C(int a1, int a2, char a3, unsigned __int8 a4, unsigned __int8 a5);
int sub_463C8();
int __fastcall sub_46434(int a1, int a2);
int __fastcall sub_466A4(int result);
int sub_467B0();
int sub_46880();
int sub_46964();
int __fastcall sub_46A48(int a1);
int __fastcall sub_46B94(unsigned __int8 *a1);
int sub_46C10();
int sub_46CBC();
int sub_470A8();
void __noreturn sub_47354();
void __fastcall sub_4791C(int a1);
int __fastcall sub_47AAC(unsigned __int64 a1, char *a2, size_t a3, int a4, char a5);
int sub_47C80();
int sub_481B4();
int __fastcall sub_481EC(int a1, int a2, int a3, int a4);
void __fastcall sub_4886C(int a1, int a2, char a3, unsigned int a4);
void __noreturn sub_48A18();
void sub_48FA8();
void __fastcall sub_490FC(int a1, int a2);
void __fastcall sub_492B0(int a1);
int sub_49458();
int __fastcall sub_4949C(int result);
int __fastcall sub_4952C(int result, char a2);
int __fastcall sub_49578(char a1);
void sub_4962C();
void __fastcall sub_49700(int a1, int a2);
int sub_497CC();
int __fastcall sub_49824(int a1);
int __fastcall sub_498C0(int a1, int a2);
int sub_498F4();
int __fastcall sub_499D4(void *a1);
int sub_49AC0();
int __fastcall sub_49BA0(int a1);
int sub_49BE8();
int __fastcall sub_49CC8(int a1);
int __fastcall sub_4A598(int a1);
int __fastcall sub_4A730(int a1, int a2);
int __fastcall sub_4A740(int a1, int a2);
int __fastcall sub_4A754(int a1, int a2, int a3, int a4, char a5);
void __fastcall sub_4ACEC(_BYTE *a1, char a2, int a3);
void __fastcall sub_4AE48(int a1, int a2, char a3);
int *__fastcall sub_4B0C0(int *a1);
int __fastcall sub_4B4F0(_DWORD *a1, unsigned int *a2);
unsigned int *__fastcall sub_4DBEC(unsigned int *result, unsigned int *a2, int a3);
unsigned int *__fastcall sub_4DCCC(int a1, _BYTE *a2);
int __fastcall sub_4DF30(void *src, int a2, void *a3, unsigned __int8 a4);
int __fastcall sub_4DF84(const void *a1, const void *a2);
unsigned int __fastcall sub_4DF94(unsigned int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6);
unsigned int *__fastcall sub_4E134(unsigned int *result, int a2);
unsigned int __fastcall sub_4EA38(int a1, int a2, int a3, size_t n);
int __fastcall sub_4EA58(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_4EAF4(void *a1, unsigned int a2);
int __fastcall sub_4EEE0(char *a1, int a2, int a3);
int __fastcall sub_4EF68(int a1, unsigned __int8 *a2);
int __fastcall sub_54DCC(char *a1, unsigned __int8 *a2);
int __fastcall sub_54ED0(char *a1, int a2);
int __fastcall sub_54F8C(int a1, char *src, unsigned __int64 n);
int __fastcall sub_55098(char *a1, int a2, const void *a3, size_t a4);
int __fastcall sub_551D4(int a1, void *a2, size_t a3);
int __fastcall sub_55470(unsigned __int8 *a1);
int __fastcall sub_55700(int result);
int __fastcall sub_5576C(int result, int a2, int a3);
_BYTE *__fastcall sub_557D4(int a1, _BYTE *a2);
_BYTE *__fastcall sub_55930(int a1, int a2, _BYTE *a3);
int __fastcall sub_559D0(int a1);
void *__fastcall sub_5664C(void *a1); // idb
void sub_56A90();
void __fastcall sub_56B3C(int *a1, int a2, int a3);
void __fastcall sub_56CD8(unsigned int *a1, int a2, int a3);
int __fastcall compar(_DWORD *a1, _DWORD *a2);
int __fastcall sub_56E6C(char *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4);
int __fastcall sub_57090(int a1, int a2);
int __fastcall sub_5709C(const void *a1, size_t a2, FILE *s);
int __fastcall sub_570BC(void *src, size_t n, const void **a3);
int __fastcall sub_570D4(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall sub_57178(_DWORD *a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5);
int __fastcall sub_577A4(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4);
int __fastcall sub_577F0(_DWORD *a1, int a2, __int16 a3);
int __fastcall sub_57804(_DWORD *a1, char *filename, __int16 a3);
void *__fastcall sub_57854(_DWORD *a1, __int16 a2);
int __fastcall sub_578C0(int result, int a2, _DWORD *a3);
int __fastcall sub_5791C(int a1, int *a2, char *s2, int a4);
void __fastcall sub_57994(int a1);
int __fastcall sub_579F4(_DWORD *a1);
void __fastcall sub_57A74(int a1);
int __fastcall sub_57A8C(int a1, char *a2, int a3, int a4);
int __fastcall sub_57C94(int a1, char *a2);
int __fastcall sub_57D0C(_DWORD *a1, char *a2);
void __fastcall sub_57E28(_DWORD *a1);
int __fastcall sub_57EA4(int a1, char *a2);
int __fastcall sub_57F3C(int a1);
void __fastcall sub_57F4C(int a1, int a2);
int __fastcall sub_57F94(_DWORD *a1);
int __fastcall sub_57FB4(_DWORD *a1);
int __fastcall sub_57FD8(_DWORD *a1);
int sub_58034(int result, _DWORD *a2, const char *a3, ...);
int __fastcall sub_58154(int a1, int a2, int a3);
void __fastcall sub_581A0(int a1);
int __fastcall sub_581CC(_BYTE *a1);
_DWORD *__fastcall sub_58274(_DWORD *result, int a2);
int __fastcall sub_5832C(int a1, int a2);
_DWORD *__fastcall sub_584B0(_DWORD *result, int a2);
int __fastcall sub_584FC(int a1, int a2);
unsigned int __fastcall sub_5852C(int a1, int a2);
int *__fastcall sub_58D00(double a1, int a2);
int *__fastcall sub_59154(_DWORD *a1, unsigned int a2, int a3);
int *__fastcall sub_59230(int *a1, unsigned int a2, char *a3);
int *__fastcall sub_592C4(int *a1, int a2, unsigned int a3, char *a4);
int *__fastcall sub_59360(int *a1, unsigned int a2, char *a3);
int *__fastcall sub_5940C(char *a1, unsigned int a2, char *a3);
void *__fastcall sub_5956C(size_t a1);
void __fastcall sub_59594(void *a1);
void *__fastcall sub_595B4(const char *a1);
void *(*__fastcall sub_5960C(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
int __fastcall sub_5961C(_DWORD *a1);
void __fastcall sub_59654(int a1);
int __fastcall sub_59680(int result);
int __fastcall sub_59694(int a1);
int __fastcall sub_5969C(int *a1);
int __fastcall sub_596B0(const void **a1, void *src, size_t n);
int __fastcall DataWriter::WriteByte(const void **this, unsigned __int8 a2);
int __fastcall luaL_addstring(const void **a1, char *s);
int __fastcall sub_597C0(int *a1, int a2, int a3);
int __fastcall sub_597E8(int a1, double *a2);
int __fastcall sub_598A8(char *a1, size_t a2);
int __fastcall sub_599DC(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_59AC4(int a1);
int __fastcall sub_59B40(char *a1, int a2, int *a3);
char *__fastcall sub_59C18(char *a1, _DWORD *a2);
int __fastcall sub_59C8C(const char *a1, signed int a2);
void *__fastcall sub_59D20(_DWORD *a1, int a2, int a3);
_DWORD *sub_59DA8();
_DWORD *__fastcall sub_59E04(_DWORD *result);
int __fastcall sub_59E20(_DWORD *a1, char *a2);
int __fastcall sub_59E44(_DWORD *a1, char *a2);
int __fastcall sub_59E68(_DWORD *a1);
_DWORD *__fastcall sub_59E9C(_DWORD *a1);
int __fastcall sub_59EC0(_DWORD *a1, char *a2);
int __fastcall sub_59EE8(_DWORD *a1, int a2);
int __fastcall sub_59F14(int result);
int __fastcall sub_59F20(int result);
int __fastcall sub_59F2C(_DWORD *a1, int a2, int a3);
int __fastcall sub_59F74(int result);
_DWORD *sub_59F80();
_DWORD *__fastcall sub_59FEC(_DWORD *result);
_DWORD *__fastcall sub_5A008(_DWORD *result, unsigned int a2);
int __fastcall sub_5A03C(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_5A0EC(const char *a1);
_DWORD *__fastcall sub_5A148(const char *a1);
_DWORD *__fastcall sub_5A178(_DWORD *result);
int __fastcall sub_5A194(int a1, const char *a2);
int __fastcall sub_5A1E0(int a1, const char *a2);
_QWORD *__fastcall sub_5A21C(__int64 a1);
__int64 __fastcall sub_5A248(int a1);
int __fastcall sub_5A274(int a1, __int64 a2);
_QWORD *__fastcall sub_5A29C(double a1);
void sub_5A2F8();
int __fastcall sub_5A328(double a1);
int __fastcall sub_5A378(int result);
void *sub_5A3C0();
void *sub_5A3CC();
void *sub_5A3D8();
void __fastcall sub_5A3E4(void **a1);
int __fastcall sub_5A4B8(_DWORD *a1);
int __fastcall sub_5A534(_DWORD *a1, unsigned int a2);
int __fastcall sub_5A5E8(int a1, unsigned int a2, int a3);
int __fastcall sub_5A6E8(int *a1, int *a2);
int __fastcall sub_5A76C(_DWORD *a1, unsigned int a2, int a3);
int __fastcall sub_5A820(_DWORD *a1, char *a2, int a3);
int __fastcall sub_5A8A0(_DWORD *a1, _DWORD *a2);
int __fastcall sub_5A95C(_DWORD *a1, char *a2, int a3);
int __fastcall sub_5A9D0(_DWORD *a1, _DWORD *a2);
int __fastcall sub_5AA7C(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_5AB30(int *a1, int *a2);
int *__fastcall sub_5ACF4(double a1);
int *__fastcall sub_5AE68(double a1);
char *__fastcall sub_5AFB0(char *result, char *s);
char *__fastcall sub_5B014(char *result, char *s);
int __fastcall sub_5B058(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg); // idb
int sub_5B098(int a1, int a2, int a3, int a4, char *format, ...); // idb
char *__fastcall sub_5B0C0(const char *a1, const char *a2);
int __fastcall sub_5B0FC(_BYTE *a1);
int __fastcall sub_5B10C(_BYTE *a1);
char *__fastcall sub_5B120(const char *a1, _BYTE *a2);
char *__fastcall sub_5B1B4(const char *a1, _BYTE *a2);
int __fastcall sub_5B1D4(int a1, _DWORD *a2);
char *__fastcall sub_5B1E0(const char *a1, _DWORD *a2);
char *__fastcall sub_5B264(const char *a1, int *a2);
char *__fastcall sub_5B2E8(const char *a1, _DWORD *a2);
int __fastcall sub_5B3A8(_DWORD *a1);
void __fastcall __noreturn sub_5B3C0(const char *a1);
void __fastcall __noreturn sub_5B3E0(int a1);
char *__fastcall sub_5B420(char *a1, unsigned __int8 *a2);
char *__fastcall sub_5B444(char *a1, unsigned __int8 *a2);
char *__fastcall sub_5B468(_BYTE *a1, const char **a2);
int __fastcall sub_5B4C8(char *a1, _DWORD *a2);
int __fastcall sub_5B4DC(char *a1, float *a2);
int __fastcall sub_5B508(char *a1, _DWORD *a2);
int __fastcall sub_5B51C(char *a1, _DWORD *a2);
int __fastcall sub_5B530(char *a1, _DWORD *a2);
unsigned __int8 *__fastcall sub_5B544(int a1, _DWORD *a2);
_BYTE *__fastcall sub_5B5EC(unsigned int *a1, _DWORD *a2);
unsigned __int8 *__fastcall sub_5B6D4(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3);
unsigned __int8 *__fastcall sub_5B7C8(const char **a1);
int __fastcall sub_5B9A8(int *a1);
unsigned __int8 *__fastcall sub_5BA08(unsigned int *a1, unsigned __int8 **a2);
unsigned __int8 *__fastcall sub_5BA60(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3);
unsigned __int8 *__fastcall sub_5BAB8(unsigned int *a1);
unsigned __int8 *__fastcall sub_5BB14(unsigned __int8 *a1, unsigned int *a2);
int __fastcall sub_5BBB8(int result, int a2);
bool __fastcall sub_5BC84(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_5BCE0();
int sub_5BD00(const char *a1, ...);
void __noreturn sub_5BD48(const char *a1, ...);
char *__fastcall sub_5BD88(const char *a1);
void *__fastcall sub_5BDB8(_DWORD *a1, int a2, int a3);
int __fastcall sub_5BDEC(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_5C20C(const char *a1, char *a2);
int __fastcall sub_5C710(int a1, int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2);
int __fastcall sub_5C80C(__int64 a1, __int64 a2);
int __fastcall sub_5CB50(__int64 a1);
int __fastcall sub_5CB64(__int64 a1);
int __fastcall sub_5CBC4(__int64 a1, __int64 a2);
int __fastcall sub_5CC10(double a1);
unsigned int __fastcall sub_5CC48(double a1);
int __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
int __fastcall _gnu_uldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
int __fastcall sub_5CD08(__int64 a1, __int64 a2);
int __fastcall sub_5D160(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4);
int nullsub_11(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_122A0; // weak
_UNKNOWN loc_201FC; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN loc_38D7C; // weak
_UNKNOWN init;
_UNKNOWN unk_5D5FC; // weak
_UNKNOWN unk_5D628; // weak
int dword_5D64C[16] = { 1, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1568 }; // weak
_UNKNOWN unk_5D6AC; // weak
char a000000029c6bf4[321] = "000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4"; // weak
char a00000002c01f50[321] = "00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f"; // weak
const char delim[] = { '|', '\0' }; // idb
const char a49[] = "4.9."; // idb
const char word_63C1C[] = { '0', '\0' }; // idb
char aClearSock[11] = "clear_sock"; // weak
char *off_64E3C = "http:"; // weak
const char dword_660D4[] = { 'n', 'o', '\0', '\0' }; // idb
char aEscapeString[14] = "escape_string"; // weak
char aResetAllHashBo[25] = "reset_all_hash_board_low"; // weak
char aD_0[2] = "d"; // weak
_UNKNOWN unk_69AF8; // weak
const char aSChainDFailed_0[20] = "%s chain %d failed!\n"; // idb
const char ptr[] = { '\n', '\0' }; // idb
const char aAsicNumErrD[16] = "asic num err![%d"; // idb
const char word_6B5B0[] = { ']', '\0' }; // idb
_UNKNOWN unk_6B9E8; // weak
_UNKNOWN unk_6BA58; // weak
unsigned int dword_6C3E4[16] = { 128u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
_UNKNOWN unk_6C578; // weak
_UNKNOWN unk_6C580; // weak
char aStatusservicet[45] = "statusServiceThread not support http command"; // weak
char aStatusservicet_1[45] = "statusServiceThread send http response error"; // weak
_DWORD dword_6CB74[29] =
{
  5,
  13,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741
}; // weak
int (*off_751B0[2])() = { &frame_dummy, &_do_global_dtors_aux }; // weak
int (*off_751B4)() = &_do_global_dtors_aux; // weak
int dword_755F0[] = { 1 }; // weak
double dbl_755F8 = 1.0; // weak
char *off_75600 = "--version-file"; // weak
int dword_75604 = 2; // weak
_UNKNOWN unk_7561C; // weak
int dword_75DC4 = 48; // weak
int dword_75DC8 = 0; // weak
int dword_75DCC = 5; // weak
char byte_75DD0 = '\x01'; // weak
char *off_75DD4 = ":D"; // weak
int dword_75DD8 = 1; // weak
int dword_75DDC = 1; // weak
double dbl_75DE0 = 1.84467441e19; // weak
double dbl_75DE8 = 1.0; // weak
int dword_75DF0 = -1; // weak
int dword_75DF4 = 120; // weak
int dword_75DF8 = 1; // weak
int dword_75DFC = 1; // weak
int dword_75E00 = 1; // weak
int dword_75E04 = 1; // weak
int dword_75E08 = 1; // weak
char byte_75E0C = '\x01'; // weak
char byte_75E0D = '\x01'; // weak
char *off_75E24 = "--config|-c"; // weak
int dword_75EB4 = 1; // weak
int dword_75EBC = 4028; // weak
_UNKNOWN *off_75EC0 = (_UNKNOWN *)0x6AF64; // weak
char *off_75EC4[3] = { "FTW", "224.0.0.75", "0.0.0.0" }; // weak
char *off_75EC8[2] = { "224.0.0.75", "0.0.0.0" }; // weak
char *off_75ECC = "0.0.0.0"; // weak
int dword_75ED0 = 4028; // weak
_UNKNOWN *off_75ED4 = &unk_63C10; // weak
int (*off_75ED8)() = &sub_28AE0; // weak
_UNKNOWN unk_75FDC; // weak
_UNKNOWN unk_760D8; // weak
_UNKNOWN unk_760F8; // weak
int dword_760FC[] = { 3 }; // weak
int dword_76100 = 7; // weak
_UNKNOWN *off_7652C = (_UNKNOWN *)0x64AD0; // weak
_UNKNOWN unk_76534; // weak
int dword_766C4 = 5; // weak
_UNKNOWN unk_76AC8; // weak
void (*off_76AD4)() = &sub_3A940; // weak
_BYTE byte_76B48[3] = { 80, 84, 88 }; // weak
char byte_76B4B = '\x01'; // weak
int dword_76B4C = -1; // weak
int dword_76B50 = 20; // weak
int dword_76B54 = 34689297; // weak
int dword_76B58 = -2144861887; // weak
int dword_76B5C = 117455361; // weak
int dword_76B60 = 16; // weak
int dword_76B64 = 3; // weak
char byte_76B68 = '\x01'; // weak
int dword_76B6C = 16777216; // weak
char byte_76B70 = '\x01'; // weak
int dword_76B74 = 84000; // weak
int dword_76B78 = 50; // weak
int dword_76B7C = 800; // weak
char *off_76B84 = "z9"; // weak
int dword_76B90 = 3; // weak
void *(*off_76B94)(void *s, int c, size_t n) = &memset; // weak
int dword_76B98 = 1; // weak
int dword_76B9C = -1; // weak
void *(*off_76BA0)(size_t size) = &malloc; // weak
void (*off_76BA4)(void *ptr) = &free; // weak
_UNKNOWN unk_76BA8; // weak
_UNKNOWN unk_76BB0; // weak
_UNKNOWN unk_76BB8; // weak
int stdscr; // weak
int LINES; // weak
int stdin; // weak
int stdout; // weak
int stderr; // weak
char byte_76BD4; // weak
int dword_76BD8; // weak
int dword_76BDC; // weak
int dword_76BE0; // weak
int dword_76BE4; // weak
int dword_76BE8; // weak
int dword_76BEC; // weak
int dword_76BF0; // weak
char byte_76BF4[256]; // weak
int dword_76CF4; // weak
char byte_76CF8[512]; // idb
int dword_76EF8; // weak
int dword_76EFC; // weak
int dword_76F00; // weak
struct timeval stru_76F04; // weak
struct timeval stru_76F0C; // weak
_UNKNOWN unk_76F14; // weak
__int64 qword_76F18; // weak
char byte_76F20; // weak
int dword_76F24; // weak
int dword_76F28; // weak
char byte_76F2C[200]; // idb
int dword_76FF4; // weak
int dword_76FF8; // weak
int dword_76FFC; // weak
int dword_77000; // weak
int dword_77004; // weak
int dword_77008; // weak
int dword_7700C; // weak
int dword_77010; // weak
int dword_77014; // weak
char byte_77018; // weak
int dword_7701C; // weak
int dword_77020; // weak
int dword_77024; // weak
int dword_77028; // weak
int dword_7702C; // weak
pthread_mutex_t stru_77030; // idb
int dword_77048; // weak
int dword_7704C; // weak
int dword_77050; // weak
char byte_77054; // weak
char byte_77055; // weak
char byte_77056; // weak
int dword_77058; // weak
int dword_7705C; // weak
pthread_mutex_t stru_77060; // idb
pthread_cond_t stru_77078; // idb
int dword_770A8; // weak
int dword_770AC; // weak
int dword_770B0; // weak
int dword_770B4; // weak
pthread_mutex_t stru_770B8; // idb
int dword_770D0; // weak
int dword_770D4; // weak
_DWORD dword_770D8[2]; // weak
double dbl_770E0[12]; // weak
int dword_77140; // weak
char byte_77144; // weak
int dword_77148; // weak
int dword_7714C; // weak
int dword_77150; // weak
char byte_77154; // weak
char byte_77155; // weak
double dbl_77158; // weak
char byte_77160[256]; // weak
char byte_77260[40]; // weak
int dword_77288; // weak
int dword_7728C; // weak
int dword_77290; // weak
pthread_rwlock_t stru_77294; // idb
int dword_772B4; // weak
char byte_772B8[8]; // weak
_DWORD dword_772C0[4]; // weak
_UNKNOWN unk_772D0; // weak
_UNKNOWN unk_772D4; // weak
_UNKNOWN unk_772D8; // weak
_UNKNOWN unk_772DC; // weak
char byte_772E0[32]; // weak
char byte_77300[8]; // idb
char byte_77308; // weak
char byte_7730C; // weak
char byte_7730D; // weak
int dword_77310; // weak
char byte_77318; // weak
_BYTE byte_7731C[2560]; // weak
_BYTE byte_77D1C[2560]; // weak
char byte_7871C; // weak
int dword_78720; // weak
int dword_78724; // weak
int dword_78728; // weak
int dword_7872C; // weak
_DWORD dword_78730[4]; // weak
_UNKNOWN unk_78740; // weak
_UNKNOWN unk_78744; // weak
_UNKNOWN unk_78748; // weak
_UNKNOWN unk_7874C; // weak
char s[256]; // idb
char byte_78850[256]; // idb
int dword_78950; // weak
int dword_78954; // weak
int dword_78958[]; // weak
char byte_78A5C; // weak
_UNKNOWN unk_78A60; // weak
int dword_78B64; // weak
int dword_78B68; // weak
int dword_78B6C; // weak
int dword_78B74; // weak
int dword_78B78; // weak
char byte_78B84[16]; // idb
int dword_78B94; // weak
unsigned __int8 byte_78BD0[200]; // weak
int dword_78C98; // weak
char byte_78CA8; // weak
char byte_78CA9; // weak
char byte_78CAC; // weak
char byte_78CAD; // weak
char byte_78CAE; // weak
int dword_78CB0; // weak
int dword_78CB4; // weak
pthread_mutex_t stru_78CB8; // idb
int dword_78CD0; // weak
int dword_78CD4; // weak
int dword_78CD8; // weak
int dword_78CDC; // weak
char byte_78CE0; // weak
int dword_78CE4; // weak
char dword_78CE8[]; // idb
char word_78DE8[]; // idb
char byte_78E08; // weak
char byte_78E09; // weak
int dword_78E10[]; // weak
char byte_78E14; // weak
char byte_78E15; // weak
char byte_78E16; // weak
char byte_78E17; // weak
double dbl_78E18; // weak
int dword_78E20; // weak
char byte_78E28; // weak
double dbl_78E30; // weak
int dword_78E38; // weak
char byte_78E3C; // weak
_UNKNOWN unk_78E40; // weak
_UNKNOWN unk_78E60; // weak
double dbl_78E80; // weak
pthread_mutex_t stru_78E88; // idb
pthread_mutex_t stru_78EA0; // idb
int dword_78EB8; // weak
pthread_mutex_t stru_78EBC[10]; // weak
_UNKNOWN unk_78FAC; // weak
int dword_7909C; // weak
pthread_mutex_t stru_790A0; // idb
__int16 word_790B8[]; // weak
pthread_mutex_t stru_790D0; // idb
unsigned __int8 byte_790E8[4]; // weak
char byte_790EC[]; // weak
char byte_790ED; // weak
char byte_790EE; // weak
char byte_790EF; // weak
char byte_790F0; // weak
char byte_790F1; // weak
int dword_790F4; // weak
int dword_790F8; // weak
pthread_mutex_t stru_79100; // idb
char byte_7911C; // weak
char byte_7911D; // weak
char byte_7911E; // weak
int dword_79120; // weak
char byte_79124; // weak
char byte_79125; // weak
char byte_79126; // weak
char byte_79127; // weak
int dword_79128; // weak
int dword_7912C; // weak
char byte_79130[]; // weak
char byte_79131; // weak
char byte_79132; // weak
pthread_mutex_t stru_79134; // idb
_UNKNOWN unk_79150; // weak
unsigned __int8 byte_79170[4]; // weak
_BYTE byte_79174[2564]; // weak
pthread_mutex_t stru_79B78; // idb
_BYTE byte_79B94[16]; // weak
_BYTE byte_79BA4[64]; // weak
_BYTE byte_79BE4[16]; // weak
_BYTE byte_79BF4[4]; // weak
char byte_79BF8; // weak
int dword_79BFC; // weak
_UNKNOWN unk_7A120; // weak
char byte_7ACB8; // weak
double dbl_7ACC0; // weak
_UNKNOWN unk_7ACC8; // weak
int (__fastcall *off_7ACD4)(_DWORD); // weak
char byte_7AD48; // weak
pthread_mutex_t stru_7AD4C; // idb
_UNKNOWN unk_7AD68; // weak
int (__fastcall *off_7AD74)(_DWORD); // weak
_UNKNOWN unk_7ADE8; // weak
int (__fastcall *off_7ADF4)(_DWORD); // weak
int dword_7AE68; // weak
_UNKNOWN unk_7AE70; // weak
int (__fastcall *off_7AE7C)(_DWORD); // weak
_UNKNOWN unk_7AEF0; // weak
_UNKNOWN *off_7AEFC; // weak
_UNKNOWN unk_7AF70; // weak
int (__fastcall *off_7AF7C)(_DWORD); // weak
_UNKNOWN unk_7AFF0; // weak
int (__fastcall *off_7AFFC)(_DWORD); // weak
int dword_7B070; // weak
_UNKNOWN unk_7B078; // weak
_UNKNOWN *off_7B084; // weak
int dword_7B0F8; // weak
int dword_7B0FC; // weak
int dword_7B100; // weak
struct sigaction oact; // idb
char byte_7B194; // weak
int dword_7B198; // weak
pthread_cond_t stru_7B1A0; // idb
_UNKNOWN unk_7B1D0; // weak
int (__fastcall *off_7B1DC)(_DWORD); // weak
char byte_7B250; // weak
_UNKNOWN unk_7B258; // weak
int (__fastcall *off_7B264)(_DWORD); // weak
pthread_rwlock_t stru_7B2D8; // weak
double dbl_7B2F8; // weak
_UNKNOWN unk_7B300; // weak
int (__fastcall *off_7B30C)(_DWORD); // weak
char byte_7B380; // weak
pthread_mutex_t stru_7B384; // idb
_UNKNOWN unk_7B3A0; // weak
int (__fastcall *off_7B3AC)(_DWORD); // weak
__int64 qword_7B420; // weak
double dbl_7B428; // weak
int dword_7B430; // weak
int dword_7B438; // weak
int dword_7B43C; // weak
int dword_7B440; // weak
int dword_7B444; // weak
_UNKNOWN unk_7B448; // weak
int (__fastcall *off_7B454)(_DWORD); // weak
char byte_7B4C8; // weak
int dword_7B4CC[3]; // weak
_UNKNOWN unk_7B4D8; // weak
int (__fastcall *off_7B4E4)(_DWORD); // weak
int dword_7B558; // weak
_UNKNOWN unk_7B560; // weak
int (__fastcall *off_7B56C)(_DWORD); // weak
int dword_7B5E0; // weak
int dword_7B5E4; // weak
double dbl_7B5E8; // weak
char byte_7B5F0; // weak
int dword_7B5F8; // weak
int dword_7B5FC; // weak
int dword_7B620; // weak
char byte_7B624; // weak
char byte_7B625; // weak
int dword_7B628; // weak
pthread_mutex_t stru_7B62C; // idb
char byte_7B644; // weak
int dword_7B648; // weak
pthread_rwlock_t rwlock; // idb
double dbl_7B670; // weak
_UNKNOWN unk_7B678; // weak
int (__fastcall *off_7B684)(_DWORD); // weak
__int64 qword_7B6F8; // weak
pthread_rwlock_t stru_7B700; // idb
int dword_7B720; // weak
_UNKNOWN unk_7B728; // weak
pthread_mutex_t mutex; // idb
int dword_7B7C0; // weak
char byte_7B7C4; // weak
int dword_7B7C8; // weak
char byte_7B7D0; // weak
char byte_7B7D1; // weak
_UNKNOWN unk_7B7D8; // weak
int (__fastcall *off_7B7E4)(_DWORD); // weak
char byte_7B858; // weak
char byte_7B859; // weak
char byte_7B85A; // weak
pthread_mutex_t stru_7B85C; // weak
char byte_7B874; // weak
int dword_7B87C; // weak
int dword_7B880; // weak
int dword_7B8A4; // weak
int dword_7B8A8; // weak
char byte_7B8AC; // weak
int dword_7B8B0; // weak
int dword_7B8B4; // weak
int dword_7B8B8; // weak
_UNKNOWN unk_7B8C0; // weak
int (__fastcall *off_7B8CC)(_DWORD); // weak
char byte_7B940; // weak
int dword_7B944; // weak
int dword_7B948; // weak
struct sigaction stru_7B94C; // idb
pthread_mutex_t stru_7B9D8; // idb
pthread_rwlock_t stru_7B9F0; // idb
pthread_mutex_t stru_7BA10; // idb
pthread_rwlock_t stru_7BA28; // idb
_UNKNOWN unk_7BA48; // weak
int (__fastcall *off_7BA54)(_DWORD); // weak
char byte_7BAC8; // weak
int dword_7BAD0; // weak
pthread_cond_t cond; // idb
double dbl_7BB10; // weak
char byte_7BB18; // weak
int dword_7BB1C; // weak
int dword_7BB20; // weak
int dword_7BB24; // weak
char dest[68]; // idb
int dword_7BB6C; // weak
_UNKNOWN unk_7BB70; // weak
_UNKNOWN *off_7BB7C; // weak
_UNKNOWN unk_7BBF0; // weak
int (__fastcall *off_7BBFC)(_DWORD); // weak
int dword_7BC74; // weak
char byte_7BC78; // weak
char byte_7BC79; // weak
int dword_7BC80; // weak
double dbl_7BC88; // weak
int dword_7BC90; // weak
double dbl_7BC98; // weak
_UNKNOWN unk_7BCA0; // weak
int (__fastcall *off_7BCAC)(_DWORD); // weak
char byte_7BD20; // weak
_UNKNOWN unk_7BD24; // weak
int dword_7BD90; // weak
int dword_7BD94; // weak
int dword_7BD98; // weak
int dword_7BD9C; // weak
int dword_7C05C; // weak
int dword_7C060; // weak
_DWORD dword_7C064[5]; // weak
pthread_cond_t stru_7C078; // idb
char byte_7C0A8[64]; // weak
int dword_7C0E8; // weak
int dword_7C12C; // weak
int dword_7C130[]; // weak
_UNKNOWN unk_7C134; // weak
_UNKNOWN unk_7C164; // weak
int dword_7C284; // weak
int dword_7C28C; // weak
int dword_7C290; // weak
int dword_7C294; // weak
_UNKNOWN unk_7F76D; // weak
int dword_9D4AC; // weak
int dword_9D4B0; // weak
_UNKNOWN unk_9D4B4; // weak
_UNKNOWN unk_9D4BB; // weak
char byte_9D4BC; // weak
int dword_9D4C4; // weak
int dword_9D4C8; // weak
_UNKNOWN unk_9D534; // weak
_UNKNOWN unk_9D5A7; // weak
_UNKNOWN unk_9D5B7; // weak
_UNKNOWN unk_9D5E7; // weak
_UNKNOWN unk_9D617; // weak
char byte_9D6CA; // weak
char byte_9D6CB; // weak
char byte_9D6CC; // weak
int dword_9D6CE; // weak
int dword_9D6D2; // weak
int dword_9D6D6; // weak
int dword_9D6DA; // weak
char byte_9D6F2; // weak
char byte_9D6F3; // weak
char byte_9D6F4; // weak
char byte_9D6F5; // weak
char byte_9D6F7; // weak
int dword_9D6F8; // weak
int dword_9D76C; // weak
int dword_9D770; // weak
int dword_9D774; // weak
int dword_9D778; // weak
int dword_9D77C; // weak
int dword_9D780; // weak
_UNKNOWN unk_9D784; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0000AA1C) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return sub_F644();
}

//----- (0000AA28) --------------------------------------------------------
void sub_AA28()
{
  JUMPOUT(0);
}
// AA34: control flows out of bounds to 0

//----- (0000B340) --------------------------------------------------------
int __fastcall sub_B340(int a1)
{
  char v3[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(v3, 0x1000u, "WTF No pool %d found!", a1);
    sub_38730(3, v3, 0);
  }
  return *(_DWORD *)(dword_7B438 + 4 * a1);
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7B438: using guessed type int dword_7B438;

//----- (0000B3C8) --------------------------------------------------------
void __noreturn sub_B3C8()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(v0, "Failed to create restart thread");
  sub_38730(3, v0, 1);
  sub_16CA8(1);
}

//----- (0000B404) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B404(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// B40C: positive sp value 1004 has been found
// B40C: unbalanced stack, ignored a potential tail call

//----- (0000B414) --------------------------------------------------------
void __fastcall __noreturn sub_B414(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B46C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B46C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B474: positive sp value 1014 has been found
// B474: unbalanced stack, ignored a potential tail call

//----- (0000B480) --------------------------------------------------------
void __fastcall __noreturn sub_B480(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B4D8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B4D8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B4E0: positive sp value 1014 has been found
// B4E0: unbalanced stack, ignored a potential tail call

//----- (0000B4EC) --------------------------------------------------------
void __fastcall __noreturn sub_B4EC(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B544) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B544(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B54C: positive sp value 1014 has been found
// B54C: unbalanced stack, ignored a potential tail call

//----- (0000B558) --------------------------------------------------------
void __fastcall __noreturn sub_B558(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B5B0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B5B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B5B8: positive sp value 1014 has been found
// B5B8: unbalanced stack, ignored a potential tail call

//----- (0000B5C4) --------------------------------------------------------
void __fastcall __noreturn sub_B5C4(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}
// 16CA8: using guessed type void __fastcall __noreturn sub_16CA8(_DWORD);

//----- (0000B61C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B61C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B624: positive sp value 1014 has been found
// B624: unbalanced stack, ignored a potential tail call

//----- (0000B630) --------------------------------------------------------
void __fastcall __noreturn sub_B630(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}
// 16CA8: using guessed type void __fastcall __noreturn sub_16CA8(_DWORD);

//----- (0000B688) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B688(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B690: positive sp value 1014 has been found
// B690: unbalanced stack, ignored a potential tail call

//----- (0000B69C) --------------------------------------------------------
void __fastcall __noreturn sub_B69C(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}
// 16CA8: using guessed type void __fastcall __noreturn sub_16CA8(_DWORD);

//----- (0000B6F4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B6F4(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B6FC: positive sp value 1014 has been found
// B6FC: unbalanced stack, ignored a potential tail call

//----- (0000B708) --------------------------------------------------------
void __fastcall __noreturn sub_B708(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B760) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B760(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B768: positive sp value 1014 has been found
// B768: unbalanced stack, ignored a potential tail call

//----- (0000B774) --------------------------------------------------------
void __fastcall __noreturn sub_B774(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B7CC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B7CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B7D4: positive sp value 1014 has been found
// B7D4: unbalanced stack, ignored a potential tail call

//----- (0000B7E0) --------------------------------------------------------
void __fastcall __noreturn sub_B7E0(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B838) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B838(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B840: positive sp value 1014 has been found
// B840: unbalanced stack, ignored a potential tail call

//----- (0000B84C) --------------------------------------------------------
void __fastcall __noreturn sub_B84C(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B8A4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B8A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B8AC: positive sp value 1014 has been found
// B8AC: unbalanced stack, ignored a potential tail call

//----- (0000B8B8) --------------------------------------------------------
void __fastcall __noreturn sub_B8B8(int a1)
{
  int *v2; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  v2 = _errno_location();
  snprintf(
    s,
    0x1000u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v2,
    "driver-btm-zcash.c",
    "bitmain_ZCASH_prepare",
    a1);
  sub_38730(3, s, 1);
  sub_16CA8(1);
}

//----- (0000B928) --------------------------------------------------------
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int v3; // r0
  int (*v4)(void); // r3
  int (**v5)(); // r12
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r5
  int v11; // r4
  int v12; // r7
  const char **v13; // r8
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  int *v48; // r12
  unsigned int v49; // r3
  int v50; // r2
  unsigned int v51; // r0
  unsigned int v52; // r3
  unsigned int v53; // r2
  unsigned int v54; // r3
  _DWORD *v55; // r2
  int v56; // r3
  int v57; // r2
  _DWORD *v58; // r2
  int v59; // r1
  int v60; // r5
  size_t v61; // r6
  _DWORD *v62; // r0
  _DWORD *v63; // r7
  _DWORD *v64; // r0
  unsigned int v65; // r3
  _DWORD *v66; // r1
  _DWORD *v67; // r5
  unsigned int n; // r6
  _DWORD *v69; // r9
  int v70; // r6
  char *v71; // r8
  unsigned int v72; // r3
  int v73; // r3
  _DWORD *v74; // r3
  unsigned int v75; // r1
  unsigned int v76; // r2
  bool v77; // cc
  int v78; // r2
  int v79; // r3
  int v80; // r5
  _DWORD *v81; // r0
  char *v82; // r3
  const char *v83; // r2
  _DWORD *v84; // r12
  int v85; // r0
  int v86; // r1
  int v87; // r2
  int v88; // r12
  char *v89; // r3
  int v90; // r2
  int v91; // r5
  char *v92; // r4
  int v93; // r6
  int v94; // r7
  FILE *v95; // r5
  signed int v96; // r0
  char *v97; // r0
  const char *v98; // r1
  char *v99; // r5
  char *v100; // r0
  char *v101; // r3
  char *v102; // r3
  char *v103; // r3
  size_t v104; // r0
  _BYTE *v105; // r1
  _BYTE *v106; // lr
  char *v107; // r3
  int v108; // r2
  bool v109; // zf
  int v110; // r0
  bool v111; // zf
  int *__attribute__((__org_arrdim(0,2))) v112; // r12
  FILE *v113; // r0
  int v114; // r3
  int v115; // r3
  bool v116; // zf
  int *v117; // r6
  char *v118; // r9
  int v119; // r10
  FILE *v120; // r0
  int v121; // r3
  char *v122; // r6
  int v123; // r10
  char *v124; // r9
  char *v125; // r4
  FILE *v126; // r0
  int v127; // r3
  int *__attribute__((__org_arrdim(0,2))) v128; // r12
  int v129; // r5
  int v130; // r6
  pthread_rwlock_t *v131; // r0
  char *v132; // r7
  int v133; // r5
  char *v134; // r8
  unsigned int v135; // r6
  int v136; // r3
  int v137; // r3
  int *__attribute__((__org_arrdim(0,2))) v138; // r12
  int *__attribute__((__org_arrdim(0,2))) v139; // r12
  int *v140; // r3
  int v141; // r0
  int v142; // t1
  int *__attribute__((__org_arrdim(0,2))) v143; // r12
  int *__attribute__((__org_arrdim(0,2))) v144; // r12
  int v145; // r6
  char *v146; // r7
  int v147; // r9
  int v148; // r3
  const char *v149; // r10
  size_t v150; // r0
  size_t v151; // r4
  char *v152; // r0
  int *__attribute__((__org_arrdim(0,2))) v153; // r12
  int v154; // r2
  int v155; // r7
  __sighandler_t v156; // r8
  __sighandler_t v157; // r0
  bool v158; // zf
  __pid_t v159; // r0
  __pid_t v160; // r8
  int *__attribute__((__org_arrdim(0,2))) v161; // r12
  _DWORD *v162; // r0
  _DWORD *v163; // r7
  void *v164; // r0
  void *v165; // r6
  int v166; // r6
  int v167; // r9
  int v168; // r8
  int v169; // r7
  _DWORD *v170; // r4
  int v171; // r6
  _DWORD *v172; // r0
  int v173; // r3
  sem_t *v174; // r0
  sem_t *v175; // r6
  char *v176; // r4
  int v177; // r3
  int *v178; // r1
  int v179; // r12
  int v180; // r0
  int j; // r1
  int v182; // lr
  int v183; // r6
  int v184; // r9
  const char *v185; // r1
  int v186; // r2
  int v187; // r3
  int v188; // r1
  int *__attribute__((__org_arrdim(0,2))) v189; // r12
  FILE *v190; // r0
  int v191; // r3
  int v192; // r6
  int v193; // r12
  int v194; // r2
  int v195; // lr
  int v196; // r3
  int v197; // r12
  int v198; // r1
  int v199; // r2
  int *__attribute__((__org_arrdim(0,2))) v200; // r12
  int *__attribute__((__org_arrdim(0,2))) v201; // r12
  int *__attribute__((__org_arrdim(0,2))) v202; // r12
  int v203; // r7
  int v204; // r6
  int v205; // r3
  int v206; // r3
  char *v207; // r0
  int v208; // r0
  int v209; // r8
  int v210; // r0
  int v211; // r2
  int *v212; // lr
  int v213; // r0
  int v214; // r3
  int v215; // t1
  int v216; // r9
  int v217; // t1
  int v218; // r3
  int v219; // r9
  int v220; // r3
  int v221; // r3
  int v222; // r0
  int v223; // r1
  int v224; // r12
  int v225; // r0
  struct timeval *v226; // r6
  char *v227; // r9
  _DWORD *v228; // r3
  int *__attribute__((__org_arrdim(0,2))) v229; // r12
  int *__attribute__((__org_arrdim(0,2))) v230; // r12
  int *__attribute__((__org_arrdim(0,2))) v231; // r12
  int *v232; // r3
  int v233; // r1
  int v234; // t1
  int v235; // r9
  int v236; // r2
  int *v237; // lr
  int v238; // r0
  int v239; // r3
  int v240; // t1
  int v241; // r6
  int v242; // t1
  int v243; // r3
  int v244; // r6
  int v245; // r3
  int v246; // r3
  int v247; // r0
  int v248; // r1
  int v249; // r12
  int v250; // r0
  int v251; // r6
  _DWORD *v252; // r8
  char *v253; // r9
  char *v254; // lr
  int v255; // r1
  int v256; // r2
  int v257; // r3
  int v258; // r1
  int v259; // r2
  int v260; // r3
  int v261; // r3
  int *__attribute__((__org_arrdim(0,2))) v262; // r12
  char *v263; // r0
  int *__attribute__((__org_arrdim(0,2))) v264; // r12
  int *__attribute__((__org_arrdim(0,2))) v265; // r12
  int *__attribute__((__org_arrdim(0,2))) v266; // r12
  int *__attribute__((__org_arrdim(0,2))) v267; // r12
  int k; // r6
  int v269; // r3
  int v270; // r8
  char *v271; // r10
  char *v272; // r9
  int m; // r8
  int *__attribute__((__org_arrdim(0,2))) v274; // r12
  const char *v275; // r1
  int v276; // r2
  int *__attribute__((__org_arrdim(0,2))) v277; // r12
  int *__attribute__((__org_arrdim(0,2))) v278; // r12
  char v279; // [sp+10h] [bp-31FCh] BYREF
  char v280[500]; // [sp+1018h] [bp-21F4h] BYREF
  _BYTE v281[3588]; // [sp+120Ch] [bp-2000h] BYREF
  char *v282; // [sp+2024h] [bp-11E8h]
  int *v283; // [sp+2028h] [bp-11E4h]
  void (**v284)(void); // [sp+202Ch] [bp-11E0h]
  char *v285; // [sp+2030h] [bp-11DCh]
  int *v286; // [sp+2034h] [bp-11D8h]
  char *v287; // [sp+2038h] [bp-11D4h]
  const char **v288; // [sp+203Ch] [bp-11D0h]
  char *v289; // [sp+2040h] [bp-11CCh]
  char *v290; // [sp+2044h] [bp-11C8h]
  int *v291; // [sp+2048h] [bp-11C4h]
  int v292; // [sp+204Ch] [bp-11C0h] BYREF
  struct sigaction v293; // [sp+2054h] [bp-11B8h] BYREF
  char v294[256]; // [sp+20E0h] [bp-112Ch] BYREF
  int v295[11]; // [sp+21E0h] [bp-102Ch] BYREF

  v288 = a2;
  v292 = a1;
  strcpy(dword_78CE8, "cgminer.log");
  byte_78CE0 = 0;
  strcpy(word_78DE8, "a+");
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v4 = sched_yield;
    v5 = &off_75ED8;
  }
  v7 = 4 * (v292 + 1);
  if ( v6 )
    *v5 = v4;
  v8 = malloc(v7);
  v9 = v292;
  v10 = v8;
  dword_77290 = (int)v8;
  if ( v292 > 0 )
  {
    v11 = 0;
    v12 = 0;
    v13 = v288;
    do
    {
      ++v12;
      v14 = _strdup(v13[v11]);
      v9 = v292;
      v10[v11++] = v14;
    }
    while ( v9 > v12 );
  }
  v10[v9] = 0;
  sub_17990(&stru_7B384, "main", 10693);
  sub_17990(&stru_7B85C, "main", 10694);
  sub_17990(&mutex, "main", 10695);
  sub_179E8((int)&stru_7BA10, "main", 10696);
  sub_17990(&stru_7AD4C, "main", 10697);
  sub_17990(&stru_770B8, "main", 10698);
  sub_179E8((int)&stru_7B9D8, "main", 10699);
  sub_17990(&stru_77030, "main", 10700);
  sub_179BC(&stru_77294, "main", 10701);
  sub_179BC(&stru_7B2D8, "main", 10702);
  sub_179BC(&rwlock, "main", 10703);
  sub_179BC(&stru_7B700, "main", 10704);
  sub_17990(&stru_77060, "main", 10706);
  if ( pthread_cond_init(&stru_77078, 0) )
  {
    strcpy((char *)v295, "Failed to pthread_cond_init lp_cond");
    sub_38730(3, (const char *)v295, 1);
    sub_1D8FC(1, 0);
  }
  sub_17990(&stru_7B62C, "main", 10710);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v295, "Failed to pthread_cond_init restart_cond");
    sub_38730(3, (const char *)v295, 1);
    sub_1D8FC(1, 0);
  }
  if ( pthread_cond_init(&stru_7B1A0, 0) )
  {
    strcpy((char *)v295, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2A168();
    dword_7B620 = (int)v15;
    if ( v15 )
    {
      dword_7704C = (int)(v15 + 12);
      snprintf(byte_76BF4, 0x100u, "%s %s", "cgminer", a49);
      v293.sa_flags = 0;
      v293.sa_handler = (__sighandler_t)sub_1795C;
      sigemptyset(&v293.sa_mask);
      sigaction(15, &v293, &oact);
      sigaction(2, &v293, &stru_7B94C);
      signal(13, (__sighandler_t)1);
      dword_7BC74 = (int)v280;
      strcpy(v280, "/usr/bin");
      dword_7B8B4 = (int)&v279;
      v16 = _strdup(*v288);
      v17 = (char *)dword_7B8B4;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_7B8B4 + strlen((const char *)dword_7B8B4)) = 47;
      dword_77028 = 8;
      dword_7701C = 9;
      dword_77024 = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        v289 = (char *)v295;
        strcpy((char *)v295, "main OOM");
        sub_38730(3, (const char *)v295, 1);
        sub_16CA8(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_772B4;
      v6 = dword_772B4 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_772B4 = (int)v20;
        v162 = malloc(0x2Cu);
        v163 = v162;
        *((_DWORD *)v20 + 17) = v162;
        if ( !v162 )
          goto LABEL_258;
        memset(v162, 0, 0x2Cu);
        v291 = (int *)(v20 + 68);
        v163[4] = v20 + 68;
        v163[1] = 32;
        v163[2] = 5;
        v163[5] = 68;
        v164 = malloc(0x180u);
        *v163 = v164;
        if ( !v164 )
          goto LABEL_258;
        memset(v164, 0, 0x180u);
        v24 = (int)v20;
        v163[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v291 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_22;
        case 0xAu:
          goto LABEL_21;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_21:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_22:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_23:
          v27 += v22[7] << 24;
LABEL_24:
          v27 += v22[6] << 16;
LABEL_25:
          v27 += v22[5] << 8;
LABEL_26:
          v27 += v22[4];
LABEL_27:
          v28 += v22[3] << 24;
LABEL_28:
          v28 += v22[2] << 16;
LABEL_29:
          v28 += v22[1] << 8;
LABEL_30:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = v291;
      v49 = (v45 - v46 - v47) ^ (v47 >> 13);
      v50 = (v46 - v47 - v49) ^ (v49 >> 12);
      v51 = (v47 - v49 - v50) ^ (v50 << 16);
      v52 = (v49 - v50 - v51) ^ (v51 >> 5);
      v53 = v50 - v51 - v52;
      v54 = (v52 - (v53 ^ (v52 >> 3)) - ((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)))
          ^ (((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v54;
      v55 = *(_DWORD **)(v24 + 68);
      v56 = 12 * (v54 & (v55[1] - 1));
      ++*(_DWORD *)(*v55 + v56 + 4);
      v57 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v57;
      v58 = *(_DWORD **)(v24 + 68);
      v59 = *(_DWORD *)(*v58 + v56);
      if ( v59 )
      {
        *(_DWORD *)(v59 + 12) = v291;
        v58 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v58 + v56) = v48;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 8)
                                                                          + 1))
        || (v60 = *((_DWORD *)v20 + 17), *(_DWORD *)(v60 + 36) == 1) )
      {
LABEL_56:
        strcpy(dest, v20);
        dword_7B440 = (int)&dword_7B440;
        dword_7B444 = (int)&dword_7B440;
        sub_5BBB8((int)&off_75600, (int)"Options for both config file and command line");
        sub_5BBB8((int)&off_75E24, (int)"Options for command line only");
        sub_5BC84(&v292, v288, (void (*)(const char *, ...))sub_11C44);
        if ( v292 != 1 )
        {
          strcpy((char *)v295, "Unexpected extra commandline arguments");
          sub_38730(3, (const char *)v295, 1);
          sub_1D8FC(1, 0);
        }
        v80 = (unsigned __int8)byte_76F20;
        if ( !byte_76F20 )
        {
          dword_76F24 = (int)malloc(0x1000u);
          sub_16150((char *)dword_76F24);
          if ( access((const char *)dword_76F24, 4) )
          {
            free((void *)dword_76F24);
            dword_76F24 = v80;
          }
          else
          {
            sub_16D98((char *)dword_76F24);
          }
        }
        if ( byte_7730D || dword_76FFC )
        {
          if ( byte_7B859 )
          {
            v289 = (char *)v295;
            strcpy((char *)v295, "Cannot use benchmark mode with scrypt");
            sub_38730(3, (const char *)v295, 1);
            sub_16CA8(1);
          }
          v289 = (char *)v295;
          v282 = sub_17A3C();
          v81 = malloc(0xFFu);
          v82 = v282;
          if ( dword_76FFC )
            v83 = "Benchfile";
          else
            v83 = "Benchmark";
          *((_DWORD *)v282 + 49) = v81;
          v84 = v81;
          v85 = *(_DWORD *)v83;
          v86 = *((_DWORD *)v83 + 1);
          v87 = *((_DWORD *)v83 + 2);
          *v84 = v85;
          v84[1] = v86;
          *((_WORD *)v84 + 4) = v87;
          v88 = *((_DWORD *)v82 + 49);
          *((_DWORD *)v82 + 51) = v88;
          *((_DWORD *)v82 + 52) = v88;
          *((_DWORD *)v82 + 50) = v88;
          *((_DWORD *)v82 + 156) = v88;
          v282 = v82;
          strncpy(v82 + 48, "?", 7u);
          v89 = v282;
          v90 = *((_DWORD *)v282 + 33);
          v282[55] = 0;
          if ( v90 != 1 )
          {
            *((_DWORD *)v89 + 33) = 1;
            ++dword_7B5E4;
          }
          v91 = 0;
          v92 = (char *)byte_78BD0;
          v89[129] = 0;
          byte_78CA9 = 1;
          do
          {
            v93 = 324 * v91;
            v94 = 5 * v91++;
            v94 *= 32;
            sub_29830(&byte_7731C[v94], (unsigned __int8 *)&a000000029c6bf4[v93], 160);
            sub_29830(&byte_77D1C[v94], (unsigned __int8 *)&a00000002c01f50[v93], 160);
          }
          while ( v91 != 16 );
          sub_16244((int)dword_78730);
        }
        else
        {
          v92 = (char *)byte_78BD0;
          v289 = (char *)v295;
        }
        if ( !dword_76BF0 )
        {
          v287 = &byte_7AD48;
          goto LABEL_108;
        }
        v95 = fopen((const char *)dword_76BF0, "rb");
        memset(v294, 0, sizeof(v294));
        if ( v95 )
        {
          v96 = fread(v294, 1u, 0x100u, v95);
          if ( v96 > 0 )
          {
            v97 = strchr(v294, 10);
            v98 = v294;
            v99 = v97;
            v6 = v97 == 0;
            v100 = s;
            if ( !v6 )
            {
              memcpy(s, v294, v99 - v294);
              v100 = byte_78850;
              v98 = v99 + 1;
            }
            strcpy(v100, v98);
            v101 = (char *)&byte_78BD0[strlen(s) - 1];
            if ( *(v101 - 1152) == 10 )
              *(v101 - 1152) = 0;
            v102 = (char *)&byte_78BD0[strlen(s) - 1];
            if ( *(v102 - 1152) == 13 )
              *(v102 - 1152) = 0;
            v103 = (char *)&byte_78BD0[strlen(byte_78850) - 1];
            if ( *(v103 - 896) == 10 )
              *(v103 - 896) = 0;
            v104 = strlen(byte_78850) - 1;
            v107 = (char *)&byte_78BD0[v104];
            v108 = byte_78BD0[v104 - 896];
            v109 = v108 == 13;
            if ( v108 == 13 )
            {
              v105 = v281;
              v108 = 44360;
            }
            else
            {
              v106 = v281;
            }
            if ( v109 )
              HIWORD(v108) = 7;
            else
              v104 = 44360;
            if ( v109 )
            {
              *((_DWORD *)v105 + 907) = v108;
              LOBYTE(v108) = 0;
            }
            else
            {
              HIWORD(v104) = 7;
            }
            if ( v109 )
              *(v107 - 896) = v108;
            else
              *((_DWORD *)v106 + 907) = v104;
            goto LABEL_103;
          }
          v287 = &byte_7AD48;
          if ( byte_7AD48 || (v285 = &byte_78E08, byte_78E08) || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Read miner version file %s error %d", (const char *)dword_76BF0, v96);
            goto LABEL_250;
          }
        }
        else
        {
          v287 = &byte_7AD48;
          if ( byte_7AD48 || (v285 = &byte_78E08, byte_78E08) || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Open miner version file %s error", (const char *)dword_76BF0);
LABEL_250:
            sub_38730(3, v289, 0);
LABEL_103:
            if ( *v287 )
            {
LABEL_107:
              snprintf(v289, 0x1000u, "Miner compile time: %s type: %s", s, byte_78850);
              sub_38730(3, v289, 0);
              goto LABEL_108;
            }
            v285 = &byte_78E08;
          }
        }
        if ( *v285 || dword_766C4 > 2 )
          goto LABEL_107;
LABEL_108:
        if ( dword_76BE0 )
        {
          byte_78CE0 = 1;
          strcpy(dword_78CE8, (const char *)dword_76BE0);
          if ( dword_76BEC )
            strcpy(word_78DE8, (const char *)dword_76BEC);
          if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 2) )
          {
            snprintf(v289, 0x1000u, "Log file path: %s Open flag: %s", dword_78CE8, word_78DE8);
            sub_38730(3, v289, 0);
          }
        }
        if ( dword_76BE8 )
        {
          memset(v294, 0, sizeof(v294));
          if ( dword_76BE4 )
          {
            if ( !*(_BYTE *)dword_76BE4 )
            {
              v161 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Log work asic num empty";
              strcpy((char *)v161 + 4, "work asic num empty");
              sub_38730(3, v289, 1);
              sub_16CA8(1);
            }
            v110 = strtol((const char *)dword_76BE4, 0, 10);
            v111 = v110 == 32;
            if ( v110 != 32 )
              v111 = v110 == 1;
            dword_78950 = v110;
            if ( !v111 && v110 != 64 )
            {
              v112 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy((char *)v112 + 4, "work asic num must be 1, 32, 64");
              sub_38730(3, v289, 1);
              sub_16CA8(1);
            }
            if ( *v287 || byte_78E08 || dword_766C4 > 2 )
            {
              snprintf(
                v289,
                0x1000u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_76BE8,
                (const char *)dword_76BE4);
              sub_38730(3, v289, 0);
            }
          }
          else if ( *v287 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Log work path: %s", (const char *)dword_76BE8);
            sub_38730(3, v289, 0);
          }
          sprintf(v294, "%s.txt", (const char *)dword_76BE8);
          v113 = fopen(v294, "a+");
          v114 = (unsigned __int8)*v287;
          dword_78954 = (int)v113;
          if ( v114 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Log work open file %s", v294);
            sub_38730(3, v289, 0);
          }
          v115 = dword_78950;
          if ( dword_78950 == 1 )
          {
            sprintf(v294, "%s%02d.txt", (const char *)dword_76BE8, 1);
            v190 = fopen(v294, "a+");
            v191 = (unsigned __int8)*v287;
            dword_78958 = (int)v190;
            if ( v191 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 2) )
            {
              snprintf(v289, 0x1000u, "Log work open asic %d file %s", dword_78950, v294);
              sub_38730(3, v289, 0);
            }
          }
          else
          {
            v116 = dword_78950 == 32;
            if ( dword_78950 != 32 )
              v116 = dword_78950 == 64;
            if ( v116 && dword_78950 >= 0 )
            {
              v117 = &dword_78954;
              v118 = v289;
              v119 = 0;
              do
              {
                sprintf(v294, "%s%02d_%02d.txt", (const char *)dword_76BE8, v115, v119);
                v120 = fopen(v294, "a+");
                v121 = (unsigned __int8)*v287;
                v117[1] = (int)v120;
                ++v117;
                if ( v121 || byte_78E08 || dword_766C4 > 2 )
                {
                  snprintf(v118, 0x1000u, "Log work open asic %d file %s", dword_78950, v294);
                  sub_38730(3, v118, 0);
                }
                v115 = dword_78950;
                ++v119;
              }
              while ( dword_78950 >= v119 );
            }
          }
          if ( byte_78A5C )
          {
            v122 = &byte_78A5C;
            v123 = 0;
            v291 = (int *)byte_78BD0;
            v124 = v289;
            v125 = v287;
            do
            {
              sprintf(v294, "%s_diff_%02d.txt", (const char *)dword_76BE8, v123);
              v126 = fopen(v294, "a+");
              v127 = (unsigned __int8)*v125;
              *((_DWORD *)v122 + 1) = v126;
              v122 += 4;
              if ( v127 || byte_78E08 || dword_766C4 > 2 )
              {
                snprintf(v124, 0x1000u, "Log work open diff file %s", v294);
                sub_38730(3, v124, 0);
              }
              ++v123;
            }
            while ( v123 != 65 );
            v92 = (char *)v291;
          }
        }
        if ( byte_7BB18 )
        {
          v286 = dword_755F0;
          byte_75DD0 = 0;
        }
        else
        {
          v286 = dword_755F0;
          if ( byte_75DD0 )
            sub_27BA0();
        }
        if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
        {
          snprintf(v289, 0x1000u, "Started %s", byte_76BF4);
          sub_38730(4, v289, 0);
        }
        if ( !dword_76F24 )
        {
LABEL_172:
          *(_WORD *)(dword_7BC74 + strlen((const char *)dword_7BC74)) = 47;
          if ( byte_7B858 )
            byte_78E08 = 1;
          if ( v286[512] < 0 )
          {
            if ( byte_7B859 )
              v137 = 30;
            else
              v137 = 60;
            v286[512] = v137;
          }
          *((_DWORD *)v92 - 27) = 8;
          dword_7B0FC = (int)calloc(8u, 0x40u);
          if ( !dword_7B0FC )
          {
            v200 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Failed to calloc control_thr";
            strcpy((char *)v200 + 4, "ed to calloc control_thr");
            sub_38730(3, v289, 1);
            sub_1D8FC(1, 0);
          }
          v129 = 0;
          dword_78B68 = 0;
          v282 = (char *)&unk_7B728;
          sub_27CD0((int)&unk_7B728);
          sub_27CD0((int)&unk_7ACC8);
          sub_27CD0((int)&unk_7B7D8);
          sub_27CD0((int)&unk_7B448);
          sub_27CD0((int)&unk_76AC8);
          sub_27CD0((int)&unk_7BCA0);
          sub_27CD0((int)&unk_7B4D8);
          sub_27CD0((int)&unk_7B678);
          sub_27CD0((int)&unk_7BA48);
          sub_27CD0((int)&unk_7AD68);
          sub_27CD0((int)&unk_7BB70);
          sub_27CD0((int)&unk_7AE70);
          sub_27CD0((int)&unk_7B300);
          sub_27CD0((int)&unk_7B258);
          sub_27CD0((int)&unk_7AF70);
          sub_27CD0((int)&unk_7B8C0);
          sub_27CD0((int)&unk_7B078);
          sub_27CD0((int)&unk_7AFF0);
          sub_27CD0((int)&unk_7B560);
          sub_27CD0((int)&unk_7B3A0);
          sub_27CD0((int)&unk_7B1D0);
          sub_27CD0((int)&unk_7BBF0);
          sub_27CD0((int)&unk_7AEF0);
          sub_27CD0((int)&unk_7ADE8);
          (*((void (__fastcall **)(_DWORD))v282 + 3))(0);
          off_7ACD4(0);
          off_7B7E4(0);
          off_7B454(0);
          off_76AD4();
          off_7BCAC(0);
          off_7B4E4(0);
          off_7B684(0);
          off_7BA54(0);
          off_7AD74(0);
          ((void (__fastcall *)(_DWORD))off_7BB7C)(0);
          off_7AE7C(0);
          off_7B30C(0);
          off_7B264(0);
          off_7AF7C(0);
          off_7B8CC(0);
          ((void (__fastcall *)(_DWORD))off_7B084)(0);
          off_7AFFC(0);
          off_7B56C(0);
          off_7B3AC(0);
          off_7B1DC(0);
          off_7BBFC(0);
          ((void (__fastcall *)(_DWORD))off_7AEFC)(0);
          off_7ADF4(0);
          v130 = dword_7B720;
          dword_7BB6C = 0;
          if ( dword_7B720 > 0 )
          {
            v291 = &dword_7B628;
            do
            {
              v131 = *(pthread_rwlock_t **)(dword_7B628 + 4 * v129++);
              sub_27F10(v131);
              v130 = dword_7B720;
            }
            while ( dword_7B720 > v129 );
          }
          if ( !v130 )
          {
            v189 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy((char *)v189 + 4, "devices disabled, cannot mine!");
            sub_38730(3, v289, 1);
            sub_1D8FC(1, 0);
          }
          dword_7702C = v130;
          if ( !dword_76F00 )
          {
            v291 = &dword_7B628;
            sub_1AB24(&stru_7B700, "load_temp_cutoffs", 1152);
            v196 = 0;
            v197 = *v291;
            v198 = dword_7B720;
            while ( v196 < v198 )
            {
              v199 = *(_DWORD *)(v197 + 4 * v196++);
              if ( !*(_DWORD *)(v199 + 184) )
                *(_DWORD *)(v199 + 184) = 95;
            }
            sub_19BBC(&stru_7B700, "load_temp_cutoffs", 1158);
            goto LABEL_203;
          }
          v132 = strtok((char *)dword_76F00, ",");
          if ( v132 )
          {
            v133 = 0;
            v291 = &dword_7B628;
            v134 = v289;
            do
            {
              if ( v133 >= dword_7B720 )
              {
                strcpy(v134, "Too many values passed to set temp cutoff");
                sub_38730(3, v134, 1);
                sub_16CA8(1);
              }
              v135 = strtol(v132, 0, 10);
              if ( v135 > 0xC8 )
              {
                strcpy(v134, "Invalid value passed to set temp cutoff");
                sub_38730(3, v134, 1);
                sub_16CA8(1);
              }
              sub_1AB24(&stru_7B700, "load_temp_cutoffs", 1145);
              v136 = *(_DWORD *)(dword_7B628 + 4 * v133++);
              *(_DWORD *)(v136 + 184) = v135;
              sub_19BBC(&stru_7B700, "load_temp_cutoffs", 1147);
              v132 = strtok(0, ",");
            }
            while ( v132 );
            if ( v133 != 1 )
              goto LABEL_203;
          }
          else
          {
            v133 = 0;
            v135 = 0;
            v291 = &dword_7B628;
          }
          sub_1AB24(&stru_7B700, "load_temp_cutoffs", 1164);
          v186 = dword_7B720;
          v187 = *v291;
          while ( v133 < v186 )
          {
            v188 = *(_DWORD *)(v187 + 4 * v133++);
            *(_DWORD *)(v188 + 184) = v135;
          }
          sub_19BBC(&stru_7B700, "load_temp_cutoffs", 1167);
LABEL_203:
          if ( dword_7B720 > 0 )
          {
            v140 = (int *)*v291;
            v141 = *v291 + 4 * dword_7B720;
            do
            {
              v142 = *v140++;
              *(_DWORD *)(v142 + 312) = 99999999;
            }
            while ( v140 != (int *)v141 );
          }
          if ( !byte_7B940 )
          {
            dword_7701C += dword_7702C;
            dword_77024 = dword_7701C + 1;
            sub_18068();
          }
          if ( !dword_7B198 )
          {
            if ( *v287 || byte_78E08 || dword_766C4 > 3 )
            {
              v143 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy((char *)v143 + 4, " to specify at least one pool server.");
              sub_38730(4, v289, 0);
            }
            if ( !*((_BYTE *)v286 + 2016) || !sub_26D10(0) )
            {
              v144 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Pool setup failed";
              strcpy((char *)v144 + 4, " setup failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
          }
          if ( dword_7B198 > 0 )
          {
            v145 = 0;
            v146 = v92;
            do
            {
              v147 = *(_DWORD *)(dword_7B438 + 4 * v145);
              v148 = *(_DWORD *)(v147 + 200);
              *(_DWORD *)(v147 + 428) = 99999999;
              *(_DWORD *)(v147 + 464) = 99999999;
              if ( !v148 )
              {
                if ( !*(_DWORD *)(v147 + 208) )
                  *(_DWORD *)(v147 + 208) = calloc(1u, 1u);
                v149 = *(const char **)(v147 + 204);
                if ( !v149 )
                {
                  snprintf(
                    v289,
                    0x1000u,
                    "No login credentials supplied for pool %u %s",
                    v145,
                    *(const char **)(v147 + 196));
                  sub_38730(3, v289, 1);
                  sub_1D8FC(1, 0);
                }
                v150 = strlen(*(const char **)(v147 + 204));
                v282 = *(char **)(v147 + 208);
                v151 = v150 + strlen(v282) + 2;
                v152 = (char *)malloc(v151);
                *(_DWORD *)(v147 + 200) = v152;
                if ( !v152 )
                {
                  v278 = (int *)v289;
                  *(_DWORD *)v289 = *(_DWORD *)"Failed to malloc userpass";
                  strcpy((char *)v278 + 4, "ed to malloc userpass");
                  sub_38730(3, v289, 1);
                  sub_1D8FC(1, 0);
                }
                snprintf(v152, v151, "%s:%s", v149, v282);
              }
              ++v145;
            }
            while ( dword_7B198 > v145 );
            v92 = v146;
          }
          v154 = (unsigned __int8)*v287;
          dword_7705C = *(_DWORD *)dword_7B438;
          if ( v154 )
            openlog("cgminer", 1, 8);
          v155 = (int)byte_78BD0;
          if ( *((_DWORD *)v92 - 25) )
          {
            if ( pipe((int *)v289) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v295[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(*((_DWORD *)v289 + 1)) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v156 = signal(13, (__sighandler_t)1);
            v157 = signal(13, (__sighandler_t)1);
            v158 = (__sighandler_t)((char *)v157 + 1) == 0;
            if ( v157 != (__sighandler_t)-1 )
              v158 = (__sighandler_t)((char *)v156 + 1) == 0;
            if ( v158 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v159 = fork();
            v160 = v159;
            dword_7728C = v159;
            if ( v159 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v159 )
            {
              if ( dup2(v295[0], 0) >= 0 )
              {
                close(v295[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_78B6C, v160);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v295[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          v165 = calloc(dword_7BB6C, 4u);
          if ( v165 )
            v155 = 0;
          dword_7B5E0 = (int)v165;
          if ( !v165 )
          {
            v274 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy((char *)v274 + 4, "ed to calloc mining_thr");
            v275 = v289;
            goto LABEL_490;
          }
          while ( v155 < dword_7BB6C )
          {
            v166 = dword_7B5E0;
            *(_DWORD *)(v166 + 4 * v155) = calloc(1u, 0x40u);
            v165 = *(void **)(dword_7B5E0 + 4 * v155);
            if ( !v165 )
            {
              snprintf(v289, 0x1000u, "Failed to calloc mining_thr[%d]", v155);
              v275 = v289;
LABEL_490:
              sub_38730(3, v275, 1);
              sub_1D8FC(1, (int)v165);
            }
            ++v155;
          }
          v167 = 0;
          v168 = 0;
          v290 = v92;
          while ( v168 < dword_7B720 )
          {
            v169 = 0;
            v170 = *(_DWORD **)(*v291 + 4 * v168);
            v171 = v170[37];
            v172 = malloc(4 * (v171 + 1));
            v170[38] = v172;
            v172[v171] = 0;
            v173 = v170[37];
            v170[24] = 4;
            if ( v173 > 0 )
            {
              do
              {
                v174 = (sem_t *)sub_1B124(v167);
                v174->__align = v167;
                v175 = v174;
                *(&v174[2].__align + 1) = (int)v170;
                *(&v174->__align + 1) = v169;
                if ( (*(int (**)(void))(v170[1] + 44))() )
                {
                  if ( sub_2F174((int)v175, 0, (void *(*)(void *))sub_11E24, v175) )
                  {
                    snprintf(v289, 0x1000u, "thread %d create failed", v175->__align);
                    sub_38730(3, v289, 1);
                    sub_1D8FC(1, 0);
                  }
                  *(_DWORD *)(v170[38] + 4 * v169) = v175;
                  if ( v170[8] != 1 )
                  {
                    if ( byte_78E09 && (*v287 || byte_78E08 || dword_766C4 > 6) )
                    {
                      snprintf(v289, 0x1000u, "Pushing sem post to thread %d", v175->__align);
                      sub_38730(7, v289, 0);
                    }
                    sub_2F1BC(v175 + 1, "cgminer.c", "main", 11098);
                  }
                }
                ++v169;
                ++v167;
              }
              while ( v170[37] > v169 );
            }
            ++v168;
          }
          v176 = v290;
          if ( byte_7730D || (v177 = dword_76FFC) != 0 )
          {
LABEL_284:
            v178 = (int *)dbl_770E0;
            dbl_7ACC0 = 0.0;
            do
            {
              *(_QWORD *)v178 = 0;
              v178 += 2;
            }
            while ( v178 != &dword_77140 );
            v179 = dword_7B720;
            dword_77140 = 0;
            v180 = *v291;
            for ( j = 0; j < v179; ++j )
            {
              v182 = *(_DWORD *)(v180 + 4 * j);
              *(_QWORD *)(v182 + 80) = 0;
              *(_QWORD *)(v182 + 48) = 0;
            }
            sub_2A84C((struct timeval *)&dword_770D0);
            sub_2A84C((struct timeval *)&dword_77148);
            sub_2A84C((struct timeval *)dword_770D8);
            sub_15264(byte_77260, 0x28u, &dword_770D0);
            v183 = dword_7B0FC;
            dword_770B0 = 2;
            if ( sub_2F174(dword_7B0FC + 128, 0, (void *(*)(void *))sub_21850, 0) )
            {
              v266 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"watchpool thread create failed";
              strcpy((char *)v266 + 4, "hpool thread create failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
            pthread_detach(*(_DWORD *)(v183 + 140));
            dword_770B4 = 3;
            v282 = (char *)dword_7B0FC;
            if ( sub_2F174(dword_7B0FC + 192, 0, (void *(*)(void *))sub_23344, 0) )
            {
              v201 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"watchdog thread create failed";
              strcpy((char *)v201 + 4, "hdog thread create failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
            pthread_detach(*((_DWORD *)v282 + 51));
            dword_76EF8 = 5;
            if ( sub_2F174(dword_7B0FC + 320, 0, (void *(*)(void *))sub_12164, (void *)(dword_7B0FC + 320)) )
            {
              v265 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"API thread create failed";
              strcpy((char *)v265 + 4, "thread create failed");
              v185 = v289;
LABEL_296:
              sub_38730(3, v185, 1);
              sub_1D8FC(1, 0);
            }
            v184 = dword_7B0FC;
            *((_DWORD *)v176 - 24) = 7;
            if ( sub_2F174(v184 + 448, 0, (void *(*)(void *))sub_27A98, (void *)(v184 + 448)) )
            {
              v264 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"input thread create failed";
              strcpy((char *)v264 + 4, "t thread create failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
            pthread_detach(*(_DWORD *)(v184 + 460));
            if ( dword_78B64 != 8 )
            {
              snprintf(v289, 0x1000u, "incorrect total_control_threads (%d) should be 8", dword_78B64);
              v185 = v289;
              goto LABEL_296;
            }
            if ( nice(-10) )
            {
              v285 = &byte_78E08;
              v283 = &dword_766C4;
              v288 = (const char **)&byte_78E09;
            }
            else
            {
              v288 = (const char **)&byte_78E09;
              if ( byte_78E09 )
              {
                if ( *v287 )
                {
                  v285 = &byte_78E08;
                  v283 = &dword_766C4;
                }
                else
                {
                  v285 = &byte_78E08;
                  if ( byte_78E08 )
                  {
                    v283 = &dword_766C4;
                  }
                  else
                  {
                    v283 = &dword_766C4;
                    if ( dword_766C4 <= 6 )
                      goto LABEL_337;
                  }
                }
                v202 = (int *)v289;
                *(_DWORD *)v289 = *(_DWORD *)"Unable to set thread to high priority";
                strcpy((char *)v202 + 4, "le to set thread to high priority");
                sub_38730(7, v289, 0);
              }
              else
              {
                v285 = &byte_78E08;
                v283 = &dword_766C4;
              }
            }
LABEL_337:
            v290 = 0;
            v284 = (void (**)(void))&off_75ED8;
            while ( 1 )
            {
              while ( 1 )
              {
                v203 = v286[506];
                if ( byte_7B8AC )
                {
                  if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                  {
                    v231 = (int *)v289;
                    *(_DWORD *)v289 = *(_DWORD *)"Work update message received";
                    strcpy((char *)v231 + 4, " update message received");
                    sub_38730(7, v289, 0);
                  }
                  sub_2A84C(&stru_76F0C);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B69C("signal_work_update", 5314);
                  if ( dword_7BB6C > 0 )
                  {
                    v232 = (int *)dword_7B5E0;
                    v233 = dword_7B5E0 + 4 * dword_7BB6C;
                    do
                    {
                      v234 = *v232++;
                      *(_BYTE *)(v234 + 63) = 1;
                    }
                    while ( v232 != (int *)v233 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B630("signal_work_update", 5317);
                  (*v284)();
                }
                byte_7B8AC = 0;
                sub_1DA58();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
                  sub_B414("main", 11235);
                v204 = dword_77050;
                if ( dword_77050 )
                  v204 = *(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 12);
                if ( v203 < v204 )
                {
                  if ( byte_77056 )
                  {
                    v205 = v286[506];
                    if ( v205 < v286[507] )
                    {
                      dword_75DD8 = v205 + 1;
                      byte_77056 = 0;
                    }
                  }
                  byte_77055 = 1;
                  pthread_cond_wait(&stru_7B1A0, (pthread_mutex_t *)dword_7704C);
                  v204 = dword_77050;
                  if ( dword_77050 )
                    v204 = *(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
                  sub_B5C4("main", 11253);
                (*v284)();
                if ( v204 <= v203 )
                  break;
                if ( byte_77056 )
                {
                  v206 = v286[506];
                  if ( v206 < v286[507] )
                  {
                    dword_75DD8 = v206 + 1;
                    byte_77056 = 0;
                  }
                }
                byte_77055 = 1;
                v207 = (char *)sub_193B4(0);
                v290 = v207;
                if ( v207 )
                {
                  sub_159B4((int)v207);
                  v290 = 0;
                }
              }
              if ( v290 )
                sub_159B4((int)v290);
              v290 = (char *)sub_1A3D4();
              v208 = sub_1DA58();
              v209 = v208;
              if ( dword_76EFC == 4 )
              {
                v209 = sub_12250(v208);
              }
              else if ( dword_76EFC == 3 )
              {
                v236 = dword_7B198;
                if ( dword_7B198 <= 0 )
                  goto LABEL_439;
                if ( *(_DWORD *)(*(_DWORD *)dword_7B438 + 60) <= *(_DWORD *)(*(_DWORD *)dword_7B438 + 64) )
                {
                  v237 = (int *)dword_7B438;
                  v238 = dword_7B438;
                  v239 = 0;
                  while ( ++v239 != dword_7B198 )
                  {
                    v240 = *(_DWORD *)(v238 + 4);
                    v238 += 4;
                    if ( *(_DWORD *)(v240 + 64) < *(_DWORD *)(v240 + 60) )
                      goto LABEL_441;
                  }
                  v241 = dword_7B438 + 4 * dword_7B198;
                  do
                  {
                    v242 = *v237++;
                    *(_DWORD *)(v242 + 64) = 0;
                  }
                  while ( v237 != (int *)v241 );
LABEL_439:
                  v243 = *((_DWORD *)v176 - 23) + 1;
                  *((_DWORD *)v176 - 23) = v243;
                  if ( v243 >= v236 )
                    dword_78B74 = 0;
                }
LABEL_441:
                v244 = 0;
                while ( 1 )
                {
                  v77 = v244++ < v236;
                  if ( !v77 )
                    break;
                  v246 = *((_DWORD *)v176 - 23);
                  v247 = *(_DWORD *)(dword_7B438 + 4 * v246);
                  v248 = *(_DWORD *)(v247 + 64);
                  v249 = *(_DWORD *)(v247 + 60);
                  *(_DWORD *)(v247 + 64) = v248 + 1;
                  if ( v248 < v249 )
                  {
                    if ( !*(_BYTE *)(v247 + 129)
                      && *(_DWORD *)(v247 + 132) == 1
                      && (!*(_BYTE *)(v247 + 664) || *(_BYTE *)(v247 + 665)) )
                    {
                      goto LABEL_453;
                    }
                    if ( byte_7B625 )
                    {
                      v250 = sub_12038(0);
                      v246 = *((_DWORD *)v176 - 23);
                      v236 = dword_7B198;
                      --*(_DWORD *)(v250 + 64);
                    }
                  }
                  v245 = v246 + 1;
                  *((_DWORD *)v176 - 23) = v245;
                  if ( v245 >= v236 )
                    dword_78B74 = 0;
                }
                if ( v236 > 0 )
                {
                  v251 = 0;
                  while ( 1 )
                  {
                    v247 = sub_12038(v251);
                    if ( !*(_BYTE *)(v247 + 129) && *(_DWORD *)(v247 + 132) == 1 )
                      break;
                    if ( ++v251 >= dword_7B198 )
                      goto LABEL_359;
                  }
LABEL_453:
                  v209 = v247;
                }
              }
LABEL_359:
              if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
              {
                snprintf(v289, 0x1000u, "Selecting pool %d for work", *(_DWORD *)v209);
                sub_38730(7, v289, 0);
              }
              if ( *(_BYTE *)(v209 + 664) )
              {
                while ( !*(_BYTE *)(v209 + 665) || !*(_BYTE *)(v209 + 667) )
                {
                  v210 = sub_1DA58();
                  v291 = (int *)v210;
                  if ( dword_76EFC == 4 )
                  {
                    v291 = (int *)sub_12250(v210);
                  }
                  else if ( dword_76EFC == 3 || !byte_7B625 )
                  {
                    v211 = dword_7B198;
                    if ( dword_7B198 <= 0 )
                      goto LABEL_378;
                    if ( *(_DWORD *)(*(_DWORD *)dword_7B438 + 60) <= *(_DWORD *)(*(_DWORD *)dword_7B438 + 64) )
                    {
                      v212 = (int *)dword_7B438;
                      v213 = dword_7B438;
                      v214 = 0;
                      while ( ++v214 != dword_7B198 )
                      {
                        v215 = *(_DWORD *)(v213 + 4);
                        v213 += 4;
                        if ( *(_DWORD *)(v215 + 64) < *(_DWORD *)(v215 + 60) )
                          goto LABEL_380;
                      }
                      v216 = dword_7B438 + 4 * dword_7B198;
                      do
                      {
                        v217 = *v212++;
                        *(_DWORD *)(v217 + 64) = 0;
                      }
                      while ( v212 != (int *)v216 );
LABEL_378:
                      v218 = *((_DWORD *)v176 - 23) + 1;
                      *((_DWORD *)v176 - 23) = v218;
                      if ( v218 >= v211 )
                        dword_78B74 = 0;
                    }
LABEL_380:
                    v219 = 0;
                    while ( 1 )
                    {
                      v77 = v219++ < v211;
                      if ( !v77 )
                        break;
                      v221 = *((_DWORD *)v176 - 23);
                      v222 = *(_DWORD *)(dword_7B438 + 4 * v221);
                      v223 = *(_DWORD *)(v222 + 64);
                      v224 = *(_DWORD *)(v222 + 60);
                      *(_DWORD *)(v222 + 64) = v223 + 1;
                      if ( v223 < v224 )
                      {
                        if ( !*(_BYTE *)(v222 + 129)
                          && *(_DWORD *)(v222 + 132) == 1
                          && (!*(_BYTE *)(v222 + 664) || *(_BYTE *)(v222 + 665)) )
                        {
                          goto LABEL_392;
                        }
                        if ( byte_7B625 )
                        {
                          v225 = sub_12038(0);
                          v221 = *((_DWORD *)v176 - 23);
                          v211 = dword_7B198;
                          --*(_DWORD *)(v225 + 64);
                        }
                      }
                      v220 = v221 + 1;
                      *((_DWORD *)v176 - 23) = v220;
                      if ( v220 >= v211 )
                        dword_78B74 = 0;
                    }
                    if ( v211 > 0 )
                    {
                      v235 = 0;
                      while ( 1 )
                      {
                        v222 = sub_12038(v235);
                        if ( !*(_BYTE *)(v222 + 129) && *(_DWORD *)(v222 + 132) == 1 )
                          break;
                        if ( ++v235 >= dword_7B198 )
                          goto LABEL_393;
                      }
LABEL_392:
                      v291 = (int *)v222;
                    }
                  }
LABEL_393:
                  if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                  {
                    snprintf(v289, 0x1000u, "Selecting pool %d for work", *v291);
                    sub_38730(7, v289, 0);
                  }
                  sub_2A92C();
                  if ( (int *)v209 != v291 )
                  {
                    v209 = (int)v291;
                    if ( !*((_BYTE *)v291 + 664) )
                      goto LABEL_400;
                  }
                }
                sub_1ACC4(v209, (int)v290);
                if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                {
                  v230 = (int *)v289;
                  *(_DWORD *)v289 = *(_DWORD *)"Generated stratum work";
                  strcpy((char *)v230 + 4, "rated stratum work");
                  sub_38730(7, v289, 0);
                }
LABEL_467:
                v263 = v290;
                v290 = 0;
                sub_1F17C((int)v263);
              }
              else
              {
LABEL_400:
                if ( dword_76FFC )
                {
                  v226 = (struct timeval *)(v290 + 1888);
                  v227 = v290;
                  sub_17254(v290);
                  v228 = (_DWORD *)dword_7B438;
                  v227[1770] = 1;
                  *((_DWORD *)v227 + 437) = *v228;
                  sub_2A84C(v226);
                  sub_2A530(&v226[1].tv_sec, v226);
                  v227[1928] = 66;
                  sub_11A5C((int)v290);
                  if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                  {
                    v229 = (int *)v289;
                    *(_DWORD *)v289 = *(_DWORD *)"Generated benchfile work";
                    strcpy((char *)v229 + 4, "rated benchfile work");
                    sub_38730(7, v289, 0);
                  }
                  goto LABEL_467;
                }
                if ( byte_7730D )
                {
                  v252 = (_DWORD *)dword_7B438;
                  v253 = v290;
                  v254 = v290 + 160;
                  *((_QWORD *)v290 + 233) = 0x4040000000000000LL;
                  v255 = dword_78730[1];
                  v256 = dword_78730[2];
                  v257 = dword_78730[3];
                  *((_DWORD *)v253 + 40) = dword_78730[0];
                  *((_DWORD *)v254 + 1) = v255;
                  *((_DWORD *)v254 + 2) = v256;
                  *((_DWORD *)v254 + 3) = v257;
                  v258 = unk_78744;
                  v259 = unk_78748;
                  v260 = unk_7874C;
                  *((_DWORD *)v254 + 4) = unk_78740;
                  *((_DWORD *)v254 + 5) = v258;
                  *((_DWORD *)v254 + 6) = v259;
                  *((_DWORD *)v254 + 7) = v260;
                  *((_DWORD *)v253 + 433) = 0;
                  v253[1770] = 1;
                  *((_DWORD *)v253 + 437) = *v252;
                  sub_2A84C((struct timeval *)v253 + 236);
                  sub_2A530((_DWORD *)v253 + 474, (_DWORD *)v253 + 472);
                  v261 = *(unsigned __int8 *)v288;
                  v290[1928] = 66;
                  if ( v261 && (*v287 || *v285 || *v283 > 6) )
                  {
                    v262 = (int *)v289;
                    *(_DWORD *)v289 = *(_DWORD *)"Generated benchmark work";
                    strcpy((char *)v262 + 4, "rated benchmark work");
                    sub_38730(7, v289, 0);
                  }
                  goto LABEL_467;
                }
              }
            }
          }
          v192 = dword_7B438;
          v193 = dword_7B198;
          while ( v177 < v193 )
          {
            v194 = *(_DWORD *)(v192 + 4 * v177++);
            v195 = *(_DWORD *)(v194 + 132);
            *(_BYTE *)(v194 + 129) = 1;
            if ( v195 != 1 )
            {
              *(_DWORD *)(v194 + 132) = 1;
              ++dword_7B5E4;
            }
          }
          v288 = (const char **)&byte_78E09;
          if ( byte_78E09 )
          {
            if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 6) )
            {
              v267 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Probing for an alive pool";
              strcpy((char *)v267 + 4, "ing for an alive pool");
              sub_38730(7, v289, 0);
            }
          }
          for ( k = 0; k < dword_7B198; ++k )
          {
            v269 = *(_DWORD *)(dword_7B438 + 4 * k);
            *(_BYTE *)(v269 + 316) = 1;
            pthread_create((pthread_t *)(v269 + 312), 0, (void *(*)(void *))start_routine, (void *)v269);
          }
          v270 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_7730C )
              break;
            if ( !--v270 )
              goto LABEL_495;
          }
          v270 = 0;
LABEL_495:
          v271 = v289;
          v272 = v287;
          while ( 1 )
          {
            if ( byte_7730C )
              goto LABEL_284;
            if ( !v270 )
            {
              if ( ((*v272 || byte_78E08 || dword_766C4 > 2)
                 && ((strcpy(v271, "No servers were found that could be used to get work from."),
                      sub_38730(3, v271, 0),
                      *v272)
                  || byte_78E08)
                 || dword_766C4 > 2)
                && ((strcpy(v271, "Please check the details from the list below of the servers you have input"),
                     sub_38730(3, v271, 0),
                     *v272)
                 || byte_78E08)
                || dword_766C4 > 2 )
              {
                strcpy(
                  v271,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_38730(3, v271, 0);
              }
              for ( m = 0; m < dword_7B198; ++m )
              {
                if ( *v272 || byte_78E08 || dword_766C4 > 3 )
                {
                  snprintf(
                    v271,
                    0x1000u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    m,
                    *(const char **)(*(_DWORD *)(dword_7B438 + 4 * m) + 196),
                    *(const char **)(*(_DWORD *)(dword_7B438 + 4 * m) + 204),
                    *(const char **)(*(_DWORD *)(dword_7B438 + 4 * m) + 208));
                  sub_38730(4, v271, 0);
                }
              }
              if ( !*((_BYTE *)v286 + 2016) )
              {
LABEL_529:
                v277 = (int *)v289;
                *(_DWORD *)v289 = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy((char *)v277 + 4, "ervers could be used! Exiting.");
                sub_38730(3, v289, 1);
                sub_1D8FC(0, 0);
              }
              if ( !*v272 && !byte_78E08 && dword_766C4 <= 2 )
              {
                v270 = 1;
                goto LABEL_523;
              }
              v270 = 1;
              strcpy(v271, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_38730(3, v271, 0);
            }
            if ( !*((_BYTE *)v286 + 2016) )
              goto LABEL_529;
LABEL_523:
            if ( dword_7B430 )
              v276 = *(__int16 *)(dword_7B430 + 4);
            else
              v276 = -1;
            v282 = (char *)&dword_7B430;
            if ( dword_7B430 )
              ++v276;
            wtouchln((WINDOW *)dword_7B430, 0, v276, 1);
            wrefresh(*(WINDOW **)v282);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_529;
            cbreak();
          }
        }
        v288 = (const char **)&byte_78E09;
        if ( byte_78E09 && (*v287 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(v289, 0x1000u, "Loaded configuration file %s", (const char *)dword_76F24);
          sub_38730(7, v289, 0);
        }
        if ( dword_76FF4 == -1 )
        {
          if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
          {
            v138 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy((char *)v138 + 4, "r in configuration file, partially loaded.");
            sub_38730(4, v289, 0);
          }
          if ( *((_BYTE *)v286 + 2016) )
          {
            if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
            {
              v139 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
              strcpy((char *)v139 + 4, "t cgminer with -T to see what failed to load.");
              sub_38730(4, v289, 0);
            }
          }
          goto LABEL_171;
        }
        if ( !dword_76FF4 )
        {
          if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
          {
            v153 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy((char *)v153 + 4, "l JSON error in configuration file.");
            sub_38730(4, v289, 0);
            if ( *v287 || byte_78E08 )
              goto LABEL_170;
            v283 = &dword_766C4;
          }
          if ( *v283 > 3 )
          {
LABEL_170:
            v128 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Configuration file could not be used.";
            strcpy((char *)v128 + 4, "iguration file could not be used.");
            sub_38730(4, v289, 0);
          }
        }
LABEL_171:
        free((void *)dword_76F24);
        dword_76F24 = 0;
        goto LABEL_172;
      }
      v61 = 24 * *(_DWORD *)(v60 + 4);
      v62 = malloc(v61);
      v63 = v62;
      if ( v62 )
      {
        memset(v62, 0, v61);
        *(_DWORD *)(v60 + 24) = (((2 * *(_DWORD *)(v60 + 4) - 1) & *(_DWORD *)(v60 + 12)) != 0)
                              + (*(_DWORD *)(v60 + 12) >> (*(_BYTE *)(v60 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v64 = (_DWORD *)*((_DWORD *)v20 + 17);
        v65 = v64[1];
        v66 = v64;
        if ( v65 )
        {
          v291 = 0;
          v290 = 0;
          do
          {
            v67 = *(_DWORD **)((char *)v291 + *v64);
            if ( v67 )
            {
              for ( n = v65; ; n = v66[1] )
              {
                v69 = (_DWORD *)v67[4];
                v70 = 3 * ((2 * n - 1) & v67[7]);
                v71 = (char *)&v63[v70];
                v72 = *((_DWORD *)v71 + 1) + 1;
                *((_DWORD *)v71 + 1) = v72;
                if ( v72 > v66[6] )
                {
                  ++v66[7];
                  *((_DWORD *)v71 + 2) = *((_DWORD *)v71 + 1) / *(_DWORD *)(*((_DWORD *)v20 + 17) + 24);
                }
                v67[3] = 0;
                v67[4] = v63[v70];
                v73 = v63[v70];
                if ( v73 )
                  *(_DWORD *)(v73 + 12) = v67;
                v63[v70] = v67;
                if ( !v69 )
                  break;
                v66 = (_DWORD *)*((_DWORD *)v20 + 17);
                v67 = v69;
              }
              v64 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v64[1];
            ++v290;
            v66 = v64;
            v291 += 3;
          }
          while ( v65 > (unsigned int)v290 );
        }
        free((void *)*v64);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v63;
        v74 = (_DWORD *)*((_DWORD *)v20 + 17);
        v75 = v74[3];
        v76 = v74[7];
        v77 = v76 > v75 >> 1;
        if ( v76 <= v75 >> 1 )
          v78 = 0;
        else
          v78 = v74[8];
        if ( v77 )
          ++v78;
        v74[8] = v78;
        v79 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v79 + 32) > 1u )
          *(_DWORD *)(v79 + 36) = 1;
        goto LABEL_56;
      }
LABEL_258:
      exit(-1);
    }
    strcpy((char *)v295, "Failed to create getq");
  }
  sub_38730(3, (const char *)v295, 1);
  sub_1D8FC(1, 0);
}
// BE7C: control flows out of bounds to BE80
// B9D0: variable 'v4' is possibly undefined
// B9D0: variable 'v5' is possibly undefined
// C648: variable 'v105' is possibly undefined
// C650: variable 'v106' is possibly undefined
// 755F0: using guessed type int dword_755F0[];
// 75600: using guessed type char *off_75600;
// 75DD0: using guessed type char byte_75DD0;
// 75DD8: using guessed type int dword_75DD8;
// 75E24: using guessed type char *off_75E24;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76AD4: using guessed type void (*off_76AD4)();
// 76BC0: using guessed type int stdscr;
// 76BD0: using guessed type int stderr;
// 76BE0: using guessed type int dword_76BE0;
// 76BE4: using guessed type int dword_76BE4;
// 76BE8: using guessed type int dword_76BE8;
// 76BEC: using guessed type int dword_76BEC;
// 76BF0: using guessed type int dword_76BF0;
// 76EF8: using guessed type int dword_76EF8;
// 76EFC: using guessed type int dword_76EFC;
// 76F00: using guessed type int dword_76F00;
// 76F0C: using guessed type struct timeval stru_76F0C;
// 76F20: using guessed type char byte_76F20;
// 76F24: using guessed type int dword_76F24;
// 76FF4: using guessed type int dword_76FF4;
// 76FFC: using guessed type int dword_76FFC;
// 7701C: using guessed type int dword_7701C;
// 77024: using guessed type int dword_77024;
// 77028: using guessed type int dword_77028;
// 7702C: using guessed type int dword_7702C;
// 7704C: using guessed type int dword_7704C;
// 77050: using guessed type int dword_77050;
// 77055: using guessed type char byte_77055;
// 77056: using guessed type char byte_77056;
// 7705C: using guessed type int dword_7705C;
// 770B0: using guessed type int dword_770B0;
// 770B4: using guessed type int dword_770B4;
// 770D0: using guessed type int dword_770D0;
// 770D8: using guessed type _DWORD dword_770D8[2];
// 770E0: using guessed type double dbl_770E0[12];
// 77140: using guessed type int dword_77140;
// 77148: using guessed type int dword_77148;
// 7728C: using guessed type int dword_7728C;
// 77290: using guessed type int dword_77290;
// 772B4: using guessed type int dword_772B4;
// 7730C: using guessed type char byte_7730C;
// 7730D: using guessed type char byte_7730D;
// 7731C: using guessed type _BYTE byte_7731C[2560];
// 77D1C: using guessed type _BYTE byte_77D1C[2560];
// 78730: using guessed type _DWORD dword_78730[4];
// 78950: using guessed type int dword_78950;
// 78954: using guessed type int dword_78954;
// 78958: using guessed type int dword_78958;
// 78A5C: using guessed type char byte_78A5C;
// 78B64: using guessed type int dword_78B64;
// 78B68: using guessed type int dword_78B68;
// 78B6C: using guessed type int dword_78B6C;
// 78B74: using guessed type int dword_78B74;
// 78BD0: using guessed type unsigned __int8 byte_78BD0[200];
// 78CA9: using guessed type char byte_78CA9;
// 78CE0: using guessed type char byte_78CE0;
// 78DEA: using guessed type char byte_78DEA;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7ACC0: using guessed type double dbl_7ACC0;
// 7ACD4: using guessed type int (__fastcall *off_7ACD4)(_DWORD);
// 7AD48: using guessed type char byte_7AD48;
// 7AD74: using guessed type int (__fastcall *off_7AD74)(_DWORD);
// 7ADF4: using guessed type int (__fastcall *off_7ADF4)(_DWORD);
// 7AE7C: using guessed type int (__fastcall *off_7AE7C)(_DWORD);
// 7AEFC: using guessed type _UNKNOWN *off_7AEFC;
// 7AF7C: using guessed type int (__fastcall *off_7AF7C)(_DWORD);
// 7AFFC: using guessed type int (__fastcall *off_7AFFC)(_DWORD);
// 7B084: using guessed type _UNKNOWN *off_7B084;
// 7B0FC: using guessed type int dword_7B0FC;
// 7B198: using guessed type int dword_7B198;
// 7B1DC: using guessed type int (__fastcall *off_7B1DC)(_DWORD);
// 7B264: using guessed type int (__fastcall *off_7B264)(_DWORD);
// 7B2D8: using guessed type pthread_rwlock_t stru_7B2D8;
// 7B30C: using guessed type int (__fastcall *off_7B30C)(_DWORD);
// 7B3AC: using guessed type int (__fastcall *off_7B3AC)(_DWORD);
// 7B430: using guessed type int dword_7B430;
// 7B438: using guessed type int dword_7B438;
// 7B440: using guessed type int dword_7B440;
// 7B444: using guessed type int dword_7B444;
// 7B454: using guessed type int (__fastcall *off_7B454)(_DWORD);
// 7B4E4: using guessed type int (__fastcall *off_7B4E4)(_DWORD);
// 7B56C: using guessed type int (__fastcall *off_7B56C)(_DWORD);
// 7B5E0: using guessed type int dword_7B5E0;
// 7B5E4: using guessed type int dword_7B5E4;
// 7B620: using guessed type int dword_7B620;
// 7B625: using guessed type char byte_7B625;
// 7B628: using guessed type int dword_7B628;
// 7B684: using guessed type int (__fastcall *off_7B684)(_DWORD);
// 7B720: using guessed type int dword_7B720;
// 7B7E4: using guessed type int (__fastcall *off_7B7E4)(_DWORD);
// 7B858: using guessed type char byte_7B858;
// 7B859: using guessed type char byte_7B859;
// 7B85C: using guessed type pthread_mutex_t stru_7B85C;
// 7B8AC: using guessed type char byte_7B8AC;
// 7B8B4: using guessed type int dword_7B8B4;
// 7B8CC: using guessed type int (__fastcall *off_7B8CC)(_DWORD);
// 7B940: using guessed type char byte_7B940;
// 7BA54: using guessed type int (__fastcall *off_7BA54)(_DWORD);
// 7BB18: using guessed type char byte_7BB18;
// 7BB6C: using guessed type int dword_7BB6C;
// 7BB7C: using guessed type _UNKNOWN *off_7BB7C;
// 7BBFC: using guessed type int (__fastcall *off_7BBFC)(_DWORD);
// 7BC74: using guessed type int dword_7BC74;
// 7BCAC: using guessed type int (__fastcall *off_7BCAC)(_DWORD);

//----- (0000F608) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_11,
    a1,
    va);
  abort();
}
// F614: positive sp value 4 has been found
// F630: variable 'v4' is possibly undefined
// 5D5A4: using guessed type int nullsub_11();

//----- (0000F644) --------------------------------------------------------
int sub_F644()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// AB8C: using guessed type int _gmon_start__(void);

//----- (0000F668) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &stdscr;
}
// 76BC0: using guessed type int stdscr;

//----- (0000F6A0) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &stdscr;
  HIDWORD(result) = 0;
  return result;
}
// 76BC0: using guessed type int stdscr;

//----- (0000F6E0) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !byte_76BD4 )
  {
    result = deregister_tm_clones();
    byte_76BD4 = 1;
  }
  return result;
}
// 76BD4: using guessed type char byte_76BD4;

//----- (0000F708) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (0000F740) --------------------------------------------------------
int __fastcall sub_F740(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (0000F750) --------------------------------------------------------
int __fastcall sub_F750(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (0000F760) --------------------------------------------------------
int __fastcall sub_F760(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0000F770) --------------------------------------------------------
int __fastcall sub_F770(_BYTE *a1)
{
  *a1 = 1;
  byte_78E08 = 1;
  return 0;
}
// 78E08: using guessed type char byte_78E08;

//----- (0000F78C) --------------------------------------------------------
int sub_F78C()
{
  return 0;
}

//----- (0000F7A0) --------------------------------------------------------
int sub_F7A0()
{
  return 1;
}

//----- (0000F7A8) --------------------------------------------------------
int sub_F7A8()
{
  return 1;
}

//----- (0000F7B0) --------------------------------------------------------
__int64 sub_F7B0()
{
  return 0xFFFFFFFFLL;
}

//----- (0000F7BC) --------------------------------------------------------
int sub_F7BC()
{
  return 1;
}

//----- (0000F7C4) --------------------------------------------------------
int sub_F7C4()
{
  return 1;
}

//----- (0000F7DC) --------------------------------------------------------
int sub_F7DC()
{
  return 0;
}

//----- (0000F7E8) --------------------------------------------------------
int __fastcall sub_F7E8(int a1, int a2)
{
  _DWORD *v2; // r3
  int result; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = *(_DWORD **)(a1 + 36);
  if ( v2[59] == a2 )
  {
    result = (unsigned __int8)byte_78E09;
    if ( byte_78E09 )
    {
      if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 6 )
      {
        snprintf(s, 0x1000u, "%s %d duplicate share detected as HW error", *(const char **)(v2[1] + 8), v2[2]);
        sub_38730(7, s, 0);
        return 0;
      }
    }
  }
  else
  {
    v2[59] = a2;
    return 1;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0000F8A4) --------------------------------------------------------
_BYTE *__fastcall sub_F8A4(const char *a1)
{
  size_t v2; // r0
  _BYTE *v3; // r4
  _DWORD *v4; // r0
  int v5; // r3
  int v6; // r1
  const char *v7; // r1
  _BYTE *v8; // r2
  bool v9; // zf
  char v10; // t1

  v2 = strlen(a1);
  v3 = malloc(2 * v2 + 1);
  v4 = malloc(8u);
  v5 = *(unsigned __int8 *)a1;
  v6 = dword_76BD8;
  *v4 = v3;
  dword_76BD8 = (int)v4;
  v4[1] = v6;
  if ( v5 )
  {
    v7 = a1 - 1;
    v8 = v3;
    do
    {
      v9 = v5 == 92;
      if ( v5 != 92 )
        v9 = v5 == 34;
      if ( v9 )
        *v8++ = 92;
      v10 = *++v7;
      *v8++ = v10;
      v5 = *((unsigned __int8 *)v7 + 1);
    }
    while ( v7[1] );
  }
  else
  {
    v8 = v3;
  }
  *v8 = 0;
  return v3;
}
// 76BD8: using guessed type int dword_76BD8;

//----- (0000F930) --------------------------------------------------------
int __fastcall sub_F930(int a1)
{
  sub_5B1D4(a1, &dword_76BDC);
  return 0;
}
// 76BDC: using guessed type int dword_76BDC;

//----- (0000F948) --------------------------------------------------------
int __fastcall sub_F948(int a1)
{
  sub_5B1D4(a1, &dword_76BE0);
  return 0;
}
// 76BE0: using guessed type int dword_76BE0;

//----- (0000F960) --------------------------------------------------------
int __fastcall sub_F960(int a1)
{
  sub_5B1D4(a1, &dword_76BE4);
  return 0;
}
// 76BE4: using guessed type int dword_76BE4;

//----- (0000F978) --------------------------------------------------------
int __fastcall sub_F978(int a1)
{
  sub_5B1D4(a1, &dword_76BE8);
  return 0;
}
// 76BE8: using guessed type int dword_76BE8;

//----- (0000F990) --------------------------------------------------------
int __fastcall sub_F990(int a1)
{
  sub_5B1D4(a1, &dword_76BEC);
  return 0;
}
// 76BEC: using guessed type int dword_76BEC;

//----- (0000F9A8) --------------------------------------------------------
int __fastcall sub_F9A8(int a1)
{
  sub_5B1D4(a1, &dword_76BF0);
  return 0;
}
// 76BF0: using guessed type int dword_76BF0;

//----- (0000F9C0) --------------------------------------------------------
void __fastcall __noreturn sub_F9C0(char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_zcash mining support.\n", byte_76BF4);
  v2 = sub_5C20C((const char *)dword_9D780, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 76BCC: using guessed type int stdout;
// 9D780: using guessed type int dword_9D780;

//----- (0000FC10) --------------------------------------------------------
void *__fastcall sub_FC10(void *a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0000FC24) --------------------------------------------------------
time_t __fastcall sub_FC24(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 0;
  sub_2A84C((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0000FC58) --------------------------------------------------------
time_t __fastcall sub_FC58(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 1;
  sub_2A84C((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0000FC90) --------------------------------------------------------
int __fastcall sub_FC90(int *a1, int *a2, int a3)
{
  int i; // r3
  _DWORD *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int v13; // r2
  int v14; // r3
  int v15; // r4
  int v16; // r5
  int v17; // r3
  int v18; // r8
  int v19; // r0
  int v20; // r8
  int v21; // r7
  int v22; // r1
  int v23; // r7
  int v24; // r6
  int v25; // r2
  int v26; // r5
  int v27; // r6
  int v28; // r3
  int v29; // r4
  int v30; // r0
  int v31; // r6
  int v32; // r8
  int v33; // r1
  int v34; // r0
  int v35; // r7
  int v36; // r1
  int v37; // r10
  int v38; // r5
  int v39; // r1
  int v40; // r4
  int v41; // r2
  int v42; // r1
  int v43; // r6
  int v44; // r3
  int v45; // r7
  int v46; // r1
  int v47; // r8
  int v48; // r7
  int v49; // r0
  int v50; // r5
  int v51; // r10
  int v52; // r7
  int v53; // r4
  int v54; // r6
  int v55; // r2
  int v56; // r10
  int v57; // r6
  int v58; // r8
  int v59; // r3
  int v60; // r5
  int v61; // r1
  int v62; // r6
  int v63; // r5
  int v64; // r0
  int v65; // r7
  int v66; // r5
  int v67; // r4
  int v68; // r10
  int v69; // r8
  int v70; // r5
  int v71; // r2
  int v72; // r6
  int v73; // r3
  int v74; // r8
  int v75; // r6
  int v76; // r7
  int v77; // r1
  int v78; // r10
  int v79; // r0
  int v80; // r6
  int v81; // r5
  int v82; // r4
  int v83; // r10
  int v84; // r5
  int v85; // r2
  int v86; // r8
  int v87; // r7
  int v88; // r5
  int v89; // r3
  int v90; // r6
  int v91; // r1
  int v92; // r7
  int v93; // r6
  int v94; // r10
  int v95; // r0
  int v96; // r8
  int v97; // r4
  int v98; // r6
  int v99; // r5
  int v100; // r2
  int v101; // r8
  int v102; // r5
  int v103; // r3
  int v104; // r7
  int v105; // r10
  int v106; // r5
  int v107; // r1
  int v108; // r6
  int v109; // r0
  int v110; // r10
  int v111; // r6
  int v112; // r8
  int v113; // r4
  int v114; // r7
  int v115; // r2
  int v116; // r6
  int v117; // r5
  int v118; // r3
  int v119; // r7
  int v120; // r5
  int v121; // r1
  int v122; // r10
  int v123; // r8
  int v124; // r5
  int v125; // r0
  int v126; // r6
  int v127; // r4
  int v128; // r8
  int v129; // r6
  int v130; // r7
  int v131; // r2
  int v132; // r10
  int v133; // r3
  int v134; // r6
  int v135; // r5
  int v136; // r1
  int v137; // r10
  int v138; // r5
  int v139; // r0
  int v140; // r8
  int v141; // r7
  int v142; // r5
  int v143; // r4
  int v144; // r6
  int v145; // r2
  int v146; // r7
  int v147; // r6
  int v148; // r10
  int v149; // r3
  int v150; // r8
  int v151; // r1
  int v152; // r6
  int v153; // r5
  int v154; // r0
  int v155; // r8
  int v156; // r5
  int v157; // r4
  int v158; // r7
  int v159; // r10
  int v160; // r5
  int v161; // r2
  int v162; // r6
  int v163; // r3
  int v164; // r10
  int v165; // r6
  int v166; // r8
  int v167; // r1
  int v168; // r7
  int v169; // r0
  int v170; // r6
  int v171; // r5
  int v172; // r4
  int v173; // r7
  int v174; // r5
  int v175; // r2
  int v176; // r10
  int v177; // r8
  int v178; // r5
  int v179; // r3
  int v180; // r6
  int v181; // r1
  int v182; // r8
  int v183; // r6
  int v184; // r7
  int v185; // r0
  int v186; // r10
  int v187; // r4
  int v188; // r6
  int v189; // r5
  int v190; // r2
  int v191; // r10
  int v192; // r5
  int v193; // r8
  int v194; // r3
  int v195; // r7
  int v196; // r5
  int v197; // r1
  int v198; // r6
  int result; // r0
  int v200; // r10
  int v201; // r6
  int v202; // r7
  int v203; // r2
  int v204; // r10
  int v205; // r8
  int v206; // r4
  int v207; // r2
  int v208; // r3
  _DWORD *v209; // r6
  int *v210; // r7
  int *v211; // r4
  int v212; // r0
  _DWORD *v213; // r5
  int v214; // r1
  int v215; // r2
  int v216; // r3
  int v217; // [sp+0h] [bp-120h]
  int v218; // [sp+4h] [bp-11Ch]
  int v219; // [sp+8h] [bp-118h]
  int v220; // [sp+Ch] [bp-114h]
  int v221; // [sp+10h] [bp-110h]
  int v222; // [sp+14h] [bp-10Ch]
  int v223; // [sp+18h] [bp-108h]
  int v224; // [sp+1Ch] [bp-104h]
  _DWORD v225[14]; // [sp+20h] [bp-100h] BYREF
  _DWORD v226[48]; // [sp+58h] [bp-C8h] BYREF
  _DWORD v227[2]; // [sp+118h] [bp-8h] BYREF

  if ( a3 )
  {
    for ( i = 0; i != 16; ++i )
      v225[i] = bswap32(a2[i]);
  }
  else
  {
    v209 = v225;
    v210 = a2 + 16;
    v211 = a2;
    do
    {
      v212 = *v211;
      v213 = v209;
      v214 = v211[1];
      v209 += 4;
      v215 = v211[2];
      v216 = v211[3];
      v211 += 4;
      *v213 = v212;
      v213[1] = v214;
      v213[2] = v215;
      v213[3] = v216;
    }
    while ( v211 != v210 );
  }
  v5 = v226;
  do
  {
    v6 = *(v5 - 13);
    v7 = *(v5 - 12);
    v8 = v6 + *(v5 - 4) + (__ROR4__(v5[1], 17) ^ __ROR4__(v5[1], 19) ^ (v5[1] >> 10));
    v5[2] = *(v5 - 14)
          + *(v5 - 5)
          + (__ROR4__(*v5, 17) ^ __ROR4__(*v5, 19) ^ (*v5 >> 10))
          + (__ROR4__(v6, 7) ^ __ROR4__(v6, 18) ^ (v6 >> 3));
    v5[3] = v8 + (__ROR4__(v7, 7) ^ __ROR4__(v7, 18) ^ (v7 >> 3));
    v5 += 2;
  }
  while ( v5 != v227 );
  v9 = a1[1];
  v10 = a1[2];
  v11 = a1[3];
  v217 = *a1;
  v218 = v9;
  v219 = v10;
  v220 = v11;
  v12 = a1[4];
  v13 = a1[6];
  v14 = a1[7];
  v15 = v217;
  v16 = v9;
  v222 = a1[5];
  v224 = v14;
  v17 = v12;
  v18 = v224
      + v225[0]
      + 1116352408
      + (__ROR4__(v12, 6) ^ __ROR4__(v12, 11) ^ __ROR4__(v12, 25))
      + ((v13 ^ v222) & v12 ^ v13);
  v19 = v18 + v220;
  v20 = ((v219 | v16) & v217 | v219 & v16) + (__ROR4__(v217, 2) ^ __ROR4__(v217, 13) ^ __ROR4__(v217, 22)) + v18;
  v21 = v13
      + v225[1]
      + 1899447441
      + (v19 & (v222 ^ v17) ^ v222)
      + (__ROR4__(v19, 6) ^ __ROR4__(v19, 11) ^ __ROR4__(v19, 25));
  v22 = v21 + v219;
  v23 = (__ROR4__(v20, 2) ^ __ROR4__(v20, 13) ^ __ROR4__(v20, 22)) + (v20 & (v16 | v15) | v16 & v15) + v21;
  v24 = v222
      + v225[2]
      - 1245643825
      + (v22 & (v19 ^ v17) ^ v17)
      + (__ROR4__(v22, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25));
  v25 = (__ROR4__(v23, 2) ^ __ROR4__(v23, 13) ^ __ROR4__(v23, 22)) + (v23 & (v20 | v15) | v20 & v15) + v24;
  v26 = v24 + v16;
  v27 = v17
      + v225[3]
      - 373957723
      + (v26 & (v22 ^ v19) ^ v19)
      + (__ROR4__(v26, 6) ^ __ROR4__(v26, 11) ^ __ROR4__(v26, 25));
  v28 = (__ROR4__(v25, 2) ^ __ROR4__(v25, 13) ^ __ROR4__(v25, 22)) + (v25 & (v23 | v20) | v23 & v20) + v27;
  v29 = v27 + v217;
  v30 = v225[4]
      + 961987163
      + v19
      + (v29 & (v26 ^ v22) ^ v22)
      + (__ROR4__(v27 + v217, 6) ^ __ROR4__(v29, 11) ^ __ROR4__(v29, 25));
  v31 = (__ROR4__(v28, 2) ^ __ROR4__(v28, 13) ^ __ROR4__(v28, 22)) + (v28 & (v25 | v23) | v25 & v23) + v30;
  v32 = v30 + v20;
  v33 = v225[5]
      + 1508970993
      + v22
      + (v32 & (v29 ^ v26) ^ v26)
      + (__ROR4__(v32, 6) ^ __ROR4__(v32, 11) ^ __ROR4__(v32, 25));
  v34 = (__ROR4__(v31, 2) ^ __ROR4__(v31, 13) ^ __ROR4__(v31, 22)) + (v31 & (v28 | v25) | v28 & v25) + v33;
  v35 = v33 + v23;
  v36 = v225[6]
      - 1841331548
      + v26
      + (v35 & (v32 ^ v29) ^ v29)
      + (__ROR4__(v35, 6) ^ __ROR4__(v35, 11) ^ __ROR4__(v35, 25));
  v37 = v36 + v25;
  v38 = (__ROR4__(v34, 2) ^ __ROR4__(v34, 13) ^ __ROR4__(v34, 22)) + (v34 & (v31 | v28) | v31 & v28) + v36;
  v39 = v225[7]
      - 1424204075
      + v29
      + (v37 & (v35 ^ v32) ^ v32)
      + (__ROR4__(v37, 6) ^ __ROR4__(v37, 11) ^ __ROR4__(v37, 25));
  v40 = v39 + v28;
  v41 = (__ROR4__(v38, 2) ^ __ROR4__(v38, 13) ^ __ROR4__(v38, 22)) + (v38 & (v34 | v31) | v34 & v31) + v39;
  v42 = v225[8]
      - 670586216
      + v32
      + (v40 & (v37 ^ v35) ^ v35)
      + (__ROR4__(v40, 6) ^ __ROR4__(v40, 11) ^ __ROR4__(v40, 25));
  v43 = v42 + v31;
  v44 = (__ROR4__(v41, 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v38 | v34) | v38 & v34) + v42;
  v45 = v225[9]
      + 310598401
      + v35
      + (v43 & (v40 ^ v37) ^ v37)
      + (__ROR4__(v43, 6) ^ __ROR4__(v43, 11) ^ __ROR4__(v43, 25));
  v46 = (__ROR4__(v44, 2) ^ __ROR4__(v44, 13) ^ __ROR4__(v44, 22)) + (v44 & (v41 | v38) | v41 & v38) + v45;
  v47 = v45 + v34;
  v48 = v225[10]
      + 607225278
      + v37
      + ((v45 + v34) & (v43 ^ v40) ^ v40)
      + (__ROR4__(v45 + v34, 6) ^ __ROR4__(v47, 11) ^ __ROR4__(v47, 25));
  v49 = (__ROR4__(v46, 2) ^ __ROR4__(v46, 13) ^ __ROR4__(v46, 22)) + (v46 & (v44 | v41) | v44 & v41) + v48;
  v50 = v48 + v38;
  v51 = v225[11]
      + 1426881987
      + v40
      + (v50 & (v47 ^ v43) ^ v43)
      + (__ROR4__(v50, 6) ^ __ROR4__(v50, 11) ^ __ROR4__(v50, 25));
  v52 = v51 + v41;
  v53 = (__ROR4__(v49, 2) ^ __ROR4__(v49, 13) ^ __ROR4__(v49, 22)) + (v49 & (v46 | v44) | v46 & v44) + v51;
  v54 = v225[12]
      + 1925078388
      + v43
      + (v52 & (v50 ^ v47) ^ v47)
      + (__ROR4__(v51 + v41, 6) ^ __ROR4__(v52, 11) ^ __ROR4__(v52, 25));
  v55 = (__ROR4__(v53, 2) ^ __ROR4__(v53, 13) ^ __ROR4__(v53, 22)) + (v53 & (v49 | v46) | v49 & v46) + v54;
  v56 = v54 + v44;
  v57 = v225[13]
      - 2132889090
      + v47
      + (v56 & (v52 ^ v50) ^ v50)
      + (__ROR4__(v54 + v44, 6) ^ __ROR4__(v56, 11) ^ __ROR4__(v56, 25));
  v58 = v57 + v46;
  v59 = (__ROR4__(v55, 2) ^ __ROR4__(v55, 13) ^ __ROR4__(v55, 22)) + (v55 & (v53 | v49) | v53 & v49) + v57;
  v60 = v226[0]
      - 1680079193
      + v50
      + (v58 & (v56 ^ v52) ^ v52)
      + (__ROR4__(v57 + v46, 6) ^ __ROR4__(v58, 11) ^ __ROR4__(v58, 25));
  v61 = (__ROR4__(v59, 2) ^ __ROR4__(v59, 13) ^ __ROR4__(v59, 22)) + (v59 & (v55 | v53) | v55 & v53) + v60;
  v62 = v60 + v49;
  v63 = v226[1]
      - 1046744716
      + v52
      + (v62 & (v58 ^ v56) ^ v56)
      + (__ROR4__(v60 + v49, 6) ^ __ROR4__(v62, 11) ^ __ROR4__(v62, 25));
  v64 = (__ROR4__(v61, 2) ^ __ROR4__(v61, 13) ^ __ROR4__(v61, 22)) + (v61 & (v59 | v55) | v59 & v55) + v63;
  v65 = v63 + v53;
  v66 = v226[2]
      - 459576895
      + v56
      + ((v63 + v53) & (v62 ^ v58) ^ v58)
      + (__ROR4__(v63 + v53, 6) ^ __ROR4__(v65, 11) ^ __ROR4__(v65, 25));
  v67 = (__ROR4__(v64, 2) ^ __ROR4__(v64, 13) ^ __ROR4__(v64, 22)) + (v64 & (v61 | v59) | v61 & v59) + v66;
  v68 = v66 + v55;
  v69 = v226[3]
      - 272742522
      + v58
      + (v68 & (v65 ^ v62) ^ v62)
      + (__ROR4__(v66 + v55, 6) ^ __ROR4__(v68, 11) ^ __ROR4__(v68, 25));
  v70 = v69 + v59;
  v71 = (__ROR4__(v67, 2) ^ __ROR4__(v67, 13) ^ __ROR4__(v67, 22)) + (v67 & (v64 | v61) | v64 & v61) + v69;
  v72 = v226[4]
      + 264347078
      + v62
      + (v70 & (v68 ^ v65) ^ v65)
      + (__ROR4__(v69 + v59, 6) ^ __ROR4__(v70, 11) ^ __ROR4__(v70, 25));
  v73 = (__ROR4__(v71, 2) ^ __ROR4__(v71, 13) ^ __ROR4__(v71, 22)) + (v71 & (v67 | v64) | v67 & v64) + v72;
  v74 = v72 + v61;
  v75 = v226[5]
      + 604807628
      + v65
      + (v74 & (v70 ^ v68) ^ v68)
      + (__ROR4__(v72 + v61, 6) ^ __ROR4__(v74, 11) ^ __ROR4__(v74, 25));
  v76 = v75 + v64;
  v77 = (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + (v73 & (v71 | v67) | v71 & v67) + v75;
  v78 = v226[6]
      + 770255983
      + v68
      + (v76 & (v74 ^ v70) ^ v70)
      + (__ROR4__(v75 + v64, 6) ^ __ROR4__(v76, 11) ^ __ROR4__(v76, 25));
  v79 = (__ROR4__(v77, 2) ^ __ROR4__(v77, 13) ^ __ROR4__(v77, 22)) + (v77 & (v73 | v71) | v73 & v71) + v78;
  v80 = v78 + v67;
  v81 = v226[7]
      + 1249150122
      + v70
      + (v80 & (v76 ^ v74) ^ v74)
      + (__ROR4__(v78 + v67, 6) ^ __ROR4__(v80, 11) ^ __ROR4__(v80, 25));
  v82 = (__ROR4__(v79, 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v77 | v73) | v77 & v73) + v81;
  v83 = v81 + v71;
  v84 = v226[8]
      + 1555081692
      + v74
      + ((v81 + v71) & (v80 ^ v76) ^ v76)
      + (__ROR4__(v81 + v71, 6) ^ __ROR4__(v83, 11) ^ __ROR4__(v83, 25));
  v85 = (__ROR4__(v82, 2) ^ __ROR4__(v82, 13) ^ __ROR4__(v82, 22)) + (v82 & (v79 | v77) | v79 & v77) + v84;
  v86 = v84 + v73;
  v87 = v226[9]
      + 1996064986
      + v76
      + (v86 & (v83 ^ v80) ^ v80)
      + (__ROR4__(v84 + v73, 6) ^ __ROR4__(v86, 11) ^ __ROR4__(v86, 25));
  v88 = v87 + v77;
  v89 = (__ROR4__(v85, 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v82 | v79) | v82 & v79) + v87;
  v90 = v226[10]
      - 1740746414
      + v80
      + (v88 & (v86 ^ v83) ^ v83)
      + (__ROR4__(v87 + v77, 6) ^ __ROR4__(v88, 11) ^ __ROR4__(v88, 25));
  v91 = (__ROR4__(v89, 2) ^ __ROR4__(v89, 13) ^ __ROR4__(v89, 22)) + (v89 & (v85 | v82) | v85 & v82) + v90;
  v92 = v90 + v79;
  v93 = v226[11]
      - 1473132947
      + v83
      + (v92 & (v88 ^ v86) ^ v86)
      + (__ROR4__(v90 + v79, 6) ^ __ROR4__(v92, 11) ^ __ROR4__(v92, 25));
  v94 = v93 + v82;
  v95 = (__ROR4__(v91, 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v89 | v85) | v89 & v85) + v93;
  v96 = v226[12]
      - 1341970488
      + v86
      + (v94 & (v92 ^ v88) ^ v88)
      + (__ROR4__(v93 + v82, 6) ^ __ROR4__(v94, 11) ^ __ROR4__(v94, 25));
  v97 = (__ROR4__(v95, 2) ^ __ROR4__(v95, 13) ^ __ROR4__(v95, 22)) + (v95 & (v91 | v89) | v91 & v89) + v96;
  v98 = v96 + v85;
  v99 = v226[13]
      - 1084653625
      + v88
      + (v98 & (v94 ^ v92) ^ v92)
      + (__ROR4__(v96 + v85, 6) ^ __ROR4__(v98, 11) ^ __ROR4__(v98, 25));
  v100 = (__ROR4__(v97, 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v95 | v91) | v95 & v91) + v99;
  v101 = v99 + v89;
  v102 = v226[14]
       - 958395405
       + v92
       + ((v99 + v89) & (v98 ^ v94) ^ v94)
       + (__ROR4__(v99 + v89, 6) ^ __ROR4__(v101, 11) ^ __ROR4__(v101, 25));
  v103 = (__ROR4__(v100, 2) ^ __ROR4__(v100, 13) ^ __ROR4__(v100, 22)) + (v100 & (v97 | v95) | v97 & v95) + v102;
  v104 = v102 + v91;
  v105 = v226[15]
       - 710438585
       + v94
       + (v104 & (v101 ^ v98) ^ v98)
       + (__ROR4__(v102 + v91, 6) ^ __ROR4__(v104, 11) ^ __ROR4__(v104, 25));
  v106 = v105 + v95;
  v107 = (__ROR4__(v103, 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v100 | v97) | v100 & v97) + v105;
  v108 = v226[16]
       + 113926993
       + v98
       + (v106 & (v104 ^ v101) ^ v101)
       + (__ROR4__(v105 + v95, 6) ^ __ROR4__(v106, 11) ^ __ROR4__(v106, 25));
  v109 = (__ROR4__(v107, 2) ^ __ROR4__(v107, 13) ^ __ROR4__(v107, 22)) + (v107 & (v103 | v100) | v103 & v100) + v108;
  v110 = v108 + v97;
  v111 = v226[17]
       + 338241895
       + v101
       + (v110 & (v106 ^ v104) ^ v104)
       + (__ROR4__(v108 + v97, 6) ^ __ROR4__(v110, 11) ^ __ROR4__(v110, 25));
  v112 = v111 + v100;
  v113 = (__ROR4__(v109, 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + (v109 & (v107 | v103) | v107 & v103) + v111;
  v114 = v226[18]
       + 666307205
       + v104
       + (v112 & (v110 ^ v106) ^ v106)
       + (__ROR4__(v111 + v100, 6) ^ __ROR4__(v112, 11) ^ __ROR4__(v112, 25));
  v115 = (__ROR4__(v113, 2) ^ __ROR4__(v113, 13) ^ __ROR4__(v113, 22)) + (v113 & (v109 | v107) | v109 & v107) + v114;
  v116 = v114 + v103;
  v117 = v226[19]
       + 773529912
       + v106
       + (v116 & (v112 ^ v110) ^ v110)
       + (__ROR4__(v114 + v103, 6) ^ __ROR4__(v116, 11) ^ __ROR4__(v116, 25));
  v118 = (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + (v115 & (v113 | v109) | v113 & v109) + v117;
  v119 = v117 + v107;
  v120 = v226[20]
       + 1294757372
       + v110
       + ((v117 + v107) & (v116 ^ v112) ^ v112)
       + (__ROR4__(v117 + v107, 6) ^ __ROR4__(v119, 11) ^ __ROR4__(v119, 25));
  v121 = (__ROR4__(v118, 2) ^ __ROR4__(v118, 13) ^ __ROR4__(v118, 22)) + (v118 & (v115 | v113) | v115 & v113) + v120;
  v122 = v120 + v109;
  v123 = v226[21]
       + 1396182291
       + v112
       + (v122 & (v119 ^ v116) ^ v116)
       + (__ROR4__(v120 + v109, 6) ^ __ROR4__(v122, 11) ^ __ROR4__(v122, 25));
  v124 = v123 + v113;
  v125 = (__ROR4__(v121, 2) ^ __ROR4__(v121, 13) ^ __ROR4__(v121, 22)) + (v121 & (v118 | v115) | v118 & v115) + v123;
  v126 = v226[22]
       + 1695183700
       + v116
       + (v124 & (v122 ^ v119) ^ v119)
       + (__ROR4__(v123 + v113, 6) ^ __ROR4__(v124, 11) ^ __ROR4__(v124, 25));
  v127 = (__ROR4__(v125, 2) ^ __ROR4__(v125, 13) ^ __ROR4__(v125, 22)) + (v125 & (v121 | v118) | v121 & v118) + v126;
  v128 = v126 + v115;
  v129 = v226[23]
       + 1986661051
       + v119
       + (v128 & (v124 ^ v122) ^ v122)
       + (__ROR4__(v126 + v115, 6) ^ __ROR4__(v128, 11) ^ __ROR4__(v128, 25));
  v130 = v129 + v118;
  v131 = (__ROR4__(v127, 2) ^ __ROR4__(v127, 13) ^ __ROR4__(v127, 22)) + (v127 & (v125 | v121) | v125 & v121) + v129;
  v132 = v226[24]
       - 2117940946
       + v122
       + (v130 & (v128 ^ v124) ^ v124)
       + (__ROR4__(v129 + v118, 6) ^ __ROR4__(v130, 11) ^ __ROR4__(v130, 25));
  v133 = (__ROR4__(v131, 2) ^ __ROR4__(v131, 13) ^ __ROR4__(v131, 22)) + (v131 & (v127 | v125) | v127 & v125) + v132;
  v134 = v132 + v121;
  v135 = v226[25]
       - 1838011259
       + v124
       + (v134 & (v130 ^ v128) ^ v128)
       + (__ROR4__(v132 + v121, 6) ^ __ROR4__(v134, 11) ^ __ROR4__(v134, 25));
  v136 = (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + (v133 & (v131 | v127) | v131 & v127) + v135;
  v137 = v135 + v125;
  v138 = v226[26]
       - 1564481375
       + v128
       + ((v135 + v125) & (v134 ^ v130) ^ v130)
       + (__ROR4__(v135 + v125, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25));
  v139 = (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + (v136 & (v133 | v131) | v133 & v131) + v138;
  v140 = v138 + v127;
  v141 = v226[27]
       - 1474664885
       + v130
       + (v140 & (v137 ^ v134) ^ v134)
       + (__ROR4__(v138 + v127, 6) ^ __ROR4__(v140, 11) ^ __ROR4__(v140, 25));
  v142 = v141 + v131;
  v143 = (__ROR4__(v139, 2) ^ __ROR4__(v139, 13) ^ __ROR4__(v139, 22)) + (v139 & (v136 | v133) | v136 & v133) + v141;
  v144 = v226[28]
       - 1035236496
       + v134
       + (v142 & (v140 ^ v137) ^ v137)
       + (__ROR4__(v141 + v131, 6) ^ __ROR4__(v142, 11) ^ __ROR4__(v142, 25));
  v145 = (__ROR4__(v143, 2) ^ __ROR4__(v143, 13) ^ __ROR4__(v143, 22)) + (v143 & (v139 | v136) | v139 & v136) + v144;
  v146 = v144 + v133;
  v147 = v226[29]
       - 949202525
       + v137
       + (v146 & (v142 ^ v140) ^ v140)
       + (__ROR4__(v144 + v133, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25));
  v148 = v147 + v136;
  v149 = (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + (v145 & (v143 | v139) | v143 & v139) + v147;
  v150 = v226[30]
       - 778901479
       + v140
       + (v148 & (v146 ^ v142) ^ v142)
       + (__ROR4__(v147 + v136, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25));
  v151 = (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + (v149 & (v145 | v143) | v145 & v143) + v150;
  v152 = v150 + v139;
  v153 = v226[31]
       - 694614492
       + v142
       + (v152 & (v148 ^ v146) ^ v146)
       + (__ROR4__(v150 + v139, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25));
  v154 = (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + (v151 & (v149 | v145) | v149 & v145) + v153;
  v155 = v153 + v143;
  v156 = v226[32]
       - 200395387
       + v146
       + ((v153 + v143) & (v152 ^ v148) ^ v148)
       + (__ROR4__(v153 + v143, 6) ^ __ROR4__(v155, 11) ^ __ROR4__(v155, 25));
  v157 = (__ROR4__(v154, 2) ^ __ROR4__(v154, 13) ^ __ROR4__(v154, 22)) + (v154 & (v151 | v149) | v151 & v149) + v156;
  v158 = v156 + v145;
  v159 = v226[33]
       + 275423344
       + v148
       + (v158 & (v155 ^ v152) ^ v152)
       + (__ROR4__(v156 + v145, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25));
  v160 = v159 + v149;
  v161 = (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + (v157 & (v154 | v151) | v154 & v151) + v159;
  v162 = v226[34]
       + 430227734
       + v152
       + (v160 & (v158 ^ v155) ^ v155)
       + (__ROR4__(v159 + v149, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25));
  v163 = (__ROR4__(v161, 2) ^ __ROR4__(v161, 13) ^ __ROR4__(v161, 22)) + (v161 & (v157 | v154) | v157 & v154) + v162;
  v164 = v162 + v151;
  v165 = v226[35]
       + 506948616
       + v155
       + (v164 & (v160 ^ v158) ^ v158)
       + (__ROR4__(v162 + v151, 6) ^ __ROR4__(v164, 11) ^ __ROR4__(v164, 25));
  v166 = v165 + v154;
  v167 = (__ROR4__(v163, 2) ^ __ROR4__(v163, 13) ^ __ROR4__(v163, 22)) + (v163 & (v161 | v157) | v161 & v157) + v165;
  v168 = v226[36]
       + 659060556
       + v158
       + (v166 & (v164 ^ v160) ^ v160)
       + (__ROR4__(v165 + v154, 6) ^ __ROR4__(v166, 11) ^ __ROR4__(v166, 25));
  v169 = (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + (v167 & (v163 | v161) | v163 & v161) + v168;
  v170 = v168 + v157;
  v171 = v226[37]
       + 883997877
       + v160
       + (v170 & (v166 ^ v164) ^ v164)
       + (__ROR4__(v168 + v157, 6) ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25));
  v172 = (__ROR4__(v169, 2) ^ __ROR4__(v169, 13) ^ __ROR4__(v169, 22)) + (v169 & (v167 | v163) | v167 & v163) + v171;
  v173 = v171 + v161;
  v174 = v226[38]
       + 958139571
       + v164
       + ((v171 + v161) & (v170 ^ v166) ^ v166)
       + (__ROR4__(v171 + v161, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25));
  v175 = (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + (v172 & (v169 | v167) | v169 & v167) + v174;
  v176 = v174 + v163;
  v177 = v226[39]
       + 1322822218
       + v166
       + (v176 & (v173 ^ v170) ^ v170)
       + (__ROR4__(v174 + v163, 6) ^ __ROR4__(v176, 11) ^ __ROR4__(v176, 25));
  v178 = v177 + v167;
  v179 = (__ROR4__(v175, 2) ^ __ROR4__(v175, 13) ^ __ROR4__(v175, 22)) + (v175 & (v172 | v169) | v172 & v169) + v177;
  v180 = v226[40]
       + 1537002063
       + v170
       + (v178 & (v176 ^ v173) ^ v173)
       + (__ROR4__(v177 + v167, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25));
  v181 = (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + (v179 & (v175 | v172) | v175 & v172) + v180;
  v182 = v180 + v169;
  v183 = v226[41]
       + 1747873779
       + v173
       + (v182 & (v178 ^ v176) ^ v176)
       + (__ROR4__(v180 + v169, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25));
  v184 = v183 + v172;
  v185 = (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v179 | v175) | v179 & v175) + v183;
  v186 = v226[42]
       + 1955562222
       + v176
       + (v184 & (v182 ^ v178) ^ v178)
       + (__ROR4__(v183 + v172, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25));
  v187 = (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + (v185 & (v181 | v179) | v181 & v179) + v186;
  v188 = v186 + v175;
  v189 = v226[43]
       + 2024104815
       + v178
       + (v188 & (v184 ^ v182) ^ v182)
       + (__ROR4__(v186 + v175, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25));
  v190 = (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + (v187 & (v185 | v181) | v185 & v181) + v189;
  v191 = v189 + v179;
  v192 = v226[44]
       - 2067236844
       + v182
       + ((v189 + v179) & (v188 ^ v184) ^ v184)
       + (__ROR4__(v189 + v179, 6) ^ __ROR4__(v191, 11) ^ __ROR4__(v191, 25));
  v193 = v192 + v181;
  v194 = (__ROR4__(v190, 2) ^ __ROR4__(v190, 13) ^ __ROR4__(v190, 22)) + (v190 & (v187 | v185) | v187 & v185) + v192;
  v195 = v226[45]
       - 1933114872
       + v184
       + (v193 & (v191 ^ v188) ^ v188)
       + (__ROR4__(v192 + v181, 6) ^ __ROR4__(v193, 11) ^ __ROR4__(v193, 25));
  v196 = v195 + v185;
  v197 = (__ROR4__(v194, 2) ^ __ROR4__(v194, 13) ^ __ROR4__(v194, 22)) + (v194 & (v190 | v187) | v190 & v187) + v195;
  v198 = v226[46]
       - 1866530822
       + v188
       + (v196 & (v193 ^ v191) ^ v191)
       + (__ROR4__(v195 + v185, 6) ^ __ROR4__(v195 + v185, 11) ^ __ROR4__(v196, 25));
  v224 = v198 + v187;
  result = (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + (v197 & (v194 | v190) | v194 & v190) + v198;
  v200 = v226[47]
       - 1538233109
       + v191
       + (v224 & (v196 ^ v193) ^ v193)
       + (__ROR4__(v198 + v187, 6) ^ __ROR4__(v224, 11) ^ __ROR4__(v224, 25));
  v201 = (__ROR4__(result, 2) ^ __ROR4__(result, 13) ^ __ROR4__(result, 22))
       + (result & (v197 | v194) | v197 & v194)
       + v200;
  v202 = v200 + v190;
  v203 = v227[0]
       - 1090935817
       + v193
       + (v202 & (v224 ^ v196) ^ v196)
       + (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25));
  v204 = v203 + v194;
  v205 = (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + (v201 & (result | v197) | result & v197) + v203;
  v206 = v227[1]
       - 965641998
       + v196
       + (v204 & (v202 ^ v224) ^ v224)
       + (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25));
  v207 = (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + (v205 & (v201 | result) | v201 & result) + v206;
  v208 = 0;
  v220 = result;
  v223 = v202;
  v219 = v201;
  v222 = v204;
  v221 = v206 + v197;
  v217 = v207;
  v218 = v205;
  while ( 1 )
  {
    a1[v208++] += v207;
    if ( v208 == 8 )
      break;
    v207 = *(int *)((char *)&v217 + v208 * 4);
  }
  return result;
}

//----- (00011514) --------------------------------------------------------
double __fastcall sub_11514(double a1)
{
  float v1; // s0
  _DWORD *v2; // r4
  double result; // r0

  v2 = (_DWORD *)LODWORD(a1);
  result = log10(a1);
  if ( (int)(v1 + 1.0) > *v2 )
    ++*v2;
  return result;
}
// 11518: variable 'v1' is possibly undefined

//----- (00011548) --------------------------------------------------------
double __fastcall sub_11548(double a1)
{
  double v1; // d0
  _DWORD *v2; // r4
  double result; // r0

  v1 = (double)SLODWORD(a1);
  v2 = (_DWORD *)HIDWORD(a1);
  result = log10(a1);
  if ( (int)(v1 + 1.0) > *v2 )
    ++*v2;
  return result;
}

//----- (00011580) --------------------------------------------------------
int __fastcall sub_11580(unsigned __int64 a1, char *a2, size_t a3, int a4)
{
  __int64 v6; // r2
  __int64 v7; // r0
  double v8; // r0
  double v9; // d8
  bool v11; // cf
  __int64 v12; // r0
  double v13; // d0
  double v14; // r0
  __int64 v15; // r0
  __int64 v16; // r0
  __int64 v17; // r0
  __int16 v18; // [sp+1Ch] [bp-4h] BYREF

  v18 = 0;
  if ( a1 > 0xDE0B6B3A763FFFFLL )
  {
    LODWORD(v6) = -1530494976;
    HIDWORD(v6) = (char *)&loc_38D7C + 2;
    LODWORD(v7) = sub_5CBC4(a1, v6);
    LODWORD(v8) = sub_5CB50(v7);
    v18 = 69;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  v11 = (unsigned int)&loc_38D7C + 2 >= HIDWORD(a1);
  if ( (_UNKNOWN *)((char *)&loc_38D7C + 2) == (_UNKNOWN *)HIDWORD(a1) )
    v11 = (unsigned int)a1 <= 0xA4C67FFF;
  if ( !v11 )
  {
    LODWORD(v12) = sub_5CBC4(a1, 1000000000000LL);
    LODWORD(v8) = sub_5CB50(v12);
    v18 = 80;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xE8D4A50FFFLL )
  {
    LODWORD(v16) = sub_5CBC4(a1, 1000000000);
    LODWORD(v8) = sub_5CB50(v16);
    v18 = 84;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3B9AC9FF )
  {
    LODWORD(v15) = sub_5CBC4(a1, 1000000);
    LODWORD(v8) = sub_5CB50(v15);
    v18 = 71;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xF423F )
  {
    LODWORD(v17) = sub_5CBC4(a1, 1000);
    LODWORD(v8) = sub_5CB50(v17);
    v18 = 77;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3E7 )
  {
    LODWORD(v8) = sub_5CB50(a1);
    v18 = 75;
    v9 = v8 / 1000.0;
LABEL_3:
    if ( !a4 )
      return snprintf(a2, a3, "%.3g%s", v9, (const char *)&v18);
    goto LABEL_9;
  }
  LODWORD(v8) = sub_5CB50(a1);
  v9 = v8;
  if ( !a4 )
    return snprintf(a2, a3, "%d%s", (unsigned int)v8, (const char *)&v18);
LABEL_9:
  if ( v9 <= 0.0 )
  {
    v13 = 0.0;
  }
  else
  {
    v13 = v9;
    v14 = log10(v8);
    floor(v14);
  }
  return snprintf(a2, a3, "%*.*f%s", a4 + 1, (int)((double)(a4 - 1) - v13), v9, (const char *)&v18);
}
// 115DC: variable 'v7' is possibly undefined
// 115EC: variable 'v8' is possibly undefined
// 11648: variable 'v12' is possibly undefined
// 11734: variable 'v16' is possibly undefined
// 11700: variable 'v15' is possibly undefined
// 117A4: variable 'v17' is possibly undefined

//----- (00011814) --------------------------------------------------------
void __fastcall sub_11814(char *a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  char v4[1016]; // [sp+8h] [bp-1400h] BYREF
  char v5[4096]; // [sp+408h] [bp-1000h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    --v2;
    v3 = (unsigned __int8)a2 + (v3 << 8);
    a2 >>= 8;
  }
  while ( v2 );
  sub_296D8(v4, a1, 128);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(v5, 0x1000u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v4);
    sub_38730(3, v5, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (000118D4) --------------------------------------------------------
bool sub_118D4()
{
  struct tm *v0; // r0
  int v1; // r12
  int v3; // r2
  int tm_hour; // r1
  int v5; // r2
  time_t tv_sec; // [sp+4h] [bp-Ch] BYREF
  struct timeval v7; // [sp+8h] [bp-8h] BYREF

  if ( !byte_7B874 && !byte_7B5F0 )
    return 1;
  sub_2A84C(&v7);
  tv_sec = v7.tv_sec;
  v0 = localtime(&tv_sec);
  if ( !byte_7B874 )
  {
    tm_hour = v0->tm_hour;
    return tm_hour < dword_7B5FC || tm_hour == dword_7B5FC && v0->tm_min < dword_7B5F8;
  }
  if ( !byte_7B5F0 )
  {
    v1 = v0->tm_hour;
    if ( v1 >= dword_7B880 && (v1 != dword_7B880 || v0->tm_min >= dword_7B87C) )
    {
      byte_7B874 = 0;
      return 1;
    }
    return 0;
  }
  if ( dword_7B880 >= dword_7B5FC && (dword_7B880 != dword_7B5FC || dword_7B87C >= dword_7B5F8) )
  {
    v3 = v0->tm_hour;
    if ( dword_7B880 <= v3 )
    {
      if ( dword_7B880 != v3 || v0->tm_min >= dword_7B87C )
        return 1;
    }
    else if ( dword_7B5FC > v3 )
    {
      return 1;
    }
    return dword_7B5FC == v3 && v0->tm_min < dword_7B5F8;
  }
  v5 = v0->tm_hour;
  return (dword_7B5FC > v5 || dword_7B5FC == v5 && v0->tm_min < dword_7B5F8)
      && dword_7B880 <= v5
      && (dword_7B880 != v5 || v0->tm_min >= dword_7B87C);
}
// 7B5F0: using guessed type char byte_7B5F0;
// 7B5F8: using guessed type int dword_7B5F8;
// 7B5FC: using guessed type int dword_7B5FC;
// 7B874: using guessed type char byte_7B874;
// 7B87C: using guessed type int dword_7B87C;
// 7B880: using guessed type int dword_7B880;

//----- (00011A5C) --------------------------------------------------------
int __fastcall sub_11A5C(int a1)
{
  double v1; // d0
  int v3; // r4
  double *v4; // r6
  int v5; // r0
  double v6; // d8
  double v7; // d0
  unsigned __int64 v8; // r0
  int result; // r0
  double v10; // d16
  double v11; // d16
  __int64 v12; // r0
  double v13; // d9
  double v14; // r0
  double v15; // d8
  double v16; // r0
  double v17; // d8
  double v18; // r0
  double v19; // d8
  double v20; // r0
  double v21; // d8

  v3 = *(_DWORD *)(a1 + 1748);
  if ( v1 == 0.0 )
  {
    v12 = *(_QWORD *)(a1 + 184);
    v13 = 65536.0;
    if ( !byte_7B859 )
      v13 = 2.69595353e67;
    LODWORD(v14) = sub_5CB50(v12);
    v15 = v14 * 6.27710174e57;
    LODWORD(v16) = sub_5CB50(*(_QWORD *)(a1 + 176));
    v17 = v15 + v16 * 3.40282367e38;
    LODWORD(v18) = sub_5CB50(*(_QWORD *)(a1 + 168));
    v19 = v17 + v18 * 1.84467441e19;
    LODWORD(v20) = sub_5CB50(*(_QWORD *)(a1 + 160));
    v21 = v19 + v20;
    if ( v21 == 0.0 )
      v21 = 1.0;
    *(double *)(a1 + 1864) = v13 / v21;
    v4 = (double *)(a1 + 1864);
  }
  else
  {
    v4 = (double *)(a1 + 1864);
    *(double *)(a1 + 1864) = v1;
  }
  v5 = sub_49824(a1 + 160);
  v6 = (double)v5;
  *v4 = (double)v5;
  v7 = (double)v5;
  *(double *)(v3 + 504) = (double)v5;
  round(v5);
  LODWORD(v8) = sub_5CC48(v7);
  result = sub_11580(v8, (char *)(*(_DWORD *)(a1 + 1748) + 48), 8u, 0);
  v10 = *(double *)(v3 + 488);
  if ( v6 == v10 )
  {
    ++*(_DWORD *)(v3 + 512);
    goto LABEL_5;
  }
  if ( v6 >= v10 )
  {
    if ( v10 != 0.0 )
    {
LABEL_5:
      v11 = *(double *)(v3 + 496);
      if ( v6 != v11 )
        goto LABEL_6;
LABEL_17:
      ++*(_DWORD *)(v3 + 516);
      return result;
    }
    *(double *)(v3 + 488) = v6;
    *(_DWORD *)(v3 + 512) = 1;
  }
  else
  {
    *(double *)(v3 + 488) = v6;
    *(_DWORD *)(v3 + 512) = 1;
  }
  v11 = *(double *)(v3 + 496);
  if ( v6 == v11 )
    goto LABEL_17;
LABEL_6:
  if ( v6 > v11 )
  {
    *(double *)(v3 + 496) = v6;
    *(_DWORD *)(v3 + 516) = 1;
  }
  return result;
}
// 11A78: variable 'v1' is possibly undefined
// 11AC4: variable 'v8' is possibly undefined
// 11B44: variable 'v14' is possibly undefined
// 11B58: variable 'v16' is possibly undefined
// 11B6C: variable 'v18' is possibly undefined
// 11B7C: variable 'v20' is possibly undefined
// ADD8: using guessed type int __fastcall round(_DWORD);
// 7B859: using guessed type char byte_7B859;

//----- (00011C1C) --------------------------------------------------------
void __fastcall __noreturn sub_11C1C(void *a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(5u);
  exit(1);
}

//----- (00011C44) --------------------------------------------------------
void __noreturn sub_11C44(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_76CF8, 0x200u, a1, varg_r1);
  sub_38730(3, byte_76CF8, 1);
  exit(1);
}

//----- (00011C8C) --------------------------------------------------------
int __fastcall sub_11C8C(int a1, int a2, int a3)
{
  int v6; // r3
  char v8[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(v8, 0x1000u, "Thread %d being disabled", a2);
    sub_38730(4, v8, 0);
  }
  v6 = (unsigned __int8)byte_78E09;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0;
  if ( v6 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    sub_38730(7, v8, 0);
  }
  sub_2F280((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 8561);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(v8, 0x1000u, "Thread %d being re-enabled", a2);
    sub_38730(4, v8, 0);
  }
  return (*(int (__fastcall **)(int))(a3 + 92))(a1);
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00011E24) --------------------------------------------------------
int __fastcall sub_11E24(int a1)
{
  _DWORD *v1; // r6
  int v3; // r5
  char v5[16]; // [sp+0h] [bp-1010h] BYREF
  char v6[4096]; // [sp+10h] [bp-1000h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v3 = v1[1];
  snprintf(v5, 0x10u, "%d/Miner", *(_DWORD *)a1);
  sub_2F0B4(v5);
  sub_FC58(a1);
  if ( (*(int (__fastcall **)(int))(v3 + 52))(a1) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v6, "Waiting on sem in miner thread");
      sub_38730(7, v6, 0);
    }
    sub_2F280((sem_t *)(a1 + 16), "cgminer.c", "miner_thread", 9147);
    v1[58] = time(0);
    (*(void (__fastcall **)(int))(v3 + 60))(a1);
    (*(void (__fastcall **)(int))(v3 + 88))(a1);
  }
  else
  {
    sub_2ED88(v1, 0);
  }
  return 0;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00011F60) --------------------------------------------------------
void __fastcall sub_11F60(int a1)
{
  int i; // r1
  int v2; // r4
  const char *v3; // r0
  char *v4; // r4
  _BYTE v5[32]; // [sp+0h] [bp-1070h] BYREF
  char v6[80]; // [sp+20h] [bp-1050h] BYREF
  char s[4096]; // [sp+70h] [bp-1000h] BYREF

  for ( i = 0; i != 80; i += 4 )
    *(_DWORD *)&v6[i] = bswap32(*(_DWORD *)(a1 + i));
  v2 = a1 + 192;
  sub_3049C(v6, 0x50u, (int)v5);
  sub_3049C(v5, 0x20u, v2);
  v3 = sub_29730(v2, 32);
  v4 = (char *)v3;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "regen:%s", v3);
    sub_38730(5, s, 0);
  }
  free(v4);
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00012038) --------------------------------------------------------
int __fastcall sub_12038(int a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // t1

  if ( dword_7B198 <= 0 )
    return sub_B340(a1);
  v1 = dword_7B438;
  v2 = *(_DWORD *)dword_7B438;
  if ( *(_DWORD *)(*(_DWORD *)dword_7B438 + 4) != a1 )
  {
    v3 = 0;
    while ( ++v3 != dword_7B198 )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return sub_B340(a1);
  }
  return v2;
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (000120A4) --------------------------------------------------------
void sub_120A4()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(v0, "Unable to set thread to low priority");
  sub_38730(7, v0, 0);
}

//----- (000120F4) --------------------------------------------------------
void sub_120F4()
{
  if ( !nice(10) && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    sub_120A4();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00012164) --------------------------------------------------------
int __fastcall sub_12164(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_2F0B4("API");
  sub_120F4();
  sub_36764(dword_76EF8);
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}
// 76EF8: using guessed type int dword_76EF8;

//----- (000121B0) --------------------------------------------------------
char *__fastcall sub_121B0(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_5B1E0(a1, a2);
  if ( !result && (*a2 < 100.0 || *a2 > 250.0) )
    return "Value out of range";
  return result;
}

//----- (00012200) --------------------------------------------------------
char *__fastcall sub_12200(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_5B1E0(a1, a2);
  if ( !result && (*a2 < 125.0 || *a2 > 500.0) )
    return "Value out of range";
  return result;
}

//----- (00012250) --------------------------------------------------------
int __fastcall sub_12250(int result)
{
  int v1; // r4
  int *v2; // r2
  int v3; // r12
  int v4; // r3
  int v5; // t1

  v1 = *(_DWORD *)(result + 188);
  if ( dword_7B198 > 0 )
  {
    v2 = (int *)dword_7B438;
    v3 = dword_7B438 + 4 * dword_7B198;
    do
    {
      while ( 1 )
      {
        v5 = *v2++;
        v4 = v5;
        if ( !*(_BYTE *)(v5 + 129) && *(_DWORD *)(v4 + 132) == 1 && (!*(_BYTE *)(v4 + 664) || *(_BYTE *)(v4 + 665)) )
          break;
        if ( v2 == (int *)v3 )
          goto LABEL_11;
      }
      if ( *(_DWORD *)(v4 + 188) < v1 )
      {
        result = v4;
        v1 = *(_DWORD *)(v4 + 188);
      }
    }
    while ( v2 != (int *)v3 );
LABEL_11:
    v1 = *(_DWORD *)(result + 188);
  }
  *(_DWORD *)(result + 188) = v1 + 1;
  return result;
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (000122E8) --------------------------------------------------------
int __fastcall sub_122E8(int *a1, int a2, int *a3)
{
  int v3; // r0
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int v7; // r10
  _DWORD *v8; // r3
  int *v9; // r2
  unsigned int v10; // lr
  unsigned int v11; // r12
  unsigned int v12; // r1
  unsigned int v13; // t1
  int v14; // r3
  int *v15; // r5
  int v16; // r7
  int i; // r3
  int v18; // r4
  int v19; // r3
  int v20; // r9
  int v21; // r7
  int v22; // r11
  int v23; // r0
  int v24; // r8
  int v25; // r2
  int v26; // r10
  int v27; // r1
  int v28; // r5
  bool v29; // zf
  int v30; // r11
  int v31; // r7
  int v32; // r9
  int v33; // r6
  int v34; // r3
  int v35; // r0
  int v36; // r1
  int v37; // r2
  int v38; // r5
  int v39; // r4
  int v40; // r12
  int v41; // lr
  int v42; // r7
  int v43; // lr
  int v44; // r6
  int v45; // r9
  int v46; // r11
  int v47; // r4
  int v48; // r12
  int v49; // r2
  int v50; // r1
  int v51; // r5
  int v52; // r8
  int v53; // r10
  int v54; // r2
  int v55; // r11
  int v56; // r9
  int v57; // lr
  int v58; // r5
  int v59; // r7
  int v60; // r6
  int v61; // r1
  int v62; // r3
  int v63; // r0
  int v64; // r3
  int v65; // r9
  int v66; // r7
  int v67; // r11
  int v68; // r0
  int v69; // r8
  int v70; // r2
  int v71; // r10
  int v72; // r1
  int v73; // r5
  int v74; // r4
  int v75; // r11
  int v76; // r7
  int v77; // r9
  int v78; // r6
  int v79; // r3
  int v80; // r0
  int v81; // r1
  int v82; // r2
  int v83; // r5
  int v84; // r4
  int v85; // r12
  int v86; // lr
  int v87; // lr
  int v88; // r9
  int v89; // r7
  int v90; // r11
  int v91; // r10
  int v92; // r4
  int v93; // r6
  int v94; // r1
  int v95; // r5
  int v96; // r8
  int v97; // r10
  int v98; // r11
  int v99; // r9
  int v100; // r7
  int v101; // lr
  int v102; // r6
  int v103; // r5
  int v104; // r12
  int v105; // r1
  int v106; // r0
  int v107; // r3
  int v108; // r2
  __int16 v109; // r2
  int *v110; // r1
  int v111; // r0
  __int64 v112; // t1
  int v113; // lr
  int v114; // r10
  int v115; // r2
  int v116; // r9
  int v117; // r11
  int v118; // r3
  int v119; // r6
  int v120; // r4
  int v121; // r5
  int v122; // r8
  int v123; // r10
  int v124; // r11
  int v125; // r9
  int v126; // r6
  int v127; // lr
  int v128; // r7
  int v129; // r5
  int v130; // r2
  int v131; // r3
  int v132; // r12
  int v133; // r1
  int v134; // r0
  int v135; // r7
  int v136; // r0
  int v137; // r2
  int v138; // r4
  int v139; // r9
  int v140; // r7
  int v141; // r11
  int v142; // r10
  int v143; // r6
  int v144; // r1
  int v145; // r5
  int v146; // lr
  int v147; // r8
  int v148; // r10
  int v149; // r1
  int v150; // r11
  int v151; // r7
  int v152; // r9
  int v153; // r5
  int v154; // r6
  int v155; // r12
  int v156; // lr
  int v157; // r0
  int v158; // r3
  int v159; // r2
  int *v160; // r12
  int v161; // lr
  __int64 v162; // t1
  int v163; // r10
  int v164; // r2
  int v165; // r9
  int v166; // r11
  int v167; // lr
  int v168; // r6
  int v169; // r3
  int v170; // r4
  int v171; // r5
  int v172; // r8
  int v173; // r10
  int v174; // r11
  int v175; // r9
  int v176; // r3
  int v177; // r6
  int v178; // r7
  int v179; // lr
  int v180; // r5
  int v181; // r2
  int v182; // r12
  int v183; // r1
  int v184; // r0
  int v185; // r7
  int v186; // r0
  int v187; // r12
  int v188; // r2
  int v189; // r5
  int v190; // r12
  int v191; // r9
  int v192; // r7
  int v193; // r11
  int v194; // r10
  int v195; // r4
  int v196; // r6
  int v197; // r1
  int v198; // r8
  int v199; // lr
  int v200; // r10
  int v201; // r9
  int v202; // r11
  int v203; // r7
  int v204; // r1
  int v205; // r5
  int v206; // r6
  int v207; // lr
  int v208; // r12
  int v209; // r0
  int v210; // r3
  int v211; // r2
  int v212; // r6
  int v213; // r1
  int v214; // r2
  int v215; // r3
  int v216; // r0
  int v217; // r1
  int v218; // r2
  int v219; // r3
  int v220; // r0
  int v221; // r1
  int v222; // r2
  int v223; // r3
  int v224; // r12
  int v225; // r3
  int v227; // [sp+4h] [bp-2C8h]
  int v228; // [sp+4h] [bp-2C8h]
  int v229; // [sp+4h] [bp-2C8h]
  int v230; // [sp+4h] [bp-2C8h]
  int v231; // [sp+4h] [bp-2C8h]
  int v232; // [sp+4h] [bp-2C8h]
  int v233; // [sp+4h] [bp-2C8h]
  int v234; // [sp+4h] [bp-2C8h]
  int v235; // [sp+4h] [bp-2C8h]
  int v236; // [sp+4h] [bp-2C8h]
  int v237; // [sp+4h] [bp-2C8h]
  int v238; // [sp+8h] [bp-2C4h]
  int v239; // [sp+8h] [bp-2C4h]
  int v240; // [sp+8h] [bp-2C4h]
  int v241; // [sp+8h] [bp-2C4h]
  int v242; // [sp+8h] [bp-2C4h]
  int v243; // [sp+8h] [bp-2C4h]
  int v244; // [sp+8h] [bp-2C4h]
  int v245; // [sp+8h] [bp-2C4h]
  int v246; // [sp+8h] [bp-2C4h]
  int v247; // [sp+8h] [bp-2C4h]
  int v248; // [sp+Ch] [bp-2C0h]
  int v249; // [sp+Ch] [bp-2C0h]
  int v250; // [sp+Ch] [bp-2C0h]
  int v251; // [sp+Ch] [bp-2C0h]
  int v252; // [sp+Ch] [bp-2C0h]
  int v253; // [sp+Ch] [bp-2C0h]
  int v254; // [sp+Ch] [bp-2C0h]
  int v255; // [sp+Ch] [bp-2C0h]
  int v256; // [sp+10h] [bp-2BCh]
  int v257; // [sp+10h] [bp-2BCh]
  int v258; // [sp+10h] [bp-2BCh]
  int v259; // [sp+10h] [bp-2BCh]
  int v260; // [sp+10h] [bp-2BCh]
  int v261; // [sp+10h] [bp-2BCh]
  int v262; // [sp+10h] [bp-2BCh]
  int v263; // [sp+10h] [bp-2BCh]
  int v264; // [sp+14h] [bp-2B8h]
  int v265; // [sp+14h] [bp-2B8h]
  int v266; // [sp+14h] [bp-2B8h]
  int v267; // [sp+14h] [bp-2B8h]
  int v268; // [sp+14h] [bp-2B8h]
  int v269; // [sp+14h] [bp-2B8h]
  int v270; // [sp+14h] [bp-2B8h]
  int v271; // [sp+14h] [bp-2B8h]
  int v272; // [sp+18h] [bp-2B4h]
  int v273; // [sp+18h] [bp-2B4h]
  int v274; // [sp+18h] [bp-2B4h]
  int v275; // [sp+18h] [bp-2B4h]
  int v276; // [sp+18h] [bp-2B4h]
  int v277; // [sp+18h] [bp-2B4h]
  int v278; // [sp+18h] [bp-2B4h]
  int v279; // [sp+18h] [bp-2B4h]
  int v280; // [sp+1Ch] [bp-2B0h]
  int v281; // [sp+1Ch] [bp-2B0h]
  int v282; // [sp+1Ch] [bp-2B0h]
  int v283; // [sp+1Ch] [bp-2B0h]
  int v284; // [sp+1Ch] [bp-2B0h]
  int v285; // [sp+1Ch] [bp-2B0h]
  int v286; // [sp+1Ch] [bp-2B0h]
  int v287; // [sp+1Ch] [bp-2B0h]
  int v288; // [sp+20h] [bp-2ACh]
  int v289; // [sp+20h] [bp-2ACh]
  int v290; // [sp+20h] [bp-2ACh]
  int v291; // [sp+20h] [bp-2ACh]
  int v292; // [sp+20h] [bp-2ACh]
  int v293; // [sp+20h] [bp-2ACh]
  int v294; // [sp+20h] [bp-2ACh]
  int v295; // [sp+20h] [bp-2ACh]
  int v296; // [sp+24h] [bp-2A8h]
  int v297; // [sp+24h] [bp-2A8h]
  int v298; // [sp+24h] [bp-2A8h]
  int v299; // [sp+24h] [bp-2A8h]
  int v300; // [sp+24h] [bp-2A8h]
  int v301; // [sp+24h] [bp-2A8h]
  int v302; // [sp+24h] [bp-2A8h]
  int v303; // [sp+24h] [bp-2A8h]
  int v304; // [sp+28h] [bp-2A4h]
  int v305; // [sp+28h] [bp-2A4h]
  int v306; // [sp+28h] [bp-2A4h]
  int v307; // [sp+28h] [bp-2A4h]
  int v308; // [sp+28h] [bp-2A4h]
  int v309; // [sp+28h] [bp-2A4h]
  int v310; // [sp+28h] [bp-2A4h]
  int v311; // [sp+28h] [bp-2A4h]
  int v312; // [sp+2Ch] [bp-2A0h]
  int v313; // [sp+2Ch] [bp-2A0h]
  int v314; // [sp+2Ch] [bp-2A0h]
  int v315; // [sp+2Ch] [bp-2A0h]
  int v316; // [sp+2Ch] [bp-2A0h]
  int v317; // [sp+2Ch] [bp-2A0h]
  int v318; // [sp+30h] [bp-29Ch]
  int v319; // [sp+30h] [bp-29Ch]
  int v320; // [sp+30h] [bp-29Ch]
  int v321; // [sp+30h] [bp-29Ch]
  int v322; // [sp+30h] [bp-29Ch]
  int v323; // [sp+30h] [bp-29Ch]
  int v324; // [sp+34h] [bp-298h]
  int v325; // [sp+34h] [bp-298h]
  int v326; // [sp+34h] [bp-298h]
  int v327; // [sp+34h] [bp-298h]
  int v328; // [sp+34h] [bp-298h]
  int v329; // [sp+34h] [bp-298h]
  int v330; // [sp+38h] [bp-294h]
  int v331; // [sp+38h] [bp-294h]
  int v332; // [sp+38h] [bp-294h]
  int v333; // [sp+38h] [bp-294h]
  int v334; // [sp+38h] [bp-294h]
  int v335; // [sp+38h] [bp-294h]
  int v336; // [sp+3Ch] [bp-290h]
  int v337; // [sp+3Ch] [bp-290h]
  int v338; // [sp+3Ch] [bp-290h]
  int v339; // [sp+3Ch] [bp-290h]
  int v340; // [sp+3Ch] [bp-290h]
  int v341; // [sp+3Ch] [bp-290h]
  int v342; // [sp+40h] [bp-28Ch]
  int v343; // [sp+40h] [bp-28Ch]
  int v344; // [sp+40h] [bp-28Ch]
  int v345; // [sp+40h] [bp-28Ch]
  int v346; // [sp+40h] [bp-28Ch]
  int v347; // [sp+40h] [bp-28Ch]
  int v348; // [sp+44h] [bp-288h]
  int v349; // [sp+44h] [bp-288h]
  int v350; // [sp+44h] [bp-288h]
  int v351; // [sp+44h] [bp-288h]
  int v352; // [sp+44h] [bp-288h]
  int v353; // [sp+44h] [bp-288h]
  int v354; // [sp+48h] [bp-284h]
  int v355; // [sp+48h] [bp-284h]
  int v356; // [sp+48h] [bp-284h]
  int v357; // [sp+48h] [bp-284h]
  int v358; // [sp+48h] [bp-284h]
  int v359; // [sp+48h] [bp-284h]
  int v360; // [sp+4Ch] [bp-280h]
  int v361; // [sp+4Ch] [bp-280h]
  int v362; // [sp+4Ch] [bp-280h]
  int v363; // [sp+4Ch] [bp-280h]
  int v364; // [sp+4Ch] [bp-280h]
  int v365; // [sp+4Ch] [bp-280h]
  int v366; // [sp+50h] [bp-27Ch]
  int v367; // [sp+50h] [bp-27Ch]
  int v368; // [sp+50h] [bp-27Ch]
  int v369; // [sp+50h] [bp-27Ch]
  int v370; // [sp+50h] [bp-27Ch]
  int v371; // [sp+50h] [bp-27Ch]
  int v372; // [sp+54h] [bp-278h]
  int v373; // [sp+54h] [bp-278h]
  int v374; // [sp+54h] [bp-278h]
  int v375; // [sp+54h] [bp-278h]
  int v376; // [sp+54h] [bp-278h]
  int v377; // [sp+54h] [bp-278h]
  int v378; // [sp+58h] [bp-274h]
  int v379; // [sp+58h] [bp-274h]
  int v380; // [sp+58h] [bp-274h]
  int v381; // [sp+58h] [bp-274h]
  int v382; // [sp+58h] [bp-274h]
  int v383; // [sp+58h] [bp-274h]
  int v384; // [sp+5Ch] [bp-270h]
  int v385; // [sp+5Ch] [bp-270h]
  int v386; // [sp+5Ch] [bp-270h]
  int v387; // [sp+5Ch] [bp-270h]
  int v388; // [sp+5Ch] [bp-270h]
  int v389; // [sp+5Ch] [bp-270h]
  int v390; // [sp+60h] [bp-26Ch]
  int v391; // [sp+60h] [bp-26Ch]
  int v392; // [sp+60h] [bp-26Ch]
  int v393; // [sp+60h] [bp-26Ch]
  int v394; // [sp+60h] [bp-26Ch]
  int v395; // [sp+60h] [bp-26Ch]
  int v396; // [sp+64h] [bp-268h]
  int v397; // [sp+64h] [bp-268h]
  int v398; // [sp+64h] [bp-268h]
  int v399; // [sp+64h] [bp-268h]
  int v400; // [sp+64h] [bp-268h]
  int v401; // [sp+64h] [bp-268h]
  int v402; // [sp+68h] [bp-264h]
  int v403; // [sp+68h] [bp-264h]
  int v404; // [sp+68h] [bp-264h]
  int v405; // [sp+68h] [bp-264h]
  int v406; // [sp+68h] [bp-264h]
  int v407; // [sp+68h] [bp-264h]
  int v408; // [sp+6Ch] [bp-260h]
  int v409; // [sp+6Ch] [bp-260h]
  int v410; // [sp+6Ch] [bp-260h]
  int v411; // [sp+6Ch] [bp-260h]
  int v412; // [sp+6Ch] [bp-260h]
  int v413; // [sp+6Ch] [bp-260h]
  int v414; // [sp+70h] [bp-25Ch]
  int v415; // [sp+70h] [bp-25Ch]
  int v416; // [sp+70h] [bp-25Ch]
  int v417; // [sp+70h] [bp-25Ch]
  int v418; // [sp+70h] [bp-25Ch]
  int v419; // [sp+70h] [bp-25Ch]
  int v420; // [sp+74h] [bp-258h]
  int v421; // [sp+74h] [bp-258h]
  int v422; // [sp+74h] [bp-258h]
  int v423; // [sp+74h] [bp-258h]
  int v424; // [sp+74h] [bp-258h]
  int v425; // [sp+74h] [bp-258h]
  int v426; // [sp+78h] [bp-254h]
  int v427; // [sp+78h] [bp-254h]
  int v428; // [sp+78h] [bp-254h]
  int v429; // [sp+78h] [bp-254h]
  int v430; // [sp+78h] [bp-254h]
  int v431; // [sp+78h] [bp-254h]
  int v432; // [sp+7Ch] [bp-250h]
  int v433; // [sp+7Ch] [bp-250h]
  int v434; // [sp+7Ch] [bp-250h]
  int v435; // [sp+7Ch] [bp-250h]
  int v436; // [sp+7Ch] [bp-250h]
  int v437; // [sp+7Ch] [bp-250h]
  int v438; // [sp+80h] [bp-24Ch]
  int v439; // [sp+80h] [bp-24Ch]
  int v440; // [sp+80h] [bp-24Ch]
  int v441; // [sp+80h] [bp-24Ch]
  int v442; // [sp+80h] [bp-24Ch]
  int v443; // [sp+80h] [bp-24Ch]
  int v444; // [sp+80h] [bp-24Ch]
  int v445; // [sp+80h] [bp-24Ch]
  int v446; // [sp+84h] [bp-248h]
  int v447; // [sp+84h] [bp-248h]
  int v448; // [sp+84h] [bp-248h]
  int v449; // [sp+84h] [bp-248h]
  int v450; // [sp+84h] [bp-248h]
  int v451; // [sp+84h] [bp-248h]
  int v452; // [sp+88h] [bp-244h]
  int v453; // [sp+88h] [bp-244h]
  int v454; // [sp+88h] [bp-244h]
  int v455; // [sp+88h] [bp-244h]
  int v456; // [sp+88h] [bp-244h]
  int v457; // [sp+88h] [bp-244h]
  int v458; // [sp+88h] [bp-244h]
  int v459; // [sp+88h] [bp-244h]
  int v460; // [sp+8Ch] [bp-240h]
  int v461; // [sp+8Ch] [bp-240h]
  int v462; // [sp+8Ch] [bp-240h]
  int v463; // [sp+8Ch] [bp-240h]
  int v464; // [sp+8Ch] [bp-240h]
  int v465; // [sp+8Ch] [bp-240h]
  int v466; // [sp+90h] [bp-23Ch]
  int v467; // [sp+90h] [bp-23Ch]
  int v468; // [sp+90h] [bp-23Ch]
  int v469; // [sp+90h] [bp-23Ch]
  int v470; // [sp+90h] [bp-23Ch]
  int v471; // [sp+90h] [bp-23Ch]
  int v472; // [sp+94h] [bp-238h]
  int v473; // [sp+94h] [bp-238h]
  int v474; // [sp+94h] [bp-238h]
  int v475; // [sp+94h] [bp-238h]
  int v476; // [sp+98h] [bp-234h]
  int v477; // [sp+98h] [bp-234h]
  int v478; // [sp+98h] [bp-234h]
  int v479; // [sp+98h] [bp-234h]
  int v480; // [sp+98h] [bp-234h]
  int v481; // [sp+98h] [bp-234h]
  int v482; // [sp+9Ch] [bp-230h]
  int v483; // [sp+9Ch] [bp-230h]
  int v484; // [sp+9Ch] [bp-230h]
  int v485; // [sp+9Ch] [bp-230h]
  int v486; // [sp+A0h] [bp-22Ch]
  int v487; // [sp+A0h] [bp-22Ch]
  int v488; // [sp+A0h] [bp-22Ch]
  int v489; // [sp+A0h] [bp-22Ch]
  int v490; // [sp+A0h] [bp-22Ch]
  int v491; // [sp+A0h] [bp-22Ch]
  int v492; // [sp+A4h] [bp-228h]
  int v493; // [sp+A4h] [bp-228h]
  int v494; // [sp+A4h] [bp-228h]
  int v495; // [sp+A4h] [bp-228h]
  int v496; // [sp+A8h] [bp-224h]
  int v497; // [sp+A8h] [bp-224h]
  int v498; // [sp+A8h] [bp-224h]
  int v499; // [sp+A8h] [bp-224h]
  int v500; // [sp+A8h] [bp-224h]
  int v501; // [sp+A8h] [bp-224h]
  char *dest; // [sp+ACh] [bp-220h]
  int desta; // [sp+ACh] [bp-220h]
  int v504; // [sp+B0h] [bp-21Ch]
  char *v505; // [sp+B4h] [bp-218h]
  char *v506; // [sp+B8h] [bp-214h]
  int *v509; // [sp+C0h] [bp-20Ch]
  int v511; // [sp+C8h] [bp-204h] BYREF
  int v512; // [sp+CCh] [bp-200h]
  int v513; // [sp+D0h] [bp-1FCh]
  int v514; // [sp+D4h] [bp-1F8h]
  int v515; // [sp+D8h] [bp-1F4h]
  int v516; // [sp+DCh] [bp-1F0h]
  int v517; // [sp+E0h] [bp-1ECh]
  int v518; // [sp+E4h] [bp-1E8h]
  _DWORD v519[8]; // [sp+E8h] [bp-1E4h]
  int v520; // [sp+108h] [bp-1C4h] BYREF
  int v521; // [sp+10Ch] [bp-1C0h]
  int v522; // [sp+110h] [bp-1BCh]
  int v523; // [sp+114h] [bp-1B8h]
  int v524; // [sp+118h] [bp-1B4h]
  int v525; // [sp+11Ch] [bp-1B0h]
  int v526; // [sp+120h] [bp-1ACh]
  int v527; // [sp+124h] [bp-1A8h]
  int v528[8]; // [sp+128h] [bp-1A4h] BYREF
  int v529; // [sp+148h] [bp-184h] BYREF
  int v530; // [sp+14Ch] [bp-180h]
  int v531; // [sp+150h] [bp-17Ch]
  int v532; // [sp+154h] [bp-178h]
  int v533; // [sp+158h] [bp-174h]
  int v534; // [sp+15Ch] [bp-170h]
  int v535; // [sp+160h] [bp-16Ch]
  int v536; // [sp+164h] [bp-168h]
  _DWORD v537[8]; // [sp+168h] [bp-164h] BYREF
  int v538; // [sp+188h] [bp-144h] BYREF
  int v539; // [sp+18Ch] [bp-140h]
  int v540; // [sp+190h] [bp-13Ch]
  int v541; // [sp+194h] [bp-138h]
  int v542; // [sp+198h] [bp-134h]
  int v543; // [sp+19Ch] [bp-130h]
  int v544; // [sp+1A0h] [bp-12Ch]
  int v545; // [sp+1A4h] [bp-128h]
  int v546[4]; // [sp+1A8h] [bp-124h] BYREF
  int v547; // [sp+1B8h] [bp-114h] BYREF
  int v548; // [sp+1E8h] [bp-E4h] BYREF
  int v549; // [sp+1ECh] [bp-E0h]
  int v550; // [sp+1F0h] [bp-DCh]
  int v551; // [sp+1F4h] [bp-D8h]
  int v552; // [sp+1F8h] [bp-D4h]
  int v553; // [sp+1FCh] [bp-D0h]
  int v554; // [sp+200h] [bp-CCh]
  int v555; // [sp+204h] [bp-C8h]
  int v556[16]; // [sp+208h] [bp-C4h] BYREF
  int src[32]; // [sp+248h] [bp-84h] BYREF
  char v558; // [sp+2C8h] [bp-4h] BYREF

  dest = (char *)((a2 + 63) & 0xFFFFFFC0);
  v511 = 1779033703;
  v512 = -1150833019;
  v513 = 1013904242;
  v514 = -1521486534;
  v515 = 1359893119;
  v516 = -1694144372;
  v517 = 528734635;
  v518 = 1541459225;
  sub_FC90(&v511, a1, 1);
  v3 = a1[16];
  v509 = a1 + 16;
  v4 = v509[1];
  v5 = v509[2];
  v6 = v509[3];
  v529 = v3;
  v530 = v4;
  v531 = v5;
  v532 = v6;
  v533 = 128;
  v534 = 0;
  v535 = 0;
  v536 = 0;
  v505 = dest;
  memset(v537, 0, 28);
  v537[7] = -2147352576;
  sub_FC90(&v511, &v529, 1);
  v541 = -1521486534;
  v542 = 1359893119;
  v519[0] = v511;
  v519[1] = v512;
  v519[2] = v513;
  v519[3] = v514;
  v538 = 1779033703;
  v7 = 0;
  v539 = -1150833019;
  v540 = 1013904242;
  v543 = -1694144372;
  v544 = 528734635;
  v545 = 1541459225;
  v519[4] = v515;
  v519[5] = v516;
  v519[6] = v517;
  v519[7] = v518;
  do
  {
    *(int *)((char *)&v529 + v7 * 4) = v519[v7] ^ 0x36363636;
    ++v7;
  }
  while ( v7 != 8 );
  memset(v537, 54, sizeof(v537));
  sub_FC90(&v538, &v529, 0);
  sub_FC90(&v538, a1, 1);
  v8 = &unk_5D5FC;
  v9 = &v547;
  v10 = a1[17];
  v11 = a1[18];
  v546[0] = bswap32(a1[16]);
  v12 = a1[19];
  v546[1] = bswap32(v10);
  v546[2] = bswap32(v11);
  v546[3] = bswap32(v12);
  do
  {
    v13 = v8[1];
    ++v8;
    v9[1] = bswap32(v13);
    ++v9;
  }
  while ( v8 != (_DWORD *)&unk_5D628 );
  v14 = 0;
  v548 = 1779033703;
  v549 = -1150833019;
  v550 = 1013904242;
  v551 = -1521486534;
  v552 = 1359893119;
  v553 = -1694144372;
  v554 = 528734635;
  v555 = 1541459225;
  do
  {
    *(int *)((char *)&v529 + v14 * 4) = v519[v14] ^ 0x5C5C5C5C;
    ++v14;
  }
  while ( v14 != 8 );
  memset(v537, 92, sizeof(v537));
  sub_FC90(&v548, &v529, 0);
  v15 = src;
  v16 = 0;
  v556[8] = 0x80000000;
  memset(&v556[9], 0, 24);
  v556[15] = 768;
  do
  {
    ++v16;
    v520 = v538;
    v521 = v539;
    v522 = v540;
    v523 = v541;
    v547 = v16;
    v524 = v542;
    v525 = v543;
    v526 = v544;
    v527 = v545;
    sub_FC90(&v520, v546, 0);
    v556[0] = v520;
    v556[1] = v521;
    v556[2] = v522;
    v556[3] = v523;
    v556[4] = v524;
    v556[5] = v525;
    v556[6] = v526;
    v556[7] = v527;
    v528[0] = v548;
    v528[1] = v549;
    v528[2] = v550;
    v528[3] = v551;
    v528[4] = v552;
    v528[5] = v553;
    v528[6] = v554;
    v528[7] = v555;
    sub_FC90(v528, v556, 0);
    for ( i = 0; i != 8; ++i )
      v15[i] = bswap32(v528[i]);
    v15 += 8;
  }
  while ( v16 != 4 );
  v318 = src[0];
  v506 = dest + 0x20000;
  v312 = src[16];
  v324 = src[1];
  v414 = src[17];
  v330 = src[2];
  v420 = src[18];
  v336 = src[3];
  v426 = src[19];
  v342 = src[4];
  v432 = src[20];
  v348 = src[5];
  v438 = src[21];
  v354 = src[6];
  v446 = src[22];
  v360 = src[7];
  v452 = src[23];
  v366 = src[8];
  v460 = src[24];
  v372 = src[9];
  v466 = src[25];
  v378 = src[10];
  v472 = src[26];
  v384 = src[11];
  v476 = src[27];
  v390 = src[12];
  v482 = src[28];
  v396 = src[13];
  v486 = src[29];
  v402 = src[14];
  v492 = src[30];
  v408 = src[15];
  v496 = src[31];
  do
  {
    memcpy(dest, src, 0x80u);
    v319 = v312 ^ v318;
    v325 = v414 ^ v324;
    v331 = v420 ^ v330;
    v337 = v426 ^ v336;
    v343 = v432 ^ v342;
    v349 = v438 ^ v348;
    v355 = v446 ^ v354;
    v361 = v452 ^ v360;
    v367 = v460 ^ v366;
    v373 = v466 ^ v372;
    v379 = v472 ^ v378;
    v385 = v476 ^ v384;
    v264 = v385;
    v397 = v486 ^ v396;
    v409 = v496 ^ v408;
    v288 = v397;
    v18 = v409;
    v256 = v355;
    v19 = v492 ^ v402;
    v20 = v361;
    v21 = v331;
    v22 = v367;
    v23 = v337;
    v24 = v379;
    v25 = v373;
    v26 = v325;
    v27 = v343;
    v28 = v319;
    v391 = v482 ^ v390;
    v248 = v391;
    v403 = v492 ^ v402;
    v296 = v349;
    v304 = 4;
    do
    {
      v227 = v27 ^ __ROR4__(v248 + v28, 25);
      v272 = v19 ^ __ROR4__(v256 + v24, 25);
      v29 = v304-- == 1;
      v238 = v25 ^ __ROR4__(v26 + v296, 25);
      v280 = v23 ^ __ROR4__(v264 + v18, 25);
      v30 = v22 ^ __ROR4__(v227 + v28, 23);
      v31 = v21 ^ __ROR4__(v272 + v24, 23);
      v32 = v20 ^ __ROR4__(v280 + v18, 23);
      v33 = v248 ^ __ROR4__(v30 + v227, 19);
      v34 = v288 ^ __ROR4__(v238 + v296, 23);
      v35 = v264 ^ __ROR4__(v32 + v280, 19);
      v36 = v256 ^ __ROR4__(v31 + v272, 19);
      v37 = v26 ^ __ROR4__(v34 + v238, 19);
      v38 = v28 ^ __ROR4__(v33 + v30, 14);
      v39 = v18 ^ __ROR4__(v35 + v32, 14);
      v40 = v24 ^ __ROR4__(v36 + v31, 14);
      v41 = v296 ^ __ROR4__(v37 + v34, 14);
      v248 = v33 ^ __ROR4__(v39 + v272, 25);
      v264 = v35 ^ __ROR4__(v40 + v238, 25);
      v256 = v36 ^ __ROR4__(v41 + v227, 25);
      v26 = v37 ^ __ROR4__(v38 + v280, 25);
      v22 = v30 ^ __ROR4__(v264 + v40, 23);
      v20 = v32 ^ __ROR4__(v256 + v41, 23);
      v21 = v31 ^ __ROR4__(v26 + v38, 23);
      v288 = v34 ^ __ROR4__(v248 + v39, 23);
      v23 = v280 ^ __ROR4__(v21 + v26, 19);
      v27 = v227 ^ __ROR4__(v20 + v256, 19);
      v25 = v238 ^ __ROR4__(v22 + v264, 19);
      v19 = v272 ^ __ROR4__(v288 + v248, 19);
      v28 = v38 ^ __ROR4__(v23 + v21, 14);
      v296 = v41 ^ __ROR4__(v27 + v20, 14);
      v24 = v40 ^ __ROR4__(v25 + v22, 14);
      v18 = v39 ^ __ROR4__(v19 + v288, 14);
    }
    while ( !v29 );
    v320 = v28 + v319;
    v326 = v26 + v325;
    v332 = v21 + v331;
    v338 = v23 + v337;
    v344 = v27 + v343;
    v350 = v296 + v349;
    v356 = v256 + v355;
    v362 = v20 + v361;
    v380 = v24 + v379;
    v368 = v22 + v367;
    v374 = v25 + v373;
    v386 = v264 + v385;
    v392 = v248 + v391;
    v398 = v288 + v397;
    v404 = v19 + v403;
    v410 = v18 + v409;
    v415 = v326 ^ v414;
    v421 = v332 ^ v420;
    v427 = v338 ^ v426;
    v433 = v344 ^ v432;
    v504 = v320 ^ v312;
    v439 = v350 ^ v438;
    v447 = v356 ^ v446;
    v453 = v362 ^ v452;
    v461 = v368 ^ v460;
    v467 = v374 ^ v466;
    v473 = v380 ^ v472;
    v493 = v404 ^ v492;
    v42 = v493;
    v257 = v415;
    v313 = 4;
    v483 = v392 ^ v482;
    v497 = v410 ^ v496;
    v43 = v398 ^ v486;
    v477 = v386 ^ v476;
    v487 = v398 ^ v486;
    v265 = v477;
    v281 = v473;
    v44 = v453;
    v45 = v421;
    v46 = v461;
    v47 = v497;
    v48 = v447;
    v49 = v467;
    v273 = v439;
    v50 = v433;
    v51 = v483;
    src[0] = v320;
    v305 = v427;
    v52 = v504;
    src[1] = v326;
    src[2] = v332;
    src[3] = v338;
    src[4] = v344;
    src[5] = v350;
    src[6] = v356;
    src[7] = v362;
    src[8] = v368;
    src[9] = v374;
    src[10] = v380;
    src[11] = v386;
    src[12] = v392;
    src[13] = v398;
    src[14] = v404;
    src[15] = v410;
    do
    {
      v249 = v50 ^ __ROR4__(v51 + v52, 25);
      v239 = v42 ^ __ROR4__(v48 + v281, 25);
      v29 = v313-- == 1;
      v53 = v305 ^ __ROR4__(v265 + v47, 25);
      v228 = v49 ^ __ROR4__(v257 + v273, 25);
      v54 = v44 ^ __ROR4__(v53 + v47, 23);
      v55 = v46 ^ __ROR4__(v249 + v52, 23);
      v56 = v45 ^ __ROR4__(v239 + v281, 23);
      v57 = v43 ^ __ROR4__(v228 + v273, 23);
      v58 = v51 ^ __ROR4__(v55 + v249, 19);
      v59 = v265 ^ __ROR4__(v54 + v53, 19);
      v60 = v48 ^ __ROR4__(v56 + v239, 19);
      v61 = v257 ^ __ROR4__(v57 + v228, 19);
      v297 = v47 ^ __ROR4__(v59 + v54, 14);
      v62 = v281 ^ __ROR4__(v60 + v56, 14);
      v289 = v52 ^ __ROR4__(v58 + v55, 14);
      v63 = v273 ^ __ROR4__(v61 + v57, 14);
      v51 = v58 ^ __ROR4__(v297 + v239, 25);
      v265 = v59 ^ __ROR4__(v62 + v228, 25);
      v48 = v60 ^ __ROR4__(v63 + v249, 25);
      v257 = v61 ^ __ROR4__(v289 + v53, 25);
      v46 = v55 ^ __ROR4__(v265 + v62, 23);
      v44 = v54 ^ __ROR4__(v48 + v63, 23);
      v45 = v56 ^ __ROR4__(v257 + v289, 23);
      v43 = v57 ^ __ROR4__(v51 + v297, 23);
      v305 = v53 ^ __ROR4__(v45 + v257, 19);
      v42 = v239 ^ __ROR4__(v43 + v51, 19);
      v50 = v249 ^ __ROR4__(v44 + v48, 19);
      v49 = v228 ^ __ROR4__(v46 + v265, 19);
      v52 = v289 ^ __ROR4__(v305 + v45, 14);
      v273 = v63 ^ __ROR4__(v50 + v44, 14);
      v281 = v62 ^ __ROR4__(v49 + v46, 14);
      v47 = v297 ^ __ROR4__(v42 + v43, 14);
    }
    while ( !v29 );
    v314 = v52 + v504;
    v416 = v257 + v415;
    v428 = v305 + v427;
    v434 = v50 + v433;
    v422 = v45 + v421;
    v454 = v44 + v453;
    v440 = v273 + v439;
    v448 = v48 + v447;
    v468 = v49 + v467;
    v488 = v43 + v487;
    v462 = v46 + v461;
    v474 = v281 + v473;
    v478 = v265 + v477;
    v484 = v51 + v483;
    v494 = v42 + v493;
    v498 = v47 + v497;
    src[16] = v52 + v504;
    src[17] = v416;
    src[18] = v422;
    src[19] = v428;
    src[20] = v434;
    src[21] = v440;
    src[22] = v448;
    src[23] = v454;
    src[24] = v462;
    src[25] = v468;
    src[26] = v474;
    src[27] = v478;
    src[28] = v484;
    src[29] = v488;
    src[30] = v494;
    src[31] = v498;
    memcpy(dest + 128, src, 0x80u);
    v321 = (v52 + v504) ^ v320;
    v327 = v416 ^ v326;
    v333 = v422 ^ v332;
    v339 = v428 ^ v338;
    v345 = v434 ^ v344;
    v351 = v440 ^ v350;
    v357 = v448 ^ v356;
    v363 = v454 ^ v362;
    v369 = v462 ^ v368;
    v375 = v468 ^ v374;
    v381 = v474 ^ v380;
    v387 = v478 ^ v386;
    v393 = v484 ^ v392;
    v399 = v488 ^ v398;
    v405 = v494 ^ v404;
    v64 = v405;
    v290 = v399;
    v258 = v357;
    v65 = v363;
    v66 = v333;
    v67 = v369;
    v68 = v339;
    v69 = v381;
    v70 = v375;
    v71 = v327;
    v72 = v345;
    v73 = v321;
    v411 = v498 ^ v410;
    v266 = v387;
    v74 = v411;
    v298 = v351;
    v250 = v393;
    v306 = 4;
    do
    {
      v229 = v72 ^ __ROR4__(v250 + v73, 25);
      v274 = v64 ^ __ROR4__(v258 + v69, 25);
      v29 = v306-- == 1;
      v240 = v70 ^ __ROR4__(v71 + v298, 25);
      v282 = v68 ^ __ROR4__(v266 + v74, 25);
      v75 = v67 ^ __ROR4__(v229 + v73, 23);
      v76 = v66 ^ __ROR4__(v274 + v69, 23);
      v77 = v65 ^ __ROR4__(v282 + v74, 23);
      v78 = v250 ^ __ROR4__(v75 + v229, 19);
      v79 = v290 ^ __ROR4__(v240 + v298, 23);
      v80 = v266 ^ __ROR4__(v77 + v282, 19);
      v81 = v258 ^ __ROR4__(v76 + v274, 19);
      v82 = v71 ^ __ROR4__(v79 + v240, 19);
      v83 = v73 ^ __ROR4__(v78 + v75, 14);
      v84 = v74 ^ __ROR4__(v80 + v77, 14);
      v85 = v69 ^ __ROR4__(v81 + v76, 14);
      v86 = v298 ^ __ROR4__(v82 + v79, 14);
      v250 = v78 ^ __ROR4__(v84 + v274, 25);
      v266 = v80 ^ __ROR4__(v85 + v240, 25);
      v258 = v81 ^ __ROR4__(v86 + v229, 25);
      v71 = v82 ^ __ROR4__(v83 + v282, 25);
      v67 = v75 ^ __ROR4__(v266 + v85, 23);
      v65 = v77 ^ __ROR4__(v258 + v86, 23);
      v66 = v76 ^ __ROR4__(v71 + v83, 23);
      v290 = v79 ^ __ROR4__(v250 + v84, 23);
      v68 = v282 ^ __ROR4__(v66 + v71, 19);
      v72 = v229 ^ __ROR4__(v65 + v258, 19);
      v70 = v240 ^ __ROR4__(v67 + v266, 19);
      v64 = v274 ^ __ROR4__(v290 + v250, 19);
      v73 = v83 ^ __ROR4__(v68 + v66, 14);
      v298 = v86 ^ __ROR4__(v72 + v65, 14);
      v69 = v85 ^ __ROR4__(v70 + v67, 14);
      v74 = v84 ^ __ROR4__(v64 + v290, 14);
    }
    while ( !v29 );
    v318 = v73 + v321;
    v324 = v71 + v327;
    v330 = v66 + v333;
    v336 = v68 + v339;
    v342 = v72 + v345;
    v348 = v298 + v351;
    v354 = v258 + v357;
    v360 = v65 + v363;
    v378 = v69 + v381;
    v366 = v67 + v369;
    v372 = v70 + v375;
    v384 = v266 + v387;
    v390 = v250 + v393;
    v396 = v290 + v399;
    v402 = v64 + v405;
    v408 = v74 + v411;
    v417 = v324 ^ v416;
    v423 = v330 ^ v422;
    v429 = v336 ^ v428;
    v435 = v342 ^ v434;
    v315 = v318 ^ v314;
    v441 = v348 ^ v440;
    v449 = v354 ^ v448;
    v455 = v360 ^ v454;
    v463 = v366 ^ v462;
    v469 = v372 ^ v468;
    v475 = v378 ^ v474;
    v485 = v390 ^ v484;
    v495 = v402 ^ v494;
    v499 = v408 ^ v498;
    v87 = v396 ^ v488;
    v479 = v384 ^ v478;
    v489 = v396 ^ v488;
    v267 = v449;
    v291 = v475;
    v259 = v417;
    v88 = v455;
    v89 = v423;
    v90 = v463;
    v91 = v429;
    v92 = v499;
    v93 = v469;
    v283 = v441;
    v94 = v435;
    v307 = 4;
    v251 = v485;
    v95 = v479;
    src[0] = v318;
    src[1] = v324;
    src[2] = v330;
    src[3] = v336;
    src[4] = v342;
    src[5] = v348;
    src[6] = v354;
    src[7] = v360;
    src[8] = v366;
    src[9] = v372;
    src[10] = v378;
    src[11] = v384;
    src[12] = v390;
    src[13] = v396;
    src[14] = v402;
    src[15] = v408;
    v241 = v495;
    v96 = v315;
    do
    {
      v230 = v94 ^ __ROR4__(v251 + v96, 25);
      v29 = v307-- == 1;
      v97 = v91 ^ __ROR4__(v95 + v92, 25);
      v275 = v241 ^ __ROR4__(v267 + v291, 25);
      v242 = v93 ^ __ROR4__(v259 + v283, 25);
      v98 = v90 ^ __ROR4__(v230 + v96, 23);
      v99 = v88 ^ __ROR4__(v97 + v92, 23);
      v100 = v89 ^ __ROR4__(v275 + v291, 23);
      v101 = v87 ^ __ROR4__(v242 + v283, 23);
      v102 = v251 ^ __ROR4__(v98 + v230, 19);
      v103 = v95 ^ __ROR4__(v99 + v97, 19);
      v104 = v267 ^ __ROR4__(v100 + v275, 19);
      v105 = v259 ^ __ROR4__(v101 + v242, 19);
      v106 = v96 ^ __ROR4__(v102 + v98, 14);
      v299 = v92 ^ __ROR4__(v103 + v99, 14);
      v107 = v291 ^ __ROR4__(v104 + v100, 14);
      v108 = v283 ^ __ROR4__(v105 + v101, 14);
      v95 = v103 ^ __ROR4__(v107 + v242, 25);
      v251 = v102 ^ __ROR4__(v299 + v275, 25);
      v267 = v104 ^ __ROR4__(v108 + v230, 25);
      v259 = v105 ^ __ROR4__(v106 + v97, 25);
      v90 = v98 ^ __ROR4__(v95 + v107, 23);
      v88 = v99 ^ __ROR4__(v267 + v108, 23);
      v89 = v100 ^ __ROR4__(v259 + v106, 23);
      v87 = v101 ^ __ROR4__(v251 + v299, 23);
      v91 = v97 ^ __ROR4__(v89 + v259, 19);
      v94 = v230 ^ __ROR4__(v88 + v267, 19);
      v93 = v242 ^ __ROR4__(v90 + v95, 19);
      v241 = v275 ^ __ROR4__(v87 + v251, 19);
      v96 = v106 ^ __ROR4__(v91 + v89, 14);
      v291 = v107 ^ __ROR4__(v93 + v90, 14);
      v283 = v108 ^ __ROR4__(v94 + v88, 14);
      v92 = v299 ^ __ROR4__(v241 + v87, 14);
    }
    while ( !v29 );
    v312 = v96 + v315;
    dest += 256;
    src[16] = v312;
    v420 = v89 + v423;
    v414 = v259 + v417;
    src[17] = v414;
    src[18] = v420;
    v426 = v91 + v429;
    src[19] = v426;
    v438 = v283 + v441;
    src[21] = v438;
    v432 = v94 + v435;
    src[20] = v432;
    v452 = v88 + v455;
    v446 = v267 + v449;
    src[22] = v446;
    v460 = v90 + v463;
    v466 = v93 + v469;
    src[23] = v452;
    v476 = v95 + v479;
    src[27] = v476;
    src[24] = v460;
    v472 = v291 + v475;
    src[25] = v466;
    src[26] = v472;
    v482 = v251 + v485;
    v486 = v87 + v489;
    src[28] = v482;
    v492 = v241 + v495;
    src[29] = v486;
    v496 = v92 + v499;
    src[30] = v492;
    src[31] = v496;
  }
  while ( dest != v506 );
  v109 = v312;
  desta = 512;
  do
  {
    v110 = src;
    v111 = (int)&v505[128 * (v109 & 0x3FF) - 8];
    do
    {
      v112 = *(_QWORD *)(v111 + 8);
      v111 += 8;
      *(_QWORD *)v110 ^= v112;
      v110 += 2;
    }
    while ( v110 != (int *)&v558 );
    v346 = src[18] ^ src[2];
    v334 = src[17] ^ src[1];
    v322 = src[16] ^ src[0];
    v370 = src[20] ^ src[4];
    v358 = src[19] ^ src[3];
    v308 = 4;
    v260 = src[17] ^ src[1];
    v382 = src[21] ^ src[5];
    v113 = src[18] ^ src[2];
    v114 = src[19] ^ src[3];
    v394 = src[22] ^ src[6];
    v406 = src[23] ^ src[7];
    v418 = src[24] ^ src[8];
    v442 = src[26] ^ src[10];
    v268 = src[22] ^ src[6];
    v456 = src[27] ^ src[11];
    v284 = src[21] ^ src[5];
    v115 = src[25] ^ src[9];
    v116 = src[23] ^ src[7];
    v117 = src[24] ^ src[8];
    v292 = src[26] ^ src[10];
    v470 = src[28] ^ src[12];
    v480 = src[29] ^ src[13];
    v118 = src[30] ^ src[14];
    v119 = src[29] ^ src[13];
    v120 = src[31] ^ src[15];
    v252 = src[28] ^ src[12];
    v121 = src[27] ^ src[11];
    v231 = src[20] ^ src[4];
    v122 = src[16] ^ src[0];
    v490 = src[30] ^ src[14];
    v500 = src[31] ^ src[15];
    do
    {
      v29 = v308-- == 1;
      v123 = v114 ^ __ROR4__(v121 + v120, 25);
      v232 = v231 ^ __ROR4__(v252 + v122, 25);
      v276 = v118 ^ __ROR4__(v268 + v292, 25);
      v243 = v115 ^ __ROR4__(v260 + v284, 25);
      v124 = v117 ^ __ROR4__(v232 + v122, 23);
      v125 = v116 ^ __ROR4__(v123 + v120, 23);
      v126 = v119 ^ __ROR4__(v243 + v284, 23);
      v127 = v113 ^ __ROR4__(v276 + v292, 23);
      v128 = v252 ^ __ROR4__(v124 + v232, 19);
      v129 = v121 ^ __ROR4__(v125 + v123, 19);
      v130 = v268 ^ __ROR4__(v127 + v276, 19);
      v131 = v260 ^ __ROR4__(v126 + v243, 19);
      v300 = v120 ^ __ROR4__(v129 + v125, 14);
      v132 = v122 ^ __ROR4__(v128 + v124, 14);
      v133 = v292 ^ __ROR4__(v130 + v127, 14);
      v134 = v284 ^ __ROR4__(v131 + v126, 14);
      v121 = v129 ^ __ROR4__(v133 + v243, 25);
      v252 = v128 ^ __ROR4__(v300 + v276, 25);
      v268 = v130 ^ __ROR4__(v134 + v232, 25);
      v260 = v131 ^ __ROR4__(v132 + v123, 25);
      v117 = v124 ^ __ROR4__(v121 + v133, 23);
      v116 = v125 ^ __ROR4__(v268 + v134, 23);
      v113 = v127 ^ __ROR4__(v260 + v132, 23);
      v119 = v126 ^ __ROR4__(v252 + v300, 23);
      v114 = v123 ^ __ROR4__(v113 + v260, 19);
      v231 = v232 ^ __ROR4__(v116 + v268, 19);
      v115 = v243 ^ __ROR4__(v117 + v121, 19);
      v118 = v276 ^ __ROR4__(v119 + v252, 19);
      v122 = v132 ^ __ROR4__(v114 + v113, 14);
      v135 = v134 ^ __ROR4__(v231 + v116, 14);
      v284 = v135;
      v120 = v300 ^ __ROR4__(v118 + v119, 14);
      v292 = v133 ^ __ROR4__(v115 + v117, 14);
    }
    while ( !v29 );
    src[0] = v122 + v322;
    v136 = v260 + v334;
    src[4] = v231 + v370;
    src[5] = v135 + v382;
    src[6] = v268 + v394;
    src[7] = v116 + v406;
    v137 = v115 + (src[25] ^ src[9]);
    src[10] = v292 + v442;
    src[12] = v252 + v470;
    src[13] = v119 + v480;
    src[8] = v117 + v418;
    src[11] = v121 + v456;
    src[14] = v118 + v490;
    src[15] = v120 + v500;
    v316 = (v122 + v322) ^ src[16];
    v328 = (v260 + v334) ^ src[17];
    v340 = (v113 + v346) ^ src[18];
    v352 = (v114 + v358) ^ src[19];
    v364 = (v231 + v370) ^ src[20];
    v376 = (v135 + v382) ^ src[21];
    v388 = (v268 + v394) ^ src[22];
    v400 = (v116 + v406) ^ src[23];
    v412 = (v117 + v418) ^ src[24];
    v424 = v137 ^ src[25];
    v430 = (v292 + v442) ^ src[26];
    v436 = (v121 + v456) ^ src[27];
    v443 = (v252 + v470) ^ src[28];
    v457 = (v118 + v490) ^ src[30];
    v253 = v436;
    v138 = (v120 + v500) ^ src[31];
    v139 = (v119 + v480) ^ src[29];
    v464 = v138;
    v269 = v388;
    v293 = v430;
    v450 = v139;
    v261 = v328;
    v285 = v376;
    src[3] = v114 + v358;
    v140 = v340;
    v141 = v412;
    v142 = v352;
    v143 = v137 ^ src[25];
    v144 = v364;
    v145 = v443;
    v309 = 4;
    src[1] = v136;
    src[2] = v113 + v346;
    src[9] = v137;
    v244 = v457;
    v146 = v400;
    v147 = v316;
    do
    {
      v233 = v144 ^ __ROR4__(v145 + v147, 25);
      v29 = v309-- == 1;
      v148 = v142 ^ __ROR4__(v253 + v138, 25);
      v277 = v244 ^ __ROR4__(v269 + v293, 25);
      v149 = v146 ^ __ROR4__(v148 + v138, 23);
      v245 = v143 ^ __ROR4__(v261 + v285, 25);
      v150 = v141 ^ __ROR4__(v233 + v147, 23);
      v151 = v140 ^ __ROR4__(v277 + v293, 23);
      v152 = v139 ^ __ROR4__(v245 + v285, 23);
      v153 = v145 ^ __ROR4__(v150 + v233, 19);
      v154 = v253 ^ __ROR4__(v149 + v148, 19);
      v155 = v261 ^ __ROR4__(v152 + v245, 19);
      v156 = v269 ^ __ROR4__(v151 + v277, 19);
      v301 = v138 ^ __ROR4__(v154 + v149, 14);
      v157 = v147 ^ __ROR4__(v153 + v150, 14);
      v158 = v293 ^ __ROR4__(v156 + v151, 14);
      v159 = v285 ^ __ROR4__(v155 + v152, 14);
      v145 = v153 ^ __ROR4__(v301 + v277, 25);
      v253 = v154 ^ __ROR4__(v158 + v245, 25);
      v261 = v155 ^ __ROR4__(v157 + v148, 25);
      v269 = v156 ^ __ROR4__(v159 + v233, 25);
      v141 = v150 ^ __ROR4__(v253 + v158, 23);
      v146 = v149 ^ __ROR4__(v269 + v159, 23);
      v140 = v151 ^ __ROR4__(v261 + v157, 23);
      v139 = v152 ^ __ROR4__(v145 + v301, 23);
      v142 = v148 ^ __ROR4__(v140 + v261, 19);
      v144 = v233 ^ __ROR4__(v146 + v269, 19);
      v143 = v245 ^ __ROR4__(v141 + v253, 19);
      v244 = v277 ^ __ROR4__(v139 + v145, 19);
      v147 = v157 ^ __ROR4__(v142 + v140, 14);
      v293 = v158 ^ __ROR4__(v143 + v141, 14);
      v285 = v159 ^ __ROR4__(v144 + v146, 14);
      v138 = v301 ^ __ROR4__(v244 + v139, 14);
    }
    while ( !v29 );
    v234 = v146;
    src[16] = v147 + v316;
    src[17] = v261 + v328;
    v160 = src;
    src[18] = v140 + v340;
    src[19] = v142 + v352;
    v161 = (int)&v505[128 * ((v147 + v316) & 0x3FF) - 8];
    src[20] = v144 + v364;
    src[21] = v285 + v376;
    src[22] = v269 + v388;
    src[23] = v234 + v400;
    src[24] = v141 + v412;
    src[25] = v143 + v424;
    src[26] = v293 + v430;
    src[27] = v253 + v436;
    src[28] = v145 + v443;
    src[29] = v139 + v450;
    src[30] = v244 + v457;
    src[31] = v138 + v464;
    do
    {
      v162 = *(_QWORD *)(v161 + 8);
      v161 += 8;
      *(_QWORD *)v160 ^= v162;
      v160 += 2;
    }
    while ( v160 != (int *)&v558 );
    v335 = src[17] ^ src[1];
    v323 = src[16] ^ src[0];
    v371 = src[20] ^ src[4];
    v310 = 4;
    v262 = src[17] ^ src[1];
    v163 = src[19] ^ src[3];
    v359 = src[19] ^ src[3];
    v383 = src[21] ^ src[5];
    v347 = src[18] ^ src[2];
    v395 = src[22] ^ src[6];
    v407 = src[23] ^ src[7];
    v419 = src[24] ^ src[8];
    v444 = src[26] ^ src[10];
    v286 = src[21] ^ src[5];
    v270 = src[22] ^ src[6];
    v458 = src[27] ^ src[11];
    v164 = src[25] ^ src[9];
    v294 = src[26] ^ src[10];
    v165 = src[23] ^ src[7];
    v166 = src[24] ^ src[8];
    v471 = src[28] ^ src[12];
    v481 = src[29] ^ src[13];
    v167 = src[28] ^ src[12];
    v168 = src[29] ^ src[13];
    v169 = src[30] ^ src[14];
    v254 = src[27] ^ src[11];
    v170 = src[31] ^ src[15];
    v235 = src[20] ^ src[4];
    v171 = src[18] ^ src[2];
    v172 = src[16] ^ src[0];
    v491 = src[30] ^ src[14];
    v501 = src[31] ^ src[15];
    do
    {
      v278 = v169 ^ __ROR4__(v294 + v270, 25);
      v29 = v310-- == 1;
      v173 = v163 ^ __ROR4__(v170 + v254, 25);
      v236 = v235 ^ __ROR4__(v172 + v167, 25);
      v246 = v164 ^ __ROR4__(v286 + v262, 25);
      v174 = v166 ^ __ROR4__(v236 + v172, 23);
      v175 = v165 ^ __ROR4__(v173 + v170, 23);
      v176 = v171 ^ __ROR4__(v278 + v294, 23);
      v177 = v168 ^ __ROR4__(v246 + v286, 23);
      v178 = v254 ^ __ROR4__(v175 + v173, 19);
      v179 = v167 ^ __ROR4__(v174 + v236, 19);
      v180 = v270 ^ __ROR4__(v176 + v278, 19);
      v181 = v262 ^ __ROR4__(v177 + v246, 19);
      v302 = v170 ^ __ROR4__(v178 + v175, 14);
      v182 = v172 ^ __ROR4__(v179 + v174, 14);
      v183 = v294 ^ __ROR4__(v180 + v176, 14);
      v184 = v286 ^ __ROR4__(v181 + v177, 14);
      v167 = v179 ^ __ROR4__(v302 + v278, 25);
      v254 = v178 ^ __ROR4__(v183 + v246, 25);
      v262 = v181 ^ __ROR4__(v182 + v173, 25);
      v270 = v180 ^ __ROR4__(v184 + v236, 25);
      v165 = v175 ^ __ROR4__(v270 + v184, 23);
      v166 = v174 ^ __ROR4__(v254 + v183, 23);
      v171 = v176 ^ __ROR4__(v262 + v182, 23);
      v168 = v177 ^ __ROR4__(v167 + v302, 23);
      v163 = v173 ^ __ROR4__(v171 + v262, 19);
      v235 = v236 ^ __ROR4__(v165 + v270, 19);
      v164 = v246 ^ __ROR4__(v166 + v254, 19);
      v169 = v278 ^ __ROR4__(v168 + v167, 19);
      v172 = v182 ^ __ROR4__(v163 + v171, 14);
      v185 = v184 ^ __ROR4__(v235 + v165, 14);
      v286 = v185;
      v170 = v302 ^ __ROR4__(v169 + v168, 14);
      v294 = v183 ^ __ROR4__(v164 + v166, 14);
    }
    while ( !v29 );
    src[0] = v172 + v323;
    v186 = v262 + v335;
    v187 = v171 + v347;
    src[3] = v163 + v359;
    src[4] = v235 + v371;
    src[5] = v185 + v383;
    src[7] = v165 + v407;
    v188 = v164 + (src[25] ^ src[9]);
    src[6] = v270 + v395;
    src[10] = v294 + v444;
    src[12] = v167 + v471;
    src[8] = v166 + v419;
    src[11] = v254 + v458;
    src[13] = v168 + v481;
    src[14] = v169 + v491;
    src[15] = v170 + v501;
    v317 = (v172 + v323) ^ src[16];
    v329 = (v262 + v335) ^ src[17];
    v341 = (v171 + v347) ^ src[18];
    v353 = (v163 + v359) ^ src[19];
    v365 = (v235 + v371) ^ src[20];
    v377 = (v185 + v383) ^ src[21];
    v389 = (v270 + v395) ^ src[22];
    v401 = (v165 + v407) ^ src[23];
    v413 = (v166 + v419) ^ src[24];
    v425 = v188 ^ src[25];
    v431 = (v294 + v444) ^ src[26];
    v437 = (v254 + v458) ^ src[27];
    v445 = (v167 + v471) ^ src[28];
    v451 = (v168 + v481) ^ src[29];
    v189 = v437;
    v263 = v389;
    v459 = (v169 + v491) ^ src[30];
    v271 = v329;
    v287 = v377;
    v465 = (v170 + v501) ^ src[31];
    v295 = v317;
    src[2] = v187;
    v190 = v459;
    v191 = v401;
    v192 = v341;
    v193 = v413;
    v194 = v353;
    v195 = v465;
    v196 = v188 ^ src[25];
    v197 = v365;
    v311 = 4;
    src[1] = v186;
    src[9] = v188;
    v255 = v445;
    v198 = v431;
    v199 = v451;
    do
    {
      v237 = v197 ^ __ROR4__(v295 + v255, 25);
      v279 = v190 ^ __ROR4__(v198 + v263, 25);
      v200 = v194 ^ __ROR4__(v195 + v189, 25);
      v29 = v311-- == 1;
      v201 = v191 ^ __ROR4__(v200 + v195, 23);
      v202 = v193 ^ __ROR4__(v237 + v295, 23);
      v247 = v196 ^ __ROR4__(v287 + v271, 25);
      v203 = v192 ^ __ROR4__(v279 + v198, 23);
      v204 = v199 ^ __ROR4__(v247 + v287, 23);
      v205 = v189 ^ __ROR4__(v201 + v200, 19);
      v206 = v255 ^ __ROR4__(v202 + v237, 19);
      v207 = v263 ^ __ROR4__(v203 + v279, 19);
      v208 = v271 ^ __ROR4__(v204 + v247, 19);
      v209 = v295 ^ __ROR4__(v206 + v202, 14);
      v303 = v195 ^ __ROR4__(v205 + v201, 14);
      v210 = v198 ^ __ROR4__(v207 + v203, 14);
      v211 = v287 ^ __ROR4__(v208 + v204, 14);
      v189 = v205 ^ __ROR4__(v210 + v247, 25);
      v255 = v206 ^ __ROR4__(v303 + v279, 25);
      v212 = v208 ^ __ROR4__(v209 + v200, 25);
      v263 = v207 ^ __ROR4__(v211 + v237, 25);
      v191 = v201 ^ __ROR4__(v263 + v211, 23);
      v192 = v203 ^ __ROR4__(v212 + v209, 23);
      v193 = v202 ^ __ROR4__(v189 + v210, 23);
      v271 = v212;
      v199 = v204 ^ __ROR4__(v255 + v303, 23);
      v194 = v200 ^ __ROR4__(v192 + v212, 19);
      v196 = v247 ^ __ROR4__(v193 + v189, 19);
      v197 = v237 ^ __ROR4__(v191 + v263, 19);
      v190 = v279 ^ __ROR4__(v199 + v255, 19);
      v295 = v209 ^ __ROR4__(v194 + v192, 14);
      v287 = v211 ^ __ROR4__(v197 + v191, 14);
      v198 = v210 ^ __ROR4__(v196 + v193, 14);
      v195 = v303 ^ __ROR4__(v190 + v199, 14);
    }
    while ( !v29 );
    v29 = desta-- == 1;
    v109 = v295 + v317;
    src[17] = v271 + v329;
    src[18] = v192 + v341;
    src[19] = v194 + v353;
    src[20] = v197 + v365;
    src[21] = v287 + v377;
    src[23] = v191 + v401;
    src[22] = v263 + v389;
    src[24] = v193 + v413;
    src[25] = v196 + v425;
    src[26] = v198 + v431;
    src[16] = v295 + v317;
    src[27] = v189 + v437;
    src[29] = v199 + v451;
    src[28] = v255 + v445;
    src[30] = v190 + v459;
    src[31] = v195 + v465;
  }
  while ( !v29 );
  v529 = 1779033703;
  v530 = -1150833019;
  v531 = 1013904242;
  v532 = -1521486534;
  v533 = 1359893119;
  v534 = -1694144372;
  v535 = 528734635;
  v536 = 1541459225;
  sub_FC90(&v529, a1, 1);
  v213 = v509[1];
  v214 = v509[2];
  v215 = v509[3];
  v548 = *v509;
  v549 = v213;
  v550 = v214;
  v551 = v215;
  v552 = 128;
  v553 = 0;
  v554 = 0;
  v555 = 0;
  memset(v556, 0, 28);
  v556[7] = -2147352576;
  sub_FC90(&v529, &v548, 1);
  v216 = v529;
  v217 = v530;
  v218 = v531;
  v219 = v532;
  a3[6] = 528734635;
  v538 = v216;
  v539 = v217;
  v540 = v218;
  v541 = v219;
  v220 = v533;
  v221 = v534;
  v222 = v535;
  v223 = v536;
  *a3 = 1779033703;
  a3[1] = -1150833019;
  a3[2] = 1013904242;
  a3[3] = -1521486534;
  a3[4] = 1359893119;
  a3[5] = -1694144372;
  a3[7] = 1541459225;
  v224 = desta;
  v542 = v220;
  v543 = v221;
  v544 = v222;
  v545 = v223;
  do
  {
    *(int *)((char *)&v548 + v224) = *(int *)((char *)&v538 + v224) ^ 0x5C5C5C5C;
    v224 += 4;
  }
  while ( v224 != 32 );
  memset(v556, 92, 32);
  sub_FC90(a3, &v548, 0);
  v225 = 0;
  v529 = 1779033703;
  v530 = -1150833019;
  v531 = 1013904242;
  v532 = -1521486534;
  v533 = 1359893119;
  v534 = -1694144372;
  v535 = 528734635;
  v536 = 1541459225;
  do
  {
    *(int *)((char *)&v548 + v225) = *(int *)((char *)&v538 + v225) ^ 0x36363636;
    v225 += 4;
  }
  while ( v225 != 32 );
  memset(v556, 54, 32);
  sub_FC90(&v529, &v548, 0);
  sub_FC90(&v529, src, 1);
  sub_FC90(&v529, &src[16], 1);
  sub_FC90(&v529, dword_5D64C, 0);
  v548 = v529;
  v549 = v530;
  v550 = v531;
  v551 = v532;
  v552 = v533;
  v553 = v534;
  v554 = v535;
  v555 = v536;
  v556[0] = 0x80000000;
  memset(&v556[1], 0, 24);
  v556[7] = 768;
  return sub_FC90(a3, &v548, 0);
}
// 5D64C: using guessed type int dword_5D64C[16];

//----- (00014E38) --------------------------------------------------------
const char *__fastcall sub_14E38(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_7B5FC, &dword_7B5F8) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( dword_7B5FC > 23 || dword_7B5F8 > 59 || dword_7B5FC < 0 || dword_7B5F8 < 0 )
    return "Invalid time set.";
  byte_7B5F0 = 1;
  return 0;
}
// 7B5F0: using guessed type char byte_7B5F0;
// 7B5F8: using guessed type int dword_7B5F8;
// 7B5FC: using guessed type int dword_7B5FC;

//----- (00014EB4) --------------------------------------------------------
const char *__fastcall sub_14EB4(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_7B880, &dword_7B87C) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( dword_7B880 > 23 || dword_7B87C > 59 || dword_7B880 < 0 || dword_7B87C < 0 )
    return "Invalid time set.";
  byte_7B874 = 1;
  return 0;
}
// 7B874: using guessed type char byte_7B874;
// 7B87C: using guessed type int dword_7B87C;
// 7B880: using guessed type int dword_7B880;

//----- (00014F30) --------------------------------------------------------
int __fastcall sub_14F30(int a1)
{
  int i; // r1
  int result; // r0
  unsigned int *v4; // r2
  int v5[20]; // [sp+0h] [bp-20250h] BYREF
  _DWORD v6[32748]; // [sp+50h] [bp-20200h] BYREF

  v6[0] = 0;
  memset(&v6[1], 0, (size_t)&loc_201FC);
  for ( i = 0; i != 19; ++i )
    v5[i] = bswap32(*(_DWORD *)(a1 + i * 4));
  v5[19] = bswap32(*(_DWORD *)(a1 + 76));
  result = sub_122E8(v5, (int)v6, (int *)(a1 + 192));
  v4 = (unsigned int *)(a1 + 192);
  do
  {
    *v4 = bswap32(*v4);
    ++v4;
  }
  while ( v4 != (unsigned int *)(a1 + 224) );
  return result;
}

//----- (00014FD0) --------------------------------------------------------
int __fastcall sub_14FD0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // r5
  int i; // r1
  unsigned int v5; // r4
  _BYTE v7[131592]; // [sp+8h] [bp-21284h] BYREF
  int v8[8]; // [sp+20210h] [bp-107Ch] BYREF
  int v9[20]; // [sp+20230h] [bp-105Ch] BYREF
  char v10[12]; // [sp+20280h] [bp-100Ch] BYREF

  v3 = *(_DWORD *)(a2 + 28);
  for ( i = 0; i != 19; ++i )
    v9[i] = bswap32(*(_DWORD *)(a1 + i * 4));
  v9[19] = bswap32(a3);
  sub_122E8(v9, (int)v7, v8);
  v5 = bswap32(v8[7]);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v10, 0x1000u, "htarget %08lx diff1 %08lx hash %08lx", v3, 0xFFFF, v5);
    sub_38730(7, v10, 0);
  }
  if ( v5 >= 0x10000 )
    return -1;
  else
    return v3 >= v5;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00015264) --------------------------------------------------------
int __fastcall sub_15264(char *a1, size_t a2, time_t *a3)
{
  struct tm *v5; // r0
  time_t v7; // [sp+1Ch] [bp-8h] BYREF

  v7 = *a3;
  v5 = localtime(&v7);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d]",
           v5->tm_year + 1900,
           v5->tm_mon + 1,
           v5->tm_mday,
           v5->tm_hour,
           v5->tm_min,
           v5->tm_sec);
}

//----- (000152E0) --------------------------------------------------------
void sub_152E0()
{
  int v0; // r7
  unsigned int v1; // r4
  int v2; // r8
  int *v3; // r6
  int *v4; // r3
  int v5; // t1
  unsigned int v6; // r2
  int v7; // t1
  unsigned int v8; // r5
  int v9; // r8
  int v10; // r6
  int v11; // r10
  _DWORD *v12; // t1
  char v13[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = dword_7B198;
  if ( dword_7B198 <= 0 )
  {
    v1 = 1;
  }
  else
  {
    v1 = -1;
    v2 = dword_7B438 + 4 * dword_7B198;
    v3 = (int *)dword_7B438;
    v4 = (int *)dword_7B438;
    do
    {
      v5 = *v4++;
      v6 = *(_DWORD *)(v5 + 56);
      if ( v6 && v1 >= v6 )
        v1 = v6;
    }
    while ( v4 != (int *)v2 );
    if ( v1 == -1 )
    {
      v1 = 1;
    }
    else
    {
      do
      {
        while ( 1 )
        {
          v7 = *v3++;
          v8 = *(_DWORD *)(v7 + 56);
          if ( v8 )
            break;
          if ( v3 == (int *)v2 )
            goto LABEL_13;
        }
        while ( v8 % v1 )
          --v1;
      }
      while ( v3 != (int *)v2 );
    }
LABEL_13:
    v9 = dword_7B438 - 4;
    v10 = 0;
    v11 = dword_755F0;
    do
    {
      v12 = *(_DWORD **)(v9 + 4);
      v9 += 4;
      ++v10;
      v12[16] = v12[16] * v11 / v1;
      v12[15] = v12[14] / v1;
    }
    while ( v10 < v0 );
  }
  dword_755F0 = v1;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v13, 0x1000u, "Global quota greatest common denominator set to %lu", v1);
    sub_38730(7, v13, 0);
  }
}
// 755F0: using guessed type int dword_755F0;
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (0001545C) --------------------------------------------------------
char *__fastcall sub_1545C(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0

  result = sub_5B2E8(a1, a2);
  if ( !result && (*a2 < a3 || *a2 > a4) )
    return "Value out of range";
  return result;
}

//----- (0001549C) --------------------------------------------------------
char *__fastcall sub_1549C(const char *a1)
{
  dword_76EFC = 2;
  return sub_1545C(a1, &dword_7B558, 0, 9999);
}
// 76EFC: using guessed type int dword_76EFC;
// 7B558: using guessed type int dword_7B558;

//----- (000154C8) --------------------------------------------------------
char *__fastcall sub_154C8(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 0, 9999);
}

//----- (000154D4) --------------------------------------------------------
char *__fastcall sub_154D4(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 0, 100);
}

//----- (000154E0) --------------------------------------------------------
char *__fastcall sub_154E0(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 1, 0xFFFF);
}

//----- (000154EC) --------------------------------------------------------
char *__fastcall sub_154EC(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 42, 62);
}

//----- (000154F8) --------------------------------------------------------
char *__fastcall sub_154F8(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 22, 55);
}

//----- (00015504) --------------------------------------------------------
char *__fastcall sub_15504(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 32, 63);
}

//----- (00015510) --------------------------------------------------------
char *__fastcall sub_15510(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 0, 4);
}

//----- (0001551C) --------------------------------------------------------
char *__fastcall sub_1551C(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 0, 200);
}

//----- (00015528) --------------------------------------------------------
char *__fastcall sub_15528(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 0, 255);
}

//----- (00015534) --------------------------------------------------------
char *__fastcall sub_15534(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 1, 10);
}

//----- (00015540) --------------------------------------------------------
char *__fastcall sub_15540(const char *a1, _DWORD *a2)
{
  return sub_1545C(a1, a2, 0, 10);
}

//----- (0001554C) --------------------------------------------------------
int __fastcall sub_1554C(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (0001557C) --------------------------------------------------------
int __fastcall sub_1557C(int a1, char *a2)
{
  char *v5; // r0
  int v6; // r2

  sub_2AA68(a1, a2);
  if ( !sub_2AB54(a2, (_DWORD *)(a1 + 624), (char **)(a1 + 608)) || strncasecmp(a2, "stratum+tcp://", 0xEu) )
    return 0;
  v5 = _strdup(a2);
  v6 = *(_DWORD *)(a1 + 624);
  *(_BYTE *)(a1 + 664) = 1;
  *(_DWORD *)(a1 + 600) = v6;
  *(_DWORD *)(a1 + 196) = v5;
  return 1;
}

//----- (000155F0) --------------------------------------------------------
const char *__fastcall sub_155F0(const char *a1)
{
  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  dword_76F00 = (int)a1;
  return 0;
}
// 76F00: using guessed type int dword_76F00;

//----- (00015648) --------------------------------------------------------
void *__fastcall sub_15648(void **a1)
{
  free(a1[444]);
  free(a1[449]);
  free(a1[454]);
  free(a1[452]);
  return memset(a1, 0, 0x7B0u);
}

//----- (00015684) --------------------------------------------------------
char *__fastcall sub_15684(int a1, int a2, int a3)
{
  int v4; // r7
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  char *result; // r0
  unsigned int v11[2]; // [sp+4h] [bp-8h] BYREF

  v4 = *(_DWORD *)(a1 + 1828);
  sub_15648((void **)a1);
  memcpy((void *)a1, (const void *)a2, 0x7B0u);
  *(_DWORD *)(a1 + 1828) = v4;
  v7 = *(const char **)(a2 + 1776);
  if ( v7 )
    *(_DWORD *)(a1 + 1776) = _strdup(v7);
  v8 = *(const char **)(a2 + 1808);
  if ( v8 )
    *(_DWORD *)(a1 + 1808) = _strdup(v8);
  v9 = *(const char **)(a2 + 1796);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
      sub_29830(v11, *(unsigned __int8 **)(a2 + 1796), 4);
      v11[0] = bswap32(bswap32(v11[0]) + a3);
      *(_DWORD *)(a1 + 1796) = sub_29730((int)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 1796) = _strdup(v9);
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
  }
  result = *(char **)(a2 + 1816);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 1816) = result;
  }
  return result;
}

//----- (00015780) --------------------------------------------------------
void __fastcall sub_15780(void **a1)
{
  sub_15648(a1);
  free(a1);
}

//----- (00015798) --------------------------------------------------------
int __fastcall sub_15798(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4

  v4 = (double *)LODWORD(a1);
  if ( v2 > 0.0 )
  {
    a1 = exp(a1);
    *v4 = (*v4 + (1.0 - 1.0 / (v2 / v3)) * (v1 / v2)) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  }
  return LODWORD(a1);
}
// 157B4: variable 'v2' is possibly undefined
// 157B8: variable 'v3' is possibly undefined
// 157CC: variable 'v1' is possibly undefined

//----- (000157EC) --------------------------------------------------------
void __fastcall sub_157EC(int a1)
{
  struct timeval v1; // [sp+0h] [bp-8h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    sub_2A84C(&v1);
    sub_2AA24();
  }
}

//----- (00015840) --------------------------------------------------------
void sub_15840()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_2A84C(&v0);
  sub_2AA24();
}

//----- (00015868) --------------------------------------------------------
void sub_15868()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_2A84C(&v0);
  sub_2AA24();
}

//----- (00015890) --------------------------------------------------------
int __fastcall sub_15890(const char *a1)
{
  return wprintw((WINDOW *)dword_7B430, "%s", a1);
}
// 7B430: using guessed type int dword_7B430;

//----- (000158AC) --------------------------------------------------------
_BYTE *__fastcall sub_158AC(int a1, unsigned int a2)
{
  _BYTE *result; // r0

  result = *(_BYTE **)(a1 + 1796);
  *(_DWORD *)(a1 + 68) = bswap32(a2);
  if ( result )
  {
    free(result);
    result = sub_29730(a1 + 68, 4);
    *(_DWORD *)(a1 + 1796) = result;
  }
  return result;
}

//----- (000158E4) --------------------------------------------------------
__int64 __fastcall sub_158E4(__int64 *a1)
{
  __int64 v2; // r0
  double v3; // d9
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d8
  double v8; // r0
  double v9; // d17
  double v10; // r0
  double v11; // d8
  int v12; // r1
  __int64 v13; // d16

  if ( !a1 )
    return 0;
  v2 = a1[27];
  v3 = 1.7668201e72;
  if ( !byte_7B859 )
    v3 = 2.69595353e67;
  LODWORD(v4) = sub_5CB50(v2);
  v5 = v4 * 6.27710174e57;
  LODWORD(v6) = sub_5CB50(a1[26]);
  v7 = v5 + v6 * 3.40282367e38;
  LODWORD(v8) = sub_5CB50(a1[25]);
  v9 = v8;
  LODWORD(v10) = sub_5CB50(a1[24]);
  v11 = v7 + v9 * 1.84467441e19 + v10;
  if ( v11 == 0.0 )
    return 0;
  LODWORD(v13) = sub_5CC48(v3 / v11);
  HIDWORD(v13) = v12;
  return v13;
}
// 15920: variable 'v4' is possibly undefined
// 15934: variable 'v6' is possibly undefined
// 15940: variable 'v8' is possibly undefined
// 15954: variable 'v10' is possibly undefined
// 15970: variable 'v12' is possibly undefined
// 7B859: using guessed type char byte_7B859;

//----- (000159B4) --------------------------------------------------------
void __fastcall sub_159B4(int a1)
{
  int v2; // r3
  char v3[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( *(_BYTE *)(a1 + 1761) || *(_DWORD *)(a1 + 1728) || *(_BYTE *)(a1 + 1760) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v3, "Discarded cloned or rolled work");
      sub_38730(7, v3, 0);
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 1748);
    if ( v2 )
    {
      ++*(_DWORD *)(v2 + 156);
      --*(_DWORD *)(*(_DWORD *)(a1 + 1748) + 64);
      --*(_DWORD *)(*(_DWORD *)(a1 + 1748) + 68);
    }
    ++*(_QWORD *)&dword_7B7C8;
  }
  sub_15780((void **)a1);
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B7C8: using guessed type int dword_7B7C8;

//----- (00015AC8) --------------------------------------------------------
int __fastcall sub_15AC8(int result)
{
  int v1; // r5
  int v2; // r7
  int *v3; // r3
  int v4; // r4
  int v5; // r1
  int v6; // t1
  int v7; // r2
  bool v8; // cc
  int v9; // r2
  int v10; // r3

  v1 = dword_7B198;
  v2 = dword_7B198 - 1;
  if ( dword_7B198 > 0 )
  {
    v3 = (int *)dword_7B438;
    v4 = dword_7B438 + 4 * dword_7B198;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= *(_DWORD *)(result + 4);
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != (int *)v4 );
  }
  if ( v2 > *(_DWORD *)result )
  {
    **(_DWORD **)(dword_7B438 + 4 * v2) = *(_DWORD *)result;
    *(_DWORD *)(dword_7B438 + 4 * *(_DWORD *)result) = *(_DWORD *)(dword_7B438 + 4 * v2);
    v1 = dword_7B198;
  }
  *(_DWORD *)result = v1;
  v10 = dword_7B198;
  *(_BYTE *)(result + 137) = 1;
  dword_7B198 = v10 - 1;
  return result;
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00015B64) --------------------------------------------------------
void __fastcall sub_15B64(FILE *s)
{
  const char *v1; // r11
  int v3; // r5
  const char *v4; // r10
  const char *v5; // r0
  const char *v6; // r9
  const char *v7; // r0
  const char *v8; // r0
  int v9; // r7
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r4
  const char *v15; // r7
  const char *v16; // r0
  const char *v17; // r9
  const char *v18; // r0
  const char *v19; // r0
  int v20; // r3
  const char *v21; // r10
  const char *v22; // r0
  const char **v23; // r5
  char *v24; // r8
  char *v25; // r4
  int v26; // r2
  int (__fastcall *v27)(_BYTE *); // r3
  char *(__fastcall *v28)(const char *, float *); // r3
  const char **v29; // r3
  const char *v30; // r0
  int v31; // r1
  int v32; // r4
  int v33; // r5
  const char *v34; // [sp+14h] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, s);
  if ( dword_7B198 > 0 )
  {
    v3 = 0;
    while ( 1 )
    {
      v13 = sub_12038(v3);
      v9 = *(_DWORD *)(v13 + 56);
      v14 = v13;
      if ( v9 == 1 )
      {
        v15 = ",";
        if ( !v3 )
          v15 = "";
        if ( *(_DWORD *)(v13 + 216) )
        {
          v16 = sub_29690(*(char **)(v13 + 212));
          v17 = sub_F8A4(v16);
          v18 = *(const char **)(v14 + 216);
          if ( v18 )
          {
            v19 = sub_F8A4(v18);
            v20 = *(_DWORD *)(v14 + 216);
            if ( v20 )
              v1 = delim;
            v21 = v19;
            if ( v20 )
              goto LABEL_20;
            goto LABEL_69;
          }
        }
        else
        {
          v17 = "";
        }
        v21 = "";
LABEL_69:
        v1 = "";
LABEL_20:
        v22 = sub_F8A4(*(const char **)(v14 + 196));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v17, v21, v1, v22);
        goto LABEL_11;
      }
      v4 = ",";
      if ( !v3 )
        v4 = "";
      if ( !*(_DWORD *)(v13 + 216) )
        break;
      v5 = sub_29690(*(char **)(v13 + 212));
      v6 = sub_F8A4(v5);
      v7 = *(const char **)(v14 + 216);
      if ( !v7 )
      {
        v9 = *(_DWORD *)(v14 + 56);
        goto LABEL_22;
      }
      v8 = sub_F8A4(v7);
      v9 = *(_DWORD *)(v14 + 56);
      v1 = v8;
      if ( !*(_DWORD *)(v14 + 216) )
        goto LABEL_23;
      v34 = delim;
LABEL_10:
      v10 = sub_F8A4(*(const char **)(v14 + 196));
      fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v4, v6, v1, v34, v9, v10);
LABEL_11:
      ++v3;
      v11 = sub_F8A4(*(const char **)(v14 + 204));
      fprintf(s, "\n\t\t\"user\" : \"%s\",", v11);
      v12 = sub_F8A4(*(const char **)(v14 + 208));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
      if ( dword_7B198 <= v3 )
        goto LABEL_24;
    }
    v6 = "";
LABEL_22:
    v1 = "";
LABEL_23:
    v34 = "";
    goto LABEL_10;
  }
LABEL_24:
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_75604 != 16 )
  {
    v23 = (const char **)&unk_7561C;
    while ( 1 )
    {
      v24 = _strdup(*(v23 - 7));
      v25 = strtok(v24, delim);
      if ( v25 )
        break;
LABEL_53:
      v23 += 7;
      free(v24);
      if ( *(v23 - 6) == (const char *)16 )
        goto LABEL_54;
    }
    while ( 1 )
    {
      if ( v25[1] == 45 && *(v23 - 1) != (const char *)&unk_9D784 )
      {
        v26 = (int)*(v23 - 6);
        if ( (v26 & 1) != 0
          && ((v27 = (int (__fastcall *)(_BYTE *))*(v23 - 5), v27 == sub_5B0FC) || v27 == sub_5B10C)
          && **(v23 - 2) == (v27 == sub_5B0FC) )
        {
          fprintf(s, ",\n\"%s\" : true", v25 + 2);
        }
        else
        {
          if ( (v26 & 2) == 0 )
            goto LABEL_49;
          v28 = (char *(__fastcall *)(const char *, float *))*(v23 - 4);
          if ( (char *)v28 == (char *)sub_5B2E8
            || (char *)v28 == (char *)sub_154C8
            || (char *)v28 == (char *)sub_154E0
            || (char *)v28 == (char *)sub_15540
            || (char *)v28 == (char *)sub_15534
            || (char *)v28 == (char *)sub_154D4
            || (char *)v28 == (char *)sub_15528
            || (char *)v28 == (char *)sub_1551C
            || (char *)v28 == (char *)sub_15510
            || (char *)v28 == (char *)sub_15504
            || (char *)v28 == (char *)sub_154F8
            || (char *)v28 == (char *)sub_154EC )
          {
            fprintf(s, ",\n\"%s\" : \"%d\"", v25 + 2, *(_DWORD *)*(v23 - 2));
          }
          else
          {
            if ( v28 != sub_12200 && v28 != sub_121B0 )
            {
LABEL_49:
              if ( (v26 & 6) != 0 )
              {
                v29 = (const char **)*(v23 - 2);
                if ( v29 != (const char **)&unk_76F14 )
                {
                  if ( *v29 )
                  {
                    v30 = sub_F8A4(*v29);
                    fprintf(s, ",\n\"%s\" : \"%s\"", v25 + 2, v30);
                  }
                }
              }
              goto LABEL_28;
            }
            fprintf(s, ",\n\"%s\" : \"%.1f\"", v25 + 2, *(float *)*(v23 - 2));
          }
        }
      }
LABEL_28:
      v25 = strtok(0, delim);
      if ( !v25 )
        goto LABEL_53;
    }
  }
LABEL_54:
  v31 = dword_76EFC;
  if ( dword_76EFC == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, s);
    v31 = dword_76EFC;
    if ( dword_76EFC != 3 )
      goto LABEL_56;
  }
  else if ( dword_76EFC != 3 )
  {
    goto LABEL_56;
  }
  fwrite(",\n\"load-balance\" : true", 1u, 0x17u, s);
  v31 = dword_76EFC;
LABEL_56:
  if ( v31 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, s);
    v31 = dword_76EFC;
  }
  if ( v31 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", dword_7B558);
  fwrite("\n}\n", 1u, 3u, s);
  v32 = dword_76BD8;
  dword_76BD8 = 0;
  if ( v32 )
  {
    do
    {
      v33 = *(_DWORD *)(v32 + 4);
      free(*(void **)v32);
      free((void *)v32);
      v32 = v33;
    }
    while ( v33 );
  }
}
// 15CE8: variable 'v1' is possibly undefined
// 75604: using guessed type int dword_75604;
// 76BD8: using guessed type int dword_76BD8;
// 76EFC: using guessed type int dword_76EFC;
// 7B198: using guessed type int dword_7B198;
// 7B558: using guessed type int dword_7B558;

//----- (000160B4) --------------------------------------------------------
int sub_160B4()
{
  int result; // r0
  int *v1; // r3
  int v2; // r1
  int v3; // t1

  dword_75DC4 = 0;
  dword_75DC8 = 0;
  dword_76F18 = 0;
  dword_76F1C = 0;
  result = sub_11580(0, (char *)&dword_75DC4, 8u, 0);
  if ( dword_7B198 > 0 )
  {
    result = 0;
    v1 = (int *)dword_7B438;
    v2 = dword_7B438 + 4 * dword_7B198;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 400) = 0;
      *(_DWORD *)(v3 + 404) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 75DC4: using guessed type int dword_75DC4;
// 75DC8: using guessed type int dword_75DC8;
// 76F18: using guessed type int dword_76F18;
// 76F1C: using guessed type int dword_76F1C;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00016150) --------------------------------------------------------
char *__fastcall sub_16150(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // r5
  char *v6; // r0

  if ( dword_76BDC && *(_BYTE *)dword_76BDC )
    return strcpy(a1, (const char *)dword_76BDC);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    *(_WORD *)stpcpy(a1, v6) = 47;
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".cgminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"cgminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"cgminer.conf";
}
// AC94: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 76BDC: using guessed type int dword_76BDC;

//----- (00016244) --------------------------------------------------------
int __fastcall sub_16244(int a1)
{
  double v1; // d0
  double v3; // d8
  double v4; // d8
  __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  __int64 v8; // r0
  double v9; // r0
  double v10; // d8
  __int64 v11; // r0
  double v12; // r0
  int v13; // r1
  int v14; // r1
  __int64 v15; // r2
  __int64 v16; // r0
  __int64 v17; // r2
  char *v18; // r6
  unsigned int v20; // [sp+0h] [bp-1020h] BYREF
  int v21; // [sp+4h] [bp-101Ch]
  __int64 v22; // [sp+8h] [bp-1018h]
  __int64 v23; // [sp+10h] [bp-1010h]
  __int64 v24; // [sp+18h] [bp-1008h]
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      strcpy(s, "Diff zero passed to set_target");
      sub_38730(3, s, 0);
      v1 = 1.0;
    }
    else
    {
      v1 = 1.0;
    }
  }
  v3 = 1.7668201e72;
  if ( !byte_7B859 )
    v3 = 2.69595353e67;
  v4 = v3 / v1;
  LODWORD(v5) = sub_5CC48(v4 * 1.59309191e-58);
  v24 = v5;
  LODWORD(v6) = sub_5CB50(v5);
  v7 = v4 - v6 * 6.27710174e57;
  LODWORD(v8) = sub_5CC48(v7 * 2.93873588e-39);
  v23 = v8;
  LODWORD(v9) = sub_5CB50(v8);
  v10 = v7 - v9 * 3.40282367e38;
  LODWORD(v11) = sub_5CC48(v10 * 5.42101086e-20);
  v22 = v11;
  LODWORD(v12) = sub_5CB50(v11);
  v20 = sub_5CC48(v10 - v12 * 1.84467441e19);
  v21 = v13;
  if ( byte_78E09 )
  {
    v18 = sub_29730((int)&v20, 32);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "Generated target %s", v18);
      sub_38730(7, s, 0);
    }
    free(v18);
  }
  v14 = v21;
  v15 = v22;
  *(_DWORD *)a1 = v20;
  *(_DWORD *)(a1 + 4) = v14;
  *(_QWORD *)(a1 + 8) = v15;
  v16 = v23;
  v17 = v24;
  *(_QWORD *)(a1 + 16) = v23;
  *(_QWORD *)(a1 + 24) = v17;
  return v16;
}
// 16260: variable 'v1' is possibly undefined
// 16294: variable 'v5' is possibly undefined
// 162A8: variable 'v6' is possibly undefined
// 162B8: variable 'v8' is possibly undefined
// 162CC: variable 'v9' is possibly undefined
// 162DC: variable 'v11' is possibly undefined
// 162F0: variable 'v12' is possibly undefined
// 16304: variable 'v13' is possibly undefined
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B859: using guessed type char byte_7B859;

//----- (00016494) --------------------------------------------------------
int __fastcall sub_16494(char *a1, unsigned __int64 a2)
{
  bool v3; // cf
  char v4; // r3
  int v6; // r4
  size_t v7; // r2
  unsigned __int64 v8; // [sp+0h] [bp-Ch] BYREF

  v8 = a2;
  if ( a2 > 0xFC )
  {
    if ( a2 <= 0xFFFF )
    {
      v6 = 3;
      *a1 = -3;
      v7 = 2;
    }
    else
    {
      v3 = HIDWORD(a2) == 0;
      if ( !HIDWORD(a2) )
        v3 = 1;
      if ( v3 )
      {
        v6 = 5;
        v7 = 4;
      }
      else
      {
        v6 = 9;
        v7 = 8;
      }
      if ( v3 )
        v4 = -2;
      else
        v4 = -1;
      *a1 = v4;
    }
  }
  else
  {
    *a1 = a2;
    v6 = 1;
    v7 = 0;
  }
  memcpy(a1 + 1, &v8, v7);
  return v6;
}

//----- (00016534) --------------------------------------------------------
int __fastcall sub_16534(int a1)
{
  return dword_7B948 - *(_DWORD *)(a1 + 232);
}
// 7B948: using guessed type int dword_7B948;

//----- (0001654C) --------------------------------------------------------
bool __fastcall sub_1654C(int a1, int a2)
{
  unsigned int v3; // r0

  *(_DWORD *)(a1 + 76) = a2;
  if ( byte_7B859 )
    sub_14F30(a1);
  else
    sub_11F60(a1);
  if ( byte_7B859 )
    v3 = 0xFFFF;
  else
    v3 = 0;
  return v3 >= *(_DWORD *)(a1 + 220);
}
// 7B859: using guessed type char byte_7B859;

//----- (000165A0) --------------------------------------------------------
bool __fastcall sub_165A0(int a1, int a2)
{
  double v2; // d0
  double v4; // d16
  unsigned __int64 v5; // r0

  *(_DWORD *)(a1 + 76) = a2;
  if ( byte_7B859 )
    sub_14F30(a1);
  else
    sub_11F60(a1);
  v4 = 2.81470682e14;
  if ( !byte_7B859 )
    v4 = 4294901760.0;
  LODWORD(v5) = sub_5CC48(v4 / v2);
  return v5 >= *(_QWORD *)(a1 + 216);
}
// 165E0: variable 'v2' is possibly undefined
// 165F4: variable 'v5' is possibly undefined
// 7B859: using guessed type char byte_7B859;

//----- (00016624) --------------------------------------------------------
unsigned int __fastcall sub_16624(int a1, int a2)
{
  int v4; // r5
  int v5; // r12
  int v6; // r3
  unsigned int v7; // r2
  unsigned int result; // r0
  int v9; // r1
  unsigned int v10; // r2
  unsigned int v11; // r3
  unsigned int v12; // r1
  unsigned int v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r2
  int v17; // r1
  int v18; // r3
  int v19; // r3
  size_t v20; // r4
  _DWORD *v21; // r0
  _DWORD *v22; // r6
  int v23; // r3
  int v24; // r8
  int v25; // r3
  unsigned int v26; // r5
  _DWORD *v27; // r4
  _DWORD *v28; // r9
  int v29; // r5
  char *v30; // r7
  unsigned int v31; // r2
  int v32; // r3
  _DWORD *v33; // r3
  unsigned int v34; // r1
  unsigned int v35; // r2
  bool v36; // cc
  int v37; // r2
  int v38; // r3
  int v39; // r6
  void *v40; // r0
  void **v41; // r6
  void *v42; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  ++*(_DWORD *)(a1 + 360);
  *(_DWORD *)(a2 + 1840) = 0;
  *(_DWORD *)(a2 + 1852) = a2 + 1828;
  *(_DWORD *)(a2 + 1856) = 4;
  v4 = *(_DWORD *)(a1 + 352);
  if ( v4 )
  {
    v5 = a2 + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 1832) + 16) + 8) = a2;
    *(_DWORD *)(a2 + 1836) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 16)
                           - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 16) = a2 + 1832;
  }
  else
  {
    *(_DWORD *)(a1 + 352) = a2;
    *(_DWORD *)(a2 + 1836) = 0;
    v39 = *(_DWORD *)(a1 + 352);
    *(_DWORD *)(v39 + 1832) = malloc(0x2Cu);
    v40 = *(void **)(*(_DWORD *)(a1 + 352) + 1832);
    if ( !v40 )
      goto LABEL_31;
    memset(v40, 0, 0x2Cu);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 16) = *(_DWORD *)(a1 + 352) + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 20) = 1832;
    v41 = *(void ***)(*(_DWORD *)(a1 + 352) + 1832);
    *v41 = malloc(0x180u);
    v42 = **(void ***)(*(_DWORD *)(a1 + 352) + 1832);
    if ( !v42 )
      goto LABEL_31;
    memset(v42, 0, 0x180u);
    v5 = a2 + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 12);
  v6 = (*(unsigned __int8 *)(a2 + 1828)
      + 17973517
      + (*(unsigned __int8 *)(a2 + 1831) << 24)
      + (*(unsigned __int8 *)(a2 + 1830) << 16)
      + (*(unsigned __int8 *)(a2 + 1829) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  result = (-17973517 - v6 - v7) ^ (v7 >> 13);
  *(_DWORD *)(a2 + 1832) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832);
  v9 = (v6 - v7 - result) ^ (result >> 12);
  v10 = (v7 - result - v9) ^ (v9 << 16);
  v11 = (result - v9 - v10) ^ (v10 >> 5);
  v12 = v9 - v10 - v11;
  v13 = (v11 - (v12 ^ (v11 >> 3)) - ((v10 - v11 - (v12 ^ (v11 >> 3))) ^ ((v12 ^ (v11 >> 3)) << 10)))
      ^ (((v10 - v11 - (v12 ^ (v11 >> 3))) ^ ((v12 ^ (v11 >> 3)) << 10)) >> 15);
  *(_DWORD *)(a2 + 1860) = v13;
  v14 = 12 * (v13 & (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 4) - 1));
  v15 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  ++*(_DWORD *)(v15 + 4);
  v16 = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14);
  *(_DWORD *)(a2 + 1844) = 0;
  *(_DWORD *)(a2 + 1848) = v16;
  v17 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  if ( *(_DWORD *)v17 )
  {
    *(_DWORD *)(*(_DWORD *)v17 + 12) = v5;
    v17 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  }
  *(_DWORD *)v17 = v5;
  v18 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  if ( *(_DWORD *)(v18 + 4) >= (unsigned int)(10 * (*(_DWORD *)(v18 + 8) + 1)) )
  {
    v19 = *(_DWORD *)(a2 + 1832);
    if ( *(_DWORD *)(v19 + 36) != 1 )
    {
      v20 = 24 * *(_DWORD *)(v19 + 4);
      v21 = malloc(v20);
      v22 = v21;
      if ( v21 )
      {
        memset(v21, 0, v20);
        v23 = *(_DWORD *)(a2 + 1832);
        v24 = 0;
        *(_DWORD *)(v23 + 24) = (((2 * *(_DWORD *)(v23 + 4) - 1) & *(_DWORD *)(v23 + 12)) != 0)
                              + (*(_DWORD *)(v23 + 12) >> (*(_BYTE *)(v23 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a2 + 1832) + 28) = 0;
        v25 = *(_DWORD *)(a2 + 1832);
        v26 = *(_DWORD *)(v25 + 4);
        if ( v26 )
        {
          for ( i = 0; i < v26; ++i )
          {
            v27 = *(_DWORD **)(*(_DWORD *)v25 + v24);
            if ( v27 )
            {
              while ( 1 )
              {
                v28 = (_DWORD *)v27[4];
                v29 = 3 * ((2 * v26 - 1) & v27[7]);
                v30 = (char *)&v22[v29];
                v31 = *((_DWORD *)v30 + 1) + 1;
                *((_DWORD *)v30 + 1) = v31;
                if ( v31 > *(_DWORD *)(v25 + 24) )
                {
                  ++*(_DWORD *)(v25 + 28);
                  *((_DWORD *)v30 + 2) = *((_DWORD *)v30 + 1) / *(_DWORD *)(*(_DWORD *)(a2 + 1832) + 24);
                }
                v27[3] = 0;
                v27[4] = v22[v29];
                v32 = v22[v29];
                if ( v32 )
                  *(_DWORD *)(v32 + 12) = v27;
                v22[v29] = v27;
                v25 = *(_DWORD *)(a2 + 1832);
                if ( !v28 )
                  break;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = v28;
              }
              v26 = *(_DWORD *)(v25 + 4);
            }
            v24 += 12;
          }
        }
        free(*(void **)v25);
        *(_DWORD *)(*(_DWORD *)(a2 + 1832) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a2 + 1832) + 8);
        **(_DWORD **)(a2 + 1832) = v22;
        v33 = *(_DWORD **)(a2 + 1832);
        v34 = v33[3];
        v35 = v33[7];
        v36 = v35 > v34 >> 1;
        if ( v35 <= v34 >> 1 )
          v37 = 0;
        else
          v37 = v33[8];
        if ( v36 )
          ++v37;
        v33[8] = v37;
        v38 = *(_DWORD *)(a2 + 1832);
        if ( *(_DWORD *)(v38 + 32) > 1u )
          *(_DWORD *)(v38 + 36) = 1;
        return result;
      }
LABEL_31:
      exit(-1);
    }
  }
  return result;
}

//----- (00016A80) --------------------------------------------------------
int __fastcall sub_16A80(int a1, void *s2, size_t n, const void *a4, int a5, size_t a6)
{
  int v6; // r5
  int v10; // r4

  v6 = a1;
  if ( a1 )
  {
    v10 = *(_DWORD *)(a1 + 1840);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, a6) )
    {
      v6 = v10;
      if ( !v10 )
        return 0;
      v10 = *(_DWORD *)(v10 + 1840);
    }
  }
  return v6;
}

//----- (00016B40) --------------------------------------------------------
void __fastcall sub_16B40(int a1, _DWORD *a2)
{
  int v3; // r3
  int v4; // r0
  int v5; // r12
  bool v6; // zf
  int v7; // r0
  int v8; // r0
  int v9; // r3
  int v10; // r0
  int v11; // r3
  int v12; // r3

  --*(_DWORD *)(a1 + 360);
  v3 = a2[459];
  if ( v3 || a2[460] )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832);
    v5 = *(_DWORD *)(v4 + 20);
    if ( (_DWORD *)(*(_DWORD *)(v4 + 16) - v5) == a2 )
    {
      *(_DWORD *)(v4 + 16) = v3 + v5;
      v3 = a2[459];
    }
    v6 = v3 == 0;
    if ( v3 )
    {
      v5 = *(_DWORD *)(a1 + 352);
      v4 = a2[460];
    }
    else
    {
      v3 = a2[460];
    }
    if ( v6 )
      *(_DWORD *)(a1 + 352) = v3;
    else
      v5 = *(_DWORD *)(v5 + 1832);
    if ( !v6 )
    {
      v3 += *(_DWORD *)(v5 + 20);
      *(_DWORD *)(v3 + 8) = v4;
    }
    v7 = a2[460];
    if ( !v6 )
      v3 = *(_DWORD *)(a1 + 352);
    if ( v7 )
    {
      *(_DWORD *)(v7 + *(_DWORD *)(*(_DWORD *)(v3 + 1832) + 20) + 4) = a2[459];
      v3 = *(_DWORD *)(a1 + 352);
    }
    v8 = **(_DWORD **)(v3 + 1832);
    v9 = 12 * ((*(_DWORD *)(*(_DWORD *)(v3 + 1832) + 4) - 1) & a2[465]);
    --*(_DWORD *)(v8 + v9 + 4);
    v10 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832);
    if ( *(_DWORD **)(v10 + v9) == a2 + 458 )
      *(_DWORD *)(v10 + v9) = a2[462];
    v11 = a2[461];
    if ( v11 )
      *(_DWORD *)(v11 + 16) = a2[462];
    v12 = a2[462];
    if ( v12 )
      *(_DWORD *)(v12 + 12) = a2[461];
    --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 12);
  }
  else
  {
    free(**(void ***)(*(_DWORD *)(a1 + 352) + 1832));
    free(*(void **)(*(_DWORD *)(a1 + 352) + 1832));
    *(_DWORD *)(a1 + 352) = 0;
  }
}

//----- (00016C88) --------------------------------------------------------
int __fastcall sub_16C88(int result)
{
  if ( *(_DWORD *)(result + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(result + 4) + 16))();
  return result;
}

//----- (00016CA8) --------------------------------------------------------
void __fastcall __noreturn sub_16CA8(int a1)
{
  sub_1D8FC(a1, 1);
}

//----- (00016CB0) --------------------------------------------------------
char *__fastcall sub_16CB0(char *a1)
{
  int *v2; // r0
  size_t v3; // r6
  size_t v4; // r6
  char *v5; // r0
  char *v6; // r4
  char v8[92]; // [sp+Ch] [bp-10FCh] BYREF
  char s[160]; // [sp+68h] [bp-10A0h] BYREF
  char v10[4096]; // [sp+108h] [bp-1000h] BYREF

  v2 = sub_5940C(a1, 0, v8);
  if ( v2 && !*v2 )
  {
    byte_76F20 = 1;
    return sub_16DEC(v2, 1);
  }
  else
  {
    v3 = strlen(a1);
    v4 = v3 + strlen(s) + 35;
    v5 = (char *)malloc(v4);
    v6 = v5;
    if ( !v5 )
    {
      strcpy(v10, "Malloc failure in json error");
      sub_38730(3, v10, 1);
      sub_16CA8(1);
    }
    snprintf(v5, v4, "JSON decode of file '%s' failed\n %s", a1, s);
  }
  return v6;
}
// 76F20: using guessed type char byte_76F20;

//----- (00016D98) --------------------------------------------------------
char *__fastcall sub_16D98(char *s)
{
  if ( !dword_76F24 )
    dword_76F24 = (int)_strdup(s);
  if ( ++dword_76F28 <= 10 )
    return sub_16CB0(s);
  else
    return "Too many levels of JSON includes (limit 10) or a loop";
}
// 76F24: using guessed type int dword_76F24;
// 76F28: using guessed type int dword_76F28;

//----- (00016DEC) --------------------------------------------------------
char *__fastcall sub_16DEC(_DWORD *a1, int a2)
{
  _DWORD *v4; // r6
  const char *v5; // r0
  char *v6; // r11
  _DWORD *v7; // r0
  _DWORD *v8; // r5
  int v9; // r2
  const char *v10; // r2
  int v11; // r3
  unsigned int v12; // r4
  _DWORD *v13; // r0
  _DWORD *v15; // r11
  _DWORD *v16; // r4
  _DWORD *v17; // r0
  char *v18; // r0
  const char *v19; // [sp+Ch] [bp-1010h]
  const char *v20; // [sp+Ch] [bp-1010h]
  char *ptr; // [sp+10h] [bp-100Ch]
  char *v22; // [sp+14h] [bp-1008h]
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( a2 && !dword_76FF4 )
    dword_76FF4 = 1;
  if ( dword_75604 == 16 )
    goto LABEL_46;
  if ( (dword_75604 & 8) != 0 )
    goto LABEL_28;
  v4 = &unk_7561C;
  while ( 2 )
  {
    v5 = (const char *)*(v4 - 7);
    if ( !v5 )
      goto LABEL_26;
    ptr = _strdup(v5);
    v6 = strtok(ptr, delim);
    if ( !v6 )
      goto LABEL_25;
    while ( 2 )
    {
      if ( v6[1] != 45 )
        goto LABEL_10;
      v7 = (_DWORD *)sub_59E20(a1, v6 + 2);
      v8 = v7;
      if ( !v7 )
        goto LABEL_10;
      v9 = *(v4 - 6);
      if ( (v9 & 6) == 0 )
        goto LABEL_17;
      if ( *v7 == 2 )
      {
        v16 = sub_5A178(v7);
        v10 = (const char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v4 - 4))(v16, *(v4 - 2));
        if ( *(v4 - 6) == 4 )
        {
          v20 = v10;
          sub_5B1D4((int)v16, (_DWORD *)*(v4 - 2));
          v10 = v20;
        }
        goto LABEL_43;
      }
      if ( *v7 != 1 )
      {
LABEL_17:
        if ( (v9 & 1) == 0 || *v7 != 5 )
        {
          v10 = "Invalid value";
          goto LABEL_19;
        }
        v10 = (const char *)((int (__fastcall *)(_DWORD))*(v4 - 5))(*(v4 - 2));
LABEL_43:
        if ( !v10 )
          goto LABEL_10;
LABEL_19:
        if ( !a2 )
          goto LABEL_38;
        goto LABEL_20;
      }
      v12 = 0;
      v22 = v6;
      while ( 1 )
      {
        if ( v12 >= (unsigned int)sub_59FEC(v8) )
          goto LABEL_10;
        v13 = sub_5A008(v8, v12);
        if ( !v13 )
          goto LABEL_10;
        if ( *v13 == 2 )
        {
          v15 = sub_5A178(v13);
          v10 = (const char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v4 - 4))(v15, *(v4 - 2));
          if ( *(v4 - 6) == 4 )
          {
            v19 = v10;
            sub_5B1D4((int)v15, (_DWORD *)*(v4 - 2));
            v10 = v19;
          }
        }
        else
        {
          if ( *v13 )
            goto LABEL_30;
          v10 = (const char *)sub_16DEC();
        }
        if ( v10 )
          break;
LABEL_30:
        ++v12;
      }
      v6 = v22;
      if ( !a2 )
      {
LABEL_38:
        snprintf(byte_76F2C, 0xC8u, "Parsing JSON option %s: %s", v6, v10);
        return byte_76F2C;
      }
LABEL_20:
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf(s, 0x1000u, "Invalid config option %s: %s", v6, v10);
        sub_38730(3, s, 0);
      }
      dword_76FF4 = -1;
LABEL_10:
      v6 = strtok(0, delim);
      if ( v6 )
        continue;
      break;
    }
LABEL_25:
    free(ptr);
LABEL_26:
    v11 = v4[1];
    if ( v11 != 16 )
    {
      v4 += 7;
      if ( (v11 & 8) != 0 )
LABEL_28:
        _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x7A0u, "parse_config");
      continue;
    }
    break;
  }
LABEL_46:
  v17 = (_DWORD *)sub_59E20(a1, "include");
  if ( !v17 )
    return 0;
  if ( *v17 != 2 )
    return 0;
  v18 = (char *)sub_5A178(v17);
  return (char *)sub_16D98(v18);
}
// 75604: using guessed type int dword_75604;
// 766C4: using guessed type int dword_766C4;
// 76FF4: using guessed type int dword_76FF4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00017100) --------------------------------------------------------
int __fastcall sub_17100(int a1, char *a2)
{
  char *v3; // r5
  int result; // r0
  char *v5; // r0
  char *v6; // r6
  char v7[4096]; // [sp+0h] [bp-1000h] BYREF

  v3 = sub_2ACE0(a2, a1);
  result = sub_1557C(a1, v3);
  if ( !result )
  {
    sub_5B1D4((int)v3, (_DWORD *)(a1 + 196));
    result = strncmp(v3, "http://", 7u);
    if ( result )
    {
      result = strncmp(v3, "https://", 8u);
      if ( result )
      {
        v5 = (char *)malloc(0x100u);
        v6 = v5;
        if ( !v5 )
        {
          strcpy(v7, "Failed to malloc httpinput");
          sub_38730(3, v7, 1);
          sub_16CA8(1);
        }
        strcpy(v5, "stratum+tcp://");
        strncat(v5, v3, 0xF2u);
        return sub_1557C(a1, v6);
      }
    }
  }
  return result;
}

//----- (00017210) --------------------------------------------------------
int sub_17210()
{
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  sub_2A84C(&stru_76F04);
  result = pthread_create(newthread, 0, sub_231F0, 0);
  if ( result )
    sub_B3C8();
  return result;
}
// 76F04: using guessed type struct timeval stru_76F04;

//----- (00017254) --------------------------------------------------------
int __fastcall sub_17254(char *a1)
{
  char *v2; // r0
  bool v3; // zf
  int v4; // r5
  _DWORD *v6; // r8
  int v7; // r10
  int v8; // r11
  char *v9; // r0
  char *v10; // r12
  char *v11; // r9
  signed int v12; // r2
  size_t v13; // r0
  const char *v14; // r8
  size_t v15; // r11
  size_t v16; // r10
  size_t v17; // r5
  char *v18; // r0
  const char *v19; // r8
  char *v20; // r0
  int v21; // r0
  int v22; // r5
  _DWORD *v23; // r7
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  int v28; // r2
  int v29; // r3
  _DWORD v30[4]; // [sp+14h] [bp-1500h] BYREF
  char *v31; // [sp+24h] [bp-14F0h]
  _BYTE v32[64]; // [sp+28h] [bp-14ECh] BYREF
  int v33[42]; // [sp+68h] [bp-14ACh] BYREF
  char s[1024]; // [sp+110h] [bp-1404h] BYREF
  char v35[4080]; // [sp+510h] [bp-1004h] BYREF

  if ( dword_76FF8 )
  {
    if ( fgets(s, 1024, (FILE *)dword_76FF8) )
      goto LABEL_3;
    if ( !dword_77004 )
      goto LABEL_25;
LABEL_9:
    fclose((FILE *)dword_76FF8);
    dword_76FF8 = 0;
    return sub_17254(a1);
  }
  else
  {
    if ( !dword_76FFC )
    {
      strcpy(v35, "BENCHFILE Invalid benchfile NULL");
      sub_38730(3, v35, 1);
      sub_16CA8(1);
    }
    dword_76FF8 = (int)fopen((const char *)dword_76FFC, "r");
    if ( !dword_76FF8 )
    {
      snprintf(v35, 0x1000u, "BENCHFILE Failed to open benchfile '%s'", (const char *)dword_76FFC);
      sub_38730(3, v35, 1);
      sub_16CA8(1);
    }
    dword_77000 = 0;
    if ( !fgets(s, 1024, (FILE *)dword_76FF8) )
    {
      snprintf(v35, 0x1000u, "BENCHFILE Failed to read benchfile '%s'", (const char *)dword_76FFC);
      sub_38730(3, v35, 1);
      sub_16CA8(1);
    }
    dword_77004 = 0;
    while ( 1 )
    {
LABEL_3:
      v2 = s;
      v3 = s[0] == 35;
      if ( s[0] != 35 )
        v3 = s[0] == 0;
      ++dword_77000;
      if ( !v3 && s[0] != 47 )
        break;
      if ( !fgets(s, 1024, (FILE *)dword_76FF8) )
      {
        if ( dword_77004 )
          goto LABEL_9;
LABEL_25:
        snprintf(v35, 0x1000u, "BENCHFILE No work in benchfile '%s'", dword_76FFC);
        sub_38730(3, v35, 1);
        sub_16CA8(1);
      }
    }
    v6 = v30;
    v7 = 0;
    v8 = 1;
    v30[0] = s;
    do
    {
      v9 = strchr(v2, 44);
      v6[1] = v9;
      if ( !v9 )
      {
        snprintf(
          v35,
          0x1000u,
          "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
          dword_77000,
          v8,
          5);
        sub_38730(3, v35, 1);
        sub_16CA8(1);
      }
      v10 = *(char **)((char *)&unk_5D6AC + v7);
      if ( v10 && &v9[-*v6] != v10 )
      {
        snprintf(
          v35,
          0x1000u,
          "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
          dword_77000,
          v8,
          *(const char **)((char *)&unk_5D6AC + v7 + 4),
          &v9[-*v6],
          v10);
        sub_38730(3, v35, 1);
        sub_16CA8(1);
      }
      ++v8;
      *v9 = 0;
      v7 += 8;
      v6[1] = v9 + 1;
      v2 = v9 + 1;
      ++v6;
    }
    while ( v8 != 5 );
    v11 = v31;
    v12 = strlen(v31);
    if ( v12 <= 9 )
    {
      snprintf(
        v35,
        0x1000u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        dword_77000,
        5,
        "NonceTime",
        v12,
        10);
      sub_38730(3, v35, 1);
      sub_16CA8(1);
    }
    sprintf(v35, "0000000%c", *(unsigned __int8 *)v30[0]);
    v13 = strlen(v35);
    v14 = (const char *)(v30[2] + 56);
    v15 = v13 + 64;
    v16 = v13;
    v17 = v13;
    do
    {
      v18 = &v35[v17];
      v17 += 8;
      sprintf(v18, "%.8s", v14);
      v14 -= 8;
    }
    while ( v17 != v15 );
    v19 = (const char *)(v30[1] + 56);
    do
    {
      v20 = &v35[v17];
      v17 += 8;
      sprintf(v20, "%.8s", v19);
      v19 -= 8;
    }
    while ( v17 != v16 + 128 );
    v21 = strtol(v11, 0, 10);
    sprintf(&v35[v17], "%08lx", v21);
    v22 = 0;
    strcpy(&v35[v16 + 136], (const char *)v30[3]);
    memset(a1, 0, 0x7B0u);
    sub_29830(a1, (unsigned __int8 *)v35, (int)(v16 + 144) >> 1);
    do
    {
      *(_DWORD *)&v32[v22] = bswap32(*(_DWORD *)&a1[v22]);
      v22 += 4;
    }
    while ( v22 != 64 );
    v23 = a1 + 128;
    sub_302D0(v33);
    sub_30304(v33, v32, 0x40u);
    v4 = 1;
    v24 = v33[35];
    v25 = v33[36];
    v26 = v33[37];
    ++dword_77004;
    *v23 = v33[34];
    v23[1] = v24;
    v23[2] = v25;
    v23[3] = v26;
    v23 += 4;
    v27 = v33[39];
    v28 = v33[40];
    v29 = v33[41];
    *v23 = v33[38];
    v23[1] = v27;
    v23[2] = v28;
    v23[3] = v29;
  }
  return v4;
}
// 76FF8: using guessed type int dword_76FF8;
// 76FFC: using guessed type int dword_76FFC;
// 77000: using guessed type int dword_77000;
// 77004: using guessed type int dword_77004;

//----- (00017744) --------------------------------------------------------
int __fastcall sub_17744(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // r0
  double v8; // d17
  unsigned __int64 v9; // r4
  int v10; // r1
  unsigned __int64 v11; // r0
  size_t v12; // r11
  char v14[16]; // [sp+28h] [bp-1064h] BYREF
  char v15[16]; // [sp+38h] [bp-1054h] BYREF
  char s[64]; // [sp+48h] [bp-1044h] BYREF
  char v17[4100]; // [sp+88h] [bp-1004h] BYREF

  sub_157EC(a3);
  LODWORD(v7) = sub_5CB64(*(_QWORD *)(a3 + 192));
  v8 = v7;
  LODWORD(v9) = sub_5CC48(*(double *)(a3 + 48));
  HIDWORD(v9) = v10;
  LODWORD(v11) = sub_5CC48(*(double *)(a3 + 80) / v3);
  sub_11580(v11, v14, 0x10u, 4);
  sub_11580(v9, v15, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  v12 = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_75DCC,
    v15,
    v14,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v8 / v3 * 60.0);
  if ( a2 <= strlen(s) + v12 )
  {
    snprintf(v17, 0x1000u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3081);
    sub_38730(3, v17, 1);
    sub_16CA8(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 17784: variable 'v7' is possibly undefined
// 177A4: variable 'v10' is possibly undefined
// 177A8: variable 'v3' is possibly undefined
// 177BC: variable 'v11' is possibly undefined
// 16CA8: using guessed type void __fastcall __noreturn sub_16CA8(_DWORD);
// 75DCC: using guessed type int dword_75DCC;

//----- (000178F8) --------------------------------------------------------
void __noreturn sub_178F8()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  sub_2F438((int)sub_1B4C0, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  sub_38730(3, v0, 1);
  sub_16CA8(0);
}

//----- (00017950) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_17950(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 17958: positive sp value 1004 has been found
// 17958: unbalanced stack, ignored a potential tail call

//----- (0001795C) --------------------------------------------------------
void __noreturn sub_1795C()
{
  sigaction(15, &oact, 0);
  sigaction(2, &stru_7B94C, 0);
  sub_178F8();
}

//----- (00017990) --------------------------------------------------------
int __fastcall sub_17990(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_mutex_init(a1, 0);
  if ( result )
    sub_B4EC(a2, a3);
  return result;
}

//----- (000179BC) --------------------------------------------------------
int __fastcall sub_179BC(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_init(a1, 0);
  if ( result )
    sub_B558(a2, a3);
  return result;
}

//----- (000179E8) --------------------------------------------------------
int __fastcall sub_179E8(int a1, const char *a2, int a3)
{
  int result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_B4EC(a2, a3);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    sub_B558(a2, a3);
  return result;
}

//----- (00017A3C) --------------------------------------------------------
char *sub_17A3C()
{
  char *v0; // r4
  int v1; // r3
  void *v2; // r0
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r12
  char v7[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = (char *)calloc(0x750u, 1u);
  if ( !v0 )
  {
    strcpy(v7, "Failed to malloc pool in add_pool");
    sub_38730(3, v7, 1);
    sub_16CA8(1);
  }
  v1 = dword_7B198;
  v2 = (void *)dword_7B438;
  v3 = dword_7B198 + 2;
  *((_DWORD *)v0 + 1) = dword_7B198;
  *(_DWORD *)v0 = v1;
  v4 = realloc(v2, 4 * v3);
  v5 = dword_7B198 + 1;
  dword_7B438 = (int)v4;
  v4[dword_7B198] = v0;
  dword_7B198 = v5;
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 220), 0) )
    sub_B4EC("add_pool", 748);
  if ( pthread_cond_init((pthread_cond_t *)(v0 + 328), 0) )
  {
    strcpy(v7, "Failed to pthread_cond_init in add_pool");
    sub_38730(3, v7, 1);
    sub_16CA8(1);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 244), 0) )
    sub_B4EC("add_pool", 751);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v0 + 268), 0) )
    sub_B558("add_pool", 751);
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 728), 0) )
    sub_B4EC("add_pool", 752);
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 764), 0) )
    sub_B4EC("add_pool", 753);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v0 + 788), 0) )
    sub_B558("add_pool", 753);
  *((_DWORD *)v0 + 94) = v0 + 376;
  *((_DWORD *)v0 + 95) = v0 + 376;
  *((_DWORD *)v0 + 48) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v0 + 42) = -1;
  *((_DWORD *)v0 + 54) = 0;
  *((_DWORD *)v0 + 14) = 1;
  sub_152E0();
  return v0;
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00017C4C) --------------------------------------------------------
const char *__fastcall sub_17C4C(char *s)
{
  int v2; // r3
  _DWORD *v3; // r4
  char *v4; // r6
  char *v5; // r0
  char *v6; // r5
  int v7; // r3
  void *v8; // r0

  if ( dword_77008 || dword_7700C )
    return "Use only user + pass or userpass, but not both";
  v2 = dword_77010 + 1;
  dword_77010 = v2;
  if ( v2 > dword_7B198 )
  {
    sub_17A3C();
    v2 = dword_77010;
  }
  v3 = *(_DWORD **)(dword_7B438 + 4 * (v2 - 1));
  v4 = _strdup(s);
  sub_5B1D4((int)s, v3 + 50);
  v5 = strtok(v4, ":");
  v3[51] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[52] = v6;
  if ( v6 )
    return 0;
  v8 = calloc(1u, 1u);
  v7 = 0;
  v3[52] = v8;
  return (const char *)v7;
}
// 77008: using guessed type int dword_77008;
// 7700C: using guessed type int dword_7700C;
// 77010: using guessed type int dword_77010;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00017D3C) --------------------------------------------------------
const char *__fastcall sub_17D3C(int a1)
{
  int v3; // r3

  if ( dword_77010 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_77008 + 1;
  dword_77008 = v3;
  if ( v3 > dword_7B198 )
  {
    sub_17A3C();
    v3 = dword_77008;
  }
  sub_5B1D4(a1, (_DWORD *)(*(_DWORD *)(dword_7B438 + 4 * (v3 - 1)) + 204));
  return 0;
}
// 77008: using guessed type int dword_77008;
// 77010: using guessed type int dword_77010;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00017DB8) --------------------------------------------------------
int sub_17DB8()
{
  int v0; // r3

  v0 = ++dword_77014;
  if ( dword_77014 > dword_7B198 )
  {
    sub_17A3C();
    v0 = dword_77014;
  }
  return *(_DWORD *)(dword_7B438 + 4 * (v0 - 1));
}
// 77014: using guessed type int dword_77014;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00017E04) --------------------------------------------------------
int __fastcall sub_17E04(char *a1)
{
  int v2; // r0

  v2 = sub_17DB8();
  sub_17100(v2, a1);
  return 0;
}

//----- (00017F68) --------------------------------------------------------
const char *__fastcall sub_17F68(int a1)
{
  int v3; // r3

  if ( dword_77010 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_7700C + 1;
  dword_7700C = v3;
  if ( v3 > dword_7B198 )
  {
    sub_17A3C();
    v3 = dword_7700C;
  }
  sub_5B1D4(a1, (_DWORD *)(*(_DWORD *)(dword_7B438 + 4 * (v3 - 1)) + 208));
  return 0;
}
// 7700C: using guessed type int dword_7700C;
// 77010: using guessed type int dword_77010;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00017FE4) --------------------------------------------------------
int sub_17FE4()
{
  int v0; // r4

  if ( pthread_mutex_lock(&mutex) )
    sub_B414("lock_curses", 2935);
  v0 = (unsigned __int8)byte_77018;
  if ( byte_77018 )
    return (unsigned __int8)byte_77018;
  if ( pthread_mutex_unlock(&mutex) )
    sub_B5C4("unlock_curses", 2930);
  off_75ED8();
  return v0;
}
// B414: using guessed type void __fastcall __noreturn sub_B414(_DWORD, _DWORD);
// B5C4: using guessed type void __fastcall __noreturn sub_B5C4(_DWORD, _DWORD);
// 75ED8: using guessed type int (*off_75ED8)();
// 77018: using guessed type char byte_77018;

//----- (00018068) --------------------------------------------------------
void sub_18068()
{
  int v0; // r2
  int v1; // r3
  int v2; // r1
  int v3; // r3
  int v4; // r2

  if ( byte_75DD0 && sub_17FE4() )
  {
    werase((WINDOW *)stdscr);
    if ( dword_7B7C0 )
      v0 = *(__int16 *)(dword_7B7C0 + 6);
    else
      v0 = -1;
    v1 = dword_7701C;
    if ( dword_7B7C0 )
      ++v0;
    if ( LINES - 1 <= dword_7701C )
      v1 = LINES - 2;
    dword_77020 = v1;
    dword_77024 = v1;
    wresize((WINDOW *)dword_7B7C0, v1, v0);
    v3 = dword_7BC90;
    if ( dword_7BC90 )
      v2 = *(__int16 *)(dword_7BC90 + 4);
    else
      v3 = -1;
    if ( dword_7BC90 )
      v4 = *(__int16 *)(v3 + 6);
    else
      v4 = v3;
    if ( dword_7BC90 )
    {
      v3 = v2 + 1;
      ++v4;
    }
    wresize((WINDOW *)dword_7B430, v3 - dword_77024, v4);
    mvwin((WINDOW *)dword_7B430, dword_77024, 0);
    if ( pthread_mutex_unlock(&mutex) )
      sub_B5C4("unlock_curses", 2930);
    off_75ED8();
  }
}
// 180FC: variable 'v2' is possibly undefined
// 75DD0: using guessed type char byte_75DD0;
// 75ED8: using guessed type int (*off_75ED8)();
// 76BC0: using guessed type int stdscr;
// 76BC4: using guessed type int LINES;
// 7701C: using guessed type int dword_7701C;
// 77020: using guessed type int dword_77020;
// 77024: using guessed type int dword_77024;
// 7B430: using guessed type int dword_7B430;
// 7B7C0: using guessed type int dword_7B7C0;
// 7BC90: using guessed type int dword_7BC90;

//----- (00018178) --------------------------------------------------------
void __fastcall sub_18178(int a1, int a2)
{
  int v2; // r2

  if ( byte_7B940 )
  {
    v2 = dword_77028;
  }
  else
  {
    v2 = dword_7702C;
    a2 = dword_77028;
  }
  if ( !byte_7B940 )
    v2 += a2;
  dword_7701C = v2 + 1;
  dword_77024 = v2 + 2;
  if ( pthread_mutex_unlock(&mutex) )
    sub_B5C4("unlock_curses", 2930);
  off_75ED8();
  sub_18068();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7701C: using guessed type int dword_7701C;
// 77024: using guessed type int dword_77024;
// 77028: using guessed type int dword_77028;
// 7702C: using guessed type int dword_7702C;
// 7B940: using guessed type char byte_7B940;

//----- (000181F4) --------------------------------------------------------
int __fastcall sub_181F4(int a1, unsigned int a2)
{
  __time_t v5; // r4
  signed int v6; // r1
  int v7; // r4
  struct timeval v9; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  sub_2A84C(&v9);
  v5 = a2 / 0x3E8 + v9.tv_sec;
  v6 = 1000 * a2 - 1000000 * (a2 / 0x3E8) + v9.tv_usec;
  if ( v6 > 999999 )
  {
    ++v5;
    v6 -= 1000000;
  }
  abstime.tv_sec = v5;
  abstime.tv_nsec = 1000 * v6;
  if ( pthread_mutex_lock(&stru_7B62C) )
    sub_B414("restart_wait", 5249);
  if ( *(_BYTE *)(a1 + 62) )
    v7 = 0;
  else
    v7 = pthread_cond_timedwait(&cond, &stru_7B62C, &abstime);
  if ( pthread_mutex_unlock(&stru_7B62C) )
    sub_B5C4("restart_wait", 5254);
  off_75ED8();
  return v7;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (000182F4) --------------------------------------------------------
int *__fastcall sub_182F4(int a1)
{
  _DWORD *v2; // r4
  int v3; // r6
  _DWORD *v4; // r5
  double v5; // d8
  int v6; // r2
  int **v7; // r3
  int v8; // r1
  int *v9; // r0
  bool v10; // zf
  int v11; // r2
  int v12; // r1
  int v13; // r1
  int v14; // r2
  int v15; // r2
  int v16; // r0
  int *result; // r0
  double v18; // d16
  double v19; // d17
  __int64 v20; // r2
  void **v21; // r11
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_77030) )
    sub_B414("clear_stratum_shares", 6986);
  v2 = (_DWORD *)dword_77048;
  if ( dword_77048 )
  {
    v3 = 0;
    v4 = *(_DWORD **)(dword_77048 + 8);
    v5 = 0.0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v2[9] + 1748) == a1 )
      {
        v6 = v2[1];
        if ( v6 || v2[2] )
        {
          v7 = (int **)dword_77048;
          v8 = *(_DWORD *)dword_77048;
          v9 = *(int **)(*(_DWORD *)dword_77048 + 20);
          if ( (_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_77048 + 16) - (_DWORD)v9) == v2 )
          {
            *(_DWORD *)(v8 + 16) = (char *)v9 + v6;
            v6 = v2[1];
          }
          v10 = v6 == 0;
          if ( v6 )
          {
            v9 = *v7;
            v8 = v2[2];
          }
          else
          {
            v6 = v2[2];
          }
          if ( v10 )
          {
            v7 = (int **)v6;
            dword_77048 = v6;
          }
          else
          {
            v6 += v9[5];
          }
          if ( !v10 )
          {
            *(_DWORD *)(v6 + 8) = v8;
            v6 = v2[2];
          }
          if ( v6 )
            *(_DWORD *)(v6 + (*v7)[5] + 4) = v2[1];
          v11 = 3 * (((*v7)[1] - 1) & v2[7]);
          v12 = **v7 + 12 * (((*v7)[1] - 1) & v2[7]);
          --*(_DWORD *)(v12 + 4);
          v13 = **v7;
          if ( *(_DWORD **)(v13 + 4 * v11) == v2 )
            *(_DWORD *)(v13 + 4 * v11) = v2[4];
          v14 = v2[3];
          if ( v14 )
            *(_DWORD *)(v14 + 16) = v2[4];
          v15 = v2[4];
          if ( v15 )
            *(_DWORD *)(v15 + 12) = v2[3];
          --(*v7)[3];
        }
        else
        {
          v21 = (void **)dword_77048;
          free(**(void ***)dword_77048);
          free(*v21);
          dword_77048 = 0;
        }
        v16 = v2[9];
        ++v3;
        v5 = v5 + *(double *)(v16 + 1864);
        sub_15780((void **)v16);
        v2[9] = 0;
        --*(_DWORD *)(a1 + 756);
        free(v2);
        if ( !v4 )
          goto LABEL_28;
      }
      else if ( !v4 )
      {
        goto LABEL_28;
      }
      v2 = v4;
      v4 = (_DWORD *)v4[2];
    }
  }
  v3 = 0;
  v5 = 0.0;
LABEL_28:
  if ( pthread_mutex_unlock(&stru_77030) )
    sub_B5C4("clear_stratum_shares", 6999);
  result = (int *)off_75ED8();
  if ( v3 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      snprintf(s, 0x1000u, "Lost %d shares due to stratum disconnect on pool %d", v3, *(_DWORD *)a1);
      sub_38730(4, s, 0);
    }
    v18 = *(double *)(a1 + 120) + v5;
    v19 = dbl_7B428;
    result = &dword_7BC80;
    v20 = *(_QWORD *)&dword_7BC80;
    *(_DWORD *)(a1 + 152) += v3;
    *(_QWORD *)&dword_7BC80 = v20 + v3;
    *(double *)(a1 + 120) = v18;
    dbl_7B428 = v19 + v5;
  }
  return result;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 77048: using guessed type int dword_77048;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7B428: using guessed type double dbl_7B428;
// 7BC80: using guessed type int dword_7BC80;

//----- (000185C8) --------------------------------------------------------
void __fastcall sub_185C8(_DWORD *a1)
{
  int v2; // r4
  int v3; // r7
  int v4; // r5
  int v5; // r1
  int v6; // r2
  int v7; // r0
  int v8; // r3
  int v9; // r12
  bool v10; // zf
  _DWORD *v11; // r1
  int v12; // r3
  int v13; // r1
  int v14; // r1
  int v15; // r12
  int v16; // r3
  int v17; // r3
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
    sub_B414("clear_pool_work", 7016);
  v2 = dword_77050;
  if ( dword_77050 )
  {
    v4 = *(_DWORD *)(dword_77050 + 1840);
    v3 = 0;
    while ( 1 )
    {
      if ( *(_DWORD **)(v2 + 1748) == a1 )
      {
        v5 = *(_DWORD *)(v2 + 1836);
        if ( v5 || *(_DWORD *)(v2 + 1840) )
        {
          v6 = dword_77050;
          v7 = v2 + 1832;
          v8 = *(_DWORD *)(dword_77050 + 1832);
          v9 = *(_DWORD *)(v8 + 20);
          if ( *(_DWORD *)(v8 + 16) - v9 == v2 )
          {
            *(_DWORD *)(v8 + 16) = v5 + v9;
            v5 = *(_DWORD *)(v2 + 1836);
          }
          v10 = v5 == 0;
          if ( v5 )
          {
            v9 = *(_DWORD *)(v6 + 1832);
            v8 = *(_DWORD *)(v2 + 1840);
          }
          else
          {
            v6 = *(_DWORD *)(v2 + 1840);
          }
          if ( v5 )
          {
            v5 += *(_DWORD *)(v9 + 20);
          }
          else
          {
            dword_77050 = v6;
            v8 = v6;
          }
          if ( !v10 )
          {
            *(_DWORD *)(v5 + 8) = v8;
            v8 = *(_DWORD *)(v2 + 1840);
          }
          if ( v8 )
            *(_DWORD *)(v8 + *(_DWORD *)(*(_DWORD *)(v6 + 1832) + 20) + 4) = *(_DWORD *)(v2 + 1836);
          v11 = *(_DWORD **)(v6 + 1832);
          v12 = 3 * ((v11[1] - 1) & *(_DWORD *)(v2 + 1860));
          v13 = *v11 + 12 * ((v11[1] - 1) & *(_DWORD *)(v2 + 1860));
          --*(_DWORD *)(v13 + 4);
          v14 = **(_DWORD **)(v6 + 1832);
          v15 = *(_DWORD *)(v14 + 4 * v12);
          if ( v15 == v7 )
          {
            v6 = *(_DWORD *)(v2 + 1848);
            *(_DWORD *)(v14 + 4 * v12) = v6;
          }
          v16 = *(_DWORD *)(v2 + 1844);
          if ( v15 == v7 )
            v6 = dword_77050;
          if ( v16 )
            *(_DWORD *)(v16 + 16) = *(_DWORD *)(v2 + 1848);
          v17 = *(_DWORD *)(v2 + 1848);
          if ( v17 )
            *(_DWORD *)(v17 + 12) = *(_DWORD *)(v2 + 1844);
          --*(_DWORD *)(*(_DWORD *)(v6 + 1832) + 12);
        }
        else
        {
          free(**(void ***)(dword_77050 + 1832));
          free(*(void **)(dword_77050 + 1832));
          dword_77050 = 0;
        }
        ++v3;
        sub_15780((void **)v2);
        if ( !v4 )
          goto LABEL_31;
      }
      else if ( !v4 )
      {
        goto LABEL_31;
      }
      v2 = v4;
      v4 = *(_DWORD *)(v4 + 1840);
    }
  }
  v3 = 0;
LABEL_31:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
    sub_B5C4("clear_pool_work", 7026);
  off_75ED8();
  if ( v3 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "Cleared %d work items due to stratum disconnect on pool %d", v3, *a1);
    sub_38730(7, s, 0);
  }
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 7704C: using guessed type int dword_7704C;
// 77050: using guessed type int dword_77050;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00018834) --------------------------------------------------------
int __fastcall sub_18834(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r5
  pthread_mutex_t *v4; // r0
  int v5; // r5

  v2 = (pthread_mutex_t *)(a1 + 220);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 220)) )
    sub_B414("pool_tset", 772);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    sub_B5C4("pool_tset", 775);
  off_75ED8();
  return v5;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (000188A8) --------------------------------------------------------
int sub_188A8()
{
  int v0; // r5
  int v1; // r3

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
    sub_B414("total_staged", 2907);
  if ( dword_77050 )
    v1 = *(_DWORD *)(dword_77050 + 1832);
  else
    v0 = 0;
  if ( dword_77050 )
    v0 = *(_DWORD *)(v1 + 12);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
    sub_B5C4("total_staged", 2909);
  off_75ED8();
  return v0;
}
// 188D4: variable 'v1' is possibly undefined
// 188F0: variable 'v0' is possibly undefined
// 75ED8: using guessed type int (*off_75ED8)();
// 7704C: using guessed type int dword_7704C;
// 77050: using guessed type int dword_77050;

//----- (00018924) --------------------------------------------------------
int __fastcall sub_18924(int a1, int a2)
{
  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("inc_dev_status", 8321);
  dword_7B8A8 = a1;
  dword_7BB20 = a2;
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("inc_dev_status", 8324);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B8A8: using guessed type int dword_7B8A8;
// 7BB20: using guessed type int dword_7BB20;

//----- (000189A4) --------------------------------------------------------
int __fastcall sub_189A4(int a1)
{
  int v2; // r1
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_38730(7, s, 1);
  }
  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("inc_hw_errors", 8296);
  v2 = dword_7B8A4;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 44);
  dword_7B8A4 = v2 + 1;
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("inc_hw_errors", 8299);
  off_75ED8();
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B8A4: using guessed type int dword_7B8A4;

//----- (00018AD8) --------------------------------------------------------
int sub_18AD8()
{
  int result; // r0

  result = sub_17FE4();
  if ( result )
  {
    werase((WINDOW *)stdscr);
    wclear((WINDOW *)dword_7B430);
    if ( pthread_mutex_unlock(&mutex) )
      sub_B5C4("unlock_curses", 2930);
    return off_75ED8();
  }
  return result;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 76BC0: using guessed type int stdscr;
// 7B430: using guessed type int dword_7B430;

//----- (00018B44) --------------------------------------------------------
int sub_18B44()
{
  int result; // r0
  int v1; // r2

  result = sub_17FE4();
  if ( result )
  {
    if ( dword_7B430 )
      v1 = *(__int16 *)(dword_7B430 + 4);
    else
      v1 = -1;
    if ( dword_7B430 )
      ++v1;
    wtouchln((WINDOW *)dword_7B430, 0, v1, 1);
    wrefresh((WINDOW *)dword_7B430);
    if ( pthread_mutex_unlock(&mutex) )
      sub_B5C4("unlock_curses", 2930);
    return off_75ED8();
  }
  return result;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B430: using guessed type int dword_7B430;

//----- (00018BC0) --------------------------------------------------------
int __fastcall sub_18BC0(const char *a1)
{
  int result; // r0

  result = sub_17FE4();
  if ( result )
  {
    wprintw((WINDOW *)dword_7B430, "%s", a1);
    if ( pthread_mutex_unlock(&mutex) )
      sub_B5C4("unlock_curses", 2930);
    return off_75ED8();
  }
  return result;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B430: using guessed type int dword_7B430;

//----- (00018C2C) --------------------------------------------------------
int __fastcall sub_18C2C(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r5
  pthread_mutex_t *v4; // r0
  int v5; // r5

  v2 = (pthread_mutex_t *)(a1 + 220);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 220)) )
    sub_B414("pool_tclear", 784);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    sub_B5C4("pool_tclear", 787);
  off_75ED8();
  return v5;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (00018CA0) --------------------------------------------------------
int __fastcall sub_18CA0(_DWORD *a1, int a2)
{
  char *v4; // r1
  int v6; // r2
  int v7; // r1
  int v8; // r3
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r1
  int v24; // r2
  int v25; // r3
  struct timeval v26; // [sp+8h] [bp-1010h] BYREF
  struct timeval v27; // [sp+10h] [bp-1008h] BYREF
  _DWORD dest[1024]; // [sp+18h] [bp-1000h] BYREF

  if ( *((_BYTE *)a1 + 760) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf((char *)dest, 0x1000u, "Retrieving block template from pool %s", a1[49]);
      goto LABEL_64;
    }
  }
  else if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf((char *)dest, 0x1000u, "Testing pool %s", a1[49]);
LABEL_64:
    sub_38730(7, (const char *)dest, 0);
  }
  if ( *((_BYTE *)a1 + 664) )
    goto LABEL_12;
  if ( !off_75DD4 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      strcpy((char *)dest, "CURL initialisation failed");
      sub_38730(3, (const char *)dest, 0);
      return 0;
    }
    return 0;
  }
  if ( *((_BYTE *)a1 + 131) )
    goto LABEL_8;
  if ( !byte_78E09 )
  {
    *((_BYTE *)a1 + 131) = 0;
    goto LABEL_8;
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
  {
    strcpy((char *)dest, "Probing for GBT support");
    sub_38730(7, (const char *)dest, 0);
    v7 = *((unsigned __int8 *)a1 + 760);
    v8 = (unsigned __int8)byte_78E09;
    *((_BYTE *)a1 + 131) = 0;
    if ( !v7 )
    {
      if ( !*((_BYTE *)a1 + 924) )
      {
        if ( !v8 )
          goto LABEL_8;
        goto LABEL_46;
      }
      if ( !v8 )
        goto LABEL_8;
LABEL_42:
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
      {
        strcpy((char *)dest, "GBT coinbase without append found, switching to GBT solo protocol");
        sub_38730(7, (const char *)dest, 0);
      }
      goto LABEL_8;
    }
    if ( !v8 )
      goto LABEL_8;
LABEL_35:
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
      goto LABEL_8;
    v9 = "GBT coinbase + append support found, switching to GBT protocol";
    goto LABEL_39;
  }
  v6 = *((unsigned __int8 *)a1 + 760);
  *((_BYTE *)a1 + 131) = 0;
  if ( v6 )
    goto LABEL_35;
  if ( *((_BYTE *)a1 + 924) )
    goto LABEL_42;
LABEL_46:
  if ( byte_7AD48 || byte_78E08 )
  {
    v9 = "No GBT coinbase + append support found, using getwork protocol";
LABEL_39:
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v14 = (int *)(v9 + 16);
    dest[0] = v10;
    dest[1] = v11;
    dest[2] = v12;
    dest[3] = v13;
    v15 = *v14;
    v16 = v14[1];
    v17 = v14[2];
    v18 = v14[3];
    v14 += 4;
    dest[4] = v15;
    dest[5] = v16;
    dest[6] = v17;
    dest[7] = v18;
    v19 = *v14;
    v20 = v14[1];
    v21 = v14[2];
    v22 = v14[3];
    v14 += 4;
    dest[8] = v19;
    dest[9] = v20;
    dest[10] = v21;
    dest[11] = v22;
    v23 = v14[1];
    v24 = v14[2];
    v25 = v14[3];
    dest[12] = *v14;
    dest[13] = v23;
    dest[14] = v24;
    LOWORD(dest[15]) = v25;
    BYTE2(dest[15]) = BYTE2(v25);
    sub_38730(7, (const char *)dest, 0);
    goto LABEL_8;
  }
  if ( dword_766C4 > 6 )
  {
    v9 = "No GBT coinbase + append support found, using getwork protocol";
    goto LABEL_39;
  }
LABEL_8:
  sub_2A84C(&v26);
  sub_2A84C(&v27);
  v4 = (char *)a1[150];
  if ( v4 && !byte_77054 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf((char *)dest, 0x1000u, "Testing pool %d stratum %s", *a1, (const char *)a1[150]);
      sub_38730(7, (const char *)dest, 0);
      v4 = (char *)a1[150];
    }
    sub_2AA68((int)a1, v4);
    if ( sub_2AB54((const char *)a1[150], a1 + 156, (char **)a1 + 152) )
    {
      if ( sub_2B8E8(a1) )
      {
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(
            (char *)dest,
            0x1000u,
            "Switching pool %d %s to %s",
            *a1,
            (const char *)a1[49],
            (const char *)a1[150]);
          sub_38730(7, (const char *)dest, 0);
        }
        if ( !a1[49] )
          a1[49] = _strdup((const char *)a1[150]);
        goto LABEL_11;
      }
    }
  }
  if ( !sub_2B8E8(a1) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf((char *)dest, 0x1000u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[49]);
      sub_38730(7, (const char *)dest, 0);
    }
    if ( !a2 && !*((_BYTE *)a1 + 129) && (byte_7AD48 || byte_78E08 || dword_766C4 > 3) )
    {
      snprintf((char *)dest, 0x1000u, "Pool %u slow/down or URL or credentials invalid", *a1);
      sub_38730(4, (const char *)dest, 0);
    }
    return 0;
  }
LABEL_11:
  *((_BYTE *)a1 + 664) = 1;
LABEL_12:
  if ( sub_18834((int)a1, (_BYTE *)a1 + 666) )
    return *((unsigned __int8 *)a1 + 665);
  if ( sub_2B8E8(a1) && sub_2EA38(a1) )
  {
    nullsub_1(a1);
    byte_7BC79 = 1;
    if ( pthread_create(a1 + 180, 0, (void *(*)(void *))sub_21FE8, a1) )
    {
      strcpy((char *)dest, "Failed to create stratum sthread");
      sub_38730(3, (const char *)dest, 1);
      sub_16CA8(1);
    }
    if ( pthread_create(a1 + 181, 0, (void *(*)(void *))sub_20088, a1) )
    {
      strcpy((char *)dest, "Failed to create stratum rthread");
      sub_38730(3, (const char *)dest, 1);
      sub_16CA8(1);
    }
    return 1;
  }
  else
  {
    nullsub_1(a1);
    sub_18C2C((int)a1, (_BYTE *)a1 + 666);
    return 0;
  }
}
// 2B8E4: using guessed type int __fastcall nullsub_1(_DWORD);
// 75DD4: using guessed type char *off_75DD4;
// 766C4: using guessed type int dword_766C4;
// 77054: using guessed type char byte_77054;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7BC79: using guessed type char byte_7BC79;

//----- (000193B4) --------------------------------------------------------
int __fastcall sub_193B4(int a1)
{
  int v2; // r3
  int v3; // r0
  int v4; // r2
  int v5; // r12
  int v6; // r1
  bool v7; // zf
  int v8; // r2
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r2
  struct timespec v14; // [sp+0h] [bp-1014h] BYREF
  struct timeval v15; // [sp+8h] [bp-100Ch] BYREF
  char v16[4080]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
    sub_B414("hash_pop", 7715);
  if ( dword_77050 && *(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 12) )
  {
    if ( !byte_7B4C8 )
      goto LABEL_18;
    goto LABEL_14;
  }
  if ( byte_77055 && dword_75DD8 < dword_75DDC )
  {
    ++dword_75DD8;
    byte_77055 = 0;
  }
  byte_77056 = 1;
  if ( a1 )
  {
    do
    {
      sub_2A84C(&v15);
      v14.tv_nsec = 1000 * v15.tv_usec;
      v14.tv_sec = v15.tv_sec + 10;
      pthread_cond_signal(&stru_7B1A0);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_7B620 + 40), (pthread_mutex_t *)dword_7704C, &v14) )
      {
        if ( !byte_7B4C8 )
        {
          byte_7B4C8 = 1;
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            strcpy(v16, "Waiting for work to be available from pools.");
            sub_38730(4, v16, 0);
          }
        }
      }
    }
    while ( !dword_77050 || !*(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 12) );
    if ( !byte_7B4C8 )
    {
LABEL_18:
      v2 = dword_77050;
      if ( dword_77050 )
      {
        v3 = *(_DWORD *)(dword_77050 + 1832);
        if ( dword_77058 < *(_DWORD *)(v3 + 12)
          && (a1 = *(_DWORD *)(dword_77050 + 1840), !*(_BYTE *)(dword_77050 + 1761))
          && *(_DWORD *)(dword_77050 + 1764) )
        {
          while ( a1 )
          {
            if ( *(_BYTE *)(a1 + 1761) )
            {
              v4 = *(_DWORD *)(a1 + 1836);
              if ( v4 )
                goto LABEL_22;
              goto LABEL_61;
            }
            if ( !*(_DWORD *)(a1 + 1764) )
              break;
            a1 = *(_DWORD *)(a1 + 1840);
          }
        }
        else
        {
          a1 = dword_77050;
        }
      }
      else
      {
        v3 = MEMORY[0x728];
        a1 = 0;
      }
      v4 = *(_DWORD *)(a1 + 1836);
      if ( !v4 )
      {
LABEL_61:
        if ( !*(_DWORD *)(a1 + 1840) )
        {
          free(*(void **)v3);
          free(*(void **)(dword_77050 + 1832));
          dword_77050 = 0;
LABEL_43:
          if ( !*(_BYTE *)(a1 + 1761) && *(_DWORD *)(a1 + 1764) )
            --dword_77058;
          pthread_cond_signal(&stru_7B1A0);
          pthread_cond_signal((pthread_cond_t *)(dword_7B620 + 40));
          dword_7B948 = time(0);
          goto LABEL_45;
        }
      }
LABEL_22:
      v5 = *(_DWORD *)(v3 + 20);
      v6 = a1 + 1832;
      if ( *(_DWORD *)(v3 + 16) - v5 == a1 )
      {
        *(_DWORD *)(v3 + 16) = v4 + v5;
        v4 = *(_DWORD *)(a1 + 1836);
      }
      v7 = v4 == 0;
      if ( v4 )
      {
        v5 = *(_DWORD *)(v2 + 1832);
        v3 = *(_DWORD *)(a1 + 1840);
      }
      else
      {
        v4 = *(_DWORD *)(a1 + 1840);
      }
      if ( v7 )
      {
        v2 = v4;
        dword_77050 = v4;
      }
      else
      {
        v4 += *(_DWORD *)(v5 + 20);
      }
      if ( !v7 )
      {
        *(_DWORD *)(v4 + 8) = v3;
        v4 = *(_DWORD *)(a1 + 1840);
      }
      if ( v4 )
        *(_DWORD *)(v4 + *(_DWORD *)(*(_DWORD *)(v2 + 1832) + 20) + 4) = *(_DWORD *)(a1 + 1836);
      v8 = 12 * ((*(_DWORD *)(*(_DWORD *)(v2 + 1832) + 4) - 1) & *(_DWORD *)(a1 + 1860));
      --*(_DWORD *)(**(_DWORD **)(v2 + 1832) + v8 + 4);
      v9 = **(_DWORD **)(v2 + 1832);
      v10 = *(_DWORD *)(v9 + v8);
      if ( v10 == v6 )
      {
        v2 = *(_DWORD *)(a1 + 1848);
        *(_DWORD *)(v9 + v8) = v2;
      }
      v11 = *(_DWORD *)(a1 + 1844);
      if ( v10 == v6 )
        v2 = dword_77050;
      if ( v11 )
        *(_DWORD *)(v11 + 16) = *(_DWORD *)(a1 + 1848);
      v12 = *(_DWORD *)(a1 + 1848);
      if ( v12 )
        *(_DWORD *)(v12 + 12) = *(_DWORD *)(a1 + 1844);
      --*(_DWORD *)(*(_DWORD *)(v2 + 1832) + 12);
      goto LABEL_43;
    }
LABEL_14:
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      strcpy(v16, "Work available from pools, resuming.");
      sub_38730(4, v16, 0);
    }
    byte_7B4C8 = 0;
    goto LABEL_18;
  }
LABEL_45:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
    sub_B5C4("hash_pop", 7782);
  off_75ED8();
  return a1;
}
// 75DD8: using guessed type int dword_75DD8;
// 75DDC: using guessed type int dword_75DDC;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 7704C: using guessed type int dword_7704C;
// 77050: using guessed type int dword_77050;
// 77055: using guessed type char byte_77055;
// 77056: using guessed type char byte_77056;
// 77058: using guessed type int dword_77058;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7B4C8: using guessed type char byte_7B4C8;
// 7B620: using guessed type int dword_7B620;
// 7B948: using guessed type int dword_7B948;

//----- (00019840) --------------------------------------------------------
int sub_19840()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
    sub_B414("wake_gws", 5204);
  pthread_cond_signal(&stru_7B1A0);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
    sub_B5C4("wake_gws", 5206);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7704C: using guessed type int dword_7704C;

//----- (000198B0) --------------------------------------------------------
int __fastcall sub_198B0(int a1, int a2)
{
  int v4; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_38730(7, s, 0);
  }
  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("inc_hw_errors_with_diff", 8309);
  v4 = dword_7B8A4;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 44) += a2;
  dword_7B8A4 = v4 + a2;
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("inc_hw_errors_with_diff", 8312);
  off_75ED8();
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B8A4: using guessed type int dword_7B8A4;

//----- (000199E8) --------------------------------------------------------
int __fastcall sub_199E8(int a1, const char *a2, const char *a3)
{
  int result; // r0
  _BOOL4 v7; // r4
  int v8; // r2

  result = sub_17FE4();
  if ( !result )
    return result;
  v7 = (unsigned int)(a1 - 3) <= 1;
  if ( byte_7BAC8 )
  {
    if ( v7 )
    {
      wprintw((WINDOW *)dword_7B430, "%s%s\n", a2, a3);
LABEL_5:
      if ( dword_7B430 )
        v8 = *(__int16 *)(dword_7B430 + 4);
      else
        v8 = -1;
      if ( dword_7B430 )
        ++v8;
      wtouchln((WINDOW *)dword_7B430, 0, v8, 1);
      wrefresh((WINDOW *)dword_7B430);
    }
  }
  else
  {
    wprintw((WINDOW *)dword_7B430, "%s%s\n", a2, a3);
    if ( v7 )
      goto LABEL_5;
  }
  if ( pthread_mutex_unlock(&mutex) )
    sub_B5C4("unlock_curses", 2930);
  off_75ED8();
  return 1;
}
// B5C4: using guessed type void __fastcall __noreturn sub_B5C4(_DWORD, _DWORD);
// 75ED8: using guessed type int (*off_75ED8)();
// 7B430: using guessed type int dword_7B430;
// 7BAC8: using guessed type char byte_7BAC8;

//----- (00019ADC) --------------------------------------------------------
int sub_19ADC()
{
  pthread_mutex_trylock(&mutex);
  if ( !byte_77018 )
  {
    if ( !pthread_mutex_unlock(&mutex) )
      return off_75ED8();
LABEL_5:
    sub_B5C4("unlock_curses", 2930);
  }
  byte_75DD0 = 0;
  byte_77018 = 0;
  leaveok((WINDOW *)dword_7B430, 0);
  leaveok((WINDOW *)dword_7B7C0, 0);
  leaveok((WINDOW *)dword_7BC90, 0);
  nocbreak();
  echo();
  delwin((WINDOW *)dword_7B430);
  delwin((WINDOW *)dword_7B7C0);
  delwin((WINDOW *)dword_7BC90);
  endwin();
  if ( pthread_mutex_unlock(&mutex) )
    goto LABEL_5;
  return off_75ED8();
}
// 75DD0: using guessed type char byte_75DD0;
// 75ED8: using guessed type int (*off_75ED8)();
// 77018: using guessed type char byte_77018;
// 7B430: using guessed type int dword_7B430;
// 7B7C0: using guessed type int dword_7B7C0;
// 7BC90: using guessed type int dword_7BC90;

//----- (00019BBC) --------------------------------------------------------
int __fastcall sub_19BBC(pthread_rwlock_t *a1, const char *a2, int a3)
{
  if ( pthread_rwlock_unlock(a1) )
    sub_B630(a2, a3);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (00019BF8) --------------------------------------------------------
int __fastcall sub_19BF8(int a1)
{
  _DWORD *v2; // r6
  int v3; // r7
  int v4; // r12
  int *v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // t1
  int v9; // r2
  bool v10; // cc
  int v11; // r2
  char v12; // r3
  int v13; // r3
  int v14; // r4
  int v15; // r0
  int v16; // r0
  int v17; // r4
  int v19; // r3
  int v20; // r2
  int v21; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_7BA10) )
    sub_B414("switch_pools", 5101);
  if ( pthread_rwlock_wrlock(&stru_7BA28) )
    sub_B480("switch_pools", 5101);
  v2 = (_DWORD *)dword_7705C;
  v3 = *(_DWORD *)dword_7705C;
  if ( a1 && (v4 = *(_DWORD *)(a1 + 4)) != 0 )
  {
    if ( dword_7B198 > 0 )
    {
      v5 = (int *)dword_7B438;
      v6 = dword_7B438 + 4 * dword_7B198;
      while ( 1 )
      {
        v8 = *v5++;
        v7 = v8;
        v9 = *(_DWORD *)(v8 + 4);
        v10 = v9 < v4;
        v11 = v9 + 1;
        if ( v10 )
          *(_DWORD *)(v7 + 4) = v11;
        if ( v5 == (int *)v6 )
          break;
        v4 = *(_DWORD *)(a1 + 4);
      }
    }
    *(_DWORD *)(a1 + 4) = 0;
    v12 = dword_76EFC;
    if ( (unsigned int)dword_76EFC > 4 )
      goto LABEL_37;
  }
  else
  {
    v12 = dword_76EFC;
    if ( (unsigned int)dword_76EFC > 4 )
      goto LABEL_37;
  }
  v13 = 1 << v12;
  if ( (v13 & 0x19) != 0 )
  {
    if ( dword_7B198 > 0 )
    {
      v14 = 0;
      while ( 1 )
      {
        v15 = v14++;
        v16 = sub_12038(v15);
        if ( !*(_BYTE *)(v16 + 129) && *(_DWORD *)(v16 + 132) == 1 )
          break;
        if ( dword_7B198 <= v14 )
          goto LABEL_37;
      }
      v17 = *(_DWORD *)(dword_7B438 + 4 * *(_DWORD *)v16);
      goto LABEL_21;
    }
LABEL_37:
    v17 = *(_DWORD *)(dword_7B438 + 4 * v3);
    goto LABEL_21;
  }
  if ( (v13 & 6) == 0 )
    goto LABEL_37;
  if ( a1 && !*(_BYTE *)(a1 + 129) )
  {
    v17 = *(_DWORD *)(dword_7B438 + 4 * *(_DWORD *)a1);
    goto LABEL_21;
  }
  if ( dword_7B198 <= 1 )
    goto LABEL_37;
  v19 = v3;
  v20 = 1;
  while ( 1 )
  {
    ++v19;
    ++v20;
    v21 = 4 * v19;
    if ( v19 >= dword_7B198 )
    {
      v19 = 0;
      v21 = 0;
    }
    v17 = *(_DWORD *)(dword_7B438 + v21);
    if ( !*(_BYTE *)(v17 + 129) && *(_DWORD *)(v17 + 132) == 1 )
      break;
    if ( v20 == dword_7B198 )
    {
      v17 = *(_DWORD *)(dword_7B438 + 4 * v3);
      break;
    }
  }
LABEL_21:
  dword_7705C = v17;
  if ( pthread_rwlock_unlock(&stru_7BA28) )
    sub_B630("switch_pools", 5163);
  if ( pthread_mutex_unlock(&stru_7BA10) )
    sub_B5C4("switch_pools", 5163);
  off_75ED8();
  if ( byte_7B625 )
    sub_18834(v17, (_BYTE *)(v17 + 130));
  if ( v2 != (_DWORD *)v17 && dword_76EFC != 3 && dword_76EFC != 4 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      snprintf(s, 0x1000u, "Switching to pool %d %s", *(_DWORD *)v17, *(const char **)(v17 + 196));
      sub_38730(4, s, 0);
    }
    sub_185C8(v2);
  }
  if ( pthread_mutex_lock(&stru_77060) )
    sub_B414("switch_pools", 5178);
  pthread_cond_broadcast(&stru_77078);
  if ( pthread_mutex_unlock(&stru_77060) )
    sub_B5C4("switch_pools", 5180);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76EFC: using guessed type int dword_76EFC;
// 7705C: using guessed type int dword_7705C;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;
// 7B625: using guessed type char byte_7B625;

//----- (00019F54) --------------------------------------------------------
int __fastcall sub_19F54(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B480("add_queued", 8825);
  sub_16624((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_B630("add_queued", 8827);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (00019FC8) --------------------------------------------------------
int __fastcall sub_19FC8(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r8
  int lock; // r5
  int i; // r4
  struct timeval v6; // [sp+0h] [bp-8h] BYREF

  v1 = a1 + 10;
  sub_2A84C(&v6);
  if ( pthread_rwlock_wrlock(v1) )
    sub_B480("age_queued_work", 8950);
  lock = a1[11].__lock;
  if ( lock )
  {
    for ( i = *(_DWORD *)(lock + 1840); ; i = *(_DWORD *)(i + 1840) )
    {
      sub_2AA24();
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(v1) )
    sub_B630("age_queued_work", 8960);
  off_75ED8();
  return 0;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001A0B8) --------------------------------------------------------
void __fastcall sub_1A0B8(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B480("work_completed", 8969);
  sub_16B40((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_B630("work_completed", 8971);
  off_75ED8();
  sub_15780(a2);
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001A134) --------------------------------------------------------
_DWORD *__fastcall sub_1A134(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r5
  _DWORD *v11; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B480("take_queued_work_bymidstate", 8982);
  v11 = (_DWORD *)sub_16A80(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
    sub_16B40((int)a1, v11);
  if ( pthread_rwlock_unlock(v6) )
    sub_B630("take_queued_work_bymidstate", 8986);
  off_75ED8();
  return v11;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001A1E8) --------------------------------------------------------
int sub_1A1E8()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_7BA10) )
    sub_B414("total_work_inc", 2273);
  if ( pthread_rwlock_wrlock(&stru_7BA28) )
    sub_B480("total_work_inc", 2273);
  v0 = dword_770A8++;
  if ( pthread_rwlock_unlock(&stru_7BA28) )
    sub_B630("total_work_inc", 2275);
  if ( pthread_mutex_unlock(&stru_7BA10) )
    sub_B5C4("total_work_inc", 2275);
  off_75ED8();
  return v0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 770A8: using guessed type int dword_770A8;

//----- (0001A2A4) --------------------------------------------------------
int __fastcall sub_1A2A4(int a1)
{
  bool v2; // zf
  unsigned int v3; // r0
  int v4; // r2
  _BYTE *v5; // r5
  int result; // r0
  unsigned int v7[1024]; // [sp+0h] [bp-1004h] BYREF

  v2 = byte_78E09 == 0;
  v3 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v4 = dword_7B4CC + 1;
  ++*(_DWORD *)(a1 + 1728);
  *(_DWORD *)(a1 + 68) = v3;
  *(_DWORD *)(a1 + 1736) = 0;
  dword_7B4CC = v4;
  if ( !v2 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy((char *)v7, "Successfully rolled work");
    sub_38730(7, (const char *)v7, 0);
  }
  v5 = *(_BYTE **)(a1 + 1796);
  if ( v5 )
  {
    sub_29830(v7, *(unsigned __int8 **)(a1 + 1796), 4);
    v7[0] = bswap32(bswap32(v7[0]) + 1);
    sub_296D8(v5, (char *)v7, 4);
  }
  result = sub_1A1E8();
  *(_DWORD *)(a1 + 1828) = result;
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B4CC: using guessed type int dword_7B4CC;

//----- (0001A3D4) --------------------------------------------------------
_DWORD *sub_1A3D4()
{
  _DWORD *v0; // r4
  char v2[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = calloc(1u, 0x7B0u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc work in make_work");
    sub_38730(3, v2, 1);
    sub_16CA8(1);
  }
  v0[457] = sub_1A1E8();
  return v0;
}

//----- (0001A44C) --------------------------------------------------------
_DWORD *__fastcall sub_1A44C(int a1, int a2)
{
  _DWORD *v4; // r4

  v4 = sub_1A3D4();
  sub_15684((int)v4, a1, a2);
  return v4;
}

//----- (0001A474) --------------------------------------------------------
_DWORD *__fastcall sub_1A474(int a1)
{
  _DWORD *v1; // r4
  int v3; // r2

  v1 = sub_1A44C(a1, 0);
  *((_BYTE *)v1 + 1761) = 1;
  sub_2A84C((struct timeval *)v1 + 238);
  v3 = v1[438] - 1;
  *((_BYTE *)v1 + 1768) = 0;
  v1[438] = v3;
  *((_BYTE *)v1 + 1770) = 0;
  return v1;
}

//----- (0001A4B4) --------------------------------------------------------
unsigned __int64 __fastcall sub_1A4B4(int a1)
{
  double v1; // d9
  __int64 v3; // r0
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d8
  double v8; // r0
  double v9; // d8
  double v10; // r0
  double v11; // d0
  int v12; // r1
  unsigned __int64 v13; // r4
  int v14; // r7
  int v15; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = 1.7668201e72;
  v3 = *(_QWORD *)(a1 + 216);
  if ( !byte_7B859 )
    v1 = 2.69595353e67;
  LODWORD(v4) = sub_5CB50(v3);
  v5 = v4 * 6.27710174e57;
  LODWORD(v6) = sub_5CB50(*(_QWORD *)(a1 + 208));
  v7 = v5 + v6 * 3.40282367e38;
  LODWORD(v8) = sub_5CB50(*(_QWORD *)(a1 + 200));
  v9 = v7 + v8 * 1.84467441e19;
  LODWORD(v10) = sub_5CB50(*(_QWORD *)(a1 + 192));
  v11 = v9 + v10;
  if ( v9 + v10 == 0.0 )
    v11 = 0.0;
  round(LODWORD(v10));
  LODWORD(v13) = sub_5CC48(v1 / v11);
  HIDWORD(v13) = v12;
  if ( pthread_mutex_lock(&stru_7BA10) )
    sub_B414("share_diff", 4986);
  if ( pthread_rwlock_wrlock(&stru_7BA28) )
    sub_B480("share_diff", 4986);
  if ( qword_76F18 < v13 )
  {
    v14 = 1;
    qword_76F18 = v13;
    sub_11580(v13, (char *)&dword_75DC4, 8u, 0);
  }
  else
  {
    v14 = 0;
  }
  v15 = *(_DWORD *)(a1 + 1748);
  if ( *(_QWORD *)(v15 + 400) < v13 )
    *(_QWORD *)(v15 + 400) = v13;
  if ( pthread_rwlock_unlock(&stru_7BA28) )
    sub_B630("share_diff", 4995);
  if ( pthread_mutex_unlock(&stru_7BA10) )
    sub_B5C4("share_diff", 4995);
  off_75ED8();
  if ( v14 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "New best share: %s", (const char *)&dword_75DC4);
    sub_38730(7, s, 0);
  }
  return v13;
}
// 1A4F4: variable 'v4' is possibly undefined
// 1A508: variable 'v6' is possibly undefined
// 1A51C: variable 'v8' is possibly undefined
// 1A52C: variable 'v10' is possibly undefined
// 1A554: variable 'v12' is possibly undefined
// ADD8: using guessed type int __fastcall round(_DWORD);
// 75DC4: using guessed type int dword_75DC4;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76F18: using guessed type __int64 qword_76F18;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B859: using guessed type char byte_7B859;

//----- (0001A730) --------------------------------------------------------
int __fastcall sub_1A730(int a1, int a2)
{
  double v2; // d16
  double v5; // d8
  unsigned __int64 v6; // r0
  bool v7; // zf
  double v8; // r0
  double *v9; // r6
  double v10; // d8
  double v11; // r0
  __int64 v12; // r0
  int v13; // r7
  double v14; // r0
  __int64 v15; // r0
  int v16; // r4
  double v17; // r0
  __int64 v18; // r0
  int v19; // r4
  int v21; // r2
  int v22; // r0
  int v23; // r12
  int v24; // r0
  char v25[4096]; // [sp+0h] [bp-1000h] BYREF

  v5 = dbl_75DE0;
  v6 = sub_1A4B4(a2);
  v7 = byte_7B859 == 0;
  if ( byte_7B859 )
    v2 = 65536.0;
  *(_QWORD *)(a2 + 1720) = v6;
  if ( !v7 )
    v5 = v5 * v2;
  LODWORD(v8) = sub_5CB50(v6);
  if ( v5 <= v8 )
  {
    v21 = *(_DWORD *)(a2 + 1748);
    v22 = (unsigned __int8)byte_7AD48;
    v23 = dword_7B8B8;
    *(_BYTE *)(a2 + 1771) = 1;
    v7 = v22 == 0;
    v24 = *(_DWORD *)(v21 + 32);
    dword_7B8B8 = v23 + 1;
    *(_DWORD *)(v21 + 32) = v24 + 1;
    *(_BYTE *)(a2 + 1770) = 1;
    if ( !v7 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(v25, 0x1000u, "Found block for pool %d!", **(_DWORD **)(a2 + 1748));
      sub_38730(5, v25, 0);
    }
  }
  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("update_work_stats", 8383);
  v9 = (double *)(a2 + 1712);
  v10 = *(double *)(a2 + 1712);
  LODWORD(v11) = sub_5CB64(*(__int64 *)&dword_7B100);
  LODWORD(v12) = sub_5CC10(v11 + v10);
  v13 = *(_DWORD *)(a1 + 36);
  *(_QWORD *)&dword_7B100 = v12;
  LODWORD(v14) = sub_5CB64(*(_QWORD *)(v13 + 192));
  LODWORD(v15) = sub_5CC10(v10 + v14);
  *(_QWORD *)(v13 + 192) = v15;
  v16 = *(_DWORD *)(a2 + 1748);
  LODWORD(v17) = sub_5CB64(*(_QWORD *)(v16 + 40));
  LODWORD(v18) = sub_5CC10(v17 + *v9);
  *(_QWORD *)(v16 + 40) = v18;
  v19 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v19 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("update_work_stats", 8388);
  return off_75ED8();
}
// 1A76C: variable 'v2' is possibly undefined
// 1A780: variable 'v8' is possibly undefined
// 1A7B0: variable 'v11' is possibly undefined
// 1A7BC: variable 'v12' is possibly undefined
// 1A7D0: variable 'v14' is possibly undefined
// 1A7D8: variable 'v15' is possibly undefined
// 1A7F4: variable 'v17' is possibly undefined
// 1A7FC: variable 'v18' is possibly undefined
// 75DE0: using guessed type double dbl_75DE0;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7B100: using guessed type int dword_7B100;
// 7B859: using guessed type char byte_7B859;
// 7B8B8: using guessed type int dword_7B8B8;

//----- (0001A914) --------------------------------------------------------
int __fastcall sub_1A914(int a1, int a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  int result; // r0
  char v9[4100]; // [sp+0h] [bp-1004h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  if ( sub_1654C(a2, a3) )
  {
    sub_1A730(a1, a2);
    if ( sub_29F54((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160)) )
    {
      return 1;
    }
    else
    {
      if ( v5 )
        *v5 = 1;
      result = (unsigned __int8)byte_78E09;
      if ( byte_78E09 )
      {
        if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 6 )
        {
          strcpy(v9, "Share above target");
          sub_38730(7, v9, 0);
          return 0;
        }
      }
    }
  }
  else
  {
    sub_189A4(a1);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001AA18) --------------------------------------------------------
void __fastcall sub_1AA18(pthread_rwlock_t *a1)
{
  void **nr_readers; // r5
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( a1 && !pthread_rwlock_trywrlock(a1 + 10) )
  {
    nr_readers = (void **)a1[11].__nr_readers;
    a1[11].__nr_readers = 0;
    if ( pthread_rwlock_unlock(a1 + 10) )
      sub_B630("flush_queue", 9004);
    off_75ED8();
    if ( nr_readers )
    {
      sub_15780(nr_readers);
      if ( byte_78E09 )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
        {
          strcpy(v3, "Discarded queued work item");
          sub_38730(7, v3, 0);
        }
      }
    }
  }
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001AB24) --------------------------------------------------------
int __fastcall sub_1AB24(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_rdlock(a1);
  if ( result )
    sub_B69C(a2, a3);
  return result;
}

//----- (0001AB4C) --------------------------------------------------------
_DWORD *__fastcall sub_1AB4C(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r0
  _DWORD *v12; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B69C("clone_queued_work_bymidstate", 8880);
  v11 = sub_16A80(a1[11].__lock, a2, a3, a4, a5, a6);
  v12 = (_DWORD *)v11;
  if ( v11 )
    v12 = sub_1A44C(v11, 0);
  if ( pthread_rwlock_unlock(v6) )
    sub_B630("clone_queued_work_bymidstate", 8884);
  off_75ED8();
  return v12;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001AC00) --------------------------------------------------------
_DWORD *__fastcall sub_1AC00(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r5
  int lock; // r2
  _DWORD *v6; // r4
  int v7; // r0

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B69C("clone_queued_work_byid", 8924);
  lock = a1[11].__lock;
  if ( lock )
  {
    v7 = *(_DWORD *)(lock + 1840);
    if ( a2 == *(_DWORD *)(lock + 1828) )
    {
      v7 = a1[11].__lock;
LABEL_12:
      v6 = sub_1A44C(v7, 0);
    }
    else
    {
      while ( v7 )
      {
        if ( a2 == *(_DWORD *)(v7 + 1828) )
          goto LABEL_12;
        v7 = *(_DWORD *)(v7 + 1840);
      }
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( pthread_rwlock_unlock(v2) )
    sub_B630("clone_queued_work_byid", 8928);
  off_75ED8();
  return v6;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001ACC4) --------------------------------------------------------
int __fastcall sub_1ACC4(int a1, int a2)
{
  pthread_mutex_t *v2; // r6
  __int64 v5; // r2
  size_t v6; // r0
  int v7; // r2
  int v8; // lr
  int v9; // r0
  int v10; // r12
  int v11; // r11
  int v12; // r0
  int v13; // r12
  int v14; // lr
  int v15; // r12
  int v16; // r2
  int v17; // lr
  const char *v19; // r0
  char *v20; // r11
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 244);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 244)) )
    sub_B414("gen_stratum_work", 7949);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B480("gen_stratum_work", 7949);
  v5 = *(_QWORD *)(a1 + 648);
  *(_QWORD *)(a2 + 1784) = v5;
  *(_QWORD *)(a1 + 648) = v5 + 1;
  *(_DWORD *)(a2 + 1792) = 2;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B630("gen_stratum_work", 7954);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B69C("gen_stratum_work", 7954);
  if ( pthread_mutex_unlock(v2) )
    sub_B5C4("gen_stratum_work", 7954);
  memset((void *)(a2 + 224), 0, 0x5CFu);
  memcpy((void *)(a2 + 224), (const void *)(a1 + 1604), 0x80u);
  v6 = strlen(*(const char **)(a1 + 636));
  sub_29830((_BYTE *)(a2 + 332), *(unsigned __int8 **)(a1 + 636), v6 >> 1);
  memcpy((void *)(a2 + 352 - *(_DWORD *)(a2 + 1792)), (const void *)(a2 + 1784), *(_DWORD *)(a2 + 1792));
  sub_16494((char *)(a2 + 364), 0x540u);
  *(_QWORD *)(a2 + 1800) = *(_QWORD *)(a1 + 712);
  *(_DWORD *)(a2 + 1776) = _strdup(*(const char **)(a1 + 672));
  *(_DWORD *)(a2 + 1808) = _strdup(*(const char **)(a1 + 636));
  *(_DWORD *)(a2 + 1796) = _strdup(*(const char **)(a1 + 692));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B630("gen_stratum_work", 7975);
  off_75ED8();
  if ( byte_78E09 )
  {
    v19 = sub_29730(a2 + 224, 143);
    v20 = (char *)v19;
    if ( byte_78E09 )
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_18;
      snprintf(s, 0x1000u, "[THR%d] Generated stratum header %s", *(_DWORD *)(a2 + 1744), v19);
      sub_38730(7, s, 0);
      if ( byte_78E09 )
      {
        if ( byte_7AD48 || byte_78E08 )
        {
LABEL_16:
          snprintf(
            s,
            0x1000u,
            "[THR%d] job_id %s, nonce1 %s, nonce2 %llu, ntime %s",
            *(_DWORD *)(a2 + 1744),
            *(const char **)(a2 + 1776),
            *(const char **)(a2 + 1808),
            *(_QWORD *)(a2 + 1784),
            *(const char **)(a2 + 1796));
          sub_38730(7, s, 0);
          goto LABEL_17;
        }
LABEL_18:
        if ( dword_766C4 <= 6 )
          goto LABEL_17;
        goto LABEL_16;
      }
    }
LABEL_17:
    free(v20);
  }
  v7 = dword_770A8;
  v8 = *(_DWORD *)(a1 + 76);
  v9 = *(_DWORD *)(a1 + 80);
  v10 = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a2 + 160) = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a2 + 164) = v8;
  *(_DWORD *)(a2 + 168) = v9;
  *(_DWORD *)(a2 + 172) = v10;
  v11 = *(_DWORD *)(a1 + 88);
  v12 = *(_DWORD *)(a1 + 96);
  v13 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a2 + 180) = *(_DWORD *)(a1 + 92);
  v14 = dword_770A8;
  *(_DWORD *)(a2 + 188) = v13;
  v15 = v7 + 1;
  v16 = dword_7B4CC;
  *(_DWORD *)(a2 + 1828) = v14;
  v17 = dword_770AC;
  *(_DWORD *)(a2 + 184) = v12;
  *(_DWORD *)(a2 + 176) = v11;
  *(_DWORD *)(a2 + 1748) = a1;
  *(_DWORD *)(a2 + 1824) = v17;
  *(_BYTE *)(a2 + 1772) = 1;
  *(_BYTE *)(a2 + 1768) = 0;
  *(_BYTE *)(a2 + 1928) = 83;
  *(_DWORD *)(a2 + 1732) = 60;
  dword_770A8 = v15;
  dword_7B4CC = v16 + 1;
  sub_11A5C(a2);
  return sub_2A84C((struct timeval *)(a2 + 1752));
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 770A8: using guessed type int dword_770A8;
// 770AC: using guessed type int dword_770AC;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B4CC: using guessed type int dword_7B4CC;

//----- (0001B074) --------------------------------------------------------
int __fastcall sub_1B074(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r3
  int v6; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B69C("find_queued_work_byid", 8913);
  lock = a1[11].__lock;
  if ( lock && (v6 = *(_DWORD *)(lock + 1840), a2 != *(_DWORD *)(lock + 1828)) )
  {
    while ( v6 && a2 != *(_DWORD *)(v6 + 1828) )
      v6 = *(_DWORD *)(v6 + 1840);
  }
  else
  {
    v6 = lock;
  }
  if ( pthread_rwlock_unlock(v2) )
    sub_B630("find_queued_work_byid", 8915);
  off_75ED8();
  return v6;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001B124) --------------------------------------------------------
int __fastcall sub_1B124(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_B69C("get_thread", 614);
  v2 = *(_DWORD *)(dword_7B5E0 + 4 * a1);
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_B630("get_thread", 616);
  off_75ED8();
  return v2;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B5E0: using guessed type int dword_7B5E0;

//----- (0001B19C) --------------------------------------------------------
int sub_1B19C()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r2
  int v4; // r3
  char v6[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_78E09 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
      goto LABEL_31;
    strcpy(v6, "Received kill message");
    sub_38730(7, v6, 1);
    if ( byte_78E09 )
    {
      if ( byte_7AD48 || byte_78E08 )
      {
LABEL_7:
        strcpy(v6, "Killing off watchpool thread");
        sub_38730(7, v6, 1);
        goto LABEL_8;
      }
LABEL_31:
      if ( dword_766C4 <= 6 )
        goto LABEL_8;
      goto LABEL_7;
    }
  }
LABEL_8:
  sub_2F438((int)sub_2A414, dword_7B0FC + (dword_770B0 << 6), 1000);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v6, "Killing off watchdog thread");
    sub_38730(7, v6, 1);
  }
  sub_2F438((int)sub_2A414, dword_7B0FC + (dword_770B4 << 6), 1000);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v6, "Shutting down mining threads");
    sub_38730(7, v6, 1);
  }
  if ( dword_7BB6C > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      v2 = sub_1B124(v1);
      v3 = dword_7BB6C;
      if ( v2 )
      {
        v4 = *(_DWORD *)(v2 + 36);
        if ( v4 )
          *(_BYTE *)(v4 + 364) = 1;
      }
    }
    while ( v0 < v3 );
  }
  sleep(1u);
  sub_2F438((int)sub_1B4D8, 0, 3000);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v6, "Killing off API thread");
    sub_38730(7, v6, 1);
  }
  return sub_2F438((int)sub_2A414, dword_7B0FC + (dword_76EF8 << 6), 1000);
}
// 766C4: using guessed type int dword_766C4;
// 76EF8: using guessed type int dword_76EF8;
// 770B0: using guessed type int dword_770B0;
// 770B4: using guessed type int dword_770B4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B0FC: using guessed type int dword_7B0FC;
// 7BB6C: using guessed type int dword_7BB6C;

//----- (0001B4C0) --------------------------------------------------------
int sub_1B4C0()
{
  int result; // r0

  if ( byte_78CA9 )
    return sub_1B19C();
  return result;
}
// 78CA9: using guessed type char byte_78CA9;

//----- (0001B4D8) --------------------------------------------------------
void sub_1B4D8()
{
  int v0; // r4
  pthread_t v1; // r0
  int v2; // r0
  int v3; // r5
  char v4[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    sub_38730(7, v4, 1);
  }
  if ( dword_7BB6C > 0 )
  {
    v0 = 0;
    do
    {
      while ( 1 )
      {
        v2 = sub_1B124(v0);
        v3 = v2;
        if ( v2 )
        {
          if ( *(_DWORD *)(v2 + 12) )
            break;
        }
        ++v0;
        sub_2A414(v2);
        if ( dword_7BB6C <= v0 )
          return;
      }
      sub_2A414(v2);
      v1 = *(_DWORD *)(v3 + 12);
      if ( v1 )
        pthread_join(v1, 0);
      ++v0;
    }
    while ( dword_7BB6C > v0 );
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7BB6C: using guessed type int dword_7BB6C;

//----- (0001B5EC) --------------------------------------------------------
int __fastcall sub_1B5EC(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(sub_1B124(a1) + 36) + 8);
}

//----- (0001B600) --------------------------------------------------------
void __fastcall sub_1B600(const char *a1, _DWORD *a2)
{
  int v4; // r10
  int v5; // r9
  char *v6; // r7
  char *v7; // r6
  char *v8; // r8
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // lr
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // lr
  int v17; // r1
  int v18; // [sp+20h] [bp-140Ch]
  int v19; // [sp+24h] [bp-1408h]
  char s[1024]; // [sp+28h] [bp-1404h] BYREF
  _DWORD v21[5]; // [sp+428h] [bp-1004h] BYREF
  __int16 v22; // [sp+43Ch] [bp-FF0h]

  if ( !dword_76CF4 )
    return;
  v4 = a2[436];
  v5 = *(_DWORD *)(sub_1B124(v4) + 36);
  v19 = a2[437];
  v18 = a2[480];
  v6 = sub_29730((int)(a2 + 40), 32);
  v7 = sub_29730((int)(a2 + 48), 32);
  v8 = sub_29730((int)a2, 128);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         v18,
         a1,
         v6,
         *(const char **)(v19 + 196),
         *(const char **)(*(_DWORD *)(v5 + 4) + 8),
         *(_DWORD *)(v5 + 8),
         v4,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 < 1024 )
  {
    if ( v9 < 0 )
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
        return;
      v11 = "sharelog printf error";
LABEL_11:
      v12 = *(_DWORD *)v11;
      v13 = *((_DWORD *)v11 + 1);
      v14 = *((_DWORD *)v11 + 2);
      v15 = *((_DWORD *)v11 + 3);
      v16 = v11 + 16;
      v21[0] = v12;
      v21[1] = v13;
      v21[2] = v14;
      v21[3] = v15;
      v17 = v16[1];
      v21[4] = *v16;
      v22 = v17;
      sub_38730(3, (const char *)v21, 0);
      return;
    }
  }
  else
  {
    s[1023] = 0;
  }
  if ( pthread_mutex_lock(&stru_770B8) )
    sub_B414("sharelog", 673);
  v10 = fwrite(s, v9, 1u, (FILE *)dword_76CF4);
  fflush((FILE *)dword_76CF4);
  if ( pthread_mutex_unlock(&stru_770B8) )
    sub_B5C4("sharelog", 676);
  off_75ED8();
  if ( v10 != 1 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
  {
    v11 = "sharelog fwrite error";
    goto LABEL_11;
  }
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76CF4: using guessed type int dword_76CF4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001B83C) --------------------------------------------------------
int __fastcall sub_1B83C(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_7B700) )
    sub_B69C("get_devices", 632);
  v2 = *(_DWORD *)(dword_7B628 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_7B700) )
    sub_B630("get_devices", 634);
  off_75ED8();
  return v2;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B628: using guessed type int dword_7B628;

//----- (0001B8B4) --------------------------------------------------------
int sub_1B8B4()
{
  int *v0; // r12
  int *v1; // r2
  int v2; // r4
  int v3; // t1
  int result; // r0
  int v5; // r7
  int v6; // r0
  int v7; // r6

  sub_2A84C((struct timeval *)&dword_770D0);
  sub_2A530(dword_770D8, &dword_770D0);
  dbl_7BC98 = 0.0;
  v0 = (int *)&unk_770E0;
  dbl_7BB10 = 0.0;
  dbl_7B2F8 = 0.0;
  dbl_7BC88 = 0.0;
  dbl_7ACC0 = 0.0;
  do
  {
    *(_QWORD *)v0 = 0;
    v0 += 2;
  }
  while ( v0 != &dword_77140 );
  byte_77144 = 1;
  dword_7B8A8 = 0;
  dword_7BB20 = 0;
  dbl_75DE8 = 1.0;
  dbl_755F8 = 1.0;
  dword_77140 = 0;
  dword_7AE68 = 0;
  *(_QWORD *)&dword_7B648 = 0;
  dword_7B8A4 = 0;
  dbl_7B5E8 = 0.0;
  dword_7B4CC = 0;
  dbl_7B670 = 0.0;
  dword_7B43C = 0;
  dbl_7B428 = 0.0;
  dword_7B8B8 = 0;
  qword_7B420 = 0;
  qword_7B6F8 = 0;
  *(_QWORD *)&dword_7BC80 = 0;
  *(_QWORD *)&dword_7B7C8 = 0;
  *(_QWORD *)&dword_7B100 = 0;
  if ( dword_7B198 > 0 )
  {
    v1 = (int *)dword_7B438;
    v2 = dword_7B438 + 4 * dword_7B198;
    do
    {
      v3 = *v1++;
      *(_QWORD *)(v3 + 104) = 0;
      *(_QWORD *)(v3 + 112) = 0;
      *(_QWORD *)(v3 + 120) = 0;
      *(_QWORD *)(v3 + 392) = 0;
      *(_DWORD *)(v3 + 148) = 0;
      *(_DWORD *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 12) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 152) = 0;
      *(_DWORD *)(v3 + 156) = 0;
      *(_DWORD *)(v3 + 160) = 0;
      *(_DWORD *)(v3 + 164) = 0;
      *(_DWORD *)(v3 + 384) = 0;
      *(_DWORD *)(v3 + 40) = 0;
      *(_DWORD *)(v3 + 44) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  result = sub_160B4();
  if ( dword_7B720 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = v5++;
      v7 = sub_1B83C(v6);
      sub_2A530((_DWORD *)(v7 + 368), &dword_770D0);
      if ( pthread_mutex_lock(&stru_7B384) )
        sub_B414("zero_stats", 5874);
      *(_QWORD *)(v7 + 80) = 0;
      *(_DWORD *)(v7 + 36) = 0;
      *(_QWORD *)(v7 + 192) = 0;
      *(_QWORD *)(v7 + 88) = 0;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 200) = 0;
      *(_DWORD *)(v7 + 44) = 0;
      *(_QWORD *)(v7 + 208) = 0;
      *(_DWORD *)(v7 + 220) = 0;
      *(_QWORD *)(v7 + 224) = 0;
      if ( pthread_mutex_unlock(&stru_7B384) )
        sub_B5C4("zero_stats", 5885);
      off_75ED8();
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(v7 + 4) + 96))(v7);
    }
    while ( dword_7B720 > v5 );
  }
  return result;
}
// 755F8: using guessed type double dbl_755F8;
// 75DE8: using guessed type double dbl_75DE8;
// 75ED8: using guessed type int (*off_75ED8)();
// 770D0: using guessed type int dword_770D0;
// 770D8: using guessed type _DWORD dword_770D8[2];
// 77140: using guessed type int dword_77140;
// 77144: using guessed type char byte_77144;
// 7ACC0: using guessed type double dbl_7ACC0;
// 7AE68: using guessed type int dword_7AE68;
// 7B100: using guessed type int dword_7B100;
// 7B198: using guessed type int dword_7B198;
// 7B2F8: using guessed type double dbl_7B2F8;
// 7B420: using guessed type __int64 qword_7B420;
// 7B428: using guessed type double dbl_7B428;
// 7B438: using guessed type int dword_7B438;
// 7B43C: using guessed type int dword_7B43C;
// 7B4CC: using guessed type int dword_7B4CC;
// 7B5E8: using guessed type double dbl_7B5E8;
// 7B648: using guessed type int dword_7B648;
// 7B670: using guessed type double dbl_7B670;
// 7B6F8: using guessed type __int64 qword_7B6F8;
// 7B720: using guessed type int dword_7B720;
// 7B7C8: using guessed type int dword_7B7C8;
// 7B8A4: using guessed type int dword_7B8A4;
// 7B8A8: using guessed type int dword_7B8A8;
// 7B8B8: using guessed type int dword_7B8B8;
// 7BB10: using guessed type double dbl_7BB10;
// 7BB20: using guessed type int dword_7BB20;
// 7BC80: using guessed type int dword_7BC80;
// 7BC88: using guessed type double dbl_7BC88;
// 7BC98: using guessed type double dbl_7BC98;

//----- (0001BBA4) --------------------------------------------------------
void __fastcall sub_1BBA4(int a1, __int64 a2)
{
  double v3; // d0
  int v6; // r7
  int v7; // r6
  int v8; // r0
  int v9; // r8
  double v10; // r0
  double v11; // d8
  double v12; // r0
  double v13; // r0
  double v14; // r0
  int v15; // r7
  int v16; // r0
  int v17; // r6
  double v18; // r0
  double v19; // r0
  double v20; // r0
  double v21; // r0
  double v22; // r0
  double v23; // d11
  int v24; // r3
  double v25; // d16
  int v26; // r3
  __int64 v27; // d16
  int v28; // r8
  int *v29; // r9
  double v30; // d8
  double v31; // r0
  int v32; // r1
  int v33; // r1
  double v34; // r0
  double v35; // r0
  double v36; // r0
  double v37; // r0
  int v38; // r0
  __int64 v39; // r0
  unsigned __int64 v40; // r0
  unsigned __int64 v41; // r0
  unsigned __int64 v42; // r0
  unsigned __int64 v43; // r0
  unsigned __int64 v44; // r0
  char v45[16]; // [sp+20h] [bp-1134h] BYREF
  char v46[16]; // [sp+30h] [bp-1124h] BYREF
  char v47[16]; // [sp+40h] [bp-1114h] BYREF
  char v48[256]; // [sp+50h] [bp-1104h] BYREF
  char s[4100]; // [sp+150h] [bp-1004h] BYREF

  sub_2A84C((struct timeval *)&dword_77148);
  sub_2AA24();
  v6 = dword_77148;
  if ( dword_77148 - dword_77150 < dword_75DCC )
  {
    if ( a1 < 0 )
      return;
    sub_2A530(dword_770D8, &dword_77148);
    v7 = 0;
  }
  else
  {
    dword_77150 = dword_77148;
    byte_77154 ^= byte_77155;
    sub_2A530(dword_770D8, &dword_77148);
    if ( a1 < 0 )
    {
      if ( pthread_mutex_lock(&stru_7B384) )
        sub_B414("hashmeter", 6763);
      if ( dword_7BB6C > 0 )
      {
        v15 = 0;
        do
        {
          v16 = v15++;
          v17 = *(_DWORD *)(sub_1B124(v16) + 36);
          sub_2AA24();
          sub_2A530((_DWORD *)(v17 + 140), &dword_77148);
          HIDWORD(v18) = dword_75DCC;
          LODWORD(v18) = v17 + 48;
          sub_15798(v18);
          LODWORD(v19) = v17 + 56;
          sub_15798(v19);
          LODWORD(v20) = v17 + 64;
          sub_15798(v20);
          LODWORD(v21) = v17 + 72;
          v3 = 0.0;
          sub_15798(v21);
        }
        while ( dword_7BB6C > v15 );
      }
      if ( pthread_mutex_unlock(&stru_7B384) )
        sub_B5C4("hashmeter", 6776);
      v7 = 1;
      off_75ED8();
      goto LABEL_24;
    }
    v7 = 1;
  }
  v8 = sub_1B124(a1);
  v9 = *(_DWORD *)(v8 + 36);
  sub_2A530((_DWORD *)(v8 + 44), &dword_77148);
  *(_DWORD *)(v9 + 240) = v6;
  sub_2AA24();
  sub_2A530((_DWORD *)(v9 + 140), &dword_77148);
  if ( pthread_mutex_lock(&stru_7B384) )
    sub_B414("hashmeter", 6737);
  LODWORD(v10) = sub_5CB50(a2);
  v11 = v10;
  HIDWORD(v10) = dword_75DCC;
  LODWORD(v10) = v9 + 48;
  *(double *)(v9 + 80) = *(double *)(v9 + 80) + v11;
  sub_15798(v10);
  LODWORD(v12) = v9 + 56;
  sub_15798(v12);
  LODWORD(v13) = v9 + 64;
  sub_15798(v13);
  LODWORD(v14) = v9 + 72;
  v3 = v11;
  sub_15798(v14);
  if ( pthread_mutex_unlock(&stru_7B384) )
    sub_B5C4("hashmeter", 6743);
  off_75ED8();
  sub_17744(v48, 0x100u, v9);
  if ( byte_77018 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "%s", v48);
      sub_38730(7, s, 0);
    }
  }
  else
  {
    printf("%s          \r", v48);
    fflush((FILE *)stdout);
  }
LABEL_24:
  if ( pthread_mutex_lock(&stru_7B384) )
    sub_B414("hashmeter", 6779);
  LODWORD(v22) = sub_5CB50(a2);
  v23 = v22;
  dbl_7ACC0 = v22 + dbl_7ACC0;
  if ( v7 )
  {
    v26 = dword_77140 + 1;
    v27 = 0;
    v28 = 0;
    v29 = (int *)dbl_770E0;
    if ( dword_77140 + 1 > 11 )
      v26 = 0;
    dword_77140 = v26;
    do
    {
      v30 = *(double *)v29;
      v29 += 2;
      if ( v30 >= 0.0 )
      {
        LODWORD(v31) = sub_5CB50(v27);
        ++v28;
        LODWORD(v27) = sub_5CC48(v30 + v31);
        HIDWORD(v27) = v32;
      }
    }
    while ( v29 != &dword_77140 );
    if ( v28 )
    {
      LODWORD(a2) = sub_5CBC4(v27, v28);
      HIDWORD(a2) = v33;
    }
    sub_5CB50(a2);
    LODWORD(v34) = &dbl_7BB10;
    sub_15798(v34);
    LODWORD(v35) = &dbl_7BC98;
    sub_15798(v35);
    LODWORD(v36) = &dbl_7BC88;
    sub_15798(v36);
    LODWORD(v37) = &dbl_7B2F8;
    v38 = sub_15798(v37);
    v3 = dbl_7BB10;
    v39 = llround(v38);
    v25 = 0.0;
    v24 = dword_77140;
    dbl_770E0[dword_77140] = 0.0;
    *(_QWORD *)&dword_7BAD0 = 1000000 * v39;
  }
  else
  {
    v24 = dword_77140;
    v25 = dbl_770E0[dword_77140];
  }
  dbl_770E0[v24] = v25 + v23;
  sub_2AA24();
  dbl_755F8 = v3;
  if ( v3 - dbl_75DE8 > 86400.0 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      snprintf(s, 0x1000u, "cgminer time error total_secs = %f last_total_secs = %f", v3, dbl_75DE8);
      sub_38730(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_7B384) )
      sub_B5C4("hashmeter", 6819);
    off_75ED8();
    sub_1B8B4();
    if ( pthread_mutex_lock(&stru_7B384) )
      sub_B414("hashmeter", 6821);
  }
  else
  {
    dbl_75DE8 = v3;
  }
  if ( v7 )
  {
    LODWORD(v40) = sub_5CC48(dbl_7ACC0 / dbl_755F8 * 1000000.0);
    sub_11580(v40, v45, 0x10u, 4);
    dbl_77158 = dbl_7BB10 / 1000.0;
    LODWORD(v41) = sub_5CC48(dbl_7BB10 * 1000000.0);
    sub_11580(v41, v46, 0x10u, 4);
    LODWORD(v42) = sub_5CC48(dbl_7BC98 * 1000000.0);
    sub_11580(v42, v47, 0x10u, 4);
    LODWORD(v43) = sub_5CC48(dbl_7BC88 * 1000000.0);
    sub_11580(v43, v48, 0x10u, 4);
    LODWORD(v44) = sub_5CC48(dbl_7B2F8 * 1000000.0);
    sub_11580(v44, s, 0x10u, 4);
    snprintf(byte_77160, 0x100u, "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s", dword_75DCC, v46, v47, v48, s, v45);
  }
  if ( pthread_mutex_unlock(&stru_7B384) )
    sub_B5C4("hashmeter", 6850);
  off_75ED8();
  if ( v7 )
  {
    if ( byte_77018 )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(s, 0x1000u, "%s", byte_77160);
        sub_38730(7, s, 0);
      }
    }
    else
    {
      printf("%s          \r", byte_77160);
      fflush((FILE *)stdout);
    }
  }
}
// 1BC7C: variable 'v10' is possibly undefined
// 1BCB0: variable 'v12' is possibly undefined
// 1BCC4: variable 'v13' is possibly undefined
// 1BCD8: variable 'v14' is possibly undefined
// 1BE40: variable 'v19' is possibly undefined
// 1BE54: variable 'v20' is possibly undefined
// 1BE68: variable 'v21' is possibly undefined
// 1BEC0: variable 'v22' is possibly undefined
// 1BF10: variable 'v3' is possibly undefined
// 1C214: variable 'v40' is possibly undefined
// 1C244: variable 'v41' is possibly undefined
// 1C268: variable 'v42' is possibly undefined
// 1C28C: variable 'v43' is possibly undefined
// 1C2B0: variable 'v44' is possibly undefined
// 1C100: variable 'v31' is possibly undefined
// 1C108: variable 'v32' is possibly undefined
// 1C12C: variable 'v33' is possibly undefined
// 1C158: variable 'v34' is possibly undefined
// 1C16C: variable 'v35' is possibly undefined
// 1C180: variable 'v36' is possibly undefined
// 1C194: variable 'v37' is possibly undefined
// B18C: using guessed type __int64 __fastcall llround(_DWORD);
// 755F8: using guessed type double dbl_755F8;
// 75DCC: using guessed type int dword_75DCC;
// 75DE8: using guessed type double dbl_75DE8;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76BCC: using guessed type int stdout;
// 77018: using guessed type char byte_77018;
// 770D8: using guessed type _DWORD dword_770D8[2];
// 770E0: using guessed type double dbl_770E0[12];
// 77140: using guessed type int dword_77140;
// 77148: using guessed type int dword_77148;
// 77150: using guessed type int dword_77150;
// 77154: using guessed type char byte_77154;
// 77155: using guessed type char byte_77155;
// 77158: using guessed type double dbl_77158;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7ACC0: using guessed type double dbl_7ACC0;
// 7AD48: using guessed type char byte_7AD48;
// 7B2F8: using guessed type double dbl_7B2F8;
// 7BAD0: using guessed type int dword_7BAD0;
// 7BB10: using guessed type double dbl_7BB10;
// 7BB6C: using guessed type int dword_7BB6C;
// 7BC88: using guessed type double dbl_7BC88;
// 7BC98: using guessed type double dbl_7BC98;

//----- (0001C668) --------------------------------------------------------
int sub_1C668()
{
  int v0; // r3
  double v1; // d9
  int v2; // r7
  int v3; // r5
  int v4; // r9
  double v5; // r0
  double v6; // d10
  double v7; // r0
  double v8; // d9
  __int64 v9; // r6
  __int64 v10; // r10
  int v11; // r1
  double v12; // d8
  double v13; // r0
  int v14; // r11
  int v15; // r1
  int v16; // r2
  __int64 v17; // r4
  __int64 v18; // kr08_8
  int v19; // r1
  double v20; // d8
  double v21; // r0
  int v22; // r4
  int v23; // r0
  int v24; // r0
  int v25; // r2
  double v26; // d16
  int v27; // r3
  const char *v29; // r2
  int v30; // [sp+18h] [bp-1114h]
  char v31[256]; // [sp+28h] [bp-1104h] BYREF
  char s[4100]; // [sp+128h] [bp-1004h] BYREF

  v0 = dword_77148 - dword_770D0;
  if ( dword_7714C - dword_770D4 < 0 )
    --v0;
  v1 = dbl_755F8;
  v2 = v0 / 3600;
  v3 = v0 % 60;
  v4 = v0 % 3600 / 60;
  LODWORD(v5) = sub_5CB64(qword_7B420);
  v6 = v5 / v1 * 60.0;
  LODWORD(v7) = sub_5CB64(*(__int64 *)&dword_7B100);
  v8 = v7 / v1 * 60.0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    strcpy(s, "\nSummary of runtime statistics:\n");
    sub_38730(4, s, 0);
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      snprintf(s, 0x1000u, "Started at %s", byte_77260);
      sub_38730(4, s, 0);
    }
  }
  if ( dword_7B198 == 1 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      goto LABEL_28;
    snprintf(s, 0x1000u, "Pool: %s", *(const char **)(*(_DWORD *)dword_7B438 + 196));
    sub_38730(4, s, 0);
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(s, 0x1000u, "Runtime: %d hrs : %d mins : %d secs", v2, v4, v3);
    sub_38730(4, s, 0);
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      snprintf(s, 0x1000u, "Average hashrate: %.1f Mhash/s", dbl_7ACC0 / dbl_755F8);
      sub_38730(4, s, 0);
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, "Solved blocks: %d", dword_7B8B8);
        sub_38730(4, s, 0);
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(s, 0x1000u, "Best share difficulty: %s", (const char *)&dword_75DC4);
          sub_38730(4, s, 0);
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, "Share submissions: %lld", qword_7B6F8 + qword_7B420);
            sub_38730(4, s, 0);
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
            {
              snprintf(s, 0x1000u, "Accepted shares: %lld", qword_7B420);
              sub_38730(4, s, 0);
              if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
              {
                snprintf(s, 0x1000u, "Rejected shares: %lld", qword_7B6F8);
                sub_38730(4, s, 0);
                if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
                {
                  snprintf(s, 0x1000u, "Accepted difficulty shares: %1.f", dbl_7B5E8);
                  sub_38730(4, s, 0);
                  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
                  {
                    snprintf(s, 0x1000u, "Rejected difficulty shares: %1.f", dbl_7B670);
                    sub_38730(4, s, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_28:
  v9 = qword_7B420;
  if ( qword_7B420 || qword_7B6F8 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      goto LABEL_50;
    v10 = qword_7B6F8;
    LODWORD(v12) = sub_5CB64(100 * qword_7B6F8);
    HIDWORD(v12) = v11;
    LODWORD(v13) = sub_5CB64(v9 + v10);
    snprintf(s, 0x1000u, "Reject ratio: %.1f%%", v12 / v13);
    sub_38730(4, s, 0);
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(s, 0x1000u, "Hardware errors: %d", dword_7B8A4);
    sub_38730(4, s, 0);
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      snprintf(s, 0x1000u, "Utility (accepted shares / min): %.2f/min", v6);
      sub_38730(4, s, 0);
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v8);
        sub_38730(4, s, 0);
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(s, 0x1000u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&dword_7BC80);
          sub_38730(4, s, 0);
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, "Unable to get work from server occasions: %d", dword_7B43C);
            sub_38730(4, s, 0);
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
            {
              snprintf(s, 0x1000u, "Work items generated locally: %d", dword_7B4CC);
              sub_38730(4, s, 0);
              if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
              {
                snprintf(s, 0x1000u, "Submitting work remotely delay occasions: %d", dword_7AE68);
                sub_38730(4, s, 0);
                if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
                {
                  snprintf(s, 0x1000u, "New blocks detected on network: %d\n", dword_7BB1C);
                  sub_38730(4, s, 0);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_50:
  if ( dword_7B198 > 1 )
  {
    v30 = 0;
    while ( 1 )
    {
      v14 = *(_DWORD *)(dword_7B438 + 4 * v30);
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
        break;
      snprintf(s, 0x1000u, "Pool: %s", *(const char **)(v14 + 196));
      sub_38730(4, s, 0);
      v15 = *(_DWORD *)(v14 + 32);
      v16 = (unsigned __int8)byte_7AD48;
      if ( !v15 )
        goto LABEL_103;
      if ( !byte_7AD48 )
        goto LABEL_59;
LABEL_100:
      v29 = "S";
      if ( v15 <= 1 )
        v29 = "";
      snprintf(s, 0x1000u, "SOLVED %d BLOCK%s!", v15, v29);
      sub_38730(4, s, 0);
      v16 = (unsigned __int8)byte_7AD48;
LABEL_103:
      if ( !v16 )
      {
LABEL_104:
        if ( !byte_78E08 && dword_766C4 <= 3 )
          goto LABEL_61;
      }
      snprintf(s, 0x1000u, " Share submissions: %lld", *(_QWORD *)(v14 + 16) + *(_QWORD *)(v14 + 8));
      sub_38730(4, s, 0);
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, " Accepted shares: %lld", *(_QWORD *)(v14 + 8));
        sub_38730(4, s, 0);
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(s, 0x1000u, " Rejected shares: %lld", *(_QWORD *)(v14 + 16));
          sub_38730(4, s, 0);
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, " Accepted difficulty shares: %1.f", *(double *)(v14 + 104));
            sub_38730(4, s, 0);
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
            {
              snprintf(s, 0x1000u, " Rejected difficulty shares: %1.f", *(double *)(v14 + 112));
              sub_38730(4, s, 0);
            }
          }
        }
      }
LABEL_61:
      if ( !*(_QWORD *)(v14 + 8) && !*(_QWORD *)(v14 + 16) )
        goto LABEL_67;
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        v17 = *(_QWORD *)(v14 + 16);
        v18 = *(_QWORD *)(v14 + 8);
        LODWORD(v20) = sub_5CB64(100 * v17);
        HIDWORD(v20) = v19;
        LODWORD(v21) = sub_5CB64(v18 + v17);
        snprintf(s, 0x1000u, " Reject ratio: %.1f%%", v20 / v21);
        sub_38730(4, s, 0);
LABEL_67:
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(s, 0x1000u, " Items worked on: %d", *(_DWORD *)(v14 + 68));
          sub_38730(4, s, 0);
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v14 + 152));
            sub_38730(4, s, 0);
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
            {
              snprintf(s, 0x1000u, " Unable to get work from server occasions: %d", *(_DWORD *)(v14 + 160));
              sub_38730(4, s, 0);
              if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
              {
                snprintf(s, 0x1000u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v14 + 164));
                sub_38730(4, s, 0);
              }
            }
          }
        }
      }
      if ( dword_7B198 <= ++v30 )
        goto LABEL_77;
    }
    v15 = *(_DWORD *)(v14 + 32);
    if ( !v15 )
      goto LABEL_104;
LABEL_59:
    if ( !byte_78E08 && dword_766C4 <= 3 )
      goto LABEL_61;
    goto LABEL_100;
  }
LABEL_77:
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    strcpy(s, "Summary of per device statistics:\n");
    sub_38730(4, s, 0);
  }
  if ( dword_7B720 > 0 )
  {
    v22 = 0;
    do
    {
      v23 = v22++;
      v24 = sub_1B83C(v23);
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 20) = nullsub_2;
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 24) = nullsub_4;
      sub_17744(v31, 0xFFu, v24);
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, "%s", v31);
        sub_38730(4, s, 0);
      }
    }
    while ( dword_7B720 > v22 );
  }
  v25 = dword_77288;
  if ( !dword_77288 )
    goto LABEL_95;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(s, 0x1000u, "Mined %.0f accepted shares of %d requested\n", dbl_7B5E8, dword_77288);
    sub_38730(4, s, 0);
    v25 = dword_77288;
    v26 = dbl_7B5E8;
    v27 = (unsigned __int8)byte_7AD48;
    if ( (double)dword_77288 <= dbl_7B5E8 )
      goto LABEL_96;
    if ( byte_7AD48 )
      goto LABEL_94;
  }
  else
  {
    v26 = dbl_7B5E8;
    if ( (double)dword_77288 <= dbl_7B5E8 )
    {
LABEL_97:
      if ( !byte_78E08 && dword_766C4 <= 3 )
        goto LABEL_99;
LABEL_98:
      strcpy(s, " ");
      sub_38730(4, s, 0);
      goto LABEL_99;
    }
  }
  if ( byte_78E08 || dword_766C4 > 3 )
  {
LABEL_94:
    snprintf(s, 0x1000u, "WARNING - Mined only %.0f shares of %d requested.", v26, v25);
    sub_38730(4, s, 0);
LABEL_95:
    v27 = (unsigned __int8)byte_7AD48;
LABEL_96:
    if ( v27 )
      goto LABEL_98;
    goto LABEL_97;
  }
LABEL_99:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 1C718: variable 'v5' is possibly undefined
// 1C730: variable 'v7' is possibly undefined
// 1CBD4: variable 'v11' is possibly undefined
// 1CBF8: variable 'v13' is possibly undefined
// 1CF78: variable 'v19' is possibly undefined
// 1CF9C: variable 'v21' is possibly undefined
// F798: using guessed type int nullsub_2();
// F79C: using guessed type int nullsub_4();
// 755F8: using guessed type double dbl_755F8;
// 75DC4: using guessed type int dword_75DC4;
// 766C4: using guessed type int dword_766C4;
// 76BCC: using guessed type int stdout;
// 76BD0: using guessed type int stderr;
// 770D0: using guessed type int dword_770D0;
// 770D4: using guessed type int dword_770D4;
// 77148: using guessed type int dword_77148;
// 7714C: using guessed type int dword_7714C;
// 77288: using guessed type int dword_77288;
// 78E08: using guessed type char byte_78E08;
// 7ACC0: using guessed type double dbl_7ACC0;
// 7AD48: using guessed type char byte_7AD48;
// 7AE68: using guessed type int dword_7AE68;
// 7B100: using guessed type int dword_7B100;
// 7B198: using guessed type int dword_7B198;
// 7B420: using guessed type __int64 qword_7B420;
// 7B438: using guessed type int dword_7B438;
// 7B43C: using guessed type int dword_7B43C;
// 7B4CC: using guessed type int dword_7B4CC;
// 7B5E8: using guessed type double dbl_7B5E8;
// 7B670: using guessed type double dbl_7B670;
// 7B6F8: using guessed type __int64 qword_7B6F8;
// 7B720: using guessed type int dword_7B720;
// 7B8A4: using guessed type int dword_7B8A4;
// 7B8B8: using guessed type int dword_7B8B8;
// 7BB1C: using guessed type int dword_7BB1C;
// 7BC80: using guessed type int dword_7BC80;

//----- (0001D7C8) --------------------------------------------------------
void sub_1D7C8()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(v0, 0x1000u, "Attempting to restart %s", byte_76BF4);
    sub_38730(4, v0, 0);
  }
  sub_2F438((int)sub_1B4C0, 0, 5000);
  sub_2A84C((struct timeval *)&dword_77148);
  sub_19ADC();
  if ( dword_7728C > 0 )
  {
    kill(dword_7728C, 15);
    dword_7728C = 0;
  }
  execv(*(const char **)dword_77290, (char *const *)dword_77290);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    strcpy(v0, "Failed to restart application");
    sub_38730(4, v0, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 77148: using guessed type int dword_77148;
// 7728C: using guessed type int dword_7728C;
// 77290: using guessed type int dword_77290;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001D8FC) --------------------------------------------------------
void __fastcall __noreturn sub_1D8FC(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, (void *(*)(void *))sub_11C1C, 0) )
  {
    if ( a2 )
    {
      sub_2A84C((struct timeval *)&dword_77148);
      sub_19ADC();
      if ( !byte_7BB18 && byte_78CA9 )
        sub_1C668();
    }
    else
    {
      sub_19ADC();
    }
    if ( dword_7728C > 0 )
    {
      kill(dword_7728C, 15);
      dword_7728C = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}
// 77148: using guessed type int dword_77148;
// 7728C: using guessed type int dword_7728C;
// 78CA9: using guessed type char byte_78CA9;
// 7BB18: using guessed type char byte_7BB18;

//----- (0001D9B4) --------------------------------------------------------
int __fastcall sub_1D9B4(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B69C("find_queued_work_bymidstate", 8869);
  v11 = sub_16A80(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    sub_B630("find_queued_work_bymidstate", 8871);
  off_75ED8();
  return v11;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0001DA58) --------------------------------------------------------
int sub_1DA58()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_7BA10) )
    sub_B414("current_pool", 796);
  if ( pthread_rwlock_rdlock(&stru_7BA28) )
    sub_B69C("current_pool", 796);
  if ( pthread_mutex_unlock(&stru_7BA10) )
    sub_B5C4("current_pool", 796);
  v0 = dword_7705C;
  if ( pthread_rwlock_unlock(&stru_7BA28) )
    sub_B630("current_pool", 798);
  off_75ED8();
  return v0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7705C: using guessed type int dword_7705C;

//----- (0001DB0C) --------------------------------------------------------
int __fastcall sub_1DB0C(int a1)
{
  int v1; // r11
  unsigned __int64 v2; // d17
  int v3; // r5
  int v4; // r4
  int v6; // r8
  int v7; // r7
  int v8; // r6
  int v9; // lr
  int v10; // r4
  int v11; // r3
  int v12; // r12
  int v13; // r10
  size_t v14; // r0
  unsigned int v15; // r12
  unsigned __int8 *v16; // r3
  int v17; // r1
  size_t v18; // r4
  int v19; // r0
  unsigned int v20; // r2
  unsigned int v21; // r12
  int v22; // lr
  int v23; // r8
  int v24; // r7
  int v25; // r6
  unsigned int v26; // r0
  int v27; // r1
  unsigned int v28; // r12
  unsigned int v29; // r0
  int v30; // r1
  unsigned int v31; // r12
  unsigned int v32; // r0
  size_t v33; // r0
  _DWORD *v34; // r6
  int v35; // r1
  unsigned int v36; // r2
  unsigned int v37; // r3
  int v38; // r1
  unsigned int v39; // r2
  unsigned int v40; // r3
  int v41; // r1
  int v42; // r6
  char *v43; // r3
  char *v44; // r0
  int v45; // r7
  int v46; // r3
  int *v47; // r10
  int v48; // r6
  int v49; // r9
  int v50; // r2
  int v51; // r12
  int v52; // lr
  unsigned int v53; // r8
  int v54; // r3
  int v55; // r1
  int v56; // r0
  int *v57; // r0
  int v58; // r4
  bool v59; // zf
  int v60; // r3
  bool v61; // zf
  int v62; // r9
  int v63; // r3
  int v64; // r2
  int v65; // r0
  int v66; // r3
  _DWORD *v67; // r2
  int v68; // r3
  int v69; // r2
  int v70; // r3
  int v71; // r3
  _DWORD *v72; // r0
  _DWORD *v73; // r4
  void *v74; // r0
  int v75; // r3
  int v76; // r3
  int v77; // r1
  int v78; // r2
  int v79; // r3
  int v80; // r1
  int v81; // r2
  int v82; // r3
  int v83; // r11
  int v84; // r3
  unsigned int v85; // r10
  size_t v86; // r0
  unsigned int v87; // r9
  unsigned __int8 *v88; // r4
  int v89; // r8
  int v90; // r1
  int v91; // r12
  int v92; // r2
  int v93; // r0
  unsigned int v94; // r3
  unsigned int v95; // r10
  int v96; // r8
  unsigned int v97; // r2
  unsigned int v98; // r3
  int v99; // r1
  unsigned int v100; // r2
  unsigned int v101; // r3
  size_t v102; // r11
  int v103; // r0
  unsigned int v104; // r2
  unsigned int v105; // r3
  int v106; // r0
  unsigned int v107; // r2
  unsigned int v108; // r3
  unsigned int v109; // r0
  unsigned int v110; // r3
  _DWORD *v111; // r2
  int v112; // r3
  int v113; // r2
  int v114; // r2
  int v115; // r4
  size_t v116; // r6
  _DWORD *v117; // r0
  _DWORD *v118; // r8
  int v119; // r1
  unsigned int v120; // r6
  int v121; // r11
  int v122; // r5
  _DWORD *v123; // r4
  _DWORD *v124; // r10
  int v125; // r6
  char *v126; // r7
  unsigned int v127; // r3
  int v128; // r3
  _DWORD *v129; // r3
  unsigned int v130; // r1
  unsigned int v131; // r2
  bool v132; // cc
  int v133; // r2
  int v134; // r3
  signed int v135; // s16
  double v136; // r0
  double v137; // d8
  struct tm *v138; // r0
  int j; // r3
  int v140; // r1
  int v141; // r2
  int v142; // r3
  int v143; // r7
  int v144; // r1
  int v145; // r2
  int v146; // r3
  int v147; // r2
  char *v148; // r3
  unsigned __int64 v149; // r0
  int v150; // [sp+8h] [bp-107Ch]
  unsigned int i; // [sp+8h] [bp-107Ch]
  _DWORD *v152; // [sp+Ch] [bp-1078h]
  int v153; // [sp+10h] [bp-1074h]
  int v154; // [sp+14h] [bp-1070h]
  time_t timer; // [sp+18h] [bp-106Ch] BYREF
  int s2; // [sp+1Ch] [bp-1068h] BYREF
  int v157; // [sp+20h] [bp-1064h]
  int v158; // [sp+24h] [bp-1060h]
  int v159; // [sp+28h] [bp-105Ch]
  int v160; // [sp+2Ch] [bp-1058h]
  int v161; // [sp+30h] [bp-1054h]
  int v162; // [sp+34h] [bp-1050h]
  int v163; // [sp+38h] [bp-104Ch]
  char s[68]; // [sp+3Ch] [bp-1048h] BYREF
  char v165[4096]; // [sp+80h] [bp-1004h] BYREF

  v3 = a1;
  v152 = *(_DWORD **)(a1 + 1748);
  if ( *(_BYTE *)(a1 + 1770) )
    return 1;
  v6 = *(_DWORD *)(a1 + 28);
  v7 = *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 20);
  v9 = *(_DWORD *)(a1 + 12);
  v10 = *(_DWORD *)(a1 + 16);
  s2 = *(_DWORD *)(a1 + 32);
  v11 = *(_DWORD *)(a1 + 4);
  v12 = *(_DWORD *)(a1 + 8);
  v161 = v9;
  v157 = v6;
  v162 = v12;
  v163 = v11;
  v158 = v7;
  v159 = v8;
  v160 = v10;
  sub_296D8(s, (char *)&s2, 32);
  if ( pthread_rwlock_rdlock(&stru_77294) )
    sub_B69C("block_exists", 5347);
  v13 = dword_772B4;
  if ( dword_772B4 )
  {
    v14 = strlen(s);
    v15 = -1640531527;
    v16 = (unsigned __int8 *)s;
    v17 = -1640531527;
    v18 = v14;
    v132 = v14 > 0xB;
    v19 = -17973521;
    v20 = v18;
    if ( v132 )
    {
      do
      {
        v20 -= 12;
        v1 = v16[7];
        v21 = (v16[6] << 16) + (v16[5] << 8) + v16[4] + (v1 << 24) + v15;
        v22 = (v16[2] << 16) + (v16[1] << 8) + *v16;
        v23 = v16[3];
        v24 = v16[11];
        v25 = (v16[10] << 16) + (v16[9] << 8) + v16[8];
        v16 += 12;
        v26 = v25 + (v24 << 24) + v19;
        v27 = (v22 + (v23 << 24) - v21 - v26 + v17) ^ (v26 >> 13);
        v28 = (v21 - v26 - v27) ^ (v27 << 8);
        v29 = (v26 - v27 - v28) ^ (v28 >> 13);
        v30 = (v27 - v28 - v29) ^ (v29 >> 12);
        v31 = (v28 - v29 - v30) ^ (v30 << 16);
        v32 = (v29 - v30 - v31) ^ (v31 >> 5);
        v17 = (v30 - v31 - v32) ^ (v32 >> 3);
        v15 = (v31 - v32 - v17) ^ (v17 << 10);
        v19 = (v32 - v17 - v15) ^ (v15 >> 15);
      }
      while ( v20 > 0xB );
    }
    v33 = v19 + v18;
    switch ( v20 )
    {
      case 1u:
        goto LABEL_21;
      case 2u:
        goto LABEL_20;
      case 3u:
        goto LABEL_19;
      case 4u:
        goto LABEL_18;
      case 5u:
        goto LABEL_17;
      case 6u:
        goto LABEL_16;
      case 7u:
        goto LABEL_15;
      case 8u:
        goto LABEL_14;
      case 9u:
        goto LABEL_13;
      case 0xAu:
        goto LABEL_12;
      case 0xBu:
        v33 += v16[10] << 24;
LABEL_12:
        v33 += v16[9] << 16;
LABEL_13:
        v33 += v16[8] << 8;
LABEL_14:
        v15 += v16[7] << 24;
LABEL_15:
        v15 += v16[6] << 16;
LABEL_16:
        v15 += v16[5] << 8;
LABEL_17:
        v15 += v16[4];
LABEL_18:
        v17 += v16[3] << 24;
LABEL_19:
        v17 += v16[2] << 16;
LABEL_20:
        v17 += v16[1] << 8;
LABEL_21:
        v17 += *v16;
        break;
      default:
        break;
    }
    v34 = *(_DWORD **)(dword_772B4 + 68);
    v35 = (v17 - v15 - v33) ^ (v33 >> 13);
    v36 = (v15 - v33 - v35) ^ (v35 << 8);
    v37 = (v33 - v35 - v36) ^ (v36 >> 13);
    v38 = (v35 - v36 - v37) ^ (v37 >> 12);
    v39 = (v36 - v37 - v38) ^ (v38 << 16);
    v40 = (v37 - v38 - v39) ^ (v39 >> 5);
    v41 = (v38 - v39 - v40) ^ (v40 >> 3);
    v13 = *(_DWORD *)(*v34
                    + 12
                    * (((v40 - v41 - ((v39 - v40 - v41) ^ (v41 << 10)))
                      ^ (((v39 - v40 - v41) ^ (v41 << 10)) >> 15))
                     & (v34[1] - 1)));
    if ( !v13 )
      goto LABEL_24;
    do
    {
      v13 -= v34[5];
LABEL_24:
      if ( !v13 || v18 == *(_DWORD *)(v13 + 92) && !memcmp(*(const void **)(v13 + 88), s, v18) )
        break;
      v13 = *(_DWORD *)(v13 + 84);
    }
    while ( v13 );
  }
  if ( pthread_rwlock_unlock(&stru_77294) )
    sub_B630("block_exists", 5349);
  off_75ED8();
  if ( v13 )
  {
    if ( !memcmp(v152 + 142, &s2, 0x20u) )
    {
      v4 = 1;
    }
    else if ( !memcmp(&s2, dword_772C0, 0x20u) )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(v165, 0x1000u, "Pool %d now up to date", *v152);
        sub_38730(7, v165, 0);
      }
      v4 = 1;
      v77 = v157;
      v78 = v158;
      v79 = v159;
      v152[142] = s2;
      v152[143] = v77;
      v152[144] = v78;
      v152[145] = v79;
      v80 = v161;
      v81 = v162;
      v82 = v163;
      v152[146] = v160;
      v152[147] = v80;
      v152[148] = v81;
      v152[149] = v82;
    }
    else
    {
      v4 = (unsigned __int8)byte_78E09;
      if ( byte_78E09 )
      {
        if ( byte_7AD48 || (v4 = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 6 )
        {
          v4 = 0;
          snprintf(v165, 0x1000u, "Stale data from pool %d", *v152);
          sub_38730(7, v165, 0);
        }
      }
    }
    if ( *(_BYTE *)(v3 + 1768) )
    {
      v132 = (unsigned int)(dword_76EFC - 3) > 1;
      *(_DWORD *)(v3 + 1824) = ++dword_770AC;
      if ( !v132 || (v42 = *(_DWORD *)(v3 + 1748), v42 == sub_1DA58()) )
      {
        if ( *(_BYTE *)(v3 + 1772) )
        {
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(v165, 0x1000u, "Stratum from pool %d requested work restart", *v152);
            sub_38730(7, v165, 0);
          }
        }
        else if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          v43 = "";
          if ( *(_BYTE *)(v3 + 1812) )
            v43 = "GBT ";
          snprintf(v165, 0x1000u, "%sLONGPOLL from pool %d requested work restart", v43, **(_DWORD **)(v3 + 1748));
          sub_38730(7, v165, 0);
        }
        sub_17210();
      }
    }
    goto LABEL_41;
  }
  v44 = (char *)calloc(0x68u, 1u);
  v45 = (int)v44;
  if ( !v44 )
  {
    strcpy(v165, "test_work_current OOM");
    sub_38730(3, v165, 1);
    sub_16CA8(1);
  }
  strcpy(v44, s);
  v46 = dword_7BB1C++;
  *(_DWORD *)(v45 + 100) = v46;
  if ( pthread_rwlock_wrlock(&stru_77294) )
    sub_B480("test_work_current", 5414);
  v47 = &dword_76BD8;
  v48 = dword_772B4;
  if ( !dword_772B4 )
  {
    *(_DWORD *)(v45 + 76) = 0;
    *(_DWORD *)(v45 + 88) = v45;
    v153 = 0;
    *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
    goto LABEL_105;
  }
  if ( *(_DWORD *)(*(_DWORD *)(dword_772B4 + 68) + 12) <= 6u )
  {
    *(_DWORD *)(v45 + 88) = v45;
    *(_DWORD *)(v45 + 76) = 0;
    v153 = 0;
    *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
    goto LABEL_137;
  }
  v49 = dword_772B4 + 68;
  v50 = 1;
  while ( 2 )
  {
    v51 = v49;
    v49 = 0;
    v52 = 0;
    v53 = 0;
    do
    {
      ++v53;
      if ( v50 )
      {
        v54 = *(_DWORD *)(v51 + 8);
        if ( v54 )
        {
          v56 = *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
          v55 = 1;
          for ( v54 += v56; v54; v54 += v56 )
          {
            if ( v55 == v50 )
              break;
            v54 = *(_DWORD *)(v54 + 8);
            ++v55;
            if ( !v54 )
              break;
          }
        }
        else
        {
          v55 = 1;
        }
      }
      else
      {
        v54 = v51;
        v55 = 0;
      }
      v57 = (int *)v51;
      v58 = v50;
      v51 = v54;
      while ( v55 )
      {
LABEL_69:
        v59 = v58 == 0;
        if ( v58 )
          v59 = v51 == 0;
        if ( v59 )
        {
          if ( !v57 )
            goto LABEL_128;
          v47 = (int *)v57[2];
          if ( v47 )
            v47 = (int *)((char *)v47 + *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20));
LABEL_76:
          --v55;
          if ( !v52 )
            goto LABEL_125;
LABEL_77:
          if ( v57 )
          {
            *(_DWORD *)(v52 + 8) = (char *)v57 - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
            v60 = v52 - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
            v52 = (int)v57;
            v57 = v47;
            goto LABEL_79;
          }
          *(_DWORD *)(v52 + 8) = 0;
          v52 = 0;
          v57 = v47;
        }
        else
        {
          v76 = *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
          v1 = *(_DWORD *)(v51 - v76 + 100);
          v47 = (int *)(*(int *)((char *)v57 - v76 + 100) - v1);
          if ( (int)v47 > 0 )
          {
            v1 = *(_DWORD *)(v51 + 8);
            if ( v1 )
              v1 += v76;
            goto LABEL_113;
          }
          if ( !v57 )
          {
LABEL_128:
            v47 = v57;
            goto LABEL_76;
          }
          v47 = (int *)v57[2];
          --v55;
          if ( v47 )
            v47 = (int *)((char *)v47 + v76);
          if ( v52 )
            goto LABEL_77;
LABEL_125:
          if ( v57 )
          {
            v52 = (int)v57;
            v60 = 0;
            v57 = v47;
            v49 = v52;
            goto LABEL_79;
          }
          v49 = 0;
          v57 = v47;
          v52 = 0;
        }
      }
      while ( 1 )
      {
        v61 = v51 == 0;
        if ( v51 )
          v61 = v58 == 0;
        if ( v61 )
          break;
        v75 = *(_DWORD *)(v51 + 8);
        if ( v75 )
          v47 = *(int **)(v48 + 68);
        else
          v1 = v55;
        if ( v75 )
        {
          v47 = (int *)v47[5];
          v1 = (int)v47 + v75;
        }
LABEL_113:
        --v58;
        if ( v52 )
        {
          v47 = v57;
          v57 = (int *)v51;
          v51 = v1;
          goto LABEL_77;
        }
        v52 = v51;
        v60 = 0;
        v51 = v1;
        v49 = v52;
LABEL_79:
        *(_DWORD *)(v52 + 4) = v60;
        if ( v55 )
          goto LABEL_69;
      }
    }
    while ( v51 );
    if ( v52 )
      *(_DWORD *)(v52 + 8) = 0;
    if ( v53 > 1 )
    {
      v50 *= 2;
      if ( !v49 )
      {
        v52 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) = v52;
  v62 = v49 - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
  dword_772B4 = v62;
  v63 = *(_DWORD *)(v62 + 72);
  v153 = *(_DWORD *)(v62 + 100);
  if ( v63 || *(_DWORD *)(v62 + 76) )
  {
    v64 = *(_DWORD *)(v62 + 68);
    v65 = *(_DWORD *)(v64 + 20);
    if ( v62 == *(_DWORD *)(v64 + 16) - v65 )
    {
      *(_DWORD *)(v64 + 16) = v63 + v65;
      v63 = *(_DWORD *)(v62 + 72);
    }
    if ( v63 )
    {
      v48 = v62;
      *(_DWORD *)(v63 + *(_DWORD *)(*(_DWORD *)(v62 + 68) + 20) + 8) = *(_DWORD *)(v62 + 76);
      v66 = *(_DWORD *)(v62 + 76);
    }
    else
    {
      v66 = *(_DWORD *)(v62 + 76);
      v48 = v66;
      dword_772B4 = v66;
    }
    if ( v66 )
      *(_DWORD *)(v66 + *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20) + 4) = *(_DWORD *)(v62 + 72);
    v67 = *(_DWORD **)(v48 + 68);
    v68 = 12 * ((v67[1] - 1) & *(_DWORD *)(v62 + 96));
    --*(_DWORD *)(*v67 + v68 + 4);
    v69 = **(_DWORD **)(v48 + 68);
    if ( *(_DWORD *)(v69 + v68) == v62 + 68 )
      *(_DWORD *)(v69 + v68) = *(_DWORD *)(v62 + 84);
    v70 = *(_DWORD *)(v62 + 80);
    if ( v70 )
      *(_DWORD *)(v70 + 16) = *(_DWORD *)(v62 + 84);
    v71 = *(_DWORD *)(v62 + 84);
    if ( v71 )
      *(_DWORD *)(v71 + 12) = *(_DWORD *)(v62 + 80);
    --*(_DWORD *)(*(_DWORD *)(v48 + 68) + 12);
  }
  else
  {
    v48 = 0;
    free(**(void ***)(v62 + 68));
    free(*(void **)(v62 + 68));
    dword_772B4 = 0;
  }
  free((void *)v62);
  *(_DWORD *)(v45 + 88) = v45;
  *(_DWORD *)(v45 + 76) = 0;
  *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
  if ( !v48 )
  {
LABEL_105:
    *(_DWORD *)(v45 + 72) = 0;
    dword_772B4 = v45;
    v72 = malloc(0x2Cu);
    v73 = v72;
    *(_DWORD *)(v45 + 68) = v72;
    if ( v72 )
    {
      v150 = v45 + 68;
      *v72 = 0;
      v72[3] = 0;
      v72[4] = 0;
      v72[5] = 0;
      v72[6] = 0;
      v72[7] = 0;
      v72[8] = 0;
      v72[9] = 0;
      v72[10] = 0;
      v72[1] = 32;
      v72[4] = v45 + 68;
      v72[2] = 5;
      v72[5] = 68;
      v74 = malloc(0x180u);
      *v73 = v74;
      if ( v74 )
      {
        memset(v74, 0, 0x180u);
        v48 = v45;
        v73[10] = -1609490463;
        goto LABEL_138;
      }
    }
LABEL_251:
    exit(-1);
  }
LABEL_137:
  v150 = v45 + 68;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) + 8) = v45;
  *(_DWORD *)(v45 + 72) = *(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
  *(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) = v45 + 68;
  v73 = *(_DWORD **)(v48 + 68);
LABEL_138:
  v83 = -17973521;
  ++v73[3];
  v84 = *(_DWORD *)(v48 + 68);
  v85 = -1640531527;
  *(_DWORD *)(v45 + 96) = -17973521;
  *(_DWORD *)(v45 + 68) = v84;
  v86 = strlen((const char *)v45);
  v87 = v86;
  if ( v86 <= 0xB )
  {
    v89 = -1640531527;
    v88 = (unsigned __int8 *)v45;
  }
  else
  {
    v88 = (unsigned __int8 *)v45;
    v89 = -1640531527;
    do
    {
      v87 -= 12;
      v90 = (v88[2] << 16) + (v88[1] << 8) + *v88;
      v91 = v88[3];
      v92 = (v88[6] << 16) + (v88[5] << 8) + v88[4];
      v93 = v88[7];
      v94 = (v88[10] << 16) + (v88[9] << 8) + v88[8] + (v88[11] << 24) + v83;
      v88 += 12;
      v95 = v92 + (v93 << 24) + v85;
      v96 = (v90 + (v91 << 24) - v94 - v95 + v89) ^ (v94 >> 13);
      v97 = (v95 - v94 - v96) ^ (v96 << 8);
      v98 = (v94 - v96 - v97) ^ (v97 >> 13);
      v99 = (v96 - v97 - v98) ^ (v98 >> 12);
      v100 = (v97 - v98 - v99) ^ (v99 << 16);
      v101 = (v98 - v99 - v100) ^ (v100 >> 5);
      v89 = (v99 - v100 - v101) ^ (v101 >> 3);
      v85 = (v100 - v101 - v89) ^ (v89 << 10);
      v83 = (v101 - v89 - v85) ^ (v85 >> 15);
      *(_DWORD *)(v45 + 96) = v83;
    }
    while ( v87 > 0xB );
    v86 = strlen((const char *)v45);
  }
  v102 = v86 + v83;
  *(_DWORD *)(v45 + 96) = v102;
  switch ( v87 )
  {
    case 1u:
      goto LABEL_153;
    case 2u:
      goto LABEL_152;
    case 3u:
      goto LABEL_151;
    case 4u:
      goto LABEL_150;
    case 5u:
      goto LABEL_149;
    case 6u:
      goto LABEL_148;
    case 7u:
      goto LABEL_147;
    case 8u:
      goto LABEL_146;
    case 9u:
      goto LABEL_145;
    case 0xAu:
      goto LABEL_144;
    case 0xBu:
      v102 += v88[10] << 24;
      *(_DWORD *)(v45 + 96) = v102;
LABEL_144:
      v102 += v88[9] << 16;
      *(_DWORD *)(v45 + 96) = v102;
LABEL_145:
      v102 += v88[8] << 8;
      *(_DWORD *)(v45 + 96) = v102;
LABEL_146:
      v85 += v88[7] << 24;
LABEL_147:
      v85 += v88[6] << 16;
LABEL_148:
      v85 += v88[5] << 8;
LABEL_149:
      v85 += v88[4];
LABEL_150:
      v89 += v88[3] << 24;
LABEL_151:
      v89 += v88[2] << 16;
LABEL_152:
      v89 += v88[1] << 8;
LABEL_153:
      v89 += *v88;
      break;
    default:
      break;
  }
  v103 = (v89 - v85 - v102) ^ (v102 >> 13);
  v104 = (v85 - v102 - v103) ^ (v103 << 8);
  v105 = (v102 - v103 - v104) ^ (v104 >> 13);
  v106 = (v103 - v104 - v105) ^ (v105 >> 12);
  v107 = (v104 - v105 - v106) ^ (v106 << 16);
  v108 = (v105 - v106 - v107) ^ (v107 >> 5);
  v109 = v106 - v107 - v108;
  v110 = (v108 - (v109 ^ (v108 >> 3)) - ((v107 - v108 - (v109 ^ (v108 >> 3))) ^ ((v109 ^ (v108 >> 3)) << 10)))
       ^ (((v107 - v108 - (v109 ^ (v108 >> 3))) ^ ((v109 ^ (v108 >> 3)) << 10)) >> 15);
  *(_DWORD *)(v45 + 96) = v110;
  v111 = *(_DWORD **)(v48 + 68);
  v112 = 12 * (v110 & (v111[1] - 1));
  ++*(_DWORD *)(*v111 + v112 + 4);
  v113 = *(_DWORD *)(**(_DWORD **)(v48 + 68) + v112);
  *(_DWORD *)(v45 + 80) = 0;
  *(_DWORD *)(v45 + 84) = v113;
  v114 = **(_DWORD **)(v48 + 68) + v112;
  if ( *(_DWORD *)v114 )
  {
    *(_DWORD *)(*(_DWORD *)v114 + 12) = v150;
    v114 = **(_DWORD **)(v48 + 68) + v112;
  }
  *(_DWORD *)v114 = v150;
  if ( *(_DWORD *)(**(_DWORD **)(v48 + 68) + v112 + 4) >= (unsigned int)(10
                                                                       * (*(_DWORD *)(**(_DWORD **)(v48 + 68) + v112 + 8)
                                                                        + 1)) )
  {
    v115 = *(_DWORD *)(v45 + 68);
    if ( *(_DWORD *)(v115 + 36) != 1 )
    {
      v116 = 24 * *(_DWORD *)(v115 + 4);
      v117 = malloc(v116);
      v118 = v117;
      if ( !v117 )
        goto LABEL_251;
      memset(v117, 0, v116);
      *(_DWORD *)(v115 + 24) = (((2 * *(_DWORD *)(v115 + 4) - 1) & *(_DWORD *)(v115 + 12)) != 0)
                             + (*(_DWORD *)(v115 + 12) >> (*(_BYTE *)(v115 + 8) + 1));
      *(_DWORD *)(*(_DWORD *)(v45 + 68) + 28) = 0;
      v119 = *(_DWORD *)(v45 + 68);
      v120 = *(_DWORD *)(v119 + 4);
      if ( v120 )
      {
        v154 = v3;
        v121 = 0;
        v122 = v45;
        for ( i = 0; i < v120; ++i )
        {
          v123 = *(_DWORD **)(*(_DWORD *)v119 + v121);
          if ( v123 )
          {
            while ( 1 )
            {
              v124 = (_DWORD *)v123[4];
              v125 = 3 * ((2 * v120 - 1) & v123[7]);
              v126 = (char *)&v118[v125];
              v127 = *((_DWORD *)v126 + 1) + 1;
              *((_DWORD *)v126 + 1) = v127;
              if ( v127 > *(_DWORD *)(v119 + 24) )
              {
                ++*(_DWORD *)(v119 + 28);
                *((_DWORD *)v126 + 2) = *((_DWORD *)v126 + 1) / *(_DWORD *)(*(_DWORD *)(v122 + 68) + 24);
              }
              v123[3] = 0;
              v123[4] = v118[v125];
              v128 = v118[v125];
              if ( v128 )
                *(_DWORD *)(v128 + 12) = v123;
              v118[v125] = v123;
              v119 = *(_DWORD *)(v122 + 68);
              if ( !v124 )
                break;
              v120 = *(_DWORD *)(v119 + 4);
              v123 = v124;
            }
            v120 = *(_DWORD *)(v119 + 4);
          }
          v121 += 12;
        }
        v45 = v122;
        v3 = v154;
      }
      free(*(void **)v119);
      *(_DWORD *)(*(_DWORD *)(v45 + 68) + 4) *= 2;
      ++*(_DWORD *)(*(_DWORD *)(v45 + 68) + 8);
      **(_DWORD **)(v45 + 68) = v118;
      v129 = *(_DWORD **)(v45 + 68);
      v130 = v129[3];
      v131 = v129[7];
      v132 = v131 > v130 >> 1;
      if ( v131 <= v130 >> 1 )
        v133 = 0;
      else
        v133 = v129[8];
      if ( v132 )
        ++v133;
      v129[8] = v133;
      v134 = *(_DWORD *)(v45 + 68);
      if ( *(_DWORD *)(v134 + 32) > 1u )
        *(_DWORD *)(v134 + 36) = 1;
    }
  }
  LODWORD(v2) = 8 * (29 - *(unsigned __int8 *)(v3 + 72));
  v135 = bswap32(*(_DWORD *)(v3 + 72)) & 0xFFFFFF;
  LODWORD(v136) = sub_5CB50(vshld_u64(0xFFFFu, v2));
  v137 = v136 / (double)v135;
  if ( v137 != dbl_75DE0 )
  {
    LODWORD(v149) = sub_5CC48(v137);
    sub_11580(v149, byte_772B8, 8u, 0);
    dbl_75DE0 = v137;
    if ( byte_78E09 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
      {
        snprintf(v165, 0x1000u, "Network diff set to %s", byte_772B8);
        sub_38730(7, v165, 0);
      }
    }
  }
  if ( pthread_rwlock_unlock(&stru_77294) )
    sub_B630("test_work_current", 5430);
  off_75ED8();
  if ( v153 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v165, 0x1000u, "Deleted block %d from database", v153);
    sub_38730(7, v165, 0);
  }
  if ( pthread_mutex_lock(&stru_7B9D8) )
    sub_B414("set_curblock", 5324);
  if ( pthread_rwlock_wrlock(&stru_7B9F0) )
    sub_B480("set_curblock", 5324);
  sub_2A84C((struct timeval *)&dword_7B070);
  strcpy(dest, s);
  timer = dword_7B070;
  dword_772C0[0] = s2;
  dword_772C0[1] = v157;
  dword_772C0[2] = v158;
  dword_772C0[3] = v159;
  unk_772D0 = v160;
  unk_772D4 = v161;
  unk_772D8 = v162;
  unk_772DC = v163;
  v138 = localtime(&timer);
  snprintf(byte_772E0, 0x20u, "[%02d:%02d:%02d]", v138->tm_hour, v138->tm_min, v138->tm_sec);
  if ( pthread_rwlock_unlock(&stru_7B9F0) )
    sub_B630("set_curblock", 5329);
  if ( pthread_mutex_unlock(&stru_7B9D8) )
    sub_B5C4("set_curblock", 5329);
  off_75ED8();
  for ( j = 0; j != 57; ++j )
  {
    if ( dest[j] != 48 )
      break;
  }
  strncpy(byte_77300, &dest[j], 8u);
  byte_77308 = 0;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v165, 0x1000u, "New block: %s... diff %s", dest, byte_772B8);
    sub_38730(7, v165, 0);
  }
  v140 = v157;
  v141 = v158;
  v142 = v159;
  v143 = dword_7BB1C;
  v152[142] = s2;
  v152[143] = v140;
  v152[144] = v141;
  v152[145] = v142;
  v144 = v161;
  v145 = v162;
  v146 = v163;
  v152[146] = v160;
  v152[147] = v144;
  v152[148] = v145;
  v152[149] = v146;
  if ( v143 == 1 )
  {
    v4 = 0;
LABEL_41:
    *(_BYTE *)(v3 + 1768) = 0;
    return v4;
  }
  v147 = *(unsigned __int8 *)(v3 + 1768);
  *(_DWORD *)(v3 + 1824) = ++dword_770AC;
  if ( v147 )
  {
    if ( *(_BYTE *)(v3 + 1772) )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(v165, 0x1000u, "Stratum from pool %d detected new block", *v152);
        sub_38730(7, v165, 0);
      }
    }
    else if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      v148 = "";
      if ( *(_BYTE *)(v3 + 1812) )
        v148 = "GBT ";
      snprintf(v165, 0x1000u, "%sLONGPOLL from pool %d detected new block", v148, **(_DWORD **)(v3 + 1748));
      sub_38730(7, v165, 0);
    }
  }
  else if ( byte_7BC79 )
  {
    if ( !*((_BYTE *)v152 + 924) && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v165, "New block detected on network before pool notification");
      sub_38730(7, v165, 0);
    }
  }
  else if ( !*((_BYTE *)v152 + 924) && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v165, "New block detected on network");
    sub_38730(7, v165, 0);
  }
  sub_17210();
  v4 = 1;
  *(_BYTE *)(v3 + 1768) = 0;
  return v4;
}
// 1DCF0: control flows out of bounds to 1DCF4
// 1E698: control flows out of bounds to 1E69C
// 1E3A0: variable 'v1' is possibly undefined
// 1EA1C: variable 'v2' is possibly undefined
// 1EA34: variable 'v136' is possibly undefined
// 1F080: variable 'v149' is possibly undefined
// 75DE0: using guessed type double dbl_75DE0;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76BD8: using guessed type int dword_76BD8;
// 76EFC: using guessed type int dword_76EFC;
// 770AC: using guessed type int dword_770AC;
// 772B4: using guessed type int dword_772B4;
// 772C0: using guessed type _DWORD dword_772C0[4];
// 77308: using guessed type char byte_77308;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B070: using guessed type int dword_7B070;
// 7BB1C: using guessed type int dword_7BB1C;
// 7BC79: using guessed type char byte_7BC79;

//----- (0001F17C) --------------------------------------------------------
int __fastcall sub_1F17C(int a1)
{
  _DWORD *v1; // r11
  pthread_mutex_t *v3; // r0
  int v4; // r0
  int v5; // r6
  int v6; // r8
  int v7; // r9
  int v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r0
  int v11; // r1
  unsigned int v12; // r2
  unsigned int v13; // r3
  unsigned int v14; // r1
  unsigned int v15; // r3
  _DWORD *v16; // r2
  int v17; // r3
  int v18; // r2
  int v19; // r2
  int v20; // r7
  int v21; // r3
  size_t v22; // r6
  _DWORD *v23; // r0
  _DWORD *v24; // r8
  int v25; // r3
  int v26; // r1
  unsigned int v27; // r3
  _DWORD *v28; // r6
  int v29; // r7
  unsigned int v30; // r0
  int v31; // r3
  _DWORD *v32; // r3
  unsigned int v33; // r1
  unsigned int v34; // r2
  bool v35; // cc
  int v36; // r2
  int v37; // r3
  int v38; // r0
  int v39; // r10
  _DWORD *v40; // r12
  int v41; // lr
  unsigned int v42; // r8
  _DWORD *j; // r3
  int v44; // r2
  int v45; // r1
  int v46; // r1
  int v47; // r6
  bool v48; // zf
  int v49; // r3
  bool v50; // zf
  int v52; // r3
  int v53; // r3
  _DWORD *v54; // r0
  _DWORD *v55; // r7
  void *v56; // r0
  int v57; // r3
  void *v58; // r0
  int v59; // [sp+0h] [bp-100Ch]
  unsigned int i; // [sp+4h] [bp-1008h]
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 1748));
    sub_38730(7, s, 0);
  }
  *(_DWORD *)(a1 + 1824) = dword_770AC;
  sub_1DB0C(a1);
  v3 = (pthread_mutex_t *)dword_7704C;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 1748) + 68);
  if ( pthread_mutex_lock(v3) )
    sub_B414("hash_push", 5533);
  if ( !*(_BYTE *)(a1 + 1761) && *(_DWORD *)(a1 + 1764) )
    ++dword_77058;
  v4 = dword_7B620;
  if ( *(_BYTE *)(dword_7B620 + 8) )
    goto LABEL_72;
  v5 = dword_77050;
  *(_DWORD *)(a1 + 1840) = *(unsigned __int8 *)(dword_7B620 + 8);
  *(_DWORD *)(a1 + 1852) = a1 + 1828;
  *(_DWORD *)(a1 + 1856) = 4;
  if ( v5 )
  {
    v6 = a1 + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 1832) + 16) + 8) = a1;
    *(_DWORD *)(a1 + 1836) = *(_DWORD *)(*(_DWORD *)(v5 + 1832) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 1832) + 20);
    *(_DWORD *)(*(_DWORD *)(v5 + 1832) + 16) = a1 + 1832;
  }
  else
  {
    *(_DWORD *)(a1 + 1836) = 0;
    dword_77050 = a1;
    v54 = malloc(0x2Cu);
    v55 = v54;
    *(_DWORD *)(a1 + 1832) = v54;
    if ( !v54 )
      goto LABEL_100;
    *v54 = 0;
    v54[3] = 0;
    v54[4] = 0;
    v6 = a1 + 1832;
    v54[5] = 0;
    v54[6] = 0;
    v54[7] = 0;
    v54[8] = 0;
    v54[9] = 0;
    v54[10] = 0;
    v54[4] = a1 + 1832;
    v54[1] = 32;
    v54[2] = 5;
    v54[5] = 1832;
    v56 = malloc(0x180u);
    v57 = dword_77050;
    *v55 = v56;
    v58 = **(void ***)(v57 + 1832);
    if ( !v58 )
      goto LABEL_100;
    memset(v58, 0, 0x180u);
    v5 = dword_77050;
    *(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(v5 + 1832) + 12);
  v7 = *(unsigned __int8 *)(a1 + 1830);
  v8 = (*(unsigned __int8 *)(a1 + 1828)
      + 17973517
      + (*(unsigned __int8 *)(a1 + 1831) << 24)
      + (v7 << 16)
      + (*(unsigned __int8 *)(a1 + 1829) << 8))
     ^ 0x7F76D;
  *(_DWORD *)(a1 + 1832) = *(_DWORD *)(v5 + 1832);
  v9 = (-1622558010 - v8) ^ (v8 << 8);
  v10 = (-17973517 - v8 - v9) ^ (v9 >> 13);
  v11 = (v8 - v9 - v10) ^ (v10 >> 12);
  v12 = (v9 - v10 - v11) ^ (v11 << 16);
  v13 = (v10 - v11 - v12) ^ (v12 >> 5);
  v14 = v11 - v12 - v13;
  v15 = (v13 - (v14 ^ (v13 >> 3)) - ((v12 - v13 - (v14 ^ (v13 >> 3))) ^ ((v14 ^ (v13 >> 3)) << 10)))
      ^ (((v12 - v13 - (v14 ^ (v13 >> 3))) ^ ((v14 ^ (v13 >> 3)) << 10)) >> 15);
  *(_DWORD *)(a1 + 1860) = v15;
  v16 = *(_DWORD **)(v5 + 1832);
  v17 = 12 * (v15 & (v16[1] - 1));
  ++*(_DWORD *)(*v16 + v17 + 4);
  v18 = *(_DWORD *)(**(_DWORD **)(v5 + 1832) + v17);
  *(_DWORD *)(a1 + 1844) = 0;
  *(_DWORD *)(a1 + 1848) = v18;
  v19 = **(_DWORD **)(v5 + 1832) + v17;
  if ( *(_DWORD *)v19 )
  {
    *(_DWORD *)(*(_DWORD *)v19 + 12) = v6;
    v19 = **(_DWORD **)(v5 + 1832) + v17;
  }
  *(_DWORD *)v19 = v6;
  v20 = dword_77050;
  if ( *(_DWORD *)(**(_DWORD **)(dword_77050 + 1832) + v17 + 4) >= (unsigned int)(10
                                                                                * (*(_DWORD *)(**(_DWORD **)(dword_77050 + 1832)
                                                                                             + v17
                                                                                             + 8)
                                                                                 + 1)) )
  {
    v21 = *(_DWORD *)(a1 + 1832);
    if ( *(_DWORD *)(v21 + 36) != 1 )
    {
      v22 = 24 * *(_DWORD *)(v21 + 4);
      v23 = malloc(v22);
      v24 = v23;
      if ( v23 )
      {
        memset(v23, 0, v22);
        v25 = *(_DWORD *)(a1 + 1832);
        v7 = 0;
        *(_DWORD *)(v25 + 24) = (((2 * *(_DWORD *)(v25 + 4) - 1) & *(_DWORD *)(v25 + 12)) != 0)
                              + (*(_DWORD *)(v25 + 12) >> (*(_BYTE *)(v25 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a1 + 1832) + 28) = 0;
        v26 = *(_DWORD *)(a1 + 1832);
        v27 = *(_DWORD *)(v26 + 4);
        if ( v27 )
        {
          v59 = 0;
          for ( i = 0; i < v27; ++i )
          {
            v28 = *(_DWORD **)(*(_DWORD *)v26 + v59);
            if ( v28 )
            {
              while ( 1 )
              {
                v1 = (_DWORD *)v28[4];
                v29 = 3 * ((2 * v27 - 1) & v28[7]);
                v7 = (int)&v24[3 * ((2 * v27 - 1) & v28[7])];
                v30 = *(_DWORD *)(v7 + 4) + 1;
                *(_DWORD *)(v7 + 4) = v30;
                if ( v30 > *(_DWORD *)(v26 + 24) )
                {
                  ++*(_DWORD *)(v26 + 28);
                  *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 4) / *(_DWORD *)(*(_DWORD *)(a1 + 1832) + 24);
                }
                v28[3] = 0;
                v28[4] = v24[v29];
                v31 = v24[v29];
                if ( v31 )
                  *(_DWORD *)(v31 + 12) = v28;
                v24[v29] = v28;
                v26 = *(_DWORD *)(a1 + 1832);
                if ( !v1 )
                  break;
                v27 = *(_DWORD *)(v26 + 4);
                v28 = v1;
              }
              v27 = *(_DWORD *)(v26 + 4);
            }
            v59 += 12;
          }
        }
        free(*(void **)v26);
        *(_DWORD *)(*(_DWORD *)(a1 + 1832) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 1832) + 8);
        **(_DWORD **)(a1 + 1832) = v24;
        v32 = *(_DWORD **)(a1 + 1832);
        v20 = dword_77050;
        v33 = v32[3];
        v34 = v32[7];
        v35 = v34 > v33 >> 1;
        if ( v34 <= v33 >> 1 )
          v36 = 0;
        else
          v36 = v32[8];
        if ( v35 )
          ++v36;
        v32[8] = v36;
        v37 = *(_DWORD *)(a1 + 1832);
        if ( *(_DWORD *)(v37 + 32) > 1u )
          *(_DWORD *)(v37 + 36) = 1;
        if ( !v20 )
        {
          v4 = dword_7B620;
          goto LABEL_72;
        }
        goto LABEL_38;
      }
LABEL_100:
      exit(-1);
    }
  }
LABEL_38:
  v38 = 1;
  v39 = v20 + 1832;
  while ( 2 )
  {
    v40 = (_DWORD *)v39;
    v39 = 0;
    v41 = 0;
    v42 = 0;
    do
    {
      ++v42;
      if ( v38 )
      {
        j = (_DWORD *)v40[2];
        if ( j )
        {
          v45 = *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
          v44 = 1;
          for ( j = (_DWORD *)((char *)j + v45); j; j = (_DWORD *)((char *)j + v45) )
          {
            if ( v44 == v38 )
              break;
            j = (_DWORD *)j[2];
            ++v44;
            if ( !j )
              break;
          }
        }
        else
        {
          v44 = 1;
        }
      }
      else
      {
        j = v40;
        v44 = 0;
      }
      v46 = (int)v40;
      v47 = v38;
      v40 = j;
      while ( v44 )
      {
LABEL_50:
        v48 = v47 == 0;
        if ( v47 )
          v48 = v40 == 0;
        if ( v48 )
        {
          if ( !v46 )
            goto LABEL_94;
          v7 = *(_DWORD *)(v46 + 8);
          if ( v7 )
            v7 += *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
LABEL_57:
          --v44;
          if ( !v41 )
            goto LABEL_91;
LABEL_58:
          if ( v46 )
          {
            *(_DWORD *)(v41 + 8) = v46 - *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
            v49 = v41 - *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
            v41 = v46;
            v46 = v7;
            goto LABEL_60;
          }
          *(_DWORD *)(v41 + 8) = 0;
          v41 = 0;
          v46 = v7;
        }
        else
        {
          v53 = *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
          v1 = *(_DWORD **)((char *)v40 - v53 + 1752);
          v7 = *(_DWORD *)(v46 - v53 + 1752) - (_DWORD)v1;
          if ( v7 > 0 )
          {
            v1 = (_DWORD *)v40[2];
            if ( v1 )
              v1 = (_DWORD *)((char *)v1 + v53);
            goto LABEL_79;
          }
          if ( !v46 )
          {
LABEL_94:
            v7 = v46;
            goto LABEL_57;
          }
          v7 = *(_DWORD *)(v46 + 8);
          --v44;
          if ( v7 )
            v7 += v53;
          if ( v41 )
            goto LABEL_58;
LABEL_91:
          if ( v46 )
          {
            v41 = v46;
            v49 = 0;
            v46 = v7;
            v39 = v41;
            goto LABEL_60;
          }
          v39 = 0;
          v46 = v7;
          v41 = 0;
        }
      }
      while ( 1 )
      {
        v50 = v40 == 0;
        if ( v40 )
          v50 = v47 == 0;
        if ( v50 )
          break;
        v52 = v40[2];
        if ( v52 )
          v7 = *(_DWORD *)(v20 + 1832);
        else
          v1 = (_DWORD *)v44;
        if ( v52 )
        {
          v7 = *(_DWORD *)(v7 + 20);
          v1 = (_DWORD *)(v52 + v7);
        }
LABEL_79:
        --v47;
        if ( v41 )
        {
          v7 = v46;
          v46 = (int)v40;
          v40 = v1;
          goto LABEL_58;
        }
        v41 = (int)v40;
        v49 = 0;
        v40 = v1;
        v39 = v41;
LABEL_60:
        *(_DWORD *)(v41 + 4) = v49;
        if ( v44 )
          goto LABEL_50;
      }
    }
    while ( v40 );
    if ( v41 )
      *(_DWORD *)(v41 + 8) = 0;
    if ( v42 > 1 )
    {
      v38 *= 2;
      if ( !v39 )
      {
        v41 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 16) = v41;
  v4 = dword_7B620;
  dword_77050 = v39 - *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
LABEL_72:
  pthread_cond_broadcast((pthread_cond_t *)(v4 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
    sub_B5C4("hash_push", 5544);
  return off_75ED8();
}
// 1F760: variable 'v1' is possibly undefined
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 7704C: using guessed type int dword_7704C;
// 77050: using guessed type int dword_77050;
// 77058: using guessed type int dword_77058;
// 770AC: using guessed type int dword_770AC;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B620: using guessed type int dword_7B620;

//----- (0001F938) --------------------------------------------------------
int __fastcall sub_1F938(int a1, int a2, int a3)
{
  int v6; // r1
  __int64 v7; // r2
  int v8; // r4
  int v10; // r0

  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("inc_work_stats", 8393);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_QWORD *)(v6 + 192) + a3;
  *(_QWORD *)&dword_7B100 += a3;
  *(_QWORD *)(v6 + 192) = v7;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v10 = sub_1DA58();
    *(_QWORD *)(v10 + 40) += a3;
  }
  v8 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v8 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("inc_work_stats", 8406);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B100: using guessed type int dword_7B100;

//----- (0001FA14) --------------------------------------------------------
void __fastcall sub_1FA14(int a1)
{
  int v2; // r0
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( !sub_18834(a1, (_BYTE *)(a1 + 129)) )
  {
    sub_2A84C((struct timeval *)(a1 + 168));
    v2 = sub_1DA58();
    if ( v2 == a1 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, "Pool %d %s not responding!", *(_DWORD *)v2, *(const char **)(v2 + 196));
        sub_38730(4, s, 0);
      }
      sub_19BF8(0);
    }
    else if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 196));
      sub_38730(7, s, 0);
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001FB44) --------------------------------------------------------
int __fastcall sub_1FB44(int a1)
{
  int result; // r0

  result = sub_18834(a1, (_BYTE *)(a1 + 129));
  if ( !result )
  {
    sub_2A84C((struct timeval *)(a1 + 168));
    result = sub_1DA58();
    if ( a1 == result )
      return sub_19BF8(0);
  }
  return result;
}

//----- (0001FB7C) --------------------------------------------------------
int sub_1FB7C()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_7BA10) )
    sub_B414("cp_prio", 7036);
  if ( pthread_rwlock_rdlock(&stru_7BA28) )
    sub_B69C("cp_prio", 7036);
  if ( pthread_mutex_unlock(&stru_7BA10) )
    sub_B5C4("cp_prio", 7036);
  v0 = *(_DWORD *)(dword_7705C + 4);
  if ( pthread_rwlock_unlock(&stru_7BA28) )
    sub_B630("cp_prio", 7038);
  off_75ED8();
  return v0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7705C: using guessed type int dword_7705C;

//----- (0001FC34) --------------------------------------------------------
void __fastcall sub_1FC34(_DWORD *a1)
{
  int v1; // r3
  int v3; // r5
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = dword_76EFC;
  a1[7] = 0;
  if ( v1 || (v3 = a1[1], v3 >= sub_1FB7C()) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "Pool %d %s alive", *a1, (const char *)a1[49]);
      sub_38730(7, s, 0);
    }
  }
  else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(s, 0x1000u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[49]);
    sub_38730(4, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 76EFC: using guessed type int dword_76EFC;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001FD64) --------------------------------------------------------
void __fastcall sub_1FD64(_DWORD *a1)
{
  char v2[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( sub_18C2C((int)a1, (_BYTE *)a1 + 129) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v2, 0x1000u, "Stratum connection to pool %d resumed", *a1);
      sub_38730(7, v2, 0);
    }
    sub_1FC34(a1);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001FE0C) --------------------------------------------------------
void *__fastcall start_routine(_DWORD *a1)
{
  _BOOL4 v2; // r5
  int v3; // r5
  pthread_t v5; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( !*((_BYTE *)a1 + 139) )
  {
    v5 = pthread_self();
    pthread_detach(v5);
  }
  while ( !sub_18CA0(a1, 0) )
  {
    sub_1FA14((int)a1);
    sleep(5u);
  }
  sub_18834((int)a1, (_BYTE *)a1 + 130);
  sub_18C2C((int)a1, (_BYTE *)a1 + 129);
  if ( pthread_mutex_lock(&stru_7BA10) )
    sub_B414("test_pool_thread", 10008);
  if ( pthread_rwlock_wrlock(&stru_7BA28) )
    sub_B480("test_pool_thread", 10008);
  if ( byte_7730C )
  {
    v2 = 0;
  }
  else
  {
    v3 = *a1;
    dword_7705C = (int)a1;
    byte_7730C = 1;
    v2 = v3 != 0;
  }
  if ( pthread_rwlock_unlock(&stru_7BA28) )
    sub_B630("test_pool_thread", 10016);
  if ( pthread_mutex_unlock(&stru_7BA10) )
    sub_B5C4("test_pool_thread", 10016);
  off_75ED8();
  if ( v2 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[49]);
    sub_38730(7, s, 0);
  }
  sub_1FC34(a1);
  sub_19BF8(0);
  *((_BYTE *)a1 + 316) = 0;
  return 0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 7705C: using guessed type int dword_7705C;
// 7730C: using guessed type char byte_7730C;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0001FFEC) --------------------------------------------------------
int __fastcall sub_1FFEC(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 132) != 1 )
    return 0;
  if ( dword_76EFC == 4 || dword_76EFC == 3 || *(_BYTE *)(a1 + 664) && *(_BYTE *)(a1 + 129) )
    return 1;
  if ( a1 == sub_1DA58() )
    return 1;
  if ( *(_DWORD *)(a1 + 756) )
    return 1;
  if ( !dword_76EFC )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < sub_1FB7C() )
      return 1;
  }
  return (unsigned __int8)byte_7B4C8;
}
// 76EFC: using guessed type int dword_76EFC;
// 7B4C8: using guessed type char byte_7B4C8;

//----- (00020088) --------------------------------------------------------
void *__fastcall sub_20088(_DWORD *a1)
{
  int v1; // r11
  pthread_t v3; // r0
  fd_set *v4; // r3
  int v5; // r3
  int v6; // r0
  int *v7; // r4
  int *v9; // r0
  _DWORD *v10; // r0
  void **v11; // r5
  int v12; // r6
  unsigned int v13; // r3
  unsigned int v14; // r2
  unsigned int v15; // r0
  _DWORD *v16; // r7
  int v17; // r1
  unsigned int v18; // r2
  unsigned int v19; // r3
  int v20; // r1
  unsigned int v21; // r1
  int v22; // r3
  int v23; // r12
  int v24; // r12
  int v25; // r7
  time_t v26; // r0
  int v27; // r3
  double *v28; // r9
  double v29; // d0
  unsigned int v30; // r6
  int v31; // r1
  __int64 v32; // d8
  const char *v33; // r2
  unsigned int v34; // r3
  _DWORD *v35; // r6
  double v36; // d18
  double v37; // d16
  double v38; // d16
  double v39; // d17
  size_t v40; // r0
  size_t v41; // r3
  _BYTE *v42; // r9
  int v43; // r9
  double v44; // r0
  int v45; // r5
  int v46; // r3
  int v47; // r2
  _DWORD *v48; // r1
  bool v49; // zf
  int v50; // r3
  int v51; // r2
  int v52; // r2
  int v53; // r3
  int v54; // r3
  _DWORD *v55; // r0
  int v56; // r5
  int v57; // r3
  int v58; // r2
  int v59; // r4
  char *v60; // r6
  int v61; // r3
  int v62; // r3
  int v63; // r3
  double v64; // d8
  double v65; // d16
  double v66; // d17
  double v67; // d18
  double v68; // d16
  double v69; // d16
  int v70; // r3
  time_t v71; // r0
  int v72; // r1
  _DWORD *v73; // r0
  const char *v74; // r0
  double v75; // d16
  double v76; // d17
  size_t n; // [sp+1Ch] [bp-1268h]
  int *v78; // [sp+38h] [bp-124Ch]
  int v79; // [sp+40h] [bp-1244h]
  _DWORD *src; // [sp+44h] [bp-1240h]
  const char *srca; // [sp+44h] [bp-1240h]
  _DWORD *v82; // [sp+48h] [bp-123Ch]
  int s2; // [sp+50h] [bp-1234h] BYREF
  struct timeval timeout; // [sp+54h] [bp-1230h] BYREF
  char s[16]; // [sp+5Ch] [bp-1228h] BYREF
  char v86[20]; // [sp+6Ch] [bp-1218h] BYREF
  char v87[2]; // [sp+80h] [bp-1204h] BYREF
  char dest[30]; // [sp+82h] [bp-1202h] BYREF
  char v89[36]; // [sp+A0h] [bp-11E4h] BYREF
  char v90[60]; // [sp+C4h] [bp-11C0h] BYREF
  char v91; // [sp+100h] [bp-1184h] BYREF
  fd_set readfds; // [sp+104h] [bp-1180h] BYREF
  int v93[23]; // [sp+184h] [bp-1100h] BYREF
  char v94[160]; // [sp+1E0h] [bp-10A4h] BYREF
  _DWORD v95[1024]; // [sp+280h] [bp-1004h] BYREF
  _BYTE v96[4]; // [sp+1280h] [bp-4h] BYREF

  v3 = pthread_self();
  pthread_detach(v3);
  snprintf(s, 0x10u, "%d/RStratum", *a1);
  sub_2F0B4(s);
  while ( !*((_BYTE *)a1 + 137) )
  {
    if ( !sub_2AE10((int)a1) && !sub_1FFEC((int)a1) )
    {
      sub_2AEE0((int)a1);
      sub_182F4((int)a1);
      sub_185C8(a1);
      while ( !sub_1FFEC((int)a1) && (!a1[33] || a1 != (_DWORD *)sub_1DA58() && dword_76EFC != 3 && dword_76EFC != 4) )
      {
        if ( pthread_mutex_lock(&stru_77060) )
          sub_B414("wait_lpcurrent", 9248);
        pthread_cond_wait(&stru_77078, &stru_77060);
        if ( pthread_mutex_unlock(&stru_77060) )
          sub_B5C4("wait_lpcurrent", 9250);
        off_75ED8();
      }
      while ( !sub_2CEC8((int)a1) )
      {
        if ( *((_BYTE *)a1 + 137) )
          return 0;
        sub_2A92C();
      }
    }
    v4 = (fd_set *)&v91;
    do
    {
      v4->__fds_bits[1] = 0;
      v4 = (fd_set *)((char *)v4 + 4);
    }
    while ( v4 != (fd_set *)&readfds.__fds_bits[31] );
    v5 = a1[153];
    timeout.tv_usec = 0;
    timeout.tv_sec = 90;
    readfds.__fds_bits[v5 / 32] |= 1 << (v5 % 32);
    if ( sub_2AE10((int)a1) || (v6 = select(a1[153] + 1, &readfds, 0, 0, &timeout), v6 > 0) )
    {
      v7 = (int *)sub_2B040((int)a1);
      if ( !v7 )
      {
        v57 = (unsigned __int8)byte_78E09;
        goto LABEL_121;
      }
      sub_1FD64(a1);
      if ( sub_2CF40(a1, v7) )
        goto LABEL_10;
      v9 = sub_59230(v7, 0, (char *)v93);
      v78 = v9;
      if ( v9 )
      {
        src = (_DWORD *)sub_59E20(v9, "result");
        v82 = (_DWORD *)sub_59E20(v78, "error");
        v10 = (_DWORD *)sub_59E20(v78, "id");
        if ( !v10 || *v10 == 7 )
        {
          if ( v82 )
          {
            v60 = (char *)sub_57854(v82, 3);
          }
          else
          {
            v60 = (char *)malloc(0x11u);
            if ( v60 )
              strcpy(v60, "(unknown reason)");
          }
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf((char *)v95, 0x1000u, "JSON-RPC non method decode failed: %s", v60);
            sub_38730(7, (const char *)v95, 0);
          }
          v45 = 0;
          free(v60);
        }
        else
        {
          s2 = sub_5A248((int)v10);
          if ( pthread_mutex_lock(&stru_77030) )
            sub_B414("parse_stratum_response", 6921);
          v11 = (void **)dword_77048;
          if ( dword_77048 )
          {
            v12 = *(_DWORD *)dword_77048;
            v13 = ((unsigned __int8)s2 + 17973517 + (HIBYTE(s2) << 24) + (BYTE2(s2) << 16) + (BYTE1(s2) << 8))
                ^ (unsigned int)&unk_7F76D;
            v14 = (-1622558010 - v13) ^ (v13 << 8);
            v15 = (-17973517 - v13 - v14) ^ (v14 >> 13);
            v16 = **(_DWORD ***)dword_77048;
            v17 = (v13 - v14 - v15) ^ (v15 >> 12);
            v18 = (v14 - v15 - v17) ^ (v17 << 16);
            v19 = (v15 - v17 - v18) ^ (v18 >> 5);
            v20 = (v17 - v18 - v19) ^ (v19 >> 3);
            v21 = (v19 - v20 - ((v18 - v19 - v20) ^ (v20 << 10))) ^ (((v18 - v19 - v20) ^ (v20 << 10)) >> 15);
            v22 = 3 * (v21 & (*(_DWORD *)(*(_DWORD *)dword_77048 + 4) - 1));
            v23 = v16[3 * (v21 & (*(_DWORD *)(*(_DWORD *)dword_77048 + 4) - 1))];
            if ( v23 )
              v22 = *(_DWORD *)(v12 + 20);
            else
              v1 = 0;
            if ( v23 )
              v1 = v23 - v22;
            while ( v1 )
            {
              if ( *(_DWORD *)(v1 + 24) == 4 && !memcmp(*(const void **)(v1 + 20), &s2, 4u) )
              {
                v46 = *(_DWORD *)(v1 + 4);
                if ( v46 || *(_DWORD *)(v1 + 8) )
                {
                  v47 = *(_DWORD *)(v12 + 20);
                  v48 = (_DWORD *)(*(_DWORD *)(v12 + 16) - v47);
                  if ( (_DWORD *)v1 == v48 )
                  {
                    *(_DWORD *)(v12 + 16) = v46 + v47;
                    v46 = *(_DWORD *)(v1 + 4);
                  }
                  v49 = v46 == 0;
                  if ( v46 )
                  {
                    v48 = *v11;
                    v47 = *(_DWORD *)(v1 + 8);
                  }
                  else
                  {
                    v46 = *(_DWORD *)(v1 + 8);
                  }
                  if ( v49 )
                  {
                    v11 = (void **)v46;
                    dword_77048 = v46;
                  }
                  else
                  {
                    v46 += v48[5];
                  }
                  if ( !v49 )
                  {
                    *(_DWORD *)(v46 + 8) = v47;
                    v46 = *(_DWORD *)(v1 + 8);
                  }
                  if ( v46 )
                    *(_DWORD *)(v46 + *((_DWORD *)*v11 + 5) + 4) = *(_DWORD *)(v1 + 4);
                  v50 = 3 * ((*((_DWORD *)*v11 + 1) - 1) & *(_DWORD *)(v1 + 28));
                  v51 = *(_DWORD *)*v11 + 12 * ((*((_DWORD *)*v11 + 1) - 1) & *(_DWORD *)(v1 + 28));
                  --*(_DWORD *)(v51 + 4);
                  v52 = *(_DWORD *)*v11;
                  if ( v1 == *(_DWORD *)(v52 + 4 * v50) )
                    *(_DWORD *)(v52 + 4 * v50) = *(_DWORD *)(v1 + 16);
                  v53 = *(_DWORD *)(v1 + 12);
                  if ( v53 )
                    *(_DWORD *)(v53 + 16) = *(_DWORD *)(v1 + 16);
                  v54 = *(_DWORD *)(v1 + 16);
                  if ( v54 )
                    *(_DWORD *)(v54 + 12) = *(_DWORD *)(v1 + 12);
                  --*((_DWORD *)*v11 + 3);
                }
                else
                {
                  free(v16);
                  free(*v11);
                  dword_77048 = 0;
                }
                --a1[189];
                break;
              }
              v24 = *(_DWORD *)(v1 + 16);
              if ( !v24 )
              {
                v1 = 0;
                break;
              }
              v1 = v24 - *(_DWORD *)(v12 + 20);
            }
          }
          else
          {
            v1 = 0;
          }
          if ( pthread_mutex_unlock(&stru_77030) )
            sub_B5C4("parse_stratum_response", 6928);
          off_75ED8();
          if ( v1 )
          {
            v25 = *(_DWORD *)(v1 + 36);
            v26 = time(0);
            if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
            {
              snprintf(
                (char *)v95,
                0x1000u,
                "Pool %d stratum share result lag time %d seconds",
                **(_DWORD **)(v25 + 1748),
                v26 - *(_DWORD *)(v1 + 48));
              sub_38730(7, (const char *)v95, 0);
            }
            v27 = 0;
            v95[0] = bswap32(*(_DWORD *)(v25 + 220));
            v95[1] = bswap32(*(_DWORD *)(v25 + 216));
            v95[2] = bswap32(*(_DWORD *)(v25 + 212));
            v95[3] = bswap32(*(_DWORD *)(v25 + 208));
            v95[4] = bswap32(*(_DWORD *)(v25 + 204));
            v95[5] = bswap32(*(_DWORD *)(v25 + 200));
            v95[6] = bswap32(*(_DWORD *)(v25 + 196));
            v95[7] = bswap32(*(_DWORD *)(v25 + 192));
            do
            {
              if ( *((_BYTE *)v95 + v27) )
                break;
              ++v27;
            }
            while ( v27 != 29 );
            v28 = (double *)(v25 + 1864);
            v29 = *(double *)(v25 + 1864);
            v30 = *(_DWORD *)((char *)v95 + v27);
            round(v96);
            LODWORD(v32) = sub_5CC48(v29);
            HIDWORD(v32) = v31;
            sub_11580(*(_QWORD *)(v25 + 1720), v89, 0x10u, 0);
            v33 = "";
            v34 = bswap32(v30);
            if ( *(_BYTE *)(v25 + 1771) )
              v33 = " BLOCK!";
            snprintf(v90, 0x40u, "%08lx Diff %s/%llu%s", v34, v89, v32, v33);
            v35 = *(_DWORD **)(v25 + 1748);
            v79 = *(_DWORD *)(sub_1B124(*(_DWORD *)(v25 + 1744)) + 36);
            if ( src && (*src == 5 || *(_BYTE *)(v25 + 1812) && *src == 7) )
            {
              if ( pthread_mutex_lock(&stru_7AD4C) )
                sub_B414("share_result", 3481);
              v67 = dbl_7B5E8;
              ++*(_DWORD *)(v79 + 36);
              ++*((_QWORD *)v35 + 1);
              v68 = *(double *)(v79 + 200) + *v28;
              ++qword_7B420;
              *(double *)(v79 + 200) = v68;
              v69 = *v28 + v67;
              *((double *)v35 + 13) = *((double *)v35 + 13) + *v28;
              dbl_7B5E8 = v69;
              if ( pthread_mutex_unlock(&stru_7AD4C) )
                sub_B5C4("share_result", 3488);
              off_75ED8();
              v70 = *v35;
              v35[6] = 0;
              *(_DWORD *)(v79 + 216) = v70;
              v71 = time(0);
              v72 = (unsigned __int8)byte_78E09;
              *(_DWORD *)(v79 + 220) = v71;
              *(double *)(v79 + 224) = *v28;
              v35[96] = v71;
              *((double *)v35 + 49) = *v28;
              if ( v72 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                strcpy((char *)v95, "PROOF OF WORK RESULT: true (yay!!!)");
                sub_38730(7, (const char *)v95, 0);
              }
              if ( !byte_7BC78 && !byte_7BB18 )
              {
                if ( dword_7B198 <= 1 )
                {
                  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                  {
                    snprintf(
                      (char *)v95,
                      0x1000u,
                      "Accepted %s %s %d %s%s",
                      v90,
                      *(const char **)(*(_DWORD *)(v79 + 4) + 8),
                      *(_DWORD *)(v79 + 8),
                      "",
                      "");
                    sub_38730(7, (const char *)v95, 0);
                  }
                }
                else if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                {
                  snprintf(
                    (char *)v95,
                    0x1000u,
                    "Accepted %s %s %d pool %d %s%s",
                    v90,
                    *(const char **)(*(_DWORD *)(v79 + 4) + 8),
                    *(_DWORD *)(v79 + 8),
                    **(_DWORD **)(v25 + 1748),
                    "",
                    "");
                  sub_38730(7, (const char *)v95, 0);
                }
              }
              sub_1B600("accept", (_DWORD *)v25);
              if ( dword_77288 && (double)dword_77288 <= dbl_7B5E8 )
              {
                if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
                {
                  snprintf(
                    (char *)v95,
                    0x1000u,
                    "Successfully mined %d accepted shares as requested and exiting.",
                    dword_77288);
                  sub_38730(4, (const char *)v95, 0);
                }
                sub_178F8();
              }
              if ( v35[33] == 2 )
              {
                if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3
                  || (snprintf((char *)v95, 0x1000u, "Rejecting pool %d now accepting shares, re-enabling!", *v35),
                      sub_38730(4, (const char *)v95, 0),
                      v35[33] != 1) )
                {
                  v35[33] = 1;
                  ++dword_7B5E4;
                }
                sub_19BF8(0);
              }
              if ( *(_BYTE *)(v25 + 1771) )
                sub_17210();
            }
            else
            {
              if ( pthread_mutex_lock(&stru_7AD4C) )
                sub_B414("share_result", 3531);
              v36 = dbl_7B670;
              ++*(_DWORD *)(v79 + 40);
              ++*((_QWORD *)v35 + 2);
              v37 = *(double *)(v79 + 208) + *v28;
              ++qword_7B6F8;
              *(double *)(v79 + 208) = v37;
              v38 = *v28;
              v39 = *((double *)v35 + 14) + *v28;
              ++v35[6];
              *((double *)v35 + 14) = v39;
              dbl_7B670 = v38 + v36;
              if ( pthread_mutex_unlock(&stru_7AD4C) )
                sub_B5C4("share_result", 3539);
              off_75ED8();
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                strcpy((char *)v95, "PROOF OF WORK RESULT: false (booooo)");
                sub_38730(7, (const char *)v95, 0);
              }
              if ( !byte_7BC78 && !byte_7BB18 )
              {
                strcpy(v89, "reject");
                memset(&v89[7], (unsigned __int8)byte_7BB18, 0x1Du);
                v87[0] = byte_7BB18;
                if ( dword_7B198 <= 1 )
                  v86[0] = byte_7BB18;
                else
                  snprintf(v86, 0x14u, "pool %d", **(_DWORD **)(v25 + 1748));
                if ( !*(_BYTE *)(v25 + 1812) )
                  src = (_DWORD *)sub_59E20(v78, "reject-reason");
                if ( src )
                {
                  srca = (const char *)sub_5A178(src);
                  v40 = strlen(srca);
                  qmemcpy(v87, " (", sizeof(v87));
                  if ( v40 >= 0x1C )
                    v41 = 28;
                  else
                    v41 = v40;
                  v42 = &v96[v41];
                  n = v41;
                  memcpy(dest, srca, v41);
                  *((_WORD *)v42 - 2303) = 41;
                  memcpy(&v89[7], srca, n);
                  v89[6] = 58;
                  *(v42 - 4569) = 0;
                }
                else if ( *(_BYTE *)(v25 + 1772) && v82 )
                {
                  if ( *v82 == 1 )
                  {
                    v73 = sub_5A008(v82, 1u);
                    if ( !v73 || *v73 != 2 )
                      goto LABEL_76;
                  }
                  else
                  {
                    if ( *v82 != 2 )
                      goto LABEL_76;
                    v73 = v82;
                  }
                  v74 = (const char *)sub_5A178(v73);
                  snprintf(v87, 0x1Fu, " (%s)", v74);
                }
LABEL_76:
                if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                {
                  snprintf(
                    (char *)v95,
                    0x1000u,
                    "Rejected %s %s %d %s%s %s%s",
                    v90,
                    *(const char **)(*(_DWORD *)(v79 + 4) + 8),
                    *(_DWORD *)(v79 + 8),
                    v86,
                    v87,
                    "",
                    "");
                  sub_38730(7, (const char *)v95, 0);
                }
                sub_1B600(v89, (_DWORD *)v25);
              }
              v43 = v35[6];
              if ( v43 > 10 && !*(_BYTE *)(v25 + 1769) )
              {
                if ( byte_7B250 )
                {
                  if ( dword_7B5E4 > 1 )
                  {
                    LODWORD(v44) = sub_5CB64(qword_7B420);
                    if ( (double)v43 > v44 / dbl_755F8 * 60.0 * 3.0 )
                    {
                      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
                      {
                        snprintf((char *)v95, 0x1000u, "Pool %d rejected %d sequential shares, disabling!", *v35, v43);
                        sub_38730(4, (const char *)v95, 0);
                      }
                      if ( v35[33] == 1 )
                        --dword_7B5E4;
                      v35[33] = 2;
                      if ( v35 == (_DWORD *)sub_1DA58() )
                        sub_19BF8(0);
                      v35[6] = 0;
                    }
                  }
                }
              }
            }
            v45 = 1;
            sub_15780(*(void ***)(v1 + 36));
            *(_DWORD *)(v1 + 36) = 0;
            free((void *)v1);
          }
          else if ( src )
          {
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
              sub_B414("parse_stratum_response", 6938);
            if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 67)) )
              sub_B69C("parse_stratum_response", 6938);
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
              sub_B5C4("parse_stratum_response", 6938);
            v64 = *((double *)a1 + 230);
            if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
              sub_B630("parse_stratum_response", 6940);
            off_75ED8();
            if ( *src == 5 )
            {
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                snprintf((char *)v95, 0x1000u, "Accepted untracked stratum share from pool %d", *a1);
                sub_38730(7, (const char *)v95, 0);
              }
              if ( pthread_mutex_lock(&stru_7AD4C) )
                sub_B414("parse_stratum_response", 6948);
              v75 = *((double *)a1 + 13) + v64;
              v76 = dbl_7B5E8;
              ++*((_QWORD *)a1 + 1);
              ++qword_7B420;
              *((double *)a1 + 13) = v75;
              dbl_7B5E8 = v64 + v76;
              if ( pthread_mutex_unlock(&stru_7AD4C) )
                sub_B5C4("parse_stratum_response", 6953);
            }
            else
            {
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                snprintf((char *)v95, 0x1000u, "Rejected untracked stratum share from pool %d", *a1);
                sub_38730(7, (const char *)v95, 0);
              }
              if ( pthread_mutex_lock(&stru_7AD4C) )
                sub_B414("parse_stratum_response", 6959);
              v65 = *((double *)a1 + 14) + v64;
              v66 = dbl_7B670;
              ++*((_QWORD *)a1 + 2);
              ++qword_7B6F8;
              *((double *)a1 + 14) = v65;
              dbl_7B670 = v64 + v66;
              if ( pthread_mutex_unlock(&stru_7AD4C) )
                sub_B5C4("parse_stratum_response", 6964);
            }
            v45 = 0;
            off_75ED8();
          }
          else
          {
            v45 = 0;
          }
        }
        v61 = v78[1];
        if ( v61 != -1 )
        {
          v62 = v61 - 1;
          v78[1] = v62;
          if ( !v62 )
            sub_5A3E4((void **)v78);
        }
        if ( v45 )
        {
LABEL_10:
          if ( *((_BYTE *)a1 + 696) )
          {
            v55 = sub_1A3D4();
            *((_BYTE *)a1 + 696) = 0;
            v56 = (int)v55;
            sub_1ACC4((int)a1, (int)v55);
            *(_BYTE *)(v56 + 1768) = 1;
            sub_1DB0C(v56);
            sub_15780((void **)v56);
          }
          goto LABEL_12;
        }
        v63 = (unsigned __int8)byte_78E09;
        goto LABEL_156;
      }
      if ( !byte_78E09 )
        goto LABEL_12;
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_157;
      snprintf((char *)v95, 0x1000u, "JSON decode failed(%d): %s", v93[0], v94);
      sub_38730(7, (const char *)v95, 0);
      v63 = (unsigned __int8)byte_78E09;
LABEL_156:
      if ( !v63 )
        goto LABEL_12;
LABEL_157:
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
      {
        snprintf((char *)v95, 0x1000u, "Unknown stratum msg: %s", (const char *)v7);
        sub_38730(7, (const char *)v95, 0);
      }
LABEL_12:
      free(v7);
    }
    else
    {
      if ( !byte_78E09 )
        goto LABEL_126;
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
      {
LABEL_122:
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
        {
          snprintf((char *)v95, 0x1000u, "Stratum connection to pool %d interrupted", *a1);
          sub_38730(7, (const char *)v95, 0);
        }
        goto LABEL_126;
      }
      snprintf((char *)v95, 0x1000u, "Stratum select failed on pool %d with value %d", *a1, v6);
      sub_38730(7, (const char *)v95, 0);
      v57 = (unsigned __int8)byte_78E09;
LABEL_121:
      if ( v57 )
        goto LABEL_122;
LABEL_126:
      v58 = dword_7B43C;
      ++a1[40];
      dword_7B43C = v58 + 1;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
        sub_B414("supports_resume", 7101);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B69C("supports_resume", 7101);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
        sub_B5C4("supports_resume", 7101);
      v59 = a1[165];
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B630("supports_resume", 7103);
      off_75ED8();
      if ( !v59 || byte_7B644 )
        sub_182F4((int)a1);
      sub_185C8(a1);
      if ( a1 == (_DWORD *)sub_1DA58() )
        sub_17210();
      while ( !sub_2CEC8((int)a1) )
      {
        if ( *((_BYTE *)a1 + 137) )
          return 0;
        sub_2A92C();
      }
    }
  }
  sub_2AEE0((int)a1);
  return 0;
}
// 204E4: variable 'v1' is possibly undefined
// 2067C: variable 'v31' is possibly undefined
// 20A4C: variable 'v44' is possibly undefined
// ADD8: using guessed type int __fastcall round(_DWORD);
// 755F8: using guessed type double dbl_755F8;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76EFC: using guessed type int dword_76EFC;
// 77048: using guessed type int dword_77048;
// 77288: using guessed type int dword_77288;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B198: using guessed type int dword_7B198;
// 7B250: using guessed type char byte_7B250;
// 7B420: using guessed type __int64 qword_7B420;
// 7B43C: using guessed type int dword_7B43C;
// 7B5E4: using guessed type int dword_7B5E4;
// 7B5E8: using guessed type double dbl_7B5E8;
// 7B644: using guessed type char byte_7B644;
// 7B670: using guessed type double dbl_7B670;
// 7B6F8: using guessed type __int64 qword_7B6F8;
// 7BB18: using guessed type char byte_7BB18;
// 7BC78: using guessed type char byte_7BC78;

//----- (00021850) --------------------------------------------------------
void __noreturn sub_21850()
{
  int v0; // r2
  int v1; // r6
  int v2; // r4
  __int64 v3; // r10
  double v4; // r0
  double v5; // d16
  double v6; // d16
  int v7; // r5
  _DWORD *v8; // r3
  _DWORD *v9; // r2
  int v10; // r5
  int v11; // r3
  int v12; // r10
  int v13; // r12
  int v14; // r6
  int v15; // r3
  _DWORD *v16; // r3
  int v17; // lr
  int v18; // r3
  const char *v19; // r10
  int v20; // r11
  int v21; // r10
  int v22; // r3
  int v23; // r5
  int v24; // r6
  int v25; // r4
  int v26; // r1
  int **v27; // r3
  int v28; // r0
  int *v29; // r12
  bool v30; // zf
  int v31; // r1
  int v32; // r0
  int v33; // r0
  int v34; // r1
  int v35; // r1
  int v36; // r3
  __int64 v37; // r2
  int v38; // [sp+10h] [bp-1024h]
  void **v39; // [sp+10h] [bp-1024h]
  int v40; // [sp+14h] [bp-1020h]
  pthread_mutex_t *mutex; // [sp+18h] [bp-101Ch]
  pthread_mutex_t *mutexa; // [sp+18h] [bp-101Ch]
  int v43; // [sp+1Ch] [bp-1018h]
  struct timeval v44; // [sp+20h] [bp-1014h] BYREF
  struct timeval v45; // [sp+28h] [bp-100Ch] BYREF
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2F0B4("Watchpool");
  sub_120F4();
  v40 = 0;
  while ( 1 )
  {
    sub_2A84C(&v44);
    v0 = v40 + 1;
    if ( v40 + 1 > 20 )
      v0 = 0;
    v40 = v0;
    if ( dword_7B198 > 0 )
    {
      v1 = 0;
      while ( 1 )
      {
        v2 = *(_DWORD *)(dword_7B438 + 4 * v1);
        if ( byte_7730D || dword_76FFC )
          goto LABEL_11;
        mutex = (pthread_mutex_t *)(v2 + 220);
        sub_2A84C(&v45);
        if ( pthread_mutex_lock((pthread_mutex_t *)(v2 + 220)) )
          sub_B414("reap_curl", 9503);
        v8 = *(_DWORD **)(v2 + 376);
        v9 = v8 - 1;
        v10 = *v8 - 4;
        if ( (_DWORD *)(v2 + 376) == v8 )
        {
          v12 = 0;
          if ( pthread_mutex_unlock(mutex) )
            goto LABEL_95;
        }
        else
        {
          v11 = *(_DWORD *)(v2 + 320);
          v12 = 0;
          if ( v11 > 1 )
          {
            v13 = 0;
            v43 = v1;
            v14 = 0;
            do
            {
              if ( v45.tv_sec - v9[3] > 300 )
              {
                *(_DWORD *)(v2 + 320) = v11 - 1;
                v16 = (_DWORD *)v9[2];
                v17 = v9[1];
                ++v14;
                *(_DWORD *)(v17 + 4) = v16;
                *v16 = v17;
                v9[1] = v13;
                v9[2] = v13;
                v38 = v13;
                free(v9);
                v13 = v38;
              }
              v9 = (_DWORD *)v10;
              v15 = v10 + 4;
              v10 = *(_DWORD *)(v10 + 4) - 4;
              if ( v2 + 376 == v15 )
                break;
              v11 = *(_DWORD *)(v2 + 320);
            }
            while ( v11 > 1 );
            v12 = v14;
            v1 = v43;
          }
          if ( pthread_mutex_unlock(mutex) )
LABEL_95:
            sub_B5C4("reap_curl", 9517);
        }
        off_75ED8();
        if ( v12 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          v18 = v12;
          if ( v12 == 1 )
            v19 = "";
          else
            v19 = "s";
          snprintf(s, 0x1000u, "Reaped %d curl%s from pool %d", v18, v19, *(_DWORD *)v2);
          sub_38730(7, s, 0);
        }
        mutexa = (pthread_mutex_t *)time(0);
        if ( pthread_mutex_lock(&stru_77030) )
          sub_B414("prune_stratum_shares", 9532);
        v20 = dword_77048;
        if ( !dword_77048 )
        {
          v21 = 0;
          goto LABEL_81;
        }
        v22 = v1;
        v23 = *(_DWORD *)(dword_77048 + 8);
        v24 = v2;
        v21 = 0;
        v25 = v22;
        while ( v24 != *(_DWORD *)(*(_DWORD *)(v20 + 36) + 1748) || (int)mutexa <= *(_DWORD *)(v20 + 44) + 120 )
        {
          if ( !v23 )
            goto LABEL_80;
LABEL_56:
          v20 = v23;
          v23 = *(_DWORD *)(v23 + 8);
        }
        v26 = *(_DWORD *)(v20 + 4);
        if ( v26 || *(_DWORD *)(v20 + 8) )
        {
          v27 = (int **)dword_77048;
          v28 = *(_DWORD *)dword_77048;
          v29 = *(int **)(*(_DWORD *)dword_77048 + 20);
          if ( v20 == *(_DWORD *)(*(_DWORD *)dword_77048 + 16) - (_DWORD)v29 )
          {
            *(_DWORD *)(v28 + 16) = (char *)v29 + v26;
            v26 = *(_DWORD *)(v20 + 4);
          }
          v30 = v26 == 0;
          if ( v26 )
          {
            v29 = *v27;
            v28 = *(_DWORD *)(v20 + 8);
          }
          else
          {
            v26 = *(_DWORD *)(v20 + 8);
          }
          if ( v30 )
          {
            v27 = (int **)v26;
            dword_77048 = v26;
          }
          else
          {
            v26 += v29[5];
          }
          if ( !v30 )
          {
            *(_DWORD *)(v26 + 8) = v28;
            v26 = *(_DWORD *)(v20 + 8);
          }
          if ( v26 )
            *(_DWORD *)(v26 + (*v27)[5] + 4) = *(_DWORD *)(v20 + 4);
          v31 = 3 * (((*v27)[1] - 1) & *(_DWORD *)(v20 + 28));
          v32 = **v27 + 12 * (((*v27)[1] - 1) & *(_DWORD *)(v20 + 28));
          --*(_DWORD *)(v32 + 4);
          v33 = **v27;
          if ( v20 == *(_DWORD *)(v33 + 4 * v31) )
            *(_DWORD *)(v33 + 4 * v31) = *(_DWORD *)(v20 + 16);
          v34 = *(_DWORD *)(v20 + 12);
          if ( v34 )
            *(_DWORD *)(v34 + 16) = *(_DWORD *)(v20 + 16);
          v35 = *(_DWORD *)(v20 + 16);
          if ( v35 )
            *(_DWORD *)(v35 + 12) = *(_DWORD *)(v20 + 12);
          --(*v27)[3];
        }
        else
        {
          v39 = (void **)dword_77048;
          free(**(void ***)dword_77048);
          free(*v39);
          dword_77048 = 0;
        }
        ++v21;
        sub_15780(*(void ***)(v20 + 36));
        *(_DWORD *)(v20 + 36) = 0;
        free((void *)v20);
        if ( v23 )
          goto LABEL_56;
LABEL_80:
        v36 = v25;
        v2 = v24;
        v1 = v36;
LABEL_81:
        if ( pthread_mutex_unlock(&stru_77030) )
          sub_B5C4("prune_stratum_shares", 9543);
        off_75ED8();
        if ( v21 )
        {
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, "Lost %d shares due to no stratum share response from pool %d", v21, *(_DWORD *)v2);
            sub_38730(4, s, 0);
          }
          v37 = *(_QWORD *)&dword_7BC80;
          *(_DWORD *)(v2 + 152) += v21;
          *(_QWORD *)&dword_7BC80 = v37 + v21;
        }
LABEL_11:
        if ( v40 == 20 )
        {
          v3 = *(_QWORD *)(v2 + 40);
          LODWORD(v4) = sub_5CB64(v3 - *(int *)(v2 + 184));
          v5 = *(double *)(v2 + 176);
          *(_DWORD *)(v2 + 184) = v3;
          v6 = (v5 + v4 * 0.63) / 1.63;
          *(double *)(v2 + 176) = v6;
          *(_DWORD *)(v2 + 188) = (int)v6;
        }
        if ( !*(_DWORD *)(v2 + 132) || *(_BYTE *)(v2 + 316) )
          goto LABEL_8;
        if ( !*(_BYTE *)(v2 + 129) )
        {
LABEL_7:
          if ( !dword_76EFC )
          {
            v7 = *(_DWORD *)(v2 + 4);
            if ( v7 < sub_1FB7C() && v44.tv_sec - *(_DWORD *)(v2 + 168) > 300 )
            {
              if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
              {
                snprintf(s, 0x1000u, "Pool %d %s stable for 5 mins", *(_DWORD *)v2, *(const char **)(v2 + 196));
                sub_38730(4, s, 0);
              }
              sub_19BF8(0);
            }
          }
          goto LABEL_8;
        }
        if ( v44.tv_sec - *(_DWORD *)(v2 + 168) <= 30 )
        {
LABEL_8:
          if ( dword_7B198 <= ++v1 )
            break;
        }
        else
        {
          if ( sub_18CA0((_DWORD *)v2, 1) && sub_18C2C(v2, (_BYTE *)(v2 + 129)) )
            sub_1FC34((_DWORD *)v2);
          else
            sub_2A84C((struct timeval *)(v2 + 168));
          if ( !*(_BYTE *)(v2 + 129) )
            goto LABEL_7;
          if ( dword_7B198 <= ++v1 )
            break;
        }
      }
    }
    if ( *(_BYTE *)(sub_1DA58() + 129) )
    {
      sub_19BF8(0);
      if ( dword_76EFC != 2 )
        goto LABEL_24;
    }
    else if ( dword_76EFC != 2 )
    {
      goto LABEL_24;
    }
    if ( v44.tv_sec - dword_77310 > 60 * dword_7B558 )
    {
      sub_2A84C((struct timeval *)&dword_77310);
      sub_19BF8(0);
    }
LABEL_24:
    sub_2A92C();
  }
}
// 21944: variable 'v4' is possibly undefined
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76EFC: using guessed type int dword_76EFC;
// 76FFC: using guessed type int dword_76FFC;
// 77048: using guessed type int dword_77048;
// 7730D: using guessed type char byte_7730D;
// 77310: using guessed type int dword_77310;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;
// 7B558: using guessed type int dword_7B558;
// 7BC80: using guessed type int dword_7BC80;

//----- (00021FE8) --------------------------------------------------------
void *__fastcall sub_21FE8(_DWORD *a1)
{
  pthread_t v1; // r0
  char *v2; // r0
  const char **v3; // r5
  int **v4; // r4
  time_t v5; // r0
  _BYTE *v6; // r7
  char *v7; // r6
  int v8; // r3
  size_t v9; // r0
  int *v10; // r6
  size_t v11; // r0
  int **v12; // r5
  int *v13; // r6
  unsigned int v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r0
  int v17; // r1
  unsigned int v18; // r2
  unsigned int v19; // r3
  unsigned int v20; // r1
  unsigned int v21; // r3
  int v22; // r2
  int v23; // r3
  int *v24; // r1
  int v25; // r1
  int ***v26; // r0
  int v27; // r2
  int *v28; // r5
  size_t v29; // r6
  _DWORD *v30; // r0
  _DWORD *v31; // r7
  int v32; // r8
  void **v33; // r3
  void *v34; // r6
  void ***v35; // r11
  _DWORD *v36; // r5
  void *v37; // r4
  _DWORD *v38; // r9
  int v39; // r4
  char *v40; // r6
  unsigned int v41; // r2
  int v42; // r3
  int *v43; // r3
  unsigned int v44; // r1
  unsigned int v45; // r2
  bool v46; // cc
  int v47; // r2
  time_t v48; // r0
  int v49; // r3
  int *v50; // r2
  int *v52; // r0
  void *v53; // r0
  const char *v54; // r1
  _BOOL4 v55; // r7
  int v56; // r3
  unsigned int i; // [sp+1Ch] [bp-2020h]
  char s[16]; // [sp+28h] [bp-2014h] BYREF
  char v60[4096]; // [sp+38h] [bp-2004h] BYREF
  char v61[4100]; // [sp+1038h] [bp-1004h] BYREF

  v1 = pthread_self();
  pthread_detach(v1);
  snprintf(s, 0x10u, "%d/SStratum", *a1);
  sub_2F0B4(s);
  v2 = sub_2A168();
  a1[188] = v2;
  if ( !v2 )
  {
    strcpy(v61, "Failed to create stratum_q in stratum_sthread");
    sub_38730(3, v61, 1);
    sub_16CA8(1);
  }
  memset(v60, 0, sizeof(v60));
  if ( *((_BYTE *)a1 + 137) )
    goto LABEL_56;
  do
  {
    v3 = (const char **)sub_2A300(a1[188], 0);
    if ( !v3 )
    {
      strcpy(v61, "Stratum q returned empty work");
      sub_38730(3, v61, 1);
      sub_16CA8(1);
    }
    v4 = (int **)calloc(0x34u, 1u);
    if ( !v4 )
    {
      snprintf(v61, 0x1000u, "%s: calloc() failed on sshare.", "stratum_sthread");
      sub_38730(3, v61, 1);
      sub_16CA8(1);
    }
    v5 = time(0);
    v4[9] = (int *)v3;
    v4[11] = (int *)v5;
    v6 = sub_29730((int)(v3 + 83), 32);
    v7 = sub_29730((int)(v3 + 91), 1347);
    if ( pthread_mutex_lock(&stru_77030) )
      sub_B414("stratum_sthread", 7288);
    v8 = dword_7B0F8++;
    v4[10] = (int *)v8;
    if ( pthread_mutex_unlock(&stru_77030) )
      sub_B5C4("stratum_sthread", 7291);
    off_75ED8();
    v9 = strlen(v3[452]);
    snprintf(
      v60,
      0x1000u,
      "{\"id\": %d, \"method\": \"mining.submit\", \"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"]}",
      v4[10],
      (const char *)a1[51],
      v3[444],
      v3[449],
      &v6[v9],
      v7);
    free(v6);
    free(v7);
    while ( 1 )
    {
      v10 = v4[11];
      if ( (int)v10 + 119 < time(0) )
        goto LABEL_50;
      v11 = strlen(v60);
      if ( sub_2B5C8((int)a1, v60, v11) )
      {
        if ( pthread_mutex_lock(&stru_77030) )
          sub_B414("stratum_sthread", 7306);
        v4[2] = 0;
        v4[5] = (int *)(v4 + 10);
        v12 = (int **)dword_77048;
        v4[6] = (int *)4;
        if ( v12 )
        {
          *(_DWORD *)((*v12)[4] + 8) = v4;
          v4[1] = (int *)((*v12)[4] - (*v12)[5]);
          (*v12)[4] = (int)v4;
          v13 = *v12;
        }
        else
        {
          v4[1] = 0;
          dword_77048 = (int)v4;
          v52 = (int *)malloc(0x2Cu);
          v13 = v52;
          *v4 = v52;
          if ( !v52 )
            goto LABEL_62;
          *v52 = 0;
          v52[3] = 0;
          v52[4] = 0;
          v52[5] = 0;
          v52[6] = 0;
          v52[7] = 0;
          v52[8] = 0;
          v52[9] = 0;
          v52[10] = 0;
          v52[4] = (int)v4;
          v52[5] = 0;
          v52[1] = 32;
          v52[2] = 5;
          v53 = malloc(0x180u);
          *v13 = (int)v53;
          if ( !v53 )
            goto LABEL_62;
          memset(v53, 0, 0x180u);
          v12 = v4;
          v13[10] = -1609490463;
        }
        ++v13[3];
        v14 = (*((unsigned __int8 *)v4 + 40)
             + 17973517
             + (*((unsigned __int8 *)v4 + 43) << 24)
             + (*((unsigned __int8 *)v4 + 42) << 16)
             + (*((unsigned __int8 *)v4 + 41) << 8))
            ^ (unsigned int)&unk_7F76D;
        v15 = (-1622558010 - v14) ^ (v14 << 8);
        *v4 = *v12;
        v16 = (-17973517 - v14 - v15) ^ (v15 >> 13);
        v17 = (v14 - v15 - v16) ^ (v16 >> 12);
        v18 = (v15 - v16 - v17) ^ (v17 << 16);
        v19 = (v16 - v17 - v18) ^ (v18 >> 5);
        v20 = v17 - v18 - v19;
        v21 = (v19 - (v20 ^ (v19 >> 3)) - ((v18 - v19 - (v20 ^ (v19 >> 3))) ^ ((v20 ^ (v19 >> 3)) << 10)))
            ^ (((v18 - v19 - (v20 ^ (v19 >> 3))) ^ ((v20 ^ (v19 >> 3)) << 10)) >> 15);
        v4[7] = (int *)v21;
        v22 = 3 * (v21 & ((*v12)[1] - 1));
        v23 = 12 * (v21 & ((*v12)[1] - 1));
        ++*(_DWORD *)(**v12 + v23 + 4);
        v24 = *(int **)(**v12 + 4 * v22);
        v4[3] = 0;
        v4[4] = v24;
        v25 = **v12;
        v26 = (int ***)(v25 + v23);
        v27 = *(_DWORD *)(v25 + 4 * v22);
        if ( v27 )
        {
          *(_DWORD *)(v27 + 12) = v4;
          v26 = (int ***)(**v12 + v23);
        }
        *v26 = v4;
        if ( *(_DWORD *)(**v12 + v23 + 4) < (unsigned int)(10 * (*(_DWORD *)(**v12 + v23 + 8) + 1)) )
          goto LABEL_39;
        v28 = *v4;
        if ( (*v4)[9] == 1 )
          goto LABEL_39;
        v29 = 24 * v28[1];
        v30 = malloc(v29);
        v31 = v30;
        if ( v30 )
        {
          memset(v30, 0, v29);
          v32 = 0;
          v28[6] = (((2 * v28[1] - 1) & v28[3]) != 0) + ((unsigned int)v28[3] >> (*((_BYTE *)v28 + 8) + 1));
          (*v4)[7] = 0;
          v33 = (void **)*v4;
          v34 = (void *)(*v4)[1];
          if ( v34 )
          {
            v35 = (void ***)v4;
            for ( i = 0; i < (unsigned int)v34; ++i )
            {
              v36 = *(_DWORD **)((char *)*v33 + v32);
              if ( v36 )
              {
                v37 = v34;
                while ( 1 )
                {
                  v38 = (_DWORD *)v36[4];
                  v39 = 3 * ((2 * (_DWORD)v37 - 1) & v36[7]);
                  v40 = (char *)&v31[v39];
                  v41 = *((_DWORD *)v40 + 1) + 1;
                  *((_DWORD *)v40 + 1) = v41;
                  if ( v41 > (unsigned int)v33[6] )
                  {
                    v33[7] = (char *)v33[7] + 1;
                    *((_DWORD *)v40 + 2) = *((_DWORD *)v40 + 1) / (unsigned int)(*v35)[6];
                  }
                  v36[3] = 0;
                  v36[4] = v31[v39];
                  v42 = v31[v39];
                  if ( v42 )
                    *(_DWORD *)(v42 + 12) = v36;
                  v31[v39] = v36;
                  v33 = *v35;
                  if ( !v38 )
                    break;
                  v37 = v33[1];
                  v36 = v38;
                }
                v34 = v33[1];
              }
              v32 += 12;
            }
            v4 = (int **)v35;
          }
          free(*v33);
          (*v4)[1] *= 2;
          ++(*v4)[2];
          **v4 = (int)v31;
          v43 = *v4;
          v44 = (*v4)[3];
          v45 = (*v4)[7];
          v46 = v45 > v44 >> 1;
          if ( v45 <= v44 >> 1 )
            v47 = 0;
          else
            v47 = v43[8];
          if ( v46 )
            ++v47;
          v43[8] = v47;
          if ( (unsigned int)(*v4)[8] > 1 )
            (*v4)[9] = 1;
LABEL_39:
          ++a1[189];
          if ( pthread_mutex_unlock(&stru_77030) )
            sub_B5C4("stratum_sthread", 7309);
          off_75ED8();
          if ( sub_18C2C((int)a1, (_BYTE *)a1 + 128) && (byte_7AD48 || byte_78E08 || dword_766C4 > 3) )
          {
            snprintf(v61, 0x1000u, "Pool %d communication resumed, submitting work", *a1);
            sub_38730(4, v61, 0);
          }
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            strcpy(v61, "Successfully submitted, adding to stratum_shares db");
            sub_38730(7, v61, 0);
          }
          goto LABEL_50;
        }
LABEL_62:
        exit(-1);
      }
      if ( !sub_18834((int)a1, (_BYTE *)a1 + 128) && sub_1FFEC((int)a1) )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(v61, 0x1000u, "Pool %d stratum share submission failure", *a1);
          sub_38730(4, v61, 0);
        }
        v56 = a1[41];
        ++dword_7AE68;
        a1[41] = v56 + 1;
      }
      if ( byte_7B644 )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
        sub_B414("stratum_sthread", 7330);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B69C("stratum_sthread", 7330);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
        sub_B5C4("stratum_sthread", 7330);
      v54 = (const char *)a1[159];
      if ( v54 )
        v55 = strcmp(v3[452], v54) == 0;
      else
        v55 = 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B630("stratum_sthread", 7332);
      off_75ED8();
      if ( !v55 )
      {
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          strcpy(v61, "No matching session id for resubmitting stratum share");
          sub_38730(7, v61, 0);
        }
        goto LABEL_50;
      }
      sleep(5u);
    }
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v61, "Lowmem option prevents resubmitting stratum share");
      sub_38730(7, v61, 0);
    }
LABEL_50:
    v48 = time(0);
    v49 = (unsigned __int8)byte_78E09;
    v50 = v4[11];
    v4[12] = (int *)v48;
    if ( v49 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v61, 0x1000u, "Pool %d stratum share submission lag time %d seconds", *a1, v48 - (_DWORD)v50);
      sub_38730(7, v61, 0);
    }
    memset(v60, 0, sizeof(v60));
  }
  while ( !*((_BYTE *)a1 + 137) );
LABEL_56:
  sub_2A230(a1[188]);
  return 0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 77048: using guessed type int dword_77048;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7AE68: using guessed type int dword_7AE68;
// 7B0F8: using guessed type int dword_7B0F8;
// 7B644: using guessed type char byte_7B644;

//----- (00022B44) --------------------------------------------------------
int __fastcall sub_22B44(int a1, int a2)
{
  int v5; // r7
  int v6; // r8
  int v7; // r7
  const char *v8; // lr
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // lr
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r9
  struct timeval v21; // [sp+0h] [bp-1008h] BYREF
  _DWORD v22[10]; // [sp+8h] [bp-1000h] BYREF
  __int16 v23; // [sp+30h] [bp-FD8h]

  if ( byte_7730D || dword_76FFC )
    return 0;
  if ( *(_DWORD *)(a1 + 1824) != dword_770AC )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy((char *)v22, "Work stale due to block mismatch");
      sub_38730(7, (const char *)v22, 0);
      return 1;
    }
    return 1;
  }
  v5 = *(_DWORD *)(a1 + 1764);
  v6 = *(_DWORD *)(a1 + 1748);
  if ( v5 <= dword_75DF0 )
    v5 = dword_75DF4;
  if ( !a2 && *(_BYTE *)(v6 + 664) )
  {
    if ( !*(_BYTE *)(v6 + 665) || !*(_BYTE *)(v6 + 667) )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy((char *)v22, "Work stale due to stratum inactive");
        sub_38730(7, (const char *)v22, 0);
        return 1;
      }
      return 1;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(v6 + 244)) )
      sub_B414("stale_work", 4935);
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 268)) )
      sub_B69C("stale_work", 4935);
    if ( pthread_mutex_unlock((pthread_mutex_t *)(v6 + 244)) )
      sub_B5C4("stale_work", 4935);
    v20 = strcmp(*(const char **)(a1 + 1776), *(const char **)(v6 + 672));
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 268)) )
      sub_B630("stale_work", 4938);
    off_75ED8();
    if ( v20 )
    {
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        return 1;
      v8 = "Work stale due to stratum job_id mismatch";
LABEL_42:
      v9 = *(_DWORD *)v8;
      v10 = *((_DWORD *)v8 + 1);
      v11 = *((_DWORD *)v8 + 2);
      v12 = *((_DWORD *)v8 + 3);
      v13 = (int *)(v8 + 16);
      v22[0] = v9;
      v22[1] = v10;
      v22[2] = v11;
      v22[3] = v12;
      v14 = *v13;
      v15 = v13[1];
      v16 = v13[2];
      v17 = v13[3];
      v13 += 4;
      v22[4] = v14;
      v22[5] = v15;
      v22[6] = v16;
      v22[7] = v17;
      v18 = v13[1];
      v19 = v13[2];
      v22[8] = *v13;
      v22[9] = v18;
      v23 = v19;
      sub_38730(7, (const char *)v22, 0);
      return 1;
    }
  }
  v7 = v5 - (int)(*(double *)(v6 + 472) * 5.0 + 1.0);
  sub_2A84C(&v21);
  if ( v7 < 5 )
    v7 = 5;
  if ( v21.tv_sec - *(_DWORD *)(a1 + 1752) >= v7 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy((char *)v22, "Work stale due to expiry");
      sub_38730(7, (const char *)v22, 0);
      return 1;
    }
    return 1;
  }
  if ( byte_7B625 && !a2 && v6 != sub_1DA58() && !*(_BYTE *)(a1 + 1770) && dword_76EFC != 3 && dword_76EFC != 4 )
  {
    if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
      return 1;
    v8 = "Work stale due to fail only pool mismatch";
    goto LABEL_42;
  }
  return 0;
}
// 75DF0: using guessed type int dword_75DF0;
// 75DF4: using guessed type int dword_75DF4;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76EFC: using guessed type int dword_76EFC;
// 76FFC: using guessed type int dword_76FFC;
// 770AC: using guessed type int dword_770AC;
// 7730D: using guessed type char byte_7730D;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B625: using guessed type char byte_7B625;

//----- (00022F88) --------------------------------------------------------
void sub_22F88()
{
  _DWORD *v0; // r4
  int v1; // r6
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2
  _DWORD *v5; // r0
  int v6; // r3
  int v7; // r12
  bool v8; // zf
  int v9; // r3
  _DWORD *v10; // r3
  int v11; // r1
  int v12; // r3
  _DWORD *v13; // r12
  int v14; // r3
  int v15; // r3
  char v16[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
    sub_B414("discard_stale", 5214);
  v0 = (_DWORD *)dword_77050;
  if ( dword_77050 )
  {
    v2 = *(_DWORD **)(dword_77050 + 1840);
    v1 = 0;
    while ( 1 )
    {
      if ( sub_22B44((int)v0, 0) )
      {
        v3 = v0[459];
        if ( v3 || v0[460] )
        {
          v4 = dword_77050;
          v5 = v0 + 458;
          v6 = *(_DWORD *)(dword_77050 + 1832);
          v7 = *(_DWORD *)(v6 + 20);
          if ( (_DWORD *)(*(_DWORD *)(v6 + 16) - v7) == v0 )
          {
            *(_DWORD *)(v6 + 16) = v3 + v7;
            v3 = v0[459];
          }
          v8 = v3 == 0;
          if ( v3 )
            v7 = *(_DWORD *)(v4 + 1832);
          v9 = v0[460];
          if ( v3 )
          {
            v3 += *(_DWORD *)(v7 + 20);
          }
          else
          {
            v4 = v0[460];
            dword_77050 = v4;
          }
          if ( !v8 )
          {
            *(_DWORD *)(v3 + 8) = v9;
            v9 = v0[460];
          }
          if ( v9 )
            *(_DWORD *)(v9 + *(_DWORD *)(*(_DWORD *)(v4 + 1832) + 20) + 4) = v0[459];
          v10 = *(_DWORD **)(v4 + 1832);
          v11 = 3 * ((v10[1] - 1) & v0[465]);
          --*(_DWORD *)(*v10 + 4 * v11 + 4);
          v12 = **(_DWORD **)(v4 + 1832);
          v13 = *(_DWORD **)(v12 + 4 * v11);
          if ( v13 == v5 )
          {
            v4 = v0[462];
            *(_DWORD *)(v12 + 4 * v11) = v4;
          }
          v14 = v0[461];
          if ( v13 == v5 )
            v4 = dword_77050;
          if ( v14 )
            *(_DWORD *)(v14 + 16) = v0[462];
          v15 = v0[462];
          if ( v15 )
            *(_DWORD *)(v15 + 12) = v0[461];
          --*(_DWORD *)(*(_DWORD *)(v4 + 1832) + 12);
        }
        else
        {
          free(**(void ***)(dword_77050 + 1832));
          free(*(void **)(dword_77050 + 1832));
          dword_77050 = 0;
        }
        ++v1;
        sub_159B4((int)v0);
      }
      if ( !v2 )
        break;
      v0 = v2;
      v2 = (_DWORD *)v2[460];
    }
  }
  else
  {
    v1 = 0;
  }
  pthread_cond_signal(&stru_7B1A0);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
    sub_B5C4("discard_stale", 5225);
  off_75ED8();
  if ( v1 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v16, 0x1000u, "Discarded %d stales that didn't match current hash", v1);
    sub_38730(7, v16, 0);
  }
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 7704C: using guessed type int dword_7704C;
// 77050: using guessed type int dword_77050;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (000231F0) --------------------------------------------------------
void *__fastcall sub_231F0(void *a1)
{
  int v1; // r4
  pthread_t v2; // r0
  int v3; // r6
  int v4; // r4
  int v5; // r3
  pthread_rwlock_t *v6; // r5

  v1 = sub_1DA58();
  v2 = pthread_self();
  pthread_detach(v2);
  sub_18834(v1, (_BYTE *)(v1 + 130));
  sub_22F88();
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_B69C("restart_thread", 5270);
  v3 = dword_7BB6C;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_B630("restart_thread", 5272);
  off_75ED8();
  if ( v3 > 0 )
  {
    v4 = 0;
    do
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(dword_7B5E0 + 4 * v4++);
        v6 = *(pthread_rwlock_t **)(v5 + 36);
        if ( v6 )
        {
          if ( !v6[1].__lock )
            break;
        }
        if ( v4 == v3 )
          goto LABEL_9;
      }
      *(_BYTE *)(v5 + 62) = 1;
      sub_1AA18(v6);
      (*(void (__fastcall **)(pthread_rwlock_t *))(v6->__nr_readers + 76))(v6);
    }
    while ( v4 != v3 );
  }
LABEL_9:
  if ( pthread_mutex_lock(&stru_7B62C) )
    sub_B414("restart_thread", 5284);
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&stru_7B62C) )
    sub_B5C4("restart_thread", 5286);
  off_75ED8();
  return 0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B5E0: using guessed type int dword_7B5E0;
// 7BB6C: using guessed type int dword_7BB6C;

//----- (00023344) --------------------------------------------------------
void __noreturn sub_23344()
{
  double v0; // d0
  int v1; // r4
  int v2; // r0
  int v3; // r5
  int v4; // r3
  int v5; // r6
  __time_t tv_sec; // r2
  int v7; // r3
  int v8; // r0
  int v9; // r5
  int v10; // r7
  int v11; // r3
  int v12; // r1
  int v13; // r1
  int v14; // r3
  int v15; // r4
  int *v16; // r3
  int v17; // r1
  int v18; // t1
  int v19; // r2
  int v20; // r4
  int v21; // r5
  bool v22; // cc
  int v23; // r1
  int v24; // r1
  int v25; // r3
  int v26; // r2
  bool v27; // zf
  int v28; // r0
  int v29; // r5
  int v30; // r6
  int v31; // r8
  int v32; // r0
  int v33; // r6
  char *v34; // r0
  const char *v35; // r1
  int v36; // r8
  int v37; // r10
  int v38; // r1
  double v39; // d8
  WINDOW *v40; // r0
  __int64 v41; // d11
  const char *v42; // r3
  size_t v43; // r0
  int v44; // r3
  const char *v45; // r3
  int v46; // r3
  double v47; // r0
  double v48; // d11
  unsigned __int64 v49; // r0
  unsigned __int64 v50; // r0
  double v51; // r0
  int v52; // r5
  int v53; // r2
  int v54; // r2
  int v55; // r0
  int v56; // r1
  double v57; // r0
  double v58; // d12
  int v59; // r6
  double v60; // d11
  double v61; // r0
  double v62; // d8
  int v63; // r0
  const char *v64; // r3
  double v65; // r0
  double v66; // r0
  unsigned __int64 v67; // r0
  unsigned __int64 v68; // r0
  double v69; // r0
  double v70; // r0
  double v71; // r0
  double v72; // r0
  double v73; // [sp+0h] [bp-1194h]
  double v74; // [sp+8h] [bp-118Ch]
  int v75; // [sp+10h] [bp-1184h]
  int v76; // [sp+44h] [bp-1150h]
  struct timeval v77; // [sp+5Ch] [bp-1138h] BYREF
  char dest[12]; // [sp+64h] [bp-1130h] BYREF
  char v79[16]; // [sp+70h] [bp-1124h] BYREF
  struct timeval v80[2]; // [sp+80h] [bp-1114h] BYREF
  char s[256]; // [sp+90h] [bp-1104h] BYREF
  _DWORD v82[1020]; // [sp+190h] [bp-1004h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2F0B4("Watchdog");
  sub_120F4();
  sub_2A84C((struct timeval *)&dword_77310);
LABEL_2:
  while ( 1 )
  {
    sleep(2u);
    sub_22F88();
    sub_1BBA4(-1, 0);
    if ( sub_17FE4() )
      break;
LABEL_3:
    sub_2A84C(v80);
    if ( byte_7B194 )
      goto LABEL_181;
    if ( !sub_118D4() )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(
          (char *)v82,
          0x1000u,
          "Pausing execution as per stop time %02d:%02d scheduled",
          dword_7B5FC,
          dword_7B5F8);
        sub_38730(4, (const char *)v82, 0);
      }
      v15 = (unsigned __int8)byte_7B874;
      if ( !byte_7B874 )
      {
        strcpy((char *)v82, "Terminating execution as planned");
        sub_38730(3, (const char *)v82, 1);
        sub_16CA8(v15);
      }
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf((char *)v82, 0x1000u, "Will restart execution as scheduled at %02d:%02d", dword_7B880, dword_7B87C);
        sub_38730(4, (const char *)v82, 0);
      }
      byte_7B194 = 1;
      if ( pthread_rwlock_rdlock(&rwlock) )
        sub_B69C("watchdog_thread", 9721);
      if ( dword_7BB6C > 0 )
      {
        v16 = (int *)dword_7B5E0;
        v17 = dword_7B5E0 + 4 * dword_7BB6C;
        do
        {
          v18 = *v16++;
          *(_BYTE *)(v18 + 60) = 1;
        }
        while ( v16 != (int *)v17 );
      }
      if ( pthread_rwlock_unlock(&rwlock) )
        sub_B630("watchdog_thread", 9724);
      off_75ED8();
      goto LABEL_22;
    }
    if ( byte_7B194 )
    {
LABEL_181:
      if ( sub_118D4() )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(
            (char *)v82,
            0x1000u,
            "Restarting execution as per start time %02d:%02d scheduled",
            dword_7B880,
            dword_7B87C);
          sub_38730(4, (const char *)v82, 0);
        }
        if ( byte_7B5F0 && (byte_7AD48 || byte_78E08 || dword_766C4 > 3) )
        {
          snprintf((char *)v82, 0x1000u, "Will pause execution as scheduled at %02d:%02d", dword_7B5FC, dword_7B5F8);
          sub_38730(4, (const char *)v82, 0);
        }
        v1 = 0;
        byte_7B194 = 0;
        while ( dword_7BB6C > v1 )
        {
          v2 = v1++;
          v3 = sub_1B124(v2);
          if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 32) != 1 )
          {
            v4 = (unsigned __int8)byte_78E09;
            *(_BYTE *)(v3 + 60) = 0;
            if ( v4 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
            {
              snprintf((char *)v82, 0x1000u, "Pushing sem post to thread %d", *(_DWORD *)v3);
              sub_38730(7, (const char *)v82, 0);
            }
            sub_2F1BC((sem_t *)(v3 + 16), "cgminer.c", "watchdog_thread", 9746);
          }
        }
      }
    }
LABEL_22:
    if ( dword_7B720 > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        v8 = sub_1B83C(v5);
        v9 = v8;
        v10 = **(_DWORD **)(v8 + 152);
        if ( !v10 )
          goto LABEL_35;
        (*(void (**)(void))(*(_DWORD *)(v8 + 4) + 32))();
        snprintf(s, 8u, "%s %d", *(const char **)(*(_DWORD *)(v9 + 4) + 8), *(_DWORD *)(v9 + 8));
        if ( *(_BYTE *)(v10 + 61) || *(_DWORD *)(v9 + 32) == 1 )
          goto LABEL_35;
        v11 = *(_DWORD *)(v9 + 96);
        v12 = *(_DWORD *)(v10 + 44);
        if ( v11 )
          break;
        tv_sec = v80[0].tv_sec;
        if ( v80[0].tv_sec - v12 <= 120 )
          goto LABEL_48;
        *(_QWORD *)(v9 + 48) = 0;
        v7 = (unsigned __int8)byte_7AD48;
        *(_DWORD *)(v9 + 96) = 1;
        if ( v7 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf((char *)v82, 0x1000u, "%s: Idle for more than 60 seconds, declaring SICK!", s);
          sub_38730(3, (const char *)v82, 0);
        }
        sub_2A84C((struct timeval *)(v10 + 52));
        sub_2ED88((_DWORD *)v9, 3);
        if ( !byte_75E0C )
          goto LABEL_35;
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf((char *)v82, 0x1000u, "%s: Attempting to restart", s);
          sub_38730(3, (const char *)v82, 0);
        }
LABEL_34:
        sub_16C88(v9);
LABEL_35:
        if ( dword_7B720 <= ++v5 )
          goto LABEL_2;
      }
      tv_sec = v80[0].tv_sec;
      v13 = v80[0].tv_sec - v12;
      if ( v13 <= 119 )
      {
        if ( v11 != 4 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf((char *)v82, 0x1000u, "%s: Recovered, declaring WELL!", s);
          sub_38730(3, (const char *)v82, 0);
        }
        *(_DWORD *)(v9 + 96) = 0;
        *(_DWORD *)(v9 + 240) = time(0);
        goto LABEL_35;
      }
      if ( v11 == 1 && v13 > 600 )
      {
        v14 = (unsigned __int8)byte_7AD48;
        *(_DWORD *)(v9 + 96) = 2;
        if ( v14 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf((char *)v82, 0x1000u, "%s: Not responded for more than 10 minutes, declaring DEAD!", s);
          sub_38730(3, (const char *)v82, 0);
        }
        sub_2A84C((struct timeval *)(v10 + 52));
        sub_2ED88((_DWORD *)v9, 4);
        goto LABEL_35;
      }
LABEL_48:
      if ( tv_sec - *(_DWORD *)(v10 + 52) <= 60 )
        goto LABEL_35;
      if ( (unsigned int)(v11 - 1) > 1 )
        goto LABEL_35;
      sub_2A84C((struct timeval *)(v10 + 52));
      if ( !byte_75E0C )
        goto LABEL_35;
      goto LABEL_34;
    }
  }
  if ( dword_7BC90 )
  {
    v19 = *(__int16 *)(dword_7BC90 + 4);
    v20 = v19 + 1;
    v21 = *(__int16 *)(dword_7BC90 + 6) + 1;
    v22 = v21 <= 79;
    if ( v21 > 79 )
      v22 = v20 <= 24;
    if ( !v22 )
    {
      if ( v20 > dword_77020 + 2 )
      {
        v23 = dword_7701C;
        if ( dword_77020 < dword_7701C )
        {
          if ( v19 <= dword_7701C )
            v23 = v19 - 1;
          dword_77020 = v23;
          dword_77024 = v23 + 1;
          mvwin((WINDOW *)dword_7B430, v23 + 1, 0);
          wresize((WINDOW *)dword_7B7C0, dword_77020, v21);
        }
      }
      v24 = v20 - dword_77024;
      if ( dword_7B430 )
        v25 = *(__int16 *)(dword_7B430 + 4);
      else
        v25 = -1;
      if ( dword_7B430 )
        v26 = *(__int16 *)(dword_7B430 + 6);
      else
        v26 = v25;
      if ( dword_7B430 )
      {
        ++v25;
        ++v26;
      }
      v27 = v21 == v26;
      if ( v21 == v26 )
        v27 = v24 == v25;
      if ( !v27 )
        wresize((WINDOW *)dword_7B430, v24, v21);
    }
  }
  v28 = sub_1DA58();
  if ( byte_77318 )
    v29 = 100;
  else
    v29 = 80;
  v76 = v28;
  wattr_on((WINDOW *)dword_7B7C0, 0x200000u, 0);
  snprintf((char *)v82, 0x100u, " cgminer version 4.9.0 - Started: %s", byte_77260);
  mvwprintw((WINDOW *)dword_7B7C0, 0, 0, "%s", (const char *)v82);
  wattr_off((WINDOW *)dword_7B7C0, 0x200000u, 0);
  if ( wmove((WINDOW *)dword_7B7C0, 1, 0) != -1 )
    whline((WINDOW *)dword_7B7C0, 0x2Du, v29);
  snprintf((char *)v82, 0x100u, " %s", byte_77160);
  mvwprintw((WINDOW *)dword_7B7C0, 2, 0, "%s", (const char *)v82);
  wclrtoeol((WINDOW *)dword_7B7C0);
  v30 = (unsigned __int8)byte_77318;
  if ( byte_77318 )
  {
    v58 = dbl_7B5E8;
    v59 = dword_7B8A4;
    v60 = dbl_7B670;
    LODWORD(v61) = sub_5CB64(*(__int64 *)&dword_7B100);
    v62 = v61 / dbl_755F8;
    v63 = sub_188A8();
    snprintf(
      (char *)v82,
      0x100u,
      " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m | ST: %d  SS: %lld  NB: %d  LW: %d  GF: %d  RF: %d",
      v58,
      v60,
      v59,
      v62 * 60.0,
      v63,
      *(_QWORD *)&dword_7BC80,
      dword_7BB1C,
      dword_7B4CC,
      dword_7B43C,
      dword_7AE68);
    mvwprintw((WINDOW *)dword_7B7C0, 3, 0, "%s", (const char *)v82);
  }
  else
  {
    v31 = (unsigned __int8)byte_77154;
    if ( byte_77154 )
    {
      v32 = sub_188A8();
      snprintf(
        (char *)v82,
        0x100u,
        " ST: %d  SS: %lld  NB: %d  LW: %d  GF: %d  RF: %d",
        v32,
        *(_QWORD *)&dword_7BC80,
        dword_7BB1C,
        dword_7B4CC,
        dword_7B43C,
        dword_7AE68);
      mvwprintw((WINDOW *)dword_7B7C0, 3, v30, "%s", (const char *)v82);
    }
    else
    {
      v73 = dbl_7B5E8;
      v75 = dword_7B8A4;
      v74 = dbl_7B670;
      LODWORD(v57) = sub_5CB64(*(__int64 *)&dword_7B100);
      snprintf((char *)v82, 0x100u, " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m", v73, v74, v75, v57 / dbl_755F8 * 60.0);
      mvwprintw((WINDOW *)dword_7B7C0, 3, v31, "%s", (const char *)v82);
    }
  }
  wclrtoeol((WINDOW *)dword_7B7C0);
  if ( (unsigned int)(dword_76EFC - 3) > 1 || dword_7B198 <= 1 )
  {
    v33 = *(unsigned __int8 *)(v76 + 664);
    if ( !*(_BYTE *)(v76 + 664) )
    {
      v34 = (char *)(unsigned __int8)byte_7BC79;
      if ( !byte_7BC79 )
        v34 = "out";
      v35 = "LP";
      if ( byte_7BC79 )
        v34 = "";
      if ( *(_BYTE *)(v76 + 760) )
        v35 = "GBT";
      snprintf(
        (char *)v82,
        0x100u,
        " Connected to %s diff %s with%s %s as user %s",
        *(const char **)(v76 + 624),
        (const char *)(v76 + 48),
        v34,
        v35,
        *(const char **)(v76 + 204));
      mvwprintw((WINDOW *)dword_7B7C0, 4, v33, "%s", (const char *)v82);
      goto LABEL_113;
    }
    snprintf(
      (char *)v82,
      0x100u,
      " Connected to %s diff %s with stratum as user %s",
      *(const char **)(v76 + 624),
      (const char *)(v76 + 48),
      *(const char **)(v76 + 204));
  }
  else
  {
    v64 = "out";
    if ( byte_7BC79 )
      v64 = "";
    snprintf((char *)v82, 0x100u, " Connected to multiple pools with%s block change notify", v64);
  }
  mvwprintw((WINDOW *)dword_7B7C0, 4, 0, "%s", (const char *)v82);
LABEL_113:
  wclrtoeol((WINDOW *)dword_7B7C0);
  snprintf(
    (char *)v82,
    0x100u,
    " Block: %s...  Diff:%s  Started: %s  Best share: %s   ",
    byte_77300,
    byte_772B8,
    byte_772E0,
    (const char *)&dword_75DC4);
  mvwprintw((WINDOW *)dword_7B7C0, 5, 0, "%s", (const char *)v82);
  if ( wmove((WINDOW *)dword_7B7C0, 6, 0) != -1 )
    whline((WINDOW *)dword_7B7C0, 0x2Du, v29);
  if ( wmove((WINDOW *)dword_7B7C0, dword_77020 - 1, 0) != -1 )
    whline((WINDOW *)dword_7B7C0, 0x2Du, v29);
  strcpy((char *)v82, "[P]ool management [S]ettings [D]isplay options [Q]uit");
  mvwprintw((WINDOW *)dword_7B7C0, dword_77028 - 1, 1, "%s", (const char *)v82);
  if ( dword_7B720 <= 0 )
  {
LABEL_146:
    if ( dword_7B7C0 )
      v53 = *(__int16 *)(dword_7B7C0 + 4) + 1;
    else
      v53 = -1;
    wtouchln((WINDOW *)dword_7B7C0, 0, v53, 1);
    wrefresh((WINDOW *)dword_7B7C0);
    if ( dword_7B430 )
      v54 = *(__int16 *)(dword_7B430 + 4);
    else
      v54 = -1;
    if ( dword_7B430 )
      ++v54;
    wtouchln((WINDOW *)dword_7B430, 0, v54, 1);
    wrefresh((WINDOW *)dword_7B430);
    if ( pthread_mutex_unlock(&mutex) )
      sub_B5C4("unlock_curses", 2930);
    off_75ED8();
    goto LABEL_3;
  }
  v36 = 0;
  v37 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v52 = sub_1B83C(v37);
      if ( !v52 )
        goto LABEL_142;
      if ( !byte_7B940 )
      {
        v38 = v36 + dword_77028;
        if ( LINES - 1 > v36 + dword_77028 && dword_7702C > v36 )
          break;
      }
      ++v37;
      ++v36;
      if ( dword_7B720 <= v37 )
        goto LABEL_146;
    }
    if ( *(_DWORD *)(v52 + 368) )
    {
      sub_2A84C(&v77);
      sub_2AA24();
      v38 = v36 + dword_77028;
      v39 = v0;
    }
    else
    {
      v39 = dbl_755F8;
    }
    v40 = (WINDOW *)dword_7B7C0;
    v41 = *(_QWORD *)(v52 + 192);
    if ( v39 < 1.0 )
      v39 = 1.0;
    *(double *)(v52 + 88) = (double)*(int *)(v52 + 36) / v39 * 60.0;
    wmove(v40, v38, 0);
    sub_11548(COERCE_DOUBLE(__PAIR64__(&dword_75DF8, v37)));
    v42 = *(const char **)(v52 + 28);
    if ( v42 )
    {
      strcpy(dest, "        ");
      strncpy(dest, v42, 8u);
    }
    else
    {
      sprintf(dest, "%-8d", *(_DWORD *)(v52 + 8));
    }
    snprintf((char *)v82, 0x100u, " %*d: %s %-8s: ", dword_75DF8, v37, *(const char **)(*(_DWORD *)(v52 + 4) + 8), dest);
    wprintw((WINDOW *)dword_7B7C0, "%s", (const char *)v82);
    s[0] = 0;
    (*(void (__fastcall **)(char *, int, int))(*(_DWORD *)(v52 + 4) + 20))(s, 256, v52);
    v43 = strlen(s);
    if ( v43 <= 0x16 )
      strncat(s, "                                        ", 23 - v43);
    snprintf((char *)v82, 0x100u, "%s | ", s);
    wprintw((WINDOW *)dword_7B7C0, "%s", (const char *)v82);
    v44 = *(_DWORD *)(v52 + 96);
    if ( v44 == 2 )
    {
      v45 = "DEAD  ";
    }
    else if ( v44 == 1 )
    {
      v45 = "SICK  ";
    }
    else
    {
      v46 = *(_DWORD *)(v52 + 32);
      if ( v46 == 1 )
      {
        v45 = "OFF   ";
      }
      else
      {
        if ( v46 != 2 )
        {
          LODWORD(v47) = sub_5CB64(v41);
          v48 = v47 / v39 * 60.0;
          if ( byte_77318 )
          {
            LODWORD(v67) = sub_5CC48(*(double *)(v52 + 80) / v39 * 1000000.0);
            sub_11580(v67, v79, 0x10u, 4);
            LODWORD(v68) = sub_5CC48(*(double *)(v52 + 48) * 1000000.0);
            sub_11580(v68, (char *)v80, 0x10u, 4);
            HIDWORD(v69) = &dword_75DFC;
            LODWORD(v69) = (int)v48;
            v70 = sub_11548(v69);
            LODWORD(v70) = &dword_75E00;
            v71 = sub_11514(v70);
            LODWORD(v71) = &dword_75E04;
            *(float *)&v0 = *(double *)(v52 + 208);
            sub_11514(v71);
            LODWORD(v72) = *(_DWORD *)(v52 + 44);
            HIDWORD(v72) = &dword_75E08;
            sub_11548(v72);
            snprintf(
              (char *)v82,
              0x100u,
              "%6s / %6sh/s WU:%*.1f/m A:%*.0f R:%*.0f HW:%*d",
              (const char *)v80,
              v79,
              dword_75DFC + 2,
              v48,
              dword_75E00,
              *(double *)(v52 + 200),
              dword_75E04,
              *(double *)(v52 + 208),
              dword_75E08,
              *(_DWORD *)(v52 + 44));
            wprintw((WINDOW *)dword_7B7C0, "%s", (const char *)v82);
          }
          else
          {
            if ( byte_77154 )
            {
              LODWORD(v47) = &dword_75E00;
              v65 = sub_11514(v47);
              LODWORD(v65) = &dword_75E04;
              *(float *)&v0 = *(double *)(v52 + 208);
              sub_11514(v65);
              LODWORD(v66) = *(_DWORD *)(v52 + 44);
              HIDWORD(v66) = &dword_75E08;
              sub_11548(v66);
              snprintf(
                (char *)v82,
                0x100u,
                "A:%*.0f R:%*.0f HW:%*d",
                dword_75E00,
                *(double *)(v52 + 200),
                dword_75E04,
                *(double *)(v52 + 208),
                dword_75E08,
                *(_DWORD *)(v52 + 44));
            }
            else
            {
              LODWORD(v49) = sub_5CC48(*(double *)(v52 + 80) / v39 * 1000000.0);
              sub_11580(v49, v79, 0x10u, 4);
              LODWORD(v50) = sub_5CC48(*(double *)(v52 + 48) * 1000000.0);
              sub_11580(v50, (char *)v80, 0x10u, 4);
              HIDWORD(v51) = &dword_75DFC;
              LODWORD(v51) = (int)v48;
              sub_11548(v51);
              snprintf((char *)v82, 0x100u, "%6s / %6sh/s WU:%*.1f/m", (const char *)v80, v79, dword_75DFC + 2, v48);
            }
            wprintw((WINDOW *)dword_7B7C0, "%s", (const char *)v82);
          }
          goto LABEL_141;
        }
        v45 = "REST  ";
      }
    }
    v55 = *(_DWORD *)v45;
    v56 = *((_DWORD *)v45 + 1);
    LOWORD(v82[1]) = v56;
    v82[0] = v55;
    BYTE2(v82[1]) = BYTE2(v56);
    wprintw((WINDOW *)dword_7B7C0, "%s", (const char *)v82);
LABEL_141:
    s[0] = 0;
    ++v36;
    (*(void (__fastcall **)(char *, int, int))(*(_DWORD *)(v52 + 4) + 24))(s, 256, v52);
    snprintf((char *)v82, 0x100u, "%s", s);
    wprintw((WINDOW *)dword_7B7C0, "%s", (const char *)v82);
    wclrtoeol((WINDOW *)dword_7B7C0);
LABEL_142:
    if ( dword_7B720 <= ++v37 )
      goto LABEL_146;
  }
}
// 240B0: variable 'v47' is possibly undefined
// 240F4: variable 'v49' is possibly undefined
// 24118: variable 'v50' is possibly undefined
// 24324: variable 'v57' is possibly undefined
// 24384: variable 'v61' is possibly undefined
// 24480: variable 'v0' is possibly undefined
// 24590: variable 'v67' is possibly undefined
// 245B4: variable 'v68' is possibly undefined
// 755F8: using guessed type double dbl_755F8;
// 75DC4: using guessed type int dword_75DC4;
// 75DF8: using guessed type int dword_75DF8;
// 75DFC: using guessed type int dword_75DFC;
// 75E00: using guessed type int dword_75E00;
// 75E04: using guessed type int dword_75E04;
// 75E08: using guessed type int dword_75E08;
// 75E0C: using guessed type char byte_75E0C;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 76BC4: using guessed type int LINES;
// 76EFC: using guessed type int dword_76EFC;
// 7701C: using guessed type int dword_7701C;
// 77020: using guessed type int dword_77020;
// 77024: using guessed type int dword_77024;
// 77028: using guessed type int dword_77028;
// 7702C: using guessed type int dword_7702C;
// 77154: using guessed type char byte_77154;
// 77310: using guessed type int dword_77310;
// 77318: using guessed type char byte_77318;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7AE68: using guessed type int dword_7AE68;
// 7B100: using guessed type int dword_7B100;
// 7B194: using guessed type char byte_7B194;
// 7B198: using guessed type int dword_7B198;
// 7B430: using guessed type int dword_7B430;
// 7B43C: using guessed type int dword_7B43C;
// 7B4CC: using guessed type int dword_7B4CC;
// 7B5E0: using guessed type int dword_7B5E0;
// 7B5E8: using guessed type double dbl_7B5E8;
// 7B5F0: using guessed type char byte_7B5F0;
// 7B5F8: using guessed type int dword_7B5F8;
// 7B5FC: using guessed type int dword_7B5FC;
// 7B670: using guessed type double dbl_7B670;
// 7B720: using guessed type int dword_7B720;
// 7B7C0: using guessed type int dword_7B7C0;
// 7B874: using guessed type char byte_7B874;
// 7B87C: using guessed type int dword_7B87C;
// 7B880: using guessed type int dword_7B880;
// 7B8A4: using guessed type int dword_7B8A4;
// 7B940: using guessed type char byte_7B940;
// 7BB1C: using guessed type int dword_7BB1C;
// 7BB6C: using guessed type int dword_7BB6C;
// 7BC79: using guessed type char byte_7BC79;
// 7BC80: using guessed type int dword_7BC80;
// 7BC90: using guessed type int dword_7BC90;

//----- (00024708) --------------------------------------------------------
int __fastcall sub_24708(int a1)
{
  int v2; // r4
  int v4; // r0

  v2 = *(_DWORD *)(a1 + 356);
  if ( v2 )
  {
    if ( sub_22B44(*(_DWORD *)(a1 + 356), 0) )
    {
      v4 = v2;
      v2 = 0;
      sub_159B4(v4);
      sub_19840();
    }
    else
    {
      sub_16624(a1, v2);
    }
    *(_DWORD *)(a1 + 356) = 0;
  }
  return v2;
}

//----- (00024760) --------------------------------------------------------
int __fastcall sub_24760(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  int v3; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B480("get_queued", 8816);
  v3 = sub_24708((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    sub_B630("get_queued", 8818);
  off_75ED8();
  return v3;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (000247D4) --------------------------------------------------------
int __fastcall sub_247D4(int a1, int a2)
{
  _DWORD *v4; // r5
  time_t v5; // r8
  int v6; // r4
  time_t v7; // r0
  int v8; // r3
  int v9; // r8
  double v10; // d16
  double *v11; // r3
  int result; // r0
  int v13; // r2
  int v14; // r3
  int v15; // r3
  char v16[4100]; // [sp+0h] [bp-1004h] BYREF

  v4 = *(_DWORD **)(a1 + 36);
  sub_FC58(a1);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v16, "Popping work from get queue to get work");
    sub_38730(7, v16, 0);
  }
  v5 = time(0);
  do
  {
    while ( 1 )
    {
      v6 = sub_193B4(1);
      if ( !sub_22B44(v6, 0) )
        break;
      sub_159B4(v6);
      sub_19840();
    }
  }
  while ( !v6 );
  v7 = time(0);
  v8 = (unsigned __int8)byte_78E09;
  v9 = v7 - v5;
  if ( v9 > 0 )
  {
    if ( byte_78E09 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
      {
        snprintf(v16, 0x1000u, "Get work blocked for %d seconds", v9);
        sub_38730(7, v16, 0);
        v8 = (unsigned __int8)byte_78E09;
      }
      else
      {
        v8 = 1;
      }
    }
    v4[58] += v9;
  }
  if ( v8 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v16, 0x1000u, "Got work from get queue to get work for thread %d", a2);
    sub_38730(7, v16, 0);
  }
  *(_DWORD *)(v6 + 1744) = a2;
  if ( byte_7730D )
  {
    v14 = v4[95] + v4[96];
    v4[95] = v14;
    if ( v14 > 0 )
    {
      if ( v14 > 15 )
      {
        v15 = v4[94] + 1;
        v4[96] = -1;
        if ( v15 > 15 )
          v15 = 0;
        v4[94] = v15;
        memcpy((void *)v6, (char *)&unk_7731C + 160 * v15, 0xA0u);
        goto LABEL_17;
      }
    }
    else
    {
      v4[96] = 1;
    }
    memcpy((void *)v6, (char *)&unk_77D1C + 160 * v14, 0xA0u);
  }
LABEL_17:
  sub_FC24(a1);
  *(_BYTE *)(v6 + 1760) = 1;
  v10 = *(double *)(v4[1] + 104);
  v11 = (double *)(v6 + 1712);
  result = v6;
  if ( v10 > *(double *)(v6 + 1864) )
    v10 = *(double *)(v6 + 1864);
  *v11 = v10;
  v13 = v4[1];
  if ( v10 < *(double *)(v13 + 120) )
    v10 = *(double *)(v13 + 120);
  *v11 = v10;
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 7730D: using guessed type char byte_7730D;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00024D88) --------------------------------------------------------
int __fastcall sub_24D88(int a1, pthread_rwlock_t *a2, int a3)
{
  int v4; // r4

  v4 = sub_247D4(a1, a3);
  sub_19F54(a2, v4);
  return v4;
}

//----- (00024DB0) --------------------------------------------------------
void __fastcall sub_24DB0(int a1)
{
  int v1; // r1
  int v2; // r11
  int v3; // r5
  int v4; // r12
  int v5; // r2
  int v6; // r9
  int v7; // r7
  int v8; // r3
  int v9; // r12
  int v10; // r0
  double v11; // d8
  double *v12; // r4
  double v13; // d9
  double *v14; // r5
  int v15; // r3
  _DWORD *v16; // r5
  __int64 v17; // kr00_8
  __suseconds_t tv_usec; // r4
  __time_t tv_sec; // r3
  int v20; // r2
  int v21; // r1
  bool v22; // nf
  int v23; // r4
  int v24; // r4
  int v25; // r3
  double v26; // r0
  double v27; // d16
  bool v28; // zf
  double v29; // d8
  int v30; // r1
  unsigned int v31; // r0
  int v32; // r1
  __time_t v33; // [sp+Ch] [bp-1090h]
  __time_t v34; // [sp+Ch] [bp-1090h]
  unsigned int v35; // [sp+10h] [bp-108Ch]
  int v36; // [sp+14h] [bp-1088h]
  int v37; // [sp+14h] [bp-1088h]
  int v38; // [sp+14h] [bp-1088h]
  int v39; // [sp+14h] [bp-1088h]
  __int64 v40; // [sp+28h] [bp-1074h]
  int v41; // [sp+34h] [bp-1068h]
  int v42; // [sp+48h] [bp-1054h]
  _DWORD *v43; // [sp+4Ch] [bp-1050h]
  _DWORD *v44; // [sp+50h] [bp-104Ch]
  struct timeval *v45; // [sp+54h] [bp-1048h]
  int *v47; // [sp+5Ch] [bp-1040h]
  int v48; // [sp+60h] [bp-103Ch]
  unsigned int v49; // [sp+64h] [bp-1038h]
  int v50; // [sp+68h] [bp-1034h]
  int remaining; // [sp+70h] [bp-102Ch]
  int v52; // [sp+74h] [bp-1028h]
  struct timeval v53; // [sp+78h] [bp-1024h] BYREF
  struct timeval v54; // [sp+80h] [bp-101Ch] BYREF
  struct timeval v55; // [sp+88h] [bp-1014h] BYREF
  struct timeval v56; // [sp+90h] [bp-100Ch] BYREF
  struct timespec s[509]; // [sp+98h] [bp-1004h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)a1;
  v4 = 1717986919 * dword_75DCC;
  v50 = *(_DWORD *)a1;
  v42 = *(_DWORD *)(v2 + 4);
  v5 = dword_75DCC / 5;
  if ( !(dword_75DCC / 5) )
    v5 = 1;
  if ( v1 )
    v3 = a1;
  else
    v4 = 1;
  v48 = v5;
  if ( v1 )
    remaining = *(unsigned __int8 *)(v3 + 8);
  else
    remaining = v4;
  v49 = (*(int (**)(void))(*(_DWORD *)(v2 + 4) + 48))();
  sub_2A84C(&v53);
  sub_2A84C(&v56);
  if ( !*(_BYTE *)(v2 + 364) )
  {
    v40 = 0;
    v6 = *(unsigned __int8 *)(v2 + 364);
    v7 = v6;
    v8 = 1000000 * v48 + 1023;
    if ( 1000000 * v48 >= 0 )
      v8 = 1000000 * v48;
    v52 = v8 >> 10;
    while ( 1 )
    {
      v10 = sub_247D4(a1, v50);
      *(_BYTE *)(a1 + 62) = 0;
      *(_BYTE *)(v2 + 172) = 1;
      v41 = v10;
      sub_2A84C(&v55);
      *(_DWORD *)(v41 + 1736) = 0;
      *(_QWORD *)(v2 + 160) = 0;
      if ( !(*(int (__fastcall **)(int, int))(v42 + 56))(a1, v41) )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf((char *)s, 0x1000u, "work prepare failed, exiting mining thread %d", v50);
          sub_38730(3, (const char *)s, 0);
        }
        goto LABEL_82;
      }
      v11 = *(double *)(v42 + 104);
      v12 = (double *)(v41 + 1864);
      v13 = *(double *)(v41 + 1864);
      v14 = (double *)(v41 + 1712);
      v15 = (unsigned __int8)byte_7B859;
      if ( v11 > v13 )
        v11 = *(double *)(v41 + 1864);
      *v14 = v11;
      if ( v11 < *(double *)(v42 + 120) )
        v11 = *(double *)(v42 + 120);
      *v14 = v11;
      if ( !v15 )
      {
        v47 = (int *)(v2 + 296);
        v43 = (_DWORD *)(v2 + 304);
        v45 = (struct timeval *)(v41 + 1912);
        v44 = (_DWORD *)(v2 + 312);
        goto LABEL_30;
      }
      LODWORD(v26) = sub_5CB64(*(__int64 *)&dword_7B100);
      if ( v26 / dbl_755F8 * 60.0 <= 30.0 )
        break;
      v27 = *(double *)(v42 + 112);
      if ( v27 >= *(double *)(v42 + 104) || v13 <= v27 )
        goto LABEL_75;
      v28 = byte_78E09 == 0;
      v29 = v27 + 1.0;
      *(double *)(v42 + 112) = v27 + 1.0;
      if ( !v28 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf((char *)s, 0x1000u, "Driver %s working diff changed to %.0f", *(const char **)(v42 + 4), v27 + 1.0);
        sub_38730(7, (const char *)s, 0);
        v29 = *(double *)(v42 + 112);
      }
      if ( *v12 < v29 )
        v29 = *v12;
      *v14 = v29;
LABEL_73:
      sub_16244(v41 + 1929);
      v45 = (struct timeval *)(v41 + 1912);
      v47 = (int *)(v2 + 296);
      v43 = (_DWORD *)(v2 + 304);
      v44 = (_DWORD *)(v2 + 312);
      while ( 1 )
      {
LABEL_30:
        sub_2A84C(&v54);
        sub_2A448(&v54, &v53.tv_sec);
        sub_2A47C(&v53, v47);
        if ( sub_2A4C8(&v53, v43) )
          sub_2A530(v43, &v53);
        if ( sub_2A4FC(&v53, v44) )
          sub_2A530(v44, &v53);
        ++*(_DWORD *)(v2 + 292);
        v16 = *(_DWORD **)(v41 + 1748);
        sub_2A47C(&v53, v16 + 103);
        if ( sub_2A4C8(&v53, v16 + 105) )
          sub_2A530(v16 + 105, &v53);
        if ( sub_2A4FC(&v53, v16 + 107) )
          sub_2A530(v16 + 107, &v53);
        ++v16[102];
        sub_2A84C(v45);
        pthread_setcancelstate(1, 0);
        sub_FC24(a1);
        v17 = ((__int64 (__fastcall *)(int, int, unsigned int, _DWORD))*(_DWORD *)(v42 + 64))(
                a1,
                v41,
                v49 + *(_DWORD *)(v41 + 1736),
                0);
        sub_FC58(a1);
        pthread_setcancelstate(0, 0);
        pthread_testcancel();
        sub_2A84C(&v53);
        if ( v17 == -1 )
          break;
        v40 += v17;
        tv_usec = v53.tv_usec;
        if ( *(_QWORD *)(v2 + 160) < v17 )
          *(_QWORD *)(v2 + 160) = v17;
        tv_sec = v53.tv_sec;
        v20 = tv_usec - v54.tv_usec + (tv_usec - v54.tv_usec < 0 ? 0xF4000 : 0);
        if ( tv_usec - v54.tv_usec < 0 )
          v20 += 576;
        v7 += v20;
        v21 = v53.tv_sec - v54.tv_sec;
        if ( tv_usec - v54.tv_usec < 0 )
          --v21;
        v6 += v21;
        if ( v7 > 1000000 )
        {
          ++v6;
          v7 -= 1000000;
        }
        v9 = v53.tv_sec - v55.tv_sec;
        if ( tv_usec - v55.tv_usec < 0 )
          --v9;
        if ( v48 > v6 )
        {
          if ( v49 == -1 )
            goto LABEL_20;
          v30 = v7 + 1024;
          v33 = v53.tv_sec;
          if ( v7 + 1024 < 0 )
            v30 = v7 + 2047;
          v38 = v9;
          v35 = (sub_5C710(1000000, v30 >> 10) + 16) * v48;
          tv_sec = v33;
          v9 = v38;
          if ( v49 <= 0xFFFFFC00 / v35 )
            v49 = (v49 * v35) >> 10;
          else
            v49 = -1;
        }
        else if ( v48 < v6 )
        {
          v49 = v48 * v49 / v6;
        }
        else if ( v7 > 100000 )
        {
          v34 = v53.tv_sec;
          v39 = v9;
          v31 = sub_5C710(1000000 * v48 + v7, v52);
          tv_sec = v34;
          v9 = v39;
          v49 = (v49 << 10) / v31;
        }
        v23 = tv_usec - v56.tv_usec;
        v22 = v23 < 0;
        v24 = v23 + (v23 < 0 ? 0xF4000 : 0);
        v25 = tv_sec - v56.tv_sec;
        if ( v22 )
        {
          --v25;
          v24 += 576;
        }
        if ( v40 && (v25 > 0 || v24 > (int)&loc_30D40) || dword_75DCC <= v25 )
        {
          v36 = v9;
          sub_1BBA4(v50, v40);
          sub_2A530(&v56, &v53);
          v9 = v36;
          v40 = 0;
        }
        if ( *(_BYTE *)(a1 + 62) )
        {
          if ( !remaining )
          {
            v32 = *(_DWORD *)(a1 + 4);
            s[0].tv_sec = 0;
            s[0].tv_nsec = 250000000 * v32;
            nanosleep(s, 0);
          }
          goto LABEL_22;
        }
        if ( *(_BYTE *)(a1 + 60) || (v6 = *(_DWORD *)(v2 + 32)) != 0 )
        {
          v6 = 0;
          v37 = v9;
          v7 = 0;
          sub_11C8C(a1, v50, v42);
          v9 = v37;
        }
        else
        {
          v7 = 0;
        }
LABEL_20:
        if ( v9 > dword_75DF0 || *(_QWORD *)(v2 + 160) > 0xFFFFFFFD || sub_22B44(v41, 0) )
          goto LABEL_22;
      }
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf((char *)s, 0x1000u, "%s %d failure, disabling!", *(const char **)(v42 + 8), *(_DWORD *)(v2 + 8));
        sub_38730(3, (const char *)s, 0);
      }
      *(_DWORD *)(v2 + 32) = 1;
      sub_2ED88((_DWORD *)v2, 1);
      *(_BYTE *)(v2 + 364) = 1;
LABEL_22:
      sub_15780((void **)v41);
      if ( *(_BYTE *)(v2 + 364) )
        goto LABEL_82;
    }
    v27 = *(double *)(v42 + 112);
LABEL_75:
    if ( v13 < v27 )
      *(double *)(v42 + 112) = v13;
    goto LABEL_73;
  }
LABEL_82:
  *(_DWORD *)(v2 + 32) = 1;
}
// 25324: variable 'v26' is possibly undefined
// 755F8: using guessed type double dbl_755F8;
// 75DCC: using guessed type int dword_75DCC;
// 75DF0: using guessed type int dword_75DF0;
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B100: using guessed type int dword_7B100;
// 7B859: using guessed type char byte_7B859;

//----- (000256A4) --------------------------------------------------------
void __fastcall sub_256A4(int a1)
{
  _DWORD *v2; // r5
  int v3; // r6
  double v4; // d16
  double v5; // d16
  double v6; // d17
  double v7; // d16
  int v8; // r2
  double v9; // d18
  double v10; // d16
  double v11; // d17
  double v12; // d16
  pthread_t v13; // [sp+Ch] [bp-1008h] BYREF
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( !*(_DWORD *)(a1 + 76) )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      strcpy(s, "Get A Error Data To Push!DROP!\r\n");
      sub_38730(4, s, 0);
    }
    return;
  }
  v2 = *(_DWORD **)(a1 + 1748);
  sub_2A84C((struct timeval *)(a1 + 1920));
  if ( byte_7730D )
  {
    v3 = *(_DWORD *)(sub_1B124(*(_DWORD *)(a1 + 1744)) + 36);
    if ( pthread_mutex_lock(&stru_7AD4C) )
      sub_B414("submit_work_async", 8236);
    ++*(_DWORD *)(v3 + 36);
    ++*((_QWORD *)v2 + 1);
    v4 = *(double *)(v3 + 200) + *(double *)(a1 + 1864);
    ++qword_7B420;
    *(double *)(v3 + 200) = v4;
    v5 = *(double *)(a1 + 1864);
    v6 = *((double *)v2 + 13) + v5;
    v7 = v5 + dbl_7B5E8;
    *((double *)v2 + 13) = v6;
    dbl_7B5E8 = v7;
    if ( pthread_mutex_unlock(&stru_7AD4C) )
      sub_B5C4("submit_work_async", 8243);
    off_75ED8();
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(
        s,
        0x1000u,
        "Accepted %s %d benchmark share nonce %08x",
        *(const char **)(*(_DWORD *)(v3 + 4) + 8),
        *(_DWORD *)(v3 + 8),
        *(_DWORD *)(a1 + 76));
      sub_38730(7, s, 0);
    }
    return;
  }
  if ( !sub_22B44(a1, 1) )
  {
    v8 = (unsigned __int8)byte_78E09;
    goto LABEL_17;
  }
  if ( byte_75E0D )
  {
    v8 = (unsigned __int8)byte_78E09;
    if ( !byte_78E09 )
      goto LABEL_37;
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
      goto LABEL_36;
    snprintf(s, 0x1000u, "Pool %d stale share detected, submitting as user requested", *v2);
    goto LABEL_48;
  }
  if ( *((_BYTE *)v2 + 136) )
  {
    v8 = (unsigned __int8)byte_78E09;
    if ( !byte_78E09 )
    {
LABEL_37:
      *(_BYTE *)(a1 + 1769) = 1;
LABEL_17:
      if ( *(_BYTE *)(a1 + 1772) )
      {
        if ( v8 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(s, 0x1000u, "Pushing pool %d work to stratum queue", *v2);
          sub_38730(7, s, 0);
        }
        if ( !sub_2A240(v2[188], a1) )
        {
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            strcpy(s, "Discarding work from removed pool");
            sub_38730(7, s, 0);
          }
          sub_15780((void **)a1);
        }
      }
      else
      {
        if ( v8 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          strcpy(s, "Pushing submit work to work thread");
          sub_38730(7, s, 0);
        }
        if ( pthread_create(&v13, 0, sub_FC10, (void *)a1) )
        {
          strcpy(s, "Failed to create submit_work_thread");
          sub_38730(3, s, 1);
          sub_16CA8(1);
        }
      }
      return;
    }
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
    {
LABEL_36:
      v8 = 1;
      goto LABEL_37;
    }
    snprintf(s, 0x1000u, "Pool %d stale share detected, submitting as pool requested", *v2);
LABEL_48:
    sub_38730(7, s, 0);
    v8 = (unsigned __int8)byte_78E09;
    goto LABEL_37;
  }
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "Pool %d stale share detected, discarding", *v2);
    sub_38730(7, s, 0);
  }
  sub_1B600("discard", (_DWORD *)a1);
  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("submit_work_async", 8261);
  v9 = *((double *)v2 + 15);
  ++v2[38];
  v10 = *(double *)(a1 + 1864);
  v11 = v9 + v10;
  ++*(_QWORD *)&dword_7BC80;
  v12 = v10 + dbl_7B428;
  *((double *)v2 + 15) = v11;
  dbl_7B428 = v12;
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("submit_work_async", 8266);
  off_75ED8();
  sub_15780((void **)a1);
}
// 75E0D: using guessed type char byte_75E0D;
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 7730D: using guessed type char byte_7730D;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B420: using guessed type __int64 qword_7B420;
// 7B428: using guessed type double dbl_7B428;
// 7B5E8: using guessed type double dbl_7B5E8;
// 7BC80: using guessed type int dword_7BC80;

//----- (00025E28) --------------------------------------------------------
int __fastcall sub_25E28(int a1, int a2, int a3)
{
  _DWORD *v3; // r0

  *(_DWORD *)(a2 + 76) = a3;
  v3 = sub_1A44C(a2, 0);
  sub_256A4((int)v3);
  return 1;
}

//----- (00025E48) --------------------------------------------------------
void __fastcall sub_25E48(int a1)
{
  _DWORD *v1; // r0

  v1 = sub_1A44C(a1, 0);
  sub_256A4((int)v1);
}

//----- (00025E5C) --------------------------------------------------------
int __fastcall sub_25E5C(int a1, int a2)
{
  int result; // r0
  _DWORD *v5; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  sub_1A730(a1, a2);
  if ( sub_29F54((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160)) )
  {
    v5 = sub_1A44C(a2, 0);
    sub_256A4((int)v5);
    return 1;
  }
  else if ( byte_78E09 )
  {
    if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 6 )
    {
      snprintf(
        s,
        0x1000u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      sub_38730(7, s, 0);
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00025F48) --------------------------------------------------------
int __fastcall sub_25F48(int a1, char *a2, unsigned int a3)
{
  if ( sub_F7E8(a1, a3) && sub_1654C((int)a2, a3) )
  {
    sub_25E5C(a1, (int)a2);
    if ( dword_76FFC && byte_7871C )
    {
      sub_11814(a2, a3);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_189A4(a1);
    return 0;
  }
}
// 76FFC: using guessed type int dword_76FFC;
// 7871C: using guessed type char byte_7871C;

//----- (00025FDC) --------------------------------------------------------
char *__fastcall sub_25FDC(const char *a1)
{
  char *v2; // r4
  char v4[4100]; // [sp+0h] [bp-1004h] BYREF

  echo();
  v2 = (char *)malloc(0xFFu);
  if ( !v2 )
  {
    strcpy(v4, "Failed to malloc input");
    sub_38730(3, v4, 1);
    sub_16CA8(1);
  }
  leaveok((WINDOW *)dword_7B430, 0);
  snprintf(v4, 0x1000u, "%s:\n", a1);
  sub_18BC0(v4);
  wgetnstr((WINDOW *)dword_7B430, v2, 255);
  if ( !*v2 )
    strcpy(v2, "-1");
  leaveok((WINDOW *)dword_7B430, 1);
  noecho();
  return v2;
}
// 7B430: using guessed type int dword_7B430;

//----- (000260D0) --------------------------------------------------------
int __fastcall sub_260D0(const char *a1)
{
  char *v1; // r4
  int v2; // r5

  v1 = sub_25FDC(a1);
  v2 = strtol(v1, 0, 10);
  free(v1);
  return v2;
}

//----- (000260FC) --------------------------------------------------------
void sub_260FC()
{
  const char *v0; // r3
  char *v1; // r11
  char *v2; // r12
  char *v3; // lr
  const char *v4; // r11
  char *v5; // r12
  const char *v6; // lr
  const char *v7; // r12
  const char *v8; // r2
  const char *v9; // r2
  int v10; // r3
  char *v11; // r3
  int v12; // r3
  int v13; // r3
  const char *v14; // r3
  int v15; // r3
  char *v16; // r3
  int v17; // r0
  int v18; // r1
  int v19; // r12
  int v20; // r3
  bool v21; // zf
  unsigned int v22; // r0
  const char *v23; // [sp+0h] [bp-1034h]
  const char *v24; // [sp+4h] [bp-1030h]
  const char *v25; // [sp+8h] [bp-102Ch]
  const char *v26; // [sp+10h] [bp-1024h]
  char s1; // [sp+2Fh] [bp-1005h] BYREF
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  byte_7BAC8 = 1;
  immedok((WINDOW *)dword_7B430, 1);
  sub_18AD8();
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            strcpy(s, "[N]ormal [C]lear [S]ilent mode (disable all output)\n");
            sub_18BC0(s);
            v0 = "off";
            if ( byte_7B858 )
              v1 = (char *)"on";
            else
              v1 = "off";
            v23 = v1;
            if ( byte_7BC78 )
              v2 = (char *)"on";
            else
              v2 = "off";
            v24 = v2;
            if ( byte_78E08 )
              v3 = (char *)"on";
            else
              v3 = "off";
            v25 = v3;
            if ( byte_7B380 )
              v4 = "on";
            else
              v4 = "off";
            if ( byte_7B85A )
              v5 = (char *)"on";
            else
              v5 = "off";
            v26 = v5;
            if ( byte_7B940 )
              v6 = "on";
            else
              v6 = "off";
            if ( byte_78E09 )
              v0 = "on";
            if ( byte_77155 )
              v7 = "enabled";
            else
              v7 = "disabled";
            if ( byte_77318 )
              v8 = "enabled";
            else
              v8 = "disabled";
            snprintf(
              s,
              0x1000u,
              "[D]ebug:%s\n"
              "[P]er-device:%s\n"
              "[Q]uiet:%s\n"
              "[V]erbose:%s\n"
              "[R]PC debug:%s\n"
              "[W]orkTime details:%s\n"
              "co[M]pact: %s\n"
              "[T]oggle status switching:%s\n"
              "w[I]descreen:%s\n"
              "[Z]ero statistics\n"
              "[L]og interval:%d\n",
              v0,
              v23,
              v24,
              v25,
              v4,
              v26,
              v6,
              v7,
              v8,
              dword_75DCC);
            sub_18BC0(s);
            strcpy(s, "Select an option or any other key to return\n");
            sub_18BC0(s);
            sub_18B44();
            s1 = wgetch((WINDOW *)stdscr);
            if ( !strncasecmp(&s1, "q", 1u) )
            {
              v9 = "Quiet mode %s\n";
              v10 = (unsigned __int8)byte_7BC78 ^ 1;
              byte_7BC78 ^= 1u;
              if ( v10 )
                v11 = "enabled";
              else
                v11 = "disabled";
              goto LABEL_64;
            }
            if ( !strncasecmp(&s1, "v", 1u) )
            {
              v9 = "Verbose mode %s\n";
              v12 = (unsigned __int8)byte_78E08 ^ 1;
              byte_78E08 ^= 1u;
              if ( v12 )
              {
                byte_7BC78 = 0;
                v11 = "enabled";
              }
              else
              {
                v11 = "disabled";
              }
              goto LABEL_64;
            }
            if ( strncasecmp(&s1, "n", 1u) )
              break;
            byte_78E09 = 0;
            byte_78E08 = 0;
            byte_7BC78 = 0;
            byte_7B380 = 0;
            strcpy(s, "Output mode reset to normal\n");
            byte_7B940 = 0;
            byte_7B858 = 0;
            sub_18BC0(s);
            v17 = sub_17FE4();
            if ( v17 )
              goto LABEL_47;
          }
          if ( strncasecmp(&s1, "d", 1u) )
            break;
          v13 = (unsigned __int8)byte_78E09 ^ 1;
          byte_78E09 ^= 1u;
          byte_78E08 = v13;
          if ( v13 )
          {
            byte_7BC78 = 0;
            v14 = "enabled";
          }
          else
          {
            v14 = "disabled";
          }
          snprintf(s, 0x1000u, "Debug mode %s\n", v14);
          sub_18BC0(s);
        }
        if ( strncasecmp(&s1, "m", 1u) )
          break;
        v15 = (unsigned __int8)byte_7B940 ^ 1;
        byte_7B940 ^= 1u;
        if ( v15 )
          v16 = "enabled";
        else
          v16 = "disabled";
        snprintf(s, 0x1000u, "Compact mode %s\n", v16);
        sub_18BC0(s);
        v17 = sub_17FE4();
        if ( v17 )
LABEL_47:
          sub_18178(v17, v18);
      }
      if ( !strncasecmp(&s1, "p", 1u) )
      {
        v9 = "Per-device stats %s\n";
        v19 = (unsigned __int8)byte_7B858 ^ 1;
        byte_7B858 ^= 1u;
        byte_78E08 = v19;
        if ( v19 )
          v11 = "enabled";
        else
          v11 = "disabled";
        goto LABEL_64;
      }
      if ( !strncasecmp(&s1, "r", 1u) )
      {
        v20 = (unsigned __int8)byte_7B380 ^ 1;
        byte_7B380 ^= 1u;
        v9 = "RPC protocol debugging %s\n";
        if ( v20 )
        {
          byte_7BC78 = 0;
          v11 = "enabled";
        }
        else
        {
          v11 = "disabled";
        }
        goto LABEL_64;
      }
      if ( !strncasecmp(&s1, "c", 1u) )
        goto LABEL_75;
      if ( strncasecmp(&s1, "l", 1u) )
        break;
      v22 = sub_260D0("Interval in seconds");
      if ( v22 <= 0x270F )
      {
        dword_75DCC = v22;
        snprintf(s, 0x1000u, "Log interval set to %d seconds\n", v22);
      }
      else
      {
        strcpy(s, "Invalid selection\n");
      }
      sub_18BC0(s);
    }
    if ( !strncasecmp(&s1, "s", 1u) )
      break;
    if ( !strncasecmp(&s1, "w", 1u) )
    {
      v11 = "enabled";
      v21 = byte_7B85A == 1;
      byte_7B85A ^= 1u;
      v9 = "WorkTime details %s\n";
      if ( v21 )
        v11 = "disabled";
LABEL_64:
      snprintf(s, 0x1000u, v9, v11);
      sub_18BC0(s);
    }
    else if ( !strncasecmp(&s1, "t", 1u) )
    {
      byte_77155 ^= 1u;
    }
    else if ( !strncasecmp(&s1, "i", 1u) )
    {
      byte_77318 ^= 1u;
    }
    else
    {
      if ( strncasecmp(&s1, "z", 1u) )
      {
LABEL_75:
        sub_18AD8();
        goto LABEL_76;
      }
      sub_1B8B4();
    }
  }
  byte_7BB18 = 1;
LABEL_76:
  immedok((WINDOW *)dword_7B430, 0);
  byte_7BAC8 = 0;
}
// 26434: variable 'v18' is possibly undefined
// 75DCC: using guessed type int dword_75DCC;
// 76BC0: using guessed type int stdscr;
// 77155: using guessed type char byte_77155;
// 77318: using guessed type char byte_77318;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7B380: using guessed type char byte_7B380;
// 7B430: using guessed type int dword_7B430;
// 7B858: using guessed type char byte_7B858;
// 7B85A: using guessed type char byte_7B85A;
// 7B940: using guessed type char byte_7B940;
// 7BAC8: using guessed type char byte_7BAC8;
// 7BB18: using guessed type char byte_7BB18;
// 7BC78: using guessed type char byte_7BC78;

//----- (000267B0) --------------------------------------------------------
void sub_267B0()
{
  int v0; // r3
  unsigned int v1; // r0
  int i; // r2
  char *v3; // r0
  char *v4; // r4
  FILE *v5; // r0
  FILE *v6; // r4
  int v7; // r0
  unsigned int v8; // r0
  char s1; // [sp+Fh] [bp-3091h] BYREF
  struct stat stat_buf; // [sp+10h] [bp-3090h] BYREF
  char filename[4052]; // [sp+6Ch] [bp-3034h] BYREF
  char v12[4052]; // [sp+106Ch] [bp-2034h] BYREF
  char v13[4116]; // [sp+206Ch] [bp-1034h] BYREF

  byte_7BAC8 = 1;
  immedok((WINDOW *)dword_7B430, 1);
  sub_18AD8();
  v0 = dword_75DDC;
  v1 = dword_75DF0;
  for ( i = dword_75DF4; ; i = dword_75DF4 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          snprintf(
            v13,
            0x1000u,
            "[Q]ueue: %d\n[S]cantime: %d\n[E]xpiry: %d\n[W]rite config file\n[C]gminer restart\n",
            v0,
            v1,
            i);
          sub_18BC0(v13);
          strcpy(v13, "Select an option or any other key to return\n");
          sub_18BC0(v13);
          sub_18B44();
          s1 = wgetch((WINDOW *)stdscr);
          if ( strncasecmp(&s1, "q", 1u) )
            break;
          v7 = sub_260D0("Extra work items to queue");
          v0 = v7;
          if ( (unsigned int)v7 > 0x270F )
            goto LABEL_18;
          dword_75DDC = v7;
          if ( v7 >= dword_75DD8 )
          {
            v1 = dword_75DF0;
            i = dword_75DF4;
          }
          else
          {
            dword_75DD8 = v7;
            i = dword_75DF4;
            v1 = dword_75DF0;
          }
        }
        if ( strncasecmp(&s1, "s", 1u) )
          break;
        v1 = sub_260D0("Set scantime in seconds");
        if ( v1 > 0x270F )
          goto LABEL_18;
        dword_75DF0 = v1;
        v0 = dword_75DDC;
        i = dword_75DF4;
      }
      if ( strncasecmp(&s1, "e", 1u) )
        break;
      v8 = sub_260D0("Set expiry time in seconds");
      i = v8;
      if ( v8 > 0x270F )
      {
LABEL_18:
        strcpy(v13, "Invalid selection\n");
        sub_18BC0(v13);
        v0 = dword_75DDC;
        v1 = dword_75DF0;
        i = dword_75DF4;
      }
      else
      {
        dword_75DF4 = v8;
        v0 = dword_75DDC;
        v1 = dword_75DF0;
      }
    }
    if ( strncasecmp(&s1, "w", 1u) )
      break;
    sub_16150(filename);
    snprintf(v13, 0x1032u, "Config filename to write (Enter for default) [%s]", filename);
    v3 = sub_25FDC(v13);
    v4 = v3;
    if ( *v3 == 45 && v3[1] == 49 && !v3[2] )
    {
      free(v3);
LABEL_10:
      v5 = fopen(filename, "w");
      v6 = v5;
      if ( v5 )
      {
        sub_15B64(v5);
        fclose(v6);
      }
      else
      {
        strcpy(v12, "Cannot open or create file\n");
        sub_18BC0(v12);
      }
      goto LABEL_12;
    }
    strcpy(filename, v3);
    free(v4);
    if ( _xstat(3, filename, &stat_buf) )
      goto LABEL_10;
    strcpy(v12, "File exists, overwrite?\n");
    sub_18BC0(v12);
    s1 = wgetch((WINDOW *)stdscr);
    if ( !strncasecmp(&s1, "y", 1u) )
      goto LABEL_10;
LABEL_12:
    v0 = dword_75DDC;
    v1 = dword_75DF0;
  }
  if ( !strncasecmp(&s1, "c", 1u)
    && (strcpy(v13, "Are you sure?\n"), sub_18BC0(v13), s1 = wgetch((WINDOW *)stdscr), !strncasecmp(&s1, "y", 1u)) )
  {
    sub_1D7C8();
  }
  else
  {
    sub_18AD8();
  }
  immedok((WINDOW *)dword_7B430, 0);
  byte_7BAC8 = 0;
}
// 75DD8: using guessed type int dword_75DD8;
// 75DDC: using guessed type int dword_75DDC;
// 75DF0: using guessed type int dword_75DF0;
// 75DF4: using guessed type int dword_75DF4;
// 76BC0: using guessed type int stdscr;
// 7B430: using guessed type int dword_7B430;
// 7BAC8: using guessed type char byte_7BAC8;

//----- (00026BCC) --------------------------------------------------------
int __fastcall sub_26BCC(int a1, int a2, char *a3, const char *a4, const char *a5)
{
  char *v8; // r0
  size_t v9; // r8
  size_t v10; // r8
  char *v11; // r0
  int v12; // r1
  int *v13; // r2
  char v15[4096]; // [sp+8h] [bp-1000h] BYREF

  v8 = sub_2ACE0(a3, a1);
  *(_DWORD *)(a1 + 204) = a4;
  *(_DWORD *)(a1 + 208) = a5;
  *(_DWORD *)(a1 + 196) = v8;
  v9 = strlen(a4);
  v10 = v9 + strlen(a5) + 2;
  v11 = (char *)malloc(v10);
  *(_DWORD *)(a1 + 200) = v11;
  if ( !v11 )
  {
    strcpy(v15, "Failed to malloc userpass");
    sub_38730(3, v15, 1);
    sub_16CA8(1);
  }
  snprintf(v11, v10, "%s:%s", a4, a5);
  v12 = *(_DWORD *)(a1 + 132);
  v13 = (int *)(a2 ^ 1);
  *(_BYTE *)(a1 + 139) = a2 ^ 1;
  if ( v12 != 1 )
  {
    *(_DWORD *)(a1 + 132) = 1;
    v13 = &dword_7B5E4;
  }
  *(_BYTE *)(a1 + 316) = 1;
  *(_BYTE *)(a1 + 129) = 1;
  if ( v12 != 1 )
    ++*v13;
  pthread_create((pthread_t *)(a1 + 312), 0, (void *(*)(void *))start_routine, (void *)a1);
  if ( a2 )
    return 1;
  pthread_join(*(_DWORD *)(a1 + 312), 0);
  return (unsigned __int8)byte_7730C;
}
// 7730C: using guessed type char byte_7730C;
// 7B5E4: using guessed type int dword_7B5E4;

//----- (00026CEC) --------------------------------------------------------
void sub_26CEC()
{
  JUMPOUT(0x26C34);
}
// 26CF8: control flows out of bounds to 26C34

//----- (00026D10) --------------------------------------------------------
int __fastcall sub_26D10(int a1)
{
  char *v2; // r0
  char *v3; // r4
  char *v4; // r0
  char *v5; // r8
  char *v6; // r0
  void *v7; // r7
  char *v8; // r10
  char *v9; // r0
  char *v10; // r9
  int v11; // r6
  char v13[4096]; // [sp+8h] [bp-1000h] BYREF

  immedok((WINDOW *)dword_7B430, 1);
  strcpy(v13, "Input server details.\n");
  sub_18BC0(v13);
  v2 = sub_25FDC("URL");
  v3 = v2;
  if ( *v2 == 45 && v2[1] == 49 && (v5 = (char *)(unsigned __int8)v2[2], !v2[2])
    || (v4 = sub_25FDC("Username"), v5 = v4, *v4 == 45) && v4[1] == 49 && !v4[2] )
  {
    immedok((WINDOW *)dword_7B430, 0);
    v7 = 0;
LABEL_19:
    v11 = 0;
    free(v3);
    free(v5);
    free(v7);
    return v11;
  }
  v6 = sub_25FDC("Password");
  v7 = v6;
  if ( *v6 == 45 && v6[1] == 49 && !v6[2] )
  {
    free(v6);
    v7 = calloc(1u, 1u);
  }
  v8 = sub_17A3C();
  if ( !sub_1557C((int)v8, v3) && strncmp(v3, "http://", 7u) && strncmp(v3, "https://", 8u) )
  {
    v9 = (char *)malloc(0x100u);
    v10 = v9;
    if ( !v9 )
    {
      strcpy(v13, "Failed to malloc httpinput");
      sub_38730(3, v13, 1);
      sub_16CA8(1);
    }
    strcpy(v9, "http://");
    strncat(v9, v3, 0xF8u);
    free(v3);
    v3 = v10;
  }
  v11 = sub_26BCC((int)v8, a1, v3, v5, (const char *)v7);
  immedok((WINDOW *)dword_7B430, 0);
  if ( !v11 )
    goto LABEL_19;
  return v11;
}
// 7B430: using guessed type int dword_7B430;

//----- (00026F50) --------------------------------------------------------
void sub_26F50()
{
  int v0; // r9
  char *v1; // r3
  const char *v2; // lr
  int v3; // r0
  int v4; // r0
  int v5; // r11
  int v6; // r11
  int v7; // r3
  const char *v8; // r3
  char *v9; // r11
  int i; // r9
  const char *v11; // t1
  int v12; // r3
  unsigned int v13; // r0
  int v14; // r9
  int v15; // r0
  int v16; // r9
  int v17; // r0
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // lr
  int v23; // r1
  int v24; // r0
  int v25; // r0
  int v26; // r11
  int v27; // r0
  int v28; // r9
  int v29; // r11
  int v30; // r0
  int v31; // r9
  int v32; // r2
  const char *v33; // r2
  const char *v34; // r3
  __int64 v35; // r10
  __int64 v36; // r2
  int v37; // r1
  double v38; // d8
  double v39; // r0
  int v40; // r3
  unsigned int v41; // [sp+10h] [bp-101Ch]
  unsigned int v42; // [sp+14h] [bp-1018h]
  char s1; // [sp+27h] [bp-1005h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  byte_7BAC8 = 1;
  immedok((WINDOW *)dword_7B430, 1);
  sub_18AD8();
  v0 = 0;
LABEL_2:
  while ( 2 )
  {
    while ( v0 < dword_7B198 )
    {
LABEL_23:
      v6 = *(_DWORD *)(dword_7B438 + 4 * v0);
      if ( v6 == sub_1DA58() )
        wattr_on((WINDOW *)dword_7B430, 0x200000u, 0);
      if ( *(_DWORD *)(v6 + 132) != 1 )
        wattr_on((WINDOW *)dword_7B430, 0x100000u, 0);
      snprintf(s, 0x1000u, "%d: ", *(_DWORD *)v6);
      sub_18BC0(s);
      v7 = *(_DWORD *)(v6 + 132);
      if ( v7 == 1 )
      {
        strcpy(s, "Enabled ");
        sub_18BC0(s);
      }
      else if ( v7 )
      {
        if ( v7 == 2 )
        {
          strcpy(s, "Rejecting ");
          sub_18BC0(s);
        }
      }
      else
      {
        strcpy(s, "Disabled ");
        sub_18BC0(s);
      }
      ++v0;
      v8 = "Alive";
      if ( *(_BYTE *)(v6 + 129) )
        v8 = "Dead";
      snprintf(
        s,
        0x1000u,
        "%s Quota %d Prio %d: %s  User:%s\n",
        v8,
        *(_DWORD *)(v6 + 56),
        *(_DWORD *)(v6 + 4),
        *(const char **)(v6 + 196),
        *(const char **)(v6 + 204));
      sub_18BC0(s);
      wattr_off((WINDOW *)dword_7B430, 0x300000u, 0);
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              snprintf(
                s,
                0x1000u,
                "\nCurrent pool management strategy: %s\n",
                (const char *)dword_755F0[dword_76EFC + 520]);
              sub_18BC0(s);
              if ( dword_76EFC == 2 )
              {
                snprintf(s, 0x1000u, "Set to rotate every %d minutes\n", dword_7B558);
                sub_18BC0(s);
              }
              v1 = "disabled";
              if ( byte_7B625 )
                v1 = "enabled";
              snprintf(s, 0x1000u, "[F]ailover only %s\n", v1);
              sub_18BC0(s);
              strcpy(s, "Pool [A]dd [R]emove [D]isable [E]nable [Q]uota change\n");
              sub_18BC0(s);
              strcpy(s, "[C]hange management strategy [S]witch pool [I]nformation\n");
              sub_18BC0(s);
              strcpy(s, "Or press any other key to continue\n");
              sub_18BC0(s);
              sub_18B44();
              s1 = wgetch((WINDOW *)stdscr);
              if ( !strncasecmp(&s1, "a", 1u) )
              {
                v0 = 0;
                sub_26D10(1);
                goto LABEL_2;
              }
              if ( strncasecmp(&s1, "r", 1u) )
                break;
              if ( dword_7B198 <= 1 )
              {
                v2 = "Cannot remove last pool";
                goto LABEL_47;
              }
              v3 = sub_260D0("Select pool number");
              if ( v3 >= 0 && v3 < dword_7B198 )
              {
                v26 = *(_DWORD *)(dword_7B438 + 4 * v3);
                if ( v26 == sub_1DA58() )
                {
                  sub_19BF8(0);
                  if ( v26 != sub_1DA58() )
                  {
LABEL_82:
                    v40 = *(_DWORD *)(v26 + 132);
                    v0 = 0;
                    *(_DWORD *)(v26 + 132) = 0;
                    if ( v40 == 1 )
                      --dword_7B5E4;
                    sub_15AC8(v26);
                    goto LABEL_2;
                  }
                }
                else if ( v26 != sub_1DA58() )
                {
                  goto LABEL_82;
                }
                strcpy(s, "Unable to remove pool due to activity\n");
                sub_18BC0(s);
              }
              else
              {
LABEL_13:
                strcpy(s, "Invalid selection\n");
                sub_18BC0(s);
              }
            }
            if ( !strncasecmp(&s1, "s", 1u) )
            {
              v24 = sub_260D0("Select pool number");
              if ( v24 >= 0 && v24 < dword_7B198 )
              {
                v25 = *(_DWORD *)(dword_7B438 + 4 * v24);
                if ( *(_DWORD *)(v25 + 132) != 1 )
                {
                  *(_DWORD *)(v25 + 132) = 1;
                  ++dword_7B5E4;
                }
                goto LABEL_52;
              }
              goto LABEL_13;
            }
            if ( strncasecmp(&s1, "d", 1u) )
              break;
            if ( dword_7B5E4 > 1 )
            {
              v4 = sub_260D0("Select pool number");
              if ( v4 < 0 || v4 >= dword_7B198 )
                goto LABEL_13;
              v5 = *(_DWORD *)(dword_7B438 + 4 * v4);
              if ( *(_DWORD *)(v5 + 132) == 1 )
                --dword_7B5E4;
              v0 = 0;
              *(_DWORD *)(v5 + 132) = 0;
              if ( v5 == sub_1DA58() )
              {
                sub_19BF8(0);
                goto LABEL_2;
              }
              goto LABEL_22;
            }
            strcpy(s, "Cannot disable last pool");
            sub_18BC0(s);
          }
          if ( strncasecmp(&s1, "e", 1u) )
            break;
          v27 = sub_260D0("Select pool number");
          if ( v27 < 0 || v27 >= dword_7B198 )
            goto LABEL_13;
          v28 = *(_DWORD *)(dword_7B438 + 4 * v27);
          if ( *(_DWORD *)(v28 + 132) != 1 )
          {
            *(_DWORD *)(v28 + 132) = 1;
            ++dword_7B5E4;
          }
          v29 = *(_DWORD *)(v28 + 4);
          if ( v29 < *(_DWORD *)(sub_1DA58() + 4) )
          {
            v25 = v28;
LABEL_52:
            v0 = 0;
            sub_19BF8(v25);
            goto LABEL_2;
          }
LABEL_22:
          v0 = 0;
          if ( dword_7B198 > 0 )
            goto LABEL_23;
        }
        if ( !strncasecmp(&s1, "c", 1u) )
        {
          v9 = &byte_75E0C;
          for ( i = 0; i != 5; ++i )
          {
            v11 = (const char *)*((_DWORD *)v9 + 1);
            v9 += 4;
            v12 = i;
            snprintf(s, 0x1000u, "%d: %s\n", v12, v11);
            sub_18BC0(s);
          }
          v13 = sub_260D0("Select strategy number type");
          v14 = v13;
          if ( v13 <= 4 )
          {
            if ( v13 != 2
              || (dword_7B558 = sub_260D0("Select interval in minutes"), (unsigned int)dword_7B558 <= 0x270F) )
            {
              dword_76EFC = v14;
              v0 = 0;
              sub_19BF8(0);
              goto LABEL_2;
            }
            dword_7B558 = 0;
          }
          goto LABEL_13;
        }
        if ( strncasecmp(&s1, "i", 1u) )
          break;
        v30 = sub_260D0("Select pool number");
        if ( v30 < 0 || v30 >= dword_7B198 )
          goto LABEL_13;
        v31 = *(_DWORD *)(dword_7B438 + 4 * v30);
        if ( sub_17FE4() )
        {
          snprintf(s, 0x1000u, "Pool: %s\n", *(const char **)(v31 + 196));
          sub_15890(s);
          v32 = *(_DWORD *)(v31 + 32);
          if ( v32 )
          {
            if ( v32 > 1 )
              v33 = "S";
            else
              v33 = "";
            snprintf(s, 0x1000u, "SOLVED %d BLOCK%s!\n", *(_DWORD *)(v31 + 32), v33);
            sub_15890(s);
          }
          if ( !*(_BYTE *)(v31 + 664) )
          {
            v34 = "Does not have";
            if ( *(_DWORD *)(v31 + 140) )
              v34 = "Has";
            snprintf(s, 0x1000u, "%s own long-poll support\n", v34);
            sub_15890(s);
          }
          snprintf(s, 0x1000u, " Queued work requests: %d\n", *(_DWORD *)(v31 + 148));
          sub_15890(s);
          snprintf(s, 0x1000u, " Share submissions: %lld\n", *(_QWORD *)(v31 + 8) + *(_QWORD *)(v31 + 16));
          sub_15890(s);
          snprintf(s, 0x1000u, " Accepted shares: %lld\n", *(_QWORD *)(v31 + 8));
          sub_15890(s);
          snprintf(s, 0x1000u, " Rejected shares: %lld\n", *(_QWORD *)(v31 + 16));
          sub_15890(s);
          snprintf(s, 0x1000u, " Accepted difficulty shares: %1.f\n", *(double *)(v31 + 104));
          sub_15890(s);
          snprintf(s, 0x1000u, " Rejected difficulty shares: %1.f\n", *(double *)(v31 + 112));
          sub_15890(s);
          v35 = *(_QWORD *)(v31 + 8);
          v36 = *(_QWORD *)(v31 + 16);
          if ( v35 || v36 )
          {
            v42 = *(_DWORD *)(v31 + 16);
            v41 = *(_DWORD *)(v31 + 20);
            LODWORD(v38) = sub_5CB64(100 * v36);
            HIDWORD(v38) = v37;
            LODWORD(v39) = sub_5CB64(v35 + __PAIR64__(v41, v42));
            snprintf(s, 0x1000u, " Reject ratio: %.1f%%\n", v38 / v39);
            sub_15890(s);
          }
          snprintf(s, 0x1000u, " Items worked on: %d\n", *(_DWORD *)(v31 + 68));
          sub_15890(s);
          snprintf(s, 0x1000u, " Discarded work due to new blocks: %d\n", *(_DWORD *)(v31 + 156));
          sub_15890(s);
          snprintf(s, 0x1000u, " Stale submissions discarded due to new blocks: %d\n", *(_DWORD *)(v31 + 152));
          sub_15890(s);
          snprintf(s, 0x1000u, " Unable to get work from server occasions: %d\n", *(_DWORD *)(v31 + 160));
          sub_15890(s);
          snprintf(s, 0x1000u, " Submitting work remotely delay occasions: %d\n\n", *(_DWORD *)(v31 + 164));
          sub_15890(s);
          if ( pthread_mutex_unlock(&mutex) )
            sub_B5C4("unlock_curses", 2930);
          off_75ED8();
        }
      }
      if ( strncasecmp(&s1, "q", 1u) )
        break;
      v15 = sub_260D0("Select pool number");
      if ( v15 < 0 || v15 >= dword_7B198 )
        goto LABEL_13;
      v16 = *(_DWORD *)(dword_7B438 + 4 * v15);
      v17 = sub_260D0("Set quota");
      if ( v17 >= 0 )
      {
        *(_DWORD *)(v16 + 56) = v17;
        v0 = 0;
        sub_152E0();
        goto LABEL_2;
      }
      v2 = "Invalid negative quota\n";
LABEL_47:
      v18 = *(_DWORD *)v2;
      v19 = *((_DWORD *)v2 + 1);
      v20 = *((_DWORD *)v2 + 2);
      v21 = *((_DWORD *)v2 + 3);
      v22 = v2 + 16;
      *(_DWORD *)s = v18;
      *(_DWORD *)&s[4] = v19;
      *(_DWORD *)&s[8] = v20;
      *(_DWORD *)&s[12] = v21;
      v23 = v22[1];
      *(_DWORD *)&s[16] = *v22;
      *(_DWORD *)&s[20] = v23;
      sub_18BC0(s);
    }
    if ( !strncasecmp(&s1, "f", 1u) )
    {
      v0 = 0;
      byte_7B625 ^= 1u;
      continue;
    }
    break;
  }
  sub_18AD8();
  immedok((WINDOW *)dword_7B430, 0);
  byte_7BAC8 = 0;
}
// 27768: variable 'v37' is possibly undefined
// 2778C: variable 'v39' is possibly undefined
// 755F0: using guessed type int dword_755F0[];
// 75E0C: using guessed type char byte_75E0C;
// 75ED8: using guessed type int (*off_75ED8)();
// 76BC0: using guessed type int stdscr;
// 76EFC: using guessed type int dword_76EFC;
// 7B198: using guessed type int dword_7B198;
// 7B430: using guessed type int dword_7B430;
// 7B438: using guessed type int dword_7B438;
// 7B558: using guessed type int dword_7B558;
// 7B5E4: using guessed type int dword_7B5E4;
// 7B625: using guessed type char byte_7B625;
// 7BAC8: using guessed type char byte_7BAC8;

//----- (00027A98) --------------------------------------------------------
int sub_27A98()
{
  char s1[5]; // [sp+7h] [bp-5h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2F0B4("Input");
  if ( byte_77018 )
  {
    do
    {
      while ( 1 )
      {
        s1[0] = wgetch((WINDOW *)stdscr);
        if ( !strncasecmp(s1, "q", 1u) )
          sub_178F8();
        if ( strncasecmp(s1, "d", 1u) )
          break;
        sub_260FC();
        if ( byte_7BB18 )
          goto LABEL_10;
      }
      if ( !strncasecmp(s1, "p", 1u) )
      {
        sub_26F50();
      }
      else if ( !strncasecmp(s1, "s", 1u) )
      {
        sub_267B0();
      }
    }
    while ( !byte_7BB18 );
LABEL_10:
    sub_19ADC();
  }
  return 0;
}
// 76BC0: using guessed type int stdscr;
// 77018: using guessed type char byte_77018;
// 7BB18: using guessed type char byte_7BB18;

//----- (00027BA0) --------------------------------------------------------
int sub_27BA0()
{
  int maxy; // r6
  WINDOW *v1; // r0
  int maxx; // r1

  if ( pthread_mutex_lock(&mutex) )
    sub_B414("lock_curses", 2935);
  if ( byte_77018 )
  {
    if ( !pthread_mutex_unlock(&mutex) )
      return off_75ED8();
LABEL_14:
    sub_B5C4("unlock_curses", 2930);
  }
  v1 = initscr();
  dword_7BC90 = (int)v1;
  if ( v1 )
    maxx = v1->_maxx;
  else
    maxy = -1;
  if ( v1 )
    maxy = v1->_maxy;
  else
    maxx = maxy;
  if ( v1 )
  {
    ++maxx;
    ++maxy;
  }
  dword_7B7C0 = (int)newwin(dword_7701C, maxx, 0, 0);
  leaveok((WINDOW *)dword_7B7C0, 1);
  dword_7B430 = (int)newwin(maxy - dword_77024, 0, dword_77024, 0);
  idlok((WINDOW *)dword_7B430, 1);
  scrollok((WINDOW *)dword_7B430, 1);
  leaveok((WINDOW *)dword_7B430, 1);
  cbreak();
  noecho();
  byte_77018 = 1;
  dword_77020 = dword_7701C;
  if ( pthread_mutex_unlock(&mutex) )
    goto LABEL_14;
  return off_75ED8();
}
// 27BEC: variable 'maxy' is possibly undefined
// 27BF0: variable 'maxx' is possibly undefined
// 75ED8: using guessed type int (*off_75ED8)();
// 77018: using guessed type char byte_77018;
// 7701C: using guessed type int dword_7701C;
// 77020: using guessed type int dword_77020;
// 77024: using guessed type int dword_77024;
// 7B430: using guessed type int dword_7B430;
// 7B7C0: using guessed type int dword_7B7C0;
// 7BC90: using guessed type int dword_7BC90;

//----- (00027CD0) --------------------------------------------------------
int __fastcall sub_27CD0(int result)
{
  if ( !*(_DWORD *)(result + 12) )
    *(_DWORD *)(result + 12) = nullsub_8;
  if ( !*(_DWORD *)(result + 16) )
    *(_DWORD *)(result + 16) = nullsub_3;
  if ( !*(_DWORD *)(result + 20) )
    *(_DWORD *)(result + 20) = nullsub_2;
  if ( !*(_DWORD *)(result + 24) )
    *(_DWORD *)(result + 24) = nullsub_4;
  if ( !*(_DWORD *)(result + 32) )
    *(_DWORD *)(result + 32) = sub_F7A0;
  if ( !*(_DWORD *)(result + 44) )
    *(_DWORD *)(result + 44) = sub_F7A8;
  if ( !*(_DWORD *)(result + 48) )
    *(_DWORD *)(result + 48) = sub_F7B0;
  if ( !*(_DWORD *)(result + 52) )
    *(_DWORD *)(result + 52) = sub_F7BC;
  if ( !*(_DWORD *)(result + 56) )
    *(_DWORD *)(result + 56) = sub_F7C4;
  if ( !*(_DWORD *)(result + 84) )
    *(_DWORD *)(result + 84) = nullsub_5;
  if ( !*(_DWORD *)(result + 88) )
    *(_DWORD *)(result + 88) = nullsub_6;
  if ( !*(_DWORD *)(result + 92) )
    *(_DWORD *)(result + 92) = nullsub_7;
  if ( !*(_DWORD *)(result + 60) )
    *(_DWORD *)(result + 60) = sub_24DB0;
  if ( !*(_DWORD *)(result + 76) )
    *(_DWORD *)(result + 76) = nullsub_3;
  if ( !*(_DWORD *)(result + 80) )
    *(_DWORD *)(result + 80) = nullsub_3;
  if ( !*(_DWORD *)(result + 72) )
    *(_DWORD *)(result + 72) = sub_F7A0;
  if ( !*(_DWORD *)(result + 96) )
    *(_DWORD *)(result + 96) = nullsub_3;
  if ( *(double *)(result + 104) == 0.0 )
    *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  return result;
}
// F794: using guessed type int nullsub_3();
// F798: using guessed type int nullsub_2();
// F79C: using guessed type int nullsub_4();
// F7CC: using guessed type int nullsub_5();
// F7D0: using guessed type int nullsub_6();
// F7D4: using guessed type int nullsub_7();
// F7D8: using guessed type int nullsub_8();

//----- (00027F10) --------------------------------------------------------
int __fastcall sub_27F10(pthread_rwlock_t *a1)
{
  int v2; // r2
  int v3; // r3
  unsigned int v4; // r1
  bool v5; // zf
  int *v6; // r3
  unsigned int nr_writers_queued; // r2
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_7B700) )
    sub_B480("enable_device", 10388);
  v2 = dword_7B628;
  v3 = dword_78720++;
  a1->__lock = v3;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  if ( pthread_rwlock_unlock(&stru_7B700) )
    sub_B630("enable_device", 10390);
  off_75ED8();
  v5 = byte_7B7D0 == 0;
  if ( byte_7B7D0 )
    v6 = (int *)dword_78724;
  else
    v6 = &dword_7BB6C;
  if ( byte_7B7D0 )
  {
    nr_writers_queued = a1[4].__nr_writers_queued;
  }
  else
  {
    v4 = a1[4].__nr_writers_queued;
    nr_writers_queued = *v6;
  }
  if ( byte_7B7D0 )
    v6 = (int *)((char *)v6 + nr_writers_queued);
  else
    *v6 = v4 + nr_writers_queued;
  if ( !v5 )
    dword_78724 = (int)v6;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    sub_B558("enable_device", 10397);
  a1[11].__lock = 0;
  return result;
}
// 27F90: variable 'v4' is possibly undefined
// 75ED8: using guessed type int (*off_75ED8)();
// 78720: using guessed type int dword_78720;
// 78724: using guessed type int dword_78724;
// 7B628: using guessed type int dword_7B628;
// 7B7D0: using guessed type char byte_7B7D0;
// 7BB6C: using guessed type int dword_7BB6C;

//----- (00028008) --------------------------------------------------------
int __fastcall sub_28008(_DWORD *a1)
{
  int v1; // r4
  const char *v2; // r6
  size_t v3; // r0
  unsigned int v4; // lr
  int v5; // r1
  unsigned __int8 *v6; // r3
  int v7; // r12
  size_t v8; // r5
  unsigned int i; // r2
  unsigned int v10; // lr
  int v11; // r0
  int v12; // r10
  int v13; // r8
  int v14; // r7
  unsigned int v15; // r1
  int v16; // r12
  unsigned int v17; // r0
  unsigned int v18; // r1
  int v19; // r12
  unsigned int v20; // r0
  unsigned int v21; // r1
  size_t v22; // r1
  _DWORD *v23; // r8
  int v24; // r0
  unsigned int v25; // r2
  unsigned int v26; // r3
  int v27; // r1
  unsigned int v28; // r2
  unsigned int v29; // r3
  int v30; // r1
  int v31; // r7
  int v32; // r3
  _DWORD *v33; // r5
  int v34; // r0
  char *v35; // r6
  _DWORD *v36; // r7
  int v37; // r9
  int v38; // r3
  unsigned int v39; // r10
  size_t v40; // r0
  unsigned int v41; // r11
  unsigned __int8 *v42; // r7
  int v43; // r8
  int v44; // r1
  int v45; // r12
  int v46; // r2
  int v47; // r0
  unsigned int v48; // r3
  unsigned int v49; // r10
  int v50; // r8
  unsigned int v51; // r2
  unsigned int v52; // r3
  int v53; // r1
  unsigned int v54; // r2
  unsigned int v55; // r3
  size_t v56; // r9
  int v57; // r3
  int v58; // r3
  int v59; // r2
  int v60; // r2
  int result; // r0
  int v62; // r1
  unsigned int v63; // r2
  unsigned int v64; // r3
  int v65; // r1
  unsigned int v66; // r2
  unsigned int v67; // r3
  unsigned int v68; // r1
  unsigned int v69; // r3
  _DWORD *v70; // r2
  int v71; // r3
  int v72; // r2
  int v73; // r1
  int v74; // r4
  size_t v75; // r6
  _DWORD *v76; // r0
  _DWORD *v77; // r7
  int v78; // r8
  int v79; // r2
  unsigned int v80; // r6
  _DWORD *v81; // r11
  _DWORD *v82; // r4
  _DWORD *v83; // r5
  int v84; // r6
  char *v85; // r9
  unsigned int v86; // r3
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r1
  unsigned int v90; // r2
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  int v94; // r0
  size_t v95; // r0
  _DWORD *v96; // r0
  void *v97; // r0
  unsigned int j; // [sp+4h] [bp-8h]

  v1 = dword_78728;
  if ( dword_78728 )
  {
    v2 = *(const char **)(a1[1] + 8);
    v3 = strlen(v2);
    v4 = -1640531527;
    v5 = -17973521;
    v6 = *(unsigned __int8 **)(a1[1] + 8);
    v7 = -1640531527;
    v8 = v3;
    for ( i = v3; i > 0xB; v5 = (v21 - v7 - v4) ^ (v4 >> 15) )
    {
      i -= 12;
      v10 = (v6[6] << 16) + (v6[5] << 8) + v6[4] + (v6[7] << 24) + v4;
      v11 = (v6[2] << 16) + (v6[1] << 8) + *v6;
      v12 = v6[3];
      v13 = v6[11];
      v14 = (v6[10] << 16) + (v6[9] << 8) + v6[8];
      v6 += 12;
      v15 = v14 + (v13 << 24) + v5;
      v16 = (v11 + (v12 << 24) - v10 - v15 + v7) ^ (v15 >> 13);
      v17 = (v10 - v15 - v16) ^ (v16 << 8);
      v18 = (v15 - v16 - v17) ^ (v17 >> 13);
      v19 = (v16 - v17 - v18) ^ (v18 >> 12);
      v20 = (v17 - v18 - v19) ^ (v19 << 16);
      v21 = (v18 - v19 - v20) ^ (v20 >> 5);
      v7 = (v19 - v20 - v21) ^ (v21 >> 3);
      v4 = (v20 - v21 - v7) ^ (v7 << 10);
    }
    v22 = v5 + v8;
    switch ( i )
    {
      case 1u:
        goto LABEL_15;
      case 2u:
        goto LABEL_14;
      case 3u:
        goto LABEL_13;
      case 4u:
        goto LABEL_12;
      case 5u:
        goto LABEL_11;
      case 6u:
        goto LABEL_10;
      case 7u:
        goto LABEL_9;
      case 8u:
        goto LABEL_8;
      case 9u:
        goto LABEL_7;
      case 0xAu:
        goto LABEL_6;
      case 0xBu:
        v22 += v6[10] << 24;
LABEL_6:
        v22 += v6[9] << 16;
LABEL_7:
        v22 += v6[8] << 8;
LABEL_8:
        v4 += v6[7] << 24;
LABEL_9:
        v4 += v6[6] << 16;
LABEL_10:
        v4 += v6[5] << 8;
LABEL_11:
        v4 += v6[4];
LABEL_12:
        v7 += v6[3] << 24;
LABEL_13:
        v7 += v6[2] << 16;
LABEL_14:
        v7 += v6[1] << 8;
LABEL_15:
        v7 += *v6;
        break;
      default:
        break;
    }
    v23 = *(_DWORD **)(dword_78728 + 8);
    v24 = (v7 - v4 - v22) ^ (v22 >> 13);
    v25 = (v4 - v22 - v24) ^ (v24 << 8);
    v26 = (v22 - v24 - v25) ^ (v25 >> 13);
    v27 = (v24 - v25 - v26) ^ (v26 >> 12);
    v28 = (v25 - v26 - v27) ^ (v27 << 16);
    v29 = (v26 - v27 - v28) ^ (v28 >> 5);
    v30 = (v27 - v28 - v29) ^ (v29 >> 3);
    v31 = *(_DWORD *)(*v23
                    + 12
                    * (((v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10)))
                      ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15))
                     & (v23[1] - 1)));
    if ( v31 )
      v31 -= v23[5];
    while ( v31 )
    {
      if ( v8 == *(_DWORD *)(v31 + 32) && !memcmp(*(const void **)(v31 + 28), v2, v8) )
      {
        v57 = *(_DWORD *)(v31 + 4) + 1;
        *(_DWORD *)(v31 + 4) = v57;
        a1[2] = v57;
        goto LABEL_29;
      }
      v32 = *(_DWORD *)(v31 + 24);
      if ( !v32 )
        break;
      v31 = v32 - v23[5];
    }
    v33 = malloc(0x28u);
    v34 = *(_DWORD *)v2;
    v33[1] = 0;
    v35 = (char *)(v33 + 2);
    *v33 = v34;
    a1[2] = 0;
    v33[4] = 0;
    v33[7] = v33;
    v33[8] = strlen((const char *)v33);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) + 8) = v33;
    v33[3] = *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) - *(_DWORD *)(*(_DWORD *)(v1 + 8) + 20);
    *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) = v33 + 2;
    v36 = *(_DWORD **)(v1 + 8);
  }
  else
  {
    v33 = malloc(0x28u);
    v94 = **(_DWORD **)(a1[1] + 8);
    v33[1] = 0;
    *v33 = v94;
    a1[2] = 0;
    v33[4] = 0;
    v33[7] = v33;
    v95 = strlen((const char *)v33);
    v33[3] = 0;
    dword_78728 = (int)v33;
    v33[8] = v95;
    v96 = malloc(0x2Cu);
    v36 = v96;
    v33[2] = v96;
    if ( !v96 )
      goto LABEL_81;
    *v96 = 0;
    v96[3] = 0;
    v35 = (char *)(v33 + 2);
    v96[4] = 0;
    v96[5] = 0;
    v96[6] = 0;
    v96[7] = 0;
    v96[8] = 0;
    v96[9] = 0;
    v96[10] = 0;
    v96[4] = v33 + 2;
    v96[1] = 32;
    v96[2] = 5;
    v96[5] = 8;
    v97 = malloc(0x180u);
    *v36 = v97;
    if ( !v97 )
      goto LABEL_81;
    memset(v97, 0, 0x180u);
    v1 = (int)v33;
    v36[10] = -1609490463;
  }
  v37 = -17973521;
  ++v36[3];
  v38 = *(_DWORD *)(v1 + 8);
  v39 = -1640531527;
  v33[9] = -17973521;
  v33[2] = v38;
  v40 = strlen((const char *)v33);
  v41 = v40;
  if ( v40 <= 0xB )
  {
    v43 = -1640531527;
    v42 = (unsigned __int8 *)v33;
  }
  else
  {
    v42 = (unsigned __int8 *)v33;
    v43 = -1640531527;
    do
    {
      v41 -= 12;
      v44 = (v42[2] << 16) + (v42[1] << 8) + *v42;
      v45 = v42[3];
      v46 = (v42[6] << 16) + (v42[5] << 8) + v42[4];
      v47 = v42[7];
      v48 = (v42[10] << 16) + (v42[9] << 8) + v42[8] + (v42[11] << 24) + v37;
      v42 += 12;
      v49 = v46 + (v47 << 24) + v39;
      v50 = (v44 + (v45 << 24) - v48 - v49 + v43) ^ (v48 >> 13);
      v51 = (v49 - v48 - v50) ^ (v50 << 8);
      v52 = (v48 - v50 - v51) ^ (v51 >> 13);
      v53 = (v50 - v51 - v52) ^ (v52 >> 12);
      v54 = (v51 - v52 - v53) ^ (v53 << 16);
      v55 = (v52 - v53 - v54) ^ (v54 >> 5);
      v43 = (v53 - v54 - v55) ^ (v55 >> 3);
      v39 = (v54 - v55 - v43) ^ (v43 << 10);
      v37 = (v55 - v43 - v39) ^ (v39 >> 15);
      v33[9] = v37;
    }
    while ( v41 > 0xB );
    v40 = strlen((const char *)v33);
  }
  v56 = v40 + v37;
  v33[9] = v56;
  switch ( v41 )
  {
    case 1u:
      goto LABEL_49;
    case 2u:
      goto LABEL_48;
    case 3u:
      goto LABEL_47;
    case 4u:
      goto LABEL_46;
    case 5u:
      goto LABEL_45;
    case 6u:
      goto LABEL_44;
    case 7u:
      goto LABEL_43;
    case 8u:
      goto LABEL_42;
    case 9u:
      goto LABEL_41;
    case 0xAu:
      goto LABEL_40;
    case 0xBu:
      v56 += v42[10] << 24;
      v33[9] = v56;
LABEL_40:
      v56 += v42[9] << 16;
      v33[9] = v56;
LABEL_41:
      v56 += v42[8] << 8;
      v33[9] = v56;
LABEL_42:
      v39 += v42[7] << 24;
LABEL_43:
      v39 += v42[6] << 16;
LABEL_44:
      v39 += v42[5] << 8;
LABEL_45:
      v39 += v42[4];
LABEL_46:
      v43 += v42[3] << 24;
LABEL_47:
      v43 += v42[2] << 16;
LABEL_48:
      v43 += v42[1] << 8;
LABEL_49:
      v43 += *v42;
      break;
    default:
      break;
  }
  v62 = (v43 - v39 - v56) ^ (v56 >> 13);
  v63 = (v39 - v56 - v62) ^ (v62 << 8);
  v64 = (v56 - v62 - v63) ^ (v63 >> 13);
  v65 = (v62 - v63 - v64) ^ (v64 >> 12);
  v66 = (v63 - v64 - v65) ^ (v65 << 16);
  v67 = (v64 - v65 - v66) ^ (v66 >> 5);
  v68 = v65 - v66 - v67;
  v69 = (v67 - (v68 ^ (v67 >> 3)) - ((v66 - v67 - (v68 ^ (v67 >> 3))) ^ ((v68 ^ (v67 >> 3)) << 10)))
      ^ (((v66 - v67 - (v68 ^ (v67 >> 3))) ^ ((v68 ^ (v67 >> 3)) << 10)) >> 15);
  v33[9] = v69;
  v70 = *(_DWORD **)(v1 + 8);
  v71 = 12 * (v69 & (v70[1] - 1));
  ++*(_DWORD *)(*v70 + v71 + 4);
  v72 = *(_DWORD *)(**(_DWORD **)(v1 + 8) + v71);
  v33[5] = 0;
  v33[6] = v72;
  v73 = **(_DWORD **)(v1 + 8) + v71;
  if ( *(_DWORD *)v73 )
  {
    *(_DWORD *)(*(_DWORD *)v73 + 12) = v35;
    v73 = **(_DWORD **)(v1 + 8) + v71;
  }
  *(_DWORD *)v73 = v35;
  if ( *(_DWORD *)(**(_DWORD **)(v1 + 8) + v71 + 4) >= (unsigned int)(10
                                                                    * (*(_DWORD *)(**(_DWORD **)(v1 + 8) + v71 + 8) + 1)) )
  {
    v74 = v33[2];
    if ( *(_DWORD *)(v74 + 36) != 1 )
    {
      v75 = 24 * *(_DWORD *)(v74 + 4);
      v76 = malloc(v75);
      v77 = v76;
      if ( v76 )
      {
        memset(v76, 0, v75);
        v78 = 0;
        *(_DWORD *)(v74 + 24) = (((2 * *(_DWORD *)(v74 + 4) - 1) & *(_DWORD *)(v74 + 12)) != 0)
                              + (*(_DWORD *)(v74 + 12) >> (*(_BYTE *)(v74 + 8) + 1));
        *(_DWORD *)(v33[2] + 28) = 0;
        v79 = v33[2];
        v80 = *(_DWORD *)(v79 + 4);
        if ( v80 )
        {
          v81 = v33;
          for ( j = 0; j < v80; ++j )
          {
            v82 = *(_DWORD **)(*(_DWORD *)v79 + v78);
            if ( v82 )
            {
              while ( 1 )
              {
                v83 = (_DWORD *)v82[4];
                v84 = 3 * ((2 * v80 - 1) & v82[7]);
                v85 = (char *)&v77[v84];
                v86 = *((_DWORD *)v85 + 1) + 1;
                *((_DWORD *)v85 + 1) = v86;
                if ( v86 > *(_DWORD *)(v79 + 24) )
                {
                  ++*(_DWORD *)(v79 + 28);
                  *((_DWORD *)v85 + 2) = *((_DWORD *)v85 + 1) / *(_DWORD *)(v81[2] + 24);
                }
                v82[3] = 0;
                v82[4] = v77[v84];
                v87 = v77[v84];
                if ( v87 )
                  *(_DWORD *)(v87 + 12) = v82;
                v77[v84] = v82;
                v79 = v81[2];
                if ( !v83 )
                  break;
                v80 = *(_DWORD *)(v79 + 4);
                v82 = v83;
              }
              v80 = *(_DWORD *)(v79 + 4);
            }
            v78 += 12;
          }
          v33 = v81;
        }
        free(*(void **)v79);
        *(_DWORD *)(v33[2] + 4) *= 2;
        ++*(_DWORD *)(v33[2] + 8);
        *(_DWORD *)v33[2] = v77;
        v88 = (_DWORD *)v33[2];
        v89 = v88[3];
        v90 = v88[7];
        v91 = v90 > v89 >> 1;
        if ( v90 <= v89 >> 1 )
          v92 = 0;
        else
          v92 = v88[8];
        if ( v91 )
          ++v92;
        v88[8] = v92;
        v93 = v33[2];
        if ( *(_DWORD *)(v93 + 32) > 1u )
          *(_DWORD *)(v93 + 36) = 1;
        goto LABEL_29;
      }
LABEL_81:
      exit(-1);
    }
  }
LABEL_29:
  if ( pthread_rwlock_wrlock(&stru_7B700) )
    sub_B480("add_cgpu", 10444);
  dword_7B628 = (int)realloc((void *)dword_7B628, 4 * (dword_7B720 + dword_7872C + 2));
  if ( pthread_rwlock_unlock(&stru_7B700) )
    sub_B630("add_cgpu", 10446);
  off_75ED8();
  if ( pthread_mutex_lock(&stru_7AD4C) )
    sub_B414("add_cgpu", 10448);
  a1[58] = time(0);
  if ( pthread_mutex_unlock(&stru_7AD4C) )
    sub_B5C4("add_cgpu", 10450);
  off_75ED8();
  if ( byte_7B7D0 )
  {
    v58 = dword_7872C + dword_7B720;
    ++dword_7872C;
    *(_DWORD *)(dword_7B628 + 4 * v58) = a1;
    v59 = dword_7B720;
  }
  else
  {
    v59 = dword_7B720 + 1;
    *(_DWORD *)(dword_7B628 + 4 * dword_7B720) = a1;
    dword_7B720 = v59;
  }
  v60 = v59 - dword_7B8B0;
  result = 1;
  if ( v60 > dword_7702C )
    dword_7702C = v60;
  return result;
}
// 2815C: control flows out of bounds to 28160
// 2844C: control flows out of bounds to 28450
// 75ED8: using guessed type int (*off_75ED8)();
// 7702C: using guessed type int dword_7702C;
// 78728: using guessed type int dword_78728;
// 7872C: using guessed type int dword_7872C;
// 7B628: using guessed type int dword_7B628;
// 7B720: using guessed type int dword_7B720;
// 7B7D0: using guessed type char byte_7B7D0;
// 7B8B0: using guessed type int dword_7B8B0;

//----- (00028AE0) --------------------------------------------------------
int sub_28AE0()
{
  return 0;
}

//----- (00028AE8) --------------------------------------------------------
int __fastcall sub_28AE8(int result)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(result + 616);
  if ( v1 )
    *v1 = 0;
  return result;
}

//----- (00028AFC) --------------------------------------------------------
bool __fastcall sub_28AFC(int a1, int a2)
{
  int v2; // lr
  fd_set *p_tv_usec; // r3
  int v4; // r0
  _DWORD *v5; // r4
  int v6; // r6
  int v7; // lr
  struct timeval timeout; // [sp+8h] [bp-88h] BYREF
  fd_set readfds; // [sp+10h] [bp-80h] BYREF
  _DWORD vars0[6]; // [sp+90h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 612);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( p_tv_usec != (fd_set *)&readfds.__fds_bits[31] );
  v4 = v2 + 1;
  v5 = &vars0[v2 / 32];
  v6 = v2 % 32;
  v7 = *(v5 - 32);
  timeout.tv_usec = 0;
  *(v5 - 32) = v7 | (1 << v6);
  timeout.tv_sec = a2 & ~(a2 >> 31);
  return select(v4, &readfds, 0, 0, &timeout) > 0;
}

//----- (00028B9C) --------------------------------------------------------
int __fastcall sub_28B9C(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return fcntl(a1, 4, v2);
}

//----- (00028BC4) --------------------------------------------------------
ssize_t __fastcall sub_28BC4(int a1)
{
  ssize_t result; // r0
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  result = recv(a1, buf, 1u, 0);
  if ( result != -1 )
    return buf[0];
  return result;
}

//----- (00028BEC) --------------------------------------------------------
int __fastcall sub_28BEC(const char **a1, int a2, int a3)
{
  const char *v5; // r3
  const char *v6; // r12
  size_t v7; // r0
  ssize_t v8; // r0
  int v9; // r3
  unsigned __int8 *v10; // r6
  unsigned __int8 v11; // r0
  char v13; // [sp+Fh] [bp-1405h] BYREF
  char s; // [sp+10h] [bp-1404h] BYREF
  char v15; // [sp+11h] [bp-1403h]
  char v16; // [sp+12h] [bp-1402h]
  unsigned __int8 v17; // [sp+13h] [bp-1401h] BYREF
  char v18[4080]; // [sp+410h] [bp-1004h] BYREF

  v5 = a1[156];
  v6 = a1[152];
  if ( a3 )
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, v6);
  else
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, v6, v5, v6);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v18, 0x1000u, "Sending proxy %s:%s - %s", a1[157], a1[158], &s);
    sub_38730(7, v18, 0);
  }
  v7 = strlen(&s);
  send(a2, &s, v7, 0);
  v8 = recv(a2, &s, 0xCu, 0);
  if ( v8 <= 0 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      return 0;
    snprintf(v18, 0x1000u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[157], a1[158]);
LABEL_22:
    sub_38730(4, v18, 0);
    return 0;
  }
  v9 = (unsigned __int8)byte_78E09;
  *(&s + v8) = 0;
  if ( v9 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v18, 0x1000u, "Received from proxy %s:%s - %s", a1[157], a1[158], &s);
    sub_38730(7, v18, 0);
  }
  if ( strcmp(&s, "HTTP/1.1 200") && strcmp(&s, "HTTP/1.0 200") )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      return 0;
    snprintf(v18, 0x1000u, "HTTP Error from proxy %s:%s - %s", a1[157], a1[158], &s);
    goto LABEL_22;
  }
  v10 = (unsigned __int8 *)&v13;
  while ( 1 )
  {
    v11 = sub_28BC4(a2);
    *++v10 = v11;
    if ( v11 == 255 )
      break;
    if ( v10 == &v17 )
    {
      while ( strncmp(&s, "\r\n\r\n", 4u) )
      {
        s = v15;
        v15 = v16;
        v16 = v17;
        v17 = sub_28BC4(a2);
        if ( v17 == 255 )
          goto LABEL_18;
      }
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        return 1;
      snprintf(v18, 0x1000u, "Success negotiating with %s:%s HTTP proxy", a1[157], a1[158]);
      sub_38730(7, v18, 0);
      return 1;
    }
  }
LABEL_18:
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(v18, 0x1000u, "Couldn't read HTTP byte from proxy %s:%s", a1[157], a1[158]);
    goto LABEL_22;
  }
  return 0;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00028FC8) --------------------------------------------------------
int __fastcall sub_28FC8(const char **a1, int a2, int a3)
{
  const char *v6; // r0
  __int16 v7; // kr00_2
  unsigned int v8; // r6
  int v10; // r4
  const char *v11; // r0
  const char *v12; // r10
  signed int v13; // r0
  size_t v14; // r8
  unsigned int v15; // r6
  struct addrinfo *v16; // [sp+8h] [bp-122Ch] BYREF
  int v17; // [sp+Ch] [bp-1228h] BYREF
  _BYTE buf[4]; // [sp+2Ch] [bp-1208h] BYREF
  char v19; // [sp+30h] [bp-1204h]
  char v20; // [sp+31h] [bp-1203h]
  char v21; // [sp+32h] [bp-1202h]
  char v22; // [sp+33h] [bp-1201h]
  char v23[8]; // [sp+34h] [bp-1200h] BYREF
  _BYTE v24[500]; // [sp+3Ch] [bp-11F8h] BYREF
  struct addrinfo s[126]; // [sp+230h] [bp-1004h] BYREF

  v6 = a1[152];
  buf[0] = 4;
  buf[1] = 1;
  v7 = strtol(v6, 0, 10);
  buf[2] = HIBYTE(v7);
  buf[3] = v7;
  strcpy(v23, "CGMINER");
  v8 = bswap32(inet_addr(a1[156]));
  if ( v8 != -1 )
    goto LABEL_2;
  s[0].ai_family = 2;
  s[0].ai_flags = 0;
  v11 = a1[156];
  s[0].ai_socktype = 0;
  s[0].ai_protocol = 0;
  v16 = (struct addrinfo *)&v17;
  memset(&s[0].ai_addrlen, 0, 16);
  if ( !getaddrinfo(v11, 0, s, &v16) )
  {
    v15 = *(_DWORD *)&v16->ai_addr->sa_data[2];
    freeaddrinfo(v16);
    v8 = bswap32(v15);
    if ( v8 != -1 )
    {
LABEL_2:
      v19 = HIBYTE(v8);
      v22 = v8;
      v20 = BYTE2(v8);
      v21 = BYTE1(v8);
      send(a2, buf, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_22:
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      return 0;
    snprintf((char *)s, 0x1000u, "Invalid IP address specified for socks4 proxy: %s", a1[156]);
    goto LABEL_8;
  }
  if ( !a3 )
    goto LABEL_22;
  v12 = a1[156];
  v19 = 0;
  v22 = 1;
  v20 = 0;
  v21 = 0;
  v13 = strlen(v12);
  if ( v13 >= 255 )
    v14 = 255;
  else
    v14 = v13;
  memcpy(v24, v12, v14);
  v24[v14] = 0;
  send(a2, buf, v14 + 17, 0);
LABEL_3:
  if ( sub_28BC4(a2) || sub_28BC4(a2) != 90 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      return 0;
    snprintf((char *)s, 0x1000u, "Bad response from %s:%s SOCKS4 server", a1[157], a1[158]);
LABEL_8:
    sub_38730(4, (const char *)s, 0);
    return 0;
  }
  v10 = 6;
  do
  {
    sub_28BC4(a2);
    --v10;
  }
  while ( v10 );
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0002926C) --------------------------------------------------------
int __fastcall sub_2926C(struct timespec *req)
{
  int result; // r0

  do
    result = clock_nanosleep(1, 1, req, 0);
  while ( result == 4 );
  return result;
}

//----- (00029294) --------------------------------------------------------
_DWORD *__fastcall sub_29294(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( a1 && *a1 == 1 && (unsigned int)sub_59FEC(a1) >= a2 && (v4 = sub_5A008(a1, a2)) != 0 && *v4 == 2 )
    return sub_5A178(v4);
  else
    return 0;
}

//----- (000292F4) --------------------------------------------------------
char *__fastcall sub_292F4(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)sub_29294(a1, a2);
  if ( result )
    return _strdup(result);
  return result;
}

//----- (0002930C) --------------------------------------------------------
int __fastcall sub_2930C(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (00029388) --------------------------------------------------------
int __fastcall sub_29388(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (00029404) --------------------------------------------------------
int __fastcall sub_29404(int a1, char *s, int a3)
{
  size_t v5; // r0
  signed int v6; // r10
  int v7; // r3
  int v8; // r5
  unsigned int v9; // r9
  _BYTE *v10; // r4
  int v11; // r8
  unsigned int v12; // r12
  int *v13; // r0
  _BYTE *v14; // r3
  ssize_t v15; // r0
  __int64 v16; // d16
  __int64 v18; // r2
  struct timeval timeout; // [sp+18h] [bp-8Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-84h] BYREF
  _BYTE v22[4]; // [sp+A0h] [bp-4h] BYREF

  v5 = strlen(s);
  v6 = a3 + 1;
  v7 = *(_DWORD *)(a1 + 612);
  *(_WORD *)&s[v5] = 10;
  if ( v6 <= 0 )
  {
    v16 = 0;
    goto LABEL_11;
  }
  v8 = v7 + 1;
  v9 = 0;
  v10 = &v22[4 * (v7 / 32)];
  v11 = 1 << (v7 % 32);
  while ( 2 )
  {
    v12 = 0;
    timeout.tv_usec = 0;
    timeout.tv_sec = 1;
    while ( 1 )
    {
      if ( v12 <= 0x1F )
        goto LABEL_7;
      *((_DWORD *)v10 - 32) |= v11;
      if ( select(v8, 0, &writefds, 0, &timeout) > 0 )
        break;
      v13 = _errno_location();
      v12 = 0;
      if ( *v13 != 4 )
        return 1;
LABEL_7:
      v14 = &v22[4 * v12++];
      *((_DWORD *)v14 - 32) = 0;
    }
    v15 = send(*(_DWORD *)(a1 + 612), &s[v9], v6, 0x4000);
    if ( v15 >= 0 )
      goto LABEL_9;
    if ( *_errno_location() != 11 )
      return 2;
    v15 = 0;
LABEL_9:
    v6 -= v15;
    v9 += v15;
    if ( v6 > 0 )
      continue;
    break;
  }
  v16 = vshrd_n_s64(vdup_n_s32(v9).n64_i64[0], 0x20u);
LABEL_11:
  *(_QWORD *)(a1 + 528) += v16;
  v18 = *(_QWORD *)(a1 + 520);
  *(_QWORD *)(a1 + 536) += v16;
  *(_QWORD *)(a1 + 520) = v18 + 1;
  return 0;
}

//----- (000295A8) --------------------------------------------------------
int __fastcall sub_295A8(int a1)
{
  pthread_mutex_t *v1; // r5
  int v3; // r0

  v1 = (pthread_mutex_t *)(a1 + 728);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 728)) )
    sub_B708("clear_sock", 1955);
  do
    v3 = *(_DWORD *)(a1 + 612);
  while ( v3 && recv(v3, *(void **)(a1 + 616), 0x1FFCu, 0) > 0 );
  sub_29388(v1, "clear_sock", 1964);
  off_75ED8();
  return sub_28AE8(a1);
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0002962C) --------------------------------------------------------
int __fastcall sub_2962C(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B708("tq_freezethaw", 1236);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_29388(v2, "tq_freezethaw", 1239);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (00029690) --------------------------------------------------------
const char *__fastcall sub_29690(char *a1)
{
  char **v2; // r3
  const char *result; // r0

  if ( !a1 )
    return "http:";
  v2 = &off_64E3C;
  while ( 1 )
  {
    result = v2[2];
    v2 += 2;
    if ( !result )
      break;
    if ( v2[1] == a1 )
      return result;
  }
  return "invalid";
}
// 64E3C: using guessed type char *off_64E3C;

//----- (000296D8) --------------------------------------------------------
_BYTE *__fastcall sub_296D8(_BYTE *result, char *a2, int a3)
{
  _BYTE *v3; // r12
  char v4; // t1

  if ( a3 <= 0 )
  {
    v3 = result;
  }
  else
  {
    v3 = &result[2 * a3];
    do
    {
      *result = aClearSock[((unsigned __int8)*a2 >> 4) + 84];
      v4 = *a2++;
      result[1] = aClearSock[(v4 & 0xF) + 84];
      result += 2;
    }
    while ( v3 != result );
  }
  *v3 = 0;
  return result;
}

//----- (00029730) --------------------------------------------------------
_BYTE *__fastcall sub_29730(int a1, int a2)
{
  int v2; // r8
  _BYTE *result; // r0
  _BYTE *v6; // r3
  _BYTE *v7; // r2
  int v8; // r3
  unsigned int v9; // r12
  char v10; // r1
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v2 = 2 * a2;
  result = calloc(4 - (v2 + 1) % 4 + v2 + 1, 1u);
  if ( !result )
  {
    snprintf(s, 0x1000u, "Failed to calloc in %s %s():%d", "util.c", "bin2hex", 920);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v6 = result;
  if ( a2 > 0 )
  {
    v7 = result;
    v8 = 0;
    do
    {
      v9 = *(unsigned __int8 *)(a1 + v8++);
      v10 = aClearSock[(v9 & 0xF) + 84];
      LOBYTE(v9) = aClearSock[(v9 >> 4) + 84];
      v7[1] = v10;
      *v7 = v9;
      v7 += 2;
    }
    while ( v8 != a2 );
    v6 = &result[v2];
  }
  *v6 = 0;
  return result;
}

//----- (00029830) --------------------------------------------------------
bool __fastcall sub_29830(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  int v4; // r12
  unsigned __int8 *v5; // r1
  char *v6; // r3
  char *v7; // r12
  int v8; // r12
  bool v9; // zf
  int v10; // r3
  int v11; // r12
  int v12; // r3
  char v14[4100]; // [sp+0h] [bp-1004h] BYREF

  v3 = *a2;
  if ( !*a2 )
    return a3 == 0;
  if ( a3 )
  {
    v4 = a2[1];
    if ( a2[1] )
    {
      v5 = a2 + 2;
      v6 = &aClearSock[4 * v3];
      v7 = &aClearSock[4 * v4];
      while ( 1 )
      {
        v10 = *((_DWORD *)v6 + 27);
        v11 = *((_DWORD *)v7 + 27);
        if ( (v11 | v10) < 0 )
          break;
        --a3;
        *a1++ = v11 | (16 * v10);
        v12 = *v5;
        v9 = v12 == 0;
        v6 = &aClearSock[4 * v12];
        if ( v9 )
          return a3 == 0;
        if ( !a3 )
          return 0;
        v8 = v5[1];
        v5 += 2;
        v9 = v8 == 0;
        v7 = &aClearSock[4 * v8];
        if ( v9 )
          goto LABEL_11;
      }
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        strcpy(v14, "hex2bin scan failed");
        sub_38730(3, v14, 0);
        return 0;
      }
    }
    else
    {
LABEL_11:
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        strcpy(v14, "hex2bin str truncated");
        sub_38730(3, v14, 0);
      }
    }
  }
  return 0;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (000299AC) --------------------------------------------------------
int __fastcall sub_299AC(int a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v5; // r1
  char *v6; // r5
  size_t v8; // r3
  void *v9; // r0
  size_t v10; // r6
  _BYTE *v11; // r0
  int v12; // r3
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  v5 = a3;
  if ( a3 )
    v5 = 1;
  v6 = sub_292F4(a2, v5);
  if ( !v6 )
    return 0;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 244)) )
    sub_B708("parse_extranonce_equihash", 2522);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 268)) )
  {
    v15 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v15,
      "util.c",
      "parse_extranonce_equihash",
      2522);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  free(*(void **)(a1 + 636));
  *(_DWORD *)(a1 + 636) = v6;
  v8 = strlen(v6) >> 1;
  v9 = *(void **)(a1 + 640);
  *(_DWORD *)(a1 + 1588) = v8;
  free(v9);
  v10 = *(_DWORD *)(a1 + 1588);
  v11 = calloc(v10, 1u);
  *(_DWORD *)(a1 + 640) = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x1000u,
      "%s: Failed to calloc pool->nonce1bin in %s %s():%d",
      "parse_extranonce_equihash",
      "util.c",
      "parse_extranonce_equihash",
      2530);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  sub_29830(v11, *(unsigned __int8 **)(a1 + 636), v10);
  v12 = 64 - *(_DWORD *)(a1 + 1588);
  *(_QWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 656) = v12;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 268)) )
  {
    v14 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v14,
      "util.c",
      "parse_extranonce_equihash",
      2536);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 244)) )
  {
    v13 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v13,
      "util.c",
      "parse_extranonce_equihash",
      2536);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  off_75ED8();
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 5 )
    return 1;
  snprintf(s, 0x1000u, "Pool %d extranonce set to %s", *(_DWORD *)a1, v6);
  sub_38730(6, s, 0);
  return 1;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00029C70) --------------------------------------------------------
_BYTE *__fastcall sub_29C70(_BYTE *a1, char *s)
{
  unsigned int v2; // r4
  signed int v4; // r0
  int v5; // r9
  int *v6; // r12
  int v7; // r8
  int v8; // r3
  __int64 v9; // r2
  char v10; // r12
  unsigned int v11; // r2
  unsigned int *v12; // r1
  _BYTE *result; // r0
  _BYTE *v14; // r3
  unsigned int v15; // t1
  int v17; // [sp+Ch] [bp-20h] BYREF
  unsigned int v18[5]; // [sp+10h] [bp-1Ch] BYREF
  unsigned int v19; // [sp+24h] [bp-8h]

  v2 = 0;
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  v4 = strlen(s);
  if ( v4 <= 0 )
  {
    v11 = 0;
    v10 = 0;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = &v17;
      v7 = 6;
      v8 = *(_DWORD *)&aClearSock[4 * (unsigned __int8)s[v5] + 1160];
      while ( 1 )
      {
        v9 = 58LL * v2 + (unsigned int)v8;
        --v7;
        v8 = BYTE4(v9) & 0x3F;
        v6[6] = v9;
        --v6;
        if ( v7 == -1 )
          break;
        v2 = v6[6];
      }
      if ( v4 == ++v5 )
        break;
      v2 = v19;
    }
    v10 = v17;
    v11 = bswap32(v18[0]);
  }
  v12 = v18;
  result = a1 + 29;
  *a1 = v10;
  v14 = a1 + 5;
  while ( 1 )
  {
    *((_DWORD *)v14 - 1) = v11;
    v14 += 4;
    if ( v14 == result )
      break;
    v15 = v12[1];
    ++v12;
    v11 = bswap32(v15);
  }
  return result;
}

//----- (00029DFC) --------------------------------------------------------
int __fastcall sub_29DFC(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    LOWORD(v5) = 16511;
    if ( a2 > 16511 )
    {
      HIWORD(v5) = 32;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (00029F54) --------------------------------------------------------
int __fastcall sub_29F54(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r12
  unsigned int *v3; // r2
  int v5; // r3
  unsigned int v6; // r5
  unsigned int v7; // t1
  unsigned int v8; // t1
  bool v9; // cf
  int v10; // r5
  unsigned int v12; // r1
  unsigned int v13; // r8
  unsigned int v14; // r7
  unsigned int v15; // r11
  unsigned int v16; // lr
  unsigned int v17; // r10
  unsigned int v18; // r12
  unsigned int v19; // r2
  unsigned int v20; // r10
  unsigned int v21; // r8
  unsigned int v22; // r7
  unsigned int v23; // r2
  unsigned int v24; // r3
  unsigned int v25; // lr
  unsigned int v26; // r12
  char *v27; // r7
  char *v28; // r6
  const char *v29; // r12
  _DWORD v30[8]; // [sp+8h] [bp-1044h] BYREF
  _DWORD v31[8]; // [sp+28h] [bp-1024h] BYREF
  char s[4088]; // [sp+48h] [bp-1004h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  v5 = 7;
  while ( 1 )
  {
    v7 = *--v2;
    v6 = v7;
    --v5;
    v8 = *--v3;
    v9 = v6 >= v8;
    if ( v6 > v8 )
      break;
    if ( !v9 || v5 == -1 )
    {
      v10 = 1;
      goto LABEL_7;
    }
  }
  v10 = 0;
LABEL_7:
  if ( byte_78E09 )
  {
    v12 = a1[6];
    v13 = a1[3];
    v14 = a1[2];
    v15 = bswap32(a1[7]);
    v16 = a1[1];
    v17 = bswap32(a1[4]);
    v18 = *a1;
    v30[2] = bswap32(a1[5]);
    v30[3] = v17;
    v30[0] = v15;
    v19 = a2[7];
    v20 = a2[6];
    v30[4] = bswap32(v13);
    v21 = a2[5];
    v30[5] = bswap32(v14);
    v22 = a2[4];
    v31[0] = bswap32(v19);
    v23 = a2[1];
    v24 = *a2;
    v30[6] = bswap32(v16);
    v25 = a2[3];
    v30[7] = bswap32(v18);
    v26 = a2[2];
    v30[1] = bswap32(v12);
    v31[7] = bswap32(v24);
    v31[3] = bswap32(v22);
    v31[4] = bswap32(v25);
    v31[5] = bswap32(v26);
    v31[6] = bswap32(v23);
    v31[1] = bswap32(v20);
    v31[2] = bswap32(v21);
    v27 = sub_29730((int)v30, 32);
    v28 = sub_29730((int)v31, 32);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      v29 = "no (false positive; hash > target)";
      if ( v10 )
        v29 = "YES (hash <= target)";
      snprintf(s, 0x1000u, " Proof: %s\nTarget: %s\nTrgVal? %s", v27, v28, v29);
      sub_38730(7, s, 0);
    }
    free(v27);
    free(v28);
  }
  return v10;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0002A168) --------------------------------------------------------
char *sub_2A168()
{
  char *v0; // r0
  char *v1; // r4

  v0 = (char *)calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = v0;
    *((_DWORD *)v0 + 1) = v0;
    pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
    pthread_cond_init((pthread_cond_t *)(v1 + 40), 0);
  }
  return v1;
}

//----- (0002A1A8) --------------------------------------------------------
void __fastcall sub_2A1A8(char *a1)
{
  int v1; // r5
  _DWORD *v3; // r3
  int v4; // r2
  _DWORD *v5; // r4
  _DWORD *v6; // r1
  bool v7; // zf

  if ( a1 )
  {
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = **(_DWORD **)a1;
    if ( a1 != *(char **)a1 )
      v1 = 0;
    v5 = (_DWORD *)(v4 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v6 = (_DWORD *)v3[2];
        *(_DWORD *)(v4 + 4) = v6;
        *v6 = v4;
        v3[1] = v1;
        v3[2] = v1;
        free(v3);
        v4 = v5[1];
        v3 = v5;
        v7 = v5 + 1 == (_DWORD *)a1;
        v5 = (_DWORD *)(v4 - 4);
      }
      while ( !v7 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    memset(a1, 0, 0x58u);
    free(a1);
  }
}
// 2A1E0: variable 'v1' is possibly undefined

//----- (0002A230) --------------------------------------------------------
int __fastcall sub_2A230(int a1)
{
  return sub_2962C(a1, 1);
}

//----- (0002A238) --------------------------------------------------------
int __fastcall sub_2A238(int a1)
{
  return sub_2962C(a1, 0);
}

//----- (0002A240) --------------------------------------------------------
int __fastcall sub_2A240(int a1, int a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r6
  int v6; // r8
  _DWORD *v7; // r4
  _DWORD *v8; // r3

  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( !v4 )
    return 0;
  *v4 = a2;
  v7 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B708("tq_push", 1264);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v6 = 0;
    free(v5);
  }
  else
  {
    v8 = *(_DWORD **)(a1 + 4);
    v6 = 1;
    *(_DWORD *)(a1 + 4) = v7;
    v5[1] = a1;
    v5[2] = v8;
    *v8 = v7;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_29388((pthread_mutex_t *)(a1 + 12), "tq_push", 1275);
  off_75ED8();
  return v6;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0002A300) --------------------------------------------------------
int __fastcall sub_2A300(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r5
  int *v5; // r3
  _DWORD *v6; // r1
  int v7; // r12
  int v8; // r4
  int v10; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B708("tq_pop", 1286);
  v5 = *(int **)a1;
  if ( a1 != *(_DWORD *)a1 )
    goto LABEL_3;
  if ( a2 )
    v10 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), v2, a2);
  else
    v10 = pthread_cond_wait((pthread_cond_t *)(a1 + 40), v2);
  if ( v10 )
  {
    v8 = 0;
    goto LABEL_4;
  }
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v8 = 0;
  }
  else
  {
LABEL_3:
    v6 = (_DWORD *)v5[1];
    v7 = *v5;
    v8 = *(v5 - 1);
    *(_DWORD *)(v7 + 4) = v6;
    *v6 = v7;
    *v5 = 0;
    v5[1] = 0;
    free(v5 - 1);
  }
LABEL_4:
  sub_29388(v2, "tq_pop", 1305);
  off_75ED8();
  return v8;
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (0002A3DC) --------------------------------------------------------
int __fastcall sub_2A3DC(int result)
{
  int v1; // r4
  pthread_t v2; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_join(v2, 0);
      *(_DWORD *)(v1 + 12) = 0;
    }
    return sem_destroy((sem_t *)(v1 + 16));
  }
  return result;
}

//----- (0002A414) --------------------------------------------------------
int __fastcall sub_2A414(int result)
{
  int v1; // r4
  pthread_t v2; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      *(_DWORD *)(v1 + 12) = 0;
    }
    return sem_destroy((sem_t *)(v1 + 16));
  }
  return result;
}

//----- (0002A448) --------------------------------------------------------
int __fastcall sub_2A448(_DWORD *a1, int *a2)
{
  int v2; // r3
  int v3; // r2
  int result; // r0
  int v5; // r3

  v2 = a2[1];
  v3 = *a1 - *a2;
  *a2 = v3;
  result = a1[1];
  v5 = result - v2;
  a2[1] = v5;
  if ( v5 < 0 )
  {
    *a2 = v3 - 1;
    a2[1] = v5 + 1000000;
  }
  return result;
}

//----- (0002A47C) --------------------------------------------------------
int __fastcall sub_2A47C(_DWORD *a1, int *a2)
{
  int v2; // r3
  int v3; // r12
  int result; // r0
  int v5; // r3

  v2 = a2[1];
  v3 = *a1 + *a2;
  *a2 = v3;
  result = a1[1];
  v5 = result + v2;
  a2[1] = v5;
  if ( v5 > 999999 )
  {
    *a2 = v3 + 1;
    a2[1] = v5 - 1000000;
  }
  return result;
}

//----- (0002A4C8) --------------------------------------------------------
bool __fastcall sub_2A4C8(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (0002A4FC) --------------------------------------------------------
bool __fastcall sub_2A4FC(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (0002A530) --------------------------------------------------------
_DWORD *__fastcall sub_2A530(_DWORD *result, _DWORD *a2)
{
  int v2; // r3

  v2 = a2[1];
  *result = *a2;
  result[1] = v2;
  return result;
}

//----- (0002A544) --------------------------------------------------------
_DWORD *__fastcall sub_2A544(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (0002A56C) --------------------------------------------------------
_DWORD *__fastcall sub_2A56C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (0002A588) --------------------------------------------------------
int __fastcall sub_2A588(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE98: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A5C0) --------------------------------------------------------
int __fastcall sub_2A5C0(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE98: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A600) --------------------------------------------------------
int __fastcall sub_2A600(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE98: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A648) --------------------------------------------------------
int __fastcall sub_2A648(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE98: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A688) --------------------------------------------------------
int *__fastcall sub_2A688(int *result, _DWORD *a2)
{
  int v2; // r4
  int v3; // r2
  int v4; // r3
  int v5; // r2
  int v6; // r1
  int v7; // r2
  int v8; // r1

  v2 = result[1];
  v3 = *result + *a2;
  *result = v3;
  v4 = v2 + a2[1];
  result[1] = v4;
  if ( v4 > 999999999 )
  {
    v5 = v3 + 1;
    do
    {
      v6 = v5++;
      v4 -= 1000000000;
    }
    while ( v4 > 999999999 );
    *result = v6;
    result[1] = v4;
  }
  if ( v4 < 0 )
  {
    v7 = *result - 1;
    do
    {
      v8 = v7--;
      v4 += 1000000000;
    }
    while ( v4 < 0 );
    *result = v8;
    result[1] = v4;
  }
  return result;
}

//----- (0002A718) --------------------------------------------------------
const char *__fastcall sub_2A718(const char *a1, const char *a2, int a3, int a4)
{
  bool v4; // zf
  signed int v7; // r10
  size_t v8; // r0
  bool v9; // zf
  int v10; // r4
  const __int32_t **v11; // r0
  int v12; // r3
  const __int32_t *v13; // r1
  const __int32_t **v14; // r0
  int v15; // r3
  const __int32_t *v16; // r1
  char *v17; // r0
  int v19; // [sp+0h] [bp-24h] BYREF

  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  v19 = a4;
  if ( v4 )
    return 0;
  v7 = strlen(a1);
  v8 = strlen(a2);
  v9 = v7 == 0;
  if ( v7 )
    v9 = v8 == 0;
  v10 = v8;
  if ( v9 )
    return 0;
  if ( v7 > 0 )
  {
    v11 = _ctype_tolower_loc();
    v12 = 0;
    v13 = *v11;
    do
    {
      *((_BYTE *)&v19 + v12) = v13[(unsigned __int8)a1[v12]];
      ++v12;
    }
    while ( v7 != v12 );
  }
  if ( v10 > 0 )
  {
    v14 = _ctype_tolower_loc();
    v15 = 0;
    v16 = *v14;
    do
    {
      *((_BYTE *)&v19 + v15) = v16[(unsigned __int8)a2[v15]];
      ++v15;
    }
    while ( v10 != v15 );
  }
  v17 = strstr((const char *)&v19, (const char *)&v19);
  if ( !v17 )
    return 0;
  else
    return &a1[v17 - (char *)&v19];
}

//----- (0002A800) --------------------------------------------------------
const char *__fastcall sub_2A800(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (0002A84C) --------------------------------------------------------
int __fastcall sub_2A84C(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (0002A854) --------------------------------------------------------
int __fastcall sub_2A854(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (0002A87C) --------------------------------------------------------
int __fastcall sub_2A87C(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r12
  int result; // r0
  int v5; // r3

  v3 = *a1 - *a2;
  *a3 = v3;
  result = a1[1];
  v5 = result - a2[1];
  if ( v5 < 0 )
  {
    *a3 = v3 - 1;
    a3[1] = v5 + 1000000000;
  }
  else
  {
    a3[1] = v5;
  }
  return result;
}

//----- (0002A8B8) --------------------------------------------------------
int __fastcall sub_2A8B8(struct timespec *tp)
{
  return clock_gettime(1, tp);
}

//----- (0002A8C4) --------------------------------------------------------
int __fastcall sub_2A8C4(_DWORD *a1)
{
  struct timespec v3; // [sp+0h] [bp-8h] BYREF

  sub_2A600(&v3);
  sub_2A688(&v3.tv_sec, a1);
  return sub_2926C(&v3);
}

//----- (0002A8FC) --------------------------------------------------------
int __fastcall sub_2A8FC(_DWORD *a1)
{
  struct timespec v3; // [sp+0h] [bp-8h] BYREF

  sub_2A5C0(&v3);
  sub_2A688(&v3.tv_sec, a1);
  return sub_2926C(&v3);
}

//----- (0002A92C) --------------------------------------------------------
int sub_2A92C()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  sub_2A8B8(&v1);
  return sub_2A8C4(&v1);
}

//----- (0002A954) --------------------------------------------------------
int sub_2A954()
{
  struct timespec tp; // [sp+8h] [bp-Ch] BYREF

  sub_2A8B8(&tp);
  return sub_2A8FC(&tp);
}

//----- (0002A988) --------------------------------------------------------
_DWORD *__fastcall sub_2A988(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return (_DWORD *)result[1];
  return result;
}

//----- (0002AA24) --------------------------------------------------------
void sub_2AA24()
{
  ;
}

//----- (0002AA68) --------------------------------------------------------
void __fastcall sub_2AA68(int a1, char *s)
{
  char *v3; // r0
  char *v4; // r6
  char v5[16]; // [sp+0h] [bp-1010h] BYREF
  char sa[4096]; // [sp+10h] [bp-1000h] BYREF

  v3 = strchr(s, 35);
  v4 = v3;
  if ( v3 )
  {
    if ( !*(_BYTE *)(a1 + 604) )
    {
      strcpy(v5, v3);
      *v4 = 0;
      if ( !strcmp(v5, "#xnsub") )
      {
        *(_BYTE *)(a1 + 604) = 1;
        if ( byte_78E09 )
        {
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
          {
            snprintf(sa, 0x1000u, "Pool %d extranonce subscribing enabled.", *(_DWORD *)a1);
            sub_38730(7, sa, 0);
          }
        }
      }
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0002AB54) --------------------------------------------------------
int __fastcall sub_2AB54(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r5
  char *v8; // r0
  bool v9; // zf
  char *v10; // r8
  int v11; // r9
  char *v12; // r11
  int v13; // r6
  signed int v14; // r12
  const char *v15; // r11
  char *v16; // r0
  int v17; // r3
  char *v19; // r0
  size_t v20; // r0
  signed int v21; // [sp+Ch] [bp-110h]
  char v22[8]; // [sp+10h] [bp-10Ch] BYREF
  char s[260]; // [sp+18h] [bp-104h] BYREF

  *a2 = a1;
  v4 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = v8 == 0;
  if ( v8 )
    v9 = v7 == 0;
  v10 = v8;
  v11 = !v9;
  if ( v9 || v7 >= v8 )
    v8 = (char *)v4;
  v12 = strchr(v8, 58);
  if ( v12 )
  {
    v13 = v12 - v4;
    v14 = ~(v12 - v4) + strlen(v4);
    if ( v14 <= 0 )
      return 0;
    v15 = v12 + 1;
  }
  else
  {
    v20 = strlen(v4);
    v14 = 0;
    v15 = 0;
    v13 = v20;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v11 && v7 < v10 )
  {
    v13 -= 2;
    ++v4;
  }
  v21 = v14;
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v21 )
  {
    snprintf(v22, 6u, "%.*s", v21, v15);
    v19 = strchr(v22, 47);
    if ( v19 )
      *v19 = 0;
  }
  else
  {
    strcpy(v22, "80");
  }
  *a3 = _strdup(v22);
  v16 = _strdup(s);
  v17 = 1;
  *a2 = v16;
  return v17;
}

//----- (0002ACE0) --------------------------------------------------------
char *__fastcall sub_2ACE0(char *s1, int a2)
{
  const char *v2; // r4
  int v5; // r5
  size_t v6; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = "http:";
  v5 = 0;
  v6 = 5;
  *(_DWORD *)(a2 + 216) = 0;
  while ( strncmp(s1, v2, v6) )
  {
    ++v5;
    v2 = (&off_64E3C)[2 * v5];
    if ( !v2 )
      return s1;
    v6 = strlen((&off_64E3C)[2 * v5]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)malloc(v7 - s1 + 1 - v6);
    *(_DWORD *)(a2 + 216) = v9;
    if ( !v9 )
    {
      snprintf(s, 0x1000u, "Failed to malloc rpc_proxy in %s %s():%d", "util.c", "get_proxy", 881);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    v10 = &s1[v6];
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_2AB54(*(const char **)(a2 + 216), (_DWORD *)(a2 + 628), (char **)(a2 + 632));
    *(_DWORD *)(a2 + 212) = *(_DWORD *)&aClearSock[8 * v5 + 32];
  }
  return s1;
}
// 64E3C: using guessed type char *off_64E3C;

//----- (0002AE10) --------------------------------------------------------
bool __fastcall sub_2AE10(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 616);
  return *v1 || sub_28AFC(a1, (unsigned __int8)*v1);
}

//----- (0002AE2C) --------------------------------------------------------
void **__fastcall sub_2AE2C(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6)
{
  _DWORD *v8; // r6
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v8 = result;
  if ( a3 != a2 )
  {
    result = (void **)realloc(*result, a3);
    *v8 = result;
    if ( !result )
    {
      snprintf(s, 0x1000u, "Failed to realloc in %s %s():%d", a4, a5, a6);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    if ( a3 > a2 )
      return (void **)memset((void *)(*v8 + a2), 0, a3 - a2);
  }
  return result;
}

//----- (0002AEE0) --------------------------------------------------------
int __fastcall sub_2AEE0(int a1)
{
  int v2; // r0
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "Closing socket for stratum pool %d", *(_DWORD *)a1);
    sub_38730(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 728)) )
    sub_B708("suspend_stratum", 3354);
  sub_28AE8(a1);
  v2 = *(_DWORD *)(a1 + 612);
  *(_BYTE *)(a1 + 667) = 0;
  *(_BYTE *)(a1 + 665) = 0;
  if ( v2 )
    close(v2);
  *(_DWORD *)(a1 + 612) = 0;
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 728)) )
  {
    v4 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 3356);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0002B040) --------------------------------------------------------
char *__fastcall sub_2B040(int a1)
{
  char *v1; // r4
  signed int v3; // r5
  char *v4; // r0
  char *v5; // r7
  size_t v6; // r0
  signed int v7; // r4
  __int64 v8; // r0
  __int64 v9; // r8
  char *v11; // r10
  size_t v12; // r11
  size_t v13; // r9
  unsigned int v14; // r0
  bool v15; // cc
  ssize_t v16; // r4
  bool v17; // nf
  int v18; // r4
  size_t v19; // r11
  char *v20; // r0
  struct timeval v21; // [sp+8h] [bp-3014h] BYREF
  struct timeval v22; // [sp+10h] [bp-300Ch] BYREF
  char s[4072]; // [sp+18h] [bp-3004h] BYREF
  char v24[8196]; // [sp+1018h] [bp-2004h] BYREF

  v1 = *(char **)(a1 + 616);
  if ( !strchr(v1, 10) )
  {
    sub_2A84C(&v21);
    if ( !sub_28AFC(a1, 60) )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy(v24, "Timed out waiting for data on socket_full");
        sub_38730(7, v24, 0);
      }
      goto LABEL_18;
    }
    while ( 1 )
    {
      memset(v24, 0, 0x2000u);
      v16 = recv(*(_DWORD *)(a1 + 612), v24, 0x1FFCu, 0);
      if ( !v16 )
        break;
      sub_2A84C(&v22);
      v17 = v16 < 0;
      v18 = (int)((double)(v22.tv_sec - v21.tv_sec) + (double)(v22.tv_usec - v21.tv_usec) / 1000000.0);
      if ( v17 )
      {
        if ( *_errno_location() != 11 || !sub_28AFC(a1, 60 - v18) )
        {
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            strcpy(s, "Failed to recv sock in recv_line");
            sub_38730(7, s, 0);
          }
          goto LABEL_38;
        }
      }
      else
      {
        v11 = *(char **)(a1 + 616);
        v12 = strlen(v24);
        v13 = strlen(v11);
        v14 = v12 + v13 + 1;
        if ( v14 >= *(_DWORD *)(a1 + 620) )
        {
          v19 = (v14 & 0xFFFFE000) + 0x2000;
          v20 = (char *)realloc(v11, v19);
          *(_DWORD *)(a1 + 616) = v20;
          if ( !v20 )
          {
            snprintf(s, 0x1000u, "Failed to realloc pool sockbuf in %s %s():%d", "util.c", "recalloc_sock", 1997);
            sub_38730(3, s, 1);
            sub_16CA8(1);
          }
          memset(&v20[v13], 0, v19 - v13);
          v11 = *(char **)(a1 + 616);
          *(_DWORD *)(a1 + 620) = v19;
        }
        strcat(v11, v24);
      }
      v15 = v18 <= 59;
      v1 = *(char **)(a1 + 616);
      if ( !v15 || strchr(*(const char **)(a1 + 616), 10) )
        goto LABEL_2;
    }
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(s, "Socket closed waiting in recv_line");
      sub_38730(7, s, 0);
    }
LABEL_38:
    sub_2AEE0(a1);
    v1 = *(char **)(a1 + 616);
  }
LABEL_2:
  v3 = strlen(v1);
  v4 = strtok(v1, ptr);
  if ( !v4 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v24, "Failed to parse a \\n terminated string in recv_line");
      sub_38730(7, v24, 0);
    }
    goto LABEL_18;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( v3 > (int)(v6 + 1) )
    memmove(*(void **)(a1 + 616), (const void *)(*(_DWORD *)(a1 + 616) + v6 + 1), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 616) = 0;
  v8 = *(_QWORD *)(a1 + 560);
  v9 = *(_QWORD *)(a1 + 552) + v7;
  ++*(_QWORD *)(a1 + 544);
  *(_QWORD *)(a1 + 552) = v9;
  *(_QWORD *)(a1 + 560) = v7 + v8;
  if ( !v5 )
  {
LABEL_18:
    v5 = 0;
    sub_295A8(a1);
    return v5;
  }
  if ( byte_7B380 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v24, 0x1000u, "RECVD: %s", v5);
    sub_38730(7, v24, 0);
  }
  return v5;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B380: using guessed type char byte_7B380;

//----- (0002B5C8) --------------------------------------------------------
int __fastcall sub_2B5C8(int a1, char *a2, int a3)
{
  int v6; // r7
  int v7; // r5
  int *v9; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_7B380 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "SEND: %s", a2);
    sub_38730(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 728)) )
    sub_B708("stratum_send", 1893);
  if ( *(_BYTE *)(a1 + 665) )
  {
    v7 = sub_29404(a1, a2, a3);
    v6 = v7 == 0;
  }
  else
  {
    v6 = *(unsigned __int8 *)(a1 + 665);
    v7 = 3;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 728)) )
  {
    v9 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1896);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  off_75ED8();
  if ( v7 == 2 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(s, "Failed to send in stratum_send");
      sub_38730(7, s, 0);
      sub_2AEE0(a1);
      return v6;
    }
    goto LABEL_21;
  }
  if ( v7 != 3 )
  {
    if ( v7 != 1 )
      return v6;
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "Write select failed on pool %d sock", *(_DWORD *)a1);
      sub_38730(7, s, 0);
    }
LABEL_21:
    sub_2AEE0(a1);
    return v6;
  }
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(s, "Stratum send failed due to no pool stratum_active");
    sub_38730(7, s, 0);
  }
  return v6;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B380: using guessed type char byte_7B380;

//----- (0002B8E8) --------------------------------------------------------
int *__fastcall sub_2B8E8(_DWORD *a1)
{
  int i; // r0
  int v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r0
  bool v7; // zf
  int v8; // r0
  struct addrinfo *v9; // r4
  char *v10; // r12
  int v11; // r0
  int v12; // r1
  int v13; // r2
  __int16 v14; // r3
  int v15; // r0
  int v16; // r7
  int v17; // r0
  int *v18; // r10
  unsigned int v19; // lr
  int *v20; // r5
  int v21; // r0
  char *v22; // r3
  int v23; // r0
  const char *v24; // r3
  int v25; // r2
  size_t v26; // r0
  void *v27; // r0
  const char *v28; // r0
  int v29; // r3
  int v30; // r2
  int v31; // r6
  int v32; // r3
  int v33; // r3
  const char *v35; // r3
  int *v36; // r0
  int *v37; // r7
  _DWORD *v38; // r6
  _DWORD *v39; // r0
  char *v40; // r4
  char *v41; // r0
  ssize_t v42; // r0
  const char *v43; // r10
  signed int v44; // r0
  size_t v45; // r5
  __int16 v46; // r0
  char *v47; // r12
  ssize_t v48; // r4
  char v49; // r0
  ssize_t v50; // r5
  int v51; // r0
  int v52; // r0
  int v53; // r2
  size_t v54; // r0
  char *v55; // r0
  int *v56; // r0
  int *v57; // r0
  int *v58; // r0
  int *v59; // r0
  struct timeval *timeout; // [sp+0h] [bp-3374h]
  int *v61; // [sp+18h] [bp-335Ch]
  char *name; // [sp+1Ch] [bp-3358h]
  char *service; // [sp+20h] [bp-3354h]
  int v64; // [sp+24h] [bp-3350h]
  pthread_mutex_t *mutex; // [sp+2Ch] [bp-3348h]
  int v66; // [sp+30h] [bp-3344h]
  struct addrinfo *pai; // [sp+38h] [bp-333Ch] BYREF
  int v68; // [sp+3Ch] [bp-3338h] BYREF
  socklen_t optlen; // [sp+40h] [bp-3334h] BYREF
  int optval; // [sp+44h] [bp-3330h] BYREF
  struct timeval v71; // [sp+48h] [bp-332Ch] BYREF
  addrinfo req; // [sp+50h] [bp-3324h] BYREF
  char v73[92]; // [sp+70h] [bp-3304h] BYREF
  char v74[160]; // [sp+CCh] [bp-32A8h] BYREF
  fd_set writefds; // [sp+16Ch] [bp-3208h] BYREF
  char s[4048]; // [sp+370h] [bp-3004h] BYREF
  char v77[8196]; // [sp+1370h] [bp-2004h] BYREF

  v61 = 0;
  v64 = 0;
  mutex = (pthread_mutex_t *)(a1 + 182);
  v66 = 0;
  for ( i = pthread_mutex_lock((pthread_mutex_t *)(a1 + 182)); ; i = pthread_mutex_lock(mutex) )
  {
    if ( i )
      sub_B708("setup_stratum_socket", 3167);
    v6 = a1[153];
    *((_BYTE *)a1 + 665) = 0;
    if ( v6 )
      close(v6);
    a1[153] = 0;
    if ( pthread_mutex_unlock(mutex) )
    {
      v58 = _errno_location();
      snprintf(
        s,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v58,
        "util.c",
        "setup_stratum_socket",
        3172);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    off_75ED8();
    v7 = a1[54] == 0;
    req.ai_family = 0;
    req.ai_flags = 0;
    memset(&req.ai_protocol, 0, 20);
    req.ai_socktype = 1;
    if ( !v7
      || (v28 = (const char *)dword_78B78) != 0
      && (a1[54] = dword_78B78, sub_2AB54(v28, a1 + 157, (char **)a1 + 158), v29 = a1[54], a1[53] = 3, v29) )
    {
      name = (char *)a1[157];
      service = (char *)a1[158];
      v8 = getaddrinfo(name, service, &req, &pai);
    }
    else
    {
      name = (char *)a1[156];
      service = (char *)a1[152];
      v8 = getaddrinfo(name, service, &req, &pai);
    }
    if ( v8 )
    {
      if ( *((_BYTE *)a1 + 131) )
      {
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(s, 0x1000u, "Failed to getaddrinfo for %s:%s", name, service);
          sub_38730(7, s, 0);
        }
      }
      else
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(s, 0x1000u, "Failed to resolve (?wrong URL) %s:%s", name, service);
          sub_38730(4, s, 0);
        }
        *((_BYTE *)a1 + 131) = 1;
      }
      goto LABEL_8;
    }
    v9 = pai;
    if ( !pai )
    {
LABEL_60:
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(s, 0x1000u, "Failed to connect to stratum on %s:%s", name, service);
        sub_38730(7, s, 0);
      }
      freeaddrinfo(pai);
      goto LABEL_8;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v15 = socket(v9->ai_family, v9->ai_socktype, v9->ai_protocol);
        v16 = v15;
        if ( v15 != -1 )
          break;
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          v10 = s;
          v11 = *(_DWORD *)"Failed socket";
          v12 = *(_DWORD *)"ed socket";
          v13 = *(_DWORD *)"ocket";
          v14 = *(_WORD *)"t";
          goto LABEL_38;
        }
LABEL_39:
        v9 = v9->ai_next;
        if ( !v9 )
          goto LABEL_60;
      }
      v17 = fcntl(v15, 3, 0);
      fcntl(v16, 4, v17 | 0x800);
      if ( connect(v16, v9->ai_addr, v9->ai_addrlen) != -1 )
        break;
      v71.tv_sec = 1;
      v71.tv_usec = 0;
      v18 = _errno_location();
      if ( *v18 == 115 )
      {
        v19 = 0;
        v20 = &writefds.__fds_bits[v16 / 32];
        while ( 1 )
        {
          if ( v19 > 0x1F )
          {
            *v20 |= 1 << (v16 % 32);
            v21 = select(v16 + 1, 0, &writefds, 0, &v71);
            if ( v21 > 0 )
            {
              if ( ((*v20 >> (v16 % 32)) & 1) != 0 )
              {
                optlen = 4;
                if ( !getsockopt(v16, 1, 4, &optval, &optlen) && !optval )
                {
                  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                  {
                    strcpy(s, "Succeeded delayed connect");
                    sub_38730(7, s, 0);
                  }
                  goto LABEL_71;
                }
              }
LABEL_47:
              close(v16);
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                qmemcpy(s, "Select timeout/f", 16);
                v10 = &s[16];
                v11 = *(_DWORD *)"ailed connect";
                v12 = *(_DWORD *)"d connect";
                v13 = *(_DWORD *)"nnect";
                v14 = *(_WORD *)"t";
LABEL_38:
                *(_DWORD *)v10 = v11;
                *((_DWORD *)v10 + 1) = v12;
                *((_DWORD *)v10 + 2) = v13;
                *((_WORD *)v10 + 6) = v14;
                sub_38730(7, s, 0);
              }
              goto LABEL_39;
            }
            v19 = 0;
            if ( !v21 || *v18 != 4 )
              goto LABEL_47;
          }
          v22 = &v77[4 * v19++ + 0x2000];
          *((_DWORD *)v22 - 3201) = 0;
        }
      }
      close(v16);
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_39;
      strcpy(s, "Failed sock connect");
      sub_38730(7, s, 0);
      v9 = v9->ai_next;
      if ( !v9 )
        goto LABEL_60;
    }
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      strcpy(s, "Succeeded immediate connect");
      sub_38730(4, s, 0);
    }
LABEL_71:
    sub_28B9C(v16);
    freeaddrinfo(pai);
    if ( a1[54] )
    {
      switch ( a1[53] )
      {
        case 0:
          if ( !sub_28BEC((const char **)a1, v16, 0) )
            break;
          if ( !a1[154] )
            goto LABEL_108;
          goto LABEL_84;
        case 1:
          if ( !sub_28BEC((const char **)a1, v16, 1) )
            break;
          goto LABEL_83;
        case 2:
          if ( !sub_28FC8((const char **)a1, v16, 0) )
            break;
          goto LABEL_83;
        case 3:
        case 5:
          LOBYTE(writefds.__fds_bits[0]) = 5;
          *(_WORD *)((char *)writefds.__fds_bits + 1) = 1;
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(
              s,
              0x1000u,
              "Attempting to negotiate with %s:%s SOCKS5 proxy",
              (const char *)a1[157],
              (const char *)a1[158]);
            sub_38730(7, s, 0);
          }
          send(v16, &writefds, 3u, 0);
          if ( sub_28BC4(v16) != 5 )
            goto LABEL_100;
          v42 = sub_28BC4(v16);
          if ( v42 != BYTE2(writefds.__fds_bits[0]) )
            goto LABEL_100;
          v43 = (const char *)a1[156];
          writefds.__fds_bits[0] = 50331909;
          v44 = strlen(v43);
          v45 = v44 >= 255 ? 255 : v44;
          LOBYTE(writefds.__fds_bits[1]) = v45;
          memcpy((char *)&writefds.__fds_bits[1] + 1, v43, v45);
          v46 = strtol((const char *)a1[152], 0, 10);
          v47 = (char *)&writefds.__fds_bits[1] + v45;
          v47[2] = v46;
          v47[1] = HIBYTE(v46);
          send(v16, &writefds, v45 + 7, 0);
          if ( sub_28BC4(v16) != 5 )
            goto LABEL_100;
          v48 = sub_28BC4(v16);
          if ( v48 )
            goto LABEL_100;
          sub_28BC4(v16);
          v49 = sub_28BC4(v16);
          if ( v49 == 1 )
          {
            sub_28BC4(v16);
            sub_28BC4(v16);
            sub_28BC4(v16);
            sub_28BC4(v16);
LABEL_177:
            sub_28BC4(v16);
            sub_28BC4(v16);
            if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
            {
              snprintf(
                s,
                0x1000u,
                "Success negotiating with %s:%s SOCKS5 proxy",
                (const char *)a1[157],
                (const char *)a1[158]);
              sub_38730(7, s, 0);
            }
            goto LABEL_83;
          }
          if ( v49 == 3 )
          {
            v50 = sub_28BC4(v16);
            if ( v50 > 0 )
            {
              do
              {
                ++v48;
                sub_28BC4(v16);
              }
              while ( v48 != v50 );
            }
            goto LABEL_177;
          }
LABEL_100:
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, "Bad response from %s:%s SOCKS5 server", (const char *)a1[157], (const char *)a1[158]);
            sub_38730(4, s, 0);
          }
          break;
        case 4:
          if ( sub_28FC8((const char **)a1, v16, 1) )
            goto LABEL_83;
          break;
        default:
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, "Unsupported proxy type for %s:%s", (const char *)a1[157], (const char *)a1[158]);
            sub_38730(4, s, 0);
          }
          break;
      }
LABEL_8:
      v3 = 0;
      goto LABEL_9;
    }
LABEL_83:
    if ( !a1[154] )
    {
LABEL_108:
      v27 = calloc(0x2000u, 1u);
      a1[154] = v27;
      if ( !v27 )
      {
        snprintf(s, 0x1000u, "Failed to calloc pool sockbuf in %s %s():%d", "util.c", "setup_stratum_socket", 3311);
        sub_38730(3, s, 1);
        sub_16CA8(1);
      }
      a1[155] = 0x2000;
    }
LABEL_84:
    a1[153] = v16;
    v68 = 1;
    optlen = 45;
    optval = 30;
    v23 = fcntl(v16, 3, 0);
    fcntl(v16, 4, v23 | 0x800);
    setsockopt(v16, 1, 9, &v68, 4u);
    if ( !byte_7BD20 )
      fcntl(v16, 2, 1);
    setsockopt(v16, 6, 1, &v68, 4u);
    setsockopt(v16, 6, 6, &v68, 4u);
    setsockopt(v16, 6, 4, &optlen, 4u);
    setsockopt(v16, 6, 5, &optval, 4u);
    if ( v66 )
    {
      sub_295A8((int)a1);
      v30 = dword_7B0F8++;
      sprintf(v77, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v30);
    }
    else
    {
      v24 = (const char *)a1[165];
      v25 = dword_7B0F8;
      if ( v24 )
      {
        ++dword_7B0F8;
        sprintf(
          v77,
          "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/4.9.0\", \"%s\"]}",
          v25,
          v24);
      }
      else
      {
        v35 = (const char *)a1[156];
        timeout = (struct timeval *)a1[152];
        ++dword_7B0F8;
        sprintf(
          v77,
          "{\"id\":%d, \"method\":\"mining.subscribe\", \"params\":[\"cgminer/4.9.0\", null, \"%s\", \"%s\"]}",
          v25,
          v35,
          (const char *)timeout);
      }
    }
    v26 = strlen(v77);
    if ( sub_29404((int)a1, v77, v26) )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        v3 = 1;
        strcpy(s, "Failed to send s in initiate_stratum");
        sub_38730(7, s, 0);
        goto LABEL_9;
      }
LABEL_121:
      v3 = 1;
      goto LABEL_9;
    }
    if ( !sub_28AFC((int)a1, 60) )
    {
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_121;
      v3 = 1;
      strcpy(s, "Timed out waiting for response in initiate_stratum");
      sub_38730(7, s, 0);
      goto LABEL_9;
    }
    v36 = (int *)sub_2B040((int)a1);
    v37 = v36;
    if ( !v36 )
    {
      v3 = 1;
      goto LABEL_9;
    }
    v61 = sub_59230(v36, 0, v73);
    free(v37);
    if ( !v61 )
    {
      if ( !byte_78E09 )
      {
        v66 = 1;
        v3 = 1;
        goto LABEL_9;
      }
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
      {
        v66 = 1;
        v3 = 1;
        goto LABEL_9;
      }
      v3 = 1;
      snprintf(s, 0x1000u, "JSON decode failed(%d): %s", *(_DWORD *)v73, v74);
      goto LABEL_204;
    }
    v38 = (_DWORD *)sub_59E20(v61, "result");
    v39 = (_DWORD *)sub_59E20(v61, "error");
    if ( !v38 || *v38 == 7 )
    {
      if ( v39 )
      {
LABEL_150:
        v40 = (char *)sub_57854(v39, 3);
      }
      else
      {
        v40 = (char *)malloc(0x11u);
        if ( v40 )
          strcpy(v40, "(unknown reason)");
      }
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(s, 0x1000u, "JSON-RPC decode failed: %s", v40);
        sub_38730(7, s, 0);
      }
      v41 = v40;
      v3 = 1;
      free(v41);
      v66 = 1;
      goto LABEL_9;
    }
    if ( v39 && *v39 != 7 )
      goto LABEL_150;
    v51 = sub_299AC((int)a1, v38, 1u);
    if ( v51 )
      break;
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      v3 = 1;
      snprintf(s, 0x1000u, "%s: Failed to get parse extranonce.", "initiate_stratum");
LABEL_204:
      sub_38730(7, s, 0);
      v66 = 1;
      goto LABEL_9;
    }
    v3 = 1;
    v66 = 1;
LABEL_9:
    if ( (v66 & (v64 ^ 1)) == 0 )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy(s, "Initiate stratum failed");
        sub_38730(7, s, 0);
      }
      if ( v3 )
      {
        sub_2AEE0((int)a1);
        if ( v61 )
          goto LABEL_133;
      }
      else if ( v61 )
      {
LABEL_133:
        v31 = 0;
        goto LABEL_134;
      }
      return v61;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
      sub_B708("initiate_stratum", 3608);
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v56 = _errno_location();
      snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v56, "util.c", "initiate_stratum", 3608);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    free((void *)a1[165]);
    free((void *)a1[159]);
    a1[159] = 0;
    a1[165] = 0;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v59 = _errno_location();
      snprintf(
        s,
        0x1000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v59,
        "util.c",
        "initiate_stratum",
        3612);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
    {
      v57 = _errno_location();
      snprintf(
        s,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v57,
        "util.c",
        "initiate_stratum",
        3612);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    off_75ED8();
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(s, "Failed to resume stratum, trying afresh");
      sub_38730(7, s, 0);
    }
    if ( v61 )
    {
      v4 = v61[1];
      if ( v4 != -1 )
      {
        v5 = v4 - 1;
        v61[1] = v5;
        if ( !v5 )
          sub_5A3E4((void **)v61);
      }
    }
    v64 = 1;
  }
  v31 = v51;
  if ( !a1[150] )
    a1[150] = a1[156];
  v52 = (unsigned __int8)byte_7B380;
  *((_BYTE *)a1 + 665) = 1;
  *((_QWORD *)a1 + 230) = 0x3FF0000000000000LL;
  if ( v52 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
      *a1,
      (const char *)a1[159],
      a1[164]);
    sub_38730(7, s, 0);
  }
  if ( *((_BYTE *)a1 + 604) )
  {
    v53 = dword_7B0F8++;
    sprintf(v77, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v53);
    v54 = strlen(v77);
    sub_2B5C8((int)a1, v77, v54);
    v55 = sub_2B040((int)a1);
    if ( v55 )
    {
      free(v55);
    }
    else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      strcpy(s, "recv mining.extranonce.subscribe failed\n");
      sub_38730(3, s, 0);
    }
  }
LABEL_134:
  v32 = v61[1];
  if ( v32 != -1 )
  {
    v33 = v32 - 1;
    v61[1] = v33;
    if ( !v33 )
      sub_5A3E4((void **)v61);
  }
  return (int *)v31;
}
// 2BFC4: control flows out of bounds to 2BFC8
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78B78: using guessed type int dword_78B78;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B0F8: using guessed type int dword_7B0F8;
// 7B380: using guessed type char byte_7B380;
// 7BD20: using guessed type char byte_7BD20;

//----- (0002CEC8) --------------------------------------------------------
int __fastcall sub_2CEC8(int a1)
{
  if ( *(_BYTE *)(a1 + 665) )
    sub_2AEE0(a1);
  if ( sub_2B8E8((_DWORD *)a1) && (!*(_BYTE *)(a1 + 604) || sub_2E69C((int *)a1)) && sub_2EA38((_DWORD *)a1) )
  {
    sub_1FD64((_DWORD *)a1);
    return 1;
  }
  else
  {
    sub_1FA14(a1);
    return 0;
  }
}

//----- (0002CF40) --------------------------------------------------------
int __fastcall sub_2CF40(_DWORD *a1, int *a2)
{
  char *v2; // r11
  double v3; // d0
  int *v5; // r0
  int *v6; // r4
  _DWORD *v7; // r8
  _DWORD *v8; // r7
  _DWORD *v9; // r6
  const char *v10; // r0
  const char *v11; // r5
  char *v12; // r0
  int v13; // r5
  int v14; // r3
  int v15; // r3
  const char *v17; // r0
  const char *v18; // r7
  int v19; // r0
  int v20; // r0
  size_t v21; // r0
  int v22; // r0
  _DWORD *v23; // r0
  double v24; // d9
  char *v25; // r8
  char *v26; // r7
  char *v27; // r10
  char *v28; // r9
  int v29; // r3
  _DWORD *v30; // r0
  bool v31; // zf
  bool v32; // zf
  bool v33; // zf
  double v34; // d16
  size_t v35; // r11
  size_t v36; // r0
  int v37; // r11
  size_t v38; // r6
  size_t v39; // r0
  size_t v40; // r1
  char *v41; // r0
  __int64 v42; // r2
  const char *v43; // r3
  struct timezone *v44; // r8
  int v45; // r6
  _DWORD *v46; // r0
  const char *v47; // r8
  const char *v48; // r10
  char *v49; // r9
  char *v50; // r1
  const char *v51; // r2
  const char *v52; // r3
  int v53; // r0
  int v54; // r0
  unsigned __int8 *v55; // r0
  unsigned __int8 *v56; // r6
  unsigned int v57; // r11
  __time_t tv_sec; // r12
  unsigned int v59; // lr
  __suseconds_t tv_usec; // r3
  unsigned int v61; // r1
  __time_t v62; // r9
  __suseconds_t v63; // r7
  _DWORD *v64; // r0
  _DWORD *v65; // r0
  _DWORD *v66; // r0
  _DWORD *v67; // r0
  int v68; // r0
  void *v69; // r0
  int v70; // r3
  void *v71; // r0
  int v72; // r3
  struct timezone *v73; // r1
  unsigned int v74; // r8
  int *v75; // r0
  int *v76; // r0
  int *v77; // r0
  int *v78; // r0
  int *v79; // r0
  int *v80; // r0
  int *v81; // r0
  int *v82; // r0
  size_t maxlen; // [sp+1Ch] [bp-2228h]
  char *v84; // [sp+20h] [bp-2224h]
  char *v85; // [sp+24h] [bp-2220h]
  char *v86; // [sp+28h] [bp-221Ch]
  _BOOL4 v87; // [sp+2Ch] [bp-2218h]
  pthread_mutex_t *v88; // [sp+30h] [bp-2214h]
  pthread_rwlock_t *rwlock; // [sp+34h] [bp-2210h]
  unsigned int v90; // [sp+38h] [bp-220Ch] BYREF
  int v91; // [sp+3Ch] [bp-2208h] BYREF
  char *v92; // [sp+40h] [bp-2204h] BYREF
  int v93[23]; // [sp+44h] [bp-2200h] BYREF
  char v94[160]; // [sp+A0h] [bp-21A4h] BYREF
  struct timeval v95[32]; // [sp+140h] [bp-2104h] BYREF
  char s[8192]; // [sp+240h] [bp-2004h] BYREF

  if ( !a2 )
    return 0;
  v5 = sub_59230(a2, 0, (char *)v93);
  v6 = v5;
  if ( !v5 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      v13 = 0;
      snprintf(s, 0x1000u, "JSON decode failed(%d): %s", v93[0], v94);
      sub_38730(7, s, 0);
      return v13;
    }
    return 0;
  }
  v7 = (_DWORD *)sub_59E20(v5, "method");
  if ( !v7 )
    goto LABEL_22;
  v8 = (_DWORD *)sub_59E20(v6, "error");
  v9 = (_DWORD *)sub_59E20(v6, "params");
  if ( v8 && *v8 != 7 )
  {
    v10 = (const char *)sub_57854(v8, 3);
    v11 = v10;
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "JSON-RPC method decode failed: %s", v10);
      sub_38730(7, s, 0);
    }
    v12 = (char *)v11;
    v13 = 0;
    free(v12);
    goto LABEL_8;
  }
  v17 = (const char *)sub_5A178(v7);
  v18 = v17;
  if ( !v17 )
    goto LABEL_22;
  if ( !strncasecmp(v17, "mining.notify", 0xDu) )
  {
    v25 = sub_292F4(v9, 0);
    v85 = sub_292F4(v9, 1u);
    v26 = sub_292F4(v9, 2u);
    v27 = sub_292F4(v9, 3u);
    v28 = sub_292F4(v9, 4u);
    v84 = sub_292F4(v9, 5u);
    v86 = sub_292F4(v9, 6u);
    if ( sub_5A008(v9, 7u) )
    {
      v30 = sub_5A008(v9, 7u);
      v29 = *v30 - 5;
      v87 = *v30 == 5;
    }
    else
    {
      v87 = 0;
    }
    v31 = v25 == 0;
    if ( v25 )
      v31 = v26 == 0;
    if ( v31 )
    {
      if ( !v25 )
      {
LABEL_141:
        if ( v26 )
          free(v26);
        if ( v28 )
          free(v28);
        if ( v27 )
          free(v27);
        if ( v85 )
          free(v85);
        if ( v86 )
          free(v86);
        v45 = 0;
        if ( v84 )
          free(v84);
        goto LABEL_131;
      }
    }
    else
    {
      v32 = v27 == 0;
      if ( v27 )
        v32 = v28 == 0;
      if ( !v32 )
      {
        v33 = v85 == 0;
        if ( v85 )
          v33 = v86 == 0;
        if ( !v33 && v84 )
        {
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            strcpy(s, "Valid Notify\n");
            sub_38730(7, s, 0);
          }
          v88 = (pthread_mutex_t *)(a1 + 61);
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
            sub_B708("parse_notify_equihash", 2142);
          rwlock = (pthread_rwlock_t *)(a1 + 67);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
          {
            v77 = _errno_location();
            snprintf(
              s,
              0x1000u,
              "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
              *v77,
              "util.c",
              "parse_notify_equihash",
              2142);
            sub_38730(3, s, 1);
            sub_16CA8(1);
          }
          free((void *)a1[168]);
          free((void *)a1[169]);
          free((void *)a1[171]);
          free((void *)a1[172]);
          free((void *)a1[173]);
          a1[168] = v25;
          a1[169] = v26;
          a1[171] = v85;
          a1[172] = v86;
          a1[173] = v84;
          *((_BYTE *)a1 + 696) = v87;
          v34 = *((double *)a1 + 231);
          if ( v34 > 0.0 )
            *((double *)a1 + 89) = v34;
          if ( v87 )
            *((_QWORD *)a1 + 81) = 0;
          v35 = strlen(v85);
          v36 = strlen(v26);
          a1[464] = v36 + v35;
          v37 = (int)(v36 + v35) / 2;
          v38 = strlen(v84);
          v39 = strlen(v86);
          a1[464] = v37;
          v31 = byte_78E09 == 0;
          v40 = 2 * ((v39 >> 1) + (v38 >> 1) + 84 + v37) + 1;
          a1[176] = v40;
          if ( !v31 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(s, 0x1000u, "%s: pool->swork.header_len = %d", "parse_notify_equihash", v40);
            sub_38730(7, s, 0);
            v40 = a1[176];
          }
          if ( (v40 & 3) != 0 )
          {
            v40 = (v40 & 0xFFFFFFFC) + 4;
            a1[176] = v40;
          }
          maxlen = v40;
          v41 = (char *)malloc(v40);
          v2 = v41;
          if ( !v41 )
          {
            snprintf(
              s,
              0x1000u,
              "%s: Failed to malloc header. in %s %s():%d",
              "parse_notify_equihash",
              "util.c",
              "parse_notify_equihash",
              2188);
            sub_38730(3, s, 1);
            sub_16CA8(1);
          }
          snprintf(
            v41,
            maxlen,
            "%s%s%s%s%s%s%s",
            (const char *)a1[171],
            (const char *)a1[169],
            v27,
            v28,
            (const char *)a1[173],
            (const char *)a1[172],
            "0000000000000000000000000000000000000000");
          if ( sub_29830((_BYTE *)a1 + 1604, (unsigned __int8 *)v2, 128) )
          {
            v42 = *(_QWORD *)&dword_7B648;
            ++a1[37];
            *(_QWORD *)&dword_7B648 = v42 + 1;
            if ( pthread_rwlock_unlock(rwlock) )
            {
              v75 = _errno_location();
              snprintf(
                s,
                0x1000u,
                "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v75,
                "util.c",
                "parse_notify_equihash",
                2214);
              sub_38730(3, s, 1);
              sub_16CA8(1);
            }
            sub_29388(v88, "parse_notify_equihash", 2214);
            off_75ED8();
            if ( a1 == (_DWORD *)sub_1DA58() )
              byte_7B8AC = 1;
            v29 = (unsigned __int8)byte_7B380;
            if ( !byte_7B380 )
              goto LABEL_129;
            v29 = (unsigned __int8)byte_78E09;
            if ( !byte_78E09 )
              goto LABEL_129;
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
            {
              snprintf(s, 0x1000u, "job_id: %s", v25);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
                goto LABEL_105;
            }
            if ( byte_78E08 || dword_766C4 > 6 )
            {
LABEL_105:
              snprintf(s, 0x1000u, "version: %s", v85);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
                goto LABEL_109;
            }
            if ( byte_78E08 || dword_766C4 > 6 )
            {
LABEL_109:
              snprintf(s, 0x1000u, "prev_hash: %s", v26);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
                goto LABEL_113;
            }
            if ( byte_78E08 || dword_766C4 > 6 )
            {
LABEL_113:
              snprintf(s, 0x1000u, "merkle: %s", v27);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
                goto LABEL_117;
            }
            if ( byte_78E08 || dword_766C4 > 6 )
            {
LABEL_117:
              snprintf(s, 0x1000u, "reserved: %s", v28);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
                goto LABEL_121;
            }
            if ( byte_78E08 || dword_766C4 > 6 )
            {
LABEL_121:
              snprintf(s, 0x1000u, "nbit: %s", v86);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
                goto LABEL_226;
            }
            if ( byte_78E08 || dword_766C4 > 6 )
            {
LABEL_226:
              snprintf(s, 0x1000u, "ntime: %s", v84);
              sub_38730(7, s, 0);
              v29 = (unsigned __int8)byte_78E09;
              if ( !byte_78E09 )
                goto LABEL_129;
              if ( byte_7AD48 )
              {
LABEL_126:
                v43 = "yes";
                if ( !v87 )
                  v43 = dword_660D4;
                snprintf(s, 0x1000u, "clean: %s", v43);
                sub_38730(7, s, 0);
                goto LABEL_129;
              }
            }
            if ( byte_78E08 )
              goto LABEL_126;
            v29 = dword_766C4;
            if ( dword_766C4 > 6 )
              goto LABEL_126;
LABEL_129:
            v44 = (struct timezone *)(unsigned __int8)byte_78CA8;
            if ( !byte_78CA8 )
            {
              sub_29830(&v90, (unsigned __int8 *)v84, 4);
              v73 = v44;
              v74 = v90;
              gettimeofday(v95, v73);
              if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
              {
                snprintf(s, 0x1000u, "stime.tv_sec %lu, block_ntime %lu\n", v95[0].tv_sec, v74);
                sub_38730(5, s, 0);
              }
              if ( v74 > v95[0].tv_sec + 3600 )
              {
                v95[0].tv_sec = v74;
                settimeofday(v95, 0);
              }
              v29 = 1;
              byte_78CA8 = 1;
            }
            v45 = 1;
LABEL_131:
            if ( v2 )
              free(v2);
            if ( v45 )
              v29 = 1;
            else
              *((_BYTE *)a1 + 667) = 0;
            if ( v45 )
            {
              *((_BYTE *)a1 + 667) = v29;
              v13 = v29;
            }
            else
            {
              v13 = 0;
            }
            goto LABEL_8;
          }
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
          {
            snprintf(s, 0x1000u, "%s: Failed to convert header to header_bin, got %s", "parse_notify_equihash", v2);
            sub_38730(4, s, 0);
          }
          sub_2930C(rwlock, "parse_notify_equihash", 2205);
          sub_29388(v88, "parse_notify_equihash", 2205);
          off_75ED8();
          sub_1FB44((int)a1);
        }
      }
    }
    free(v25);
    goto LABEL_141;
  }
  if ( !strncasecmp(v18, "mining.set_extranonce", 0x15u) )
  {
    v13 = sub_299AC((int)a1, v9, 0);
    goto LABEL_8;
  }
  if ( !strncasecmp(v18, "mining.set_difficulty", 0x15u) )
  {
    v23 = sub_5A008(v9, 0);
    sub_5A378((int)v23);
    if ( v3 == 0.0 )
    {
      v13 = 0;
      goto LABEL_8;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
      sub_B708("parse_diff", 2483);
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v80 = _errno_location();
      snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v80, "util.c", "parse_diff", 2483);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    v24 = *((double *)a1 + 230);
    *((double *)a1 + 230) = v3;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v82 = _errno_location();
      snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v82, "util.c", "parse_diff", 2486);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
    {
      v81 = _errno_location();
      snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v81, "util.c", "parse_diff", 2486);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    off_75ED8();
    if ( v3 == v24 )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        v72 = *a1;
        v13 = 1;
        snprintf(s, 0x1000u, "Pool %d difficulty set to %f", v72, v3);
        sub_38730(7, s, 0);
        goto LABEL_8;
      }
      goto LABEL_60;
    }
    if ( v3 == (double)(int)v3 )
    {
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_60;
      snprintf(s, 0x1000u, "Pool %d difficulty changed to %d", *a1, (int)v3);
    }
    else
    {
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_60;
      snprintf(s, 0x1000u, "Pool %d difficulty changed to %.1f", *a1, v3);
    }
    goto LABEL_59;
  }
  if ( !strncasecmp(v18, "client.reconnect", 0x10u) )
  {
    memset(v95, 0, 0xFFu);
    v46 = sub_5A008(v9, 0);
    v47 = (const char *)sub_5A178(v46);
    if ( !v47 )
    {
      v47 = (const char *)a1[156];
      goto LABEL_185;
    }
    v48 = (const char *)a1[156];
    v49 = strchr(v48, 46);
    if ( v49 )
    {
      v50 = strchr(v47, 46);
      if ( v50 )
      {
        if ( !strcmp(v49, v50) )
        {
LABEL_185:
          v66 = sub_5A008(v9, 1u);
          v67 = sub_5A178(v66);
          if ( !v67 )
            v67 = (_DWORD *)a1[152];
          snprintf((char *)v95, 0xFEu, "%s:%s", v47, v67);
          if ( sub_2AB54((const char *)v95, &v91, &v92) )
          {
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
            {
              snprintf(s, 0x1000u, "Stratum reconnect requested from pool %d to %s", *a1, (const char *)v95);
              sub_38730(4, s, 0);
            }
            sub_185C8(a1);
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 182)) )
              sub_B708("parse_reconnect", 2641);
            sub_28AE8((int)a1);
            v68 = a1[153];
            *((_BYTE *)a1 + 667) = 0;
            *((_BYTE *)a1 + 665) = 0;
            if ( v68 )
              close(v68);
            v69 = (void *)a1[156];
            v70 = v91;
            a1[153] = 0;
            a1[150] = v70;
            a1[156] = v70;
            free(v69);
            v71 = (void *)a1[152];
            a1[152] = v92;
            free(v71);
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 182)) )
            {
              v76 = _errno_location();
              snprintf(
                s,
                0x1000u,
                "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v76,
                "util.c",
                "parse_reconnect",
                2650);
              sub_38730(3, s, 1);
              sub_16CA8(1);
            }
            off_75ED8();
            v13 = sub_2CEC8(a1);
            goto LABEL_8;
          }
          goto LABEL_22;
        }
        if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
          goto LABEL_22;
        v51 = "Denied stratum reconnect request to non-matching domain url '%s'";
        v52 = v48;
      }
      else
      {
        if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
          goto LABEL_22;
        v52 = v47;
        v51 = "Denied stratum reconnect request to url without domain '%s'";
      }
    }
    else
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
        goto LABEL_22;
      v52 = v48;
      v51 = "Denied stratum reconnect request for pool without domain '%s'";
    }
    v13 = 0;
    snprintf(s, 0x1000u, v51, v52);
    sub_38730(3, s, 0);
    goto LABEL_8;
  }
  if ( !strncasecmp(v18, "client.get_version", 0x12u) )
  {
    v22 = sub_59E20(v6, "id");
    if ( !v22 )
      goto LABEL_43;
    v53 = sub_59E20(v6, "id");
    v54 = sub_5A248(v53);
    sprintf(s, "{\"id\": %d, \"result\": \"cgminer/4.9.0\", \"error\": null}", v54);
LABEL_42:
    v21 = strlen(s);
    v22 = sub_2B5C8((int)a1, s, v21);
LABEL_43:
    v13 = v22;
    goto LABEL_8;
  }
  if ( !strncasecmp(v18, "client.show_message", 0x13u) )
  {
    if ( !v9 )
      goto LABEL_22;
    if ( *v9 != 1 )
      goto LABEL_22;
    v64 = sub_5A008(v9, 0);
    v65 = sub_5A178(v64);
    if ( !v65 )
      goto LABEL_22;
    if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
    {
LABEL_60:
      v13 = 1;
      goto LABEL_8;
    }
    snprintf(s, 0x1000u, "Pool %d message: %s", *a1, v65);
LABEL_59:
    sub_38730(7, s, 0);
    goto LABEL_60;
  }
  if ( !strncasecmp(v18, "mining.ping", 0xBu) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "Pool %d ping", *a1);
      sub_38730(7, s, 0);
    }
    if ( sub_59E20(v6, "id") )
    {
      v19 = sub_59E20(v6, "id");
      v20 = sub_5A248(v19);
      sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v20);
      goto LABEL_42;
    }
  }
  else if ( !strncasecmp(v18, "mining.set_target", 0x11u) )
  {
    v55 = (unsigned __int8 *)sub_292F4(v9, 0);
    v56 = v55;
    if ( v55 )
    {
      sub_29830(v95, v55, 32);
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
        sub_B708("parse_target", 2714);
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
      {
        v79 = _errno_location();
        snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v79, "util.c", "parse_target", 2714);
        sub_38730(3, s, 1);
        sub_16CA8(1);
      }
      v57 = bswap32(v95[3].tv_usec);
      tv_sec = v95[2].tv_sec;
      v59 = bswap32(v95[3].tv_sec);
      tv_usec = v95[1].tv_usec;
      v61 = bswap32(v95[2].tv_usec);
      a1[25] = bswap32(v95[0].tv_sec);
      v62 = v95[1].tv_sec;
      v63 = v95[0].tv_usec;
      a1[19] = v59;
      a1[20] = v61;
      a1[21] = bswap32(tv_sec);
      a1[22] = bswap32(tv_usec);
      a1[18] = v57;
      a1[23] = bswap32(v62);
      a1[24] = bswap32(v63);
      sub_2930C((pthread_rwlock_t *)(a1 + 67), "parse_target", 2717);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
      {
        v78 = _errno_location();
        snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v78, "util.c", "parse_target", 2717);
        sub_38730(3, s, 1);
        sub_16CA8(1);
      }
      v13 = 1;
      off_75ED8();
      free(v56);
      goto LABEL_8;
    }
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(s, "parse_target: Missing an array value.");
      sub_38730(7, s, 0);
    }
  }
LABEL_22:
  v13 = 0;
LABEL_8:
  v14 = v6[1];
  if ( v14 != -1 )
  {
    v15 = v14 - 1;
    v6[1] = v15;
    if ( !v15 )
      sub_5A3E4((void **)v6);
  }
  return v13;
}
// 2D304: variable 'v3' is possibly undefined
// 2DAA4: variable 'v2' is possibly undefined
// 2DAC0: variable 'v29' is possibly undefined
// 2CEC8: using guessed type int __fastcall sub_2CEC8(_DWORD);
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78CA8: using guessed type char byte_78CA8;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B380: using guessed type char byte_7B380;
// 7B648: using guessed type int dword_7B648;
// 7B8AC: using guessed type char byte_7B8AC;

//----- (0002E69C) --------------------------------------------------------
int __fastcall sub_2E69C(int *a1)
{
  int v1; // r2
  size_t v3; // r0
  int *v4; // r5
  int v5; // r4
  int *v7; // r6
  _DWORD *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r5
  const char *v11; // r7
  char *v12; // r5
  int v13; // r3
  const char *v14; // r2
  int v15; // r3
  int v16; // r3
  char v17[252]; // [sp+Ch] [bp-3100h] BYREF
  char s[4088]; // [sp+108h] [bp-3004h] BYREF
  char v19[8196]; // [sp+1108h] [bp-2004h] BYREF

  v1 = dword_7B0F8++;
  sprintf(v19, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
  v3 = strlen(v19);
  if ( !sub_2B5C8((int)a1, v19, v3) )
    return 0;
  while ( 1 )
  {
    if ( !sub_28AFC((int)a1, 2) )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy(s, "Timed out waiting for response extranonce.subscribe");
        sub_38730(7, s, 0);
      }
      return 1;
    }
    v4 = (int *)sub_2B040((int)a1);
    if ( !v4 )
      return 0;
    if ( !sub_2CF40(a1, v4) )
      break;
    free(v4);
  }
  v7 = sub_59230(v4, 0, v17);
  free(v4);
  v8 = (_DWORD *)sub_59E20(v7, "result");
  v9 = (_DWORD *)sub_59E20(v7, "error");
  v10 = v9;
  if ( !v8 || *v8 == 6 )
  {
    if ( !v9 )
    {
      v12 = (char *)malloc(0x11u);
      if ( v12 )
        strcpy(v12, "(unknown reason)");
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  if ( v9 && *v9 != 7 )
  {
LABEL_18:
    v11 = (const char *)sub_29294(v9, 1u);
    if ( !v11 && (v11 = (const char *)sub_5A178(v10)) == 0
      || strcmp(v11, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v11, "Unrecognized request provided") )
    {
      v12 = (char *)sub_57854(v10, 3);
LABEL_22:
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 5 )
      {
        snprintf(s, 0x1000u, "Pool %d JSON extranonce subscribe failed: %s", *a1, v12);
        sub_38730(6, s, 0);
      }
      v5 = 0;
      free(v12);
      goto LABEL_31;
    }
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 5 )
      goto LABEL_41;
    v13 = *a1;
    v14 = "Cannot subscribe to mining.extranonce for pool %d";
    goto LABEL_30;
  }
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 5 )
  {
LABEL_41:
    v5 = 1;
    goto LABEL_31;
  }
  v13 = *a1;
  v14 = "Stratum extranonce subscribe for pool %d";
LABEL_30:
  v5 = 1;
  snprintf(s, 0x1000u, v14, v13);
  sub_38730(6, s, 0);
LABEL_31:
  if ( v7 )
  {
    v15 = v7[1];
    if ( v15 != -1 )
    {
      v16 = v15 - 1;
      v7[1] = v16;
      if ( !v16 )
        sub_5A3E4((void **)v7);
    }
  }
  return v5;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B0F8: using guessed type int dword_7B0F8;

//----- (0002EA38) --------------------------------------------------------
int __fastcall sub_2EA38(_DWORD *a1)
{
  const char *v1; // r12
  const char *v3; // r3
  int v4; // r2
  size_t v5; // r0
  int *v6; // r4
  int v7; // r4
  int *v9; // r7
  _DWORD *v10; // r4
  _DWORD *v11; // r0
  char *v12; // r4
  char *v13; // r0
  int v14; // r3
  int v15; // r3
  int v16; // r2
  size_t v17; // r0
  int v18; // r2
  size_t v19; // r0
  char v20[252]; // [sp+Ch] [bp-3100h] BYREF
  char s[4088]; // [sp+108h] [bp-3004h] BYREF
  char v22[8196]; // [sp+1108h] [bp-2004h] BYREF

  v1 = (const char *)a1[52];
  v3 = (const char *)a1[51];
  v4 = dword_7B0F8++;
  sprintf(v22, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v4, v3, v1);
  v5 = strlen(v22);
  if ( sub_2B5C8((int)a1, v22, v5) )
  {
    while ( 1 )
    {
      v6 = (int *)sub_2B040((int)a1);
      if ( !v6 )
        return 0;
      if ( !sub_2CF40(a1, v6) )
        break;
      free(v6);
    }
    v9 = sub_59230(v6, 0, v20);
    free(v6);
    v10 = (_DWORD *)sub_59E20(v9, "result");
    v11 = (_DWORD *)sub_59E20(v9, "error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(s, 0x1000u, "Stratum authorisation success for pool %d", *a1);
        sub_38730(7, s, 0);
      }
      *((_BYTE *)a1 + 131) = 1;
      byte_78CA9 = 1;
      if ( dword_7BB24 )
      {
        v18 = dword_7B0F8++;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v18, dword_7BB24);
        v19 = strlen(v22);
        sub_2B5C8((int)a1, v22, v19);
      }
      if ( dword_75EB4 )
      {
        v16 = dword_7B0F8++;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.multi_version\", \"params\": [%d]}", v16, dword_75EB4);
        v7 = 1;
        v17 = strlen(v22);
        sub_2B5C8((int)a1, v22, v17);
      }
      else
      {
        v7 = 1;
      }
      goto LABEL_18;
    }
    v12 = (char *)sub_57854(v11, 3);
LABEL_13:
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "pool %d JSON stratum auth failed: %s", *a1, v12);
      sub_38730(7, s, 0);
    }
    v13 = v12;
    v7 = 0;
    free(v13);
    sub_2AEE0((int)a1);
LABEL_18:
    if ( v9 )
    {
      v14 = v9[1];
      if ( v14 != -1 )
      {
        v15 = v14 - 1;
        v9[1] = v15;
        if ( !v15 )
          sub_5A3E4((void **)v9);
      }
    }
    return v7;
  }
  return 0;
}
// 75EB4: using guessed type int dword_75EB4;
// 766C4: using guessed type int dword_766C4;
// 78CA9: using guessed type char byte_78CA9;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B0F8: using guessed type int dword_7B0F8;
// 7BB24: using guessed type int dword_7BB24;

//----- (0002ED88) --------------------------------------------------------
time_t __fastcall sub_2ED88(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}
// 2EDAC: control flows out of bounds to 2EDB0

//----- (0002EF64) --------------------------------------------------------
char *__fastcall sub_2EF64(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  char *v3; // r0
  char *v4; // r6
  char *v5; // r5
  char v6; // r3
  int v7; // r2
  int v8; // t1
  char *v10; // r3
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v1 = a1;
  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(s, 0x1000u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3730);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(v1);
  v3 = (char *)malloc(4 * v2 + 5);
  v4 = v3;
  if ( !v3 )
  {
    snprintf(s, 0x1000u, "Failed to malloc txt in %s %s():%d", "util.c", "str_text", 3737);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v5 = v3;
  do
  {
    while ( 1 )
    {
      v8 = *(unsigned __int8 *)v1++;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x", v7);
      v6 = *(v1 - 1);
      v5 += 4;
      if ( !v6 )
        goto LABEL_9;
    }
    *v5++ = v7;
    v6 = *(v1 - 1);
  }
  while ( v6 );
LABEL_9:
  *v5 = v6;
  return v4;
}

//----- (0002F0B4) --------------------------------------------------------
int __fastcall sub_2F0B4(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (0002F0F4) --------------------------------------------------------
int __fastcall sub_2F0F4(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r7
  int *v9; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x1000u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (0002F174) --------------------------------------------------------
int __fastcall sub_2F174(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_2F0F4((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1312);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (0002F1BC) --------------------------------------------------------
int __fastcall sub_2F1BC(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int *v9; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = sem_post(a1);
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x1000u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v9, a1, a2, a3, a4);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (0002F23C) --------------------------------------------------------
void *__fastcall sub_2F23C(sem_t *a1)
{
  pthread_setcanceltype(1, 0);
  ((void (__fastcall *)(_DWORD))a1[1].__align)(*(&a1[1].__align + 1));
  sub_2F1BC(a1, "util.c", "completion_thread", 3963);
  return 0;
}

//----- (0002F280) --------------------------------------------------------
int __fastcall sub_2F280(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 0x1000u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
  }
  return result;
}

//----- (0002F304) --------------------------------------------------------
int __fastcall sub_2F304(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  int result; // r0
  int v9; // r3
  struct timespec abstime; // [sp+10h] [bp-101Ch] BYREF
  _DWORD v11[2]; // [sp+18h] [bp-1014h] BYREF
  struct timeval v12; // [sp+20h] [bp-100Ch] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  sub_2A84C(&v12);
  v11[1] = 1000 * v12.tv_usec;
  v11[0] = v12.tv_sec;
  sub_2A600(&abstime);
  while ( 1 )
  {
    sub_2A688(&abstime.tv_sec, v11);
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 == 110 )
      return 110;
    if ( v9 != 4 )
    {
      snprintf(s, 0x1000u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", v9, a1, a3, a4, a5);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
  }
  return result;
}

//----- (0002F400) --------------------------------------------------------
int *__fastcall sub_2F400(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (0002F438) --------------------------------------------------------
int __fastcall sub_2F438(int a1, int a2, int a3)
{
  sem_t *v6; // r0
  sem_t *v7; // r4
  _BOOL4 v8; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)malloc(0x18u);
  v7 = v6;
  if ( !v6 )
    return 0;
  sub_2F0F4(v6, "util.c", "cg_completion_timeout", 3977);
  v7[1].__align = a1;
  *(&v7[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_2F23C, v7);
  v8 = sub_2F304(v7, a3, "util.c", "cg_completion_timeout", 3983) != 0;
  if ( v8 )
  {
    pthread_cancel(newthread[0]);
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v7);
  }
  return !v8;
}

//----- (0002F64C) --------------------------------------------------------
int __fastcall sub_2F64C(int a1, char a2)
{
  int v3; // r1
  unsigned int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1
  unsigned int v7; // r1

  switch ( a1 )
  {
    case 1:
      return 1;
    case 2:
      if ( (a2 & 0x80) == 0 )
        return 1;
      return 2;
    case 4:
      v3 = a2 & 0xC0;
      switch ( v3 )
      {
        case 128:
          return 3;
        case 192:
          return 4;
        case 64:
          return 2;
        default:
          return 1;
      }
    case 8:
      v4 = a2 & 0xE0;
      if ( v4 == 128 )
        return 5;
      if ( v4 > 0x80 )
      {
        if ( v4 == 192 )
          return 7;
        if ( v4 == 224 )
          return 8;
        if ( v4 != 160 )
          return 1;
        return 6;
      }
      if ( v4 == 64 )
        return 3;
      if ( v4 == 96 )
        return 4;
      if ( v4 != 32 )
        return 1;
      return 2;
    case 16:
      v5 = a2 & 0xF0;
      if ( v5 == 128 )
        return 9;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
        {
          return 5;
        }
        else if ( v5 > 0x40 )
        {
          switch ( v5 )
          {
            case '`':
              return 7;
            case 'p':
              return 8;
            case 'P':
              return 6;
            default:
              return 1;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 0x20u:
              return 3;
            case 0x30u:
              return 4;
            case 0x10u:
              return 2;
            default:
              return 1;
          }
        }
      }
      else if ( v5 == 192 )
      {
        return 13;
      }
      else if ( v5 > 0xC0 )
      {
        switch ( v5 )
        {
          case 0xE0u:
            return 15;
          case 0xF0u:
            return 16;
          case 0xD0u:
            return 14;
          default:
            return 1;
        }
      }
      else
      {
        switch ( v5 )
        {
          case 0xA0u:
            return 11;
          case 0xB0u:
            return 12;
          case 0x90u:
            return 10;
          default:
            return 1;
        }
      }
    case 32:
      v6 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v6 > 0xF0 )
        return 1;
      return aClearSock[v6 + 1928];
    case 64:
      v7 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v7 > 0xF8 )
        return 1;
      return aClearSock[v7 + 2172];
    default:
      return 0;
  }
}
// 2F658: control flows out of bounds to 2F65C

//----- (0002F934) --------------------------------------------------------
void __fastcall sub_2F934(_DWORD *a1, char *a2, int a3)
{
  int v4; // r12
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // lr
  int v12; // r1
  int v13; // r2
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r3
  char v20; // r3
  _DWORD *v21; // r2
  int i; // r3
  char v23; // r1
  _DWORD *v24; // r2
  int j; // r3
  char v26; // r1
  unsigned int *v27; // r2
  int k; // r3
  char v29; // r1
  char *v30; // r8
  char *v31; // r5
  char *v32; // r4
  char *v33; // r10
  char *v34; // r7
  char *v35; // r6
  __int64 v36; // kr00_8
  size_t v37; // r0
  bool v38; // zf
  unsigned __int64 v39; // r2
  int m; // r11
  size_t v41; // r0
  size_t v42; // r0
  size_t v43; // r0
  int v44; // r11
  size_t v45; // r0
  size_t v46; // r0
  _DWORD v49[8]; // [sp+30h] [bp-14B4h] BYREF
  _DWORD v50[2]; // [sp+50h] [bp-1494h] BYREF
  int v51; // [sp+58h] [bp-148Ch]
  int v52; // [sp+5Ch] [bp-1488h]
  int v53; // [sp+60h] [bp-1484h]
  int v54; // [sp+64h] [bp-1480h]
  int v55; // [sp+68h] [bp-147Ch]
  int v56; // [sp+6Ch] [bp-1478h]
  _DWORD v57[8]; // [sp+70h] [bp-1474h] BYREF
  unsigned int v58[20]; // [sp+90h] [bp-1454h] BYREF
  char s[1024]; // [sp+E0h] [bp-1404h] BYREF
  char v60[4064]; // [sp+4E0h] [bp-1004h] BYREF

  if ( dword_76BE8 )
  {
    memset(s, 0, sizeof(s));
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    memset(v58, 0, sizeof(v58));
    v4 = 0;
    v5 = a1[33];
    v6 = a1[34];
    v7 = a1[35];
    v49[0] = a1[32];
    v49[1] = v5;
    v49[2] = v6;
    v49[3] = v7;
    v8 = a1[37];
    v9 = a1[38];
    v10 = a1[39];
    v49[4] = a1[36];
    v49[5] = v8;
    v49[6] = v9;
    v49[7] = v10;
    v11 = v49;
    v12 = a1[17];
    v13 = a1[18];
    v50[0] = a1[16];
    v50[1] = v12;
    v51 = v13;
    v14 = a1[49];
    v15 = a1[50];
    v16 = a1[51];
    v57[0] = a1[48];
    v57[1] = v14;
    v57[2] = v15;
    v57[3] = v16;
    v17 = a1[53];
    v18 = a1[54];
    v19 = a1[55];
    v57[4] = a1[52];
    v57[5] = v17;
    v57[6] = v18;
    v57[7] = v19;
    do
    {
      v20 = *((_BYTE *)v49 + v4);
      *((_BYTE *)v49 + v4++) = *((_BYTE *)v11 + 31);
      *((_BYTE *)v11 + 31) = v20;
      v11 = (_DWORD *)((char *)v11 - 1);
    }
    while ( v4 != 16 );
    v21 = v50;
    for ( i = 0; i != 6; ++i )
    {
      v23 = *((_BYTE *)v50 + i);
      *((_BYTE *)v50 + i) = *((_BYTE *)v21 + 11);
      *((_BYTE *)v21 + 11) = v23;
      v21 = (_DWORD *)((char *)v21 - 1);
    }
    v24 = v57;
    for ( j = 0; j != 16; ++j )
    {
      v26 = *((_BYTE *)v57 + j);
      *((_BYTE *)v57 + j) = *((_BYTE *)v24 + 31);
      *((_BYTE *)v24 + 31) = v26;
      v24 = (_DWORD *)((char *)v24 - 1);
    }
    if ( byte_7B859 )
    {
      memcpy(v58, a1, sizeof(v58));
      v27 = v58;
      for ( k = 0; k != 40; ++k )
      {
        v29 = *((_BYTE *)v58 + k);
        *((_BYTE *)v58 + k) = *((_BYTE *)v27 + 79);
        *((_BYTE *)v27 + 79) = v29;
        v27 = (unsigned int *)((char *)v27 - 1);
      }
      v58[0] = bswap32(16 * bswap32(v58[0]));
      v30 = sub_29730((int)v58, 80);
    }
    else
    {
      v30 = sub_29730((int)a1, 128);
    }
    v31 = sub_29730((int)v49, 32);
    v32 = sub_29730((int)v50, 12);
    v33 = sub_29730((int)a2, 4);
    v34 = sub_29730((int)a2, 5);
    v35 = sub_29730((int)v57, 32);
    v36 = sub_158E4((__int64 *)a1);
    if ( !strcmp((const char *)dword_76BE8, "screen") )
    {
      if ( a3 )
      {
        sprintf(s, "work %s nonce %s", v30, v33);
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf(v60, 0x1000u, s);
          sub_38730(3, v60, 0);
        }
        v43 = strlen(s);
        fwrite(s, v43, 1u, (FILE *)dword_78954);
        fwrite(ptr, 1u, 1u, (FILE *)dword_78954);
        fflush((FILE *)dword_78954);
      }
    }
    else
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf(v60, 0x1000u, s);
        sub_38730(3, v60, 0);
      }
      if ( dword_78954 )
      {
        if ( a3 )
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
            "o",
            a1[457],
            v30,
            v31,
            v32,
            v34,
            v35,
            v36);
          v37 = strlen(s);
          fwrite(s, v37, 1u, (FILE *)dword_78954);
          fwrite(ptr, 1u, 1u, (FILE *)dword_78954);
          fflush((FILE *)dword_78954);
          if ( dword_78950 == 1 )
          {
            sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
            v46 = strlen(s);
            fwrite(s, v46, 1u, (FILE *)dword_78958[0]);
            fwrite(ptr, 1u, 1u, (FILE *)dword_78958[0]);
            fflush((FILE *)dword_78958[0]);
          }
          else
          {
            v38 = dword_78950 == 32;
            if ( dword_78950 != 32 )
              v38 = dword_78950 == 64;
            if ( v38 )
            {
              sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
              v44 = sub_2F64C(dword_78950, *a2);
              v45 = strlen(s);
              fwrite(s, v45, 1u, (FILE *)dword_78958[v44]);
              fwrite(ptr, 1u, 1u, (FILE *)dword_78958[v44]);
              fflush((FILE *)dword_78958[v44]);
            }
          }
          if ( byte_78A5C )
          {
            v39 = v36;
            for ( m = 0; m != 64; ++m )
            {
              v39 >>= 1;
              if ( !v39 )
                break;
            }
            if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
            {
              snprintf(v60, 0x1000u, "work diff %lld diffnum %d", v36, m);
              sub_38730(7, v60, 0);
            }
            sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
            v41 = strlen(s);
            fwrite(s, v41, 1u, *((FILE **)&unk_78A60 + m));
            fwrite(ptr, 1u, 1u, *((FILE **)&unk_78A60 + m));
            fflush(*((FILE **)&unk_78A60 + m));
          }
        }
        else
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
            "x",
            a1[457],
            v30,
            v31,
            v32,
            v34,
            v35,
            v36);
          v42 = strlen(s);
          fwrite(s, v42, 1u, (FILE *)dword_78954);
          fwrite(ptr, 1u, 1u, (FILE *)dword_78954);
          fflush((FILE *)dword_78954);
        }
      }
    }
    if ( v30 )
      free(v30);
    if ( v31 )
      free(v31);
    if ( v32 )
      free(v32);
    if ( v33 )
      free(v33);
    if ( v34 )
      free(v34);
    if ( v35 )
      free(v35);
  }
}
// 766C4: using guessed type int dword_766C4;
// 76BE8: using guessed type int dword_76BE8;
// 78950: using guessed type int dword_78950;
// 78954: using guessed type int dword_78954;
// 78958: using guessed type int dword_78958[];
// 78A5C: using guessed type char byte_78A5C;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B859: using guessed type char byte_7B859;

//----- (00030074) --------------------------------------------------------
void __fastcall sub_30074(_DWORD *a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-Ch] BYREF
  char v4; // [sp+4h] [bp-8h]

  if ( dword_76BE8 )
  {
    v4 = 0;
    v3 = a2;
    sub_2F934(a1, (char *)&v3, a3);
  }
}
// 76BE8: using guessed type int dword_76BE8;

//----- (000300B0) --------------------------------------------------------
unsigned int __fastcall sub_300B0(unsigned int result, int a2, int a3)
{
  int *v3; // r1
  int v4; // r0
  int i; // r3
  unsigned int *v6; // r2
  _DWORD *v7; // r3
  int j; // r2
  int v9; // r12
  int *v10; // r2
  unsigned int v11; // r3
  int v12; // r1
  int *v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r5
  int v17; // r4
  int v18; // r9
  unsigned int v19; // r2
  unsigned int v20; // r12
  unsigned int v21; // r6
  int v22; // r11
  int v23; // r8
  int v24; // r7
  int v25; // r8
  unsigned int v26; // r10
  int v27; // r1
  unsigned int v28; // r3
  int *v29; // [sp+0h] [bp-138h] BYREF
  int v30; // [sp+4h] [bp-134h]
  unsigned int v31; // [sp+8h] [bp-130h]
  unsigned int v32; // [sp+Ch] [bp-12Ch]
  int v33; // [sp+10h] [bp-128h]
  int v34; // [sp+14h] [bp-124h] BYREF
  _DWORD *v35; // [sp+18h] [bp-120h]
  _DWORD *v36; // [sp+1Ch] [bp-11Ch]
  _DWORD *v37; // [sp+20h] [bp-118h]
  unsigned int v38; // [sp+24h] [bp-114h]
  int v39; // [sp+28h] [bp-110h]
  int v40; // [sp+2Ch] [bp-10Ch]
  int v41; // [sp+30h] [bp-108h]
  int v42; // [sp+34h] [bp-104h] BYREF
  _BYTE v43[256]; // [sp+38h] [bp-100h] BYREF

  v33 = a3;
  v31 = result;
  v34 = a2;
  if ( a3 > 0 )
  {
    v29 = &v42;
    v30 = 0;
    do
    {
      v3 = &v42;
      v4 = v34 + (v30 << 6);
      for ( i = 0; i != 16; ++i )
      {
        v6 = (unsigned int *)(v4 + 4 * i);
        v3[1] = _byteswap_ulong(*v6);
        ++v3;
      }
      v7 = v43;
      for ( j = 0; j != 192; j += 4 )
      {
        v9 = *(_DWORD *)&v43[j];
        v7[16] = v7[9]
               + v9
               + (__ROR4__(v7[14], 17) ^ __ROR4__(v7[14], 19) ^ (v7[14] >> 10))
               + (__ROR4__(v7[1], 7) ^ __ROR4__(v7[1], 18) ^ (v7[1] >> 3));
        ++v7;
      }
      v10 = &v34;
      v11 = v31;
      v32 = v31;
      do
      {
        v12 = *(_DWORD *)(v11 + 136);
        v11 += 4;
        v13 = v29;
        v10[1] = v12;
        ++v10;
      }
      while ( v10 != v13 );
      v14 = 0;
      v15 = v39;
      v16 = v40;
      v17 = v41;
      v18 = v42;
      v19 = (unsigned int)v35;
      v20 = (unsigned int)v36;
      result = (unsigned int)v37;
      v21 = v38;
      while ( 1 )
      {
        v22 = *(_DWORD *)&v43[v14];
        v23 = *(_DWORD *)((char *)&unk_75FDC + v14);
        v14 += 4;
        v24 = v22 + v23 + (__ROR4__(v15, 6) ^ __ROR4__(v15, 11) ^ __ROR4__(v15, 25)) + (v17 & ~v15 ^ v16 & v15) + v18;
        v18 = v17;
        v25 = v21 + v24;
        v26 = ((v20 ^ result) & v19 ^ result & v20) + (__ROR4__(v19, 2) ^ __ROR4__(v19, 13) ^ __ROR4__(v19, 22)) + v24;
        v21 = result;
        if ( v14 == 256 )
          break;
        result = v20;
        v17 = v16;
        v20 = v19;
        v16 = v15;
        v19 = v26;
        v15 = v25;
      }
      v40 = v15;
      v27 = 0;
      v42 = v17;
      v39 = v25;
      v41 = v16;
      v35 = (_DWORD *)v26;
      v36 = (_DWORD *)v19;
      v37 = (_DWORD *)v20;
      v38 = result;
      v28 = v32;
      while ( 1 )
      {
        ++v27;
        *(_DWORD *)(v28 + 136) += v26;
        v28 += 4;
        if ( v27 == 8 )
          break;
        result = (unsigned int)&v29;
        v26 = (unsigned int)(&v29)[v27 + 6];
      }
      ++v30;
    }
    while ( v33 != v30 );
  }
  return result;
}

//----- (000302D0) --------------------------------------------------------
_DWORD *__fastcall sub_302D0(_DWORD *result)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r2
  int v3; // t1

  v1 = &unk_760D8;
  v2 = result;
  do
  {
    v3 = v1[1];
    ++v1;
    v2[34] = v3;
    ++v2;
  }
  while ( v1 != (_DWORD *)&unk_760F8 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00030304) --------------------------------------------------------
void *__fastcall sub_30304(int *a1, const void *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r6
  int v8; // r0
  void *result; // r0
  unsigned int v10; // r3
  unsigned int v11; // r5
  size_t v12; // r8
  int v13; // r6
  int v14; // r3

  v4 = a1[1];
  v7 = 64 - v4;
  v8 = v4 + 8;
  if ( n < v7 )
    v7 = n;
  result = memcpy((char *)a1 + v8, a2, v7);
  v10 = n + a1[1];
  if ( v10 > 0x3F )
  {
    v11 = n - v7;
    v12 = v11 & 0x3F;
    v13 = (int)a2 + v7;
    v11 >>= 6;
    sub_300B0((unsigned int)a1, (int)(a1 + 2), 1);
    sub_300B0((unsigned int)a1, v13, v11);
    result = memcpy(a1 + 2, (const void *)(v13 + (v11 << 6)), v12);
    v14 = *a1;
    a1[1] = v12;
    *a1 = v14 + ((v11 + 1) << 6);
  }
  else
  {
    a1[1] = v10;
  }
  return result;
}

//----- (000303A4) --------------------------------------------------------
_DWORD *__fastcall sub_303A4(_DWORD *a1, int a2)
{
  int v3; // r3
  int v5; // r6
  char *v6; // r0
  int v7; // r6
  int v8; // r2
  size_t v9; // r2
  int v10; // r8
  int v11; // r10
  int v12; // r9
  int v13; // r11
  int v14; // r7
  int v15; // r6
  _DWORD *result; // r0
  int i; // r3
  _BYTE *v18; // r2

  v3 = a1[1];
  v5 = *a1;
  v6 = (char *)a1 + v3 + 8;
  v7 = v3 + v5;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v8 = 128;
  else
    v8 = 64;
  v9 = v8 - v3;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v10 = 31;
  else
    v10 = 15;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v11 = 125;
  else
    v11 = 61;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v12 = 126;
  else
    v12 = 62;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v13 = 127;
  else
    v13 = 63;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v14 = 2;
  else
    v14 = 1;
  memset(v6, 0, v9);
  v15 = 8 * v7;
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  *((_BYTE *)a1 + v13 + 8) = v15;
  *((_BYTE *)a1 + v12 + 8) = BYTE1(v15);
  *((_BYTE *)a1 + v11 + 8) = BYTE2(v15);
  LOBYTE(a1[v10 + 2]) = HIBYTE(v15);
  sub_300B0((unsigned int)a1, (int)(a1 + 2), v14);
  result = a1;
  for ( i = 0; i != 8; ++i )
  {
    v18 = (_BYTE *)(a2 + 4 * i);
    v18[3] = result[34];
    v18[2] = BYTE1(result[34]);
    v18[1] = *((_WORD *)result + 69);
    LOBYTE(v18) = *((_BYTE *)result++ + 139);
    *(_BYTE *)(a2 + 4 * i) = (_BYTE)v18;
  }
  return result;
}

//----- (0003049C) --------------------------------------------------------
_DWORD *__fastcall sub_3049C(const void *a1, size_t n, int a3)
{
  _DWORD *v3; // r3
  char *v4; // r12
  int v6; // t1
  int v8[33]; // [sp+0h] [bp-A8h] BYREF
  char v9; // [sp+84h] [bp-24h] BYREF

  v3 = &unk_760D8;
  v4 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *((_DWORD *)v4 + 1) = v6;
    v4 += 4;
  }
  while ( v3 != (_DWORD *)&unk_760F8 );
  v8[0] = 0;
  v8[1] = 0;
  sub_30304(v8, a1, n);
  return sub_303A4(v8, a3);
}

//----- (00030500) --------------------------------------------------------
char *__fastcall sub_30500(char *s, int a2)
{
  unsigned int v2; // r4
  char *v3; // r8
  char *v5; // r6
  char *v6; // r2
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // t1
  unsigned int v10; // t1
  size_t v12; // r5
  _BYTE *v13; // r0
  _BYTE *v14; // r3
  char *v15; // r2
  unsigned int v16; // t1
  char sa[4100]; // [sp+10h] [bp-1004h] BYREF

  v2 = (unsigned __int8)*s;
  v3 = s;
  if ( *s )
  {
    v5 = s;
    v6 = s;
    v7 = (unsigned __int8)*s;
    v8 = 0;
    while ( 1 )
    {
      if ( v7 == 61 )
        goto LABEL_10;
      if ( v7 <= 0x3D )
      {
        if ( v7 == 34 )
        {
          if ( a2 )
            goto LABEL_11;
          goto LABEL_5;
        }
        if ( v7 != 44 )
          goto LABEL_5;
LABEL_10:
        if ( !a2 )
          goto LABEL_11;
LABEL_5:
        v9 = (unsigned __int8)*++v6;
        v7 = v9;
        if ( !v9 )
          goto LABEL_12;
      }
      else
      {
        if ( v7 != 92 )
        {
          if ( v7 != 124 )
            goto LABEL_5;
          goto LABEL_10;
        }
LABEL_11:
        v10 = (unsigned __int8)*++v6;
        v7 = v10;
        ++v8;
        if ( !v10 )
        {
LABEL_12:
          if ( !v8 )
            return v3;
          v12 = v8 + 1 + strlen(s);
          v13 = malloc(v12);
          if ( !v13 )
          {
            snprintf(sa, 0x1000u, "Failed to malloc escape buf %d in %s %s():%d", v12, "api.c", "escape_string", 840);
            sub_38730(3, sa, 1);
            sub_16CA8(1);
          }
          v14 = v13;
          v15 = v3 + 1;
          while ( 2 )
          {
            if ( !v2 )
            {
              v3 = v13;
              *v14 = 0;
              return v3;
            }
            if ( v2 == 61 )
            {
LABEL_28:
              if ( a2 )
                goto LABEL_21;
            }
            else
            {
              if ( v2 > 0x3D )
              {
                if ( v2 == 92 )
                {
                  *v14 = 92;
                  v14[1] = *(v15 - 1);
                  v14 += 2;
                }
                else
                {
                  if ( v2 == 124 )
                    goto LABEL_28;
LABEL_21:
                  *v14++ = v2;
                }
                v16 = (unsigned __int8)*++v5;
                v2 = v16;
                ++v15;
                continue;
              }
              if ( v2 != 34 )
              {
                if ( v2 == 44 )
                  goto LABEL_28;
                goto LABEL_21;
              }
              if ( !a2 )
                goto LABEL_21;
            }
            break;
          }
          *v14++ = 92;
          LOBYTE(v2) = *(v15 - 1);
          goto LABEL_21;
        }
      }
    }
  }
  return v3;
}

//----- (0003069C) --------------------------------------------------------
void sub_3069C()
{
  JUMPOUT(0x305CC);
}
// 306A4: control flows out of bounds to 305CC

//----- (000306B4) --------------------------------------------------------
void *__fastcall sub_306B4(int a1, char *s)
{
  void **v2; // r5
  size_t v5; // r0
  char *v6; // r10
  unsigned int v7; // r1
  char *v8; // r6
  size_t v9; // r4
  size_t v10; // r9
  void *result; // r0
  int v12; // r11
  char sa[4100]; // [sp+18h] [bp-1004h] BYREF

  v2 = *(void ***)(a1 + 12);
  v5 = strlen(s);
  v6 = (char *)v2[1];
  v7 = (unsigned int)v2[2];
  v8 = (char *)*v2;
  v9 = v5;
  v10 = v5 + 1;
  if ( (unsigned int)&v6[v5 + 1] > v7 )
  {
    v12 = v5 + 4097 - (v10 & 0xFFF);
    v8 = (char *)realloc(*v2, v12 + v7);
    *v2 = v8;
    if ( !v8 )
    {
      snprintf(
        sa,
        0x1000u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v9,
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8),
        v12,
        "api.c",
        "add_item_buf",
        1179);
      sub_38730(3, sa, 1);
      sub_16CA8(1);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8) += v12;
  }
  result = memcpy(&v6[(_DWORD)v8], s, v10);
  *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) += v9;
  return result;
}

//----- (000307C8) --------------------------------------------------------
int __fastcall sub_307C8(unsigned int *a1, char *s)
{
  size_t v4; // r5
  _BYTE *v5; // r0
  char *v6; // r3
  int v7; // r8
  unsigned int v8; // r2
  size_t v9; // r7
  char *v10; // r0

  v4 = strlen(s);
  v5 = (_BYTE *)a1[1];
  v6 = (char *)a1[2];
  v7 = v6 - v5;
  v8 = v6 - v5 + 12 + v4;
  if ( v8 > *a1 )
  {
    v9 = *a1 + 0x20000;
    if ( v8 > v9 )
      v9 = ((unsigned int)vcvts_n_f32_u32(v8, 0x10u) + 2) << 16;
    v10 = (char *)realloc(v5, v9);
    *a1 = v9;
    v6 = &v10[v7];
    a1[1] = (unsigned int)v10;
    a1[2] = (unsigned int)&v10[v7];
  }
  memcpy(v6, s, v4 + 1);
  a1[2] += v4;
  return 1;
}

//----- (0003085C) --------------------------------------------------------
void __fastcall sub_3085C(unsigned int *a1, char *s, int a3, _BYTE *a4)
{
  char *v6; // r5

  if ( *a4 )
  {
    if ( !a3 )
    {
      *a4 = 0;
      goto LABEL_5;
    }
    sub_307C8(a1, "{");
    *a4 = 0;
    v6 = sub_30500(s, 1);
  }
  else
  {
    if ( !a3 )
    {
LABEL_5:
      v6 = sub_30500(s, a3);
      sub_307C8(a1, "CMD=");
      sub_307C8(a1, v6);
      sub_307C8(a1, (char *)delim);
      if ( v6 == s )
        return;
      goto LABEL_6;
    }
    sub_307C8(a1, (char *)",");
    v6 = sub_30500(s, 1);
  }
  sub_307C8(a1, (char *)"\"");
  sub_307C8(a1, v6);
  sub_307C8(a1, "\":[");
  if ( v6 != s )
LABEL_6:
    free(v6);
}

//----- (00030968) --------------------------------------------------------
int __fastcall sub_30968(unsigned int *a1, char *s)
{
  _BYTE *v2; // r12

  v2 = (_BYTE *)a1[1];
  a1[2] = (unsigned int)v2;
  *v2 = 0;
  *((_BYTE *)a1 + 13) = 0;
  return sub_307C8(a1, s);
}

//----- (00030980) --------------------------------------------------------
int __fastcall sub_30980(unsigned int *a1, int a2, int a3, int a4)
{
  char *v4; // r1
  int result; // r0

  if ( a4 )
    v4 = "{\"STATUS\":\"RESTART\"";
  else
    v4 = "RESTART";
  result = sub_30968(a1, v4);
  byte_78CAC = 1;
  byte_78CAD = 1;
  return result;
}
// 78CAC: using guessed type char byte_78CAC;
// 78CAD: using guessed type char byte_78CAD;

//----- (000309B4) --------------------------------------------------------
int __fastcall sub_309B4(unsigned int *a1, int a2, int a3, int a4)
{
  char *v4; // r1
  int result; // r0

  if ( a4 )
    v4 = "{\"STATUS\":\"BYE\"";
  else
    v4 = "BYE";
  result = sub_30968(a1, v4);
  byte_78CAC = 1;
  byte_78CAE = 1;
  return result;
}
// 78CAC: using guessed type char byte_78CAC;
// 78CAE: using guessed type char byte_78CAE;

//----- (000309E8) --------------------------------------------------------
bool __fastcall sub_309E8(const struct sockaddr *a1, const char **a2, _BYTE *a3)
{
  char *v6; // r0
  int v7; // r7
  int v8; // r2
  char *v9; // r1
  int v10; // r3
  int v11; // r4
  int v12; // r0
  int v13; // t1
  int v14; // t1
  _BOOL4 result; // r0
  int v16; // r5
  char v17; // [sp+Fh] [bp-35h] BYREF
  _BOOL4 buf; // [sp+10h] [bp-34h] BYREF
  int v19; // [sp+14h] [bp-30h]
  int v20; // [sp+18h] [bp-2Ch]
  int v21; // [sp+1Ch] [bp-28h] BYREF
  char s[36]; // [sp+20h] [bp-24h] BYREF

  v6 = (char *)malloc(0x2Eu);
  *a2 = v6;
  getnameinfo(a1, 0x80u, v6, 0x2Eu, 0, 0, 1u);
  if ( a1->sa_family == 2 )
  {
    sprintf(s, "::ffff:%s", *a2);
    inet_pton(10, s, &buf);
  }
  else
  {
    inet_pton(10, *a2, &buf);
  }
  *a3 = (*_ctype_toupper_loc())[82];
  if ( dword_78C98 )
  {
    if ( dword_78CB0 > 0 )
    {
      v7 = 0;
      v8 = dword_78CB4 - 1;
      do
      {
        v9 = &v17;
        v10 = v8;
        while ( 1 )
        {
          v11 = *(unsigned __int8 *)(v10 + 17);
          v13 = (unsigned __int8)*++v9;
          v12 = v13;
          v14 = *(unsigned __int8 *)++v10;
          if ( v14 != (v11 & v12) )
            break;
          if ( v9 == (char *)&v21 + 3 )
          {
            result = 1;
            *a3 = *(_BYTE *)(v8 + 33);
            return result;
          }
        }
        ++v7;
        v8 += 36;
      }
      while ( v7 != dword_78CB0 );
    }
    return 0;
  }
  else
  {
    v16 = (unsigned __int8)byte_7B7C4;
    if ( byte_7B7C4 || !strcmp(*a2, "127.0.0.1") )
    {
      return 1;
    }
    else
    {
      result = buf;
      if ( buf )
      {
        return v16;
      }
      else if ( !v19 )
      {
        if ( v20 )
          return v19;
        else
          return v21 == 0x1000000;
      }
    }
  }
  return result;
}
// 78C98: using guessed type int dword_78C98;
// 78CB0: using guessed type int dword_78CB0;
// 78CB4: using guessed type int dword_78CB4;
// 7B7C4: using guessed type char byte_7B7C4;

//----- (00030B88) --------------------------------------------------------
void __fastcall sub_30B88(int a1, int a2, int a3)
{
  char *v4; // r7
  signed int v5; // r0
  const char *v6; // r3
  signed int v7; // r4
  int v8; // r5
  int v9; // r9
  _BOOL4 v10; // r3
  fd_set *p_tv_usec; // r3
  int v12; // r0
  ssize_t v13; // r0
  ssize_t v14; // r12
  int v15; // r0
  char *v16; // r0
  ssize_t v17; // [sp+8h] [bp-1094h]
  ssize_t v18; // [sp+8h] [bp-1094h]
  signed int v20; // [sp+Ch] [bp-1090h]
  struct timeval timeout; // [sp+10h] [bp-108Ch] BYREF
  fd_set writefds; // [sp+18h] [bp-1084h] BYREF
  char s[4072]; // [sp+98h] [bp-1004h] BYREF

  v4 = *(char **)(a1 + 4);
  if ( *(_BYTE *)(a1 + 13) )
  {
    *(_WORD *)&v4[strlen(*(const char **)(a1 + 4))] = 93;
    if ( !a3 )
      goto LABEL_3;
  }
  else if ( !a3 )
  {
    goto LABEL_3;
  }
  strcat(v4, ",\"id\":1}");
LABEL_3:
  v5 = strlen(v4);
  v20 = v5 + 1;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    if ( v5 > 10 )
      v6 = "...";
    else
      v6 = "";
    snprintf(s, 0x1000u, "API: send reply: (%d) '%.10s%s'", v20, v4, v6);
    sub_38730(7, s, 0);
  }
  v7 = v20;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = v7 > 0;
    if ( v9 > 4 )
      v10 = 0;
    if ( !v10 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&writefds.__fds_bits[31] );
    writefds.__fds_bits[a2 / 32] |= 1 << (a2 % 32);
    v12 = select(a2 + 1, 0, &writefds, 0, &timeout);
    if ( v12 <= 0 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, "API: send select failed (%d)", v12);
        sub_38730(4, s, 0);
      }
      return;
    }
    v13 = send(a2, v4, v7, 0);
    ++v8;
    v14 = v13;
    if ( v13 < 0 )
    {
      v15 = *_errno_location();
      if ( v15 != 11 )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          v16 = strerror(v15);
          snprintf(s, 0x1000u, "API: send (%d:%d) failed: %s", v20, v20 - v7, v16);
          sub_38730(4, s, 0);
        }
        return;
      }
LABEL_25:
      ++v9;
    }
    else if ( v8 == 1 )
    {
      if ( v13 != v7 )
      {
        if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
          goto LABEL_24;
        v17 = v13;
        snprintf(s, 0x1000u, "API: sent %d of %d first go", v13, v7);
        goto LABEL_23;
      }
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        v18 = v13;
        snprintf(s, 0x1000u, "API: sent all of %d first go", v13);
        goto LABEL_41;
      }
LABEL_42:
      v7 -= v14;
      v4 += v14;
    }
    else
    {
      if ( v13 == v7 )
      {
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          v18 = v13;
          snprintf(s, 0x1000u, "API: sent all of remaining %d (sendc=%d)", v13, v8);
LABEL_41:
          sub_38730(7, s, 0);
          v14 = v18;
          goto LABEL_42;
        }
        goto LABEL_42;
      }
      if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        goto LABEL_24;
      v17 = v13;
      snprintf(s, 0x1000u, "API: sent %d of remaining %d (sendc=%d)", v13, v7, v8);
LABEL_23:
      sub_38730(7, s, 0);
      v14 = v17;
LABEL_24:
      v7 -= v14;
      v4 += v14;
      if ( !v14 )
        goto LABEL_25;
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003107C) --------------------------------------------------------
int sub_3107C()
{
  struct addrinfo *v0; // r4
  struct addrinfo *i; // r3
  int v2; // r0
  int v3; // r9
  time_t v4; // r7
  int ai_family; // r3
  const char *v6; // r7
  size_t v7; // r0
  size_t v8; // r4
  int v9; // r5
  ssize_t v10; // r4
  _BOOL4 v11; // r12
  const char *v12; // r2
  int *v13; // r0
  char *v14; // r8
  struct addrinfo *v15; // r0
  int *v16; // r0
  char *v17; // r0
  int *v19; // r0
  char *v20; // r0
  const char *v21; // r4
  int v22; // r0
  struct addrinfo *v23; // r4
  int v24; // r0
  int v25; // r12
  size_t v26; // r0
  ssize_t v27; // r4
  int *v28; // r0
  char *v29; // r0
  int *v30; // r0
  char *v31; // r0
  int v32; // r0
  int v33; // r1
  int v34; // r2
  int v35; // r3
  _BOOL4 v36; // [sp+14h] [bp-18F0h]
  int v37; // [sp+14h] [bp-18F0h]
  size_t n; // [sp+18h] [bp-18ECh]
  char *v39; // [sp+1Ch] [bp-18E8h]
  int fd; // [sp+20h] [bp-18E4h]
  char v41; // [sp+2Bh] [bp-18D9h] BYREF
  socklen_t addr_len; // [sp+2Ch] [bp-18D8h] BYREF
  const char *v43; // [sp+30h] [bp-18D4h] BYREF
  struct addrinfo *pai; // [sp+34h] [bp-18D0h] BYREF
  int optval; // [sp+38h] [bp-18CCh] BYREF
  char v46[12]; // [sp+3Ch] [bp-18C8h] BYREF
  char s[12]; // [sp+48h] [bp-18BCh] BYREF
  char serv[12]; // [sp+54h] [bp-18B0h] BYREF
  struct addrinfo req; // [sp+60h] [bp-18A4h] BYREF
  struct sockaddr v50[8]; // [sp+80h] [bp-1884h] BYREF
  char v51[1024]; // [sp+100h] [bp-1804h] BYREF
  int v52; // [sp+500h] [bp-1404h] BYREF
  int v53; // [sp+504h] [bp-1400h]
  int v54; // [sp+508h] [bp-13FCh]
  int v55; // [sp+50Ch] [bp-13F8h]
  int v56; // [sp+510h] [bp-13F4h]
  char v57[4100]; // [sp+900h] [bp-1004h] BYREF

  strcpy(v46, "cgminer-");
  sprintf(s, "%d", dword_75EBC);
  memset(&req, 0, sizeof(req));
  if ( getaddrinfo(off_75EC8[0], s, &req, &pai) )
  {
    strcpy(v57, "Invalid API Multicast Address");
    sub_38730(3, v57, 1);
    sub_16CA8(1);
  }
  v0 = pai;
  if ( !pai )
  {
    v15 = 0;
LABEL_43:
    freeaddrinfo(v15);
    strcpy(v57, "API mcast could not open socket");
    sub_38730(3, v57, 1);
    sub_16CA8(1);
  }
  for ( i = pai; ; i = pai )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      v3 = v2;
      goto LABEL_8;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  v3 = v2;
  if ( v2 == -1 )
  {
    v15 = pai;
    goto LABEL_43;
  }
LABEL_8:
  optval = 1;
  if ( setsockopt(v3, 1, 2, &optval, 4u) < 0 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
      return close(v3);
    v16 = _errno_location();
    v17 = strerror(*v16);
    snprintf(
      v57,
      0x1000u,
      "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
      v17,
      " - API multicast listener will not be available");
LABEL_48:
    sub_38730(3, v57, 0);
    return close(v3);
  }
  v4 = time(0);
  while ( 1 )
  {
    if ( bind(v3, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        v52 = 0;
        v53 = 0;
        v52 = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(v3, 0, 35, &v52, 8u) < 0 )
        {
LABEL_97:
          if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
            return close(v3);
          v30 = _errno_location();
          v31 = strerror(*v30);
          snprintf(v57, 0x1000u, "API mcast join failed (%s)%s", v31, " - API multicast listener will not be available");
          goto LABEL_48;
        }
      }
      else if ( ai_family == 10 )
      {
        v32 = *(_DWORD *)&v0->ai_addr->sa_data[6];
        v33 = *(_DWORD *)&v0->ai_addr->sa_data[10];
        v34 = *(_DWORD *)&v0->ai_addr[1].sa_family;
        v35 = *(_DWORD *)&v0->ai_addr[1].sa_data[2];
        v56 = 0;
        v52 = v32;
        v53 = v33;
        v54 = v34;
        v55 = v35;
        if ( setsockopt(v3, 41, 20, &v52, 0x14u) < 0 )
          goto LABEL_97;
      }
      freeaddrinfo(pai);
      v6 = off_75EC4[0];
      v7 = strlen(off_75EC4[0]);
      v8 = v7 + 10;
      n = v7 + 9;
      v39 = (char *)malloc(v7 + 10);
      if ( !v39 )
      {
        strcpy(v57, "Failed to malloc mcast expect_code");
        sub_38730(3, v57, 1);
        sub_16CA8(1);
      }
      v9 = 0;
      snprintf(v39, v8, "%s%s-", v46, v6);
      fd = -1;
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              do
              {
                while ( 1 )
                {
                  ++v9;
                  sub_2A92C();
                  addr_len = 128;
                  v10 = recvfrom(v3, v51, 0x3FFu, 0, v50, &addr_len);
                  if ( v10 >= 0 )
                    break;
                  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                  {
                    v19 = _errno_location();
                    v20 = strerror(*v19);
                    snprintf(v57, 0x1000u, "API mcast failed count=%d (%s) (%d)", v9, v20, v3);
                    sub_38730(7, v57, 0);
                  }
                }
                v11 = sub_309E8(v50, &v43, &v41);
                if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                {
                  v12 = "Ignored";
                  v36 = v11;
                  if ( v11 )
                    v12 = "Accepted";
                  snprintf(v57, 0x1000u, "API mcast from %s - %s", v43, v12);
                  sub_38730(7, v57, 0);
                  v11 = v36;
                }
              }
              while ( !v11 );
              v51[v10] = 0;
              if ( v10 && v50[7].sa_data[v10 + 13] == 10 )
                v51[--v10] = 0;
              getnameinfo(v50, addr_len, 0, 0, serv, 0xAu, 1u);
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                snprintf(v57, 0x1000u, "API mcast request rep=%d (%s) from [%s]:%s", v10, v51, v43, serv);
                sub_38730(7, v57, 0);
              }
              if ( n < v10 && !memcmp(v51, v39, n) )
                break;
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                strcpy(v57, "API mcast request was no good");
                sub_38730(7, v57, 0);
              }
            }
            v21 = &v51[n];
            v22 = strtol(&v51[n], 0, 10);
            if ( (unsigned int)(v22 - 1) <= 0xFFFE )
              break;
            if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
            {
              snprintf(v57, 0x1000u, "API mcast request ignored - invalid port (%s)", v21);
              sub_38730(7, v57, 0);
            }
          }
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(v57, 0x1000u, "API mcast request OK port %s=%d", v21, v22);
            sub_38730(7, v57, 0);
          }
          if ( !getaddrinfo(v43, v21, &req, &pai) )
            break;
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v57, 0x1000u, "Invalid client address %s", v43);
            goto LABEL_71;
          }
        }
        v23 = pai;
        if ( pai && (v24 = socket(pai->ai_family, 2, 0), v25 = -6348, fd = v24, v3 <= 0) )
        {
          while ( 1 )
          {
            v23 = v23->ai_next;
            if ( !v23 )
              break;
            v37 = v25;
            v24 = socket(*(_DWORD *)(*(_DWORD *)&v57[v25 + 4096] + 4), 2, 0);
            v25 = v37;
          }
          fd = v24;
          if ( v24 == -1 )
            goto LABEL_85;
LABEL_75:
          snprintf((char *)&v52, 0x400u, "cgm-FTW-%d-%s", dword_75ED0, (const char *)off_75EC0);
          v26 = strlen((const char *)&v52);
          v27 = sendto(fd, &v52, v26 + 1, 0, v23->ai_addr, v23->ai_addrlen);
          freeaddrinfo(pai);
          if ( v27 < 0 )
          {
            if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
            {
              v28 = _errno_location();
              v29 = strerror(*v28);
              snprintf(v57, 0x1000u, "API mcast send reply failed (%s) (%d)", v29, fd);
              sub_38730(7, v57, 0);
            }
          }
          else if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(v57, 0x1000u, "API mcast send reply (%s) succeeded (%d) (%d)", (const char *)&v52, v27, fd);
            sub_38730(7, v57, 0);
          }
          close(fd);
        }
        else
        {
          if ( fd != -1 )
            goto LABEL_75;
LABEL_85:
          freeaddrinfo(pai);
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v57, 0x1000u, "API mcast could not open socket to client %s", v43);
LABEL_71:
            sub_38730(3, v57, 0);
          }
        }
      }
    }
    v13 = _errno_location();
    v14 = strerror(*v13);
    if ( time(0) - v4 > 61 )
      break;
    sub_2A92C();
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(
      v57,
      0x1000u,
      "API mcast bind to port %d failed (%s)%s",
      dword_75EBC,
      v14,
      " - API multicast listener will not be available");
    sub_38730(3, v57, 0);
  }
  return close(v3);
}
// 75EBC: using guessed type int dword_75EBC;
// 75EC0: using guessed type _UNKNOWN *off_75EC0;
// 75EC4: using guessed type char *off_75EC4[3];
// 75EC8: using guessed type char *off_75EC8[2];
// 75ED0: using guessed type int dword_75ED0;
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00031CA0) --------------------------------------------------------
int __fastcall sub_31CA0(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_2F0B4("APIMcast");
  sub_3107C();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}

//----- (00031CDC) --------------------------------------------------------
_DWORD *__fastcall sub_31CDC(_DWORD *a1, const char *a2, int a3, const char *a4, char a5)
{
  _DWORD *v9; // r4
  char *v10; // r0
  bool v11; // zf
  int v12; // r3
  _DWORD *v14; // r0
  _QWORD *v15; // r0
  _WORD *v16; // r0
  _BYTE *v17; // r0
  _BYTE *v18; // r0
  _DWORD *v19; // r0
  int v20; // r1
  size_t v21; // r0
  char *v22; // r0
  char v23[4100]; // [sp+0h] [bp-1004h] BYREF

  v9 = malloc(0x18u);
  v10 = _strdup(a2);
  v11 = a1 == 0;
  *v9 = a3;
  if ( !a1 )
  {
    v9[4] = v9;
    a1 = v9;
    v9[5] = v9;
  }
  v9[1] = v10;
  if ( !v11 )
  {
    v9[4] = a1[4];
    a1[4] = v9;
    v12 = v9[4];
    v9[5] = a1;
    *(_DWORD *)(v12 + 20) = v9;
  }
  *((_BYTE *)v9 + 12) = a5;
  if ( !a4 )
  {
    *((_BYTE *)v9 + 12) = 0;
    a4 = "(null)";
    *v9 = 2;
    goto LABEL_9;
  }
  if ( !a5 )
  {
LABEL_9:
    v9[2] = a4;
    return a1;
  }
  switch ( a3 )
  {
    case 0:
    case 1:
    case 2:
      v21 = strlen(a4);
      v22 = (char *)malloc(v21 + 1);
      v9[2] = v22;
      strcpy(v22, a4);
      break;
    case 3:
      v17 = malloc(4u);
      v9[2] = v17;
      *v17 = *a4;
      break;
    case 4:
    case 5:
      v16 = malloc(4u);
      v9[2] = v16;
      *v16 = *(_WORD *)a4;
      break;
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      v14 = malloc(4u);
      v9[2] = v14;
      *v14 = *(_DWORD *)a4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      v15 = malloc(8u);
      v9[2] = v15;
      *v15 = *(_QWORD *)a4;
      break;
    case 14:
      v18 = malloc(1u);
      v9[2] = v18;
      *v18 = *a4;
      break;
    case 15:
      v19 = malloc(8u);
      v9[2] = v19;
      v20 = *((_DWORD *)a4 + 1);
      *v19 = *(_DWORD *)a4;
      v19[1] = v20;
      break;
    default:
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf(v23, 0x1000u, "API: unknown1 data type %d ignored", a3);
        sub_38730(3, v23, 0);
      }
      *v9 = 1;
      *((_BYTE *)v9 + 12) = 0;
      v9[2] = "Unknown";
      break;
  }
  return a1;
}
// 31D60: control flows out of bounds to 31D64
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00031F64) --------------------------------------------------------
int __fastcall sub_31F64(int result, int a2)
{
  int v2; // r4

  v2 = result;
  if ( !*(_BYTE *)(result + 13) )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  result = sub_307C8((unsigned int *)result, (char *)word_6B5B0);
  *(_BYTE *)(v2 + 13) = 0;
  if ( a2 )
  {
LABEL_3:
    sub_307C8((unsigned int *)v2, ",\"id\":1}");
    return sub_307C8((unsigned int *)v2, (char *)word_6B5B0);
  }
  return result;
}

//----- (00031FC4) --------------------------------------------------------
unsigned __int8 **__fastcall sub_31FC4(unsigned __int8 **result, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // r3
  int v3; // r2
  unsigned __int8 *v4; // r12
  unsigned __int8 *v5; // r2
  unsigned __int8 *v6; // r3

  v2 = *result;
  v3 = **result;
  if ( **result )
  {
    while ( v3 != 44 )
    {
      if ( v3 == 92 && (v4 = v2 + 1, v2[1]) )
        *result = v4;
      else
        v4 = *result;
      v5 = *a2;
      v2 = v4 + 1;
      *v5 = *v4;
      *a2 = v5 + 1;
      *result = v4 + 1;
      v3 = v4[1];
      if ( !v4[1] )
        goto LABEL_11;
    }
    *result = v2 + 1;
  }
LABEL_11:
  v6 = *a2;
  *v6 = 0;
  *a2 = v6 + 1;
  return result;
}

//----- (0003204C) --------------------------------------------------------
int __fastcall sub_3204C(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, _DWORD *a4)
{
  size_t v7; // r0
  unsigned __int8 *v8; // r0
  unsigned __int8 *v9; // r4
  int v10; // r5
  unsigned __int8 *v12[2]; // [sp+4h] [bp-1010h] BYREF
  unsigned __int8 *v13; // [sp+Ch] [bp-1008h] BYREF
  char v14[4100]; // [sp+10h] [bp-1004h] BYREF

  v12[0] = a1;
  v7 = strlen((const char *)a1);
  v8 = (unsigned __int8 *)malloc(v7 + 1);
  v13 = v8;
  v9 = v8;
  if ( !v8 )
  {
    strcpy(v14, "Failed to malloc pooldetails buf");
    sub_38730(3, v14, 1);
    sub_16CA8(1);
  }
  *a2 = v8;
  LOWORD(v10) = -4108;
  sub_31FC4(v12, &v13);
  HIWORD(v10) = -1;
  if ( **(_BYTE **)&v14[v10 + 4096] && (*a3 = v13, sub_31FC4(v12, &v13), **(_BYTE **)&v14[v10 + 4096]) )
  {
    *a4 = v13;
    sub_31FC4(v12, &v13);
    return 1;
  }
  else
  {
    free(v9);
    return 0;
  }
}

//----- (00032190) --------------------------------------------------------
int __fastcall sub_32190(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_rwlock_rdlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x1000u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "api.c", a2, a3);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (0003220C) --------------------------------------------------------
int __fastcall sub_3220C(pthread_mutex_t *a1, const char *a2, int a3)
{
  if ( pthread_mutex_unlock(a1) )
    sub_B84C(a2, a3);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();

//----- (00032248) --------------------------------------------------------
int sub_32248()
{
  char v1[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_78CB8) )
    sub_B774("restart_thread", 4951);
  if ( pthread_mutex_unlock(&stru_78CB8) )
    sub_B84C("restart_thread", 4952);
  off_75ED8();
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v1, "API: restarting cgminer");
    sub_38730(7, v1, 0);
  }
  sub_1D7C8();
  return 0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00032340) --------------------------------------------------------
void __noreturn sub_32340()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( !pthread_mutex_lock(&stru_78CB8) )
  {
    if ( !pthread_mutex_unlock(&stru_78CB8) )
    {
      off_75ED8();
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy(v0, "API: killing cgminer");
        sub_38730(7, v0, 0);
      }
      sub_178F8();
    }
    sub_B84C("quit_thread", 4938);
  }
  sub_B774("quit_thread", 4937);
}
// 32340: using guessed type void __noreturn sub_32340();
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003243C) --------------------------------------------------------
int __fastcall sub_3243C(int *a1)
{
  int v2; // r0
  bool v3; // zf
  int v4; // r6
  void **v5; // r4
  void **v6; // r5

  if ( pthread_mutex_lock(&stru_78CB8) )
    sub_B774("tidyup", 4620);
  v2 = *a1;
  v3 = *a1 == -1;
  byte_78CAC = 1;
  if ( !v3 )
  {
    shutdown(v2, 2);
    close(*a1);
    *a1 = -1;
  }
  if ( dword_78CB4 )
  {
    free((void *)dword_78CB4);
    dword_78CB4 = 0;
  }
  v4 = dword_78CD0;
  if ( dword_78CD0 )
  {
    v5 = (void **)dword_78CD0;
    do
    {
      v6 = (void **)v5[2];
      free(*((void **)*v5 + 1));
      free(*v5);
      free(v5);
      v5 = v6;
    }
    while ( (void **)v4 != v6 );
    dword_78CD0 = 0;
  }
  if ( pthread_mutex_unlock(&stru_78CB8) )
    sub_B84C("tidyup", 4641);
  return off_75ED8();
}
// 75ED8: using guessed type int (*off_75ED8)();
// 78CAC: using guessed type char byte_78CAC;
// 78CB4: using guessed type int dword_78CB4;
// 78CD0: using guessed type int dword_78CD0;

//----- (00032534) --------------------------------------------------------
int __fastcall sub_32534(unsigned int *a1, int a2, int a3, int a4)
{
  int v8; // r5
  int v9; // r0
  int v10; // r8
  int v11; // r5
  int v12; // r0
  int v13; // r3
  int v14; // r2
  void *v15; // r0
  char *v16; // r1
  int v17; // r4
  int v18; // r4
  const char *v20; // r3
  char *v21; // r11
  char *v22; // r3
  int *v23; // r0
  int *v24; // r0
  char *ptr; // [sp+10h] [bp-104Ch]
  char s[64]; // [sp+18h] [bp-1044h] BYREF
  char v27[4100]; // [sp+58h] [bp-1004h] BYREF

  v8 = *(_DWORD *)(dword_78CD4 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v8) )
    sub_B774("print_data", 1196);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v8 + 24)) )
  {
    v24 = _errno_location();
    snprintf(v27, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1196);
    sub_38730(3, v27, 1);
    sub_16CA8(1);
  }
  v9 = sub_391FC(dword_78CD4, "api.c", "print_data", 1197);
  v10 = *(_DWORD *)(dword_78CD4 + 8);
  v11 = v9;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 24)) )
    sub_B7E0("print_data", 1198);
  if ( pthread_mutex_unlock((pthread_mutex_t *)v10) )
    sub_B84C("print_data", 1198);
  off_75ED8();
  *(_DWORD *)(*(_DWORD *)(v11 + 12) + 4) = 0;
  if ( a4 )
    sub_306B4(v11, (char *)",");
  if ( a3 )
    sub_306B4(v11, "{");
  if ( a2 )
  {
    v12 = v11;
    if ( a3 )
      goto LABEL_18;
LABEL_11:
    sub_306B4(v12, *(char **)(a2 + 4));
    sub_306B4(v11, "=");
    while ( 1 )
    {
      switch ( *(_DWORD *)a2 )
      {
        case 0:
          v21 = *(char **)(a2 + 8);
          v22 = sub_30500(v21, a3);
          ptr = v22;
          if ( a3 )
          {
            sub_306B4(v11, (char *)"\"");
            sub_306B4(v11, ptr);
            sub_306B4(v11, (char *)"\"");
          }
          else
          {
            sub_306B4(v11, v22);
          }
          if ( ptr != v21 )
            free(ptr);
          break;
        case 1:
        case 2:
          if ( a3 )
          {
            sub_306B4(v11, (char *)"\"");
            sub_306B4(v11, *(char **)(a2 + 8));
            sub_306B4(v11, (char *)"\"");
          }
          else
          {
            sub_306B4(v11, *(char **)(a2 + 8));
          }
          break;
        case 3:
          snprintf(s, 0x40u, "%u", **(unsigned __int8 **)(a2 + 8));
          goto LABEL_14;
        case 4:
          snprintf(s, 0x40u, "%d", **(__int16 **)(a2 + 8));
          goto LABEL_14;
        case 5:
          snprintf(s, 0x40u, "%u", **(unsigned __int16 **)(a2 + 8));
          goto LABEL_14;
        case 6:
          snprintf(s, 0x40u, "%d", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 7:
        case 8:
          snprintf(s, 0x40u, "%u", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 9:
          if ( a3 )
          {
            sub_306B4(v11, (char *)"\"");
            snprintf(s, 0x40u, "0x%08x", **(_DWORD **)(a2 + 8));
            sub_306B4(v11, s);
            sub_306B4(v11, (char *)"\"");
          }
          else
          {
            snprintf(s, 0x40u, "0x%08x", **(_DWORD **)(a2 + 8));
            sub_306B4(v11, s);
          }
          break;
        case 0xA:
          snprintf(s, 0x40u, "%llu", *(_QWORD *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xB:
          snprintf(s, 0x40u, "%lld", *(_QWORD *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xC:
          snprintf(s, 0x40u, "%f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xD:
          snprintf(s, 0x40u, "%.0f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xE:
          v20 = "false";
          if ( **(_BYTE **)(a2 + 8) )
            v20 = "true";
          snprintf(s, 0x40u, "%s", v20);
          goto LABEL_14;
        case 0xF:
          snprintf(s, 0x40u, "%ld.%06ld", **(_DWORD **)(a2 + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4));
          goto LABEL_14;
        case 0x10:
          snprintf(s, 0x40u, "%lu", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 0x11:
        case 0x14:
        case 0x15:
          snprintf(s, 0x40u, "%.2f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x12:
          snprintf(s, 0x40u, "%.4f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x13:
          snprintf(s, 0x40u, "%.2f", **(float **)(a2 + 8));
          goto LABEL_14;
        case 0x16:
        case 0x1A:
          snprintf(s, 0x40u, "%.3f", **(float **)(a2 + 8));
          goto LABEL_14;
        case 0x17:
          snprintf(s, 0x40u, "%.15f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x18:
          snprintf(s, 0x40u, "%.8f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x19:
          snprintf(s, 0x40u, "%.4f", *(double *)*(_DWORD *)(a2 + 8) * 100.0);
LABEL_14:
          sub_306B4(v11, s);
          break;
        default:
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v27, 0x1000u, "API: unknown2 data type %d ignored", *(_DWORD *)a2);
            sub_38730(3, v27, 0);
          }
          if ( a3 )
          {
            sub_306B4(v11, (char *)"\"");
            sub_306B4(v11, "Unknown");
            sub_306B4(v11, (char *)"\"");
          }
          else
          {
            sub_306B4(v11, "Unknown");
          }
          break;
      }
      free(*(void **)(a2 + 4));
      if ( *(_BYTE *)(a2 + 12) )
      {
        free(*(void **)(a2 + 8));
        v13 = *(_DWORD *)(a2 + 20);
        if ( v13 == a2 )
        {
LABEL_20:
          free((void *)a2);
          break;
        }
      }
      else
      {
        v13 = *(_DWORD *)(a2 + 20);
        if ( v13 == a2 )
          goto LABEL_20;
      }
      v14 = *(_DWORD *)(a2 + 16);
      v15 = (void *)a2;
      a2 = v13;
      *(_DWORD *)(v13 + 16) = v14;
      *(_DWORD *)(v14 + 20) = v13;
      free(v15);
      sub_306B4(v11, (char *)",");
      v12 = v11;
      if ( !a3 )
        goto LABEL_11;
LABEL_18:
      sub_306B4(v12, (char *)"\"");
      sub_306B4(v11, *(char **)(a2 + 4));
      sub_306B4(v11, (char *)"\"");
      sub_306B4(v11, (char *)":");
    }
  }
  if ( a3 )
    v16 = (char *)"}";
  else
    v16 = (char *)delim;
  sub_306B4(v11, v16);
  sub_307C8(a1, **(char ***)(v11 + 12));
  v17 = *(_DWORD *)(dword_78CD4 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v17) )
    sub_B774("print_data", 1368);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v17 + 24)) )
  {
    v23 = _errno_location();
    snprintf(v27, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "api.c", "print_data", 1368);
    sub_38730(3, v27, 1);
    sub_16CA8(1);
  }
  sub_39370(dword_78CD4, v11, "api.c", "print_data", 1369);
  v18 = *(_DWORD *)(dword_78CD4 + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v18 + 24)) )
    sub_B7E0("print_data", 1370);
  if ( pthread_mutex_unlock((pthread_mutex_t *)v18) )
    sub_B84C("print_data", 1370);
  off_75ED8();
  return 0;
}
// 3262C: control flows out of bounds to 32630
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 78CD4: using guessed type int dword_78CD4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00032DF8) --------------------------------------------------------
_DWORD *__fastcall sub_32DF8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 0, a3, a4);
}

//----- (00032E1C) --------------------------------------------------------
_DWORD *__fastcall sub_32E1C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 1, a3, a4);
}

//----- (00032E40) --------------------------------------------------------
_DWORD *__fastcall sub_32E40(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 2, a3, a4);
}

//----- (00032E64) --------------------------------------------------------
_DWORD *__fastcall sub_32E64(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 3, a3, a4);
}

//----- (00032E88) --------------------------------------------------------
_DWORD *__fastcall sub_32E88(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 4, a3, a4);
}

//----- (00032EAC) --------------------------------------------------------
_DWORD *__fastcall sub_32EAC(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 5, a3, a4);
}

//----- (00032ED0) --------------------------------------------------------
_DWORD *__fastcall sub_32ED0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 6, a3, a4);
}

//----- (00032EF4) --------------------------------------------------------
_DWORD *__fastcall sub_32EF4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 7, a3, a4);
}

//----- (00032F18) --------------------------------------------------------
_DWORD *__fastcall sub_32F18(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 8, a3, a4);
}

//----- (00032F3C) --------------------------------------------------------
_DWORD *__fastcall sub_32F3C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 9, a3, a4);
}

//----- (00032F60) --------------------------------------------------------
_DWORD *__fastcall sub_32F60(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 10, a3, a4);
}

//----- (00032F84) --------------------------------------------------------
_DWORD *__fastcall sub_32F84(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 11, a3, a4);
}

//----- (00032FA8) --------------------------------------------------------
_DWORD *__fastcall sub_32FA8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 12, a3, a4);
}

//----- (00032FCC) --------------------------------------------------------
_DWORD *__fastcall sub_32FCC(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 13, a3, a4);
}

//----- (00032FF0) --------------------------------------------------------
_DWORD *__fastcall sub_32FF0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 14, a3, a4);
}

//----- (00033014) --------------------------------------------------------
_DWORD *__fastcall sub_33014(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 15, a3, a4);
}

//----- (00033038) --------------------------------------------------------
_DWORD *__fastcall sub_33038(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 16, a3, a4);
}

//----- (0003305C) --------------------------------------------------------
int __fastcall sub_3305C(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  int v8; // r12
  int *v9; // r1
  int v10; // lr
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r4
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  int result; // r0
  int v18; // lr
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  char *v21; // r2
  int v22; // [sp+4h] [bp-200Ch] BYREF
  char v23[4]; // [sp+8h] [bp-2008h] BYREF
  int v24; // [sp+Ch] [bp-2004h] BYREF
  char s[8176]; // [sp+10h] [bp-2000h] BYREF

  v22 = a2;
  if ( a5 )
    sub_307C8(a1, "{\"STATUS\":[");
  v8 = dword_760FC[0];
  if ( dword_760FC[0] == 4 )
  {
LABEL_9:
    v11 = sub_32E1C(0, "STATUS", "F", 0);
    v12 = sub_33038(v11, "When", (const char *)&dword_78CD8, 0);
    v24 = -1;
    v13 = sub_32ED0(v12, "Code", (const char *)&v24, 0);
    sprintf(s, "%d", v22);
    v14 = v13;
    goto LABEL_10;
  }
  if ( dword_76100 != v22 )
  {
    v9 = dword_760FC;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[4];
      ++v10;
      v9 += 4;
      if ( v8 == 4 )
        goto LABEL_9;
      if ( v9[1] == v22 )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case 2:
      v23[0] = 73;
      break;
    case 3:
      v23[0] = 83;
      break;
    case 1:
      v23[0] = 87;
      break;
    default:
      v23[0] = 69;
      break;
  }
  v18 = 4 * v10;
  v23[1] = 0;
  switch ( dword_760FC[v18 + 2] )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      sprintf(s, (const char *)dword_760FC[v18 + 3], a3);
      break;
    case 5:
      sprintf(s, (const char *)dword_760FC[v18 + 3], dword_7B198);
      break;
    case 6:
      sprintf(s, (const char *)dword_760FC[v18 + 3], a3, dword_7B198 - 1);
      break;
    case 7:
      sprintf(s, (const char *)dword_760FC[v18 + 3]);
      break;
    case 8:
      sprintf(s, (const char *)dword_760FC[v18 + 3], "command");
      break;
    case 9:
      sprintf(s, (const char *)dword_760FC[v18 + 3], a3, *(_DWORD *)(*(_DWORD *)(dword_7B438 + 4 * a3) + 196));
      break;
    case 10:
      sprintf(s, (const char *)dword_760FC[v18 + 3], a4);
      break;
    case 11:
      sprintf(s, (const char *)dword_760FC[v18 + 3], a3, a4);
      break;
    case 12:
      v21 = "false";
      if ( a3 )
        v21 = "true";
      sprintf(s, (const char *)dword_760FC[v18 + 3], v21);
      break;
    case 13:
      sprintf(s, (const char *)dword_760FC[v18 + 3], a4, a3);
      break;
    default:
      strcpy(s, (const char *)dword_760FC[v18 + 3]);
      break;
  }
  v19 = sub_32E1C(0, "STATUS", v23, 0);
  v20 = sub_33038(v19, "When", (const char *)&dword_78CD8, 0);
  v14 = sub_32ED0(v20, "Code", (const char *)&v22, 0);
LABEL_10:
  v15 = sub_32DF8(v14, "Msg", s, 0);
  v16 = sub_32DF8(v15, "Description", (const char *)off_75ED4, 0);
  result = sub_32534(a1, (int)v16, a5, 0);
  if ( a5 )
    return sub_307C8(a1, (char *)word_6B5B0);
  return result;
}
// 33210: control flows out of bounds to 33214
// 75ED4: using guessed type _UNKNOWN *off_75ED4;
// 760FC: using guessed type int dword_760FC[];
// 76100: using guessed type int dword_76100;
// 78CD8: using guessed type int dword_78CD8;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00033474) --------------------------------------------------------
int __fastcall sub_33474(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3305C(a1, 124, 0, 0, a4);
}

//----- (00033548) --------------------------------------------------------
int __fastcall sub_33548(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3305C(a1, 102, 0, 0, a4);
}

//----- (0003355C) --------------------------------------------------------
int __fastcall sub_3355C(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r5
  char *v7; // r0
  char *v8; // r7
  int v9; // r8
  int v10; // r10
  int v11; // r9
  int v12; // r2
  bool v13; // zf
  _BOOL4 v14; // r4
  const char *v16; // r3
  int v17; // r1
  unsigned __int8 v18; // [sp+20h] [bp+20h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = strchr(a3, 44);
    v8 = v7;
    if ( v7 && (*v7 = 0, v7 != (char *)-1) && (v9 = (unsigned __int8)v7[1], v7[1]) )
    {
      if ( !strcasecmp(a3, "all") )
      {
        v11 = 0;
        v10 = 1;
      }
      else
      {
        if ( strcasecmp(a3, "bestshare") )
        {
          v18 = a4;
          a1 = v5;
          v16 = a3;
          v17 = 95;
          return sub_3305C(a1, v17, 0, (int)v16, v18);
        }
        v10 = 0;
        v11 = 1;
      }
      v12 = LOBYTE((*_ctype_tolower_loc())[v9]);
      v13 = v12 == 102;
      if ( v12 != 102 )
        v13 = v12 == 116;
      v8[1] = v12;
      if ( v13 )
      {
        v14 = v12 == 116;
        if ( v12 == 116 )
          sub_1C668();
        if ( v10 )
          sub_1B8B4();
        if ( v11 )
          sub_160B4();
        a1 = v5;
        v16 = "All";
        if ( v14 )
        {
          v17 = 96;
          v18 = a4;
          if ( !v10 )
            v16 = "BestShare";
        }
        else
        {
          v18 = a4;
          v17 = 97;
          if ( !v10 )
            v16 = "BestShare";
        }
      }
      else
      {
        v18 = a4;
        a1 = v5;
        v16 = 0;
        v17 = 76;
      }
    }
    else
    {
      v18 = a4;
      a1 = v5;
      v16 = 0;
      v17 = 75;
    }
  }
  else
  {
    v18 = a4;
    v16 = 0;
    v17 = 94;
  }
  return sub_3305C(a1, v17, 0, (int)v16, v18);
}

//----- (00033710) --------------------------------------------------------
int __fastcall sub_33710(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3305C(a1, 88, 0, 0, a4);
}

//----- (00033724) --------------------------------------------------------
int __fastcall sub_33724(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r5
  char *v7; // r0
  int v8; // r2
  unsigned int v9; // r7
  int v10; // r3
  int v11; // r1
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = strchr(a3, 44);
    v8 = (int)v7;
    if ( v7 )
    {
      *v7 = 0;
      v9 = strtol(v7 + 1, 0, 10);
      if ( v9 > 0x270F )
      {
        v13 = a4;
        a1 = v5;
        v8 = v9;
        v10 = (int)a3;
        v11 = 84;
      }
      else
      {
        if ( !strcasecmp(a3, "queue") )
        {
          dword_75DDC = v9;
        }
        else if ( !strcasecmp(a3, "scantime") )
        {
          dword_75DF0 = v9;
        }
        else
        {
          if ( strcasecmp(a3, "expiry") )
          {
            v13 = a4;
            a1 = v5;
            v8 = 0;
            v10 = (int)a3;
            v11 = 83;
            return sub_3305C(a1, v11, v8, v10, v13);
          }
          dword_75DF4 = v9;
        }
        v13 = a4;
        a1 = v5;
        v8 = v9;
        v10 = (int)a3;
        v11 = 82;
      }
    }
    else
    {
      v13 = a4;
      a1 = v5;
      v10 = (int)a3;
      v11 = 86;
    }
  }
  else
  {
    v8 = 0;
    v13 = a4;
    v10 = 0;
    v11 = 85;
  }
  return sub_3305C(a1, v11, v8, v10, v13);
}
// 75DDC: using guessed type int dword_75DDC;
// 75DF0: using guessed type int dword_75DF0;
// 75DF4: using guessed type int dword_75DF4;

//----- (0003387C) --------------------------------------------------------
int __fastcall sub_3387C(int a1, int a2, _BYTE *a3, int a4)
{
  int v7; // r2
  int v8; // r3
  int v9; // r4
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  int result; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r1
  char *v25; // r2
  int v26; // r3

  if ( a3 )
  {
    v7 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*a3]);
    *a3 = v7;
    switch ( v7 )
    {
      case 'd':
        v8 = (unsigned __int8)byte_78E09 ^ 1;
        byte_78E09 ^= 1u;
        byte_78E08 = v8;
        if ( v8 )
          goto LABEL_4;
        break;
      case 'n':
        byte_78E08 = 0;
        byte_78E09 = 0;
        byte_7BC78 = 0;
        byte_7B380 = 0;
        byte_7B858 = 0;
        byte_7B85A = 0;
        break;
      case 'p':
        byte_7B858 ^= 1u;
        byte_78E08 = byte_7B858;
        break;
      case 'q':
        byte_7BC78 ^= 1u;
        break;
      case 'r':
        v25 = &byte_7B380;
        goto LABEL_15;
      case 's':
        byte_7BB18 = 1;
        break;
      case 'v':
        v25 = &byte_78E08;
LABEL_15:
        v26 = (unsigned __int8)*v25 ^ 1;
        *v25 = v26;
        if ( v26 )
LABEL_4:
          byte_7BC78 = 0;
        break;
      case 'w':
        byte_7B85A ^= 1u;
        break;
      default:
        break;
    }
  }
  sub_3305C((unsigned int *)a1, 79, 0, 0, a4);
  if ( a4 )
  {
    v9 = sub_307C8((unsigned int *)a1, ",\"DEBUG\":[");
    v10 = sub_32FF0(0, "Silent", &byte_7BB18, 0);
    v11 = sub_32FF0(v10, "Quiet", &byte_7BC78, 0);
    v12 = sub_32FF0(v11, "Verbose", &byte_78E08, 0);
    v13 = sub_32FF0(v12, "Debug", &byte_78E09, 0);
    v14 = sub_32FF0(v13, "RPCProto", &byte_7B380, 0);
    v15 = sub_32FF0(v14, "PerDevice", &byte_7B858, 0);
    v16 = sub_32FF0(v15, "WorkTime", &byte_7B85A, 0);
    result = sub_32534((unsigned int *)a1, (int)v16, 1, 0);
    if ( v9 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_307C8((unsigned int *)a1, "DEBUG,");
    v18 = sub_32FF0(0, "Silent", &byte_7BB18, 0);
    v19 = sub_32FF0(v18, "Quiet", &byte_7BC78, 0);
    v20 = sub_32FF0(v19, "Verbose", &byte_78E08, 0);
    v21 = sub_32FF0(v20, "Debug", &byte_78E09, 0);
    v22 = sub_32FF0(v21, "RPCProto", &byte_7B380, 0);
    v23 = sub_32FF0(v22, "PerDevice", &byte_7B858, 0);
    v24 = sub_32FF0(v23, "WorkTime", &byte_7B85A, 0);
    return sub_32534((unsigned int *)a1, (int)v24, 0, 0);
  }
  return result;
}
// 338B4: control flows out of bounds to 338B8
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7B380: using guessed type char byte_7B380;
// 7B858: using guessed type char byte_7B858;
// 7B85A: using guessed type char byte_7B85A;
// 7BB18: using guessed type char byte_7BB18;
// 7BC78: using guessed type char byte_7BC78;

//----- (00033B88) --------------------------------------------------------
int __fastcall sub_33B88(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r6
  int v7; // r5
  int v8; // r1
  bool v9; // zf
  _BOOL4 v10; // r12
  int v11; // r1
  int v12; // r2
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = (unsigned __int8)*a3;
    v8 = LOBYTE((*_ctype_tolower_loc())[v7]);
    v9 = v8 == 102;
    if ( v8 != 102 )
      v9 = v8 == 116;
    *a3 = v8;
    if ( v9 )
    {
      v14 = a4;
      v10 = v8 == 116;
      a1 = v5;
      v11 = 77;
      byte_7B625 = v10;
      v12 = v10;
    }
    else
    {
      v12 = 0;
      v14 = a4;
      a1 = v5;
      v11 = 76;
    }
  }
  else
  {
    v12 = 0;
    v14 = a4;
    v11 = 75;
  }
  return sub_3305C(a1, v11, v12, 0, v14);
}
// 7B625: using guessed type char byte_7B625;

//----- (00033C34) --------------------------------------------------------
int __fastcall sub_33C34(int a1, int a2, const char *a3, int a4, unsigned __int8 a5)
{
  const char *v8; // r0
  _UNKNOWN **v9; // r4
  const char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r2
  int v13; // r8
  int v14; // r9
  char *v15; // r1
  int v16; // r10
  const char *v17; // r2
  _DWORD *v18; // r0
  const char *v19; // r2
  _DWORD *v20; // r0
  int result; // r0
  char s[100]; // [sp+Ch] [bp-64h] BYREF

  if ( !a3 || !*a3 )
    return sub_3305C((unsigned int *)a1, 71, 0, 0, a4);
  v8 = (const char *)off_7652C;
  if ( off_7652C )
  {
    v9 = &off_7652C;
    while ( strcmp(v8, a3) )
    {
      v10 = (const char *)v9[3];
      v9 += 3;
      v8 = v10;
      if ( !v10 )
        goto LABEL_23;
    }
    sprintf(s, "|%s|", a3);
    v11 = _ctype_toupper_loc();
    v12 = (*v11)[a5];
    if ( v12 == (*v11)[87] || strstr(*((const char **)&unk_7BD24 + v12 - (*v11)[65]), s) )
    {
      v13 = 1;
      v14 = 1;
    }
    else
    {
      v13 = 0;
      v14 = 1;
    }
  }
  else
  {
LABEL_23:
    v13 = (int)v8;
    v14 = (int)v8;
  }
  sub_3305C((unsigned int *)a1, 72, 0, 0, a4);
  v15 = "CHECK,";
  if ( a4 )
    v15 = ",\"CHECK\":[";
  v16 = sub_307C8((unsigned int *)a1, v15);
  if ( v14 )
    v17 = "Y";
  else
    v17 = "N";
  v18 = sub_32E40(0, "Exists", v17, 0);
  if ( v13 )
    v19 = "Y";
  else
    v19 = "N";
  v20 = sub_32E40(v18, "Access", v19, 0);
  result = sub_32534((unsigned int *)a1, (int)v20, a4, 0);
  if ( (v16 & a4) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7652C: using guessed type _UNKNOWN *off_7652C;

//----- (00033DCC) --------------------------------------------------------
int __fastcall sub_33DCC(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r10
  _DWORD *v8; // r9
  int v9; // r4
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  const char *v14; // r2
  _DWORD *v15; // r0
  const char *v16; // r2
  _DWORD *v17; // r0
  const char *v18; // r2
  _DWORD *v19; // r0
  _BOOL4 v20; // r3
  int v21; // [sp+Ch] [bp-4h] BYREF

  if ( !dword_7B720 )
    return sub_3305C((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_3305C((unsigned int *)a1, 69, 0, 0, a4);
  if ( a4 )
  {
    result = sub_307C8((unsigned int *)a1, ",\"DEVDETAILS\":[");
    v7 = result;
  }
  else
  {
    v7 = 0;
  }
  v8 = 0;
  v21 = 0;
  if ( dword_7B720 > 0 )
  {
    result = 0;
    do
    {
      v9 = sub_1B83C(result);
      v10 = sub_32ED0(v8, "DEVDETAILS", (const char *)&v21, 0);
      v11 = sub_32E1C(v10, "Name", *(const char **)(*(_DWORD *)(v9 + 4) + 8), 0);
      v12 = sub_32ED0(v11, "ID", (const char *)(v9 + 8), 0);
      v13 = sub_32E1C(v12, "Driver", *(const char **)(*(_DWORD *)(v9 + 4) + 4), 0);
      v14 = *(const char **)(v9 + 168);
      if ( !v14 )
        v14 = "";
      v15 = sub_32E40(v13, "Kernel", v14, 0);
      v16 = *(const char **)(v9 + 12);
      if ( !v16 )
        v16 = "";
      v17 = sub_32E40(v15, "Model", v16, 0);
      v18 = *(const char **)(v9 + 16);
      if ( !v18 )
        v18 = "";
      v19 = sub_32E40(v17, "Device Path", v18, 0);
      v20 = a4;
      if ( a4 )
        v20 = v21 > 0;
      v8 = (_DWORD *)sub_32534((unsigned int *)a1, (int)v19, a4, v20);
      result = ++v21;
    }
    while ( v21 < dword_7B720 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7B720: using guessed type int dword_7B720;

//----- (00033F70) --------------------------------------------------------
void __fastcall sub_33F70(unsigned int *a1, int a2, char *nptr, int a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r0
  int v11; // r7
  int v12; // r4
  char *v13; // r0
  char *v14; // r8
  unsigned __int8 v15; // [sp+20h] [bp+18h]

  v6 = a1;
  if ( !dword_7B198 )
  {
    v15 = a4;
    v7 = 0;
    v8 = 0;
    v9 = 8;
    goto LABEL_5;
  }
  if ( !nptr || !*nptr )
  {
    v7 = 0;
    v15 = a4;
    v8 = 0;
    v9 = 25;
LABEL_5:
    sub_3305C(a1, v9, v7, v8, v15);
    return;
  }
  v10 = strtol(nptr, 0, 10);
  v11 = v10;
  if ( v10 < 0 || v10 >= dword_7B198 )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 26;
    v8 = 0;
    goto LABEL_5;
  }
  if ( dword_7B198 <= 1 )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 66;
    v8 = 0;
    goto LABEL_5;
  }
  v12 = *(_DWORD *)(dword_7B438 + 4 * v10);
  if ( v12 == sub_1DA58() )
    sub_19BF8(0);
  if ( v12 == sub_1DA58() )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 67;
    v8 = 0;
    goto LABEL_5;
  }
  v13 = *(char **)(v12 + 196);
  *(_DWORD *)(v12 + 132) = 0;
  v14 = sub_30500(v13, a4);
  if ( v14 == *(char **)(v12 + 196) )
  {
    sub_15AC8(v12);
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v8 = (int)v14;
    v9 = 68;
    goto LABEL_5;
  }
  sub_15AC8(v12);
  sub_3305C(v6, 68, v11, (int)v14, a4);
  free(v14);
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (0003411C) --------------------------------------------------------
int __fastcall sub_3411C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_7B198 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_7B198 )
      {
        v13 = a4;
        a1 = v6;
        v7 = v10;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_7B438 + 4 * v9);
        if ( *(_DWORD *)(v11 + 132) )
        {
          if ( dword_7B5E4 <= 1 )
          {
            v13 = a4;
            a1 = v6;
            v7 = v10;
            v8 = 51;
          }
          else
          {
            *(_DWORD *)(v11 + 132) = 0;
            if ( v11 == sub_1DA58() )
              sub_19BF8(0);
            v13 = a4;
            a1 = v6;
            v7 = v10;
            v8 = 48;
          }
        }
        else
        {
          v13 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 50;
        }
      }
    }
    else
    {
      v7 = 0;
      v13 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v13 = a4;
    v8 = 8;
  }
  return sub_3305C(a1, v8, v7, 0, v13);
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;
// 7B5E4: using guessed type int dword_7B5E4;

//----- (00034264) --------------------------------------------------------
int __fastcall sub_34264(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  int v12; // r8
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_7B198 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_7B198 )
      {
        v14 = a4;
        a1 = v6;
        v7 = v10;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_7B438 + 4 * v9);
        if ( *(_DWORD *)(v11 + 132) == 1 )
        {
          v14 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 49;
        }
        else
        {
          *(_DWORD *)(v11 + 132) = 1;
          v12 = *(_DWORD *)(v11 + 4);
          if ( v12 < *(_DWORD *)(sub_1DA58() + 4) )
            sub_19BF8(v11);
          v14 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 47;
        }
      }
    }
    else
    {
      v7 = 0;
      v14 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v14 = a4;
    v8 = 8;
  }
  return sub_3305C(a1, v8, v7, 0, v14);
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00034388) --------------------------------------------------------
int __fastcall sub_34388(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  unsigned int *v7; // r7
  int v8; // r2
  char *v9; // r10
  int v10; // r0
  int v11; // r1
  char *v12; // r3
  int v14; // r4
  int v15; // r0
  int v16; // r5
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  v7 = a1;
  v8 = dword_7B198;
  if ( dword_7B198 )
  {
    if ( s && *s )
    {
      v9 = strchr(s, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol(s, 0, 10);
        if ( v10 >= 0 && v10 < dword_7B198 )
        {
          v14 = *(_DWORD *)(dword_7B438 + 4 * v10);
          v15 = strtol(v9 + 1, 0, 10);
          v16 = v15;
          if ( v15 < 0 )
          {
            v12 = *(char **)(v14 + 196);
            a1 = v7;
            v17 = a4;
            v8 = v16;
            v11 = 121;
          }
          else
          {
            *(_DWORD *)(v14 + 56) = v15;
            sub_152E0();
            v12 = *(char **)(v14 + 196);
            a1 = v7;
            v17 = a4;
            v8 = v16;
            v11 = 122;
          }
        }
        else
        {
          v8 = v10;
          v17 = a4;
          a1 = v7;
          v11 = 26;
          v12 = 0;
        }
      }
      else
      {
        v17 = a4;
        a1 = v7;
        v8 = 0;
        v12 = s;
        v11 = 86;
      }
    }
    else
    {
      v8 = 0;
      v17 = a4;
      v12 = 0;
      v11 = 25;
    }
  }
  else
  {
    v17 = a4;
    v11 = 8;
    v12 = 0;
  }
  return sub_3305C(a1, v11, v8, (int)v12, v17);
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (000344D0) --------------------------------------------------------
int __fastcall sub_344D0(unsigned int *a1, int a2, char *s, int a4)
{
  const char *v4; // r8
  _BYTE *v6; // r2
  _BYTE *v7; // r3
  int v8; // r5
  char *v9; // r10
  int v10; // r0
  int v11; // r1
  _BYTE *v12; // r2
  int v13; // r3
  int v14; // lr
  int v15; // r12
  int v16; // t1
  bool v17; // zf
  int v18; // lr
  int v19; // r12
  int v20; // r3
  int v21; // r2
  int v22; // [sp+0h] [bp-3Ch] BYREF
  _BYTE v23[4]; // [sp+8h] [bp-34h] BYREF
  unsigned int *v24; // [sp+Ch] [bp-30h]
  int v25; // [sp+10h] [bp-2Ch]
  int *v26; // [sp+14h] [bp-28h]

  v4 = s;
  v25 = a4;
  v24 = a1;
  v26 = &v22;
  if ( !dword_7B198 )
    return sub_3305C(a1, 8, 0, 0, a4);
  if ( !s || !*s )
    return sub_3305C(v24, 25, 0, 0, v25);
  if ( dword_7B198 > 0 )
  {
    v6 = &v23[dword_7B198];
    v7 = v23;
    do
      *v7++ = 0;
    while ( v7 != v6 );
  }
  v8 = 0;
  while ( 1 )
  {
    v9 = strchr(v4, 44);
    if ( v9 )
      *v9++ = 0;
    v10 = strtol(v4, 0, 10);
    v4 = v9;
    if ( v10 < 0 )
      return sub_3305C(v24, 26, v10, 0, v25);
    v11 = dword_7B198;
    if ( dword_7B198 <= v10 )
      return sub_3305C(v24, 26, v10, 0, v25);
    if ( v23[v10] )
      return sub_3305C(v24, 74, v10, 0, v25);
    *(_DWORD *)&v23[4 * v10] = v8;
    v23[v10] = 1;
    ++v8;
    if ( !v9 )
      break;
    if ( !*v9 )
    {
      if ( v11 <= 0 )
        goto LABEL_29;
      break;
    }
  }
  v12 = v23;
  v13 = 0;
  v14 = dword_7B438;
  do
  {
    v16 = (unsigned __int8)*v12++;
    v15 = v16;
    v17 = v16 == 0;
    if ( v16 )
    {
      v15 = *(_DWORD *)(v14 + v13);
      v4 = *(const char **)&v23[v13];
    }
    v13 += 4;
    if ( !v17 )
      *(_DWORD *)(v15 + 4) = v4;
  }
  while ( v12 != &v23[v11] );
  v18 = dword_7B438;
  v19 = 0;
LABEL_24:
  while ( 2 )
  {
    v20 = 0;
    while ( 1 )
    {
      if ( !v23[v20] )
      {
        v21 = *(_DWORD *)(v18 + 4 * v20);
        if ( *(_DWORD *)(v21 + 4) == v19 )
          break;
      }
      if ( ++v20 == v11 )
      {
        if ( ++v19 != v11 )
          goto LABEL_24;
        goto LABEL_29;
      }
    }
    ++v19;
    *(_DWORD *)(v21 + 4) = v8++;
    v23[v20] = 1;
    if ( v19 != v11 )
      continue;
    break;
  }
LABEL_29:
  if ( *(_DWORD *)(sub_1DA58() + 4) )
    sub_19BF8(0);
  return sub_3305C(v24, 73, 0, 0, v25);
}
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00034728) --------------------------------------------------------
void __fastcall sub_34728(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v7; // r7
  int *v8; // r7
  char *v9; // r4
  char *s; // [sp+Ch] [bp-Ch] BYREF
  const char *v11; // [sp+10h] [bp-8h] BYREF
  const char *v12; // [sp+14h] [bp-4h] BYREF

  if ( a3 && *a3 )
  {
    if ( sub_3204C((unsigned __int8 *)a3, (unsigned __int8 **)&s, &v11, &v12) )
    {
      v8 = (int *)sub_17A3C();
      sub_1557C((int)v8, s);
      sub_26BCC((int)v8, 1, s, v11, v12);
      v9 = sub_30500(s, a4);
      sub_3305C(a1, 55, *v8, (int)v9, a4);
      if ( v9 != s )
        free(v9);
    }
    else
    {
      v7 = sub_30500(a3, a4);
      sub_3305C(a1, 53, 0, (int)v7, a4);
      if ( v7 != a3 )
        free(v7);
    }
  }
  else
  {
    sub_3305C(a1, 52, 0, 0, a4);
  }
}

//----- (00034830) --------------------------------------------------------
int __fastcall sub_34830(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r7
  int v11; // r4
  unsigned __int8 v12; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_7B198 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      if ( pthread_mutex_lock(&stru_7BA10) )
        sub_B774("switchpool", 2907);
      sub_32190(&stru_7BA28, "switchpool", 2907);
      if ( pthread_mutex_unlock(&stru_7BA10) )
        sub_B84C("switchpool", 2907);
      if ( v9 >= 0 && v9 < dword_7B198 )
      {
        v11 = *(_DWORD *)(dword_7B438 + 4 * v9);
        *(_DWORD *)(v11 + 132) = 1;
        if ( pthread_rwlock_unlock(&stru_7BA28) )
          sub_B7E0("switchpool", 2917);
        off_75ED8();
        sub_19BF8(v11);
        v12 = a4;
        a1 = v6;
        v7 = v9;
        v8 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&stru_7BA28) )
          sub_B7E0("switchpool", 2910);
        off_75ED8();
        v12 = a4;
        a1 = v6;
        v7 = v9;
        v8 = 26;
      }
    }
    else
    {
      v7 = 0;
      v12 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v12 = a4;
    v8 = 8;
  }
  return sub_3305C(a1, v8, v7, 0, v12);
}
// 75ED8: using guessed type int (*off_75ED8)();
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;

//----- (00034A90) --------------------------------------------------------
int __fastcall sub_34A90(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3305C(a1, 10, 0, 0, a4);
}

//----- (00034AA4) --------------------------------------------------------
int __fastcall sub_34AA4(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3305C(a1, 10, 0, 0, a4);
}

//----- (00034C60) --------------------------------------------------------
int __fastcall sub_34C60(int a1, int a2, int a3, int a4)
{
  int v6; // r4
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  int result; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r1

  sub_3305C((unsigned int *)a1, 22, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_307C8((unsigned int *)a1, ",\"VERSION\":[");
    v7 = sub_32E1C(0, "CGMiner", a49, 0);
    v8 = sub_32E40(v7, "API", "3.1", 0);
    v9 = sub_32E1C(v8, "Miner", (const char *)&dword_78B94, 0);
    v10 = sub_32E1C(v9, "CompileTime", s, 0);
    v11 = sub_32E1C(v10, "Type", byte_78850, 0);
    result = sub_32534((unsigned int *)a1, (int)v11, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_307C8((unsigned int *)a1, "VERSION,");
    v13 = sub_32E1C(0, "CGMiner", a49, 0);
    v14 = sub_32E40(v13, "API", "3.1", 0);
    v15 = sub_32E1C(v14, "Miner", (const char *)&dword_78B94, 0);
    v16 = sub_32E1C(v15, "CompileTime", s, 0);
    v17 = sub_32E1C(v16, "Type", byte_78850, 0);
    return sub_32534((unsigned int *)a1, (int)v17, 0, 0);
  }
  return result;
}
// 78B94: using guessed type int dword_78B94;

//----- (00034DC0) --------------------------------------------------------
void __fastcall sub_34DC0(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v4; // r4
  FILE *v7; // r0
  FILE *v8; // r5
  char *v9; // r5
  char *v10; // r8
  char v11[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = a3;
  if ( !a3 || !*a3 )
  {
    v4 = v11;
    sub_16150(v11);
  }
  v7 = fopen(v4, "w");
  v8 = v7;
  if ( v7 )
  {
    sub_15B64(v7);
    fclose(v8);
    v9 = sub_30500(v4, a4);
    sub_3305C(a1, 44, 0, (int)v9, a4);
    if ( v9 != v4 )
      free(v9);
  }
  else
  {
    v10 = sub_30500(v4, a4);
    sub_3305C(a1, 43, 0, (int)v10, a4);
    if ( v10 != v4 )
      free(v10);
  }
}

//----- (00034E9C) --------------------------------------------------------
int __fastcall sub_34E9C(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_3305C(a1, 46, 0, 0, a4);
}

//----- (00034EB0) --------------------------------------------------------
_DWORD *__fastcall sub_34EB0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 17, a3, a4);
}

//----- (00035154) --------------------------------------------------------
int __fastcall sub_35154(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6)
{
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  int v18; // r2
  int v19; // r1
  int v20; // r3
  _BOOL4 v21; // r3
  int v23; // [sp+4h] [bp-10h] BYREF
  double v24; // [sp+8h] [bp-Ch] BYREF

  v23 = a2;
  v24 = dbl_7ACC0 / dbl_755F8;
  v9 = sub_32ED0(0, "STATS", (const char *)&v23, 0);
  v10 = sub_32E1C(v9, "ID", a3, 0);
  v11 = sub_32FCC(v10, "Elapsed", (const char *)&dbl_755F8, 0);
  v12 = sub_32F18(v11, "Calls", a4, 0);
  v13 = sub_33014(v12, "Wait", a4 + 4, 0);
  v14 = sub_33014(v13, "Max", a4 + 12, 0);
  v15 = sub_33014(v14, "Min", a4 + 20, 0);
  v16 = sub_32E1C(v15, "GHS 5s", byte_78B84, 0);
  v17 = sub_34EB0(v16, "GHS av", (const char *)&v24, 0);
  v19 = (int)v17;
  if ( a5 )
  {
    if ( v17 )
      v18 = v17[4];
    else
      v19 = a5;
    if ( v17 )
    {
      v20 = *(_DWORD *)(a5 + 16);
      *(_DWORD *)(a5 + 16) = v18;
      *(_DWORD *)(v17[4] + 20) = a5;
      *(_DWORD *)(v20 + 20) = v17;
      v17[4] = v20;
    }
  }
  if ( a6 )
    v21 = v23 > 0;
  else
    v21 = 0;
  sub_32534(a1, v19, a6, v21);
  return v23 + 1;
}
// 35154: too many cbuild loops
// 3523C: variable 'v18' is possibly undefined
// 755F8: using guessed type double dbl_755F8;
// 7ACC0: using guessed type double dbl_7ACC0;

//----- (00035520) --------------------------------------------------------
_DWORD *__fastcall sub_35520(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 18, a3, a4);
}

//----- (00035544) --------------------------------------------------------
_DWORD *__fastcall sub_35544(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 19, a3, a4);
}

//----- (00035568) --------------------------------------------------------
_DWORD *__fastcall sub_35568(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 20, a3, a4);
}

//----- (0003558C) --------------------------------------------------------
_DWORD *__fastcall sub_3558C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 21, a3, a4);
}

//----- (000355B0) --------------------------------------------------------
_DWORD *__fastcall sub_355B0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 22, a3, a4);
}

//----- (000355D4) --------------------------------------------------------
_DWORD *__fastcall sub_355D4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 23, a3, a4);
}

//----- (000355F8) --------------------------------------------------------
_DWORD *__fastcall sub_355F8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 24, a3, a4);
}

//----- (000357A4) --------------------------------------------------------
_DWORD *__fastcall sub_357A4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 25, a3, a4);
}

//----- (000357C8) --------------------------------------------------------
int __fastcall sub_357C8(int a1, int a2, int a3, int a4)
{
  char *v5; // r1
  int v6; // r9
  __int64 v7; // r0
  __int64 v8; // d9
  double v9; // r0
  double v10; // d8
  int v11; // r1
  double v12; // d16
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r12
  __int64 v34; // r0
  double v35; // d8
  double v36; // r0
  double v37; // d16
  _DWORD *v38; // r11
  double v39; // r0
  double v40; // d16
  _DWORD *v41; // r0
  double v42; // d16
  double v43; // d16
  _DWORD *v44; // r0
  double v45; // d16
  double v46; // d16
  _DWORD *v47; // r0
  _DWORD *v48; // r5
  int result; // r0
  time_t v50; // r0
  int v51; // r11
  int v52; // r11
  int v53; // r10
  time_t v54; // r0
  double v55; // d16
  int v56; // r11
  _DWORD *v58; // [sp+10h] [bp-44h]
  double v59; // [sp+18h] [bp-3Ch] BYREF
  double v60; // [sp+20h] [bp-34h] BYREF
  double v61; // [sp+28h] [bp-2Ch] BYREF
  double v62; // [sp+30h] [bp-24h] BYREF
  double v63; // [sp+38h] [bp-1Ch] BYREF
  double v64; // [sp+40h] [bp-14h] BYREF
  double v65; // [sp+48h] [bp-Ch] BYREF

  sub_3305C((unsigned int *)a1, 11, 0, 0, a4);
  v5 = "SUMMARY,";
  if ( a4 )
    v5 = ",\"SUMMARY\":[";
  v6 = sub_307C8((unsigned int *)a1, v5);
  if ( pthread_mutex_lock(&stru_7B384) )
    sub_B774("summary", 2793);
  LODWORD(v7) = sub_5CC10(dbl_7B5E8 + dbl_7B670 + dbl_7B428);
  *(_QWORD *)&dword_7B100 = v7;
  v8 = v7;
  LODWORD(v9) = sub_5CB64(qword_7B420);
  v10 = dbl_755F8;
  v60 = dbl_7ACC0 / dbl_755F8;
  if ( dbl_755F8 == 0.0 )
  {
    v59 = v9 * 60.0;
    v10 = 1.0;
  }
  else
  {
    v59 = v9 / dbl_755F8 * 60.0;
  }
  LODWORD(v12) = sub_5CB64(v8);
  HIDWORD(v12) = v11;
  v61 = v12 / v10 * 60.0;
  if ( byte_78E28 )
  {
    v50 = time(0);
    srand(v50);
    if ( *off_76B84 == 122 && off_76B84[1] == 57 && !off_76B84[2] )
    {
      v51 = dword_78E38;
      v52 = 14 * v51 + rand() % 2;
      v53 = v52 % 5;
    }
    else if ( !strcmp(off_76B84, "z9-mini") )
    {
      v56 = dword_78E38;
      v52 = 3 * v56 + 1 + rand() % 2;
      v53 = v52 % 5;
    }
    else
    {
      v53 = 4;
      v52 = 14;
    }
    v54 = time(0);
    srand(v54);
    v55 = (double)(rand() % 99) / 100.0;
    dbl_78E30 = (double)v52 + v55;
    v60 = (double)v52 + v55;
    v59 = v55 + (double)v53;
    v61 = (double)(rand() % 4 + 100) + 0.27;
    sprintf(byte_78B84, "%f", v60 + 0.79);
  }
  v13 = sub_32FCC(0, "Elapsed", (const char *)&dbl_755F8, 1);
  v14 = sub_32E1C(v13, "GHS 5s", byte_78B84, 0);
  v15 = sub_34EB0(v14, "GHS av", (const char *)&v60, 0);
  v16 = sub_32EF4(v15, "Found Blocks", (const char *)&dword_7B8B8, 1);
  v17 = sub_32F84(v16, "Getworks", (const char *)&dword_7B648, 1);
  v18 = sub_32F84(v17, "Accepted", (const char *)&qword_7B420, 1);
  v19 = sub_32F84(v18, "Rejected", (const char *)&qword_7B6F8, 1);
  v20 = sub_32ED0(v19, "Hardware Errors", (const char *)&dword_7B8A4, 1);
  v21 = sub_35568(v20, "Utility", (const char *)&v59, 0);
  v22 = sub_32F84(v21, "Discarded", (const char *)&dword_7B7C8, 1);
  v23 = sub_32F84(v22, "Stale", (const char *)&dword_7BC80, 1);
  v24 = sub_32EF4(v23, "Get Failures", (const char *)&dword_7B43C, 1);
  v25 = sub_32EF4(v24, "Local Work", (const char *)dword_7B4CC, 1);
  v26 = sub_32EF4(v25, "Remote Failures", (const char *)&dword_7AE68, 1);
  v27 = sub_32EF4(v26, "Network Blocks", (const char *)&dword_7BB1C, 1);
  v28 = sub_35520(v27, "Total MH", (const char *)&dbl_7ACC0, 1);
  v29 = sub_35568(v28, "Work Utility", (const char *)&v61, 0);
  v30 = sub_355F8(v29, "Difficulty Accepted", (const char *)&dbl_7B5E8, 1);
  v31 = sub_355F8(v30, "Difficulty Rejected", (const char *)&dbl_7B670, 1);
  v32 = sub_355F8(v31, "Difficulty Stale", (const char *)&dbl_7B428, 1);
  v33 = sub_32F60(v32, "Best Share", (const char *)&qword_76F18, 1);
  v34 = *(_QWORD *)&dword_7B100 + dword_7B8A4;
  if ( v34 )
  {
    v58 = v33;
    v35 = (double)dword_7B8A4;
    LODWORD(v36) = sub_5CB64(v34);
    v33 = v58;
    v37 = v35 / v36;
  }
  else
  {
    v37 = 0.0;
  }
  v62 = v37;
  v38 = sub_357A4(v33, "Device Hardware%", (const char *)&v62, 0);
  if ( *(_QWORD *)&dword_7B100 )
  {
    LODWORD(v39) = sub_5CB64(*(__int64 *)&dword_7B100);
    v40 = dbl_7B670 / v39;
  }
  else
  {
    v40 = 0.0;
  }
  v63 = v40;
  v41 = sub_357A4(v38, "Device Rejected%", (const char *)&v63, 0);
  v42 = dbl_7B670 + dbl_7B5E8 + dbl_7B428;
  if ( v42 == 0.0 )
    v43 = 0.0;
  else
    v43 = dbl_7B670 / v42;
  v64 = v43;
  v44 = sub_357A4(v41, "Pool Rejected%", (const char *)&v64, 0);
  v45 = dbl_7B5E8 + dbl_7B670 + dbl_7B428;
  if ( v45 == 0.0 )
    v46 = 0.0;
  else
    v46 = dbl_7B428 / v45;
  v65 = v46;
  v47 = sub_357A4(v44, "Pool Stale%", (const char *)&v65, 0);
  v48 = sub_33038(v47, "Last getwork", (const char *)&dword_7B948, 0);
  if ( pthread_mutex_unlock(&stru_7B384) )
    sub_B84C("summary", 2862);
  off_75ED8();
  result = sub_32534((unsigned int *)a1, (int)v48, a4, 0);
  if ( (v6 & a4) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 3584C: variable 'v7' is possibly undefined
// 35874: variable 'v9' is possibly undefined
// 3589C: variable 'v11' is possibly undefined
// 35A4C: variable 'v36' is possibly undefined
// 35A88: variable 'v39' is possibly undefined
// 755F8: using guessed type double dbl_755F8;
// 75ED8: using guessed type int (*off_75ED8)();
// 76B84: using guessed type char *off_76B84;
// 76F18: using guessed type __int64 qword_76F18;
// 78E28: using guessed type char byte_78E28;
// 78E30: using guessed type double dbl_78E30;
// 78E38: using guessed type int dword_78E38;
// 7ACC0: using guessed type double dbl_7ACC0;
// 7AE68: using guessed type int dword_7AE68;
// 7B100: using guessed type int dword_7B100;
// 7B420: using guessed type __int64 qword_7B420;
// 7B428: using guessed type double dbl_7B428;
// 7B43C: using guessed type int dword_7B43C;
// 7B4CC: using guessed type int dword_7B4CC[3];
// 7B5E8: using guessed type double dbl_7B5E8;
// 7B648: using guessed type int dword_7B648;
// 7B670: using guessed type double dbl_7B670;
// 7B6F8: using guessed type __int64 qword_7B6F8;
// 7B7C8: using guessed type int dword_7B7C8;
// 7B8A4: using guessed type int dword_7B8A4;
// 7B8B8: using guessed type int dword_7B8B8;
// 7B948: using guessed type int dword_7B948;
// 7BB1C: using guessed type int dword_7BB1C;
// 7BC80: using guessed type int dword_7BC80;

//----- (000363D8) --------------------------------------------------------
_DWORD *__fastcall sub_363D8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31CDC(a1, a2, 26, a3, a4);
}

//----- (000363FC) --------------------------------------------------------
int __fastcall sub_363FC(unsigned int *a1, int a2, int a3, int a4)
{
  int v5; // r2
  unsigned int v8; // r3
  const char *v9; // r7
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _BOOL4 v26; // r3
  char v28[8]; // [sp+4h] [bp-8h] BYREF

  v5 = *(_DWORD *)(a3 + 244);
  *(_DWORD *)v28 = a2;
  if ( v5 )
  {
    v8 = *(_DWORD *)(a3 + 248);
    if ( v8 <= 8 )
      v9 = *(const char **)&aEscapeString[4 * v8 + 112];
    else
      v9 = "Unknown reason - code bug";
  }
  else
  {
    v9 = "None";
  }
  v10 = sub_32ED0(0, "NOTIFY", v28, 0);
  v11 = sub_32E1C(v10, "Name", *(const char **)(*(_DWORD *)(a3 + 4) + 8), 0);
  v12 = sub_32ED0(v11, "ID", (const char *)(a3 + 8), 0);
  v13 = sub_33038(v12, "Last Well", (const char *)(a3 + 240), 0);
  v14 = sub_33038(v13, "Last Not Well", (const char *)(a3 + 244), 0);
  v15 = sub_32E1C(v14, "Reason Not Well", v9, 0);
  v16 = sub_32ED0(v15, "*Thread Fail Init", (const char *)(a3 + 252), 0);
  v17 = sub_32ED0(v16, "*Thread Zero Hash", (const char *)(a3 + 256), 0);
  v18 = sub_32ED0(v17, "*Thread Fail Queue", (const char *)(a3 + 260), 0);
  v19 = sub_32ED0(v18, "*Dev Sick Idle 60s", (const char *)(a3 + 264), 0);
  v20 = sub_32ED0(v19, "*Dev Dead Idle 600s", (const char *)(a3 + 268), 0);
  v21 = sub_32ED0(v20, "*Dev Nostart", (const char *)(a3 + 272), 0);
  v22 = sub_32ED0(v21, "*Dev Over Heat", (const char *)(a3 + 276), 0);
  v23 = sub_32ED0(v22, "*Dev Thermal Cutoff", (const char *)(a3 + 280), 0);
  v24 = sub_32ED0(v23, "*Dev Comms Error", (const char *)(a3 + 284), 0);
  v25 = sub_32ED0(v24, "*Dev Throttle", (const char *)(a3 + 288), 0);
  if ( a4 )
    v26 = *(_DWORD *)v28 > 0;
  else
    v26 = 0;
  return sub_32534(a1, (int)v25, a4, v26);
}

//----- (0003669C) --------------------------------------------------------
int sub_3669C()
{
  void *v0; // r0
  int result; // r0
  char v2[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc mcast thr");
    sub_38730(3, v2, 1);
    sub_16CA8(1);
  }
  result = sub_2F174((int)v0, 0, (void *(*)(void *))sub_31CA0, v0);
  if ( result )
  {
    strcpy(v2, "API mcast thread create failed");
    sub_38730(3, v2, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (00036764) --------------------------------------------------------
void __fastcall sub_36764(int a1)
{
  double v1; // d0
  int *v2; // r0
  _BYTE *v3; // r0
  _DWORD *v4; // r0
  char *v5; // r3
  int v6; // r2
  bool v7; // zf
  char *v8; // r4
  size_t v9; // r5
  char *v10; // r0
  unsigned __int8 *v11; // r4
  char *v12; // r0
  char *v13; // r0
  int v14; // r3
  const __int32_t *v15; // r2
  int v16; // r8
  __int32_t v17; // r1
  unsigned __int8 *v18; // r6
  int v19; // r10
  char *v20; // r0
  char *v21; // r7
  const char *v22; // r9
  _UNKNOWN **v23; // r5
  int v24; // r4
  const char *v25; // t1
  const char *v26; // r4
  char *v27; // r3
  const char *v28; // r2
  _BYTE *v29; // r6
  char *v30; // r7
  const char *v31; // r9
  size_t v32; // r0
  int v33; // r5
  size_t v34; // r0
  char *v35; // r0
  int *v36; // r4
  const char *v37; // r5
  char *v38; // r7
  const char *v39; // t1
  size_t v40; // r0
  const char *v41; // t1
  const __int32_t *v42; // r2
  __int32_t v43; // r3
  int v44; // r5
  size_t v45; // r0
  char *v46; // r0
  const char *v47; // r5
  size_t v48; // r0
  char *v49; // r0
  char *v50; // r11
  char *v51; // r2
  size_t v52; // r0
  int v53; // r3
  int v54; // t1
  int v55; // r7
  int v56; // r3
  char *v57; // r6
  bool v58; // zf
  unsigned __int8 *v59; // r6
  int v60; // t1
  bool v61; // zf
  char *v62; // r0
  const unsigned __int16 **v63; // r0
  int v64; // r1
  const __int32_t *v65; // r3
  char v66; // r2
  char *v67; // r5
  int v68; // r9
  int v69; // r3
  char *v70; // r5
  unsigned __int8 v71; // r2
  char *v72; // r0
  int v73; // r9
  int i; // r3
  int j; // r3
  char v76; // t1
  int v77; // r0
  int v78; // r2
  int v79; // r2
  int v80; // r3
  char *v81; // r1
  int v82; // r0
  int v83; // r3
  char *v84; // r1
  int v85; // r12
  __int32_t v86; // r1
  unsigned __int8 *v87; // r4
  int v88; // r2
  char *v89; // r3
  struct addrinfo *v90; // r12
  struct addrinfo *v91; // r4
  int v92; // r0
  time_t v93; // r9
  int v94; // r9
  int *v95; // r11
  int v96; // r0
  _BOOL4 v97; // r5
  const char *v98; // r2
  ssize_t v99; // r0
  int v100; // r6
  int v101; // r3
  int v102; // r5
  time_t v103; // r0
  _BYTE *v104; // r1
  char *v105; // r0
  char *v106; // r10
  const char *v107; // r8
  size_t v108; // r0
  char *v109; // r7
  char *v110; // r0
  const char *v111; // r1
  _UNKNOWN **v112; // r10
  int v113; // r6
  const char *v114; // t1
  int v115; // r3
  int v116; // r6
  int v117; // r3
  int v118; // r3
  int *v119; // r0
  char *v120; // r10
  int *v121; // r0
  char *v122; // r0
  int *v123; // r0
  char *v124; // r0
  int v125; // r0
  int v126; // r12
  __int32_t v127; // r2
  char *v128; // r0
  int *v129; // r0
  char *v130; // r0
  const char *v131; // r3
  int *v132; // r0
  int *v133; // r0
  char *v134; // r0
  int *v135; // r0
  int *v136; // r0
  char *v137; // r0
  _DWORD *v138; // r0
  size_t v139; // r0
  int *v140; // r3
  char *v141; // r0
  int v142; // r3
  int v143; // r0
  int v144; // [sp+10h] [bp-539Ch]
  unsigned __int8 *v145; // [sp+14h] [bp-5398h]
  const __int32_t **v146; // [sp+20h] [bp-538Ch]
  char *dest; // [sp+28h] [bp-5384h]
  int *ptr; // [sp+2Ch] [bp-5380h]
  int fd; // [sp+34h] [bp-5378h]
  _DWORD *v150; // [sp+38h] [bp-5374h]
  char *haystack; // [sp+3Ch] [bp-5370h]
  __int16 v152; // [sp+40h] [bp-536Ch]
  char *s; // [sp+48h] [bp-5364h]
  char *v155; // [sp+6Ch] [bp-5340h]
  unsigned __int8 v156; // [sp+72h] [bp-533Ah] BYREF
  char v157; // [sp+73h] [bp-5339h] BYREF
  const char *v158; // [sp+74h] [bp-5338h] BYREF
  socklen_t addr_len; // [sp+78h] [bp-5334h] BYREF
  struct addrinfo *v160; // [sp+7Ch] [bp-5330h] BYREF
  int optval; // [sp+80h] [bp-532Ch] BYREF
  char service[12]; // [sp+84h] [bp-5328h] BYREF
  struct addrinfo req; // [sp+90h] [bp-531Ch] BYREF
  char v164[100]; // [sp+B0h] [bp-52FCh] BYREF
  struct sockaddr addr; // [sp+114h] [bp-5298h] BYREF
  char v166[252]; // [sp+194h] [bp-5218h] BYREF
  struct __jmp_buf_tag env; // [sp+290h] [bp-511Ch] BYREF
  char needle[4056]; // [sp+3A8h] [bp-5004h] BYREF
  int v169[2038]; // [sp+13A8h] [bp-4004h] BYREF
  char v170[8024]; // [sp+33A8h] [bp-2004h] BYREF

  v152 = dword_75ED0;
  v2 = (int *)malloc(4u);
  v7 = byte_7B7D1 == 0;
  ptr = v2;
  *v2 = -1;
  if ( v7 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v170, 0x1000u, "API not running%s", " - API will not be available");
      sub_38730(7, v170, 0);
    }
    goto LABEL_7;
  }
  v150 = malloc(0x10u);
  v3 = malloc(0x10000u);
  v150[1] = v3;
  v150[2] = v3;
  *((_BYTE *)v150 + 12) = 1;
  *v150 = 0x10000;
  *v3 = 0;
  *((_BYTE *)v150 + 13) = 0;
  v4 = malloc(0xCu);
  v5 = &byte_78CAC;
  v6 = dword_78CD0;
  v7 = dword_78CD0 == 0;
  *v4 = v150;
  if ( v7 )
  {
    v4[1] = v4;
    v4[2] = v4;
  }
  else
  {
    v4[2] = v6;
    v5 = *(char **)(v6 + 4);
  }
  if ( v7 )
  {
    *((_DWORD *)v5 + 9) = v4;
  }
  else
  {
    v4[1] = v5;
    *(_DWORD *)(v6 + 4) = v4;
    v5 = (char *)v4[1];
  }
  if ( !v7 )
    *((_DWORD *)v5 + 2) = v4;
  if ( pthread_mutex_init(&stru_78CB8, 0) )
  {
    v132 = _errno_location();
    snprintf(v170, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v132, "api.c", "api", 5297);
    sub_38730(3, v170, 1);
    sub_16CA8(1);
  }
  if ( _sigsetjmp(&env, 0) )
  {
    sub_3243C(ptr);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
    goto LABEL_308;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
  v8 = (char *)dword_7B944;
  dword_78CDC = a1;
  if ( dword_7B944 )
  {
    v9 = strlen((const char *)dword_7B944) + 1;
  }
  else
  {
    v8 = "";
    v9 = 1;
  }
  v10 = (char *)malloc(v9);
  s = v10;
  if ( !v10 )
  {
    strcpy(v170, "Failed to malloc ipgroups buf");
    sub_38730(3, v170, 1);
    sub_16CA8(1);
  }
  memcpy(v10, v8, v9);
  if ( !*s )
  {
    v146 = _ctype_toupper_loc();
    goto LABEL_69;
  }
  v11 = (unsigned __int8 *)s;
  v146 = _ctype_toupper_loc();
  while ( 2 )
  {
    v12 = strchr((const char *)v11, 44);
    v145 = (unsigned __int8 *)v12;
    if ( v12 )
    {
      *v12 = 0;
      v145 = (unsigned __int8 *)(v12 + 1);
    }
    if ( v11[1] != 58 )
    {
      v13 = strchr((const char *)v11, 58);
      if ( v13 )
        *v13 = 0;
      snprintf((char *)v169, 0x1000u, "API invalid group name '%s'", v11);
      sub_38730(3, (const char *)v169, 1);
      sub_16CA8(1);
    }
    v14 = *v11;
    v15 = *v146;
    v16 = LOBYTE((*v146)[v14]);
    v17 = (*v146)[v16];
    if ( v17 < (*v146)[65] || v17 > v15[90] )
    {
      snprintf((char *)v169, 0x1000u, "API invalid group name '%c'", v14);
      sub_38730(3, (const char *)v169, 1);
      sub_16CA8(1);
    }
    if ( v16 == v15[87] )
    {
      snprintf((char *)v169, 0x1000u, "API group name can't be '%c'", v16);
      sub_38730(3, (const char *)v169, 1);
      sub_16CA8(1);
    }
    if ( v16 == v15[82] )
    {
      snprintf((char *)v169, 0x1000u, "API group name can't be '%c'", v16);
      sub_38730(3, (const char *)v169, 1);
      sub_16CA8(1);
    }
    if ( *((_DWORD *)&unk_7BD24 + v15[v16] - v15[65]) )
    {
      snprintf((char *)v169, 0x1000u, "API duplicate group name '%c'", *v11);
      sub_38730(3, (const char *)v169, 1);
      sub_16CA8(1);
    }
    v18 = v11 + 2;
    v19 = 0;
    strcpy(v170, "|");
    if ( v11 == (unsigned __int8 *)-2 || !v11[2] )
      goto LABEL_61;
    dest = &v170[1];
    while ( 1 )
    {
      v20 = strchr((const char *)v18, 58);
      v21 = v20;
      if ( v20 )
      {
        *v20 = 0;
        v21 = v20 + 1;
      }
      if ( *v18 == 42 && !v18[1] )
      {
        v19 = 1;
        goto LABEL_42;
      }
      v22 = (const char *)off_7652C;
      if ( !off_7652C )
      {
LABEL_65:
        snprintf((char *)v169, 0x1000u, "API unknown command '%s' in group '%c'", v18, v16);
        sub_38730(3, (const char *)v169, 1);
        sub_16CA8(1);
      }
      v23 = &off_7652C;
      v24 = 0;
      while ( strcasecmp((const char *)v18, v22) )
      {
        v25 = (const char *)v23[3];
        v23 += 3;
        v22 = v25;
        ++v24;
        if ( !v25 )
          goto LABEL_65;
      }
      sprintf(needle, "|%s|", v22);
      if ( !strstr(v170, needle) )
        break;
LABEL_42:
      if ( !v21 )
        goto LABEL_54;
LABEL_43:
      if ( !*v21 )
        goto LABEL_54;
      v18 = (unsigned __int8 *)v21;
    }
    v26 = (const char *)dword_760FC[3 * v24 + 268];
    strcpy(dest, v26);
    v27 = &dest[strlen(v26)];
    *v27 = 124;
    dest = v27 + 1;
    v27[1] = 0;
    if ( v21 )
      goto LABEL_43;
LABEL_54:
    if ( v19 )
    {
      v28 = (const char *)off_7652C;
      if ( off_7652C )
      {
        v29 = &unk_76534;
        v30 = dest;
        do
        {
          while ( 1 )
          {
            if ( !*v29 )
            {
              sprintf(needle, "|%s|", v28);
              if ( !strstr(v170, needle) )
                break;
            }
            v29 += 12;
            v28 = (const char *)*((_DWORD *)v29 - 2);
            if ( !v28 )
              goto LABEL_61;
          }
          v31 = (const char *)*((_DWORD *)v29 - 2);
          v29 += 12;
          strcpy(v30, v31);
          v32 = strlen(v31);
          v30[v32] = 124;
          v30 += v32 + 1;
          *v30 = 0;
          v28 = (const char *)*((_DWORD *)v29 - 2);
        }
        while ( v28 );
      }
    }
LABEL_61:
    v33 = (*v146)[v16] - (*v146)[65];
    v34 = strlen(v170);
    v35 = (char *)malloc(v34 + 1);
    *((_DWORD *)&unk_7BD24 + v33) = v35;
    if ( !v35 )
    {
      strcpy((char *)v169, "Failed to malloc group commands buf");
      sub_38730(3, (const char *)v169, 1);
      sub_16CA8(1);
    }
    strcpy(v35, v170);
    if ( v145 && *v145 )
    {
      v11 = v145;
      continue;
    }
    break;
  }
LABEL_69:
  v36 = dword_760FC;
  v37 = (const char *)off_7652C;
  if ( off_7652C )
    v36 = (int *)&off_7652C;
  strcpy(v170, "|");
  if ( off_7652C )
  {
    v38 = &v170[1];
    do
    {
      while ( *((_BYTE *)v36 + 8) )
      {
        v39 = (const char *)v36[3];
        v36 += 3;
        v37 = v39;
        if ( !v39 )
          goto LABEL_77;
      }
      strcpy(v38, v37);
      v40 = strlen(v37);
      v38[v40] = 124;
      v38 += v40 + 1;
      *v38 = 0;
      v41 = (const char *)v36[3];
      v36 += 3;
      v37 = v41;
    }
    while ( v41 );
  }
LABEL_77:
  v42 = *v146;
  v43 = (*v146)[82];
  if ( (unsigned int)(v43 + 128) < 0x180 )
    v43 = v42[v43];
  v44 = v43 - v42[65];
  v45 = strlen(v170);
  v46 = (char *)malloc(v45 + 1);
  *((_DWORD *)&unk_7BD24 + v44) = v46;
  if ( !v46 )
  {
LABEL_308:
    strcpy((char *)v169, "Failed to malloc noprivgroup commands buf");
    sub_38730(3, (const char *)v169, 1);
    sub_16CA8(1);
  }
  strcpy(v46, v170);
  free(s);
  v47 = (const char *)dword_78C98;
  if ( !dword_78C98 )
    goto LABEL_114;
  v48 = strlen((const char *)dword_78C98);
  v49 = (char *)malloc(v48 + 1);
  v50 = v49;
  if ( !v49 )
  {
    strcpy(v170, "Failed to malloc ipaccess buf");
    sub_38730(3, v170, 1);
    sub_16CA8(1);
  }
  strcpy(v49, v47);
  v51 = v50 - 1;
  v52 = 1;
  while ( 1 )
  {
    v54 = (unsigned __int8)*++v51;
    v53 = v54;
    if ( !v54 )
      break;
    if ( v53 == 44 )
      ++v52;
  }
  dword_78CB4 = (int)calloc(v52, 0x24u);
  if ( !dword_78CB4 )
  {
    strcpy(v170, "Failed to calloc ipaccess");
    sub_38730(3, v170, 1);
    sub_16CA8(1);
  }
  v55 = 0;
  dword_78CB0 = 0;
  if ( !v50 || (v56 = (unsigned __int8)*v50, !*v50) )
  {
    free(v50);
    goto LABEL_158;
  }
  v57 = v50;
  do
  {
    v58 = v56 == 32;
    if ( v56 != 32 )
      v58 = v56 == 9;
    if ( v58 )
    {
      v59 = (unsigned __int8 *)(v57 + 1);
      do
      {
        v87 = v59;
        v60 = *v59++;
        v56 = v60;
        v61 = v60 == 32;
        if ( v60 != 32 )
          v61 = v56 == 9;
      }
      while ( v61 );
    }
    else
    {
      v87 = (unsigned __int8 *)v57;
    }
    if ( v56 == 44 )
    {
      v57 = (char *)(v87 + 1);
    }
    else
    {
      v62 = strchr((const char *)v87, 44);
      v57 = v62;
      if ( v62 )
      {
        *v62 = 0;
        v57 = v62 + 1;
      }
      v63 = _ctype_b_loc();
      v64 = *v87;
      v65 = *v146;
      v66 = *((_BYTE *)*v146 + 328);
      if ( ((*v63)[v64] & 0x400) != 0 && v87[1] == 58 )
      {
        v86 = v65[v64];
        if ( v86 == v65[87] || *((_DWORD *)&unk_7BD24 + v86 - v65[65]) )
          v66 = v86;
        v87 += 2;
      }
      v67 = (char *)(dword_78CB4 + 36 * v55);
      v67[32] = v66;
      v68 = *v87;
      if ( v68 == 48 && v87[1] == 47 && v87[2] == 48 )
      {
        v69 = v87[3];
        if ( !v87[3] )
        {
          v70 = v67 - 1;
          v71 = v87[3];
          do
          {
            ++v69;
            *++v70 = v71;
            v70[16] = v71;
          }
          while ( v69 != 16 );
          goto LABEL_110;
        }
      }
      v72 = strchr((const char *)v87, 47);
      if ( !v72 )
      {
        v88 = 0;
        v89 = v67;
        do
        {
          ++v88;
          v89[16] = -1;
          ++v89;
        }
        while ( v88 != 16 );
        v68 = *v87;
        v72 = (char *)&v87[strlen((const char *)v87)];
      }
      if ( v68 == 91 && *(v72 - 1) == 93 )
      {
        v73 = 1;
        *v87++ = 0;
        *(v72 - 1) = 0;
      }
      else
      {
        v73 = 0;
      }
      if ( !*v72 )
        goto LABEL_124;
      *v72 = 0;
      v77 = strtol(v72 + 1, 0, 10);
      if ( v77 > 0 )
      {
        v78 = v73 ? 0 : 96;
        v79 = v77 + v78;
        if ( v79 <= 128 )
        {
          v80 = 0;
          v81 = v67;
          v82 = 0;
          do
          {
            ++v80;
            v81[16] = 0;
            ++v81;
          }
          while ( v80 != 16 );
          v83 = 7;
          while ( v79 > 0 )
          {
            v84 = &v67[v82];
            if ( !v83 )
              ++v82;
            --v79;
            v85 = (unsigned __int8)v84[16] | (1 << v83);
            if ( v83 )
              --v83;
            else
              v83 = 7;
            v84[16] = v85;
          }
LABEL_124:
          for ( i = 0; i != 16; ++i )
            v67[i] = 0;
          if ( v73 )
          {
            if ( inet_pton(10, (const char *)v87, v67) != 1 )
              goto LABEL_111;
          }
          else
          {
            sprintf(v170, "::ffff:%s", v87);
            v55 = dword_78CB0;
            v67 = (char *)(dword_78CB4 + 36 * dword_78CB0);
            if ( inet_pton(10, v170, v67) != 1 )
              goto LABEL_111;
          }
          for ( j = 0; j != 16; ++j )
          {
            v76 = *v67++;
            *(v67 - 1) = v76 & v67[15];
          }
LABEL_110:
          dword_78CB0 = ++v55;
        }
      }
    }
LABEL_111:
    if ( !v57 )
      break;
    v56 = (unsigned __int8)*v57;
  }
  while ( *v57 );
  free(v50);
  if ( !v55 )
  {
LABEL_158:
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      snprintf(v170, 0x1000u, "API not running (no valid IPs specified)%s", " - API will not be available");
      sub_38730(4, v170, 0);
    }
    goto LABEL_7;
  }
LABEL_114:
  sub_2A92C();
  sprintf(service, "%d", v152);
  req.ai_flags = 1;
  memset(&req.ai_family, 0, 28);
  if ( getaddrinfo(off_75ECC, service, &req, &v160) )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      snprintf(v170, 0x1000u, "API failed to resolve %s", off_75ECC);
LABEL_119:
      sub_38730(3, v170, 0);
    }
    goto LABEL_7;
  }
  v90 = v160;
  if ( v160 )
  {
    v91 = v160;
    while ( 1 )
    {
      v92 = socket(v90->ai_family, 1, 0);
      *ptr = v92;
      if ( v92 > 0 )
        break;
      v91 = v91->ai_next;
      if ( !v91 )
        goto LABEL_240;
      v90 = v160;
    }
  }
  else
  {
    v92 = *ptr;
LABEL_240:
    if ( v92 == -1 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        v121 = _errno_location();
        v122 = strerror(*v121);
        snprintf(v170, 0x1000u, "API initialisation failed (%s)%s", v122, " - API will not be available");
        sub_38730(3, v170, 0);
      }
      freeaddrinfo(v160);
      free(ptr);
      return;
    }
    v91 = 0;
  }
  optval = 1;
  if ( setsockopt(v92, 1, 2, &optval, 4u) < 0 && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    v123 = _errno_location();
    v124 = strerror(*v123);
    snprintf(v170, 0x1000u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v124);
    sub_38730(7, v170, 0);
  }
  v93 = time(0);
  while ( 2 )
  {
    if ( bind(*ptr, v91->ai_addr, v91->ai_addrlen) >= 0 )
    {
      freeaddrinfo(v160);
      if ( listen(*ptr, 100) < 0 )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          v133 = _errno_location();
          v134 = strerror(*v133);
          snprintf(v170, 0x1000u, "API3 initialisation failed (%s)%s", v134, " - API will not be available");
          sub_38730(3, v170, 0);
        }
        close(*ptr);
        goto LABEL_7;
      }
      if ( !dword_78C98 )
      {
        if ( byte_7B7C4 )
        {
          if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
            goto LABEL_180;
          snprintf(v170, 0x1000u, "API running in UNRESTRICTED read access mode on port %d (%d)", v152, *ptr);
        }
        else
        {
          if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
            goto LABEL_180;
          snprintf(v170, 0x1000u, "API running in local read access mode on port %d (%d)", v152, *ptr);
        }
LABEL_179:
        sub_38730(4, v170, 0);
        goto LABEL_180;
      }
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(v170, 0x1000u, "API running in IP access mode on port %d (%d)", v152, *ptr);
        goto LABEL_179;
      }
LABEL_180:
      if ( byte_7B624 )
        sub_3669C();
      dword_78CD4 = (int)sub_38F3C("StrBufs", 12, 2, 0, 0, "api.c", "api", 5409);
      if ( !byte_78CAC )
      {
        v94 = 0;
        v95 = 0;
        while ( 1 )
        {
          v96 = *ptr;
          addr_len = 128;
          fd = accept(v96, &addr, &addr_len);
          if ( fd < 0 )
            break;
          v97 = sub_309E8(&addr, &v158, &v156);
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            if ( v97 )
              LOWORD(v98) = 27640;
            else
              LOWORD(v98) = 27652;
            HIWORD(v98) = 6;
            snprintf(needle, 0x1000u, "API: connection from %s - %s", v158, v98);
            sub_38730(7, needle, 0);
          }
          if ( v97 )
          {
            v99 = recv(fd, v169, 0x1FFFu, 0);
            v100 = v99;
            if ( v99 < 0 )
            {
              LOBYTE(v169[0]) = 0;
              if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                v136 = _errno_location();
                v137 = strerror(*v136);
                snprintf(needle, 0x1000u, "API: recv failed: %s", v137);
                sub_38730(7, needle, 0);
              }
            }
            else
            {
              v101 = (unsigned __int8)byte_78E09;
              *((_BYTE *)v169 + v99) = 0;
              if ( v101 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
              {
                snprintf(needle, 0x1000u, "API: recv command: (%d) '%s'", v99, (const char *)v169);
                sub_38730(7, needle, 0);
              }
              v102 = 0;
              v103 = time(0);
              v104 = (_BYTE *)v150[1];
              v150[2] = v104;
              dword_78CD8 = v103;
              *v104 = 0;
              *((_BYTE *)v150 + 13) = 0;
              if ( LOBYTE(v169[0]) != 123 )
              {
                v105 = strchr((const char *)v169, 124);
                v106 = v105;
                if ( v105 )
                {
                  *v105 = 0;
                  v106 = v105 + 1;
                }
                else
                {
                  v102 = 0;
                }
                v107 = (const char *)v169;
LABEL_205:
                if ( strchr(v107, 43) )
                {
                  v157 = 1;
                  v108 = strlen(v107);
                  haystack = (char *)malloc(v108 + 3);
                  if ( !haystack )
                  {
                    snprintf(needle, 0x1000u, "OOM cmdsbuf in %s %s():%d", "api.c", "api", 5520);
                    sub_38730(3, needle, 1);
                    sub_16CA8(1);
                  }
                  v94 = 1;
                  v106 = 0;
                  *(_WORD *)haystack = 124;
                }
                else
                {
                  haystack = 0;
                  v94 = 0;
                  v157 = 0;
                }
                v109 = (char *)v107;
                v155 = v106;
                while ( 2 )
                {
                  if ( !v94 )
                    goto LABEL_214;
                  v110 = strchr(v109, 43);
                  v107 = v110;
                  if ( v110 )
                  {
                    *v110 = 0;
                    v107 = v110 + 1;
                  }
                  if ( !*v109 )
                  {
LABEL_220:
                    v109 = (char *)v107;
                  }
                  else
                  {
LABEL_214:
                    v111 = (const char *)off_7652C;
                    if ( off_7652C )
                    {
                      v112 = &off_7652C;
                      v113 = 0;
                      while ( strcmp(v109, v111) )
                      {
                        v114 = (const char *)v112[3];
                        v112 += 3;
                        v111 = v114;
                        ++v113;
                        if ( !v114 )
                          goto LABEL_253;
                      }
                      sprintf(v164, "|%s|", v109);
                      if ( v94 )
                      {
                        if ( strstr(haystack, v164) )
                          goto LABEL_220;
                        v139 = strlen(haystack);
                        *(_WORD *)stpcpy(&haystack[v139], v109) = 124;
                        sub_3085C(v150, v109, v102, &v157);
                        v140 = &dword_760FC[3 * v113];
                        if ( !*((_BYTE *)v140 + 1081) )
                        {
                          sub_3305C(v150, 45, *((unsigned __int8 *)v140 + 1081), v140[268], v102);
                          sub_31F64((int)v150, v102);
                          goto LABEL_220;
                        }
                      }
                      v126 = v156;
                      v127 = (*v146)[v156];
                      if ( v127 == (*v146)[87]
                        || (v144 = v156,
                            v128 = strstr(*((const char **)&unk_7BD24 + v127 - (*v146)[65]), v164),
                            v126 = v144,
                            v128) )
                      {
                        ((void (__fastcall *)(_DWORD *, int, char *, int, int))dword_760FC[3 * v113 + 269])(
                          v150,
                          fd,
                          v155,
                          v102,
                          v126);
                      }
                      else
                      {
                        sub_3305C(v150, 45, 0, dword_760FC[3 * v113 + 268], v102);
                        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                        {
                          snprintf(
                            needle,
                            0x1000u,
                            "API: access denied to '%s' for '%s' command",
                            v158,
                            (const char *)dword_760FC[3 * v113 + 268]);
                          sub_38730(7, needle, 0);
                        }
                      }
                      v125 = (int)v150;
                      if ( v94 )
                      {
LABEL_260:
                        sub_31F64(v125, v102);
                        goto LABEL_220;
                      }
                    }
                    else
                    {
LABEL_253:
                      if ( v94 )
                      {
                        sub_3085C(v150, v109, v102, &v157);
                        sub_3305C(v150, 14, 0, 0, v102);
                        v125 = (int)v150;
                        goto LABEL_260;
                      }
                      sub_3305C(v150, 14, 0, 0, v102);
                      v125 = (int)v150;
                    }
                    sub_30B88(v125, fd, v102);
                  }
                  if ( v109 )
                    v115 = v94 & 1;
                  else
                    v115 = 0;
                  if ( !v115 )
                  {
                    v116 = v102;
                    goto LABEL_226;
                  }
                  continue;
                }
              }
              v135 = sub_592C4(v169, v100, 0, v166);
              v95 = v135;
              if ( v135 && !*v135 )
              {
                v138 = (_DWORD *)sub_59E20(v135, "command");
                if ( v138 )
                {
                  if ( *v138 == 2 )
                  {
                    v107 = (const char *)sub_5A178(v138);
                    v141 = (char *)sub_59E20(v95, "parameter");
                    v106 = v141;
                    if ( v141 )
                    {
                      v142 = *(_DWORD *)v141;
                      if ( *(_DWORD *)v141 == 2 )
                      {
                        v102 = 1;
                        v106 = (char *)sub_5A178(v141);
                        goto LABEL_205;
                      }
                      if ( v142 == 3 )
                      {
                        v143 = sub_5A248((int)v141);
                        v102 = 1;
                        v106 = v170;
                        sprintf(v170, "%d", v143);
                        goto LABEL_205;
                      }
                      if ( v142 == 4 )
                      {
                        sub_5A2F8();
                        v102 = 1;
                        v106 = v170;
                        sprintf(v170, "%f", v1);
                        goto LABEL_205;
                      }
                      v106 = 0;
                    }
                    v102 = 1;
                    goto LABEL_205;
                  }
                  sub_3305C(v150, 14, 0, 0, 1u);
                }
                else
                {
                  sub_3305C(v150, 24, 0, 0, 1u);
                }
              }
              else
              {
                sub_3305C(v150, 23, 0, 0, 1u);
              }
              sub_30B88((int)v150, fd, 1);
              v116 = (int)v95;
              v102 = 1;
              if ( v95 )
                v116 = 1;
LABEL_226:
              if ( v94 )
                sub_30B88((int)v150, fd, v102);
              if ( v116 )
              {
                if ( !*v95 )
                {
                  v117 = v95[1];
                  if ( v117 != -1 )
                  {
                    v118 = v117 - 1;
                    v95[1] = v118;
                    if ( !v118 )
                      sub_5A3E4((void **)v95);
                  }
                }
              }
            }
          }
          close(fd);
          if ( byte_78CAC )
            goto LABEL_265;
        }
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          v129 = _errno_location();
          v130 = strerror(*v129);
          snprintf(needle, 0x1000u, "API failed (%s)%s (%d)", v130, " - API will not be available", *ptr);
          sub_38730(3, needle, 0);
        }
      }
LABEL_265:
      _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
      sub_3243C(ptr);
      free(ptr);
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        if ( byte_78CAE )
        {
          v131 = "QUIT";
        }
        else if ( byte_78CAD )
        {
          v131 = "RESTART";
        }
        else if ( byte_78CAC )
        {
          v131 = "BYE";
        }
        else
        {
          v131 = "UNKNOWN!";
        }
        snprintf(needle, 0x1000u, "API: terminating due to: %s", v131);
        sub_38730(7, needle, 0);
      }
      if ( pthread_mutex_lock(&stru_78CB8) )
        sub_B774("api", 5619);
      if ( byte_78CAD )
      {
        if ( sub_2F174((int)&env, 0, (void *(*)(void *))sub_32248, &env) )
        {
          sub_3220C(&stru_78CB8, "api", 5625);
          strcpy(needle, "API failed to initiate a restart - aborting");
          sub_38730(3, needle, 1);
          sub_16CA8(1);
        }
      }
      else
      {
        if ( !byte_78CAE )
        {
LABEL_280:
          if ( pthread_mutex_unlock(&stru_78CB8) )
            sub_B84C("api", 5640);
          off_75ED8();
          return;
        }
        if ( sub_2F174(
               (int)&env,
               (const pthread_attr_t *)(unsigned __int8)byte_78CAD,
               (void *(*)(void *))sub_32340,
               &env) )
        {
          sub_3220C(&stru_78CB8, "api", 5634);
          strcpy(needle, "API failed to initiate a clean quit - aborting");
          sub_38730(3, needle, 1);
          sub_16CA8(1);
        }
      }
      pthread_detach(env.__jmpbuf[3]);
      goto LABEL_280;
    }
    v119 = _errno_location();
    v120 = strerror(*v119);
    if ( time(0) - v93 <= 61 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(v170, 0x1000u, "API bind to port %d failed - trying again in 30sec", v152);
        sub_38730(4, v170, 0);
      }
      sub_2A92C();
      continue;
    }
    break;
  }
  freeaddrinfo(v160);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(v170, 0x1000u, "API bind to port %d failed (%s)%s", v152, v120, " - API will not be available");
    goto LABEL_119;
  }
LABEL_7:
  free(ptr);
}
// 386EC: variable 'v1' is possibly undefined
// AC94: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 32340: using guessed type void __noreturn sub_32340();
// 75DCC: using guessed type int dword_75DCC;
// 75ECC: using guessed type char *off_75ECC;
// 75ED0: using guessed type int dword_75ED0;
// 75ED8: using guessed type int (*off_75ED8)();
// 760FC: using guessed type int dword_760FC[];
// 7652C: using guessed type _UNKNOWN *off_7652C;
// 766C4: using guessed type int dword_766C4;
// 78C98: using guessed type int dword_78C98;
// 78CAC: using guessed type char byte_78CAC;
// 78CAD: using guessed type char byte_78CAD;
// 78CAE: using guessed type char byte_78CAE;
// 78CB0: using guessed type int dword_78CB0;
// 78CB4: using guessed type int dword_78CB4;
// 78CD0: using guessed type int dword_78CD0;
// 78CD4: using guessed type int dword_78CD4;
// 78CD8: using guessed type int dword_78CD8;
// 78CDC: using guessed type int dword_78CDC;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7B624: using guessed type char byte_7B624;
// 7B7C4: using guessed type char byte_7B7C4;
// 7B7D1: using guessed type char byte_7B7D1;
// 7B944: using guessed type int dword_7B944;

//----- (00038730) --------------------------------------------------------
void __fastcall sub_38730(int a1, const char *a2, int a3)
{
  struct tm *v6; // r0
  int v7; // r0
  FILE *v8; // r8
  size_t v9; // r0
  size_t v10; // r0
  time_t tv_sec; // [sp+1Ch] [bp-4Ch] BYREF
  struct timeval v12; // [sp+20h] [bp-48h] BYREF
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_7AD48 )
  {
    syslog(a1 | 0x80, "%s", a2);
    return;
  }
  v12.tv_sec = 0;
  v12.tv_usec = 0;
  sub_2A84C(&v12);
  tv_sec = v12.tv_sec;
  v6 = localtime(&tv_sec);
  snprintf(
    s,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d] ",
    v6->tm_year + 1900,
    v6->tm_mon + 1,
    v6->tm_mday,
    v6->tm_hour,
    v6->tm_min,
    v6->tm_sec);
  v7 = fileno((FILE *)stderr);
  if ( isatty(v7) )
  {
    if ( byte_78CE0 )
    {
LABEL_4:
      v8 = (FILE *)dword_78CE4;
      if ( dword_78CE4 || (v8 = fopen(dword_78CE8, word_78DE8), (dword_78CE4 = (int)v8) != 0) )
      {
        v9 = strlen(s);
        fwrite(s, v9, 1u, v8);
        v10 = strlen(a2);
        fwrite(a2, v10, 1u, (FILE *)dword_78CE4);
        fwrite(ptr, 1u, 1u, (FILE *)dword_78CE4);
        fflush((FILE *)dword_78CE4);
      }
    }
  }
  else
  {
    fprintf((FILE *)stderr, "%s%s\n", s, a2);
    fflush((FILE *)stderr);
    if ( byte_78CE0 )
      goto LABEL_4;
  }
  sub_389F4(a1, s, a2, a3);
}
// 76BD0: using guessed type int stderr;
// 78CE0: using guessed type char byte_78CE0;
// 78CE4: using guessed type int dword_78CE4;
// 7AD48: using guessed type char byte_7AD48;

//----- (000388E4) --------------------------------------------------------
int sub_388E4()
{
  int result; // r0
  int *v1; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_mutex_lock(&mutex);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 47);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}
// 16CA8: using guessed type void __fastcall __noreturn sub_16CA8(_DWORD);
// 38730: using guessed type int __fastcall sub_38730(_DWORD, _DWORD, _DWORD);

//----- (0003896C) --------------------------------------------------------
int __fastcall sub_3896C(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  result = pthread_mutex_unlock(&mutex);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}
// 16CA8: using guessed type void __fastcall __noreturn sub_16CA8(_DWORD);
// 38730: using guessed type int __fastcall sub_38730(_DWORD, _DWORD, _DWORD);

//----- (000389F4) --------------------------------------------------------
int __fastcall sub_389F4(int result, const char *a2, const char *a3, int a4)
{
  int v4; // r6

  v4 = result;
  if ( !byte_7BC78 || result == 3 )
  {
    if ( a4 )
    {
      pthread_mutex_trylock(&mutex);
      sub_3896C(38);
      off_75ED8();
      if ( byte_75DD0 )
      {
LABEL_5:
        result = sub_199E8(v4, a2, a3);
        if ( result )
          return result;
      }
    }
    else if ( byte_75DD0 )
    {
      goto LABEL_5;
    }
    sub_388E4();
    printf("%s%s%s", a2, a3, "                    \n");
    sub_3896C(49);
    return off_75ED8();
  }
  return result;
}
// 75DD0: using guessed type char byte_75DD0;
// 75ED8: using guessed type int (*off_75ED8)();
// 7BC78: using guessed type char byte_7BC78;

//----- (00038AC4) --------------------------------------------------------
void __fastcall sub_38AC4(int a1, const char *a2, int a3)
{
  int v6; // r0

  if ( byte_7AD48 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    sub_389F4(a1, "", a2, a3);
  }
}
// 76BD0: using guessed type int stderr;
// 7AD48: using guessed type char byte_7AD48;

//----- (00038B58) --------------------------------------------------------
const char *__fastcall sub_38B58(const char **a1, const char *a2, const char *a3, int a4)
{
  const char *result; // r0
  int v6; // r3
  const char *v7; // r2
  size_t v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  const char **v12; // r0
  const char **v13; // r5
  size_t v14; // lr
  const char *v15; // r1
  const char *v16; // r0
  const char **v17; // r3
  int v18; // r2
  const char *v19; // r1
  const char **v20; // r3
  int v21; // r2
  char *v22; // r0
  int v23; // r1
  const char *v24; // r0
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = (const char *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (size_t)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (size_t)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v12 = (const char **)calloc(v8, 0x10u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v14 = v8 - 1;
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] - 1)] = v12;
  v15 = *a1;
  v16 = a1[6];
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v16[v8];
  *v13 = v15;
  v13[1] = 0;
  v13[2] = (const char *)(v13 + 4);
  if ( (int)(v8 - 1) > 1 )
  {
    v17 = v13;
    v18 = 1;
    do
    {
      v19 = *a1;
      ++v18;
      v17[5] = (const char *)v17;
      v17[6] = (const char *)(v17 + 8);
      v17[4] = v19;
      v17 += 4;
    }
    while ( v18 != v14 );
  }
  v20 = &v13[4 * v14];
  *v20 = *a1;
  v20[1] = (const char *)&v13[4 * v8 - 8];
  v20[2] = 0;
  v21 = *((unsigned __int8 *)a1 + 44);
  a1[3] = (const char *)v13;
  if ( v21 )
    a1[4] = (const char *)v20;
  do
  {
    v22 = (char *)a1[15];
    v23 = (int)(a1[14] + 1);
    a1[14] = (const char *)v23;
    v24 = (const char *)realloc(v22, 4 * v23);
    a1[15] = v24;
    if ( !v24 )
    {
      snprintf(
        s,
        0x1000u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    result = (const char *)calloc(1u, (size_t)a1[5]);
    v13[3] = result;
    if ( !result )
    {
      snprintf(s, 0x1000u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_38730(3, s, 1);
      sub_16CA8(1);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] - 1)] = result;
    v13 = (const char **)v13[2];
  }
  while ( v13 );
  return result;
}

//----- (00038E94) --------------------------------------------------------
_BYTE *__fastcall sub_38E94(int a1)
{
  _BYTE *result; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = calloc(1u, 0x40u);
  if ( !result )
  {
    snprintf(
      s,
      0x1000u,
      "Failed to calloc store for %s in %s %s():%d",
      *(const char **)a1,
      "klist.c",
      "k_new_store",
      85);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  result[4] = 1;
  *((_DWORD *)result + 2) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)result = *(_DWORD *)a1;
  result[44] = *(_BYTE *)(a1 + 44);
  return result;
}

//----- (00038F3C) --------------------------------------------------------
_BYTE *__fastcall sub_38F3C(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r4
  pthread_mutex_t *v13; // r0
  pthread_mutex_t *v14; // r10
  int *v16; // r0
  int *v17; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x1000u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      0x1000u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v12 = calloc(1u, 0x40u);
  if ( !v12 )
  {
    snprintf(s, 0x1000u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v12[4] = 0;
  v13 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v14 = v13;
  *((_DWORD *)v12 + 2) = v13;
  if ( !v13 )
  {
    snprintf(s, 0x1000u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( pthread_mutex_init(v13, 0) )
  {
    v17 = _errno_location();
    snprintf(s, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v14[1], 0) )
  {
    v16 = _errno_location();
    snprintf(s, 0x1000u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v16, "klist.c", "_k_new_list", 115);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  *(_DWORD *)v12 = a1;
  *((_DWORD *)v12 + 5) = a2;
  *((_DWORD *)v12 + 9) = a3;
  *((_DWORD *)v12 + 10) = a4;
  v12[44] = a5;
  sub_38B58((const char **)v12, a6, a7, a8);
  return v12;
}

//----- (000391FC) --------------------------------------------------------
int __fastcall sub_391FC(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r4
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return v5;
    sub_38B58((const char **)a1, a2, a3, a4);
    if ( !*(_DWORD *)(a1 + 12) )
      return v5;
    v5 = *(_DWORD *)(a1 + 12);
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (0003927C) --------------------------------------------------------
int __fastcall sub_3927C(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_391FC(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (000392A8) --------------------------------------------------------
int __fastcall sub_392A8(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}

//----- (00039370) --------------------------------------------------------
const char *__fastcall sub_39370(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r3
  int v10; // r3
  int v11; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = *(const char **)a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_head",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v9 = *(_DWORD *)(a1 + 12);
  if ( v9 )
    *(_DWORD *)(v9 + 4) = a2;
  v10 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v10 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v11 = *(_DWORD *)(a1 + 32);
  ++*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 32) = v11 + 1;
  return result;
}

//----- (00039460) --------------------------------------------------------
const char *__fastcall sub_39460(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  const char *v9; // r3
  const char *v10; // r3
  bool v11; // zf
  const char *v12; // r3
  int v13; // r2
  const char *v14; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_tail",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v9 = a1[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v9;
  v10 = a1[4];
  if ( v10 )
    *((_DWORD *)v10 + 2) = a2;
  v11 = a1[3] == 0;
  v12 = a1[8];
  v13 = (int)(a1[7] + 1);
  a1[4] = (const char *)a2;
  v14 = v12 + 1;
  if ( v11 )
    a1[3] = (const char *)a2;
  a1[7] = (const char *)v13;
  a1[8] = v14;
  return result;
}

//----- (000395B8) --------------------------------------------------------
const char **__fastcall sub_395B8(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  const char *v9; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x1000u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 )
    *(_DWORD *)(v8 + 8) = a2;
  else
    result[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v9 = result[8];
  ++result[7];
  result[8] = v9 + 1;
  return result;
}

//----- (00039714) --------------------------------------------------------
const char **__fastcall sub_39714(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  const char *v9; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x1000u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a2;
  }
  else if ( *((_BYTE *)result + 44) )
  {
    result[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v9 = result[8];
  ++result[7];
  result[8] = v9 + 1;
  return result;
}

//----- (00039880) --------------------------------------------------------
const char *__fastcall sub_39880(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r3
  int v10; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = *(const char **)a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_unlink_item",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v9 = *(_DWORD *)(a2 + 4);
  if ( v9 )
    *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(a2 + 8);
  if ( v10 )
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (00039984) --------------------------------------------------------
const char *__fastcall sub_39984(const char **a1, int *a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *result; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r2
  const char *v12; // r2
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *a1;
  result = (const char *)*a2;
  if ( v7 != (const char *)*a2 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v7,
      "_k_list_transfer_to_head",
      (const char *)*a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v9 = *((unsigned __int8 *)a1 + 44);
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( a1[3] )
  {
    v10 = a2[3];
    v11 = a1[4];
    if ( v10 )
    {
      *(_DWORD *)(v10 + 4) = v11;
    }
    else
    {
      v9 = 0;
      a2[4] = (int)v11;
    }
    if ( v10 )
      v9 = a2[3];
    *((_DWORD *)a1[4] + 2) = v9;
    a2[3] = (int)a1[3];
    a1[4] = 0;
    v12 = a1[7];
    a1[3] = 0;
    a2[7] += (int)v12;
    a1[7] = 0;
    a2[8] += (int)a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00039B04) --------------------------------------------------------
const char *__fastcall sub_39B04(const char **a1, int *a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *result; // r0
  const char *v9; // r3
  int v10; // r2
  const char *v11; // r2
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *a1;
  result = (const char *)*a2;
  if ( v7 != (const char *)*a2 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v7,
      "_k_list_transfer_to_tail",
      (const char *)*a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = a2[4];
    if ( v10 )
      *(_DWORD *)(v10 + 8) = v9;
    else
      a2[3] = (int)v9;
    if ( v10 )
      v10 = a2[4];
    *((_DWORD *)a1[3] + 1) = v10;
    a2[4] = (int)a1[4];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    a2[7] += (int)v11;
    a1[7] = 0;
    a2[8] += (int)a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00039C7C) --------------------------------------------------------
int __fastcall sub_39C7C(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (00039D98) --------------------------------------------------------
int __fastcall sub_39D98(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x1000u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  free(ptr);
  return 0;
}

//----- (00039EF4) --------------------------------------------------------
int __fastcall sub_39EF4(__int64 a1, _QWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    *(_QWORD *)HIDWORD(a1) = *(_QWORD *)(v2 + 16);
    a1 = *(_QWORD *)(v2 + 24);
    *a2 = a1;
  }
  else
  {
    *(_QWORD *)HIDWORD(a1) = 0;
    *a2 = 0;
  }
  return a1;
}

//----- (0003A354) --------------------------------------------------------
void sub_3A354()
{
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s %d", "reset_all_hash_board_low", 4386);
    sub_38730(5, s, 0);
  }
  *(_DWORD *)(dword_78E10 + 52) = 0xFFFF;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003A3F4) --------------------------------------------------------
void sub_3A3F4()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v0, "Updated Work!");
    sub_38730(7, v0, 0);
  }
  byte_78E14 = 1;
  byte_78E15 = 1;
  byte_78E16 = 1;
  byte_78E17 = 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E14: using guessed type char byte_78E14;
// 78E15: using guessed type char byte_78E15;
// 78E16: using guessed type char byte_78E16;
// 78E17: using guessed type char byte_78E17;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003A4EC) --------------------------------------------------------
_DWORD *sub_3A4EC()
{
  _DWORD *v0; // r0
  int v1; // r5
  _DWORD *v2; // r8
  const char *v3; // r2
  _DWORD *v4; // r0
  int v5; // r5
  _DWORD *v6; // r6
  const char *v7; // r2
  int i; // r5
  const char *v9; // r2
  _DWORD *v10; // r0
  _DWORD *v11; // r5
  __int64 v12; // r0
  __int64 v13; // r0
  int32x2_t v14; // d8
  double v15; // r0
  double v16; // d16
  int v17; // r6
  _DWORD *v18; // r0
  _DWORD *v19; // r5
  const char *v20; // r2
  int j; // r6
  char *v22; // r2
  int k; // r6
  _DWORD *v24; // r0
  int v25; // r8
  int v26; // r2
  int v27; // r4
  int v28; // r6
  int v29; // r7
  _DWORD *result; // r0
  const char *v31; // [sp+4h] [bp-28h]
  _DWORD s[4]; // [sp+8h] [bp-24h] BYREF
  _DWORD v33[5]; // [sp+18h] [bp-14h] BYREF

  v0 = sub_32E64(0, "miner_count", &byte_9D6CB, 0);
  v1 = 0;
  v2 = sub_32E64(v0, "fan_num", &byte_9D6CC, 0);
  do
  {
    sprintf((char *)v33, "fan%d", v1 + 1);
    v3 = (char *)&unk_9D4B4 + 4 * v1++ + 489;
    v4 = sub_32F18(v2, (const char *)v33, v3, 0);
    v2 = v4;
  }
  while ( v1 != 6 );
  v5 = 0;
  v6 = sub_32E64(v4, "temp_num", &byte_9D6CB, 0);
  do
  {
    sprintf((char *)v33, "temp%d", v5 + 1);
    v7 = (char *)&unk_9D4B4 + 4 * v5++ + 653;
    v6 = sub_32E88(v6, (const char *)v33, v7, 0);
  }
  while ( v5 != 4 );
  for ( i = 0; i != 4; ++i )
  {
    sprintf((char *)v33, "temp2_%d", i + 1);
    v9 = (char *)&unk_9D4B4 + 4 * i + 669;
    v10 = sub_32E88(v6, (const char *)v33, v9, 0);
    v6 = v10;
  }
  v11 = sub_32F18(v10, "temp_max", (const char *)&dword_9D6D6, 0);
  LODWORD(v12) = sub_5CC10(dbl_7B5E8 + dbl_7B670 + dbl_7B428);
  *(_QWORD *)&dword_7B100 = v12;
  v13 = v12 + dword_7B8A4;
  if ( v13 )
  {
    v14.n64_u32[0] = dword_7B8A4;
    v14.n64_u32[1] = dword_7B8A4;
    LODWORD(v15) = sub_5CB64(v13);
    v16 = vcvt_n_f64_s32(v14, 8u) / v15;
  }
  else
  {
    v16 = 0.0;
  }
  v17 = 0;
  *(double *)&dword_78E20 = v16;
  v18 = sub_357A4(v11, "Device Hardware%", (const char *)&dword_78E20, 1);
  v19 = sub_32ED0(v18, "no_matching_work", (const char *)&dword_7B8A4, 1);
  do
  {
    sprintf((char *)v33, "chain_acn%d", v17 + 1);
    v20 = (char *)&unk_9D4B4 + v17++ + 529;
    v19 = sub_32E64(v19, (const char *)v33, v20, 0);
  }
  while ( v17 != 4 );
  for ( j = 0; j != 4; ++j )
  {
    sprintf((char *)v33, "chain_acs%d", j + 1);
    v22 = (char *)&unk_9D4B4 + 19 * j;
    v19 = sub_32E1C(v19, (const char *)v33, v22 + 355, 0);
  }
  for ( k = 0; k != 4; ++k )
  {
    sprintf((char *)v33, "chain_hw%d", k + 1);
    v24 = sub_32F18(v19, (const char *)v33, (const char *)&unk_9D4B4 + 4 * k + 243, 0);
    v19 = v24;
  }
  v25 = 0;
  do
  {
    memset(s, 0, sizeof(s));
    memset(v33, 0, 16);
    sprintf((char *)s, "frequency%d", v25 + 1);
    v26 = v25 + 296;
    ++v25;
    v31 = (char *)&unk_9D4B4 + 2 * v26 + 1;
    sprintf((char *)v33, "%u", *(unsigned __int16 *)v31);
    v19 = sub_32EAC(v19, (const char *)s, v31, 0);
  }
  while ( v25 != 4 );
  v27 = 0;
  do
  {
    v28 = v27 + 1;
    v29 = 16 * v27;
    sprintf((char *)v33, "chain_rate%d", v27 + 1);
    if ( byte_78E28 )
      sprintf(&byte_7C0A8[v29], "%2.2f", dbl_78E30 / (double)dword_78E38);
    result = sub_32E1C(v19, (const char *)v33, &byte_7C0A8[v29], 0);
    ++v27;
    v19 = result;
  }
  while ( v28 != 4 );
  return result;
}
// 3A658: variable 'v12' is possibly undefined
// 3A67C: variable 'v15' is possibly undefined
// 78E20: using guessed type int dword_78E20;
// 78E28: using guessed type char byte_78E28;
// 78E30: using guessed type double dbl_78E30;
// 78E38: using guessed type int dword_78E38;
// 7B100: using guessed type int dword_7B100;
// 7B428: using guessed type double dbl_7B428;
// 7B5E8: using guessed type double dbl_7B5E8;
// 7B670: using guessed type double dbl_7B670;
// 7B8A4: using guessed type int dword_7B8A4;
// 9D6CB: using guessed type char byte_9D6CB;
// 9D6CC: using guessed type char byte_9D6CC;
// 9D6D6: using guessed type int dword_9D6D6;

//----- (0003A920) --------------------------------------------------------
int sub_3A920()
{
  int result; // r0

  if ( !byte_78E3C )
    return system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
  return result;
}
// 78E3C: using guessed type char byte_78E3C;

//----- (0003A940) --------------------------------------------------------
void sub_3A940()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  v0 = calloc(1u, 0x188u);
  v1 = v0;
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-zcash.c", 0x1D38u, "bitmain_ZCASH_detect");
  v0[37] = 1;
  v0[1] = &unk_76AC8;
  v0[8] = 0;
  v2 = calloc(0x4B4u, 1u);
  v1[5] = v2;
  if ( !v2 )
  {
    strcpy(v3, "Failed to calloc cgpu_info data");
    sub_38730(3, v3, 1);
    sub_16CA8(1);
  }
  if ( !sub_28008(v1) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-zcash.c", 0x1D40u, "bitmain_ZCASH_detect");
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v3, 0x1000u, "%s detect new device", "bitmain_ZCASH_detect");
    sub_38730(7, v3, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003AA9C) --------------------------------------------------------
void __noreturn sub_3AA9C()
{
  int v0; // r5
  int v1; // r8
  int v2; // r1
  unsigned int v3; // r3
  int v4; // r1
  unsigned int v5; // [sp+4h] [bp-8h]

  while ( 1 )
  {
    v0 = 2;
    dword_9D6CE = 0;
    dword_9D6D2 = 0;
    do
    {
      v1 = 6;
      do
      {
        while ( 1 )
        {
          v5 = *(_DWORD *)(dword_78E10[0] + 4);
          if ( v5 == -1 )
            goto LABEL_9;
          v2 = (v5 >> 8) & 7;
          v3 = 120 * (unsigned __int8)v5;
          *(_DWORD *)((char *)&unk_9D4B4 + 4 * v2 + 489) = v3;
          if ( (_BYTE)v5 )
          {
            if ( !*((_BYTE *)&unk_9D4B4 + v2 + 459) )
            {
              *((_BYTE *)&unk_9D4B4 + v2 + 459) = 1;
              ++byte_9D6CC;
              dword_9D4C8 |= 1 << v2;
            }
          }
          else if ( *((_BYTE *)&unk_9D4B4 + v2 + 459) == 1 )
          {
            *((_BYTE *)&unk_9D4B4 + v2 + 459) = 0;
            if ( 1 << v2 )
              v4 = 0;
            else
              v4 = dword_9D4C8 & 1;
            dword_9D4C8 = v4;
            --byte_9D6CC;
          }
          if ( v3 > dword_9D6CE )
            dword_9D6CE = 120 * (unsigned __int8)v5;
          if ( (v3 >= dword_9D6D2 || !v3) && dword_9D6D2 )
            break;
          dword_9D6D2 = 120 * (unsigned __int8)v5;
LABEL_9:
          sub_2A92C();
          if ( !--v1 )
            goto LABEL_16;
        }
        sub_2A92C();
        --v1;
      }
      while ( v1 );
LABEL_16:
      --v0;
    }
    while ( v0 );
    sleep(1u);
  }
}
// 78E10: using guessed type int dword_78E10[];
// 9D4C8: using guessed type int dword_9D4C8;
// 9D6CC: using guessed type char byte_9D6CC;
// 9D6CE: using guessed type int dword_9D6CE;
// 9D6D2: using guessed type int dword_9D6D2;

//----- (0003ABF4) --------------------------------------------------------
void __noreturn sub_3ABF4()
{
  double *v0; // r5
  int v1; // r6
  int v2; // r3
  int v3; // r9
  int v4; // r2
  int v5; // r3
  _QWORD *v6; // r7
  int v7; // s28
  int v8; // s29
  int v9; // r4
  double v10; // d8
  int v12; // r10
  double v13; // r0
  double *v14; // r8
  int v15; // r3
  double v16; // d16
  double v17; // d17
  int v18; // r10
  double v19; // d9
  struct timeval v20; // [sp+8h] [bp-10h] BYREF
  struct timeval v21; // [sp+10h] [bp-8h] BYREF
  _DWORD v22[4]; // [sp+18h] [bp+0h] BYREF
  _DWORD s[81]; // [sp+28h] [bp+10h] BYREF

  memset(s, 0, 0x140u);
  memset(v22, 0, sizeof(v22));
  sub_2A84C(&v20);
  sub_2A84C(&v21);
  while ( 1 )
  {
    v0 = (double *)&unk_78E40;
    sub_2A84C(&v21);
    v1 = 0;
    v2 = v21.tv_usec - v20.tv_usec + (v21.tv_usec - v20.tv_usec < 0 ? 0xF4000 : 0);
    v3 = 644283;
    v4 = v21.tv_sec - v20.tv_sec;
    if ( v21.tv_usec - v20.tv_usec < 0 )
      v2 += 576;
    v5 = v2 + 1;
    v6 = &unk_78E60;
    v7 = v21.tv_sec - v20.tv_sec;
    if ( v21.tv_usec - v20.tv_usec < 0 )
      --v4;
    v8 = v5;
    v9 = 0;
    if ( v21.tv_usec - v20.tv_usec < 0 )
      v7 = v4;
    v10 = 0.0;
    do
    {
      if ( *(unsigned __int8 *)++v3 )
      {
        v12 = v22[v1];
        LODWORD(v13) = sub_5CB50(0xFFFFLL * *v6);
        *v6 = 0;
        v14 = (double *)&s[20 * v9];
        v15 = 10;
        *v0 = 0.0;
        v16 = 0.0;
        *(double *)&s[20 * v9 + 2 * v12] = v13 / ((double)v7 + (double)v8 / 1000000.0);
        do
        {
          --v15;
          v17 = *v14++;
          v16 = v16 + v17;
        }
        while ( v15 );
        *v0 = v16;
        v18 = v12 + 1;
        sprintf(&byte_7C0A8[16 * v9], "%.2f", v16 / 1000.0 / 10.0);
        v19 = *v0 / 10.0;
        if ( v18 > 9 )
          v18 = 0;
        v22[v1] = v18;
        v10 = v10 + v19;
      }
      ++v9;
      ++v1;
      ++v0;
      ++v6;
    }
    while ( v9 != 4 );
    sprintf(byte_78B84, "%.2f", v10);
    dbl_78E80 = v10;
    sub_2A530(&v20, &v21);
    sleep(5u);
  }
}
// 3AD0C: variable 'v13' is possibly undefined
// 78E80: using guessed type double dbl_78E80;

//----- (0003ADE0) --------------------------------------------------------
void sub_3ADE0()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  snprintf(v0, 0x1000u, "%s: i2c always busy, break\n", "i2c_write");
  sub_38730(5, v0, 0);
}

//----- (0003AE24) --------------------------------------------------------
int sub_3AE24()
{
  char v1[4100]; // [sp+0h] [bp-1004h] BYREF

  snprintf(v1, 0x1000u, "%s: i2c always busy, break\n", "i2c_read");
  sub_38730(5, v1, 0);
  return 255;
}

//----- (0003AE6C) --------------------------------------------------------
int sub_3AE6C()
{
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  snprintf(s, 0x1000u, "%s input param error: str length = %u\n", "bm1740_makeup_set_config_cmd", 13);
  sub_38730(3, s, 0);
  return -1;
}

//----- (0003AEBC) --------------------------------------------------------
int sub_3AEBC()
{
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  snprintf(s, 0x1000u, "%s input param error: str length = %u\n", "bm1740_makeup_get_status_cmd", 9);
  sub_38730(3, s, 0);
  return -1;
}

//----- (0003AF0C) --------------------------------------------------------
int __fastcall sub_3AF0C(pthread_rwlock_t *a1)
{
  int result; // r0
  int *v2; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v2 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v2,
      "driver-btm-zcash.c",
      "bitmain_ZCASH_prepare",
      7499);
    sub_38730(3, s, 1);
    sub_16CA8(1);
  }
  return result;
}

//----- (0003AF90) --------------------------------------------------------
int __fastcall sub_3AF90(int a1)
{
  int v1; // r6
  char *v2; // r4
  unsigned __int8 *v3; // lr
  unsigned __int8 *v4; // r8
  unsigned int v5; // r7
  int v6; // r9
  int v7; // r3
  char *v8; // r3
  int *v9; // r3
  int v10; // t1
  char *v11; // r3
  _DWORD *v12; // r2
  unsigned int v13; // r0
  unsigned int v14; // t1
  unsigned int v15; // t1
  bool v16; // cc
  int v17; // r0
  __int64 *v19; // r12
  int v20; // lr
  __int64 v21; // r2
  unsigned int v22; // r0
  int v23; // r8
  char *v24; // r10
  char *v25; // r9
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  int *v29; // r0
  pthread_mutex_t *mutex; // [sp+18h] [bp-1724h]
  unsigned int v31; // [sp+1Ch] [bp-1720h]
  int v32; // [sp+20h] [bp-171Ch]
  _DWORD *v33; // [sp+34h] [bp-1708h]
  char v35[4]; // [sp+40h] [bp-16FCh] BYREF
  int v36; // [sp+44h] [bp-16F8h]
  struct timeval v37; // [sp+48h] [bp-16F4h] BYREF
  _DWORD v38[8]; // [sp+50h] [bp-16ECh] BYREF
  _BYTE v39[32]; // [sp+70h] [bp-16CCh] BYREF
  char v40[360]; // [sp+90h] [bp-16ACh] BYREF
  _BYTE s[1344]; // [sp+1F8h] [bp-1544h] BYREF
  char v42[4100]; // [sp+738h] [bp-1004h] BYREF

  v33 = *(_DWORD **)(a1 + 36);
  mutex = (pthread_mutex_t *)v33[5];
  memset(s, 0, sizeof(s));
  sub_2A84C(&v37);
  dbl_78E18 = 0.0;
  pthread_mutex_lock(&stru_78E88);
  v1 = dword_7C294;
  pthread_mutex_unlock(&stru_78E88);
  if ( pthread_mutex_lock(mutex) )
  {
    v26 = _errno_location();
    snprintf(
      v42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v26,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6302);
    sub_38730(3, v42, 1);
    sub_16CA8(1);
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)&mutex[1]) )
  {
    v29 = _errno_location();
    snprintf(
      v42,
      0x1000u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v29,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6302);
    sub_38730(3, v42, 1);
    sub_16CA8(1);
  }
  if ( pthread_mutex_unlock(mutex) )
  {
    v27 = _errno_location();
    snprintf(
      v42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v27,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6302);
    sub_38730(3, v42, 1);
    sub_16CA8(1);
  }
  if ( v1 )
  {
    v2 = 0;
    while ( 1 )
    {
      --v1;
      pthread_mutex_lock(&stru_78E88);
      v3 = (unsigned __int8 *)&dword_7C28C + 1357 * dword_7C290;
      --dword_7C294;
      v4 = v3 + 1360;
      v5 = v3[1368];
      v6 = v3[1357];
      v32 = v3[1358];
      v31 = v3[1356];
      memcpy(s, v3 + 12, sizeof(s));
      if ( (unsigned int)dword_7C290 > 0x62 )
        v7 = 0;
      else
        v7 = dword_7C290 + 1;
      v36 = *((_DWORD *)v4 + 1);
      dword_7C290 = v7;
      pthread_mutex_unlock(&stru_78E88);
      if ( v5 > 4 )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          snprintf(v42, 0x1000u, "Error:scanhash chainid=%u\n", v5);
          sub_38730(5, v42, 0);
        }
        goto LABEL_24;
      }
      pthread_mutex_lock(&stru_78EA0);
      v8 = &mutex[4].__size[4 * v6 + 16];
      v10 = *(_DWORD *)(v8 + 6);
      v9 = (int *)(v8 + 6);
      if ( v10 )
        v2 = (char *)sub_1A44C(*v9, 0);
      pthread_mutex_unlock(&stru_78EA0);
      if ( !v2 )
        break;
      *((_DWORD *)v2 + 90) = v36;
      memcpy(v2 + 367, s, 0x540u);
      sub_4EEE0(v40, 200, 9);
      sub_54F8C((int)v40, v2 + 224, 0x8Cu);
      memset(v39, 0, sizeof(v39));
      memset(v38, 0, sizeof(v38));
      memset(v42, 0, 0x5CFu);
      memcpy(v42, v2 + 224, 0x5CFu);
      sub_55930((int)v42, 1487, v38);
      sub_55930((int)v38, 32, v39);
      v11 = v40;
      v12 = v2 + 192;
      do
      {
        v14 = (unsigned __int8)*--v11;
        v13 = v14;
        v15 = *((unsigned __int8 *)v12 - 1);
        v12 = (_DWORD *)((char *)v12 - 1);
        v16 = v13 > v15;
        if ( v13 < v15 )
          break;
        if ( v16 )
        {
          v17 = sub_4EAF4(v40, (unsigned int)s);
          if ( !v17 )
            goto LABEL_32;
LABEL_18:
          if ( v17 == 2 )
          {
            v24 = (char *)&unk_9D4B4 + 12 * v5 + 4 * (unsigned __int8)(v31 / (unsigned __int8)byte_9D6F3) + 304;
            ++*(_DWORD *)(v24 + 3);
          }
          if ( byte_77144 )
          {
            byte_77144 = 0;
            memset(&unk_9D5A7, 0, 0x10u);
          }
LABEL_22:
          sub_2F934(v2, v35, 1);
          sub_15780((void **)v2);
          v2 = 0;
          goto LABEL_23;
        }
      }
      while ( v11 != v39 );
      v17 = sub_4EAF4(v40, (unsigned int)s);
      if ( v17 )
        goto LABEL_18;
      sub_25E28(a1, (int)v2, 1);
LABEL_32:
      v19 = (__int64 *)((char *)&unk_78E60 + 8 * v5);
      v20 = *((unsigned __int8 *)&unk_9D4B4 + v5 + 8);
      v21 = *v19 + 1;
      ++*(_QWORD *)&dbl_78E18;
      *v19 = v21;
      if ( v20 )
      {
        v22 = v31 / (unsigned __int8)byte_9D6F3;
        v23 = (unsigned __int8)v22;
        if ( (unsigned __int8)v22 <= 2u )
        {
          sub_1A730(a1, (int)v2);
          v25 = (char *)&unk_9D4B4 + 12 * v5 + 4 * v23 + 256;
          ++*(_DWORD *)(v25 + 3);
          goto LABEL_22;
        }
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(v42, 0x1000u, "Which Nonce Cause Err![%d] %08x", (unsigned __int8)v22, v32);
          sub_38730(7, v42, 0);
        }
        goto LABEL_23;
      }
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf(v42, 0x1000u, "ChainID Cause Error! ChainID:[%d]", v5);
LABEL_30:
        sub_38730(3, v42, 0);
      }
LABEL_23:
      if ( !v1 )
        goto LABEL_24;
    }
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
      goto LABEL_23;
    snprintf(v42, 0x1000u, "%s %d: work %02x not find error", *(const char **)(v33[1] + 8), v33[2], v6);
    goto LABEL_30;
  }
LABEL_24:
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)&mutex[1]) )
  {
    v28 = _errno_location();
    snprintf(
      v42,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v28,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6411);
    sub_38730(3, v42, 1);
    sub_16CA8(1);
  }
  off_75ED8();
  *(_QWORD *)&dbl_78E18 = vshld_n_s64(*(__int64 *)&dbl_78E18, 0x10u) - *(_QWORD *)&dbl_78E18;
  return 0;
}
// 75ED8: using guessed type int (*off_75ED8)();
// 766C4: using guessed type int dword_766C4;
// 77144: using guessed type char byte_77144;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E18: using guessed type double dbl_78E18;
// 7AD48: using guessed type char byte_7AD48;
// 7C28C: using guessed type int dword_7C28C;
// 7C290: using guessed type int dword_7C290;
// 7C294: using guessed type int dword_7C294;
// 9D6F3: using guessed type char byte_9D6F3;

//----- (0003B704) --------------------------------------------------------
int sub_3B704()
{
  int fd; // r0
  void *v1; // r1
  int v2; // r0
  void *v3; // r1

  fd = open("/dev/axi_fpga_dev", 2);
  dword_7BD90 = fd;
  if ( fd < 0 )
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    return -1;
  }
  else
  {
    v1 = mmap(0, 0x1200u, 3, 1, fd, 0);
    dword_78E10 = (int)v1;
    if ( v1 )
    {
      printf("mmap axi_fpga_addr = 0x%x\n", v1);
      printf("axi_fpga_addr data = 0x%x\n", *(unsigned __int16 *)dword_78E10);
      v2 = open("/dev/fpga_mem", 2);
      dword_7C0E8 = v2;
      if ( v2 < 0 )
      {
        printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n", v2);
        return -1;
      }
      else
      {
        v3 = mmap(0, 0x1000000u, 3, 1, v2, 0);
        dword_78EB8 = (int)v3;
        if ( v3 )
        {
          printf("mmap fpga_mem_addr = 0x%x\n", v3);
          return 0;
        }
        else
        {
          printf("mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", 0);
          return -1;
        }
      }
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", 0);
      return -1;
    }
  }
}
// 78E10: using guessed type int dword_78E10;
// 78EB8: using guessed type int dword_78EB8;
// 7BD90: using guessed type int dword_7BD90;
// 7C0E8: using guessed type int dword_7C0E8;

//----- (0003B844) --------------------------------------------------------
int sub_3B844()
{
  printf("\n\n--- %s\n", "bitmain_axi_close");
  if ( munmap((void *)dword_78E10, 0x1200u) < 0 )
    puts("munmap failed!");
  if ( munmap((void *)dword_78EB8, 0x1000000u) < 0 )
    puts("munmap failed!");
  close(dword_7BD90);
  return close(dword_7C0E8);
}
// 78E10: using guessed type int dword_78E10;
// 78EB8: using guessed type int dword_78EB8;
// 7BD90: using guessed type int dword_7BD90;
// 7C0E8: using guessed type int dword_7C0E8;

//----- (0003B954) --------------------------------------------------------
int __fastcall sub_3B954(int a1)
{
  return *(_DWORD *)(dword_78E10 + 4 * a1);
}
// 78E10: using guessed type int dword_78E10;

//----- (0003B980) --------------------------------------------------------
int __fastcall sub_3B980(int result, int a2)
{
  *(_DWORD *)(dword_78E10 + 4 * result) = a2;
  return result;
}
// 78E10: using guessed type int dword_78E10;

//----- (0003B994) --------------------------------------------------------
void sub_3B994()
{
  char s[4088]; // [sp+8h] [bp-1000h] BYREF

  *(_DWORD *)dword_78E10[0] |= 0x60000000u;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "FPGA version: %04X", (unsigned __int16)*(_DWORD *)dword_78E10[0]);
    sub_38730(5, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10[];
// 7AD48: using guessed type char byte_7AD48;

//----- (0003BA70) --------------------------------------------------------
int sub_3BA70()
{
  printf("\n--- %s\n", "init_fpga");
  *(_DWORD *)(dword_78E10[0] + 128) = -2139062257;
  do
    sub_2A954();
  while ( *(int *)(dword_78E10[0] + 128) < 0 );
  sub_3B994();
  return sub_2A954();
}
// 78E10: using guessed type int dword_78E10[];

//----- (0003BB00) --------------------------------------------------------
int __fastcall sub_3BB00(int result)
{
  if ( result != 1 )
  {
    if ( result )
    {
      if ( result != 26 )
      {
        printf("%s: Don't support ASIC baud = %d, error!!!\n", "asic_baud_to_fpga_baud", result);
        return 53;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0003BB44) --------------------------------------------------------
int __fastcall sub_3BB44(int a1)
{
  int result; // r0

  result = sub_3BB00(a1) & 0x3F;
  *(_DWORD *)(dword_78E10 + 60) = result & 0x3F
                                | ((result & 0x3F) << 8)
                                | ((result & 0x3F) << 16) & 0xC0FFFFFF
                                | ((result & 0x3F) << 24);
  return result;
}
// 78E10: using guessed type int dword_78E10;

//----- (0003BB78) --------------------------------------------------------
int __fastcall sub_3BB78(int a1)
{
  int result; // r0

  switch ( a1 )
  {
    case 0:
      result = HIWORD(*(_DWORD *)(dword_78E10 + 496)) & 0x3FF;
      break;
    case 1:
      result = *(_DWORD *)(dword_78E10 + 496) & 0x3FF;
      break;
    case 2:
      result = HIWORD(*(_DWORD *)(dword_78E10 + 500)) & 0x3FF;
      break;
    case 3:
      result = *(_DWORD *)(dword_78E10 + 500) & 0x3FF;
      break;
    case 4:
      result = HIWORD(*(_DWORD *)(dword_78E10 + 504)) & 0x3FF;
      break;
    case 5:
      result = *(_DWORD *)(dword_78E10 + 504) & 0x3FF;
      break;
    case 6:
      result = HIWORD(*(_DWORD *)(dword_78E10 + 508)) & 0x3FF;
      break;
    case 7:
      result = *(_DWORD *)(dword_78E10 + 508) & 0x3FF;
      break;
    case 8:
      result = HIWORD(*(_DWORD *)(dword_78E10 + 512)) & 0x3FF;
      break;
    case 9:
      result = *(_DWORD *)(dword_78E10 + 512) & 0x3FF;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      result = 0;
      break;
  }
  return result;
}
// 3BB88: control flows out of bounds to 3BB8C
// 78E10: using guessed type int dword_78E10;

//----- (0003BD44) --------------------------------------------------------
int __fastcall sub_3BD44(int a1, _BYTE *a2, unsigned int a3)
{
  int v3; // r3
  int v4; // r10
  unsigned int v5; // r9
  int result; // r0
  _BYTE *v7; // r3
  int v8; // r12
  int v9; // r2
  _BYTE *v10; // r2
  int v11; // [sp+4h] [bp-4h]

  switch ( a1 )
  {
    case 0:
      v3 = 528;
      v4 = 133;
      goto LABEL_3;
    case 1:
      v3 = 536;
      v4 = 135;
      goto LABEL_3;
    case 2:
      v3 = 544;
      v4 = 137;
      goto LABEL_3;
    case 3:
      v3 = 552;
      v4 = 139;
      goto LABEL_3;
    case 4:
      v3 = 560;
      v4 = 141;
      goto LABEL_3;
    case 5:
      v3 = 568;
      v4 = 143;
      goto LABEL_3;
    case 6:
      v3 = 576;
      v4 = 145;
      goto LABEL_3;
    case 7:
      v3 = 584;
      v4 = 147;
      goto LABEL_3;
    case 8:
      v3 = 592;
      v4 = 149;
      goto LABEL_3;
    case 9:
      v3 = 600;
      v4 = 151;
LABEL_3:
      v5 = a3 >> 2;
      *(_DWORD *)(dword_78E10 + v3) = a3 & 0x3FF | 0x80000000;
      if ( a3 >> 2 )
      {
        result = 4 * v5;
        v7 = a2;
        do
        {
          v8 = *(_DWORD *)(dword_78E10 + 4 * v4);
          v7[3] = v8;
          *v7 = HIBYTE(v8);
          v7[1] = BYTE2(v8);
          v7[2] = BYTE1(v8);
          v7 += 4;
        }
        while ( v7 != &a2[4 * v5] );
      }
      else
      {
        result = 0;
      }
      v9 = a3 & 3;
      if ( v9 )
      {
        v11 = *(_DWORD *)(dword_78E10 + 4 * v4);
        if ( v9 == 2 )
        {
          a2[4 * v5] = HIBYTE(v11);
          a2[result + 1] = BYTE2(v11);
          result += 2;
        }
        else if ( v9 == 3 )
        {
          v10 = &a2[result];
          a2[4 * v5] = HIBYTE(v11);
          v10[1] = BYTE2(v11);
          v10[2] = BYTE1(v11);
          result += 3;
        }
        else
        {
          ++result;
          a2[4 * v5] = HIBYTE(v11);
        }
      }
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", a3);
      result = 0;
      break;
  }
  return result;
}
// 3BD54: control flows out of bounds to 3BD58
// 78E10: using guessed type int dword_78E10;

//----- (0003BF0C) --------------------------------------------------------
int __fastcall sub_3BF0C(int a1)
{
  int v2; // r10
  char v3; // r8
  int v4; // r4
  int v5; // r5

  printf("--- %s\n", "clear_uart_send_fifo");
  pthread_mutex_lock(&stru_78EBC[a1]);
  switch ( a1 )
  {
    case 0:
      v2 = 384;
      v3 = 24;
      goto LABEL_3;
    case 1:
      v2 = 384;
      v3 = 16;
      goto LABEL_3;
    case 2:
      v2 = 384;
      v3 = 8;
      goto LABEL_3;
    case 3:
      v2 = 384;
      v3 = 0;
      goto LABEL_3;
    case 4:
      v2 = 388;
      v3 = 24;
      goto LABEL_3;
    case 5:
      v2 = 388;
      v3 = 16;
      goto LABEL_3;
    case 6:
      v2 = 388;
      v3 = 8;
      goto LABEL_3;
    case 7:
      v2 = 388;
      v3 = 0;
      goto LABEL_3;
    case 8:
      v2 = 392;
      v3 = 24;
      goto LABEL_3;
    case 9:
      v2 = 392;
      v3 = 16;
LABEL_3:
      v4 = 21;
      break;
    default:
      v5 = 1;
      printf("%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", a1);
      pthread_mutex_unlock(&stru_78EBC[a1]);
      return v5;
  }
  while ( 1 )
  {
    v5 = (unsigned __int8)(*(_DWORD *)(dword_78E10 + v2) >> v3);
    if ( v5 == 255 )
      break;
    printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", a1);
    usleep(0xBB8u);
    if ( !--v4 )
    {
      printf("%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", a1);
      pthread_mutex_unlock(&stru_78EBC[a1]);
      return v5;
    }
  }
  v5 = 0;
  pthread_mutex_unlock(&stru_78EBC[a1]);
  return v5;
}
// 3BF40: control flows out of bounds to 3BF44
// 78E10: using guessed type int dword_78E10;
// 78EBC: using guessed type pthread_mutex_t stru_78EBC[10];

//----- (0003C0A0) --------------------------------------------------------
int __fastcall sub_3C0A0(int a1)
{
  pthread_mutex_t *v2; // r5
  size_t v3; // r0
  unsigned int v4; // r6
  _BYTE *v5; // r7
  int v6; // r0

  v2 = (pthread_mutex_t *)((char *)&unk_78FAC + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_3BB78(a1);
  v4 = v3;
  if ( v3 )
  {
    v5 = malloc(v3);
    if ( v5 )
    {
      v6 = sub_3BD44(a1, v5, v4);
      if ( v6 != v4 )
        printf("%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, v4, v6);
      free(v5);
    }
    usleep((__useconds_t)&unk_7A120);
    pthread_mutex_unlock(v2);
    return 1;
  }
  else
  {
    pthread_mutex_unlock(v2);
    return 0;
  }
}

//----- (0003C150) --------------------------------------------------------
size_t __fastcall sub_3C150(int a1, const void *a2, size_t a3)
{
  int v4; // r10
  char v5; // r7
  int v6; // r9
  int v7; // r4
  int v9; // r9
  size_t v10; // r7
  char *v11; // r3
  int v12; // r8
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r3
  int v18; // [sp+0h] [bp-122Ch]
  pthread_mutex_t *mutex; // [sp+10h] [bp-121Ch]
  int v21; // [sp+14h] [bp-1218h]
  int v22; // [sp+18h] [bp-1214h]
  char s[512]; // [sp+28h] [bp-1204h] BYREF
  char v25[4056]; // [sp+228h] [bp-1004h] BYREF

  memset(s, 0, sizeof(s));
  mutex = &stru_78EBC[a1];
  pthread_mutex_lock(mutex);
  switch ( a1 )
  {
    case 0:
      v4 = 384;
      v5 = 24;
      v22 = 101;
      v21 = 100;
      goto LABEL_3;
    case 1:
      v4 = 384;
      v5 = 16;
      v22 = 103;
      v21 = 102;
      goto LABEL_3;
    case 2:
      v4 = 384;
      v5 = 8;
      v22 = 105;
      v21 = 104;
      goto LABEL_3;
    case 3:
      v4 = 384;
      v5 = 0;
      v22 = 107;
      v21 = 106;
      goto LABEL_3;
    case 4:
      v4 = 388;
      v5 = 24;
      v22 = 109;
      v21 = 108;
      goto LABEL_3;
    case 5:
      v4 = 388;
      v5 = 16;
      v22 = 111;
      v21 = 110;
      goto LABEL_3;
    case 6:
      v4 = 388;
      v5 = 8;
      v22 = 113;
      v21 = 112;
      goto LABEL_3;
    case 7:
      v4 = 388;
      v5 = 0;
      v22 = 115;
      v21 = 114;
      goto LABEL_3;
    case 8:
      v4 = 392;
      v5 = 24;
      v22 = 117;
      v21 = 116;
      goto LABEL_3;
    case 9:
      v4 = 392;
      v5 = 16;
      v22 = 119;
      v21 = 118;
LABEL_3:
      v6 = 21;
      break;
    default:
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
        return 0;
      a3 = 0;
      snprintf(v25, 0x1000u, "%s: The uart%d is not supported!!!\n", "uart_send", v18);
      sub_38730(5, v25, 0);
      return a3;
  }
  while ( 1 )
  {
    v7 = dword_78E10;
    if ( a3 <= (unsigned __int8)(*(_DWORD *)(dword_78E10 + v4) >> v5) )
      break;
    usleep(0xBB8u);
    if ( !--v6 )
    {
      pthread_mutex_unlock(mutex);
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(v25, 0x1000u, "%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", a1);
LABEL_10:
        sub_38730(5, v25, 0);
      }
      return 0;
    }
  }
  if ( *(int *)(dword_78E10 + 4 * v21) < 0 )
  {
    v9 = 21;
    while ( 1 )
    {
      usleep(0xBB8u);
      v7 = dword_78E10;
      if ( *(int *)(dword_78E10 + 4 * v21) >= 0 )
        break;
      if ( !--v9 )
      {
        pthread_mutex_unlock(mutex);
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          snprintf(v25, 0x1000u, "%s: uart%d always busy, break\n", "uart_send", a1);
          goto LABEL_10;
        }
        return 0;
      }
    }
  }
  memcpy(s, a2, a3);
  v10 = a3 >> 2;
  if ( a3 >> 2 )
  {
    v11 = s;
    do
    {
      v12 = (unsigned __int8)*v11;
      v13 = (unsigned __int8)v11[3];
      v14 = (unsigned __int8)v11[2];
      v15 = (unsigned __int8)v11[1] << 16;
      v11 += 4;
      *(_DWORD *)(v7 + 4 * v22) = v15 | (v12 << 24) | v13 | (v14 << 8);
      v7 = dword_78E10;
    }
    while ( v11 != &s[4 * v10] );
  }
  v16 = a3 & 3;
  if ( (a3 & 3) != 0 )
  {
    if ( v16 == 2 )
    {
      v17 = ((unsigned __int8)s[4 * v10] << 24) | ((unsigned __int8)s[4 * v10 + 1] << 16);
    }
    else if ( v16 == 3 )
    {
      v17 = ((unsigned __int8)s[4 * v10 + 2] << 8)
          | ((unsigned __int8)s[4 * v10 + 1] << 16)
          | ((unsigned __int8)s[4 * v10] << 24);
    }
    else
    {
      v17 = (unsigned __int8)s[4 * v10] << 24;
    }
    *(_DWORD *)(v7 + 4 * v22) = v17;
    v7 = dword_78E10;
  }
  *(_DWORD *)(v7 + 4 * v21) = a3 | 0x80000000;
  pthread_mutex_unlock(mutex);
  return a3;
}
// 3C1A0: control flows out of bounds to 3C1A4
// 3C2F4: variable 'v18' is possibly undefined
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 78EBC: using guessed type pthread_mutex_t stru_78EBC[10];
// 7AD48: using guessed type char byte_7AD48;

//----- (0003C5E8) --------------------------------------------------------
int __fastcall sub_3C5E8(int a1, _BYTE *a2, unsigned int a3)
{
  pthread_mutex_t *v6; // r5
  unsigned int v7; // r0
  int v8; // r4

  v6 = (pthread_mutex_t *)((char *)&unk_78FAC + 24 * a1);
  pthread_mutex_lock(v6);
  v7 = sub_3BB78(a1);
  if ( v7 >= a3 )
  {
    v8 = sub_3BD44(a1, a2, a3);
  }
  else if ( v7 )
  {
    v8 = sub_3BD44(a1, a2, v7);
  }
  else
  {
    v8 = 0;
  }
  pthread_mutex_unlock(v6);
  return v8;
}

//----- (0003C66C) --------------------------------------------------------
void __fastcall sub_3C66C(int a1)
{
  int v2; // r4

  v2 = 22;
  do
  {
    if ( *(int *)(dword_78E10 + 48) < 0 )
    {
      *(_DWORD *)(dword_78E10 + 48) = a1;
      return;
    }
    usleep(0x1388u);
    --v2;
  }
  while ( v2 );
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    sub_3ADE0();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003C708) --------------------------------------------------------
int __fastcall sub_3C708(int a1)
{
  int v1; // r4
  int v2; // r3

  sub_3C66C(a1 | 0x2000000);
  v1 = 22;
  do
  {
    usleep(0x1388u);
    v2 = *(_DWORD *)(dword_78E10 + 48);
    if ( v2 < 0 )
      return (unsigned __int8)v2;
    --v1;
  }
  while ( v1 );
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    return sub_3AE24();
  else
    return 255;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003C7B0) --------------------------------------------------------
void __fastcall sub_3C7B0(int a1)
{
  sub_3C66C(a1 | (dword_7909C << 16) | 0xA00000);
}
// 7909C: using guessed type int dword_7909C;

//----- (0003C7C8) --------------------------------------------------------
int sub_3C7C8()
{
  return sub_3C708((dword_7909C << 16) | 0xA00000);
}
// 7909C: using guessed type int dword_7909C;

//----- (0003C7E0) --------------------------------------------------------
int __fastcall sub_3C7E0(char a1, char a2, int a3, int a4)
{
  char v4; // r8
  int v5; // r0
  int v6; // r1
  char v7; // r12
  unsigned int v8; // r12
  unsigned int v9; // r2
  _BYTE *v10; // r2
  __int16 v11; // t1
  int v12; // r7
  char *v13; // r3
  int v14; // r3
  unsigned __int8 v15; // r4
  int *v16; // r4
  int v18; // [sp+Ch] [bp-1024h] BYREF
  int v19; // [sp+10h] [bp-1020h]
  int v20; // [sp+14h] [bp-101Ch] BYREF
  int v21; // [sp+18h] [bp-1018h]
  int v22; // [sp+1Ch] [bp-1014h]
  char v23; // [sp+20h] [bp-1010h]
  _BYTE v24[15]; // [sp+21h] [bp-100Fh] BYREF
  char v25[4048]; // [sp+30h] [bp-1000h] BYREF
  _DWORD savedregs[8]; // [sp+1030h] [bp+0h] BYREF

  v4 = 2 * a1;
  v5 = 0;
  memset(&v24[3], 0, 12);
  v24[4] = a2;
  v6 = (int)savedregs;
  v20 = 0;
  v19 = 255;
  v24[0] = -86;
  v21 = 0;
  v23 = 85;
  if ( a4 > 0 )
    v6 = 0;
  v24[3] = v4;
  v24[2] = 50;
  v24[1] = a4 + 6;
  v22 = 0;
  if ( a4 > 0 )
  {
    do
    {
      v7 = *(_BYTE *)(a3 + v6);
      v6 = (unsigned __int8)(v6 + 1);
      v24[v5 + 5] = v7;
      v5 = v6;
    }
    while ( a4 > v6 );
  }
  if ( a4 >= -3 )
  {
    LOWORD(v8) = 0;
    v10 = v24;
    do
    {
      v11 = (unsigned __int8)*++v10;
      v8 = (unsigned __int16)(v8 + v11);
    }
    while ( v10 != &v24[a4 + 4] );
    v9 = v8 >> 8;
  }
  else
  {
    LOBYTE(v8) = 0;
    LOBYTE(v9) = 0;
  }
  v12 = (unsigned __int8)(a4 + 6) + 1;
  v13 = &v25[a4];
  *(v13 - 10) = v9;
  *(v13 - 9) = v8;
  pthread_mutex_lock(&stru_790A0);
  v14 = 0;
  v15 = 0;
  do
  {
    sub_3C7B0((unsigned __int8)v24[v14 - 1]);
    v14 = ++v15;
  }
  while ( v15 <= v12 );
  v16 = (int *)((char *)&v18 + 3);
  usleep(0x30D40u);
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  do
  {
    *((_BYTE *)v16 + 1) = sub_3C7C8();
    v16 = (int *)((char *)v16 + 1);
  }
  while ( v16 != &v20 );
  pthread_mutex_unlock(&stru_790A0);
  if ( BYTE1(v19) == 50 && BYTE2(v19) == 1 )
    return 0;
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
    return -1;
  snprintf(
    v25,
    0x1000u,
    "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n\n",
    "write_dc_dc",
    (unsigned __int8)v19,
    BYTE1(v19),
    BYTE2(v19),
    HIBYTE(v19));
  sub_38730(5, v25, 0);
  return -1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003CA38) --------------------------------------------------------
int __fastcall sub_3CA38(char a1, __int16 a2, int a3, int a4)
{
  unsigned __int8 v6; // r4
  int i; // r0
  int v8; // r5
  int v9; // r4
  int v11; // r2
  int v12; // r3
  _BYTE v13[4]; // [sp+14h] [bp-1020h]
  unsigned __int8 v14; // [sp+18h] [bp-101Ch]
  char v15; // [sp+19h] [bp-101Bh]
  char v16; // [sp+1Ah] [bp-101Ah]
  char v17; // [sp+1Bh] [bp-1019h]
  char v18; // [sp+1Ch] [bp-1018h]
  int v19; // [sp+20h] [bp-1014h]
  int v20; // [sp+24h] [bp-1010h]
  int v21; // [sp+28h] [bp-100Ch]
  int v22; // [sp+2Ch] [bp-1008h]
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  v15 = a2;
  v13[1] = -86;
  v13[3] = 50;
  v14 = (2 * a1) | 1;
  v16 = a4;
  v20 = 0;
  v21 = 0;
  v6 = 0;
  v13[2] = 7;
  v19 = 255;
  v17 = (unsigned __int16)((unsigned __int8)a4 + a2 + v14 + 57) >> 8;
  v18 = a4 + a2 + v14 + 57;
  v22 = 0;
  v13[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = (unsigned __int8)v13[v6] )
  {
    sub_3C7B0(i);
    if ( ++v6 == 9 )
      break;
  }
  v8 = 0;
  sub_2A92C();
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if ( a4 + 4 < 0 )
  {
    pthread_mutex_unlock(&stru_790A0);
    goto LABEL_8;
  }
  LOBYTE(v9) = 0;
  do
  {
    v9 = (unsigned __int8)(v9 + 1);
    *((_BYTE *)&v19 + v8) = sub_3C7C8();
    v8 = v9;
  }
  while ( v9 <= a4 + 4 );
  v8 = BYTE1(v19);
  pthread_mutex_unlock(&stru_790A0);
  if ( v8 != 50 || BYTE2(v19) != 1 )
  {
LABEL_8:
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
      return -1;
    snprintf(
      s,
      0x1000u,
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
      "read_dc_dc",
      (unsigned __int8)v19,
      v8,
      BYTE2(v19),
      HIBYTE(v19));
    sub_38730(5, s, 0);
    return -1;
  }
  if ( a4 > 0 )
  {
    v11 = 0;
    v12 = 0;
    do
    {
      *(_BYTE *)(a3 + v12) = *((_BYTE *)&v19 + v11 + 3);
      v12 = (unsigned __int8)(v12 + 1);
      v11 = v12;
    }
    while ( a4 > v12 );
  }
  return 0;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003CC6C) --------------------------------------------------------
int __fastcall sub_3CC6C(_BYTE *a1, int a2)
{
  int v2; // r5
  int v3; // r3
  char v4; // r8
  int v5; // r9
  int v6; // r6
  char v7; // r7
  unsigned __int8 v8; // r12
  unsigned int v9; // r2
  int v10; // r4
  unsigned __int8 v11; // r8
  int v12; // r10
  int result; // r0

  if ( a2 )
  {
    v2 = 1;
    LOBYTE(v3) = 0;
    v4 = 1;
    v5 = 1;
    v6 = 1;
    v7 = 1;
    v8 = 0;
    v9 = 128;
    while ( 1 )
    {
      ++v8;
      v3 = (unsigned __int8)(v3 + 1);
      if ( ((unsigned __int8)v9 & *a1) != 0 )
        LOBYTE(v10) = v7 ^ 1;
      else
        LOBYTE(v10) = v7;
      v9 >>= 1;
      v10 = (unsigned __int8)v10;
      if ( v3 == 8 )
        ++a1;
      v11 = v4 ^ v10;
      if ( v3 == 8 )
      {
        LOBYTE(v3) = 0;
        v9 = 128;
      }
      v12 = v11;
      v7 = v6;
      v4 = v2;
      if ( v8 == a2 )
        break;
      v6 = v5;
      v2 = (unsigned __int8)v10;
      v5 = v12;
    }
    if ( !v6 )
    {
      result = 0;
      goto LABEL_15;
    }
  }
  else
  {
    v10 = 1;
    v2 = 1;
    v12 = 1;
    v5 = 1;
  }
  result = 16;
LABEL_15:
  if ( v5 )
    result = (unsigned __int8)result | 8;
  if ( v12 )
    result = (unsigned __int8)result | 4;
  if ( v2 )
    result = (unsigned __int8)result | 2;
  if ( v10 )
    return (unsigned __int8)result | 1;
  return result;
}

//----- (0003CD58) --------------------------------------------------------
int __fastcall sub_3CD58(int a1)
{
  char v2; // r0
  char v3; // r3
  char v4; // r3
  int v5; // r0
  int v7; // [sp+0h] [bp-8h] BYREF
  char v8; // [sp+4h] [bp-4h]

  v8 = 0;
  v7 = 1363;
  v2 = sub_3CC6C(&v7, 32);
  v3 = v8;
  *(_BYTE *)a1 = 85;
  *(_BYTE *)(a1 + 1) = -86;
  v4 = v3 & 0xE0 | v2 & 0x1F;
  v5 = v7;
  *(_BYTE *)(a1 + 6) = v4;
  *(_DWORD *)(a1 + 2) = v5;
  return 7;
}

//----- (0003CDCC) --------------------------------------------------------
int __fastcall sub_3CDCC(int a1, char a2, char a3, char a4, unsigned int a5)
{
  char v6; // r0
  int v7; // r1
  __int16 v8; // r2
  char v9; // r3
  int v11; // [sp+Ch] [bp-10h] BYREF
  _BYTE v12[6]; // [sp+10h] [bp-Ch]
  char v13; // [sp+16h] [bp-6h]

  v12[0] = a3;
  v12[1] = a4;
  BYTE2(v11) = (16 * (a2 & 1)) | 0x41;
  LOWORD(v11) = -21931;
  HIBYTE(v11) = 9;
  *(_DWORD *)&v12[2] = bswap32(a5);
  v13 &= 0x1Fu;
  v6 = sub_3CC6C((_BYTE *)&v11 + 2, 64);
  v13 = v13 & 0xE0 | v6 & 0x1F;
  v7 = *(_DWORD *)v12;
  v8 = *(_WORD *)&v12[4];
  v9 = v13;
  *(_DWORD *)a1 = v11;
  *(_DWORD *)(a1 + 4) = v7;
  *(_WORD *)(a1 + 8) = v8;
  *(_BYTE *)(a1 + 10) = v9;
  return 11;
}

//----- (0003CE7C) --------------------------------------------------------
int __fastcall sub_3CE7C(int a1, unsigned __int8 a2)
{
  char v3; // r0
  char v4; // r3
  char v5; // r3
  int v6; // r0
  int v8; // [sp+0h] [bp-8h] BYREF
  char v9; // [sp+4h] [bp-4h]

  HIWORD(v8) = a2;
  v9 = 0;
  LOWORD(v8) = 1344;
  v3 = sub_3CC6C(&v8, 32);
  v4 = v9;
  *(_BYTE *)a1 = 85;
  *(_BYTE *)(a1 + 1) = -86;
  v5 = v4 & 0xE0 | v3 & 0x1F;
  v6 = v8;
  *(_BYTE *)(a1 + 6) = v5;
  *(_DWORD *)(a1 + 2) = v6;
  return 7;
}

//----- (0003CEF0) --------------------------------------------------------
int __fastcall sub_3CEF0(int a1, char a2, char a3, char a4)
{
  char v5; // r0
  int v6; // t1
  __int16 v7; // r3
  int v9; // [sp+0h] [bp-Ch] BYREF
  __int16 v10; // [sp+4h] [bp-8h]
  char v11; // [sp+6h] [bp-6h]

  LOBYTE(v10) = a3;
  HIBYTE(v10) = a4;
  BYTE2(v9) = (16 * (a2 & 1)) | 0x42;
  v11 &= 0x1Fu;
  LOWORD(v9) = -21931;
  HIBYTE(v9) = 5;
  v5 = sub_3CC6C((_BYTE *)&v9 + 2, 32);
  v6 = v9;
  *(_BYTE *)(a1 + 6) = v11 & 0xE0 | v5 & 0x1F;
  v7 = v10;
  *(_DWORD *)a1 = v6;
  *(_WORD *)(a1 + 4) = v7;
  return 7;
}

//----- (0003CFC4) --------------------------------------------------------
unsigned int __fastcall sub_3CFC4(unsigned int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r2
  int v4; // t1

  if ( a3 )
  {
    v3 = &a2[a3];
    do
    {
      v4 = *a2++;
      result = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v4 ^ (result >> 8)) + 404] ^ ((_WORD)result << 8));
    }
    while ( a2 != v3 );
  }
  return result;
}

//----- (0003D000) --------------------------------------------------------
int __fastcall sub_3D000(__int16 a1, __int16 a2)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  int v5; // r4
  int v6; // r5
  int result; // r0
  _BYTE v8[7]; // [sp+10h] [bp-1008h] BYREF
  char v9; // [sp+17h] [bp-1001h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v8[4] = a1;
  v8[1] = -86;
  v8[3] = 1;
  v9 = a2 + a1 + 7;
  v2 = v8;
  v8[5] = a2;
  v8[6] = (unsigned __int16)(a2 + a1 + 7) >> 8;
  v8[0] = 85;
  v8[2] = 6;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v2 == &v9 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x186A0u);
  v5 = sub_3C7C8();
  v6 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  if ( v5 == 1 && v6 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "set_PIC16F1704_flash_pointer_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_flash_pointer_new",
      dword_7909C,
      v5,
      v6);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003D1AC) --------------------------------------------------------
int __fastcall sub_3D1AC(int a1)
{
  int v1; // r3
  __int16 v2; // r2
  __int16 v3; // r12
  int v4; // r1
  _DWORD *v5; // r3
  char v6; // t1
  _WORD *v7; // r4
  int v8; // t1
  int v9; // r4
  int v10; // r5
  int result; // r0
  _BYTE v12[17]; // [sp+Fh] [bp-1019h] BYREF
  int v13; // [sp+20h] [bp-1008h] BYREF
  __int16 v14; // [sp+24h] [bp-1004h] BYREF
  char s[4056]; // [sp+28h] [bp-1000h] BYREF

  v1 = 0;
  v2 = 22;
  memset(&v12[1], 0, 16);
  v13 = 0;
  v14 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a1 + v1++);
    v2 += v3;
  }
  while ( v1 != 16 );
  v4 = a1 - 1;
  v5 = &v12[4];
  *(_DWORD *)&v12[1] = 34908757;
  do
  {
    v6 = *(_BYTE *)++v4;
    *((_BYTE *)v5 + 1) = v6;
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v13 + 3) );
  LOBYTE(v14) = HIBYTE(v2);
  v7 = v12;
  HIBYTE(v14) = v2;
  pthread_mutex_lock(&stru_790A0);
  do
  {
    v8 = *((unsigned __int8 *)v7 + 1);
    v7 = (_WORD *)((char *)v7 + 1);
    sub_3C7B0(v8);
  }
  while ( v7 != (__int16 *)((char *)&v14 + 1) );
  usleep(0x186A0u);
  v9 = sub_3C7C8();
  v10 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  if ( v9 == 2 && v10 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "send_data_to_PIC16F1704_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "send_data_to_PIC16F1704_new",
      dword_7909C,
      v9,
      v10);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003DA84) --------------------------------------------------------
int sub_3DA84()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v7 = 8;
  v6[2] = 4;
  v6[3] = 4;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C7C8();
  v4 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( v3 == 4 && v4 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "erase_PIC16F1704_flash_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "erase_PIC16F1704_flash_new",
      dword_7909C,
      v3,
      v4);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003DC28) --------------------------------------------------------
int sub_3DC28()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v6[2] = 4;
  v6[3] = 5;
  v7 = 9;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x30D40u);
  v3 = sub_3C7C8();
  v4 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( v3 == 5 && v4 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok\n\n", "write_data_into_PIC16F1704_flash_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_data_into_PIC16F1704_flash_new",
      dword_7909C,
      v3,
      v4);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003DDD0) --------------------------------------------------------
int sub_3DDD0()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v6[2] = 4;
  v6[3] = 6;
  v7 = 10;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C7C8();
  v4 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x493E0u);
  if ( v3 == 6 && v4 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "jump_from_loader_to_app_PIC16F1704_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "jump_from_loader_to_app_PIC16F1704_new",
      dword_7909C,
      v3,
      v4);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003DF78) --------------------------------------------------------
int sub_3DF78()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v6[2] = 4;
  v6[3] = 7;
  v7 = 11;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C7C8();
  v4 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0xF4240u);
  if ( v3 == 7 && v4 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "reset_PIC16F1704_pic_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "reset_PIC16F1704_pic_new",
      dword_7909C,
      v3,
      v4);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003E564) --------------------------------------------------------
int __fastcall sub_3E564(char a1, _WORD *a2)
{
  __int16 v4; // [sp+4h] [bp-8h] BYREF

  v4 = 0;
  sub_3CA38(a1, 33, (int)&v4, 2);
  *a2 = (unsigned __int8)v4 | (HIBYTE(v4) << 8);
  return 0;
}

//----- (0003E5A4) --------------------------------------------------------
void __fastcall sub_3E5A4(int a1)
{
  int v1; // r4
  __int16 *v2; // r6
  char v3; // r0
  bool v4; // zf
  int v5; // r12
  unsigned __int16 v7; // [sp+16h] [bp-FEAh] BYREF
  char s[4072]; // [sp+18h] [bp-FE8h] BYREF

  v1 = 0;
  v2 = &word_790B8[3 * a1 - 1];
  do
  {
    v3 = byte_76B48[v1];
    v7 = 0;
    sub_3E564(v3, &v7);
    v4 = byte_7AD48 == 0;
    v5 = v7;
    v2[1] = v7;
    ++v2;
    if ( !v4 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "chain %d asic = %d vol=%u\n", a1, v1, v5);
      sub_38730(5, s, 0);
    }
    ++v1;
  }
  while ( v1 != 3 );
}
// 766C4: using guessed type int dword_766C4;
// 76B48: using guessed type _BYTE byte_76B48[3];
// 78E08: using guessed type char byte_78E08;
// 790B8: using guessed type __int16 word_790B8[];
// 7AD48: using guessed type char byte_7AD48;

//----- (0003E688) --------------------------------------------------------
int sub_3E688()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1
  int result; // r0

  v0 = 0;
  v1 = 644283;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = v0;
      sub_3E5A4(v0);
      result = pthread_mutex_unlock(&stru_790D0);
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 7909C: using guessed type int dword_7909C;

//----- (0003E6E0) --------------------------------------------------------
int __fastcall sub_3E6E0(int result, unsigned __int8 *a2, int a3)
{
  int v3; // r6
  int v4; // r8
  int i; // r4
  int v8; // t1
  int v9; // r5
  char v10; // r0
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  v3 = 644283;
  v4 = result;
  for ( i = 0; i != 4; ++i )
  {
    v8 = *(unsigned __int8 *)++v3;
    if ( v8 == 1 )
    {
      v9 = 0;
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      do
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          snprintf(
            s,
            0x1000u,
            "chain%d asic%d, set data slave:%02x addr:%02x %02x %02x, len=%d\n",
            i,
            v9,
            (unsigned __int8)byte_76B48[v9],
            v4,
            *a2,
            a2[1],
            a3);
          sub_38730(5, s, 0);
        }
        v10 = *((_BYTE *)&unk_76AC8 + v9++ + 128);
        sub_3C7E0(v10, v4, (int)a2, a3);
        sub_2A92C();
      }
      while ( v9 != 3 );
      result = pthread_mutex_unlock(&stru_790D0);
    }
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 76B48: using guessed type _BYTE byte_76B48[3];
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003E814) --------------------------------------------------------
int __fastcall sub_3E814(int result, unsigned __int8 *a2, int a3)
{
  int v3; // r6
  int v4; // r10
  int i; // r4
  int v8; // t1
  int v9; // r5
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  v3 = 644283;
  v4 = result;
  for ( i = 0; i != 4; ++i )
  {
    v8 = *(unsigned __int8 *)++v3;
    if ( v8 == 1 )
    {
      v9 = 0;
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      do
      {
        sub_3CA38(byte_76B48[v9], v4, (int)a2, a3);
        if ( a3 == 1 )
        {
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
          {
            snprintf(
              s,
              0x1000u,
              "chain%d asic%d, slave:%02x, addr:%02x %02x\n",
              i,
              v9,
              (unsigned __int8)byte_76B48[v9],
              v4,
              *a2);
            sub_38730(5, s, 0);
          }
        }
        else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          snprintf(
            s,
            0x1000u,
            "chain%d asic%d, slave:%02x, addr:%02x %02x %02x\n",
            i,
            v9,
            (unsigned __int8)byte_76B48[v9],
            v4,
            *a2,
            a2[1]);
          sub_38730(5, s, 0);
        }
        ++v9;
        sub_2A92C();
      }
      while ( v9 != 3 );
      result = pthread_mutex_unlock(&stru_790D0);
    }
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 76B48: using guessed type _BYTE byte_76B48[3];
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003E9AC) --------------------------------------------------------
int __fastcall sub_3E9AC(unsigned int a1)
{
  int v3; // [sp+0h] [bp-8h] BYREF
  unsigned int v4; // [sp+4h] [bp-4h]

  v3 = 32;
  sub_3E6E0(0, (unsigned __int8 *)&v3, 1);
  sleep(1u);
  BYTE1(v3) = 64;
  v4 = (unsigned int)(((double)a1 / 1000.0 - 0.25) / 0.005 + 1.0);
  LOBYTE(v3) = v4;
  return sub_3E6E0(19, (unsigned __int8 *)&v3, 2);
}

//----- (0003EA50) --------------------------------------------------------
int __fastcall sub_3EA50(char a1, unsigned int a2)
{
  int v3; // r7
  int v4; // r8
  int v5; // r12
  char v7; // [sp+Ch] [bp-1018h]
  unsigned int v8; // [sp+10h] [bp-1014h]
  int v9; // [sp+14h] [bp-1010h]
  char v10; // [sp+1Bh] [bp-1009h] BYREF
  _BYTE v11[2]; // [sp+1Ch] [bp-1008h] BYREF
  unsigned __int16 v12; // [sp+1Eh] [bp-1006h] BYREF
  char s[4064]; // [sp+20h] [bp-1004h] BYREF

  if ( a2 - 700 > 0x64 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      v3 = 700;
      snprintf(s, 0x1000u, "illegal voltage [%d, %d], set default voltage %d\n", 700, 800, 700);
      sub_38730(5, s, 0);
      LOBYTE(v8) = 2;
      v9 = 704;
      v7 = -68;
    }
    else
    {
      v9 = 704;
      LOBYTE(v8) = 2;
      v7 = -68;
      v3 = 700;
    }
  }
  else
  {
    v3 = a2;
    v7 = a2;
    v8 = a2 >> 8;
    v9 = a2 + 4;
  }
  LOBYTE(v4) = 4;
  v12 = 0;
  while ( 1 )
  {
    v10 = -1;
    sub_3C7E0(a1, 0, (int)&v10, 1);
    sub_2A92C();
    v11[1] = v8;
    v11[0] = v7;
    sub_3C7E0(a1, 33, (int)v11, 2);
    sub_2A92C();
    sub_3E564(a1, &v12);
    v5 = v12;
    if ( v12 <= v9 && v12 >= v3 - 4 )
      break;
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "set vol %d, get vol %d, set again!\n", v3, v12);
      sub_38730(5, s, 0);
    }
    sub_2A92C();
    v4 = (unsigned __int8)(v4 - 1);
    if ( !v4 )
      return v12;
  }
  return v5;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003ECB8) --------------------------------------------------------
int __fastcall sub_3ECB8(char a1, int a2)
{
  __int16 v2; // r5
  int v4; // r3
  int v6; // r6
  char v7; // [sp+Bh] [bp-1009h] BYREF
  char v8; // [sp+Ch] [bp-1008h] BYREF
  char v9; // [sp+Dh] [bp-1007h] BYREF
  unsigned __int16 v10; // [sp+Eh] [bp-1006h] BYREF
  char s[4080]; // [sp+10h] [bp-1004h] BYREF

  v2 = a2;
  if ( (unsigned int)(a2 - 700) <= 0x64 )
  {
    v7 = -1;
    sub_3C7E0(a1, 0, (int)&v7, 1);
    v8 = 26;
    sub_3C7E0(a1, 2, (int)&v8, 1);
    sub_2A92C();
    v9 = 64;
    sub_3C7E0(a1, 1, (int)&v9, 1);
    sub_2A92C();
    *(_WORD *)s = v2;
    sub_3C7E0(a1, 33, (int)s, 2);
    sub_2A92C();
    v9 = 0x80;
    sub_3C7E0(a1, 1, (int)&v9, 1);
    sub_2A92C();
    LOBYTE(v6) = 5;
    v10 = 0;
    sub_2A92C();
    sub_3E564(a1, &v10);
    while ( 1 )
    {
      v4 = v10;
      if ( v10 )
        break;
      sub_2A92C();
      sub_3E564(a1, &v10);
      v6 = (unsigned __int8)(v6 - 1);
      if ( !v6 )
        return v10;
    }
  }
  else if ( byte_7AD48 || (v4 = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "illegal voltage [%d, %d]\n", 700, 800);
    sub_38730(5, s, 0);
    return 0;
  }
  return v4;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003EEC8) --------------------------------------------------------
int __fastcall sub_3EEC8(int a1)
{
  __int16 *v1; // r6
  int i; // r4
  unsigned int v4; // r5
  unsigned int v5; // t1
  int v6; // lr
  int result; // r0
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  v1 = &word_790B8[3 * a1 - 1];
  for ( i = 0; i != 3; ++i )
  {
    v5 = (unsigned __int16)v1[1];
    ++v1;
    v4 = v5;
    v6 = sub_3EA50(byte_76B48[i], v5);
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(
        s,
        0x1000u,
        "chain%d asic%d addr %02x, %s set vol %d, get vol %d",
        a1,
        i,
        (unsigned __int8)byte_76B48[i],
        "every_asic_set_isl_voltage",
        v4,
        v6);
      sub_38730(5, s, 0);
    }
    result = sub_2A92C();
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 76B48: using guessed type _BYTE byte_76B48[3];
// 78E08: using guessed type char byte_78E08;
// 790B8: using guessed type __int16 word_790B8[];
// 7AD48: using guessed type char byte_7AD48;

//----- (0003EFB0) --------------------------------------------------------
int sub_3EFB0()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1
  int result; // r0

  v0 = 0;
  v1 = 644283;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = v0;
      sub_3EEC8(v0);
      sub_2A92C();
      result = pthread_mutex_unlock(&stru_790D0);
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 7909C: using guessed type int dword_7909C;

//----- (0003F010) --------------------------------------------------------
int __fastcall sub_3F010(int a1, int a2, int a3)
{
  char v6; // r0
  unsigned __int16 v8; // [sp+6h] [bp-2h] BYREF

  pthread_mutex_lock(&stru_790D0);
  v8 = 0;
  v6 = *((_BYTE *)&unk_76AC8 + a2 + 128);
  dword_7909C = a1;
  sub_3E564(v6, &v8);
  if ( v8 > a3 + 5 || v8 < a3 - 5 )
  {
    sub_3EA50(*((_BYTE *)&unk_76AC8 + a2 + 128), (unsigned __int16)a3);
    sub_2A92C();
  }
  return pthread_mutex_unlock(&stru_790D0);
}
// 7909C: using guessed type int dword_7909C;

//----- (0003F0A4) --------------------------------------------------------
void __fastcall sub_3F0A4(int a1)
{
  int v2; // r6
  int i; // r4
  int v4; // t1
  char v5[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(v5, 0x1000u, "set voltage to %d\n", a1);
    sub_38730(5, v5, 0);
  }
  v2 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
    {
      sub_3F010(i, 0, a1);
      sub_3F010(i, 1, a1);
      sub_3F010(i, 2, a1);
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003F308) --------------------------------------------------------
int __fastcall sub_3F308(int a1)
{
  char *v1; // r4
  int i; // r0
  int v4; // t1
  int v5; // r4
  int v6; // r5
  int result; // r0
  _BYTE v8[6]; // [sp+10h] [bp-100Ch] BYREF
  char v9; // [sp+16h] [bp-1006h] BYREF
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v9 = a1 + 21;
  v8[3] = 16;
  v1 = v8;
  v8[5] = (unsigned __int16)(a1 + 21) >> 8;
  v8[4] = a1;
  v8[1] = -86;
  v8[0] = 85;
  v8[2] = 5;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v1 == &v9 )
      break;
    v4 = (unsigned __int8)*++v1;
  }
  usleep(0x30D40u);
  v5 = sub_3C7C8();
  v6 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( v5 == 16 && v6 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok, voltage = 0x%02x", "set_PIC16F1704_voltage_new", a1);
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_voltage_new",
      dword_7909C,
      v5,
      v6);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003F4BC) --------------------------------------------------------
int __fastcall sub_3F4BC(int a1)
{
  int v1; // r3
  __int16 v2; // r2
  __int16 v3; // r12
  int v4; // r1
  _DWORD *v5; // r3
  char v6; // t1
  _WORD *v7; // r4
  int v8; // t1
  int v9; // r4
  int v10; // r5
  int result; // r0
  _BYTE v12[13]; // [sp+13h] [bp-1015h] BYREF
  int v13; // [sp+20h] [bp-1008h] BYREF
  __int16 v14; // [sp+24h] [bp-1004h] BYREF
  char s[4056]; // [sp+28h] [bp-1000h] BYREF

  v1 = 0;
  v2 = 34;
  memset(&v12[1], 0, 12);
  v13 = 0;
  v14 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a1 + v1++);
    v2 += v3;
  }
  while ( v1 != 12 );
  v4 = a1 - 1;
  v5 = &v12[4];
  *(_DWORD *)&v12[1] = 303082069;
  do
  {
    v6 = *(_BYTE *)++v4;
    *((_BYTE *)v5 + 1) = v6;
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v13 + 3) );
  LOBYTE(v14) = HIBYTE(v2);
  v7 = v12;
  HIBYTE(v14) = v2;
  pthread_mutex_lock(&stru_790A0);
  do
  {
    v8 = *((unsigned __int8 *)v7 + 1);
    v7 = (_WORD *)((char *)v7 + 1);
    sub_3C7B0(v8);
  }
  while ( v7 != (__int16 *)((char *)&v14 + 1) );
  usleep(0x30D40u);
  v9 = sub_3C7C8();
  v10 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( v9 == 18 && v10 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "write_hash_ID_PIC16F1704_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_hash_ID_PIC16F1704_new",
      dword_7909C,
      v9,
      v10);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003F6CC) --------------------------------------------------------
int __fastcall sub_3F6CC(int a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  char *v5; // r4
  int v6; // r5
  int result; // r0
  char v8; // r3
  int v9; // r6
  char *j; // r2
  char v11; // t1
  _BYTE v12[5]; // [sp+40h] [bp-1018h] BYREF
  char v13; // [sp+45h] [bp-1013h] BYREF
  char v14; // [sp+47h] [bp-1011h] BYREF
  int v15; // [sp+48h] [bp-1010h] BYREF
  int v16; // [sp+4Ch] [bp-100Ch]
  int v17; // [sp+50h] [bp-1008h]
  int v18; // [sp+54h] [bp-1004h] BYREF
  char s[4072]; // [sp+58h] [bp-1000h] BYREF

  v16 = 0;
  v15 = 255;
  v17 = 0;
  v18 = 0;
  v12[4] = 0;
  v12[1] = -86;
  v2 = v12;
  v12[2] = 4;
  v12[3] = 19;
  v13 = 23;
  v12[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v2 == &v13 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x30D40u);
  v5 = &v14;
  do
    *++v5 = sub_3C7C8();
  while ( v5 != (char *)&v18 + 3 );
  pthread_mutex_unlock(&stru_790A0);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    v6 = BYTE1(v15);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\trea"
      "d_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_back_"
      "data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_data["
      "12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
      "read_hash_id_PIC16F1704_new",
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15),
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16),
      (unsigned __int8)v17,
      BYTE1(v17),
      BYTE2(v17),
      HIBYTE(v17),
      (unsigned __int8)v18,
      BYTE1(v18),
      BYTE2(v18),
      HIBYTE(v18));
    sub_38730(5, s, 0);
    if ( v6 != 19 )
      goto LABEL_9;
  }
  else if ( BYTE1(v15) != 19 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v15 != 16 )
  {
LABEL_9:
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, aSChainDFailed_0, "read_hash_id_PIC16F1704_new", dword_7909C);
    goto LABEL_13;
  }
  v8 = BYTE2(v15);
  if ( BYTE2(v18) != (unsigned __int16)(BYTE1(v18)
                                      + (unsigned __int8)v18
                                      + HIBYTE(v17)
                                      + BYTE2(v17)
                                      + BYTE1(v17)
                                      + (unsigned __int8)v17
                                      + HIBYTE(v16)
                                      + BYTE2(v16)
                                      + BYTE1(v16)
                                      + (unsigned __int8)v16
                                      + BYTE2(v15)
                                      + HIBYTE(v15)
                                      + 35) >> 8
    || HIBYTE(v18) != (unsigned __int8)(BYTE1(v18)
                                      + v18
                                      + HIBYTE(v17)
                                      + BYTE2(v17)
                                      + BYTE1(v17)
                                      + v17
                                      + HIBYTE(v16)
                                      + BYTE2(v16)
                                      + BYTE1(v16)
                                      + v16
                                      + BYTE2(v15)
                                      + HIBYTE(v15)
                                      + 35) )
  {
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(
      s,
      0x1000u,
      "%s failed! crc = 0x%04x",
      "read_hash_id_PIC16F1704_new",
      (unsigned __int16)(BYTE1(v18)
                       + (unsigned __int8)v18
                       + HIBYTE(v17)
                       + BYTE2(v17)
                       + BYTE1(v17)
                       + (unsigned __int8)v17
                       + HIBYTE(v16)
                       + BYTE2(v16)
                       + BYTE1(v16)
                       + (unsigned __int8)v16
                       + BYTE2(v15)
                       + HIBYTE(v15)
                       + 35));
LABEL_13:
    sub_38730(3, s, 0);
    return 0;
  }
  v9 = a1 - 1;
  for ( j = (char *)&v15 + 2; ; ++j )
  {
    *(_BYTE *)++v9 = v8;
    if ( j == (char *)&v18 + 1 )
      break;
    v11 = j[1];
    v8 = v11;
  }
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok", "read_hash_id_PIC16F1704_new");
  sub_38730(5, s, 0);
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003FA7C) --------------------------------------------------------
int sub_3FA7C()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[4]; // [sp+10h] [bp-1008h] BYREF
  __int16 v7; // [sp+14h] [bp-1004h]
  char v8; // [sp+16h] [bp-1002h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v7 = 1;
  v6[2] = 5;
  v6[3] = 21;
  v6[1] = -86;
  v0 = v6;
  v8 = 27;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == &v8 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C7C8();
  v4 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  if ( v3 == 21 && v4 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "enable_PIC16F1704_dc_dc_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "enable_PIC16F1704_dc_dc_new",
      dword_7909C,
      v3,
      v4);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003FC24) --------------------------------------------------------
int sub_3FC24()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[4]; // [sp+10h] [bp-1008h] BYREF
  __int16 v7; // [sp+14h] [bp-1004h]
  char v8; // [sp+16h] [bp-1002h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v7 = 0;
  v6[2] = 5;
  v6[1] = -86;
  v6[3] = 21;
  v0 = v6;
  v8 = 26;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == &v8 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C7C8();
  v4 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  if ( v3 == 21 && v4 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "disable_PIC16F1704_dc_dc_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "disable_PIC16F1704_dc_dc_new",
      dword_7909C,
      v3,
      v4);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (0003FDC4) --------------------------------------------------------
int sub_3FDC4()
{
  _WORD *v0; // r4
  int i; // r0
  int v2; // t1
  _WORD *v3; // r4
  int v4; // r4
  int result; // r0
  int v6; // [sp+14h] [bp-1014h] BYREF
  int v7; // [sp+18h] [bp-1010h]
  __int16 v8; // [sp+1Ch] [bp-100Ch] BYREF
  _BYTE v9[4]; // [sp+20h] [bp-1008h] BYREF
  __int16 v10; // [sp+24h] [bp-1004h] BYREF
  char s[4056]; // [sp+28h] [bp-1000h] BYREF

  v9[1] = -86;
  v7 = 255;
  v10 = 6656;
  v8 = 0;
  v9[2] = 4;
  v9[3] = 22;
  v0 = v9;
  v9[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C7B0(i);
    if ( v0 == (__int16 *)((char *)&v10 + 1) )
      break;
    v2 = *((unsigned __int8 *)v0 + 1);
    v0 = (_WORD *)((char *)v0 + 1);
  }
  usleep(0x186A0u);
  v3 = (_WORD *)((char *)&v6 + 3);
  do
  {
    *((_BYTE *)v3 + 1) = sub_3C7C8();
    v3 = (_WORD *)((char *)v3 + 1);
  }
  while ( v3 != (__int16 *)((char *)&v8 + 1) );
  pthread_mutex_unlock(&stru_790A0);
  v4 = BYTE1(v7);
  if ( BYTE1(v7) == 22 && (result = BYTE2(v7), BYTE2(v7) == 1) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "%s ok", "heart_beat_PIC16F1704_new");
      sub_38730(7, s, 0);
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(s, 0x1000u, "%s chain %d failed!", "heart_beat_PIC16F1704_new", dword_7909C);
    sub_38730(3, s, 0);
    if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
    {
      v6 = HIBYTE(v8);
      snprintf(
        s,
        0x1000u,
        "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
        "heart_beat_PIC16F1704_new",
        (unsigned __int8)v7,
        v4,
        BYTE2(v7),
        HIBYTE(v7),
        (unsigned __int8)v8,
        v6);
      sub_38730(3, s, 0);
      return 0;
    }
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040034) --------------------------------------------------------
void __noreturn sub_40034()
{
  int v0; // r5
  int i; // r4
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(v3, "pic_heart_beat_func_new");
    sub_38730(5, v3, 0);
  }
  while ( 1 )
  {
    v0 = 644283;
    sleep(0xAu);
    for ( i = 0; i != 4; ++i )
    {
      if ( *(unsigned __int8 *)++v0 )
      {
        if ( byte_76B4B )
        {
          pthread_mutex_lock(&stru_790D0);
          dword_7909C = i;
          sub_3FDC4();
          sub_2A92C();
          pthread_mutex_unlock(&stru_790D0);
        }
      }
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 76B4B: using guessed type char byte_76B4B;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040128) --------------------------------------------------------
int __fastcall sub_40128(_BYTE *a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r4
  unsigned int v7; // r3
  char v9; // [sp+17h] [bp-1015h] BYREF
  int v10; // [sp+18h] [bp-1014h]
  unsigned __int8 v11; // [sp+1Ch] [bp-1010h] BYREF
  _BYTE v12[5]; // [sp+20h] [bp-100Ch] BYREF
  char v13; // [sp+25h] [bp-1007h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  v12[1] = -86;
  v10 = 255;
  v12[4] = 0;
  v11 = 0;
  v2 = v12;
  v12[2] = 4;
  v12[3] = 23;
  v13 = 27;
  v12[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v2 == &v13 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep((__useconds_t)"n network");
  v5 = (unsigned __int8 *)&v9;
  do
    *++v5 = sub_3C7C8();
  while ( v5 != &v11 );
  pthread_mutex_unlock(&stru_790A0);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    v6 = BYTE1(v10);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_b"
      "ack_data[4] = 0x%x",
      "get_PIC16F1704_software_version_new",
      (unsigned __int8)v10,
      BYTE1(v10),
      BYTE2(v10),
      HIBYTE(v10),
      v11);
    sub_38730(7, s, 0);
    if ( v6 != 23 )
    {
LABEL_18:
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
        return 0;
      snprintf(s, 0x1000u, "%s chain %d failed!", "get_PIC16F1704_software_version_new", dword_7909C);
      sub_38730(3, s, 0);
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
        return 0;
      snprintf(
        s,
        0x1000u,
        "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
        "_back_data[4] = 0x%x",
        "get_PIC16F1704_software_version_new",
        (unsigned __int8)v10,
        v6,
        BYTE2(v10),
        HIBYTE(v10),
        v11);
      goto LABEL_23;
    }
  }
  else
  {
    v6 = BYTE1(v10);
    if ( BYTE1(v10) != 23 )
      goto LABEL_18;
  }
  if ( (unsigned __int8)v10 != 5 )
    goto LABEL_18;
  v7 = BYTE2(v10) + 28;
  if ( HIBYTE(v10) != v7 >> 8 || v11 != (unsigned __int8)v7 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
      return 0;
    snprintf(s, 0x1000u, "%s failed! crc = 0x%04x", "get_PIC16F1704_software_version_new", BYTE2(v10) + 28);
LABEL_23:
    sub_38730(3, s, 0);
    return 0;
  }
  *a1 = BYTE2(v10);
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040454) --------------------------------------------------------
void sub_40454()
{
  int v0; // r5
  int v1; // r4
  int v2; // t1
  int v3; // r9
  int v4; // [sp+Ch] [bp-1004h] BYREF
  char s[4080]; // [sp+10h] [bp-1000h] BYREF

  v0 = 644283;
  v1 = 0;
  v4 = 0;
  do
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = v1;
      v3 = sub_40128(&s[v1 - 4]);
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
      if ( v3 == 1 )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          snprintf(s, 0x1000u, "chain%d pic version %02x\n", v1, (unsigned __int8)s[v1 - 4]);
          sub_38730(5, s, 0);
        }
      }
      else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "chain%d pic version read failed\n", v1);
        sub_38730(5, s, 0);
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (000405AC) --------------------------------------------------------
int __fastcall sub_405AC(_BYTE *a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r5
  int result; // r0
  int v8; // r2
  unsigned int v9; // r3
  char v10; // [sp+17h] [bp-1015h] BYREF
  int v11; // [sp+18h] [bp-1014h]
  unsigned __int8 v12; // [sp+1Ch] [bp-1010h] BYREF
  _BYTE v13[5]; // [sp+20h] [bp-100Ch] BYREF
  char v14; // [sp+25h] [bp-1007h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  v13[1] = -86;
  v11 = 255;
  v13[4] = 0;
  v12 = 0;
  v2 = v13;
  v13[2] = 4;
  v13[3] = 24;
  v14 = 28;
  v13[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v2 == &v14 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x30D40u);
  v5 = (unsigned __int8 *)&v10;
  do
    *++v5 = sub_3C7C8();
  while ( v5 != &v12 );
  pthread_mutex_unlock(&stru_790A0);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    v6 = BYTE1(v11);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_b"
      "ack_data[4] = 0x%x\n",
      "get_PIC16F1704_voltage_new",
      (unsigned __int8)v11,
      BYTE1(v11),
      BYTE2(v11),
      HIBYTE(v11),
      v12);
    sub_38730(5, s, 0);
    if ( v6 != 24 )
      goto LABEL_9;
  }
  else if ( BYTE1(v11) != 24 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v11 != 5 )
  {
LABEL_9:
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "%s chain %d failed!", "get_PIC16F1704_voltage_new", dword_7909C);
    goto LABEL_13;
  }
  v8 = BYTE2(v11);
  v9 = BYTE2(v11) + 29;
  if ( HIBYTE(v11) != v9 >> 8 || v12 != (unsigned __int8)v9 )
  {
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "%s failed! crc = 0x%04x", "get_PIC16F1704_voltage_new", BYTE2(v11) + 29);
LABEL_13:
    sub_38730(3, s, 0);
    return 0;
  }
  *a1 = BYTE2(v11);
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok, voltage = 0x%02x", "get_PIC16F1704_voltage_new", v8);
  sub_38730(5, s, 0);
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040888) --------------------------------------------------------
int __fastcall sub_40888(int a1)
{
  int v1; // r3
  __int16 v2; // r2
  __int16 v3; // r12
  int v4; // r1
  _DWORD *v5; // r3
  char v6; // t1
  char *v7; // r4
  int v8; // t1
  int v9; // r4
  int v10; // r5
  int result; // r0
  char v12; // [sp+7h] [bp-1011h] BYREF
  _DWORD v13[2]; // [sp+8h] [bp-1010h] BYREF
  int v14; // [sp+10h] [bp-1008h] BYREF
  __int16 v15; // [sp+14h] [bp-1004h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v1 = 0;
  v2 = 46;
  v13[1] = 0;
  v13[0] = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a1 + v1++);
    v2 += v3;
  }
  while ( v1 != 8 );
  v4 = a1 - 1;
  v5 = (_DWORD *)((char *)v13 + 3);
  v13[0] = 571255381;
  do
  {
    v6 = *(_BYTE *)++v4;
    *((_BYTE *)v5 + 1) = v6;
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v14 + 3) );
  LOBYTE(v15) = HIBYTE(v2);
  v7 = &v12;
  HIBYTE(v15) = v2;
  pthread_mutex_lock(&stru_790A0);
  do
  {
    v8 = (unsigned __int8)*++v7;
    sub_3C7B0(v8);
  }
  while ( v7 != (char *)&v15 + 1 );
  usleep(0x30D40u);
  v9 = sub_3C7C8();
  v10 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( v9 == 34 && v10 == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "write_temperature_offset_PIC16F1704_new");
      sub_38730(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "write_temperature_offset_PIC16F1704_new",
      v9,
      v10);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040A84) --------------------------------------------------------
int __fastcall sub_40A84(int a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  char *v5; // r4
  int v6; // r5
  int result; // r0
  char v8; // r3
  unsigned int v9; // r2
  int v10; // r6
  char *j; // r2
  char v12; // t1
  _BYTE v13[3]; // [sp+34h] [bp-1014h] BYREF
  char v14[4]; // [sp+37h] [bp-1011h] BYREF
  char v15; // [sp+3Bh] [bp-100Dh] BYREF
  int v16; // [sp+3Ch] [bp-100Ch] BYREF
  int v17; // [sp+40h] [bp-1008h]
  int v18; // [sp+44h] [bp-1004h] BYREF
  char s[4088]; // [sp+48h] [bp-1000h] BYREF

  v17 = 0;
  v18 = 0;
  v16 = 255;
  v14[2] = 39;
  v13[2] = 4;
  v13[1] = -86;
  v2 = v13;
  strcpy(v14, "#");
  v13[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v2 == &v14[2] )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x30D40u);
  v5 = &v15;
  do
    *++v5 = sub_3C7C8();
  while ( v5 != (char *)&v18 + 3 );
  pthread_mutex_unlock(&stru_790A0);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    v6 = BYTE1(v16);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\tre"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
      "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
      "read_temperature_offset_PIC16F1704_new",
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16),
      (unsigned __int8)v17,
      BYTE1(v17),
      BYTE2(v17),
      HIBYTE(v17),
      (unsigned __int8)v18,
      BYTE1(v18),
      BYTE2(v18),
      HIBYTE(v18));
    sub_38730(5, s, 0);
    if ( v6 != 35 )
      goto LABEL_9;
  }
  else if ( BYTE1(v16) != 35 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v16 != 12 )
  {
LABEL_9:
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "%s failed!", "read_temperature_offset_PIC16F1704_new");
    goto LABEL_13;
  }
  v8 = BYTE2(v16);
  v9 = BYTE1(v18)
     + (unsigned __int8)v18
     + HIBYTE(v17)
     + BYTE2(v17)
     + BYTE1(v17)
     + (unsigned __int8)v17
     + BYTE2(v16)
     + HIBYTE(v16)
     + 47;
  if ( BYTE2(v18) != v9 >> 8 || HIBYTE(v18) != (unsigned __int8)v9 )
  {
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(
      s,
      0x1000u,
      "%s failed! crc = 0x%04x",
      "read_temperature_offset_PIC16F1704_new",
      BYTE1(v18)
    + (unsigned __int8)v18
    + HIBYTE(v17)
    + BYTE2(v17)
    + BYTE1(v17)
    + (unsigned __int8)v17
    + BYTE2(v16)
    + HIBYTE(v16)
    + 47);
LABEL_13:
    sub_38730(3, s, 0);
    return 0;
  }
  v10 = a1 - 1;
  for ( j = (char *)&v16 + 2; ; ++j )
  {
    *(_BYTE *)++v10 = v8;
    if ( j == (char *)&v18 + 1 )
      break;
    v12 = j[1];
    v8 = v12;
  }
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok", "read_temperature_offset_PIC16F1704_new");
  sub_38730(5, s, 0);
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040DEC) --------------------------------------------------------
int sub_40DEC()
{
  int v0; // r4
  int result; // r0
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  sub_3D000(6, 0);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash_new", 76);
    sub_38730(5, s, 0);
  }
  v0 = 76;
  do
  {
    result = sub_3DA84();
    --v0;
  }
  while ( v0 );
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00040E94) --------------------------------------------------------
void sub_40E94()
{
  FILE *v0; // r0
  FILE *v1; // r5
  _BYTE *v2; // r4
  __int16 v3; // r0
  int i; // r10
  int *v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int j; // r9
  char nptr[8]; // [sp+10h] [bp-23A4h] BYREF
  int v12; // [sp+18h] [bp-239Ch] BYREF
  int v13; // [sp+1Ch] [bp-2398h]
  int v14; // [sp+20h] [bp-2394h]
  int v15; // [sp+24h] [bp-2390h]
  char s[4056]; // [sp+28h] [bp-238Ch] BYREF
  _BYTE v17[5000]; // [sp+1028h] [bp-138Ch] BYREF

  memset(v17, 0, sizeof(v17));
  v13 = 0;
  nptr[0] = 0;
  v14 = 0;
  v12 = 0;
  v15 = 0;
  nptr[1] = 0;
  nptr[2] = 0;
  nptr[3] = 0;
  nptr[4] = 0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(s, "PIC1704_update_pic_app_program_new");
    sub_38730(5, s, 0);
  }
  v0 = fopen("/sbin/pic.txt", "r");
  v1 = v0;
  if ( !v0 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      snprintf(s, 0x1000u, "%s: open pic16f1704_app_new.txt failed\n", "PIC1704_update_pic_app_program_new");
      sub_38730(3, s, 0);
    }
    return;
  }
  fseek(v0, 0, 0);
  memset(v17, 0, sizeof(v17));
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s: pic_flash_length = %d\n", "PIC1704_update_pic_app_program_new", 2432);
    sub_38730(5, s, 0);
  }
  v2 = v17;
  do
  {
    fgets(nptr, 1023, v1);
    v3 = strtoul(nptr, 0, 16);
    v2[1] = v3;
    *v2 = HIBYTE(v3);
    v2 += 2;
  }
  while ( v2 != &v17[4864] );
  fclose(v1);
  if ( !sub_3DF78() )
  {
LABEL_11:
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      snprintf(s, 0x1000u, "%s: reset pic error!\n\n", "PIC1704_update_pic_app_program_new");
LABEL_15:
      sub_38730(3, s, 0);
      return;
    }
    return;
  }
  if ( sub_40DEC() )
  {
    if ( !sub_3D000(6, 0) )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf(s, 0x1000u, "%s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program_new");
        goto LABEL_15;
      }
      return;
    }
    for ( i = 0; i != 304; ++i )
    {
      v5 = (int *)&v17[16 * i];
      v6 = *v5;
      v7 = v5[1];
      v8 = v5[2];
      v9 = v5[3];
      v12 = v6;
      v13 = v7;
      v14 = v8;
      v15 = v9;
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "send pic program time: %d", i);
        sub_38730(5, s, 0);
      }
      for ( j = 0; j != 16; ++j )
      {
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(s, 0x1000u, "buf[%d] = 0x%02x", j, *((unsigned __int8 *)&v12 + j));
          sub_38730(7, s, 0);
        }
      }
      sub_3D1AC((int)&v12);
      sub_3DC28();
    }
    if ( sub_3DF78() )
      return;
    goto LABEL_11;
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(s, 0x1000u, "%s: erase flash error!\n\n", "PIC1704_update_pic_app_program_new");
    goto LABEL_15;
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00041308) --------------------------------------------------------
int sub_41308()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v0 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "chain%d %s", i, "every_chain_reset_PIC16F1704_pic_new");
        sub_38730(5, s, 0);
      }
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      sub_3DF78();
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
  }
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (000413F0) --------------------------------------------------------
int sub_413F0()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v0 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "chain%d %s", i, "every_chain_jump_from_loader_to_app_PIC16F1704_new");
        sub_38730(5, s, 0);
      }
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      sub_3DDD0();
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
  }
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (000414D8) --------------------------------------------------------
int sub_414D8()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char v4[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(v4, "every_chain_disable_PIC16F1704_dc_dc_new");
    sub_38730(5, v4, 0);
  }
  v0 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      sub_3FC24();
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
  }
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (000415BC) --------------------------------------------------------
int sub_415BC()
{
  sub_414D8();
  sub_3A354();
  sub_2A92C();
  sub_2A414(dword_7C060);
  sub_2A414(dword_7C284);
  sub_2A414(dword_7C05C);
  return sub_2A414(dword_7C12C);
}
// 7C05C: using guessed type int dword_7C05C;
// 7C060: using guessed type int dword_7C060;
// 7C12C: using guessed type int dword_7C12C;
// 7C284: using guessed type int dword_7C284;

//----- (00041614) --------------------------------------------------------
void sub_41614()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char v3[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(v3, "every_chain_enable_PIC16F1704_dc_dc_new");
    sub_38730(5, v3, 0);
  }
  v0 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      sub_3FA7C();
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (000416EC) --------------------------------------------------------
int sub_416EC()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9D4AC = (int)calloc(1u, 0x40u);
  if ( !sub_2F174(dword_9D4AC, 0, (void *(*)(void *))sub_40034, (void *)dword_9D4AC) )
    return pthread_detach(*(_DWORD *)(dword_9D4AC + 12));
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(v1, 0x1000u, "%s: create thread error for pic_heart_beat_func", "send_heart_beat_to_every_chain");
    sub_38730(3, v1, 0);
  }
  return -3;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 9D4AC: using guessed type int dword_9D4AC;

//----- (000417B0) --------------------------------------------------------
pthread_mutex_t *sub_417B0()
{
  int v0; // r5
  int v1; // r3
  bool v2; // r3
  unsigned int v3; // r4
  _BOOL4 v4; // r3
  pthread_mutex_t *result; // r0
  int v6; // r6
  int v7; // r4
  int v8; // [sp+Ch] [bp-1008h]
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(s, "check_whether_need_update_pic_program");
    sub_38730(5, s, 0);
  }
  v0 = 0;
  v8 = 644283;
  do
  {
    v1 = *(unsigned __int8 *)++v8;
    if ( v1 != 1 )
      goto LABEL_6;
    pthread_mutex_lock(&stru_790D0);
    dword_7909C = v0;
    sub_3DF78();
    sub_2A92C();
    sub_3DDD0();
    sub_2A92C();
    v7 = sub_40128(&byte_790E8[v0]);
    sub_2A92C();
    pthread_mutex_unlock(&stru_790D0);
    if ( byte_790E8[v0] <= 0x80u )
      v2 = v7 == 1;
    else
LABEL_6:
      v2 = 0;
    v3 = 0;
    while ( 1 )
    {
      v4 = v3 <= 2 && v2;
      result = &stru_790D0;
      if ( !v4 )
        break;
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = v0;
      sub_40E94();
      sub_2A92C();
      sub_3DDD0();
      sub_2A92C();
      v3 = (unsigned __int8)(v3 + 1);
      v6 = sub_40128(&byte_790E8[v0]);
      pthread_mutex_unlock(&stru_790D0);
      sub_2A92C();
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "%s: Chain%d pic update for %d times", "check_whether_need_update_pic_program", v0, v3);
        sub_38730(5, s, 0);
      }
      v2 = 1;
      if ( byte_790E8[v0] == 129 )
        v2 = v6 == 0;
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 790E8: using guessed type unsigned __int8[4];
// 7AD48: using guessed type char byte_7AD48;

//----- (000419C8) --------------------------------------------------------
int __fastcall sub_419C8(unsigned int a1)
{
  char *v1; // r4
  int i; // r0
  int v3; // t1
  int v4; // r4
  int v5; // r5
  int result; // r0
  _BYTE v7[7]; // [sp+8h] [bp-1008h] BYREF
  char v8; // [sp+Fh] [bp-1001h] BYREF
  char s[4080]; // [sp+10h] [bp-1000h] BYREF

  v7[5] = a1;
  v7[1] = -86;
  v7[3] = 36;
  v8 = BYTE1(a1) + a1 + 42;
  v7[4] = BYTE1(a1);
  v7[6] = (unsigned __int16)((a1 >> 8) + (unsigned __int8)a1 + 42) >> 8;
  v1 = v7;
  v7[0] = 85;
  v7[2] = 6;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v3 )
  {
    sub_3C7B0(i);
    if ( v1 == &v8 )
      break;
    v3 = (unsigned __int8)*++v1;
  }
  usleep(0x493E0u);
  v4 = sub_3C7C8();
  v5 = sub_3C7C8();
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( v4 == 36 && v5 == 1 )
  {
    if ( byte_78E09 )
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
        return 1;
      snprintf(s, 0x1000u, "\n--- %s ok\n\n", "save_freq_PIC16F1704_new");
      sub_38730(7, s, 0);
    }
    return 1;
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "save_freq_PIC16F1704_new",
      v4,
      v5);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00041B8C) --------------------------------------------------------
int __fastcall sub_41B8C(_WORD *a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  char *v5; // r4
  int v6; // r5
  int result; // r0
  unsigned int v8; // r3
  int v9; // r2
  char v10; // [sp+17h] [bp-1015h] BYREF
  int v11; // [sp+18h] [bp-1014h]
  __int16 v12; // [sp+1Ch] [bp-1010h] BYREF
  _BYTE v13[3]; // [sp+20h] [bp-100Ch] BYREF
  char v14[5]; // [sp+23h] [bp-1009h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  v13[1] = -86;
  v11 = 255;
  v12 = 0;
  v2 = v13;
  v13[2] = 4;
  strcpy(v14, "%");
  v14[2] = 41;
  v13[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C7B0(i);
    if ( v2 == &v14[2] )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x493E0u);
  v5 = &v10;
  do
    *++v5 = sub_3C7C8();
  while ( v5 != (char *)&v12 + 1 );
  pthread_mutex_unlock(&stru_790A0);
  usleep(0x30D40u);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    v6 = BYTE1(v11);
    snprintf(
      s,
      0x1000u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
      "get_PIC16F1704_freq_new",
      (unsigned __int8)v11,
      BYTE1(v11),
      BYTE2(v11),
      HIBYTE(v11),
      (unsigned __int8)v12,
      HIBYTE(v12));
    sub_38730(5, s, 0);
    if ( v6 != 37 )
      goto LABEL_9;
  }
  else if ( BYTE1(v11) != 37 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v11 != 6 )
  {
LABEL_9:
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "\n--- %s failed!\n\n", "get_PIC16F1704_freq_new");
    goto LABEL_13;
  }
  v8 = BYTE2(v11) + HIBYTE(v11) + 43;
  if ( (unsigned __int8)v12 != v8 >> 8 || HIBYTE(v12) != (unsigned __int8)v8 )
  {
    if ( !byte_7AD48 )
    {
      result = (unsigned __int8)byte_78E08;
      if ( !byte_78E08 && dword_766C4 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq_new", BYTE2(v11) + HIBYTE(v11) + 43);
LABEL_13:
    sub_38730(3, s, 0);
    return 0;
  }
  v9 = HIBYTE(v11) | (BYTE2(v11) << 8);
  *a1 = _byteswap_ushort(HIWORD(v11));
  if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "\n--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq_new", v9);
  sub_38730(5, s, 0);
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00041E7C) --------------------------------------------------------
int __fastcall sub_41E7C(unsigned __int8 *src, char a2, signed int n)
{
  signed int v4; // r3
  __int16 v5; // r4
  __int16 v6; // r12
  char *v7; // r3
  int v8; // r6
  int v9; // r3
  unsigned __int8 i; // r4
  char *v11; // r4
  int result; // r0
  char v13; // [sp+13h] [bp-1021h] BYREF
  int v14; // [sp+14h] [bp-1020h]
  char v15; // [sp+18h] [bp-101Ch] BYREF
  _BYTE v16[20]; // [sp+1Ch] [bp-1018h] BYREF
  char s[4100]; // [sp+30h] [bp-1004h] BYREF

  v4 = 0;
  memset(&v16[4], 0, 13);
  v5 = 2 * n + 57;
  v14 = 255;
  v15 = 0;
  if ( n > 0 )
  {
    do
    {
      v6 = src[v4];
      v4 = (unsigned __int8)(v4 + 1);
      v5 += v6;
    }
    while ( n > v4 );
  }
  v16[4] = a2;
  v16[5] = n;
  v16[0] = 85;
  v16[2] = n + 6;
  v16[1] = -86;
  v16[3] = 51;
  memcpy(&v16[6], src, n);
  v7 = &s[n + 4096];
  v8 = n + 8;
  v7 -= 4096;
  *(v7 - 13) = v5;
  *(v7 - 14) = HIBYTE(v5);
  pthread_mutex_lock(&stru_790A0);
  if ( v8 > 0 )
  {
    v9 = 0;
    for ( i = 0; i < v8; v9 = ++i )
      sub_3C7B0((unsigned __int8)v16[v9]);
  }
  usleep(0x30D40u);
  v11 = &v13;
  do
    *++v11 = sub_3C7C8();
  while ( v11 != &v15 );
  pthread_mutex_unlock(&stru_790A0);
  if ( (unsigned __int8)v14 == 5 && BYTE1(v14) == 51 && (result = BYTE2(v14), BYTE2(v14) == 1) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "\n--- %s ok\n\n", "write_data_to_PIC16F1704_flash");
      sub_38730(7, s, 0);
      return 1;
    }
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
      "write_data_to_PIC16F1704_flash",
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14));
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (00042100) --------------------------------------------------------
int __fastcall sub_42100(void *a1, char a2, size_t a3)
{
  char *v5; // r4
  int i; // r0
  int v7; // t1
  signed int v8; // r5
  signed int v9; // r9
  signed int v10; // r4
  int v11; // r4
  int result; // r0
  __int16 v13; // r2
  signed int v14; // r3
  unsigned int v15; // r1
  _BYTE v16[7]; // [sp+8h] [bp-8h] BYREF
  char v17; // [sp+Fh] [bp-1h] BYREF
  _DWORD v18[10]; // [sp+10h] [bp+0h] BYREF
  char s[4040]; // [sp+38h] [bp+28h] BYREF

  v17 = a3 + 58;
  memset(&v18[1], 0, 36);
  v18[0] = 255;
  v16[6] = (unsigned __int16)(a3 + 58) >> 8;
  v16[4] = a2;
  v16[1] = -86;
  v5 = v16;
  v16[5] = a3;
  v16[2] = 6;
  v16[3] = 52;
  v16[0] = 85;
  pthread_mutex_lock(&stru_790A0);
  for ( i = 85; ; i = v7 )
  {
    sub_3C7B0(i);
    if ( v5 == &v17 )
      break;
    v7 = (unsigned __int8)*++v5;
  }
  usleep(0x30D40u);
  v8 = 0;
  v9 = a3 + 4;
  LOBYTE(v10) = 0;
  do
  {
    v10 = (unsigned __int8)(v10 + 1);
    *((_BYTE *)v18 + v8) = sub_3C7C8();
    v8 = v10;
  }
  while ( v10 <= v9 );
  v11 = BYTE1(v18[0]);
  pthread_mutex_unlock(&stru_790A0);
  if ( v11 != 52 )
    return 0;
  v13 = LOBYTE(v18[0]);
  if ( LOBYTE(v18[0]) != a3 + 5 || BYTE2(v18[0]) != 1 )
    return 0;
  LOBYTE(v14) = 0;
  LOWORD(v15) = 0;
  while ( 1 )
  {
    v14 = (unsigned __int8)(v14 + 1);
    v15 = (unsigned __int16)(v15 + v13);
    if ( v14 > (int)(a3 + 2) )
      break;
    v13 = *((unsigned __int8 *)v18 + v14);
  }
  if ( *((unsigned __int8 *)v18 + a3 + 3) == v15 >> 8 && *((unsigned __int8 *)v18 + v9) == (unsigned __int8)v15 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "\n--- %s ok\n\n", "read_data_from_PIC16F1704_flash");
      sub_38730(7, s, 0);
    }
    memcpy(a1, (char *)v18 + 3, a3);
    return 1;
  }
  else if ( byte_7AD48 || (result = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 2 )
  {
    snprintf(s, 0x1000u, "\n--- %s failed! crc = 0x%04x\n\n", "read_data_from_PIC16F1704_flash", v15);
    sub_38730(3, s, 0);
    return 0;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (000425C0) --------------------------------------------------------
int __fastcall sub_425C0(unsigned int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s %u", "set freq:", a1);
    sub_38730(5, s, 0);
  }
  v2 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      sub_419C8(a1);
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
  }
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (00042820) --------------------------------------------------------
int sub_42820()
{
  int v0; // r4
  char v2; // [sp+6h] [bp-2Eh] BYREF
  char v3; // [sp+7h] [bp-2Dh] BYREF
  _DWORD v4[2]; // [sp+8h] [bp-2Ch] BYREF
  _DWORD v5[2]; // [sp+10h] [bp-24h] BYREF
  _DWORD v6[3]; // [sp+18h] [bp-1Ch] BYREF
  _DWORD v7[4]; // [sp+24h] [bp-10h] BYREF

  v2 = 0;
  v0 = 0;
  v3 = 0;
  v6[0] = 218893066;
  v6[1] = 286265102;
  v6[2] = 353637138;
  memset(v7, 0, 12);
  v5[0] = 0;
  v5[1] = 0;
  v4[0] = 387323156;
  v4[1] = 454695192;
  sub_3DF78();
  sub_40E94();
  sub_3DDD0();
  sub_40128(&v2);
  sub_3F4BC((int)v6);
  sub_3F6CC((int)v7);
  sub_40888((int)v4);
  sub_40A84((int)v5);
  sub_3F308(120);
  sub_405AC(&v3);
  sub_3FA7C();
  sub_3FA7C();
  sub_3FDC4();
  usleep(0x1E8480u);
  sub_3FDC4();
  usleep(0x1E8480u);
  sub_3FDC4();
  usleep(0x1E8480u);
  do
  {
    printf("i = %d\n", v0++);
    usleep(0x1E8480u);
  }
  while ( v0 != 35 );
  sub_3FDC4();
  usleep(0x1E8480u);
  sub_3FDC4();
  usleep(0x1E8480u);
  sub_3FDC4();
  return usleep(0x1E8480u);
}

//----- (00042958) --------------------------------------------------------
int __fastcall sub_42958(int a1, int a2)
{
  int result; // r0

  switch ( a2 % 8 )
  {
    case 0:
      result = *(_BYTE *)(a1 + a2 / 8) & 1;
      break;
    case 1:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 1) & 1;
      break;
    case 2:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 2) & 1;
      break;
    case 3:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 3) & 1;
      break;
    case 4:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 4) & 1;
      break;
    case 5:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 5) & 1;
      break;
    case 6:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 6) & 1;
      break;
    case 7:
      result = *(unsigned __int8 *)(a1 + a2 / 8) >> 7;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 42974: control flows out of bounds to 42978

//----- (00042A60) --------------------------------------------------------
int __fastcall sub_42A60(_BYTE *a1, int a2)
{
  int v2; // r2
  unsigned __int8 *v4; // r2
  char v5; // r1
  unsigned int v6; // r3
  int v7; // t1
  char v8[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( a2 == 146 )
  {
    v4 = a1 + 2;
    v5 = a1[2];
    v6 = 0xFFFF;
    *a1 = 85;
    a1[2] = v5 & 0x1F | 0x20;
    a1[1] = -86;
    do
    {
      v7 = *v4++;
      v6 = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v7 ^ (v6 >> 8)) + 404] ^ ((_WORD)v6 << 8));
    }
    while ( v4 != a1 + 144 );
    v2 = 146;
    *((_WORD *)a1 + 72) = (v6 >> 8) | ((_WORD)v6 << 8);
  }
  else if ( byte_7AD48 || (v2 = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 3 )
  {
    snprintf(v8, 0x1000u, "%s len error\n", "bm1740_makeup_work");
    sub_38730(4, v8, 0);
    return 0;
  }
  return v2;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00042B54) --------------------------------------------------------
int __fastcall sub_42B54(unsigned __int8 *a1)
{
  pthread_t v2; // r0
  int v3; // r8
  int v4; // r5
  int v5; // r10
  char *v6; // r3
  int v7; // r3
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r11
  int v13; // [sp+Ch] [bp-10B8h]
  int *v14; // [sp+14h] [bp-10B0h]
  struct timeval v15; // [sp+1Ch] [bp-10A8h] BYREF
  struct timeval v16; // [sp+24h] [bp-10A0h] BYREF
  _BYTE v17[148]; // [sp+2Ch] [bp-1098h] BYREF
  char s[4096]; // [sp+C0h] [bp-1004h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *(_DWORD *)a1;
  v4 = a1[4];
  v14 = *(int **)(*(_DWORD *)a1 + 630);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "Start To Fill Work!ChainIndex:[%d]", v4);
    sub_38730(7, s, 0);
  }
  sub_2A84C(&v15);
  v5 = 0;
  sub_2A84C(&v16);
LABEL_7:
  while ( 1 )
  {
    v6 = (char *)&dword_78E10 + v4;
    if ( *((_BYTE *)&dword_78E10 + v4 + 748) )
      return 0;
    while ( 1 )
    {
      if ( !v6[732] || byte_790F0 || byte_78E28 )
      {
        sub_2A92C();
        goto LABEL_7;
      }
      sub_2A84C(&v15);
      v7 = v15.tv_usec - v16.tv_usec + (v15.tv_usec - v16.tv_usec < 0 ? 0xF4000 : 0);
      if ( v15.tv_usec - v16.tv_usec < 0 )
        v7 += 576;
      v8 = v15.tv_sec - v16.tv_sec;
      if ( v15.tv_usec - v16.tv_usec < 0 )
        --v8;
      if ( !*((_BYTE *)&dword_78E10 + v4 + 4) && v7 + 1000000 * v8 < (unsigned int)dword_9D4C4 )
        break;
      sub_2A84C(&v16);
      while ( 1 )
      {
        v9 = sub_247D4((int)v14, *v14);
        if ( v9 )
          break;
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf(s, 0x1000u, "Work Error![%d]", v5);
          sub_38730(3, s, 0);
        }
      }
      v10 = v9;
      v11 = *(_DWORD *)(v9 + 1828) & 0x7F;
      *((_BYTE *)&dword_78E10 + v4 + 4) = 0;
      v5 = (unsigned __int8)v11;
      memset(v17, 0, 0x92u);
      v17[2] = 32;
      v17[3] = v11;
      memcpy(&v17[4], (const void *)(v10 + 224), 0x8Cu);
      v13 = v3 + 4 * (v11 + 28);
      sub_42A60(v17, 146);
      pthread_mutex_lock(&stru_78EA0);
      if ( *(_DWORD *)(v13 + 6) )
      {
        sub_15780(*(void ***)(v13 + 6));
        *(_WORD *)(v13 + 6) = 0;
        *(_WORD *)(v13 + 8) = 0;
      }
      *(_DWORD *)(v3 + 4 * (v11 + 28) + 6) = sub_1A44C(v10, 0);
      pthread_mutex_unlock(&stru_78EA0);
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(s, 0x1000u, "ChainID[%d] Wirte Work. workid=%d, jobid=%s", v4, v11, *(const char **)(v10 + 1776));
        sub_38730(7, s, 0);
      }
      sub_3C150(v4, v17, 0x92u);
      byte_790F1 = 1;
      sub_2A84C((struct timeval *)&dword_790F4);
      sub_2A954();
      sub_15780((void **)v10);
      v6 = (char *)&dword_78E10 + v4;
      if ( *((_BYTE *)&dword_78E10 + v4 + 748) )
        return 0;
    }
    sub_2A954();
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E10: using guessed type int dword_78E10;
// 78E28: using guessed type char byte_78E28;
// 790F0: using guessed type char byte_790F0;
// 790F1: using guessed type char byte_790F1;
// 790F4: using guessed type int dword_790F4;
// 7AD48: using guessed type char byte_7AD48;
// 9D4C4: using guessed type int dword_9D4C4;

//----- (00042F04) --------------------------------------------------------
size_t __fastcall sub_42F04(unsigned __int8 a1)
{
  size_t v2; // r0
  int v4; // [sp+0h] [bp-8h] BYREF
  __int16 v5; // [sp+4h] [bp-4h]
  char v6; // [sp+6h] [bp-2h]

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v2 = sub_3CD58((int)&v4);
  return sub_3C150(a1, &v4, v2);
}

//----- (00042F40) --------------------------------------------------------
size_t __fastcall sub_42F40(unsigned __int8 a1, unsigned __int8 a2)
{
  size_t v3; // r0
  int v5; // [sp+0h] [bp-8h] BYREF
  __int16 v6; // [sp+4h] [bp-4h]
  char v7; // [sp+6h] [bp-2h]

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v3 = sub_3CE7C((int)&v5, a2);
  return sub_3C150(a1, &v5, v3);
}

//----- (00042F7C) --------------------------------------------------------
int __fastcall sub_42F7C(int a1)
{
  unsigned __int8 v1; // r5
  int v2; // r4
  unsigned __int8 v3; // r1
  int result; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  v1 = a1;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chainID%d asics %d addrInterval %d",
      "software_set_address_chain",
      a1,
      *((unsigned __int8 *)&unk_9D4B4 + a1 + 529),
      (unsigned __int8)byte_9D6F3);
    sub_38730(5, s, 0);
  }
  v2 = 0;
  sub_42F04(v1);
  sub_2A92C();
  do
  {
    v3 = v2++ * byte_9D6F3;
    sub_42F40(v1, v3);
    result = sub_2A92C();
  }
  while ( v2 != 3 );
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 9D6F3: using guessed type char byte_9D6F3;

//----- (00043060) --------------------------------------------------------
int sub_43060()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1

  v0 = 0;
  v1 = 644283;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
      sub_42F7C(v0);
    ++v0;
  }
  while ( v0 != 4 );
  return sub_2A92C();
}

//----- (000430A0) --------------------------------------------------------
int __fastcall sub_430A0(int a1, unsigned int a2)
{
  _DWORD v5[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v6; // [sp+14h] [bp-1008h]
  char v7; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v5[1] = 0;
  v6 = 0;
  v5[0] = 0;
  v7 = 0;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "chainid%d %s: core timeout = %08x", a1, "set_core_timeout_chain", a2);
    sub_38730(7, s, 0);
  }
  dword_76B4C = a2;
  sub_3CDCC((int)v5, 1, 0, 40, a2);
  sub_3C150(a1, v5, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B4C: using guessed type int dword_76B4C;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (000431AC) --------------------------------------------------------
int __fastcall sub_431AC(int a1, int a2)
{
  unsigned int v3; // r4
  _DWORD v5[2]; // [sp+Ch] [bp-100Ch] BYREF
  __int16 v6; // [sp+14h] [bp-1004h]
  char v7; // [sp+16h] [bp-1002h]
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v5[1] = 0;
  v6 = 0;
  v5[0] = 0;
  v3 = (unsigned __int8)a2 << 27;
  v7 = 0;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "chainid%d %s: nonce shift = %08x", a1, "set_nonce_shift_chain", a2);
    sub_38730(7, s, 0);
  }
  dword_76B50 = v3;
  sub_3CDCC((int)v5, 1, 0, 80, v3);
  sub_3C150(a1, v5, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B50: using guessed type int dword_76B50;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (000432C0) --------------------------------------------------------
int __fastcall sub_432C0(unsigned int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1

  v2 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      sub_430A0(i, a1);
  }
  return sub_2A92C();
}

//----- (0004330C) --------------------------------------------------------
int __fastcall sub_4330C(int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1

  v2 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      sub_431AC(i, a1);
  }
  return sub_2A92C();
}

//----- (00043358) --------------------------------------------------------
int __fastcall sub_43358(int a1)
{
  int v2; // r4
  _DWORD v4[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v5; // [sp+14h] [bp-1008h]
  char v6; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v4[1] = 0;
  v4[0] = 0;
  v5 = 0;
  v2 = dword_76B54 & 0xFFFF0FFF | 0x3000;
  v6 = 0;
  dword_76B54 = v2;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "chainid%d %s: IO drive = %08x", a1, "set_io_drive_strength_chain", v2);
    sub_38730(5, s, 0);
  }
  sub_3CDCC((int)v4, 1, 0, 48, v2);
  sub_3C150(a1, v4, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B54: using guessed type int dword_76B54;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0004345C) --------------------------------------------------------
int sub_4345C()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1

  v0 = 0;
  v1 = 644283;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
      sub_43358(v0);
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
  return sub_2A92C();
}

//----- (000434A0) --------------------------------------------------------
int __fastcall sub_434A0(int a1, char a2)
{
  unsigned int v3; // r4
  _DWORD v5[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v6; // [sp+14h] [bp-1008h]
  char v7; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v5[1] = 0;
  v6 = 0;
  v5[0] = 0;
  v3 = a2 & 7;
  v7 = 0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "chainid%d %s: analog mux = %08x", a1, "set_analog_mux_control_chain", v3);
    sub_38730(5, s, 0);
  }
  sub_3CDCC((int)v5, 1, 0, 64, v3);
  sub_3C150(a1, v5, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00043594) --------------------------------------------------------
int __fastcall sub_43594(char a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1

  v2 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      sub_434A0(i, a1);
  }
  return sub_2A92C();
}

//----- (000435E0) --------------------------------------------------------
int __fastcall sub_435E0(int a1, int a2)
{
  int v4; // r2
  int v5; // r12
  int v6; // lr
  _DWORD v8[2]; // [sp+Ch] [bp-100Ch] BYREF
  __int16 v9; // [sp+14h] [bp-1004h]
  char v10; // [sp+16h] [bp-1002h]
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v8[1] = 0;
  v8[0] = 0;
  v9 = 0;
  v10 = 0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "chainid%d %s freq=%d", a1, "set_frequency_chain", a2);
    sub_38730(5, s, 0);
  }
  v4 = 0;
  while ( 1 )
  {
    v5 = *(_DWORD *)&aD_0[16 * v4];
    v6 = 16 * v4++;
    if ( a2 == v5 )
      break;
    if ( v4 == 115 )
    {
      v6 = 64;
      break;
    }
  }
  dword_76B58 = *(_DWORD *)&aResetAllHashBo[v6 + 2232];
  sub_3CDCC((int)v8, 1, 0, 12, dword_76B58);
  sub_3C150(a1, v8, 0xBu);
  *(_WORD *)((char *)&unk_9D4B4 + 2 * a1 + 593) = a2;
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B58: using guessed type int dword_76B58;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00043734) --------------------------------------------------------
int __fastcall sub_43734(int a1, int a2, int a3)
{
  char v4; // r6
  int v6; // r3
  int v7; // r12
  int v8; // r2
  _DWORD v10[2]; // [sp+14h] [bp-100Ch] BYREF
  __int16 v11; // [sp+1Ch] [bp-1004h]
  char v12; // [sp+1Eh] [bp-1002h]
  char s[4064]; // [sp+20h] [bp-1000h] BYREF

  v4 = a2;
  v10[1] = 0;
  v10[0] = 0;
  v11 = 0;
  v12 = 0;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "%s %d %d freq=%d\n", "set_freq_asic", a1, a2, a3);
    sub_38730(7, s, 0);
  }
  v6 = 0;
  while ( 1 )
  {
    v7 = *(_DWORD *)&aD_0[16 * v6];
    v8 = 16 * v6++;
    if ( a3 == v7 )
      break;
    if ( v6 == 115 )
    {
      v8 = 64;
      break;
    }
  }
  sub_3CDCC((int)v10, 0, byte_9D6F3 * v4, 12, *(_DWORD *)&aResetAllHashBo[v8 + 2232]);
  sub_3C150(a1, v10, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 9D6F3: using guessed type char byte_9D6F3;

//----- (0004388C) --------------------------------------------------------
void __noreturn sub_4388C()
{
  int v0; // lr
  _DWORD *v1; // r12
  int *v2; // r0
  unsigned __int8 *v3; // r5
  int v4; // t1
  int v5; // r3
  int v6; // r1
  int v7; // r3
  int v8; // r4
  int v9; // r3
  int v10; // r6
  int *v11; // r11
  int *v12; // r7
  int *v13; // r5
  _DWORD *v14; // r11
  int v15; // t1
  int v16; // r3
  const char *v17; // r2
  int v18; // r1
  const char *v19; // r0
  int v20; // r12
  int v21; // r12
  int i; // r3
  int v23; // r0
  int v24; // r3
  int v25; // r2
  int v27; // r2
  int *v28; // r7
  int v29; // r2
  unsigned __int8 *v30; // lr
  int v31; // t1
  int v32; // r1
  int *v33; // r1
  int v34; // r4
  char *v35; // r11
  int v36; // t1
  int v37; // r5
  int *v38; // r6
  int v39; // t1
  unsigned int v40; // r12
  unsigned int v41; // r3
  const char *v42; // r2
  int j; // r3
  int v44; // r1
  int v45; // r3
  int v46; // r2
  int v47; // [sp+18h] [bp-1074h]
  int v48; // [sp+1Ch] [bp-1070h]
  unsigned __int8 *v49; // [sp+20h] [bp-106Ch]
  _DWORD v50[12]; // [sp+28h] [bp-1064h] BYREF
  _DWORD v51[12]; // [sp+58h] [bp-1034h] BYREF
  char s[4088]; // [sp+88h] [bp-1004h] BYREF

  v0 = 0;
  v1 = v51;
  memset(v50, 0, sizeof(v50));
  v2 = dword_7C130;
  memset(v51, 0, sizeof(v51));
  v3 = (unsigned __int8 *)&unk_9D4BB;
  do
  {
    v4 = *++v3;
    if ( v4 == 1 )
    {
      v5 = v2[62];
      v6 = v2[61];
      *v1 = 775;
      LOWORD(v6) = v6 + v5;
      v7 = v2[63];
      v1[1] = 775;
      v1[2] = 775;
      *(_WORD *)((char *)&unk_9D4B4 + 2 * v0 + 593) = (__int16)(v6 + v7) / 3;
    }
    ++v0;
    v1 += 3;
    v2 += 3;
  }
  while ( v0 != 4 );
  while ( !byte_790EC )
LABEL_11:
    sub_2A92C();
  while ( 1 )
  {
    v8 = 0;
    v48 = 0;
    v49 = (unsigned __int8 *)&unk_9D4BB;
    do
    {
      v9 = *++v49;
      if ( v9 == 1 )
      {
        v10 = 0;
        v11 = &v50[3 * v8];
        v12 = &dword_7C130[3 * v8 + 61];
        v13 = &v51[3 * v8];
        v15 = *v11;
        v14 = v11 + 1;
        if ( !v15 )
        {
LABEL_13:
          v16 = *v12;
          if ( (unsigned int)*v12 <= 0x306 )
          {
            v27 = *v12;
            *v13 = v16;
            sub_43734((unsigned __int8)v8, (unsigned __int8)v10, v27);
            *(v14 - 1) = 1;
            goto LABEL_27;
          }
          if ( v16 == 775 )
          {
            *v13 = 775;
            sub_43734((unsigned __int8)v8, (unsigned __int8)v10, 775);
            *(v14 - 1) = 1;
            goto LABEL_27;
          }
          v17 = "d";
          v18 = 1;
          v19 = "d";
          while ( 1 )
          {
            v20 = *((_DWORD *)v19 + 4);
            v19 += 16;
            if ( v16 == v20 )
              break;
            if ( ++v18 == 115 )
            {
              v21 = *v13;
              v18 = -1;
              if ( *v13 == 100 )
              {
LABEL_33:
                i = 0;
                goto LABEL_22;
              }
LABEL_19:
              for ( i = 1; i != 115; ++i )
              {
                v23 = *((_DWORD *)v17 + 4);
                v17 += 16;
                if ( v21 == v23 )
                  goto LABEL_22;
              }
              i = -1;
LABEL_22:
              if ( v18 - i <= 1 )
                v24 = i + 1;
              else
                v24 = i + 2;
              v25 = *(_DWORD *)&aResetAllHashBo[16 * v24 + 2220];
              *v13 = v25;
              v47 = v25;
              sub_43734((unsigned __int8)v8, (unsigned __int8)v10, v25);
              if ( v47 == *v12 )
                *(v14 - 1) = 1;
              goto LABEL_27;
            }
          }
          v21 = *v13;
          if ( *v13 == 100 )
            goto LABEL_33;
          goto LABEL_19;
        }
        while ( 1 )
        {
          ++v48;
LABEL_27:
          ++v10;
          ++v13;
          ++v12;
          if ( v10 == 3 )
            break;
          if ( !*v14++ )
            goto LABEL_13;
        }
      }
      ++v8;
    }
    while ( v8 != 4 );
    if ( 3 * (unsigned __int8)byte_9D6CB <= v48 )
      break;
    sleep(3u);
    if ( !byte_790EC )
      goto LABEL_11;
  }
  v28 = dword_7C130;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(s, "All asics arrive target freq\n");
    sub_38730(5, s, 0);
  }
  v29 = 0;
  v30 = (unsigned __int8 *)&unk_9D4BB;
  do
  {
    while ( 1 )
    {
      v31 = *++v30;
      if ( v31 == 1 )
        break;
      ++v29;
      v28 += 3;
      if ( v29 == 4 )
        goto LABEL_42;
    }
    v32 = 3 * v29++;
    v33 = &dword_7C130[v32];
    v33[1] = 0;
    v33[25] = 0;
    v33[49] = 815;
    v33[37] = 775;
    v28[2] = 0;
    v28[26] = 0;
    v28[50] = 815;
    v28[38] = 775;
    v28[3] = 0;
    v28[27] = 0;
    v28[51] = 815;
    v28[39] = 775;
    v28 += 3;
  }
  while ( v29 != 4 );
  while ( 1 )
  {
    do
    {
LABEL_42:
      sleep(1u);
      pthread_mutex_lock(&stru_79100);
      pthread_cond_wait(&stru_7C078, &stru_79100);
      pthread_mutex_unlock(&stru_79100);
      v34 = (unsigned __int8)byte_78E3C;
    }
    while ( byte_78E3C );
    v35 = &byte_9D4BC;
    if ( byte_9D4BC == 1 )
    {
LABEL_46:
      v37 = 0;
      v38 = &dword_7C130[3 * v34 + 25];
      if ( *v38 == 1 )
      {
LABEL_49:
        v40 = v38[36];
        v41 = v38[12];
        if ( v40 > v41 )
        {
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
          {
            snprintf(
              s,
              0x1000u,
              "low freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
              v34,
              v37,
              v40,
              v41,
              v38[24],
              *(v38 - 24),
              1);
            sub_38730(5, s, 0);
            v40 = v38[36];
          }
          if ( v40 == 100 )
          {
            v45 = -1;
          }
          else
          {
            v42 = "d";
            for ( j = 1; j != 115; ++j )
            {
              v44 = *((_DWORD *)v42 + 4);
              v42 += 16;
              if ( v44 == v40 )
              {
                v45 = j - 1;
                goto LABEL_59;
              }
            }
            v45 = -2;
          }
LABEL_59:
          v46 = *(_DWORD *)&aResetAllHashBo[16 * v45 + 2220];
          v38[36] = v46;
          sub_43734((unsigned __int8)v34, (unsigned __int8)v37, v46);
        }
      }
      while ( ++v37 != 3 )
      {
        v39 = v38[1];
        ++v38;
        if ( v39 == 1 )
          goto LABEL_49;
      }
    }
    while ( ++v34 != 4 )
    {
      v36 = (unsigned __int8)*++v35;
      if ( v36 == 1 )
        goto LABEL_46;
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E3C: using guessed type char byte_78E3C;
// 790EC: using guessed type char byte_790EC;
// 7AD48: using guessed type char byte_7AD48;
// 7C130: using guessed type int dword_7C130[];
// 9D4BC: using guessed type char byte_9D4BC;
// 9D6CB: using guessed type char byte_9D6CB;

//----- (00043E4C) --------------------------------------------------------
int __fastcall sub_43E4C(int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1

  v2 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      sub_435E0(i, a1);
  }
  return sub_2A92C();
}

//----- (00043E98) --------------------------------------------------------
int __fastcall sub_43E98(int a1, char a2)
{
  _DWORD v4[2]; // [sp+Ch] [bp-10h] BYREF
  __int16 v5; // [sp+14h] [bp-8h]
  char v6; // [sp+16h] [bp-6h]

  dword_76B5C = dword_76B5C & 0xFFFFE0FF | ((a2 & 0x1F) << 8);
  v4[0] = 0;
  v4[1] = 0;
  v5 = 0;
  v6 = 0;
  sub_3CDCC((int)v4, 1, 0, 28, dword_76B5C);
  sub_3C150(a1, v4, 0xBu);
  return sub_2A92C();
}
// 76B5C: using guessed type int dword_76B5C;

//----- (00043F04) --------------------------------------------------------
int __fastcall sub_43F04(int a1)
{
  int v1; // r6
  char v2; // r7
  int v3; // r5
  int i; // r4
  int v5; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = (unsigned __int8)a1;
  v2 = a1;
  byte_9D6F5 = a1;
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "%s: bt8d = %d", "set_baud", a1);
    sub_38730(7, s, 0);
  }
  v3 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v5 = *(unsigned __int8 *)++v3;
    if ( v5 == 1 )
      sub_43E98(i, v2);
  }
  sleep(1u);
  sub_3BB44(v1);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 9D6F5: using guessed type char byte_9D6F5;

//----- (00044004) --------------------------------------------------------
int __fastcall sub_44004(int a1, int a2)
{
  unsigned __int8 v3; // r5
  _DWORD v5[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v6; // [sp+14h] [bp-1008h]
  char v7; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v3 = a2;
  v5[1] = 0;
  v5[0] = 0;
  v6 = 0;
  v7 = 0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s chainID%d ticket_mask = 0x%08x", "set_ticket_mask_chain", a1, a2);
    sub_38730(5, s, 0);
  }
  dword_76B60 = v3;
  sub_3CDCC((int)v5, 1, 0, 20, v3);
  sub_3C150(a1, v5, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B60: using guessed type int dword_76B60;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00044104) --------------------------------------------------------
int __fastcall sub_44104(int result)
{
  int v1; // r6
  int v2; // r5
  int i; // r4
  int v4; // t1

  v1 = result;
  v2 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      result = sub_44004(i, v1);
  }
  return result;
}

//----- (00044148) --------------------------------------------------------
int __fastcall sub_44148(int a1, int a2, int a3)
{
  char v4; // r7
  char v5; // r6
  _DWORD v7[2]; // [sp+14h] [bp-1010h] BYREF
  __int16 v8; // [sp+1Ch] [bp-1008h]
  char v9; // [sp+1Eh] [bp-1006h]
  char s[4064]; // [sp+20h] [bp-1004h] BYREF

  v7[1] = 0;
  v8 = 0;
  v4 = a2;
  v5 = a3;
  v7[0] = 0;
  v9 = 0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "chainID%d %s txndata %d txnzero %d", a1, "set_txn_data_chain", a2, a3);
    sub_38730(5, s, 0);
  }
  dword_76B64 = (2 * (v4 & 1)) | v5 & 1;
  sub_3CDCC((int)v7, 1, 0, 88, dword_76B64);
  sub_3C150(a1, v7, 0xBu);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B64: using guessed type int dword_76B64;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0004425C) --------------------------------------------------------
int __fastcall sub_4425C(int result, int a2)
{
  int v2; // r7
  int v3; // r5
  int i; // r4
  int v6; // t1

  v2 = result;
  v3 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v6 = *(unsigned __int8 *)++v3;
    if ( v6 == 1 )
      result = sub_44148(i, v2, a2);
  }
  return result;
}

//----- (000442A8) --------------------------------------------------------
unsigned int __fastcall sub_442A8(unsigned int a1)
{
  return a1 >> 7;
}

//----- (000442B0) --------------------------------------------------------
void sub_442B0()
{
  int v0; // r8
  int i; // r7
  int v3; // r4
  int v4; // r6
  unsigned int v5; // r4
  int v6; // r10
  int v7; // r12
  int v8; // r12
  int v9; // r3
  int v10; // r2
  int v11; // [sp+8h] [bp-100Ch]
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v0 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    if ( *(unsigned __int8 *)++v0 )
    {
      v3 = *(unsigned __int8 *)(v0 + 521);
      if ( *(_BYTE *)(v0 + 521) )
      {
        v4 = 0;
        v5 = 0;
        v11 = 8 * i;
        v6 = 19 * i + 644276;
        do
        {
          if ( (v5 & 7) == 0 )
          {
            v7 = v5 + v4;
            if ( (int)(v5 + v4) > 19 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
            {
              snprintf(s, 0x1000u, "offset[%d] ERR", v5 + v4);
              sub_38730(3, s, 0);
              v7 = v5 + v4;
            }
            v4 = (unsigned __int8)(v4 + 1);
            *(_BYTE *)(v6 + v7 + 355) = 32;
          }
          v8 = v5 + v4;
          if ( (int)(v5 + v4) > 19 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
          {
            snprintf(s, 0x1000u, "offset[%d] ERR", v5 + v4);
            sub_38730(3, s, 0);
            v8 = v5 + v4;
          }
          *(_BYTE *)(v6 + v8 + 355) = 111;
          v9 = 4 * (3 * i + v5 + 64) + 644276;
          v5 = (unsigned __int8)(v5 + 1);
          v10 = *(_DWORD *)(v9 + 4);
          *(_BYTE *)(v9 + 3) = 0;
          *(_DWORD *)(v9 + 4) = v10 & 0xFF000000;
        }
        while ( *(unsigned __int8 *)(v0 + 521) > v5 );
        v3 = v5 + v4;
        if ( v3 > 19 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(s, 0x1000u, "offset[%d] ERR", v3);
          sub_38730(3, s, 0);
        }
      }
      else
      {
        v11 = 8 * i;
      }
      *((_BYTE *)&unk_9D4B4 + 2 * v11 + 2 * i + i + v3 + 355) = 0;
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (000445E8) --------------------------------------------------------
int __fastcall sub_445E8(int result, int a2)
{
  int v2; // r4
  int v4; // r3
  int v5; // r7
  int v6; // [sp+8h] [bp-100Ch] BYREF
  char v7; // [sp+Ch] [bp-1008h]
  char s[4080]; // [sp+10h] [bp-1004h] BYREF

  v2 = result;
  if ( *((_BYTE *)&unk_9D4B4 + result + 8) )
  {
    v4 = (unsigned __int8)byte_7AD48;
    dword_7C064[result] = result;
    if ( v4 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s chainid = %d", "tty_init_chain", result);
      sub_38730(5, s, 0);
    }
    *((_BYTE *)&dword_78E10 + v2 + 776) = 1;
    if ( sub_2F174(a2 + (v2 << 6) + 890, 0, (void *(*)(void *))sub_4B0C0, &dword_7C064[v2]) )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
      {
        snprintf(s, 0x1000u, "create rx read thread for chain %d failed", v2);
        goto LABEL_11;
      }
    }
    else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      snprintf(s, 0x1000u, "create rx read thread for chain %d ok", v2);
LABEL_11:
      sub_38730(3, s, 0);
    }
    sub_2A92C();
    v6 = a2;
    v7 = v2;
    v5 = sub_2F174(a2 + (v2 << 6) + 634, 0, (void *(*)(void *))sub_42B54, &v6);
    sub_2A92C();
    if ( v5 )
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
        goto LABEL_22;
      snprintf(s, 0x1000u, "create tx read thread for chain %d failed", v2);
    }
    else
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
        goto LABEL_22;
      snprintf(s, 0x1000u, "create tx read thread for chain %d ok", v2);
    }
    sub_38730(3, s, 0);
    if ( byte_7AD48 || byte_78E08 )
    {
LABEL_19:
      strcpy(s, "open device over");
      sub_38730(5, s, 0);
      return sub_2A92C();
    }
LABEL_22:
    if ( dword_766C4 <= 4 )
      return sub_2A92C();
    goto LABEL_19;
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 7AD48: using guessed type char byte_7AD48;
// 7C064: using guessed type _DWORD dword_7C064[5];

//----- (000448BC) --------------------------------------------------------
int __fastcall sub_448BC(int a1)
{
  int v2; // r4
  int v3; // r0
  char v5[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(v5, "tty_init");
    sub_38730(5, v5, 0);
  }
  v2 = 0;
  do
  {
    v3 = v2;
    v2 = (unsigned __int8)(v2 + 1);
    sub_445E8(v3, a1);
  }
  while ( v2 != 4 );
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00044968) --------------------------------------------------------
size_t __fastcall sub_44968(unsigned __int8 a1, const void *a2, size_t a3)
{
  return sub_3C150(a1, a2, a3);
}

//----- (00044970) --------------------------------------------------------
int __fastcall sub_44970(unsigned __int8 a1, _BYTE *a2, unsigned int a3)
{
  return sub_3C5E8(a1, a2, a3);
}

//----- (00044978) --------------------------------------------------------
void sub_44978()
{
  int v0; // r4
  char *v1; // r5
  int v2; // r11
  int v3; // r12
  char s[4088]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(s, "check_chain");
    sub_38730(5, s, 0);
  }
  v0 = 0;
  byte_9D6CB = 0;
  v1 = (char *)&unk_9D4B4;
  v2 = *(_DWORD *)(dword_78E10[0] + 8);
  do
  {
    if ( ((v2 >> v0) & 1) != 0 )
    {
      v3 = (unsigned __int8)byte_7AD48;
      v1[8] = 1;
      ++byte_9D6CB;
      if ( v3 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "Chain %d existed!", v0);
        sub_38730(5, s, 0);
      }
    }
    else
    {
      v1[8] = 0;
    }
    ++v0;
    ++v1;
  }
  while ( v0 != 4 );
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10[];
// 7AD48: using guessed type char byte_7AD48;
// 9D6CB: using guessed type char byte_9D6CB;

//----- (00044AC0) --------------------------------------------------------
int __fastcall sub_44AC0(int a1)
{
  char s[100]; // [sp+4h] [bp-64h] BYREF

  byte_76B68 ^= 1u;
  if ( a1 )
  {
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", 0, 942);
    system(s);
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)byte_76B68, 941);
  }
  else
  {
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", 0, 941);
    system(s);
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)byte_76B68, 942);
  }
  return system(s);
}
// 76B68: using guessed type char byte_76B68;

//----- (00044B5C) --------------------------------------------------------
void __noreturn sub_44B5C()
{
  int v0; // r3
  int v1; // r3
  int v2; // r2
  int v3; // r0
  int v4; // r1
  int v5; // r5
  int v6; // r4
  unsigned int v7; // lr
  unsigned int v8; // lr
  int v9; // r0
  int v10; // r5
  int v11; // r4
  int v12; // t1
  int v13; // lr
  int v14; // r2
  int v15; // r1
  int v16; // r12
  _DWORD *v17; // r4
  _DWORD *v18; // lr
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r12
  _DWORD *v24; // r4
  _DWORD *v25; // lr
  int v26; // r0
  int v27; // r1
  int v28; // r2
  int v29; // r3
  int v30; // r5
  unsigned int v31; // r7
  unsigned int v32; // r9
  int v33; // r6
  unsigned int v35; // r4
  int v36; // r12
  int v37; // r7
  int v38; // r12
  int v39; // r9
  unsigned int v41; // r4
  int *v42; // r6
  int v43; // r5
  unsigned int v44; // r4
  int v45; // r10
  int v46; // r3
  bool v47; // zf
  int v48; // r3
  int v49; // r3
  char *v50; // r3
  int v51; // r2
  int v52; // [sp+24h] [bp-1048h]
  int v53; // [sp+24h] [bp-1048h]
  int v54; // [sp+24h] [bp-1048h]
  int v55; // [sp+24h] [bp-1048h]
  int v56; // [sp+24h] [bp-1048h]
  int v57; // [sp+24h] [bp-1048h]
  char *v58; // [sp+28h] [bp-1044h]
  unsigned int v59; // [sp+30h] [bp-103Ch]
  int v60; // [sp+34h] [bp-1038h]
  int v61; // [sp+40h] [bp-102Ch] BYREF
  int v62; // [sp+44h] [bp-1028h]
  struct timeval v63; // [sp+48h] [bp-1024h] BYREF
  struct timeval v64; // [sp+50h] [bp-101Ch] BYREF
  int v65; // [sp+58h] [bp-1014h]
  int v66; // [sp+5Ch] [bp-1010h]
  int v67; // [sp+60h] [bp-100Ch]
  int v68; // [sp+64h] [bp-1008h]
  char s[4056]; // [sp+68h] [bp-1004h] BYREF

  v62 = 0;
  v61 = 0;
  sub_2A84C(&v63);
  sub_2A84C(&v64);
  sub_2A530(&v61, &v63);
  sub_2A530(&dword_790F4, &v64);
  v66 = 0;
  v67 = 0;
  v65 = 0;
  v68 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      sub_2A84C(&v63);
      sub_2A84C(&v64);
      v0 = v63.tv_sec - v61;
      if ( v63.tv_usec - v62 < 0 )
        --v0;
      if ( v0 <= 11999 )
        break;
      sub_2A530(&v61, &v63);
      sub_2A92C();
    }
    if ( v0 > 120 )
      break;
LABEL_6:
    if ( dword_9D6D6 > 80 || dword_9D6DA > 110 )
    {
      if ( (unsigned __int8)++byte_7911C <= 2u )
      {
        if ( !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Temperature pcb:%d/chip:%d is higher than %d/%d'C for %d time, PWM is %d",
            dword_9D6D6,
            dword_9D6DA,
            80,
            110,
            (unsigned __int8)byte_7911C,
            (unsigned __int8)byte_9D6CA);
          sub_38730(3, s, 0);
        }
      }
      else
      {
        byte_7911D = 1;
        if ( !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "%s: the temperature pcb:%d/chip:%d is too high, close PIC and need reboot!!!",
            "check_miner_status",
            dword_9D6D6,
            dword_9D6DA);
          sub_38730(3, s, 0);
        }
      }
    }
    else
    {
      byte_7911C = 0;
      byte_7911D = 0;
    }
    v1 = v64.tv_sec - dword_790F4;
    if ( v64.tv_usec - dword_790F8 < 0 )
      --v1;
    if ( v1 > 120 )
    {
      byte_7911E = 1;
      if ( !byte_78E3C && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        snprintf(
          s,
          0x1000u,
          "%s: We have lost internet for %d seconds, so don't send work to hashboard anymore",
          "check_miner_status",
          v1);
        sub_38730(7, s, 0);
      }
    }
    else
    {
      byte_7911E = 0;
    }
    if ( (dword_9D4C8 & 1) != 0 )
    {
      v4 = 1;
      v2 = 0;
    }
    else
    {
      v2 = 1;
      while ( 1 )
      {
        v3 = dword_9D4C8 & (1 << v2);
        if ( v3 )
          break;
        if ( ++v2 == 32 )
        {
          v2 = -1;
          v4 = 0;
          goto LABEL_27;
        }
      }
      v4 = v2 + 1;
      if ( (unsigned int)(v2 + 1) > 0x1F )
      {
        v3 = 1;
LABEL_28:
        v4 = -1;
        v5 = 0;
        goto LABEL_29;
      }
    }
    v3 = 1;
    if ( (dword_9D4C8 & (1 << v4)) == 0 )
    {
LABEL_27:
      while ( (unsigned int)++v4 <= 0x1F )
      {
        if ( (dword_9D4C8 & (1 << v4)) != 0 )
          goto LABEL_91;
      }
      goto LABEL_28;
    }
LABEL_91:
    v5 = 1;
LABEL_29:
    if ( (unsigned __int8)byte_9D6CC > 1u )
    {
      if ( v3 )
      {
        v7 = *(_DWORD *)((char *)&unk_9D4B4 + 4 * v2 + 489);
        if ( v7 < (unsigned int)((unsigned __int64)(12686672634000LL * (unsigned __int8)dword_9D6F8) >> 32) >> 6 )
        {
          v6 = 2;
          goto LABEL_67;
        }
        if ( byte_9D6CA == 100 && v7 < 0x12C0 )
          goto LABEL_66;
      }
      if ( !v5 )
        goto LABEL_39;
      v8 = *(_DWORD *)((char *)&unk_9D4B4 + 4 * v4 + 489);
      if ( v8 >= (unsigned int)((unsigned __int64)(9092115387700LL * (unsigned __int8)dword_9D6F8) >> 32) >> 6 )
      {
        if ( byte_9D6CA != 100 || v8 >= 0xD70 )
        {
LABEL_39:
          dword_79120 = 0;
LABEL_40:
          byte_79125 = 0;
          goto LABEL_41;
        }
LABEL_66:
        v6 = 4;
        goto LABEL_67;
      }
      v6 = 3;
    }
    else
    {
      v6 = 1;
    }
LABEL_67:
    v13 = ++dword_79120;
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(
        s,
        0x1000u,
        "ret:%d [%d:%d]fan_error_num:%d fan_num %d fan_pwm %d fan1_speed_value %d fan2_speed_value %d",
        v6,
        v3,
        v5,
        v13,
        (unsigned __int8)byte_9D6CC,
        (unsigned __int8)dword_9D6F8,
        *(_DWORD *)((char *)&unk_9D4B4 + 4 * v2 + 489),
        *(_DWORD *)((char *)&unk_9D4B4 + 4 * v4 + 489));
      sub_38730(7, s, 0);
      v13 = dword_79120;
    }
    if ( v13 <= 20 )
      goto LABEL_40;
    v14 = 1;
    byte_79125 = 1;
    if ( (dword_9D4C8 & 1) == 0 )
    {
      while ( 1 )
      {
        v15 = dword_9D4C8 & (1 << v14);
        if ( v15 )
          break;
        if ( ++v14 == 32 )
        {
          v14 = -1;
          goto LABEL_78;
        }
      }
      v15 = v14 + 1;
      if ( v14 != 31 )
        goto LABEL_78;
      goto LABEL_82;
    }
    v15 = 1;
    v14 = 0;
LABEL_78:
    if ( (dword_9D4C8 & (1 << v15)) == 0 )
    {
      while ( (unsigned int)++v15 <= 0x1F )
      {
        if ( (dword_9D4C8 & (1 << v15)) != 0 )
          goto LABEL_83;
      }
LABEL_82:
      v15 = -1;
    }
LABEL_83:
    switch ( v6 )
    {
      case 3:
        if ( !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Fan Err! Disable PIC! Fan2 speed is too low %d pwm %d ",
            *(_DWORD *)((char *)&unk_9D4B4 + 4 * v15 + 489),
            (unsigned __int8)byte_9D6CA);
LABEL_178:
          sub_38730(3, s, 0);
        }
        break;
      case 4:
        if ( !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Fan Err! Disable PIC! Fan1:%d Fan2:%d pwm %d",
            *(_DWORD *)((char *)&unk_9D4B4 + 4 * v14 + 489),
            *(_DWORD *)((char *)&unk_9D4B4 + 4 * v15 + 489),
            (unsigned __int8)byte_9D6CA);
          sub_38730(3, s, 0);
        }
        break;
      case 2:
        if ( !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Fan Err! Disable PIC! Fan1 speed is too low %d pwm %d ",
            *(_DWORD *)((char *)&unk_9D4B4 + 4 * v14 + 489),
            (unsigned __int8)byte_9D6CA);
          goto LABEL_178;
        }
        break;
      default:
        if ( !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          snprintf(s, 0x1000u, "Fan Err! Disable PIC! Fan num is %d", (unsigned __int8)byte_9D6CC);
          sub_38730(3, s, 0);
        }
        break;
    }
LABEL_41:
    if ( byte_78E28 )
      byte_7911E = 0;
    if ( byte_79124 || byte_7911E || byte_7911D || byte_79125 || byte_79126 )
    {
      v9 = 1;
      byte_790F0 = 1;
      if ( !byte_79127 && (byte_7911D || byte_79125) )
      {
        v10 = 644283;
        v11 = 0;
        byte_78E3C = 1;
        byte_79127 = 1;
        do
        {
          v12 = *(unsigned __int8 *)++v10;
          if ( v12 == 1 )
          {
            pthread_mutex_lock(&stru_790D0);
            dword_7909C = v11;
            sub_3FC24();
            sub_2A92C();
            pthread_mutex_unlock(&stru_790D0);
          }
          ++v11;
        }
        while ( v11 != 4 );
        v9 = (unsigned __int8)byte_790F0;
      }
    }
    else
    {
      v9 = (unsigned __int8)byte_79127;
      byte_790F0 = 0;
      byte_78E3C = 0;
      if ( byte_79127 )
      {
        v9 = 1;
        byte_790F0 = 1;
        byte_78E3C = 1;
      }
    }
    sub_44AC0(v9);
    sub_2A92C();
  }
  v16 = 644583;
  v17 = &unk_7C134;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  do
  {
    v18 = v17;
    v19 = *(_DWORD *)v16;
    v17 += 4;
    v20 = *(_DWORD *)(v16 + 4);
    v21 = *(_DWORD *)(v16 + 8);
    v22 = *(_DWORD *)(v16 + 12);
    v16 += 16;
    *v18 = v19;
    v18[1] = v20;
    v18[2] = v21;
    v18[3] = v22;
  }
  while ( (_UNKNOWN *)v16 != &unk_9D617 );
  v23 = 644535;
  v24 = &unk_7C164;
  do
  {
    v25 = v24;
    v26 = *(_DWORD *)v23;
    v24 += 4;
    v27 = *(_DWORD *)(v23 + 4);
    v28 = *(_DWORD *)(v23 + 8);
    v29 = *(_DWORD *)(v23 + 12);
    v23 += 16;
    *v25 = v26;
    v25[1] = v27;
    v25[2] = v28;
    v25[3] = v29;
  }
  while ( (_UNKNOWN *)v23 != &unk_9D5E7 );
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 644283;
  do
  {
    if ( *(unsigned __int8 *)++v33 )
    {
      v32 += *(unsigned __int8 *)(v33 + 521);
      if ( *(_BYTE *)(v33 + 521) )
      {
        v35 = 0;
        do
        {
          v36 = *(_DWORD *)((char *)&unk_9D4B4 + 12 * v30 + 4 * v35 + 259);
          v31 += v36;
          if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(s, 0x1000u, "%s: chain %d asic %d asic_nonce_num %d", "check_miner_status", v30, v35, v36);
            sub_38730(7, s, 0);
          }
          ++v35;
        }
        while ( *(unsigned __int8 *)(v33 + 521) > v35 );
      }
    }
    ++v30;
  }
  while ( v30 != 4 );
  if ( v32 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "%s: avg_num %d asic_num %d", "check_miner_status", v31, v32);
      sub_38730(7, s, 0);
    }
    v59 = (v31 / v32) >> 3;
  }
  else
  {
    v59 = 1;
  }
  v37 = 644283;
  v38 = 0;
  v39 = 0;
LABEL_123:
  if ( !*(unsigned __int8 *)++v37 )
    goto LABEL_158;
  v41 = *(unsigned __int8 *)(v37 + 521);
  if ( !*(_BYTE *)(v37 + 521) )
  {
    v60 = 8 * v39;
    goto LABEL_157;
  }
  v60 = 8 * v39;
  v42 = &dword_7C130[3 * v39 + 25];
  v43 = 0;
  v44 = 0;
  v58 = (char *)&unk_9D4B4 + 19 * v39;
  while ( 1 )
  {
    if ( (v44 & 7) == 0 )
    {
      v45 = v44 + v43;
      if ( v44 + v43 > 0x13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
      {
        v52 = v38;
        snprintf(s, 0x1000u, aAsicNumErrD, v44 + v43);
        sub_38730(3, s, 0);
        v38 = v52;
      }
      ++v43;
      v58[v45 + 355] = 32;
    }
    if ( v59 >= *(_DWORD *)((char *)&unk_9D4B4 + 12 * v39 + 4 * v44 + 259) )
    {
      v46 = (unsigned __int8)byte_78E28;
      *v42 = 1;
      if ( !v46 )
      {
        if ( v43 + v44 > 0x13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
        {
          v53 = v38;
          snprintf(s, 0x1000u, aAsicNumErrD, v43 + v44);
          sub_38730(3, s, 0);
          v38 = v53;
        }
        v47 = byte_78E09 == 0;
        v48 = *(int *)((char *)&v65 + v38);
        v58[v43 + 355 + v44] = 120;
        *(int *)((char *)&v65 + v38) = v48 + 1;
        if ( !v47 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          v54 = v38;
          snprintf(
            s,
            0x1000u,
            "x chain%d asic%d nonce_num=%d avg_num=%d\n",
            v39,
            v44,
            *(_DWORD *)((char *)&unk_9D4B4 + 12 * v39 + 4 * v44 + 259),
            v59);
          sub_38730(7, s, 0);
          v38 = v54;
        }
        goto LABEL_146;
      }
    }
    else
    {
      *v42 = 0;
    }
    if ( v43 + v44 > 0x13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
    {
      v57 = v38;
      snprintf(s, 0x1000u, aAsicNumErrD, v43 + v44);
      sub_38730(3, s, 0);
      v38 = v57;
    }
    v58[v43 + 355 + v44] = 111;
LABEL_146:
    if ( v44 > 0x13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
    {
      v55 = v38;
      snprintf(s, 0x1000u, aAsicNumErrD, v44);
      sub_38730(3, s, 0);
      v38 = v55;
    }
    v49 = 3 * v39 + v44++;
    ++v42;
    v50 = (char *)&unk_9D4B4 + 4 * v49 + 256;
    v51 = *((_DWORD *)v50 + 1);
    v50[3] = 0;
    *((_DWORD *)v50 + 1) = v51 & 0xFF000000;
    if ( *(unsigned __int8 *)(v37 + 521) <= v44 )
    {
      v41 = v43 + v44;
      if ( v41 > 0x13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
      {
        v56 = v38;
        snprintf(s, 0x1000u, aAsicNumErrD, v41);
        sub_38730(3, s, 0);
        v38 = v56;
      }
LABEL_157:
      *((_BYTE *)&unk_9D4B4 + 2 * v60 + 2 * v39 + v39 + v41 + 355) = 0;
LABEL_158:
      ++v39;
      v38 += 4;
      if ( v39 == 4 )
      {
        pthread_mutex_lock(&stru_79100);
        pthread_cond_signal(&stru_7C078);
        pthread_mutex_unlock(&stru_79100);
        memset(&unk_9D5E7, 0, 0x30u);
        memset(&unk_9D5B7, 0, 0x30u);
        sub_2A530(&v61, &v63);
        goto LABEL_6;
      }
      goto LABEL_123;
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E28: using guessed type char byte_78E28;
// 78E3C: using guessed type char byte_78E3C;
// 7909C: using guessed type int dword_7909C;
// 790F0: using guessed type char byte_790F0;
// 790F4: using guessed type int dword_790F4;
// 790F8: using guessed type int dword_790F8;
// 7911C: using guessed type char byte_7911C;
// 7911D: using guessed type char byte_7911D;
// 7911E: using guessed type char byte_7911E;
// 79120: using guessed type int dword_79120;
// 79124: using guessed type char byte_79124;
// 79125: using guessed type char byte_79125;
// 79126: using guessed type char byte_79126;
// 79127: using guessed type char byte_79127;
// 7AD48: using guessed type char byte_7AD48;
// 7C130: using guessed type int dword_7C130[];
// 9D4C8: using guessed type int dword_9D4C8;
// 9D6CA: using guessed type char byte_9D6CA;
// 9D6CC: using guessed type char byte_9D6CC;
// 9D6D6: using guessed type int dword_9D6D6;
// 9D6DA: using guessed type int dword_9D6DA;
// 9D6F8: using guessed type int dword_9D6F8;

//----- (00045AF0) --------------------------------------------------------
int __fastcall sub_45AF0(_BYTE *a1, _DWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(dword_78E10 + 4);
  *a2 = (unsigned __int8)v2;
  *a1 = BYTE1(v2) & 7;
  return v2;
}
// 78E10: using guessed type int dword_78E10;

//----- (00045B30) --------------------------------------------------------
int sub_45B30()
{
  system("echo 1 > /sys/class/gpio/gpio954/value");
  return system("echo 1 > /sys/class/gpio/gpio955/value");
}

//----- (00045B50) --------------------------------------------------------
void sub_45B50()
{
  int v0; // r5
  int v1; // r1
  unsigned int v2; // r3
  int v3; // r1
  unsigned int v4; // [sp+Ch] [bp-1008h]
  char s[4080]; // [sp+10h] [bp-1004h] BYREF

  v0 = 0;
  dword_9D6CE = 0;
  dword_9D6D2 = 0;
  while ( 1 )
  {
    if ( v0 <= 5 )
      goto LABEL_13;
    if ( (unsigned __int8)byte_9D6CC > 1u )
      break;
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "No %d Fan find, check again", 2);
      sub_38730(5, s, 0);
    }
    v0 = 0;
    sub_2A92C();
LABEL_13:
    v4 = *(_DWORD *)(dword_78E10[0] + 4);
    if ( v4 != -1 )
    {
      v1 = (v4 >> 8) & 7;
      v2 = 120 * (unsigned __int8)v4;
      *(_DWORD *)((char *)&unk_9D4B4 + 4 * v1 + 489) = v2;
      if ( (_BYTE)v4 )
      {
        if ( !*((_BYTE *)&unk_9D4B4 + v1 + 459) )
        {
          *((_BYTE *)&unk_9D4B4 + v1 + 459) = 1;
          ++byte_9D6CC;
          dword_9D4C8 |= 1 << v1;
        }
      }
      else if ( *((_BYTE *)&unk_9D4B4 + v1 + 459) == 1 )
      {
        *((_BYTE *)&unk_9D4B4 + v1 + 459) = v4;
        if ( 1 << v1 )
          v3 = 0;
        else
          v3 = dword_9D4C8 & 1;
        dword_9D4C8 = v3;
        --byte_9D6CC;
      }
      if ( v2 > dword_9D6CE )
        dword_9D6CE = 120 * (unsigned __int8)v4;
      if ( v2 < dword_9D6D2 && v2 || !dword_9D6D2 )
        dword_9D6D2 = 120 * (unsigned __int8)v4;
    }
    ++v0;
    sub_2A92C();
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "fan-num %d fan-map %d\n", (unsigned __int8)byte_9D6CC, dword_9D4C8);
    sub_38730(5, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10[];
// 7AD48: using guessed type char byte_7AD48;
// 9D4C8: using guessed type int dword_9D4C8;
// 9D6CC: using guessed type char byte_9D6CC;
// 9D6CE: using guessed type int dword_9D6CE;
// 9D6D2: using guessed type int dword_9D6D2;

//----- (00045D88) --------------------------------------------------------
int __fastcall sub_45D88(int a1)
{
  __int64 v1; // r0
  int v2; // r3

  if ( a1 <= 39 )
  {
    a1 = 40;
  }
  else if ( a1 > 100 )
  {
    v1 = 0x6400640000LL;
    goto LABEL_4;
  }
  if ( byte_79126 )
  {
    v1 = 0x6400640000LL;
  }
  else
  {
    BYTE4(v1) = a1;
    LODWORD(v1) = (100 - a1) | (a1 << 16);
  }
LABEL_4:
  v2 = dword_78E10;
  byte_9D6CA = BYTE4(v1);
  *(_DWORD *)(dword_78E10 + 132) = v1;
  *(_DWORD *)(v2 + 160) = v1;
  return v1;
}
// 78E10: using guessed type int dword_78E10;
// 79126: using guessed type char byte_79126;
// 9D6CA: using guessed type char byte_9D6CA;

//----- (00045DEC) --------------------------------------------------------
void sub_45DEC()
{
  ;
}

//----- (00045EC0) --------------------------------------------------------
int sub_45EC0()
{
  float v0; // s0
  int result; // r0
  _BOOL4 v2; // r3
  int v3; // r3
  int v4; // r6
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  result = dword_9D6D6;
  dword_79128 = dword_9D6D6;
  if ( byte_9D6F7 && (unsigned __int8)dword_9D6F8 <= 0x64u )
    return sub_45D88((unsigned __int8)dword_9D6F8);
  v2 = dword_9D6D6 > 62;
  if ( !dword_9D6D6 )
    v2 = 1;
  if ( v2 )
  {
    result = sub_45D88(100);
    LOBYTE(dword_9D6F8) = 100;
  }
  else if ( dword_9D6D6 <= 35 )
  {
    result = sub_45D88(40);
    LOBYTE(dword_9D6F8) = 40;
  }
  else if ( (unsigned int)(dword_9D6D6 - dword_7912C + 1) > 2 )
  {
    sub_45DEC();
    v3 = (int)v0 & ~((int)v0 >> 31);
    v4 = (unsigned __int8)v3;
    LOBYTE(dword_9D6F8) = (int)v0 & ~((int)v0 >> 31);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(s, 0x1000u, "%s: Set PWM percent : %d", "set_PWM_according_to_temperature", v3);
      sub_38730(7, s, 0);
    }
    result = sub_45D88(v4);
    dword_7912C = dword_79128;
  }
  return result;
}
// 45F40: variable 'v0' is possibly undefined
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 79128: using guessed type int dword_79128;
// 7912C: using guessed type int dword_7912C;
// 7AD48: using guessed type char byte_7AD48;
// 9D6D6: using guessed type int dword_9D6D6;
// 9D6F7: using guessed type char byte_9D6F7;
// 9D6F8: using guessed type int dword_9D6F8;

//----- (0004601C) --------------------------------------------------------
int __fastcall sub_4601C(int a1)
{
  int result; // r0
  unsigned int v3; // r4
  int v4; // r5
  char v5; // t1
  _DWORD v6[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v7; // [sp+14h] [bp-1008h]
  char v8; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  result = *((unsigned __int8 *)&unk_9D4B4 + a1 + 8);
  v6[1] = 0;
  v7 = 0;
  v8 = 0;
  v3 = dword_76B5C | 0x4060;
  dword_76B5C |= 0x4060u;
  v6[0] = 0;
  if ( result == 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s: reg_value=0x%08x chainid %u", "enable_read_temperature_from_asic_chain", v3, a1);
      sub_38730(5, s, 0);
    }
    v4 = 495919;
    do
    {
      v5 = *(_BYTE *)++v4;
      sub_3CDCC((int)v6, 0, v5, 28, v3);
      sub_3C150((unsigned __int8)a1, v6, 0xBu);
      result = sub_2A92C();
    }
    while ( v4 != 495922 );
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 76B5C: using guessed type int dword_76B5C;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0004614C) --------------------------------------------------------
int sub_4614C()
{
  sub_4601C(0);
  sub_4601C(1);
  sub_4601C(2);
  return sub_4601C(3);
}

//----- (00046174) --------------------------------------------------------
void __fastcall sub_46174(int a1, int a2)
{
  unsigned int v3; // r5
  int v4; // r4
  char v5; // t1
  _DWORD v6[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v7; // [sp+14h] [bp-1008h]
  char v8; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v6[1] = 0;
  v7 = 0;
  v6[0] = 0;
  v3 = a2 & 0xFFFFFFF8;
  v8 = 0;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s: analog_mux_reg_value = %08x", "select_core_to_check_temperature_chain", a2);
    sub_38730(5, s, 0);
  }
  if ( *((_BYTE *)&unk_9D4B4 + a1 + 8) == 1 )
  {
    v4 = 495919;
    do
    {
      v5 = *(_BYTE *)++v4;
      sub_3CDCC((int)v6, 0, v5, 64, v3);
      sub_3C150((unsigned __int8)a1, v6, 0xBu);
      sub_2A92C();
    }
    while ( v4 != 495922 );
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00046294) --------------------------------------------------------
void __fastcall sub_46294(int a1)
{
  int i; // r4
  int v3; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s: analog_mux_reg_value = %08x", "select_core_to_check_temperature", a1);
    sub_38730(5, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    v3 = i;
    sub_46174(v3, a1);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0004633C) --------------------------------------------------------
int __fastcall sub_4633C(int a1, int a2, char a3, unsigned __int8 a4, unsigned __int8 a5)
{
  unsigned int v5; // r12
  char v7; // r2
  _DWORD v9[2]; // [sp+Ch] [bp-10h] BYREF
  __int16 v10; // [sp+14h] [bp-8h]
  char v11; // [sp+16h] [bp-6h]

  v5 = dword_76B6C & 0xFE0100FF | 0x1000000 | ((a3 & 0x7F) << 17) | (a4 << 8);
  v7 = *((_BYTE *)&dword_78E10[200] + a2);
  v9[0] = 0;
  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  sub_3CDCC((int)v9, 0, v7, 32, v5 & 0xFFFFFF00 | a5 | 0x10000);
  sub_3C150(a1, v9, 0xBu);
  return sub_2A92C();
}
// 76B6C: using guessed type int dword_76B6C;
// 78E10: using guessed type int dword_78E10[];

//----- (000463C8) --------------------------------------------------------
int sub_463C8()
{
  int v0; // r6
  int i; // r4
  int v2; // t1
  int v3; // r5
  int v4; // r1
  int result; // r0

  v0 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      v3 = 0;
      do
      {
        v4 = v3;
        v3 = (unsigned __int8)(v3 + 1);
        result = sub_4633C(i, v4, 76, 9u, 4u);
      }
      while ( v3 != 3 );
    }
  }
  return result;
}

//----- (00046434) --------------------------------------------------------
int __fastcall sub_46434(int a1, int a2)
{
  char *v4; // r3
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(s, 0x1000u, "%s chainid %d", "reset_chain", a2);
    sub_38730(4, s, 0);
  }
  pthread_mutex_lock(&stru_790D0);
  dword_7909C = a2;
  sub_3FC24();
  pthread_mutex_unlock(&stru_790D0);
  v4 = (char *)&dword_78E10 + a2;
  v4[732] = 0;
  v4[776] = 0;
  v4[748] = 1;
  sub_2A3DC(a1 + (a2 << 6) + 634);
  sub_2A3DC(a1 + (a2 << 6) + 890);
  byte_76B4B = 0;
  pthread_mutex_lock(&stru_790D0);
  dword_7909C = a2;
  sub_3DF78();
  sub_2A92C();
  sub_3DDD0();
  sub_2A92C();
  pthread_mutex_unlock(&stru_790D0);
  byte_76B4B = 1;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s %d", "reset_hash_board_low", a2);
    sub_38730(5, s, 0);
  }
  *(_DWORD *)(dword_78E10 + 52) = 1 << a2;
  sub_2A92C();
  pthread_mutex_lock(&stru_790D0);
  dword_7909C = a2;
  sub_3FA7C();
  pthread_mutex_unlock(&stru_790D0);
  sleep(1u);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s %d", "reset_hash_board_high", a2);
    sub_38730(5, s, 0);
  }
  *(_DWORD *)(dword_78E10 + 52) = 0;
  *((_BYTE *)&dword_78E10 + a2 + 748) = 0;
  sub_445E8(a2, a1);
  sub_3BB44(26);
  sub_2A92C();
  sub_43E98(a2, 0);
  sub_2A92C();
  sub_3BB44(0);
  return sub_2A92C();
}
// 766C4: using guessed type int dword_766C4;
// 76B4B: using guessed type char byte_76B4B;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (000466A4) --------------------------------------------------------
int __fastcall sub_466A4(int result)
{
  char v1[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( result != 1 && result != 2 )
  {
    if ( (unsigned int)(result - 3) > 1 )
    {
      if ( (unsigned int)(result - 5) > 3 )
      {
        if ( (unsigned int)(result - 9) > 7 )
        {
          if ( (unsigned int)(result - 17) > 0xF )
          {
            if ( (unsigned int)(result - 33) > 0x1F )
            {
              if ( (unsigned int)(result - 65) > 0x3F )
              {
                if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
                {
                  snprintf(v1, 0x1000u, "actual_asic_number = %d, but it is error\n", result);
                  sub_38730(7, v1, 0);
                  return -1;
                }
                else
                {
                  return -1;
                }
              }
              else
              {
                return 128;
              }
            }
            else
            {
              return 64;
            }
          }
          else
          {
            return 32;
          }
        }
        else
        {
          return 16;
        }
      }
      else
      {
        return 8;
      }
    }
    else
    {
      return 4;
    }
  }
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;

//----- (000467B0) --------------------------------------------------------
int sub_467B0()
{
  int v0; // r0
  unsigned __int8 v1; // r0
  int v2; // r2
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v0 = sub_466A4(3);
  v1 = sub_5C710(256, v0);
  byte_9D6F3 = v1;
  v2 = v1;
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s:addrInterval = %d", "calculate_address_interval", v1);
    sub_38730(5, s, 0);
    v2 = (unsigned __int8)byte_9D6F3;
  }
  byte_79131 = v2;
  byte_79132 = 2 * v2;
  byte_79130[0] = 0;
  return 2 * v2;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 79131: using guessed type char byte_79131;
// 79132: using guessed type char byte_79132;
// 7AD48: using guessed type char byte_7AD48;
// 9D6F3: using guessed type char byte_9D6F3;

//----- (00046880) --------------------------------------------------------
int sub_46880()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9D4B0 = (int)calloc(1u, 0x40u);
  if ( sub_2F174(dword_9D4B0, 0, (void *(*)(void *))sub_47354, 0) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_scan_freq_pthread");
      sub_38730(7, v1, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_9D4B0 + 12));
    sub_2A92C();
    return 0;
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 9D4B0: using guessed type int dword_9D4B0;

//----- (00046964) --------------------------------------------------------
int sub_46964()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9D4B0 = (int)calloc(1u, 0x40u);
  if ( sub_2F174(dword_9D4B0, 0, (void *(*)(void *))sub_4388C, 0) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_turbo_mode_monitor_pthread");
      sub_38730(7, v1, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_9D4B0 + 12));
    sub_2A92C();
    return 0;
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 9D4B0: using guessed type int dword_9D4B0;

//----- (00046A48) --------------------------------------------------------
int __fastcall sub_46A48(int a1)
{
  int v1; // r6
  int v2; // r5
  int v4; // r4
  int v5; // r7
  int v6; // t1
  int v8; // r2
  int v9; // r1
  char v10; // r3
  int v11; // [sp+4h] [bp-1010h] BYREF
  int v12; // [sp+8h] [bp-100Ch]
  char v13; // [sp+Ch] [bp-1008h]
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v1 = 644283;
  v2 = 0;
  v4 = 0;
  v5 = 1;
  while ( 1 )
  {
    v6 = *(unsigned __int8 *)++v1;
    if ( v6 == 1 )
      break;
LABEL_3:
    ++v4;
    v2 += 9;
    if ( v4 == 4 )
      return v5;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0;
  pthread_mutex_lock(&stru_790D0);
  dword_7909C = v4;
  v5 = sub_42100(&v11, 0, 9u);
  sub_2A92C();
  pthread_mutex_unlock(&stru_790D0);
  if ( v5 )
  {
    if ( v5 > 0 )
    {
      sub_56CD8((unsigned int *)((char *)&v11 + 1), 2, (int)&unk_69AF8 + 16 * v4);
      v8 = a1 + v2;
      v9 = v12;
      v10 = v13;
      *(_DWORD *)(a1 + v2) = v11;
      *(_DWORD *)(v8 + 4) = v9;
      *(_BYTE *)(v8 + 8) = v10;
    }
    goto LABEL_3;
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "chain%d pic not support flash data storage, adopt file mode\n", v4);
    sub_38730(5, s, 0);
  }
  return v5;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7909C: using guessed type int dword_7909C;
// 7AD48: using guessed type char byte_7AD48;

//----- (00046B94) --------------------------------------------------------
int __fastcall sub_46B94(unsigned __int8 *a1)
{
  int v2; // r6
  int v3; // r7
  int i; // r4
  int v5; // t1

  v2 = 644283;
  v3 = 1;
  for ( i = 0; i != 4; ++i )
  {
    v5 = *(unsigned __int8 *)++v2;
    if ( v5 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = i;
      v3 = sub_41E7C(a1, 0, 9);
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
    a1 += 9;
  }
  return v3;
}
// 7909C: using guessed type int dword_7909C;

//----- (00046C10) --------------------------------------------------------
int sub_46C10()
{
  int v0; // r5
  int v1; // r4
  int v2; // r6
  int v3; // t1
  _DWORD v5[9]; // [sp+4h] [bp-28h] BYREF

  v0 = 644283;
  v1 = 0;
  v2 = 1;
  memset(v5, 0, sizeof(v5));
  do
  {
    v3 = *(unsigned __int8 *)++v0;
    if ( v3 == 1 )
    {
      pthread_mutex_lock(&stru_790D0);
      dword_7909C = v1;
      v2 = sub_41E7C((unsigned __int8 *)v5 + 9 * v1, 0, 9);
      sub_2A92C();
      pthread_mutex_unlock(&stru_790D0);
    }
    ++v1;
  }
  while ( v1 != 4 );
  return v2;
}
// 7909C: using guessed type int dword_7909C;

//----- (00046CBC) --------------------------------------------------------
int sub_46CBC()
{
  int v0; // r6
  int v1; // r1
  int v2; // r3
  int v3; // t1
  _DWORD *v4; // r5
  int i; // r4
  int v6; // t1
  int *v7; // lr
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // lr
  const char *v14; // lr
  int v15; // r12
  int *v16; // r7
  int v17; // r10
  int v18; // r8
  int v19; // r4
  int v20; // r0
  int v21; // r1
  int v22; // r2
  int v23; // r3
  int *v24; // lr
  int v25; // r0
  int v26; // r1
  int v27; // r2
  int v28; // r3
  int v29; // r1
  int v30; // r2
  int v31; // r3
  FILE *v32; // r7
  int v33; // r11
  int v34; // t1
  int v35; // r5
  int *v36; // r6
  int v37; // r3
  int v38; // [sp+0h] [bp-103Ch] BYREF
  int v39; // [sp+Ch] [bp-1030h]
  int v40; // [sp+10h] [bp-102Ch] BYREF
  _DWORD v41[9]; // [sp+14h] [bp-1028h] BYREF
  int s; // [sp+38h] [bp-1004h] BYREF
  int v43; // [sp+3Ch] [bp-1000h]
  int v44; // [sp+40h] [bp-FFCh]
  int v45; // [sp+44h] [bp-FF8h]
  int v46; // [sp+48h] [bp-FF4h]
  int v47; // [sp+4Ch] [bp-FF0h]
  int v48; // [sp+50h] [bp-FECh]
  int v49; // [sp+54h] [bp-FE8h]
  int v50; // [sp+58h] [bp-FE4h]
  int v51; // [sp+5Ch] [bp-FE0h]
  int v52; // [sp+60h] [bp-FDCh]
  __int16 v53; // [sp+64h] [bp-FD8h]

  memset(v41, 0, 12);
  sub_40454();
  dword_7C130[0] = sub_46A48((int)v41);
  if ( dword_7C130[0] > 0 )
  {
    v0 = 644283;
    v1 = 0;
    v2 = 644283;
    while ( 1 )
    {
      v3 = *(unsigned __int8 *)++v2;
      if ( v3 == 1 && *((_BYTE *)&v38 + v1 + 20) != 78 )
        break;
      v1 += 9;
      if ( v1 == 36 )
      {
        v4 = v41;
        for ( i = 0; i != 4; ++i )
        {
          v6 = *(unsigned __int8 *)++v0;
          if ( v6 == 1 )
          {
            v15 = 0;
            v39 = v0;
            v16 = &dword_7C130[3 * i + 61];
            do
            {
              v17 = v15 + 1;
              v18 = *(_DWORD *)&aResetAllHashBo[16 * *((unsigned __int8 *)v4 + v15 + 1) + 2220];
              if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
              {
                snprintf((char *)&s, 0x1000u, "pic read chain%d asic%d freq %d\n", i, v15, v18);
                sub_38730(5, (const char *)&s, 0);
              }
              v15 = v17;
              if ( (unsigned int)(v18 - 775) <= 0x32 )
                *v16 = v18;
              else
                *v16 = 800;
              ++v16;
            }
            while ( v17 != 3 );
            v0 = v39;
          }
          v4 = (_DWORD *)((char *)v4 + 9);
        }
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          v7 = (int *)&unk_6B9E8;
          goto LABEL_11;
        }
        return sub_46964();
      }
    }
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      v14 = "1 Goto scan mode and find the best frequency\n";
      goto LABEL_34;
    }
    return sub_46880();
  }
  v19 = access("/config/chips_freq.config", 0);
  if ( !v19 )
  {
    v32 = fopen("/config/chips_freq.config", "r");
    if ( v32 )
    {
      v33 = 644283;
      do
      {
        v34 = *(unsigned __int8 *)++v33;
        if ( v34 == 1 )
        {
          v35 = 0;
          v36 = &dword_7C130[3 * v19 + 61];
          do
          {
            ++v35;
            v40 = 0;
            fscanf(v32, "%d", &v40);
            v37 = v40;
            if ( (unsigned int)(v40 - 775) >= 0x33 )
              v37 = 800;
            *v36++ = v37;
          }
          while ( v35 != 3 );
        }
        ++v19;
      }
      while ( v19 != 4 );
      fclose(v32);
    }
    else
    {
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
        return sub_46964();
      snprintf((char *)&s, 0x1000u, "open %s failed\n", "/config/chips_freq.config");
      sub_38730(5, (const char *)&s, 0);
    }
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      v7 = (int *)&unk_6BA58;
LABEL_11:
      v8 = *v7;
      v9 = v7[1];
      v10 = v7[2];
      v11 = v7[3];
      v12 = v7[4];
      s = v8;
      v43 = v9;
      v44 = v10;
      v45 = v11;
      LOWORD(v46) = v12;
      BYTE2(v46) = BYTE2(v12);
      sub_38730(5, (const char *)&s, 0);
    }
    return sub_46964();
  }
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    v14 = "2 Goto scan mode and find the best frequency\n";
LABEL_34:
    v20 = *(_DWORD *)v14;
    v21 = *((_DWORD *)v14 + 1);
    v22 = *((_DWORD *)v14 + 2);
    v23 = *((_DWORD *)v14 + 3);
    v24 = (int *)(v14 + 16);
    s = v20;
    v43 = v21;
    v44 = v22;
    v45 = v23;
    v25 = *v24;
    v26 = v24[1];
    v27 = v24[2];
    v28 = v24[3];
    v24 += 4;
    v46 = v25;
    v47 = v26;
    v48 = v27;
    v49 = v28;
    v29 = v24[1];
    v30 = v24[2];
    v31 = v24[3];
    v50 = *v24;
    v51 = v29;
    v52 = v30;
    v53 = v31;
    sub_38730(5, (const char *)&s, 0);
  }
  return sub_46880();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7C130: using guessed type int dword_7C130[];

//----- (000470A8) --------------------------------------------------------
int sub_470A8()
{
  int *v0; // r9
  int v1; // r8
  int v2; // r6
  int v3; // r4
  int v4; // t1
  char *v6; // r11
  int *v7; // r7
  int v8; // r5
  int v9; // r0
  int v10; // t1
  const char *v11; // r2
  int v12; // r3
  int v13; // r1
  int v14; // t1
  FILE *v15; // r6
  int i; // r5
  int v17; // t1
  int j; // r4
  int *v19; // r3
  _DWORD v20[9]; // [sp+14h] [bp-1028h] BYREF
  char s[4100]; // [sp+38h] [bp-1004h] BYREF

  v0 = dword_7C130;
  if ( dword_7C130[0] > 0 )
  {
    v1 = 644283;
    v2 = 0;
    v3 = 0;
    memset(v20, 0, sizeof(v20));
    while ( 1 )
    {
      v4 = *(unsigned __int8 *)++v1;
      if ( v4 != 1 )
        goto LABEL_4;
      v6 = (char *)v20 + 9 * v3;
      v7 = &dword_7C130[3 * v3 + 60];
      v8 = 0;
      *((_BYTE *)v20 + v2) = 78;
      do
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          snprintf(s, 0x1000u, "pic write chain%d asic%d freq %d\n", v3, v8, v7[1]);
          sub_38730(5, s, 0);
          v14 = v7[1];
          ++v7;
          v9 = v14;
          if ( v14 == 100 )
          {
LABEL_17:
            LOBYTE(v12) = 0;
            goto LABEL_14;
          }
        }
        else
        {
          v10 = v7[1];
          ++v7;
          v9 = v10;
          if ( v10 == 100 )
            goto LABEL_17;
        }
        v11 = "d";
        v12 = 1;
        while ( 1 )
        {
          v13 = *((_DWORD *)v11 + 4);
          v11 += 16;
          if ( v9 == v13 )
            break;
          if ( ++v12 == 115 )
          {
            LOBYTE(v12) = -1;
            break;
          }
        }
LABEL_14:
        ++v8;
        *++v6 = v12;
      }
      while ( v8 != 3 );
      sub_56B3C((_DWORD *)((char *)v20 + 9 * v3 + 1), 2, (int)&unk_69AF8 + 16 * v3);
LABEL_4:
      ++v3;
      v2 += 9;
      if ( v3 == 4 )
      {
        sub_46B94((unsigned __int8 *)v20);
        return 0;
      }
    }
  }
  v15 = fopen("/config/chips_freq.config", "w+");
  if ( v15 )
  {
    for ( i = 644283; i != 644287; ++i )
    {
      v17 = *(unsigned __int8 *)(i + 1);
      if ( v17 == 1 )
      {
        for ( j = 0; j != 3; ++j )
        {
          v19 = &v0[j];
          fprintf(v15, "%d ", v19[61]);
        }
      }
      v0 += 3;
    }
    fclose(v15);
    return 0;
  }
  else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%s open %s failed\n", "scan_freq_save_freq", "/config/chips_freq.config");
    sub_38730(5, s, 0);
    return -1;
  }
  else
  {
    return -1;
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;
// 7C130: using guessed type int dword_7C130[];

//----- (00047354) --------------------------------------------------------
void __noreturn sub_47354()
{
  int *v0; // r1
  int j; // r3
  int v2; // t1
  int v3; // r5
  int v4; // r11
  int v5; // t1
  int *v6; // r5
  int v7; // r10
  int v8; // r6
  int v9; // r9
  int ii; // r4
  int v11; // t1
  int v12; // r0
  _BOOL4 v13; // r3
  int v14; // r4
  int v15; // r6
  int v16; // r0
  int *v17; // r4
  int v18; // r3
  int v19; // lr
  int v20; // r12
  int k; // r2
  int v22; // r1
  int m; // r1
  int v24; // lr
  unsigned int v25; // r1
  int v26; // r12
  int v27; // r2
  const char *v28; // r3
  int v29; // t1
  int v30; // r1
  int v31; // lr
  const char *v32; // r3
  int n; // r2
  int v34; // r12
  int v35; // lr
  const char *v36; // r3
  int v37; // r12
  int v38; // r3
  char *v39; // lr
  bool v40; // zf
  int *v41; // r12
  int v42; // r0
  int *v43; // r2
  int i; // [sp+24h] [bp-1008h]
  char s[4100]; // [sp+28h] [bp-1004h] BYREF

  sub_43E4C(800);
  for ( i = 815; ; i = 825 )
  {
    v0 = dword_7C130;
    for ( j = 644283; j != 644287; ++j )
    {
      v2 = *(unsigned __int8 *)(j + 1);
      if ( v2 == 1 )
      {
        v42 = 0;
        do
        {
          v43 = &v0[v42++];
          v43[1] = 0;
          v43[25] = 0;
          v43[61] = 800;
          v43[49] = i;
          v43[37] = 775;
          v43[73] = 0;
        }
        while ( v42 != 3 );
      }
      v0 += 3;
    }
    do
    {
      do
      {
LABEL_5:
        sleep(1u);
        pthread_mutex_lock(&stru_79100);
        pthread_cond_wait(&stru_7C078, &stru_79100);
        pthread_mutex_unlock(&stru_79100);
        v3 = (unsigned __int8)byte_78E3C;
      }
      while ( byte_78E3C );
      v4 = 644283;
      do
      {
        v5 = *(unsigned __int8 *)++v4;
        if ( v5 != 1 )
          goto LABEL_8;
        v15 = 0;
        v17 = &dword_7C130[3 * v3 + 25];
        v16 = *v17;
        if ( *v17 )
          goto LABEL_48;
        while ( 2 )
        {
          v18 = *(v17 - 24);
          if ( (unsigned int)v18 <= 0xF )
          {
            v19 = v17[36];
            v20 = v17[24];
            if ( v20 == v19 )
            {
LABEL_76:
              v17[48] = 1;
              goto LABEL_46;
            }
            v17[12] = v19;
            if ( v19 == 100 )
            {
              k = v16;
LABEL_28:
              if ( v20 == 100 )
                goto LABEL_70;
            }
            else
            {
              v18 = (int)"d";
              for ( k = 1; k != 115; ++k )
              {
                v22 = *(_DWORD *)(v18 + 16);
                v18 += 16;
                if ( v19 == v22 )
                  goto LABEL_28;
              }
              k = -1;
              if ( v20 == 100 )
              {
LABEL_70:
                m = 0;
                goto LABEL_32;
              }
            }
            v18 = (int)"d";
            for ( m = 1; m != 115; ++m )
            {
              v24 = *(_DWORD *)(v18 + 16);
              v18 += 16;
              if ( v20 == v24 )
                goto LABEL_32;
            }
            m = -1;
LABEL_32:
            v25 = m - k;
            if ( v25 == 1 )
              ++k;
            else
              v18 = v25 + (v25 >> 31);
            if ( v25 != 1 )
            {
              v25 = 1;
              k += v18 >> 1;
            }
            goto LABEL_37;
          }
LABEL_48:
          v30 = v17[12];
          v31 = v17[36];
          if ( v30 == v31 )
            goto LABEL_76;
          if ( v31 == 100 )
          {
            v35 = -1;
LABEL_54:
            if ( v30 == 100 )
              goto LABEL_74;
            goto LABEL_55;
          }
          v32 = "d";
          for ( n = 1; n != 115; ++n )
          {
            v34 = *((_DWORD *)v32 + 4);
            v32 += 16;
            if ( v31 == v34 )
            {
              v35 = n - 1;
              goto LABEL_54;
            }
          }
          v35 = -2;
          if ( v30 == 100 )
          {
LABEL_74:
            k = 0;
            goto LABEL_58;
          }
LABEL_55:
          v36 = "d";
          for ( k = 1; k != 115; ++k )
          {
            v37 = *((_DWORD *)v36 + 4);
            v36 += 16;
            if ( v30 == v37 )
              goto LABEL_58;
          }
          k = -1;
LABEL_58:
          v38 = v35 - k;
          v39 = &aResetAllHashBo[16 * v35];
          v40 = v38 == 1;
          v25 = -1;
          if ( v38 == 1 )
            ++k;
          else
            v38 += (unsigned int)v38 >> 31;
          if ( !v40 )
            k += v38 >> 1;
          v17[24] = *((_DWORD *)v39 + 555);
LABEL_37:
          v26 = (unsigned __int8)byte_78E09;
          v27 = *(_DWORD *)&aResetAllHashBo[16 * k + 2220];
          v17[36] = v27;
          if ( v26 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            if ( v25 == 1 )
              v28 = "up";
            else
              v28 = "down";
            snprintf(
              s,
              0x1000u,
              "%s freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
              v28,
              v3,
              v15,
              v27,
              v17[12],
              v17[24],
              *(v17 - 24),
              v16);
            sub_38730(7, s, 0);
            v27 = v17[36];
          }
          sub_43734((unsigned __int8)v3, (unsigned __int8)v15, v27);
LABEL_46:
          if ( ++v15 != 3 )
          {
            v29 = v17[1];
            ++v17;
            v16 = v29;
            if ( !v29 )
              continue;
            goto LABEL_48;
          }
          break;
        }
LABEL_8:
        ++v3;
      }
      while ( v3 != 4 );
      v6 = dword_7C130;
      v7 = 0;
      v8 = 644283;
      v9 = 0;
      for ( ii = 0; ii != 4; ++ii )
      {
        v11 = *(unsigned __int8 *)++v8;
        if ( v11 == 1 )
        {
          v41 = &dword_7C130[3 * ii];
          v7 += v41[61] + v6[62] + v6[63];
          v9 += v41[73] + v6[74] + v6[75];
          if ( byte_78E09 )
          {
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
            {
              snprintf(s, 0x1000u, "chain%d %d %d %d\n", ii, v6[61], v6[62], v6[63]);
              sub_38730(7, s, 0);
            }
          }
        }
        v6 += 3;
      }
    }
    while ( v9 != 3 * (unsigned __int8)byte_9D6CB );
    v12 = sub_5C710(v7, v9);
    v13 = i == 825;
    if ( v12 > 800 )
      v13 = 1;
    v14 = v12;
    if ( v13 )
    {
      sub_470A8();
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "scan freq done, avg freq %d max %d, reboot cgminer\n", v14, i);
        sub_38730(5, s, 0);
      }
      system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
      goto LABEL_5;
    }
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "scan freq again, avg freq %d max %d\n", v12, 825);
      sub_38730(5, s, 0);
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E3C: using guessed type char byte_78E3C;
// 7AD48: using guessed type char byte_7AD48;
// 7C130: using guessed type int dword_7C130[];
// 9D6CB: using guessed type char byte_9D6CB;

//----- (0004791C) --------------------------------------------------------
void __fastcall sub_4791C(int a1)
{
  pthread_t v2; // r0
  int v3; // r4
  char v4[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(v4, 0x1000u, "%s Begin\n", "bitmain_ZCASH_reinit_chain");
    sub_38730(5, v4, 0);
  }
  v2 = pthread_self();
  pthread_detach(v2);
  pthread_mutex_lock(&stru_79134);
  v3 = *(unsigned __int8 *)(a1 + 4);
  sub_46434(*(_DWORD *)a1, v3);
  sub_42F7C(v3);
  sub_2A92C();
  sub_435E0(v3, *(unsigned __int16 *)((char *)&unk_9D4B4 + 2 * v3 + 593));
  sub_2A92C();
  sub_430A0(v3, 0x13880u);
  sub_2A92C();
  sub_44004(v3, dword_76B60);
  sub_2A92C();
  sub_4601C(v3);
  *((_BYTE *)&dword_78E10 + v3 + 732) = 1;
  sleep(1u);
  pthread_mutex_unlock(&stru_79134);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(v4, 0x1000u, "%s Done\n", "bitmain_ZCASH_reinit_chain");
    sub_38730(5, v4, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 76B60: using guessed type int dword_76B60;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10;
// 7AD48: using guessed type char byte_7AD48;

//----- (00047AAC) --------------------------------------------------------
int __fastcall sub_47AAC(unsigned __int64 a1, char *a2, size_t a3, int a4, char a5)
{
  __int64 v7; // r0
  double v8; // r0
  double v9; // d8
  __int64 v11; // r0
  double v12; // d0
  double v13; // r0
  int v14; // r3
  int v15; // [sp+0h] [bp-24h]
  char v16[8]; // [sp+1Ch] [bp-8h] BYREF

  *(_WORD *)v16 = 0;
  if ( a1 > 0x3B9AC9FF )
  {
    LODWORD(v7) = sub_5CBC4(a1, 1000000);
    LODWORD(v8) = sub_5CB50(v7);
    *(_WORD *)v16 = 71;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xF423F )
  {
    LODWORD(v11) = sub_5CBC4(a1, 1000);
    LODWORD(v8) = sub_5CB50(v11);
    *(_WORD *)v16 = 77;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3E7 )
  {
    LODWORD(v8) = sub_5CB50(a1);
    *(_WORD *)v16 = 75;
    v9 = v8 / 1000.0;
LABEL_3:
    if ( !a4 )
      return snprintf(a2, a3, "%.3g%s", v9, v16);
    goto LABEL_7;
  }
  LODWORD(v8) = sub_5CB50(a1);
  v9 = v8;
  if ( !a4 )
    return snprintf(a2, a3, "%d%s", (unsigned int)v8, v16);
LABEL_7:
  if ( v9 <= 0.0 )
  {
    v12 = 0.0;
  }
  else
  {
    v12 = v9;
    v13 = log10(v8);
    floor(v13);
  }
  v14 = a4 + 1;
  v15 = (int)((double)(a4 - 1) - v12);
  if ( a5 )
    return snprintf(a2, a3, "%*.*f%s", v14, v15, v9, v16);
  else
    return snprintf(a2, a3, "%*.*f", v14, v15, v9);
}
// 47B04: variable 'v7' is possibly undefined
// 47B14: variable 'v8' is possibly undefined
// 47B68: variable 'v11' is possibly undefined

//----- (00047C80) --------------------------------------------------------
int sub_47C80()
{
  unsigned __int64 v0; // d8
  _QWORD *v1; // r9
  int v2; // r11
  int i; // r10
  unsigned int v5; // r3
  int k; // r4
  unsigned int v8; // r3
  char *v9; // r5
  int v10; // r4
  char *v11; // r5
  __int64 v12; // r6
  int v13; // lr
  int j; // r4
  int v15; // t1
  int v16; // r12
  double v17; // r0
  char *v18; // r5
  int v19; // lr
  int v20; // t1
  int v21; // r12
  double v22; // r0
  __int64 v23; // [sp+10h] [bp-1014h]
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  v0 = 0;
  v1 = &unk_79150;
  v2 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    while ( !*(unsigned __int8 *)++v2 )
    {
LABEL_7:
      ++i;
      ++v1;
      if ( i == 4 )
        return sub_47AAC(v0, byte_78B84, 0x10u, 6, 0);
    }
    if ( !byte_79170[i] )
    {
      v5 = (unsigned __int8)(byte_79174[i] + 1);
      byte_79174[i] = v5;
      if ( v5 > 3 || byte_78E3C )
      {
        *v1 = 0;
        sub_47AAC(0, &byte_7C0A8[16 * i], 0x10u, 6, 1);
      }
      goto LABEL_7;
    }
    if ( byte_79170[i] > 2u )
    {
      v9 = (char *)&byte_79170[512 * i];
      v10 = (unsigned __int8)byte_76B70;
      if ( byte_76B70 )
      {
        v11 = v9 + 516;
        v12 = 0;
        v13 = (unsigned __int8)byte_78E09;
        for ( j = 0; j != 3; ++j )
        {
          v15 = *((_DWORD *)v11 + 1);
          v11 += 4;
          v16 = v15 & 0x7FFFFFFF;
          v12 += v15 & 0x7FFFFFFF;
          if ( v13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(s, 0x1000u, "%s: RT g_HASH_RATE_reg_value[%d][%d] = 0x%08x", "calculate_hash_rate", i, j, v16);
            sub_38730(7, s, 0);
            v13 = (unsigned __int8)byte_78E09;
          }
        }
        if ( v13 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          LODWORD(v17) = sub_5CB50(v12);
          snprintf(s, 0x1000u, "%s: chain%d RT hash rate is %0.2fGHz/s", "calculate_hash_rate", i, v17 / 1000000.0);
          sub_38730(7, s, 0);
        }
        byte_79174[i] = 0;
        *v1 = 1000000 * v12;
        sub_47AAC(1000000 * v12, &byte_7C0A8[16 * i], 0x10u, 6, 0);
        v0 += *v1;
      }
      else
      {
        v18 = v9 + 516;
        v19 = (unsigned __int8)byte_78E09;
        v23 = 0;
        do
        {
          v20 = *((_DWORD *)v18 + 1);
          v18 += 4;
          v21 = v20 & 0x7FFFFFFF;
          v23 += v20 & 0x7FFFFFFF;
          if ( v19 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(s, 0x1000u, "%s: avg g_HASH_RATE_reg_value[%d][%d] = 0x%08x", "calculate_hash_rate", i, v10, v21);
            sub_38730(7, s, 0);
            v19 = (unsigned __int8)byte_78E09;
          }
          ++v10;
        }
        while ( v10 != 3 );
        if ( v19 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          LODWORD(v22) = sub_5CB50(v23);
          snprintf(s, 0x1000u, "%s: chain%d avg hash rate is %0.2fGHz/s", "calculate_hash_rate", i, v22 / 1000000.0);
          sub_38730(7, s, 0);
        }
        v0 += *v1;
        byte_79174[i] = 0;
      }
    }
    else
    {
      for ( k = 0; k != 3; ++k )
      {
        if ( !byte_79174[128 * i + 4] && !byte_78E3C && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(
            s,
            0x1000u,
            "%s: Chain%d ASIC%d didn't send back HASH_RATE register value",
            "calculate_hash_rate",
            i,
            k);
          sub_38730(7, s, 0);
        }
      }
      v8 = (unsigned __int8)(byte_79174[i] + 1);
      byte_79174[i] = v8;
      if ( v8 > 3 || byte_78E3C )
      {
        *v1 = 0;
        sub_47AAC(0, &byte_7C0A8[16 * i], 0x10u, 6, 1);
      }
      v0 += *v1;
    }
    ++v1;
  }
  return sub_47AAC(v0, byte_78B84, 0x10u, 6, 0);
}
// 47F90: variable 'v17' is possibly undefined
// 4812C: variable 'v22' is possibly undefined
// 766C4: using guessed type int dword_766C4;
// 76B70: using guessed type char byte_76B70;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E3C: using guessed type char byte_78E3C;
// 79170: using guessed type unsigned __int8 byte_79170[4];
// 79174: using guessed type _BYTE byte_79174[2564];
// 7AD48: using guessed type char byte_7AD48;

//----- (000481B4) --------------------------------------------------------
int sub_481B4()
{
  pthread_mutex_lock(&stru_79B78);
  dword_7BD94 = 0;
  dword_7BD98 = 0;
  dword_7BD9C = 0;
  return pthread_mutex_unlock(&stru_79B78);
}
// 7BD94: using guessed type int dword_7BD94;
// 7BD98: using guessed type int dword_7BD98;
// 7BD9C: using guessed type int dword_7BD9C;

//----- (000481EC) --------------------------------------------------------
int __fastcall sub_481EC(int a1, int a2, int a3, int a4)
{
  size_t v8; // r0
  int v9; // r8
  unsigned int v10; // r5
  int v11; // r10
  int v12; // r11
  int v13; // r5
  int v14; // r3
  int v15; // r1
  int v16; // r2
  unsigned int v17; // r3
  unsigned int v19; // r1
  char *v20; // r0
  _WORD *v21; // r12
  int v22; // [sp+10h] [bp-1024h]
  __int16 v23; // [sp+1Ch] [bp-1018h]
  int v24; // [sp+28h] [bp-100Ch] BYREF
  __int16 v25; // [sp+2Ch] [bp-1008h]
  char v26; // [sp+2Eh] [bp-1006h]
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  v25 = 0;
  v24 = 0;
  v26 = 0;
  sub_481B4();
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(s, 0x1000u, "%s: check chain J%d mode %d chipaddr %02x regaddr %02x", "check_asic_reg", a1, a4, a2, a3);
    sub_38730(7, s, 0);
  }
  v8 = sub_3CEF0((int)&v24, a4, a2, a3);
  sub_3C150(a1, &v24, v8);
  if ( !a3 && *((_BYTE *)&dword_78E10 + a1 + 3456) )
    *((_BYTE *)&unk_9D4B4 + a1 + 529) = 0;
  v9 = a3;
  v10 = 0;
  v11 = a2;
  do
  {
LABEL_10:
    usleep(0x493E0u);
    pthread_mutex_lock(&stru_79B78);
    v12 = dword_7BD9C;
    pthread_mutex_unlock(&stru_79B78);
    if ( v12 )
    {
      v13 = 0;
      while ( 1 )
      {
        pthread_mutex_lock(&stru_79B78);
        v14 = dword_7BD98;
        v15 = *((unsigned __int8 *)&dword_7BD94 + 7 * dword_7BD98 + 18);
        if ( v15 != a1 )
        {
          ++dword_7BD98;
          --dword_7BD9C;
          if ( v14 == 99 )
            dword_7BD98 = 0;
          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
          {
            snprintf(
              s,
              0x1000u,
              "%s: the return data is from chain%d, but it should be from chain%d chipaddr=0x%02x reg=0x%02x\n",
              "check_asic_reg",
              v15,
              a1,
              v11,
              v9);
            sub_38730(5, s, 0);
          }
          goto LABEL_18;
        }
        v16 = *((unsigned __int8 *)&dword_7BD94 + 7 * dword_7BD98 + 17);
        v17 = bswap32(*(int *)((char *)&dword_7BD94 + 7 * dword_7BD98 + 13));
        switch ( v9 )
        {
          case 0:
            if ( *((_BYTE *)&dword_78E10 + a1 + 3456) )
            {
              ++*((_BYTE *)&unk_9D4B4 + a1 + 529);
              goto LABEL_23;
            }
            if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic address is 0x%08x", "check_asic_reg", v17);
            goto LABEL_31;
          case 12:
            if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic freq is 0x%08x", "check_asic_reg", v17);
            goto LABEL_31;
          case 20:
            if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic tm is 0x%08x", "check_asic_reg", v17);
            goto LABEL_31;
          case 28:
            if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic misc is 0x%08x", "check_asic_reg", v17);
            goto LABEL_31;
        }
        if ( v9 != 32 )
        {
          if ( v9 == 84 )
          {
            if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the start nonce offset is 0x%08x", "check_asic_reg", v17);
          }
          else
          {
            if ( v9 != 48 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic IO strength is 0x%08x", "check_asic_reg", v17);
          }
LABEL_31:
          sub_38730(5, s, 0);
          goto LABEL_23;
        }
        v19 = v17 & 0xC0000000;
        if ( (v17 & 0xC0000000) == 0 )
        {
          v20 = &byte_79BA4[12 * a1 + 16];
          v23 = (unsigned __int8)v17 - 64;
          v22 = v17 & 0xFF00;
          v21 = (_WORD *)((char *)&unk_9D4B4 + 24 * a1 + 128);
          if ( (unsigned __int8)byte_79130[0] == v16 )
          {
LABEL_61:
            if ( (v17 & 0xFF00) != 0 )
            {
              switch ( v22 )
              {
                case 256:
                  v21[1] = v23;
                  v20[1] = 1;
                  break;
                case 4352:
                  byte_79B94[4 * a1 + v19] = v17;
                  v20[2] = 1;
                  break;
                case 65024:
                  byte_79BA4[4 * a1 + v19] = v17;
                  v20[3] = 1;
                  break;
              }
            }
            else
            {
              *v21 = v23;
              *v20 = 1;
            }
          }
          while ( 1 )
          {
            ++v19;
            v21 += 4;
            v20 += 4;
            if ( v19 == 3 )
              break;
            if ( (unsigned __int8)byte_79130[v19] == v16 )
              goto LABEL_61;
          }
        }
LABEL_23:
        ++dword_7BD98;
        --dword_7BD9C;
        if ( dword_7BD98 == 100 )
          dword_7BD98 = 0;
LABEL_18:
        ++v13;
        pthread_mutex_unlock(&stru_79B78);
        if ( v13 == v12 )
        {
          v10 = 0;
          goto LABEL_10;
        }
      }
    }
    ++v10;
    usleep(0x186A0u);
  }
  while ( v10 <= 2 );
  if ( !v9 )
  {
    if ( (unsigned __int8)byte_9D6F4 < (unsigned int)*((unsigned __int8 *)&unk_9D4B4 + a1 + 529) )
      byte_9D6F4 = *((_BYTE *)&unk_9D4B4 + a1 + 529);
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(
        s,
        0x1000u,
        "%s: chain J%d has %d ASIC",
        "check_asic_reg",
        a1,
        *((unsigned __int8 *)&unk_9D4B4 + a1 + 529));
      sub_38730(5, s, 0);
    }
  }
  return sub_481B4();
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E10: using guessed type int dword_78E10;
// 79B94: using guessed type _BYTE byte_79B94[16];
// 79BA4: using guessed type _BYTE byte_79BA4[64];
// 7AD48: using guessed type char byte_7AD48;
// 7BD94: using guessed type int dword_7BD94;
// 7BD98: using guessed type int dword_7BD98;
// 7BD9C: using guessed type int dword_7BD9C;
// 9D6F4: using guessed type char byte_9D6F4;

//----- (0004886C) --------------------------------------------------------
void __fastcall sub_4886C(int a1, int a2, char a3, unsigned int a4)
{
  int v8; // r9
  int v9; // r4
  char *v10; // r9
  _DWORD v11[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v12; // [sp+14h] [bp-1008h]
  char v13; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v11[1] = 0;
  v12 = 0;
  v11[0] = 0;
  v13 = 0;
  sub_2A92C();
  if ( a4 < 2 )
  {
    v8 = a4;
  }
  else if ( a4 == 17 )
  {
    v8 = 2;
  }
  else
  {
    if ( a4 != 254 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
      {
        snprintf(s, 0x1000u, "%s unknow reg_type %d\n", "read_i2c_reg", a4);
        sub_38730(4, s, 0);
      }
      return;
    }
    v8 = 3;
  }
  v9 = 3;
  sub_3CDCC(
    (int)v11,
    0,
    *((_BYTE *)&dword_78E10[200] + a2),
    32,
    dword_76B6C & 0xFE000000 | 0x1000000 | ((a3 & 0x7F) << 17) | (unsigned __int16)((unsigned __int8)a4 << 8));
  sub_3C150(a1, v11, 0xBu);
  sub_2A92C();
  v10 = (char *)&dword_78E10[3 * a1 + a2] + v8;
  v10[3492] = 0;
  do
  {
    sub_2A92C();
    sub_481EC(a1, *((unsigned __int8 *)&dword_78E10[200] + a2), 32, 0);
    if ( v10[3492] )
      break;
    --v9;
  }
  while ( v9 );
}
// 766C4: using guessed type int dword_766C4;
// 76B6C: using guessed type int dword_76B6C;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10[];
// 7AD48: using guessed type char byte_7AD48;

//----- (00048A18) --------------------------------------------------------
void __noreturn sub_48A18()
{
  int v0; // r6
  int v1; // r4
  int v2; // r5
  int v3; // t1
  __int16 *v4; // r5
  int v5; // r4
  int v6; // r9
  int v7; // r11
  int v8; // r10
  int v9; // t1
  __int16 *v10; // r7
  _BYTE *v11; // r8
  __int16 *v12; // r3
  int v13; // r5
  int v14; // r4
  __int16 *v15; // r12
  __int16 v16; // r2
  __int16 v17; // r2
  int v18; // r1
  int v19; // r2
  char *v20; // r12
  int v21; // lr
  int v22; // r3
  int v23; // r0
  int i; // r8
  int v25; // r10
  int v26; // r1
  __int16 *v27; // [sp+14h] [bp-1028h]
  __int16 *v28; // [sp+14h] [bp-1028h]
  char v29[4100]; // [sp+38h] [bp-1004h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v29, "read_temp_func");
    sub_38730(7, v29, 0);
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v0 = 644283;
      sleep(1u);
      v1 = 0;
      v2 = 644283;
      do
      {
        v3 = *(unsigned __int8 *)++v2;
        if ( v3 == 1 && byte_790EC[v1] )
        {
          for ( i = 0; i != 3; ++i )
          {
            v25 = (unsigned __int8)i;
            v26 = (unsigned __int8)i;
            sub_4886C((unsigned __int8)v1, v26, 76, 1u);
            sub_4886C((unsigned __int8)v1, v25, 76, 0);
          }
        }
        ++v1;
        sub_2A92C();
      }
      while ( v1 != 4 );
      v4 = (__int16 *)&unk_9D4B4;
      v5 = 0;
      v6 = -256;
      v7 = 0;
      v8 = -256;
      do
      {
        v9 = *(unsigned __int8 *)++v0;
        if ( v9 == 1 && byte_790EC[v5] )
        {
          v10 = (__int16 *)((char *)&unk_9D4B4 + 24 * v5 + 130);
          v11 = &byte_79BA4[12 * v5 + 16];
          v12 = v4;
          v13 = v5;
          v14 = 0;
          v15 = v12;
          do
          {
            if ( *v11 )
            {
              v7 = 1;
            }
            else if ( v11[1] )
            {
              v7 = 1;
            }
            v16 = *(v10 - 1);
            if ( v16 > v6 )
            {
              if ( v16 > 80 && !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
              {
                v6 = v16;
                v27 = v15;
                snprintf(
                  v29,
                  0x1000u,
                  "%s: Chain%d sensor%d local temp is %d `C, higher than MAX_TEMP",
                  "read_temp_func",
                  v13,
                  v14,
                  v16);
                sub_38730(3, v29, 0);
                v15 = v27;
              }
              else
              {
                v6 = v16;
              }
            }
            v17 = *v10;
            if ( *v10 > v8 )
            {
              if ( v17 > 110 && !byte_78E3C && (byte_7AD48 || byte_78E08 || dword_766C4 > 2) )
              {
                v8 = v17;
                v28 = v15;
                snprintf(
                  v29,
                  0x1000u,
                  "%s: Chain%d sensor%d remote temp is %d `C, higher than MAX_CHIP_TEMP",
                  "read_temp_func",
                  v13,
                  v14,
                  v17);
                sub_38730(3, v29, 0);
                v15 = v28;
              }
              else
              {
                v8 = v17;
              }
            }
            ++v14;
            v11 += 4;
            v10 += 4;
          }
          while ( v14 != 3 );
          v5 = v13;
          v18 = v15[68];
          v4 = v15;
          v19 = v15[64];
          v20 = (char *)&unk_9D4B4 + 4 * v5;
          v21 = v4[65];
          v22 = -256;
          if ( v18 >= v19 )
            v19 = v18;
          if ( v19 < -256 )
            v19 = -256;
          if ( v21 < v4[69] )
            v21 = v4[69];
          if ( v21 >= -256 )
            v22 = v21;
          if ( v4[72] >= v19 )
            v19 = v4[72];
          if ( v4[73] >= v22 )
            v22 = v4[73];
          v23 = (unsigned __int8)byte_78E09;
          *(_DWORD *)(v20 + 653) = v19;
          *(_DWORD *)(v20 + 669) = v22;
          if ( v23 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
          {
            snprintf(v29, 0x1000u, "chain%d, max local temp :%d, max remote temp: %d", v5, v19, v22);
            sub_38730(7, v29, 0);
          }
        }
        ++v5;
        v4 += 12;
      }
      while ( v5 != 4 );
      dword_9D6D6 = v6;
      dword_9D6DA = v8;
      if ( !v7 )
        break;
      byte_79126 = 0;
      if ( !byte_790F0 )
        goto LABEL_16;
LABEL_62:
      sub_45D88(100);
    }
    byte_79126 = 1;
    if ( !byte_78E3C && byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v29, 0x1000u, "%s: can't read all sensor's temperature, close PIC and need reboot!!!", "read_temp_func");
      sub_38730(7, v29, 0);
    }
    if ( byte_790F0 )
      goto LABEL_62;
LABEL_16:
    sub_45EC0();
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E3C: using guessed type char byte_78E3C;
// 790F0: using guessed type char byte_790F0;
// 79126: using guessed type char byte_79126;
// 79BA4: using guessed type _BYTE byte_79BA4[64];
// 7AD48: using guessed type char byte_7AD48;
// 9D6D6: using guessed type int dword_9D6D6;
// 9D6DA: using guessed type int dword_9D6DA;

//----- (00048FA8) --------------------------------------------------------
void sub_48FA8()
{
  int v0; // r6
  int i; // r4
  int v2; // t1
  int j; // r5
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(s, "check_sensor_ID");
    sub_38730(7, s, 0);
  }
  v0 = 644283;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      for ( j = 0; j != 3; ++j )
      {
        sub_4886C((unsigned __int8)i, (unsigned __int8)j, 76, 0xFEu);
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf(
            s,
            0x1000u,
            "%s: Chain%d Sensor%d Manufacturer ID = 0x%02x",
            "check_sensor_ID",
            i,
            j,
            (char)byte_79BA4[4 * i + j]);
          sub_38730(3, s, 0);
        }
      }
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 79BA4: using guessed type _BYTE byte_79BA4[64];
// 7AD48: using guessed type char byte_7AD48;

//----- (000490FC) --------------------------------------------------------
void __fastcall sub_490FC(int a1, int a2)
{
  char *v4; // r6
  int v5; // r3
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
  {
    snprintf(s, 0x1000u, "Chain %d %s", a1, "set_temperature_offset_value_chain_sensor");
    sub_38730(4, s, 0);
  }
  v4 = (char *)&dword_78E10[a1] + a2;
  sub_4633C(a1, a2, 76, 0x11u, v4[3540]);
  sub_2A92C();
  sub_4886C(a1, a2, 76, 0x11u);
  v5 = v4[3460];
  if ( v5 == v4[3540] )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(
        s,
        0x1000u,
        "%s: Chain%d Sensor%d temp offset : %02d, ",
        "set_temperature_offset_value_chain_sensor",
        a1,
        a2,
        v4[3460]);
      sub_38730(5, s, 0);
    }
  }
  else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s: Chain%d Sensor%d temp offset value set error. It should be %02d, but read back is %02d\n",
      "set_temperature_offset_value_chain_sensor",
      a1,
      a2,
      v4[3540],
      v5);
    sub_38730(3, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10[];
// 7AD48: using guessed type char byte_7AD48;

//----- (000492B0) --------------------------------------------------------
void __fastcall sub_492B0(int a1)
{
  int v2; // r7
  __int16 *v3; // r5
  int v4; // r10
  __int16 v5; // r2
  __int16 v6; // r3
  int v7; // r11
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "%d %s", a1, "calibration_sensor_offset_chain");
    sub_38730(5, s, 0);
  }
  v2 = 0;
  v3 = (__int16 *)((char *)&unk_9D534 + 24 * a1);
  do
  {
    LOBYTE(v4) = 11;
    do
    {
      sub_4886C(a1, (unsigned __int8)v2, 76, 1u);
      sub_4886C(a1, (unsigned __int8)v2, 76, 0);
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        snprintf(s, 0x1000u, "chain:%d local:%d remote:%d", a1, *v3, v3[1]);
        sub_38730(5, s, 0);
      }
      v5 = *v3;
      v6 = v3[1];
      v7 = *v3 - v6;
      if ( v7 < 0 )
        v7 = v6 - v5;
      byte_79BE4[4 * a1 + v2] = v5 + byte_79BE4[4 * a1 + v2] - v6;
      if ( v7 <= 2 )
        break;
      sub_490FC(a1, (unsigned __int8)v2);
      v4 = (unsigned __int8)(v4 - 1);
    }
    while ( v4 );
    ++v2;
    v3 += 4;
  }
  while ( v2 != 3 );
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 79BE4: using guessed type _BYTE byte_79BE4[16];
// 7AD48: using guessed type char byte_7AD48;

//----- (00049458) --------------------------------------------------------
int sub_49458()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1
  int result; // r0

  v0 = 0;
  v1 = 644283;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
    {
      sub_492B0(v0);
      result = sub_2A92C();
    }
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
  return result;
}

//----- (0004949C) --------------------------------------------------------
int __fastcall sub_4949C(int result)
{
  int v1; // r6
  int v2; // r7
  int v3; // r4
  int v4; // t1
  int v5; // [sp+0h] [bp-Ch] BYREF
  __int16 v6; // [sp+4h] [bp-8h]
  char v7; // [sp+6h] [bp-6h]

  v1 = 644283;
  v2 = result;
  v3 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  do
  {
    v4 = *(unsigned __int8 *)++v1;
    if ( v4 == 1 )
    {
      sub_3CEF0((int)&v5, 1, 0, v2);
      sub_3C150(v3, &v5, 7u);
      sub_2A92C();
      result = sub_481EC(v3, 0, v2, 1);
    }
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
  return result;
}

//----- (0004952C) --------------------------------------------------------
int __fastcall sub_4952C(int result, char a2)
{
  if ( *((_BYTE *)&unk_9D4B4 + result + 8) )
  {
    *((_BYTE *)&dword_78E10[864] + result) = a2;
    return sub_481EC(result, 0, 0, 1);
  }
  return result;
}
// 78E10: using guessed type int dword_78E10[];

//----- (00049578) --------------------------------------------------------
int __fastcall sub_49578(char a1)
{
  int v2; // r4
  int result; // r0
  char v4[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(v4, "check_every_chain_asic_number");
    sub_38730(5, v4, 0);
  }
  v2 = 0;
  do
  {
    sub_4952C(v2, a1);
    v2 = (unsigned __int8)(v2 + 1);
    result = sub_2A92C();
  }
  while ( (unsigned __int8)v2 != 4 );
  return result;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (0004962C) --------------------------------------------------------
void sub_4962C()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(v3, "check_every_chain_asic_pll");
    sub_38730(5, v3, 0);
  }
  v0 = 644283;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      sub_481EC(i, 0, 12, 1);
      sub_2A92C();
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00049700) --------------------------------------------------------
void __fastcall sub_49700(int a1, int a2)
{
  char v4[4100]; // [sp+0h] [bp-1004h] BYREF

  pthread_mutex_lock(&stru_79134);
  sub_46434(a1, a2);
  pthread_mutex_unlock(&stru_79134);
  sub_481B4();
  sub_2A92C();
  sub_4952C(a2, 1);
  sub_2A92C();
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(v4, 0x1000u, "%s DONE!", "recheck_asic_num");
    sub_38730(5, v4, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (000497CC) --------------------------------------------------------
int sub_497CC()
{
  pthread_mutex_lock(&stru_78E88);
  dword_7C28C = 0;
  dword_7C290 = 0;
  dword_7C294 = 0;
  sub_3C0A0(0);
  sub_3C0A0(1);
  sub_3C0A0(2);
  sub_3C0A0(3);
  return pthread_mutex_unlock(&stru_78E88);
}
// 7C28C: using guessed type int dword_7C28C;
// 7C290: using guessed type int dword_7C290;
// 7C294: using guessed type int dword_7C294;

//----- (00049824) --------------------------------------------------------
int __fastcall sub_49824(int a1)
{
  int v1; // r0
  _DWORD *v2; // r3
  char v3; // t1
  int v4; // r8
  int v5; // r5
  int v6; // r7
  int v7; // r4
  _DWORD v10[7]; // [sp+0h] [bp-20h] BYREF
  int v11; // [sp+1Ch] [bp-4h] BYREF

  v1 = a1 + 32;
  v2 = (_DWORD *)((char *)&v10[-1] + 3);
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  do
  {
    v3 = *(_BYTE *)--v1;
    *((_BYTE *)v2 + 1) = v3;
    v2 = (_DWORD *)((char *)v2 + 1);
  }
  while ( v2 != (int *)((char *)&v11 + 3) );
  v4 = 0;
  v5 = 0;
LABEL_4:
  v6 = v5 + 8;
  v7 = 7;
  while ( !sub_42958((int)v10 + v4, v7--) )
  {
    if ( ++v5 == v6 )
    {
      if ( ++v4 != 32 )
        goto LABEL_4;
      return v5;
    }
  }
  return v5;
}

//----- (000498C0) --------------------------------------------------------
int __fastcall sub_498C0(int a1, int a2)
{
  int v2; // r3
  unsigned int v3; // r12
  unsigned int v4; // r2

  v2 = 31;
  while ( 1 )
  {
    v3 = *(unsigned __int8 *)(a1 + v2);
    v4 = *(unsigned __int8 *)(a2 + v2--);
    if ( v3 < v4 )
      return 1;
    if ( v3 > v4 )
      break;
    if ( v2 == -1 )
      return 1;
  }
  return 0;
}

//----- (000498F4) --------------------------------------------------------
int sub_498F4()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_7C284 = (int)calloc(1u, 0x40u);
  if ( sub_2F174(dword_7C284, 0, (void *(*)(void *))sub_3AA9C, 0) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_check_fan_pthread");
      sub_38730(7, v1, 0);
    }
    return -8;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_7C284 + 12));
    return sub_2A92C();
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7C284: using guessed type int dword_7C284;

//----- (000499D4) --------------------------------------------------------
int __fastcall sub_499D4(void *a1)
{
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  dword_7C060 = (int)calloc(1u, 0x40u);
  if ( sub_2F174(dword_7C060, 0, (void *(*)(void *))sub_44B5C, a1) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v3, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_check_miner_status_pthread");
      sub_38730(7, v3, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_7C060 + 12));
    return sub_2A92C();
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7C060: using guessed type int dword_7C060;

//----- (00049AC0) --------------------------------------------------------
int sub_49AC0()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_7C05C = (int)calloc(1u, 0x40u);
  if ( sub_2F174(dword_7C05C, 0, (void *(*)(void *))sub_3ABF4, (void *)dword_7C05C) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(
        v1,
        0x1000u,
        "%s: create thread for get hashrate from asic failed",
        "create_bitmain_get_hash_rate_pthread");
      sub_38730(7, v1, 0);
    }
    return -6;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_7C05C + 12));
    return sub_2A92C();
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7C05C: using guessed type int dword_7C05C;

//----- (00049BA0) --------------------------------------------------------
int __fastcall sub_49BA0(int a1)
{
  int v1; // r4
  int v2; // r6

  v1 = (a1 << 16) | 0x1900000;
  pthread_mutex_lock(&stru_790A0);
  v2 = sub_3C708(v1);
  sub_3C708(v1);
  sub_2A92C();
  pthread_mutex_unlock(&stru_790A0);
  return v2;
}

//----- (00049BE8) --------------------------------------------------------
int sub_49BE8()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_7C12C = (int)calloc(1u, 0x40u);
  if ( sub_2F174(dword_7C12C, 0, (void *(*)(void *))sub_48A18, (void *)dword_7C12C) )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for read temp", "create_bitmain_read_temp_pthread");
      sub_38730(7, v1, 0);
    }
    return -7;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_7C12C + 12));
    return sub_2A92C();
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7C12C: using guessed type int dword_7C12C;

//----- (00049CC8) --------------------------------------------------------
int __fastcall sub_49CC8(int a1)
{
  int *v2; // r3
  int v3; // r12
  int v4; // r1
  int v5; // t1
  _BYTE *v6; // r2
  _BYTE *v7; // r2
  int v8; // r1
  int v9; // r10
  int *v11; // r2
  unsigned int v12; // r3
  int v13; // t1
  int v14; // r3
  int v15; // r2
  int v16; // r2
  int v17; // r10
  char *v18; // r9
  int v19; // t1
  unsigned int v20; // r7
  _BOOL4 v21; // r1
  bool v22; // zf
  int v23; // r11
  int v24; // r3
  int v25; // r2
  char v26; // [sp+14h] [bp-1048h]
  int v27; // [sp+18h] [bp-1044h]
  int v28; // [sp+1Ch] [bp-1040h]
  int v29; // [sp+20h] [bp-103Ch]
  int v30; // [sp+24h] [bp-1038h]
  int v31; // [sp+28h] [bp-1034h]
  int v32; // [sp+2Ch] [bp-1030h]
  int v33; // [sp+30h] [bp-102Ch]
  int v34; // [sp+34h] [bp-1028h]
  int v35; // [sp+38h] [bp-1024h] BYREF
  int v36; // [sp+3Ch] [bp-1020h]
  int v37; // [sp+40h] [bp-101Ch]
  int v38; // [sp+44h] [bp-1018h]
  int v39; // [sp+48h] [bp-1014h]
  int v40; // [sp+4Ch] [bp-1010h]
  int v41; // [sp+50h] [bp-100Ch]
  int v42; // [sp+54h] [bp-1008h] BYREF
  char s[4072]; // [sp+58h] [bp-1004h] BYREF

  v27 = *(_DWORD *)(a1 + 1170);
  v28 = *(_DWORD *)(a1 + 1174);
  v29 = *(_DWORD *)(a1 + 1178);
  v30 = *(_DWORD *)(a1 + 1182);
  v31 = *(_DWORD *)(a1 + 1186);
  v32 = *(_DWORD *)(a1 + 1190);
  v33 = *(_DWORD *)(a1 + 1194);
  v34 = *(_DWORD *)(a1 + 1198);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(s, "z15 init...\n");
    sub_38730(5, s, 0);
  }
  sub_56A90();
  while ( 1 )
  {
    if ( dword_7B198 > 0 )
    {
      v2 = (int *)dword_7B438;
      v3 = 0;
      do
      {
        v5 = *v2++;
        v4 = v5;
        v6 = *(_BYTE **)(v5 + 196);
        if ( v6 )
        {
          if ( *v6 )
          {
            v7 = *(_BYTE **)(v4 + 204);
            if ( v7 )
            {
              if ( *v7 )
                ++v3;
            }
          }
        }
      }
      while ( v2 != (int *)(dword_7B438 + 4 * dword_7B198) );
      if ( v3 )
        break;
    }
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
    {
      strcpy(s, "No valid pools, please configure them first!!!");
      sub_38730(4, s, 0);
    }
    sleep(5u);
  }
  sub_3B704();
  sub_3BA70();
  sub_3BB44(26);
  v35 = v27;
  v36 = v28;
  v37 = v29;
  v38 = v30;
  byte_9D6F3 = 1;
  v39 = v31;
  v40 = v32;
  v41 = v33;
  v42 = v34;
  strcpy((char *)&dword_78B94, "9.0.0.5");
  sub_45B30();
  sub_45D88((unsigned __int8)dword_76B78);
  sub_45B50();
  v8 = (unsigned __int8)v27;
  if ( (unsigned __int8)v27 != 81 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
      return -1;
    v9 = -1;
    snprintf(
      s,
      0x1000u,
      "%s: config_parameter.token_type != 0x%x, it is 0x%x",
      "bitmain_ZCASH_init",
      81,
      (unsigned __int8)v35);
LABEL_25:
    sub_38730(3, s, 0);
    return v9;
  }
  v11 = &v35;
  v12 = 255;
  while ( 1 )
  {
    v12 = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v8 ^ (v12 >> 8)) + 404] ^ ((_WORD)v12 << 8));
    if ( v11 == (int *)((char *)&v42 + 1) )
      break;
    v13 = *((unsigned __int8 *)v11 + 1);
    v11 = (int *)((char *)v11 + 1);
    v8 = v13;
  }
  if ( HIWORD(v42) != v12 )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 2 )
      return -2;
    v9 = -2;
    snprintf(
      s,
      0x1000u,
      "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x",
      "bitmain_ZCASH_init",
      HIWORD(v42),
      v12);
    goto LABEL_25;
  }
  v14 = 0;
  do
  {
    v15 = v14 + 28;
    ++v14;
    v16 = a1 + 4 * v15;
    *(_WORD *)(v16 + 6) = 0;
    *(_WORD *)(v16 + 8) = 0;
  }
  while ( v14 != 128 );
  sub_44978();
  if ( byte_78E28 )
  {
    BYTE2(v38) = 50;
    dword_78E38 = (unsigned __int8)byte_9D6CB;
    LOBYTE(v37) = v37 | 2;
  }
  sub_41308();
  sub_413F0();
  sleep(1u);
  v9 = sub_416EC();
  if ( v9 != -3 )
  {
    if ( !access("/tmp/delete_freq", 0) )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        strcpy(s, "delete freq data and scan freq again\n");
        sub_38730(5, s, 0);
      }
      memset(s, 0, 36);
      sub_46B94((unsigned __int8 *)s);
      system("rm /tmp/delete_freq");
      sleep(3u);
      exit(1);
    }
    v26 = v37;
    if ( (v37 & 8) == 0 )
      goto LABEL_45;
    v22 = (unsigned __int16)v39 == 800;
    if ( (unsigned __int16)v39 != 800 )
      v22 = (unsigned __int16)v39 == 0;
    if ( v22 )
LABEL_45:
      dword_9D6F8 = dword_9D6F8 & 0xFF0000FF | 0x32000;
    else
      *(_WORD *)((char *)&dword_9D6F8 + 1) = v39;
    sub_3A354();
    sub_2A92C();
    sub_414D8();
    sub_2A92C();
    sub_2A92C();
    sub_41614();
    sub_2A92C();
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
    {
      snprintf(s, 0x1000u, "%s %d", "reset_all_hash_board_high", 4392);
      sub_38730(5, s, 0);
    }
    v17 = 0;
    v18 = &byte_9D4BC;
    *(_DWORD *)(dword_78E10[0] + 52) = 0;
    sub_2A92C();
    sub_448BC(a1);
    sleep(3u);
    sub_43F04(v36);
    sub_2A92C();
    sub_467B0();
    byte_9D6F2 = 1;
    sub_481B4();
    sub_2A92C();
    sleep(2u);
    sub_49578(1);
    sub_2A92C();
    do
    {
      v19 = (unsigned __int8)*v18++;
      if ( v19 == 1 )
      {
        v23 = 3;
        byte_79BF4[v17] = 1;
        while ( 1 )
        {
          v24 = (unsigned __int8)v18[520];
          if ( v24 == 3 )
            break;
          v25 = (unsigned __int8)byte_7AD48;
          byte_79BF4[v17] = 1;
          if ( !v25 && !byte_78E08 && dword_766C4 <= 4
            || (snprintf(
                  s,
                  0x1000u,
                  "recheck: chainid %d exist %d asicnum %d realnum %d",
                  v17,
                  (unsigned __int8)*(v18 - 1),
                  v24,
                  3),
                sub_38730(5, s, 0),
                byte_79BF4[v17]) )
          {
            sub_49700(a1, (unsigned __int8)v17);
            if ( --v23 )
              continue;
          }
          goto LABEL_52;
        }
        byte_79BF4[v17] = 0;
      }
LABEL_52:
      ++v17;
    }
    while ( v17 != 4 );
    sub_46CBC();
    sub_44104(dword_76B60);
    sub_2A92C();
    sub_43060();
    sub_2A92C();
    sub_432C0(dword_76B74);
    sub_2A92C();
    sub_4330C(0);
    sub_2A92C();
    sub_4614C();
    sub_463C8();
    sub_43594(0);
    if ( (v26 & 4) != 0 )
    {
      dword_9D4C4 = 100000000;
      if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 4 )
      {
        v20 = BYTE2(v38);
        byte_9D6F7 = (v37 & 2) != 0;
        v21 = (v37 & 2) != 0;
        LOBYTE(dword_9D6F8) = BYTE2(v38);
LABEL_58:
        if ( !byte_78E08 && dword_766C4 <= 4 )
        {
LABEL_61:
          if ( (v26 & 2) != 0 && v20 <= 0x64 )
            sub_45D88(v20);
          else
            sub_45EC0();
          v9 = sub_498F4();
          if ( v9 != -8 )
          {
            sleep(1u);
            sub_49BE8();
            if ( v9 != -7 )
            {
              v9 = sub_499D4((void *)a1);
              if ( v9 != -5 )
              {
                v9 = sub_49AC0();
                if ( v9 != -6 )
                {
                  sub_442B0();
                  byte_790EC[0] = 1;
                  byte_790ED = 1;
                  byte_790EE = 1;
                  byte_790EF = 1;
                  if ( byte_7AD48 || (v9 = (unsigned __int8)byte_78E08, byte_78E08) || dword_766C4 > 4 )
                  {
                    v9 = 0;
                    snprintf(s, 0x1000u, "%s done", "bitmain_ZCASH_init");
                    sub_38730(5, s, 0);
                  }
                }
              }
            }
          }
          return v9;
        }
LABEL_60:
        snprintf(s, 0x1000u, "%s: fan_eft : %d  fan_pwm : %d", "bitmain_ZCASH_init", v21, v20);
        sub_38730(5, s, 0);
        goto LABEL_61;
      }
      snprintf(s, 0x1000u, "dev.timeout = %d us", 100000000);
      sub_38730(5, s, 0);
    }
    v20 = BYTE2(v38);
    byte_9D6F7 = (v37 & 2) != 0;
    v21 = (v37 & 2) != 0;
    LOBYTE(dword_9D6F8) = BYTE2(v38);
    if ( byte_7AD48 )
      goto LABEL_60;
    goto LABEL_58;
  }
  return v9;
}
// 766C4: using guessed type int dword_766C4;
// 76B60: using guessed type int dword_76B60;
// 76B74: using guessed type int dword_76B74;
// 76B78: using guessed type int dword_76B78;
// 78B94: using guessed type int dword_78B94;
// 78B98: using guessed type int dword_78B98;
// 78E08: using guessed type char byte_78E08;
// 78E10: using guessed type int dword_78E10[];
// 78E28: using guessed type char byte_78E28;
// 78E38: using guessed type int dword_78E38;
// 790ED: using guessed type char byte_790ED;
// 790EE: using guessed type char byte_790EE;
// 790EF: using guessed type char byte_790EF;
// 79BF4: using guessed type _BYTE byte_79BF4[4];
// 7AD48: using guessed type char byte_7AD48;
// 7B198: using guessed type int dword_7B198;
// 7B438: using guessed type int dword_7B438;
// 9D4BC: using guessed type char byte_9D4BC;
// 9D4C4: using guessed type int dword_9D4C4;
// 9D6CB: using guessed type char byte_9D6CB;
// 9D6F2: using guessed type char byte_9D6F2;
// 9D6F3: using guessed type char byte_9D6F3;
// 9D6F7: using guessed type char byte_9D6F7;
// 9D6F8: using guessed type int dword_9D6F8;

//----- (0004A598) --------------------------------------------------------
int __fastcall sub_4A598(int a1)
{
  int v1; // r4
  int v2; // r2
  int *v3; // r3
  unsigned int v4; // r12
  int v5; // t1
  int v6; // r1
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v13; // [sp+0h] [bp-24h] BYREF
  int v14; // [sp+4h] [bp-20h]
  int v15; // [sp+8h] [bp-1Ch]
  int v16; // [sp+Ch] [bp-18h]
  __int64 v17; // [sp+10h] [bp-14h] BYREF
  int v18; // [sp+18h] [bp-Ch]
  int v19; // [sp+1Ch] [bp-8h] BYREF

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20);
  *(_DWORD *)(v1 + 630) = a1;
  if ( pthread_mutex_init((pthread_mutex_t *)(v1 + 1146), 0) )
    sub_B8B8(7498);
  if ( pthread_mutex_init((pthread_mutex_t *)v1, 0) )
    sub_B8B8(7499);
  sub_3AF0C((pthread_rwlock_t *)(v1 + 24));
  HIWORD(v15) = 0;
  v2 = 81;
  v19 = 4;
  BYTE2(v16) = dword_76B78;
  v3 = &v13;
  LOBYTE(v15) = ~(~(((2 * (byte_79BF8 & 1)) | 1u) << 30) >> 30);
  v14 = 0;
  v18 = 0;
  v4 = 255;
  LOWORD(v17) = dword_76B7C;
  v13 = 1572945;
  BYTE1(v15) = 7;
  LOWORD(v16) = 774;
  HIBYTE(v16) = 80;
  BYTE2(v17) = 7;
  strcpy((char *)&v17 + 3, "%\n\n");
  HIBYTE(v17) = 0;
  while ( 1 )
  {
    LOWORD(v4) = *(_WORD *)&aResetAllHashBo[2 * (v2 ^ (v4 >> 8)) + 404] ^ ((_WORD)v4 << 8);
    if ( v3 == (int *)((char *)&v19 + 1) )
      break;
    v5 = *((unsigned __int8 *)v3 + 1);
    v3 = (int *)((char *)v3 + 1);
    v2 = v5;
  }
  HIWORD(v19) = v4;
  v6 = v14;
  v7 = v15;
  v8 = v16;
  *(_DWORD *)(v1 + 1170) = v13;
  *(_DWORD *)(v1 + 1174) = v6;
  *(_DWORD *)(v1 + 1178) = v7;
  *(_DWORD *)(v1 + 1182) = v8;
  v9 = HIDWORD(v17);
  v10 = v18;
  v11 = v19;
  *(_DWORD *)(v1 + 1186) = v17;
  *(_DWORD *)(v1 + 1190) = v9;
  *(_DWORD *)(v1 + 1194) = v10;
  *(_DWORD *)(v1 + 1198) = v11;
  sub_49CC8(v1);
  return 1;
}
// 76B78: using guessed type int dword_76B78;
// 76B7C: using guessed type int dword_76B7C;
// 79BF8: using guessed type char byte_79BF8;

//----- (0004A730) --------------------------------------------------------
int __fastcall sub_4A730(int a1, int a2)
{
  if ( a1 )
    return a1 - 1;
  else
    return a2 - 1;
}

//----- (0004A740) --------------------------------------------------------
int __fastcall sub_4A740(int a1, int a2)
{
  if ( a2 - 1 <= a1 )
    return 0;
  else
    return a1 + 1;
}

//----- (0004A754) --------------------------------------------------------
int __fastcall sub_4A754(int a1, int a2, int a3, int a4, char a5)
{
  unsigned __int8 v6; // r0
  int v7; // r5
  int v9; // r8
  int v10; // r6
  int v11; // r10
  unsigned __int8 *v12; // r2
  unsigned int v13; // r3
  unsigned __int8 *v14; // r0
  int v15; // t1
  int v16; // r11
  int v17; // r2
  int v18; // r3
  char v19; // r1
  int v20; // r3
  int v21; // r1
  int v22; // r2
  int v23; // r4
  int v24; // r0
  int v25; // r3
  int v26; // r2
  int v27; // r0
  int v28; // r3
  int v29; // r3
  int v30; // r0
  char *v31; // r5
  char *v32; // r7
  int v33; // r1
  void *v34; // r0
  unsigned int v35; // r6
  char *v36; // r12
  __int16 s1; // [sp+16h] [bp-1006h] BYREF
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v6 = *(_BYTE *)(a3 + 3) / (unsigned __int8)byte_9D6F3;
  v7 = v6;
  if ( v6 > 2u )
  {
    if ( !byte_7AD48 && !byte_78E08 && dword_766C4 <= 3 )
      return -1;
    snprintf(s, 0x1000u, "%s chipid %d is not exist", "nonce_handle", v6);
LABEL_6:
    sub_38730(4, s, 0);
    return -1;
  }
  v9 = *(_BYTE *)(a3 + 2) & 0xF;
  v10 = a2 + 1456 * v6;
  memcpy((void *)(v10 + 91 * v9), (const void *)(a3 + 2), 0x5Bu);
  if ( v9 == 15 )
  {
    v11 = 0;
    while ( 1 )
    {
      v12 = (unsigned __int8 *)(v10 + 91 * v11);
      v13 = 0xFFFF;
      v14 = v12 + 89;
      do
      {
        v15 = *v12++;
        v13 = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v15 ^ (v13 >> 8)) + 404] ^ ((_WORD)v13 << 8));
      }
      while ( v12 != v14 );
      v16 = (unsigned __int16)((v13 >> 8) | ((_WORD)v13 << 8));
      s1 = (v13 >> 8) | ((_WORD)v13 << 8);
      if ( memcmp(&s1, (const void *)(v10 + 91 * v11 + 89), 2u) )
        break;
      if ( ++v11 == 16 )
      {
        v17 = 0;
        v18 = 0;
        while ( 1 )
        {
          v19 = *(_BYTE *)(v10 + v17);
          v17 += 91;
          if ( v18 != (v19 & 0xF) )
            break;
          if ( ++v18 == 16 )
          {
            v20 = *(unsigned __int8 *)(v10 + 1);
            v21 = v10;
            v22 = v10;
            v23 = 15;
            while ( 1 )
            {
              v24 = *(unsigned __int8 *)(v22 + 92);
              v22 += 91;
              if ( v24 != v20 )
                break;
              if ( !--v23 )
              {
                v25 = *(unsigned __int8 *)(v10 + 2);
                v26 = v10;
                while ( 1 )
                {
                  v27 = *(unsigned __int8 *)(v26 + 93);
                  ++v23;
                  v26 += 91;
                  if ( v27 != v25 )
                    break;
                  if ( v23 == 15 )
                  {
                    v29 = *(unsigned __int8 *)(v10 + 3);
                    while ( 1 )
                    {
                      v30 = *(unsigned __int8 *)(v21 + 94);
                      v21 += 91;
                      if ( v30 != v29 )
                        break;
                      if ( !--v23 )
                      {
                        v31 = (char *)(a1 + 1357 * v7);
                        v32 = v31;
                        do
                        {
                          v33 = v10 + 91 * v23;
                          v34 = v32;
                          ++v23;
                          v32 += 85;
                          memcpy(v34, (const void *)(v33 + 4), 0x55u);
                        }
                        while ( v23 != 15 );
                        memcpy(v31 + 1275, (const void *)(v10 + 1369), 0x45u);
                        *((_DWORD *)v31 + 338) = *(_DWORD *)(v10 + 1450);
                        v31[1344] = *(_BYTE *)(v10 + 1366);
                        v31[1345] = *(_BYTE *)(v10 + 1367);
                        v31[1346] = *(_BYTE *)(v10 + 1368);
                        v31[1347] = *(_BYTE *)(v10 + 1441);
                        *((_DWORD *)v31 + 337) = *(_DWORD *)(v10 + 1442);
                        pthread_mutex_lock(&stru_78E88);
                        v35 = dword_7C28C;
                        v36 = (char *)&dword_7C28C + 1357 * dword_7C28C;
                        v36[1368] = a5;
                        v36[1356] = v31[1344];
                        v36[1357] = v31[1345] & 0x7F;
                        v36[1358] = v31[1346];
                        v36[1359] = v31[1347];
                        *((_DWORD *)v36 + 340) = *((_DWORD *)v31 + 337);
                        *((_DWORD *)v36 + 341) = *((_DWORD *)v31 + 338);
                        memcpy(v36 + 12, v31, 0x540u);
                        if ( v35 > 0x62 )
                          dword_7C28C = 0;
                        else
                          dword_7C28C = v35 + 1;
                        if ( (unsigned int)dword_7C294 > 0x63 )
                        {
                          dword_7C294 = 100;
                          if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
                          {
                            snprintf(s, 0x1000u, "%s: nonce fifo full!!!", "nonce_handle");
                            sub_38730(4, s, 0);
                          }
                        }
                        else
                        {
                          ++dword_7C294;
                        }
                        pthread_mutex_unlock(&stru_78E88);
                        return 0;
                      }
                    }
                    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
                    {
                      snprintf(s, 0x1000u, "nonceID is different %02x != %02x chipid=%d\n", v29, v30, v7);
                      goto LABEL_28;
                    }
                    goto LABEL_30;
                  }
                }
                if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
                {
                  snprintf(s, 0x1000u, "workID is different %02x != %02x\n", v25, v27);
                  goto LABEL_28;
                }
                goto LABEL_30;
              }
            }
            if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
            {
              snprintf(s, 0x1000u, "chip_addr is different %02x != %02x\n", v20, v24);
              goto LABEL_28;
            }
            goto LABEL_30;
          }
        }
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
        {
          snprintf(s, 0x1000u, "nonce is not continous i=%d\n", v18);
          goto LABEL_28;
        }
        goto LABEL_30;
      }
    }
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      snprintf(
        s,
        0x1000u,
        "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
        "bm1740_verify_nonce_integrality",
        v16,
        *(unsigned __int8 *)(v10 + 91 * v11 + 89),
        *(unsigned __int8 *)(v10 + 91 * v11 + 90));
LABEL_28:
      sub_38730(3, s, 0);
      if ( byte_7AD48 )
        goto LABEL_31;
    }
    if ( byte_78E08 )
      goto LABEL_31;
LABEL_30:
    if ( dword_766C4 <= 3 )
      return -1;
LABEL_31:
    v28 = dword_79BFC++;
    snprintf(s, 0x1000u, "receive a error nonce. total = %u", v28);
    goto LABEL_6;
  }
  return 1;
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 79BFC: using guessed type int dword_79BFC;
// 7AD48: using guessed type char byte_7AD48;
// 7C28C: using guessed type int dword_7C28C;
// 7C294: using guessed type int dword_7C294;
// 9D6F3: using guessed type char byte_9D6F3;

//----- (0004ACEC) --------------------------------------------------------
void __fastcall sub_4ACEC(_BYTE *a1, char a2, int a3)
{
  int v5; // r0
  char s[4096]; // [sp+18h] [bp-1000h] BYREF

  v5 = sub_3CC6C(a1 + 2, (unsigned __int8)(8 * a2 - 21));
  if ( (a1[8] & 0x1F) == v5 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      snprintf(
        s,
        0x1000u,
        "chain[%d] asic[%d] %02x %02x %02x %02x\n",
        a3,
        (unsigned __int8)(a1[7] / (unsigned __int8)byte_9D6F3),
        (unsigned __int8)a1[3],
        (unsigned __int8)a1[4],
        (unsigned __int8)a1[5],
        (unsigned __int8)a1[6]);
      sub_38730(7, s, 0);
    }
  }
  else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(s, 0x1000u, "%s chain%d CRC error crc = %02x\n", "pm_handle", a3, v5);
    sub_38730(3, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 9D6F3: using guessed type char byte_9D6F3;

//----- (0004AE48) --------------------------------------------------------
void __fastcall sub_4AE48(int a1, int a2, char a3)
{
  int v5; // r0
  int v6; // r3
  bool v7; // cc
  char *v8; // r1
  char *v9; // r2
  char v10; // r1
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v5 = sub_3CC6C((_BYTE *)(a1 + 2), 51);
  if ( (*(_BYTE *)(a1 + 8) & 0x1F) == v5 )
  {
    if ( (unsigned int)dword_7BD9C > 0x63 || (unsigned int)dword_7BD94 > 0x63 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        strcpy(s, "Will Clean!");
        sub_38730(5, s, 0);
      }
      sub_481B4();
    }
    else
    {
      pthread_mutex_lock(&stru_79B78);
      v6 = dword_7BD94;
      v7 = (unsigned int)dword_7BD94 > 0x62;
      v8 = (char *)&dword_7BD94 + 7 * dword_7BD94;
      if ( (unsigned int)dword_7BD94 > 0x62 )
        v6 = 0;
      v9 = v8 + 8;
      *(_DWORD *)(v8 + 13) = *(_DWORD *)(a1 + 3);
      v8[17] = *(_BYTE *)(a1 + 7);
      v10 = *(_BYTE *)(a1 + 2);
      v9[10] = a3;
      if ( v7 )
        dword_7BD94 = v6;
      v9[4] = v10;
      if ( !v7 )
      {
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(s, 0x1000u, "%s: p_wr = %d reg_value_num = %d", "reg_handle", v6, dword_7BD9C);
          sub_38730(7, s, 0);
          v6 = dword_7BD94;
        }
        dword_7BD94 = v6 + 1;
      }
      if ( (unsigned int)dword_7BD9C > 0x63 )
      {
        dword_7BD9C = 100;
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 3 )
        {
          snprintf(s, 0x1000u, "%s: reg fifo full!!!", "reg_handle");
          sub_38730(4, s, 0);
        }
      }
      else
      {
        ++dword_7BD9C;
      }
      pthread_mutex_unlock(&stru_79B78);
    }
  }
  else if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
  {
    snprintf(s, 0x1000u, "%s CRC error crc = %02x\n", "reg_handle", v5);
    sub_38730(3, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7AD48: using guessed type char byte_7AD48;
// 7BD94: using guessed type int dword_7BD94;
// 7BD9C: using guessed type int dword_7BD9C;

//----- (0004B0C0) --------------------------------------------------------
int *__fastcall sub_4B0C0(int *a1)
{
  pthread_t v2; // r0
  int v3; // r5
  int v4; // r4
  int v5; // r12
  int *result; // r0
  int v7; // r0
  char *v8; // r3
  char v9; // t1
  int v10; // r7
  int v11; // r5
  char *v12; // r12
  unsigned __int8 *v13; // r2
  int v14; // r3
  char v15; // r1
  char *v16; // r3
  char v17; // r2
  char *v18; // r3
  char v19; // r2
  char *v20; // r3
  char v21; // r2
  int v22; // [sp+Ch] [bp-149E8h]
  char *v23; // [sp+Ch] [bp-149E8h]
  char *v24; // [sp+Ch] [bp-149E8h]
  char *v25; // [sp+Ch] [bp-149E8h]
  int v26; // [sp+10h] [bp-149E4h]
  int v27; // [sp+18h] [bp-149DCh]
  _BYTE v28[3]; // [sp+23h] [bp-149D1h] BYREF
  unsigned __int8 v29; // [sp+26h] [bp-149CEh] BYREF
  char v30; // [sp+27h] [bp-149CDh] BYREF
  _BYTE v31[95]; // [sp+28h] [bp-149CCh] BYREF
  char v32; // [sp+87h] [bp-1496Dh] BYREF
  _BYTE s[1488]; // [sp+88h] [bp-1496Ch] BYREF
  int v34; // [sp+658h] [bp-1439Ch] BYREF
  _BYTE v35[4352]; // [sp+1640h] [bp-133B4h] BYREF
  char v36[74404]; // [sp+2750h] [bp-122A4h] BYREF

  memset(s, 0, sizeof(s));
  v26 = *a1;
  v2 = pthread_self();
  pthread_detach(v2);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(v36, 0x1000u, "Start A New Asic Response.Chain Id:[%d]", v26);
    sub_38730(5, v36, 0);
  }
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    snprintf(v36, 0x1000u, "%s %d", "get_asic_response", v26);
    sub_38730(7, v36, 0);
  }
  memset(v36, 0, (size_t)&loc_122A0);
  v3 = 0;
  memset(v31, 0, 0x5Du);
  v4 = 0;
  v5 = -84428;
LABEL_10:
  while ( 1 )
  {
    result = &dword_78E10;
    if ( !*((_BYTE *)&dword_78E10 + v26 + 776) )
      return result;
    v22 = v5;
    sub_2A954();
    v7 = sub_3C5E8((unsigned __int8)v26, s, 0x5D0u);
    v5 = v22;
    if ( v7 > 0 )
    {
      v8 = &v32;
      do
      {
        v9 = *++v8;
        v36[v3++] = v9;
        if ( v3 > 74399 )
          v3 = 0;
      }
      while ( v8 != &s[v7 - 1] );
    }
    if ( v3 != v4 )
    {
      v10 = v4 >= v3 ? 74400 - v4 + v3 : v3 - v4;
      if ( v10 > 2 )
      {
        v27 = v3;
        v11 = v22;
        v12 = &v31[8];
        while ( 1 )
        {
          v13 = v28;
          v29 = 0;
          v14 = v4;
          *(_WORD *)&v36[v11 + 74400] = 0;
          do
          {
            v15 = v36[v14++];
            *++v13 = v15;
            if ( v14 > 74399 )
              v14 = 0;
          }
          while ( v13 != &v29 );
          if ( (unsigned __int8)v36[v11 + 74400] == 170 && v28[2] == 85 )
          {
            if ( (v29 & 0xF0) == 0xE0 )
            {
              if ( v10 <= 92 )
                goto LABEL_29;
              v18 = &v30;
              do
              {
                v19 = v36[v4++];
                *++v18 = v19;
                if ( v4 > 74399 )
                  v4 = 0;
              }
              while ( v18 != &v31[92] );
              v24 = v12;
              sub_4A754((int)&v34, (int)v35, (int)v31, 93, v26);
              v10 -= 93;
              v12 = v24;
            }
            else if ( v29 == 204 )
            {
              if ( v10 <= 8 )
              {
LABEL_29:
                v5 = v11;
                v3 = v27;
                goto LABEL_10;
              }
              v20 = &v30;
              do
              {
                v21 = v36[v4++];
                *++v20 = v21;
                if ( v4 > 74399 )
                  v4 = 0;
              }
              while ( v20 != v12 );
              v10 -= 9;
              v25 = v12;
              sub_4ACEC(v31, 9, (unsigned __int8)v26);
              v12 = v25;
            }
            else
            {
              if ( v10 <= 8 )
                goto LABEL_29;
              v16 = &v30;
              do
              {
                v17 = v36[v4++];
                *++v16 = v17;
                if ( v4 > 74399 )
                  v4 = 0;
              }
              while ( v16 != v12 );
              v10 -= 9;
              v23 = v12;
              sub_4AE48((int)v31, 9, v26);
              v12 = v23;
            }
          }
          else
          {
            ++v4;
            --v10;
            if ( v4 > 74399 )
              v4 = 0;
          }
          if ( v10 <= 2 )
            goto LABEL_29;
        }
      }
    }
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 78E10: using guessed type int dword_78E10;
// 7AD48: using guessed type char byte_7AD48;

//----- (0004B4F0) --------------------------------------------------------
int __fastcall sub_4B4F0(_DWORD *a1, unsigned int *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  int v4; // r3
  int v5; // r12
  int v6; // r3
  int v7; // r0
  int v8; // r8
  int v9; // r2
  int v10; // r3
  int v11; // r4
  unsigned int v12; // r5
  int v13; // r12
  int v14; // r4
  int v15; // r6
  int v16; // r0
  int v17; // r8
  int v18; // r12
  int v19; // r2
  int v20; // r3
  int v21; // r5
  int v22; // r11
  int v23; // r6
  int v24; // r4
  int v25; // r10
  int v26; // r7
  int v27; // r12
  int v28; // r7
  int v29; // r3
  int v30; // r0
  int v31; // r3
  int v32; // r11
  int v33; // r8
  int v34; // r10
  int v35; // r6
  int v36; // r10
  int v37; // r5
  int v38; // r2
  int v39; // r7
  int v40; // r0
  int v41; // r3
  int v42; // r11
  int v43; // r8
  int v44; // r9
  int v45; // r4
  int v46; // r12
  int v47; // r6
  int v48; // r10
  int v49; // r1
  int v50; // r7
  int v51; // r2
  int v52; // r12
  int v53; // r3
  int v54; // r0
  int v55; // r11
  int v56; // r4
  int v57; // r8
  int v58; // r5
  int v59; // r10
  int v60; // r6
  int v61; // r9
  int v62; // r2
  int v63; // r12
  int v64; // r1
  int v65; // r11
  int v66; // r3
  int v67; // r0
  int v68; // r8
  int v69; // r5
  int v70; // r10
  int v71; // r6
  int v72; // r9
  int v73; // r7
  int v74; // r4
  int v75; // r8
  int v76; // r12
  int v77; // r6
  int v78; // r1
  int v79; // r6
  int v80; // r0
  int v81; // r3
  int v82; // r1
  int v83; // r10
  int v84; // r9
  int v85; // r7
  int v86; // r2
  int v87; // r8
  int v88; // r12
  int v89; // r3
  int v90; // r5
  int v91; // r0
  int v92; // r6
  int v93; // r10
  int v94; // r5
  int v95; // r1
  int v96; // r7
  int v97; // r2
  int v98; // r4
  int v99; // r7
  int v100; // r12
  int v101; // r3
  int v102; // r7
  int v103; // r0
  int v104; // r6
  int v105; // r10
  int v106; // r1
  int v107; // r5
  int v108; // r10
  int v109; // r2
  int v110; // r4
  int v111; // r7
  int v112; // r12
  int v113; // r3
  int v114; // r6
  int v115; // r10
  int v116; // r0
  int v117; // r7
  int v118; // r1
  int v119; // r6
  int v120; // r5
  int v121; // r8
  int v122; // r2
  int v123; // r4
  int v124; // r12
  int v125; // r3
  int v126; // r5
  int v127; // r0
  int v128; // r10
  int v129; // r5
  int v130; // r1
  int v131; // r6
  int v132; // r4
  int v133; // r2
  int v134; // r8
  int v135; // r5
  int v136; // r12
  int v137; // r3
  int v138; // r10
  int v139; // r0
  int v140; // r7
  int v141; // r5
  int v142; // r1
  int v143; // r6
  unsigned int v144; // r9
  int v145; // r10
  int v146; // r2
  int v147; // r4
  int v148; // r5
  int v149; // r3
  int v150; // r12
  int v151; // r8
  int v152; // r7
  int v153; // r0
  int v154; // r5
  int v155; // r6
  int v156; // r1
  int v157; // r5
  int v158; // r4
  int v159; // r2
  int v160; // r5
  int v161; // r12
  int v162; // r3
  int v163; // r8
  int v164; // r0
  int v165; // r6
  unsigned int v166; // r5
  int v167; // r1
  int v168; // r9
  unsigned int v169; // r4
  int v170; // r2
  int v171; // r12
  int v172; // r3
  unsigned int v173; // r5
  int v174; // r0
  int v175; // r6
  int v176; // r0
  unsigned int v177; // r11
  int v178; // r12
  int v179; // r6
  int v180; // r1
  unsigned int v181; // r5
  int v182; // r4
  int v183; // r9
  int v184; // r2
  int v185; // r12
  int v186; // r4
  int v187; // r12
  int v188; // r5
  int result; // r0
  int v190; // [sp+4h] [bp-6Ch]
  int v191; // [sp+8h] [bp-68h]
  int v192; // [sp+Ch] [bp-64h]
  int v193; // [sp+10h] [bp-60h]
  int v194; // [sp+14h] [bp-5Ch]
  int v195; // [sp+18h] [bp-58h]
  int v196; // [sp+1Ch] [bp-54h]
  int v197; // [sp+20h] [bp-50h]
  int v198; // [sp+24h] [bp-4Ch]
  int v199; // [sp+24h] [bp-4Ch]
  int v200; // [sp+24h] [bp-4Ch]
  unsigned int v201; // [sp+24h] [bp-4Ch]
  unsigned int v202; // [sp+24h] [bp-4Ch]
  int v203; // [sp+24h] [bp-4Ch]
  int v204; // [sp+24h] [bp-4Ch]
  unsigned int v205; // [sp+28h] [bp-48h]
  int v206; // [sp+28h] [bp-48h]
  int v207; // [sp+28h] [bp-48h]
  unsigned int v208; // [sp+28h] [bp-48h]
  unsigned int v209; // [sp+28h] [bp-48h]
  unsigned int v210; // [sp+28h] [bp-48h]
  int v211; // [sp+2Ch] [bp-44h]
  int v212; // [sp+2Ch] [bp-44h]
  int v213; // [sp+2Ch] [bp-44h]
  unsigned int v214; // [sp+2Ch] [bp-44h]
  unsigned int v215; // [sp+2Ch] [bp-44h]
  unsigned int v216; // [sp+2Ch] [bp-44h]
  int v217; // [sp+30h] [bp-40h]
  unsigned int v218; // [sp+30h] [bp-40h]
  unsigned int v219; // [sp+30h] [bp-40h]
  unsigned int v220; // [sp+30h] [bp-40h]
  int v221; // [sp+30h] [bp-40h]
  unsigned int v222; // [sp+34h] [bp-3Ch]
  unsigned int v223; // [sp+34h] [bp-3Ch]
  unsigned int v224; // [sp+34h] [bp-3Ch]
  unsigned int v225; // [sp+34h] [bp-3Ch]
  int v226; // [sp+34h] [bp-3Ch]
  unsigned int v227; // [sp+38h] [bp-38h]
  unsigned int v228; // [sp+38h] [bp-38h]
  unsigned int v229; // [sp+38h] [bp-38h]
  int v230; // [sp+38h] [bp-38h]
  unsigned int v231; // [sp+3Ch] [bp-34h]
  unsigned int v232; // [sp+3Ch] [bp-34h]
  unsigned int v233; // [sp+3Ch] [bp-34h]
  unsigned int v234; // [sp+3Ch] [bp-34h]
  unsigned int v235; // [sp+40h] [bp-30h]
  unsigned int v236; // [sp+40h] [bp-30h]
  unsigned int v237; // [sp+40h] [bp-30h]
  unsigned int v238; // [sp+40h] [bp-30h]
  unsigned int v239; // [sp+44h] [bp-2Ch]
  unsigned int v240; // [sp+44h] [bp-2Ch]
  unsigned int v241; // [sp+44h] [bp-2Ch]
  unsigned int v242; // [sp+44h] [bp-2Ch]
  unsigned int v243; // [sp+48h] [bp-28h]
  unsigned int v244; // [sp+48h] [bp-28h]
  unsigned int v245; // [sp+48h] [bp-28h]
  unsigned int v246; // [sp+48h] [bp-28h]
  unsigned int v247; // [sp+4Ch] [bp-24h]
  unsigned int v248; // [sp+4Ch] [bp-24h]
  unsigned int v249; // [sp+4Ch] [bp-24h]
  unsigned int v250; // [sp+4Ch] [bp-24h]
  unsigned int v251; // [sp+50h] [bp-20h]
  unsigned int v252; // [sp+50h] [bp-20h]
  unsigned int v253; // [sp+50h] [bp-20h]
  unsigned int v254; // [sp+54h] [bp-1Ch]
  unsigned int v255; // [sp+54h] [bp-1Ch]
  unsigned int v256; // [sp+54h] [bp-1Ch]
  unsigned int v257; // [sp+58h] [bp-18h]
  unsigned int v258; // [sp+58h] [bp-18h]
  unsigned int v259; // [sp+58h] [bp-18h]
  unsigned int v260; // [sp+5Ch] [bp-14h]
  unsigned int v261; // [sp+5Ch] [bp-14h]
  unsigned int v262; // [sp+5Ch] [bp-14h]
  unsigned int v263; // [sp+60h] [bp-10h]
  unsigned int v264; // [sp+60h] [bp-10h]
  unsigned int v265; // [sp+60h] [bp-10h]
  unsigned int v267; // [sp+68h] [bp-8h]
  unsigned int v268; // [sp+68h] [bp-8h]
  unsigned int v269; // [sp+6Ch] [bp-4h]

  v193 = a1[6];
  v191 = a1[8];
  v197 = a1[2];
  v192 = a1[7];
  v196 = a1[3];
  v195 = a1[4];
  v190 = a1[9];
  v269 = _byteswap_ulong(*a2);
  v2 = v190
     + 1116352408
     + (__ROR4__(v193, 6) ^ __ROR4__(v193, 11) ^ __ROR4__(v193, 25))
     + ((v191 ^ v192) & v193 ^ v191)
     + v269;
  v3 = v2 + a1[5];
  v205 = ((v196 | v197) & v195 | v196 & v197) + (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + v2;
  v222 = _byteswap_ulong(a2[1]);
  v194 = a1[5];
  v4 = v191 + 1899447441 + v222 + (v3 & (v192 ^ v193) ^ v192) + (__ROR4__(v3, 6) ^ __ROR4__(v3, 11) ^ __ROR4__(v3, 25));
  v5 = v4 + v195;
  v227 = _byteswap_ulong(a2[2]);
  v211 = ((v205 | v197) & v196 | v205 & v197) + (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + v4;
  v6 = v192 - 1245643825 + v227 + (v5 & (v3 ^ v193) ^ v193) + (__ROR4__(v5, 6) ^ __ROR4__(v5, 11) ^ __ROR4__(v5, 25));
  v7 = v6 + v196;
  v198 = ((v211 | v205) & v197 | v211 & v205) + (__ROR4__(v211, 2) ^ __ROR4__(v211, 13) ^ __ROR4__(v211, 22)) + v6;
  v231 = _byteswap_ulong(a2[3]);
  v8 = v193 - 373957723 + v231 + (v7 & (v5 ^ v3) ^ v3) + (__ROR4__(v7, 6) ^ __ROR4__(v7, 11) ^ __ROR4__(v7, 25));
  v235 = _byteswap_ulong(a2[4]);
  v9 = v8 + v197;
  v10 = ((v198 | v211) & v205 | v198 & v211) + (__ROR4__(v198, 2) ^ __ROR4__(v198, 13) ^ __ROR4__(v198, 22)) + v8;
  v11 = v235
      + 961987163
      + v3
      + ((v8 + v197) & (v7 ^ v5) ^ v5)
      + (__ROR4__(v8 + v197, 6) ^ __ROR4__(v8 + v197, 11) ^ __ROR4__(v8 + v197, 25));
  v12 = v11 + v205;
  v206 = ((v10 | v198) & v211 | v10 & v198) + (__ROR4__(v10, 2) ^ __ROR4__(v10, 13) ^ __ROR4__(v10, 22)) + v11;
  v239 = _byteswap_ulong(a2[5]);
  v13 = v239
      + 1508970993
      + v5
      + (v12 & ((v8 + v197) ^ v7) ^ v7)
      + (__ROR4__(v12, 6) ^ __ROR4__(v12, 11) ^ __ROR4__(v12, 25));
  v14 = v211;
  v212 = ((v206 | v10) & v198 | v206 & v10) + (__ROR4__(v206, 2) ^ __ROR4__(v206, 13) ^ __ROR4__(v206, 22)) + v13;
  v243 = _byteswap_ulong(a2[6]);
  v15 = v13 + v14;
  v16 = v243
      - 1841331548
      + v7
      + (v15 & (v12 ^ v9) ^ v9)
      + (__ROR4__(v13 + v14, 6) ^ __ROR4__(v13 + v14, 11) ^ __ROR4__(v15, 25));
  v17 = v198;
  v199 = ((v212 | v206) & v10 | v212 & v206) + (__ROR4__(v212, 2) ^ __ROR4__(v212, 13) ^ __ROR4__(v212, 22)) + v16;
  v18 = v16 + v17;
  v247 = _byteswap_ulong(a2[7]);
  v19 = v247
      - 1424204075
      + v9
      + (v18 & (v15 ^ v12) ^ v12)
      + (__ROR4__(v16 + v17, 6) ^ __ROR4__(v16 + v17, 11) ^ __ROR4__(v18, 25));
  v20 = v19 + v10;
  v217 = ((v199 | v212) & v206 | v199 & v212) + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + v19;
  v267 = _byteswap_ulong(a2[8]);
  v21 = v267
      - 670586216
      + v12
      + (v20 & ((v16 + v17) ^ v15) ^ v15)
      + (__ROR4__(v20, 6) ^ __ROR4__(v20, 11) ^ __ROR4__(v20, 25));
  v22 = v21 + v206;
  v207 = ((v217 | v199) & v212 | v217 & v199) + (__ROR4__(v217, 2) ^ __ROR4__(v217, 13) ^ __ROR4__(v217, 22)) + v21;
  v251 = _byteswap_ulong(a2[9]);
  v23 = v251 + 310598401 + v15 + (v22 & (v20 ^ v18) ^ v18) + (__ROR4__(v22, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25));
  v24 = v212;
  v213 = ((v207 | v217) & v199 | v207 & v217) + (__ROR4__(v207, 2) ^ __ROR4__(v207, 13) ^ __ROR4__(v207, 22)) + v23;
  v25 = v23 + v24;
  v254 = _byteswap_ulong(a2[10]);
  v26 = v254
      + 607225278
      + v16
      + v17
      + (v25 & (v22 ^ v20) ^ v20)
      + (__ROR4__(v25, 6) ^ __ROR4__(v25, 11) ^ __ROR4__(v25, 25));
  v257 = _byteswap_ulong(a2[11]);
  v27 = v26 + v199;
  v28 = ((v213 | v207) & v217 | v213 & v207) + (__ROR4__(v213, 2) ^ __ROR4__(v213, 13) ^ __ROR4__(v213, 22)) + v26;
  v29 = v257
      + 1426881987
      + v20
      + (v27 & ((v23 + v24) ^ v22) ^ v22)
      + (__ROR4__(v27, 6) ^ __ROR4__(v27, 11) ^ __ROR4__(v27, 25));
  v30 = v29 + v217;
  v31 = ((v28 | v213) & v207 | v28 & v213) + (__ROR4__(v28, 2) ^ __ROR4__(v28, 13) ^ __ROR4__(v28, 22)) + v29;
  v260 = _byteswap_ulong(a2[12]);
  v32 = v260 + 1925078388 + v22 + (v30 & (v27 ^ v25) ^ v25) + (__ROR4__(v30, 6) ^ __ROR4__(v30, 11) ^ __ROR4__(v30, 25));
  v33 = v32 + v207;
  v200 = ((v31 | v28) & v213 | v31 & v28) + (__ROR4__(v31, 2) ^ __ROR4__(v31, 13) ^ __ROR4__(v31, 22)) + v32;
  v263 = _byteswap_ulong(a2[13]);
  v34 = v263
      - 2132889090
      + v23
      + v24
      + ((v32 + v207) & (v30 ^ v27) ^ v27)
      + (__ROR4__(v32 + v207, 6) ^ __ROR4__(v32 + v207, 11) ^ __ROR4__(v32 + v207, 25));
  v208 = _byteswap_ulong(a2[14]);
  v35 = v34 + v213;
  v36 = ((v200 | v31) & v28 | v200 & v31) + (__ROR4__(v200, 2) ^ __ROR4__(v200, 13) ^ __ROR4__(v200, 22)) + v34;
  v37 = v208 - 1680079193 + v27 + (v35 & (v33 ^ v30) ^ v30) + (__ROR4__(v35, 6) ^ __ROR4__(v35, 11) ^ __ROR4__(v35, 25));
  v214 = _byteswap_ulong(a2[15]);
  v38 = ((v36 | v200) & v31 | v36 & v200) + (__ROR4__(v36, 2) ^ __ROR4__(v36, 13) ^ __ROR4__(v36, 22)) + v37;
  v39 = v37 + v28;
  v40 = v214 - 1046744716 + v30 + (v39 & (v35 ^ v33) ^ v33) + (__ROR4__(v39, 6) ^ __ROR4__(v39, 11) ^ __ROR4__(v39, 25));
  v41 = v40 + v31;
  v218 = v251
       + v269
       + (__ROR4__(v208, 17) ^ __ROR4__(v208, 19) ^ (v208 >> 10))
       + (__ROR4__(v222, 7) ^ __ROR4__(v222, 18) ^ (v222 >> 3));
  v42 = ((v38 | v36) & v200 | v38 & v36) + (__ROR4__(v38, 2) ^ __ROR4__(v38, 13) ^ __ROR4__(v38, 22)) + v40;
  v43 = v218 - 459576895 + v33 + (v41 & (v39 ^ v35) ^ v35) + (__ROR4__(v41, 6) ^ __ROR4__(v41, 11) ^ __ROR4__(v41, 25));
  v44 = ((v42 | v38) & v36 | v42 & v38) + (__ROR4__(v42, 2) ^ __ROR4__(v42, 13) ^ __ROR4__(v42, 22)) + v43;
  v45 = v43 + v200;
  v46 = __ROR4__(v43 + v200, 6);
  v201 = v254
       + v222
       + (__ROR4__(v214, 17) ^ __ROR4__(v214, 19) ^ (v214 >> 10))
       + (__ROR4__(v227, 7) ^ __ROR4__(v227, 18) ^ (v227 >> 3));
  v47 = v201 - 272742522 + v35 + (v45 & (v41 ^ v39) ^ v39) + (v46 ^ __ROR4__(v45, 11) ^ __ROR4__(v45, 25));
  v48 = v47 + v36;
  v49 = ((v44 | v42) & v38 | v44 & v42) + (__ROR4__(v44, 2) ^ __ROR4__(v44, 13) ^ __ROR4__(v44, 22)) + v47;
  v223 = v257
       + v227
       + (__ROR4__(v231, 7) ^ __ROR4__(v231, 18) ^ (v231 >> 3))
       + (__ROR4__(v218, 17) ^ __ROR4__(v218, 19) ^ (v218 >> 10));
  v50 = v223 + 264347078 + v39 + (v48 & (v45 ^ v41) ^ v41) + (__ROR4__(v48, 6) ^ __ROR4__(v48, 11) ^ __ROR4__(v48, 25));
  v51 = v50 + v38;
  v52 = ((v49 | v44) & v42 | v49 & v44) + (__ROR4__(v49, 2) ^ __ROR4__(v49, 13) ^ __ROR4__(v49, 22)) + v50;
  v228 = v260
       + v231
       + (__ROR4__(v235, 7) ^ __ROR4__(v235, 18) ^ (v235 >> 3))
       + (__ROR4__(v201, 17) ^ __ROR4__(v201, 19) ^ (v201 >> 10));
  v53 = v228 + 604807628 + v41 + (v51 & (v48 ^ v45) ^ v45) + (__ROR4__(v51, 6) ^ __ROR4__(v51, 11) ^ __ROR4__(v51, 25));
  v54 = ((v52 | v49) & v44 | v52 & v49) + (__ROR4__(v52, 2) ^ __ROR4__(v52, 13) ^ __ROR4__(v52, 22)) + v53;
  v55 = v53 + v42;
  v232 = v263
       + v235
       + (__ROR4__(v239, 7) ^ __ROR4__(v239, 18) ^ (v239 >> 3))
       + (__ROR4__(v223, 17) ^ __ROR4__(v223, 19) ^ (v223 >> 10));
  v56 = v232 + 770255983 + v45 + (v55 & (v51 ^ v48) ^ v48) + (__ROR4__(v55, 6) ^ __ROR4__(v55, 11) ^ __ROR4__(v55, 25));
  v57 = v56 + v44;
  v58 = ((v54 | v52) & v49 | v54 & v52) + (__ROR4__(v54, 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + v56;
  v236 = v208
       + v239
       + (__ROR4__(v243, 7) ^ __ROR4__(v243, 18) ^ (v243 >> 3))
       + (__ROR4__(v228, 17) ^ __ROR4__(v228, 19) ^ (v228 >> 10));
  v59 = v236 + 1249150122 + v48 + (v57 & (v55 ^ v51) ^ v51) + (__ROR4__(v57, 6) ^ __ROR4__(v57, 11) ^ __ROR4__(v57, 25));
  v60 = v59 + v49;
  v61 = ((v58 | v54) & v52 | v58 & v54) + (__ROR4__(v58, 2) ^ __ROR4__(v58, 13) ^ __ROR4__(v58, 22)) + v59;
  v240 = v214
       + v243
       + (__ROR4__(v247, 7) ^ __ROR4__(v247, 18) ^ (v247 >> 3))
       + (__ROR4__(v232, 17) ^ __ROR4__(v232, 19) ^ (v232 >> 10));
  v62 = v240 + 1555081692 + v51 + (v60 & (v57 ^ v55) ^ v55) + (__ROR4__(v60, 6) ^ __ROR4__(v60, 11) ^ __ROR4__(v60, 25));
  v63 = v62 + v52;
  v64 = ((v61 | v58) & v54 | v61 & v58) + (__ROR4__(v61, 2) ^ __ROR4__(v61, 13) ^ __ROR4__(v61, 22)) + v62;
  v244 = (__ROR4__(v267, 7) ^ __ROR4__(v267, 18) ^ (v267 >> 3))
       + v247
       + v218
       + (__ROR4__(v236, 17) ^ __ROR4__(v236, 19) ^ (v236 >> 10));
  v65 = v244 + 1996064986 + v55 + (v63 & (v60 ^ v57) ^ v57) + (__ROR4__(v63, 6) ^ __ROR4__(v63, 11) ^ __ROR4__(v63, 25));
  v66 = ((v64 | v61) & v58 | v64 & v61) + (__ROR4__(v64, 2) ^ __ROR4__(v64, 13) ^ __ROR4__(v64, 22)) + v65;
  v67 = v65 + v54;
  v248 = (__ROR4__(v251, 7) ^ __ROR4__(v251, 18) ^ (v251 >> 3))
       + v267
       + v201
       + (__ROR4__(v240, 17) ^ __ROR4__(v240, 19) ^ (v240 >> 10));
  v68 = v248 - 1740746414 + v57 + (v67 & (v63 ^ v60) ^ v60) + (__ROR4__(v67, 6) ^ __ROR4__(v67, 11) ^ __ROR4__(v67, 25));
  v69 = v68 + v58;
  v70 = ((v66 | v64) & v61 | v66 & v64) + (__ROR4__(v66, 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + v68;
  v252 = (__ROR4__(v254, 7) ^ __ROR4__(v254, 18) ^ (v254 >> 3))
       + v251
       + v223
       + (__ROR4__(v244, 17) ^ __ROR4__(v244, 19) ^ (v244 >> 10));
  v71 = v252 - 1473132947 + v60 + (v69 & (v67 ^ v63) ^ v63) + (__ROR4__(v69, 6) ^ __ROR4__(v69, 11) ^ __ROR4__(v69, 25));
  v72 = v71 + v61;
  v73 = ((v70 | v66) & v64 | v70 & v66) + (__ROR4__(v70, 2) ^ __ROR4__(v70, 13) ^ __ROR4__(v70, 22)) + v71;
  v255 = (__ROR4__(v257, 7) ^ __ROR4__(v257, 18) ^ (v257 >> 3))
       + v254
       + v228
       + (__ROR4__(v248, 17) ^ __ROR4__(v248, 19) ^ (v248 >> 10));
  v74 = v255 - 1341970488 + v63 + (v72 & (v69 ^ v67) ^ v67) + (__ROR4__(v72, 6) ^ __ROR4__(v72, 11) ^ __ROR4__(v72, 25));
  v75 = v74 + v64;
  v76 = ((v73 | v70) & v66 | v73 & v70) + (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + v74;
  v77 = (__ROR4__(v260, 7) ^ __ROR4__(v260, 18) ^ (v260 >> 3))
      + v257
      + v232
      + (__ROR4__(v252, 17) ^ __ROR4__(v252, 19) ^ (v252 >> 10));
  v78 = v77
      - 1084653625
      + v67
      + ((v74 + v64) & (v72 ^ v69) ^ v69)
      + (__ROR4__(v74 + v64, 6) ^ __ROR4__(v75, 11) ^ __ROR4__(v75, 25));
  v258 = v77;
  v79 = v78 + v66;
  v80 = ((v76 | v73) & v70 | v76 & v73) + (__ROR4__(v76, 2) ^ __ROR4__(v76, 13) ^ __ROR4__(v76, 22)) + v78;
  v261 = (__ROR4__(v263, 7) ^ __ROR4__(v263, 18) ^ (v263 >> 3))
       + v260
       + v236
       + (__ROR4__(v255, 17) ^ __ROR4__(v255, 19) ^ (v255 >> 10));
  v81 = v261 - 958395405 + v69 + (v79 & (v75 ^ v72) ^ v72) + (__ROR4__(v79, 6) ^ __ROR4__(v79, 11) ^ __ROR4__(v79, 25));
  v82 = ((v80 | v76) & v73 | v80 & v76) + (__ROR4__(v80, 2) ^ __ROR4__(v80, 13) ^ __ROR4__(v80, 22)) + v81;
  v83 = v81 + v70;
  v264 = (__ROR4__(v208, 7) ^ __ROR4__(v208, 18) ^ (v208 >> 3))
       + v263
       + v240
       + (__ROR4__(v258, 17) ^ __ROR4__(v258, 19) ^ (v258 >> 10));
  v84 = v264 - 710438585 + v72 + (v83 & (v79 ^ v75) ^ v75) + (__ROR4__(v83, 6) ^ __ROR4__(v83, 11) ^ __ROR4__(v83, 25));
  v85 = v84 + v73;
  v86 = ((v82 | v80) & v76 | v82 & v80) + (__ROR4__(v82, 2) ^ __ROR4__(v82, 13) ^ __ROR4__(v82, 22)) + v84;
  v209 = (__ROR4__(v214, 7) ^ __ROR4__(v214, 18) ^ (v214 >> 3))
       + v208
       + v244
       + (__ROR4__(v261, 17) ^ __ROR4__(v261, 19) ^ (v261 >> 10));
  v87 = v209 + 113926993 + v75 + (v85 & (v83 ^ v79) ^ v79) + (__ROR4__(v85, 6) ^ __ROR4__(v85, 11) ^ __ROR4__(v85, 25));
  v88 = v87 + v76;
  v89 = ((v86 | v82) & v80 | v86 & v82) + (__ROR4__(v86, 2) ^ __ROR4__(v86, 13) ^ __ROR4__(v86, 22)) + v87;
  v215 = (__ROR4__(v218, 7) ^ __ROR4__(v218, 18) ^ (v218 >> 3))
       + v214
       + v248
       + (__ROR4__(v264, 17) ^ __ROR4__(v264, 19) ^ (v264 >> 10));
  v90 = v215 + 338241895 + v79 + (v88 & (v85 ^ v83) ^ v83) + (__ROR4__(v88, 6) ^ __ROR4__(v88, 11) ^ __ROR4__(v88, 25));
  v91 = v90 + v80;
  v92 = ((v89 | v86) & v82 | v89 & v86) + (__ROR4__(v89, 2) ^ __ROR4__(v89, 13) ^ __ROR4__(v89, 22)) + v90;
  v219 = (__ROR4__(v201, 7) ^ __ROR4__(v201, 18) ^ (v201 >> 3))
       + v218
       + v252
       + (__ROR4__(v209, 17) ^ __ROR4__(v209, 19) ^ (v209 >> 10));
  v93 = v219 + 666307205 + v83 + (v91 & (v88 ^ v85) ^ v85) + (__ROR4__(v91, 6) ^ __ROR4__(v91, 11) ^ __ROR4__(v91, 25));
  v94 = ((v92 | v89) & v86 | v92 & v89) + (__ROR4__(v92, 2) ^ __ROR4__(v92, 13) ^ __ROR4__(v92, 22)) + v93;
  v202 = (__ROR4__(v223, 7) ^ __ROR4__(v223, 18) ^ (v223 >> 3))
       + v201
       + v255
       + (__ROR4__(v215, 17) ^ __ROR4__(v215, 19) ^ (v215 >> 10));
  v95 = v93 + v82;
  v96 = v202 + 773529912 + v85 + (v95 & (v91 ^ v88) ^ v88) + (__ROR4__(v95, 6) ^ __ROR4__(v95, 11) ^ __ROR4__(v95, 25));
  v97 = v96 + v86;
  v98 = ((v94 | v92) & v89 | v94 & v92) + (__ROR4__(v94, 2) ^ __ROR4__(v94, 13) ^ __ROR4__(v94, 22)) + v96;
  v224 = (__ROR4__(v228, 7) ^ __ROR4__(v228, 18) ^ (v228 >> 3))
       + v223
       + v258
       + (__ROR4__(v219, 17) ^ __ROR4__(v219, 19) ^ (v219 >> 10));
  v99 = v224 + 1294757372 + v88 + (v97 & (v95 ^ v91) ^ v91) + (__ROR4__(v97, 6) ^ __ROR4__(v97, 11) ^ __ROR4__(v97, 25));
  v100 = ((v98 | v94) & v92 | v98 & v94) + (__ROR4__(v98, 2) ^ __ROR4__(v98, 13) ^ __ROR4__(v98, 22)) + v99;
  v101 = v99 + v89;
  v229 = (__ROR4__(v232, 7) ^ __ROR4__(v232, 18) ^ (v232 >> 3))
       + v228
       + v261
       + (__ROR4__(v202, 17) ^ __ROR4__(v202, 19) ^ (v202 >> 10));
  v102 = v229
       + 1396182291
       + v91
       + (v101 & (v97 ^ v95) ^ v95)
       + (__ROR4__(v101, 6) ^ __ROR4__(v101, 11) ^ __ROR4__(v101, 25));
  v103 = ((v100 | v98) & v94 | v100 & v98) + (__ROR4__(v100, 2) ^ __ROR4__(v100, 13) ^ __ROR4__(v100, 22)) + v102;
  v104 = v102 + v92;
  v233 = (__ROR4__(v236, 7) ^ __ROR4__(v236, 18) ^ (v236 >> 3))
       + v232
       + v264
       + (__ROR4__(v224, 17) ^ __ROR4__(v224, 19) ^ (v224 >> 10));
  v105 = v233
       + 1695183700
       + v95
       + (v104 & (v101 ^ v97) ^ v97)
       + (__ROR4__(v104, 6) ^ __ROR4__(v104, 11) ^ __ROR4__(v104, 25));
  v106 = ((v103 | v100) & v98 | v103 & v100) + (__ROR4__(v103, 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + v105;
  v107 = v105 + v94;
  v237 = (__ROR4__(v240, 7) ^ __ROR4__(v240, 18) ^ (v240 >> 3))
       + v236
       + v209
       + (__ROR4__(v229, 17) ^ __ROR4__(v229, 19) ^ (v229 >> 10));
  v108 = v237
       + 1986661051
       + v97
       + (v107 & (v104 ^ v101) ^ v101)
       + (__ROR4__(v107, 6) ^ __ROR4__(v107, 11) ^ __ROR4__(v107, 25));
  v109 = ((v106 | v103) & v100 | v106 & v103) + (__ROR4__(v106, 2) ^ __ROR4__(v106, 13) ^ __ROR4__(v106, 22)) + v108;
  v110 = v108 + v98;
  v241 = (__ROR4__(v244, 7) ^ __ROR4__(v244, 18) ^ (v244 >> 3))
       + v240
       + v215
       + (__ROR4__(v233, 17) ^ __ROR4__(v233, 19) ^ (v233 >> 10));
  v111 = v241
       - 2117940946
       + v101
       + (v110 & (v107 ^ v104) ^ v104)
       + (__ROR4__(v110, 6) ^ __ROR4__(v110, 11) ^ __ROR4__(v110, 25));
  v112 = v111 + v100;
  v113 = ((v109 | v106) & v103 | v109 & v106) + (__ROR4__(v109, 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + v111;
  v245 = (__ROR4__(v248, 7) ^ __ROR4__(v248, 18) ^ (v248 >> 3))
       + v244
       + v219
       + (__ROR4__(v237, 17) ^ __ROR4__(v237, 19) ^ (v237 >> 10));
  v114 = v245
       - 1838011259
       + v104
       + (v112 & (v110 ^ v107) ^ v107)
       + (__ROR4__(v112, 6) ^ __ROR4__(v112, 11) ^ __ROR4__(v112, 25));
  v115 = ((v113 | v109) & v106 | v113 & v109) + (__ROR4__(v113, 2) ^ __ROR4__(v113, 13) ^ __ROR4__(v113, 22)) + v114;
  v116 = v114 + v103;
  v249 = (__ROR4__(v252, 7) ^ __ROR4__(v252, 18) ^ (v252 >> 3))
       + v248
       + v202
       + (__ROR4__(v241, 17) ^ __ROR4__(v241, 19) ^ (v241 >> 10));
  v117 = v249
       - 1564481375
       + v107
       + (v116 & (v112 ^ v110) ^ v110)
       + (__ROR4__(v116, 6) ^ __ROR4__(v116, 11) ^ __ROR4__(v116, 25));
  v118 = v117 + v106;
  v119 = ((v115 | v113) & v109 | v115 & v113) + (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + v117;
  v253 = (__ROR4__(v255, 7) ^ __ROR4__(v255, 18) ^ (v255 >> 3))
       + v252
       + v224
       + (__ROR4__(v245, 17) ^ __ROR4__(v245, 19) ^ (v245 >> 10));
  v120 = v253
       - 1474664885
       + v110
       + (v118 & (v116 ^ v112) ^ v112)
       + (__ROR4__(v118, 6) ^ __ROR4__(v118, 11) ^ __ROR4__(v118, 25));
  v121 = ((v119 | v115) & v113 | v119 & v115) + (__ROR4__(v119, 2) ^ __ROR4__(v119, 13) ^ __ROR4__(v119, 22)) + v120;
  v122 = v120 + v109;
  v256 = (__ROR4__(v258, 7) ^ __ROR4__(v258, 18) ^ (v258 >> 3))
       + v255
       + v229
       + (__ROR4__(v249, 17) ^ __ROR4__(v249, 19) ^ (v249 >> 10));
  v123 = v256
       - 1035236496
       + v112
       + (v122 & (v118 ^ v116) ^ v116)
       + (__ROR4__(v122, 6) ^ __ROR4__(v122, 11) ^ __ROR4__(v122, 25));
  v124 = ((v121 | v119) & v115 | v121 & v119) + (__ROR4__(v121, 2) ^ __ROR4__(v121, 13) ^ __ROR4__(v121, 22)) + v123;
  v125 = v123 + v113;
  v259 = (__ROR4__(v261, 7) ^ __ROR4__(v261, 18) ^ (v261 >> 3))
       + v258
       + v233
       + (__ROR4__(v253, 17) ^ __ROR4__(v253, 19) ^ (v253 >> 10));
  v126 = v259
       - 949202525
       + v116
       + (v125 & (v122 ^ v118) ^ v118)
       + (__ROR4__(v125, 6) ^ __ROR4__(v125, 11) ^ __ROR4__(v125, 25));
  v127 = ((v124 | v121) & v119 | v124 & v121) + (__ROR4__(v124, 2) ^ __ROR4__(v124, 13) ^ __ROR4__(v124, 22)) + v126;
  v128 = v126 + v115;
  v262 = (__ROR4__(v264, 7) ^ __ROR4__(v264, 18) ^ (v264 >> 3))
       + v261
       + v237
       + (__ROR4__(v256, 17) ^ __ROR4__(v256, 19) ^ (v256 >> 10));
  v129 = v262
       - 778901479
       + v118
       + (v128 & (v125 ^ v122) ^ v122)
       + (__ROR4__(v128, 6) ^ __ROR4__(v128, 11) ^ __ROR4__(v128, 25));
  v130 = ((v127 | v124) & v121 | v127 & v124) + (__ROR4__(v127, 2) ^ __ROR4__(v127, 13) ^ __ROR4__(v127, 22)) + v129;
  v131 = v129 + v119;
  v265 = (__ROR4__(v209, 7) ^ __ROR4__(v209, 18) ^ (v209 >> 3))
       + v264
       + v241
       + (__ROR4__(v259, 17) ^ __ROR4__(v259, 19) ^ (v259 >> 10));
  v132 = v265
       - 694614492
       + v122
       + (v131 & (v128 ^ v125) ^ v125)
       + (__ROR4__(v131, 6) ^ __ROR4__(v131, 11) ^ __ROR4__(v131, 25));
  v133 = ((v130 | v127) & v124 | v130 & v127) + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + v132;
  v134 = v132 + v121;
  v210 = (__ROR4__(v215, 7) ^ __ROR4__(v215, 18) ^ (v215 >> 3))
       + v209
       + v245
       + (__ROR4__(v262, 17) ^ __ROR4__(v262, 19) ^ (v262 >> 10));
  v135 = v210
       - 200395387
       + v125
       + (v134 & (v131 ^ v128) ^ v128)
       + (__ROR4__(v134, 6) ^ __ROR4__(v134, 11) ^ __ROR4__(v134, 25));
  v136 = v135 + v124;
  v137 = ((v133 | v130) & v127 | v133 & v130) + (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + v135;
  v216 = (__ROR4__(v219, 7) ^ __ROR4__(v219, 18) ^ (v219 >> 3))
       + v215
       + v249
       + (__ROR4__(v265, 17) ^ __ROR4__(v265, 19) ^ (v265 >> 10));
  v138 = v216
       + 275423344
       + v128
       + (v136 & (v134 ^ v131) ^ v131)
       + (__ROR4__(v136, 6) ^ __ROR4__(v136, 11) ^ __ROR4__(v136, 25));
  v139 = v138 + v127;
  v140 = ((v137 | v133) & v130 | v137 & v133) + (__ROR4__(v137, 2) ^ __ROR4__(v137, 13) ^ __ROR4__(v137, 22)) + v138;
  v268 = (__ROR4__(v202, 7) ^ __ROR4__(v202, 18) ^ (v202 >> 3))
       + v219
       + v253
       + (__ROR4__(v210, 17) ^ __ROR4__(v210, 19) ^ (v210 >> 10));
  v141 = v268
       + 430227734
       + v131
       + (v139 & (v136 ^ v134) ^ v134)
       + (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25));
  v142 = v141 + v130;
  v143 = ((v140 | v137) & v133 | v140 & v137) + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + v141;
  v144 = (__ROR4__(v224, 7) ^ __ROR4__(v224, 18) ^ (v224 >> 3))
       + v202
       + v256
       + (__ROR4__(v216, 17) ^ __ROR4__(v216, 19) ^ (v216 >> 10));
  v145 = v144
       + 506948616
       + v134
       + (v142 & (v139 ^ v136) ^ v136)
       + (__ROR4__(v142, 6) ^ __ROR4__(v142, 11) ^ __ROR4__(v142, 25));
  v146 = v145 + v133;
  v147 = ((v143 | v140) & v137 | v143 & v140) + (__ROR4__(v143, 2) ^ __ROR4__(v143, 13) ^ __ROR4__(v143, 22)) + v145;
  v220 = (__ROR4__(v229, 7) ^ __ROR4__(v229, 18) ^ (v229 >> 3))
       + v224
       + v259
       + (__ROR4__(v268, 17) ^ __ROR4__(v268, 19) ^ (v268 >> 10));
  v148 = v220
       + 659060556
       + v136
       + (v146 & (v142 ^ v139) ^ v139)
       + (__ROR4__(v146, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25));
  v149 = v148 + v137;
  v150 = ((v147 | v143) & v140 | v147 & v143) + (__ROR4__(v147, 2) ^ __ROR4__(v147, 13) ^ __ROR4__(v147, 22)) + v148;
  v225 = (__ROR4__(v233, 7) ^ __ROR4__(v233, 18) ^ (v233 >> 3))
       + v229
       + v262
       + (__ROR4__(v144, 17) ^ __ROR4__(v144, 19) ^ (v144 >> 10));
  v151 = v225
       + 883997877
       + v139
       + (v149 & (v146 ^ v142) ^ v142)
       + (__ROR4__(v149, 6) ^ __ROR4__(v149, 11) ^ __ROR4__(v149, 25));
  v152 = v151 + v140;
  v153 = ((v150 | v147) & v143 | v150 & v147) + (__ROR4__(v150, 2) ^ __ROR4__(v150, 13) ^ __ROR4__(v150, 22)) + v151;
  v234 = (__ROR4__(v237, 7) ^ __ROR4__(v237, 18) ^ (v237 >> 3))
       + v233
       + v265
       + (__ROR4__(v220, 17) ^ __ROR4__(v220, 19) ^ (v220 >> 10));
  v154 = v234
       + 958139571
       + v142
       + (v152 & (v149 ^ v146) ^ v146)
       + (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25));
  v155 = v154 + v143;
  v156 = ((v153 | v150) & v147 | v153 & v150) + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + v154;
  v238 = (__ROR4__(v241, 7) ^ __ROR4__(v241, 18) ^ (v241 >> 3))
       + v237
       + v210
       + (__ROR4__(v225, 17) ^ __ROR4__(v225, 19) ^ (v225 >> 10));
  v157 = v238
       + 1322822218
       + v146
       + (v155 & (v152 ^ v149) ^ v149)
       + (__ROR4__(v155, 6) ^ __ROR4__(v155, 11) ^ __ROR4__(v155, 25));
  v158 = v157 + v147;
  v159 = ((v156 | v153) & v150 | v156 & v153) + (__ROR4__(v156, 2) ^ __ROR4__(v156, 13) ^ __ROR4__(v156, 22)) + v157;
  v242 = (__ROR4__(v245, 7) ^ __ROR4__(v245, 18) ^ (v245 >> 3))
       + v241
       + v216
       + (__ROR4__(v234, 17) ^ __ROR4__(v234, 19) ^ (v234 >> 10));
  v160 = v242
       + 1537002063
       + v149
       + (v158 & (v155 ^ v152) ^ v152)
       + (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25));
  v161 = v160 + v150;
  v162 = ((v159 | v156) & v153 | v159 & v156) + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + v160;
  v246 = (__ROR4__(v249, 7) ^ __ROR4__(v249, 18) ^ (v249 >> 3))
       + v245
       + v268
       + (__ROR4__(v238, 17) ^ __ROR4__(v238, 19) ^ (v238 >> 10));
  v163 = v246
       + 1747873779
       + v152
       + (v161 & (v158 ^ v155) ^ v155)
       + (__ROR4__(v161, 6) ^ __ROR4__(v161, 11) ^ __ROR4__(v161, 25));
  v164 = v163 + v153;
  v203 = ((v162 | v159) & v156 | v162 & v159) + (__ROR4__(v162, 2) ^ __ROR4__(v162, 13) ^ __ROR4__(v162, 22)) + v163;
  v250 = (__ROR4__(v253, 7) ^ __ROR4__(v253, 18) ^ (v253 >> 3))
       + v249
       + v144
       + (__ROR4__(v242, 17) ^ __ROR4__(v242, 19) ^ (v242 >> 10));
  v165 = v250
       + 1955562222
       + v155
       + (v164 & (v161 ^ v158) ^ v158)
       + (__ROR4__(v164, 6) ^ __ROR4__(v164, 11) ^ __ROR4__(v164, 25));
  v230 = v165 + v156;
  v166 = (__ROR4__(v256, 7) ^ __ROR4__(v256, 18) ^ (v256 >> 3))
       + v253
       + v220
       + (__ROR4__(v246, 17) ^ __ROR4__(v246, 19) ^ (v246 >> 10));
  v167 = ((v203 | v162) & v159 | v203 & v162) + (__ROR4__(v203, 2) ^ __ROR4__(v203, 13) ^ __ROR4__(v203, 22)) + v165;
  v168 = v166
       + 2024104815
       + v158
       + (v230 & (v164 ^ v161) ^ v161)
       + (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25));
  v221 = ((v167 | v203) & v162 | v167 & v203) + (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + v168;
  v169 = (__ROR4__(v259, 7) ^ __ROR4__(v259, 18) ^ (v259 >> 3))
       + v256
       + v225
       + (__ROR4__(v250, 17) ^ __ROR4__(v250, 19) ^ (v250 >> 10));
  v170 = v168 + v159;
  v171 = v169
       - 2067236844
       + v161
       + (v170 & (v230 ^ v164) ^ v164)
       + (__ROR4__(v170, 6) ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25));
  v226 = ((v221 | v167) & v203 | v221 & v167) + (__ROR4__(v221, 2) ^ __ROR4__(v221, 13) ^ __ROR4__(v221, 22)) + v171;
  v172 = v171 + v162;
  v173 = (__ROR4__(v262, 7) ^ __ROR4__(v262, 18) ^ (v262 >> 3))
       + v259
       + v234
       + (__ROR4__(v166, 17) ^ __ROR4__(v166, 19) ^ (v166 >> 10));
  v174 = v173
       - 1933114872
       + v164
       + (v172 & (v170 ^ v230) ^ v230)
       + (__ROR4__(v172, 6) ^ __ROR4__(v172, 11) ^ __ROR4__(v172, 25));
  v175 = v174 + v203;
  v176 = ((v226 | v221) & v167 | v226 & v221) + (__ROR4__(v226, 2) ^ __ROR4__(v226, 13) ^ __ROR4__(v226, 22)) + v174;
  v204 = v175;
  v177 = (__ROR4__(v265, 7) ^ __ROR4__(v265, 18) ^ (v265 >> 3))
       + v262
       + v238
       + (__ROR4__(v169, 17) ^ __ROR4__(v169, 19) ^ (v169 >> 10));
  v178 = v177
       - 1866530822
       + v230
       + (v175 & (v172 ^ v170) ^ v170)
       + (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25));
  v179 = v178 + v167;
  v180 = ((v176 | v226) & v221 | v176 & v226) + (__ROR4__(v176, 2) ^ __ROR4__(v176, 13) ^ __ROR4__(v176, 22)) + v178;
  v181 = (__ROR4__(v210, 7) ^ __ROR4__(v210, 18) ^ (v210 >> 3))
       + v265
       + v242
       + (__ROR4__(v173, 17) ^ __ROR4__(v173, 19) ^ (v173 >> 10));
  v182 = v181
       - 1538233109
       + v170
       + (v179 & (v204 ^ v172) ^ v172)
       + (__ROR4__(v179, 6) ^ __ROR4__(v179, 11) ^ __ROR4__(v179, 25));
  v183 = v182 + v221;
  v184 = ((v180 | v176) & v226 | v180 & v176) + (__ROR4__(v180, 2) ^ __ROR4__(v180, 13) ^ __ROR4__(v180, 22)) + v182;
  v185 = v210
       - 1090935817
       + (__ROR4__(v216, 7) ^ __ROR4__(v216, 18) ^ (v216 >> 3))
       + v246
       + (__ROR4__(v177, 17) ^ __ROR4__(v177, 19) ^ (v177 >> 10))
       + v172
       + ((v182 + v221) & (v179 ^ v204) ^ v204)
       + (__ROR4__(v182 + v221, 6) ^ __ROR4__(v182 + v221, 11) ^ __ROR4__(v182 + v221, 25));
  v186 = ((v184 | v180) & v176 | v184 & v180) + (__ROR4__(v184, 2) ^ __ROR4__(v184, 13) ^ __ROR4__(v184, 22)) + v185;
  v187 = v185 + v226;
  v188 = v216
       - 965641998
       + (__ROR4__(v268, 7) ^ __ROR4__(v268, 18) ^ (v268 >> 3))
       + v250
       + (__ROR4__(v181, 17) ^ __ROR4__(v181, 19) ^ (v181 >> 10))
       + v204
       + (v187 & (v183 ^ v179) ^ v179)
       + (__ROR4__(v187, 6) ^ __ROR4__(v187, 11) ^ __ROR4__(v187, 25));
  result = v176 + v193 + v188;
  a1[2] = (__ROR4__(v186, 2) ^ __ROR4__(v186, 13) ^ __ROR4__(v186, 22))
        + ((v186 | v184) & v180 | v186 & v184)
        + v197
        + v188;
  a1[5] = v180 + v194;
  a1[6] = result;
  a1[3] = v186 + v196;
  a1[7] = v187 + v192;
  a1[4] = v184 + v195;
  a1[8] = v183 + v191;
  a1[9] = v179 + v190;
  return result;
}

//----- (0004DBEC) --------------------------------------------------------
unsigned int *__fastcall sub_4DBEC(unsigned int *result, unsigned int *a2, int a3)
{
  signed int v3; // r7
  unsigned int *v4; // r6
  unsigned int *v5; // r8
  unsigned int v6; // r10
  unsigned int v7; // r3
  int v8; // r10
  int v9; // r4
  _BOOL4 v10; // r3
  int v11; // r5
  unsigned int *v12; // r4
  unsigned int *v13; // r1
  unsigned int v14; // r7
  int v15; // r2

  v3 = a3;
  v4 = result;
  v5 = a2;
  if ( a3 > 0 )
  {
    v6 = *result;
    v7 = a3 + *result;
    *result = v7;
    v8 = v6 & 0x3F;
    v9 = 64 - v8;
    if ( a3 > v7 )
      ++result[1];
    v10 = a3 >= v9;
    if ( !v8 )
      v10 = 0;
    if ( v10 )
    {
      v3 = a3 - v9;
      memcpy((char *)result + v8 + 40, a2, 64 - v8);
      v5 = (unsigned int *)((char *)v5 + v9);
      result = (unsigned int *)sub_4B4F0(v4, v4 + 10);
      v8 = 0;
    }
    if ( v3 > 63 )
    {
      v11 = v3;
      v12 = v5;
      do
      {
        v13 = v12;
        v11 -= 64;
        v12 += 16;
        result = (unsigned int *)sub_4B4F0(v4, v13);
      }
      while ( v11 > 63 );
      v14 = v3 - 64;
      v15 = (v14 >> 6) + 1;
      v3 = v14 - (v14 >> 6 << 6);
      v5 += 16 * v15;
    }
    if ( v3 > 0 )
      return (unsigned int *)memcpy((char *)v4 + v8 + 40, v5, v3);
  }
  return result;
}

//----- (0004DCCC) --------------------------------------------------------
unsigned int *__fastcall sub_4DCCC(int a1, _BYTE *a2)
{
  unsigned int v4; // r2
  int v5; // r1
  int v6; // r3
  int v7; // r2
  unsigned int *result; // r0
  unsigned int v9; // [sp+0h] [bp-Ch] BYREF
  char v10; // [sp+4h] [bp-8h]
  char v11; // [sp+5h] [bp-7h]
  char v12; // [sp+6h] [bp-6h]
  char v13; // [sp+7h] [bp-5h]

  v4 = *(_DWORD *)a1 & 0x3F;
  v5 = *(_QWORD *)a1 >> 29;
  v6 = 8 * *(_DWORD *)a1;
  if ( v4 > 0x37 )
    v7 = 120 - v4;
  else
    v7 = 56 - v4;
  HIBYTE(v9) = *(_QWORD *)a1 >> 29;
  BYTE1(v9) = BYTE2(v5);
  BYTE2(v9) = BYTE1(v5);
  v11 = BYTE2(v6);
  v12 = BYTE1(v6);
  v13 = v6;
  LOBYTE(v9) = HIBYTE(v5);
  v10 = HIBYTE(v6);
  sub_4DBEC((unsigned int *)a1, dword_6C3E4, v7);
  result = sub_4DBEC((unsigned int *)a1, &v9, 8);
  *a2 = *(_BYTE *)(a1 + 11);
  a2[1] = *(_WORD *)(a1 + 10);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
  a2[3] = *(_DWORD *)(a1 + 8);
  a2[4] = *(_BYTE *)(a1 + 15);
  a2[5] = *(_WORD *)(a1 + 14);
  a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
  a2[7] = *(_DWORD *)(a1 + 12);
  a2[8] = *(_BYTE *)(a1 + 19);
  a2[9] = *(_WORD *)(a1 + 18);
  a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
  a2[11] = *(_DWORD *)(a1 + 16);
  a2[12] = *(_BYTE *)(a1 + 23);
  a2[13] = *(_WORD *)(a1 + 22);
  a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
  a2[15] = *(_DWORD *)(a1 + 20);
  a2[16] = *(_BYTE *)(a1 + 27);
  a2[17] = *(_WORD *)(a1 + 26);
  a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
  a2[19] = *(_DWORD *)(a1 + 24);
  a2[20] = *(_BYTE *)(a1 + 31);
  a2[21] = *(_WORD *)(a1 + 30);
  a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
  a2[23] = *(_DWORD *)(a1 + 28);
  a2[24] = *(_BYTE *)(a1 + 35);
  a2[25] = *(_WORD *)(a1 + 34);
  a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
  a2[27] = *(_DWORD *)(a1 + 32);
  a2[28] = *(_BYTE *)(a1 + 39);
  a2[29] = *(_WORD *)(a1 + 38);
  a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
  a2[31] = *(_DWORD *)(a1 + 36);
  return result;
}
// 6C3E4: using guessed type unsigned int dword_6C3E4[16];

//----- (0004DF30) --------------------------------------------------------
int __fastcall sub_4DF30(void *src, int a2, void *a3, unsigned __int8 a4)
{
  int srca; // [sp+4h] [bp-170h] BYREF
  _BYTE dest[364]; // [sp+8h] [bp-16Ch] BYREF

  srca = a2;
  memcpy(dest, src, 0x168u);
  sub_54F8C((int)dest, (char *)&srca, 4u);
  return sub_551D4((int)dest, a3, a4);
}

//----- (0004DF84) --------------------------------------------------------
int __fastcall sub_4DF84(const void *a1, const void *a2)
{
  return memcmp(a1, a2, dword_76B90);
}
// 76B90: using guessed type int dword_76B90;

//----- (0004DF94) --------------------------------------------------------
unsigned int __fastcall sub_4DF94(unsigned int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  int v8; // r11
  int v9; // r4
  unsigned int v10; // r6
  unsigned int v11; // r5
  int v12; // t1
  _BYTE *v13; // r3
  unsigned int v14; // r3
  _BYTE *v15; // r2
  unsigned int v16; // [sp+0h] [bp-1Ch]
  int v18; // [sp+10h] [bp-Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "sort-verify.c", 0x40u, "expandArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "sort-verify.c", 0x41u, "expandArray");
  v16 = a6 + ((a5 + 7) >> 3);
  result = v16 * 8 * a2 / a5;
  if ( result != a4 )
    _assert_fail("out_len == 8 * out_width * in_len / bit_len", "sort-verify.c", 0x44u, "expandArray");
  if ( a2 )
  {
    v8 = 0;
    v18 = a3 + a6;
    v9 = a1 + a2;
    result = a1;
    v10 = 0;
    v11 = 0;
    do
    {
      v11 += 8;
      v12 = *(unsigned __int8 *)result++;
      v10 = v12 | (v10 << 8);
      if ( a5 <= v11 )
      {
        v11 -= a5;
        if ( a6 )
        {
          v13 = (_BYTE *)(a3 + v8);
          do
            *v13++ = 0;
          while ( v13 != (_BYTE *)(v18 + v8) );
        }
        if ( a6 < v16 )
        {
          v14 = v11 + 8 * (((a5 + 7) >> 3) + 0x1FFFFFFF);
          v15 = (_BYTE *)(a3 + v8 + a6);
          do
          {
            *v15++ = (v10 >> v14) & ((unsigned int)~(-1 << a5) >> (v14 - v11));
            v14 -= 8;
          }
          while ( v15 != (_BYTE *)(a3 + v16 + v8) );
        }
        v8 += v16;
      }
    }
    while ( result != v9 );
  }
  return result;
}

//----- (0004E134) --------------------------------------------------------
unsigned int *__fastcall sub_4E134(unsigned int *result, int a2)
{
  unsigned int *v2; // r3
  int v3; // r2
  int v4; // r5
  unsigned int v5; // r12
  unsigned int v6; // r4

  v2 = &result[a2];
  if ( a2 )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *result;
      v6 = *v2;
      if ( v4 || v5 > v6 )
      {
        *result = v6;
        v4 = 1;
        *v2 = v5;
      }
      else if ( v5 < v6 )
      {
        return result;
      }
      ++v3;
      ++result;
      ++v2;
    }
    while ( v3 != a2 );
  }
  return result;
}

//----- (0004EA38) --------------------------------------------------------
unsigned int __fastcall sub_4EA38(int a1, int a2, int a3, size_t n)
{
  return (unsigned int)memcmp((const void *)(a1 + a3), (const void *)(a2 + a3), n) >> 31;
}

//----- (0004EA58) --------------------------------------------------------
int __fastcall sub_4EA58(int a1, int a2, int a3, unsigned int a4)
{
  int v5; // r7
  int v6; // r10
  unsigned int v7; // r8
  unsigned int v8; // r4
  const void *v9; // r1
  int result; // r0

  if ( !a4 )
    return 1;
  v5 = a2 + a3;
  v6 = a1 + a3;
  v7 = 0;
LABEL_4:
  v8 = 0;
  while ( 1 )
  {
    v9 = (const void *)(v5 + v8);
    v8 += 4;
    result = memcmp((const void *)(v6 + v7), v9, 4u);
    if ( !result )
      return result;
    if ( a4 <= v8 )
    {
      v7 += 4;
      if ( a4 > v7 )
        goto LABEL_4;
      return 1;
    }
  }
}

//----- (0004EAF4) --------------------------------------------------------
int __fastcall sub_4EAF4(void *a1, unsigned int a2)
{
  int v4; // r11
  int *v5; // r6
  _DWORD *v6; // r5
  unsigned int v7; // t1
  signed int v8; // r8
  int v9; // lr
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r0
  _BYTE *v17; // r0
  int v18; // r10
  int v19; // r8
  size_t v20; // r11
  unsigned int v21; // r7
  int v22; // r9
  int v23; // r6
  int v24; // r5
  int v25; // r3
  int v26; // r1
  int v27; // r2
  int v28; // r3
  int v29; // r10
  char *v30; // r0
  size_t v31; // r10
  _BYTE *v33; // r2
  int v34; // r3
  char *s; // [sp+8h] [bp-894h]
  size_t n; // [sp+Ch] [bp-890h]
  int v38; // [sp+10h] [bp-88Ch]
  size_t v39; // [sp+18h] [bp-884h]
  unsigned int v40; // [sp+30h] [bp-86Ch]
  _BYTE *dest; // [sp+34h] [bp-868h]
  int v42; // [sp+38h] [bp-864h]
  size_t v43; // [sp+3Ch] [bp-860h]
  _DWORD v44[7]; // [sp+44h] [bp-858h] BYREF
  __int16 v45; // [sp+60h] [bp-83Ch]
  _DWORD v46[7]; // [sp+64h] [bp-838h] BYREF
  __int16 v47; // [sp+80h] [bp-81Ch]
  int v48; // [sp+94h] [bp-808h] BYREF
  _DWORD v49[513]; // [sp+98h] [bp-804h] BYREF

  v4 = 0;
  v5 = &v48;
  dest = malloc(0x4400u);
  v6 = dest + 30;
  s = (char *)malloc(0x4400u);
  memset(v49, 0, 0x800u);
  sub_4DF94(a2, 1344, (int)v49, 2048, 0x15u, 1u);
  do
  {
    v7 = v5[1];
    ++v5;
    v8 = bswap32(v7);
    sub_4DF30(a1, v8 / 2, v46, 0x32u);
    sub_4DF94((unsigned int)v46 + 25 * (v8 % 2), 25, (int)v44, 30, 0x14u, 0);
    v9 = (int)v6 - 30;
    v10 = v44[1];
    v11 = v44[2];
    v12 = v44[3];
    *(_DWORD *)((char *)v6 - 30) = v44[0];
    *(_DWORD *)((char *)v6 - 26) = v10;
    *(_DWORD *)((char *)v6 - 22) = v11;
    v13 = v44[4];
    v14 = v44[5];
    v15 = v44[6];
    *(_DWORD *)((char *)v6 - 18) = v12;
    *(_DWORD *)((char *)v6 - 14) = v13;
    LOWORD(v12) = v45;
    v16 = v49[v4++];
    *(_DWORD *)((char *)v6 - 10) = v14;
    *((_WORD *)v6 - 1) = v12;
    *(_DWORD *)((char *)v6 - 6) = v15;
    *v6 = v16;
    v6 = (_DWORD *)((char *)v6 + 34);
    v17 = sub_29730(v9, 34);
    free(v17);
  }
  while ( v4 != 512 );
  v18 = 30;
  v19 = 512;
  v20 = 4;
  n = 27;
  while ( 1 )
  {
    v40 = v19;
    if ( v19 )
    {
      v42 = 2 * v20;
      v19 = 0;
      v21 = 0;
      v39 = v18 + v20;
      v22 = v18;
      v23 = (int)&dest[v18 + v20];
      v24 = (int)dest;
      v38 = 2 * (v18 + v20);
      v43 = n;
      while ( 1 )
      {
        v25 = 0;
        do
        {
          v26 = *(unsigned __int8 *)(v24 + v25);
          v27 = *(unsigned __int8 *)(v23 + v25++);
          if ( v26 != v27 )
          {
            puts("Invalid solution: invalid collision length between StepRows");
            goto LABEL_18;
          }
        }
        while ( v25 != 3 );
        if ( sub_4EA38(v23, v24, v22, v20) )
        {
          puts("Invalid solution: Index tree incorrectly ordered");
          goto LABEL_18;
        }
        if ( !sub_4EA58(v24, v23, v22, v20) )
          break;
        v28 = 0;
        memset(v46, 0, sizeof(v46));
        v47 = 0;
        do
        {
          *((_BYTE *)v46 + v28) = *(_BYTE *)(v23 + v28) ^ *(_BYTE *)(v24 + v28);
          ++v28;
        }
        while ( v28 < v22 );
        ++v19;
        v29 = (2 * v20 + n) * (v21 >> 1);
        v21 = 2 * v19;
        v23 += v38;
        v30 = &s[v29];
        v31 = n + v29;
        memcpy(v30, (char *)v46 + 3, n);
        memcpy(&s[v31], (const void *)(v22 + v24), v20);
        memcpy(&s[v31 + v20], (const void *)(v22 + v39 + v24), v20);
        v24 += v38;
        if ( v40 <= 2 * v19 )
        {
          v18 = v22;
          goto LABEL_15;
        }
      }
      puts("Invalid solution: duplicate indices");
      free(dest);
      free(s);
      return 1;
    }
    v42 = 2 * v20;
    v43 = n;
LABEL_15:
    v18 -= 3;
    memcpy(dest, s, 0x4400u);
    memset(s, 0, 0x4400u);
    n -= 3;
    if ( v18 == 3 )
      break;
    v20 = v42;
  }
  if ( v43 )
  {
    v33 = dest;
    v34 = (unsigned __int8)*dest;
    if ( *dest )
    {
LABEL_18:
      free(dest);
      free(s);
      return 2;
    }
    while ( ++v34 != v43 )
    {
      if ( *++v33 )
        goto LABEL_18;
    }
  }
  free(dest);
  free(s);
  return 0;
}

//----- (0004EEE0) --------------------------------------------------------
int __fastcall sub_4EEE0(char *a1, int a2, int a3)
{
  int v6; // r0
  _DWORD v8[16]; // [sp+0h] [bp-40h] BYREF

  memset(v8, 0, sizeof(v8));
  HIWORD(v8[0]) = 257;
  v6 = sub_5C710(512, a2);
  v8[14] = a2;
  v8[15] = a3;
  qmemcpy(&v8[12], "ZcashPoW", 8);
  LOBYTE(v8[0]) = a2 * v6 / 8;
  return sub_54DCC(a1, (unsigned __int8 *)v8);
}

//----- (0004EF68) --------------------------------------------------------
int __fastcall sub_4EF68(int a1, unsigned __int8 *a2)
{
  __int64 *v2; // r12
  unsigned __int8 *v3; // r6
  unsigned int v4; // r2
  unsigned int v5; // d16.s[0]
  __int64 v6; // d19
  int v7; // r12
  __int64 *v8; // r1
  __int64 v9; // t1
  __int64 v10; // r2
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // d18
  unsigned int v13; // r12
  unsigned int v14; // r1
  __int64 v15; // r2
  __int64 v16; // r4
  __int64 v17; // r8
  __int64 v18; // r2
  signed __int64 v19; // r2
  unsigned __int64 v20; // r10
  __int64 v21; // r2
  unsigned __int64 v22; // r4
  __int64 v23; // r4
  __int64 v24; // r2
  __int64 v25; // r6
  unsigned __int64 v26; // r8
  __int64 v27; // r4
  signed __int64 v28; // r2
  unsigned __int64 v29; // r6
  __int64 v30; // r0
  __int64 v31; // r10
  __int64 v32; // r2
  __int64 v33; // r4
  __int64 v34; // r0
  __int64 v35; // r4
  __int64 v36; // r6
  unsigned __int64 v37; // r4
  __int64 v38; // r2
  __int64 v39; // r4
  unsigned __int64 v40; // r6
  signed __int64 v41; // r0
  __int64 v42; // r4
  unsigned __int64 v43; // r0
  unsigned __int64 v44; // r6
  __int64 v45; // r4
  __int64 v46; // r0
  __int64 v47; // r8
  __int64 v48; // r4
  unsigned __int64 v49; // r10
  __int64 v50; // r2
  __int64 v51; // r10
  __int64 v52; // r2
  __int64 v53; // r6
  signed __int64 v54; // r4
  signed __int64 v55; // r0
  signed __int64 v56; // r6
  __int64 v57; // r2
  signed __int64 v58; // r0
  __int64 v59; // r0
  unsigned __int64 v60; // r10
  __int64 v61; // r8
  unsigned __int64 v62; // r4
  int v63; // r12
  unsigned __int64 v64; // r6
  signed __int64 v65; // r0
  __int64 v66; // r2
  __int64 v67; // r8
  __int64 v68; // r4
  __int64 v69; // r0
  __int64 v70; // r2
  unsigned __int64 v71; // r6
  __int64 v72; // r6
  signed __int64 v73; // r2
  __int64 v74; // r4
  __int64 v75; // r0
  unsigned __int64 v76; // r4
  __int64 v77; // r0
  unsigned __int64 v78; // r6
  unsigned __int64 v79; // r4
  __int64 v80; // r4
  __int64 v81; // r0
  unsigned __int64 v82; // r6
  unsigned __int64 v83; // r4
  int v84; // r12
  unsigned __int64 v85; // r10
  __int64 v86; // r0
  __int64 v87; // r10
  signed __int64 v88; // r2
  __int64 v89; // r2
  signed __int64 v90; // r0
  unsigned __int64 v91; // r0
  __int64 v92; // r4
  unsigned __int64 v93; // r6
  signed __int64 v94; // r0
  unsigned __int64 v95; // r2
  unsigned int v96; // r12
  __int64 v97; // r4
  __int64 v98; // r6
  __int64 v99; // r2
  unsigned __int64 v100; // r4
  __int64 v101; // r6
  __int64 v102; // r8
  __int64 v103; // r4
  __int64 v104; // r8
  __int64 v105; // r6
  signed __int64 v106; // r2
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // r4
  __int64 v109; // r2
  __int64 v110; // r2
  unsigned __int64 v111; // r8
  signed __int64 v112; // r4
  __int64 v113; // r6
  __int64 v114; // r2
  __int64 v115; // r6
  __int64 v116; // r4
  unsigned __int64 v117; // r8
  __int64 v118; // r0
  __int64 v119; // r6
  unsigned __int64 v120; // r8
  __int64 v121; // r4
  __int64 v122; // r4
  unsigned __int64 v123; // r4
  __int64 v124; // r2
  __int64 v125; // r4
  __int64 v126; // r2
  unsigned __int64 v127; // r4
  __int64 v128; // r0
  __int64 v129; // r2
  unsigned __int64 v130; // r4
  unsigned __int64 v131; // r10
  __int64 v132; // r4
  int v133; // r12
  __int64 v134; // r4
  __int64 v135; // r2
  __int64 v136; // r2
  __int64 v137; // r2
  __int64 v138; // r4
  __int64 v139; // r6
  __int64 v140; // r0
  unsigned __int64 v141; // r4
  signed __int64 v142; // r4
  unsigned __int64 v143; // r6
  __int64 v144; // r0
  unsigned __int64 v145; // r2
  __int64 v146; // r0
  __int64 v147; // r2
  unsigned __int64 v148; // r2
  __int64 v149; // r0
  __int64 v150; // r8
  __int64 v151; // r4
  __int64 v152; // r2
  signed __int64 v153; // r4
  __int64 v154; // r8
  signed __int64 v155; // r2
  __int64 v156; // r0
  __int64 v157; // r4
  __int64 v158; // r10
  signed __int64 v159; // r0
  unsigned __int64 v160; // r4
  __int64 v161; // r0
  __int64 v162; // r2
  __int64 v163; // r4
  __int64 v164; // r0
  __int64 v165; // r2
  __int64 v166; // r6
  __int64 v167; // r6
  __int64 v168; // r6
  __int64 v169; // r4
  __int64 v170; // r2
  unsigned __int64 v171; // r8
  unsigned __int64 v172; // r10
  signed __int64 v173; // r0
  __int64 v174; // r10
  __int64 v175; // r2
  __int64 v176; // r0
  unsigned __int64 v177; // r4
  __int64 v178; // r2
  unsigned __int64 v179; // r6
  unsigned __int64 v180; // r10
  __int64 v181; // r4
  unsigned __int64 v182; // r0
  __int64 v183; // r8
  __int64 v184; // r2
  __int64 v185; // r2
  __int64 v186; // r6
  unsigned __int64 v187; // r0
  __int64 v188; // r4
  __int64 v189; // r0
  __int64 v190; // r6
  unsigned __int64 v191; // r4
  __int64 v192; // r6
  __int64 v193; // r2
  __int64 v194; // r6
  __int64 v195; // r2
  __int64 v196; // r4
  unsigned __int64 v197; // r0
  __int64 v198; // r2
  unsigned __int64 v199; // r8
  __int64 v200; // r10
  __int64 v201; // r4
  __int64 v202; // r0
  __int64 v203; // r2
  __int64 v204; // r4
  __int64 v205; // r0
  __int64 v206; // r6
  unsigned __int64 v207; // r2
  unsigned __int64 v208; // r10
  signed __int64 v209; // r8
  signed __int64 v210; // r2
  unsigned __int64 v211; // r4
  unsigned __int64 v212; // r8
  __int64 v213; // r2
  int v214; // r12
  unsigned __int64 v215; // r6
  __int64 v216; // r10
  unsigned __int64 v217; // r8
  __int64 v218; // r6
  __int64 v219; // r2
  __int64 v220; // r4
  unsigned __int64 v221; // r2
  unsigned __int64 v222; // r4
  unsigned __int64 v223; // r0
  unsigned __int64 v224; // r10
  __int64 v225; // r2
  unsigned __int64 v226; // r4
  unsigned __int64 v227; // r4
  __int64 v228; // r0
  __int64 v229; // r4
  __int64 v230; // r0
  unsigned __int64 v231; // r6
  unsigned __int64 v232; // r10
  unsigned int v233; // kr54_4
  __int64 v234; // r2
  __int64 v235; // r0
  unsigned __int64 v236; // r10
  __int64 v237; // r6
  __int64 v238; // r2
  __int64 v239; // r10
  unsigned __int64 v240; // r0
  __int64 v241; // r4
  unsigned __int64 v242; // r10
  __int64 v243; // r0
  __int64 v244; // r4
  __int64 v245; // r2
  __int64 v246; // r2
  signed __int64 v247; // r4
  __int64 v248; // r0
  __int64 v249; // r2
  __int64 v250; // r4
  unsigned __int64 v251; // r10
  __int64 v252; // r0
  int v253; // r12
  unsigned __int64 v254; // r2
  unsigned __int64 v255; // r6
  unsigned __int64 v256; // r4
  __int64 v257; // r4
  __int64 v258; // r0
  __int64 v259; // r6
  __int64 v260; // r0
  __int64 v261; // r4
  unsigned __int64 v262; // r0
  __int64 v263; // r2
  unsigned __int64 v264; // r8
  __int64 v265; // r2
  __int64 v266; // r6
  __int64 v267; // r4
  __int64 v268; // r0
  __int64 v269; // r4
  unsigned __int64 v270; // r6
  unsigned __int64 v271; // r4
  signed __int64 v272; // r0
  __int64 v273; // r2
  __int64 v274; // r6
  signed __int64 v275; // r0
  __int64 v276; // r0
  unsigned __int64 v277; // r6
  __int64 v278; // r10
  unsigned int v279; // kr74_4
  unsigned int v280; // kr78_4
  signed __int64 v281; // r2
  unsigned __int64 v282; // r10
  signed __int64 v283; // r0
  unsigned __int64 v284; // r4
  unsigned __int64 v285; // r2
  unsigned __int64 v286; // r4
  __int64 v287; // r0
  unsigned __int64 v288; // r4
  unsigned __int64 v289; // r6
  int v290; // r12
  __int64 v291; // r4
  __int64 v292; // r0
  __int64 v293; // r4
  unsigned __int64 v294; // r8
  unsigned __int64 v295; // r2
  unsigned __int64 v296; // r4
  __int64 v297; // r4
  __int64 v298; // r2
  __int64 v299; // r0
  __int64 v300; // r6
  __int64 v301; // r2
  __int64 v302; // r4
  __int64 v303; // r4
  unsigned __int64 v304; // r10
  __int64 v305; // r2
  unsigned __int64 v306; // r4
  unsigned __int64 v307; // r2
  unsigned __int64 v308; // r0
  signed __int64 v309; // r0
  __int64 v310; // r4
  signed __int64 v311; // r2
  signed __int64 v312; // r6
  unsigned __int64 v313; // r8
  __int64 v314; // r6
  __int64 v315; // r8
  signed __int64 v316; // r4
  __int64 v317; // r6
  unsigned __int64 v318; // r8
  signed __int64 v319; // r6
  unsigned __int64 v320; // r10
  __int64 v321; // r8
  signed __int64 v322; // r0
  __int64 v323; // r2
  int v324; // r12
  unsigned __int64 v325; // r10
  int result; // r0
  __int64 v327; // r8
  unsigned __int64 v328; // r6
  __int64 v329; // r4
  unsigned __int64 v330; // r2
  __int64 v331; // r2
  unsigned __int64 v332; // r2
  __int64 v333; // r6
  unsigned __int64 v334; // r10
  __int64 v335; // r4
  __int64 v336; // r2
  _QWORD *v337; // r12
  __int64 v338; // r8
  __int64 *v339; // r6
  _QWORD *i; // r1
  __int64 v341; // t1
  unsigned __int64 v342; // t1
  unsigned __int64 v343; // [sp+0h] [bp-220h]
  unsigned __int64 v344; // [sp+0h] [bp-220h]
  unsigned __int64 v345; // [sp+0h] [bp-220h]
  __int64 v346; // [sp+0h] [bp-220h]
  unsigned __int64 v347; // [sp+0h] [bp-220h]
  unsigned __int64 v348; // [sp+0h] [bp-220h]
  unsigned __int64 v349; // [sp+0h] [bp-220h]
  __int64 v350; // [sp+0h] [bp-220h]
  unsigned __int64 v351; // [sp+0h] [bp-220h]
  unsigned __int64 v352; // [sp+0h] [bp-220h]
  unsigned __int64 v353; // [sp+0h] [bp-220h]
  unsigned __int64 v354; // [sp+0h] [bp-220h]
  unsigned __int64 v355; // [sp+0h] [bp-220h]
  unsigned __int64 v356; // [sp+0h] [bp-220h]
  unsigned __int64 v357; // [sp+0h] [bp-220h]
  unsigned __int64 v358; // [sp+0h] [bp-220h]
  unsigned __int64 v359; // [sp+0h] [bp-220h]
  unsigned __int64 v360; // [sp+0h] [bp-220h]
  unsigned __int64 v361; // [sp+8h] [bp-218h]
  unsigned __int64 v362; // [sp+8h] [bp-218h]
  unsigned __int64 v363; // [sp+8h] [bp-218h]
  unsigned __int64 v364; // [sp+8h] [bp-218h]
  __int64 v365; // [sp+8h] [bp-218h]
  unsigned __int64 v366; // [sp+8h] [bp-218h]
  unsigned __int64 v367; // [sp+8h] [bp-218h]
  unsigned __int64 v368; // [sp+8h] [bp-218h]
  unsigned __int64 v369; // [sp+8h] [bp-218h]
  unsigned __int64 v370; // [sp+8h] [bp-218h]
  __int64 v371; // [sp+8h] [bp-218h]
  unsigned __int64 v372; // [sp+8h] [bp-218h]
  unsigned __int64 v373; // [sp+8h] [bp-218h]
  __int64 v374; // [sp+8h] [bp-218h]
  __int64 v375; // [sp+10h] [bp-210h]
  __int64 v376; // [sp+10h] [bp-210h]
  __int64 v377; // [sp+10h] [bp-210h]
  __int64 v378; // [sp+10h] [bp-210h]
  unsigned __int64 v379; // [sp+10h] [bp-210h]
  unsigned __int64 v380; // [sp+10h] [bp-210h]
  unsigned __int64 v381; // [sp+10h] [bp-210h]
  unsigned __int64 v382; // [sp+10h] [bp-210h]
  __int64 v383; // [sp+10h] [bp-210h]
  __int64 v384; // [sp+10h] [bp-210h]
  unsigned __int64 v385; // [sp+10h] [bp-210h]
  __int64 v386; // [sp+10h] [bp-210h]
  __int64 v387; // [sp+10h] [bp-210h]
  __int64 v388; // [sp+10h] [bp-210h]
  __int64 v389; // [sp+18h] [bp-208h]
  unsigned __int64 v390; // [sp+18h] [bp-208h]
  unsigned __int64 v391; // [sp+18h] [bp-208h]
  unsigned __int64 v392; // [sp+18h] [bp-208h]
  unsigned __int64 v393; // [sp+18h] [bp-208h]
  __int64 v394; // [sp+18h] [bp-208h]
  __int64 v395; // [sp+18h] [bp-208h]
  unsigned __int64 v396; // [sp+18h] [bp-208h]
  unsigned __int64 v397; // [sp+18h] [bp-208h]
  __int64 v398; // [sp+18h] [bp-208h]
  __int64 v399; // [sp+18h] [bp-208h]
  __int64 v400; // [sp+18h] [bp-208h]
  unsigned __int64 v401; // [sp+18h] [bp-208h]
  __int64 v402; // [sp+18h] [bp-208h]
  __int64 v403; // [sp+18h] [bp-208h]
  __int64 v404; // [sp+18h] [bp-208h]
  __int64 v405; // [sp+18h] [bp-208h]
  unsigned __int64 v406; // [sp+20h] [bp-200h]
  unsigned __int64 v407; // [sp+20h] [bp-200h]
  unsigned __int64 v408; // [sp+20h] [bp-200h]
  __int64 v409; // [sp+20h] [bp-200h]
  unsigned __int64 v410; // [sp+20h] [bp-200h]
  unsigned __int64 v411; // [sp+20h] [bp-200h]
  unsigned __int64 v412; // [sp+20h] [bp-200h]
  unsigned __int64 v413; // [sp+20h] [bp-200h]
  unsigned __int64 v414; // [sp+20h] [bp-200h]
  unsigned __int64 v415; // [sp+20h] [bp-200h]
  unsigned __int64 v416; // [sp+20h] [bp-200h]
  unsigned __int64 v417; // [sp+20h] [bp-200h]
  unsigned __int64 v418; // [sp+20h] [bp-200h]
  unsigned __int64 v419; // [sp+20h] [bp-200h]
  __int64 v420; // [sp+28h] [bp-1F8h]
  unsigned __int64 v421; // [sp+28h] [bp-1F8h]
  unsigned __int64 v422; // [sp+28h] [bp-1F8h]
  unsigned __int64 v423; // [sp+28h] [bp-1F8h]
  unsigned __int64 v424; // [sp+28h] [bp-1F8h]
  unsigned __int64 v425; // [sp+28h] [bp-1F8h]
  unsigned __int64 v426; // [sp+28h] [bp-1F8h]
  __int64 v427; // [sp+28h] [bp-1F8h]
  unsigned __int64 v428; // [sp+28h] [bp-1F8h]
  unsigned __int64 v429; // [sp+28h] [bp-1F8h]
  unsigned __int64 v430; // [sp+28h] [bp-1F8h]
  unsigned __int64 v431; // [sp+28h] [bp-1F8h]
  unsigned __int64 v432; // [sp+28h] [bp-1F8h]
  unsigned __int64 v433; // [sp+28h] [bp-1F8h]
  unsigned __int64 v434; // [sp+30h] [bp-1F0h]
  unsigned __int64 v435; // [sp+30h] [bp-1F0h]
  __int64 v436; // [sp+30h] [bp-1F0h]
  __int64 v437; // [sp+30h] [bp-1F0h]
  unsigned __int64 v438; // [sp+30h] [bp-1F0h]
  __int64 v439; // [sp+30h] [bp-1F0h]
  unsigned __int64 v440; // [sp+30h] [bp-1F0h]
  unsigned __int64 v441; // [sp+30h] [bp-1F0h]
  __int64 v442; // [sp+30h] [bp-1F0h]
  unsigned __int64 v443; // [sp+30h] [bp-1F0h]
  unsigned __int64 v444; // [sp+30h] [bp-1F0h]
  __int64 v445; // [sp+30h] [bp-1F0h]
  __int64 v446; // [sp+30h] [bp-1F0h]
  unsigned __int64 v447; // [sp+30h] [bp-1F0h]
  __int64 v448; // [sp+30h] [bp-1F0h]
  __int64 v449; // [sp+30h] [bp-1F0h]
  __int64 v450; // [sp+30h] [bp-1F0h]
  __int64 v451; // [sp+30h] [bp-1F0h]
  __int64 v452; // [sp+30h] [bp-1F0h]
  unsigned __int64 v453; // [sp+30h] [bp-1F0h]
  __int64 v454; // [sp+30h] [bp-1F0h]
  __int64 v455; // [sp+30h] [bp-1F0h]
  unsigned __int64 v456; // [sp+30h] [bp-1F0h]
  unsigned __int64 v457; // [sp+30h] [bp-1F0h]
  unsigned __int64 v458; // [sp+30h] [bp-1F0h]
  unsigned __int64 v459; // [sp+30h] [bp-1F0h]
  __int64 v460; // [sp+30h] [bp-1F0h]
  unsigned __int64 v461; // [sp+38h] [bp-1E8h]
  unsigned __int64 v462; // [sp+38h] [bp-1E8h]
  unsigned __int64 v463; // [sp+38h] [bp-1E8h]
  unsigned __int64 v464; // [sp+38h] [bp-1E8h]
  __int64 v465; // [sp+38h] [bp-1E8h]
  unsigned __int64 v466; // [sp+38h] [bp-1E8h]
  __int64 v467; // [sp+38h] [bp-1E8h]
  unsigned __int64 v468; // [sp+38h] [bp-1E8h]
  unsigned __int64 v469; // [sp+38h] [bp-1E8h]
  __int64 v470; // [sp+38h] [bp-1E8h]
  unsigned __int64 v471; // [sp+38h] [bp-1E8h]
  unsigned __int64 v472; // [sp+38h] [bp-1E8h]
  unsigned __int64 v473; // [sp+38h] [bp-1E8h]
  unsigned __int64 v474; // [sp+38h] [bp-1E8h]
  unsigned __int64 v475; // [sp+38h] [bp-1E8h]
  unsigned __int64 v476; // [sp+38h] [bp-1E8h]
  __int64 v477; // [sp+38h] [bp-1E8h]
  __int64 v478; // [sp+40h] [bp-1E0h]
  unsigned __int64 v479; // [sp+40h] [bp-1E0h]
  unsigned __int64 v480; // [sp+40h] [bp-1E0h]
  unsigned __int64 v481; // [sp+40h] [bp-1E0h]
  unsigned __int64 v482; // [sp+40h] [bp-1E0h]
  unsigned __int64 v483; // [sp+40h] [bp-1E0h]
  unsigned __int64 v484; // [sp+40h] [bp-1E0h]
  __int64 v485; // [sp+40h] [bp-1E0h]
  unsigned __int64 v486; // [sp+40h] [bp-1E0h]
  __int64 v487; // [sp+40h] [bp-1E0h]
  unsigned __int64 v488; // [sp+40h] [bp-1E0h]
  __int64 v489; // [sp+40h] [bp-1E0h]
  __int64 v490; // [sp+40h] [bp-1E0h]
  __int64 v491; // [sp+40h] [bp-1E0h]
  __int64 v492; // [sp+40h] [bp-1E0h]
  __int64 v493; // [sp+40h] [bp-1E0h]
  __int64 v494; // [sp+40h] [bp-1E0h]
  __int64 v495; // [sp+40h] [bp-1E0h]
  unsigned __int64 v496; // [sp+40h] [bp-1E0h]
  __int64 v497; // [sp+40h] [bp-1E0h]
  unsigned __int64 v498; // [sp+40h] [bp-1E0h]
  __int64 v499; // [sp+40h] [bp-1E0h]
  __int64 v500; // [sp+40h] [bp-1E0h]
  unsigned __int64 v501; // [sp+40h] [bp-1E0h]
  unsigned __int64 v502; // [sp+40h] [bp-1E0h]
  __int64 v503; // [sp+40h] [bp-1E0h]
  unsigned __int64 v504; // [sp+40h] [bp-1E0h]
  unsigned __int64 v505; // [sp+40h] [bp-1E0h]
  unsigned __int64 v506; // [sp+40h] [bp-1E0h]
  unsigned __int64 v507; // [sp+40h] [bp-1E0h]
  __int64 v508; // [sp+40h] [bp-1E0h]
  __int64 v509; // [sp+40h] [bp-1E0h]
  __int64 v510; // [sp+48h] [bp-1D8h]
  unsigned __int64 v511; // [sp+48h] [bp-1D8h]
  unsigned __int64 v512; // [sp+48h] [bp-1D8h]
  __int64 v513; // [sp+48h] [bp-1D8h]
  unsigned __int64 v514; // [sp+48h] [bp-1D8h]
  __int64 v515; // [sp+48h] [bp-1D8h]
  unsigned __int64 v516; // [sp+48h] [bp-1D8h]
  __int64 v517; // [sp+48h] [bp-1D8h]
  unsigned __int64 v518; // [sp+48h] [bp-1D8h]
  __int64 v519; // [sp+48h] [bp-1D8h]
  __int64 v520; // [sp+48h] [bp-1D8h]
  unsigned __int64 v521; // [sp+48h] [bp-1D8h]
  __int64 v522; // [sp+48h] [bp-1D8h]
  __int64 v523; // [sp+48h] [bp-1D8h]
  unsigned __int64 v524; // [sp+48h] [bp-1D8h]
  unsigned __int64 v525; // [sp+48h] [bp-1D8h]
  unsigned __int64 v526; // [sp+48h] [bp-1D8h]
  unsigned __int64 v527; // [sp+48h] [bp-1D8h]
  unsigned __int64 v528; // [sp+48h] [bp-1D8h]
  unsigned __int64 v529; // [sp+48h] [bp-1D8h]
  unsigned __int64 v530; // [sp+48h] [bp-1D8h]
  unsigned __int64 v531; // [sp+48h] [bp-1D8h]
  __int64 v532; // [sp+48h] [bp-1D8h]
  __int64 v533; // [sp+48h] [bp-1D8h]
  unsigned __int64 v534; // [sp+48h] [bp-1D8h]
  unsigned __int64 v535; // [sp+48h] [bp-1D8h]
  unsigned __int64 v536; // [sp+48h] [bp-1D8h]
  unsigned __int64 v537; // [sp+48h] [bp-1D8h]
  unsigned __int64 v538; // [sp+48h] [bp-1D8h]
  unsigned __int64 v539; // [sp+50h] [bp-1D0h]
  unsigned __int64 v540; // [sp+50h] [bp-1D0h]
  __int64 v541; // [sp+50h] [bp-1D0h]
  unsigned __int64 v542; // [sp+50h] [bp-1D0h]
  unsigned __int64 v543; // [sp+50h] [bp-1D0h]
  __int64 v544; // [sp+50h] [bp-1D0h]
  __int64 v545; // [sp+50h] [bp-1D0h]
  unsigned __int64 v546; // [sp+50h] [bp-1D0h]
  unsigned __int64 v547; // [sp+50h] [bp-1D0h]
  unsigned __int64 v548; // [sp+50h] [bp-1D0h]
  __int64 v549; // [sp+50h] [bp-1D0h]
  unsigned __int64 v550; // [sp+50h] [bp-1D0h]
  unsigned __int64 v551; // [sp+50h] [bp-1D0h]
  unsigned __int64 v552; // [sp+50h] [bp-1D0h]
  unsigned __int64 v553; // [sp+50h] [bp-1D0h]
  __int64 v554; // [sp+50h] [bp-1D0h]
  __int64 v555; // [sp+50h] [bp-1D0h]
  unsigned __int64 v556; // [sp+50h] [bp-1D0h]
  unsigned __int64 v557; // [sp+50h] [bp-1D0h]
  __int64 v558; // [sp+50h] [bp-1D0h]
  unsigned __int64 v559; // [sp+50h] [bp-1D0h]
  __int64 v560; // [sp+50h] [bp-1D0h]
  __int64 v561; // [sp+50h] [bp-1D0h]
  __int64 v562; // [sp+50h] [bp-1D0h]
  __int64 v563; // [sp+50h] [bp-1D0h]
  unsigned __int64 v564; // [sp+50h] [bp-1D0h]
  unsigned __int64 v565; // [sp+50h] [bp-1D0h]
  __int64 v566; // [sp+50h] [bp-1D0h]
  __int64 v567; // [sp+50h] [bp-1D0h]
  unsigned __int64 v568; // [sp+50h] [bp-1D0h]
  unsigned __int64 v569; // [sp+50h] [bp-1D0h]
  unsigned __int64 v570; // [sp+50h] [bp-1D0h]
  unsigned __int64 v571; // [sp+50h] [bp-1D0h]
  __int64 v572; // [sp+58h] [bp-1C8h]
  unsigned __int64 v573; // [sp+58h] [bp-1C8h]
  unsigned __int64 v574; // [sp+58h] [bp-1C8h]
  __int64 v575; // [sp+58h] [bp-1C8h]
  unsigned __int64 v576; // [sp+58h] [bp-1C8h]
  __int64 v577; // [sp+58h] [bp-1C8h]
  __int64 v578; // [sp+58h] [bp-1C8h]
  __int64 v579; // [sp+58h] [bp-1C8h]
  unsigned __int64 v580; // [sp+58h] [bp-1C8h]
  unsigned __int64 v581; // [sp+58h] [bp-1C8h]
  unsigned __int64 v582; // [sp+58h] [bp-1C8h]
  unsigned __int64 v583; // [sp+58h] [bp-1C8h]
  __int64 v584; // [sp+58h] [bp-1C8h]
  unsigned __int64 v585; // [sp+58h] [bp-1C8h]
  unsigned __int64 v586; // [sp+58h] [bp-1C8h]
  unsigned __int64 v587; // [sp+58h] [bp-1C8h]
  __int64 v588; // [sp+58h] [bp-1C8h]
  __int64 v589; // [sp+58h] [bp-1C8h]
  __int64 v590; // [sp+58h] [bp-1C8h]
  unsigned __int64 v591; // [sp+58h] [bp-1C8h]
  unsigned __int64 v592; // [sp+58h] [bp-1C8h]
  __int64 v593; // [sp+58h] [bp-1C8h]
  __int64 v594; // [sp+58h] [bp-1C8h]
  __int64 v595; // [sp+58h] [bp-1C8h]
  __int64 v596; // [sp+58h] [bp-1C8h]
  unsigned __int64 v597; // [sp+58h] [bp-1C8h]
  unsigned __int64 v598; // [sp+58h] [bp-1C8h]
  unsigned __int64 v599; // [sp+58h] [bp-1C8h]
  unsigned __int64 v600; // [sp+58h] [bp-1C8h]
  unsigned __int64 v601; // [sp+58h] [bp-1C8h]
  unsigned __int64 v602; // [sp+58h] [bp-1C8h]
  __int64 v603; // [sp+60h] [bp-1C0h]
  unsigned __int64 v604; // [sp+60h] [bp-1C0h]
  unsigned __int64 v605; // [sp+60h] [bp-1C0h]
  unsigned __int64 v606; // [sp+60h] [bp-1C0h]
  __int64 v607; // [sp+60h] [bp-1C0h]
  __int64 v608; // [sp+60h] [bp-1C0h]
  __int64 v609; // [sp+60h] [bp-1C0h]
  __int64 v610; // [sp+60h] [bp-1C0h]
  __int64 v611; // [sp+60h] [bp-1C0h]
  __int64 v612; // [sp+60h] [bp-1C0h]
  __int64 v613; // [sp+60h] [bp-1C0h]
  __int64 v614; // [sp+60h] [bp-1C0h]
  unsigned __int64 v615; // [sp+60h] [bp-1C0h]
  unsigned __int64 v616; // [sp+60h] [bp-1C0h]
  unsigned __int64 v617; // [sp+60h] [bp-1C0h]
  unsigned __int64 v618; // [sp+60h] [bp-1C0h]
  unsigned __int64 v619; // [sp+60h] [bp-1C0h]
  unsigned __int64 v620; // [sp+60h] [bp-1C0h]
  unsigned __int64 v621; // [sp+60h] [bp-1C0h]
  unsigned __int64 v622; // [sp+60h] [bp-1C0h]
  unsigned __int64 v623; // [sp+60h] [bp-1C0h]
  __int64 v624; // [sp+60h] [bp-1C0h]
  __int64 v625; // [sp+60h] [bp-1C0h]
  __int64 v626; // [sp+60h] [bp-1C0h]
  __int64 v627; // [sp+60h] [bp-1C0h]
  __int64 v628; // [sp+60h] [bp-1C0h]
  unsigned __int64 v629; // [sp+60h] [bp-1C0h]
  unsigned __int64 v630; // [sp+60h] [bp-1C0h]
  unsigned __int64 v631; // [sp+60h] [bp-1C0h]
  __int64 v632; // [sp+60h] [bp-1C0h]
  __int64 v633; // [sp+60h] [bp-1C0h]
  unsigned __int64 v634; // [sp+68h] [bp-1B8h]
  __int64 v635; // [sp+68h] [bp-1B8h]
  unsigned __int64 v636; // [sp+68h] [bp-1B8h]
  unsigned __int64 v637; // [sp+68h] [bp-1B8h]
  __int64 v638; // [sp+68h] [bp-1B8h]
  unsigned __int64 v639; // [sp+68h] [bp-1B8h]
  unsigned __int64 v640; // [sp+68h] [bp-1B8h]
  __int64 v641; // [sp+68h] [bp-1B8h]
  __int64 v642; // [sp+68h] [bp-1B8h]
  unsigned __int64 v643; // [sp+68h] [bp-1B8h]
  __int64 v644; // [sp+68h] [bp-1B8h]
  __int64 v645; // [sp+68h] [bp-1B8h]
  __int64 v646; // [sp+68h] [bp-1B8h]
  __int64 v647; // [sp+68h] [bp-1B8h]
  __int64 v648; // [sp+68h] [bp-1B8h]
  __int64 v649; // [sp+68h] [bp-1B8h]
  __int64 v650; // [sp+68h] [bp-1B8h]
  __int64 v651; // [sp+68h] [bp-1B8h]
  __int64 v652; // [sp+68h] [bp-1B8h]
  __int64 v653; // [sp+68h] [bp-1B8h]
  __int64 v654; // [sp+68h] [bp-1B8h]
  unsigned __int64 v655; // [sp+68h] [bp-1B8h]
  unsigned __int64 v656; // [sp+68h] [bp-1B8h]
  unsigned __int64 v657; // [sp+68h] [bp-1B8h]
  unsigned __int64 v658; // [sp+68h] [bp-1B8h]
  unsigned __int64 v659; // [sp+68h] [bp-1B8h]
  __int64 v660; // [sp+68h] [bp-1B8h]
  __int64 v661; // [sp+68h] [bp-1B8h]
  __int64 v662; // [sp+68h] [bp-1B8h]
  __int64 v663; // [sp+68h] [bp-1B8h]
  unsigned __int64 v664; // [sp+70h] [bp-1B0h]
  __int64 v665; // [sp+70h] [bp-1B0h]
  unsigned __int64 v666; // [sp+70h] [bp-1B0h]
  __int64 v667; // [sp+70h] [bp-1B0h]
  __int64 v668; // [sp+70h] [bp-1B0h]
  __int64 v669; // [sp+70h] [bp-1B0h]
  __int64 v670; // [sp+70h] [bp-1B0h]
  __int64 v671; // [sp+70h] [bp-1B0h]
  __int64 v672; // [sp+70h] [bp-1B0h]
  __int64 v673; // [sp+70h] [bp-1B0h]
  __int64 v674; // [sp+70h] [bp-1B0h]
  __int64 v675; // [sp+70h] [bp-1B0h]
  __int64 v676; // [sp+70h] [bp-1B0h]
  __int64 v677; // [sp+70h] [bp-1B0h]
  __int64 v678; // [sp+70h] [bp-1B0h]
  __int64 v679; // [sp+70h] [bp-1B0h]
  unsigned __int64 v680; // [sp+70h] [bp-1B0h]
  unsigned __int64 v681; // [sp+70h] [bp-1B0h]
  __int64 v682; // [sp+70h] [bp-1B0h]
  __int64 v683; // [sp+70h] [bp-1B0h]
  __int64 v684; // [sp+70h] [bp-1B0h]
  __int64 v685; // [sp+70h] [bp-1B0h]
  unsigned __int64 v686; // [sp+70h] [bp-1B0h]
  unsigned __int64 v687; // [sp+70h] [bp-1B0h]
  unsigned __int64 v688; // [sp+70h] [bp-1B0h]
  unsigned __int64 v689; // [sp+70h] [bp-1B0h]
  unsigned __int64 v690; // [sp+70h] [bp-1B0h]
  unsigned __int64 v691; // [sp+78h] [bp-1A8h]
  unsigned __int64 v692; // [sp+78h] [bp-1A8h]
  __int64 v693; // [sp+78h] [bp-1A8h]
  __int64 v694; // [sp+78h] [bp-1A8h]
  __int64 v695; // [sp+78h] [bp-1A8h]
  __int64 v696; // [sp+78h] [bp-1A8h]
  __int64 v697; // [sp+78h] [bp-1A8h]
  __int64 v698; // [sp+78h] [bp-1A8h]
  __int64 v699; // [sp+78h] [bp-1A8h]
  __int64 v700; // [sp+78h] [bp-1A8h]
  __int64 v701; // [sp+78h] [bp-1A8h]
  __int64 v702; // [sp+78h] [bp-1A8h]
  __int64 v703; // [sp+78h] [bp-1A8h]
  unsigned __int64 v704; // [sp+78h] [bp-1A8h]
  __int64 v705; // [sp+78h] [bp-1A8h]
  unsigned __int64 v706; // [sp+78h] [bp-1A8h]
  __int64 v707; // [sp+78h] [bp-1A8h]
  __int64 v708; // [sp+78h] [bp-1A8h]
  __int64 v709; // [sp+78h] [bp-1A8h]
  __int64 v710; // [sp+78h] [bp-1A8h]
  __int64 v711; // [sp+78h] [bp-1A8h]
  __int64 v712; // [sp+78h] [bp-1A8h]
  __int64 v713; // [sp+78h] [bp-1A8h]
  __int64 v714; // [sp+78h] [bp-1A8h]
  __int64 v715; // [sp+78h] [bp-1A8h]
  __int64 v716; // [sp+78h] [bp-1A8h]
  unsigned __int64 v717; // [sp+78h] [bp-1A8h]
  __int64 v718; // [sp+78h] [bp-1A8h]
  unsigned __int64 v719; // [sp+80h] [bp-1A0h]
  unsigned __int64 v720; // [sp+80h] [bp-1A0h]
  __int64 v721; // [sp+80h] [bp-1A0h]
  unsigned __int64 v722; // [sp+80h] [bp-1A0h]
  unsigned __int64 v723; // [sp+80h] [bp-1A0h]
  __int64 v724; // [sp+80h] [bp-1A0h]
  __int64 v725; // [sp+80h] [bp-1A0h]
  __int64 v726; // [sp+80h] [bp-1A0h]
  unsigned __int64 v727; // [sp+80h] [bp-1A0h]
  __int64 v728; // [sp+80h] [bp-1A0h]
  __int64 v729; // [sp+80h] [bp-1A0h]
  __int64 v730; // [sp+80h] [bp-1A0h]
  __int64 v731; // [sp+80h] [bp-1A0h]
  unsigned __int64 v732; // [sp+80h] [bp-1A0h]
  unsigned __int64 v733; // [sp+80h] [bp-1A0h]
  __int64 v734; // [sp+80h] [bp-1A0h]
  unsigned __int64 v735; // [sp+80h] [bp-1A0h]
  __int64 v736; // [sp+80h] [bp-1A0h]
  __int64 v737; // [sp+80h] [bp-1A0h]
  __int64 v738; // [sp+80h] [bp-1A0h]
  unsigned __int64 v739; // [sp+88h] [bp-198h]
  unsigned __int64 v740; // [sp+88h] [bp-198h]
  unsigned __int64 v741; // [sp+88h] [bp-198h]
  unsigned __int64 v742; // [sp+88h] [bp-198h]
  unsigned __int64 v743; // [sp+88h] [bp-198h]
  unsigned __int64 v744; // [sp+88h] [bp-198h]
  unsigned __int64 v745; // [sp+90h] [bp-190h]
  unsigned __int64 v746; // [sp+90h] [bp-190h]
  __int64 v747; // [sp+98h] [bp-188h]
  unsigned __int64 v748; // [sp+98h] [bp-188h]
  __int64 v749; // [sp+A0h] [bp-180h]
  __int64 v750; // [sp+A0h] [bp-180h]
  __int64 v751; // [sp+A0h] [bp-180h]
  unsigned __int64 v752; // [sp+A0h] [bp-180h]
  __int64 v753; // [sp+A0h] [bp-180h]
  __int64 v754; // [sp+A0h] [bp-180h]
  __int64 v755; // [sp+A0h] [bp-180h]
  __int64 v756; // [sp+A0h] [bp-180h]
  __int64 v757; // [sp+A0h] [bp-180h]
  __int64 v758; // [sp+A0h] [bp-180h]
  unsigned __int64 v759; // [sp+A0h] [bp-180h]
  __int64 v760; // [sp+A0h] [bp-180h]
  __int64 v761; // [sp+A0h] [bp-180h]
  __int64 v762; // [sp+A8h] [bp-178h]
  unsigned __int64 v763; // [sp+B0h] [bp-170h]
  unsigned __int64 v764; // [sp+B0h] [bp-170h]
  unsigned __int64 v765; // [sp+B8h] [bp-168h]
  unsigned __int64 v766; // [sp+B8h] [bp-168h]
  unsigned __int64 v767; // [sp+C0h] [bp-160h]
  __int64 v768; // [sp+C8h] [bp-158h]
  __int64 v769; // [sp+D0h] [bp-150h]
  unsigned __int64 v770; // [sp+D0h] [bp-150h]
  unsigned __int64 v771; // [sp+D0h] [bp-150h]
  unsigned __int64 v772; // [sp+D8h] [bp-148h]
  unsigned __int64 v773; // [sp+E0h] [bp-140h]
  unsigned __int64 v774; // [sp+E0h] [bp-140h]
  __int64 v775; // [sp+E8h] [bp-138h]
  unsigned __int64 v776; // [sp+F0h] [bp-130h]
  __int64 v777; // [sp+F8h] [bp-128h]
  __int64 v778; // [sp+F8h] [bp-128h]
  __int64 v779; // [sp+F8h] [bp-128h]
  __int64 v780; // [sp+F8h] [bp-128h]
  __int64 v781; // [sp+F8h] [bp-128h]
  __int64 v782; // [sp+F8h] [bp-128h]
  unsigned __int64 v783; // [sp+F8h] [bp-128h]
  unsigned __int64 v784; // [sp+F8h] [bp-128h]
  __int64 v785; // [sp+F8h] [bp-128h]
  __int64 v786; // [sp+F8h] [bp-128h]
  __int64 v787; // [sp+108h] [bp-118h]
  __int64 v789; // [sp+118h] [bp-108h] BYREF
  __int64 v790; // [sp+120h] [bp-100h]
  __int64 v791; // [sp+128h] [bp-F8h]
  __int64 v792; // [sp+130h] [bp-F0h]
  __int64 v793; // [sp+138h] [bp-E8h]
  __int64 v794; // [sp+140h] [bp-E0h]
  __int64 v795; // [sp+148h] [bp-D8h]
  __int64 v796; // [sp+150h] [bp-D0h]
  __int64 v797; // [sp+158h] [bp-C8h]
  __int64 v798; // [sp+160h] [bp-C0h]
  __int64 v799; // [sp+168h] [bp-B8h]
  __int64 v800; // [sp+170h] [bp-B0h]
  __int64 v801; // [sp+178h] [bp-A8h]
  __int64 v802; // [sp+180h] [bp-A0h]
  __int64 v803; // [sp+188h] [bp-98h]
  __int64 v804; // [sp+190h] [bp-90h]
  __int64 v805; // [sp+198h] [bp-88h] BYREF
  __int64 v806; // [sp+1A0h] [bp-80h] BYREF
  unsigned __int64 v807; // [sp+1A8h] [bp-78h]
  unsigned __int64 v808; // [sp+1B0h] [bp-70h]
  __int64 v809; // [sp+1B8h] [bp-68h]
  __int64 v810; // [sp+1C0h] [bp-60h]
  __int64 v811; // [sp+1C8h] [bp-58h]
  __int64 v812; // [sp+1D0h] [bp-50h]
  __int64 v813; // [sp+1D8h] [bp-48h] BYREF
  _QWORD v814[8]; // [sp+1E0h] [bp-40h] BYREF

  v2 = &v789;
  v3 = a2 + 128;
  do
  {
    v4 = a2[7];
    v5 = a2[6];
    v6 = vshld_n_s64(a2[5], 0x28u)
       | vshld_n_s64(a2[4], 0x20u)
       | vshld_n_s64(a2[3], 0x18u)
       | *a2
       | vshld_n_s64(a2[2], 0x10u)
       | vshld_n_s64(a2[1], 8u);
    a2 += 8;
    v2[1] = vshld_n_s64(v4, 0x38u) | vshld_n_s64(v5, 0x30u) | v6;
    ++v2;
  }
  while ( a2 != v3 );
  v7 = a1 - 8;
  v8 = &v805;
  do
  {
    v9 = *(_QWORD *)(v7 + 8);
    v7 += 8;
    v8[1] = v9;
    ++v8;
  }
  while ( v8 != &v813 );
  v10 = v807 + v811 + v792;
  v11 = __PAIR64__(
          *(_DWORD *)(a1 + 72) ^ 0x2B3E6C1F ^ (unsigned int)v10,
          (*(_QWORD *)(a1 + 72) ^ 0x9B05688C2B3E6C1FLL ^ v10) >> 32);
  v12 = __PAIR64__(
          *(_DWORD *)(a1 + 72) ^ 0x2B3E6C1F ^ (unsigned int)v10,
          (*(_QWORD *)(a1 + 72) ^ 0x9B05688C2B3E6C1FLL ^ v10) >> 32)
      - 0x4498517A7B3558C5LL;
  v13 = (__int64)((__PAIR64__(
                     *(_DWORD *)(a1 + 72) ^ 0x2B3E6C1F ^ (unsigned int)v10,
                     (*(_QWORD *)(a1 + 72) ^ 0x9B05688C2B3E6C1FLL ^ v10) >> 32)
                 - 0x4498517A7B3558C5LL)
                ^ v811) >> 24;
  v14 = ((unsigned int)((v12 ^ v811) >> 32) >> 24) | (((unsigned int)v12 ^ (unsigned int)v811) << 8);
  v461 = v10 + v793 + __PAIR64__(v14, v13);
  v15 = *(_QWORD *)(a1 + 80) ^ 0x1F83D9ABFB41BD6BLL;
  v16 = *(_QWORD *)(a1 + 64) ^ 0x510E527FADE682D1LL ^ (v806 + v810 + v790);
  HIDWORD(v739) = *(_DWORD *)(a1 + 88) ^ 0x137E2179 ^ (v809 + v813 + v796);
  LODWORD(v739) = (*(_QWORD *)(a1 + 88) ^ 0x5BE0CD19137E2179LL ^ (unsigned __int64)(v809 + v813 + v796)) >> 32;
  v719 = __PAIR64__(v15 ^ (v812 + v808 + v794), (v15 ^ (v812 + v808 + v794)) >> 32);
  v17 = v11 ^ v461;
  LODWORD(v375) = v17 >> 16;
  v361 = __PAIR64__(v15 ^ (v812 + v808 + v794), (v15 ^ (v812 + v808 + v794)) >> 32) + 0x3C6EF372FE94F82BLL;
  HIDWORD(v375) = HIWORD(HIDWORD(v17)) | ((_DWORD)v17 << 16);
  v18 = (v739 - 0x5AB00AC5A0E2C90FLL) ^ v813;
  LODWORD(v389) = ((((_DWORD)v739 + 1595750129) ^ (unsigned int)v813) >> 24) | (HIDWORD(v18) << 8);
  HIDWORD(v389) = HIBYTE(HIDWORD(v18)) | ((((_DWORD)v739 + 1595750129) ^ (unsigned int)v813) << 8);
  LODWORD(v762) = (__int64)(v361 ^ v812) >> 24;
  LODWORD(v769) = (__int64)((__PAIR64__(v16, HIDWORD(v16)) + 0x6A09E667F3BCC908LL) ^ v810) >> 24;
  HIDWORD(v769) = ((unsigned int)(((__PAIR64__(v16, HIDWORD(v16)) + 0x6A09E667F3BCC908LL) ^ v810) >> 32) >> 24)
                | (((HIDWORD(v16) - 205731576) ^ (unsigned int)v810) << 8);
  v572 = v375 + v12;
  v19 = (v375 + v12) ^ __PAIR64__(v14, v13);
  HIDWORD(v762) = ((unsigned int)((v361 ^ v812) >> 32) >> 24) | (((unsigned int)v361 ^ (unsigned int)v812) << 8);
  HIDWORD(v773) = v19 >> 31;
  v603 = v809 + v813 + v796 + v797 + v389;
  LODWORD(v773) = (2 * v19) | (HIDWORD(v19) >> 31);
  v478 = v806 + v810 + v790 + v791 + v769;
  v510 = v812 + v808 + v794 + v795 + v762;
  LODWORD(v691) = (__int64)(v603 ^ v739) >> 16;
  HIDWORD(v691) = ((unsigned int)((v603 ^ v739) >> 32) >> 16) | (((unsigned int)v603 ^ (unsigned int)v739) << 16);
  LODWORD(v406) = (__int64)(v510 ^ v719) >> 16;
  HIDWORD(v406) = ((unsigned int)((v510 ^ v719) >> 32) >> 16) | (((unsigned int)v510 ^ (unsigned int)v719) << 16);
  HIDWORD(v20) = (v478 + v798 + v773) ^ v691;
  LODWORD(v20) = ((v478 + v798 + v773) ^ v691) >> 32;
  v21 = (v406 + v361) ^ v762;
  v539 = v20 + v406 + v361;
  LODWORD(v17) = (__int64)(v478 ^ __PAIR64__(v16, HIDWORD(v16))) >> 16;
  HIDWORD(v17) = ((HIDWORD(v478) ^ (unsigned int)v16) >> 16) | (((unsigned int)v478 ^ HIDWORD(v16)) << 16);
  LODWORD(v343) = (__int64)(v539 ^ v773) >> 24;
  HIDWORD(v343) = ((unsigned int)((v539 ^ v773) >> 32) >> 24) | (((unsigned int)v539 ^ (unsigned int)v773) << 8);
  HIDWORD(v361) = v21 >> 31;
  LODWORD(v361) = (2 * v21) | (HIDWORD(v21) >> 31);
  v634 = v478 + v798 + v773 + v799 + v343;
  v479 = v17 + __PAIR64__(v16, HIDWORD(v16)) + 0x6A09E667F3BCC908LL;
  v664 = v461 + v800 + v361;
  LODWORD(v461) = (__int64)(v634 ^ v20) >> 16;
  v22 = v691 + v739 - 0x5AB00AC5A0E2C90FLL;
  v434 = __PAIR64__((unsigned int)v17 ^ (unsigned int)v664, (v17 ^ v664) >> 32);
  v692 = __PAIR64__((unsigned int)v17 ^ (unsigned int)v664, (v17 ^ v664) >> 32) + v22;
  v23 = v22 ^ v389;
  HIDWORD(v461) = ((unsigned int)((v634 ^ v20) >> 32) >> 16) | (((unsigned int)v634 ^ (unsigned int)v20) << 16);
  LODWORD(v389) = (2 * (v479 ^ v769)) | ((unsigned int)((v479 ^ v769) >> 32) >> 31);
  v540 = v461 + v539;
  LODWORD(v420) = (2 * v23) | (HIDWORD(v23) >> 31);
  HIDWORD(v420) = v23 >> 31;
  v665 = v664 + v801;
  HIDWORD(v389) = (__int64)(v479 ^ v769) >> 31;
  v24 = v692 ^ v361;
  v25 = v603 + v804 + v389;
  v362 = __PAIR64__((unsigned int)v25 ^ (unsigned int)v406, (v25 ^ v406) >> 32);
  v407 = v25 + v805;
  v749 = v510 + v802 + v420 + v803;
  v26 = (v510 + v802 + v420) ^ v375;
  v635 = v634 + v804;
  v376 = (2 * (v540 ^ v343)) | ((unsigned int)((v540 ^ v343) >> 32) >> 31);
  v27 = (v362 + v572) ^ v389;
  v390 = __PAIR64__(HIBYTE(HIDWORD(v24)) | ((_DWORD)v24 << 8), v24 >> 24);
  LODWORD(v343) = v27 >> 24;
  HIDWORD(v343) = HIBYTE(HIDWORD(v27)) | ((_DWORD)v27 << 8);
  v604 = v25 + v805 + v343;
  v28 = (v665 + __PAIR64__(HIBYTE(HIDWORD(v24)) | ((_DWORD)v24 << 8), v24 >> 24)) ^ v434;
  v29 = __PAIR64__(v26, HIDWORD(v26));
  v30 = (v407 + v343) ^ v362;
  LODWORD(v407) = v28 >> 16;
  v480 = __PAIR64__(v26, HIDWORD(v26)) + v479;
  HIDWORD(v407) = HIWORD(HIDWORD(v28)) | ((_DWORD)v28 << 16);
  LODWORD(v434) = v30 >> 16;
  v720 = v665 + v390 + v794 + v376;
  HIDWORD(v434) = HIWORD(HIDWORD(v30)) | ((_DWORD)v30 << 16);
  v31 = v362 + v572;
  v573 = v407 + v692;
  LODWORD(v26) = (__int64)(v480 ^ v420) >> 24;
  HIDWORD(v26) = ((unsigned int)((v480 ^ v420) >> 32) >> 24) | (((unsigned int)v480 ^ (unsigned int)v420) << 8);
  v32 = (v407 + v692) ^ v390;
  v33 = (v434 + v31) ^ v343;
  LODWORD(v362) = (2 * v32) | (HIDWORD(v32) >> 31);
  HIDWORD(v362) = v32 >> 31;
  LODWORD(v420) = (2 * v33) | (HIDWORD(v33) >> 31);
  v34 = (v749 + v26) ^ v29;
  HIDWORD(v420) = v33 >> 31;
  LODWORD(v32) = v34 >> 16;
  HIDWORD(v32) = HIWORD(HIDWORD(v34)) | ((_DWORD)v34 << 16);
  v391 = v635 + v420;
  v740 = (v749 + v26 + v799 + v362) ^ v434;
  v344 = __PAIR64__((unsigned int)v720 ^ (unsigned int)v32, (v720 ^ v32) >> 32);
  v408 = __PAIR64__((v635 + v420) ^ v407, ((v635 + v420) ^ v407) >> 32);
  v481 = v32 + v480;
  v636 = __PAIR64__((unsigned int)v720 ^ (unsigned int)v32, (v720 ^ v32) >> 32) + v434 + v31;
  HIDWORD(v29) = (v749 + v26 + v799 + v362) ^ v434;
  v750 = v749 + v26 + v799 + v362 + v805;
  v693 = v391 + v800;
  v435 = __PAIR64__(HIDWORD(v29), HIDWORD(v740));
  v666 = __PAIR64__(HIDWORD(v29), HIDWORD(v740)) + v540;
  v35 = v481 ^ v26;
  v511 = v408 + v481;
  v36 = (v408 + v481) ^ v420;
  LODWORD(v31) = (__int64)(v636 ^ v376) >> 24;
  HIDWORD(v31) = ((unsigned int)((v636 ^ v376) >> 32) >> 24) | (((unsigned int)v636 ^ (unsigned int)v376) << 8);
  LODWORD(v391) = (2 * (v481 ^ v26)) | ((unsigned int)((v481 ^ v26) >> 32) >> 31);
  LODWORD(v26) = v36 >> 24;
  v721 = v720 + v798 + v31;
  HIDWORD(v391) = v35 >> 31;
  v482 = __PAIR64__(
           ((unsigned int)(((v435 + v540) ^ v362) >> 32) >> 24)
         | (((HIDWORD(v740) + (_DWORD)v540) ^ (unsigned int)v362) << 8),
           (__int64)((v435 + v540) ^ v362) >> 24);
  HIDWORD(v26) = HIBYTE(HIDWORD(v36)) | ((_DWORD)v36 << 8);
  v37 = __PAIR64__(
          ((unsigned int)(((v435 + v540) ^ v362) >> 32) >> 24)
        | (((HIDWORD(v740) + (_DWORD)v540) ^ (unsigned int)v362) << 8),
          (__int64)((v435 + v540) ^ v362) >> 24);
  v541 = v693 + v26;
  v694 = v750 + v37;
  LODWORD(v420) = (__int64)(v721 ^ v344) >> 16;
  HIDWORD(v420) = ((unsigned int)((v721 ^ v344) >> 32) >> 16) | (((unsigned int)v721 ^ (unsigned int)v344) << 16);
  v38 = (v750 + v37) ^ v435;
  LODWORD(v376) = (__int64)(v541 ^ v408) >> 16;
  HIDWORD(v376) = ((unsigned int)((v541 ^ v408) >> 32) >> 16) | (((unsigned int)v541 ^ (unsigned int)v408) << 16);
  v436 = v420 + v636;
  v39 = (v420 + v636) ^ v31;
  v345 = __PAIR64__(HIWORD(HIDWORD(v38)) | ((_DWORD)v38 << 16), v38 >> 16);
  v512 = v376 + v511;
  v637 = __PAIR64__(HIWORD(HIDWORD(v38)) | ((_DWORD)v38 << 16), v38 >> 16) + v666;
  LODWORD(v362) = (2 * v39) | (HIDWORD(v39) >> 31);
  v40 = v604 + v803 + v391;
  v41 = (__PAIR64__(HIWORD(HIDWORD(v38)) | ((_DWORD)v38 << 16), v38 >> 16) + v666) ^ v482;
  HIDWORD(v362) = v39 >> 31;
  LODWORD(v408) = (2 * (v512 ^ v26)) | ((unsigned int)((v512 ^ v26) >> 32) >> 31);
  HIDWORD(v38) = (__int64)(v512 ^ v26) >> 31;
  LODWORD(v26) = (v40 ^ v461) >> 32;
  HIDWORD(v26) = v40 ^ v461;
  v483 = v26 + v573;
  HIDWORD(v408) = HIDWORD(v38);
  v42 = (v26 + v573) ^ v391;
  LODWORD(v391) = v42 >> 24;
  HIDWORD(v391) = HIBYTE(HIDWORD(v42)) | ((_DWORD)v42 << 8);
  HIDWORD(v461) = v41 >> 31;
  LODWORD(v461) = (2 * v41) | (HIDWORD(v41) >> 31);
  v542 = v541 + v791 + v362;
  v43 = v40 + v796 + v391;
  v44 = v721 + v790 + v461;
  v45 = v43 + v795;
  v46 = v43 ^ v26;
  v47 = v44 ^ v376;
  v48 = v45 + v408;
  v777 = v44 + v792;
  LODWORD(v38) = v46 >> 16;
  HIDWORD(v38) = HIWORD(HIDWORD(v46)) | ((_DWORD)v46 << 16);
  v49 = v345;
  v346 = v542 ^ v38;
  LODWORD(v46) = (v48 ^ v49) >> 32;
  v484 = v38 + v483;
  HIDWORD(v46) = v48 ^ v49;
  v667 = v46 + v436;
  v751 = v542 + v802;
  v377 = (2 * (v484 ^ v391)) | ((unsigned int)((v484 ^ v391) >> 32) >> 31);
  v50 = (v46 + v436) ^ v408;
  v51 = v694 + v801 + v377;
  LODWORD(v436) = v50 >> 24;
  HIDWORD(v436) = HIBYTE(HIDWORD(v50)) | ((_DWORD)v50 << 8);
  v695 = v48 + v793 + v436;
  v52 = v51 ^ v420;
  v574 = __PAIR64__(v346, HIDWORD(v346)) + v637;
  v53 = v695 ^ v46;
  v605 = __PAIR64__(v47, HIDWORD(v47)) + v484;
  v54 = (__PAIR64__(v346, HIDWORD(v346)) + v637) ^ v362;
  v421 = __PAIR64__(HIWORD(HIDWORD(v53)) | ((_DWORD)v53 << 16), v53 >> 16);
  v55 = (__PAIR64__(v47, HIDWORD(v47)) + v484) ^ v461;
  v485 = v51 + v797;
  v363 = __PAIR64__(v52, HIDWORD(v52));
  v543 = __PAIR64__(v52, HIDWORD(v52)) + v512;
  LODWORD(v408) = v54 >> 24;
  v668 = __PAIR64__(HIWORD(HIDWORD(v53)) | ((_DWORD)v53 << 16), v53 >> 16) + v667;
  v56 = (__PAIR64__(v52, HIDWORD(v52)) + v512) ^ v377;
  v722 = __PAIR64__(HIBYTE(HIDWORD(v55)) | ((_DWORD)v55 << 8), v55 >> 24);
  v57 = v668 ^ v436;
  HIDWORD(v408) = HIBYTE(HIDWORD(v54)) | ((_DWORD)v54 << 8);
  LODWORD(v461) = (2 * v57) | (HIDWORD(v57) >> 31);
  v437 = v777 + __PAIR64__(HIBYTE(HIDWORD(v55)) | ((_DWORD)v55 << 8), v55 >> 24);
  v58 = (v751 + v408) ^ __PAIR64__(v346, HIDWORD(v346));
  HIDWORD(v461) = v57 >> 31;
  LODWORD(v51) = v56 >> 24;
  HIDWORD(v51) = HIBYTE(HIDWORD(v56)) | ((_DWORD)v56 << 8);
  LODWORD(v391) = v58 >> 16;
  v638 = v485 + v51;
  HIDWORD(v391) = HIWORD(HIDWORD(v58)) | ((_DWORD)v58 << 16);
  LODWORD(v56) = (__int64)(v437 ^ __PAIR64__(v47, HIDWORD(v47))) >> 16;
  v752 = v751 + v408 + v801 + v461;
  HIDWORD(v56) = ((unsigned int)((v437 ^ __PAIR64__(v47, HIDWORD(v47))) >> 32) >> 16)
               | (((unsigned int)v437 ^ HIDWORD(v47)) << 16);
  v486 = v391 + v574;
  v59 = (v391 + v574) ^ v408;
  v513 = v56 + v605;
  v364 = __PAIR64__(
           ((unsigned int)((v638 ^ v363) >> 32) >> 16) | (((unsigned int)v638 ^ (unsigned int)v363) << 16),
           (__int64)(v638 ^ v363) >> 16);
  LODWORD(v377) = (2 * v59) | (HIDWORD(v59) >> 31);
  HIDWORD(v377) = v59 >> 31;
  v347 = __PAIR64__((unsigned int)v56 ^ (unsigned int)v752, (v56 ^ v752) >> 32);
  LODWORD(v408) = (2 * (v513 ^ v722)) | ((unsigned int)((v513 ^ v722) >> 32) >> 31);
  v60 = v51 ^ (v364 + v543);
  HIDWORD(v408) = (__int64)((v56 + v605) ^ v722) >> 31;
  v606 = __PAIR64__((unsigned int)v56 ^ (unsigned int)v752, (v56 ^ v752) >> 32) + v364 + v543;
  v575 = v752 + v798;
  v61 = v437 + v802 + v377;
  v62 = v606 ^ v461;
  v63 = (__int64)(v606 ^ v461) >> 24;
  v778 = v695 + v805;
  v462 = __PAIR64__((unsigned int)v61 ^ (unsigned int)v364, (v61 ^ v364) >> 32);
  v696 = v61 + v790;
  v438 = __PAIR64__((v638 + v795 + v408) ^ v421, ((v638 + v795 + v408) ^ v421) >> 32);
  v753 = v638 + v795 + v408 + v792;
  v64 = __PAIR64__((v638 + v795 + v408) ^ v421, ((v638 + v795 + v408) ^ v421) >> 32);
  LODWORD(v421) = v63;
  v639 = v64 + v486;
  HIDWORD(v421) = HIBYTE(HIDWORD(v62)) | ((_DWORD)v62 << 8);
  v544 = __PAIR64__((unsigned int)v61 ^ (unsigned int)v364, (v61 ^ v364) >> 32) + v668;
  v65 = (__PAIR64__((unsigned int)v61 ^ (unsigned int)v364, (v61 ^ v364) >> 32) + v668) ^ v377;
  v365 = (2 * v60) | (HIDWORD(v60) >> 31);
  v66 = (v64 + v486) ^ v408;
  v67 = v778 + v365;
  v779 = v778 + v365 + v803;
  LODWORD(v60) = v65 >> 24;
  v68 = (v575 + v421) ^ v347;
  HIDWORD(v60) = HIBYTE(HIDWORD(v65)) | ((_DWORD)v65 << 8);
  v409 = v67 ^ v391;
  HIDWORD(v486) = HIBYTE(HIDWORD(v66)) | ((_DWORD)v66 << 8);
  LODWORD(v486) = v66 >> 24;
  v789 = v575 + v421 + v800;
  v669 = v753 + v486;
  v69 = (v696 + v60) ^ v462;
  v70 = (v753 + v486) ^ v438;
  HIDWORD(v391) = HIWORD(HIDWORD(v68)) | ((_DWORD)v68 << 16);
  v697 = v696 + v60 + v793;
  LODWORD(v391) = v68 >> 16;
  v576 = __PAIR64__(v409, HIDWORD(v409));
  v71 = __PAIR64__(v409, HIDWORD(v409));
  v410 = __PAIR64__(HIWORD(HIDWORD(v69)) | ((_DWORD)v69 << 16), v69 >> 16);
  v439 = v71 + v513;
  v72 = (v71 + v513) ^ v365;
  HIDWORD(v347) = HIWORD(HIDWORD(v70)) | ((_DWORD)v70 << 16);
  LODWORD(v347) = v70 >> 16;
  v514 = v391 + v606;
  v607 = __PAIR64__(HIWORD(HIDWORD(v69)) | ((_DWORD)v69 << 16), v69 >> 16) + v544;
  LODWORD(v462) = v72 >> 24;
  LODWORD(v377) = (2 * (v514 ^ v63)) | ((unsigned int)((v514 ^ v421) >> 32) >> 31);
  v73 = (__PAIR64__(HIWORD(HIDWORD(v69)) | ((_DWORD)v69 << 16), v69 >> 16) + v544) ^ v60;
  HIDWORD(v462) = HIBYTE(HIDWORD(v72)) | ((_DWORD)v72 << 8);
  v74 = (v347 + v639) ^ v486;
  LODWORD(v365) = (2 * (((v69 >> 16) + v544) ^ v60)) | (HIDWORD(v73) >> 31);
  HIDWORD(v365) = v73 >> 31;
  v75 = (v779 + v462) ^ v576;
  HIDWORD(v377) = (__int64)(v514 ^ v421) >> 31;
  LODWORD(v60) = (2 * v74) | (HIDWORD(v74) >> 31);
  HIDWORD(v60) = v74 >> 31;
  LODWORD(v73) = v75 >> 16;
  HIDWORD(v73) = HIWORD(HIDWORD(v75)) | ((_DWORD)v75 << 16);
  v577 = v73 + v439;
  v76 = (v697 + v60) ^ v391;
  v422 = __PAIR64__((v789 + v365) ^ v73, ((v789 + v365) ^ (unsigned __int64)v73) >> 32);
  v698 = v697 + v60 + v796;
  v77 = (v73 + v439) ^ v462;
  v440 = __PAIR64__(v76, HIDWORD(v76));
  v78 = __PAIR64__((v789 + v365) ^ v73, ((v789 + v365) ^ (unsigned __int64)v73) >> 32) + v347 + v639;
  LODWORD(v391) = (2 * v77) | (HIDWORD(v77) >> 31);
  v578 = __PAIR64__(v76, HIDWORD(v76)) + v577;
  HIDWORD(v77) = v77 >> 31;
  v79 = v578 ^ v60;
  LODWORD(v77) = (__int64)(v78 ^ v365) >> 24;
  HIDWORD(v391) = HIDWORD(v77);
  HIDWORD(v77) = ((unsigned int)((v78 ^ v365) >> 32) >> 24) | (((unsigned int)v78 ^ (unsigned int)v365) << 8);
  LODWORD(v60) = (__int64)(v578 ^ v60) >> 24;
  HIDWORD(v60) = HIBYTE(HIDWORD(v79)) | ((_DWORD)v79 << 8);
  v545 = v789 + v365 + v804 + v77;
  v723 = v698 + v60;
  v80 = (v698 + v60) ^ v440;
  HIDWORD(v365) = ((unsigned int)(HIDWORD(v545) ^ HIDWORD(v422)) >> 16)
                | (((unsigned int)v545 ^ (unsigned int)v422) << 16);
  LODWORD(v365) = (__int64)(v545 ^ v422) >> 16;
  LODWORD(v486) = v80 >> 16;
  HIDWORD(v486) = HIWORD(HIDWORD(v80)) | ((_DWORD)v80 << 16);
  v441 = v365 + v78;
  v579 = v486 + v578;
  v81 = v77 ^ (v365 + v78);
  v82 = v669 + v797 + v391;
  v83 = v779 + v462 + v799 + v377;
  LODWORD(v422) = (2 * v81) | (HIDWORD(v81) >> 31);
  HIDWORD(v422) = v81 >> 31;
  v640 = v82 ^ v410;
  v84 = (2 * (v579 ^ v60)) | ((unsigned int)((v579 ^ v60) >> 32) >> 31);
  HIDWORD(v410) = (__int64)(v579 ^ v60) >> 31;
  v463 = __PAIR64__((unsigned int)v83 ^ (unsigned int)v347, (v83 ^ v347) >> 32);
  v670 = v82 + v791;
  v608 = __PAIR64__((unsigned int)v83 ^ (unsigned int)v347, (v83 ^ v347) >> 32) + v607;
  v754 = v545 + v797;
  LODWORD(v82) = (v608 ^ v377) >> 24;
  v780 = v698 + v60 + v793 + v422 + v791;
  HIDWORD(v82) = ((unsigned int)((v608 ^ (unsigned __int64)v377) >> 32) >> 24)
               | (((unsigned int)v608 ^ (unsigned int)v377) << 8);
  v85 = v83 + v794 + v82;
  v348 = __PAIR64__(v640, HIDWORD(v640)) + v514;
  LODWORD(v410) = v84;
  v86 = v85 + v801;
  v87 = v85 ^ v463;
  v699 = v86;
  LODWORD(v83) = v87 >> 16;
  HIDWORD(v83) = HIWORD(HIDWORD(v87)) | ((_DWORD)v87 << 16);
  v88 = (__PAIR64__(v640, HIDWORD(v640)) + v514) ^ v391;
  v515 = v83 + v608;
  LODWORD(v87) = v88 >> 24;
  HIDWORD(v87) = HIBYTE(HIDWORD(v88)) | ((_DWORD)v88 << 8);
  v89 = (v83 + v608) ^ v82;
  LODWORD(v391) = (2 * v89) | (HIDWORD(v89) >> 31);
  HIDWORD(v391) = v89 >> 31;
  v90 = (v670 + v87) ^ __PAIR64__(v640, HIDWORD(v640));
  LODWORD(v89) = v90 >> 16;
  HIDWORD(v89) = HIWORD(HIDWORD(v90)) | ((_DWORD)v90 << 16);
  LODWORD(v377) = ((v545 + v797 + v391) ^ v486) >> 32;
  v91 = (v670 + v87 + v803 + v410) ^ v83;
  HIDWORD(v377) = (v545 + v797 + v391) ^ v486;
  v487 = v377 + v89 + v348;
  v92 = (v89 + v348) ^ v87;
  v464 = __PAIR64__(v89 ^ (v723 + v793 + v422), (v89 ^ (v723 + v793 + v422)) >> 32);
  v641 = v670 + v87 + v803 + v410 + v802;
  v609 = __PAIR64__(v89 ^ (v723 + v793 + v422), (v89 ^ (v723 + v793 + v422)) >> 32) + v515;
  v741 = __PAIR64__(v91, HIDWORD(v91));
  LODWORD(v348) = (__int64)(v487 ^ v391) >> 24;
  v93 = __PAIR64__(v91, HIDWORD(v91)) + v441;
  HIDWORD(v348) = ((unsigned int)((v487 ^ v391) >> 32) >> 24) | (((unsigned int)v487 ^ (unsigned int)v391) << 8);
  v94 = (__PAIR64__(v89 ^ (v723 + v793 + v422), (v89 ^ (v723 + v793 + v422)) >> 32) + v515) ^ v422;
  v546 = v93;
  LODWORD(v87) = (2 * v92) | (HIDWORD(v92) >> 31);
  HIDWORD(v87) = v92 >> 31;
  v95 = v93 ^ v410;
  LODWORD(v723) = v94 >> 24;
  v671 = v699 + v87;
  v96 = (__int64)(v93 ^ v410) >> 24;
  v516 = v754 + v391 + v799 + v348;
  HIDWORD(v723) = HIBYTE(HIDWORD(v94)) | ((_DWORD)v94 << 8);
  v423 = __PAIR64__(HIBYTE(HIDWORD(v95)) | ((_DWORD)v95 << 8), v96);
  v392 = __PAIR64__(
           ((unsigned int)((v516 ^ v377) >> 32) >> 16)
         | ((((_DWORD)v754 + (_DWORD)v391 + (_DWORD)v799 + (_DWORD)v348) ^ (unsigned int)v377) << 16),
           (__int64)(v516 ^ v377) >> 16);
  v642 = v641 + __PAIR64__(HIBYTE(HIDWORD(v95)) | ((_DWORD)v95 << 8), v96);
  v366 = __PAIR64__((v699 + v87) ^ v365, ((v699 + v87) ^ (unsigned __int64)v365) >> 32);
  v97 = (v780 + v723) ^ v464;
  v700 = v366 + v579;
  v580 = v392 + v487;
  v98 = (v392 + v487) ^ v348;
  LODWORD(v410) = v97 >> 16;
  v99 = v700 ^ v87;
  LODWORD(v87) = (__int64)(v642 ^ v741) >> 16;
  LODWORD(v377) = (2 * v98) | (HIDWORD(v98) >> 31);
  HIDWORD(v377) = v98 >> 31;
  HIDWORD(v87) = ((unsigned int)((v642 ^ v741) >> 32) >> 16) | (((unsigned int)v642 ^ (unsigned int)v741) << 16);
  HIDWORD(v410) = HIWORD(HIDWORD(v97)) | ((_DWORD)v97 << 16);
  LODWORD(v464) = v99 >> 24;
  HIDWORD(v464) = HIBYTE(HIDWORD(v99)) | ((_DWORD)v99 << 8);
  v610 = v410 + v609;
  v547 = v87 + v546;
  v100 = v671 + v804 + v464;
  v101 = v547 ^ v423;
  v755 = v780 + v723 + v795;
  LODWORD(v348) = (2 * (v547 ^ v423)) | ((unsigned int)((v547 ^ v423) >> 32) >> 31);
  v102 = v100 + v805;
  v103 = v100 ^ v366;
  v104 = v102 + v377;
  LODWORD(v423) = v103 >> 16;
  HIDWORD(v423) = HIWORD(HIDWORD(v103)) | ((_DWORD)v103 << 16);
  LODWORD(v366) = (2 * (v610 ^ v723)) | ((unsigned int)((v610 ^ v723) >> 32) >> 31);
  HIDWORD(v348) = v101 >> 31;
  v488 = __PAIR64__((unsigned int)v104 ^ (unsigned int)v87, HIDWORD(v104) ^ HIDWORD(v87));
  HIDWORD(v366) = (__int64)(v610 ^ v723) >> 31;
  v672 = v423 + v700;
  v724 = v516 + v792;
  v105 = v423 + v700;
  v701 = __PAIR64__((unsigned int)v104 ^ (unsigned int)v87, HIDWORD(v104) ^ HIDWORD(v87)) + v610;
  v517 = v755 + v348;
  v442 = (2 * (v105 ^ v464)) | ((unsigned int)((v105 ^ v464) >> 32) >> 31);
  v106 = (__PAIR64__((unsigned int)v104 ^ (unsigned int)v87, HIDWORD(v104) ^ HIDWORD(v87)) + v610) ^ v377;
  v378 = v104 + v798;
  v611 = v642 + v794 + v442;
  LODWORD(v105) = v106 >> 24;
  v107 = (v755 + v348) ^ v392;
  HIDWORD(v105) = HIBYTE(HIDWORD(v106)) | ((_DWORD)v106 << 8);
  v756 = v378 + v105;
  v393 = (v724 + v366) ^ v423;
  v108 = v611 ^ v410;
  v109 = v378 + v105;
  v379 = v517 + v800;
  v110 = v109 ^ v488;
  v411 = __PAIR64__(v107, HIDWORD(v107));
  v725 = v724 + v366 + v796;
  v781 = v611 + v790;
  v612 = __PAIR64__(v107, HIDWORD(v107)) + v672;
  LODWORD(v464) = v110 >> 16;
  HIDWORD(v464) = HIWORD(HIDWORD(v110)) | ((_DWORD)v110 << 16);
  v111 = __PAIR64__(v393, HIDWORD(v393));
  v518 = __PAIR64__(v393, HIDWORD(v393)) + v547;
  v424 = __PAIR64__(v108, HIDWORD(v108));
  v702 = v464 + v701;
  v112 = (__PAIR64__(v393, HIDWORD(v393)) + v547) ^ v366;
  v643 = v424 + v580;
  v113 = v105 ^ v702;
  LODWORD(v488) = (2 * v113) | (HIDWORD(v113) >> 31);
  v114 = (v424 + v580) ^ v442;
  HIDWORD(v488) = v113 >> 31;
  LODWORD(v393) = v112 >> 24;
  HIDWORD(v393) = HIBYTE(HIDWORD(v112)) | ((_DWORD)v112 << 8);
  HIDWORD(v366) = ((unsigned int)((v612 ^ v348) >> 32) >> 24) | (((unsigned int)v612 ^ (unsigned int)v348) << 8);
  LODWORD(v366) = (__int64)(v612 ^ v348) >> 24;
  LODWORD(v348) = v114 >> 24;
  HIDWORD(v348) = HIBYTE(HIDWORD(v114)) | ((_DWORD)v114 << 8);
  v548 = v379 + v366;
  v115 = (v725 + v393) ^ v111;
  v673 = v781 + v348;
  v116 = (v379 + v366) ^ v411;
  v117 = v725 + v393 + v799 + v488;
  LODWORD(v379) = v115 >> 16;
  v118 = (v781 + v348) ^ v424;
  v782 = v117 + v790;
  LODWORD(v114) = v116 >> 16;
  HIDWORD(v114) = HIWORD(HIDWORD(v116)) | ((_DWORD)v116 << 16);
  HIDWORD(v379) = HIWORD(HIDWORD(v115)) | ((_DWORD)v115 << 16);
  LODWORD(v424) = v118 >> 16;
  HIDWORD(v424) = HIWORD(HIDWORD(v118)) | ((_DWORD)v118 << 16);
  v581 = v379 + v518;
  v443 = __PAIR64__((unsigned int)v114 ^ (unsigned int)v117, (v114 ^ v117) >> 32);
  v119 = (v379 + v518) ^ v393;
  v519 = v114 + v612;
  v120 = __PAIR64__((unsigned int)v114 ^ (unsigned int)v117, (v114 ^ v117) >> 32) + v424 + v643;
  v121 = (v114 + v612) ^ v366;
  LODWORD(v411) = (2 * v119) | (HIDWORD(v119) >> 31);
  HIDWORD(v411) = v119 >> 31;
  LODWORD(v87) = (2 * (v519 ^ v366)) | ((unsigned int)((v519 ^ v366) >> 32) >> 31);
  HIDWORD(v114) = ((unsigned int)((v120 ^ v488) >> 32) >> 24) | (((unsigned int)v120 ^ (unsigned int)v488) << 8);
  HIDWORD(v87) = v121 >> 31;
  LODWORD(v114) = (__int64)(v120 ^ v488) >> 24;
  v489 = v782 + v114;
  v122 = (v782 + v114) ^ v443;
  LODWORD(v366) = v122 >> 16;
  HIDWORD(v366) = HIWORD(HIDWORD(v122)) | ((_DWORD)v122 << 16);
  v444 = v366 + v120;
  v394 = (2 * ((v424 + v643) ^ v348)) | ((unsigned int)(((v424 + v643) ^ v348) >> 32) >> 31);
  v123 = v548 + v795 + v411;
  v124 = v114 ^ (v366 + v120);
  v425 = __PAIR64__((unsigned int)v123 ^ (unsigned int)v424, (v123 ^ v424) >> 32);
  v549 = v123 + v797;
  v349 = __PAIR64__((v673 + v792 + v87) ^ v464, ((v673 + v792 + v87) ^ v464) >> 32);
  v644 = v673 + v792 + v87 + v794;
  v613 = v425 + v702;
  v582 = __PAIR64__((v673 + v792 + v87) ^ v464, ((v673 + v792 + v87) ^ v464) >> 32) + v581;
  v465 = (v756 + v800 + v394) ^ v379;
  HIDWORD(v379) = v124 >> 31;
  v125 = (v425 + v702) ^ v411;
  v674 = v756 + v800 + v394 + v805;
  LODWORD(v411) = v125 >> 24;
  v703 = v489 + v804;
  LODWORD(v119) = (__int64)(v582 ^ v87) >> 24;
  HIDWORD(v411) = HIBYTE(HIDWORD(v125)) | ((_DWORD)v125 << 8);
  HIDWORD(v119) = ((unsigned int)((v582 ^ v87) >> 32) >> 24) | (((unsigned int)v582 ^ (unsigned int)v87) << 8);
  LODWORD(v118) = (v549 + v411) ^ v425;
  LODWORD(v379) = (2 * v124) | (HIDWORD(v124) >> 31);
  v126 = (v644 + v119) ^ v349;
  HIDWORD(v118) = (unsigned int)(((v549 + v411) ^ v425) >> 32) >> 16;
  LODWORD(v425) = (__int64)((v549 + v411) ^ v425) >> 16;
  v127 = __PAIR64__(v465, HIDWORD(v465));
  v726 = v549 + v411 + v801;
  HIDWORD(v425) = HIDWORD(v118) | ((_DWORD)v118 << 16);
  v520 = __PAIR64__(v465, HIDWORD(v465)) + v519;
  LODWORD(v118) = v520 ^ v394;
  LODWORD(v465) = v126 >> 16;
  v490 = v425 + v613;
  HIDWORD(v465) = HIWORD(HIDWORD(v126)) | ((_DWORD)v126 << 16);
  HIDWORD(v118) = (unsigned int)((v520 ^ (unsigned __int64)v394) >> 32) >> 24;
  LODWORD(v394) = (v520 ^ v394) >> 24;
  HIDWORD(v394) = HIDWORD(v118) | ((_DWORD)v118 << 8);
  v645 = v644 + v119 + v796;
  v350 = (2 * ((v425 + v613) ^ v411)) | ((unsigned int)(((v425 + v613) ^ v411) >> 32) >> 31);
  v128 = (v465 + v582) ^ v119;
  LODWORD(v119) = (2 * v128) | (HIDWORD(v128) >> 31);
  v129 = (v674 + v394) ^ v127;
  v614 = v674 + v394;
  HIDWORD(v119) = v128 >> 31;
  LODWORD(v120) = v129 >> 16;
  HIDWORD(v120) = HIWORD(HIDWORD(v129)) | ((_DWORD)v129 << 16);
  v130 = (v703 + v350) ^ v120;
  v131 = __PAIR64__(v130, HIDWORD(v130));
  v583 = __PAIR64__(v130, HIDWORD(v130)) + v465 + v582;
  v132 = (v120 + v520) ^ v394;
  v133 = (2 * ((v120 + v520) ^ v394)) | (HIDWORD(v132) >> 31);
  v395 = v726 + v119 + v802;
  v367 = __PAIR64__((v726 + v119) ^ v366, ((v726 + v119) ^ v366) >> 32);
  LODWORD(v411) = v133;
  v550 = v367 + v120 + v520;
  HIDWORD(v411) = v132 >> 31;
  v134 = v550 ^ v119;
  LODWORD(v120) = (__int64)(v583 ^ v350) >> 24;
  HIDWORD(v120) = ((unsigned int)((v583 ^ v350) >> 32) >> 24) | (((unsigned int)v583 ^ (unsigned int)v350) << 8);
  LODWORD(v119) = (__int64)(v550 ^ v119) >> 24;
  HIDWORD(v119) = HIBYTE(HIDWORD(v134)) | ((_DWORD)v134 << 8);
  v521 = v703 + v350 + v791 + v120;
  v675 = v645 + v411;
  v646 = v395 + v119;
  v135 = v395 + v119;
  LODWORD(v395) = (__int64)(v521 ^ v131) >> 16;
  HIDWORD(v395) = ((unsigned int)(HIDWORD(v521) ^ HIDWORD(v131)) >> 16)
                | (((unsigned int)v521 ^ (unsigned int)v131) << 16);
  v136 = v135 ^ v367;
  v351 = __PAIR64__((unsigned int)v675 ^ (unsigned int)v425, (v675 ^ v425) >> 32);
  v584 = v395 + v583;
  LODWORD(v425) = v136 >> 16;
  HIDWORD(v425) = HIWORD(HIDWORD(v136)) | ((_DWORD)v136 << 16);
  v704 = v351 + v444;
  v551 = v425 + v550;
  v137 = (v351 + v444) ^ v411;
  HIDWORD(v367) = (__int64)(v584 ^ v120) >> 31;
  v676 = v675 + v798;
  LODWORD(v367) = (2 * (v584 ^ v120)) | ((unsigned int)((v584 ^ v120) >> 32) >> 31);
  v138 = v551 ^ v119;
  LODWORD(v411) = (2 * (v551 ^ v119)) | ((unsigned int)((v551 ^ v119) >> 32) >> 31);
  v139 = (v614 + v793 + v379) ^ v465;
  HIDWORD(v411) = v138 >> 31;
  v491 = __PAIR64__(v139, HIDWORD(v139)) + v490;
  LODWORD(v465) = v137 >> 24;
  HIDWORD(v465) = HIBYTE(HIDWORD(v137)) | ((_DWORD)v137 << 8);
  LODWORD(v131) = (__int64)(v491 ^ v379) >> 24;
  HIDWORD(v131) = ((unsigned int)((v491 ^ v379) >> 32) >> 24) | (((unsigned int)v491 ^ (unsigned int)v379) << 8);
  v140 = (v676 + v465) ^ v351;
  v141 = v614 + v793 + v379 + v803 + v131;
  v757 = v141 + v798;
  v142 = v141 ^ __PAIR64__(v139, HIDWORD(v139));
  LODWORD(v120) = v140 >> 16;
  v143 = v676 + v465 + v790 + v411;
  LODWORD(v137) = v142 >> 16;
  HIDWORD(v137) = HIWORD(HIDWORD(v142)) | ((_DWORD)v142 << 16);
  HIDWORD(v120) = HIWORD(HIDWORD(v140)) | ((_DWORD)v140 << 16);
  v445 = v137 + v491;
  v144 = v143 ^ v137;
  v145 = v646 + v796 + v367;
  v492 = v144;
  v727 = v120 ^ v145;
  v146 = v445 ^ v131;
  v647 = v145 + v800;
  v147 = (v120 + v704) ^ v465;
  LODWORD(v131) = (2 * (v445 ^ v131)) | ((unsigned int)((v445 ^ v131) >> 32) >> 31);
  HIDWORD(v131) = v146 >> 31;
  LODWORD(v379) = (2 * v147) | (HIDWORD(v147) >> 31);
  HIDWORD(v379) = v147 >> 31;
  v148 = (v521 + v792 + v131) ^ v425;
  v149 = (v757 + v379) ^ v395;
  v466 = __PAIR64__(v148, HIDWORD(v148)) + v120 + v704;
  HIDWORD(v395) = ((unsigned int)((v466 ^ v131) >> 32) >> 24) | (((unsigned int)v466 ^ (unsigned int)v131) << 8);
  v352 = __PAIR64__(v492, HIDWORD(v492));
  LODWORD(v395) = (__int64)(v466 ^ v131) >> 24;
  v150 = __PAIR64__(v492, HIDWORD(v492)) + v584;
  v493 = __PAIR64__(v727, HIDWORD(v727)) + v445;
  v446 = v521 + v792 + v131 + v802 + v395;
  v522 = v150;
  v552 = __PAIR64__(v149, HIDWORD(v149)) + v551;
  v151 = v150 ^ v411;
  LODWORD(v411) = (__int64)(__PAIR64__(v148, HIDWORD(v148)) ^ v446) >> 16;
  HIDWORD(v411) = (((unsigned int)v148 ^ HIDWORD(v446)) >> 16) | ((HIDWORD(v148) ^ (unsigned int)v446) << 16);
  v368 = __PAIR64__(
           ((unsigned int)((v493 ^ v367) >> 32) >> 24) | (((unsigned int)v493 ^ (unsigned int)v367) << 8),
           (__int64)(v493 ^ v367) >> 24);
  v585 = v411 + v466;
  v152 = (v411 + v466) ^ v395;
  LODWORD(v131) = v151 >> 24;
  LODWORD(v741) = (__int64)(v552 ^ v379) >> 24;
  v467 = v647 + v368;
  HIDWORD(v131) = HIBYTE(HIDWORD(v151)) | ((_DWORD)v151 << 8);
  HIDWORD(v741) = ((unsigned int)((v552 ^ v379) >> 32) >> 24) | (((unsigned int)v552 ^ (unsigned int)v379) << 8);
  v153 = (v647 + v368) ^ __PAIR64__(v727, HIDWORD(v727));
  v615 = v143 + v801 + v131;
  v154 = v757 + v379 + v793;
  LODWORD(v379) = (2 * v152) | (HIDWORD(v152) >> 31);
  v648 = v154 + v741;
  HIDWORD(v379) = v152 >> 31;
  LODWORD(v395) = v153 >> 16;
  v155 = (v154 + v741) ^ __PAIR64__(v149, HIDWORD(v149));
  HIDWORD(v395) = HIWORD(HIDWORD(v153)) | ((_DWORD)v153 << 16);
  LODWORD(v154) = (__int64)(v615 ^ v352) >> 16;
  HIDWORD(v154) = ((unsigned int)((v615 ^ v352) >> 32) >> 16) | (((unsigned int)v615 ^ (unsigned int)v352) << 16);
  HIDWORD(v352) = HIWORD(HIDWORD(v155)) | ((_DWORD)v155 << 16);
  LODWORD(v352) = v155 >> 16;
  v523 = v154 + v522;
  v494 = v395 + v493;
  v156 = v494 ^ v368;
  v553 = v352 + v552;
  v677 = v446 + v794;
  LODWORD(v425) = (2 * (v523 ^ v131)) | ((unsigned int)((v523 ^ v131) >> 32) >> 31);
  HIDWORD(v425) = (__int64)(v523 ^ v131) >> 31;
  v157 = (v648 + v791 + v379) ^ v154;
  v447 = __PAIR64__(v157, HIDWORD(v157));
  v728 = v615 + v805;
  LODWORD(v368) = (2 * v156) | (HIDWORD(v156) >> 31);
  HIDWORD(v368) = v156 >> 31;
  v616 = v467 + v797 + v425;
  v158 = v648 + v791 + v379 + v799;
  LODWORD(v467) = (2 * (v553 ^ v741)) | ((unsigned int)((v553 ^ v741) >> 32) >> 31);
  v649 = __PAIR64__(v157, HIDWORD(v157)) + v494;
  HIDWORD(v467) = (__int64)(v553 ^ v741) >> 31;
  v159 = (__PAIR64__(v157, HIDWORD(v157)) + v494) ^ v379;
  v380 = v677 + v368;
  v729 = v728 + v467;
  v160 = (v677 + v368) ^ v352;
  LODWORD(v143) = v159 >> 24;
  HIDWORD(v143) = HIBYTE(HIDWORD(v159)) | ((_DWORD)v159 << 8);
  v161 = v729 ^ v395;
  v678 = v158 + v143;
  v412 = __PAIR64__((unsigned int)v616 ^ (unsigned int)v411, (v616 ^ v411) >> 32);
  v705 = v616 + v795;
  v162 = (v158 + v143) ^ v447;
  v396 = __PAIR64__(v160, HIDWORD(v160));
  v617 = v412 + v553;
  v448 = __PAIR64__(v160, HIDWORD(v160)) + v523;
  v353 = __PAIR64__(v161, HIDWORD(v161));
  v163 = (v412 + v553) ^ v425;
  HIDWORD(v494) = HIWORD(HIDWORD(v162)) | ((_DWORD)v162 << 16);
  LODWORD(v494) = v162 >> 16;
  v586 = __PAIR64__(v161, HIDWORD(v161)) + v585;
  v164 = v448 ^ v368;
  LODWORD(v368) = v163 >> 24;
  v554 = v494 + v649;
  v165 = v586 ^ v467;
  v166 = v143 ^ (v494 + v649);
  LODWORD(v467) = (2 * v166) | (HIDWORD(v166) >> 31);
  HIDWORD(v467) = v166 >> 31;
  v167 = v380 + v803;
  HIDWORD(v380) = HIBYTE(HIDWORD(v164)) | ((_DWORD)v164 << 8);
  LODWORD(v380) = v164 >> 24;
  HIDWORD(v368) = HIBYTE(HIDWORD(v163)) | ((_DWORD)v163 << 8);
  LODWORD(v425) = v165 >> 24;
  HIDWORD(v425) = HIBYTE(HIDWORD(v165)) | ((_DWORD)v165 << 8);
  v168 = v167 + v380;
  v524 = v729 + v804 + v425;
  v169 = v168 + v802 + v467;
  v170 = (v705 + v368) ^ v412;
  v397 = __PAIR64__(
           ((unsigned int)((v168 ^ v396) >> 32) >> 16) | (((unsigned int)v168 ^ (unsigned int)v396) << 16),
           (__int64)(v168 ^ v396) >> 16);
  v171 = v524 ^ v353;
  LODWORD(v164) = v170 >> 16;
  HIDWORD(v164) = HIWORD(HIDWORD(v170)) | ((_DWORD)v170 << 16);
  LODWORD(v353) = (__int64)(v524 ^ v353) >> 16;
  v449 = v397 + v448;
  HIDWORD(v353) = HIWORD(HIDWORD(v171)) | ((_DWORD)v171 << 16);
  v650 = v169 + v795;
  v172 = v353 + v586;
  LODWORD(v168) = HIDWORD(v169) ^ HIDWORD(v164);
  v587 = v164 + v617;
  HIDWORD(v168) = v169 ^ v164;
  LODWORD(v412) = (2 * (v449 ^ v380)) | ((unsigned int)((v449 ^ v380) >> 32) >> 31);
  HIDWORD(v412) = (__int64)(v449 ^ v380) >> 31;
  v618 = __PAIR64__((unsigned int)v169 ^ (unsigned int)v164, HIDWORD(v169) ^ HIDWORD(v164)) + v172;
  v173 = (__PAIR64__((unsigned int)v169 ^ (unsigned int)v164, HIDWORD(v169) ^ HIDWORD(v164)) + v172) ^ v467;
  v468 = v705 + v368 + v791 + v412;
  LODWORD(v169) = v173 >> 24;
  v174 = v172 ^ v425;
  HIDWORD(v169) = HIBYTE(HIDWORD(v173)) | ((_DWORD)v173 << 8);
  v706 = v468 ^ v353;
  LODWORD(v171) = (2 * (v587 ^ v368)) | ((unsigned int)((v587 ^ v368) >> 32) >> 31);
  HIDWORD(v171) = (__int64)(v587 ^ v368) >> 31;
  v175 = (v650 + v169) ^ v168;
  v354 = v650 + v169;
  LODWORD(v368) = v175 >> 16;
  HIDWORD(v368) = HIWORD(HIDWORD(v175)) | ((_DWORD)v175 << 16);
  v426 = __PAIR64__(v706, HIDWORD(v706));
  v619 = v368 + v618;
  HIDWORD(v380) = v174 >> 31;
  v555 = __PAIR64__(v706, HIDWORD(v706)) + v554;
  v176 = v619 ^ v169;
  v651 = v468 + v805;
  LODWORD(v380) = (2 * v174) | (HIDWORD(v174) >> 31);
  v177 = v524 + v804 + v171;
  v178 = v555 ^ v412;
  v413 = v678 + v794 + v380;
  v679 = v177 + v803;
  v179 = v177 ^ v494;
  v469 = v177 ^ v494;
  v495 = v413 + v800;
  v707 = v354 + v790;
  v414 = __PAIR64__((unsigned int)v413 ^ (unsigned int)v397, (v413 ^ v397) >> 32);
  v180 = __PAIR64__(v469, HIDWORD(v469));
  v398 = (2 * v176) | (HIDWORD(v176) >> 31);
  v450 = __PAIR64__(v179, HIDWORD(v179)) + v449;
  v181 = (v414 + v587) ^ v380;
  v182 = v450 ^ v171;
  LODWORD(v179) = v178 >> 24;
  HIDWORD(v179) = HIBYTE(HIDWORD(v178)) | ((_DWORD)v178 << 8);
  LODWORD(v469) = v181 >> 24;
  LODWORD(v354) = (__int64)(v450 ^ v171) >> 24;
  HIDWORD(v469) = HIBYTE(HIDWORD(v181)) | ((_DWORD)v181 << 8);
  v183 = v651 + v179;
  v184 = (v651 + v179) ^ v426;
  HIDWORD(v354) = HIBYTE(HIDWORD(v182)) | ((_DWORD)v182 << 8);
  v652 = v495 + v469;
  LODWORD(v380) = v184 >> 16;
  HIDWORD(v380) = HIWORD(HIDWORD(v184)) | ((_DWORD)v184 << 16);
  v185 = (v679 + v354) ^ v180;
  LODWORD(v180) = (__int64)((v495 + v469) ^ v414) >> 16;
  HIDWORD(v426) = HIWORD(HIDWORD(v185)) | ((_DWORD)v185 << 16);
  HIDWORD(v180) = ((unsigned int)((v652 ^ v414) >> 32) >> 16) | (((unsigned int)v652 ^ (unsigned int)v414) << 16);
  v186 = v179 ^ (v380 + v555);
  v187 = v180 + v414 + v587;
  v588 = v380 + v555;
  LODWORD(v426) = v185 >> 16;
  v556 = v187;
  LODWORD(v414) = (2 * v186) | (HIDWORD(v186) >> 31);
  v188 = v187 ^ v469;
  HIDWORD(v414) = v186 >> 31;
  v189 = (v426 + v450) ^ v354;
  HIDWORD(v469) = v188 >> 31;
  v190 = v679 + v354 + v799;
  LODWORD(v469) = (2 * v188) | (HIDWORD(v188) >> 31);
  LODWORD(v354) = (2 * v189) | (HIDWORD(v189) >> 31);
  v191 = (v707 + v414) ^ v180;
  v192 = v190 + v469;
  HIDWORD(v354) = v189 >> 31;
  v730 = v707 + v414 + v797;
  v193 = v183 + v796 + v354;
  v525 = __PAIR64__(v191, HIDWORD(v191)) + v426 + v450;
  v708 = v192 + v792;
  v496 = __PAIR64__((unsigned int)v193 ^ (unsigned int)v368, (v193 ^ v368) >> 32);
  v369 = __PAIR64__((unsigned int)v192 ^ (unsigned int)v380, (v192 ^ v380) >> 32);
  v557 = v496 + v556;
  v680 = __PAIR64__((unsigned int)v192 ^ (unsigned int)v380, (v192 ^ v380) >> 32) + v619;
  v194 = v193 + v793;
  LODWORD(v380) = (__int64)(v525 ^ v414) >> 24;
  HIDWORD(v380) = ((unsigned int)((v525 ^ v414) >> 32) >> 24) | (((unsigned int)v525 ^ (unsigned int)v414) << 8);
  LODWORD(v180) = (__int64)(v557 ^ v354) >> 24;
  HIDWORD(v180) = ((unsigned int)((v557 ^ v354) >> 32) >> 24) | (((unsigned int)v557 ^ (unsigned int)v354) << 8);
  LODWORD(v354) = (__int64)(v680 ^ v469) >> 24;
  HIDWORD(v193) = ((unsigned int)((v680 ^ v469) >> 32) >> 24) | (((unsigned int)v680 ^ (unsigned int)v469) << 8);
  v470 = v730 + v380;
  LODWORD(v193) = (v730 + v380) ^ HIDWORD(v191);
  HIDWORD(v354) = HIDWORD(v193);
  HIDWORD(v193) = ((v730 + v380) >> 32) ^ v191;
  v731 = v194 + v180;
  LODWORD(v414) = v193 >> 16;
  v451 = v708 + v354;
  HIDWORD(v414) = HIWORD(HIDWORD(v193)) | ((_DWORD)v193 << 16);
  v195 = (v708 + v354) ^ v369;
  v526 = v414 + v525;
  v370 = __PAIR64__(
           ((unsigned int)(((v194 + v180) ^ v496) >> 32) >> 16)
         | ((((_DWORD)v194 + (_DWORD)v180) ^ (unsigned int)v496) << 16),
           (__int64)((v194 + v180) ^ v496) >> 16);
  LODWORD(v194) = v195 >> 16;
  HIDWORD(v194) = HIWORD(HIDWORD(v195)) | ((_DWORD)v195 << 16);
  v620 = v370 + v557;
  v196 = v526 ^ v380;
  v497 = v194 + v680;
  v197 = (v370 + v557) ^ v180;
  LODWORD(v380) = (2 * (v526 ^ v380)) | ((unsigned int)((v526 ^ v380) >> 32) >> 31);
  v653 = v652 + v798 + v398;
  v198 = (v194 + v680) ^ v354;
  HIDWORD(v380) = v196 >> 31;
  v558 = v653 + v801;
  v355 = __PAIR64__((unsigned int)v653 ^ (unsigned int)v426, (v653 ^ v426) >> 32);
  v654 = v470 + v803;
  v199 = v731 + v797 + v380;
  v200 = v355 + v588;
  v589 = v199 ^ v194;
  v427 = (2 * v197) | (HIDWORD(v197) >> 31);
  LODWORD(v470) = (v200 ^ v398) >> 24;
  HIDWORD(v470) = ((unsigned int)((v200 ^ (unsigned __int64)v398) >> 32) >> 24)
                | (((unsigned int)v200 ^ (unsigned int)v398) << 8);
  v399 = (2 * v198) | (HIDWORD(v198) >> 31);
  v201 = (v558 + v470) ^ v355;
  LODWORD(v194) = v201 >> 16;
  HIDWORD(v194) = HIWORD(HIDWORD(v201)) | ((_DWORD)v201 << 16);
  v202 = v558 + v470 + v793 + v399;
  v203 = (v194 + v200) ^ v470;
  v559 = __PAIR64__(v589, HIDWORD(v589)) + v194 + v200;
  LODWORD(v355) = (2 * v203) | (HIDWORD(v203) >> 31);
  v415 = v202 ^ v414;
  HIDWORD(v355) = v203 >> 31;
  v204 = v202 + v799;
  v205 = (v451 + v802 + v427) ^ v194;
  v709 = v204;
  v758 = v451 + v802 + v427 + v791;
  v206 = v654 + v355;
  v207 = (v654 + v355) ^ v370;
  v655 = v199
       + v804
       + __PAIR64__(
           ((unsigned int)((v559 ^ v380) >> 32) >> 24) | (((unsigned int)v559 ^ (unsigned int)v380) << 8),
           (__int64)(v559 ^ v380) >> 24);
  v208 = __PAIR64__(v207, HIDWORD(v207));
  v209 = __PAIR64__(v589, HIDWORD(v589)) ^ v655;
  v590 = __PAIR64__(v207, HIDWORD(v207)) + v497;
  v471 = __PAIR64__(HIWORD(HIDWORD(v209)) | ((_DWORD)v209 << 16), v209 >> 16);
  v210 = (__PAIR64__(v207, HIDWORD(v207)) + v497) ^ v355;
  v498 = __PAIR64__(v415, HIDWORD(v415));
  v211 = __PAIR64__(v415, HIDWORD(v415));
  v416 = __PAIR64__(v205, HIDWORD(v205));
  v681 = v211 + v620;
  v621 = __PAIR64__(HIWORD(HIDWORD(v209)) | ((_DWORD)v209 << 16), v209 >> 16) + v559;
  v527 = __PAIR64__(v205, HIDWORD(v205)) + v526;
  v212 = __PAIR64__(
           ((unsigned int)((v559 ^ v380) >> 32) >> 24) | (((unsigned int)v559 ^ (unsigned int)v380) << 8),
           (__int64)(v559 ^ v380) >> 24);
  v381 = __PAIR64__(HIBYTE(HIDWORD(v210)) | ((_DWORD)v210 << 8), v210 >> 24);
  LODWORD(v370) = (2 * (v621 ^ v212)) | ((unsigned int)((v621 ^ v212) >> 32) >> 31);
  v213 = v527 ^ v427;
  v214 = (__int64)(v621 ^ v212) >> 31;
  v215 = v206 + v801 + v381;
  v216 = v208 ^ v215;
  HIDWORD(v355) = ((unsigned int)((v681 ^ v399) >> 32) >> 24) | (((unsigned int)v681 ^ (unsigned int)v399) << 8);
  LODWORD(v355) = (__int64)(v681 ^ v399) >> 24;
  LODWORD(v427) = (__int64)(v527 ^ v427) >> 24;
  LODWORD(v399) = v216 >> 16;
  HIDWORD(v427) = HIBYTE(HIDWORD(v213)) | ((_DWORD)v213 << 8);
  HIDWORD(v399) = HIWORD(HIDWORD(v216)) | ((_DWORD)v216 << 16);
  v217 = v215 + v795;
  v218 = (v709 + v355) ^ v498;
  HIDWORD(v370) = v214;
  v710 = v709 + v355;
  v732 = v217 + v370;
  v499 = v399 + v590;
  v219 = (v399 + v590) ^ v381;
  LODWORD(v205) = v218 >> 16;
  v220 = (v758 + v427) ^ v416;
  HIDWORD(v205) = HIWORD(HIDWORD(v218)) | ((_DWORD)v218 << 16);
  LODWORD(v416) = (2 * v219) | (HIDWORD(v219) >> 31);
  v382 = __PAIR64__(HIWORD(HIDWORD(v220)) | ((_DWORD)v220 << 16), v220 >> 16);
  HIDWORD(v416) = v219 >> 31;
  v221 = __PAIR64__(HIWORD(HIDWORD(v220)) | ((_DWORD)v220 << 16), v220 >> 16) + v527;
  v222 = (v217 + v370) ^ v205;
  v591 = v205 + v681;
  v223 = __PAIR64__(v222, HIDWORD(v222)) + v221;
  v224 = __PAIR64__(v222, HIDWORD(v222));
  v225 = v221 ^ v427;
  v528 = v223;
  LODWORD(v223) = v223 ^ v370;
  LODWORD(v451) = (2 * (v591 ^ v355)) | ((unsigned int)((v591 ^ v355) >> 32) >> 31);
  HIDWORD(v451) = (__int64)(v591 ^ v355) >> 31;
  v356 = __PAIR64__((v710 + v792 + v416) ^ v382, ((v710 + v792 + v416) ^ v382) >> 32);
  v226 = v710 + v792 + v416;
  HIDWORD(v223) = (unsigned int)((v528 ^ v370) >> 32) >> 24;
  LODWORD(v370) = (__int64)(v528 ^ v370) >> 24;
  v711 = v758 + v427 + v798 + v451;
  v560 = v226 + v800;
  v622 = v356 + v621;
  HIDWORD(v370) = HIDWORD(v223) | ((_DWORD)v223 << 8);
  HIDWORD(v382) = v225 >> 31;
  v227 = v711 ^ v471;
  LODWORD(v382) = (2 * v225) | (HIDWORD(v225) >> 31);
  v472 = v732 + v790 + v370;
  v733 = __PAIR64__(v227, HIDWORD(v227));
  LODWORD(v217) = (__int64)(v622 ^ v416) >> 24;
  HIDWORD(v217) = ((unsigned int)((v622 ^ v416) >> 32) >> 24) | (((unsigned int)v622 ^ (unsigned int)v416) << 8);
  v656 = v655 + v805 + v382;
  HIDWORD(v427) = ((unsigned int)((v472 ^ v224) >> 32) >> 16) | (((unsigned int)v472 ^ (unsigned int)v224) << 16);
  v561 = v560 + v217;
  LODWORD(v427) = (__int64)(v472 ^ v224) >> 16;
  LODWORD(v225) = v561 ^ v356;
  v417 = __PAIR64__((unsigned int)v656 ^ (unsigned int)v399, (v656 ^ v399) >> 32);
  v529 = v427 + v528;
  v682 = v656 + v794;
  v592 = __PAIR64__((unsigned int)v656 ^ (unsigned int)v399, (v656 ^ v399) >> 32) + v591;
  v500 = __PAIR64__(v227, HIDWORD(v227)) + v499;
  LODWORD(v218) = v592 ^ v382;
  LODWORD(v399) = (2 * (v529 ^ v370)) | ((unsigned int)((v529 ^ v370) >> 32) >> 31);
  v228 = v500 ^ v451;
  HIDWORD(v225) = (unsigned int)((v561 ^ v356) >> 32) >> 16;
  LODWORD(v356) = (__int64)(v561 ^ v356) >> 16;
  HIDWORD(v356) = HIDWORD(v225) | ((_DWORD)v225 << 16);
  HIDWORD(v399) = (__int64)(v529 ^ v370) >> 31;
  v657 = v356 + v622;
  LODWORD(v382) = (__int64)(v592 ^ v382) >> 24;
  v452 = v472 + v796;
  v229 = (v356 + v622) ^ v217;
  HIDWORD(v382) = ((unsigned int)(HIDWORD(v592) ^ HIDWORD(v382)) >> 24) | ((_DWORD)v218 << 8);
  LODWORD(v370) = v228 >> 24;
  HIDWORD(v370) = HIBYTE(HIDWORD(v228)) | ((_DWORD)v228 << 8);
  v623 = v711 + v796 + v370;
  v230 = (v682 + v382) ^ v417;
  v231 = v682 + v382 + v804 + v399;
  LODWORD(v217) = v230 >> 16;
  HIDWORD(v472) = v229 >> 31;
  LODWORD(v472) = (2 * v229) | (HIDWORD(v229) >> 31);
  v683 = v231 + v799;
  HIDWORD(v217) = HIWORD(HIDWORD(v230)) | ((_DWORD)v230 << 16);
  v232 = v452 + ((2 * v229) | (HIDWORD(v229) >> 31));
  HIDWORD(v229) = ((unsigned int)(HIDWORD(v623) ^ HIDWORD(v733)) >> 16)
                | (((unsigned int)v623 ^ (unsigned int)v733) << 16);
  v712 = v452 + v472 + v805;
  v233 = (__int64)(v623 ^ v733) >> 16;
  v234 = __PAIR64__(HIDWORD(v229), v233) + v500;
  v453 = __PAIR64__(v233 ^ (unsigned int)v231, HIDWORD(v229) ^ HIDWORD(v231));
  v501 = v217 + v592;
  v658 = __PAIR64__(v233 ^ (unsigned int)v231, HIDWORD(v229) ^ HIDWORD(v231)) + v657;
  v235 = v234 ^ v370;
  v236 = __PAIR64__((unsigned int)v217 ^ (unsigned int)v232, (v217 ^ v232) >> 32);
  LODWORD(v417) = (2 * (v501 ^ v382)) | ((unsigned int)((v501 ^ v382) >> 32) >> 31);
  v237 = v658 ^ v399;
  v593 = v236 + v234;
  HIDWORD(v417) = (__int64)(v501 ^ v382) >> 31;
  LODWORD(v399) = (2 * (v234 ^ v370)) | ((unsigned int)((v234 ^ v370) >> 32) >> 31);
  v238 = (v236 + v234) ^ v472;
  LODWORD(v217) = v237 >> 24;
  HIDWORD(v382) = HIBYTE(HIDWORD(v238)) | ((_DWORD)v238 << 8);
  LODWORD(v382) = v238 >> 24;
  HIDWORD(v217) = HIBYTE(HIDWORD(v237)) | ((_DWORD)v237 << 8);
  v684 = v683 + v217;
  HIDWORD(v399) = v235 >> 31;
  v239 = v236 ^ (v712 + v382);
  HIDWORD(v472) = ((unsigned int)((v684 ^ v453) >> 32) >> 16) | (((unsigned int)v684 ^ (unsigned int)v453) << 16);
  LODWORD(v472) = (__int64)(v684 ^ v453) >> 16;
  LODWORD(v370) = v239 >> 16;
  HIDWORD(v370) = HIWORD(HIDWORD(v239)) | ((_DWORD)v239 << 16);
  v659 = v472 + v658;
  v594 = v370 + v593;
  HIDWORD(v453) = (__int64)(v659 ^ v217) >> 31;
  v240 = v623 + v801 + v417;
  v241 = v561 + v790 + v399;
  LODWORD(v453) = (2 * (v659 ^ v217)) | ((unsigned int)((v659 ^ v217) >> 32) >> 31);
  v624 = v240 + v793;
  v562 = v241 + v798;
  v428 = __PAIR64__((unsigned int)v241 ^ (unsigned int)v427, (v241 ^ (unsigned __int64)v427) >> 32);
  v242 = __PAIR64__((unsigned int)v240 ^ (unsigned int)v356, (v240 ^ v356) >> 32);
  v502 = v428 + v501;
  v357 = __PAIR64__((unsigned int)v240 ^ (unsigned int)v356, (v240 ^ v356) >> 32) + v529;
  v243 = v399;
  v400 = (2 * (v594 ^ v382)) | ((unsigned int)((v594 ^ v382) >> 32) >> 31);
  v530 = v712 + v382 + v802 + v453;
  LODWORD(v382) = (v502 ^ v243) >> 24;
  LODWORD(v237) = (__int64)(v357 ^ v417) >> 24;
  HIDWORD(v382) = ((unsigned int)((v502 ^ (unsigned __int64)v243) >> 32) >> 24)
                | (((unsigned int)v502 ^ (unsigned int)v243) << 8);
  HIDWORD(v237) = ((unsigned int)((v357 ^ v417) >> 32) >> 24) | (((unsigned int)v357 ^ (unsigned int)v417) << 8);
  v244 = (v241 + v798 + v382) ^ v428;
  v245 = (v624 + v237) ^ v242;
  v625 = v624 + v237 + v791;
  LODWORD(v243) = v244 >> 16;
  HIDWORD(v243) = HIWORD(HIDWORD(v244)) | ((_DWORD)v244 << 16);
  LODWORD(v242) = v245 >> 16;
  HIDWORD(v242) = HIWORD(HIDWORD(v245)) | ((_DWORD)v245 << 16);
  v503 = v243 + v502;
  v358 = v242 + v357;
  v759 = v562 + v382 + v800 + v400;
  LODWORD(v417) = (2 * (v503 ^ v382)) | ((unsigned int)((v503 ^ v382) >> 32) >> 31);
  HIDWORD(v417) = (__int64)(v503 ^ v382) >> 31;
  v783 = v759 ^ v242;
  v429 = __PAIR64__((unsigned int)v243 ^ (unsigned int)v530, (v243 ^ v530) >> 32);
  v563 = v530 + v792;
  v383 = (2 * (v358 ^ v237)) | ((unsigned int)((v358 ^ v237) >> 32) >> 31);
  v531 = __PAIR64__((unsigned int)v243 ^ (unsigned int)v530, (v243 ^ v530) >> 32) + v358;
  v734 = v684 + v803 + v383;
  v246 = (v429 + v358) ^ v453;
  v359 = __PAIR64__((unsigned int)v734 ^ (unsigned int)v370, (v734 ^ v370) >> 32);
  LODWORD(v242) = v246 >> 24;
  v473 = __PAIR64__((v625 + v417) ^ v472, ((v625 + v417) ^ v472) >> 32);
  HIDWORD(v242) = HIBYTE(HIDWORD(v246)) | ((_DWORD)v246 << 8);
  v713 = v625 + v417 + v794;
  v626 = __PAIR64__((unsigned int)v734 ^ (unsigned int)v370, (v734 ^ v370) >> 32) + v503;
  v685 = v473 + v594;
  v247 = (__PAIR64__((unsigned int)v734 ^ (unsigned int)v370, (v734 ^ v370) >> 32) + v503) ^ v383;
  v248 = (v473 + v594) ^ v417;
  v595 = v563 + v242;
  LODWORD(v453) = v248 >> 24;
  LODWORD(v370) = v247 >> 24;
  HIDWORD(v453) = HIBYTE(HIDWORD(v248)) | ((_DWORD)v248 << 8);
  v249 = (v563 + v242) ^ v429;
  LODWORD(v383) = v249 >> 16;
  HIDWORD(v370) = HIBYTE(HIDWORD(v247)) | ((_DWORD)v247 << 8);
  HIDWORD(v383) = HIWORD(HIDWORD(v249)) | ((_DWORD)v249 << 16);
  v564 = v734 + v797 + v370;
  v504 = __PAIR64__(v783, HIDWORD(v783));
  v714 = v713 + v453;
  v784 = __PAIR64__(v783, HIDWORD(v783)) + v659;
  v532 = v383 + v531;
  LODWORD(v429) = (__int64)(v564 ^ v359) >> 16;
  LODWORD(v217) = (__int64)(v714 ^ v473) >> 16;
  LODWORD(v417) = (2 * (v532 ^ v242)) | ((unsigned int)((v532 ^ v242) >> 32) >> 31);
  HIDWORD(v417) = (__int64)(v532 ^ v242) >> 31;
  HIDWORD(v429) = ((unsigned int)(HIDWORD(v564) ^ HIDWORD(v359)) >> 16)
                | (((unsigned int)v564 ^ (unsigned int)v359) << 16);
  HIDWORD(v217) = ((unsigned int)((v714 ^ v473) >> 32) >> 16) | (((unsigned int)v714 ^ (unsigned int)v473) << 16);
  v627 = v429 + v626;
  LODWORD(v473) = (__int64)(v784 ^ v400) >> 24;
  HIDWORD(v473) = ((unsigned int)((v784 ^ v400) >> 32) >> 24) | (((unsigned int)v784 ^ (unsigned int)v400) << 8);
  v660 = v217 + v685;
  v250 = (v217 + v685) ^ v453;
  v251 = v759 + v795 + v473;
  v252 = v627 ^ v370;
  HIDWORD(v359) = v250 >> 31;
  v253 = (2 * (v627 ^ v370)) | ((unsigned int)((v627 ^ v370) >> 32) >> 31);
  v254 = v251 ^ v504;
  LODWORD(v359) = (2 * v250) | (HIDWORD(v250) >> 31);
  v255 = (v564 + v798 + v417) ^ v217;
  LODWORD(v370) = (__int64)(v251 ^ v504) >> 16;
  v505 = __PAIR64__(v255, HIDWORD(v255));
  HIDWORD(v370) = HIWORD(HIDWORD(v254)) | ((_DWORD)v254 << 16);
  HIDWORD(v400) = v252 >> 31;
  LODWORD(v400) = v253;
  v686 = __PAIR64__(v255, HIDWORD(v255)) + v370 + v784;
  v454 = (2 * ((v370 + v784) ^ v473)) | ((unsigned int)(((v370 + v784) ^ v473) >> 32) >> 31);
  v735 = v251 + v791 + v359;
  v715 = v714 + v797 + v400;
  v596 = v595 + v800 + v454;
  LODWORD(v255) = (__int64)(v686 ^ v417) >> 24;
  v384 = v735 ^ v383;
  HIDWORD(v255) = ((unsigned int)((v686 ^ v417) >> 32) >> 24) | (((unsigned int)v686 ^ (unsigned int)v417) << 8);
  v256 = v596 ^ v429;
  v565 = v564 + v798 + v417 + v794 + v255;
  v785 = v735 + v795;
  v430 = __PAIR64__((unsigned int)v715 ^ (unsigned int)v370, (v715 ^ v370) >> 32);
  v760 = v715 + v796;
  HIDWORD(v473) = v384;
  LODWORD(v384) = HIDWORD(v256);
  HIDWORD(v417) = ((unsigned int)((v565 ^ v505) >> 32) >> 16) | (((unsigned int)v565 ^ (unsigned int)v505) << 16);
  HIDWORD(v251) = HIDWORD(v384);
  v736 = v596 + v792;
  HIDWORD(v384) = v256;
  LODWORD(v473) = HIDWORD(v251);
  LODWORD(v417) = (__int64)(v565 ^ v505) >> 16;
  v597 = v417 + v686;
  v257 = (v473 + v627) ^ v359;
  v533 = __PAIR64__((unsigned int)v715 ^ (unsigned int)v370, (v715 ^ v370) >> 32) + v532;
  v258 = (v384 + v660) ^ v454;
  LODWORD(v454) = v257 >> 24;
  v259 = v255 ^ (v417 + v686);
  LODWORD(v370) = (2 * v259) | (HIDWORD(v259) >> 31);
  HIDWORD(v370) = v259 >> 31;
  LODWORD(v251) = v258 >> 24;
  HIDWORD(v251) = HIBYTE(HIDWORD(v258)) | ((_DWORD)v258 << 8);
  HIDWORD(v454) = HIBYTE(HIDWORD(v257)) | ((_DWORD)v257 << 8);
  LODWORD(v359) = (v533 ^ v400) >> 24;
  HIDWORD(v359) = ((unsigned int)((v533 ^ (unsigned __int64)v400) >> 32) >> 24) | (((unsigned int)v533 ^ v253) << 8);
  v260 = (v785 + v454) ^ v473;
  v401 = __PAIR64__(
           ((unsigned int)(((v736 + v251) ^ v384) >> 32) >> 16)
         | ((((_DWORD)v736 + (_DWORD)v251) ^ (unsigned int)v384) << 16),
           (__int64)((v736 + v251) ^ v384) >> 16);
  v261 = (v715 + v796 + v359) ^ v430;
  LODWORD(v254) = v260 >> 16;
  HIDWORD(v254) = HIWORD(HIDWORD(v260)) | ((_DWORD)v260 << 16);
  LODWORD(v430) = v261 >> 16;
  HIDWORD(v430) = HIWORD(HIDWORD(v261)) | ((_DWORD)v261 << 16);
  v506 = __PAIR64__(
           ((unsigned int)(((v736 + v251) ^ v384) >> 32) >> 16)
         | ((((_DWORD)v736 + (_DWORD)v251) ^ (unsigned int)v384) << 16),
           (__int64)((v736 + v251) ^ v384) >> 16)
       + v384
       + v660;
  v687 = v254 + v473 + v627;
  v262 = (v736 + v251 + v805 + v370) ^ v254;
  LODWORD(v384) = (2 * (v506 ^ v251)) | ((unsigned int)((v506 ^ v251) >> 32) >> 31);
  v263 = v430 + v533;
  v534 = __PAIR64__(v262, HIDWORD(v262)) + v430 + v533;
  v264 = __PAIR64__(v262, HIDWORD(v262));
  HIDWORD(v384) = (__int64)(v506 ^ v251) >> 31;
  v265 = v263 ^ v359;
  LODWORD(v262) = (__int64)(v534 ^ v370) >> 24;
  HIDWORD(v262) = ((unsigned int)((v534 ^ v370) >> 32) >> 24) | (((unsigned int)v534 ^ (unsigned int)v370) << 8);
  v266 = v736 + v251 + v805 + v370 + v801;
  LODWORD(v370) = (2 * (v687 ^ v454)) | ((unsigned int)((v687 ^ v454) >> 32) >> 31);
  v716 = v266 + v262;
  LODWORD(v473) = (__int64)((v266 + v262) ^ v264) >> 16;
  HIDWORD(v473) = ((unsigned int)((v716 ^ v264) >> 32) >> 16) | (((unsigned int)v716 ^ (unsigned int)v264) << 16);
  HIDWORD(v370) = (__int64)(v687 ^ v454) >> 31;
  v535 = v473 + v534;
  v267 = v785 + v454;
  v455 = v565 + v799;
  v268 = v262 ^ v535;
  v269 = v267 + v803 + v384;
  v270 = v760 + v359 + v793 + v370;
  v628 = v269 + v790;
  LODWORD(v359) = (2 * v268) | (HIDWORD(v268) >> 31);
  v271 = v269 ^ v430;
  v418 = v270 ^ v417;
  v566 = v270 + v802;
  v431 = __PAIR64__(v271, HIDWORD(v271));
  HIDWORD(v359) = v268 >> 31;
  v272 = (__PAIR64__(v271, HIDWORD(v271)) + v597) ^ v384;
  LODWORD(v270) = (2 * v265) | (HIDWORD(v265) >> 31);
  v598 = __PAIR64__(v271, HIDWORD(v271)) + v597;
  LODWORD(v264) = v272 >> 24;
  HIDWORD(v270) = v265 >> 31;
  HIDWORD(v264) = HIBYTE(HIDWORD(v272)) | ((_DWORD)v272 << 8);
  v737 = v455 + v270 + v804;
  v661 = v628 + v264;
  LODWORD(v271) = ((v455 + v270) ^ v401) >> 32;
  HIDWORD(v271) = (v455 + v270) ^ v401;
  v456 = v271 + v687;
  v273 = (v628 + v264) ^ v431;
  v385 = __PAIR64__(v418, HIDWORD(v418));
  v274 = v270 ^ (v271 + v687);
  v629 = __PAIR64__(v418, HIDWORD(v418)) + v506;
  LODWORD(v401) = v274 >> 24;
  HIDWORD(v401) = HIBYTE(HIDWORD(v274)) | ((_DWORD)v274 << 8);
  v275 = (__PAIR64__(v418, HIDWORD(v418)) + v506) ^ v370;
  HIDWORD(v431) = HIWORD(HIDWORD(v273)) | ((_DWORD)v273 << 16);
  LODWORD(v431) = v273 >> 16;
  LODWORD(v418) = v275 >> 24;
  HIDWORD(v273) = HIBYTE(HIDWORD(v275)) | ((_DWORD)v275 << 8);
  v276 = (v737 + v401) ^ v271;
  v688 = v431 + v598;
  HIDWORD(v418) = HIDWORD(v273);
  v567 = v566 + v418;
  v371 = (2 * ((v431 + v598) ^ v264)) | ((unsigned int)(((v431 + v598) ^ v264) >> 32) >> 31);
  v277 = v737 + v401 + v792 + v359;
  HIDWORD(v264) = HIWORD(HIDWORD(v276)) | ((_DWORD)v276 << 16);
  v278 = v716 + v790 + v371;
  HIDWORD(v271) = ((unsigned int)(HIDWORD(v567) ^ HIDWORD(v385)) >> 16)
                | (((unsigned int)v567 ^ (unsigned int)v385) << 16);
  v279 = v276 >> 16;
  v599 = __PAIR64__(HIDWORD(v264), v279) + v456;
  v280 = (__int64)(v567 ^ v385) >> 16;
  v689 = __PAIR64__(v280 ^ (unsigned int)v277, HIDWORD(v271) ^ HIDWORD(v277)) + v688;
  v457 = __PAIR64__(v279 ^ (unsigned int)v278, HIDWORD(v264) ^ HIDWORD(v278));
  HIDWORD(v385) = (__int64)(v599 ^ v401) >> 31;
  v281 = (__PAIR64__(HIDWORD(v271), v280) + v629) ^ v418;
  v630 = __PAIR64__(v279 ^ (unsigned int)v278, HIDWORD(v264) ^ HIDWORD(v278)) + __PAIR64__(HIDWORD(v271), v280) + v629;
  LODWORD(v385) = (2 * (v599 ^ v401)) | ((unsigned int)((v599 ^ v401) >> 32) >> 31);
  LODWORD(v418) = (__int64)(v630 ^ v371) >> 24;
  v717 = v567 + v794 + v385;
  LODWORD(v264) = (__int64)(v689 ^ v359) >> 24;
  HIDWORD(v264) = ((unsigned int)((v689 ^ v359) >> 32) >> 24) | (((unsigned int)v689 ^ (unsigned int)v359) << 8);
  HIDWORD(v418) = ((unsigned int)((v630 ^ v371) >> 32) >> 24) | (((unsigned int)v630 ^ (unsigned int)v371) << 8);
  v568 = v277 + v793 + v264;
  LODWORD(v401) = (2 * v281) | (HIDWORD(v281) >> 31);
  HIDWORD(v401) = v281 >> 31;
  v282 = v278 + v791 + v418;
  v283 = v568 ^ __PAIR64__(v280 ^ (unsigned int)v277, HIDWORD(v271) ^ HIDWORD(v277));
  v284 = v717 ^ v431;
  LODWORD(v431) = v283 >> 16;
  HIDWORD(v431) = HIWORD(HIDWORD(v283)) | ((_DWORD)v283 << 16);
  v285 = v282 ^ v457;
  v690 = v431 + v689;
  HIDWORD(v283) = ((unsigned int)v282 ^ (unsigned int)v457) >> 16;
  v458 = __PAIR64__(v284, HIDWORD(v284));
  LODWORD(v371) = HIDWORD(v283) | (HIDWORD(v285) << 16);
  HIDWORD(v371) = HIWORD(HIDWORD(v285)) | ((_DWORD)v285 << 16);
  v536 = __PAIR64__(v284, HIDWORD(v284)) + v535;
  v507 = v371 + v630;
  HIDWORD(v359) = (__int64)(v690 ^ v264) >> 31;
  v738 = v717 + v795;
  LODWORD(v359) = (2 * (v690 ^ v264)) | ((unsigned int)((v690 ^ v264) >> 32) >> 31);
  v286 = v661 + v796 + v401;
  v287 = (v371 + v630) ^ v418;
  v662 = v286 + v797;
  v288 = v286 ^ v473;
  v289 = __PAIR64__(v288, HIDWORD(v288));
  v631 = v282 + v798 + v359;
  v761 = v568 + v800;
  v718 = v631 + v799;
  v600 = __PAIR64__(v288, HIDWORD(v288)) + v599;
  LODWORD(v282) = (2 * v287) | (HIDWORD(v287) >> 31);
  HIDWORD(v282) = v287 >> 31;
  v290 = (__int64)(v536 ^ v385) >> 24;
  HIDWORD(v385) = ((unsigned int)((v536 ^ v385) >> 32) >> 24) | (((unsigned int)v536 ^ (unsigned int)v385) << 8);
  LODWORD(v385) = v290;
  LODWORD(v418) = (__int64)(v600 ^ v401) >> 24;
  HIDWORD(v418) = ((unsigned int)((v600 ^ v401) >> 32) >> 24) | (((unsigned int)v600 ^ (unsigned int)v401) << 8);
  v291 = (v738 + v385) ^ v458;
  v292 = (v662 + v418) ^ v289;
  v402 = v662 + v418 + v804;
  LODWORD(v264) = v291 >> 16;
  HIDWORD(v264) = HIWORD(HIDWORD(v291)) | ((_DWORD)v291 << 16);
  LODWORD(v285) = v292 >> 16;
  HIDWORD(v285) = HIWORD(HIDWORD(v292)) | ((_DWORD)v292 << 16);
  v474 = v264 + v536;
  v569 = (v402 + v282) ^ v264;
  v459 = v285 + v600;
  v786 = v402 + v282 + v805;
  v403 = (2 * ((v264 + v536) ^ v385)) | ((unsigned int)(((v264 + v536) ^ v385) >> 32) >> 31);
  LODWORD(v289) = (2 * (v459 ^ v418)) | ((unsigned int)((v459 ^ v418) >> 32) >> 31);
  HIDWORD(v289) = (__int64)((v285 + v600) ^ v418) >> 31;
  v293 = v738 + v385 + v802;
  v294 = __PAIR64__((unsigned int)v285 ^ (unsigned int)v631, (v285 ^ v631) >> 32);
  v632 = v761 + v403 + v801;
  v475 = v294 + v474;
  v295 = (v293 + v289) ^ v431;
  v432 = __PAIR64__(v295, HIDWORD(v295));
  v663 = v293 + v289 + v803;
  v372 = __PAIR64__((v761 + v403) ^ v371, ((v761 + v403) ^ (unsigned __int64)v371) >> 32);
  HIDWORD(v385) = ((unsigned int)((v475 ^ v359) >> 32) >> 24) | (((unsigned int)v475 ^ (unsigned int)v359) << 8);
  LODWORD(v385) = (__int64)(v475 ^ v359) >> 24;
  v601 = v372 + v459;
  v537 = __PAIR64__(v295, HIDWORD(v295)) + v507;
  v360 = __PAIR64__(v569, HIDWORD(v569));
  v296 = v372 + v459;
  v460 = v718 + v385;
  v297 = v296 ^ v403;
  v570 = __PAIR64__(v569, HIDWORD(v569)) + v690;
  v298 = v570 ^ v282;
  v299 = v537 ^ v289;
  v300 = (v718 + v385) ^ v294;
  LODWORD(v403) = v300 >> 16;
  HIDWORD(v403) = HIWORD(HIDWORD(v300)) | ((_DWORD)v300 << 16);
  LODWORD(v294) = v297 >> 24;
  LODWORD(v282) = v299 >> 24;
  LODWORD(v718) = v298 >> 24;
  v476 = v403 + v475;
  HIDWORD(v294) = HIBYTE(HIDWORD(v297)) | ((_DWORD)v297 << 8);
  HIDWORD(v282) = HIBYTE(HIDWORD(v299)) | ((_DWORD)v299 << 8);
  HIDWORD(v718) = HIBYTE(HIDWORD(v298)) | ((_DWORD)v298 << 8);
  v508 = v632 + v294;
  v633 = v663 + v282;
  LODWORD(v418) = (2 * (v476 ^ v385)) | ((unsigned int)((v476 ^ v385) >> 32) >> 31);
  HIDWORD(v418) = (__int64)(v476 ^ v385) >> 31;
  v301 = (v663 + v282) ^ v432;
  LODWORD(v385) = (__int64)(v508 ^ v372) >> 16;
  v302 = (v786 + v718) ^ v360;
  HIDWORD(v385) = ((unsigned int)((v508 ^ v372) >> 32) >> 16) | (((unsigned int)v508 ^ (unsigned int)v372) << 16);
  LODWORD(v372) = v301 >> 16;
  HIDWORD(v372) = HIWORD(HIDWORD(v301)) | ((_DWORD)v301 << 16);
  LODWORD(v360) = v302 >> 16;
  v602 = v385 + v601;
  HIDWORD(v360) = HIWORD(HIDWORD(v302)) | ((_DWORD)v302 << 16);
  v538 = v372 + v537;
  v303 = v538 ^ v282;
  v304 = v508 + v794 + v418;
  LODWORD(v432) = (2 * v303) | (HIDWORD(v303) >> 31);
  HIDWORD(v432) = v303 >> 31;
  v742 = __PAIR64__((unsigned int)v304 ^ (unsigned int)v372, (v304 ^ v372) >> 32);
  HIDWORD(v768) = (__int64)(v602 ^ v294) >> 31;
  LODWORD(v768) = (2 * (v602 ^ v294)) | ((unsigned int)((v602 ^ v294) >> 32) >> 31);
  LODWORD(v738) = (2 * ((v360 + v570) ^ v718)) | ((unsigned int)(((v360 + v570) ^ v718) >> 32) >> 31);
  v373 = __PAIR64__((unsigned int)v304 ^ (unsigned int)v372, (v304 ^ v372) >> 32) + v360 + v570;
  HIDWORD(v738) = (__int64)((v360 + v570) ^ v718) >> 31;
  v305 = v403;
  v404 = v460 + v804 + v738;
  v306 = (v786 + v718 + v803 + v432) ^ v305;
  v307 = (v633 + v799 + v768) ^ v360;
  LODWORD(v300) = (__int64)(v373 ^ v418) >> 24;
  HIDWORD(v300) = ((unsigned int)((v373 ^ v418) >> 32) >> 24) | (((unsigned int)v373 ^ (unsigned int)v418) << 8);
  v308 = v404 ^ v385;
  v386 = v304 + v798 + v300;
  v770 = __PAIR64__(v306, HIDWORD(v306));
  v509 = v786 + v718 + v803 + v432 + v796;
  v772 = __PAIR64__(v308, HIDWORD(v308));
  v765 = __PAIR64__(
           ((unsigned int)((v386 ^ v742) >> 32) >> 16) | (((unsigned int)v386 ^ (unsigned int)v742) << 16),
           (__int64)(v386 ^ v742) >> 16);
  v571 = __PAIR64__(v307, HIDWORD(v307));
  v309 = (__PAIR64__(v306, HIDWORD(v306)) + v602) ^ v432;
  v310 = (v772 + v538) ^ v738;
  v433 = __PAIR64__(v307, HIDWORD(v307)) + v476;
  v419 = __PAIR64__(
           ((unsigned int)((v386 ^ v742) >> 32) >> 16) | (((unsigned int)v386 ^ (unsigned int)v742) << 16),
           (__int64)(v386 ^ v742) >> 16)
       + v373;
  v311 = (__PAIR64__(v307, HIDWORD(v307)) + v476) ^ v768;
  v312 = v300
       ^ (__PAIR64__(
            ((unsigned int)((v386 ^ v742) >> 32) >> 16) | (((unsigned int)v386 ^ (unsigned int)v742) << 16),
            (__int64)(v386 ^ v742) >> 16)
        + v373);
  LODWORD(v738) = (2 * v312) | (HIDWORD(v312) >> 31);
  v477 = v386 + v790;
  HIDWORD(v738) = v312 >> 31;
  LODWORD(v745) = v310 >> 24;
  HIDWORD(v745) = HIBYTE(HIDWORD(v310)) | ((_DWORD)v310 << 8);
  LODWORD(v747) = v311 >> 24;
  v313 = v404 + v800 + v745;
  HIDWORD(v747) = HIBYTE(HIDWORD(v311)) | ((_DWORD)v311 << 8);
  v314 = v313 + v791;
  v315 = v313 ^ v772;
  v387 = v509 + __PAIR64__(HIBYTE(HIDWORD(v309)) | ((_DWORD)v309 << 8), v309 >> 24);
  v405 = v633 + v799 + v768 + v805 + v747;
  v316 = (v509 + __PAIR64__(HIBYTE(HIDWORD(v309)) | ((_DWORD)v309 << 8), v309 >> 24)) ^ v770;
  v317 = v314 + v738;
  LODWORD(v763) = v315 >> 16;
  HIDWORD(v763) = HIWORD(HIDWORD(v315)) | ((_DWORD)v315 << 16);
  v374 = v317 + v802;
  LODWORD(v311) = v316 >> 16;
  v318 = v772 + v538;
  HIDWORD(v311) = HIWORD(HIDWORD(v316)) | ((_DWORD)v316 << 16);
  LODWORD(v772) = (__int64)(v405 ^ v571) >> 16;
  HIDWORD(v772) = ((unsigned int)((v405 ^ v571) >> 32) >> 16) | (((unsigned int)v405 ^ (unsigned int)v571) << 16);
  v319 = v317 ^ v311;
  v320 = v311 + v770 + v602;
  v771 = v763 + v318;
  v767 = v320;
  v321 = (v763 + v318) ^ v745;
  v322 = v320 ^ __PAIR64__(HIBYTE(HIDWORD(v309)) | ((_DWORD)v309 << 8), v309 >> 24);
  v743 = __PAIR64__(v319, HIDWORD(v319)) + v772 + v433;
  LODWORD(v768) = (2 * v321) | (HIDWORD(v321) >> 31);
  v323 = (v772 + v433) ^ v747;
  HIDWORD(v768) = v321 >> 31;
  v324 = (2 * v322) | (HIDWORD(v322) >> 31);
  LODWORD(v745) = (2 * v323) | (HIDWORD(v323) >> 31);
  LODWORD(v762) = (__int64)(v743 ^ v738) >> 24;
  HIDWORD(v762) = ((unsigned int)((v743 ^ v738) >> 32) >> 24) | (((unsigned int)v743 ^ (unsigned int)v738) << 8);
  HIDWORD(v322) = v322 >> 31;
  HIDWORD(v745) = v323 >> 31;
  LODWORD(v322) = (v374 + v762) ^ HIDWORD(v319);
  HIDWORD(v738) = HIDWORD(v322);
  HIDWORD(v322) = ((unsigned __int64)(v374 + v762) >> 32) ^ v319;
  LODWORD(v738) = v324;
  v806 = v374 + v762;
  LODWORD(v323) = v322 >> 16;
  HIDWORD(v323) = HIWORD(HIDWORD(v322)) | ((_DWORD)v322 << 16);
  v748 = __PAIR64__((v477 + v745) ^ v763, ((v477 + v745) ^ v763) >> 32);
  v325 = v323 + v743;
  v814[7] = v323;
  v744 = __PAIR64__((v477 + v745) ^ v763, ((v477 + v745) ^ v763) >> 32) + v767;
  v388 = v387 + v795;
  v775 = v325 ^ v762;
  result = 8;
  v814[2] = v325;
  v327 = v405 + v801 + v738;
  v776 = (v388 + v768) ^ v772;
  LODWORD(v325) = (__int64)((__PAIR64__((v477 + v745) ^ v763, ((v477 + v745) ^ v763) >> 32) + v767) ^ v745) >> 24;
  HIDWORD(v325) = ((unsigned int)((v744 ^ v745) >> 32) >> 24) | (((unsigned int)v744 ^ (unsigned int)v745) << 8);
  HIDWORD(v763) = v327 ^ v765;
  v328 = __PAIR64__(v776, HIDWORD(v776));
  LODWORD(v763) = (v327 ^ v765) >> 32;
  v766 = v763 + v771;
  v774 = __PAIR64__(v776, HIDWORD(v776)) + v419;
  v807 = v477 + v745 + v792 + v325;
  v329 = (v763 + v771) ^ v738;
  v330 = __PAIR64__(v776, HIDWORD(v776)) + v419;
  LODWORD(v776) = v329 >> 24;
  v331 = v330 ^ v768;
  LODWORD(v787) = v331 >> 24;
  HIDWORD(v787) = HIBYTE(HIDWORD(v331)) | ((_DWORD)v331 << 8);
  HIDWORD(v776) = HIBYTE(HIDWORD(v329)) | ((_DWORD)v329 << 8);
  v808 = v327 + v797 + v776;
  v809 = v388 + v768 + v793 + v787;
  v746 = __PAIR64__(
           ((unsigned int)((v807 ^ v748) >> 32) >> 16)
         | ((((_DWORD)v477 + (_DWORD)v745 + (_DWORD)v792 + (_DWORD)v325) ^ (unsigned int)v748) << 16),
           (__int64)(v807 ^ v748) >> 16);
  v332 = v809 ^ v328;
  v814[3] = v746 + v744;
  LODWORD(v768) = (__int64)(v809 ^ v328) >> 16;
  v764 = __PAIR64__(
           ((unsigned int)((v808 ^ v763) >> 32) >> 16) | (((unsigned int)v808 ^ (unsigned int)v763) << 16),
           (__int64)(v808 ^ v763) >> 16);
  v333 = (v746 + v744) ^ v325;
  HIDWORD(v768) = HIWORD(HIDWORD(v332)) | ((_DWORD)v332 << 16);
  v334 = v764 + v766;
  LODWORD(v811) = (2 * v775) | (HIDWORD(v775) >> 31);
  v814[1] = v768 + v774;
  v335 = (v764 + v766) ^ v776;
  HIDWORD(v811) = v775 >> 31;
  v336 = (v768 + v774) ^ v787;
  LODWORD(v812) = (2 * v333) | (HIDWORD(v333) >> 31);
  v814[4] = v746;
  LODWORD(v813) = (2 * v335) | (HIDWORD(v335) >> 31);
  HIDWORD(v812) = v333 >> 31;
  HIDWORD(v813) = v335 >> 31;
  LODWORD(v810) = (2 * v336) | (HIDWORD(v336) >> 31);
  v814[5] = v764;
  v814[0] = v764 + v766;
  v814[6] = v768;
  HIDWORD(v810) = v336 >> 31;
  v337 = (_QWORD *)a1;
  v338 = v374 + v762;
  v339 = &v806;
  for ( i = v814; ; ++i )
  {
    --result;
    *v337++ ^= v338 ^ v334;
    if ( !result )
      break;
    v341 = v339[1];
    ++v339;
    v338 = v341;
    v342 = i[1];
    v334 = v342;
  }
  return result;
}
// 4EF68: too many cbuild loops

//----- (00054DCC) --------------------------------------------------------
int __fastcall sub_54DCC(char *a1, unsigned __int8 *a2)
{
  char *v4; // r12
  char *v5; // r4
  __int64 v6; // t1
  unsigned __int8 *v7; // r1
  _QWORD *v8; // r0
  __int64 v9; // d18
  __int64 v10; // d21
  __int64 v11; // d17
  unsigned int v12; // r2
  __int64 v13; // d19

  memset(a1, 0, 0x168u);
  v4 = "hPoW";
  v5 = a1 - 8;
  do
  {
    v6 = *((_QWORD *)v4 + 1);
    v4 += 8;
    *((_QWORD *)v5 + 1) = v6;
    v5 += 8;
  }
  while ( v4 != (char *)&unk_6C578 );
  v7 = a2;
  v8 = a1;
  do
  {
    v9 = vshld_n_s64(v7[2], 0x10u) | vshld_n_s64(v7[1], 8u);
    LODWORD(v9) = *v7 | (unsigned int)v9;
    v10 = vshld_n_s64(v7[4], 0x20u) | vshld_n_s64(v7[3], 0x18u) | v9;
    v11 = vshld_n_s64(v7[5], 0x28u);
    v12 = v7[7];
    v13 = vshld_n_s64(v7[6], 0x30u);
    v7 += 8;
    *v8++ ^= vshld_n_s64(v12, 0x38u) | v13 | v11 | v10;
  }
  while ( v7 != a2 + 64 );
  return 0;
}

//----- (00054ED0) --------------------------------------------------------
int __fastcall sub_54ED0(char *a1, int a2)
{
  unsigned __int8 v3[18]; // [sp+0h] [bp-44h] BYREF
  __int16 v4; // [sp+12h] [bp-32h]
  __int16 v5; // [sp+14h] [bp-30h]
  __int16 v6; // [sp+16h] [bp-2Eh]
  __int16 v7; // [sp+18h] [bp-2Ch]
  __int16 v8; // [sp+1Ah] [bp-2Ah]
  __int16 v9; // [sp+1Ch] [bp-28h]
  __int16 v10; // [sp+1Eh] [bp-26h]
  int v11; // [sp+20h] [bp-24h]
  int v12; // [sp+24h] [bp-20h]
  int v13; // [sp+28h] [bp-1Ch]
  int v14; // [sp+2Ch] [bp-18h]
  int v15; // [sp+30h] [bp-14h]
  int v16; // [sp+34h] [bp-10h]
  int v17; // [sp+38h] [bp-Ch]
  int v18; // [sp+3Ch] [bp-8h]

  if ( (unsigned int)(a2 - 1) > 0x3F )
    return -1;
  v3[0] = a2;
  v3[2] = 1;
  v3[1] = 0;
  memset(&v3[4], 0, 14);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v3[3] = 1;
  return sub_54DCC(a1, v3);
}

//----- (00054F8C) --------------------------------------------------------
int __fastcall sub_54F8C(int a1, char *src, unsigned __int64 n)
{
  unsigned __int64 v3; // r4
  int v6; // r3
  int v7; // r10
  int v8; // r6
  int v9; // r12
  unsigned __int64 v10; // r2
  void *srca; // [sp+4h] [bp-8h]

  v3 = n;
  if ( n )
  {
    v6 = *(_DWORD *)(a1 + 352);
    srca = (void *)(a1 + 224);
    while ( 1 )
    {
      v7 = 256 - v6;
      v8 = 256 - v6;
      if ( (unsigned int)(256 - v6) >= v3 )
        break;
      memcpy((void *)(a1 + v6 + 96), src, 256 - v6);
      v9 = *(_DWORD *)(a1 + 352);
      v10 = *(_QWORD *)(a1 + 64) + 128LL;
      *(_QWORD *)(a1 + 64) = v10;
      src += v7;
      *(_QWORD *)(a1 + 72) += v10 <= 0x7F;
      *(_DWORD *)(a1 + 352) = v9 + v7;
      v3 -= (unsigned int)v8;
      sub_4EF68(a1, (unsigned __int8 *)(a1 + 96));
      memcpy((void *)(a1 + 96), srca, 0x80u);
      v6 = *(_DWORD *)(a1 + 352) - 128;
      *(_DWORD *)(a1 + 352) = v6;
      if ( !v3 )
        return 0;
    }
    memcpy((void *)(a1 + v6 + 96), src, v3);
    *(_DWORD *)(a1 + 352) += v3;
  }
  return 0;
}

//----- (00055098) --------------------------------------------------------
int __fastcall sub_55098(char *a1, int a2, const void *a3, size_t a4)
{
  bool v7; // zf
  unsigned __int8 v9[18]; // [sp+0h] [bp-C4h] BYREF
  __int16 v10; // [sp+12h] [bp-B2h]
  __int16 v11; // [sp+14h] [bp-B0h]
  __int16 v12; // [sp+16h] [bp-AEh]
  __int16 v13; // [sp+18h] [bp-ACh]
  __int16 v14; // [sp+1Ah] [bp-AAh]
  __int16 v15; // [sp+1Ch] [bp-A8h]
  __int16 v16; // [sp+1Eh] [bp-A6h]
  int v17; // [sp+20h] [bp-A4h]
  int v18; // [sp+24h] [bp-A0h]
  int v19; // [sp+28h] [bp-9Ch]
  int v20; // [sp+2Ch] [bp-98h]
  int v21; // [sp+30h] [bp-94h]
  int v22; // [sp+34h] [bp-90h]
  int v23; // [sp+38h] [bp-8Ch]
  int v24; // [sp+3Ch] [bp-88h]
  char s[132]; // [sp+40h] [bp-84h] BYREF

  if ( (unsigned int)(a2 - 1) > 0x3F )
    return -1;
  v7 = a3 == 0;
  if ( a3 )
    v7 = a4 == 0;
  if ( v7 )
    return -1;
  if ( a4 > 0x40 )
    return -1;
  v9[1] = a4;
  v9[0] = a2;
  memset(&v9[4], 0, 14);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v9[2] = 1;
  v9[3] = 1;
  if ( sub_54DCC(a1, v9) < 0 )
    return -1;
  memset(s, 0, 0x80u);
  memcpy(s, a3, a4);
  sub_54F8C((int)a1, s, 0x80u);
  off_76B94(s, 0, 0x80u);
  return 0;
}
// 76B94: using guessed type void *(*off_76B94)(void *s, int c, size_t n);

//----- (000551D4) --------------------------------------------------------
int __fastcall sub_551D4(int a1, void *a2, size_t a3)
{
  bool v6; // zf
  unsigned int v7; // r2
  unsigned __int8 *v8; // r9
  __int64 v9; // r6
  int v10; // r3
  unsigned __int64 v11; // r0
  int v12; // r0
  int v13; // r11
  char *v14; // r12
  __int64 v15; // t1
  __int64 v17; // r4
  unsigned __int64 v18; // r6
  size_t v19; // r2
  _BYTE v20[64]; // [sp+0h] [bp-44h] BYREF
  char v21; // [sp+40h] [bp-4h] BYREF

  memset(v20, 0, sizeof(v20));
  v6 = a2 == 0;
  if ( a2 )
    v6 = a3 == 0;
  if ( v6 || a3 > 0x40 || *(_QWORD *)(a1 + 80) )
    return -1;
  v7 = *(_DWORD *)(a1 + 352);
  v8 = (unsigned __int8 *)(a1 + 96);
  if ( v7 > 0x80 )
  {
    v17 = *(_QWORD *)(a1 + 72);
    v18 = *(_QWORD *)(a1 + 64) + 128LL;
    *(_QWORD *)(a1 + 64) = v18;
    *(_QWORD *)(a1 + 72) = v17 + (v18 <= 0x7F);
    sub_4EF68(a1, (unsigned __int8 *)(a1 + 96));
    v19 = *(_DWORD *)(a1 + 352) - 128;
    *(_DWORD *)(a1 + 352) = v19;
    memcpy((void *)(a1 + 96), (const void *)(a1 + 224), v19);
    v7 = *(_DWORD *)(a1 + 352);
  }
  v9 = *(_QWORD *)(a1 + 72);
  v10 = *(unsigned __int8 *)(a1 + 356);
  v11 = *(_QWORD *)(a1 + 64) + v7;
  *(_QWORD *)(a1 + 64) = v11;
  *(_QWORD *)(a1 + 72) = v9 + (v11 < v7);
  if ( v10 )
    *(_QWORD *)(a1 + 88) = -1;
  *(_QWORD *)(a1 + 80) = -1;
  memset((void *)(a1 + v7 + 96), 0, 256 - v7);
  v12 = a1;
  v13 = a1 - 8;
  sub_4EF68(v12, v8);
  v14 = v20;
  do
  {
    v15 = *(_QWORD *)(v13 + 8);
    v13 += 8;
    *(_QWORD *)v14 = v15;
    v14 += 8;
  }
  while ( v14 != &v21 );
  memcpy(a2, v20, a3);
  return 0;
}

//----- (00055470) --------------------------------------------------------
int __fastcall sub_55470(unsigned __int8 *a1)
{
  char *v1; // r2
  unsigned __int8 *v2; // r3
  int v3; // r12
  int v4; // r0
  int v5; // r1
  unsigned __int8 *v6; // r1
  int i; // r3
  int v8; // r9
  int v9; // r3
  unsigned int v10; // r6
  unsigned int v11; // r5
  int v12; // r6
  _BYTE *v13; // r2
  _BYTE *v14; // r5
  int v15; // r6
  _BYTE *v16; // r7
  _BYTE *v17; // r11
  _BYTE *v18; // r12
  int v19; // r1
  int v20; // r8
  int v21; // r4
  int v22; // r12
  int v23; // r0
  int v24; // r1
  int v25; // r4
  int v26; // r12
  unsigned __int8 *v27; // r2
  int k; // r3
  int result; // r0
  int v30; // [sp+0h] [bp-B8h] BYREF
  int v31; // [sp+4h] [bp-B4h]
  int j; // [sp+8h] [bp-B0h]
  char *v33; // [sp+Ch] [bp-ACh]
  int v34; // [sp+10h] [bp-A8h]
  unsigned __int8 *v35; // [sp+14h] [bp-A4h]
  _DWORD v36[7]; // [sp+18h] [bp-A0h]
  char v37; // [sp+34h] [bp-84h] BYREF
  _BYTE var44[100]; // [sp+74h] [bp-44h] BYREF

  v1 = &v37;
  v2 = a1;
  v35 = a1;
  do
  {
    v3 = v2[43];
    v4 = v2[42];
    v5 = (v2[41] << 16) + (v2[40] << 24);
    v2 += 4;
    *((_DWORD *)v1 + 1) = v5 + v3 + (v4 << 8);
    v1 += 4;
  }
  while ( v1 != var44 );
  v6 = v35;
  for ( i = 0; i != 8; ++i )
    v36[i] = *(_DWORD *)&v6[i * 4];
  for ( j = 0; j != 64; j += 16 )
  {
    v8 = 0;
    v9 = 7;
    v33 = (char *)&unk_6C580 + 4 * j;
    do
    {
      v20 = v9 - 1;
      v21 = v36[((_BYTE)v9 - 3) & 7];
      v22 = v36[(v9 - 1) & 7];
      v23 = __ROR4__(v21, 6) ^ __ROR4__(v21, 11) ^ __ROR4__(v21, 25);
      v24 = (v22 ^ v36[((_BYTE)v9 - 2) & 7]) & v21 ^ v22;
      v25 = v36[v9 & 7];
      v26 = *(_DWORD *)&v33[v8];
      if ( j )
      {
        v10 = *(_DWORD *)&var44[4 * ((5 - (_BYTE)v9) & 0xF) + 4];
        v11 = *(_DWORD *)&var44[4 * ((-8 - (_BYTE)v9) & 0xF) + 4];
        v31 = *(_DWORD *)&var44[4 * (-v9 & 0xF) + 4];
        v30 = __ROR4__(v10, 17) ^ __ROR4__(v10, 19);
        v34 = __ROR4__(v11, 7);
        v31 += *(_DWORD *)&var44[v8 + 4];
        v12 = v31 + (v30 ^ (v10 >> 10)) + (v34 ^ __ROR4__(v11, 18) ^ (v11 >> 3));
      }
      else
      {
        v12 = *(int *)((char *)&v30 + v8 + 56);
      }
      *(_DWORD *)&var44[v8 + 4] = v12;
      v13 = &var44[4 * (v9 & 7) + 68];
      v14 = &var44[4 * (((_BYTE)v9 - 4) & 7) + 68];
      v15 = v25 + v26 + v23 + v24 + v12;
      v16 = &var44[4 * (((_BYTE)v9 - 7) & 7) + 68];
      *((_DWORD *)v13 - 40) = v15;
      v17 = &var44[4 * (((_BYTE)v9 - 6) & 7) + 68];
      v18 = &var44[4 * (((_BYTE)v9 - 5) & 7) + 68];
      *((_DWORD *)v14 - 40) += v15;
      --v9;
      v19 = *((_DWORD *)v16 - 40);
      v8 += 4;
      *((_DWORD *)v13 - 40) += (__ROR4__(v19, 2) ^ __ROR4__(v19, 13) ^ __ROR4__(v19, 22))
                             + ((v19 | *((_DWORD *)v17 - 40)) & *((_DWORD *)v18 - 40) | v19 & *((_DWORD *)v17 - 40));
    }
    while ( v20 != -9 );
  }
  v27 = v35;
  for ( k = 0; k != 8; ++k )
  {
    result = *(_DWORD *)&v27[k * 4];
    *(_DWORD *)&v27[k * 4] = result + v36[k];
  }
  return result;
}

//----- (00055700) --------------------------------------------------------
int __fastcall sub_55700(int result)
{
  *(_DWORD *)result = 1779033703;
  *(_DWORD *)(result + 4) = -1150833019;
  *(_DWORD *)(result + 8) = 1013904242;
  *(_DWORD *)(result + 12) = -1521486534;
  *(_DWORD *)(result + 16) = 1359893119;
  *(_DWORD *)(result + 20) = -1694144372;
  *(_DWORD *)(result + 24) = 528734635;
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 28) = 1541459225;
  return result;
}

//----- (0005576C) --------------------------------------------------------
int __fastcall sub_5576C(int result, int a2, int a3)
{
  __int64 v3; // r4
  int v4; // r7
  int v5; // r3
  int v6; // r8
  int v7; // r6
  int v9; // r2

  v3 = *(_QWORD *)(result + 32);
  v4 = result;
  v5 = v3 & 0x3F;
  if ( a3 )
  {
    v6 = a2 + a3;
    v7 = a2 + 1;
    while ( 1 )
    {
      v9 = v4 + v5++;
      *(_BYTE *)(v9 + 40) = *(_BYTE *)(v7 - 1);
      *(_QWORD *)(v4 + 32) = v3 + 1;
      if ( v5 == 64 )
      {
        result = sub_55470((unsigned __int8 *)v4);
        v5 = 0;
      }
      if ( v7++ == v6 )
        break;
      v3 = *(_QWORD *)(v4 + 32);
    }
  }
  return result;
}

//----- (000557D4) --------------------------------------------------------
_BYTE *__fastcall sub_557D4(int a1, _BYTE *a2)
{
  __int64 v2; // d16
  __int64 v5; // r4
  char v6; // r3
  int v7; // r7
  int v8; // r2
  int v9; // r3
  _BYTE *result; // r0
  _BYTE *v11; // r2
  int v12; // r3
  int v13; // r1

  v2 = *(_QWORD *)(a1 + 32);
  v5 = vshld_n_s64(v2, 3u);
  v6 = (v2 & 0x3F) + 1;
  *(_BYTE *)(a1 + (v2 & 0x3F) + 40) = 0x80;
  if ( (v2 & 0x3F) != 0x37 )
  {
    do
    {
      while ( 1 )
      {
        v7 = v6 & 0x3F;
        v6 = v7 + 1;
        if ( v7 )
          break;
        sub_55470((unsigned __int8 *)a1);
        *(_BYTE *)(a1 + 40) = v7;
        v6 = 1;
      }
      *(_BYTE *)(a1 + v7 + 40) = 0;
    }
    while ( v7 != 55 );
  }
  v8 = a1;
  v9 = 56;
  do
  {
    ++v9;
    *(_BYTE *)(v8 + 96) = HIBYTE(v5);
    v5 <<= 8;
    ++v8;
  }
  while ( v9 != 64 );
  sub_55470((unsigned __int8 *)a1);
  result = a2 + 32;
  v11 = a2;
  v12 = 0;
  do
  {
    a2[v12] = HIBYTE(*(_DWORD *)(a1 + v12));
    v11[1] = BYTE2(*(_DWORD *)(a1 + v12));
    v11[2] = BYTE1(*(_DWORD *)(a1 + v12));
    v13 = *(_DWORD *)(a1 + v12);
    v12 += 4;
    v11[3] = v13;
    v11 += 4;
  }
  while ( result != v11 );
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)a1 = 1779033703;
  *(_DWORD *)(a1 + 4) = -1150833019;
  *(_DWORD *)(a1 + 8) = 1013904242;
  *(_DWORD *)(a1 + 12) = -1521486534;
  *(_DWORD *)(a1 + 16) = 1359893119;
  *(_DWORD *)(a1 + 20) = -1694144372;
  *(_DWORD *)(a1 + 24) = 528734635;
  *(_DWORD *)(a1 + 28) = 1541459225;
  return result;
}

//----- (00055930) --------------------------------------------------------
_BYTE *__fastcall sub_55930(int a1, int a2, _BYTE *a3)
{
  _DWORD v5[8]; // [sp+0h] [bp-68h] BYREF
  double v6; // [sp+20h] [bp-48h]

  v6 = 0.0;
  v5[0] = 1779033703;
  v5[1] = -1150833019;
  v5[2] = 1013904242;
  v5[3] = -1521486534;
  v5[4] = 1359893119;
  v5[5] = -1694144372;
  v5[6] = 528734635;
  v5[7] = 1541459225;
  sub_5576C((int)v5, a1, a2);
  return sub_557D4((int)v5, a3);
}

//----- (000559D0) --------------------------------------------------------
int __fastcall sub_559D0(int a1)
{
  char *v2; // r5
  int v3; // r4
  ssize_t v4; // r3
  char v5; // r3
  char *v6; // r12
  char *v7; // r1
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // lr
  int v15; // r1
  int v16; // r2
  int v17; // r3
  signed int v18; // r8
  int v19; // r5
  int v20; // r5
  int v21; // r5
  int v22; // r5
  int v23; // r5
  int v24; // r0
  unsigned int v25; // r5
  size_t v26; // r0
  ssize_t v27; // r0
  int v28; // r5
  ssize_t v29; // r12
  ssize_t v30; // [sp+Ch] [bp-7030h]
  char v31; // [sp+10h] [bp-702Ch] BYREF
  char v32[2]; // [sp+11h] [bp-702Bh] BYREF
  socklen_t addr_len; // [sp+14h] [bp-7028h] BYREF
  char needle[3]; // [sp+18h] [bp-7024h] BYREF
  char v35[5]; // [sp+1Bh] [bp-7021h] BYREF
  _DWORD optval[2]; // [sp+20h] [bp-701Ch] BYREF
  struct sockaddr addr; // [sp+28h] [bp-7014h] BYREF
  char s[4096]; // [sp+38h] [bp-7004h] BYREF
  char v39[4040]; // [sp+1038h] [bp-6004h] BYREF
  char v40[10240]; // [sp+2038h] [bp-5004h] BYREF
  _DWORD v41[11]; // [sp+4838h] [bp-2804h] BYREF
  int v42; // [sp+4864h] [bp-27D8h] BYREF

  optval[0] = 3;
  optval[1] = 0;
  memset(s, 0, sizeof(s));
  addr_len = 0;
  v31 = 13;
  needle[0] = 13;
  v2 = v40;
  needle[2] = 13;
  v3 = 0;
  strcpy(v32, "\n");
  needle[1] = 10;
  strcpy(v35, "\n");
  memset(v40, 0, sizeof(v40));
  do
  {
    if ( byte_7ACB8 )
      goto LABEL_10;
    v4 = recvfrom(a1, v2, 10239 - v3, 0, &addr, &addr_len);
    v3 += v4;
    if ( v4 <= 0 )
    {
      close(a1);
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy((char *)v41, ":statusServiceThread recvfrom<=0");
        sub_38730(7, (const char *)v41, 0);
      }
      return 0;
    }
    v2 = &v40[v3];
    if ( v3 > 10238 )
    {
      close(a1);
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        strcpy((char *)v41, "BUFSIZE is too small!");
        sub_38730(7, (const char *)v41, 0);
        return 0;
      }
      return 0;
    }
  }
  while ( !strstr(v40, needle) );
  if ( byte_78E09 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
    {
      strcpy((char *)v41, "find http request end flag!");
      sub_38730(7, (const char *)v41, 0);
LABEL_10:
      if ( byte_78E09 )
      {
        if ( !byte_7AD48 && !byte_78E08 )
          goto LABEL_47;
LABEL_13:
        snprintf((char *)v41, 0x1000u, "get http=%s", v40);
        sub_38730(7, (const char *)v41, 0);
      }
    }
    else
    {
LABEL_47:
      if ( dword_766C4 > 6 )
        goto LABEL_13;
    }
  }
  if ( v40[0] != 71 || v40[1] != 69 || v40[2] != 84 || v40[3] != 32 )
  {
    close(a1);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      qmemcpy(v41, "statusServiceThread not support http command", sizeof(v41));
      v5 = aStatusservicet[44];
      v6 = (char *)&v42;
      v7 = &v40[10184];
      goto LABEL_20;
    }
    return 0;
  }
  if ( strstr(&v40[4], "/rate") )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy((char *)v41, "cmd : get rate");
      sub_38730(7, (const char *)v41, 0);
    }
    if ( dword_76B98 == 1 )
    {
      snprintf(s, 0x1000u, "%d", "():%d");
    }
    else if ( dword_76B98 == 2 )
    {
      snprintf(s, 0x1000u, "%s:%s", "searchfailed", "search_failed_info");
    }
    else
    {
      strcpy(s, "searching");
    }
    goto LABEL_39;
  }
  if ( !strstr(&v40[4], "/productName") )
  {
    close(a1);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy((char *)v41, "statusServiceThread exit for Error cmd!");
      sub_38730(7, (const char *)v41, 0);
      return 0;
    }
    return 0;
  }
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy((char *)v41, "cmd : get miner type");
    sub_38730(7, (const char *)v41, 0);
  }
  snprintf(s, 0x1000u, byte_78850);
LABEL_39:
  if ( setsockopt(a1, 1, 21, optval, 8u) )
  {
    close(a1);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      v9 = "setsockopt SO_SNDTIMEO failed";
LABEL_45:
      v10 = *(_DWORD *)v9;
      v11 = *((_DWORD *)v9 + 1);
      v12 = *((_DWORD *)v9 + 2);
      v13 = *((_DWORD *)v9 + 3);
      v14 = v9 + 16;
      v41[0] = v10;
      v41[1] = v11;
      v41[2] = v12;
      v41[3] = v13;
      v15 = v14[1];
      v16 = v14[2];
      v17 = v14[3];
      v41[4] = *v14;
      v41[5] = v15;
      v41[6] = v16;
      LOWORD(v41[7]) = v17;
      sub_38730(7, (const char *)v41, 0);
      return 0;
    }
    return 0;
  }
  if ( setsockopt(a1, 1, 20, optval, 8u) )
  {
    close(a1);
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      v9 = "setsockopt SO_RCVTIMEO failed";
      goto LABEL_45;
    }
    return 0;
  }
  v18 = strlen(s);
  v19 = sprintf((char *)v41, "HTTP/1.0  200  OK%s", &v31);
  v20 = v19 + sprintf((char *)v41 + v19, "Server: SearchFreqServer%s", &v31);
  v21 = sprintf((char *)v41 + v20, "Cache-Control: no-cache%s", &v31) + v20;
  v22 = sprintf((char *)v41 + v21, "Pragma: no-cache%s", &v31) + v21;
  v23 = sprintf((char *)v41 + v22, "Content-Type: text/plain%s", &v31) + v22;
  v24 = sprintf((char *)v41 + v23, "Content-Length: %d%s", v18, &v31);
  sprintf((char *)v41 + v24 + v23, "Connection: Keep-Alive%s", needle);
  if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
  {
    strcpy(v39, "send http response...\n");
    sub_38730(7, v39, 0);
  }
  v25 = (unsigned __int8)byte_7ACB8;
  if ( byte_7ACB8 )
  {
LABEL_80:
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v39, "send http data...");
      sub_38730(7, v39, 0);
    }
    v28 = 0;
    while ( 1 )
    {
      v29 = send(a1, &s[v28], v18 - v28, 0);
      if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
      {
        v30 = v29;
        snprintf(v39, 0x1000u, "send http data ret=%d", v29);
        sub_38730(7, v39, 0);
        v29 = v30;
      }
      if ( v29 <= 0 )
        break;
      v28 += v29;
      if ( v18 <= v28 || byte_7ACB8 )
        goto LABEL_94;
    }
    if ( byte_78E09 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 6 )
      {
        strcpy(v39, "statusServiceThread send http data error");
        sub_38730(7, v39, 0);
LABEL_94:
        if ( !byte_78E09 )
          goto LABEL_99;
        if ( byte_7AD48 )
          goto LABEL_98;
      }
      if ( byte_78E08 || dword_766C4 > 6 )
      {
LABEL_98:
        strcpy(v39, "one client disconnected!");
        sub_38730(7, v39, 0);
      }
    }
LABEL_99:
    close(a1);
    return v28;
  }
  v26 = strlen((const char *)v41);
  while ( 1 )
  {
    v27 = send(a1, (char *)v41 + v25, v26 - v25, 0);
    if ( v27 == -1 )
      break;
    if ( v27 <= 0 )
      goto LABEL_75;
    v25 += v27;
LABEL_71:
    v26 = strlen((const char *)v41);
    if ( v26 <= v25 || byte_7ACB8 )
      goto LABEL_80;
  }
  if ( *_errno_location() == 11 )
  {
    if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
    {
      strcpy(v39, "statusServiceThread send http timeout, try again...");
      sub_38730(7, v39, 0);
    }
    usleep(0x186A0u);
    goto LABEL_71;
  }
LABEL_75:
  close(a1);
  if ( !byte_78E09 || !byte_7AD48 && !byte_78E08 && dword_766C4 <= 6 )
    return 0;
  qmemcpy(v39, "statusServiceThread send http response error", 44);
  v5 = aStatusservicet_1[44];
  v6 = &v39[44];
  v7 = &s[4040];
LABEL_20:
  *v6 = v5;
  sub_38730(7, v7 + 56, 0);
  return 0;
}
// 766C4: using guessed type int dword_766C4;
// 76B98: using guessed type int dword_76B98;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7ACB8: using guessed type char byte_7ACB8;
// 7AD48: using guessed type char byte_7AD48;

//----- (0005664C) --------------------------------------------------------
void *__fastcall sub_5664C(void *a1)
{
  int v1; // r0
  int v2; // r3
  int v3; // r0
  int v4; // r12
  int v6; // [sp+Ch] [bp-1030h]
  socklen_t v7; // [sp+10h] [bp-102Ch] BYREF
  int optval; // [sp+14h] [bp-1028h] BYREF
  struct sockaddr addr; // [sp+18h] [bp-1024h] BYREF
  struct sockaddr v10; // [sp+28h] [bp-1014h] BYREF
  char s[4040]; // [sp+38h] [bp-1004h] BYREF

  sleep(0x1Eu);
  do
  {
    v1 = socket(2, 1, 6);
    dword_76B9C = v1;
    if ( v1 < 0 )
    {
      if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
      {
        strcpy(s, "socket creating failed, try again after 10s...");
        sub_38730(5, s, 0);
      }
      sleep(0xAu);
    }
    else
    {
      optval = 1;
      if ( setsockopt(v1, 1, 2, &optval, 4u) < 0 && (byte_7AD48 || byte_78E08 || dword_766C4 > 3) )
      {
        strcpy(s, "*******************setsockopt(SO_REUSEADDR) failed");
        sub_38730(4, s, 0);
      }
      addr.sa_family = 2;
      *(_WORD *)addr.sa_data = -21481;
      memset(&addr.sa_data[2], 0, 12);
      if ( bind(dword_76B9C, &addr, 0x10u) < 0 )
      {
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          strcpy(s, "http port bind failed! try again after 10s...");
          sub_38730(5, s, 0);
        }
      }
      else
      {
        if ( listen(dword_76B9C, 100) >= 0 )
          break;
        if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
        {
          strcpy(s, "http listen failed! try again after 10s...");
          sub_38730(5, s, 0);
        }
      }
      close(dword_76B9C);
      dword_76B9C = -1;
      sleep(0xAu);
    }
  }
  while ( !byte_7ACB8 );
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    strcpy(s, "start listen on 6060 ...");
    sub_38730(5, s, 0);
  }
  if ( !byte_7ACB8 )
  {
LABEL_10:
    v2 = 0;
    while ( !v2 )
    {
      usleep(0x2710u);
      v7 = 16;
      v3 = accept(dword_76B9C, &v10, &v7);
      v2 = (unsigned __int8)byte_7ACB8;
      v4 = v3;
      if ( v3 != -1 )
      {
        if ( byte_7ACB8 )
        {
          close(v3);
          break;
        }
        if ( byte_78E09 && (byte_7AD48 || byte_78E08 || dword_766C4 > 6) )
        {
          v6 = v3;
          snprintf(s, 0x1000u, "one client connected sock=%d", v3);
          sub_38730(7, s, 0);
          v4 = v6;
        }
        sub_559D0(v4);
        if ( !byte_7ACB8 )
          goto LABEL_10;
        break;
      }
    }
  }
  close(dword_76B9C);
  dword_76B9C = -1;
  return 0;
}
// 766C4: using guessed type int dword_766C4;
// 76B9C: using guessed type int dword_76B9C;
// 78E08: using guessed type char byte_78E08;
// 78E09: using guessed type char byte_78E09;
// 7ACB8: using guessed type char byte_7ACB8;
// 7AD48: using guessed type char byte_7AD48;

//----- (00056A90) --------------------------------------------------------
void sub_56A90()
{
  int v0; // r0
  pthread_t v1; // [sp+0h] [bp-102Ch] BYREF
  pthread_attr_t attr; // [sp+4h] [bp-1028h] BYREF
  char s[4100]; // [sp+28h] [bp-1004h] BYREF

  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 0x200000u);
  v0 = pthread_create(&v1, &attr, sub_5664C, 0);
  if ( byte_7AD48 || byte_78E08 || dword_766C4 > 4 )
  {
    snprintf(s, 0x1000u, "httpListenThread start ret=%d", v0);
    sub_38730(5, s, 0);
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00056B3C) --------------------------------------------------------
void __fastcall sub_56B3C(int *a1, int a2, int a3)
{
  int v5; // r10
  int v6; // r0
  unsigned int v7; // r3
  unsigned int v8; // r5
  int *v9; // r1
  int v10; // r2
  int v11; // r8
  unsigned int v12; // r0
  int v13; // r12
  int v14; // t1
  unsigned int *v15; // [sp+0h] [bp-100Ch]
  int v16; // [sp+4h] [bp-1008h]
  char v17[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( a2 <= 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      strcpy(v17, "XXTEA encode failes, N <= 1 found.\n");
      sub_38730(3, v17, 0);
    }
  }
  else
  {
    v5 = a2 - 1;
    v6 = sub_5C710(52, a2);
    v7 = a1[v5];
    v8 = 0;
    v15 = (unsigned int *)&a1[v5];
    v16 = -1640531527 * v6 - 1253254570;
    do
    {
      v9 = a1;
      v10 = 0;
      v8 -= 1640531527;
      v11 = (v8 >> 2) & 3;
      do
      {
        v12 = v9[1];
        v13 = v10++ & 3 ^ v11;
        v14 = *v9++;
        v7 = (((v7 ^ *(_DWORD *)(a3 + 4 * v13)) + (v12 ^ v8)) ^ (((16 * v7) ^ (v12 >> 3)) + ((v7 >> 5) ^ (4 * v12))))
           + v14;
        *(v9 - 1) = v7;
      }
      while ( v10 != v5 );
      v7 = (((v7 ^ *(_DWORD *)(a3 + 4 * (v11 ^ v5 & 3))) + (v8 ^ *a1))
          ^ ((((unsigned int)*a1 >> 3) ^ (16 * v7)) + ((4 * *a1) ^ (v7 >> 5))))
         + *v15;
      *v15 = v7;
    }
    while ( v8 != v16 );
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00056CD8) --------------------------------------------------------
void __fastcall sub_56CD8(unsigned int *a1, int a2, int a3)
{
  int v6; // r0
  unsigned int v7; // r3
  int v8; // r0
  unsigned int v9; // r5
  int v10; // r1
  unsigned int *v11; // r12
  int v12; // r10
  int v13; // r8
  char v14[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( a2 <= 1 )
  {
    if ( byte_7AD48 || byte_78E08 || dword_766C4 > 2 )
    {
      strcpy(v14, "XXTEA decode failes, N <= 1 found.\n");
      sub_38730(3, v14, 0);
    }
  }
  else
  {
    v6 = sub_5C710(52, a2);
    v7 = *a1;
    v8 = v6 + 6;
    v9 = -1640531527 * v8;
    do
    {
      v10 = a2 - 1;
      v11 = &a1[a2];
      v12 = (v9 >> 2) & 3;
      do
      {
        v13 = *(_DWORD *)(a3 + 4 * (v10-- & 3 ^ v12));
        v7 = *(v11 - 1)
           - (((*(v11 - 2) ^ v13) + (v7 ^ v9)) ^ (((v7 >> 3) ^ (16 * *(v11 - 2))) + ((4 * v7) ^ (*(v11 - 2) >> 5))));
        *--v11 = v7;
      }
      while ( v10 );
      --v8;
      v7 = *a1
         - ((((16 * a1[a2 - 1]) ^ (v7 >> 3)) + ((a1[a2 - 1] >> 5) ^ (4 * v7)))
          ^ ((v7 ^ v9) + (a1[a2 - 1] ^ *(_DWORD *)(a3 + 4 * v12))));
      v9 += 1640531527;
      *a1 = v7;
    }
    while ( v8 );
  }
}
// 766C4: using guessed type int dword_766C4;
// 78E08: using guessed type char byte_78E08;
// 7AD48: using guessed type char byte_7AD48;

//----- (00056E48) --------------------------------------------------------
int __fastcall compar(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 < *a2 )
    return -1;
  else
    return *a1 != *a2;
}

//----- (00056E6C) --------------------------------------------------------
int __fastcall sub_56E6C(char *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4)
{
  char *v8; // r0
  int v9; // r1
  char *v10; // r6
  char *v11; // r5
  char *v13; // r0
  bool v14; // zf
  unsigned int v15; // r2
  int v16; // r3
  int v17; // [sp+4h] [bp-18h] BYREF
  char s[20]; // [sp+8h] [bp-14h] BYREF

  if ( !((int (__fastcall *)(const char *, int))a2)("\"", 1) )
  {
    while ( 1 )
    {
      v10 = a1;
      while ( *a1 )
      {
        v13 = sub_59C18(a1, &v17);
        v11 = v13;
        if ( !v13 )
          return -1;
        v14 = v17 == 92;
        if ( v17 != 92 )
          v14 = v17 == 34;
        if ( v14 || v17 <= 31 || (a4 & 0x400) != 0 && v17 == 47 || (a4 & 0x40) != 0 && v17 > 127 )
          goto LABEL_13;
        a1 = v13;
      }
      v11 = a1;
LABEL_13:
      if ( a1 != v10 && a2(v10, a1 - v10, a3) )
        return -1;
      if ( v11 == a1 )
        return a2((char *)"\"", 1, a3);
      if ( v17 == 12 )
      {
        v9 = 2;
        v8 = "\\f";
        goto LABEL_8;
      }
      if ( v17 <= 12 )
        break;
      if ( v17 == 34 )
      {
        v8 = "\\\"";
        v9 = 2;
        goto LABEL_8;
      }
      if ( v17 > 34 )
      {
        if ( v17 == 47 )
        {
          v9 = 2;
          v8 = "\\/";
        }
        else
        {
          if ( v17 == 92 )
          {
            v9 = 2;
            v8 = "\\\\";
            goto LABEL_8;
          }
LABEL_6:
          if ( v17 >= 0x10000 )
          {
            v15 = ((unsigned int)(v17 - 0x10000) >> 10) & 0x3FF | 0xD800;
            v16 = (v17 - 0x10000) & 0x3FF | 0xDC00;
            v17 -= 0x10000;
            sprintf(s, "\\u%04x\\u%04x", v15, v16);
            v8 = s;
            v9 = 12;
          }
          else
          {
            sprintf(s, "\\u%04x", v17);
            v8 = s;
            v9 = 6;
          }
        }
        goto LABEL_8;
      }
      if ( v17 != 13 )
        goto LABEL_6;
      if ( a2("\\r", 2, a3) )
        return -1;
LABEL_9:
      a1 = v11;
    }
    switch ( v17 )
    {
      case 9:
        v9 = 2;
        v8 = "\\t";
        break;
      case 10:
        v9 = 2;
        v8 = "\\n";
        break;
      case 8:
        v9 = 2;
        v8 = "\\b";
        break;
      default:
        goto LABEL_6;
    }
LABEL_8:
    if ( !a2(v8, v9, a3) )
      goto LABEL_9;
  }
  return -1;
}

//----- (00057090) --------------------------------------------------------
int __fastcall sub_57090(int a1, int a2)
{
  return strcmp(*(const char **)(a1 + 4), *(const char **)(a2 + 4));
}

//----- (0005709C) --------------------------------------------------------
int __fastcall sub_5709C(const void *a1, size_t a2, FILE *s)
{
  if ( fwrite(a1, a2, 1u, s) == 1 )
    return 0;
  else
    return -1;
}

//----- (000570BC) --------------------------------------------------------
int __fastcall sub_570BC(void *src, size_t n, const void **a3)
{
  return sub_596B0(a3, src, n);
}

//----- (000570D4) --------------------------------------------------------
int __fastcall sub_570D4(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int v5; // r8
  int v9; // r4

  v5 = a1 & 0x1F;
  if ( (a1 & 0x1F) != 0 )
  {
    if ( !a4(ptr, 1, a5) )
    {
      if ( a2 <= 0 )
        return 0;
      v9 = 0;
      while ( 1 )
      {
        ++v9;
        if ( a4("                                ", v5, a5) )
          break;
        if ( v9 == a2 )
          return 0;
      }
    }
    return -1;
  }
  else
  {
    if ( !a3 || (a1 & 0x20) != 0 )
      return 0;
    return a4(" ", 1, a5);
  }
}

//----- (00057178) --------------------------------------------------------
int __fastcall sub_57178(_DWORD *a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5)
{
  int (__fastcall *v7)(char *, int, int); // r4
  int v8; // r5
  __int64 v9; // r0
  int v10; // r1
  int result; // r0
  const char *v12; // r2
  int v13; // r11
  _DWORD *v14; // r8
  int v15; // r9
  int v16; // r10
  int v17; // r10
  char *v18; // r0
  int v19; // r0
  _DWORD *v20; // r9
  int v21; // r10
  signed int i; // r8
  _DWORD *v23; // r0
  char *v24; // r0
  char *v25; // r0
  int v26; // r5
  unsigned int v27; // r11
  char *v28; // r4
  char *v29; // r6
  unsigned int v30; // r8
  int (*v31)(const void *, const void *); // r3
  char *v32; // r11
  int v33; // r10
  char *v35; // [sp+Ch] [bp-88h]
  size_t nmemb; // [sp+10h] [bp-84h]
  void *base; // [sp+14h] [bp-80h]
  int v38; // [sp+18h] [bp-7Ch]
  unsigned int v39; // [sp+1Ch] [bp-78h]
  int v40; // [sp+20h] [bp-74h]
  int (__fastcall *v41)(char *, int, int); // [sp+24h] [bp-70h]
  char s[104]; // [sp+2Ch] [bp-68h] BYREF

  v7 = a4;
  v8 = a5;
  if ( !a1 )
    return -1;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v35 = (char *)v12;
      if ( a1[8] )
        goto LABEL_22;
      a1[8] = 1;
      v14 = sub_59E9C(a1);
      if ( v7("{", 1, a5) )
        goto LABEL_22;
      if ( v14 )
      {
        v15 = a3 + 1;
        v16 = sub_570D4(a2, a3 + 1, 0, (int (__fastcall *)(const char *, int, int))v7, a5);
        if ( !v16 )
        {
          if ( (a2 & 0x180) != 0 )
          {
            nmemb = (size_t)sub_59E04(a1);
            v25 = (char *)sub_5956C(8 * nmemb);
            base = v25;
            if ( v25 )
            {
              v38 = v13;
              v41 = v7;
              v26 = (int)v14;
              v27 = 0;
              v40 = a2;
              v28 = v25;
              while ( 1 )
              {
                *(_DWORD *)&v28[v16] = sub_57F3C(v26);
                v29 = &v28[v16];
                v16 += 8;
                *((_DWORD *)v29 + 1) = sub_59F14(v26);
                v26 = sub_59EE8(a1, v26);
                if ( !v26 )
                  break;
                ++v27;
              }
              v30 = 0;
              v8 = a5;
              v39 = v27;
              v7 = v41;
              if ( nmemb != v27 + 1 )
                _assert_fail("i == size", "dump.c", 0x141u, "do_dump");
              v31 = (int (*)(const void *, const void *))sub_57090;
              if ( (v40 & 0x80) == 0 )
                v31 = (int (*)(const void *, const void *))compar;
              qsort(base, nmemb, 8u, v31);
              if ( !nmemb )
              {
LABEL_65:
                sub_59594(base);
LABEL_43:
                a1[8] = 0;
                return v7((char *)"}", 1, v8);
              }
              while ( 1 )
              {
                v32 = (char *)*((_DWORD *)base + 2 * v30 + 1);
                v33 = sub_59E20(a1, v32);
                if ( !v33 )
                  _assert_fail("value", "dump.c", 0x151u, "do_dump");
                sub_56E6C(v32, v41, a5, v40);
                if ( v41(v35, v38, a5) || sub_57178(v33, v40, v15, v41, a5) )
                  break;
                if ( v39 > v30 )
                {
                  if ( v41((char *)",", 1, a5)
                    || sub_570D4(v40, v15, 1, (int (__fastcall *)(const char *, int, int))v41, a5) )
                  {
                    break;
                  }
                }
                else if ( sub_570D4(v40, a3, 0, (int (__fastcall *)(const char *, int, int))v41, a5) )
                {
                  break;
                }
                if ( nmemb == ++v30 )
                  goto LABEL_65;
              }
              sub_59594(base);
            }
          }
          else
          {
            while ( 1 )
            {
              v17 = sub_59EE8(a1, (int)v14);
              v18 = (char *)sub_59F14((int)v14);
              sub_56E6C(v18, v7, a5, a2);
              if ( v7(v35, v13, a5) )
                goto LABEL_22;
              v19 = sub_59F20((int)v14);
              if ( sub_57178(v19, a2, v15, v7, a5) )
                goto LABEL_22;
              if ( !v17 )
                break;
              if ( !v7((char *)",", 1, a5) )
              {
                v14 = (_DWORD *)v17;
                if ( !sub_570D4(a2, v15, 1, (int (__fastcall *)(const char *, int, int))v7, a5) )
                  continue;
              }
              goto LABEL_22;
            }
            if ( !sub_570D4(a2, a3, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
              goto LABEL_43;
          }
        }
LABEL_22:
        a1[8] = 0;
        return -1;
      }
      a1[8] = 0;
      result = v7((char *)"}", 1, a5);
      break;
    case 1:
      if ( a1[5] )
        goto LABEL_36;
      a1[5] = 1;
      v20 = sub_59FEC(a1);
      if ( v7("[", 1, a5) )
        goto LABEL_36;
      if ( !v20 )
        goto LABEL_44;
      v21 = a3 + 1;
      if ( sub_570D4(a2, a3 + 1, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
        goto LABEL_36;
      if ( (int)v20 <= 0 )
        goto LABEL_44;
      for ( i = 0; (_DWORD *)i != v20; ++i )
      {
        v23 = sub_5A008(a1, i);
        if ( sub_57178(v23, a2, v21, v7, a5) )
        {
LABEL_36:
          a1[5] = 0;
          return -1;
        }
        if ( (int)v20 - 1 > i )
        {
          if ( v7((char *)",", 1, a5) || sub_570D4(a2, v21, 1, (int (__fastcall *)(const char *, int, int))v7, a5) )
            goto LABEL_36;
        }
        else if ( sub_570D4(a2, a3, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
        {
          goto LABEL_36;
        }
      }
LABEL_44:
      a1[5] = 0;
      return v7((char *)word_6B5B0, 1, a5);
    case 2:
      v24 = (char *)sub_5A178(a1);
      return sub_56E6C(v24, v7, a5, a2);
    case 3:
      v9 = sub_5A248((int)a1);
      v10 = snprintf(s, 0x64u, "%lld", v9);
      if ( (unsigned int)v10 > 0x63 )
        return -1;
      return v7(s, v10, a5);
    case 4:
      sub_5A2F8();
      v10 = sub_598A8(s, 0x64u);
      if ( v10 < 0 )
        return -1;
      return v7(s, v10, a5);
    case 5:
      return a4("true", 4, a5);
    case 6:
      return a4("false", 5, a5);
    case 7:
      return a4("null", 4, a5);
    default:
      return -1;
  }
  return result;
}
// 571A4: control flows out of bounds to 571A8

//----- (000577A4) --------------------------------------------------------
int __fastcall sub_577A4(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4)
{
  if ( (a4 & 0x200) != 0 || a1 && *a1 <= 1u )
    return sub_57178(a1, a4, 0, a2, a3);
  else
    return -1;
}

//----- (000577F0) --------------------------------------------------------
int __fastcall sub_577F0(_DWORD *a1, int a2, __int16 a3)
{
  return sub_577A4(a1, (int (__fastcall *)(char *, int, int))sub_5709C, a2, a3);
}

//----- (00057804) --------------------------------------------------------
int __fastcall sub_57804(_DWORD *a1, char *filename, __int16 a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = fopen(filename, "w");
  if ( !v5 )
    return -1;
  v6 = sub_577F0(a1, (int)v5, a3);
  fclose(v5);
  return v6;
}

//----- (00057854) --------------------------------------------------------
void *__fastcall sub_57854(_DWORD *a1, __int16 a2)
{
  void *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (void *)sub_5961C(v7);
  if ( v4 )
    return 0;
  if ( !sub_577A4(a1, (int (__fastcall *)(char *, int, int))sub_570BC, (int)v7, a2) )
  {
    v6 = (const char *)sub_59694((int)v7);
    v4 = sub_595B4(v6);
  }
  sub_59654((int)v7);
  return v4;
}

//----- (000578C0) --------------------------------------------------------
int __fastcall sub_578C0(int result, int a2, _DWORD *a3)
{
  _DWORD *v3; // r3
  int v4; // r12
  int v5; // r3

  v3 = *(_DWORD **)a2;
  if ( *(_DWORD *)a2 == result + 12 && v3 == *(_DWORD **)(a2 + 4) )
  {
    v4 = *(_DWORD *)(result + 12);
    a3[1] = v3;
    *a3 = v4;
    v5 = *(_DWORD *)(result + 12);
    *(_DWORD *)(result + 12) = a3;
    *(_DWORD *)(v5 + 4) = a3;
    *(_DWORD *)(a2 + 4) = a3;
    *(_DWORD *)a2 = a3;
  }
  else
  {
    *a3 = *v3;
    a3[1] = v3;
    result = *v3;
    *v3 = a3;
    *(_DWORD *)(result + 4) = a3;
    *(_DWORD *)a2 = a3;
  }
  return result;
}

//----- (0005791C) --------------------------------------------------------
int __fastcall sub_5791C(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 - 4) != a4 || strcmp((const char *)(v4 + 16), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4 - 4;
}

//----- (00057994) --------------------------------------------------------
void __fastcall sub_57994(int a1)
{
  int v1; // r3
  int v2; // r6
  int v3; // r0
  void *v4; // r5
  int v5; // r4
  int v6; // r1

  v1 = *(_DWORD *)(a1 + 16);
  v2 = a1 + 12;
  if ( v1 != a1 + 12 )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 8);
      v4 = (void *)(v1 - 4);
      v5 = *(_DWORD *)(v1 + 4);
      if ( v3 )
      {
        v6 = *(_DWORD *)(v3 + 4);
        if ( v6 != -1 )
        {
          *(_DWORD *)(v3 + 4) = v6 - 1;
          if ( v6 == 1 )
            sub_5A3E4();
        }
      }
      sub_59594(v4);
      v1 = v5;
    }
    while ( v5 != v2 );
  }
}
// 5A3E4: using guessed type int sub_5A3E4(void);

//----- (000579F4) --------------------------------------------------------
int __fastcall sub_579F4(_DWORD *a1)
{
  char *v2; // r2
  _DWORD *v3; // r1
  int v4; // r0
  int v5; // r12
  int v6; // r12
  int v7; // r3

  *a1 = 0;
  a1[2] = 0;
  v2 = (char *)sub_5956C(0x28u);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1 + 3;
  v4 = a1[2];
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  v5 = dword_6CB74[v4];
  if ( v5 )
  {
    v6 = 8 * v5;
    v7 = 0;
    do
    {
      *(_DWORD *)&v2[v7 + 4] = v3;
      *(_DWORD *)&v2[v7] = v3;
      v7 += 8;
    }
    while ( v7 != v6 );
  }
  return 0;
}
// 6CB74: using guessed type _DWORD dword_6CB74[29];

//----- (00057A74) --------------------------------------------------------
void __fastcall sub_57A74(int a1)
{
  sub_57994(a1);
  sub_59594(*(void **)(a1 + 4));
}

//----- (00057A8C) --------------------------------------------------------
int __fastcall sub_57A8C(int a1, char *a2, int a3, int a4)
{
  unsigned int v6; // r1
  char *v7; // r9
  int v8; // r12
  char *v9; // lr
  unsigned int v10; // r4
  int v11; // r5
  int v12; // t1
  int *v13; // r9
  int v14; // r0
  int v15; // r5
  int v16; // r0
  int v17; // r3
  int v18; // r3
  int v20; // r3
  unsigned int v21; // r4
  int v22; // r11
  int v23; // r3
  _DWORD *v24; // r10
  int v25; // r1
  _DWORD *v26; // r2
  size_t v27; // r0
  void *v28; // r0
  _DWORD *v29; // r11

  v6 = dword_6CB74[*(_DWORD *)(a1 + 8)];
  if ( *(_DWORD *)a1 >= v6 )
  {
    sub_59594(*(void **)(a1 + 4));
    v20 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v20;
    v21 = dword_6CB74[v20];
    v7 = (char *)sub_5956C(8 * v21);
    *(_DWORD *)(a1 + 4) = v7;
    if ( !v7 )
      return -1;
    v6 = dword_6CB74[*(_DWORD *)(a1 + 8)];
    if ( v6 )
    {
      v22 = a1 + 12;
      v23 = 0;
      do
      {
        *(_DWORD *)&v7[v23 + 4] = v22;
        *(_DWORD *)&v7[v23] = v22;
        v23 += 8;
      }
      while ( v23 != 8 * v6 );
    }
    else
    {
      v22 = a1 + 12;
    }
    v24 = *(_DWORD **)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v22;
    *(_DWORD *)(a1 + 16) = v22;
    if ( v24 != (_DWORD *)v22 )
    {
      while ( 1 )
      {
        v25 = *(v24 - 1) % v21;
        v26 = v24;
        v24 = (_DWORD *)v24[1];
        sub_578C0(a1, (int)&v7[8 * v25], v26);
        if ( (_DWORD *)v22 == v24 )
          break;
        v7 = *(char **)(a1 + 4);
      }
      v7 = *(char **)(a1 + 4);
      v6 = dword_6CB74[*(_DWORD *)(a1 + 8)];
    }
  }
  else
  {
    v7 = *(char **)(a1 + 4);
  }
  v8 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v9 = a2;
    v10 = 5381;
    do
    {
      v11 = v8 + 32 * v10;
      v12 = (unsigned __int8)*++v9;
      v8 = v12;
      v10 += v11;
    }
    while ( v12 );
  }
  else
  {
    v10 = 5381;
  }
  v13 = (int *)&v7[8 * (v10 % v6)];
  v14 = sub_5791C(a1, v13, a2, v10);
  v15 = v14;
  if ( !v14 )
  {
    v27 = strlen(a2);
    v28 = sub_5956C(v27 + 21);
    v29 = v28;
    if ( v28 )
    {
      *(_DWORD *)v28 = v10;
      *((_DWORD *)v28 + 4) = a3;
      strcpy((char *)v28 + 20, a2);
      v29[2] = v29 + 1;
      v29[3] = a4;
      v29[1] = v29 + 1;
      sub_578C0(a1, (int)v13, v29 + 1);
      ++*(_DWORD *)a1;
      return 0;
    }
    return -1;
  }
  v16 = *(_DWORD *)(v14 + 12);
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4);
    if ( v17 != -1 )
    {
      v18 = v17 - 1;
      *(_DWORD *)(v16 + 4) = v18;
      if ( !v18 )
        sub_5A3E4((void **)v16);
    }
  }
  *(_DWORD *)(v15 + 12) = a4;
  return 0;
}
// 6CB74: using guessed type _DWORD dword_6CB74[29];

//----- (00057C94) --------------------------------------------------------
int __fastcall sub_57C94(int a1, char *a2)
{
  int v2; // r3
  char *v3; // r12
  unsigned int v4; // r4
  int v5; // lr
  int v6; // t1
  int result; // r0

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v3 = a2;
    v4 = 5381;
    do
    {
      v5 = v2 + 32 * v4;
      v6 = (unsigned __int8)*++v3;
      v2 = v6;
      v4 += v5;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  result = sub_5791C(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v4 % dword_6CB74[*(_DWORD *)(a1 + 8)])), a2, v4);
  if ( result )
    return *(_DWORD *)(result + 12);
  return result;
}
// 6CB74: using guessed type _DWORD dword_6CB74[29];

//----- (00057D0C) --------------------------------------------------------
int __fastcall sub_57D0C(_DWORD *a1, char *a2)
{
  int v2; // r3
  char *v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  int v7; // t1
  int v8; // r7
  int *v9; // r6
  int v10; // r8
  _DWORD *v11; // r0
  _DWORD *v12; // r4
  _DWORD *v13; // r3
  int v14; // r2
  int v15; // r3
  int v16; // r0
  int v17; // r3
  int v18; // r3
  _DWORD *v20; // r3

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v4 = a2;
    v5 = 5381;
    do
    {
      v6 = v2 + 32 * v5;
      v7 = (unsigned __int8)*++v4;
      v2 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  else
  {
    v5 = 5381;
  }
  v8 = a1[1];
  v9 = (int *)(v8 + 8 * (v5 % dword_6CB74[a1[2]]));
  v10 = v5 % dword_6CB74[a1[2]];
  v11 = (_DWORD *)sub_5791C((int)a1, v9, a2, v5);
  v12 = v11;
  if ( !v11 )
    return -1;
  v13 = v11 + 1;
  v14 = v9[1];
  if ( v11 + 1 == *(_DWORD **)(v8 + 8 * v10) )
  {
    if ( v13 == (_DWORD *)v14 )
    {
      v20 = a1 + 3;
      v9[1] = (int)(a1 + 3);
    }
    else
    {
      v20 = (_DWORD *)v11[2];
    }
    *(_DWORD *)(v8 + 8 * v10) = v20;
  }
  else if ( v13 == (_DWORD *)v14 )
  {
    v9[1] = v11[1];
  }
  v15 = v11[1];
  v16 = v11[3];
  *(_DWORD *)(v15 + 4) = v12[2];
  *(_DWORD *)v12[2] = v15;
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4);
    if ( v17 != -1 )
    {
      v18 = v17 - 1;
      *(_DWORD *)(v16 + 4) = v18;
      if ( !v18 )
        sub_5A3E4((void **)v16);
    }
  }
  sub_59594(v12);
  --*a1;
  return 0;
}
// 6CB74: using guessed type _DWORD dword_6CB74[29];

//----- (00057E28) --------------------------------------------------------
void __fastcall sub_57E28(_DWORD *a1)
{
  int v2; // r4
  int v3; // r1
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r3

  sub_57994((int)a1);
  v2 = dword_6CB74[a1[2]];
  if ( v2 )
  {
    v3 = a1[1];
    v4 = 8 * v2;
    v5 = a1 + 3;
    v6 = 0;
    do
    {
      *(_DWORD *)(v3 + v6 + 4) = v5;
      *(_DWORD *)(v3 + v6) = v5;
      v6 += 8;
    }
    while ( v6 != v4 );
  }
  else
  {
    v5 = a1 + 3;
  }
  a1[4] = v5;
  a1[3] = v5;
  *a1 = 0;
}
// 6CB74: using guessed type _DWORD dword_6CB74[29];

//----- (00057EA4) --------------------------------------------------------
int __fastcall sub_57EA4(int a1, char *a2)
{
  int v2; // r3
  char *v3; // r12
  unsigned int v4; // r4
  int v5; // lr
  int v6; // t1
  int result; // r0

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v3 = a2;
    v4 = 5381;
    do
    {
      v5 = v2 + 32 * v4;
      v6 = (unsigned __int8)*++v3;
      v2 = v6;
      v4 += v5;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  result = sub_5791C(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v4 % dword_6CB74[*(_DWORD *)(a1 + 8)])), a2, v4);
  if ( result )
    result += 4;
  return result;
}
// 6CB74: using guessed type _DWORD dword_6CB74[29];

//----- (00057F3C) --------------------------------------------------------
int __fastcall sub_57F3C(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00057F4C) --------------------------------------------------------
void __fastcall sub_57F4C(int a1, int a2)
{
  int v3; // r0
  int v5; // r2
  int v6; // r2

  v3 = *(_DWORD *)(a1 + 8);
  if ( !v3 || (v5 = *(_DWORD *)(v3 + 4), v5 == -1) || (v6 = v5 - 1, (*(_DWORD *)(v3 + 4) = v6) != 0) )
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  else
  {
    sub_5A3E4((void **)v3);
    *(_DWORD *)(a1 + 8) = a2;
  }
}

//----- (00057F94) --------------------------------------------------------
int __fastcall sub_57F94(_DWORD *a1)
{
  int v1; // r2
  int result; // r0

  v1 = a1[1];
  result = *(unsigned __int8 *)(*a1 + v1);
  if ( !result )
    return -1;
  a1[1] = v1 + 1;
  return result;
}

//----- (00057FB4) --------------------------------------------------------
int __fastcall sub_57FB4(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r2
  int v3; // r3

  v1 = a1[2];
  if ( v1 >= a1[1] )
    return -1;
  v2 = v1 + 1;
  v3 = *(unsigned __int8 *)(*a1 + v1);
  a1[2] = v2;
  return v3;
}

//----- (00057FD8) --------------------------------------------------------
int __fastcall sub_57FD8(_DWORD *a1)
{
  unsigned int v1; // r3
  int result; // r0
  int (__fastcall *v4)(_DWORD *, int, _DWORD); // r3
  int v5; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_2;
  v4 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v5 = v4(a1, 1024, a1[259]);
  a1[256] = v5;
  if ( (unsigned int)(v5 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_2:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (00058034) --------------------------------------------------------
int sub_58034(int result, _DWORD *a2, const char *a3, ...)
{
  int v3; // r5
  const char *v5; // r0
  int v6; // r10
  int v7; // r6
  int v8; // r8
  char *v9; // r3
  char s[160]; // [sp+10h] [bp-144h] BYREF
  char v11[159]; // [sp+B0h] [bp-A4h] BYREF
  char v12; // [sp+14Fh] [bp-5h]
  const char *varg_r2; // [sp+170h] [bp+1Ch]
  va_list varg_r3; // [sp+174h] [bp+20h] BYREF

  va_start(varg_r3, a3);
  varg_r2 = a3;
  v3 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r2, varg_r3);
    s[159] = 0;
    if ( a2 )
    {
      v5 = (const char *)sub_59694((int)(a2 + 10));
      v6 = a2[6];
      v7 = a2[7];
      v8 = a2[9];
      if ( v5 && *v5 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v11, 0xA0u, "%s near '%s'", s, v5);
          v9 = v11;
          v12 = 0;
        }
        else
        {
          v9 = s;
        }
      }
      else
      {
        v9 = s;
        if ( a2[5] != -2 )
        {
          snprintf(v11, 0xA0u, "%s near end of file", s);
          v9 = v11;
          v12 = 0;
        }
      }
    }
    else
    {
      v7 = -1;
      v9 = s;
      v8 = 0;
      v6 = -1;
    }
    return sub_5B098(v3, v6, v7, v8, (char *)"%s", v9);
  }
  return result;
}

//----- (00058154) --------------------------------------------------------
int __fastcall sub_58154(int a1, int a2, int a3)
{
  int result; // r0
  int v5; // r3
  bool v6; // zf

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 24) = 1;
  result = sub_5961C((_DWORD *)(a1 + 40));
  v6 = result == 0;
  if ( result )
    result = -1;
  else
    v5 = -1;
  if ( v6 )
    *(_DWORD *)(a1 + 52) = v5;
  return result;
}
// 58198: variable 'v5' is possibly undefined

//----- (000581A0) --------------------------------------------------------
void __fastcall sub_581A0(int a1)
{
  if ( *(_DWORD *)(a1 + 52) == 256 )
    sub_59594(*(void **)(a1 + 56));
  sub_59654(a1 + 40);
}

//----- (000581CC) --------------------------------------------------------
int __fastcall sub_581CC(_BYTE *a1)
{
  int v1; // r1
  int i; // r3
  int v3; // r2
  int v4; // r4
  int v5; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x120u, "decode_unicode_escape");
  v1 = 0;
  for ( i = 1; i != 5; ++i )
  {
    v3 = (unsigned __int8)a1[i];
    v4 = 16 * v1;
    v5 = v3 - 48;
    if ( (unsigned __int8)(v3 - 48) <= 9u )
      goto LABEL_7;
    if ( (unsigned int)(v3 - 97) <= 0x19 )
    {
      v5 = v3 - 87;
LABEL_7:
      v1 = v5 + v4;
      continue;
    }
    if ( (unsigned int)(v3 - 65) > 0x19 )
      _assert_fail(word_63C1C, "load.c", 0x12Cu, "decode_unicode_escape");
    v1 = v3 - 55 + v4;
  }
  return v1;
}

//----- (00058274) --------------------------------------------------------
_DWORD *__fastcall sub_58274(_DWORD *result, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r3

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      v6 = result[6];
      result[7] = result[8];
      result[6] = v6 - 1;
    }
    else
    {
      result = (_DWORD *)sub_59AC4((unsigned __int8)a2);
      if ( result )
        --v3[7];
    }
    v4 = v3[4];
    if ( !v4 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xE0u, "stream_unget");
    v5 = v4 - 1;
    v3[4] = v5;
    if ( *((unsigned __int8 *)v3 + v5 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (0005832C) --------------------------------------------------------
int __fastcall sub_5832C(int a1, int a2)
{
  int v3; // r5
  int v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r7
  bool v13; // cc
  int v14; // r0
  int v15; // r10
  int v16; // r5
  int v17; // r8
  int v18; // r1
  int v19; // r3

  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
    return v3;
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(unsigned __int8 *)(a1 + v5 + 8);
  if ( v6 )
  {
    v7 = v5 + 1;
    goto LABEL_5;
  }
  v6 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v12 = v6;
  if ( v6 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return -1;
  }
  *(_DWORD *)(a1 + 16) = 0;
  v13 = (unsigned int)(v6 - 128) > 0x7F;
  v6 = (unsigned __int8)v6;
  if ( v13 )
    *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 8) = v6;
  if ( v13 )
  {
    v7 = 1;
  }
  else
  {
    v14 = sub_59AC4((unsigned __int8)v6);
    v15 = v14;
    if ( !v14 )
      goto LABEL_23;
    if ( v14 <= 1 )
      _assert_fail("count >= 2", "load.c", 0xAFu, "stream_get");
    v16 = a1;
    v17 = a1 - 1 + v14;
    do
    {
      *(_BYTE *)(v16 + 9) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
      ++v16;
    }
    while ( v16 != v17 );
    if ( !sub_59B40((char *)(a1 + 8), v15, 0) )
    {
LABEL_23:
      v3 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_58034(a2, (_DWORD *)a1, "unable to decode byte 0x%x", v12);
      return v3;
    }
    v18 = *(_DWORD *)(a1 + 16);
    v19 = a1 + v18;
    *(_BYTE *)(a1 + v15 + 8) = 0;
    v7 = v18 + 1;
    v6 = *(unsigned __int8 *)(v19 + 8);
  }
LABEL_5:
  v8 = *(_DWORD *)(a1 + 36);
  v3 = v6;
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 36) = v8 + 1;
  if ( v6 != 10 )
  {
    if ( sub_59AC4(v6) )
      ++*(_DWORD *)(a1 + 28);
    return v3;
  }
  v10 = *(_DWORD *)(a1 + 28);
  v11 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = v10;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  return 10;
}

//----- (000584B0) --------------------------------------------------------
_DWORD *__fastcall sub_584B0(_DWORD *result, int a2)
{
  _DWORD *v3; // r5
  int v4; // r1
  int v5; // r2

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    sub_58274(result, a2);
    result = (_DWORD *)sub_597C0(v3 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}
// 584D0: variable 'v4' is possibly undefined
// 584D0: variable 'v5' is possibly undefined

//----- (000584FC) --------------------------------------------------------
int __fastcall sub_584FC(int a1, int a2)
{
  int v3; // r4

  v3 = sub_5832C(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    DataWriter::WriteByte((const void **)(a1 + 40), v3);
  return v3;
}

//----- (0005852C) --------------------------------------------------------
unsigned int __fastcall sub_5852C(int a1, int a2)
{
  const void **v2; // r7
  int v5; // r0
  bool v6; // zf
  unsigned int v7; // r4
  bool v8; // zf
  bool v9; // zf
  bool v10; // zf
  bool v11; // zf
  bool v12; // cc
  unsigned __int8 i; // r1
  int v14; // r2
  int v15; // r3
  int v17; // r0
  const char *v18; // r4
  int v19; // r0
  bool v20; // zf
  const char *v21; // r4
  int *v22; // r7
  __int64 v23; // r2
  int v24; // r0
  int v25; // r1
  unsigned int v26; // r4
  int v27; // r0
  bool v28; // zf
  bool v29; // zf
  bool v30; // zf
  double v31; // r2
  bool v32; // zf
  int v33; // r8
  bool v34; // cc
  _BYTE *v35; // r0
  _BYTE *v36; // r8
  unsigned __int8 *v37; // r7
  int v38; // r2
  unsigned int v39; // r2
  int v40; // r0
  int v41; // r2
  int v42; // r0
  int v43; // r0
  int v44; // [sp+8h] [bp-24h]
  int v45; // [sp+Ch] [bp-20h]
  _BYTE src[4]; // [sp+14h] [bp-18h] BYREF
  size_t n; // [sp+18h] [bp-14h] BYREF
  char *endptr; // [sp+1Ch] [bp-10h] BYREF
  double v49; // [sp+20h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  sub_59680(a1 + 40);
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    sub_59594(*(void **)(a1 + 56));
    *(_DWORD *)(a1 + 56) = 0;
  }
  while ( 1 )
  {
    v5 = sub_5832C(a1, a2);
    v6 = v5 == 32;
    if ( v5 != 32 )
      v6 = v5 == 9;
    v7 = v5;
    if ( !v6 )
    {
      v8 = v5 == 10;
      if ( v5 != 10 )
        v8 = v5 == 13;
      if ( !v8 )
        break;
    }
  }
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 52) = 0;
    return 0;
  }
  if ( v5 == -2 )
  {
LABEL_33:
    v7 = -1;
LABEL_34:
    *(_DWORD *)(a1 + 52) = v7;
    return v7;
  }
  DataWriter::WriteByte(v2, v5);
  v9 = v7 == 123;
  if ( v7 != 123 )
    v9 = v7 == 125;
  if ( v9 )
    goto LABEL_34;
  v10 = v7 == 91;
  if ( v7 != 91 )
    v10 = v7 == 93;
  if ( v10 )
    goto LABEL_34;
  v11 = v7 == 58;
  if ( v7 != 58 )
    v11 = v7 == 44;
  if ( v11 )
    goto LABEL_34;
  if ( v7 != 34 )
  {
    v12 = v7 > 0x2D;
    if ( v7 != 45 )
      v12 = v7 - 48 > 9;
    if ( !v12 )
    {
      *(_DWORD *)(a1 + 52) = -1;
      if ( v7 == 45 )
        v7 = sub_584FC(a1, a2);
      if ( v7 == 48 )
      {
        v19 = sub_584FC(a1, a2);
        if ( (unsigned int)(v19 - 48) <= 9 )
          goto LABEL_97;
      }
      else
      {
        if ( v7 - 48 > 9 )
        {
          sub_584B0((_DWORD *)a1, v7);
          return *(_DWORD *)(a1 + 52);
        }
        do
          v19 = sub_584FC(a1, a2);
        while ( (unsigned int)(v19 - 48) <= 9 );
      }
      v20 = v19 == 69;
      if ( v19 != 69 )
        v20 = v19 == 46;
      if ( v20 )
      {
        if ( v19 == 46 )
        {
          v43 = sub_5832C(a1, a2);
          if ( (unsigned int)(v43 - 48) > 9 )
          {
            sub_58274((_DWORD *)a1, v43);
            return *(_DWORD *)(a1 + 52);
          }
          DataWriter::WriteByte(v2, v43);
          do
            v19 = sub_584FC(a1, a2);
          while ( (unsigned int)(v19 - 48) <= 9 );
        }
        if ( (v19 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_79;
      }
      else if ( v19 != 101 )
      {
        sub_584B0((_DWORD *)a1, v19);
        v21 = (const char *)sub_59694((int)v2);
        v22 = _errno_location();
        *v22 = 0;
        v23 = strtoll(v21, &endptr, 10);
        if ( *v22 == 34 )
        {
          if ( v23 >= 0 )
            sub_58034(a2, (_DWORD *)a1, "too big integer");
          else
            sub_58034(a2, (_DWORD *)a1, "too big negative integer");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          if ( endptr != &v21[*(_DWORD *)(a1 + 44)] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x206u, "lex_scan_number");
          *(_QWORD *)(a1 + 56) = v23;
          v7 = 257;
          *(_DWORD *)(a1 + 52) = 257;
        }
        return v7;
      }
      v19 = sub_584FC(a1, a2);
      v32 = v19 == 43;
      if ( v19 != 43 )
        v32 = v19 == 45;
      if ( v32 )
        v19 = sub_584FC(a1, a2);
      if ( (unsigned int)(v19 - 48) <= 9 )
      {
        do
          v19 = sub_584FC(a1, a2);
        while ( (unsigned int)(v19 - 48) <= 9 );
LABEL_79:
        sub_584B0((_DWORD *)a1, v19);
        if ( sub_597E8((int)v2, &v49) )
        {
          sub_58034(a2, (_DWORD *)a1, "real number overflow");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          v31 = v49;
          v7 = 258;
          *(_DWORD *)(a1 + 52) = 258;
          *(double *)(a1 + 56) = v31;
        }
        return v7;
      }
LABEL_97:
      sub_584B0((_DWORD *)a1, v19);
      return *(_DWORD *)(a1 + 52);
    }
    if ( (v7 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v17 = sub_584FC(a1, a2);
      while ( (v17 & 0xFFFFFFDF) - 65 <= 0x19 );
      sub_584B0((_DWORD *)a1, v17);
      v18 = (const char *)sub_59694((int)v2);
      if ( !strcmp(v18, "true") )
      {
        v7 = 259;
        *(_DWORD *)(a1 + 52) = 259;
        return v7;
      }
      if ( !strcmp(v18, "false") )
      {
        v7 = 260;
        *(_DWORD *)(a1 + 52) = 260;
        return v7;
      }
      if ( !strcmp(v18, "null") )
      {
        v7 = 261;
        *(_DWORD *)(a1 + 52) = 261;
        return v7;
      }
    }
    else
    {
      for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v15 + 8) )
      {
        DataWriter::WriteByte(v2, i);
        v14 = *(_DWORD *)(a1 + 36);
        v15 = *(_DWORD *)(a1 + 16) + 1;
        *(_DWORD *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) = v14 + 1;
      }
    }
    goto LABEL_33;
  }
  v24 = a1;
  v25 = a2;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 52) = -1;
LABEL_58:
  v26 = sub_584FC(v24, v25);
LABEL_59:
  while ( v26 != 34 )
  {
    if ( v26 == -2 )
      goto LABEL_104;
    if ( v26 == -1 )
    {
      sub_58034(a2, (_DWORD *)a1, "premature end of input");
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v24 = a1;
    if ( v26 <= 0x1F )
    {
      sub_584B0((_DWORD *)a1, v26);
      if ( v26 == 10 )
        sub_58034(a2, (_DWORD *)a1, "unexpected newline");
      else
        sub_58034(a2, (_DWORD *)a1, "control character 0x%x", v26);
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v25 = a2;
    if ( v26 != 92 )
      goto LABEL_58;
    v27 = sub_584FC(a1, a2);
    if ( v27 == 117 )
    {
      v33 = 4;
      v26 = sub_584FC(a1, a2);
      while ( 1 )
      {
        v34 = v26 - 65 > 5;
        if ( v26 - 65 > 5 )
          v34 = v26 - 48 > 9;
        if ( v34 && v26 - 97 > 5 )
          break;
        --v33;
        v26 = sub_584FC(a1, a2);
        if ( !v33 )
          goto LABEL_59;
      }
LABEL_149:
      sub_58034(a2, (_DWORD *)a1, "invalid escape");
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v28 = v27 == 34;
    if ( v27 != 34 )
      v28 = v27 == 92;
    if ( !v28 )
    {
      v29 = v27 == 47;
      if ( v27 != 47 )
        v29 = v27 == 98;
      if ( !v29 && (v27 & 0xFFFFFFF7) != 0x66 )
      {
        v30 = v27 == 114;
        if ( v27 != 114 )
          v30 = v27 == 116;
        if ( !v30 )
          goto LABEL_149;
      }
    }
    v26 = sub_584FC(a1, a2);
  }
  v35 = sub_5956C(*(_DWORD *)(a1 + 44) + 1);
  v36 = v35;
  *(_DWORD *)(a1 + 56) = v35;
  if ( !v35 )
    goto LABEL_102;
  v37 = (unsigned __int8 *)(sub_59694((int)v2) + 1);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v38 = *v37;
        if ( v38 == 34 )
        {
          v7 = 256;
          *v36 = 0;
          *(_DWORD *)(a1 + 52) = 256;
          return v7;
        }
        if ( v38 == 92 )
          break;
        *v36++ = v38;
        ++v37;
      }
      v39 = v37[1];
      if ( v39 == 117 )
        break;
      if ( v39 == 102 )
      {
        *v36 = 12;
        goto LABEL_122;
      }
      if ( v39 > 0x66 )
      {
        switch ( v39 )
        {
          case 'r':
            *v36 = 13;
            break;
          case 't':
            *v36 = 9;
            break;
          case 'n':
            *v36 = 10;
            break;
          default:
            goto LABEL_117;
        }
      }
      else
      {
        if ( v39 == 92 )
          goto LABEL_135;
        if ( v39 <= 0x5C )
        {
          if ( v39 != 34 && v39 != 47 )
LABEL_117:
            _assert_fail(word_63C1C, "load.c", 0x1BCu, "lex_scan_string");
LABEL_135:
          *v36 = v39;
          goto LABEL_122;
        }
        if ( v39 != 98 )
          goto LABEL_117;
        *v36 = 8;
      }
LABEL_122:
      ++v36;
      v37 += 2;
    }
    v40 = sub_581CC(v37 + 1);
    v41 = v40;
    if ( (unsigned int)(v40 - 55296) > 0x3FF )
      break;
    if ( v37[6] != 92 || v37[7] != 117 )
    {
LABEL_103:
      sub_58034(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X'", v40);
      goto LABEL_104;
    }
    v44 = v40 - 55296;
    v45 = v40;
    v42 = sub_581CC(v37 + 7);
    v37 += 12;
    if ( (unsigned int)(v42 - 56320) > 0x3FF )
    {
      sub_58034(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X\\u%04X'", v45, v42);
      goto LABEL_104;
    }
    v41 = v42 - 56320 + (v44 << 10) + 0x10000;
LABEL_131:
    if ( sub_599DC(v41, src, &n) )
      _assert_fail(word_63C1C, "load.c", 0x1AEu, "lex_scan_string");
    memcpy(v36, src, n);
    v36 += n;
  }
  if ( (unsigned int)(v40 - 56320) <= 0x3FF )
    goto LABEL_103;
  if ( v40 )
  {
    v37 += 6;
    goto LABEL_131;
  }
  sub_58034(a2, (_DWORD *)a1, "\\u0000 is not allowed");
LABEL_104:
  v35 = *(_BYTE **)(a1 + 56);
LABEL_102:
  sub_59594(v35);
  return *(_DWORD *)(a1 + 52);
}
// 5852C: too many cbuild loops

//----- (00058D00) --------------------------------------------------------
int *__fastcall sub_58D00(double a1, int a2)
{
  int v2; // r4
  int v3; // r3
  int v4; // r8
  int *v6; // r7
  int v8; // r3
  void *v9; // r10
  int v10; // r0
  int *v11; // r6
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int *v19; // r0
  int v20; // r3
  int v21; // r3
  void **v22; // r0
  double v23; // r0
  int v24; // r3
  int v25; // r3
  double v26; // [sp+0h] [bp-Ch] BYREF

  v2 = LODWORD(a1);
  v3 = *(_DWORD *)(LODWORD(a1) + 52);
  LODWORD(a1) = 257;
  v4 = HIDWORD(a1);
  if ( v3 != 257 )
  {
    if ( v3 > 257 )
    {
      if ( v3 == 259 )
        return (int *)sub_5A3C0();
      if ( v3 < 259 )
        return (int *)sub_5A29C(a1);
      if ( v3 == 260 )
        return (int *)sub_5A3CC();
      if ( v3 == 261 )
        return (int *)sub_5A3D8();
LABEL_7:
      v6 = 0;
      sub_58034(a2, (_DWORD *)v2, "unexpected token");
      return v6;
    }
    if ( v3 == 91 )
    {
      v6 = sub_59F80();
      if ( v6 )
      {
        sub_5852C(v2, a2);
        v16 = *(_DWORD *)(v2 + 52);
        if ( v16 == 93 )
          return v6;
        if ( v16 )
        {
          while ( 1 )
          {
            v19 = (int *)sub_58D00(v2, v4, a2);
            v11 = v19;
            if ( !v19 )
              break;
            if ( v19[1] != -1 )
              ++v19[1];
            if ( sub_5A6E8(v6, v19) )
            {
              v24 = v11[1];
              if ( v24 != -1 )
              {
LABEL_60:
                v25 = v24 - 1;
                v11[1] = v25;
                if ( !v25 )
                  sub_5A3E4((void **)v11);
              }
              goto LABEL_49;
            }
            v17 = v11[1];
            if ( v17 != -1 )
            {
              v11[1] = v17 - 1;
              if ( v17 == 1 )
                sub_5A3E4((void **)v11);
            }
            sub_5852C(v2, a2);
            v18 = *(_DWORD *)(v2 + 52);
            if ( v18 != 44 )
            {
              if ( v18 == 93 )
                return v6;
              goto LABEL_63;
            }
            sub_5852C(v2, a2);
            if ( !*(_DWORD *)(v2 + 52) )
              goto LABEL_63;
          }
        }
        else
        {
LABEL_63:
          sub_58034(a2, (_DWORD *)v2, "']' expected");
        }
        goto LABEL_49;
      }
    }
    else
    {
      if ( v3 <= 91 )
      {
        if ( v3 == -1 )
        {
          v6 = 0;
          sub_58034(a2, (_DWORD *)v2, "invalid token");
          return v6;
        }
        goto LABEL_7;
      }
      if ( v3 != 123 )
      {
        if ( v3 == 256 )
          return sub_5A0EC(*(const char **)(v2 + 56));
        goto LABEL_7;
      }
      v6 = sub_59DA8();
      if ( v6 )
      {
        sub_5852C(v2, a2);
        v8 = *(_DWORD *)(v2 + 52);
        if ( v8 == 125 )
          return v6;
        if ( v8 != 256 )
        {
LABEL_64:
          sub_58034(a2, (_DWORD *)v2, "string or '}' expected");
          goto LABEL_49;
        }
        v9 = *(void **)(v2 + 56);
        *(_DWORD *)(v2 + 56) = 0;
        if ( v9 )
        {
          while ( 1 )
          {
            if ( (v4 & 1) != 0 && sub_59E20(v6, (char *)v9) )
            {
              sub_59594(v9);
              sub_58034(a2, (_DWORD *)v2, "duplicate object key");
              goto LABEL_49;
            }
            sub_5852C(v2, a2);
            if ( *(_DWORD *)(v2 + 52) != 58 )
            {
              sub_59594(v9);
              sub_58034(a2, (_DWORD *)v2, "':' expected");
              goto LABEL_49;
            }
            sub_5852C(v2, a2);
            v10 = sub_58D00(v2, v4, a2);
            v11 = (int *)v10;
            if ( !v10 )
            {
              sub_59594(v9);
              goto LABEL_49;
            }
            v12 = *(_DWORD *)(v10 + 4);
            if ( v12 != -1 )
              *(_DWORD *)(v10 + 4) = v12 + 1;
            if ( sub_5A820(v6, (char *)v9, v10) )
            {
              sub_59594(v9);
              v24 = v11[1];
              if ( v24 != -1 )
                goto LABEL_60;
              goto LABEL_49;
            }
            v13 = v11[1];
            if ( v13 != -1 )
            {
              v14 = v13 - 1;
              v11[1] = v14;
              if ( !v14 )
                sub_5A3E4((void **)v11);
            }
            sub_59594(v9);
            sub_5852C(v2, a2);
            v15 = *(_DWORD *)(v2 + 52);
            if ( v15 != 44 )
              break;
            sub_5852C(v2, a2);
            if ( *(_DWORD *)(v2 + 52) != 256 )
              goto LABEL_64;
            v9 = *(void **)(v2 + 56);
            *(_DWORD *)(v2 + 56) = 0;
            if ( !v9 )
              return 0;
          }
          if ( v15 == 125 )
            return v6;
          sub_58034(a2, (_DWORD *)v2, "'}' expected");
LABEL_49:
          v20 = v6[1];
          if ( v20 != -1 )
          {
            v21 = v20 - 1;
            v6[1] = v21;
            if ( !v21 )
            {
              v22 = (void **)v6;
              v6 = 0;
              sub_5A3E4(v22);
              return v6;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( (BYTE4(a1) & 8) == 0 )
    return (int *)sub_5A21C(*(_QWORD *)(v2 + 56));
  LODWORD(v23) = sub_597E8(v2 + 40, &v26);
  if ( !LODWORD(v23) )
    return (int *)sub_5A29C(v23);
  v6 = 0;
  sub_58034(a2, (_DWORD *)v2, "real number overflow");
  return v6;
}
// 58D00: too many cbuild loops
// 59024: variable 'v23' is possibly undefined

//----- (00059154) --------------------------------------------------------
int *__fastcall sub_59154(_DWORD *a1, unsigned int a2, int a3)
{
  int *v6; // r7
  int v8; // r3
  int v9; // r3
  void **v10; // r0

  sub_5852C((int)a1, a3);
  v6 = (int *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[13] & 0xFFFFFFDF) != 0x5B )
  {
    sub_58034(a3, a1, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_58D00(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), a3);
  if ( !v6 )
    return 0;
  if ( (a2 & 2) == 0 )
  {
    sub_5852C((int)a1, a3);
    if ( a1[13] )
    {
      sub_58034(a3, a1, "end of file expected");
      v8 = v6[1];
      if ( v8 != -1 )
      {
        v9 = v8 - 1;
        v6[1] = v9;
        if ( !v9 )
        {
          v10 = (void **)v6;
          v6 = 0;
          sub_5A3E4(v10);
          return v6;
        }
      }
      return 0;
    }
  }
  if ( a3 )
    *(_DWORD *)(a3 + 8) = a1[9];
  return v6;
}

//----- (00059230) --------------------------------------------------------
int *__fastcall sub_59230(int *a1, unsigned int a2, char *a3)
{
  _DWORD v7[2]; // [sp+0h] [bp-48h] BYREF
  _DWORD v8[16]; // [sp+8h] [bp-40h] BYREF

  sub_5B014(a3, "<string>");
  if ( a1 )
  {
    v7[0] = a1;
    a1 = 0;
    v7[1] = 0;
    if ( !sub_58154((int)v8, (int)sub_57F94, (int)v7) )
    {
      a1 = sub_59154(v8, a2, (int)a3);
      sub_581A0((int)v8);
    }
  }
  else
  {
    sub_58034((int)a3, 0, "wrong arguments");
  }
  return a1;
}

//----- (000592C4) --------------------------------------------------------
int *__fastcall sub_592C4(int *a1, int a2, unsigned int a3, char *a4)
{
  _DWORD v9[3]; // [sp+4h] [bp-50h] BYREF
  _DWORD v10[17]; // [sp+10h] [bp-44h] BYREF

  sub_5B014(a4, "<buffer>");
  if ( a1 )
  {
    v9[0] = a1;
    v9[1] = a2;
    a1 = 0;
    v9[2] = 0;
    if ( !sub_58154((int)v10, (int)sub_57FB4, (int)v9) )
    {
      a1 = sub_59154(v10, a3, (int)a4);
      sub_581A0((int)v10);
    }
  }
  else
  {
    sub_58034((int)a4, 0, "wrong arguments");
  }
  return a1;
}

//----- (00059360) --------------------------------------------------------
int *__fastcall sub_59360(int *a1, unsigned int a2, char *a3)
{
  int *v5; // r4
  char *v6; // r1
  _DWORD v8[16]; // [sp+0h] [bp-40h] BYREF

  v5 = a1;
  if ( a1 == (int *)stdin )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_5B014(a3, v6);
  if ( v5 )
  {
    if ( sub_58154((int)v8, (int)fgetc, (int)v5) )
    {
      return 0;
    }
    else
    {
      v5 = sub_59154(v8, a2, (int)a3);
      sub_581A0((int)v8);
    }
  }
  else
  {
    sub_58034((int)a3, 0, "wrong arguments");
  }
  return v5;
}
// 76BC8: using guessed type int stdin;

//----- (0005940C) --------------------------------------------------------
int *__fastcall sub_5940C(char *a1, unsigned int a2, char *a3)
{
  FILE *v6; // r0
  FILE *v7; // r7
  int *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_5B014(a3, a1);
  if ( a1 )
  {
    v6 = fopen(a1, "rb");
    v7 = v6;
    if ( v6 )
    {
      v8 = sub_59360(&v6->_flags, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_58034((int)a3, 0, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_58034((int)a3, 0, "wrong arguments");
  }
  return v8;
}

//----- (0005956C) --------------------------------------------------------
void *__fastcall sub_5956C(size_t a1)
{
  if ( a1 )
    return off_76BA0(a1);
  else
    return 0;
}
// 76BA0: using guessed type void *(*off_76BA0)(size_t size);

//----- (00059594) --------------------------------------------------------
void __fastcall sub_59594(void *a1)
{
  if ( a1 )
    off_76BA4(a1);
}
// 76BA4: using guessed type void (*off_76BA4)(void *ptr);

//----- (000595B4) --------------------------------------------------------
void *__fastcall sub_595B4(const char *a1)
{
  size_t v2; // r0
  size_t v3; // r4
  void *v5; // r0
  void *v6; // r5

  v2 = strlen(a1);
  if ( v2 == -1 )
    return 0;
  v3 = v2 + 1;
  v5 = off_76BA0(v2 + 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  memcpy(v5, a1, v3);
  return v6;
}
// 76BA0: using guessed type void *(*off_76BA0)(size_t size);

//----- (0005960C) --------------------------------------------------------
void *(*__fastcall sub_5960C(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  off_76BA0 = result;
  off_76BA4 = a2;
  return result;
}
// 76BA0: using guessed type void *(*off_76BA0)(size_t size);
// 76BA4: using guessed type void (*off_76BA4)(void *ptr);

//----- (0005961C) --------------------------------------------------------
int __fastcall sub_5961C(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = sub_5956C(0x10u);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (00059654) --------------------------------------------------------
void __fastcall sub_59654(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    sub_59594(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (00059680) --------------------------------------------------------
int __fastcall sub_59680(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (00059694) --------------------------------------------------------
int __fastcall sub_59694(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0005969C) --------------------------------------------------------
int __fastcall sub_5969C(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (000596B0) --------------------------------------------------------
int __fastcall sub_596B0(const void **a1, void *src, size_t n)
{
  size_t v4; // r3
  int v6; // r0
  char *v8; // r6
  unsigned int v9; // r0
  size_t v10; // r8
  char *v11; // r0
  char *v12; // r2
  size_t v13; // r5

  v4 = (size_t)a1[1];
  v6 = (int)a1[2];
  if ( v6 - v4 > n )
  {
    v8 = (char *)*a1;
LABEL_10:
    memcpy(&v8[v4], src, n);
    v12 = (char *)*a1;
    v13 = (size_t)a1[1] + n;
    a1[1] = (const void *)v13;
    v12[v13] = 0;
    return 0;
  }
  if ( v6 >= 0 && n != -1 && v4 <= -2 - n )
  {
    v9 = 2 * v6;
    v10 = v4 + 1 + n;
    if ( v10 < v9 )
      v10 = v9;
    v11 = (char *)sub_5956C(v10);
    v8 = v11;
    if ( v11 )
    {
      memcpy(v11, *a1, (size_t)a1[1]);
      sub_59594((void *)*a1);
      v4 = (size_t)a1[1];
      *a1 = v8;
      a1[2] = (const void *)v10;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (00059774) --------------------------------------------------------
int __fastcall DataWriter::WriteByte(const void **this, unsigned __int8 a2)
{
  unsigned __int8 v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return sub_596B0(this, &v3, 1u);
}

//----- (00059798) --------------------------------------------------------
int __fastcall luaL_addstring(const void **a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  return sub_596B0(a1, s, v4);
}

//----- (000597C0) --------------------------------------------------------
int __fastcall sub_597C0(int *a1, int a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = v3 - 1;
    a1[1] = v3 - 1;
    a2 = *a1;
    LOBYTE(v3) = 0;
    result = *(unsigned __int8 *)(*a1 + a3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a2 + a3) = v3;
  return result;
}

//----- (000597E8) --------------------------------------------------------
int __fastcall sub_597E8(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x46u, "jsonp_strtod");
  if ( *v9 == 34 && v2 != 0.0 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 59868: variable 'v2' is possibly undefined

//----- (000598A8) --------------------------------------------------------
int __fastcall sub_598A8(char *a1, size_t a2)
{
  double v2; // d0
  int v5; // r0
  int v6; // r4
  int v7; // r6
  int v8; // r1
  char *v9; // r0
  char *v10; // r3
  char *v11; // r4
  char *v12; // r7
  char *v13; // r3

  v5 = snprintf(a1, a2, "%.17g", v2);
  v6 = v5;
  if ( v5 >= 0 )
  {
    v7 = v5;
    if ( a2 > v5 )
    {
      v8 = *(unsigned __int8 *)localeconv()->decimal_point;
      if ( v8 != 46 )
      {
        v9 = strchr(a1, v8);
        if ( v9 )
          *v9 = 46;
      }
      if ( strchr(a1, 46) )
      {
LABEL_7:
        v10 = strchr(a1, 101);
        if ( !v10 )
          return v7;
LABEL_8:
        v11 = v10 + 2;
        if ( v10[1] == 45 )
          v12 = v10 + 2;
        else
          v12 = v10 + 1;
        if ( v10[2] == 48 )
        {
          v13 = v10 + 3;
          do
            v11 = v13++;
          while ( *v11 == 48 );
        }
        if ( v11 != v12 )
        {
          memmove(v12, v11, a1 - v11 + v7);
          v7 += v12 - v11;
        }
        return v7;
      }
      v10 = strchr(a1, 101);
      if ( v10 )
        goto LABEL_8;
      if ( a2 > v6 + 3 )
      {
        v7 = v6 + 2;
        a1[v6] = 46;
        a1[v6 + 1] = 48;
        a1[v6 + 2] = 0;
        goto LABEL_7;
      }
    }
  }
  return -1;
}
// 598C0: variable 'v2' is possibly undefined

//----- (000599DC) --------------------------------------------------------
int __fastcall sub_599DC(int a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r12
  int v5; // r3

  if ( a1 >= 0 )
  {
    if ( a1 <= 127 )
    {
      *a2 = a1;
      *a3 = 1;
      return 0;
    }
    if ( a1 < 2048 )
    {
      *a2 = (((unsigned int)a1 >> 6) & 0x1F) - 64;
      a2[1] = (a1 & 0x3F) + 0x80;
      *a3 = 2;
      return 0;
    }
    if ( a1 < 0x10000 )
    {
      a2[1] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
      a2[2] = (a1 & 0x3F) + 0x80;
      *a2 = ((unsigned __int16)a1 >> 12) - 32;
      *a3 = 3;
      return 0;
    }
    if ( a1 < 1114112 )
    {
      v3 = ((unsigned int)a1 >> 18) & 7;
      v4 = ((unsigned int)a1 >> 12) & 0x3F;
      v5 = ((unsigned int)a1 >> 6) & 0x3F;
      a2[3] = (a1 & 0x3F) + 0x80;
      a2[2] = v5 + 0x80;
      *a2 = v3 - 16;
      a2[1] = v4 + 0x80;
      *a3 = 4;
      return 0;
    }
  }
  return -1;
}

//----- (00059AC4) --------------------------------------------------------
int __fastcall sub_59AC4(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x3F || (unsigned __int8)(a1 + 64) <= 1u )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) > 4u )
    return 0;
  return 4;
}

//----- (00059B40) --------------------------------------------------------
int __fastcall sub_59B40(char *a1, int a2, int *a3)
{
  char v3; // r4
  int v4; // r4
  int result; // r0
  int v6; // r12
  int v7; // r3
  bool v8; // zf
  bool v9; // zf
  _BOOL4 v10; // r0

  v3 = *a1;
  switch ( a2 )
  {
    case 2:
      v4 = v3 & 0x1F;
      break;
    case 3:
      v4 = v3 & 0xF;
      break;
    case 4:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = 1;
  while ( 1 )
  {
    ++v7;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v7 )
      break;
    v6 = (unsigned __int8)a1[v7];
    if ( (v6 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) <= 0x7FF )
    return 0;
  v8 = v4 == 127;
  if ( v4 <= 127 )
    v8 = a2 == 2;
  if ( v8 )
    return 0;
  result = 0;
  v9 = v4 == 2047;
  if ( v4 <= 2047 )
    v9 = a2 == 3;
  if ( !v9 )
  {
    v10 = v4 < 0x10000;
    if ( a2 != 4 )
      v10 = 0;
    if ( !v10 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00059C18) --------------------------------------------------------
char *__fastcall sub_59C18(char *a1, _DWORD *a2)
{
  char *v2; // r4
  int v3; // r5
  int v5; // r0
  int v6; // r6
  int v8; // [sp+4h] [bp-8h] BYREF

  v2 = a1;
  v3 = (unsigned __int8)*a1;
  if ( !*a1 )
    return v2;
  v5 = sub_59AC4((unsigned __int8)*a1);
  v6 = v5;
  if ( v5 <= 0 )
    return 0;
  if ( v5 == 1 )
  {
    v8 = v3;
    goto LABEL_6;
  }
  if ( !sub_59B40(v2, v5, &v8) )
    return 0;
LABEL_6:
  v2 += v6;
  if ( a2 )
    *a2 = v8;
  return v2;
}

//----- (00059C8C) --------------------------------------------------------
int __fastcall sub_59C8C(const char *a1, signed int a2)
{
  signed int v2; // r8
  int v4; // r4
  int v5; // r5
  char *v6; // r0

  v2 = a2;
  if ( a2 == -1 )
    v2 = strlen(a1);
  if ( v2 <= 0 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_59AC4((unsigned __int8)a1[v4]);
    v6 = (char *)&a1[v4];
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( v2 < v4 + v5 )
        break;
      v4 += v5 - 1;
      if ( !sub_59B40(v6, v5, 0) )
        break;
    }
    if ( v2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (00059D20) --------------------------------------------------------
void *__fastcall sub_59D20(_DWORD *a1, int a2, int a3)
{
  unsigned int v5; // r3
  void *v6; // r5
  unsigned int v8; // r1
  unsigned int v9; // r3
  unsigned int v10; // r7
  void *v11; // r0

  v5 = a1[2];
  if ( a2 + a1[3] <= v5 )
    return (void *)a1[4];
  v8 = a2 + v5;
  v9 = 2 * v5;
  if ( v8 < v9 )
    v10 = v9;
  else
    v10 = v8;
  v6 = (void *)a1[4];
  v11 = sub_5956C(4 * v10);
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( a3 )
  {
    memcpy(v11, v6, 4 * a1[3]);
    sub_59594(v6);
    return (void *)a1[4];
  }
  return v6;
}

//----- (00059DA8) --------------------------------------------------------
_DWORD *sub_59DA8()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4

  v0 = sub_5956C(0x24u);
  v1 = v0;
  if ( !v0 )
    return 0;
  v0[1] = 1;
  *v0 = 0;
  if ( sub_579F4(v0 + 2) )
  {
    sub_59594(v1);
    return 0;
  }
  else
  {
    v1[7] = 0;
    v1[8] = 0;
    return v1;
  }
}

//----- (00059E04) --------------------------------------------------------
_DWORD *__fastcall sub_59E04(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (00059E20) --------------------------------------------------------
int __fastcall sub_59E20(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_57C94((int)(a1 + 2), a2);
}

//----- (00059E44) --------------------------------------------------------
int __fastcall sub_59E44(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return -1;
  else
    return sub_57D0C(a1 + 2, a2);
}

//----- (00059E68) --------------------------------------------------------
int __fastcall sub_59E68(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  sub_57E28(a1 + 2);
  a1[7] = 0;
  return 0;
}

//----- (00059E9C) --------------------------------------------------------
_DWORD *__fastcall sub_59E9C(_DWORD *a1)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r0
  _DWORD *result; // r0

  if ( !a1 || *a1 )
    return 0;
  v2 = a1 + 2;
  v1 = v2 + 3;
  result = (_DWORD *)v2[4];
  if ( result == v1 )
    return 0;
  return result;
}

//----- (00059EC0) --------------------------------------------------------
int __fastcall sub_59EC0(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_57EA4((int)(a1 + 2), a2);
}

//----- (00059EE8) --------------------------------------------------------
int __fastcall sub_59EE8(_DWORD *a1, int a2)
{
  if ( !a1 || *a1 || !a2 )
    return 0;
  if ( *(_DWORD **)(a2 + 4) == a1 + 5 )
    return 0;
  return *(_DWORD *)(a2 + 4);
}

//----- (00059F14) --------------------------------------------------------
int __fastcall sub_59F14(int result)
{
  if ( result )
    result += 16;
  return result;
}

//----- (00059F20) --------------------------------------------------------
int __fastcall sub_59F20(int result)
{
  if ( result )
    return *(_DWORD *)(result + 8);
  return result;
}

//----- (00059F2C) --------------------------------------------------------
int __fastcall sub_59F2C(_DWORD *a1, int a2, int a3)
{
  bool v3; // zf

  if ( !a1 || *a1 )
    return -1;
  v3 = a2 == 0;
  if ( a2 )
    v3 = a3 == 0;
  if ( v3 )
    return -1;
  sub_57F4C(a2, a3);
  return 0;
}

//----- (00059F74) --------------------------------------------------------
int __fastcall sub_59F74(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (00059F80) --------------------------------------------------------
_DWORD *sub_59F80()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r5

  v0 = sub_5956C(0x18u);
  v1 = v0;
  if ( !v0 )
    return 0;
  *v0 = 1;
  v0[1] = 1;
  v0[3] = 0;
  v0[2] = 8;
  v2 = sub_5956C(0x20u);
  v1[4] = v2;
  if ( v2 )
  {
    v1[5] = 0;
    return v1;
  }
  else
  {
    sub_59594(v1);
    return 0;
  }
}

//----- (00059FEC) --------------------------------------------------------
_DWORD *__fastcall sub_59FEC(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (0005A008) --------------------------------------------------------
_DWORD *__fastcall sub_5A008(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (0005A03C) --------------------------------------------------------
int __fastcall sub_5A03C(_DWORD *a1, _DWORD *a2)
{
  size_t v4; // r2
  char *v5; // r1
  char *v6; // r0
  int v7; // r3
  int v8; // t1

  if ( !a1 || *a1 != 1 || !a2 || *a2 != 1 || !sub_59D20(a1, a2[3], 1) )
    return -1;
  v4 = a2[3];
  v5 = (char *)a2[4];
  if ( v4 )
  {
    v4 *= 4;
    v6 = (char *)a2[4];
    do
    {
      v8 = *(_DWORD *)v6;
      v6 += 4;
      v7 = v8;
      if ( v8 )
      {
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
      }
    }
    while ( v6 != &v5[v4] );
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), v5, v4);
  a1[3] += a2[3];
  return 0;
}

//----- (0005A0EC) --------------------------------------------------------
_DWORD *__fastcall sub_5A0EC(const char *a1)
{
  _DWORD *v2; // r4
  void *v3; // r5
  _DWORD *result; // r0

  if ( !a1 )
    return 0;
  v2 = sub_5956C(0xCu);
  if ( !v2 )
    return 0;
  *v2 = 2;
  v2[1] = 1;
  v3 = sub_595B4(a1);
  result = v2;
  v2[2] = v3;
  if ( !v3 )
  {
    sub_59594(v2);
    return 0;
  }
  return result;
}

//----- (0005A148) --------------------------------------------------------
_DWORD *__fastcall sub_5A148(const char *a1)
{
  if ( a1 && sub_59C8C(a1, -1) )
    return sub_5A0EC(a1);
  else
    return 0;
}

//----- (0005A178) --------------------------------------------------------
_DWORD *__fastcall sub_5A178(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (0005A194) --------------------------------------------------------
int __fastcall sub_5A194(int a1, const char *a2)
{
  void *v3; // r5

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 )
    return -1;
  if ( !a2 )
    return -1;
  v3 = sub_595B4(a2);
  if ( !v3 )
    return -1;
  sub_59594(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v3;
  return 0;
}

//----- (0005A1E0) --------------------------------------------------------
int __fastcall sub_5A1E0(int a1, const char *a2)
{
  if ( a2 && sub_59C8C(a2, -1) )
    return sub_5A194(a1, a2);
  else
    return -1;
}

//----- (0005A21C) --------------------------------------------------------
_QWORD *__fastcall sub_5A21C(__int64 a1)
{
  _QWORD *result; // r0

  result = sub_5956C(0x10u);
  if ( result )
  {
    result[1] = a1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (0005A248) --------------------------------------------------------
__int64 __fastcall sub_5A248(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (0005A274) --------------------------------------------------------
int __fastcall sub_5A274(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (0005A29C) --------------------------------------------------------
_QWORD *__fastcall sub_5A29C(double a1)
{
  __int64 v1; // d0
  double v2; // r0
  _QWORD *result; // r0

  LODWORD(v2) = _isnan(a1);
  if ( LODWORD(v2) )
    return 0;
  if ( _isinf(v2) )
    return 0;
  result = sub_5956C(0x10u);
  if ( !result )
    return 0;
  result[1] = v1;
  *(_DWORD *)result = 4;
  *((_DWORD *)result + 1) = 1;
  return result;
}
// 5A2B8: variable 'v2' is possibly undefined
// 5A2E0: variable 'v1' is possibly undefined

//----- (0005A2F8) --------------------------------------------------------
void sub_5A2F8()
{
  ;
}

//----- (0005A328) --------------------------------------------------------
int __fastcall sub_5A328(double a1)
{
  __int64 v1; // d0
  int v2; // r4
  double v3; // r0
  int result; // r0

  v2 = LODWORD(a1);
  if ( !LODWORD(a1) )
    return -1;
  if ( *(_DWORD *)LODWORD(a1) != 4 )
    return -1;
  LODWORD(v3) = _isnan(a1);
  if ( LODWORD(v3) )
    return -1;
  result = _isinf(v3);
  if ( result )
    return -1;
  *(_QWORD *)(v2 + 8) = v1;
  return result;
}
// 5A358: variable 'v3' is possibly undefined
// 5A364: variable 'v1' is possibly undefined

//----- (0005A378) --------------------------------------------------------
int __fastcall sub_5A378(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_5CB64(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (0005A3C0) --------------------------------------------------------
void *sub_5A3C0()
{
  return &unk_76BA8;
}

//----- (0005A3CC) --------------------------------------------------------
void *sub_5A3CC()
{
  return &unk_76BB0;
}

//----- (0005A3D8) --------------------------------------------------------
void *sub_5A3D8()
{
  return &unk_76BB8;
}

//----- (0005A3E4) --------------------------------------------------------
void __fastcall sub_5A3E4(void **a1)
{
  void *v2; // r3
  void *v3; // r1
  _DWORD *v4; // r12
  unsigned int i; // r5
  int v6; // r0
  int v7; // r3

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
    {
      if ( v2 == (void *)1 )
      {
        v3 = a1[3];
        v4 = a1[4];
        if ( v3 )
        {
          for ( i = 0; i < (unsigned int)v3; ++i )
          {
            v6 = v4[i];
            if ( v6 )
            {
              v7 = *(_DWORD *)(v6 + 4);
              if ( v7 != -1 )
              {
                *(_DWORD *)(v6 + 4) = v7 - 1;
                if ( v7 == 1 )
                {
                  sub_5A3E4();
                  v4 = a1[4];
                  v3 = a1[3];
                }
              }
            }
          }
        }
        sub_59594(v4);
        sub_59594(a1);
      }
      else if ( v2 == (void *)2 )
      {
        sub_59594(a1[2]);
        sub_59594(a1);
      }
      else if ( v2 == (void *)3 || v2 == (void *)4 )
      {
        sub_59594(a1);
      }
    }
    else
    {
      sub_57A74((int)(a1 + 2));
      sub_59594(a1);
    }
  }
}

//----- (0005A4B8) --------------------------------------------------------
int __fastcall sub_5A4B8(_DWORD *a1)
{
  unsigned int v2; // r1
  unsigned int i; // r4
  int v4; // r0
  int v5; // r3

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD *)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 4);
        if ( v5 != -1 )
        {
          *(_DWORD *)(v4 + 4) = v5 - 1;
          if ( v5 == 1 )
          {
            sub_5A3E4((void **)v4);
            v2 = a1[3];
          }
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (0005A534) --------------------------------------------------------
int __fastcall sub_5A534(_DWORD *a1, unsigned int a2)
{
  unsigned int v4; // r3
  int v5; // r6
  int v6; // r0
  int v7; // r2
  int v8; // r2
  unsigned int v9; // r3

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v4 = a1[3];
      if ( v4 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD *)(a1[4] + 4 * a2);
        if ( !v6 || (v7 = *(_DWORD *)(v6 + 4), v7 == -1) || (v8 = v7 - 1, (*(_DWORD *)(v6 + 4) = v8) != 0) )
        {
          v9 = v4 - 1;
          if ( a2 >= v9 )
          {
LABEL_8:
            a1[3] = v9;
            return 0;
          }
        }
        else
        {
          sub_5A3E4((void **)v6);
          v9 = a1[3] - 1;
          if ( a2 >= v9 )
            goto LABEL_8;
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + 4 * (a2 + 1)), 4 * (v9 - a2));
        v9 = a1[3] - 1;
        goto LABEL_8;
      }
    }
  }
  return -1;
}

//----- (0005A5E8) --------------------------------------------------------
int __fastcall sub_5A5E8(int a1, unsigned int a2, int a3)
{
  char *v6; // r0
  char *v7; // r6
  char *v8; // r1
  int v10; // r3
  int v11; // r3
  int v12; // r3

  if ( !a3 )
    return -1;
  if ( !a1
    || *(_DWORD *)a1 != 1
    || a1 == a3
    || *(_DWORD *)(a1 + 12) < a2
    || (v6 = (char *)sub_59D20((_DWORD *)a1, 1, 0), (v7 = v6) == 0) )
  {
    v11 = *(_DWORD *)(a3 + 4);
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      *(_DWORD *)(a3 + 4) = v12;
      if ( !v12 )
        sub_5A3E4((void **)a3);
    }
    return -1;
  }
  v8 = *(char **)(a1 + 16);
  if ( v8 == v6 )
  {
    memmove(&v8[4 * a2 + 4], &v8[4 * a2], 4 * (*(_DWORD *)(a1 + 12) - a2));
  }
  else
  {
    memcpy(*(void **)(a1 + 16), v6, 4 * a2);
    memcpy((void *)(*(_DWORD *)(a1 + 16) + 4 * (a2 + 1)), &v7[4 * a2], 4 * (*(_DWORD *)(a1 + 12) - a2));
    sub_59594(v7);
  }
  v10 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * a2) = a3;
  *(_DWORD *)(a1 + 12) = v10 + 1;
  return 0;
}

//----- (0005A6E8) --------------------------------------------------------
int __fastcall sub_5A6E8(int *a1, int *a2)
{
  int v4; // r3
  int v6; // r3
  int v7; // r3

  if ( a2 )
  {
    if ( a1 && *a1 == 1 && a1 != a2 && sub_59D20(a1, 1, *a1) )
    {
      v4 = a1[3];
      *(_DWORD *)(a1[4] + 4 * v4) = a2;
      a1[3] = v4 + 1;
      return 0;
    }
    v6 = a2[1];
    if ( v6 != -1 )
    {
      v7 = v6 - 1;
      a2[1] = v7;
      if ( !v7 )
        sub_5A3E4((void **)a2);
    }
  }
  return -1;
}

//----- (0005A76C) --------------------------------------------------------
int __fastcall sub_5A76C(_DWORD *a1, unsigned int a2, int a3)
{
  int v5; // r6
  int *v6; // r2
  int v7; // r0
  int v8; // r3
  int v9; // r3
  int v11; // r3
  int v12; // r3

  if ( !a3 )
    return -1;
  if ( !a1 || *a1 != 1 || a1 == (_DWORD *)a3 || a1[3] <= a2 )
  {
    v11 = *(_DWORD *)(a3 + 4);
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      *(_DWORD *)(a3 + 4) = v12;
      if ( !v12 )
        sub_5A3E4((void **)a3);
    }
    return -1;
  }
  v5 = 4 * a2;
  v6 = (int *)(a1[4] + 4 * a2);
  v7 = *v6;
  if ( *v6 )
  {
    v8 = *(_DWORD *)(v7 + 4);
    if ( v8 != -1 )
    {
      v9 = v8 - 1;
      *(_DWORD *)(v7 + 4) = v9;
      if ( !v9 )
      {
        sub_5A3E4((void **)v7);
        v6 = (int *)(a1[4] + v5);
      }
    }
  }
  *v6 = a3;
  return 0;
}

//----- (0005A820) --------------------------------------------------------
int __fastcall sub_5A820(_DWORD *a1, char *a2, int a3)
{
  bool v4; // zf
  int v5; // r2
  int result; // r0
  int v7; // r3
  int v8; // r3

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( v4
    || *a1
    || a1 == (_DWORD *)a3
    || (v5 = a1[7], a1[7] = v5 + 1, (result = sub_57A8C((int)(a1 + 2), a2, v5, a3)) != 0) )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_5A3E4((void **)a3);
    }
    return -1;
  }
  return result;
}

//----- (0005A8A0) --------------------------------------------------------
int __fastcall sub_5A8A0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r0
  int v7; // r8

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_59E9C(a2);
  for ( i = (char *)sub_59F14((int)v4); i; i = (char *)sub_59F14(v6) )
  {
    v7 = sub_59F20((int)(i - 16));
    if ( !v7 )
      break;
    if ( !sub_59E20(a1, i) )
    {
      if ( *(_DWORD *)(v7 + 4) != -1 )
        ++*(_DWORD *)(v7 + 4);
      sub_5A820(a1, i, v7);
    }
    v6 = sub_59EE8(a2, (int)(i - 16));
  }
  return 0;
}

//----- (0005A95C) --------------------------------------------------------
int __fastcall sub_5A95C(_DWORD *a1, char *a2, int a3)
{
  int v7; // r3
  int v8; // r3

  if ( a2 && sub_59C8C(a2, -1) )
    return sub_5A820(a1, a2, a3);
  if ( a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_5A3E4((void **)a3);
    }
  }
  return -1;
}

//----- (0005A9D0) --------------------------------------------------------
int __fastcall sub_5A9D0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r0
  int v7; // r0

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_59E9C(a2);
  for ( i = (char *)sub_59F14((int)v4); i; i = (char *)sub_59F14(v6) )
  {
    v7 = sub_59F20((int)(i - 16));
    if ( !v7 )
      break;
    if ( *(_DWORD *)(v7 + 4) != -1 )
      ++*(_DWORD *)(v7 + 4);
    if ( sub_5A820(a1, i, v7) )
      return -1;
    v6 = sub_59EE8(a2, (int)(i - 16));
  }
  return 0;
}

//----- (0005AA7C) --------------------------------------------------------
int __fastcall sub_5AA7C(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r5
  int v7; // r0

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_59E9C(a2);
  for ( i = (char *)sub_59F14((int)v4); i; i = (char *)sub_59F14(v7) )
  {
    v6 = sub_59F20((int)(i - 16));
    if ( !v6 )
      break;
    if ( sub_59E20(a1, i) )
    {
      if ( *(_DWORD *)(v6 + 4) != -1 )
        ++*(_DWORD *)(v6 + 4);
      sub_5A820(a1, i, v6);
    }
    v7 = sub_59EE8(a2, (int)(i - 16));
  }
  return 0;
}

//----- (0005AB30) --------------------------------------------------------
bool __fastcall sub_5AB30(int *a1, int *a2)
{
  bool v2; // zf
  int v3; // r2
  int v6; // r3
  _DWORD *v8; // r0
  int v9; // r7
  int v10; // r0
  int v11; // r5
  int v12; // r0
  char *v13; // r1
  int v14; // r7
  int v15; // r0
  int v16; // r7
  unsigned int v17; // r5
  int v18; // r2
  int v19; // r1
  int v20; // r0

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  v3 = v2;
  if ( v2 )
    return 0;
  v6 = *a1;
  if ( *a1 != *a2 )
    return v3;
  if ( a1 == a2 )
    return 1;
  switch ( v6 )
  {
    case 0:
      if ( a1[2] == a2[2] )
      {
        v8 = sub_59E9C(a1);
        v9 = sub_59F14((int)v8);
        if ( v9 )
        {
          while ( 1 )
          {
            v11 = v9 - 16;
            v12 = sub_59F20(v9 - 16);
            v13 = (char *)v9;
            v14 = v12;
            if ( !v12 )
              break;
            v15 = sub_59E20(a2, v13);
            if ( !sub_5AB30(v14, v15) )
              return 0;
            v10 = sub_59EE8(a1, v11);
            v9 = sub_59F14(v10);
            if ( !v9 )
              return 1;
          }
        }
        return 1;
      }
      return 0;
    case 1:
      v16 = a1[3];
      if ( v16 == a2[3] )
      {
        if ( v16 )
        {
          v17 = v3;
          v18 = *a1;
          while ( 1 )
          {
            v20 = v18 == 1 && a1[3] > v17 ? *(_DWORD *)(a1[4] + 4 * v17) : 0;
            v19 = v6 == 1 && a2[3] > v17 ? *(_DWORD *)(a2[4] + 4 * v17) : 0;
            if ( !sub_5AB30(v20, v19) )
              break;
            if ( ++v17 == v16 )
              return 1;
            v18 = *a1;
            v6 = *a2;
          }
          return 0;
        }
        return 1;
      }
      return 0;
    case 2:
      return strcmp((const char *)a1[2], (const char *)a2[2]) == 0;
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
  }
  if ( v6 != 4 )
    return v3;
  return *((double *)a1 + 1) == *((double *)a2 + 1);
}

//----- (0005ACF4) --------------------------------------------------------
int *__fastcall sub_5ACF4(double a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  _DWORD *v4; // r7
  _DWORD *v5; // r0
  char *j; // r5
  int v7; // r3
  int v8; // r0
  int *v9; // r6
  unsigned int v10; // r3
  unsigned int i; // r5
  int *v12; // r1

  v1 = (_DWORD *)LODWORD(a1);
  if ( !LODWORD(a1) )
    return 0;
  v2 = *(_DWORD *)LODWORD(a1);
  if ( *(_DWORD *)LODWORD(a1) )
  {
    switch ( v2 )
    {
      case 1:
        v9 = sub_59F80();
        if ( v9 )
        {
          if ( *v1 == 1 )
          {
            v10 = v1[3];
            if ( v10 )
            {
              for ( i = 0; i < v10; ++i )
              {
                v12 = 0;
                if ( v10 > i )
                {
                  v12 = *(int **)(v1[4] + 4 * i);
                  if ( v12 )
                  {
                    if ( v12[1] != -1 )
                      ++v12[1];
                  }
                }
                sub_5A6E8(v9, v12);
                if ( *v1 != 1 )
                  break;
                v10 = v1[3];
              }
            }
          }
        }
        return v9;
      case 2:
        return sub_5A0EC(*(const char **)(LODWORD(a1) + 8));
      case 3:
        return (int *)sub_5A21C(*(_QWORD *)(LODWORD(a1) + 8));
      case 4:
        return (int *)sub_5A29C(a1);
      default:
        if ( (unsigned int)(v2 - 5) <= 2 )
          return v1;
        return 0;
    }
  }
  else
  {
    v4 = sub_59DA8();
    if ( v4 )
    {
      v5 = sub_59E9C(v1);
      for ( j = (char *)sub_59F14((int)v5); j; j = (char *)sub_59F14(v8) )
      {
        v7 = sub_59F20((int)(j - 16));
        if ( !v7 )
          break;
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
        sub_5A820(v4, j, v7);
        v8 = sub_59EE8(v1, (int)(j - 16));
      }
    }
    return v4;
  }
}

//----- (0005AE68) --------------------------------------------------------
int *__fastcall sub_5AE68(double a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  _DWORD *v4; // r7
  _DWORD *j; // r5
  char *v6; // r6
  int v7; // r0
  int v8; // r0
  int *v9; // r6
  unsigned int v10; // r3
  unsigned int i; // r5
  int v12; // r0
  int *v13; // r0

  v1 = (_DWORD *)LODWORD(a1);
  if ( !LODWORD(a1) )
    return v1;
  v2 = *(_DWORD *)LODWORD(a1);
  if ( *(_DWORD *)LODWORD(a1) )
  {
    switch ( v2 )
    {
      case 1:
        v9 = sub_59F80();
        if ( v9 )
        {
          if ( *v1 == 1 )
          {
            v10 = v1[3];
            if ( v10 )
            {
              for ( i = 0; i < v10; ++i )
              {
                v12 = 0;
                if ( i < v10 )
                  v12 = *(_DWORD *)(v1[4] + 4 * i);
                v13 = (int *)sub_5AE68(v12);
                sub_5A6E8(v9, v13);
                if ( *v1 != 1 )
                  break;
                v10 = v1[3];
              }
            }
          }
        }
        return v9;
      case 2:
        return sub_5A0EC(*(const char **)(LODWORD(a1) + 8));
      case 3:
        return (int *)sub_5A21C(*(_QWORD *)(LODWORD(a1) + 8));
      case 4:
        return (int *)sub_5A29C(a1);
      default:
        if ( (unsigned int)(v2 - 5) > 2 )
          return 0;
        return v1;
    }
  }
  else
  {
    v4 = sub_59DA8();
    if ( v4 )
    {
      for ( j = sub_59E9C(v1); j; j = (_DWORD *)sub_59EE8(v1, (int)j) )
      {
        v6 = (char *)sub_59F14((int)j);
        v7 = sub_59F20((int)j);
        v8 = sub_5AE68(v7);
        sub_5A820(v4, v6, v8);
      }
    }
    return v4;
  }
}

//----- (0005AFB0) --------------------------------------------------------
char *__fastcall sub_5AFB0(char *result, char *s)
{
  bool v2; // zf
  int v4; // r5
  size_t v5; // r0

  v2 = result == 0;
  if ( result )
    v2 = s == 0;
  v4 = (int)result;
  if ( !v2 )
  {
    v5 = strlen(s);
    if ( v5 <= 0x4F )
    {
      return (char *)memcpy((void *)(v4 + 12), s, v5 + 1);
    }
    else
    {
      strcpy((char *)(v4 + 12), "...");
      return strcpy((char *)(v4 + 15), &s[v5 - 76]);
    }
  }
  return result;
}

//----- (0005B014) --------------------------------------------------------
char *__fastcall sub_5B014(char *result, char *s)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( s )
      return sub_5AFB0(result, s);
    else
      result[12] = 0;
  }
  return result;
}

//----- (0005B058) --------------------------------------------------------
int __fastcall sub_5B058(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg)
{
  int v6; // r4

  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0xA0u, format, arg);
      *(_BYTE *)(v6 + 251) = 0;
    }
  }
  return result;
}

//----- (0005B098) --------------------------------------------------------
int sub_5B098(int a1, int a2, int a3, int a4, char *format, ...)
{
  va_list __varargs; // [sp+1Ch] [bp+8h] BYREF

  va_start(__varargs, format);
  return sub_5B058(a1, a2, a3, a4, format, __varargs);
}

//----- (0005B0C0) --------------------------------------------------------
char *__fastcall sub_5B0C0(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v5 + v4);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (0005B0FC) --------------------------------------------------------
int __fastcall sub_5B0FC(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0005B10C) --------------------------------------------------------
int __fastcall sub_5B10C(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (0005B120) --------------------------------------------------------
char *__fastcall sub_5B120(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, dword_660D4) || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_5BD88(a1);
  }
}

//----- (0005B1B4) --------------------------------------------------------
char *__fastcall sub_5B1B4(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_5B120(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (0005B1D4) --------------------------------------------------------
int __fastcall sub_5B1D4(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (0005B1E0) --------------------------------------------------------
char *__fastcall sub_5B1E0(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return sub_5B0C0("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return sub_5B0C0("'%s' is out of range", a1);
  return result;
}
// 5B210: variable 'v2' is possibly undefined
// AF70: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0005B264) --------------------------------------------------------
char *__fastcall sub_5B264(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_5B0C0("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_5B0C0("'%s' is out of range", a1);
  return result;
}

//----- (0005B2E8) --------------------------------------------------------
char *__fastcall sub_5B2E8(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_5B264(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (0005B3A8) --------------------------------------------------------
int __fastcall sub_5B3A8(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (0005B3C0) --------------------------------------------------------
void __fastcall __noreturn sub_5B3C0(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 76BCC: using guessed type int stdout;

//----- (0005B3E0) --------------------------------------------------------
void __fastcall __noreturn sub_5B3E0(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_5C20C(dword_9D780, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 5C20C: using guessed type int __fastcall sub_5C20C(_DWORD, _DWORD);
// 76BCC: using guessed type int stdout;
// 9D780: using guessed type int dword_9D780;

//----- (0005B420) --------------------------------------------------------
char *__fastcall sub_5B420(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (0005B444) --------------------------------------------------------
char *__fastcall sub_5B444(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (0005B468) --------------------------------------------------------
char *__fastcall sub_5B468(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  const char *v5; // r1
  bool v6; // cc
  size_t v7; // r5
  char *v8; // r0
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  *a1 = 34;
  v5 = *a2;
  v6 = v4 > 0x4E;
  v7 = v4;
  v8 = a1 + 1;
  if ( v6 )
  {
    result = strncpy(v8, v5, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v7];
    result = strncpy(v8, v5, v7);
    v9[1] = 34;
    if ( v7 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (0005B4C8) --------------------------------------------------------
int __fastcall sub_5B4C8(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (0005B4DC) --------------------------------------------------------
int __fastcall sub_5B4DC(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (0005B508) --------------------------------------------------------
int __fastcall sub_5B508(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (0005B51C) --------------------------------------------------------
int __fastcall sub_5B51C(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (0005B530) --------------------------------------------------------
int __fastcall sub_5B530(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (0005B544) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5B544(int a1, _DWORD *a2)
{
  unsigned __int8 *v2; // r4
  int v3; // r3
  bool v4; // zf
  int v5; // r2
  int v6; // r12
  unsigned __int8 *v7; // r12
  int v8; // r3
  int v9; // t1
  unsigned __int8 *result; // r0

  v2 = (unsigned __int8 *)(a1 + *a2);
  v3 = *v2;
  v4 = v3 == 32;
  if ( v3 != 32 )
    v4 = v3 == 61;
  if ( v4 )
    return 0;
  v5 = 0;
  if ( !*(_BYTE *)(a1 + *a2) )
    return 0;
  v6 = v2[2];
  result = v2 + 2;
  if ( v2[2] )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v7 = v2 + 2;
      do
      {
        v9 = *++v7;
        v8 = v9;
        ++v5;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  else
  {
    v5 = v2[2];
  }
  *a2 = v5;
  return result;
}

//----- (0005B5EC) --------------------------------------------------------
_BYTE *__fastcall sub_5B5EC(unsigned int *a1, _DWORD *a2)
{
  _DWORD *v2; // r3
  int v3; // r4
  unsigned int v4; // r12
  _BYTE *result; // r0
  int v6; // r2
  int v7; // r12
  int v8; // r3
  int v9; // t1

  *a1 = 0;
  if ( !dword_9D774 )
    return 0;
  v2 = (_DWORD *)dword_9D77C;
  if ( *(_DWORD *)(dword_9D77C + 4) == 8 )
  {
    v3 = dword_9D77C + 28;
    v4 = 1;
    do
    {
      *a1 = v4;
      v2 = (_DWORD *)v3;
      v3 += 28;
      if ( dword_9D774 <= v4++ )
        return 0;
    }
    while ( v2[1] == 8 );
  }
  result = (_BYTE *)(*v2 + 1);
  v6 = (unsigned __int8)*result;
  if ( *result )
  {
    if ( v6 == 124 || v6 == 61 || v6 == 32 )
    {
      v6 = 0;
    }
    else
    {
      v7 = *v2 + 1;
      v6 = 0;
      do
      {
        v9 = *(unsigned __int8 *)++v7;
        v8 = v9;
        ++v6;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  *a2 = v6;
  return result;
}
// 9D774: using guessed type int dword_9D774;
// 9D77C: using guessed type int dword_9D77C;

//----- (0005B6D4) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5B6D4(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3)
{
  unsigned int i; // r3
  _DWORD *v7; // r4
  _BYTE *v9; // r1
  int v10; // r3
  int v11; // r2
  int v12; // r3
  int v13; // t1

  for ( i = *a2; dword_9D774 > i; *a2 = ++i )
  {
    v7 = (_DWORD *)(dword_9D77C + 28 * i);
    if ( v7[1] != 8 )
    {
      if ( !a1 )
      {
        v9 = (_BYTE *)(*v7 + 1);
        v10 = (unsigned __int8)*v9;
        if ( *v9 && v10 != 124 && v10 != 61 && v10 != 32 )
        {
          v11 = *v7 + 1;
          do
          {
            v13 = *(unsigned __int8 *)++v11;
            v12 = v13;
            ++a1;
          }
          while ( v13 && v12 != 124 && v12 != 61 && v12 != 32 );
        }
        *a3 = a1;
        return v9;
      }
      a1 = sub_5B544((int)a1, a3);
      if ( a1 )
        return a1;
      i = *a2;
    }
  }
  return 0;
}
// 9D774: using guessed type int dword_9D774;
// 9D77C: using guessed type int dword_9D77C;

//----- (0005B7C8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5B7C8(const char **a1)
{
  unsigned int v1; // r1
  bool v2; // cc
  int v4; // r3
  const char *v5; // r2
  int v6; // r1
  unsigned __int8 *v7; // r12
  const char *v8; // r1
  int v9; // r2
  int v10; // t1
  const char *v11; // r2
  bool v12; // zf
  int v13; // r1
  const char *v14; // r0
  int v15; // r1
  bool v16; // zf
  unsigned __int8 *result; // r0
  int i; // [sp+Ch] [bp-4h] BYREF

  v1 = (unsigned int)a1[1];
  v2 = v1 > 4;
  if ( v1 != 4 )
    v2 = v1 - 1 > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", *a1, a1[1]);
  v4 = 0;
  v5 = *a1;
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", v5);
  if ( *v5 != 45 )
    errx(1, "Option %s: does not begin with '-'", v5);
  v6 = *((unsigned __int8 *)v5 + 1);
  v7 = (unsigned __int8 *)(v5 + 1);
  if ( v5[1] )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v8 = v5 + 1;
      do
      {
        v10 = *(unsigned __int8 *)++v8;
        v9 = v10;
        ++v4;
      }
      while ( v10 && v9 != 124 && v9 != 61 && v9 != 32 );
    }
  }
  else
  {
    v4 = *((unsigned __int8 *)v5 + 1);
  }
  for ( i = v4; ; v4 = i )
  {
    if ( *v7 == 45 )
    {
      if ( v4 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v14 = a1[1];
      ++dword_9D76C;
    }
    else
    {
      if ( v4 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v4 + 1, (const char *)v7 - 1);
      v11 = a1[1];
      v12 = v11 == (const char *)2;
      if ( v11 != (const char *)2 )
        v12 = v11 == (const char *)4;
      v13 = ++dword_9D770;
      if ( v12 )
        v13 = dword_9D778;
      v14 = v11;
      if ( v12 )
        dword_9D778 = v13 + 1;
    }
    if ( v14 == (const char *)1 )
    {
      v15 = v7[v4];
      v16 = v15 == 32;
      if ( v15 != 32 )
        v16 = v15 == 61;
      if ( v16 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, (const char *)&v7[v4 + 1]);
    }
    result = sub_5B544((int)v7, &i);
    v7 = result;
    if ( !result )
      break;
  }
  return result;
}
// 9D76C: using guessed type int dword_9D76C;
// 9D770: using guessed type int dword_9D770;
// 9D778: using guessed type int dword_9D778;

//----- (0005B9A8) --------------------------------------------------------
int __fastcall sub_5B9A8(int *a1)
{
  char *v2; // r0
  int v3; // r10
  int v4; // r8
  char *v5; // r12
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int result; // r0
  int v11; // r1
  int v12; // r2

  v2 = (char *)realloc((void *)dword_9D77C, 28 * (dword_9D774 + 1));
  v3 = dword_9D774 + 1;
  v4 = (int)v2;
  v5 = &v2[28 * dword_9D774];
  v6 = *a1;
  v7 = a1[1];
  v8 = a1[2];
  v9 = a1[3];
  a1 += 4;
  dword_9D77C = v4;
  *(_DWORD *)v5 = v6;
  *((_DWORD *)v5 + 1) = v7;
  *((_DWORD *)v5 + 2) = v8;
  *((_DWORD *)v5 + 3) = v9;
  v5 += 16;
  result = *a1;
  v11 = a1[1];
  v12 = a1[2];
  dword_9D774 = v3;
  *(_DWORD *)v5 = result;
  *((_DWORD *)v5 + 1) = v11;
  *((_DWORD *)v5 + 2) = v12;
  return result;
}
// 9D774: using guessed type int dword_9D774;
// 9D77C: using guessed type int dword_9D77C;

//----- (0005BA08) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5BA08(unsigned int *a1, unsigned __int8 **a2)
{
  unsigned __int8 *v4; // r0

  v4 = sub_5B5EC(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = sub_5B6D4(v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (0005BA60) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5BA60(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3)
{
  unsigned __int8 *v5; // r0

  v5 = sub_5B6D4(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = sub_5B6D4(v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (0005BAB8) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5BAB8(unsigned int *a1)
{
  unsigned __int8 *result; // r0
  unsigned __int8 *v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_5B5EC(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = sub_5B6D4(result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0005BB14) --------------------------------------------------------
unsigned __int8 *__fastcall sub_5BB14(unsigned __int8 *a1, unsigned int *a2)
{
  unsigned __int8 *result; // r0
  int v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = sub_5B6D4(a1, a2, (unsigned __int8 **)&v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = sub_5B6D4(result, a2, (unsigned __int8 **)&v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0005BBB8) --------------------------------------------------------
int __fastcall sub_5BBB8(int result, int a2)
{
  const char **v3; // r5
  int v4; // r6
  const char *v5; // r3
  const char **v6; // r4
  int v7[7]; // [sp+4h] [bp-1Ch] BYREF

  v3 = (const char **)result;
  v4 = dword_9D774;
  if ( a2 )
  {
    v7[6] = a2;
    v7[0] = 0;
    memset(&v7[2], 0, 16);
    v7[1] = 8;
    result = sub_5B9A8(v7);
  }
  v5 = v3[1];
  if ( v5 != (const char *)16 )
  {
    v6 = v3 + 7;
    do
    {
      if ( v5 == (const char *)8 )
      {
        result = sub_5BBB8(*v3, v3[6]);
      }
      else
      {
        sub_5B7C8(v3);
        result = sub_5B9A8((int *)v3);
      }
      v3 = v6;
      v6 += 7;
      v5 = *(v6 - 6);
    }
    while ( v5 != (const char *)16 );
  }
  if ( a2 )
    *(_DWORD *)(dword_9D77C + 28 * v4 + 20) = dword_9D774 - v4;
  return result;
}
// 9D774: using guessed type int dword_9D774;
// 9D77C: using guessed type int dword_9D77C;

//----- (0005BC84) --------------------------------------------------------
bool __fastcall sub_5BC84(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  const char *v4; // r1
  int v7; // r0
  int v9; // [sp+4h] [bp-8h] BYREF

  v4 = *a2;
  v9 = 0;
  dword_9D780 = (int)v4;
  do
    v7 = sub_5BDEC(a1, a2, &v9, a3);
  while ( v7 == 1 );
  return v7 == 0;
}
// 9D780: using guessed type int dword_9D780;

//----- (0005BCE0) --------------------------------------------------------
void sub_5BCE0()
{
  free((void *)dword_9D77C);
  dword_9D77C = 0;
}
// 9D77C: using guessed type int dword_9D77C;

//----- (0005BD00) --------------------------------------------------------
int sub_5BD00(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 76BD0: using guessed type int stderr;

//----- (0005BD48) --------------------------------------------------------
void __noreturn sub_5BD48(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 76BD0: using guessed type int stderr;

//----- (0005BD88) --------------------------------------------------------
char *__fastcall sub_5BD88(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (0005BDB8) --------------------------------------------------------
void *__fastcall sub_5BDB8(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * (a3 + 1)), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (0005BDEC) --------------------------------------------------------
int __fastcall sub_5BDEC(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  char *v8; // r0
  const char *v9; // r12
  const char **v10; // r6
  int v12; // r5
  unsigned __int8 *v13; // r11
  const char *v14; // r3
  int v15; // r0
  size_t v16; // r0
  int v17; // r4
  unsigned __int8 *i; // r11
  int v19; // r0
  unsigned int v20; // r1
  const char *v21; // r11
  int v22; // lr
  int v23; // r12
  char *v24; // r4
  const char *v25; // r12
  const char **v26; // r4
  const char *v27; // t1
  _BYTE *ptr; // [sp+8h] [bp-14h]
  char *ptra; // [sp+8h] [bp-14h]
  const char *v30; // [sp+Ch] [bp-10h]
  unsigned int v31; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT");
  v9 = a2[1];
  if ( !v8 )
  {
    if ( v9 )
    {
      if ( *v9 == 45 )
      {
        v10 = a2 + 1;
        v12 = 1;
        goto LABEL_6;
      }
      v26 = a2 + 2;
      v12 = 1;
      while ( 1 )
      {
        v10 = v26;
        v27 = *v26++;
        v9 = v27;
        ++v12;
        if ( !v27 )
          break;
        if ( *v9 == 45 )
          goto LABEL_6;
      }
    }
    return 0;
  }
  v10 = a2 + 1;
  if ( !v9 || *v9 != 45 )
    return 0;
  v12 = 1;
LABEL_6:
  if ( v9[1] == 45 )
  {
    v17 = *((unsigned __int8 *)v9 + 2);
    if ( !v9[2] )
    {
      sub_5BDB8(a1, (int)a2, v12);
      return v17;
    }
    if ( *a3 )
      _assert_fail("*offset == 0", "opt/parse.c", 0x3Bu, "parse_one");
    for ( i = sub_5BA08(&v31, (unsigned __int8 **)n); i; i = sub_5BA60(i, &v31, (unsigned __int8 **)n) )
    {
      v30 = *v10;
      ptr = (_BYTE *)n[0];
      v19 = strncmp(*v10 + 2, (const char *)i, n[0]);
      v14 = v30;
      if ( !v19 )
      {
        if ( ptr[(_DWORD)v30 + 2] == 61 )
        {
          v20 = v31;
          v24 = &ptr[(_DWORD)v30 + 3];
          v21 = (const char *)(i - 2);
          n[0] = (size_t)(ptr + 2);
          v22 = dword_9D77C + 28 * v31;
          v23 = *(_DWORD *)(v22 + 4);
          if ( v23 != 1 )
          {
            if ( v24 )
              goto LABEL_39;
            goto LABEL_48;
          }
          if ( v24 )
          {
            a4("%s: %.*s: %s", *a2, (int)(ptr + 2), v21, "doesn't allow an argument");
            return -1;
          }
LABEL_18:
          v24 = 0;
          v25 = (const char *)(*(int (__fastcall **)(_DWORD))(v22 + 8))(*(_DWORD *)(v22 + 20));
LABEL_19:
          if ( v25 )
          {
            ptra = (char *)v25;
            a4("%s: %.*s: %s", *a2, n[0], v21, v25);
            free(ptra);
            return -1;
          }
          if ( *a3 )
          {
            if ( !(*v10)[*a3 + 1] )
            {
              *a3 = 0;
              goto LABEL_23;
            }
          }
          else
          {
LABEL_23:
            sub_5BDB8(a1, (int)a2, v12);
            if ( v24 )
            {
              if ( *v10 == v24 )
                sub_5BDB8(a1, (int)a2, v12);
            }
          }
          return 1;
        }
        if ( !ptr[(_DWORD)v30 + 2] )
        {
          v20 = v31;
          v21 = (const char *)(i - 2);
          n[0] = (size_t)(ptr + 2);
          v22 = dword_9D77C + 28 * v31;
          v23 = *(_DWORD *)(v22 + 4);
          if ( v23 == 1 )
            goto LABEL_18;
LABEL_48:
          v15 = *a3;
          goto LABEL_37;
        }
      }
    }
LABEL_10:
    v16 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v16, *v10, "unrecognized option");
    return -1;
  }
  v13 = sub_5BAB8(&v31);
  if ( !v13 )
    goto LABEL_10;
  while ( 1 )
  {
    v14 = *v10;
    v15 = *a3 + 1;
    if ( (unsigned __int8)(*v10)[v15] == *v13 )
      break;
    v13 = sub_5BB14(v13, &v31);
    if ( !v13 )
      goto LABEL_10;
  }
  v20 = v31;
  v21 = (const char *)(v13 - 1);
  *a3 = v15;
  n[0] = 2;
  v22 = dword_9D77C + 28 * v20;
  v23 = *(_DWORD *)(v22 + 4);
  if ( v23 == 1 )
    goto LABEL_18;
LABEL_37:
  if ( v15 )
  {
    v24 = (char *)&v14[v15 + 1];
    if ( *v24 )
    {
      *a3 = 0;
      goto LABEL_39;
    }
  }
  v24 = (char *)a2[v12 + 1];
  if ( v24 )
  {
LABEL_39:
    if ( v23 == 4 )
    {
      sub_5B1D4((int)v24, *(_DWORD **)(v22 + 20));
      v20 = v31;
    }
    v25 = (const char *)(*(int (__fastcall **)(char *, _DWORD))(dword_9D77C + 28 * v20 + 12))(
                          v24,
                          *(_DWORD *)(dword_9D77C + 28 * v20 + 20));
    goto LABEL_19;
  }
  a4("%s: %.*s: %s", *a2, n[0], v21, "requires an argument");
  return -1;
}
// 9D77C: using guessed type int dword_9D77C;

//----- (0005C20C) --------------------------------------------------------
char *__fastcall sub_5C20C(const char *a1, char *a2)
{
  size_t v2; // r4
  unsigned int v3; // r11
  size_t v4; // r8
  int v5; // r4
  unsigned int v6; // r5
  const char *v7; // r7
  size_t v8; // r8
  size_t v9; // r0
  size_t v10; // r8
  size_t v11; // r9
  size_t v12; // r0
  char *v13; // r0
  char *v14; // r4
  char *v15; // r5
  unsigned __int8 *v16; // r2
  int v17; // r9
  int v18; // r0
  char *v19; // r5
  int v20; // r4
  unsigned int v21; // r7
  unsigned int v22; // r9
  int v23; // r2
  unsigned int v24; // r9
  unsigned int v25; // r9
  int v26; // r3
  const char *v27; // r2
  char *v29; // r2
  int v30; // r2
  int v31; // r3
  size_t v32; // r5
  char *v33; // [sp+0h] [bp-6Ch]
  char *v34; // [sp+4h] [bp-68h]
  char *s; // [sp+8h] [bp-64h]
  unsigned int v37; // [sp+10h] [bp-5Ch] BYREF
  char v38[80]; // [sp+14h] [bp-58h] BYREF
  int v39; // [sp+64h] [bp-8h]

  s = a2;
  if ( a2 )
  {
    v2 = strlen(a1);
    v3 = dword_9D774;
    v4 = dword_9D770 + 20 + v2 + strlen(s);
    if ( !dword_9D774 )
      goto LABEL_12;
    v5 = dword_9D77C;
  }
  else
  {
    v3 = dword_9D774;
    if ( !dword_9D774 )
    {
      s = "";
      v4 = dword_9D770 + 20 + strlen(a1);
      goto LABEL_12;
    }
    v30 = 0;
    v5 = dword_9D77C;
    v31 = dword_9D77C;
    do
    {
      ++v30;
      if ( *(void (__fastcall __noreturn **)(int))(v31 + 8) == sub_5B3E0 && *(_DWORD *)(v31 + 20) )
      {
        s = *(char **)(v31 + 20);
        v32 = strlen(s);
        goto LABEL_45;
      }
      v31 += 28;
    }
    while ( v30 != dword_9D774 );
    v32 = 0;
    s = "";
LABEL_45:
    v4 = dword_9D770 + 20 + strlen(a1) + v32;
  }
  v6 = 0;
  do
  {
    while ( 1 )
    {
      v11 = v4 + 6;
      if ( *(_DWORD *)(v5 + 4) != 8 )
        break;
      ++v6;
      v12 = strlen(*(const char **)(v5 + 24));
      v5 += 28;
      v4 += 3 + v12;
      if ( v3 <= v6 )
        goto LABEL_12;
    }
    v7 = *(const char **)(v5 + 24);
    if ( v7 != (const char *)&unk_9D784 )
    {
      v8 = strlen(*(const char **)v5);
      v9 = v11 + v8 + strlen(v7);
      v10 = v9 + 21;
      if ( *(_DWORD *)(v5 + 16) )
        v10 = v9 + 118;
      v4 = v10 + 1;
    }
    ++v6;
    v5 += 28;
  }
  while ( v3 > v6 );
LABEL_12:
  v13 = (char *)malloc(v4);
  v34 = v13;
  if ( v13 )
  {
    v14 = &v13[sprintf(v13, "Usage: %s", a1)];
    v15 = v14 + 3;
    strcpy(v14, " [-");
    v16 = sub_5BAB8(&v37);
    if ( v16 )
    {
      v17 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_9D77C + 28 * v37 + 24) != &unk_9D784 )
          v15[v17++] = *v16;
        v16 = sub_5BB14(v16, &v37);
      }
      while ( v16 );
      if ( v17 )
      {
        v14 = &v15[v17 + 1];
        *(_WORD *)&v15[v17] = 93;
      }
    }
    v18 = sprintf(v14, " %s", s);
    *(_WORD *)&v14[v18] = 10;
    v19 = &v14[v18 + 1];
    if ( dword_9D774 )
    {
      v20 = 0;
      v21 = 0;
      do
      {
        v26 = dword_9D77C + v20;
        v27 = *(const char **)(dword_9D77C + v20 + 24);
        if ( v27 != (const char *)&unk_9D784 )
        {
          if ( *(_DWORD *)(v26 + 4) == 8 )
          {
            v19 += sprintf(v19, "%s:\n", v27);
          }
          else
          {
            v22 = sprintf(v19, "%s", *(const char **)v26);
            if ( *(_DWORD *)(dword_9D77C + v20 + 4) == 2 )
            {
              v33 = *(char **)(dword_9D77C + v20);
              if ( !strchr(v33, 32) && !strchr(v33, 61) )
              {
                v29 = &v19[v22];
                *(_DWORD *)&v19[v22] = *(_DWORD *)" <arg>";
                v22 += 6;
                strcpy(v29 + 4, "g>");
              }
            }
            if ( v22 > 0x13 )
              v23 = 1;
            else
              v23 = 20 - v22;
            v24 = sprintf(&v19[v22], "%.*s", v23, "                    ", v33) + v22;
            v25 = v24 + sprintf(&v19[v24], "%s", *(const char **)(dword_9D77C + v20 + 24));
            if ( *(_DWORD *)(dword_9D77C + v20 + 16) )
            {
              v39 = 3026478;
              (*(void (__fastcall **)(char *, _DWORD))(dword_9D77C + v20 + 16))(
                v38,
                *(_DWORD *)(dword_9D77C + v20 + 20));
              v25 += sprintf(&v19[v25], " (default: %s)", v38);
            }
            *(_WORD *)&v19[v25] = 10;
            v19 += v25 + 1;
          }
        }
        ++v21;
        v20 += 28;
      }
      while ( dword_9D774 > v21 );
    }
    *v19 = 0;
  }
  return v34;
}
// 5C428: variable 'v33' is possibly undefined
// 9D770: using guessed type int dword_9D770;
// 9D774: using guessed type int dword_9D774;
// 9D77C: using guessed type int dword_9D77C;

//----- (0005C710) --------------------------------------------------------
int __fastcall sub_5C710(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(0x5CC00);
  return divsi3_skip_div0_test();
}
// 5C7E8: control flows out of bounds to 5CC00
// 5C718: using guessed type int divsi3_skip_div0_test(void);

//----- (0005C718) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3
  char v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r2
  bool v8; // zf

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      v5 = __clz(a2) - __clz(v4);
      v6 = a2 << v5;
      v7 = 1 << v5;
      result = 0;
      while ( 1 )
      {
        if ( v4 >= v6 )
        {
          v4 -= v6;
          result |= v7;
        }
        if ( v4 >= v6 >> 1 )
        {
          v4 -= v6 >> 1;
          result |= v7 >> 1;
        }
        if ( v4 >= v6 >> 2 )
        {
          v4 -= v6 >> 2;
          result |= v7 >> 2;
        }
        if ( v4 >= v6 >> 3 )
        {
          v4 -= v6 >> 3;
          result |= v7 >> 3;
        }
        v8 = v4 == 0;
        if ( v4 )
        {
          v7 >>= 4;
          v8 = v7 == 0;
        }
        if ( v8 )
          break;
        v6 >>= 4;
      }
      if ( v3 < 0 )
        return -result;
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 5C71C: variable 'v2' is possibly undefined

//----- (0005C80C) --------------------------------------------------------
int __fastcall sub_5C80C(__int64 a1, __int64 a2)
{
  int v2; // r4
  int v3; // r5
  bool v4; // zf
  int v5; // r4
  bool v6; // vf
  char v7; // cc
  int v8; // r5
  __int64 v9; // r2
  int v10; // r4
  char v11; // lr
  unsigned int v12; // r12
  __int64 v13; // r0
  bool v14; // nf
  char v15; // r5
  _BOOL1 v16; // off
  _BOOL1 v17; // cf
  int v18; // off
  int v19; // r4
  bool v20; // zf
  unsigned int v21; // r3
  int v22; // r3
  bool v23; // cc
  int v24; // r2
  int v25; // r4
  int v26; // r4
  char v27; // r4
  bool v28; // zf
  bool v29; // zf

  HIDWORD(a1) ^= 0x80000000;
  v2 = 2 * HIDWORD(a1);
  v3 = 2 * HIDWORD(a2);
  v4 = 2 * HIDWORD(a1) == 2 * HIDWORD(a2);
  if ( 2 * HIDWORD(a1) == 2 * HIDWORD(a2) )
    v4 = (unsigned int)a1 == (unsigned int)a2;
  if ( !v4 )
  {
    v4 = (v2 | (unsigned int)a1) == 0;
    if ( v2 | (unsigned int)a1 )
    {
      v4 = (v3 | (unsigned int)a2) == 0;
      if ( v3 | (unsigned int)a2 )
      {
        v4 = v2 >> 21 == -1;
        if ( v2 >> 21 != -1 )
          v4 = v3 >> 21 == -1;
      }
    }
  }
  if ( v4 )
  {
    v28 = v2 >> 21 == -1;
    if ( v2 >> 21 != -1 )
      v28 = v3 >> 21 == -1;
    if ( v28 )
    {
      if ( v2 >> 21 != -1 )
        return a2;
    }
    else
    {
      v29 = v2 == v3;
      if ( v2 == v3 )
        v29 = (unsigned int)a1 == (unsigned int)a2;
      if ( v29 )
      {
        if ( HIDWORD(a1) != HIDWORD(a2) )
        {
          LODWORD(a1) = 0;
          return a1;
        }
        if ( !((unsigned int)v2 >> 21) )
        {
          LODWORD(a1) = 2 * a1;
          return a1;
        }
        if ( (unsigned int)v2 < 0xFFC00000 )
          return a1;
        goto LABEL_68;
      }
      if ( !(v2 | (unsigned int)a1) )
        LODWORD(a1) = a2;
    }
  }
  else
  {
    v5 = (unsigned int)v2 >> 21;
    v6 = __OFSUB__((unsigned int)v3 >> 21, v5);
    v8 = ((unsigned int)v3 >> 21) - v5;
    v7 = (v8 < 0) ^ v6 | (v8 == 0);
    if ( v8 < 0 != v6 )
      v8 = -v8;
    if ( !v7 )
    {
      v5 += v8;
      v9 = a1 ^ a2;
      a1 ^= v9;
      a2 = a1 ^ v9;
    }
    if ( (unsigned int)v8 <= 0x36 )
    {
      v4 = a1 >= 0;
      HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
      if ( !v4 )
        a1 = -a1;
      v4 = a2 >= 0;
      HIDWORD(a2) = HIDWORD(a2) & 0xFFFFF | 0x100000;
      if ( !v4 )
        a2 = -a2;
      if ( v5 == v8 )
      {
        HIDWORD(a2) ^= 0x100000u;
        if ( v5 )
        {
          --v8;
        }
        else
        {
          HIDWORD(a1) ^= 0x100000u;
          v5 = 1;
        }
      }
      v10 = v5 - 1;
      v11 = 32 - v8;
      if ( v8 > 32 )
      {
        v15 = v8 - 32;
        v12 = HIDWORD(a2) << (v11 + 32);
        if ( (_DWORD)a2 )
          v12 |= 2u;
        LODWORD(a1) = a1 + (SHIDWORD(a2) >> v15);
        HIDWORD(a1) += (SHIDWORD(a2) >> 31) + __CFSHR__(HIDWORD(a2), 31);
        v14 = a1 < 0;
      }
      else
      {
        v12 = (_DWORD)a2 << v11;
        v13 = a1 + ((unsigned int)a2 >> v8);
        LODWORD(a1) = v13 + (HIDWORD(a2) << v11);
        HIDWORD(a1) = (SHIDWORD(a2) >> v8) + __CFSHR__(HIDWORD(a2), v8) + HIDWORD(v13);
        v14 = a1 < 0;
      }
      if ( v14 )
      {
        v17 = v12 == 0;
        v12 = -v12;
        v16 = v17;
        v17 = __CFSUB__(0, (_DWORD)a1, v17);
        LODWORD(a1) = -(a1 + !v16);
        HIDWORD(a1) = -(HIDWORD(a1) + !v17);
      }
      if ( HIDWORD(a1) >= 0x100000 )
      {
        if ( HIDWORD(a1) < 0x200000 )
          goto LABEL_30;
        v17 = a1 & 1;
        LODWORD(a1) = a1 >> 1;
        v12 = (v12 >> 1) | (v17 << 31);
        if ( (unsigned int)((v10 + 1) << 21) < 0xFFC00000 )
          goto LABEL_30;
LABEL_68:
        JUMPOUT(0x5CA88);
      }
      v17 = __CFSHL__(v12, 1);
      v12 *= 2;
      v18 = v17 + (_DWORD)a1;
      v17 = __CFADD__(v17, (_DWORD)a1) | __CFADD__((_DWORD)a1, v18);
      LODWORD(a1) = a1 + v18;
      HIDWORD(a1) += v17 + HIDWORD(a1);
      v19 = v10 - 1;
      if ( (a1 & 0x10000000000000LL) != 0 )
      {
LABEL_30:
        v17 = v12 >= 0x80000000;
        if ( v12 == 0x80000000 )
          v17 = a1 & 1;
        LODWORD(a1) = v17 + (_DWORD)a1;
        return a1;
      }
      v20 = HIDWORD(a1) == 0;
      if ( !HIDWORD(a1) )
      {
        HIDWORD(a1) = a1;
        LODWORD(a1) = 0;
      }
      v21 = __clz(HIDWORD(a1));
      if ( v20 )
        v21 += 32;
      v22 = v21 - 11;
      v24 = v22 - 32;
      v23 = v22 <= 32;
      if ( v22 < 32 )
      {
        v23 = v24 <= -12;
        if ( v24 > -12 )
        {
          LODWORD(a1) = HIDWORD(a1) << v22;
          HIDWORD(a1) >>= 32 - v22;
LABEL_46:
          v7 = v19 < v22;
          v25 = v19 - v22;
          if ( v7 )
          {
            v26 = ~v25;
            v7 = v26 < 31;
            v27 = v26 - 31;
            if ( v7 )
              LODWORD(a1) = ((unsigned int)a1 >> (v27 + 32)) | (HIDWORD(a1) << -v27);
            else
              LODWORD(a1) = HIDWORD(a1) >> v27;
          }
          return a1;
        }
        LOBYTE(v24) = v22;
      }
      if ( v23 )
        LOBYTE(v12) = 32 - v24;
      HIDWORD(a1) <<= v24;
      if ( v23 )
      {
        HIDWORD(a1) |= (unsigned int)a1 >> v12;
        LODWORD(a1) = (_DWORD)a1 << v24;
      }
      goto LABEL_46;
    }
  }
  return a1;
}
// 5CA84: control flows out of bounds to 5CA88

//----- (0005CB50) --------------------------------------------------------
int __fastcall sub_5CB50(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x5CB80);
  return a1;
}
// 5CB60: control flows out of bounds to 5CB80

//----- (0005CB64) --------------------------------------------------------
int __fastcall sub_5CB64(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  int v9; // r4
  int v10; // r4
  char v11; // r4
  int v12; // r4
  unsigned int v13; // r12
  int v14; // r2
  int v15; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
    a1 = -a1;
  v12 = 1074;
  v13 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v14 = 3;
    if ( HIDWORD(a1) >> 25 )
      v14 = 6;
    if ( HIDWORD(a1) >> 28 )
      v14 += 3;
    v15 = v14 + (HIDWORD(a1) >> 31);
    v13 = (_DWORD)a1 << (32 - v15);
    LODWORD(a1) = ((unsigned int)a1 >> v15) | (HIDWORD(a1) << (32 - v15));
    HIDWORD(a1) >>= v15;
    v12 = v15 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v13 = (v13 >> 1) | (v1 << 31);
      if ( (unsigned int)((v12 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v13, 1);
  v13 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v12 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v13 >= 0x80000000;
    if ( v13 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v13) = 32 - v8;
    HIDWORD(a1) <<= v8;
    if ( v7 )
    {
      HIDWORD(a1) |= (unsigned int)a1 >> v13;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v9 = v3 - v6;
  if ( v7 )
  {
    v10 = ~v9;
    v7 = v10 < 31;
    v11 = v10 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v11 + 32)) | (HIDWORD(a1) << -v11);
    else
      LODWORD(a1) = HIDWORD(a1) >> v11;
  }
  return a1;
}

//----- (0005CBC4) --------------------------------------------------------
int __fastcall sub_5CBC4(__int64 a1, __int64 a2)
{
  __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _gnu_uldivmod_helper(a1, a2, &v3);
  else
    return raise(8);
}

//----- (0005CC10) --------------------------------------------------------
int __fastcall sub_5CC10(double a1)
{
  __int64 v1; // r0
  __int64 v2; // r0

  if ( a1 >= 0.0 )
  {
    LODWORD(v2) = sub_5CC48(a1);
  }
  else
  {
    HIDWORD(a1) ^= 0x80000000;
    LODWORD(v1) = sub_5CC48(a1);
    return -v1;
  }
  return v2;
}
// 5CC38: variable 'v1' is possibly undefined

//----- (0005CC48) --------------------------------------------------------
unsigned int __fastcall sub_5CC48(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (0005CC90) --------------------------------------------------------
int __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r0

  LODWORD(v5) = sub_5CD08(a1, a2);
  *a3 = a1 - a2 * v5;
  return v5;
}
// 5CCB4: variable 'v5' is possibly undefined

//----- (0005CCCC) --------------------------------------------------------
int __fastcall _gnu_uldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r0

  LODWORD(v5) = sub_5D160(a1, HIDWORD(a1), a2, HIDWORD(a2));
  *a3 = a1 - v5 * a2;
  return v5;
}
// 5CCEC: variable 'v5' is possibly undefined

//----- (0005CD08) --------------------------------------------------------
int __fastcall sub_5CD08(__int64 a1, __int64 a2)
{
  __int64 v2; // kr00_8
  __int64 v3; // kr08_8
  int v4; // r4
  unsigned int v5; // r6
  unsigned int v6; // r9
  __int64 v7; // r10
  unsigned int v8; // r3
  unsigned int v9; // r5
  int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r8
  unsigned int v14; // r0
  unsigned int v15; // r10
  unsigned int v16; // r7
  unsigned int v17; // r12
  unsigned int v18; // r6
  int v19; // r12
  unsigned int v20; // r3
  unsigned int v21; // r7
  int v22; // r5
  unsigned int v23; // r8
  unsigned int v24; // r7
  int v25; // r0
  unsigned int v26; // r3
  unsigned int v27; // r2
  int v28; // r11
  unsigned int v29; // r0
  unsigned int v30; // r1
  unsigned int v31; // r9
  unsigned int v32; // r5
  unsigned int v33; // r8
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r2
  int v37; // r7
  unsigned int v38; // r0
  unsigned int v39; // r10
  unsigned int v40; // r9
  unsigned int v41; // r12
  unsigned int v42; // r6
  unsigned int v43; // r10
  bool v44; // cf
  unsigned int v45; // r6
  unsigned int v46; // r7
  unsigned int v47; // r9
  int v48; // r0
  unsigned int v49; // r1
  unsigned int v50; // r2
  int v51; // r3
  unsigned int v52; // r0
  unsigned int v53; // r1
  unsigned int v54; // r11
  unsigned int v55; // r12
  unsigned int v56; // r11
  unsigned __int64 v57; // r2
  bool v58; // r3
  __int64 v59; // r0
  unsigned int v61; // [sp+4h] [bp-8h]

  v2 = a1;
  v3 = a2;
  if ( a1 < 0 )
  {
    v4 = -1;
    v2 = -a1;
  }
  else
  {
    v4 = 0;
  }
  if ( a2 < 0 )
  {
    v4 = ~v4;
    v3 = -a2;
  }
  v5 = v3;
  v6 = HIDWORD(v2);
  LODWORD(v7) = v2;
  if ( !HIDWORD(v3) )
  {
    if ( (unsigned int)v3 > HIDWORD(v2) )
    {
      v8 = __clz(v3);
      if ( v8 )
      {
        v5 = (_DWORD)v3 << v8;
        LODWORD(v7) = (_DWORD)v2 << v8;
        v6 = ((unsigned int)v2 >> (32 - v8)) | (HIDWORD(v2) << v8);
      }
      v9 = HIWORD(v5);
      v10 = v6 / HIWORD(v5);
      v11 = WORD1(v7) | ((v6 % HIWORD(v5)) << 16);
      v12 = (unsigned __int16)v5 * v10;
      if ( v11 < v12 )
      {
        v44 = __CFADD__(v11, v5);
        v11 += v5;
        v13 = v10 - 1;
        if ( !v44 && v11 < v12 )
        {
          v13 = v10 - 2;
          v11 += v5;
        }
      }
      else
      {
        v13 = v6 / v9;
      }
      v14 = (v11 - v12) / v9;
      v15 = (unsigned __int16)v7 | (((v11 - v12) % v9) << 16);
      v16 = (unsigned __int16)v5 * v14;
      if ( v15 < v16 )
      {
        v44 = __CFADD__(v15, v5);
        v18 = v15 + v5;
        v17 = v14 - 1;
        if ( !v44 && v18 < v16 )
          v17 = v14 - 2;
      }
      else
      {
        v17 = (v11 - v12) / v9;
      }
      v19 = v17 | (v13 << 16);
      goto LABEL_70;
    }
    if ( !(_DWORD)v3 )
      v5 = 1 / 0u;
    v20 = __clz(v5);
    if ( v20 )
    {
      v5 <<= v20;
      HIDWORD(v7) = HIDWORD(v2) >> (32 - v20);
      v23 = HIWORD(v5);
      v24 = ((unsigned int)v2 >> (32 - v20)) | (HIDWORD(v2) << v20);
      LODWORD(v7) = (_DWORD)v2 << v20;
      v25 = HIDWORD(v7) / HIWORD(v5);
      v26 = HIWORD(v24) | ((HIDWORD(v7) % HIWORD(v5)) << 16);
      v27 = (unsigned __int16)v5 * v25;
      if ( v26 < v27 )
      {
        v44 = __CFADD__(v26, v5);
        v26 += v5;
        v28 = v25 - 1;
        if ( !v44 && v26 < v27 )
        {
          v28 = v25 - 2;
          v26 += v5;
        }
      }
      else
      {
        v28 = HIDWORD(v7) / v23;
      }
      v29 = (v26 - v27) / v23;
      v30 = (unsigned __int16)v24 | (((v26 - v27) % v23) << 16);
      v31 = (unsigned __int16)v5 * v29;
      if ( v30 < v31 )
      {
        v44 = __CFADD__(v30, v5);
        v30 += v5;
        v32 = v29 - 1;
        if ( !v44 && v30 < v31 )
        {
          v32 = v29 - 2;
          v30 += v5;
        }
      }
      else
      {
        v32 = (v26 - v27) / v23;
      }
      v21 = v30 - v31;
      v22 = v32 | (v28 << 16);
    }
    else
    {
      v21 = HIDWORD(v2) - v5;
      v22 = 1;
    }
    v33 = HIWORD(v5);
    v34 = v21 / HIWORD(v5);
    HIDWORD(v7) = v21 % HIWORD(v5);
    v35 = v7 >> 16;
    v36 = (unsigned __int16)v5 * v34;
    if ( v35 < v36 )
    {
      v44 = __CFADD__(v35, v5);
      v35 += v5;
      v37 = v34 - 1;
      if ( !v44 && v35 < v36 )
      {
        v37 = v34 - 2;
        v35 += v5;
      }
    }
    else
    {
      v37 = v21 / v33;
    }
    v38 = (v35 - v36) / v33;
    v39 = (unsigned __int16)v7 | (((v35 - v36) % v33) << 16);
    v40 = (unsigned __int16)v5 * v38;
    if ( v39 < v40 )
    {
      v44 = __CFADD__(v39, v5);
      v42 = v39 + v5;
      v41 = v38 - 1;
      if ( !v44 && v42 < v40 )
        v41 = v38 - 2;
    }
    else
    {
      v41 = (v35 - v36) / v33;
    }
    v19 = v41 | (v37 << 16);
    goto LABEL_73;
  }
  if ( HIDWORD(v3) > HIDWORD(v2) )
  {
    v22 = 0;
LABEL_72:
    v19 = 0;
    goto LABEL_73;
  }
  v43 = __clz(HIDWORD(v3));
  if ( !v43 )
  {
    v44 = HIDWORD(v2) >= HIDWORD(v3);
    if ( HIDWORD(v2) <= HIDWORD(v3) )
      v44 = (unsigned int)v2 >= (unsigned int)v3;
    if ( v44 )
    {
      v19 = 1;
      v22 = 0;
      goto LABEL_73;
    }
    v22 = 0;
    goto LABEL_72;
  }
  v45 = ((unsigned int)v3 >> (32 - v43)) | (HIDWORD(v3) << v43);
  v46 = ((unsigned int)v2 >> (32 - v43)) | (HIDWORD(v2) << v43);
  v47 = HIWORD(v45);
  v61 = HIDWORD(v2) >> (32 - v43);
  v48 = v61 / HIWORD(v45);
  v49 = HIWORD(v46) | ((v61 % HIWORD(v45)) << 16);
  v50 = (unsigned __int16)v45 * v48;
  if ( v49 < v50 )
  {
    v44 = __CFADD__(v49, v45);
    v49 += v45;
    v51 = v48 - 1;
    if ( !v44 && v49 < v50 )
    {
      v51 = v48 - 2;
      v49 += v45;
    }
  }
  else
  {
    v51 = v61 / v47;
  }
  v52 = (v49 - v50) / v47;
  v53 = (unsigned __int16)v46 | (((v49 - v50) % v47) << 16);
  v54 = (unsigned __int16)v45 * v52;
  if ( v53 < v54 )
  {
    v44 = __CFADD__(v53, v45);
    v53 += v45;
    v55 = v52 - 1;
    if ( !v44 && v53 < v54 )
    {
      v55 = v52 - 2;
      v53 += v45;
    }
  }
  else
  {
    v55 = v52;
  }
  v19 = v55 | (v51 << 16);
  v56 = v53 - v54;
  v57 = (unsigned int)v19 * (unsigned __int64)(unsigned int)((_DWORD)v3 << v43);
  if ( HIDWORD(v57) > v56
    || ((v58 = HIDWORD(v57) == v56, (unsigned int)v57 > (_DWORD)v2 << v43) ? (v22 = v58) : (v22 = 0), v22) )
  {
    --v19;
LABEL_70:
    v22 = 0;
  }
LABEL_73:
  LODWORD(v59) = v19;
  if ( v4 )
    return -__SPAIR64__(v22, v19);
  return v59;
}

//----- (0005D160) --------------------------------------------------------
int __fastcall sub_5D160(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // r4
  unsigned int v6; // r7
  unsigned int v7; // r10
  unsigned int v8; // r3
  unsigned int v9; // r5
  int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r6
  unsigned int v14; // r0
  unsigned int v15; // r7
  unsigned int v16; // r8
  unsigned int v17; // r3
  unsigned int v18; // r4
  int result; // r0
  unsigned int v20; // r3
  unsigned int v21; // r10
  unsigned int v22; // r6
  unsigned int v23; // r8
  int v24; // r0
  unsigned int v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r1
  unsigned int v28; // r10
  unsigned int v29; // r6
  int v30; // r0
  unsigned int v31; // r3
  unsigned int v32; // r2
  int v33; // r10
  unsigned int v34; // r0
  unsigned int v35; // r7
  unsigned int v36; // r8
  unsigned int v37; // r3
  unsigned int v38; // r4
  unsigned int v39; // r7
  bool v40; // cf
  unsigned int v41; // r11
  unsigned int v42; // r4
  unsigned int v43; // r5
  unsigned int v44; // r10
  int v45; // r0
  unsigned int v46; // r12
  unsigned int v47; // r3
  int v48; // r11
  unsigned int v49; // r0
  unsigned int v50; // r1
  unsigned int v51; // r9
  unsigned int v52; // r3
  unsigned int v53; // r9
  unsigned __int64 v54; // r2
  _BOOL4 v55; // r5

  v5 = a3;
  v6 = a1;
  v7 = a2;
  if ( !a4 )
  {
    if ( a3 <= a2 )
    {
      if ( !a3 )
        v5 = 1 / 0u;
      v20 = __clz(v5);
      if ( v20 )
      {
        v5 <<= v20;
        v6 = a1 << v20;
        v22 = HIWORD(v5);
        v23 = (a1 >> (32 - v20)) | (a2 << v20);
        v24 = (a2 >> (32 - v20)) / HIWORD(v5);
        v25 = HIWORD(v23) | (((a2 >> (32 - v20)) % HIWORD(v5)) << 16);
        v26 = (unsigned __int16)v5 * v24;
        if ( v25 < v26 )
        {
          v40 = __CFADD__(v25, v5);
          v25 += v5;
          if ( !v40 && v25 < v26 )
            v25 += v5;
        }
        v27 = (unsigned __int16)v23 | (((v25 - v26) % v22) << 16);
        v28 = (unsigned __int16)v5 * ((v25 - v26) / v22);
        if ( v27 < v28 )
        {
          v40 = __CFADD__(v27, v5);
          v27 += v5;
          if ( !v40 && v27 < v28 )
            v27 += v5;
        }
        v21 = v27 - v28;
      }
      else
      {
        v21 = a2 - v5;
      }
      v29 = HIWORD(v5);
      v30 = v21 / HIWORD(v5);
      v31 = HIWORD(v6) | ((v21 % HIWORD(v5)) << 16);
      v32 = (unsigned __int16)v5 * v30;
      if ( v31 < v32 )
      {
        v40 = __CFADD__(v31, v5);
        v31 += v5;
        v33 = v30 - 1;
        if ( !v40 && v31 < v32 )
        {
          v33 = v30 - 2;
          v31 += v5;
        }
      }
      else
      {
        v33 = v21 / v29;
      }
      v34 = (v31 - v32) / v29;
      v35 = (unsigned __int16)v6 | (((v31 - v32) % v29) << 16);
      v36 = (unsigned __int16)v5 * v34;
      if ( v35 < v36 )
      {
        v40 = __CFADD__(v35, v5);
        v38 = v35 + v5;
        v37 = v34 - 1;
        if ( !v40 && v38 < v36 )
          v37 = v34 - 2;
      }
      else
      {
        v37 = (v31 - v32) / v29;
      }
      return v37 | (v33 << 16);
    }
    else
    {
      v8 = __clz(a3);
      if ( v8 )
      {
        v5 = a3 << v8;
        v6 = a1 << v8;
        v7 = (a1 >> (32 - v8)) | (a2 << v8);
      }
      v9 = HIWORD(v5);
      v10 = v7 / HIWORD(v5);
      v11 = HIWORD(v6) | ((v7 % HIWORD(v5)) << 16);
      v12 = (unsigned __int16)v5 * v10;
      if ( v11 < v12 )
      {
        v40 = __CFADD__(v11, v5);
        v11 += v5;
        v13 = v10 - 1;
        if ( !v40 && v11 < v12 )
        {
          v13 = v10 - 2;
          v11 += v5;
        }
      }
      else
      {
        v13 = v7 / v9;
      }
      v14 = (v11 - v12) / v9;
      v15 = (unsigned __int16)v6 | (((v11 - v12) % v9) << 16);
      v16 = (unsigned __int16)v5 * v14;
      if ( v15 < v16 )
      {
        v40 = __CFADD__(v15, v5);
        v18 = v15 + v5;
        v17 = v14 - 1;
        if ( !v40 && v18 < v16 )
          v17 = v14 - 2;
      }
      else
      {
        v17 = (v11 - v12) / v9;
      }
      return v17 | (v13 << 16);
    }
  }
  if ( a4 > a2 )
    return 0;
  v39 = __clz(a4);
  if ( !v39 )
  {
    v40 = a2 >= a4;
    if ( a2 <= a4 )
      return a1 >= a3;
    return v40;
  }
  v41 = a2 >> (32 - v39);
  v42 = (a3 >> (32 - v39)) | (a4 << v39);
  v43 = (a1 >> (32 - v39)) | (a2 << v39);
  v44 = HIWORD(v42);
  v45 = v41 / HIWORD(v42);
  v46 = HIWORD(v43) | ((v41 % HIWORD(v42)) << 16);
  v47 = (unsigned __int16)v42 * v45;
  if ( v46 < v47 )
  {
    v40 = __CFADD__(v46, v42);
    v46 += v42;
    v48 = v45 - 1;
    if ( !v40 && v46 < v47 )
    {
      v48 = v45 - 2;
      v46 += v42;
    }
  }
  else
  {
    v48 = v41 / v44;
  }
  v49 = (v46 - v47) / v44;
  v50 = (unsigned __int16)v43 | (((v46 - v47) % v44) << 16);
  v51 = (unsigned __int16)v42 * v49;
  if ( v50 < v51 )
  {
    v40 = __CFADD__(v50, v42);
    v50 += v42;
    v52 = v49 - 1;
    if ( !v40 && v50 < v51 )
    {
      v52 = v49 - 2;
      v50 += v42;
    }
  }
  else
  {
    v52 = (v46 - v47) / v44;
  }
  result = v52 | (v48 << 16);
  v53 = v50 - v51;
  v54 = (unsigned int)result * (unsigned __int64)(a3 << v39);
  if ( HIDWORD(v54) > v53 || ((unsigned int)v54 > a1 << v39 ? (v55 = HIDWORD(v54) == v53) : (v55 = 0), v55) )
    --result;
  return result;
}

//----- (0005D540) --------------------------------------------------------
void __fastcall init(int a1, int a2, int a3)
{
  int v6; // r6
  unsigned int v7; // r5
  int v8; // r4
  void (__fastcall *v9)(int, int, int); // t1

  init_proc();
  v6 = &off_751B4 - off_751B0;
  if ( v6 )
  {
    v7 = 0x751ACu;
    v8 = 0;
    do
    {
      ++v8;
      v9 = *(void (__fastcall **)(int, int, int))(v7 + 4);
      v7 += 4;
      v9(a1, a2, a3);
    }
    while ( v8 != v6 );
  }
}
// 751B0: using guessed type int (*off_751B0[2])();
// 751B4: using guessed type int (*off_751B4)();

//----- (0005D5A8) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=1191 queued=785 decompiled=785 lumina nreq=0 worse=0 better=0
// ALL OK, 785 function(s) have been successfully decompiled
