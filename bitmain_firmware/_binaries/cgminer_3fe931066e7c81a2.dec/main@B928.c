void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int v3; // r0
  int (*v4)(void); // r3
  int (**v5)(); // r12
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r5
  int v11; // r4
  int v12; // r7
  const char **v13; // r8
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  int *v48; // r12
  unsigned int v49; // r3
  int v50; // r2
  unsigned int v51; // r0
  unsigned int v52; // r3
  unsigned int v53; // r2
  unsigned int v54; // r3
  _DWORD *v55; // r2
  int v56; // r3
  int v57; // r2
  _DWORD *v58; // r2
  int v59; // r1
  int v60; // r5
  size_t v61; // r6
  _DWORD *v62; // r0
  _DWORD *v63; // r7
  _DWORD *v64; // r0
  unsigned int v65; // r3
  _DWORD *v66; // r1
  _DWORD *v67; // r5
  unsigned int n; // r6
  _DWORD *v69; // r9
  int v70; // r6
  char *v71; // r8
  unsigned int v72; // r3
  int v73; // r3
  _DWORD *v74; // r3
  unsigned int v75; // r1
  unsigned int v76; // r2
  bool v77; // cc
  int v78; // r2
  int v79; // r3
  int v80; // r5
  _DWORD *v81; // r0
  char *v82; // r3
  const char *v83; // r2
  _DWORD *v84; // r12
  int v85; // r0
  int v86; // r1
  int v87; // r2
  int v88; // r12
  char *v89; // r3
  int v90; // r2
  int v91; // r5
  char *v92; // r4
  int v93; // r6
  int v94; // r7
  FILE *v95; // r5
  signed int v96; // r0
  char *v97; // r0
  const char *v98; // r1
  char *v99; // r5
  char *v100; // r0
  unsigned __int8 *v101; // r3
  unsigned __int8 *v102; // r3
  unsigned __int8 *v103; // r3
  size_t v104; // r0
  _BYTE *v105; // r1
  _BYTE *v106; // lr
  unsigned __int8 *v107; // r3
  int v108; // r2
  bool v109; // zf
  int v110; // r0
  bool v111; // zf
  int *__attribute__((__org_arrdim(0,2))) v112; // r12
  FILE *v113; // r0
  int v114; // r3
  int v115; // r3
  bool v116; // zf
  int *v117; // r6
  char *v118; // r9
  int v119; // r10
  FILE *v120; // r0
  int v121; // r3
  char *v122; // r6
  int v123; // r10
  char *v124; // r9
  char *v125; // r4
  FILE *v126; // r0
  int v127; // r3
  int *__attribute__((__org_arrdim(0,2))) v128; // r12
  int v129; // r5
  int v130; // r6
  pthread_rwlock_t *v131; // r0
  char *v132; // r7
  int v133; // r5
  char *v134; // r8
  unsigned int v135; // r6
  int v136; // r3
  int v137; // r3
  int *__attribute__((__org_arrdim(0,2))) v138; // r12
  int *__attribute__((__org_arrdim(0,2))) v139; // r12
  int *v140; // r3
  int v141; // r0
  int v142; // t1
  int *__attribute__((__org_arrdim(0,2))) v143; // r12
  int *__attribute__((__org_arrdim(0,2))) v144; // r12
  int v145; // r6
  char *v146; // r7
  int v147; // r9
  int v148; // r3
  const char *v149; // r10
  size_t v150; // r0
  size_t v151; // r4
  char *v152; // r0
  int *__attribute__((__org_arrdim(0,2))) v153; // r12
  int v154; // r2
  unsigned __int8 *v155; // r7
  __sighandler_t v156; // r8
  __sighandler_t v157; // r0
  bool v158; // zf
  __pid_t v159; // r0
  __pid_t v160; // r8
  int *__attribute__((__org_arrdim(0,2))) v161; // r12
  _DWORD *v162; // r0
  _DWORD *v163; // r7
  void *v164; // r0
  void *v165; // r6
  int v166; // r6
  int v167; // r9
  int v168; // r8
  int v169; // r7
  _DWORD *v170; // r4
  int v171; // r6
  _DWORD *v172; // r0
  int v173; // r3
  sem_t *v174; // r0
  sem_t *v175; // r6
  char *v176; // r4
  int v177; // r3
  int *v178; // r1
  int v179; // r12
  int v180; // r0
  int j; // r1
  int v182; // lr
  int v183; // r6
  int v184; // r9
  const char *v185; // r1
  int v186; // r2
  int v187; // r3
  int v188; // r1
  int *__attribute__((__org_arrdim(0,2))) v189; // r12
  FILE *v190; // r0
  int v191; // r3
  int v192; // r6
  int v193; // r12
  int v194; // r2
  int v195; // lr
  int v196; // r3
  int v197; // r12
  int v198; // r1
  int v199; // r2
  int *__attribute__((__org_arrdim(0,2))) v200; // r12
  int *__attribute__((__org_arrdim(0,2))) v201; // r12
  int *__attribute__((__org_arrdim(0,2))) v202; // r12
  int v203; // r7
  int v204; // r6
  int v205; // r3
  int v206; // r3
  char *v207; // r0
  int v208; // r0
  int v209; // r8
  int v210; // r0
  int v211; // r2
  int *v212; // lr
  int v213; // r0
  int v214; // r3
  int v215; // t1
  int v216; // r9
  int v217; // t1
  int v218; // r3
  int v219; // r9
  int v220; // r3
  int v221; // r3
  int v222; // r0
  int v223; // r1
  int v224; // r12
  int v225; // r0
  struct timeval *v226; // r6
  char *v227; // r9
  _DWORD *v228; // r3
  int *__attribute__((__org_arrdim(0,2))) v229; // r12
  int *__attribute__((__org_arrdim(0,2))) v230; // r12
  int *__attribute__((__org_arrdim(0,2))) v231; // r12
  int *v232; // r3
  int v233; // r1
  int v234; // t1
  int v235; // r9
  int v236; // r2
  int *v237; // lr
  int v238; // r0
  int v239; // r3
  int v240; // t1
  int v241; // r6
  int v242; // t1
  int v243; // r3
  int v244; // r6
  int v245; // r3
  int v246; // r3
  int v247; // r0
  int v248; // r1
  int v249; // r12
  int v250; // r0
  int v251; // r6
  _DWORD *v252; // r8
  char *v253; // r9
  char *v254; // lr
  int v255; // r1
  int v256; // r2
  int v257; // r3
  int v258; // r1
  int v259; // r2
  int v260; // r3
  int v261; // r3
  int *__attribute__((__org_arrdim(0,2))) v262; // r12
  char *v263; // r0
  int *__attribute__((__org_arrdim(0,2))) v264; // r12
  int *__attribute__((__org_arrdim(0,2))) v265; // r12
  int *__attribute__((__org_arrdim(0,2))) v266; // r12
  int *__attribute__((__org_arrdim(0,2))) v267; // r12
  int k; // r6
  int v269; // r3
  int v270; // r8
  char *v271; // r10
  char *v272; // r9
  int m; // r8
  int *__attribute__((__org_arrdim(0,2))) v274; // r12
  const char *v275; // r1
  int v276; // r2
  int *__attribute__((__org_arrdim(0,2))) v277; // r12
  int *__attribute__((__org_arrdim(0,2))) v278; // r12
  char v279; // [sp+10h] [bp-31FCh] BYREF
  char v280[500]; // [sp+1018h] [bp-21F4h] BYREF
  _BYTE v281[3588]; // [sp+120Ch] [bp-2000h] BYREF
  char *v282; // [sp+2024h] [bp-11E8h]
  int *v283; // [sp+2028h] [bp-11E4h]
  void (**v284)(void); // [sp+202Ch] [bp-11E0h]
  char *v285; // [sp+2030h] [bp-11DCh]
  int *v286; // [sp+2034h] [bp-11D8h]
  char *v287; // [sp+2038h] [bp-11D4h]
  const char **v288; // [sp+203Ch] [bp-11D0h]
  char *v289; // [sp+2040h] [bp-11CCh]
  char *v290; // [sp+2044h] [bp-11C8h]
  int *v291; // [sp+2048h] [bp-11C4h]
  int v292; // [sp+204Ch] [bp-11C0h] BYREF
  struct sigaction v293; // [sp+2054h] [bp-11B8h] BYREF
  char v294[256]; // [sp+20E0h] [bp-112Ch] BYREF
  int v295[11]; // [sp+21E0h] [bp-102Ch] BYREF

  v288 = a2;
  v292 = a1;
  strcpy(dword_78CE8, "cgminer.log");
  byte_78CE0 = 0;
  strcpy(word_78DE8, "a+");
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v4 = sched_yield;
    v5 = &off_75ED8;
  }
  v7 = 4 * (v292 + 1);
  if ( v6 )
    *v5 = v4;
  v8 = malloc(v7);
  v9 = v292;
  v10 = v8;
  dword_77290 = (int)v8;
  if ( v292 > 0 )
  {
    v11 = 0;
    v12 = 0;
    v13 = v288;
    do
    {
      ++v12;
      v14 = _strdup(v13[v11]);
      v9 = v292;
      v10[v11++] = v14;
    }
    while ( v9 > v12 );
  }
  v10[v9] = 0;
  sub_17990(&stru_7B384, "main", 10693);
  sub_17990(&stru_7B85C, "main", 10694);
  sub_17990(&mutex, "main", 10695);
  sub_179E8((int)&stru_7BA10, "main", 10696);
  sub_17990(&stru_7AD4C, "main", 10697);
  sub_17990(&stru_770B8, "main", 10698);
  sub_179E8((int)&stru_7B9D8, "main", 10699);
  sub_17990(&stru_77030, "main", 10700);
  sub_179BC(&stru_77294, "main", 10701);
  sub_179BC(&stru_7B2D8, "main", 10702);
  sub_179BC(&rwlock, "main", 10703);
  sub_179BC(&stru_7B700, "main", 10704);
  sub_17990(&stru_77060, "main", 10706);
  if ( pthread_cond_init(&stru_77078, 0) )
  {
    strcpy((char *)v295, "Failed to pthread_cond_init lp_cond");
    sub_38730(3, (const char *)v295, 1);
    sub_1D8FC(1, 0);
  }
  sub_17990(&stru_7B62C, "main", 10710);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v295, "Failed to pthread_cond_init restart_cond");
    sub_38730(3, (const char *)v295, 1);
    sub_1D8FC(1, 0);
  }
  if ( pthread_cond_init(&stru_7B1A0, 0) )
  {
    strcpy((char *)v295, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2A168();
    dword_7B620 = (int)v15;
    if ( v15 )
    {
      dword_7704C = (int)(v15 + 12);
      snprintf(byte_76BF4, 0x100u, "%s %s", "cgminer", a49);
      v293.sa_flags = 0;
      v293.sa_handler = (__sighandler_t)sub_1795C;
      sigemptyset(&v293.sa_mask);
      sigaction(15, &v293, &oact);
      sigaction(2, &v293, &stru_7B94C);
      signal(13, (__sighandler_t)1);
      dword_7BC74 = (int)v280;
      strcpy(v280, "/usr/bin");
      dword_7B8B4 = (int)&v279;
      v16 = _strdup(*v288);
      v17 = (char *)dword_7B8B4;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_7B8B4 + strlen((const char *)dword_7B8B4)) = 47;
      dword_77028 = 8;
      dword_7701C = 9;
      dword_77024 = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        v289 = (char *)v295;
        strcpy((char *)v295, "main OOM");
        sub_38730(3, (const char *)v295, 1);
        sub_16CA8(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_772B4;
      v6 = dword_772B4 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_772B4 = (int)v20;
        v162 = malloc(0x2Cu);
        v163 = v162;
        *((_DWORD *)v20 + 17) = v162;
        if ( !v162 )
          goto LABEL_258;
        memset(v162, 0, 0x2Cu);
        v291 = (int *)(v20 + 68);
        v163[4] = v20 + 68;
        v163[1] = 32;
        v163[2] = 5;
        v163[5] = 68;
        v164 = malloc(0x180u);
        *v163 = v164;
        if ( !v164 )
          goto LABEL_258;
        memset(v164, 0, 0x180u);
        v24 = (int)v20;
        v163[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v291 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_22;
        case 0xAu:
          goto LABEL_21;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_21:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_22:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_23:
          v27 += v22[7] << 24;
LABEL_24:
          v27 += v22[6] << 16;
LABEL_25:
          v27 += v22[5] << 8;
LABEL_26:
          v27 += v22[4];
LABEL_27:
          v28 += v22[3] << 24;
LABEL_28:
          v28 += v22[2] << 16;
LABEL_29:
          v28 += v22[1] << 8;
LABEL_30:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = v291;
      v49 = (v45 - v46 - v47) ^ (v47 >> 13);
      v50 = (v46 - v47 - v49) ^ (v49 >> 12);
      v51 = (v47 - v49 - v50) ^ (v50 << 16);
      v52 = (v49 - v50 - v51) ^ (v51 >> 5);
      v53 = v50 - v51 - v52;
      v54 = (v52 - (v53 ^ (v52 >> 3)) - ((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)))
          ^ (((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v54;
      v55 = *(_DWORD **)(v24 + 68);
      v56 = 12 * (v54 & (v55[1] - 1));
      ++*(_DWORD *)(*v55 + v56 + 4);
      v57 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v57;
      v58 = *(_DWORD **)(v24 + 68);
      v59 = *(_DWORD *)(*v58 + v56);
      if ( v59 )
      {
        *(_DWORD *)(v59 + 12) = v291;
        v58 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v58 + v56) = v48;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 8)
                                                                          + 1))
        || (v60 = *((_DWORD *)v20 + 17), *(_DWORD *)(v60 + 36) == 1) )
      {
LABEL_56:
        strcpy(dest, v20);
        dword_7B440 = (int)&dword_7B440;
        dword_7B444 = (int)&dword_7B440;
        sub_5BBB8((int)&off_75600, (int)"Options for both config file and command line");
        sub_5BBB8((int)&off_75E24, (int)"Options for command line only");
        sub_5BC84(&v292, v288, (void (*)(const char *, ...))sub_11C44);
        if ( v292 != 1 )
        {
          strcpy((char *)v295, "Unexpected extra commandline arguments");
          sub_38730(3, (const char *)v295, 1);
          sub_1D8FC(1, 0);
        }
        v80 = (unsigned __int8)byte_76F20;
        if ( !byte_76F20 )
        {
          dword_76F24 = (int)malloc(0x1000u);
          sub_16150((char *)dword_76F24);
          if ( access((const char *)dword_76F24, 4) )
          {
            free((void *)dword_76F24);
            dword_76F24 = v80;
          }
          else
          {
            sub_16D98((char *)dword_76F24);
          }
        }
        if ( byte_7730D || dword_76FFC )
        {
          if ( byte_7B859 )
          {
            v289 = (char *)v295;
            strcpy((char *)v295, "Cannot use benchmark mode with scrypt");
            sub_38730(3, (const char *)v295, 1);
            sub_16CA8(1);
          }
          v289 = (char *)v295;
          v282 = sub_17A3C();
          v81 = malloc(0xFFu);
          v82 = v282;
          if ( dword_76FFC )
            v83 = "Benchfile";
          else
            v83 = "Benchmark";
          *((_DWORD *)v282 + 49) = v81;
          v84 = v81;
          v85 = *(_DWORD *)v83;
          v86 = *((_DWORD *)v83 + 1);
          v87 = *((_DWORD *)v83 + 2);
          *v84 = v85;
          v84[1] = v86;
          *((_WORD *)v84 + 4) = v87;
          v88 = *((_DWORD *)v82 + 49);
          *((_DWORD *)v82 + 51) = v88;
          *((_DWORD *)v82 + 52) = v88;
          *((_DWORD *)v82 + 50) = v88;
          *((_DWORD *)v82 + 156) = v88;
          v282 = v82;
          strncpy(v82 + 48, "?", 7u);
          v89 = v282;
          v90 = *((_DWORD *)v282 + 33);
          v282[55] = 0;
          if ( v90 != 1 )
          {
            *((_DWORD *)v89 + 33) = 1;
            ++dword_7B5E4;
          }
          v91 = 0;
          v92 = (char *)byte_78BD0;
          v89[129] = 0;
          byte_78CA9 = 1;
          do
          {
            v93 = 324 * v91;
            v94 = 5 * v91++;
            v94 *= 32;
            sub_29830(&byte_7731C[v94], (unsigned __int8 *)&a000000029c6bf4[v93], 160);
            sub_29830(&byte_77D1C[v94], (unsigned __int8 *)&a00000002c01f50[v93], 160);
          }
          while ( v91 != 16 );
          sub_16244((int)dword_78730);
        }
        else
        {
          v92 = (char *)byte_78BD0;
          v289 = (char *)v295;
        }
        if ( !dword_76BF0 )
        {
          v287 = &byte_7AD48;
          goto LABEL_108;
        }
        v95 = fopen((const char *)dword_76BF0, "rb");
        memset(v294, 0, sizeof(v294));
        if ( v95 )
        {
          v96 = fread(v294, 1u, 0x100u, v95);
          if ( v96 > 0 )
          {
            v97 = strchr(v294, 10);
            v98 = v294;
            v99 = v97;
            v6 = v97 == 0;
            v100 = s;
            if ( !v6 )
            {
              memcpy(s, v294, v99 - v294);
              v100 = byte_78850;
              v98 = v99 + 1;
            }
            strcpy(v100, v98);
            v101 = &byte_78BD0[strlen(s) - 1];
            if ( *(v101 - 1152) == 10 )
              *(v101 - 1152) = 0;
            v102 = &byte_78BD0[strlen(s) - 1];
            if ( *(v102 - 1152) == 13 )
              *(v102 - 1152) = 0;
            v103 = &byte_78BD0[strlen(byte_78850) - 1];
            if ( *(v103 - 896) == 10 )
              *(v103 - 896) = 0;
            v104 = strlen(byte_78850) - 1;
            v107 = &byte_78BD0[v104];
            v108 = byte_78BD0[v104 - 896];
            v109 = v108 == 13;
            if ( v108 == 13 )
            {
              v105 = v281;
              v108 = 44360;
            }
            else
            {
              v106 = v281;
            }
            if ( v109 )
              HIWORD(v108) = 7;
            else
              v104 = 44360;
            if ( v109 )
            {
              *((_DWORD *)v105 + 907) = v108;
              LOBYTE(v108) = 0;
            }
            else
            {
              HIWORD(v104) = 7;
            }
            if ( v109 )
              *(v107 - 896) = v108;
            else
              *((_DWORD *)v106 + 907) = v104;
            goto LABEL_103;
          }
          v287 = &byte_7AD48;
          if ( byte_7AD48 || (v285 = &byte_78E08, byte_78E08) || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Read miner version file %s error %d", (const char *)dword_76BF0, v96);
            goto LABEL_250;
          }
        }
        else
        {
          v287 = &byte_7AD48;
          if ( byte_7AD48 || (v285 = &byte_78E08, byte_78E08) || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Open miner version file %s error", (const char *)dword_76BF0);
LABEL_250:
            sub_38730(3, v289, 0);
LABEL_103:
            if ( *v287 )
            {
LABEL_107:
              snprintf(v289, 0x1000u, "Miner compile time: %s type: %s", s, byte_78850);
              sub_38730(3, v289, 0);
              goto LABEL_108;
            }
            v285 = &byte_78E08;
          }
        }
        if ( *v285 || dword_766C4 > 2 )
          goto LABEL_107;
LABEL_108:
        if ( dword_76BE0 )
        {
          byte_78CE0 = 1;
          strcpy(dword_78CE8, (const char *)dword_76BE0);
          if ( dword_76BEC )
            strcpy(word_78DE8, (const char *)dword_76BEC);
          if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 2) )
          {
            snprintf(v289, 0x1000u, "Log file path: %s Open flag: %s", dword_78CE8, word_78DE8);
            sub_38730(3, v289, 0);
          }
        }
        if ( dword_76BE8 )
        {
          memset(v294, 0, sizeof(v294));
          if ( dword_76BE4 )
          {
            if ( !*(_BYTE *)dword_76BE4 )
            {
              v161 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Log work asic num empty";
              strcpy((char *)v161 + 4, "work asic num empty");
              sub_38730(3, v289, 1);
              sub_16CA8(1);
            }
            v110 = strtol((const char *)dword_76BE4, 0, 10);
            v111 = v110 == 32;
            if ( v110 != 32 )
              v111 = v110 == 1;
            dword_78950 = v110;
            if ( !v111 && v110 != 64 )
            {
              v112 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy((char *)v112 + 4, "work asic num must be 1, 32, 64");
              sub_38730(3, v289, 1);
              sub_16CA8(1);
            }
            if ( *v287 || byte_78E08 || dword_766C4 > 2 )
            {
              snprintf(
                v289,
                0x1000u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_76BE8,
                (const char *)dword_76BE4);
              sub_38730(3, v289, 0);
            }
          }
          else if ( *v287 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Log work path: %s", (const char *)dword_76BE8);
            sub_38730(3, v289, 0);
          }
          sprintf(v294, "%s.txt", (const char *)dword_76BE8);
          v113 = fopen(v294, "a+");
          v114 = (unsigned __int8)*v287;
          dword_78954 = (int)v113;
          if ( v114 || byte_78E08 || dword_766C4 > 2 )
          {
            snprintf(v289, 0x1000u, "Log work open file %s", v294);
            sub_38730(3, v289, 0);
          }
          v115 = dword_78950;
          if ( dword_78950 == 1 )
          {
            sprintf(v294, "%s%02d.txt", (const char *)dword_76BE8, 1);
            v190 = fopen(v294, "a+");
            v191 = (unsigned __int8)*v287;
            dword_78958[0] = (int)v190;
            if ( v191 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 2) )
            {
              snprintf(v289, 0x1000u, "Log work open asic %d file %s", dword_78950, v294);
              sub_38730(3, v289, 0);
            }
          }
          else
          {
            v116 = dword_78950 == 32;
            if ( dword_78950 != 32 )
              v116 = dword_78950 == 64;
            if ( v116 && dword_78950 >= 0 )
            {
              v117 = &dword_78954;
              v118 = v289;
              v119 = 0;
              do
              {
                sprintf(v294, "%s%02d_%02d.txt", (const char *)dword_76BE8, v115, v119);
                v120 = fopen(v294, "a+");
                v121 = (unsigned __int8)*v287;
                v117[1] = (int)v120;
                ++v117;
                if ( v121 || byte_78E08 || dword_766C4 > 2 )
                {
                  snprintf(v118, 0x1000u, "Log work open asic %d file %s", dword_78950, v294);
                  sub_38730(3, v118, 0);
                }
                v115 = dword_78950;
                ++v119;
              }
              while ( dword_78950 >= v119 );
            }
          }
          if ( byte_78A5C )
          {
            v122 = &byte_78A5C;
            v123 = 0;
            v291 = (int *)byte_78BD0;
            v124 = v289;
            v125 = v287;
            do
            {
              sprintf(v294, "%s_diff_%02d.txt", (const char *)dword_76BE8, v123);
              v126 = fopen(v294, "a+");
              v127 = (unsigned __int8)*v125;
              *((_DWORD *)v122 + 1) = v126;
              v122 += 4;
              if ( v127 || byte_78E08 || dword_766C4 > 2 )
              {
                snprintf(v124, 0x1000u, "Log work open diff file %s", v294);
                sub_38730(3, v124, 0);
              }
              ++v123;
            }
            while ( v123 != 65 );
            v92 = (char *)v291;
          }
        }
        if ( byte_7BB18 )
        {
          v286 = dword_755F0;
          byte_75DD0 = 0;
        }
        else
        {
          v286 = dword_755F0;
          if ( byte_75DD0 )
            sub_27BA0();
        }
        if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
        {
          snprintf(v289, 0x1000u, "Started %s", byte_76BF4);
          sub_38730(4, v289, 0);
        }
        if ( !dword_76F24 )
        {
LABEL_172:
          *(_WORD *)(dword_7BC74 + strlen((const char *)dword_7BC74)) = 47;
          if ( byte_7B858 )
            byte_78E08 = 1;
          if ( v286[512] < 0 )
          {
            if ( byte_7B859 )
              v137 = 30;
            else
              v137 = 60;
            v286[512] = v137;
          }
          *((_DWORD *)v92 - 27) = 8;
          dword_7B0FC = (int)calloc(8u, 0x40u);
          if ( !dword_7B0FC )
          {
            v200 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Failed to calloc control_thr";
            strcpy((char *)v200 + 4, "ed to calloc control_thr");
            sub_38730(3, v289, 1);
            sub_1D8FC(1, 0);
          }
          v129 = 0;
          dword_78B68 = 0;
          v282 = (char *)&unk_7B728;
          sub_27CD0((int)&unk_7B728);
          sub_27CD0((int)&unk_7ACC8);
          sub_27CD0((int)&unk_7B7D8);
          sub_27CD0((int)&unk_7B448);
          sub_27CD0((int)&unk_76AC8);
          sub_27CD0((int)&unk_7BCA0);
          sub_27CD0((int)&unk_7B4D8);
          sub_27CD0((int)&unk_7B678);
          sub_27CD0((int)&unk_7BA48);
          sub_27CD0((int)&unk_7AD68);
          sub_27CD0((int)&unk_7BB70);
          sub_27CD0((int)&unk_7AE70);
          sub_27CD0((int)&unk_7B300);
          sub_27CD0((int)&unk_7B258);
          sub_27CD0((int)&unk_7AF70);
          sub_27CD0((int)&unk_7B8C0);
          sub_27CD0((int)&unk_7B078);
          sub_27CD0((int)&unk_7AFF0);
          sub_27CD0((int)&unk_7B560);
          sub_27CD0((int)&unk_7B3A0);
          sub_27CD0((int)&unk_7B1D0);
          sub_27CD0((int)&unk_7BBF0);
          sub_27CD0((int)&unk_7AEF0);
          sub_27CD0((int)&unk_7ADE8);
          (*((void (__fastcall **)(_DWORD))v282 + 3))(0);
          off_7ACD4(0);
          off_7B7E4(0);
          off_7B454(0);
          off_76AD4();
          off_7BCAC(0);
          off_7B4E4(0);
          off_7B684(0);
          off_7BA54(0);
          off_7AD74(0);
          ((void (__fastcall *)(_DWORD))off_7BB7C)(0);
          off_7AE7C(0);
          off_7B30C(0);
          off_7B264(0);
          off_7AF7C(0);
          off_7B8CC(0);
          ((void (__fastcall *)(_DWORD))off_7B084)(0);
          off_7AFFC(0);
          off_7B56C(0);
          off_7B3AC(0);
          off_7B1DC(0);
          off_7BBFC(0);
          ((void (__fastcall *)(_DWORD))off_7AEFC)(0);
          off_7ADF4(0);
          v130 = dword_7B720;
          dword_7BB6C = 0;
          if ( dword_7B720 > 0 )
          {
            v291 = &dword_7B628;
            do
            {
              v131 = *(pthread_rwlock_t **)(dword_7B628 + 4 * v129++);
              sub_27F10(v131);
              v130 = dword_7B720;
            }
            while ( dword_7B720 > v129 );
          }
          if ( !v130 )
          {
            v189 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy((char *)v189 + 4, "devices disabled, cannot mine!");
            sub_38730(3, v289, 1);
            sub_1D8FC(1, 0);
          }
          dword_7702C = v130;
          if ( !dword_76F00 )
          {
            v291 = &dword_7B628;
            sub_1AB24(&stru_7B700, "load_temp_cutoffs", 1152);
            v196 = 0;
            v197 = *v291;
            v198 = dword_7B720;
            while ( v196 < v198 )
            {
              v199 = *(_DWORD *)(v197 + 4 * v196++);
              if ( !*(_DWORD *)(v199 + 184) )
                *(_DWORD *)(v199 + 184) = 95;
            }
            sub_19BBC(&stru_7B700, "load_temp_cutoffs", 1158);
            goto LABEL_203;
          }
          v132 = strtok((char *)dword_76F00, ",");
          if ( v132 )
          {
            v133 = 0;
            v291 = &dword_7B628;
            v134 = v289;
            do
            {
              if ( v133 >= dword_7B720 )
              {
                strcpy(v134, "Too many values passed to set temp cutoff");
                sub_38730(3, v134, 1);
                sub_16CA8(1);
              }
              v135 = strtol(v132, 0, 10);
              if ( v135 > 0xC8 )
              {
                strcpy(v134, "Invalid value passed to set temp cutoff");
                sub_38730(3, v134, 1);
                sub_16CA8(1);
              }
              sub_1AB24(&stru_7B700, "load_temp_cutoffs", 1145);
              v136 = *(_DWORD *)(dword_7B628 + 4 * v133++);
              *(_DWORD *)(v136 + 184) = v135;
              sub_19BBC(&stru_7B700, "load_temp_cutoffs", 1147);
              v132 = strtok(0, ",");
            }
            while ( v132 );
            if ( v133 != 1 )
              goto LABEL_203;
          }
          else
          {
            v133 = 0;
            v135 = 0;
            v291 = &dword_7B628;
          }
          sub_1AB24(&stru_7B700, "load_temp_cutoffs", 1164);
          v186 = dword_7B720;
          v187 = *v291;
          while ( v133 < v186 )
          {
            v188 = *(_DWORD *)(v187 + 4 * v133++);
            *(_DWORD *)(v188 + 184) = v135;
          }
          sub_19BBC(&stru_7B700, "load_temp_cutoffs", 1167);
LABEL_203:
          if ( dword_7B720 > 0 )
          {
            v140 = (int *)*v291;
            v141 = *v291 + 4 * dword_7B720;
            do
            {
              v142 = *v140++;
              *(_DWORD *)(v142 + 312) = 99999999;
            }
            while ( v140 != (int *)v141 );
          }
          if ( !byte_7B940 )
          {
            dword_7701C += dword_7702C;
            dword_77024 = dword_7701C + 1;
            sub_18068();
          }
          if ( !dword_7B198 )
          {
            if ( *v287 || byte_78E08 || dword_766C4 > 3 )
            {
              v143 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy((char *)v143 + 4, " to specify at least one pool server.");
              sub_38730(4, v289, 0);
            }
            if ( !*((_BYTE *)v286 + 2016) || !sub_26D10(0) )
            {
              v144 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Pool setup failed";
              strcpy((char *)v144 + 4, " setup failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
          }
          if ( dword_7B198 > 0 )
          {
            v145 = 0;
            v146 = v92;
            do
            {
              v147 = *(_DWORD *)(dword_7B438 + 4 * v145);
              v148 = *(_DWORD *)(v147 + 200);
              *(_DWORD *)(v147 + 428) = 99999999;
              *(_DWORD *)(v147 + 464) = 99999999;
              if ( !v148 )
              {
                if ( !*(_DWORD *)(v147 + 208) )
                  *(_DWORD *)(v147 + 208) = calloc(1u, 1u);
                v149 = *(const char **)(v147 + 204);
                if ( !v149 )
                {
                  snprintf(
                    v289,
                    0x1000u,
                    "No login credentials supplied for pool %u %s",
                    v145,
                    *(const char **)(v147 + 196));
                  sub_38730(3, v289, 1);
                  sub_1D8FC(1, 0);
                }
                v150 = strlen(*(const char **)(v147 + 204));
                v282 = *(char **)(v147 + 208);
                v151 = v150 + strlen(v282) + 2;
                v152 = (char *)malloc(v151);
                *(_DWORD *)(v147 + 200) = v152;
                if ( !v152 )
                {
                  v278 = (int *)v289;
                  *(_DWORD *)v289 = *(_DWORD *)"Failed to malloc userpass";
                  strcpy((char *)v278 + 4, "ed to malloc userpass");
                  sub_38730(3, v289, 1);
                  sub_1D8FC(1, 0);
                }
                snprintf(v152, v151, "%s:%s", v149, v282);
              }
              ++v145;
            }
            while ( dword_7B198 > v145 );
            v92 = v146;
          }
          v154 = (unsigned __int8)*v287;
          dword_7705C = *(_DWORD *)dword_7B438;
          if ( v154 )
            openlog("cgminer", 1, 8);
          v155 = byte_78BD0;
          if ( *((_DWORD *)v92 - 25) )
          {
            if ( pipe((int *)v289) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v295[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(*((_DWORD *)v289 + 1)) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v156 = signal(13, (__sighandler_t)1);
            v157 = signal(13, (__sighandler_t)1);
            v158 = (__sighandler_t)((char *)v157 + 1) == 0;
            if ( v157 != (__sighandler_t)-1 )
              v158 = (__sighandler_t)((char *)v156 + 1) == 0;
            if ( v158 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v159 = fork();
            v160 = v159;
            dword_7728C = v159;
            if ( v159 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v159 )
            {
              if ( dup2(v295[0], 0) >= 0 )
              {
                close(v295[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_78B6C, v160);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v295[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          v165 = calloc(dword_7BB6C, 4u);
          if ( v165 )
            v155 = 0;
          dword_7B5E0 = (int)v165;
          if ( !v165 )
          {
            v274 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy((char *)v274 + 4, "ed to calloc mining_thr");
            v275 = v289;
            goto LABEL_490;
          }
          while ( (int)v155 < dword_7BB6C )
          {
            v166 = dword_7B5E0;
            *(_DWORD *)(v166 + 4 * (_DWORD)v155) = calloc(1u, 0x40u);
            v165 = *(void **)(dword_7B5E0 + 4 * (_DWORD)v155);
            if ( !v165 )
            {
              snprintf(v289, 0x1000u, "Failed to calloc mining_thr[%d]", v155);
              v275 = v289;
LABEL_490:
              sub_38730(3, v275, 1);
              sub_1D8FC(1, (int)v165);
            }
            ++v155;
          }
          v167 = 0;
          v168 = 0;
          v290 = v92;
          while ( v168 < dword_7B720 )
          {
            v169 = 0;
            v170 = *(_DWORD **)(*v291 + 4 * v168);
            v171 = v170[37];
            v172 = malloc(4 * (v171 + 1));
            v170[38] = v172;
            v172[v171] = 0;
            v173 = v170[37];
            v170[24] = 4;
            if ( v173 > 0 )
            {
              do
              {
                v174 = (sem_t *)sub_1B124(v167);
                v174->__align = v167;
                v175 = v174;
                *(&v174[2].__align + 1) = (int)v170;
                *(&v174->__align + 1) = v169;
                if ( (*(int (**)(void))(v170[1] + 44))() )
                {
                  if ( sub_2F174((int)v175, 0, (void *(*)(void *))sub_11E24, v175) )
                  {
                    snprintf(v289, 0x1000u, "thread %d create failed", v175->__align);
                    sub_38730(3, v289, 1);
                    sub_1D8FC(1, 0);
                  }
                  *(_DWORD *)(v170[38] + 4 * v169) = v175;
                  if ( v170[8] != 1 )
                  {
                    if ( byte_78E09 && (*v287 || byte_78E08 || dword_766C4 > 6) )
                    {
                      snprintf(v289, 0x1000u, "Pushing sem post to thread %d", v175->__align);
                      sub_38730(7, v289, 0);
                    }
                    sub_2F1BC(v175 + 1, "cgminer.c", "main", 11098);
                  }
                }
                ++v169;
                ++v167;
              }
              while ( v170[37] > v169 );
            }
            ++v168;
          }
          v176 = v290;
          if ( byte_7730D || (v177 = dword_76FFC) != 0 )
          {
LABEL_284:
            v178 = (int *)dbl_770E0;
            dbl_7ACC0 = 0.0;
            do
            {
              *(_QWORD *)v178 = 0;
              v178 += 2;
            }
            while ( v178 != &dword_77140 );
            v179 = dword_7B720;
            dword_77140 = 0;
            v180 = *v291;
            for ( j = 0; j < v179; ++j )
            {
              v182 = *(_DWORD *)(v180 + 4 * j);
              *(_QWORD *)(v182 + 80) = 0;
              *(_QWORD *)(v182 + 48) = 0;
            }
            sub_2A84C((struct timeval *)&dword_770D0);
            sub_2A84C((struct timeval *)&dword_77148);
            sub_2A84C((struct timeval *)dword_770D8);
            sub_15264(byte_77260, 0x28u, &dword_770D0);
            v183 = dword_7B0FC;
            dword_770B0 = 2;
            if ( sub_2F174(dword_7B0FC + 128, 0, (void *(*)(void *))sub_21850, 0) )
            {
              v266 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"watchpool thread create failed";
              strcpy((char *)v266 + 4, "hpool thread create failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
            pthread_detach(*(_DWORD *)(v183 + 140));
            dword_770B4 = 3;
            v282 = (char *)dword_7B0FC;
            if ( sub_2F174(dword_7B0FC + 192, 0, (void *(*)(void *))sub_23344, 0) )
            {
              v201 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"watchdog thread create failed";
              strcpy((char *)v201 + 4, "hdog thread create failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
            pthread_detach(*((_DWORD *)v282 + 51));
            dword_76EF8 = 5;
            if ( sub_2F174(dword_7B0FC + 320, 0, (void *(*)(void *))sub_12164, (void *)(dword_7B0FC + 320)) )
            {
              v265 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"API thread create failed";
              strcpy((char *)v265 + 4, "thread create failed");
              v185 = v289;
LABEL_296:
              sub_38730(3, v185, 1);
              sub_1D8FC(1, 0);
            }
            v184 = dword_7B0FC;
            *((_DWORD *)v176 - 24) = 7;
            if ( sub_2F174(v184 + 448, 0, (void *(*)(void *))sub_27A98, (void *)(v184 + 448)) )
            {
              v264 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"input thread create failed";
              strcpy((char *)v264 + 4, "t thread create failed");
              sub_38730(3, v289, 1);
              sub_1D8FC(1, 0);
            }
            pthread_detach(*(_DWORD *)(v184 + 460));
            if ( dword_78B64 != 8 )
            {
              snprintf(v289, 0x1000u, "incorrect total_control_threads (%d) should be 8", dword_78B64);
              v185 = v289;
              goto LABEL_296;
            }
            if ( nice(-10) )
            {
              v285 = &byte_78E08;
              v283 = &dword_766C4;
              v288 = (const char **)&byte_78E09;
            }
            else
            {
              v288 = (const char **)&byte_78E09;
              if ( byte_78E09 )
              {
                if ( *v287 )
                {
                  v285 = &byte_78E08;
                  v283 = &dword_766C4;
                }
                else
                {
                  v285 = &byte_78E08;
                  if ( byte_78E08 )
                  {
                    v283 = &dword_766C4;
                  }
                  else
                  {
                    v283 = &dword_766C4;
                    if ( dword_766C4 <= 6 )
                      goto LABEL_337;
                  }
                }
                v202 = (int *)v289;
                *(_DWORD *)v289 = *(_DWORD *)"Unable to set thread to high priority";
                strcpy((char *)v202 + 4, "le to set thread to high priority");
                sub_38730(7, v289, 0);
              }
              else
              {
                v285 = &byte_78E08;
                v283 = &dword_766C4;
              }
            }
LABEL_337:
            v290 = 0;
            v284 = (void (**)(void))&off_75ED8;
            while ( 1 )
            {
              while ( 1 )
              {
                v203 = v286[506];
                if ( byte_7B8AC )
                {
                  if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                  {
                    v231 = (int *)v289;
                    *(_DWORD *)v289 = *(_DWORD *)"Work update message received";
                    strcpy((char *)v231 + 4, " update message received");
                    sub_38730(7, v289, 0);
                  }
                  sub_2A84C(&stru_76F0C);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B69C("signal_work_update", 5314);
                  if ( dword_7BB6C > 0 )
                  {
                    v232 = (int *)dword_7B5E0;
                    v233 = dword_7B5E0 + 4 * dword_7BB6C;
                    do
                    {
                      v234 = *v232++;
                      *(_BYTE *)(v234 + 63) = 1;
                    }
                    while ( v232 != (int *)v233 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B630("signal_work_update", 5317);
                  (*v284)();
                }
                byte_7B8AC = 0;
                sub_1DA58();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_7704C) )
                  sub_B414("main", 11235);
                v204 = dword_77050;
                if ( dword_77050 )
                  v204 = *(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 12);
                if ( v203 < v204 )
                {
                  if ( byte_77056 )
                  {
                    v205 = v286[506];
                    if ( v205 < v286[507] )
                    {
                      dword_75DD8 = v205 + 1;
                      byte_77056 = 0;
                    }
                  }
                  byte_77055 = 1;
                  pthread_cond_wait(&stru_7B1A0, (pthread_mutex_t *)dword_7704C);
                  v204 = dword_77050;
                  if ( dword_77050 )
                    v204 = *(_DWORD *)(*(_DWORD *)(dword_77050 + 1832) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_7704C) )
                  sub_B5C4("main", 11253);
                (*v284)();
                if ( v204 <= v203 )
                  break;
                if ( byte_77056 )
                {
                  v206 = v286[506];
                  if ( v206 < v286[507] )
                  {
                    dword_75DD8 = v206 + 1;
                    byte_77056 = 0;
                  }
                }
                byte_77055 = 1;
                v207 = (char *)sub_193B4(0);
                v290 = v207;
                if ( v207 )
                {
                  sub_159B4((int)v207);
                  v290 = 0;
                }
              }
              if ( v290 )
                sub_159B4((int)v290);
              v290 = (char *)sub_1A3D4();
              v208 = sub_1DA58();
              v209 = v208;
              if ( dword_76EFC == 4 )
              {
                v209 = sub_12250(v208);
              }
              else if ( dword_76EFC == 3 )
              {
                v236 = dword_7B198;
                if ( dword_7B198 <= 0 )
                  goto LABEL_439;
                if ( *(_DWORD *)(*(_DWORD *)dword_7B438 + 60) <= *(_DWORD *)(*(_DWORD *)dword_7B438 + 64) )
                {
                  v237 = (int *)dword_7B438;
                  v238 = dword_7B438;
                  v239 = 0;
                  while ( ++v239 != dword_7B198 )
                  {
                    v240 = *(_DWORD *)(v238 + 4);
                    v238 += 4;
                    if ( *(_DWORD *)(v240 + 64) < *(_DWORD *)(v240 + 60) )
                      goto LABEL_441;
                  }
                  v241 = dword_7B438 + 4 * dword_7B198;
                  do
                  {
                    v242 = *v237++;
                    *(_DWORD *)(v242 + 64) = 0;
                  }
                  while ( v237 != (int *)v241 );
LABEL_439:
                  v243 = *((_DWORD *)v176 - 23) + 1;
                  *((_DWORD *)v176 - 23) = v243;
                  if ( v243 >= v236 )
                    dword_78B74 = 0;
                }
LABEL_441:
                v244 = 0;
                while ( 1 )
                {
                  v77 = v244++ < v236;
                  if ( !v77 )
                    break;
                  v246 = *((_DWORD *)v176 - 23);
                  v247 = *(_DWORD *)(dword_7B438 + 4 * v246);
                  v248 = *(_DWORD *)(v247 + 64);
                  v249 = *(_DWORD *)(v247 + 60);
                  *(_DWORD *)(v247 + 64) = v248 + 1;
                  if ( v248 < v249 )
                  {
                    if ( !*(_BYTE *)(v247 + 129)
                      && *(_DWORD *)(v247 + 132) == 1
                      && (!*(_BYTE *)(v247 + 664) || *(_BYTE *)(v247 + 665)) )
                    {
                      goto LABEL_453;
                    }
                    if ( byte_7B625 )
                    {
                      v250 = sub_12038(0);
                      v246 = *((_DWORD *)v176 - 23);
                      v236 = dword_7B198;
                      --*(_DWORD *)(v250 + 64);
                    }
                  }
                  v245 = v246 + 1;
                  *((_DWORD *)v176 - 23) = v245;
                  if ( v245 >= v236 )
                    dword_78B74 = 0;
                }
                if ( v236 > 0 )
                {
                  v251 = 0;
                  while ( 1 )
                  {
                    v247 = sub_12038(v251);
                    if ( !*(_BYTE *)(v247 + 129) && *(_DWORD *)(v247 + 132) == 1 )
                      break;
                    if ( ++v251 >= dword_7B198 )
                      goto LABEL_359;
                  }
LABEL_453:
                  v209 = v247;
                }
              }
LABEL_359:
              if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
              {
                snprintf(v289, 0x1000u, "Selecting pool %d for work", *(_DWORD *)v209);
                sub_38730(7, v289, 0);
              }
              if ( *(_BYTE *)(v209 + 664) )
              {
                while ( !*(_BYTE *)(v209 + 665) || !*(_BYTE *)(v209 + 667) )
                {
                  v210 = sub_1DA58();
                  v291 = (int *)v210;
                  if ( dword_76EFC == 4 )
                  {
                    v291 = (int *)sub_12250(v210);
                  }
                  else if ( dword_76EFC == 3 || !byte_7B625 )
                  {
                    v211 = dword_7B198;
                    if ( dword_7B198 <= 0 )
                      goto LABEL_378;
                    if ( *(_DWORD *)(*(_DWORD *)dword_7B438 + 60) <= *(_DWORD *)(*(_DWORD *)dword_7B438 + 64) )
                    {
                      v212 = (int *)dword_7B438;
                      v213 = dword_7B438;
                      v214 = 0;
                      while ( ++v214 != dword_7B198 )
                      {
                        v215 = *(_DWORD *)(v213 + 4);
                        v213 += 4;
                        if ( *(_DWORD *)(v215 + 64) < *(_DWORD *)(v215 + 60) )
                          goto LABEL_380;
                      }
                      v216 = dword_7B438 + 4 * dword_7B198;
                      do
                      {
                        v217 = *v212++;
                        *(_DWORD *)(v217 + 64) = 0;
                      }
                      while ( v212 != (int *)v216 );
LABEL_378:
                      v218 = *((_DWORD *)v176 - 23) + 1;
                      *((_DWORD *)v176 - 23) = v218;
                      if ( v218 >= v211 )
                        dword_78B74 = 0;
                    }
LABEL_380:
                    v219 = 0;
                    while ( 1 )
                    {
                      v77 = v219++ < v211;
                      if ( !v77 )
                        break;
                      v221 = *((_DWORD *)v176 - 23);
                      v222 = *(_DWORD *)(dword_7B438 + 4 * v221);
                      v223 = *(_DWORD *)(v222 + 64);
                      v224 = *(_DWORD *)(v222 + 60);
                      *(_DWORD *)(v222 + 64) = v223 + 1;
                      if ( v223 < v224 )
                      {
                        if ( !*(_BYTE *)(v222 + 129)
                          && *(_DWORD *)(v222 + 132) == 1
                          && (!*(_BYTE *)(v222 + 664) || *(_BYTE *)(v222 + 665)) )
                        {
                          goto LABEL_392;
                        }
                        if ( byte_7B625 )
                        {
                          v225 = sub_12038(0);
                          v221 = *((_DWORD *)v176 - 23);
                          v211 = dword_7B198;
                          --*(_DWORD *)(v225 + 64);
                        }
                      }
                      v220 = v221 + 1;
                      *((_DWORD *)v176 - 23) = v220;
                      if ( v220 >= v211 )
                        dword_78B74 = 0;
                    }
                    if ( v211 > 0 )
                    {
                      v235 = 0;
                      while ( 1 )
                      {
                        v222 = sub_12038(v235);
                        if ( !*(_BYTE *)(v222 + 129) && *(_DWORD *)(v222 + 132) == 1 )
                          break;
                        if ( ++v235 >= dword_7B198 )
                          goto LABEL_393;
                      }
LABEL_392:
                      v291 = (int *)v222;
                    }
                  }
LABEL_393:
                  if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                  {
                    snprintf(v289, 0x1000u, "Selecting pool %d for work", *v291);
                    sub_38730(7, v289, 0);
                  }
                  sub_2A92C();
                  if ( (int *)v209 != v291 )
                  {
                    v209 = (int)v291;
                    if ( !*((_BYTE *)v291 + 664) )
                      goto LABEL_400;
                  }
                }
                sub_1ACC4(v209, (int)v290);
                if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                {
                  v230 = (int *)v289;
                  *(_DWORD *)v289 = *(_DWORD *)"Generated stratum work";
                  strcpy((char *)v230 + 4, "rated stratum work");
                  sub_38730(7, v289, 0);
                }
LABEL_467:
                v263 = v290;
                v290 = 0;
                sub_1F17C((int)v263);
              }
              else
              {
LABEL_400:
                if ( dword_76FFC )
                {
                  v226 = (struct timeval *)(v290 + 1888);
                  v227 = v290;
                  sub_17254(v290);
                  v228 = (_DWORD *)dword_7B438;
                  v227[1770] = 1;
                  *((_DWORD *)v227 + 437) = *v228;
                  sub_2A84C(v226);
                  sub_2A530(&v226[1].tv_sec, v226);
                  v227[1928] = 66;
                  sub_11A5C((int)v290);
                  if ( *(_BYTE *)v288 && (*v287 || *v285 || *v283 > 6) )
                  {
                    v229 = (int *)v289;
                    *(_DWORD *)v289 = *(_DWORD *)"Generated benchfile work";
                    strcpy((char *)v229 + 4, "rated benchfile work");
                    sub_38730(7, v289, 0);
                  }
                  goto LABEL_467;
                }
                if ( byte_7730D )
                {
                  v252 = (_DWORD *)dword_7B438;
                  v253 = v290;
                  v254 = v290 + 160;
                  *((_QWORD *)v290 + 233) = 0x4040000000000000LL;
                  v255 = dword_78730[1];
                  v256 = dword_78730[2];
                  v257 = dword_78730[3];
                  *((_DWORD *)v253 + 40) = dword_78730[0];
                  *((_DWORD *)v254 + 1) = v255;
                  *((_DWORD *)v254 + 2) = v256;
                  *((_DWORD *)v254 + 3) = v257;
                  v258 = unk_78744;
                  v259 = unk_78748;
                  v260 = unk_7874C;
                  *((_DWORD *)v254 + 4) = unk_78740;
                  *((_DWORD *)v254 + 5) = v258;
                  *((_DWORD *)v254 + 6) = v259;
                  *((_DWORD *)v254 + 7) = v260;
                  *((_DWORD *)v253 + 433) = 0;
                  v253[1770] = 1;
                  *((_DWORD *)v253 + 437) = *v252;
                  sub_2A84C((struct timeval *)v253 + 236);
                  sub_2A530((_DWORD *)v253 + 474, (_DWORD *)v253 + 472);
                  v261 = *(unsigned __int8 *)v288;
                  v290[1928] = 66;
                  if ( v261 && (*v287 || *v285 || *v283 > 6) )
                  {
                    v262 = (int *)v289;
                    *(_DWORD *)v289 = *(_DWORD *)"Generated benchmark work";
                    strcpy((char *)v262 + 4, "rated benchmark work");
                    sub_38730(7, v289, 0);
                  }
                  goto LABEL_467;
                }
              }
            }
          }
          v192 = dword_7B438;
          v193 = dword_7B198;
          while ( v177 < v193 )
          {
            v194 = *(_DWORD *)(v192 + 4 * v177++);
            v195 = *(_DWORD *)(v194 + 132);
            *(_BYTE *)(v194 + 129) = 1;
            if ( v195 != 1 )
            {
              *(_DWORD *)(v194 + 132) = 1;
              ++dword_7B5E4;
            }
          }
          v288 = (const char **)&byte_78E09;
          if ( byte_78E09 )
          {
            if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 6) )
            {
              v267 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Probing for an alive pool";
              strcpy((char *)v267 + 4, "ing for an alive pool");
              sub_38730(7, v289, 0);
            }
          }
          for ( k = 0; k < dword_7B198; ++k )
          {
            v269 = *(_DWORD *)(dword_7B438 + 4 * k);
            *(_BYTE *)(v269 + 316) = 1;
            pthread_create((pthread_t *)(v269 + 312), 0, (void *(*)(void *))start_routine, (void *)v269);
          }
          v270 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_7730C )
              break;
            if ( !--v270 )
              goto LABEL_495;
          }
          v270 = 0;
LABEL_495:
          v271 = v289;
          v272 = v287;
          while ( 1 )
          {
            if ( byte_7730C )
              goto LABEL_284;
            if ( !v270 )
            {
              if ( ((*v272 || byte_78E08 || dword_766C4 > 2)
                 && ((strcpy(v271, "No servers were found that could be used to get work from."),
                      sub_38730(3, v271, 0),
                      *v272)
                  || byte_78E08)
                 || dword_766C4 > 2)
                && ((strcpy(v271, "Please check the details from the list below of the servers you have input"),
                     sub_38730(3, v271, 0),
                     *v272)
                 || byte_78E08)
                || dword_766C4 > 2 )
              {
                strcpy(
                  v271,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_38730(3, v271, 0);
              }
              for ( m = 0; m < dword_7B198; ++m )
              {
                if ( *v272 || byte_78E08 || dword_766C4 > 3 )
                {
                  snprintf(
                    v271,
                    0x1000u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    m,
                    *(const char **)(*(_DWORD *)(dword_7B438 + 4 * m) + 196),
                    *(const char **)(*(_DWORD *)(dword_7B438 + 4 * m) + 204),
                    *(const char **)(*(_DWORD *)(dword_7B438 + 4 * m) + 208));
                  sub_38730(4, v271, 0);
                }
              }
              if ( !*((_BYTE *)v286 + 2016) )
              {
LABEL_529:
                v277 = (int *)v289;
                *(_DWORD *)v289 = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy((char *)v277 + 4, "ervers could be used! Exiting.");
                sub_38730(3, v289, 1);
                sub_1D8FC(0, 0);
              }
              if ( !*v272 && !byte_78E08 && dword_766C4 <= 2 )
              {
                v270 = 1;
                goto LABEL_523;
              }
              v270 = 1;
              strcpy(v271, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_38730(3, v271, 0);
            }
            if ( !*((_BYTE *)v286 + 2016) )
              goto LABEL_529;
LABEL_523:
            if ( dword_7B430 )
              v276 = *(__int16 *)(dword_7B430 + 4);
            else
              v276 = -1;
            v282 = (char *)&dword_7B430;
            if ( dword_7B430 )
              ++v276;
            wtouchln((WINDOW *)dword_7B430, 0, v276, 1);
            wrefresh(*(WINDOW **)v282);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_529;
            cbreak();
          }
        }
        v288 = (const char **)&byte_78E09;
        if ( byte_78E09 && (*v287 || byte_78E08 || dword_766C4 > 6) )
        {
          snprintf(v289, 0x1000u, "Loaded configuration file %s", (const char *)dword_76F24);
          sub_38730(7, v289, 0);
        }
        if ( dword_76FF4 == -1 )
        {
          if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
          {
            v138 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy((char *)v138 + 4, "r in configuration file, partially loaded.");
            sub_38730(4, v289, 0);
          }
          if ( *((_BYTE *)v286 + 2016) )
          {
            if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
            {
              v139 = (int *)v289;
              *(_DWORD *)v289 = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
              strcpy((char *)v139 + 4, "t cgminer with -T to see what failed to load.");
              sub_38730(4, v289, 0);
            }
          }
          goto LABEL_171;
        }
        if ( !dword_76FF4 )
        {
          if ( *v287 || byte_78E08 || (v283 = &dword_766C4, dword_766C4 > 3) )
          {
            v153 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy((char *)v153 + 4, "l JSON error in configuration file.");
            sub_38730(4, v289, 0);
            if ( *v287 || byte_78E08 )
              goto LABEL_170;
            v283 = &dword_766C4;
          }
          if ( *v283 > 3 )
          {
LABEL_170:
            v128 = (int *)v289;
            *(_DWORD *)v289 = *(_DWORD *)"Configuration file could not be used.";
            strcpy((char *)v128 + 4, "iguration file could not be used.");
            sub_38730(4, v289, 0);
          }
        }
LABEL_171:
        free((void *)dword_76F24);
        dword_76F24 = 0;
        goto LABEL_172;
      }
      v61 = 24 * *(_DWORD *)(v60 + 4);
      v62 = malloc(v61);
      v63 = v62;
      if ( v62 )
      {
        memset(v62, 0, v61);
        *(_DWORD *)(v60 + 24) = (((2 * *(_DWORD *)(v60 + 4) - 1) & *(_DWORD *)(v60 + 12)) != 0)
                              + (*(_DWORD *)(v60 + 12) >> (*(_BYTE *)(v60 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v64 = (_DWORD *)*((_DWORD *)v20 + 17);
        v65 = v64[1];
        v66 = v64;
        if ( v65 )
        {
          v291 = 0;
          v290 = 0;
          do
          {
            v67 = *(_DWORD **)((char *)v291 + *v64);
            if ( v67 )
            {
              for ( n = v65; ; n = v66[1] )
              {
                v69 = (_DWORD *)v67[4];
                v70 = 3 * ((2 * n - 1) & v67[7]);
                v71 = (char *)&v63[v70];
                v72 = *((_DWORD *)v71 + 1) + 1;
                *((_DWORD *)v71 + 1) = v72;
                if ( v72 > v66[6] )
                {
                  ++v66[7];
                  *((_DWORD *)v71 + 2) = *((_DWORD *)v71 + 1) / *(_DWORD *)(*((_DWORD *)v20 + 17) + 24);
                }
                v67[3] = 0;
                v67[4] = v63[v70];
                v73 = v63[v70];
                if ( v73 )
                  *(_DWORD *)(v73 + 12) = v67;
                v63[v70] = v67;
                if ( !v69 )
                  break;
                v66 = (_DWORD *)*((_DWORD *)v20 + 17);
                v67 = v69;
              }
              v64 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v64[1];
            ++v290;
            v66 = v64;
            v291 += 3;
          }
          while ( v65 > (unsigned int)v290 );
        }
        free((void *)*v64);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v63;
        v74 = (_DWORD *)*((_DWORD *)v20 + 17);
        v75 = v74[3];
        v76 = v74[7];
        v77 = v76 > v75 >> 1;
        if ( v76 <= v75 >> 1 )
          v78 = 0;
        else
          v78 = v74[8];
        if ( v77 )
          ++v78;
        v74[8] = v78;
        v79 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v79 + 32) > 1u )
          *(_DWORD *)(v79 + 36) = 1;
        goto LABEL_56;
      }
LABEL_258:
      exit(-1);
    }
    strcpy((char *)v295, "Failed to create getq");
  }
  sub_38730(3, (const char *)v295, 1);
  sub_1D8FC(1, 0);
}
