/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_A994();
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int scrollok(WINDOW *, bool);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int open(const char *file, int oflag, ...);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int sigemptyset(sigset_t *set);
// char *strerror(int errnum);
// const __int32_t **_ctype_toupper_loc(void);
// int fileno(FILE *stream);
// int mkdir(const char *path, __mode_t mode);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// void abort(void);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int nocbreak(void);
// void srand(unsigned int seed);
// struct tm *localtime(const time_t *timer);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int memcmp(const void *s1, const void *s2, size_t n);
// WINDOW *newwin(int, int, int, int);
// int sysconf(int name);
// void syslog(int pri, const char *fmt, ...);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int _xstat(int ver, const char *filename, struct stat *stat_buf);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int wmove(WINDOW *, int, int);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int _isinf(double value);
// int _gmon_start__(void); weak
// int echo(void);
// int sched_yield(void);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// in_addr_t inet_addr(const char *cp);
// int endwin(void);
// char *strncpy(char *dest, const char *src, size_t n);
// int fclose(FILE *stream);
// char *fgets(char *s, int n, FILE *stream);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *getenv(const char *name);
// double strtod(const char *nptr, char **endptr);
// int system(const char *command);
// char *strchr(const char *s, int c);
// int strcasecmp(const char *s1, const char *s2);
// char *dirname(char *path);
// int leaveok(WINDOW *, bool);
// int listen(int fd, int n);
// void *calloc(size_t nmemb, size_t size);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// void *memset(void *s, int c, size_t n);
// int sem_destroy(sem_t *sem);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// void freeaddrinfo(struct addrinfo *ai);
// void perror(const char *s);
// int delwin(WINDOW *);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int werase(WINDOW *);
// double floor(double x);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// double exp(double x);
// WINDOW *initscr(void);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int usleep(__useconds_t useconds);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
// int wclrtoeol(WINDOW *);
// void free(void *ptr);
// int access(const char *name, int type);
// void openlog(const char *ident, int option, int facility);
// int inet_pton(int af, const char *cp, void *buf);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int sem_trywait(sem_t *sem);
// int fseek(FILE *stream, int off, int whence);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int __fastcall round(_DWORD); weak
// int socket(int domain, int type, int protocol);
// int wtouchln(WINDOW *, int, int, int);
// int execl(const char *path, const char *arg, ...);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fflush(FILE *stream);
// void immedok(WINDOW *, bool);
// int isatty(int fd);
// int wrefresh(WINDOW *);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// size_t strlen(const char *s);
// int sscanf(const char *s, const char *format, ...);
// int mvwprintw(WINDOW *, int, int, const char *, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int execv(const char *path, char *const argv[]);
// int __fastcall lldiv(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int halfdelay(int);
// int pthread_cond_signal(pthread_cond_t *cond);
// const __int32_t **_ctype_tolower_loc(void);
// struct lconv *localeconv(void);
// int fgetc(FILE *stream);
// int strtol(const char *nptr, char **endptr, int base);
// char *strcpy(char *dest, const char *src);
// int sem_post(sem_t *sem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int cbreak(void);
// char *strncat(char *dest, const char *src, size_t n);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int printf(const char *format, ...);
// int raise(int sig);
// void errx(int status, const char *format, ...);
// int __fastcall strtof(_DWORD, _DWORD); weak
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int shutdown(int fd, int how);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int wresize(WINDOW *, int, int);
// char *strstr(const char *haystack, const char *needle);
// int nice(int inc);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int close(int fd);
// int wgetch(WINDOW *);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int _isnan(double value);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int wprintw(WINDOW *, const char *, ...);
// time_t time(time_t *timer);
// double log10(double x);
// const unsigned __int16 **_ctype_b_loc(void);
// int fprintf(FILE *stream, const char *format, ...);
// void *malloc(size_t size);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// int wgetnstr(WINDOW *, char *, int);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// unsigned int sleep(unsigned int seconds);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// char *strcat(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// void pthread_testcancel(void);
// int dup2(int fd, int fd2);
// int puts(const char *s);
// int prctl(int option, ...);
// int fcntl(int fd, int cmd, ...);
// int idlok(WINDOW *, bool);
// __pid_t fork(void);
// int wattr_off(WINDOW *, attr_t, void *);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
// int rand(void);
// int munmap(void *addr, size_t len);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// __int64 __fastcall llround(_DWORD); weak
// int whline(WINDOW *, chtype, int);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int strncmp(const char *s1, const char *s2, size_t n);
// int kill(__pid_t pid, int sig);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int wclear(WINDOW *);
// int pthread_detach(pthread_t th);
// void *realloc(void *ptr, size_t size);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_setcancelstate(int state, int *oldstate);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int pipe(int pipedes[2]);
// char *_strdup(const char *s);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int noecho(void);
// char *strpbrk(const char *s, const char *accept);
// int sem_wait(sem_t *sem);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int pthread_setcanceltype(int type, int *oldtype);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int *_errno_location(void);
// pthread_t pthread_self(void);
// int pthread_cancel(pthread_t th);
// int mvwin(WINDOW *, int, int);
// int wattr_on(WINDOW *, attr_t, void *);
// int sprintf(char *s, const char *format, ...);
// int pthread_join(pthread_t th, void **thread_return);
// int fscanf(FILE *stream, const char *format, ...);
int __fastcall sub_B288(int a1);
void __noreturn sub_B310();
void __fastcall sub_B34C(int a1, int a2, int a3, int a4, int a5);
void __fastcall __noreturn sub_B35C(const char *a1, int a2);
void __fastcall sub_B3B4(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B3C8(const char *a1, int a2);
void __fastcall sub_B420(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B434(const char *a1, int a2);
void __fastcall sub_B48C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B4A0(const char *a1, int a2);
void __fastcall sub_B4F8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B50C(const char *a1, int a2);
void __fastcall sub_B564(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B578(const char *a1, int a2);
void __fastcall sub_B5D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B5E4(const char *a1, int a2);
void __fastcall sub_B63C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B650(const char *a1, int a2);
void __fastcall sub_B6A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B6BC(const char *a1, int a2);
void __fastcall sub_B714(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B728(const char *a1, int a2);
void __fastcall sub_B780(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B794(const char *a1, int a2);
void __fastcall sub_B7EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
void __fastcall __noreturn sub_B800(int a1);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int sub_F57C();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
int __fastcall sub_F678(_DWORD *a1);
int __fastcall sub_F688(_DWORD *a1);
int __fastcall sub_F698(_DWORD *a1);
int __fastcall sub_F6A8(_BYTE *a1);
int sub_F6C4();
int nullsub_3(); // weak
int nullsub_2(); // weak
int nullsub_4(); // weak
int sub_F6D8();
int sub_F6E0();
__int64 sub_F6E8();
int sub_F6F4();
int sub_F6FC();
int nullsub_5(); // weak
int nullsub_6(); // weak
int nullsub_7(); // weak
int nullsub_8(); // weak
int sub_F714();
int __fastcall sub_F720(int a1, int a2);
_BYTE *__fastcall sub_F7DC(const char *a1);
int __fastcall sub_F868(int a1);
int __fastcall sub_F880(int a1);
int __fastcall sub_F898(int a1);
int __fastcall sub_F8B0(int a1);
int __fastcall sub_F8C8(int a1);
int __fastcall sub_F8E0(int a1);
void __fastcall __noreturn sub_F8F8(char *a1);
void *__fastcall sub_FB48(void *a1); // idb
time_t __fastcall sub_FB5C(int a1);
time_t __fastcall sub_FB90(int a1);
int __fastcall sub_FBC8(int *a1, int *a2, int a3);
double __fastcall sub_1144C(double a1);
double __fastcall sub_11480(double a1);
int __fastcall sub_114B8(unsigned __int64 a1, char *a2, size_t a3, int a4);
void __fastcall sub_1174C(char *a1, unsigned int a2);
bool sub_1180C();
int __fastcall sub_11994(int a1);
void __fastcall __noreturn sub_11B54(void *a1);
void __noreturn sub_11B7C(const char *a1, ...);
int __fastcall sub_11BC4(int a1, int a2, int a3);
int __fastcall sub_11D5C(int a1);
void __fastcall sub_11E98(int a1);
int __fastcall sub_11F70(int a1);
void sub_11FDC();
void sub_1202C();
int __fastcall sub_1209C(int a1);
char *__fastcall sub_120E8(const char *a1, float *a2);
char *__fastcall sub_12138(const char *a1, float *a2);
int __fastcall sub_12188(int result);
int __fastcall sub_12220(int *a1, int a2, int *a3);
const char *__fastcall sub_14D70(const char *a1);
const char *__fastcall sub_14DEC(const char *a1);
int __fastcall sub_14E68(int a1);
int __fastcall sub_14F08(int a1, int a2, unsigned int a3);
int __fastcall sub_1519C(char *a1, size_t a2, time_t *a3);
void sub_15218();
char *__fastcall sub_15394(const char *a1, _DWORD *a2, int a3, int a4);
char *__fastcall sub_153D4(const char *a1);
char *__fastcall sub_15400(const char *a1, _DWORD *a2);
char *__fastcall sub_1540C(const char *a1, _DWORD *a2);
char *__fastcall sub_15418(const char *a1, _DWORD *a2);
char *__fastcall sub_15424(const char *a1, _DWORD *a2);
char *__fastcall sub_15430(const char *a1, _DWORD *a2);
char *__fastcall sub_1543C(const char *a1, _DWORD *a2);
char *__fastcall sub_15448(const char *a1, _DWORD *a2);
char *__fastcall sub_15454(const char *a1, _DWORD *a2);
char *__fastcall sub_15460(const char *a1, _DWORD *a2);
char *__fastcall sub_1546C(const char *a1, _DWORD *a2);
char *__fastcall sub_15478(const char *a1, _DWORD *a2);
int __fastcall sub_15484(const char *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_154B4(int a1, char *a2);
const char *__fastcall sub_15528(const char *a1);
void *__fastcall sub_15580(void **a1);
char *__fastcall sub_155BC(int a1, int a2, int a3);
void __fastcall sub_156B8(void **a1);
int __fastcall sub_156D0(double a1);
void __fastcall sub_15724(int a1);
void sub_15778();
void sub_157A0();
int __fastcall sub_157C8(const char *a1);
_BYTE *__fastcall sub_157E4(int a1, unsigned int a2);
__int64 __fastcall sub_1581C(__int64 *a1);
void __fastcall sub_158EC(int a1);
int __fastcall sub_15A00(int result);
void __fastcall sub_15A9C(FILE *s);
int sub_15FEC();
char *__fastcall sub_16088(char *a1);
int __fastcall sub_1617C(int a1);
int __fastcall sub_163CC(char *a1, unsigned __int64 a2);
int __fastcall sub_1646C(int a1);
bool __fastcall sub_16484(int a1, int a2);
bool __fastcall sub_164D8(int a1, int a2);
unsigned int __fastcall sub_1655C(int a1, int a2);
int __fastcall sub_169B8(int a1, void *s2, size_t n, const void *a4, int a5, size_t a6);
void __fastcall sub_16A78(int a1, _DWORD *a2);
int __fastcall sub_16BC0(int result);
void __fastcall __noreturn sub_16BE0(int a1);
char *__fastcall sub_16BE8(char *a1);
char *__fastcall sub_16CD0(char *s);
char *__fastcall sub_16D24(_DWORD *a1, int a2);
int __fastcall sub_17038(int a1, char *a2);
int sub_17148();
int __fastcall sub_1718C(char *a1);
int __fastcall sub_1767C(char *a1, size_t a2, int a3);
void __noreturn sub_17830();
void __fastcall sub_17888(int a1, int a2, int a3, int a4, int a5);
void __noreturn sub_17894();
int __fastcall sub_178C8(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_178F4(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_17920(int a1, const char *a2, int a3);
char *sub_17974();
const char *__fastcall sub_17B84(char *s);
const char *__fastcall sub_17C74(int a1);
int sub_17CF0();
int __fastcall sub_17D3C(char *a1);
const char *__fastcall sub_17EAC(int a1);
int *__fastcall sub_17F28(int a1);
int __fastcall sub_18200(int a1, _BYTE *a2);
int __fastcall sub_18274(int a1, int a2);
int __fastcall sub_182F4(int a1, int a2);
int __fastcall sub_1842C(int a1, unsigned int a2);
int sub_1852C();
int __fastcall sub_1859C(int a1, _BYTE *a2);
int __fastcall sub_18610(_DWORD *a1, int a2);
int __fastcall sub_18D24(int a1);
int sub_191B0();
void __fastcall sub_1922C(_DWORD *a1);
int __fastcall sub_19498(int a1);
int sub_195CC();
int sub_196AC();
void sub_19730();
void __fastcall sub_19840(int a1, int a2);
int sub_198BC();
int sub_19938();
int __fastcall sub_199A4(int a1, const char *a2, const char *a3);
int __fastcall sub_19A98(const char *a1);
int __fastcall sub_19B04(pthread_rwlock_t *a1, const char *a2, int a3);
unsigned __int64 __fastcall sub_19B40(int a1);
int __fastcall sub_19DB8(int a1, int a2);
int __fastcall sub_19F9C(int a1, int a2, int a3, _DWORD *a4);
_DWORD *__fastcall sub_1A0A0(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
void __fastcall sub_1A154(pthread_rwlock_t *a1, void **a2);
int __fastcall sub_1A1D0(pthread_rwlock_t *a1, int a2);
int __fastcall sub_1A244(pthread_rwlock_t *a1);
int sub_1A334();
int __fastcall sub_1A3F0(int a1);
_DWORD *sub_1A520();
_DWORD *__fastcall sub_1A598(int a1, int a2);
_DWORD *__fastcall sub_1A5C0(int a1);
int __fastcall sub_1A600(int a1);
void __fastcall sub_1A95C(pthread_rwlock_t *a1);
int __fastcall sub_1AA68(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_1AA90(int a1);
int sub_1AB08();
int sub_1AE2C();
void sub_1AE44();
int __fastcall sub_1AF58(int a1);
void __fastcall sub_1AF6C(const char *a1, _DWORD *a2);
int __fastcall sub_1B1A8(int a1);
int sub_1B220();
void __fastcall sub_1B514(int a1, __int64 a2);
int sub_1BFD8();
void sub_1D138();
void __fastcall __noreturn sub_1D26C(int a1, int a2);
int __fastcall sub_1D324(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
int __fastcall sub_1D3C8(pthread_rwlock_t *a1, int a2);
_DWORD *__fastcall sub_1D478(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6);
_DWORD *__fastcall sub_1D52C(pthread_rwlock_t *a1, int a2);
int __fastcall sub_1D5F0(int a1, int a2);
int sub_1D9A0();
int __fastcall sub_1DA54(int a1);
int __fastcall sub_1F0C4(int a1);
int __fastcall sub_1F880(int a1, int a2, int a3);
void __fastcall sub_1F95C(int a1);
int __fastcall sub_1FA8C(int a1);
int sub_1FAC4();
void __fastcall sub_1FB7C(_DWORD *a1);
void __fastcall sub_1FCAC(_DWORD *a1);
void *__fastcall start_routine(_DWORD *a1);
int __fastcall sub_1FF34(int a1);
void __fastcall sub_1FFD0(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void __fastcall sub_201FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void __noreturn sub_21798();
void *__fastcall sub_21F30(_DWORD *a1);
int __fastcall sub_22A8C(int a1, int a2);
void sub_22ED0();
void *__fastcall sub_23138(void *a1); // idb
void __noreturn sub_2328C();
int __fastcall sub_24660(int a1);
int __fastcall sub_246B8(pthread_rwlock_t *a1);
int __fastcall sub_2472C(int a1, int a2);
int __fastcall sub_24CE0(int a1, pthread_rwlock_t *a2, int a3);
void __fastcall sub_24D08(int a1);
void __fastcall sub_255FC(int a1);
int __fastcall sub_25D80(int a1, int a2, int a3);
void __fastcall sub_25DA0(int a1);
int __fastcall sub_25DB4(int a1, int a2);
int __fastcall sub_25EA0(int a1, char *a2, unsigned int a3);
char *__fastcall sub_25F34(const char *a1);
int __fastcall sub_26028(const char *a1);
void sub_26054();
void sub_26708();
int __fastcall sub_26B24(int a1, int a2, char *a3, const char *a4, const char *a5);
void sub_26C44();
int __fastcall sub_26C68(int a1);
void sub_26EA8();
int sub_279F0();
int sub_27AF8();
int __fastcall sub_27C28(int result);
int __fastcall sub_27E68(pthread_rwlock_t *a1);
int __fastcall sub_27F60(_DWORD *a1);
int sub_28A38();
int __fastcall sub_28A40(int result);
bool __fastcall sub_28A54(int a1, int a2);
int __fastcall sub_28AF4(int a1);
ssize_t __fastcall sub_28B1C(int a1);
int __fastcall sub_28B44(const char **a1, int a2, int a3);
int __fastcall sub_28F20(const char **a1, int a2, int a3);
int __fastcall sub_291C4(struct timespec *req); // idb
_DWORD *__fastcall sub_291EC(_DWORD *a1, unsigned int a2);
char *__fastcall sub_2924C(_DWORD *a1, unsigned int a2);
int __fastcall sub_29264(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_292E0(pthread_mutex_t *a1, const char *a2, int a3);
int __fastcall sub_2935C(int a1, char *s, int a3);
int __fastcall sub_29500(int a1);
int __fastcall sub_29584(int a1, char a2);
const char *__fastcall sub_295E8(char *a1);
_BYTE *__fastcall sub_29630(_BYTE *result, char *a2, int a3);
_BYTE *__fastcall sub_29688(int a1, int a2);
bool __fastcall sub_29788(_BYTE *a1, unsigned __int8 *a2, int a3);
int __fastcall sub_29904(int a1, _DWORD *a2, unsigned int a3);
_BYTE *__fastcall sub_29BC8(_BYTE *a1, char *s);
int __fastcall sub_29D54(int a1, int a2);
int __fastcall sub_29EAC(unsigned int *a1, unsigned int *a2);
char *sub_2A0C0();
void __fastcall sub_2A100(char *a1);
int __fastcall sub_2A188(int a1);
int __fastcall sub_2A190(int a1);
int __fastcall sub_2A198(int a1, int a2);
int __fastcall sub_2A258(int a1, const struct timespec *a2);
int __fastcall sub_2A334(int result);
int __fastcall sub_2A36C(int result);
int __fastcall sub_2A3A0(_DWORD *a1, int *a2);
int __fastcall sub_2A3D4(_DWORD *a1, int *a2);
bool __fastcall sub_2A420(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_2A454(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_2A488(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_2A49C(_DWORD *result, _DWORD *a2);
_DWORD *__fastcall sub_2A4C4(_DWORD *result, _DWORD *a2);
int __fastcall sub_2A4E0(_DWORD *a1);
int __fastcall sub_2A518(_DWORD *a1);
int __fastcall sub_2A558(_DWORD *a1);
int __fastcall sub_2A5A0(_DWORD *a1);
int *__fastcall sub_2A5E0(int *result, _DWORD *a2);
const char *__fastcall sub_2A670(const char *a1, const char *a2, int a3, int a4);
const char *__fastcall sub_2A758(const char **a1, const char *a2);
int __fastcall sub_2A7A4(struct timeval *a1);
int __fastcall sub_2A7AC(_DWORD *a1);
int __fastcall sub_2A7D4(_DWORD *a1, _DWORD *a2, int *a3);
int __fastcall sub_2A810(struct timespec *tp); // idb
int __fastcall sub_2A81C(_DWORD *a1);
int __fastcall sub_2A854(_DWORD *a1);
int sub_2A884();
int sub_2A8AC();
_DWORD *__fastcall sub_2A8E0(_DWORD *result, _DWORD *a2);
void sub_2A97C();
void __fastcall sub_2A9C0(int a1, char *s);
int __fastcall sub_2AAAC(const char *a1, _DWORD *a2, char **a3);
char *__fastcall sub_2AC38(char *s1, int a2);
bool __fastcall sub_2AD68(int a1);
void **__fastcall sub_2AD84(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6);
int __fastcall sub_2AE38(int a1);
char *__fastcall sub_2AF98(int a1);
int __fastcall sub_2B520(int a1, char *a2, int a3);
int __fastcall nullsub_1(_DWORD); // weak
int *__fastcall sub_2B840(_DWORD *a1);
int __fastcall sub_2CE20(int a1);
int __fastcall sub_2CE98(_DWORD *a1, int *a2);
int __fastcall sub_2E50C(int *a1);
int __fastcall sub_2E8A8(_DWORD *a1);
time_t __fastcall sub_2EBF8(_DWORD *a1, int a2);
char *__fastcall sub_2EDD4(const char *a1);
int __fastcall sub_2EF24(const char *a1);
int __fastcall sub_2EF64(sem_t *a1, const char *a2, const char *a3, int a4);
int __fastcall sub_2EFE4(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4);
int __fastcall sub_2F02C(sem_t *a1, const char *a2, const char *a3, int a4);
void *__fastcall sub_2F0AC(sem_t *a1);
int __fastcall sub_2F0F0(sem_t *sem, const char *a2, const char *a3, int a4);
int __fastcall sub_2F174(sem_t *a1, int a2, const char *a3, const char *a4, int a5);
int *__fastcall sub_2F270(sem_t *sem);
int __fastcall sub_2F2A8(int a1, int a2, int a3);
int __fastcall sub_2F4BC(int a1, char a2);
void __fastcall sub_2F7A4(_DWORD *a1, char *a2, int a3);
void __fastcall sub_2FEE4(_DWORD *a1, int a2, int a3);
unsigned int __fastcall sub_2FF20(unsigned int result, int a2, int a3);
_DWORD *__fastcall sub_30140(_DWORD *result);
void *__fastcall sub_30174(int *a1, const void *a2, size_t n);
_DWORD *__fastcall sub_30214(_DWORD *a1, int a2);
_DWORD *__fastcall sub_3030C(const void *a1, size_t n, int a3);
char *__fastcall sub_30370(char *s, int a2);
void sub_3050C();
void *__fastcall sub_30524(int a1, char *s);
int __fastcall sub_30638(unsigned int *a1, char *s);
void __fastcall sub_306CC(unsigned int *a1, char *s, int a3, _BYTE *a4);
int __fastcall sub_307D8(unsigned int *a1, char *s);
int __fastcall sub_307F0(unsigned int *a1, int a2, int a3, int a4);
int __fastcall sub_30824(unsigned int *a1, int a2, int a3, int a4);
bool __fastcall sub_30858(const struct sockaddr *a1, const char **a2, _BYTE *a3);
void __fastcall sub_309F8(int a1, int a2, int a3);
int sub_30EEC();
int __fastcall sub_31B10(int a1);
_DWORD *__fastcall sub_31B4C(_DWORD *a1, const char *a2, int a3, const char *a4, char a5);
int __fastcall sub_31DD4(int result, int a2);
unsigned __int8 **__fastcall sub_31E34(unsigned __int8 **result, unsigned __int8 **a2);
int __fastcall sub_31EBC(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, _DWORD *a4);
int __fastcall sub_32000(pthread_rwlock_t *a1, const char *a2, int a3);
int __fastcall sub_3207C(pthread_mutex_t *a1, const char *a2, int a3);
int sub_320B8();
void __noreturn sub_321B0(); // weak
int __fastcall sub_322AC(int *a1);
int __fastcall sub_323A4(unsigned int *a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_32C68(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32C8C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32CB0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32CD4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32CF8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D1C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D40(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D64(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32D88(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32DAC(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32DD0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32DF4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E18(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E3C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E60(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32E84(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_32EA8(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_32ECC(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5);
int __fastcall sub_332E4(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_333B8(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_333CC(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_33580(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_33594(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4);
int __fastcall sub_336EC(int a1, int a2, _BYTE *a3, int a4);
int __fastcall sub_339F8(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4);
int __fastcall sub_33AA4(int a1, int a2, const char *a3, int a4, unsigned __int8 a5);
int __fastcall sub_33C3C(int a1, int a2, int a3, int a4);
void __fastcall sub_33DE0(unsigned int *a1, int a2, char *nptr, int a4, int a5);
int __fastcall sub_33F8C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_340D4(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_341F8(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5);
int __fastcall sub_34340(unsigned int *a1, int a2, char *s, int a4);
void __fastcall sub_34598(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_346A0(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5);
int __fastcall sub_34900(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_34914(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
int __fastcall sub_34AD0(int a1, int a2, int a3, int a4);
void __fastcall sub_34C30(unsigned int *a1, int a2, char *a3, int a4);
int __fastcall sub_34D0C(unsigned int *a1, int a2, int a3, unsigned __int8 a4);
_DWORD *__fastcall sub_34D20(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_34FC4(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6);
_DWORD *__fastcall sub_353A0(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_353C4(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_353E8(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_3540C(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35430(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35454(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35478(_DWORD *a1, const char *a2, const char *a3, char a4);
_DWORD *__fastcall sub_35624(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_35648(int a1, int a2, int a3, int a4);
_DWORD *__fastcall sub_36270(_DWORD *a1, const char *a2, const char *a3, char a4);
int __fastcall sub_36294(unsigned int *a1, int a2, int a3, int a4);
int sub_36534();
void __fastcall sub_365FC(int a1);
void __fastcall sub_385C8(int a1, const char *a2, int a3);
int sub_3877C();
int __fastcall sub_38804(int a1);
int __fastcall sub_3888C(int result, const char *a2, const char *a3, int a4);
void __fastcall sub_3895C(int a1, const char *a2, int a3);
const char *__fastcall sub_389F0(const char **a1, const char *a2, const char *a3, int a4);
_BYTE *__fastcall sub_38D2C(int a1);
_BYTE *__fastcall sub_38DD4(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8);
int __fastcall sub_39094(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_39114(int a1, const char *a2, const char *a3, int a4);
int __fastcall sub_39140(int a1, const char *a2, const char *a3, int a4);
const char *__fastcall sub_39208(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_392F8(const char **a1, int a2, const char *a3, const char *a4, int a5);
const char **__fastcall sub_39450(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char **__fastcall sub_395AC(const char **result, int a2, int a3, const char *a4, const char *a5, int a6);
const char *__fastcall sub_39718(int a1, int a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_3981C(const char **a1, int *a2, const char *a3, const char *a4, int a5);
const char *__fastcall sub_3999C(const char **a1, int *a2, const char *a3, const char *a4, int a5);
int __fastcall sub_39B14(const char **a1, const char *a2, const char *a3, int a4);
int __fastcall sub_39C30(const char **ptr, const char *a2, const char *a3, int a4);
int __fastcall sub_39D8C(__int64 a1, _QWORD *a2);
void sub_3A1EC();
void sub_3A28C();
_DWORD *sub_3A384();
int sub_3A7B8();
void sub_3A7D8();
void __noreturn sub_3A934();
void __noreturn sub_3AA8C();
int sub_3AC78();
int sub_3ACC8();
int __fastcall sub_3AD18(pthread_rwlock_t *a1);
int __fastcall sub_3AD9C(int a1);
int sub_3B5B8();
int sub_3B6F8();
int __fastcall sub_3B808(int a1);
int __fastcall sub_3B834(int result, int a2);
int sub_3B848();
int __fastcall sub_3B8DC(int a1);
int __fastcall sub_3B998(int a1);
int __fastcall sub_3B9B4(int a1);
int __fastcall sub_3BBA8(int a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_3BD70(int a1);
int __fastcall sub_3BF04(int a1);
size_t __fastcall sub_3BFB4(int a1, const void *a2, size_t a3);
int __fastcall sub_3C2F4(int a1, _BYTE *a2, unsigned int a3);
int __fastcall sub_3C378(int a1);
int __fastcall sub_3C3E8(int a1);
int __fastcall sub_3C460(int a1);
int sub_3C478();
int __fastcall sub_3C490(char a1, char a2, int a3, int a4);
int __fastcall sub_3C6E8(char a1, __int16 a2, int a3, int a4);
int __fastcall sub_3C92C(_BYTE *a1, int a2);
int __fastcall sub_3CA18(int a1);
int __fastcall sub_3CA8C(int a1, char a2, char a3, char a4, unsigned int a5);
int __fastcall sub_3CB3C(int a1, unsigned __int8 a2);
int __fastcall sub_3CBB0(int a1, char a2, char a3, char a4);
unsigned int __fastcall sub_3CC84(unsigned int result, unsigned __int8 *a2, int a3);
int __fastcall sub_3CCC0(__int16 a1, __int16 a2);
int __fastcall sub_3CE6C(int a1);
int sub_3D744();
int sub_3D8E8();
int sub_3DA90();
int sub_3DC38();
int __fastcall sub_3E224(char a1, _WORD *a2);
void __fastcall sub_3E264(int a1);
int sub_3E348();
int __fastcall sub_3E3A0(char a1, unsigned int a2);
int __fastcall sub_3E610(char a1, int a2);
int __fastcall sub_3E820(int a1);
int sub_3E908();
int __fastcall sub_3E968(int a1, int a2, int a3);
unsigned int __fastcall sub_3E9FC(int a1);
int __fastcall sub_3EB90(int a1);
int __fastcall sub_3ED44(int a1);
int __fastcall sub_3EF54(int a1);
int sub_3F304();
int sub_3F4AC();
int sub_3F64C();
void __noreturn sub_3F8BC();
int __fastcall sub_3F9B0(_BYTE *a1);
int __fastcall sub_3FD3C(_BYTE *a1);
int __fastcall sub_40018(int a1);
int __fastcall sub_40214(int a1);
int sub_4057C();
void sub_40624();
int sub_40A98();
int sub_40B80();
int sub_40C68();
int sub_40D4C();
void sub_40DA4();
int sub_40E7C();
pthread_mutex_t *sub_40F40();
int __fastcall sub_41158(unsigned int a1);
int __fastcall sub_4131C(_WORD *a1);
int __fastcall sub_41828(unsigned int a1);
int sub_41A88();
int __fastcall sub_41BC0(int a1, int a2);
int __fastcall sub_41CC8(_BYTE *a1, int a2);
int __fastcall sub_41DBC(int *a1);
size_t __fastcall sub_42188(unsigned __int8 a1);
int __fastcall sub_42200(int a1);
int sub_42318();
int __fastcall sub_42358(int a1, unsigned int a2);
int __fastcall sub_42454(unsigned int a1);
int __fastcall sub_424A0(int a1);
int sub_425A4();
int __fastcall sub_425E8(int a1, int a2);
int __fastcall sub_4273C(int a1, int a2, int a3);
void __noreturn sub_42894();
void __noreturn sub_42FD8();
int __fastcall sub_43204(int a1);
int __fastcall sub_43250(int a1, char a2);
int __fastcall sub_432BC(int a1);
int __fastcall sub_433BC(int a1, int a2);
int __fastcall sub_434BC(int result);
int __fastcall sub_43500(int a1, int a2, int a3);
int __fastcall sub_43614(int result, int a2);
unsigned int __fastcall sub_43660(unsigned int a1);
void sub_43668();
int __fastcall sub_439A0(int result, int a2);
int __fastcall sub_43C74(int a1);
size_t __fastcall sub_43D20(unsigned __int8 a1, const void *a2, size_t a3);
int __fastcall sub_43D28(unsigned __int8 a1, _BYTE *a2, unsigned int a3);
void sub_43D30();
int __fastcall sub_43E78(int a1);
void __noreturn sub_43F14();
int __fastcall sub_44D74(_BYTE *a1, _DWORD *a2);
void sub_44DB4();
int __fastcall sub_44FEC(int a1);
void sub_4504C();
void sub_45120();
int __fastcall sub_45310(int a1);
int sub_45464();
void __fastcall sub_4548C(int a1, int a2);
void __fastcall sub_455CC(int a1);
int __fastcall sub_45674(int a1, int a2, char a3, unsigned __int8 a4, unsigned __int8 a5);
int __fastcall sub_45700(int a1, int a2);
int __fastcall sub_45970(int result);
int sub_45A7C();
int sub_45B48();
int sub_45C28();
int sub_45D08();
int sub_45DE8();
int sub_45F7C();
void __noreturn sub_46090();
void __fastcall sub_46654(int a1);
int __fastcall sub_467E4(unsigned __int64 a1, char *a2, size_t a3, int a4, char a5);
int sub_469B8();
int sub_46EEC();
int __fastcall sub_46F24(int a1, int a2, int a3, int a4);
void __fastcall sub_475A0(int a1, int a2, char a3, unsigned int a4);
void __noreturn sub_47748();
void sub_47C4C();
void __fastcall sub_47DA0(int a1, int a2);
void __fastcall sub_47F54(int a1);
int sub_480FC();
int __fastcall sub_48140(int result);
int __fastcall sub_481D0(int result, char a2);
int __fastcall sub_4821C(char a1);
void sub_482D0();
void __fastcall sub_483A4(int a1, int a2);
int sub_48470();
int __fastcall sub_484C8(int a1);
int __fastcall sub_48564(int a1, int a2);
int sub_48598();
int sub_48678();
int __fastcall sub_48840(void *a1);
int sub_4892C();
int __fastcall sub_48A0C(int a1);
int sub_48A54();
int __fastcall sub_48B34(int a1);
void __fastcall sub_49290(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
void __fastcall sub_493E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
int *__fastcall sub_49428(int *result, int a2);
int __fastcall sub_49440(int a1, int a2);
int __fastcall sub_49450(int a1, int a2);
int __fastcall sub_49464(int a1, int a2, int a3, int a4, char a5);
void __fastcall sub_49A18(_BYTE *a1, char a2, int a3);
void __fastcall sub_49B74(int a1, int a2, char a3);
int *__fastcall sub_49DEC(int *a1);
int __fastcall sub_4A218(_DWORD *a1, unsigned int *a2);
unsigned int *__fastcall sub_4C914(unsigned int *result, unsigned int *a2, int a3);
unsigned int *__fastcall sub_4C9F4(int a1, _BYTE *a2);
int __fastcall sub_4CC58(void *src, int a2, void *a3, unsigned __int8 a4);
int __fastcall compar(const void *a1, const void *a2); // idb
unsigned int __fastcall sub_4CCBC(unsigned int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6);
unsigned int *__fastcall sub_4CE5C(unsigned int *result, int a2);
int __fastcall sub_4CEC0(int *a1, unsigned int a2);
int __fastcall sub_4D714(char *a1, int a2, int a3);
int __fastcall sub_4D798(int a1, unsigned __int8 *a2);
int __fastcall sub_535FC(char *a1, unsigned __int8 *a2);
int __fastcall sub_53700(char *a1, int a2);
int __fastcall sub_537BC(int a1, char *src, unsigned __int64 n);
int __fastcall sub_538C8(char *a1, int a2, const void *a3, size_t a4);
int __fastcall sub_53A04(int a1, void *a2, size_t a3);
int __fastcall sub_53CA0(unsigned __int8 *a1);
int __fastcall sub_53F30(int result);
int __fastcall sub_53F9C(int result, int a2, int a3);
_BYTE *__fastcall sub_54004(int a1, _BYTE *a2);
_BYTE *__fastcall sub_54160(int a1, int a2, _BYTE *a3);
int __fastcall sub_54200(_DWORD *a1, _DWORD *a2);
int __fastcall sub_54224(char *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4);
int __fastcall sub_54448(int a1, int a2);
int __fastcall sub_54454(const void *a1, size_t a2, FILE *s);
int __fastcall sub_54474(void *src, size_t n, const void **a3);
int __fastcall sub_5448C(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
int __fastcall sub_54530(_DWORD *a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5);
int __fastcall sub_54B5C(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4);
int __fastcall sub_54BA8(_DWORD *a1, int a2, __int16 a3);
int __fastcall sub_54BBC(_DWORD *a1, char *filename, __int16 a3);
void *__fastcall sub_54C0C(_DWORD *a1, __int16 a2);
int __fastcall sub_54C78(int result, int a2, _DWORD *a3);
int __fastcall sub_54CD4(int a1, int *a2, char *s2, int a4);
void __fastcall sub_54D4C(int a1);
int __fastcall sub_54DAC(_DWORD *a1);
void __fastcall sub_54E2C(int a1);
int __fastcall sub_54E44(int a1, char *a2, int a3, int a4);
int __fastcall sub_5504C(int a1, char *a2);
int __fastcall sub_550C4(_DWORD *a1, char *a2);
void __fastcall sub_551E0(_DWORD *a1);
int __fastcall sub_5525C(int a1, char *a2);
int __fastcall sub_552F4(int a1);
void __fastcall sub_55304(int a1, int a2);
int __fastcall sub_5534C(_DWORD *a1);
int __fastcall sub_5536C(_DWORD *a1);
int __fastcall sub_55390(_DWORD *a1);
int sub_553EC(int result, _DWORD *a2, const char *a3, ...);
int __fastcall sub_5550C(int a1, int a2, int a3);
void __fastcall sub_55558(int a1);
int __fastcall sub_55584(_BYTE *a1);
_DWORD *__fastcall sub_5562C(_DWORD *result, int a2);
int __fastcall sub_556E4(int a1, int a2);
_DWORD *__fastcall sub_55868(_DWORD *result, int a2);
int __fastcall sub_558B4(int a1, int a2);
unsigned int __fastcall sub_558E4(int a1, int a2);
int *__fastcall sub_560B8(double a1, int a2);
int *__fastcall sub_5650C(_DWORD *a1, unsigned int a2, int a3);
int *__fastcall sub_565E8(int *a1, unsigned int a2, char *a3);
int *__fastcall sub_5667C(int *a1, int a2, unsigned int a3, char *a4);
int *__fastcall sub_56718(int *a1, unsigned int a2, char *a3);
int *__fastcall sub_567C4(char *a1, unsigned int a2, char *a3);
void *__fastcall sub_56924(size_t a1);
void __fastcall sub_5694C(void *a1);
void *__fastcall sub_5696C(const char *a1);
void *(*__fastcall sub_569C4(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
int __fastcall sub_569D4(_DWORD *a1);
void __fastcall sub_56A0C(int a1);
int __fastcall sub_56A38(int result);
int __fastcall sub_56A4C(int a1);
int __fastcall sub_56A54(int *a1);
int __fastcall sub_56A68(const void **a1, void *src, size_t n);
int __fastcall DataWriter::WriteByte(const void **this, unsigned __int8 a2);
int __fastcall luaL_addstring(const void **a1, char *s);
int __fastcall sub_56B78(int *a1, int a2, int a3);
int __fastcall sub_56BA0(int a1, double *a2);
int __fastcall sub_56C60(char *a1, size_t a2);
int __fastcall sub_56D94(int a1, _BYTE *a2, _DWORD *a3);
int __fastcall sub_56E7C(int a1);
int __fastcall sub_56EF8(char *a1, int a2, int *a3);
char *__fastcall sub_56FD0(char *a1, _DWORD *a2);
int __fastcall sub_57044(const char *a1, signed int a2);
void *__fastcall sub_570D8(_DWORD *a1, int a2, int a3);
_DWORD *sub_57160();
_DWORD *__fastcall sub_571BC(_DWORD *result);
int __fastcall sub_571D8(_DWORD *a1, char *a2);
int __fastcall sub_571FC(_DWORD *a1, char *a2);
int __fastcall sub_57220(_DWORD *a1);
_DWORD *__fastcall sub_57254(_DWORD *a1);
int __fastcall sub_57278(_DWORD *a1, char *a2);
int __fastcall sub_572A0(_DWORD *a1, int a2);
int __fastcall sub_572CC(int result);
int __fastcall sub_572D8(int result);
int __fastcall sub_572E4(_DWORD *a1, int a2, int a3);
int __fastcall sub_5732C(int result);
_DWORD *sub_57338();
_DWORD *__fastcall sub_573A4(_DWORD *result);
_DWORD *__fastcall sub_573C0(_DWORD *result, unsigned int a2);
int __fastcall sub_573F4(_DWORD *a1, _DWORD *a2);
_DWORD *__fastcall sub_574A4(const char *a1);
_DWORD *__fastcall sub_57500(const char *a1);
_DWORD *__fastcall sub_57530(_DWORD *result);
int __fastcall sub_5754C(int a1, const char *a2);
int __fastcall sub_57598(int a1, const char *a2);
_QWORD *__fastcall sub_575D4(__int64 a1);
__int64 __fastcall sub_57600(int a1);
int __fastcall sub_5762C(int a1, __int64 a2);
_QWORD *__fastcall sub_57654(double a1);
void sub_576B0();
int __fastcall sub_576E0(double a1);
int __fastcall sub_57730(int result);
void *sub_57778();
void *sub_57784();
void *sub_57790();
void __fastcall sub_5779C(void **a1);
int __fastcall sub_57870(_DWORD *a1);
int __fastcall sub_578EC(_DWORD *a1, unsigned int a2);
int __fastcall sub_579A0(int a1, unsigned int a2, int a3);
int __fastcall sub_57AA0(int *a1, int *a2);
int __fastcall sub_57B24(_DWORD *a1, unsigned int a2, int a3);
int __fastcall sub_57BD8(_DWORD *a1, char *a2, int a3);
int __fastcall sub_57C58(_DWORD *a1, _DWORD *a2);
int __fastcall sub_57D14(_DWORD *a1, char *a2, int a3);
int __fastcall sub_57D88(_DWORD *a1, _DWORD *a2);
int __fastcall sub_57E34(_DWORD *a1, _DWORD *a2);
bool __fastcall sub_57EE8(int *a1, int *a2);
int *__fastcall sub_580AC(double a1);
int *__fastcall sub_58220(double a1);
char *__fastcall sub_58368(char *result, char *s);
char *__fastcall sub_583CC(char *result, char *s);
int __fastcall sub_58410(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg); // idb
int sub_58450(int a1, int a2, int a3, int a4, char *format, ...); // idb
char *__fastcall sub_58478(const char *a1, const char *a2);
int __fastcall sub_584B4(_BYTE *a1);
int __fastcall sub_584C4(_BYTE *a1);
char *__fastcall sub_584D8(const char *a1, _BYTE *a2);
char *__fastcall sub_5856C(const char *a1, _BYTE *a2);
int __fastcall sub_5858C(int a1, _DWORD *a2);
char *__fastcall sub_58598(const char *a1, _DWORD *a2);
char *__fastcall sub_5861C(const char *a1, int *a2);
char *__fastcall sub_586A0(const char *a1, _DWORD *a2);
int __fastcall sub_58760(_DWORD *a1);
void __fastcall __noreturn sub_58778(const char *a1);
void __fastcall __noreturn sub_58798(int a1);
char *__fastcall sub_587D8(char *a1, unsigned __int8 *a2);
char *__fastcall sub_587FC(char *a1, unsigned __int8 *a2);
char *__fastcall sub_58820(_BYTE *a1, const char **a2);
int __fastcall sub_58880(char *a1, _DWORD *a2);
int __fastcall sub_58894(char *a1, float *a2);
int __fastcall sub_588C0(char *a1, _DWORD *a2);
int __fastcall sub_588D4(char *a1, _DWORD *a2);
int __fastcall sub_588E8(char *a1, _DWORD *a2);
unsigned __int8 *__fastcall sub_588FC(int a1, _DWORD *a2);
_BYTE *__fastcall sub_589A4(unsigned int *a1, _DWORD *a2);
unsigned __int8 *__fastcall sub_58A8C(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3);
unsigned __int8 *__fastcall sub_58B80(const char **a1);
int __fastcall sub_58D60(int *a1);
unsigned __int8 *__fastcall sub_58DC0(unsigned int *a1, unsigned __int8 **a2);
unsigned __int8 *__fastcall sub_58E18(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3);
unsigned __int8 *__fastcall sub_58E70(unsigned int *a1);
unsigned __int8 *__fastcall sub_58ECC(unsigned __int8 *a1, unsigned int *a2);
int __fastcall sub_58F70(int result, int a2);
bool __fastcall sub_5903C(_DWORD *a1, const char **a2, void (*a3)(const char *, ...));
void sub_59098();
int sub_590B8(const char *a1, ...);
void __noreturn sub_59100(const char *a1, ...);
char *__fastcall sub_59140(const char *a1);
void *__fastcall sub_59170(_DWORD *a1, int a2, int a3);
int __fastcall sub_591A4(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...));
char *__fastcall sub_595C4(const char *a1, char *a2);
int __fastcall sub_59AC8(int a1, int a2);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2);
int __fastcall sub_59BC4(__int64 a1, __int64 a2);
int __fastcall sub_59F08(__int64 a1);
int __fastcall sub_59F1C(__int64 a1);
int __fastcall sub_59F7C(__int64 a1, __int64 a2);
int __fastcall sub_59FC8(double a1);
unsigned int __fastcall sub_5A000(double a1);
int __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
int __fastcall _gnu_uldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3);
int __fastcall sub_5A0C0(__int64 a1, __int64 a2);
int __fastcall sub_5A518(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4);
int nullsub_11(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN loc_122A0; // weak
_UNKNOWN loc_30D40; // weak
_UNKNOWN locret_38D7C; // weak
_UNKNOWN init;
_UNKNOWN unk_5A9B4; // weak
_UNKNOWN unk_5A9E0; // weak
int dword_5AA04[16] = { 1, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1568 }; // weak
_UNKNOWN unk_5AA64; // weak
char a000000029c6bf4[321] = "000000029c6bf469abe4ad37605c097a860cff3cf5c1ef4377618f74000000000000000082b1514e7b6565941e5824f084292164ec5f97e7ea20c494bd96e524d478977b536dd2261900896c8b10020000000080000000000000000000000000000000000000000000000000000000000000000000000000000000008002000064e4e3becc01064d808269b330f40f4de82dc92e894d635025daa3e2e2c410b4"; // weak
char a00000002c01f50[321] = "00000002c01f502cb3e9fdb053230ec12a4954c1021a6b35862b5e29000000000000000084d1b83ae44057025e8c5b5756b44f04df5fffe4a7a30e5c12d12a97a7a4c2ea536dce431900896cb6d60e00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000d08f7e14c50dad77dc238b4db2901a0578e657b1954779ab9cd82a73829edf7f"; // weak
const char delim[] = { '|', '\0' }; // idb
const char a49[] = "4.9."; // idb
const char word_60FDC[] = { '0', '\0' }; // idb
char aClearSock[11] = "clear_sock"; // weak
char *off_621FC = "http:"; // weak
const char dword_63494[] = { 'n', 'o', '\0', '\0' }; // idb
char aEscapeString[14] = "escape_string"; // weak
char aResetAllHashBo[25] = "reset_all_hash_board_low"; // weak
char aD_0[2] = "d"; // weak
const char aSChainDFailed_0[20] = "%s chain %d failed!\n"; // idb
const char ptr[] = { '\n', '\0' }; // idb
const char aAsicNumErrD[16] = "asic num err![%d"; // idb
const char word_686A0[] = { ']', '\0' }; // idb
unsigned int dword_692DC[16] = { 128u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
_UNKNOWN unk_693E0; // weak
_UNKNOWN unk_693E8; // weak
_DWORD dword_6956C[29] =
{
  5,
  13,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741
}; // weak
int (*off_72000[2])() = { &frame_dummy, &_do_global_dtors_aux }; // weak
int (*off_72004)() = &_do_global_dtors_aux; // weak
int dword_72430[] = { 1 }; // weak
double dbl_72438 = 1.0; // weak
char *off_72440 = "--version-file"; // weak
int dword_72444 = 2; // weak
_UNKNOWN unk_7245C; // weak
int dword_72C04 = 48; // weak
int dword_72C08 = 0; // weak
int dword_72C0C = 5; // weak
char *off_72C10 = ":D"; // weak
int dword_72C14 = 1; // weak
int dword_72C18 = 1; // weak
char byte_72C1C = '\x01'; // weak
double dbl_72C20 = 1.84467441e19; // weak
double dbl_72C28 = 1.0; // weak
int dword_72C30 = -1; // weak
int dword_72C34 = 120; // weak
int dword_72C38 = 1; // weak
int dword_72C3C = 1; // weak
int dword_72C40 = 1; // weak
int dword_72C44 = 1; // weak
int dword_72C48 = 1; // weak
char byte_72C4C = '\x01'; // weak
char byte_72C4D = '\x01'; // weak
char *off_72C64 = "--config|-c"; // weak
int dword_72CF4 = 1; // weak
int dword_72CFC = 4028; // weak
_UNKNOWN *off_72D00 = (_UNKNOWN *)0x680DC; // weak
char *off_72D04[3] = { "FTW", "224.0.0.75", "0.0.0.0" }; // weak
char *off_72D08[2] = { "224.0.0.75", "0.0.0.0" }; // weak
char *off_72D0C = "0.0.0.0"; // weak
int dword_72D10 = 4028; // weak
_UNKNOWN *off_72D14 = &unk_60FD0; // weak
int (*off_72D18)() = &sub_28A38; // weak
_UNKNOWN unk_72E1C; // weak
_UNKNOWN unk_72F18; // weak
_UNKNOWN unk_72F38; // weak
int dword_72F3C[] = { 3 }; // weak
int dword_72F40 = 7; // weak
_UNKNOWN *off_7336C = (_UNKNOWN *)0x61E90; // weak
_UNKNOWN unk_73374; // weak
int dword_73504 = 5; // weak
_UNKNOWN unk_73908; // weak
void (*off_73914)() = &sub_3A7D8; // weak
_BYTE byte_73988[3] = { 80, 81, 84 }; // weak
char byte_7398B = '\x01'; // weak
int dword_7398C = -1; // weak
int dword_73990 = 34677009; // weak
int dword_73994 = -2145386175; // weak
int dword_73998 = 117455361; // weak
int dword_7399C = 13; // weak
int dword_739A0 = 3; // weak
char byte_739A4 = '\x01'; // weak
int dword_739A8 = 16777216; // weak
char byte_739AC = '\x01'; // weak
int dword_739B0 = 30; // weak
int dword_739B4 = 84000; // weak
int dword_739B8 = 681; // weak
char *off_739C0 = "z9"; // weak
int dword_739D0 = 3; // weak
void *(*off_739D4)(void *s, int c, size_t n) = &memset; // weak
void *(*off_739D8)(size_t size) = &malloc; // weak
void (*off_739DC)(void *ptr) = &free; // weak
_UNKNOWN unk_739E0; // weak
_UNKNOWN unk_739E8; // weak
_UNKNOWN unk_739F0; // weak
int stdscr; // weak
int LINES; // weak
int stdin; // weak
int stdout; // weak
int stderr; // weak
char byte_73A0C; // weak
int dword_73A10; // weak
int dword_73A14; // weak
int dword_73A18; // weak
int dword_73A1C; // weak
int dword_73A20; // weak
int dword_73A24; // weak
int dword_73A28; // weak
char byte_73A2C[256]; // weak
int dword_73B2C; // weak
char byte_73B30[512]; // idb
int dword_73D30; // weak
int dword_73D34; // weak
int dword_73D38; // weak
struct timeval stru_73D3C; // weak
struct timeval stru_73D44; // weak
_UNKNOWN unk_73D4C; // weak
__int64 qword_73D50; // weak
char byte_73D58; // weak
int dword_73D5C; // weak
int dword_73D60; // weak
char byte_73D64[200]; // idb
int dword_73E2C; // weak
int dword_73E30; // weak
int dword_73E34; // weak
int dword_73E38; // weak
int dword_73E3C; // weak
int dword_73E40; // weak
int dword_73E44; // weak
int dword_73E48; // weak
int dword_73E4C; // weak
pthread_mutex_t mutex; // idb
int dword_73E68; // weak
int dword_73E6C; // weak
char byte_73E70; // weak
int dword_73E74; // weak
char byte_73E78; // weak
char byte_73E79; // weak
int dword_73E7C; // weak
char byte_73E80; // weak
int dword_73E84; // weak
int dword_73E88; // weak
int dword_73E8C; // weak
int dword_73E90; // weak
int dword_73E94; // weak
int dword_73E98; // weak
int dword_73E9C; // weak
pthread_mutex_t stru_73EA0; // idb
pthread_cond_t stru_73EB8; // idb
int dword_73EE8; // weak
int dword_73EEC; // weak
pthread_mutex_t stru_73EF0; // idb
int dword_73F08; // weak
int dword_73F0C; // weak
_DWORD dword_73F10[2]; // weak
double dbl_73F18[12]; // weak
int dword_73F78; // weak
char byte_73F7C; // weak
int dword_73F80; // weak
int dword_73F84; // weak
int dword_73F88; // weak
char byte_73F8C; // weak
char byte_73F8D; // weak
double dbl_73F90; // weak
char byte_73F98[256]; // weak
char byte_74098[40]; // weak
int dword_740C0; // weak
int dword_740C4; // weak
int dword_740C8; // weak
int dword_740CC; // weak
pthread_rwlock_t stru_740D0; // idb
int dword_740F0; // weak
char byte_740F4[8]; // weak
_DWORD dword_740FC[4]; // weak
_UNKNOWN unk_7410C; // weak
_UNKNOWN unk_74110; // weak
_UNKNOWN unk_74114; // weak
_UNKNOWN unk_74118; // weak
char byte_7411C[32]; // weak
char byte_7413C[8]; // idb
char byte_74144; // weak
char byte_74148; // weak
char byte_74149; // weak
struct timeval stru_7414C; // weak
char byte_74154; // weak
_BYTE byte_74158[2560]; // weak
_BYTE byte_74B58[2560]; // weak
char byte_75558; // weak
int dword_7555C; // weak
int dword_75560; // weak
int dword_75564; // weak
int dword_75568; // weak
_DWORD dword_7556C[4]; // weak
_UNKNOWN unk_7557C; // weak
_UNKNOWN unk_75580; // weak
_UNKNOWN unk_75584; // weak
_UNKNOWN unk_75588; // weak
char s[256]; // idb
char byte_7568C[256]; // idb
int dword_7578C; // weak
int dword_75790; // weak
int dword_75794[]; // weak
char byte_75898; // weak
_UNKNOWN unk_7589C; // weak
int dword_759A0; // weak
int dword_759A4; // weak
int dword_759A8; // weak
int dword_759B0; // weak
int dword_759B4; // weak
char byte_759C0[16]; // idb
int dword_759D0; // weak
unsigned __int8 byte_75A08[204]; // weak
int dword_75AD4; // weak
char byte_75AE8; // weak
char byte_75AEC; // weak
char byte_75AED; // weak
char byte_75AEE; // weak
int dword_75AF0; // weak
int dword_75AF4; // weak
pthread_mutex_t stru_75AF8; // idb
int dword_75B10; // weak
int dword_75B14; // weak
int dword_75B18; // weak
int dword_75B1C; // weak
char byte_75B20; // weak
int dword_75B24; // weak
char dword_75B28[]; // idb
char word_75C28[]; // idb
char byte_75C48; // weak
char byte_75C49; // weak
int dword_75C50[]; // weak
char byte_75C54; // weak
char byte_75C55; // weak
char byte_75C56; // weak
char byte_75C57; // weak
double dbl_75C58; // weak
int dword_75C60; // weak
char byte_75C68; // weak
double dbl_75C70; // weak
int dword_75C78; // weak
char byte_75C7C; // weak
_UNKNOWN unk_75C80; // weak
_QWORD qword_75CA0[4]; // weak
double dbl_75CC0; // weak
pthread_mutex_t stru_75CC8; // idb
pthread_mutex_t stru_75CE0; // idb
int dword_75CF8; // weak
pthread_mutex_t stru_75CFC[10]; // weak
_UNKNOWN unk_75DEC; // weak
int dword_75EDC; // weak
pthread_mutex_t stru_75EE0; // idb
__int16 word_75EF8[]; // weak
pthread_mutex_t stru_75F10; // idb
unsigned __int8 byte_75F28[4]; // weak
char byte_75F2C[]; // weak
char byte_75F2D; // weak
char byte_75F2E; // weak
char byte_75F2F; // weak
char byte_75F30; // weak
char byte_75F31; // weak
int dword_75F34; // weak
int dword_75F38; // weak
pthread_mutex_t stru_75F40; // idb
char byte_75F5C; // weak
char byte_75F5D; // weak
char byte_75F5E; // weak
int dword_75F60; // weak
char byte_75F64; // weak
char byte_75F65; // weak
char byte_75F66; // weak
char byte_75F67; // weak
int dword_75F68; // weak
int dword_75F6C; // weak
char byte_75F70[]; // weak
char byte_75F71; // weak
pthread_mutex_t stru_75F74; // idb
_UNKNOWN unk_75F90; // weak
unsigned __int8 byte_75FB0[4]; // weak
_BYTE byte_75FB4[2564]; // weak
pthread_mutex_t stru_769B8; // idb
_BYTE byte_769D4[16]; // weak
_BYTE byte_769E4[16]; // weak
_UNKNOWN unk_769F4; // weak
_UNKNOWN unk_76A14; // weak
_BYTE byte_76A24[4]; // weak
char byte_76A28; // weak
int dword_76A2C; // weak
double dbl_77AE8; // weak
_UNKNOWN unk_77AF0; // weak
int (__fastcall *off_77AFC)(_DWORD); // weak
char byte_77B70; // weak
pthread_mutex_t stru_77B74; // idb
_UNKNOWN unk_77B90; // weak
int (__fastcall *off_77B9C)(_DWORD); // weak
_UNKNOWN unk_77C10; // weak
int (__fastcall *off_77C1C)(_DWORD); // weak
int dword_77C90; // weak
_UNKNOWN unk_77C98; // weak
int (__fastcall *off_77CA4)(_DWORD); // weak
_UNKNOWN unk_77D18; // weak
_UNKNOWN *off_77D24; // weak
_UNKNOWN unk_77D98; // weak
int (__fastcall *off_77DA4)(_DWORD); // weak
_UNKNOWN unk_77E18; // weak
int (__fastcall *off_77E24)(_DWORD); // weak
int dword_77E98; // weak
_UNKNOWN unk_77EA0; // weak
_UNKNOWN *off_77EAC; // weak
int dword_77F20; // weak
int dword_77F24; // weak
int dword_77F28; // weak
struct sigaction oact; // idb
char byte_77FBC; // weak
int dword_77FC0; // weak
pthread_cond_t stru_77FC8; // idb
_UNKNOWN unk_77FF8; // weak
int (__fastcall *off_78004)(_DWORD); // weak
char byte_78078; // weak
_UNKNOWN unk_78080; // weak
int (__fastcall *off_7808C)(_DWORD); // weak
pthread_rwlock_t stru_78100; // weak
double dbl_78120; // weak
_UNKNOWN unk_78128; // weak
int (__fastcall *off_78134)(_DWORD); // weak
char byte_781A8; // weak
pthread_mutex_t stru_781AC; // idb
_UNKNOWN unk_781C8; // weak
int (__fastcall *off_781D4)(_DWORD); // weak
__int64 qword_78248; // weak
double dbl_78250; // weak
int dword_78258; // weak
int dword_78260; // weak
int dword_78264; // weak
int dword_78268; // weak
int dword_7826C; // weak
_UNKNOWN unk_78270; // weak
int (__fastcall *off_7827C)(_DWORD); // weak
char byte_782F0; // weak
int dword_782F4; // weak
_UNKNOWN unk_78300; // weak
int (__fastcall *off_7830C)(_DWORD); // weak
int dword_78380; // weak
_UNKNOWN unk_78388; // weak
int (__fastcall *off_78394)(_DWORD); // weak
int dword_78408; // weak
int dword_7840C; // weak
double dbl_78410; // weak
char byte_78418; // weak
int dword_78420; // weak
int dword_78424; // weak
int dword_78448; // weak
char byte_7844C; // weak
char byte_7844D; // weak
int dword_78450; // weak
pthread_mutex_t stru_78454; // idb
char byte_7846C; // weak
int dword_78470; // weak
pthread_rwlock_t rwlock; // idb
double dbl_78498; // weak
_UNKNOWN unk_784A0; // weak
int (__fastcall *off_784AC)(_DWORD); // weak
__int64 qword_78520; // weak
pthread_rwlock_t stru_78528; // idb
int dword_78548; // weak
_UNKNOWN unk_78550; // weak
pthread_mutex_t stru_785D0; // idb
int dword_785E8; // weak
char byte_785EC; // weak
int dword_785F0; // weak
char byte_785F8; // weak
char byte_785F9; // weak
_UNKNOWN unk_78600; // weak
int (__fastcall *off_7860C)(_DWORD); // weak
char byte_78680; // weak
char byte_78681; // weak
char byte_78682; // weak
pthread_mutex_t stru_78684; // weak
char byte_7869C; // weak
int dword_786A4; // weak
int dword_786A8; // weak
int dword_786CC; // weak
int dword_786D0; // weak
char byte_786D4; // weak
int dword_786D8; // weak
int dword_786DC; // weak
int dword_786E0; // weak
_UNKNOWN unk_786E8; // weak
int (__fastcall *off_786F4)(_DWORD); // weak
char byte_78768; // weak
int dword_7876C; // weak
int dword_78770; // weak
struct sigaction stru_78774; // idb
pthread_mutex_t stru_78800; // idb
pthread_rwlock_t stru_78818; // idb
pthread_mutex_t stru_78838; // idb
pthread_rwlock_t stru_78850; // idb
_UNKNOWN unk_78870; // weak
int (__fastcall *off_7887C)(_DWORD); // weak
char byte_788F0; // weak
int dword_788F8; // weak
pthread_cond_t cond; // idb
double dbl_78938; // weak
char byte_78940; // weak
int dword_78944; // weak
int dword_78948; // weak
int dword_7894C; // weak
char dest[68]; // idb
int dword_78994; // weak
_UNKNOWN unk_78998; // weak
_UNKNOWN *off_789A4; // weak
_UNKNOWN unk_78A18; // weak
int (__fastcall *off_78A24)(_DWORD); // weak
int dword_78A9C; // weak
char byte_78AA0; // weak
char byte_78AA1; // weak
int dword_78AA8; // weak
double dbl_78AB0; // weak
int dword_78AB8; // weak
double dbl_78AC0; // weak
_UNKNOWN unk_78AC8; // weak
int (__fastcall *off_78AD4)(_DWORD); // weak
char byte_78B48; // weak
_UNKNOWN unk_78B4C; // weak
int dword_78BB8; // weak
int dword_78BBC; // weak
int dword_78BC0; // weak
int dword_78BC4; // weak
int dword_78E84; // weak
int dword_78E88; // weak
_DWORD dword_78E8C[5]; // weak
pthread_cond_t stru_78EA0; // idb
char byte_78ED0[64]; // weak
int dword_78F10; // weak
int dword_78F54; // weak
_UNKNOWN unk_78F58; // weak
int dword_79078; // weak
int dword_79080; // weak
int dword_79084; // weak
int dword_79088; // weak
_UNKNOWN unk_7A120; // weak
_UNKNOWN unk_7F76D; // weak
int dword_9A2A0; // weak
int dword_9A2A4; // weak
_UNKNOWN unk_9A2A8; // weak
_UNKNOWN unk_9A2AF; // weak
char byte_9A2B0; // weak
int dword_9A2B8; // weak
int dword_9A2BC; // weak
_UNKNOWN unk_9A37B; // weak
_UNKNOWN unk_9A38B; // weak
_UNKNOWN unk_9A3BB; // weak
_UNKNOWN unk_9A3EB; // weak
int dword_9A471; // weak
int dword_9A475; // weak
char byte_9A49E; // weak
char byte_9A49F; // weak
char byte_9A4A0; // weak
int dword_9A4A2; // weak
int dword_9A4A6; // weak
int dword_9A4AA; // weak
int dword_9A4AE; // weak
char byte_9A4C6; // weak
char byte_9A4C7; // weak
char byte_9A4C8; // weak
char byte_9A4C9; // weak
char byte_9A4CB; // weak
int dword_9A4CC; // weak
int dword_9A540; // weak
int dword_9A544; // weak
int dword_9A548; // weak
int dword_9A54C; // weak
int dword_9A550; // weak
int dword_9A554; // weak
_UNKNOWN unk_9A558; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (0000A988) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return sub_F57C();
}

//----- (0000A994) --------------------------------------------------------
void sub_A994()
{
  JUMPOUT(0);
}
// A9A0: control flows out of bounds to 0

//----- (0000B288) --------------------------------------------------------
int __fastcall sub_B288(int a1)
{
  char v3[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(v3, 0x1000u, "WTF No pool %d found!", a1);
    sub_385C8(3, v3, 0);
  }
  return *(_DWORD *)(dword_78260 + 4 * a1);
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 78260: using guessed type int dword_78260;

//----- (0000B310) --------------------------------------------------------
void __noreturn sub_B310()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(v0, "Failed to create restart thread");
  sub_385C8(3, v0, 1);
  sub_16BE0(1);
}

//----- (0000B34C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B34C(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// B354: positive sp value 1004 has been found
// B354: unbalanced stack, ignored a potential tail call

//----- (0000B35C) --------------------------------------------------------
void __fastcall __noreturn sub_B35C(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B3B4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B3B4(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B3BC: positive sp value 1014 has been found
// B3BC: unbalanced stack, ignored a potential tail call

//----- (0000B3C8) --------------------------------------------------------
void __fastcall __noreturn sub_B3C8(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B420) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B420(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B428: positive sp value 1014 has been found
// B428: unbalanced stack, ignored a potential tail call

//----- (0000B434) --------------------------------------------------------
void __fastcall __noreturn sub_B434(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B48C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B48C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B494: positive sp value 1014 has been found
// B494: unbalanced stack, ignored a potential tail call

//----- (0000B4A0) --------------------------------------------------------
void __fastcall __noreturn sub_B4A0(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B4F8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B4F8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B500: positive sp value 1014 has been found
// B500: unbalanced stack, ignored a potential tail call

//----- (0000B50C) --------------------------------------------------------
void __fastcall __noreturn sub_B50C(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}
// 16BE0: using guessed type void __fastcall __noreturn sub_16BE0(_DWORD);

//----- (0000B564) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B564(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B56C: positive sp value 1014 has been found
// B56C: unbalanced stack, ignored a potential tail call

//----- (0000B578) --------------------------------------------------------
void __fastcall __noreturn sub_B578(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}
// 16BE0: using guessed type void __fastcall __noreturn sub_16BE0(_DWORD);

//----- (0000B5D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B5D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B5D8: positive sp value 1014 has been found
// B5D8: unbalanced stack, ignored a potential tail call

//----- (0000B5E4) --------------------------------------------------------
void __fastcall __noreturn sub_B5E4(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}
// 16BE0: using guessed type void __fastcall __noreturn sub_16BE0(_DWORD);

//----- (0000B63C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B63C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B644: positive sp value 1014 has been found
// B644: unbalanced stack, ignored a potential tail call

//----- (0000B650) --------------------------------------------------------
void __fastcall __noreturn sub_B650(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "util.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B6A8) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B6A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B6B0: positive sp value 1014 has been found
// B6B0: unbalanced stack, ignored a potential tail call

//----- (0000B6BC) --------------------------------------------------------
void __fastcall __noreturn sub_B6BC(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B714) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B714(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B71C: positive sp value 1014 has been found
// B71C: unbalanced stack, ignored a potential tail call

//----- (0000B728) --------------------------------------------------------
void __fastcall __noreturn sub_B728(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B780) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B780(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B788: positive sp value 1014 has been found
// B788: unbalanced stack, ignored a potential tail call

//----- (0000B794) --------------------------------------------------------
void __fastcall __noreturn sub_B794(const char *a1, int a2)
{
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = _errno_location();
  snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "api.c", a1, a2);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B7EC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_B7EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __asm { POP             {R4,R5,PC} }
}
// B7F4: positive sp value 1014 has been found
// B7F4: unbalanced stack, ignored a potential tail call

//----- (0000B800) --------------------------------------------------------
void __fastcall __noreturn sub_B800(int a1)
{
  int *v2; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  v2 = _errno_location();
  snprintf(
    s,
    0x1000u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v2,
    "driver-btm-zcash.c",
    "bitmain_ZCASH_prepare",
    a1);
  sub_385C8(3, s, 1);
  sub_16BE0(1);
}

//----- (0000B870) --------------------------------------------------------
void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int v3; // r0
  int (*v4)(void); // r3
  int (**v5)(); // r12
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r5
  int v11; // r4
  int v12; // r7
  const char **v13; // r8
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  int *v48; // r12
  unsigned int v49; // r3
  int v50; // r2
  unsigned int v51; // r0
  unsigned int v52; // r3
  unsigned int v53; // r2
  unsigned int v54; // r3
  _DWORD *v55; // r2
  int v56; // r3
  int v57; // r2
  _DWORD *v58; // r2
  int v59; // r1
  int v60; // r5
  size_t v61; // r6
  _DWORD *v62; // r0
  _DWORD *v63; // r7
  _DWORD *v64; // r0
  unsigned int v65; // r3
  _DWORD *v66; // r1
  _DWORD *v67; // r5
  unsigned int n; // r6
  _DWORD *v69; // r9
  int v70; // r6
  char *v71; // r8
  unsigned int v72; // r3
  int v73; // r3
  _DWORD *v74; // r3
  unsigned int v75; // r1
  unsigned int v76; // r2
  bool v77; // cc
  int v78; // r2
  int v79; // r3
  int v80; // r5
  char *v81; // r9
  _DWORD *v82; // r0
  const char *v83; // r2
  _DWORD *v84; // r3
  int v85; // r0
  int v86; // r1
  int v87; // r2
  int v88; // r3
  int v89; // r3
  int v90; // r4
  int v91; // r5
  int v92; // r9
  FILE *v93; // r4
  signed int v94; // r0
  char *v95; // r0
  const char *v96; // r1
  char *v97; // r4
  char *v98; // r0
  char *v99; // r4
  char *v100; // r3
  char *v101; // r3
  char *v102; // r3
  size_t v103; // r0
  _BYTE *v104; // r1
  _BYTE *v105; // lr
  char *v106; // r3
  int v107; // r2
  bool v108; // zf
  int v109; // r0
  bool v110; // zf
  int *__attribute__((__org_arrdim(0,2))) v111; // r12
  FILE *v112; // r0
  int v113; // r3
  int v114; // r3
  bool v115; // zf
  int *v116; // r6
  char *v117; // r9
  int v118; // r10
  FILE *v119; // r0
  int v120; // r3
  char *v121; // r6
  int v122; // r10
  char *v123; // r9
  char *v124; // r4
  FILE *v125; // r0
  int v126; // r3
  int *__attribute__((__org_arrdim(0,2))) v127; // r12
  int v128; // r5
  int v129; // r6
  pthread_rwlock_t *v130; // r0
  char *v131; // r7
  int v132; // r5
  char *v133; // r8
  unsigned int v134; // r6
  int v135; // r3
  int v136; // r3
  int *__attribute__((__org_arrdim(0,2))) v137; // r12
  int *__attribute__((__org_arrdim(0,2))) v138; // r12
  int *v139; // r3
  int v140; // r0
  int v141; // t1
  int *__attribute__((__org_arrdim(0,2))) v142; // r12
  int *__attribute__((__org_arrdim(0,2))) v143; // r12
  int v144; // r6
  char *v145; // r7
  int v146; // r9
  int v147; // r3
  const char *v148; // r10
  size_t v149; // r0
  size_t v150; // r4
  char *v151; // r0
  int *__attribute__((__org_arrdim(0,2))) v152; // r12
  int v153; // r2
  int v154; // r7
  __sighandler_t v155; // r8
  __sighandler_t v156; // r0
  bool v157; // zf
  __pid_t v158; // r0
  __pid_t v159; // r8
  int *__attribute__((__org_arrdim(0,2))) v160; // r12
  _DWORD *v161; // r0
  _DWORD *v162; // r7
  void *v163; // r0
  FILE *v164; // r0
  int v165; // r3
  int *__attribute__((__org_arrdim(0,2))) v166; // r12
  int *__attribute__((__org_arrdim(0,2))) v167; // r12
  int v168; // r3
  int v169; // r12
  int v170; // r1
  int v171; // r2
  void *v172; // r6
  int v173; // r6
  int v174; // r9
  int v175; // r8
  int v176; // r7
  _DWORD *v177; // r4
  int v178; // r6
  _DWORD *v179; // r0
  int v180; // r3
  sem_t *v181; // r0
  sem_t *v182; // r6
  char *v183; // r4
  int v184; // r3
  int *v185; // r1
  int v186; // r12
  int v187; // r0
  int j; // r1
  int v189; // lr
  int v190; // r6
  int v191; // r9
  const char *v192; // r1
  int v193; // r6
  int v194; // r12
  int v195; // r2
  int v196; // lr
  int v197; // r2
  int v198; // r3
  int v199; // r1
  int *__attribute__((__org_arrdim(0,2))) v200; // r12
  int *__attribute__((__org_arrdim(0,2))) v201; // r12
  int v202; // r7
  int v203; // r6
  int v204; // r3
  int v205; // r3
  char *v206; // r0
  int v207; // r0
  int v208; // r8
  int v209; // r0
  int v210; // r2
  int *v211; // lr
  int v212; // r0
  int v213; // r3
  int v214; // t1
  int v215; // r9
  int v216; // t1
  int v217; // r3
  int v218; // r9
  int v219; // r3
  int v220; // r3
  int v221; // r0
  int v222; // r1
  int v223; // r12
  int v224; // r0
  struct timeval *v225; // r6
  char *v226; // r9
  _DWORD *v227; // r3
  int *__attribute__((__org_arrdim(0,2))) v228; // r12
  int *__attribute__((__org_arrdim(0,2))) v229; // r12
  int *__attribute__((__org_arrdim(0,2))) v230; // r12
  int *v231; // r3
  int v232; // r1
  int v233; // t1
  int v234; // r9
  int v235; // r2
  int *v236; // lr
  int v237; // r0
  int v238; // r3
  int v239; // t1
  int v240; // r6
  int v241; // t1
  int v242; // r3
  int v243; // r6
  int v244; // r3
  int v245; // r3
  int v246; // r0
  int v247; // r1
  int v248; // r12
  int v249; // r0
  int v250; // r6
  _DWORD *v251; // r8
  char *v252; // r9
  char *v253; // lr
  int v254; // r1
  int v255; // r2
  int v256; // r3
  int v257; // r1
  int v258; // r2
  int v259; // r3
  int v260; // r3
  int *__attribute__((__org_arrdim(0,2))) v261; // r12
  char *v262; // r0
  int *__attribute__((__org_arrdim(0,2))) v263; // r12
  int *__attribute__((__org_arrdim(0,2))) v264; // r12
  int *__attribute__((__org_arrdim(0,2))) v265; // r12
  int *__attribute__((__org_arrdim(0,2))) v266; // r12
  int k; // r6
  int v268; // r3
  int v269; // r8
  char *v270; // r10
  char *v271; // r9
  int m; // r8
  int *__attribute__((__org_arrdim(0,2))) v273; // r12
  const char *v274; // r1
  int v275; // r2
  int *__attribute__((__org_arrdim(0,2))) v276; // r12
  int *__attribute__((__org_arrdim(0,2))) v277; // r12
  char v278; // [sp+10h] [bp-31FCh] BYREF
  char v279[500]; // [sp+1018h] [bp-21F4h] BYREF
  _BYTE v280[3588]; // [sp+120Ch] [bp-2000h] BYREF
  const char *v281; // [sp+2024h] [bp-11E8h]
  int *v282; // [sp+2028h] [bp-11E4h]
  void (**v283)(void); // [sp+202Ch] [bp-11E0h]
  char *v284; // [sp+2030h] [bp-11DCh]
  int *v285; // [sp+2034h] [bp-11D8h]
  char *v286; // [sp+2038h] [bp-11D4h]
  const char **v287; // [sp+203Ch] [bp-11D0h]
  char *v288; // [sp+2040h] [bp-11CCh]
  char *v289; // [sp+2044h] [bp-11C8h]
  int *v290; // [sp+2048h] [bp-11C4h]
  int v291; // [sp+204Ch] [bp-11C0h] BYREF
  struct sigaction v292; // [sp+2054h] [bp-11B8h] BYREF
  char v293[256]; // [sp+20E0h] [bp-112Ch] BYREF
  int v294[11]; // [sp+21E0h] [bp-102Ch] BYREF

  v287 = a2;
  v291 = a1;
  strcpy(dword_75B28, "cgminer.log");
  byte_75B20 = 0;
  strcpy(word_75C28, "a+");
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v4 = sched_yield;
    v5 = &off_72D18;
  }
  v7 = 4 * (v291 + 1);
  if ( v6 )
    *v5 = v4;
  v8 = malloc(v7);
  v9 = v291;
  v10 = v8;
  dword_740C8 = (int)v8;
  if ( v291 > 0 )
  {
    v11 = 0;
    v12 = 0;
    v13 = v287;
    do
    {
      ++v12;
      v14 = _strdup(v13[v11]);
      v9 = v291;
      v10[v11++] = v14;
    }
    while ( v9 > v12 );
  }
  v10[v9] = 0;
  sub_178C8(&stru_781AC, "main", 10680);
  sub_178C8(&stru_78684, "main", 10681);
  sub_178C8(&stru_785D0, "main", 10682);
  sub_17920((int)&stru_78838, "main", 10683);
  sub_178C8(&stru_77B74, "main", 10684);
  sub_178C8(&stru_73EF0, "main", 10685);
  sub_17920((int)&stru_78800, "main", 10686);
  sub_178C8(&mutex, "main", 10687);
  sub_178F4(&stru_740D0, "main", 10688);
  sub_178F4(&stru_78100, "main", 10689);
  sub_178F4(&rwlock, "main", 10690);
  sub_178F4(&stru_78528, "main", 10691);
  sub_178C8(&stru_73EA0, "main", 10693);
  if ( pthread_cond_init(&stru_73EB8, 0) )
  {
    strcpy((char *)v294, "Failed to pthread_cond_init lp_cond");
    sub_385C8(3, (const char *)v294, 1);
    sub_1D26C(1, 0);
  }
  sub_178C8(&stru_78454, "main", 10697);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v294, "Failed to pthread_cond_init restart_cond");
    sub_385C8(3, (const char *)v294, 1);
    sub_1D26C(1, 0);
  }
  if ( pthread_cond_init(&stru_77FC8, 0) )
  {
    strcpy((char *)v294, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2A0C0();
    dword_78448 = (int)v15;
    if ( v15 )
    {
      dword_73E6C = (int)(v15 + 12);
      snprintf(byte_73A2C, 0x100u, "%s %s", "cgminer", a49);
      v292.sa_flags = 0;
      v292.sa_handler = (__sighandler_t)sub_17894;
      sigemptyset(&v292.sa_mask);
      sigaction(15, &v292, &oact);
      sigaction(2, &v292, &stru_78774);
      signal(13, (__sighandler_t)1);
      dword_78A9C = (int)v279;
      strcpy(v279, "/usr/bin");
      dword_786DC = (int)&v278;
      v16 = _strdup(*v287);
      v17 = (char *)dword_786DC;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_786DC + strlen((const char *)dword_786DC)) = 47;
      dword_73E90 = 8;
      dword_73E84 = 9;
      dword_73E8C = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        v288 = (char *)v294;
        strcpy((char *)v294, "main OOM");
        sub_385C8(3, (const char *)v294, 1);
        sub_16BE0(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_740F0;
      v6 = dword_740F0 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_740F0 = (int)v20;
        v161 = malloc(0x2Cu);
        v162 = v161;
        *((_DWORD *)v20 + 17) = v161;
        if ( !v161 )
          goto LABEL_317;
        memset(v161, 0, 0x2Cu);
        v290 = (int *)(v20 + 68);
        v162[4] = v20 + 68;
        v162[1] = 32;
        v162[2] = 5;
        v162[5] = 68;
        v163 = malloc(0x180u);
        *v162 = v163;
        if ( !v163 )
          goto LABEL_317;
        memset(v163, 0, 0x180u);
        v24 = (int)v20;
        v162[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v290 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_22;
        case 0xAu:
          goto LABEL_21;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_21:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_22:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_23:
          v27 += v22[7] << 24;
LABEL_24:
          v27 += v22[6] << 16;
LABEL_25:
          v27 += v22[5] << 8;
LABEL_26:
          v27 += v22[4];
LABEL_27:
          v28 += v22[3] << 24;
LABEL_28:
          v28 += v22[2] << 16;
LABEL_29:
          v28 += v22[1] << 8;
LABEL_30:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = v290;
      v49 = (v45 - v46 - v47) ^ (v47 >> 13);
      v50 = (v46 - v47 - v49) ^ (v49 >> 12);
      v51 = (v47 - v49 - v50) ^ (v50 << 16);
      v52 = (v49 - v50 - v51) ^ (v51 >> 5);
      v53 = v50 - v51 - v52;
      v54 = (v52 - (v53 ^ (v52 >> 3)) - ((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)))
          ^ (((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v54;
      v55 = *(_DWORD **)(v24 + 68);
      v56 = 12 * (v54 & (v55[1] - 1));
      ++*(_DWORD *)(*v55 + v56 + 4);
      v57 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v57;
      v58 = *(_DWORD **)(v24 + 68);
      v59 = *(_DWORD *)(*v58 + v56);
      if ( v59 )
      {
        *(_DWORD *)(v59 + 12) = v290;
        v58 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v58 + v56) = v48;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 8)
                                                                          + 1))
        || (v60 = *((_DWORD *)v20 + 17), *(_DWORD *)(v60 + 36) == 1) )
      {
LABEL_56:
        strcpy(dest, v20);
        dword_78268 = (int)&dword_78268;
        dword_7826C = (int)&dword_78268;
        sub_58F70((int)&off_72440, (int)"Options for both config file and command line");
        sub_58F70((int)&off_72C64, (int)"Options for command line only");
        sub_5903C(&v291, v287, (void (*)(const char *, ...))sub_11B7C);
        if ( v291 != 1 )
        {
          strcpy((char *)v294, "Unexpected extra commandline arguments");
          sub_385C8(3, (const char *)v294, 1);
          sub_1D26C(1, 0);
        }
        v80 = (unsigned __int8)byte_73D58;
        if ( !byte_73D58 )
        {
          dword_73D5C = (int)malloc(0x1000u);
          sub_16088((char *)dword_73D5C);
          if ( access((const char *)dword_73D5C, 4) )
          {
            free((void *)dword_73D5C);
            dword_73D5C = v80;
          }
          else
          {
            sub_16CD0((char *)dword_73D5C);
          }
        }
        if ( byte_74149 || dword_73E34 )
        {
          if ( byte_78681 )
          {
            v288 = (char *)v294;
            strcpy((char *)v294, "Cannot use benchmark mode with scrypt");
            sub_385C8(3, (const char *)v294, 1);
            sub_16BE0(1);
          }
          v288 = (char *)v294;
          v81 = sub_17974();
          v82 = malloc(0xFFu);
          if ( dword_73E34 )
            v83 = "Benchfile";
          else
            v83 = "Benchmark";
          *((_DWORD *)v81 + 49) = v82;
          v84 = v82;
          v85 = *(_DWORD *)v83;
          v86 = *((_DWORD *)v83 + 1);
          v87 = *((_DWORD *)v83 + 2);
          *v84 = v85;
          v84[1] = v86;
          *((_WORD *)v84 + 4) = v87;
          v88 = *((_DWORD *)v81 + 49);
          *((_DWORD *)v81 + 51) = v88;
          *((_DWORD *)v81 + 52) = v88;
          *((_DWORD *)v81 + 50) = v88;
          *((_DWORD *)v81 + 156) = v88;
          strncpy(v81 + 48, "?", 7u);
          v89 = *((_DWORD *)v81 + 33);
          v81[55] = 0;
          if ( v89 != 1 )
          {
            *((_DWORD *)v81 + 33) = 1;
            ++dword_7840C;
          }
          v90 = 0;
          v81[129] = 0;
          byte_75AE8 = 1;
          do
          {
            v91 = 324 * v90;
            v92 = 5 * v90++;
            v92 *= 32;
            sub_29788(&byte_74158[v92], (unsigned __int8 *)&a000000029c6bf4[v91], 160);
            sub_29788(&byte_74B58[v92], (unsigned __int8 *)&a00000002c01f50[v91], 160);
          }
          while ( v90 != 16 );
          sub_1617C((int)dword_7556C);
        }
        else
        {
          v288 = (char *)v294;
        }
        if ( !dword_73A28 )
        {
          v99 = (char *)byte_75A08;
          v286 = &byte_77B70;
          goto LABEL_108;
        }
        v93 = fopen((const char *)dword_73A28, "rb");
        memset(v293, 0, sizeof(v293));
        if ( v93 )
        {
          v94 = fread(v293, 1u, 0x100u, v93);
          if ( v94 > 0 )
          {
            v95 = strchr(v293, 10);
            v96 = v293;
            v97 = v95;
            v6 = v95 == 0;
            v98 = s;
            if ( !v6 )
            {
              memcpy(s, v293, v97 - v293);
              v98 = byte_7568C;
              v96 = v97 + 1;
            }
            strcpy(v98, v96);
            v99 = (char *)byte_75A08;
            v100 = (char *)&byte_75A08[strlen(s) - 1];
            if ( *(v100 - 1148) == 10 )
              *(v100 - 1148) = 0;
            v101 = (char *)&byte_75A08[strlen(s) - 1];
            if ( *(v101 - 1148) == 13 )
              *(v101 - 1148) = 0;
            v102 = (char *)&byte_75A08[strlen(byte_7568C) - 1];
            if ( *(v102 - 892) == 10 )
              *(v102 - 892) = 0;
            v103 = strlen(byte_7568C) - 1;
            v106 = (char *)&byte_75A08[v103];
            v107 = byte_75A08[v103 - 892];
            v108 = v107 == 13;
            if ( v107 == 13 )
            {
              v104 = v280;
              v107 = 31600;
            }
            else
            {
              v105 = v280;
            }
            if ( v108 )
              HIWORD(v107) = 7;
            else
              v103 = 31600;
            if ( v108 )
            {
              *((_DWORD *)v104 + 907) = v107;
              LOBYTE(v107) = 0;
            }
            else
            {
              HIWORD(v103) = 7;
            }
            if ( v108 )
              *(v106 - 892) = v107;
            else
              *((_DWORD *)v105 + 907) = v103;
            goto LABEL_103;
          }
          v286 = &byte_77B70;
          if ( byte_77B70 || (v284 = &byte_75C48, byte_75C48) || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Read miner version file %s error %d", (const char *)dword_73A28, v94);
            goto LABEL_257;
          }
        }
        else
        {
          v286 = &byte_77B70;
          if ( byte_77B70 || (v284 = &byte_75C48, byte_75C48) || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Open miner version file %s error", (const char *)dword_73A28);
LABEL_257:
            v99 = (char *)byte_75A08;
            sub_385C8(3, v288, 0);
LABEL_103:
            if ( *v286 )
            {
LABEL_107:
              snprintf(v288, 0x1000u, "Miner compile time: %s type: %s", s, byte_7568C);
              sub_385C8(3, v288, 0);
              goto LABEL_108;
            }
            v284 = &byte_75C48;
            goto LABEL_105;
          }
        }
        v99 = (char *)byte_75A08;
LABEL_105:
        if ( *v284 || dword_73504 > 2 )
          goto LABEL_107;
LABEL_108:
        if ( dword_73A18 )
        {
          byte_75B20 = 1;
          strcpy(dword_75B28, (const char *)dword_73A18);
          if ( dword_73A24 )
            strcpy(word_75C28, (const char *)dword_73A24);
          if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 2) )
          {
            snprintf(v288, 0x1000u, "Log file path: %s Open flag: %s", dword_75B28, word_75C28);
            sub_385C8(3, v288, 0);
          }
        }
        if ( dword_73A20 )
        {
          memset(v293, 0, sizeof(v293));
          if ( dword_73A1C )
          {
            if ( !*(_BYTE *)dword_73A1C )
            {
              v160 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Log work asic num empty";
              strcpy((char *)v160 + 4, "work asic num empty");
              sub_385C8(3, v288, 1);
              sub_16BE0(1);
            }
            v109 = strtol((const char *)dword_73A1C, 0, 10);
            v110 = v109 == 32;
            if ( v109 != 32 )
              v110 = v109 == 1;
            dword_7578C = v109;
            if ( !v110 && v109 != 64 )
            {
              v111 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy((char *)v111 + 4, "work asic num must be 1, 32, 64");
              sub_385C8(3, v288, 1);
              sub_16BE0(1);
            }
            if ( *v286 || byte_75C48 || dword_73504 > 2 )
            {
              snprintf(
                v288,
                0x1000u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_73A20,
                (const char *)dword_73A1C);
              sub_385C8(3, v288, 0);
            }
          }
          else if ( *v286 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Log work path: %s", (const char *)dword_73A20);
            sub_385C8(3, v288, 0);
          }
          sprintf(v293, "%s.txt", (const char *)dword_73A20);
          v112 = fopen(v293, "a+");
          v113 = (unsigned __int8)*v286;
          dword_75790 = (int)v112;
          if ( v113 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Log work open file %s", v293);
            sub_385C8(3, v288, 0);
          }
          v114 = dword_7578C;
          if ( dword_7578C == 1 )
          {
            sprintf(v293, "%s%02d.txt", (const char *)dword_73A20, 1);
            v164 = fopen(v293, "a+");
            v165 = (unsigned __int8)*v286;
            dword_75794 = (int)v164;
            if ( v165 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 2) )
            {
              snprintf(v288, 0x1000u, "Log work open asic %d file %s", dword_7578C, v293);
              sub_385C8(3, v288, 0);
            }
          }
          else
          {
            v115 = dword_7578C == 32;
            if ( dword_7578C != 32 )
              v115 = dword_7578C == 64;
            if ( v115 && dword_7578C >= 0 )
            {
              v116 = &dword_75790;
              v117 = v288;
              v118 = 0;
              do
              {
                sprintf(v293, "%s%02d_%02d.txt", (const char *)dword_73A20, v114, v118);
                v119 = fopen(v293, "a+");
                v120 = (unsigned __int8)*v286;
                v116[1] = (int)v119;
                ++v116;
                if ( v120 || byte_75C48 || dword_73504 > 2 )
                {
                  snprintf(v117, 0x1000u, "Log work open asic %d file %s", dword_7578C, v293);
                  sub_385C8(3, v117, 0);
                }
                v114 = dword_7578C;
                ++v118;
              }
              while ( dword_7578C >= v118 );
            }
          }
          if ( byte_75898 )
          {
            v121 = &byte_75898;
            v122 = 0;
            v290 = (int *)byte_75A08;
            v123 = v288;
            v124 = v286;
            do
            {
              sprintf(v293, "%s_diff_%02d.txt", (const char *)dword_73A20, v122);
              v125 = fopen(v293, "a+");
              v126 = (unsigned __int8)*v124;
              *((_DWORD *)v121 + 1) = v125;
              v121 += 4;
              if ( v126 || byte_75C48 || dword_73504 > 2 )
              {
                snprintf(v123, 0x1000u, "Log work open diff file %s", v293);
                sub_385C8(3, v123, 0);
              }
              ++v122;
            }
            while ( v122 != 65 );
            v99 = (char *)v290;
          }
        }
        if ( byte_78940 )
        {
          v285 = dword_72430;
          byte_72C1C = 0;
        }
        else
        {
          v285 = dword_72430;
          if ( byte_72C1C )
            sub_27AF8();
        }
        if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
        {
          snprintf(v288, 0x1000u, "Started %s", byte_73A2C);
          sub_385C8(4, v288, 0);
        }
        if ( !dword_73D5C )
        {
LABEL_172:
          *(_WORD *)(dword_78A9C + strlen((const char *)dword_78A9C)) = 47;
          if ( byte_78680 )
            byte_75C48 = 1;
          if ( v285[512] < 0 )
          {
            if ( byte_78681 )
              v136 = 30;
            else
              v136 = 60;
            v285[512] = v136;
          }
          *((_DWORD *)v99 - 26) = 8;
          dword_77F24 = (int)calloc(8u, 0x40u);
          if ( !dword_77F24 )
          {
            v167 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Failed to calloc control_thr";
            strcpy((char *)v167 + 4, "ed to calloc control_thr");
            sub_385C8(3, v288, 1);
            sub_1D26C(1, 0);
          }
          v128 = 0;
          dword_759A4 = 0;
          v281 = (const char *)&unk_78550;
          sub_27C28((int)&unk_78550);
          sub_27C28((int)&unk_77AF0);
          sub_27C28((int)&unk_78600);
          sub_27C28((int)&unk_78270);
          sub_27C28((int)&unk_73908);
          sub_27C28((int)&unk_78AC8);
          sub_27C28((int)&unk_78300);
          sub_27C28((int)&unk_784A0);
          sub_27C28((int)&unk_78870);
          sub_27C28((int)&unk_77B90);
          sub_27C28((int)&unk_78998);
          sub_27C28((int)&unk_77C98);
          sub_27C28((int)&unk_78128);
          sub_27C28((int)&unk_78080);
          sub_27C28((int)&unk_77D98);
          sub_27C28((int)&unk_786E8);
          sub_27C28((int)&unk_77EA0);
          sub_27C28((int)&unk_77E18);
          sub_27C28((int)&unk_78388);
          sub_27C28((int)&unk_781C8);
          sub_27C28((int)&unk_77FF8);
          sub_27C28((int)&unk_78A18);
          sub_27C28((int)&unk_77D18);
          sub_27C28((int)&unk_77C10);
          (*((void (__fastcall **)(_DWORD))v281 + 3))(0);
          off_77AFC(0);
          off_7860C(0);
          off_7827C(0);
          off_73914();
          off_78AD4(0);
          off_7830C(0);
          off_784AC(0);
          off_7887C(0);
          off_77B9C(0);
          ((void (__fastcall *)(_DWORD))off_789A4)(0);
          off_77CA4(0);
          off_78134(0);
          off_7808C(0);
          off_77DA4(0);
          off_786F4(0);
          ((void (__fastcall *)(_DWORD))off_77EAC)(0);
          off_77E24(0);
          off_78394(0);
          off_781D4(0);
          off_78004(0);
          off_78A24(0);
          ((void (__fastcall *)(_DWORD))off_77D24)(0);
          off_77C1C(0);
          v129 = dword_78548;
          dword_78994 = 0;
          if ( dword_78548 > 0 )
          {
            v290 = &dword_78450;
            do
            {
              v130 = *(pthread_rwlock_t **)(dword_78450 + 4 * v128++);
              sub_27E68(v130);
              v129 = dword_78548;
            }
            while ( dword_78548 > v128 );
          }
          if ( !v129 )
          {
            v166 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy((char *)v166 + 4, "devices disabled, cannot mine!");
            sub_385C8(3, v288, 1);
            sub_1D26C(1, 0);
          }
          dword_73E94 = v129;
          if ( !dword_73D38 )
          {
            v290 = &dword_78450;
            sub_1AA68(&stru_78528, "load_temp_cutoffs", 1152);
            v168 = 0;
            v169 = *v290;
            v170 = dword_78548;
            while ( v168 < v170 )
            {
              v171 = *(_DWORD *)(v169 + 4 * v168++);
              if ( !*(_DWORD *)(v171 + 184) )
                *(_DWORD *)(v171 + 184) = 95;
            }
            sub_19B04(&stru_78528, "load_temp_cutoffs", 1158);
            goto LABEL_203;
          }
          v131 = strtok((char *)dword_73D38, ",");
          if ( v131 )
          {
            v132 = 0;
            v290 = &dword_78450;
            v133 = v288;
            do
            {
              if ( v132 >= dword_78548 )
              {
                strcpy(v133, "Too many values passed to set temp cutoff");
                sub_385C8(3, v133, 1);
                sub_16BE0(1);
              }
              v134 = strtol(v131, 0, 10);
              if ( v134 > 0xC8 )
              {
                strcpy(v133, "Invalid value passed to set temp cutoff");
                sub_385C8(3, v133, 1);
                sub_16BE0(1);
              }
              sub_1AA68(&stru_78528, "load_temp_cutoffs", 1145);
              v135 = *(_DWORD *)(dword_78450 + 4 * v132++);
              *(_DWORD *)(v135 + 184) = v134;
              sub_19B04(&stru_78528, "load_temp_cutoffs", 1147);
              v131 = strtok(0, ",");
            }
            while ( v131 );
            if ( v132 != 1 )
              goto LABEL_203;
          }
          else
          {
            v132 = 0;
            v134 = 0;
            v290 = &dword_78450;
          }
          sub_1AA68(&stru_78528, "load_temp_cutoffs", 1164);
          v197 = dword_78548;
          v198 = *v290;
          while ( v132 < v197 )
          {
            v199 = *(_DWORD *)(v198 + 4 * v132++);
            *(_DWORD *)(v199 + 184) = v134;
          }
          sub_19B04(&stru_78528, "load_temp_cutoffs", 1167);
LABEL_203:
          if ( dword_78548 > 0 )
          {
            v139 = (int *)*v290;
            v140 = *v290 + 4 * dword_78548;
            do
            {
              v141 = *v139++;
              *(_DWORD *)(v141 + 312) = 99999999;
            }
            while ( v139 != (int *)v140 );
          }
          if ( !byte_78768 )
          {
            dword_73E84 += dword_73E94;
            dword_73E8C = dword_73E84 + 1;
            sub_19730();
          }
          if ( !dword_77FC0 )
          {
            if ( *v286 || byte_75C48 || dword_73504 > 3 )
            {
              v142 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy((char *)v142 + 4, " to specify at least one pool server.");
              sub_385C8(4, v288, 0);
            }
            if ( !*((_BYTE *)v285 + 2028) || !sub_26C68(0) )
            {
              v143 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Pool setup failed";
              strcpy((char *)v143 + 4, " setup failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
          }
          if ( dword_77FC0 > 0 )
          {
            v144 = 0;
            v145 = v99;
            do
            {
              v146 = *(_DWORD *)(dword_78260 + 4 * v144);
              v147 = *(_DWORD *)(v146 + 200);
              *(_DWORD *)(v146 + 428) = 99999999;
              *(_DWORD *)(v146 + 464) = 99999999;
              if ( !v147 )
              {
                if ( !*(_DWORD *)(v146 + 208) )
                  *(_DWORD *)(v146 + 208) = calloc(1u, 1u);
                v148 = *(const char **)(v146 + 204);
                if ( !v148 )
                {
                  snprintf(
                    v288,
                    0x1000u,
                    "No login credentials supplied for pool %u %s",
                    v144,
                    *(const char **)(v146 + 196));
                  sub_385C8(3, v288, 1);
                  sub_1D26C(1, 0);
                }
                v149 = strlen(*(const char **)(v146 + 204));
                v281 = *(const char **)(v146 + 208);
                v150 = v149 + strlen(v281) + 2;
                v151 = (char *)malloc(v150);
                *(_DWORD *)(v146 + 200) = v151;
                if ( !v151 )
                {
                  v277 = (int *)v288;
                  *(_DWORD *)v288 = *(_DWORD *)"Failed to malloc userpass";
                  strcpy((char *)v277 + 4, "ed to malloc userpass");
                  sub_385C8(3, v288, 1);
                  sub_1D26C(1, 0);
                }
                snprintf(v151, v150, "%s:%s", v148, v281);
              }
              ++v144;
            }
            while ( dword_77FC0 > v144 );
            v99 = v145;
          }
          v153 = (unsigned __int8)*v286;
          dword_73E9C = *(_DWORD *)dword_78260;
          if ( v153 )
            openlog("cgminer", 1, 8);
          v154 = (int)byte_75A08;
          if ( *((_DWORD *)v99 - 24) )
          {
            if ( pipe((int *)v288) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v294[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(*((_DWORD *)v288 + 1)) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v155 = signal(13, (__sighandler_t)1);
            v156 = signal(13, (__sighandler_t)1);
            v157 = (__sighandler_t)((char *)v156 + 1) == 0;
            if ( v156 != (__sighandler_t)-1 )
              v157 = (__sighandler_t)((char *)v155 + 1) == 0;
            if ( v157 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v158 = fork();
            v159 = v158;
            dword_740C4 = v158;
            if ( v158 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v158 )
            {
              if ( dup2(v294[0], 0) >= 0 )
              {
                close(v294[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_759A8, v159);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v294[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          v172 = calloc(dword_78994, 4u);
          if ( v172 )
            v154 = 0;
          dword_78408 = (int)v172;
          if ( !v172 )
          {
            v273 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy((char *)v273 + 4, "ed to calloc mining_thr");
            v274 = v288;
            goto LABEL_491;
          }
          while ( v154 < dword_78994 )
          {
            v173 = dword_78408;
            *(_DWORD *)(v173 + 4 * v154) = calloc(1u, 0x40u);
            v172 = *(void **)(dword_78408 + 4 * v154);
            if ( !v172 )
            {
              snprintf(v288, 0x1000u, "Failed to calloc mining_thr[%d]", v154);
              v274 = v288;
LABEL_491:
              sub_385C8(3, v274, 1);
              sub_1D26C(1, (int)v172);
            }
            ++v154;
          }
          v174 = 0;
          v175 = 0;
          v289 = v99;
          while ( v175 < dword_78548 )
          {
            v176 = 0;
            v177 = *(_DWORD **)(*v290 + 4 * v175);
            v178 = v177[37];
            v179 = malloc(4 * (v178 + 1));
            v177[38] = v179;
            v179[v178] = 0;
            v180 = v177[37];
            v177[24] = 4;
            if ( v180 > 0 )
            {
              do
              {
                v181 = (sem_t *)sub_1AA90(v174);
                v181->__align = v174;
                v182 = v181;
                *(&v181[2].__align + 1) = (int)v177;
                *(&v181->__align + 1) = v176;
                if ( (*(int (**)(void))(v177[1] + 44))() )
                {
                  if ( sub_2EFE4((int)v182, 0, (void *(*)(void *))sub_11D5C, v182) )
                  {
                    snprintf(v288, 0x1000u, "thread %d create failed", v182->__align);
                    sub_385C8(3, v288, 1);
                    sub_1D26C(1, 0);
                  }
                  *(_DWORD *)(v177[38] + 4 * v176) = v182;
                  if ( v177[8] != 1 )
                  {
                    if ( byte_75C49 && (*v286 || byte_75C48 || dword_73504 > 6) )
                    {
                      snprintf(v288, 0x1000u, "Pushing sem post to thread %d", v182->__align);
                      sub_385C8(7, v288, 0);
                    }
                    sub_2F02C(v182 + 1, "cgminer.c", "main", 11085);
                  }
                }
                ++v176;
                ++v174;
              }
              while ( v177[37] > v176 );
            }
            ++v175;
          }
          v183 = v289;
          if ( byte_74149 || (v184 = dword_73E34) != 0 )
          {
LABEL_304:
            v185 = (int *)dbl_73F18;
            dbl_77AE8 = 0.0;
            do
            {
              *(_QWORD *)v185 = 0;
              v185 += 2;
            }
            while ( v185 != &dword_73F78 );
            v186 = dword_78548;
            dword_73F78 = 0;
            v187 = *v290;
            for ( j = 0; j < v186; ++j )
            {
              v189 = *(_DWORD *)(v187 + 4 * j);
              *(_QWORD *)(v189 + 80) = 0;
              *(_QWORD *)(v189 + 48) = 0;
            }
            sub_2A7A4((struct timeval *)&dword_73F08);
            sub_2A7A4((struct timeval *)&dword_73F80);
            sub_2A7A4((struct timeval *)dword_73F10);
            sub_1519C(byte_74098, 0x28u, &dword_73F08);
            v190 = dword_77F24;
            dword_73EE8 = 2;
            if ( sub_2EFE4(dword_77F24 + 128, 0, (void *(*)(void *))sub_21798, 0) )
            {
              v265 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"watchpool thread create failed";
              strcpy((char *)v265 + 4, "hpool thread create failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
            pthread_detach(*(_DWORD *)(v190 + 140));
            dword_73EEC = 3;
            v281 = (const char *)dword_77F24;
            if ( sub_2EFE4(dword_77F24 + 192, 0, (void *(*)(void *))sub_2328C, 0) )
            {
              v200 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"watchdog thread create failed";
              strcpy((char *)v200 + 4, "hdog thread create failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
            pthread_detach(*((_DWORD *)v281 + 51));
            dword_73D30 = 5;
            if ( sub_2EFE4(dword_77F24 + 320, 0, (void *(*)(void *))sub_1209C, (void *)(dword_77F24 + 320)) )
            {
              v264 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"API thread create failed";
              strcpy((char *)v264 + 4, "thread create failed");
              v192 = v288;
LABEL_316:
              sub_385C8(3, v192, 1);
              sub_1D26C(1, 0);
            }
            v191 = dword_77F24;
            *((_DWORD *)v183 - 23) = 7;
            if ( sub_2EFE4(v191 + 448, 0, (void *(*)(void *))sub_279F0, (void *)(v191 + 448)) )
            {
              v263 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"input thread create failed";
              strcpy((char *)v263 + 4, "t thread create failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
            pthread_detach(*(_DWORD *)(v191 + 460));
            if ( dword_759A0 != 8 )
            {
              snprintf(v288, 0x1000u, "incorrect total_control_threads (%d) should be 8", dword_759A0);
              v192 = v288;
              goto LABEL_316;
            }
            if ( nice(-10) )
            {
              v284 = &byte_75C48;
              v282 = &dword_73504;
              v287 = (const char **)&byte_75C49;
            }
            else
            {
              v287 = (const char **)&byte_75C49;
              if ( byte_75C49 )
              {
                if ( *v286 )
                {
                  v284 = &byte_75C48;
                  v282 = &dword_73504;
                }
                else
                {
                  v284 = &byte_75C48;
                  if ( byte_75C48 )
                  {
                    v282 = &dword_73504;
                  }
                  else
                  {
                    v282 = &dword_73504;
                    if ( dword_73504 <= 6 )
                      goto LABEL_338;
                  }
                }
                v201 = (int *)v288;
                *(_DWORD *)v288 = *(_DWORD *)"Unable to set thread to high priority";
                strcpy((char *)v201 + 4, "le to set thread to high priority");
                sub_385C8(7, v288, 0);
              }
              else
              {
                v284 = &byte_75C48;
                v282 = &dword_73504;
              }
            }
LABEL_338:
            v289 = 0;
            v283 = (void (**)(void))&off_72D18;
            while ( 1 )
            {
              while ( 1 )
              {
                v202 = v285[505];
                if ( byte_786D4 )
                {
                  if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                  {
                    v230 = (int *)v288;
                    *(_DWORD *)v288 = *(_DWORD *)"Work update message received";
                    strcpy((char *)v230 + 4, " update message received");
                    sub_385C8(7, v288, 0);
                  }
                  sub_2A7A4(&stru_73D44);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B5E4("signal_work_update", 5314);
                  if ( dword_78994 > 0 )
                  {
                    v231 = (int *)dword_78408;
                    v232 = dword_78408 + 4 * dword_78994;
                    do
                    {
                      v233 = *v231++;
                      *(_BYTE *)(v233 + 63) = 1;
                    }
                    while ( v231 != (int *)v232 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B578("signal_work_update", 5317);
                  (*v283)();
                }
                byte_786D4 = 0;
                sub_1D9A0();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
                  sub_B35C("main", 11222);
                v203 = dword_73E74;
                if ( dword_73E74 )
                  v203 = *(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 12);
                if ( v202 < v203 )
                {
                  if ( byte_73E79 )
                  {
                    v204 = v285[505];
                    if ( v204 < v285[506] )
                    {
                      dword_72C14 = v204 + 1;
                      byte_73E79 = 0;
                    }
                  }
                  byte_73E78 = 1;
                  pthread_cond_wait(&stru_77FC8, (pthread_mutex_t *)dword_73E6C);
                  v203 = dword_73E74;
                  if ( dword_73E74 )
                    v203 = *(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
                  sub_B50C("main", 11240);
                (*v283)();
                if ( v203 <= v202 )
                  break;
                if ( byte_73E79 )
                {
                  v205 = v285[505];
                  if ( v205 < v285[506] )
                  {
                    dword_72C14 = v205 + 1;
                    byte_73E79 = 0;
                  }
                }
                byte_73E78 = 1;
                v206 = (char *)sub_18D24(0);
                v289 = v206;
                if ( v206 )
                {
                  sub_158EC((int)v206);
                  v289 = 0;
                }
              }
              if ( v289 )
                sub_158EC((int)v289);
              v289 = (char *)sub_1A520();
              v207 = sub_1D9A0();
              v208 = v207;
              if ( dword_73D34 == 4 )
              {
                v208 = sub_12188(v207);
              }
              else if ( dword_73D34 == 3 )
              {
                v235 = dword_77FC0;
                if ( dword_77FC0 <= 0 )
                  goto LABEL_440;
                if ( *(_DWORD *)(*(_DWORD *)dword_78260 + 60) <= *(_DWORD *)(*(_DWORD *)dword_78260 + 64) )
                {
                  v236 = (int *)dword_78260;
                  v237 = dword_78260;
                  v238 = 0;
                  while ( ++v238 != dword_77FC0 )
                  {
                    v239 = *(_DWORD *)(v237 + 4);
                    v237 += 4;
                    if ( *(_DWORD *)(v239 + 64) < *(_DWORD *)(v239 + 60) )
                      goto LABEL_442;
                  }
                  v240 = dword_78260 + 4 * dword_77FC0;
                  do
                  {
                    v241 = *v236++;
                    *(_DWORD *)(v241 + 64) = 0;
                  }
                  while ( v236 != (int *)v240 );
LABEL_440:
                  v242 = *((_DWORD *)v183 - 22) + 1;
                  *((_DWORD *)v183 - 22) = v242;
                  if ( v242 >= v235 )
                    dword_759B0 = 0;
                }
LABEL_442:
                v243 = 0;
                while ( 1 )
                {
                  v77 = v243++ < v235;
                  if ( !v77 )
                    break;
                  v245 = *((_DWORD *)v183 - 22);
                  v246 = *(_DWORD *)(dword_78260 + 4 * v245);
                  v247 = *(_DWORD *)(v246 + 64);
                  v248 = *(_DWORD *)(v246 + 60);
                  *(_DWORD *)(v246 + 64) = v247 + 1;
                  if ( v247 < v248 )
                  {
                    if ( !*(_BYTE *)(v246 + 129)
                      && *(_DWORD *)(v246 + 132) == 1
                      && (!*(_BYTE *)(v246 + 664) || *(_BYTE *)(v246 + 665)) )
                    {
                      goto LABEL_454;
                    }
                    if ( byte_7844D )
                    {
                      v249 = sub_11F70(0);
                      v245 = *((_DWORD *)v183 - 22);
                      v235 = dword_77FC0;
                      --*(_DWORD *)(v249 + 64);
                    }
                  }
                  v244 = v245 + 1;
                  *((_DWORD *)v183 - 22) = v244;
                  if ( v244 >= v235 )
                    dword_759B0 = 0;
                }
                if ( v235 > 0 )
                {
                  v250 = 0;
                  while ( 1 )
                  {
                    v246 = sub_11F70(v250);
                    if ( !*(_BYTE *)(v246 + 129) && *(_DWORD *)(v246 + 132) == 1 )
                      break;
                    if ( ++v250 >= dword_77FC0 )
                      goto LABEL_360;
                  }
LABEL_454:
                  v208 = v246;
                }
              }
LABEL_360:
              if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
              {
                snprintf(v288, 0x1000u, "Selecting pool %d for work", *(_DWORD *)v208);
                sub_385C8(7, v288, 0);
              }
              if ( *(_BYTE *)(v208 + 664) )
              {
                while ( !*(_BYTE *)(v208 + 665) || !*(_BYTE *)(v208 + 667) )
                {
                  v209 = sub_1D9A0();
                  v290 = (int *)v209;
                  if ( dword_73D34 == 4 )
                  {
                    v290 = (int *)sub_12188(v209);
                  }
                  else if ( dword_73D34 == 3 || !byte_7844D )
                  {
                    v210 = dword_77FC0;
                    if ( dword_77FC0 <= 0 )
                      goto LABEL_379;
                    if ( *(_DWORD *)(*(_DWORD *)dword_78260 + 60) <= *(_DWORD *)(*(_DWORD *)dword_78260 + 64) )
                    {
                      v211 = (int *)dword_78260;
                      v212 = dword_78260;
                      v213 = 0;
                      while ( ++v213 != dword_77FC0 )
                      {
                        v214 = *(_DWORD *)(v212 + 4);
                        v212 += 4;
                        if ( *(_DWORD *)(v214 + 64) < *(_DWORD *)(v214 + 60) )
                          goto LABEL_381;
                      }
                      v215 = dword_78260 + 4 * dword_77FC0;
                      do
                      {
                        v216 = *v211++;
                        *(_DWORD *)(v216 + 64) = 0;
                      }
                      while ( v211 != (int *)v215 );
LABEL_379:
                      v217 = *((_DWORD *)v183 - 22) + 1;
                      *((_DWORD *)v183 - 22) = v217;
                      if ( v217 >= v210 )
                        dword_759B0 = 0;
                    }
LABEL_381:
                    v218 = 0;
                    while ( 1 )
                    {
                      v77 = v218++ < v210;
                      if ( !v77 )
                        break;
                      v220 = *((_DWORD *)v183 - 22);
                      v221 = *(_DWORD *)(dword_78260 + 4 * v220);
                      v222 = *(_DWORD *)(v221 + 64);
                      v223 = *(_DWORD *)(v221 + 60);
                      *(_DWORD *)(v221 + 64) = v222 + 1;
                      if ( v222 < v223 )
                      {
                        if ( !*(_BYTE *)(v221 + 129)
                          && *(_DWORD *)(v221 + 132) == 1
                          && (!*(_BYTE *)(v221 + 664) || *(_BYTE *)(v221 + 665)) )
                        {
                          goto LABEL_393;
                        }
                        if ( byte_7844D )
                        {
                          v224 = sub_11F70(0);
                          v220 = *((_DWORD *)v183 - 22);
                          v210 = dword_77FC0;
                          --*(_DWORD *)(v224 + 64);
                        }
                      }
                      v219 = v220 + 1;
                      *((_DWORD *)v183 - 22) = v219;
                      if ( v219 >= v210 )
                        dword_759B0 = 0;
                    }
                    if ( v210 > 0 )
                    {
                      v234 = 0;
                      while ( 1 )
                      {
                        v221 = sub_11F70(v234);
                        if ( !*(_BYTE *)(v221 + 129) && *(_DWORD *)(v221 + 132) == 1 )
                          break;
                        if ( ++v234 >= dword_77FC0 )
                          goto LABEL_394;
                      }
LABEL_393:
                      v290 = (int *)v221;
                    }
                  }
LABEL_394:
                  if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                  {
                    snprintf(v288, 0x1000u, "Selecting pool %d for work", *v290);
                    sub_385C8(7, v288, 0);
                  }
                  sub_2A884();
                  if ( (int *)v208 != v290 )
                  {
                    v208 = (int)v290;
                    if ( !*((_BYTE *)v290 + 664) )
                      goto LABEL_401;
                  }
                }
                sub_1D5F0(v208, (int)v289);
                if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                {
                  v229 = (int *)v288;
                  *(_DWORD *)v288 = *(_DWORD *)"Generated stratum work";
                  strcpy((char *)v229 + 4, "rated stratum work");
                  sub_385C8(7, v288, 0);
                }
LABEL_468:
                v262 = v289;
                v289 = 0;
                sub_1F0C4((int)v262);
              }
              else
              {
LABEL_401:
                if ( dword_73E34 )
                {
                  v225 = (struct timeval *)(v289 + 1888);
                  v226 = v289;
                  sub_1718C(v289);
                  v227 = (_DWORD *)dword_78260;
                  v226[1770] = 1;
                  *((_DWORD *)v226 + 437) = *v227;
                  sub_2A7A4(v225);
                  sub_2A488(&v225[1].tv_sec, v225);
                  v226[1928] = 66;
                  sub_11994((int)v289);
                  if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                  {
                    v228 = (int *)v288;
                    *(_DWORD *)v288 = *(_DWORD *)"Generated benchfile work";
                    strcpy((char *)v228 + 4, "rated benchfile work");
                    sub_385C8(7, v288, 0);
                  }
                  goto LABEL_468;
                }
                if ( byte_74149 )
                {
                  v251 = (_DWORD *)dword_78260;
                  v252 = v289;
                  v253 = v289 + 160;
                  *((_QWORD *)v289 + 233) = 0x4040000000000000LL;
                  v254 = dword_7556C[1];
                  v255 = dword_7556C[2];
                  v256 = dword_7556C[3];
                  *((_DWORD *)v252 + 40) = dword_7556C[0];
                  *((_DWORD *)v253 + 1) = v254;
                  *((_DWORD *)v253 + 2) = v255;
                  *((_DWORD *)v253 + 3) = v256;
                  v257 = unk_75580;
                  v258 = unk_75584;
                  v259 = unk_75588;
                  *((_DWORD *)v253 + 4) = unk_7557C;
                  *((_DWORD *)v253 + 5) = v257;
                  *((_DWORD *)v253 + 6) = v258;
                  *((_DWORD *)v253 + 7) = v259;
                  *((_DWORD *)v252 + 433) = 0;
                  v252[1770] = 1;
                  *((_DWORD *)v252 + 437) = *v251;
                  sub_2A7A4((struct timeval *)v252 + 236);
                  sub_2A488((_DWORD *)v252 + 474, (_DWORD *)v252 + 472);
                  v260 = *(unsigned __int8 *)v287;
                  v289[1928] = 66;
                  if ( v260 && (*v286 || *v284 || *v282 > 6) )
                  {
                    v261 = (int *)v288;
                    *(_DWORD *)v288 = *(_DWORD *)"Generated benchmark work";
                    strcpy((char *)v261 + 4, "rated benchmark work");
                    sub_385C8(7, v288, 0);
                  }
                  goto LABEL_468;
                }
              }
            }
          }
          v193 = dword_78260;
          v194 = dword_77FC0;
          while ( v184 < v194 )
          {
            v195 = *(_DWORD *)(v193 + 4 * v184++);
            v196 = *(_DWORD *)(v195 + 132);
            *(_BYTE *)(v195 + 129) = 1;
            if ( v196 != 1 )
            {
              *(_DWORD *)(v195 + 132) = 1;
              ++dword_7840C;
            }
          }
          v287 = (const char **)&byte_75C49;
          if ( byte_75C49 )
          {
            if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 6) )
            {
              v266 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Probing for an alive pool";
              strcpy((char *)v266 + 4, "ing for an alive pool");
              sub_385C8(7, v288, 0);
            }
          }
          for ( k = 0; k < dword_77FC0; ++k )
          {
            v268 = *(_DWORD *)(dword_78260 + 4 * k);
            *(_BYTE *)(v268 + 316) = 1;
            pthread_create((pthread_t *)(v268 + 312), 0, (void *(*)(void *))start_routine, (void *)v268);
          }
          v269 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_74148 )
              break;
            if ( !--v269 )
              goto LABEL_496;
          }
          v269 = 0;
LABEL_496:
          v270 = v288;
          v271 = v286;
          while ( 1 )
          {
            if ( byte_74148 )
              goto LABEL_304;
            if ( !v269 )
            {
              if ( ((*v271 || byte_75C48 || dword_73504 > 2)
                 && ((strcpy(v270, "No servers were found that could be used to get work from."),
                      sub_385C8(3, v270, 0),
                      *v271)
                  || byte_75C48)
                 || dword_73504 > 2)
                && ((strcpy(v270, "Please check the details from the list below of the servers you have input"),
                     sub_385C8(3, v270, 0),
                     *v271)
                 || byte_75C48)
                || dword_73504 > 2 )
              {
                strcpy(
                  v270,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_385C8(3, v270, 0);
              }
              for ( m = 0; m < dword_77FC0; ++m )
              {
                if ( *v271 || byte_75C48 || dword_73504 > 3 )
                {
                  snprintf(
                    v270,
                    0x1000u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    m,
                    *(const char **)(*(_DWORD *)(dword_78260 + 4 * m) + 196),
                    *(const char **)(*(_DWORD *)(dword_78260 + 4 * m) + 204),
                    *(const char **)(*(_DWORD *)(dword_78260 + 4 * m) + 208));
                  sub_385C8(4, v270, 0);
                }
              }
              if ( !*((_BYTE *)v285 + 2028) )
              {
LABEL_530:
                v276 = (int *)v288;
                *(_DWORD *)v288 = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy((char *)v276 + 4, "ervers could be used! Exiting.");
                sub_385C8(3, v288, 1);
                sub_1D26C(0, 0);
              }
              if ( !*v271 && !byte_75C48 && dword_73504 <= 2 )
              {
                v269 = 1;
                goto LABEL_524;
              }
              v269 = 1;
              strcpy(v270, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_385C8(3, v270, 0);
            }
            if ( !*((_BYTE *)v285 + 2028) )
              goto LABEL_530;
LABEL_524:
            if ( dword_78258 )
              v275 = *(__int16 *)(dword_78258 + 4);
            else
              v275 = -1;
            v281 = (const char *)&dword_78258;
            if ( dword_78258 )
              ++v275;
            wtouchln((WINDOW *)dword_78258, 0, v275, 1);
            wrefresh(*(WINDOW **)v281);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_530;
            cbreak();
          }
        }
        v287 = (const char **)&byte_75C49;
        if ( byte_75C49 && (*v286 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(v288, 0x1000u, "Loaded configuration file %s", (const char *)dword_73D5C);
          sub_385C8(7, v288, 0);
        }
        if ( dword_73E2C == -1 )
        {
          if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
          {
            v137 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy((char *)v137 + 4, "r in configuration file, partially loaded.");
            sub_385C8(4, v288, 0);
          }
          if ( *((_BYTE *)v285 + 2028) )
          {
            if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
            {
              v138 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
              strcpy((char *)v138 + 4, "t cgminer with -T to see what failed to load.");
              sub_385C8(4, v288, 0);
            }
          }
          goto LABEL_171;
        }
        if ( !dword_73E2C )
        {
          if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
          {
            v152 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy((char *)v152 + 4, "l JSON error in configuration file.");
            sub_385C8(4, v288, 0);
            if ( *v286 || byte_75C48 )
              goto LABEL_170;
            v282 = &dword_73504;
          }
          if ( *v282 > 3 )
          {
LABEL_170:
            v127 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Configuration file could not be used.";
            strcpy((char *)v127 + 4, "iguration file could not be used.");
            sub_385C8(4, v288, 0);
          }
        }
LABEL_171:
        free((void *)dword_73D5C);
        dword_73D5C = 0;
        goto LABEL_172;
      }
      v61 = 24 * *(_DWORD *)(v60 + 4);
      v62 = malloc(v61);
      v63 = v62;
      if ( v62 )
      {
        memset(v62, 0, v61);
        *(_DWORD *)(v60 + 24) = (((2 * *(_DWORD *)(v60 + 4) - 1) & *(_DWORD *)(v60 + 12)) != 0)
                              + (*(_DWORD *)(v60 + 12) >> (*(_BYTE *)(v60 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v64 = (_DWORD *)*((_DWORD *)v20 + 17);
        v65 = v64[1];
        v66 = v64;
        if ( v65 )
        {
          v290 = 0;
          v289 = 0;
          do
          {
            v67 = *(_DWORD **)((char *)v290 + *v64);
            if ( v67 )
            {
              for ( n = v65; ; n = v66[1] )
              {
                v69 = (_DWORD *)v67[4];
                v70 = 3 * ((2 * n - 1) & v67[7]);
                v71 = (char *)&v63[v70];
                v72 = *((_DWORD *)v71 + 1) + 1;
                *((_DWORD *)v71 + 1) = v72;
                if ( v72 > v66[6] )
                {
                  ++v66[7];
                  *((_DWORD *)v71 + 2) = *((_DWORD *)v71 + 1) / *(_DWORD *)(*((_DWORD *)v20 + 17) + 24);
                }
                v67[3] = 0;
                v67[4] = v63[v70];
                v73 = v63[v70];
                if ( v73 )
                  *(_DWORD *)(v73 + 12) = v67;
                v63[v70] = v67;
                if ( !v69 )
                  break;
                v66 = (_DWORD *)*((_DWORD *)v20 + 17);
                v67 = v69;
              }
              v64 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v64[1];
            ++v289;
            v66 = v64;
            v290 += 3;
          }
          while ( v65 > (unsigned int)v289 );
        }
        free((void *)*v64);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v63;
        v74 = (_DWORD *)*((_DWORD *)v20 + 17);
        v75 = v74[3];
        v76 = v74[7];
        v77 = v76 > v75 >> 1;
        if ( v76 <= v75 >> 1 )
          v78 = 0;
        else
          v78 = v74[8];
        if ( v77 )
          ++v78;
        v74[8] = v78;
        v79 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v79 + 32) > 1u )
          *(_DWORD *)(v79 + 36) = 1;
        goto LABEL_56;
      }
LABEL_317:
      exit(-1);
    }
    strcpy((char *)v294, "Failed to create getq");
  }
  sub_385C8(3, (const char *)v294, 1);
  sub_1D26C(1, 0);
}
// BDBC: control flows out of bounds to BDC0
// B918: variable 'v4' is possibly undefined
// B918: variable 'v5' is possibly undefined
// C56C: variable 'v104' is possibly undefined
// C574: variable 'v105' is possibly undefined
// 72430: using guessed type int dword_72430[];
// 72440: using guessed type char *off_72440;
// 72C14: using guessed type int dword_72C14;
// 72C1C: using guessed type char byte_72C1C;
// 72C64: using guessed type char *off_72C64;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73914: using guessed type void (*off_73914)();
// 739F8: using guessed type int stdscr;
// 73A08: using guessed type int stderr;
// 73A18: using guessed type int dword_73A18;
// 73A1C: using guessed type int dword_73A1C;
// 73A20: using guessed type int dword_73A20;
// 73A24: using guessed type int dword_73A24;
// 73A28: using guessed type int dword_73A28;
// 73D30: using guessed type int dword_73D30;
// 73D34: using guessed type int dword_73D34;
// 73D38: using guessed type int dword_73D38;
// 73D44: using guessed type struct timeval stru_73D44;
// 73D58: using guessed type char byte_73D58;
// 73D5C: using guessed type int dword_73D5C;
// 73E2C: using guessed type int dword_73E2C;
// 73E34: using guessed type int dword_73E34;
// 73E6C: using guessed type int dword_73E6C;
// 73E74: using guessed type int dword_73E74;
// 73E78: using guessed type char byte_73E78;
// 73E79: using guessed type char byte_73E79;
// 73E84: using guessed type int dword_73E84;
// 73E8C: using guessed type int dword_73E8C;
// 73E90: using guessed type int dword_73E90;
// 73E94: using guessed type int dword_73E94;
// 73E9C: using guessed type int dword_73E9C;
// 73EE8: using guessed type int dword_73EE8;
// 73EEC: using guessed type int dword_73EEC;
// 73F08: using guessed type int dword_73F08;
// 73F10: using guessed type _DWORD dword_73F10[2];
// 73F18: using guessed type double dbl_73F18[12];
// 73F78: using guessed type int dword_73F78;
// 73F80: using guessed type int dword_73F80;
// 740C4: using guessed type int dword_740C4;
// 740C8: using guessed type int dword_740C8;
// 740F0: using guessed type int dword_740F0;
// 74148: using guessed type char byte_74148;
// 74149: using guessed type char byte_74149;
// 74158: using guessed type _BYTE byte_74158[2560];
// 74B58: using guessed type _BYTE byte_74B58[2560];
// 7556C: using guessed type _DWORD dword_7556C[4];
// 7578C: using guessed type int dword_7578C;
// 75790: using guessed type int dword_75790;
// 75794: using guessed type int dword_75794;
// 75898: using guessed type char byte_75898;
// 759A0: using guessed type int dword_759A0;
// 759A4: using guessed type int dword_759A4;
// 759A8: using guessed type int dword_759A8;
// 759B0: using guessed type int dword_759B0;
// 75A08: using guessed type unsigned __int8 byte_75A08[204];
// 75AE8: using guessed type char byte_75AE8;
// 75B20: using guessed type char byte_75B20;
// 75C2A: using guessed type char byte_75C2A;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77AE8: using guessed type double dbl_77AE8;
// 77AFC: using guessed type int (__fastcall *off_77AFC)(_DWORD);
// 77B70: using guessed type char byte_77B70;
// 77B9C: using guessed type int (__fastcall *off_77B9C)(_DWORD);
// 77C1C: using guessed type int (__fastcall *off_77C1C)(_DWORD);
// 77CA4: using guessed type int (__fastcall *off_77CA4)(_DWORD);
// 77D24: using guessed type _UNKNOWN *off_77D24;
// 77DA4: using guessed type int (__fastcall *off_77DA4)(_DWORD);
// 77E24: using guessed type int (__fastcall *off_77E24)(_DWORD);
// 77EAC: using guessed type _UNKNOWN *off_77EAC;
// 77F24: using guessed type int dword_77F24;
// 77FC0: using guessed type int dword_77FC0;
// 78004: using guessed type int (__fastcall *off_78004)(_DWORD);
// 7808C: using guessed type int (__fastcall *off_7808C)(_DWORD);
// 78100: using guessed type pthread_rwlock_t stru_78100;
// 78134: using guessed type int (__fastcall *off_78134)(_DWORD);
// 781D4: using guessed type int (__fastcall *off_781D4)(_DWORD);
// 78258: using guessed type int dword_78258;
// 78260: using guessed type int dword_78260;
// 78268: using guessed type int dword_78268;
// 7826C: using guessed type int dword_7826C;
// 7827C: using guessed type int (__fastcall *off_7827C)(_DWORD);
// 7830C: using guessed type int (__fastcall *off_7830C)(_DWORD);
// 78394: using guessed type int (__fastcall *off_78394)(_DWORD);
// 78408: using guessed type int dword_78408;
// 7840C: using guessed type int dword_7840C;
// 78448: using guessed type int dword_78448;
// 7844D: using guessed type char byte_7844D;
// 78450: using guessed type int dword_78450;
// 784AC: using guessed type int (__fastcall *off_784AC)(_DWORD);
// 78548: using guessed type int dword_78548;
// 7860C: using guessed type int (__fastcall *off_7860C)(_DWORD);
// 78680: using guessed type char byte_78680;
// 78681: using guessed type char byte_78681;
// 78684: using guessed type pthread_mutex_t stru_78684;
// 786D4: using guessed type char byte_786D4;
// 786DC: using guessed type int dword_786DC;
// 786F4: using guessed type int (__fastcall *off_786F4)(_DWORD);
// 78768: using guessed type char byte_78768;
// 7887C: using guessed type int (__fastcall *off_7887C)(_DWORD);
// 78940: using guessed type char byte_78940;
// 78994: using guessed type int dword_78994;
// 789A4: using guessed type _UNKNOWN *off_789A4;
// 78A24: using guessed type int (__fastcall *off_78A24)(_DWORD);
// 78A9C: using guessed type int dword_78A9C;
// 78AD4: using guessed type int (__fastcall *off_78AD4)(_DWORD);

//----- (0000F540) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())nullsub_11,
    a1,
    va);
  abort();
}
// F54C: positive sp value 4 has been found
// F568: variable 'v4' is possibly undefined
// 5A95C: using guessed type int nullsub_11();

//----- (0000F57C) --------------------------------------------------------
int sub_F57C()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// AAF8: using guessed type int _gmon_start__(void);

//----- (0000F5A0) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &stdscr;
}
// 739F8: using guessed type int stdscr;

//----- (0000F5D8) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &stdscr;
  HIDWORD(result) = 0;
  return result;
}
// 739F8: using guessed type int stdscr;

//----- (0000F618) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !byte_73A0C )
  {
    result = deregister_tm_clones();
    byte_73A0C = 1;
  }
  return result;
}
// 73A0C: using guessed type char byte_73A0C;

//----- (0000F640) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (0000F678) --------------------------------------------------------
int __fastcall sub_F678(_DWORD *a1)
{
  *a1 = 4;
  return 0;
}

//----- (0000F688) --------------------------------------------------------
int __fastcall sub_F688(_DWORD *a1)
{
  *a1 = 3;
  return 0;
}

//----- (0000F698) --------------------------------------------------------
int __fastcall sub_F698(_DWORD *a1)
{
  *a1 = 1;
  return 0;
}

//----- (0000F6A8) --------------------------------------------------------
int __fastcall sub_F6A8(_BYTE *a1)
{
  *a1 = 1;
  byte_75C48 = 1;
  return 0;
}
// 75C48: using guessed type char byte_75C48;

//----- (0000F6C4) --------------------------------------------------------
int sub_F6C4()
{
  return 0;
}

//----- (0000F6D8) --------------------------------------------------------
int sub_F6D8()
{
  return 1;
}

//----- (0000F6E0) --------------------------------------------------------
int sub_F6E0()
{
  return 1;
}

//----- (0000F6E8) --------------------------------------------------------
__int64 sub_F6E8()
{
  return 0xFFFFFFFFLL;
}

//----- (0000F6F4) --------------------------------------------------------
int sub_F6F4()
{
  return 1;
}

//----- (0000F6FC) --------------------------------------------------------
int sub_F6FC()
{
  return 1;
}

//----- (0000F714) --------------------------------------------------------
int sub_F714()
{
  return 0;
}

//----- (0000F720) --------------------------------------------------------
int __fastcall sub_F720(int a1, int a2)
{
  _DWORD *v2; // r3
  int result; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = *(_DWORD **)(a1 + 36);
  if ( v2[59] == a2 )
  {
    result = (unsigned __int8)byte_75C49;
    if ( byte_75C49 )
    {
      if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 6 )
      {
        snprintf(s, 0x1000u, "%s %d duplicate share detected as HW error", *(const char **)(v2[1] + 8), v2[2]);
        sub_385C8(7, s, 0);
        return 0;
      }
    }
  }
  else
  {
    v2[59] = a2;
    return 1;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0000F7DC) --------------------------------------------------------
_BYTE *__fastcall sub_F7DC(const char *a1)
{
  size_t v2; // r0
  _BYTE *v3; // r4
  _DWORD *v4; // r0
  int v5; // r3
  int v6; // r1
  const char *v7; // r1
  _BYTE *v8; // r2
  bool v9; // zf
  char v10; // t1

  v2 = strlen(a1);
  v3 = malloc(2 * v2 + 1);
  v4 = malloc(8u);
  v5 = *(unsigned __int8 *)a1;
  v6 = dword_73A10;
  *v4 = v3;
  dword_73A10 = (int)v4;
  v4[1] = v6;
  if ( v5 )
  {
    v7 = a1 - 1;
    v8 = v3;
    do
    {
      v9 = v5 == 92;
      if ( v5 != 92 )
        v9 = v5 == 34;
      if ( v9 )
        *v8++ = 92;
      v10 = *++v7;
      *v8++ = v10;
      v5 = *((unsigned __int8 *)v7 + 1);
    }
    while ( v7[1] );
  }
  else
  {
    v8 = v3;
  }
  *v8 = 0;
  return v3;
}
// 73A10: using guessed type int dword_73A10;

//----- (0000F868) --------------------------------------------------------
int __fastcall sub_F868(int a1)
{
  sub_5858C(a1, &dword_73A14);
  return 0;
}
// 73A14: using guessed type int dword_73A14;

//----- (0000F880) --------------------------------------------------------
int __fastcall sub_F880(int a1)
{
  sub_5858C(a1, &dword_73A18);
  return 0;
}
// 73A18: using guessed type int dword_73A18;

//----- (0000F898) --------------------------------------------------------
int __fastcall sub_F898(int a1)
{
  sub_5858C(a1, &dword_73A1C);
  return 0;
}
// 73A1C: using guessed type int dword_73A1C;

//----- (0000F8B0) --------------------------------------------------------
int __fastcall sub_F8B0(int a1)
{
  sub_5858C(a1, &dword_73A20);
  return 0;
}
// 73A20: using guessed type int dword_73A20;

//----- (0000F8C8) --------------------------------------------------------
int __fastcall sub_F8C8(int a1)
{
  sub_5858C(a1, &dword_73A24);
  return 0;
}
// 73A24: using guessed type int dword_73A24;

//----- (0000F8E0) --------------------------------------------------------
int __fastcall sub_F8E0(int a1)
{
  sub_5858C(a1, &dword_73A28);
  return 0;
}
// 73A28: using guessed type int dword_73A28;

//----- (0000F8F8) --------------------------------------------------------
void __fastcall __noreturn sub_F8F8(char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_zcash mining support.\n", byte_73A2C);
  v2 = sub_595C4((const char *)dword_9A554, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 73A04: using guessed type int stdout;
// 9A554: using guessed type int dword_9A554;

//----- (0000FB48) --------------------------------------------------------
void *__fastcall sub_FB48(void *a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (0000FB5C) --------------------------------------------------------
time_t __fastcall sub_FB5C(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 0;
  sub_2A7A4((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0000FB90) --------------------------------------------------------
time_t __fastcall sub_FB90(int a1)
{
  int v2; // r4
  time_t result; // r0

  *(_BYTE *)(a1 + 61) = 1;
  sub_2A7A4((struct timeval *)(a1 + 44));
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 96) = 0;
  v2 = *(_DWORD *)(a1 + 36);
  result = time(0);
  *(_DWORD *)(v2 + 240) = result;
  return result;
}

//----- (0000FBC8) --------------------------------------------------------
int __fastcall sub_FBC8(int *a1, int *a2, int a3)
{
  int i; // r3
  _DWORD *v5; // r3
  unsigned int v6; // r2
  unsigned int v7; // r1
  int v8; // r0
  int v9; // r1
  int v10; // r2
  int v11; // r3
  int v12; // r0
  int v13; // r2
  int v14; // r3
  int v15; // r4
  int v16; // r5
  int v17; // r3
  int v18; // r8
  int v19; // r0
  int v20; // r8
  int v21; // r7
  int v22; // r1
  int v23; // r7
  int v24; // r6
  int v25; // r2
  int v26; // r5
  int v27; // r6
  int v28; // r3
  int v29; // r4
  int v30; // r0
  int v31; // r6
  int v32; // r8
  int v33; // r1
  int v34; // r0
  int v35; // r7
  int v36; // r1
  int v37; // r10
  int v38; // r5
  int v39; // r1
  int v40; // r4
  int v41; // r2
  int v42; // r1
  int v43; // r6
  int v44; // r3
  int v45; // r7
  int v46; // r1
  int v47; // r8
  int v48; // r7
  int v49; // r0
  int v50; // r5
  int v51; // r10
  int v52; // r7
  int v53; // r4
  int v54; // r6
  int v55; // r2
  int v56; // r10
  int v57; // r6
  int v58; // r8
  int v59; // r3
  int v60; // r5
  int v61; // r1
  int v62; // r6
  int v63; // r5
  int v64; // r0
  int v65; // r7
  int v66; // r5
  int v67; // r4
  int v68; // r10
  int v69; // r8
  int v70; // r5
  int v71; // r2
  int v72; // r6
  int v73; // r3
  int v74; // r8
  int v75; // r6
  int v76; // r7
  int v77; // r1
  int v78; // r10
  int v79; // r0
  int v80; // r6
  int v81; // r5
  int v82; // r4
  int v83; // r10
  int v84; // r5
  int v85; // r2
  int v86; // r8
  int v87; // r7
  int v88; // r5
  int v89; // r3
  int v90; // r6
  int v91; // r1
  int v92; // r7
  int v93; // r6
  int v94; // r10
  int v95; // r0
  int v96; // r8
  int v97; // r4
  int v98; // r6
  int v99; // r5
  int v100; // r2
  int v101; // r8
  int v102; // r5
  int v103; // r3
  int v104; // r7
  int v105; // r10
  int v106; // r5
  int v107; // r1
  int v108; // r6
  int v109; // r0
  int v110; // r10
  int v111; // r6
  int v112; // r8
  int v113; // r4
  int v114; // r7
  int v115; // r2
  int v116; // r6
  int v117; // r5
  int v118; // r3
  int v119; // r7
  int v120; // r5
  int v121; // r1
  int v122; // r10
  int v123; // r8
  int v124; // r5
  int v125; // r0
  int v126; // r6
  int v127; // r4
  int v128; // r8
  int v129; // r6
  int v130; // r7
  int v131; // r2
  int v132; // r10
  int v133; // r3
  int v134; // r6
  int v135; // r5
  int v136; // r1
  int v137; // r10
  int v138; // r5
  int v139; // r0
  int v140; // r8
  int v141; // r7
  int v142; // r5
  int v143; // r4
  int v144; // r6
  int v145; // r2
  int v146; // r7
  int v147; // r6
  int v148; // r10
  int v149; // r3
  int v150; // r8
  int v151; // r1
  int v152; // r6
  int v153; // r5
  int v154; // r0
  int v155; // r8
  int v156; // r5
  int v157; // r4
  int v158; // r7
  int v159; // r10
  int v160; // r5
  int v161; // r2
  int v162; // r6
  int v163; // r3
  int v164; // r10
  int v165; // r6
  int v166; // r8
  int v167; // r1
  int v168; // r7
  int v169; // r0
  int v170; // r6
  int v171; // r5
  int v172; // r4
  int v173; // r7
  int v174; // r5
  int v175; // r2
  int v176; // r10
  int v177; // r8
  int v178; // r5
  int v179; // r3
  int v180; // r6
  int v181; // r1
  int v182; // r8
  int v183; // r6
  int v184; // r7
  int v185; // r0
  int v186; // r10
  int v187; // r4
  int v188; // r6
  int v189; // r5
  int v190; // r2
  int v191; // r10
  int v192; // r5
  int v193; // r8
  int v194; // r3
  int v195; // r7
  int v196; // r5
  int v197; // r1
  int v198; // r6
  int result; // r0
  int v200; // r10
  int v201; // r6
  int v202; // r7
  int v203; // r2
  int v204; // r10
  int v205; // r8
  int v206; // r4
  int v207; // r2
  int v208; // r3
  _DWORD *v209; // r6
  int *v210; // r7
  int *v211; // r4
  int v212; // r0
  _DWORD *v213; // r5
  int v214; // r1
  int v215; // r2
  int v216; // r3
  int v217; // [sp+0h] [bp-120h]
  int v218; // [sp+4h] [bp-11Ch]
  int v219; // [sp+8h] [bp-118h]
  int v220; // [sp+Ch] [bp-114h]
  int v221; // [sp+10h] [bp-110h]
  int v222; // [sp+14h] [bp-10Ch]
  int v223; // [sp+18h] [bp-108h]
  int v224; // [sp+1Ch] [bp-104h]
  _DWORD v225[14]; // [sp+20h] [bp-100h] BYREF
  _DWORD v226[48]; // [sp+58h] [bp-C8h] BYREF
  _DWORD v227[2]; // [sp+118h] [bp-8h] BYREF

  if ( a3 )
  {
    for ( i = 0; i != 16; ++i )
      v225[i] = bswap32(a2[i]);
  }
  else
  {
    v209 = v225;
    v210 = a2 + 16;
    v211 = a2;
    do
    {
      v212 = *v211;
      v213 = v209;
      v214 = v211[1];
      v209 += 4;
      v215 = v211[2];
      v216 = v211[3];
      v211 += 4;
      *v213 = v212;
      v213[1] = v214;
      v213[2] = v215;
      v213[3] = v216;
    }
    while ( v211 != v210 );
  }
  v5 = v226;
  do
  {
    v6 = *(v5 - 13);
    v7 = *(v5 - 12);
    v8 = v6 + *(v5 - 4) + (__ROR4__(v5[1], 17) ^ __ROR4__(v5[1], 19) ^ (v5[1] >> 10));
    v5[2] = *(v5 - 14)
          + *(v5 - 5)
          + (__ROR4__(*v5, 17) ^ __ROR4__(*v5, 19) ^ (*v5 >> 10))
          + (__ROR4__(v6, 7) ^ __ROR4__(v6, 18) ^ (v6 >> 3));
    v5[3] = v8 + (__ROR4__(v7, 7) ^ __ROR4__(v7, 18) ^ (v7 >> 3));
    v5 += 2;
  }
  while ( v5 != v227 );
  v9 = a1[1];
  v10 = a1[2];
  v11 = a1[3];
  v217 = *a1;
  v218 = v9;
  v219 = v10;
  v220 = v11;
  v12 = a1[4];
  v13 = a1[6];
  v14 = a1[7];
  v15 = v217;
  v16 = v9;
  v222 = a1[5];
  v224 = v14;
  v17 = v12;
  v18 = v224
      + v225[0]
      + 1116352408
      + (__ROR4__(v12, 6) ^ __ROR4__(v12, 11) ^ __ROR4__(v12, 25))
      + ((v13 ^ v222) & v12 ^ v13);
  v19 = v18 + v220;
  v20 = ((v219 | v16) & v217 | v219 & v16) + (__ROR4__(v217, 2) ^ __ROR4__(v217, 13) ^ __ROR4__(v217, 22)) + v18;
  v21 = v13
      + v225[1]
      + 1899447441
      + (v19 & (v222 ^ v17) ^ v222)
      + (__ROR4__(v19, 6) ^ __ROR4__(v19, 11) ^ __ROR4__(v19, 25));
  v22 = v21 + v219;
  v23 = (__ROR4__(v20, 2) ^ __ROR4__(v20, 13) ^ __ROR4__(v20, 22)) + (v20 & (v16 | v15) | v16 & v15) + v21;
  v24 = v222
      + v225[2]
      - 1245643825
      + (v22 & (v19 ^ v17) ^ v17)
      + (__ROR4__(v22, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25));
  v25 = (__ROR4__(v23, 2) ^ __ROR4__(v23, 13) ^ __ROR4__(v23, 22)) + (v23 & (v20 | v15) | v20 & v15) + v24;
  v26 = v24 + v16;
  v27 = v17
      + v225[3]
      - 373957723
      + (v26 & (v22 ^ v19) ^ v19)
      + (__ROR4__(v26, 6) ^ __ROR4__(v26, 11) ^ __ROR4__(v26, 25));
  v28 = (__ROR4__(v25, 2) ^ __ROR4__(v25, 13) ^ __ROR4__(v25, 22)) + (v25 & (v23 | v20) | v23 & v20) + v27;
  v29 = v27 + v217;
  v30 = v225[4]
      + 961987163
      + v19
      + (v29 & (v26 ^ v22) ^ v22)
      + (__ROR4__(v27 + v217, 6) ^ __ROR4__(v29, 11) ^ __ROR4__(v29, 25));
  v31 = (__ROR4__(v28, 2) ^ __ROR4__(v28, 13) ^ __ROR4__(v28, 22)) + (v28 & (v25 | v23) | v25 & v23) + v30;
  v32 = v30 + v20;
  v33 = v225[5]
      + 1508970993
      + v22
      + (v32 & (v29 ^ v26) ^ v26)
      + (__ROR4__(v32, 6) ^ __ROR4__(v32, 11) ^ __ROR4__(v32, 25));
  v34 = (__ROR4__(v31, 2) ^ __ROR4__(v31, 13) ^ __ROR4__(v31, 22)) + (v31 & (v28 | v25) | v28 & v25) + v33;
  v35 = v33 + v23;
  v36 = v225[6]
      - 1841331548
      + v26
      + (v35 & (v32 ^ v29) ^ v29)
      + (__ROR4__(v35, 6) ^ __ROR4__(v35, 11) ^ __ROR4__(v35, 25));
  v37 = v36 + v25;
  v38 = (__ROR4__(v34, 2) ^ __ROR4__(v34, 13) ^ __ROR4__(v34, 22)) + (v34 & (v31 | v28) | v31 & v28) + v36;
  v39 = v225[7]
      - 1424204075
      + v29
      + (v37 & (v35 ^ v32) ^ v32)
      + (__ROR4__(v37, 6) ^ __ROR4__(v37, 11) ^ __ROR4__(v37, 25));
  v40 = v39 + v28;
  v41 = (__ROR4__(v38, 2) ^ __ROR4__(v38, 13) ^ __ROR4__(v38, 22)) + (v38 & (v34 | v31) | v34 & v31) + v39;
  v42 = v225[8]
      - 670586216
      + v32
      + (v40 & (v37 ^ v35) ^ v35)
      + (__ROR4__(v40, 6) ^ __ROR4__(v40, 11) ^ __ROR4__(v40, 25));
  v43 = v42 + v31;
  v44 = (__ROR4__(v41, 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v38 | v34) | v38 & v34) + v42;
  v45 = v225[9]
      + 310598401
      + v35
      + (v43 & (v40 ^ v37) ^ v37)
      + (__ROR4__(v43, 6) ^ __ROR4__(v43, 11) ^ __ROR4__(v43, 25));
  v46 = (__ROR4__(v44, 2) ^ __ROR4__(v44, 13) ^ __ROR4__(v44, 22)) + (v44 & (v41 | v38) | v41 & v38) + v45;
  v47 = v45 + v34;
  v48 = v225[10]
      + 607225278
      + v37
      + ((v45 + v34) & (v43 ^ v40) ^ v40)
      + (__ROR4__(v45 + v34, 6) ^ __ROR4__(v47, 11) ^ __ROR4__(v47, 25));
  v49 = (__ROR4__(v46, 2) ^ __ROR4__(v46, 13) ^ __ROR4__(v46, 22)) + (v46 & (v44 | v41) | v44 & v41) + v48;
  v50 = v48 + v38;
  v51 = v225[11]
      + 1426881987
      + v40
      + (v50 & (v47 ^ v43) ^ v43)
      + (__ROR4__(v50, 6) ^ __ROR4__(v50, 11) ^ __ROR4__(v50, 25));
  v52 = v51 + v41;
  v53 = (__ROR4__(v49, 2) ^ __ROR4__(v49, 13) ^ __ROR4__(v49, 22)) + (v49 & (v46 | v44) | v46 & v44) + v51;
  v54 = v225[12]
      + 1925078388
      + v43
      + (v52 & (v50 ^ v47) ^ v47)
      + (__ROR4__(v51 + v41, 6) ^ __ROR4__(v52, 11) ^ __ROR4__(v52, 25));
  v55 = (__ROR4__(v53, 2) ^ __ROR4__(v53, 13) ^ __ROR4__(v53, 22)) + (v53 & (v49 | v46) | v49 & v46) + v54;
  v56 = v54 + v44;
  v57 = v225[13]
      - 2132889090
      + v47
      + (v56 & (v52 ^ v50) ^ v50)
      + (__ROR4__(v54 + v44, 6) ^ __ROR4__(v56, 11) ^ __ROR4__(v56, 25));
  v58 = v57 + v46;
  v59 = (__ROR4__(v55, 2) ^ __ROR4__(v55, 13) ^ __ROR4__(v55, 22)) + (v55 & (v53 | v49) | v53 & v49) + v57;
  v60 = v226[0]
      - 1680079193
      + v50
      + (v58 & (v56 ^ v52) ^ v52)
      + (__ROR4__(v57 + v46, 6) ^ __ROR4__(v58, 11) ^ __ROR4__(v58, 25));
  v61 = (__ROR4__(v59, 2) ^ __ROR4__(v59, 13) ^ __ROR4__(v59, 22)) + (v59 & (v55 | v53) | v55 & v53) + v60;
  v62 = v60 + v49;
  v63 = v226[1]
      - 1046744716
      + v52
      + (v62 & (v58 ^ v56) ^ v56)
      + (__ROR4__(v60 + v49, 6) ^ __ROR4__(v62, 11) ^ __ROR4__(v62, 25));
  v64 = (__ROR4__(v61, 2) ^ __ROR4__(v61, 13) ^ __ROR4__(v61, 22)) + (v61 & (v59 | v55) | v59 & v55) + v63;
  v65 = v63 + v53;
  v66 = v226[2]
      - 459576895
      + v56
      + ((v63 + v53) & (v62 ^ v58) ^ v58)
      + (__ROR4__(v63 + v53, 6) ^ __ROR4__(v65, 11) ^ __ROR4__(v65, 25));
  v67 = (__ROR4__(v64, 2) ^ __ROR4__(v64, 13) ^ __ROR4__(v64, 22)) + (v64 & (v61 | v59) | v61 & v59) + v66;
  v68 = v66 + v55;
  v69 = v226[3]
      - 272742522
      + v58
      + (v68 & (v65 ^ v62) ^ v62)
      + (__ROR4__(v66 + v55, 6) ^ __ROR4__(v68, 11) ^ __ROR4__(v68, 25));
  v70 = v69 + v59;
  v71 = (__ROR4__(v67, 2) ^ __ROR4__(v67, 13) ^ __ROR4__(v67, 22)) + (v67 & (v64 | v61) | v64 & v61) + v69;
  v72 = v226[4]
      + 264347078
      + v62
      + (v70 & (v68 ^ v65) ^ v65)
      + (__ROR4__(v69 + v59, 6) ^ __ROR4__(v70, 11) ^ __ROR4__(v70, 25));
  v73 = (__ROR4__(v71, 2) ^ __ROR4__(v71, 13) ^ __ROR4__(v71, 22)) + (v71 & (v67 | v64) | v67 & v64) + v72;
  v74 = v72 + v61;
  v75 = v226[5]
      + 604807628
      + v65
      + (v74 & (v70 ^ v68) ^ v68)
      + (__ROR4__(v72 + v61, 6) ^ __ROR4__(v74, 11) ^ __ROR4__(v74, 25));
  v76 = v75 + v64;
  v77 = (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + (v73 & (v71 | v67) | v71 & v67) + v75;
  v78 = v226[6]
      + 770255983
      + v68
      + (v76 & (v74 ^ v70) ^ v70)
      + (__ROR4__(v75 + v64, 6) ^ __ROR4__(v76, 11) ^ __ROR4__(v76, 25));
  v79 = (__ROR4__(v77, 2) ^ __ROR4__(v77, 13) ^ __ROR4__(v77, 22)) + (v77 & (v73 | v71) | v73 & v71) + v78;
  v80 = v78 + v67;
  v81 = v226[7]
      + 1249150122
      + v70
      + (v80 & (v76 ^ v74) ^ v74)
      + (__ROR4__(v78 + v67, 6) ^ __ROR4__(v80, 11) ^ __ROR4__(v80, 25));
  v82 = (__ROR4__(v79, 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v77 | v73) | v77 & v73) + v81;
  v83 = v81 + v71;
  v84 = v226[8]
      + 1555081692
      + v74
      + ((v81 + v71) & (v80 ^ v76) ^ v76)
      + (__ROR4__(v81 + v71, 6) ^ __ROR4__(v83, 11) ^ __ROR4__(v83, 25));
  v85 = (__ROR4__(v82, 2) ^ __ROR4__(v82, 13) ^ __ROR4__(v82, 22)) + (v82 & (v79 | v77) | v79 & v77) + v84;
  v86 = v84 + v73;
  v87 = v226[9]
      + 1996064986
      + v76
      + (v86 & (v83 ^ v80) ^ v80)
      + (__ROR4__(v84 + v73, 6) ^ __ROR4__(v86, 11) ^ __ROR4__(v86, 25));
  v88 = v87 + v77;
  v89 = (__ROR4__(v85, 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v82 | v79) | v82 & v79) + v87;
  v90 = v226[10]
      - 1740746414
      + v80
      + (v88 & (v86 ^ v83) ^ v83)
      + (__ROR4__(v87 + v77, 6) ^ __ROR4__(v88, 11) ^ __ROR4__(v88, 25));
  v91 = (__ROR4__(v89, 2) ^ __ROR4__(v89, 13) ^ __ROR4__(v89, 22)) + (v89 & (v85 | v82) | v85 & v82) + v90;
  v92 = v90 + v79;
  v93 = v226[11]
      - 1473132947
      + v83
      + (v92 & (v88 ^ v86) ^ v86)
      + (__ROR4__(v90 + v79, 6) ^ __ROR4__(v92, 11) ^ __ROR4__(v92, 25));
  v94 = v93 + v82;
  v95 = (__ROR4__(v91, 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v89 | v85) | v89 & v85) + v93;
  v96 = v226[12]
      - 1341970488
      + v86
      + (v94 & (v92 ^ v88) ^ v88)
      + (__ROR4__(v93 + v82, 6) ^ __ROR4__(v94, 11) ^ __ROR4__(v94, 25));
  v97 = (__ROR4__(v95, 2) ^ __ROR4__(v95, 13) ^ __ROR4__(v95, 22)) + (v95 & (v91 | v89) | v91 & v89) + v96;
  v98 = v96 + v85;
  v99 = v226[13]
      - 1084653625
      + v88
      + (v98 & (v94 ^ v92) ^ v92)
      + (__ROR4__(v96 + v85, 6) ^ __ROR4__(v98, 11) ^ __ROR4__(v98, 25));
  v100 = (__ROR4__(v97, 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v95 | v91) | v95 & v91) + v99;
  v101 = v99 + v89;
  v102 = v226[14]
       - 958395405
       + v92
       + ((v99 + v89) & (v98 ^ v94) ^ v94)
       + (__ROR4__(v99 + v89, 6) ^ __ROR4__(v101, 11) ^ __ROR4__(v101, 25));
  v103 = (__ROR4__(v100, 2) ^ __ROR4__(v100, 13) ^ __ROR4__(v100, 22)) + (v100 & (v97 | v95) | v97 & v95) + v102;
  v104 = v102 + v91;
  v105 = v226[15]
       - 710438585
       + v94
       + (v104 & (v101 ^ v98) ^ v98)
       + (__ROR4__(v102 + v91, 6) ^ __ROR4__(v104, 11) ^ __ROR4__(v104, 25));
  v106 = v105 + v95;
  v107 = (__ROR4__(v103, 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v100 | v97) | v100 & v97) + v105;
  v108 = v226[16]
       + 113926993
       + v98
       + (v106 & (v104 ^ v101) ^ v101)
       + (__ROR4__(v105 + v95, 6) ^ __ROR4__(v106, 11) ^ __ROR4__(v106, 25));
  v109 = (__ROR4__(v107, 2) ^ __ROR4__(v107, 13) ^ __ROR4__(v107, 22)) + (v107 & (v103 | v100) | v103 & v100) + v108;
  v110 = v108 + v97;
  v111 = v226[17]
       + 338241895
       + v101
       + (v110 & (v106 ^ v104) ^ v104)
       + (__ROR4__(v108 + v97, 6) ^ __ROR4__(v110, 11) ^ __ROR4__(v110, 25));
  v112 = v111 + v100;
  v113 = (__ROR4__(v109, 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + (v109 & (v107 | v103) | v107 & v103) + v111;
  v114 = v226[18]
       + 666307205
       + v104
       + (v112 & (v110 ^ v106) ^ v106)
       + (__ROR4__(v111 + v100, 6) ^ __ROR4__(v112, 11) ^ __ROR4__(v112, 25));
  v115 = (__ROR4__(v113, 2) ^ __ROR4__(v113, 13) ^ __ROR4__(v113, 22)) + (v113 & (v109 | v107) | v109 & v107) + v114;
  v116 = v114 + v103;
  v117 = v226[19]
       + 773529912
       + v106
       + (v116 & (v112 ^ v110) ^ v110)
       + (__ROR4__(v114 + v103, 6) ^ __ROR4__(v116, 11) ^ __ROR4__(v116, 25));
  v118 = (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + (v115 & (v113 | v109) | v113 & v109) + v117;
  v119 = v117 + v107;
  v120 = v226[20]
       + 1294757372
       + v110
       + ((v117 + v107) & (v116 ^ v112) ^ v112)
       + (__ROR4__(v117 + v107, 6) ^ __ROR4__(v119, 11) ^ __ROR4__(v119, 25));
  v121 = (__ROR4__(v118, 2) ^ __ROR4__(v118, 13) ^ __ROR4__(v118, 22)) + (v118 & (v115 | v113) | v115 & v113) + v120;
  v122 = v120 + v109;
  v123 = v226[21]
       + 1396182291
       + v112
       + (v122 & (v119 ^ v116) ^ v116)
       + (__ROR4__(v120 + v109, 6) ^ __ROR4__(v122, 11) ^ __ROR4__(v122, 25));
  v124 = v123 + v113;
  v125 = (__ROR4__(v121, 2) ^ __ROR4__(v121, 13) ^ __ROR4__(v121, 22)) + (v121 & (v118 | v115) | v118 & v115) + v123;
  v126 = v226[22]
       + 1695183700
       + v116
       + (v124 & (v122 ^ v119) ^ v119)
       + (__ROR4__(v123 + v113, 6) ^ __ROR4__(v124, 11) ^ __ROR4__(v124, 25));
  v127 = (__ROR4__(v125, 2) ^ __ROR4__(v125, 13) ^ __ROR4__(v125, 22)) + (v125 & (v121 | v118) | v121 & v118) + v126;
  v128 = v126 + v115;
  v129 = v226[23]
       + 1986661051
       + v119
       + (v128 & (v124 ^ v122) ^ v122)
       + (__ROR4__(v126 + v115, 6) ^ __ROR4__(v128, 11) ^ __ROR4__(v128, 25));
  v130 = v129 + v118;
  v131 = (__ROR4__(v127, 2) ^ __ROR4__(v127, 13) ^ __ROR4__(v127, 22)) + (v127 & (v125 | v121) | v125 & v121) + v129;
  v132 = v226[24]
       - 2117940946
       + v122
       + (v130 & (v128 ^ v124) ^ v124)
       + (__ROR4__(v129 + v118, 6) ^ __ROR4__(v130, 11) ^ __ROR4__(v130, 25));
  v133 = (__ROR4__(v131, 2) ^ __ROR4__(v131, 13) ^ __ROR4__(v131, 22)) + (v131 & (v127 | v125) | v127 & v125) + v132;
  v134 = v132 + v121;
  v135 = v226[25]
       - 1838011259
       + v124
       + (v134 & (v130 ^ v128) ^ v128)
       + (__ROR4__(v132 + v121, 6) ^ __ROR4__(v134, 11) ^ __ROR4__(v134, 25));
  v136 = (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + (v133 & (v131 | v127) | v131 & v127) + v135;
  v137 = v135 + v125;
  v138 = v226[26]
       - 1564481375
       + v128
       + ((v135 + v125) & (v134 ^ v130) ^ v130)
       + (__ROR4__(v135 + v125, 6) ^ __ROR4__(v137, 11) ^ __ROR4__(v137, 25));
  v139 = (__ROR4__(v136, 2) ^ __ROR4__(v136, 13) ^ __ROR4__(v136, 22)) + (v136 & (v133 | v131) | v133 & v131) + v138;
  v140 = v138 + v127;
  v141 = v226[27]
       - 1474664885
       + v130
       + (v140 & (v137 ^ v134) ^ v134)
       + (__ROR4__(v138 + v127, 6) ^ __ROR4__(v140, 11) ^ __ROR4__(v140, 25));
  v142 = v141 + v131;
  v143 = (__ROR4__(v139, 2) ^ __ROR4__(v139, 13) ^ __ROR4__(v139, 22)) + (v139 & (v136 | v133) | v136 & v133) + v141;
  v144 = v226[28]
       - 1035236496
       + v134
       + (v142 & (v140 ^ v137) ^ v137)
       + (__ROR4__(v141 + v131, 6) ^ __ROR4__(v142, 11) ^ __ROR4__(v142, 25));
  v145 = (__ROR4__(v143, 2) ^ __ROR4__(v143, 13) ^ __ROR4__(v143, 22)) + (v143 & (v139 | v136) | v139 & v136) + v144;
  v146 = v144 + v133;
  v147 = v226[29]
       - 949202525
       + v137
       + (v146 & (v142 ^ v140) ^ v140)
       + (__ROR4__(v144 + v133, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25));
  v148 = v147 + v136;
  v149 = (__ROR4__(v145, 2) ^ __ROR4__(v145, 13) ^ __ROR4__(v145, 22)) + (v145 & (v143 | v139) | v143 & v139) + v147;
  v150 = v226[30]
       - 778901479
       + v140
       + (v148 & (v146 ^ v142) ^ v142)
       + (__ROR4__(v147 + v136, 6) ^ __ROR4__(v148, 11) ^ __ROR4__(v148, 25));
  v151 = (__ROR4__(v149, 2) ^ __ROR4__(v149, 13) ^ __ROR4__(v149, 22)) + (v149 & (v145 | v143) | v145 & v143) + v150;
  v152 = v150 + v139;
  v153 = v226[31]
       - 694614492
       + v142
       + (v152 & (v148 ^ v146) ^ v146)
       + (__ROR4__(v150 + v139, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25));
  v154 = (__ROR4__(v151, 2) ^ __ROR4__(v151, 13) ^ __ROR4__(v151, 22)) + (v151 & (v149 | v145) | v149 & v145) + v153;
  v155 = v153 + v143;
  v156 = v226[32]
       - 200395387
       + v146
       + ((v153 + v143) & (v152 ^ v148) ^ v148)
       + (__ROR4__(v153 + v143, 6) ^ __ROR4__(v155, 11) ^ __ROR4__(v155, 25));
  v157 = (__ROR4__(v154, 2) ^ __ROR4__(v154, 13) ^ __ROR4__(v154, 22)) + (v154 & (v151 | v149) | v151 & v149) + v156;
  v158 = v156 + v145;
  v159 = v226[33]
       + 275423344
       + v148
       + (v158 & (v155 ^ v152) ^ v152)
       + (__ROR4__(v156 + v145, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25));
  v160 = v159 + v149;
  v161 = (__ROR4__(v157, 2) ^ __ROR4__(v157, 13) ^ __ROR4__(v157, 22)) + (v157 & (v154 | v151) | v154 & v151) + v159;
  v162 = v226[34]
       + 430227734
       + v152
       + (v160 & (v158 ^ v155) ^ v155)
       + (__ROR4__(v159 + v149, 6) ^ __ROR4__(v160, 11) ^ __ROR4__(v160, 25));
  v163 = (__ROR4__(v161, 2) ^ __ROR4__(v161, 13) ^ __ROR4__(v161, 22)) + (v161 & (v157 | v154) | v157 & v154) + v162;
  v164 = v162 + v151;
  v165 = v226[35]
       + 506948616
       + v155
       + (v164 & (v160 ^ v158) ^ v158)
       + (__ROR4__(v162 + v151, 6) ^ __ROR4__(v164, 11) ^ __ROR4__(v164, 25));
  v166 = v165 + v154;
  v167 = (__ROR4__(v163, 2) ^ __ROR4__(v163, 13) ^ __ROR4__(v163, 22)) + (v163 & (v161 | v157) | v161 & v157) + v165;
  v168 = v226[36]
       + 659060556
       + v158
       + (v166 & (v164 ^ v160) ^ v160)
       + (__ROR4__(v165 + v154, 6) ^ __ROR4__(v166, 11) ^ __ROR4__(v166, 25));
  v169 = (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + (v167 & (v163 | v161) | v163 & v161) + v168;
  v170 = v168 + v157;
  v171 = v226[37]
       + 883997877
       + v160
       + (v170 & (v166 ^ v164) ^ v164)
       + (__ROR4__(v168 + v157, 6) ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25));
  v172 = (__ROR4__(v169, 2) ^ __ROR4__(v169, 13) ^ __ROR4__(v169, 22)) + (v169 & (v167 | v163) | v167 & v163) + v171;
  v173 = v171 + v161;
  v174 = v226[38]
       + 958139571
       + v164
       + ((v171 + v161) & (v170 ^ v166) ^ v166)
       + (__ROR4__(v171 + v161, 6) ^ __ROR4__(v173, 11) ^ __ROR4__(v173, 25));
  v175 = (__ROR4__(v172, 2) ^ __ROR4__(v172, 13) ^ __ROR4__(v172, 22)) + (v172 & (v169 | v167) | v169 & v167) + v174;
  v176 = v174 + v163;
  v177 = v226[39]
       + 1322822218
       + v166
       + (v176 & (v173 ^ v170) ^ v170)
       + (__ROR4__(v174 + v163, 6) ^ __ROR4__(v176, 11) ^ __ROR4__(v176, 25));
  v178 = v177 + v167;
  v179 = (__ROR4__(v175, 2) ^ __ROR4__(v175, 13) ^ __ROR4__(v175, 22)) + (v175 & (v172 | v169) | v172 & v169) + v177;
  v180 = v226[40]
       + 1537002063
       + v170
       + (v178 & (v176 ^ v173) ^ v173)
       + (__ROR4__(v177 + v167, 6) ^ __ROR4__(v178, 11) ^ __ROR4__(v178, 25));
  v181 = (__ROR4__(v179, 2) ^ __ROR4__(v179, 13) ^ __ROR4__(v179, 22)) + (v179 & (v175 | v172) | v175 & v172) + v180;
  v182 = v180 + v169;
  v183 = v226[41]
       + 1747873779
       + v173
       + (v182 & (v178 ^ v176) ^ v176)
       + (__ROR4__(v180 + v169, 6) ^ __ROR4__(v182, 11) ^ __ROR4__(v182, 25));
  v184 = v183 + v172;
  v185 = (__ROR4__(v181, 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v179 | v175) | v179 & v175) + v183;
  v186 = v226[42]
       + 1955562222
       + v176
       + (v184 & (v182 ^ v178) ^ v178)
       + (__ROR4__(v183 + v172, 6) ^ __ROR4__(v184, 11) ^ __ROR4__(v184, 25));
  v187 = (__ROR4__(v185, 2) ^ __ROR4__(v185, 13) ^ __ROR4__(v185, 22)) + (v185 & (v181 | v179) | v181 & v179) + v186;
  v188 = v186 + v175;
  v189 = v226[43]
       + 2024104815
       + v178
       + (v188 & (v184 ^ v182) ^ v182)
       + (__ROR4__(v186 + v175, 6) ^ __ROR4__(v188, 11) ^ __ROR4__(v188, 25));
  v190 = (__ROR4__(v187, 2) ^ __ROR4__(v187, 13) ^ __ROR4__(v187, 22)) + (v187 & (v185 | v181) | v185 & v181) + v189;
  v191 = v189 + v179;
  v192 = v226[44]
       - 2067236844
       + v182
       + ((v189 + v179) & (v188 ^ v184) ^ v184)
       + (__ROR4__(v189 + v179, 6) ^ __ROR4__(v191, 11) ^ __ROR4__(v191, 25));
  v193 = v192 + v181;
  v194 = (__ROR4__(v190, 2) ^ __ROR4__(v190, 13) ^ __ROR4__(v190, 22)) + (v190 & (v187 | v185) | v187 & v185) + v192;
  v195 = v226[45]
       - 1933114872
       + v184
       + (v193 & (v191 ^ v188) ^ v188)
       + (__ROR4__(v192 + v181, 6) ^ __ROR4__(v193, 11) ^ __ROR4__(v193, 25));
  v196 = v195 + v185;
  v197 = (__ROR4__(v194, 2) ^ __ROR4__(v194, 13) ^ __ROR4__(v194, 22)) + (v194 & (v190 | v187) | v190 & v187) + v195;
  v198 = v226[46]
       - 1866530822
       + v188
       + (v196 & (v193 ^ v191) ^ v191)
       + (__ROR4__(v195 + v185, 6) ^ __ROR4__(v195 + v185, 11) ^ __ROR4__(v196, 25));
  v224 = v198 + v187;
  result = (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + (v197 & (v194 | v190) | v194 & v190) + v198;
  v200 = v226[47]
       - 1538233109
       + v191
       + (v224 & (v196 ^ v193) ^ v193)
       + (__ROR4__(v198 + v187, 6) ^ __ROR4__(v224, 11) ^ __ROR4__(v224, 25));
  v201 = (__ROR4__(result, 2) ^ __ROR4__(result, 13) ^ __ROR4__(result, 22))
       + (result & (v197 | v194) | v197 & v194)
       + v200;
  v202 = v200 + v190;
  v203 = v227[0]
       - 1090935817
       + v193
       + (v202 & (v224 ^ v196) ^ v196)
       + (__ROR4__(v202, 6) ^ __ROR4__(v202, 11) ^ __ROR4__(v202, 25));
  v204 = v203 + v194;
  v205 = (__ROR4__(v201, 2) ^ __ROR4__(v201, 13) ^ __ROR4__(v201, 22)) + (v201 & (result | v197) | result & v197) + v203;
  v206 = v227[1]
       - 965641998
       + v196
       + (v204 & (v202 ^ v224) ^ v224)
       + (__ROR4__(v204, 6) ^ __ROR4__(v204, 11) ^ __ROR4__(v204, 25));
  v207 = (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + (v205 & (v201 | result) | v201 & result) + v206;
  v208 = 0;
  v220 = result;
  v223 = v202;
  v219 = v201;
  v222 = v204;
  v221 = v206 + v197;
  v217 = v207;
  v218 = v205;
  while ( 1 )
  {
    a1[v208++] += v207;
    if ( v208 == 8 )
      break;
    v207 = *(int *)((char *)&v217 + v208 * 4);
  }
  return result;
}

//----- (0001144C) --------------------------------------------------------
double __fastcall sub_1144C(double a1)
{
  float v1; // s0
  _DWORD *v2; // r4
  double result; // r0

  v2 = (_DWORD *)LODWORD(a1);
  result = log10(a1);
  if ( (int)(v1 + 1.0) > *v2 )
    ++*v2;
  return result;
}
// 11450: variable 'v1' is possibly undefined

//----- (00011480) --------------------------------------------------------
double __fastcall sub_11480(double a1)
{
  double v1; // d0
  _DWORD *v2; // r4
  double result; // r0

  v1 = (double)SLODWORD(a1);
  v2 = (_DWORD *)HIDWORD(a1);
  result = log10(a1);
  if ( (int)(v1 + 1.0) > *v2 )
    ++*v2;
  return result;
}

//----- (000114B8) --------------------------------------------------------
int __fastcall sub_114B8(unsigned __int64 a1, char *a2, size_t a3, int a4)
{
  __int64 v6; // r2
  __int64 v7; // r0
  double v8; // r0
  double v9; // d8
  bool v11; // cf
  __int64 v12; // r0
  double v13; // d0
  double v14; // r0
  __int64 v15; // r0
  __int64 v16; // r0
  __int64 v17; // r0
  __int16 v18; // [sp+1Ch] [bp-4h] BYREF

  v18 = 0;
  if ( a1 > 0xDE0B6B3A763FFFFLL )
  {
    LODWORD(v6) = -1530494976;
    HIDWORD(v6) = (char *)&locret_38D7C + 2;
    LODWORD(v7) = sub_59F7C(a1, v6);
    LODWORD(v8) = sub_59F08(v7);
    v18 = 69;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  v11 = (unsigned int)&locret_38D7C + 2 >= HIDWORD(a1);
  if ( (_UNKNOWN *)((char *)&locret_38D7C + 2) == (_UNKNOWN *)HIDWORD(a1) )
    v11 = (unsigned int)a1 <= 0xA4C67FFF;
  if ( !v11 )
  {
    LODWORD(v12) = sub_59F7C(a1, 1000000000000LL);
    LODWORD(v8) = sub_59F08(v12);
    v18 = 80;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xE8D4A50FFFLL )
  {
    LODWORD(v16) = sub_59F7C(a1, 1000000000);
    LODWORD(v8) = sub_59F08(v16);
    v18 = 84;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3B9AC9FF )
  {
    LODWORD(v15) = sub_59F7C(a1, 1000000);
    LODWORD(v8) = sub_59F08(v15);
    v18 = 71;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xF423F )
  {
    LODWORD(v17) = sub_59F7C(a1, 1000);
    LODWORD(v8) = sub_59F08(v17);
    v18 = 77;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3E7 )
  {
    LODWORD(v8) = sub_59F08(a1);
    v18 = 75;
    v9 = v8 / 1000.0;
LABEL_3:
    if ( !a4 )
      return snprintf(a2, a3, "%.3g%s", v9, (const char *)&v18);
    goto LABEL_9;
  }
  LODWORD(v8) = sub_59F08(a1);
  v9 = v8;
  if ( !a4 )
    return snprintf(a2, a3, "%d%s", (unsigned int)v8, (const char *)&v18);
LABEL_9:
  if ( v9 <= 0.0 )
  {
    v13 = 0.0;
  }
  else
  {
    v13 = v9;
    v14 = log10(v8);
    floor(v14);
  }
  return snprintf(a2, a3, "%*.*f%s", a4 + 1, (int)((double)(a4 - 1) - v13), v9, (const char *)&v18);
}
// 11514: variable 'v7' is possibly undefined
// 11524: variable 'v8' is possibly undefined
// 11580: variable 'v12' is possibly undefined
// 1166C: variable 'v16' is possibly undefined
// 11638: variable 'v15' is possibly undefined
// 116DC: variable 'v17' is possibly undefined

//----- (0001174C) --------------------------------------------------------
void __fastcall sub_1174C(char *a1, unsigned int a2)
{
  int v2; // r2
  int v3; // r4
  char v4[1016]; // [sp+8h] [bp-1400h] BYREF
  char v5[4096]; // [sp+408h] [bp-1000h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    --v2;
    v3 = (unsigned __int8)a2 + (v3 << 8);
    a2 >>= 8;
  }
  while ( v2 );
  sub_29630(v4, a1, 128);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(v5, 0x1000u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, v4);
    sub_385C8(3, v5, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0001180C) --------------------------------------------------------
bool sub_1180C()
{
  struct tm *v0; // r0
  int v1; // r12
  int v3; // r2
  int tm_hour; // r1
  int v5; // r2
  time_t tv_sec; // [sp+4h] [bp-Ch] BYREF
  struct timeval v7; // [sp+8h] [bp-8h] BYREF

  if ( !byte_7869C && !byte_78418 )
    return 1;
  sub_2A7A4(&v7);
  tv_sec = v7.tv_sec;
  v0 = localtime(&tv_sec);
  if ( !byte_7869C )
  {
    tm_hour = v0->tm_hour;
    return tm_hour < dword_78424 || tm_hour == dword_78424 && v0->tm_min < dword_78420;
  }
  if ( !byte_78418 )
  {
    v1 = v0->tm_hour;
    if ( v1 >= dword_786A8 && (v1 != dword_786A8 || v0->tm_min >= dword_786A4) )
    {
      byte_7869C = 0;
      return 1;
    }
    return 0;
  }
  if ( dword_786A8 >= dword_78424 && (dword_786A8 != dword_78424 || dword_786A4 >= dword_78420) )
  {
    v3 = v0->tm_hour;
    if ( dword_786A8 <= v3 )
    {
      if ( dword_786A8 != v3 || v0->tm_min >= dword_786A4 )
        return 1;
    }
    else if ( dword_78424 > v3 )
    {
      return 1;
    }
    return dword_78424 == v3 && v0->tm_min < dword_78420;
  }
  v5 = v0->tm_hour;
  return (dword_78424 > v5 || dword_78424 == v5 && v0->tm_min < dword_78420)
      && dword_786A8 <= v5
      && (dword_786A8 != v5 || v0->tm_min >= dword_786A4);
}
// 78418: using guessed type char byte_78418;
// 78420: using guessed type int dword_78420;
// 78424: using guessed type int dword_78424;
// 7869C: using guessed type char byte_7869C;
// 786A4: using guessed type int dword_786A4;
// 786A8: using guessed type int dword_786A8;

//----- (00011994) --------------------------------------------------------
int __fastcall sub_11994(int a1)
{
  double v1; // d0
  int v3; // r4
  double *v4; // r6
  int v5; // r0
  double v6; // d8
  double v7; // d0
  unsigned __int64 v8; // r0
  int result; // r0
  double v10; // d16
  double v11; // d16
  __int64 v12; // r0
  double v13; // d9
  double v14; // r0
  double v15; // d8
  double v16; // r0
  double v17; // d8
  double v18; // r0
  double v19; // d8
  double v20; // r0
  double v21; // d8

  v3 = *(_DWORD *)(a1 + 1748);
  if ( v1 == 0.0 )
  {
    v12 = *(_QWORD *)(a1 + 184);
    v13 = 65536.0;
    if ( !byte_78681 )
      v13 = 2.69595353e67;
    LODWORD(v14) = sub_59F08(v12);
    v15 = v14 * 6.27710174e57;
    LODWORD(v16) = sub_59F08(*(_QWORD *)(a1 + 176));
    v17 = v15 + v16 * 3.40282367e38;
    LODWORD(v18) = sub_59F08(*(_QWORD *)(a1 + 168));
    v19 = v17 + v18 * 1.84467441e19;
    LODWORD(v20) = sub_59F08(*(_QWORD *)(a1 + 160));
    v21 = v19 + v20;
    if ( v21 == 0.0 )
      v21 = 1.0;
    *(double *)(a1 + 1864) = v13 / v21;
    v4 = (double *)(a1 + 1864);
  }
  else
  {
    v4 = (double *)(a1 + 1864);
    *(double *)(a1 + 1864) = v1;
  }
  v5 = sub_484C8(a1 + 160);
  v6 = (double)v5;
  *v4 = (double)v5;
  v7 = (double)v5;
  *(double *)(v3 + 504) = (double)v5;
  round(v5);
  LODWORD(v8) = sub_5A000(v7);
  result = sub_114B8(v8, (char *)(*(_DWORD *)(a1 + 1748) + 48), 8u, 0);
  v10 = *(double *)(v3 + 488);
  if ( v6 == v10 )
  {
    ++*(_DWORD *)(v3 + 512);
    goto LABEL_5;
  }
  if ( v6 >= v10 )
  {
    if ( v10 != 0.0 )
    {
LABEL_5:
      v11 = *(double *)(v3 + 496);
      if ( v6 != v11 )
        goto LABEL_6;
LABEL_17:
      ++*(_DWORD *)(v3 + 516);
      return result;
    }
    *(double *)(v3 + 488) = v6;
    *(_DWORD *)(v3 + 512) = 1;
  }
  else
  {
    *(double *)(v3 + 488) = v6;
    *(_DWORD *)(v3 + 512) = 1;
  }
  v11 = *(double *)(v3 + 496);
  if ( v6 == v11 )
    goto LABEL_17;
LABEL_6:
  if ( v6 > v11 )
  {
    *(double *)(v3 + 496) = v6;
    *(_DWORD *)(v3 + 516) = 1;
  }
  return result;
}
// 119B0: variable 'v1' is possibly undefined
// 119FC: variable 'v8' is possibly undefined
// 11A7C: variable 'v14' is possibly undefined
// 11A90: variable 'v16' is possibly undefined
// 11AA4: variable 'v18' is possibly undefined
// 11AB4: variable 'v20' is possibly undefined
// AD44: using guessed type int __fastcall round(_DWORD);
// 78681: using guessed type char byte_78681;

//----- (00011B54) --------------------------------------------------------
void __fastcall __noreturn sub_11B54(void *a1)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(5u);
  exit(1);
}

//----- (00011B7C) --------------------------------------------------------
void __noreturn sub_11B7C(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vsnprintf(byte_73B30, 0x200u, a1, varg_r1);
  sub_385C8(3, byte_73B30, 1);
  exit(1);
}

//----- (00011BC4) --------------------------------------------------------
int __fastcall sub_11BC4(int a1, int a2, int a3)
{
  int v6; // r3
  char v8[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(v8, 0x1000u, "Thread %d being disabled", a2);
    sub_385C8(4, v8, 0);
  }
  v6 = (unsigned __int8)byte_75C49;
  *(_QWORD *)(*(_DWORD *)(a1 + 36) + 48) = 0;
  if ( v6 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v8, "Waiting on sem in miner thread");
    sub_385C8(7, v8, 0);
  }
  sub_2F0F0((sem_t *)(a1 + 16), "cgminer.c", "mt_disable", 8548);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(v8, 0x1000u, "Thread %d being re-enabled", a2);
    sub_385C8(4, v8, 0);
  }
  return (*(int (__fastcall **)(int))(a3 + 92))(a1);
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00011D5C) --------------------------------------------------------
int __fastcall sub_11D5C(int a1)
{
  _DWORD *v1; // r6
  int v3; // r5
  char v5[16]; // [sp+0h] [bp-1010h] BYREF
  char v6[4096]; // [sp+10h] [bp-1000h] BYREF

  v1 = *(_DWORD **)(a1 + 36);
  v3 = v1[1];
  snprintf(v5, 0x10u, "%d/Miner", *(_DWORD *)a1);
  sub_2EF24(v5);
  sub_FB90(a1);
  if ( (*(int (__fastcall **)(int))(v3 + 52))(a1) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(v6, "Waiting on sem in miner thread");
      sub_385C8(7, v6, 0);
    }
    sub_2F0F0((sem_t *)(a1 + 16), "cgminer.c", "miner_thread", 9134);
    v1[58] = time(0);
    (*(void (__fastcall **)(int))(v3 + 60))(a1);
    (*(void (__fastcall **)(int))(v3 + 88))(a1);
  }
  else
  {
    sub_2EBF8(v1, 0);
  }
  return 0;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00011E98) --------------------------------------------------------
void __fastcall sub_11E98(int a1)
{
  int i; // r1
  int v2; // r4
  const char *v3; // r0
  char *v4; // r4
  _BYTE v5[32]; // [sp+0h] [bp-1070h] BYREF
  char v6[80]; // [sp+20h] [bp-1050h] BYREF
  char s[4096]; // [sp+70h] [bp-1000h] BYREF

  for ( i = 0; i != 80; i += 4 )
    *(_DWORD *)&v6[i] = bswap32(*(_DWORD *)(a1 + i));
  v2 = a1 + 192;
  sub_3030C(v6, 0x50u, (int)v5);
  sub_3030C(v5, 0x20u, v2);
  v3 = sub_29688(v2, 32);
  v4 = (char *)v3;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "regen:%s", v3);
    sub_385C8(5, s, 0);
  }
  free(v4);
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00011F70) --------------------------------------------------------
int __fastcall sub_11F70(int a1)
{
  int v1; // r1
  int v2; // r2
  int v3; // r3
  int v4; // t1

  if ( dword_77FC0 <= 0 )
    return sub_B288(a1);
  v1 = dword_78260;
  v2 = *(_DWORD *)dword_78260;
  if ( *(_DWORD *)(*(_DWORD *)dword_78260 + 4) != a1 )
  {
    v3 = 0;
    while ( ++v3 != dword_77FC0 )
    {
      v4 = *(_DWORD *)(v1 + 4);
      v1 += 4;
      v2 = v4;
      if ( *(_DWORD *)(v4 + 4) == a1 )
        return v2;
    }
    return sub_B288(a1);
  }
  return v2;
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00011FDC) --------------------------------------------------------
void sub_11FDC()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(v0, "Unable to set thread to low priority");
  sub_385C8(7, v0, 0);
}

//----- (0001202C) --------------------------------------------------------
void sub_1202C()
{
  if ( !nice(10) && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    sub_11FDC();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001209C) --------------------------------------------------------
int __fastcall sub_1209C(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_2EF24("API");
  sub_1202C();
  sub_365FC(dword_73D30);
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}
// 73D30: using guessed type int dword_73D30;

//----- (000120E8) --------------------------------------------------------
char *__fastcall sub_120E8(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_58598(a1, a2);
  if ( !result && (*a2 < 100.0 || *a2 > 250.0) )
    return "Value out of range";
  return result;
}

//----- (00012138) --------------------------------------------------------
char *__fastcall sub_12138(const char *a1, float *a2)
{
  char *result; // r0

  result = sub_58598(a1, a2);
  if ( !result && (*a2 < 125.0 || *a2 > 500.0) )
    return "Value out of range";
  return result;
}

//----- (00012188) --------------------------------------------------------
int __fastcall sub_12188(int result)
{
  int v1; // r4
  int *v2; // r2
  int v3; // r12
  int v4; // r3
  int v5; // t1

  v1 = *(_DWORD *)(result + 188);
  if ( dword_77FC0 > 0 )
  {
    v2 = (int *)dword_78260;
    v3 = dword_78260 + 4 * dword_77FC0;
    do
    {
      while ( 1 )
      {
        v5 = *v2++;
        v4 = v5;
        if ( !*(_BYTE *)(v5 + 129) && *(_DWORD *)(v4 + 132) == 1 && (!*(_BYTE *)(v4 + 664) || *(_BYTE *)(v4 + 665)) )
          break;
        if ( v2 == (int *)v3 )
          goto LABEL_11;
      }
      if ( *(_DWORD *)(v4 + 188) < v1 )
      {
        result = v4;
        v1 = *(_DWORD *)(v4 + 188);
      }
    }
    while ( v2 != (int *)v3 );
LABEL_11:
    v1 = *(_DWORD *)(result + 188);
  }
  *(_DWORD *)(result + 188) = v1 + 1;
  return result;
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00012220) --------------------------------------------------------
int __fastcall sub_12220(int *a1, int a2, int *a3)
{
  int v3; // r1
  int v4; // r2
  int v5; // r3
  int v6; // r10
  _DWORD *v7; // r3
  int *v8; // r2
  unsigned int v9; // lr
  unsigned int v10; // r12
  unsigned int v11; // r1
  unsigned int v12; // t1
  int v13; // r3
  int *v14; // r5
  int v15; // r7
  int i; // r3
  int v17; // r4
  int v18; // r3
  int v19; // r9
  int v20; // r7
  int v21; // r11
  int v22; // r0
  int v23; // r8
  int v24; // r2
  int v25; // r10
  int v26; // r1
  int v27; // r5
  bool v28; // zf
  int v29; // r11
  int v30; // r7
  int v31; // r9
  int v32; // r6
  int v33; // r3
  int v34; // r0
  int v35; // r1
  int v36; // r2
  int v37; // r5
  int v38; // r4
  int v39; // r12
  int v40; // lr
  int v41; // r7
  int v42; // lr
  int v43; // r6
  int v44; // r9
  int v45; // r11
  int v46; // r4
  int v47; // r12
  int v48; // r2
  int v49; // r1
  int v50; // r5
  int v51; // r8
  int v52; // r10
  int v53; // r2
  int v54; // r11
  int v55; // r9
  int v56; // lr
  int v57; // r5
  int v58; // r7
  int v59; // r6
  int v60; // r1
  int v61; // r3
  int v62; // r0
  int v63; // r3
  int v64; // r9
  int v65; // r7
  int v66; // r11
  int v67; // r0
  int v68; // r8
  int v69; // r2
  int v70; // r10
  int v71; // r1
  int v72; // r5
  int v73; // r4
  int v74; // r11
  int v75; // r7
  int v76; // r9
  int v77; // r6
  int v78; // r3
  int v79; // r0
  int v80; // r1
  int v81; // r2
  int v82; // r5
  int v83; // r4
  int v84; // r12
  int v85; // lr
  int v86; // lr
  int v87; // r9
  int v88; // r7
  int v89; // r11
  int v90; // r10
  int v91; // r4
  int v92; // r6
  int v93; // r1
  int v94; // r5
  int v95; // r8
  int v96; // r10
  int v97; // r11
  int v98; // r9
  int v99; // r7
  int v100; // lr
  int v101; // r6
  int v102; // r5
  int v103; // r12
  int v104; // r1
  int v105; // r0
  int v106; // r3
  int v107; // r2
  __int16 v108; // r2
  int *v109; // r1
  int v110; // r0
  __int64 v111; // t1
  int v112; // lr
  int v113; // r10
  int v114; // r2
  int v115; // r9
  int v116; // r11
  int v117; // r3
  int v118; // r6
  int v119; // r4
  int v120; // r5
  int v121; // r8
  int v122; // r10
  int v123; // r11
  int v124; // r9
  int v125; // r6
  int v126; // lr
  int v127; // r7
  int v128; // r5
  int v129; // r2
  int v130; // r3
  int v131; // r12
  int v132; // r1
  int v133; // r0
  int v134; // r7
  int v135; // r0
  int v136; // r2
  int v137; // r4
  int v138; // r9
  int v139; // r7
  int v140; // r11
  int v141; // r10
  int v142; // r6
  int v143; // r1
  int v144; // r5
  int v145; // lr
  int v146; // r8
  int v147; // r10
  int v148; // r1
  int v149; // r11
  int v150; // r7
  int v151; // r9
  int v152; // r5
  int v153; // r6
  int v154; // r12
  int v155; // lr
  int v156; // r0
  int v157; // r3
  int v158; // r2
  int *v159; // r12
  int v160; // lr
  __int64 v161; // t1
  int v162; // r10
  int v163; // r2
  int v164; // r9
  int v165; // r11
  int v166; // lr
  int v167; // r6
  int v168; // r3
  int v169; // r4
  int v170; // r5
  int v171; // r8
  int v172; // r10
  int v173; // r11
  int v174; // r9
  int v175; // r3
  int v176; // r6
  int v177; // r7
  int v178; // lr
  int v179; // r5
  int v180; // r2
  int v181; // r12
  int v182; // r1
  int v183; // r0
  int v184; // r7
  int v185; // r0
  int v186; // r12
  int v187; // r2
  int v188; // r5
  int v189; // r12
  int v190; // r9
  int v191; // r7
  int v192; // r11
  int v193; // r10
  int v194; // r4
  int v195; // r6
  int v196; // r1
  int v197; // r8
  int v198; // lr
  int v199; // r10
  int v200; // r9
  int v201; // r11
  int v202; // r7
  int v203; // r1
  int v204; // r5
  int v205; // r6
  int v206; // lr
  int v207; // r12
  int v208; // r0
  int v209; // r3
  int v210; // r2
  int v211; // r6
  int v212; // r1
  int v213; // r2
  int v214; // r3
  int v215; // r0
  int v216; // r1
  int v217; // r2
  int v218; // r3
  int v219; // r0
  int v220; // r1
  int v221; // r2
  int v222; // r3
  int v223; // r12
  int v224; // r3
  int v226; // [sp+4h] [bp-2C8h]
  int v227; // [sp+4h] [bp-2C8h]
  int v228; // [sp+4h] [bp-2C8h]
  int v229; // [sp+4h] [bp-2C8h]
  int v230; // [sp+4h] [bp-2C8h]
  int v231; // [sp+4h] [bp-2C8h]
  int v232; // [sp+4h] [bp-2C8h]
  int v233; // [sp+4h] [bp-2C8h]
  int v234; // [sp+4h] [bp-2C8h]
  int v235; // [sp+4h] [bp-2C8h]
  int v236; // [sp+4h] [bp-2C8h]
  int v237; // [sp+8h] [bp-2C4h]
  int v238; // [sp+8h] [bp-2C4h]
  int v239; // [sp+8h] [bp-2C4h]
  int v240; // [sp+8h] [bp-2C4h]
  int v241; // [sp+8h] [bp-2C4h]
  int v242; // [sp+8h] [bp-2C4h]
  int v243; // [sp+8h] [bp-2C4h]
  int v244; // [sp+8h] [bp-2C4h]
  int v245; // [sp+8h] [bp-2C4h]
  int v246; // [sp+8h] [bp-2C4h]
  int v247; // [sp+Ch] [bp-2C0h]
  int v248; // [sp+Ch] [bp-2C0h]
  int v249; // [sp+Ch] [bp-2C0h]
  int v250; // [sp+Ch] [bp-2C0h]
  int v251; // [sp+Ch] [bp-2C0h]
  int v252; // [sp+Ch] [bp-2C0h]
  int v253; // [sp+Ch] [bp-2C0h]
  int v254; // [sp+Ch] [bp-2C0h]
  int v255; // [sp+10h] [bp-2BCh]
  int v256; // [sp+10h] [bp-2BCh]
  int v257; // [sp+10h] [bp-2BCh]
  int v258; // [sp+10h] [bp-2BCh]
  int v259; // [sp+10h] [bp-2BCh]
  int v260; // [sp+10h] [bp-2BCh]
  int v261; // [sp+10h] [bp-2BCh]
  int v262; // [sp+10h] [bp-2BCh]
  int v263; // [sp+14h] [bp-2B8h]
  int v264; // [sp+14h] [bp-2B8h]
  int v265; // [sp+14h] [bp-2B8h]
  int v266; // [sp+14h] [bp-2B8h]
  int v267; // [sp+14h] [bp-2B8h]
  int v268; // [sp+14h] [bp-2B8h]
  int v269; // [sp+14h] [bp-2B8h]
  int v270; // [sp+14h] [bp-2B8h]
  int v271; // [sp+18h] [bp-2B4h]
  int v272; // [sp+18h] [bp-2B4h]
  int v273; // [sp+18h] [bp-2B4h]
  int v274; // [sp+18h] [bp-2B4h]
  int v275; // [sp+18h] [bp-2B4h]
  int v276; // [sp+18h] [bp-2B4h]
  int v277; // [sp+18h] [bp-2B4h]
  int v278; // [sp+18h] [bp-2B4h]
  int v279; // [sp+1Ch] [bp-2B0h]
  int v280; // [sp+1Ch] [bp-2B0h]
  int v281; // [sp+1Ch] [bp-2B0h]
  int v282; // [sp+1Ch] [bp-2B0h]
  int v283; // [sp+1Ch] [bp-2B0h]
  int v284; // [sp+1Ch] [bp-2B0h]
  int v285; // [sp+1Ch] [bp-2B0h]
  int v286; // [sp+1Ch] [bp-2B0h]
  int v287; // [sp+20h] [bp-2ACh]
  int v288; // [sp+20h] [bp-2ACh]
  int v289; // [sp+20h] [bp-2ACh]
  int v290; // [sp+20h] [bp-2ACh]
  int v291; // [sp+20h] [bp-2ACh]
  int v292; // [sp+20h] [bp-2ACh]
  int v293; // [sp+20h] [bp-2ACh]
  int v294; // [sp+20h] [bp-2ACh]
  int v295; // [sp+24h] [bp-2A8h]
  int v296; // [sp+24h] [bp-2A8h]
  int v297; // [sp+24h] [bp-2A8h]
  int v298; // [sp+24h] [bp-2A8h]
  int v299; // [sp+24h] [bp-2A8h]
  int v300; // [sp+24h] [bp-2A8h]
  int v301; // [sp+24h] [bp-2A8h]
  int v302; // [sp+24h] [bp-2A8h]
  int v303; // [sp+28h] [bp-2A4h]
  int v304; // [sp+28h] [bp-2A4h]
  int v305; // [sp+28h] [bp-2A4h]
  int v306; // [sp+28h] [bp-2A4h]
  int v307; // [sp+28h] [bp-2A4h]
  int v308; // [sp+28h] [bp-2A4h]
  int v309; // [sp+28h] [bp-2A4h]
  int v310; // [sp+28h] [bp-2A4h]
  int v311; // [sp+2Ch] [bp-2A0h]
  int v312; // [sp+2Ch] [bp-2A0h]
  int v313; // [sp+2Ch] [bp-2A0h]
  int v314; // [sp+2Ch] [bp-2A0h]
  int v315; // [sp+2Ch] [bp-2A0h]
  int v316; // [sp+2Ch] [bp-2A0h]
  int v317; // [sp+30h] [bp-29Ch]
  int v318; // [sp+30h] [bp-29Ch]
  int v319; // [sp+30h] [bp-29Ch]
  int v320; // [sp+30h] [bp-29Ch]
  int v321; // [sp+30h] [bp-29Ch]
  int v322; // [sp+30h] [bp-29Ch]
  int v323; // [sp+34h] [bp-298h]
  int v324; // [sp+34h] [bp-298h]
  int v325; // [sp+34h] [bp-298h]
  int v326; // [sp+34h] [bp-298h]
  int v327; // [sp+34h] [bp-298h]
  int v328; // [sp+34h] [bp-298h]
  int v329; // [sp+38h] [bp-294h]
  int v330; // [sp+38h] [bp-294h]
  int v331; // [sp+38h] [bp-294h]
  int v332; // [sp+38h] [bp-294h]
  int v333; // [sp+38h] [bp-294h]
  int v334; // [sp+38h] [bp-294h]
  int v335; // [sp+3Ch] [bp-290h]
  int v336; // [sp+3Ch] [bp-290h]
  int v337; // [sp+3Ch] [bp-290h]
  int v338; // [sp+3Ch] [bp-290h]
  int v339; // [sp+3Ch] [bp-290h]
  int v340; // [sp+3Ch] [bp-290h]
  int v341; // [sp+40h] [bp-28Ch]
  int v342; // [sp+40h] [bp-28Ch]
  int v343; // [sp+40h] [bp-28Ch]
  int v344; // [sp+40h] [bp-28Ch]
  int v345; // [sp+40h] [bp-28Ch]
  int v346; // [sp+40h] [bp-28Ch]
  int v347; // [sp+44h] [bp-288h]
  int v348; // [sp+44h] [bp-288h]
  int v349; // [sp+44h] [bp-288h]
  int v350; // [sp+44h] [bp-288h]
  int v351; // [sp+44h] [bp-288h]
  int v352; // [sp+44h] [bp-288h]
  int v353; // [sp+48h] [bp-284h]
  int v354; // [sp+48h] [bp-284h]
  int v355; // [sp+48h] [bp-284h]
  int v356; // [sp+48h] [bp-284h]
  int v357; // [sp+48h] [bp-284h]
  int v358; // [sp+48h] [bp-284h]
  int v359; // [sp+4Ch] [bp-280h]
  int v360; // [sp+4Ch] [bp-280h]
  int v361; // [sp+4Ch] [bp-280h]
  int v362; // [sp+4Ch] [bp-280h]
  int v363; // [sp+4Ch] [bp-280h]
  int v364; // [sp+4Ch] [bp-280h]
  int v365; // [sp+50h] [bp-27Ch]
  int v366; // [sp+50h] [bp-27Ch]
  int v367; // [sp+50h] [bp-27Ch]
  int v368; // [sp+50h] [bp-27Ch]
  int v369; // [sp+50h] [bp-27Ch]
  int v370; // [sp+50h] [bp-27Ch]
  int v371; // [sp+54h] [bp-278h]
  int v372; // [sp+54h] [bp-278h]
  int v373; // [sp+54h] [bp-278h]
  int v374; // [sp+54h] [bp-278h]
  int v375; // [sp+54h] [bp-278h]
  int v376; // [sp+54h] [bp-278h]
  int v377; // [sp+58h] [bp-274h]
  int v378; // [sp+58h] [bp-274h]
  int v379; // [sp+58h] [bp-274h]
  int v380; // [sp+58h] [bp-274h]
  int v381; // [sp+58h] [bp-274h]
  int v382; // [sp+58h] [bp-274h]
  int v383; // [sp+5Ch] [bp-270h]
  int v384; // [sp+5Ch] [bp-270h]
  int v385; // [sp+5Ch] [bp-270h]
  int v386; // [sp+5Ch] [bp-270h]
  int v387; // [sp+5Ch] [bp-270h]
  int v388; // [sp+5Ch] [bp-270h]
  int v389; // [sp+60h] [bp-26Ch]
  int v390; // [sp+60h] [bp-26Ch]
  int v391; // [sp+60h] [bp-26Ch]
  int v392; // [sp+60h] [bp-26Ch]
  int v393; // [sp+60h] [bp-26Ch]
  int v394; // [sp+60h] [bp-26Ch]
  int v395; // [sp+64h] [bp-268h]
  int v396; // [sp+64h] [bp-268h]
  int v397; // [sp+64h] [bp-268h]
  int v398; // [sp+64h] [bp-268h]
  int v399; // [sp+64h] [bp-268h]
  int v400; // [sp+64h] [bp-268h]
  int v401; // [sp+68h] [bp-264h]
  int v402; // [sp+68h] [bp-264h]
  int v403; // [sp+68h] [bp-264h]
  int v404; // [sp+68h] [bp-264h]
  int v405; // [sp+68h] [bp-264h]
  int v406; // [sp+68h] [bp-264h]
  int v407; // [sp+6Ch] [bp-260h]
  int v408; // [sp+6Ch] [bp-260h]
  int v409; // [sp+6Ch] [bp-260h]
  int v410; // [sp+6Ch] [bp-260h]
  int v411; // [sp+6Ch] [bp-260h]
  int v412; // [sp+6Ch] [bp-260h]
  int v413; // [sp+70h] [bp-25Ch]
  int v414; // [sp+70h] [bp-25Ch]
  int v415; // [sp+70h] [bp-25Ch]
  int v416; // [sp+70h] [bp-25Ch]
  int v417; // [sp+70h] [bp-25Ch]
  int v418; // [sp+70h] [bp-25Ch]
  int v419; // [sp+74h] [bp-258h]
  int v420; // [sp+74h] [bp-258h]
  int v421; // [sp+74h] [bp-258h]
  int v422; // [sp+74h] [bp-258h]
  int v423; // [sp+74h] [bp-258h]
  int v424; // [sp+74h] [bp-258h]
  int v425; // [sp+78h] [bp-254h]
  int v426; // [sp+78h] [bp-254h]
  int v427; // [sp+78h] [bp-254h]
  int v428; // [sp+78h] [bp-254h]
  int v429; // [sp+78h] [bp-254h]
  int v430; // [sp+78h] [bp-254h]
  int v431; // [sp+7Ch] [bp-250h]
  int v432; // [sp+7Ch] [bp-250h]
  int v433; // [sp+7Ch] [bp-250h]
  int v434; // [sp+7Ch] [bp-250h]
  int v435; // [sp+7Ch] [bp-250h]
  int v436; // [sp+7Ch] [bp-250h]
  int v437; // [sp+80h] [bp-24Ch]
  int v438; // [sp+80h] [bp-24Ch]
  int v439; // [sp+80h] [bp-24Ch]
  int v440; // [sp+80h] [bp-24Ch]
  int v441; // [sp+80h] [bp-24Ch]
  int v442; // [sp+80h] [bp-24Ch]
  int v443; // [sp+80h] [bp-24Ch]
  int v444; // [sp+80h] [bp-24Ch]
  int v445; // [sp+84h] [bp-248h]
  int v446; // [sp+84h] [bp-248h]
  int v447; // [sp+84h] [bp-248h]
  int v448; // [sp+84h] [bp-248h]
  int v449; // [sp+84h] [bp-248h]
  int v450; // [sp+84h] [bp-248h]
  int v451; // [sp+88h] [bp-244h]
  int v452; // [sp+88h] [bp-244h]
  int v453; // [sp+88h] [bp-244h]
  int v454; // [sp+88h] [bp-244h]
  int v455; // [sp+88h] [bp-244h]
  int v456; // [sp+88h] [bp-244h]
  int v457; // [sp+88h] [bp-244h]
  int v458; // [sp+88h] [bp-244h]
  int v459; // [sp+8Ch] [bp-240h]
  int v460; // [sp+8Ch] [bp-240h]
  int v461; // [sp+8Ch] [bp-240h]
  int v462; // [sp+8Ch] [bp-240h]
  int v463; // [sp+8Ch] [bp-240h]
  int v464; // [sp+8Ch] [bp-240h]
  int v465; // [sp+90h] [bp-23Ch]
  int v466; // [sp+90h] [bp-23Ch]
  int v467; // [sp+90h] [bp-23Ch]
  int v468; // [sp+90h] [bp-23Ch]
  int v469; // [sp+90h] [bp-23Ch]
  int v470; // [sp+90h] [bp-23Ch]
  int v471; // [sp+94h] [bp-238h]
  int v472; // [sp+94h] [bp-238h]
  int v473; // [sp+94h] [bp-238h]
  int v474; // [sp+94h] [bp-238h]
  int v475; // [sp+98h] [bp-234h]
  int v476; // [sp+98h] [bp-234h]
  int v477; // [sp+98h] [bp-234h]
  int v478; // [sp+98h] [bp-234h]
  int v479; // [sp+98h] [bp-234h]
  int v480; // [sp+98h] [bp-234h]
  int v481; // [sp+9Ch] [bp-230h]
  int v482; // [sp+9Ch] [bp-230h]
  int v483; // [sp+9Ch] [bp-230h]
  int v484; // [sp+9Ch] [bp-230h]
  int v485; // [sp+A0h] [bp-22Ch]
  int v486; // [sp+A0h] [bp-22Ch]
  int v487; // [sp+A0h] [bp-22Ch]
  int v488; // [sp+A0h] [bp-22Ch]
  int v489; // [sp+A0h] [bp-22Ch]
  int v490; // [sp+A0h] [bp-22Ch]
  int v491; // [sp+A4h] [bp-228h]
  int v492; // [sp+A4h] [bp-228h]
  int v493; // [sp+A4h] [bp-228h]
  int v494; // [sp+A4h] [bp-228h]
  int v495; // [sp+A8h] [bp-224h]
  int v496; // [sp+A8h] [bp-224h]
  int v497; // [sp+A8h] [bp-224h]
  int v498; // [sp+A8h] [bp-224h]
  int v499; // [sp+A8h] [bp-224h]
  int v500; // [sp+A8h] [bp-224h]
  char *dest; // [sp+ACh] [bp-220h]
  int desta; // [sp+ACh] [bp-220h]
  int v503; // [sp+B0h] [bp-21Ch]
  char *v504; // [sp+B4h] [bp-218h]
  char *v505; // [sp+B8h] [bp-214h]
  int v508; // [sp+C8h] [bp-204h] BYREF
  int v509; // [sp+CCh] [bp-200h]
  int v510; // [sp+D0h] [bp-1FCh]
  int v511; // [sp+D4h] [bp-1F8h]
  int v512; // [sp+D8h] [bp-1F4h]
  int v513; // [sp+DCh] [bp-1F0h]
  int v514; // [sp+E0h] [bp-1ECh]
  int v515; // [sp+E4h] [bp-1E8h]
  _DWORD v516[8]; // [sp+E8h] [bp-1E4h]
  int v517; // [sp+108h] [bp-1C4h] BYREF
  int v518; // [sp+10Ch] [bp-1C0h]
  int v519; // [sp+110h] [bp-1BCh]
  int v520; // [sp+114h] [bp-1B8h]
  int v521; // [sp+118h] [bp-1B4h]
  int v522; // [sp+11Ch] [bp-1B0h]
  int v523; // [sp+120h] [bp-1ACh]
  int v524; // [sp+124h] [bp-1A8h]
  int v525[8]; // [sp+128h] [bp-1A4h] BYREF
  int v526; // [sp+148h] [bp-184h] BYREF
  int v527; // [sp+14Ch] [bp-180h]
  int v528; // [sp+150h] [bp-17Ch]
  int v529; // [sp+154h] [bp-178h]
  int v530; // [sp+158h] [bp-174h]
  int v531; // [sp+15Ch] [bp-170h]
  int v532; // [sp+160h] [bp-16Ch]
  int v533; // [sp+164h] [bp-168h]
  _DWORD v534[8]; // [sp+168h] [bp-164h] BYREF
  int v535; // [sp+188h] [bp-144h] BYREF
  int v536; // [sp+18Ch] [bp-140h]
  int v537; // [sp+190h] [bp-13Ch]
  int v538; // [sp+194h] [bp-138h]
  int v539; // [sp+198h] [bp-134h]
  int v540; // [sp+19Ch] [bp-130h]
  int v541; // [sp+1A0h] [bp-12Ch]
  int v542; // [sp+1A4h] [bp-128h]
  int v543[4]; // [sp+1A8h] [bp-124h] BYREF
  int v544; // [sp+1B8h] [bp-114h] BYREF
  int v545; // [sp+1E8h] [bp-E4h] BYREF
  int v546; // [sp+1ECh] [bp-E0h]
  int v547; // [sp+1F0h] [bp-DCh]
  int v548; // [sp+1F4h] [bp-D8h]
  int v549; // [sp+1F8h] [bp-D4h]
  int v550; // [sp+1FCh] [bp-D0h]
  int v551; // [sp+200h] [bp-CCh]
  int v552; // [sp+204h] [bp-C8h]
  int v553[16]; // [sp+208h] [bp-C4h] BYREF
  int src[32]; // [sp+248h] [bp-84h] BYREF
  char v555; // [sp+2C8h] [bp-4h] BYREF

  dest = (char *)((a2 + 63) & 0xFFFFFFC0);
  v508 = 1779033703;
  v509 = -1150833019;
  v510 = 1013904242;
  v511 = -1521486534;
  v512 = 1359893119;
  v513 = -1694144372;
  v514 = 528734635;
  v515 = 1541459225;
  sub_FBC8(&v508, a1, 1);
  v3 = a1[17];
  v4 = a1[18];
  v5 = a1[19];
  v526 = a1[16];
  v527 = v3;
  v528 = v4;
  v529 = v5;
  v530 = 128;
  v531 = 0;
  v532 = 0;
  v533 = 0;
  v504 = dest;
  memset(v534, 0, 28);
  v534[7] = -2147352576;
  sub_FBC8(&v508, &v526, 1);
  v538 = -1521486534;
  v539 = 1359893119;
  v516[0] = v508;
  v516[1] = v509;
  v516[2] = v510;
  v516[3] = v511;
  v535 = 1779033703;
  v6 = 0;
  v536 = -1150833019;
  v537 = 1013904242;
  v540 = -1694144372;
  v541 = 528734635;
  v542 = 1541459225;
  v516[4] = v512;
  v516[5] = v513;
  v516[6] = v514;
  v516[7] = v515;
  do
  {
    *(int *)((char *)&v526 + v6 * 4) = v516[v6] ^ 0x36363636;
    ++v6;
  }
  while ( v6 != 8 );
  memset(v534, 54, sizeof(v534));
  sub_FBC8(&v535, &v526, 0);
  sub_FBC8(&v535, a1, 1);
  v7 = &unk_5A9B4;
  v8 = &v544;
  v9 = a1[17];
  v10 = a1[18];
  v543[0] = bswap32(a1[16]);
  v11 = a1[19];
  v543[1] = bswap32(v9);
  v543[2] = bswap32(v10);
  v543[3] = bswap32(v11);
  do
  {
    v12 = v7[1];
    ++v7;
    v8[1] = bswap32(v12);
    ++v8;
  }
  while ( v7 != (_DWORD *)&unk_5A9E0 );
  v13 = 0;
  v545 = 1779033703;
  v546 = -1150833019;
  v547 = 1013904242;
  v548 = -1521486534;
  v549 = 1359893119;
  v550 = -1694144372;
  v551 = 528734635;
  v552 = 1541459225;
  do
  {
    *(int *)((char *)&v526 + v13 * 4) = v516[v13] ^ 0x5C5C5C5C;
    ++v13;
  }
  while ( v13 != 8 );
  memset(v534, 92, sizeof(v534));
  sub_FBC8(&v545, &v526, 0);
  v14 = src;
  v15 = 0;
  v553[8] = 0x80000000;
  memset(&v553[9], 0, 24);
  v553[15] = 768;
  do
  {
    ++v15;
    v517 = v535;
    v518 = v536;
    v519 = v537;
    v520 = v538;
    v544 = v15;
    v521 = v539;
    v522 = v540;
    v523 = v541;
    v524 = v542;
    sub_FBC8(&v517, v543, 0);
    v553[0] = v517;
    v553[1] = v518;
    v553[2] = v519;
    v553[3] = v520;
    v553[4] = v521;
    v553[5] = v522;
    v553[6] = v523;
    v553[7] = v524;
    v525[0] = v545;
    v525[1] = v546;
    v525[2] = v547;
    v525[3] = v548;
    v525[4] = v549;
    v525[5] = v550;
    v525[6] = v551;
    v525[7] = v552;
    sub_FBC8(v525, v553, 0);
    for ( i = 0; i != 8; ++i )
      v14[i] = bswap32(v525[i]);
    v14 += 8;
  }
  while ( v15 != 4 );
  v317 = src[0];
  v505 = dest + 0x20000;
  v311 = src[16];
  v323 = src[1];
  v413 = src[17];
  v329 = src[2];
  v419 = src[18];
  v335 = src[3];
  v425 = src[19];
  v341 = src[4];
  v431 = src[20];
  v347 = src[5];
  v437 = src[21];
  v353 = src[6];
  v445 = src[22];
  v359 = src[7];
  v451 = src[23];
  v365 = src[8];
  v459 = src[24];
  v371 = src[9];
  v465 = src[25];
  v377 = src[10];
  v471 = src[26];
  v383 = src[11];
  v475 = src[27];
  v389 = src[12];
  v481 = src[28];
  v395 = src[13];
  v485 = src[29];
  v401 = src[14];
  v491 = src[30];
  v407 = src[15];
  v495 = src[31];
  do
  {
    memcpy(dest, src, 0x80u);
    v318 = v311 ^ v317;
    v324 = v413 ^ v323;
    v330 = v419 ^ v329;
    v336 = v425 ^ v335;
    v342 = v431 ^ v341;
    v348 = v437 ^ v347;
    v354 = v445 ^ v353;
    v360 = v451 ^ v359;
    v366 = v459 ^ v365;
    v372 = v465 ^ v371;
    v378 = v471 ^ v377;
    v384 = v475 ^ v383;
    v263 = v384;
    v396 = v485 ^ v395;
    v408 = v495 ^ v407;
    v287 = v396;
    v17 = v408;
    v255 = v354;
    v18 = v491 ^ v401;
    v19 = v360;
    v20 = v330;
    v21 = v366;
    v22 = v336;
    v23 = v378;
    v24 = v372;
    v25 = v324;
    v26 = v342;
    v27 = v318;
    v390 = v481 ^ v389;
    v247 = v390;
    v402 = v491 ^ v401;
    v295 = v348;
    v303 = 4;
    do
    {
      v226 = v26 ^ __ROR4__(v247 + v27, 25);
      v271 = v18 ^ __ROR4__(v255 + v23, 25);
      v28 = v303-- == 1;
      v237 = v24 ^ __ROR4__(v25 + v295, 25);
      v279 = v22 ^ __ROR4__(v263 + v17, 25);
      v29 = v21 ^ __ROR4__(v226 + v27, 23);
      v30 = v20 ^ __ROR4__(v271 + v23, 23);
      v31 = v19 ^ __ROR4__(v279 + v17, 23);
      v32 = v247 ^ __ROR4__(v29 + v226, 19);
      v33 = v287 ^ __ROR4__(v237 + v295, 23);
      v34 = v263 ^ __ROR4__(v31 + v279, 19);
      v35 = v255 ^ __ROR4__(v30 + v271, 19);
      v36 = v25 ^ __ROR4__(v33 + v237, 19);
      v37 = v27 ^ __ROR4__(v32 + v29, 14);
      v38 = v17 ^ __ROR4__(v34 + v31, 14);
      v39 = v23 ^ __ROR4__(v35 + v30, 14);
      v40 = v295 ^ __ROR4__(v36 + v33, 14);
      v247 = v32 ^ __ROR4__(v38 + v271, 25);
      v263 = v34 ^ __ROR4__(v39 + v237, 25);
      v255 = v35 ^ __ROR4__(v40 + v226, 25);
      v25 = v36 ^ __ROR4__(v37 + v279, 25);
      v21 = v29 ^ __ROR4__(v263 + v39, 23);
      v19 = v31 ^ __ROR4__(v255 + v40, 23);
      v20 = v30 ^ __ROR4__(v25 + v37, 23);
      v287 = v33 ^ __ROR4__(v247 + v38, 23);
      v22 = v279 ^ __ROR4__(v20 + v25, 19);
      v26 = v226 ^ __ROR4__(v19 + v255, 19);
      v24 = v237 ^ __ROR4__(v21 + v263, 19);
      v18 = v271 ^ __ROR4__(v287 + v247, 19);
      v27 = v37 ^ __ROR4__(v22 + v20, 14);
      v295 = v40 ^ __ROR4__(v26 + v19, 14);
      v23 = v39 ^ __ROR4__(v24 + v21, 14);
      v17 = v38 ^ __ROR4__(v18 + v287, 14);
    }
    while ( !v28 );
    v319 = v27 + v318;
    v325 = v25 + v324;
    v331 = v20 + v330;
    v337 = v22 + v336;
    v343 = v26 + v342;
    v349 = v295 + v348;
    v355 = v255 + v354;
    v361 = v19 + v360;
    v379 = v23 + v378;
    v367 = v21 + v366;
    v373 = v24 + v372;
    v385 = v263 + v384;
    v391 = v247 + v390;
    v397 = v287 + v396;
    v403 = v18 + v402;
    v409 = v17 + v408;
    v414 = v325 ^ v413;
    v420 = v331 ^ v419;
    v426 = v337 ^ v425;
    v432 = v343 ^ v431;
    v503 = v319 ^ v311;
    v438 = v349 ^ v437;
    v446 = v355 ^ v445;
    v452 = v361 ^ v451;
    v460 = v367 ^ v459;
    v466 = v373 ^ v465;
    v472 = v379 ^ v471;
    v492 = v403 ^ v491;
    v41 = v492;
    v256 = v414;
    v312 = 4;
    v482 = v391 ^ v481;
    v496 = v409 ^ v495;
    v42 = v397 ^ v485;
    v476 = v385 ^ v475;
    v486 = v397 ^ v485;
    v264 = v476;
    v280 = v472;
    v43 = v452;
    v44 = v420;
    v45 = v460;
    v46 = v496;
    v47 = v446;
    v48 = v466;
    v272 = v438;
    v49 = v432;
    v50 = v482;
    src[0] = v319;
    v304 = v426;
    v51 = v503;
    src[1] = v325;
    src[2] = v331;
    src[3] = v337;
    src[4] = v343;
    src[5] = v349;
    src[6] = v355;
    src[7] = v361;
    src[8] = v367;
    src[9] = v373;
    src[10] = v379;
    src[11] = v385;
    src[12] = v391;
    src[13] = v397;
    src[14] = v403;
    src[15] = v409;
    do
    {
      v248 = v49 ^ __ROR4__(v50 + v51, 25);
      v238 = v41 ^ __ROR4__(v47 + v280, 25);
      v28 = v312-- == 1;
      v52 = v304 ^ __ROR4__(v264 + v46, 25);
      v227 = v48 ^ __ROR4__(v256 + v272, 25);
      v53 = v43 ^ __ROR4__(v52 + v46, 23);
      v54 = v45 ^ __ROR4__(v248 + v51, 23);
      v55 = v44 ^ __ROR4__(v238 + v280, 23);
      v56 = v42 ^ __ROR4__(v227 + v272, 23);
      v57 = v50 ^ __ROR4__(v54 + v248, 19);
      v58 = v264 ^ __ROR4__(v53 + v52, 19);
      v59 = v47 ^ __ROR4__(v55 + v238, 19);
      v60 = v256 ^ __ROR4__(v56 + v227, 19);
      v296 = v46 ^ __ROR4__(v58 + v53, 14);
      v61 = v280 ^ __ROR4__(v59 + v55, 14);
      v288 = v51 ^ __ROR4__(v57 + v54, 14);
      v62 = v272 ^ __ROR4__(v60 + v56, 14);
      v50 = v57 ^ __ROR4__(v296 + v238, 25);
      v264 = v58 ^ __ROR4__(v61 + v227, 25);
      v47 = v59 ^ __ROR4__(v62 + v248, 25);
      v256 = v60 ^ __ROR4__(v288 + v52, 25);
      v45 = v54 ^ __ROR4__(v264 + v61, 23);
      v43 = v53 ^ __ROR4__(v47 + v62, 23);
      v44 = v55 ^ __ROR4__(v256 + v288, 23);
      v42 = v56 ^ __ROR4__(v50 + v296, 23);
      v304 = v52 ^ __ROR4__(v44 + v256, 19);
      v41 = v238 ^ __ROR4__(v42 + v50, 19);
      v49 = v248 ^ __ROR4__(v43 + v47, 19);
      v48 = v227 ^ __ROR4__(v45 + v264, 19);
      v51 = v288 ^ __ROR4__(v304 + v44, 14);
      v272 = v62 ^ __ROR4__(v49 + v43, 14);
      v280 = v61 ^ __ROR4__(v48 + v45, 14);
      v46 = v296 ^ __ROR4__(v41 + v42, 14);
    }
    while ( !v28 );
    v313 = v51 + v503;
    v415 = v256 + v414;
    v427 = v304 + v426;
    v433 = v49 + v432;
    v421 = v44 + v420;
    v453 = v43 + v452;
    v439 = v272 + v438;
    v447 = v47 + v446;
    v467 = v48 + v466;
    v487 = v42 + v486;
    v461 = v45 + v460;
    v473 = v280 + v472;
    v477 = v264 + v476;
    v483 = v50 + v482;
    v493 = v41 + v492;
    v497 = v46 + v496;
    src[16] = v51 + v503;
    src[17] = v415;
    src[18] = v421;
    src[19] = v427;
    src[20] = v433;
    src[21] = v439;
    src[22] = v447;
    src[23] = v453;
    src[24] = v461;
    src[25] = v467;
    src[26] = v473;
    src[27] = v477;
    src[28] = v483;
    src[29] = v487;
    src[30] = v493;
    src[31] = v497;
    memcpy(dest + 128, src, 0x80u);
    v320 = (v51 + v503) ^ v319;
    v326 = v415 ^ v325;
    v332 = v421 ^ v331;
    v338 = v427 ^ v337;
    v344 = v433 ^ v343;
    v350 = v439 ^ v349;
    v356 = v447 ^ v355;
    v362 = v453 ^ v361;
    v368 = v461 ^ v367;
    v374 = v467 ^ v373;
    v380 = v473 ^ v379;
    v386 = v477 ^ v385;
    v392 = v483 ^ v391;
    v398 = v487 ^ v397;
    v404 = v493 ^ v403;
    v63 = v404;
    v289 = v398;
    v257 = v356;
    v64 = v362;
    v65 = v332;
    v66 = v368;
    v67 = v338;
    v68 = v380;
    v69 = v374;
    v70 = v326;
    v71 = v344;
    v72 = v320;
    v410 = v497 ^ v409;
    v265 = v386;
    v73 = v410;
    v297 = v350;
    v249 = v392;
    v305 = 4;
    do
    {
      v228 = v71 ^ __ROR4__(v249 + v72, 25);
      v273 = v63 ^ __ROR4__(v257 + v68, 25);
      v28 = v305-- == 1;
      v239 = v69 ^ __ROR4__(v70 + v297, 25);
      v281 = v67 ^ __ROR4__(v265 + v73, 25);
      v74 = v66 ^ __ROR4__(v228 + v72, 23);
      v75 = v65 ^ __ROR4__(v273 + v68, 23);
      v76 = v64 ^ __ROR4__(v281 + v73, 23);
      v77 = v249 ^ __ROR4__(v74 + v228, 19);
      v78 = v289 ^ __ROR4__(v239 + v297, 23);
      v79 = v265 ^ __ROR4__(v76 + v281, 19);
      v80 = v257 ^ __ROR4__(v75 + v273, 19);
      v81 = v70 ^ __ROR4__(v78 + v239, 19);
      v82 = v72 ^ __ROR4__(v77 + v74, 14);
      v83 = v73 ^ __ROR4__(v79 + v76, 14);
      v84 = v68 ^ __ROR4__(v80 + v75, 14);
      v85 = v297 ^ __ROR4__(v81 + v78, 14);
      v249 = v77 ^ __ROR4__(v83 + v273, 25);
      v265 = v79 ^ __ROR4__(v84 + v239, 25);
      v257 = v80 ^ __ROR4__(v85 + v228, 25);
      v70 = v81 ^ __ROR4__(v82 + v281, 25);
      v66 = v74 ^ __ROR4__(v265 + v84, 23);
      v64 = v76 ^ __ROR4__(v257 + v85, 23);
      v65 = v75 ^ __ROR4__(v70 + v82, 23);
      v289 = v78 ^ __ROR4__(v249 + v83, 23);
      v67 = v281 ^ __ROR4__(v65 + v70, 19);
      v71 = v228 ^ __ROR4__(v64 + v257, 19);
      v69 = v239 ^ __ROR4__(v66 + v265, 19);
      v63 = v273 ^ __ROR4__(v289 + v249, 19);
      v72 = v82 ^ __ROR4__(v67 + v65, 14);
      v297 = v85 ^ __ROR4__(v71 + v64, 14);
      v68 = v84 ^ __ROR4__(v69 + v66, 14);
      v73 = v83 ^ __ROR4__(v63 + v289, 14);
    }
    while ( !v28 );
    v317 = v72 + v320;
    v323 = v70 + v326;
    v329 = v65 + v332;
    v335 = v67 + v338;
    v341 = v71 + v344;
    v347 = v297 + v350;
    v353 = v257 + v356;
    v359 = v64 + v362;
    v377 = v68 + v380;
    v365 = v66 + v368;
    v371 = v69 + v374;
    v383 = v265 + v386;
    v389 = v249 + v392;
    v395 = v289 + v398;
    v401 = v63 + v404;
    v407 = v73 + v410;
    v416 = v323 ^ v415;
    v422 = v329 ^ v421;
    v428 = v335 ^ v427;
    v434 = v341 ^ v433;
    v314 = v317 ^ v313;
    v440 = v347 ^ v439;
    v448 = v353 ^ v447;
    v454 = v359 ^ v453;
    v462 = v365 ^ v461;
    v468 = v371 ^ v467;
    v474 = v377 ^ v473;
    v484 = v389 ^ v483;
    v494 = v401 ^ v493;
    v498 = v407 ^ v497;
    v86 = v395 ^ v487;
    v478 = v383 ^ v477;
    v488 = v395 ^ v487;
    v266 = v448;
    v290 = v474;
    v258 = v416;
    v87 = v454;
    v88 = v422;
    v89 = v462;
    v90 = v428;
    v91 = v498;
    v92 = v468;
    v282 = v440;
    v93 = v434;
    v306 = 4;
    v250 = v484;
    v94 = v478;
    src[0] = v317;
    src[1] = v323;
    src[2] = v329;
    src[3] = v335;
    src[4] = v341;
    src[5] = v347;
    src[6] = v353;
    src[7] = v359;
    src[8] = v365;
    src[9] = v371;
    src[10] = v377;
    src[11] = v383;
    src[12] = v389;
    src[13] = v395;
    src[14] = v401;
    src[15] = v407;
    v240 = v494;
    v95 = v314;
    do
    {
      v229 = v93 ^ __ROR4__(v250 + v95, 25);
      v28 = v306-- == 1;
      v96 = v90 ^ __ROR4__(v94 + v91, 25);
      v274 = v240 ^ __ROR4__(v266 + v290, 25);
      v241 = v92 ^ __ROR4__(v258 + v282, 25);
      v97 = v89 ^ __ROR4__(v229 + v95, 23);
      v98 = v87 ^ __ROR4__(v96 + v91, 23);
      v99 = v88 ^ __ROR4__(v274 + v290, 23);
      v100 = v86 ^ __ROR4__(v241 + v282, 23);
      v101 = v250 ^ __ROR4__(v97 + v229, 19);
      v102 = v94 ^ __ROR4__(v98 + v96, 19);
      v103 = v266 ^ __ROR4__(v99 + v274, 19);
      v104 = v258 ^ __ROR4__(v100 + v241, 19);
      v105 = v95 ^ __ROR4__(v101 + v97, 14);
      v298 = v91 ^ __ROR4__(v102 + v98, 14);
      v106 = v290 ^ __ROR4__(v103 + v99, 14);
      v107 = v282 ^ __ROR4__(v104 + v100, 14);
      v94 = v102 ^ __ROR4__(v106 + v241, 25);
      v250 = v101 ^ __ROR4__(v298 + v274, 25);
      v266 = v103 ^ __ROR4__(v107 + v229, 25);
      v258 = v104 ^ __ROR4__(v105 + v96, 25);
      v89 = v97 ^ __ROR4__(v94 + v106, 23);
      v87 = v98 ^ __ROR4__(v266 + v107, 23);
      v88 = v99 ^ __ROR4__(v258 + v105, 23);
      v86 = v100 ^ __ROR4__(v250 + v298, 23);
      v90 = v96 ^ __ROR4__(v88 + v258, 19);
      v93 = v229 ^ __ROR4__(v87 + v266, 19);
      v92 = v241 ^ __ROR4__(v89 + v94, 19);
      v240 = v274 ^ __ROR4__(v86 + v250, 19);
      v95 = v105 ^ __ROR4__(v90 + v88, 14);
      v290 = v106 ^ __ROR4__(v92 + v89, 14);
      v282 = v107 ^ __ROR4__(v93 + v87, 14);
      v91 = v298 ^ __ROR4__(v240 + v86, 14);
    }
    while ( !v28 );
    v311 = v95 + v314;
    dest += 256;
    src[16] = v311;
    v419 = v88 + v422;
    v413 = v258 + v416;
    src[17] = v413;
    src[18] = v419;
    v425 = v90 + v428;
    src[19] = v425;
    v437 = v282 + v440;
    src[21] = v437;
    v431 = v93 + v434;
    src[20] = v431;
    v451 = v87 + v454;
    v445 = v266 + v448;
    src[22] = v445;
    v459 = v89 + v462;
    v465 = v92 + v468;
    src[23] = v451;
    v475 = v94 + v478;
    src[27] = v475;
    src[24] = v459;
    v471 = v290 + v474;
    src[25] = v465;
    src[26] = v471;
    v481 = v250 + v484;
    v485 = v86 + v488;
    src[28] = v481;
    v491 = v240 + v494;
    src[29] = v485;
    v495 = v91 + v498;
    src[30] = v491;
    src[31] = v495;
  }
  while ( dest != v505 );
  v108 = v311;
  desta = 512;
  do
  {
    v109 = src;
    v110 = (int)&v504[128 * (v108 & 0x3FF) - 8];
    do
    {
      v111 = *(_QWORD *)(v110 + 8);
      v110 += 8;
      *(_QWORD *)v109 ^= v111;
      v109 += 2;
    }
    while ( v109 != (int *)&v555 );
    v345 = src[18] ^ src[2];
    v333 = src[17] ^ src[1];
    v321 = src[16] ^ src[0];
    v369 = src[20] ^ src[4];
    v357 = src[19] ^ src[3];
    v307 = 4;
    v259 = src[17] ^ src[1];
    v381 = src[21] ^ src[5];
    v112 = src[18] ^ src[2];
    v113 = src[19] ^ src[3];
    v393 = src[22] ^ src[6];
    v405 = src[23] ^ src[7];
    v417 = src[24] ^ src[8];
    v441 = src[26] ^ src[10];
    v267 = src[22] ^ src[6];
    v455 = src[27] ^ src[11];
    v283 = src[21] ^ src[5];
    v114 = src[25] ^ src[9];
    v115 = src[23] ^ src[7];
    v116 = src[24] ^ src[8];
    v291 = src[26] ^ src[10];
    v469 = src[28] ^ src[12];
    v479 = src[29] ^ src[13];
    v117 = src[30] ^ src[14];
    v118 = src[29] ^ src[13];
    v119 = src[31] ^ src[15];
    v251 = src[28] ^ src[12];
    v120 = src[27] ^ src[11];
    v230 = src[20] ^ src[4];
    v121 = src[16] ^ src[0];
    v489 = src[30] ^ src[14];
    v499 = src[31] ^ src[15];
    do
    {
      v28 = v307-- == 1;
      v122 = v113 ^ __ROR4__(v120 + v119, 25);
      v231 = v230 ^ __ROR4__(v251 + v121, 25);
      v275 = v117 ^ __ROR4__(v267 + v291, 25);
      v242 = v114 ^ __ROR4__(v259 + v283, 25);
      v123 = v116 ^ __ROR4__(v231 + v121, 23);
      v124 = v115 ^ __ROR4__(v122 + v119, 23);
      v125 = v118 ^ __ROR4__(v242 + v283, 23);
      v126 = v112 ^ __ROR4__(v275 + v291, 23);
      v127 = v251 ^ __ROR4__(v123 + v231, 19);
      v128 = v120 ^ __ROR4__(v124 + v122, 19);
      v129 = v267 ^ __ROR4__(v126 + v275, 19);
      v130 = v259 ^ __ROR4__(v125 + v242, 19);
      v299 = v119 ^ __ROR4__(v128 + v124, 14);
      v131 = v121 ^ __ROR4__(v127 + v123, 14);
      v132 = v291 ^ __ROR4__(v129 + v126, 14);
      v133 = v283 ^ __ROR4__(v130 + v125, 14);
      v120 = v128 ^ __ROR4__(v132 + v242, 25);
      v251 = v127 ^ __ROR4__(v299 + v275, 25);
      v267 = v129 ^ __ROR4__(v133 + v231, 25);
      v259 = v130 ^ __ROR4__(v131 + v122, 25);
      v116 = v123 ^ __ROR4__(v120 + v132, 23);
      v115 = v124 ^ __ROR4__(v267 + v133, 23);
      v112 = v126 ^ __ROR4__(v259 + v131, 23);
      v118 = v125 ^ __ROR4__(v251 + v299, 23);
      v113 = v122 ^ __ROR4__(v112 + v259, 19);
      v230 = v231 ^ __ROR4__(v115 + v267, 19);
      v114 = v242 ^ __ROR4__(v116 + v120, 19);
      v117 = v275 ^ __ROR4__(v118 + v251, 19);
      v121 = v131 ^ __ROR4__(v113 + v112, 14);
      v134 = v133 ^ __ROR4__(v230 + v115, 14);
      v283 = v134;
      v119 = v299 ^ __ROR4__(v117 + v118, 14);
      v291 = v132 ^ __ROR4__(v114 + v116, 14);
    }
    while ( !v28 );
    src[0] = v121 + v321;
    v135 = v259 + v333;
    src[4] = v230 + v369;
    src[5] = v134 + v381;
    src[6] = v267 + v393;
    src[7] = v115 + v405;
    v136 = v114 + (src[25] ^ src[9]);
    src[10] = v291 + v441;
    src[12] = v251 + v469;
    src[13] = v118 + v479;
    src[8] = v116 + v417;
    src[11] = v120 + v455;
    src[14] = v117 + v489;
    src[15] = v119 + v499;
    v315 = (v121 + v321) ^ src[16];
    v327 = (v259 + v333) ^ src[17];
    v339 = (v112 + v345) ^ src[18];
    v351 = (v113 + v357) ^ src[19];
    v363 = (v230 + v369) ^ src[20];
    v375 = (v134 + v381) ^ src[21];
    v387 = (v267 + v393) ^ src[22];
    v399 = (v115 + v405) ^ src[23];
    v411 = (v116 + v417) ^ src[24];
    v423 = v136 ^ src[25];
    v429 = (v291 + v441) ^ src[26];
    v435 = (v120 + v455) ^ src[27];
    v442 = (v251 + v469) ^ src[28];
    v456 = (v117 + v489) ^ src[30];
    v252 = v435;
    v137 = (v119 + v499) ^ src[31];
    v138 = (v118 + v479) ^ src[29];
    v463 = v137;
    v268 = v387;
    v292 = v429;
    v449 = v138;
    v260 = v327;
    v284 = v375;
    src[3] = v113 + v357;
    v139 = v339;
    v140 = v411;
    v141 = v351;
    v142 = v136 ^ src[25];
    v143 = v363;
    v144 = v442;
    v308 = 4;
    src[1] = v135;
    src[2] = v112 + v345;
    src[9] = v136;
    v243 = v456;
    v145 = v399;
    v146 = v315;
    do
    {
      v232 = v143 ^ __ROR4__(v144 + v146, 25);
      v28 = v308-- == 1;
      v147 = v141 ^ __ROR4__(v252 + v137, 25);
      v276 = v243 ^ __ROR4__(v268 + v292, 25);
      v148 = v145 ^ __ROR4__(v147 + v137, 23);
      v244 = v142 ^ __ROR4__(v260 + v284, 25);
      v149 = v140 ^ __ROR4__(v232 + v146, 23);
      v150 = v139 ^ __ROR4__(v276 + v292, 23);
      v151 = v138 ^ __ROR4__(v244 + v284, 23);
      v152 = v144 ^ __ROR4__(v149 + v232, 19);
      v153 = v252 ^ __ROR4__(v148 + v147, 19);
      v154 = v260 ^ __ROR4__(v151 + v244, 19);
      v155 = v268 ^ __ROR4__(v150 + v276, 19);
      v300 = v137 ^ __ROR4__(v153 + v148, 14);
      v156 = v146 ^ __ROR4__(v152 + v149, 14);
      v157 = v292 ^ __ROR4__(v155 + v150, 14);
      v158 = v284 ^ __ROR4__(v154 + v151, 14);
      v144 = v152 ^ __ROR4__(v300 + v276, 25);
      v252 = v153 ^ __ROR4__(v157 + v244, 25);
      v260 = v154 ^ __ROR4__(v156 + v147, 25);
      v268 = v155 ^ __ROR4__(v158 + v232, 25);
      v140 = v149 ^ __ROR4__(v252 + v157, 23);
      v145 = v148 ^ __ROR4__(v268 + v158, 23);
      v139 = v150 ^ __ROR4__(v260 + v156, 23);
      v138 = v151 ^ __ROR4__(v144 + v300, 23);
      v141 = v147 ^ __ROR4__(v139 + v260, 19);
      v143 = v232 ^ __ROR4__(v145 + v268, 19);
      v142 = v244 ^ __ROR4__(v140 + v252, 19);
      v243 = v276 ^ __ROR4__(v138 + v144, 19);
      v146 = v156 ^ __ROR4__(v141 + v139, 14);
      v292 = v157 ^ __ROR4__(v142 + v140, 14);
      v284 = v158 ^ __ROR4__(v143 + v145, 14);
      v137 = v300 ^ __ROR4__(v243 + v138, 14);
    }
    while ( !v28 );
    v233 = v145;
    src[16] = v146 + v315;
    src[17] = v260 + v327;
    v159 = src;
    src[18] = v139 + v339;
    src[19] = v141 + v351;
    v160 = (int)&v504[128 * ((v146 + v315) & 0x3FF) - 8];
    src[20] = v143 + v363;
    src[21] = v284 + v375;
    src[22] = v268 + v387;
    src[23] = v233 + v399;
    src[24] = v140 + v411;
    src[25] = v142 + v423;
    src[26] = v292 + v429;
    src[27] = v252 + v435;
    src[28] = v144 + v442;
    src[29] = v138 + v449;
    src[30] = v243 + v456;
    src[31] = v137 + v463;
    do
    {
      v161 = *(_QWORD *)(v160 + 8);
      v160 += 8;
      *(_QWORD *)v159 ^= v161;
      v159 += 2;
    }
    while ( v159 != (int *)&v555 );
    v334 = src[17] ^ src[1];
    v322 = src[16] ^ src[0];
    v370 = src[20] ^ src[4];
    v309 = 4;
    v261 = src[17] ^ src[1];
    v162 = src[19] ^ src[3];
    v358 = src[19] ^ src[3];
    v382 = src[21] ^ src[5];
    v346 = src[18] ^ src[2];
    v394 = src[22] ^ src[6];
    v406 = src[23] ^ src[7];
    v418 = src[24] ^ src[8];
    v443 = src[26] ^ src[10];
    v285 = src[21] ^ src[5];
    v269 = src[22] ^ src[6];
    v457 = src[27] ^ src[11];
    v163 = src[25] ^ src[9];
    v293 = src[26] ^ src[10];
    v164 = src[23] ^ src[7];
    v165 = src[24] ^ src[8];
    v470 = src[28] ^ src[12];
    v480 = src[29] ^ src[13];
    v166 = src[28] ^ src[12];
    v167 = src[29] ^ src[13];
    v168 = src[30] ^ src[14];
    v253 = src[27] ^ src[11];
    v169 = src[31] ^ src[15];
    v234 = src[20] ^ src[4];
    v170 = src[18] ^ src[2];
    v171 = src[16] ^ src[0];
    v490 = src[30] ^ src[14];
    v500 = src[31] ^ src[15];
    do
    {
      v277 = v168 ^ __ROR4__(v293 + v269, 25);
      v28 = v309-- == 1;
      v172 = v162 ^ __ROR4__(v169 + v253, 25);
      v235 = v234 ^ __ROR4__(v171 + v166, 25);
      v245 = v163 ^ __ROR4__(v285 + v261, 25);
      v173 = v165 ^ __ROR4__(v235 + v171, 23);
      v174 = v164 ^ __ROR4__(v172 + v169, 23);
      v175 = v170 ^ __ROR4__(v277 + v293, 23);
      v176 = v167 ^ __ROR4__(v245 + v285, 23);
      v177 = v253 ^ __ROR4__(v174 + v172, 19);
      v178 = v166 ^ __ROR4__(v173 + v235, 19);
      v179 = v269 ^ __ROR4__(v175 + v277, 19);
      v180 = v261 ^ __ROR4__(v176 + v245, 19);
      v301 = v169 ^ __ROR4__(v177 + v174, 14);
      v181 = v171 ^ __ROR4__(v178 + v173, 14);
      v182 = v293 ^ __ROR4__(v179 + v175, 14);
      v183 = v285 ^ __ROR4__(v180 + v176, 14);
      v166 = v178 ^ __ROR4__(v301 + v277, 25);
      v253 = v177 ^ __ROR4__(v182 + v245, 25);
      v261 = v180 ^ __ROR4__(v181 + v172, 25);
      v269 = v179 ^ __ROR4__(v183 + v235, 25);
      v164 = v174 ^ __ROR4__(v269 + v183, 23);
      v165 = v173 ^ __ROR4__(v253 + v182, 23);
      v170 = v175 ^ __ROR4__(v261 + v181, 23);
      v167 = v176 ^ __ROR4__(v166 + v301, 23);
      v162 = v172 ^ __ROR4__(v170 + v261, 19);
      v234 = v235 ^ __ROR4__(v164 + v269, 19);
      v163 = v245 ^ __ROR4__(v165 + v253, 19);
      v168 = v277 ^ __ROR4__(v167 + v166, 19);
      v171 = v181 ^ __ROR4__(v162 + v170, 14);
      v184 = v183 ^ __ROR4__(v234 + v164, 14);
      v285 = v184;
      v169 = v301 ^ __ROR4__(v168 + v167, 14);
      v293 = v182 ^ __ROR4__(v163 + v165, 14);
    }
    while ( !v28 );
    src[0] = v171 + v322;
    v185 = v261 + v334;
    v186 = v170 + v346;
    src[3] = v162 + v358;
    src[4] = v234 + v370;
    src[5] = v184 + v382;
    src[7] = v164 + v406;
    v187 = v163 + (src[25] ^ src[9]);
    src[6] = v269 + v394;
    src[10] = v293 + v443;
    src[12] = v166 + v470;
    src[8] = v165 + v418;
    src[11] = v253 + v457;
    src[13] = v167 + v480;
    src[14] = v168 + v490;
    src[15] = v169 + v500;
    v316 = (v171 + v322) ^ src[16];
    v328 = (v261 + v334) ^ src[17];
    v340 = (v170 + v346) ^ src[18];
    v352 = (v162 + v358) ^ src[19];
    v364 = (v234 + v370) ^ src[20];
    v376 = (v184 + v382) ^ src[21];
    v388 = (v269 + v394) ^ src[22];
    v400 = (v164 + v406) ^ src[23];
    v412 = (v165 + v418) ^ src[24];
    v424 = v187 ^ src[25];
    v430 = (v293 + v443) ^ src[26];
    v436 = (v253 + v457) ^ src[27];
    v444 = (v166 + v470) ^ src[28];
    v450 = (v167 + v480) ^ src[29];
    v188 = v436;
    v262 = v388;
    v458 = (v168 + v490) ^ src[30];
    v270 = v328;
    v286 = v376;
    v464 = (v169 + v500) ^ src[31];
    v294 = v316;
    src[2] = v186;
    v189 = v458;
    v190 = v400;
    v191 = v340;
    v192 = v412;
    v193 = v352;
    v194 = v464;
    v195 = v187 ^ src[25];
    v196 = v364;
    v310 = 4;
    src[1] = v185;
    src[9] = v187;
    v254 = v444;
    v197 = v430;
    v198 = v450;
    do
    {
      v236 = v196 ^ __ROR4__(v294 + v254, 25);
      v278 = v189 ^ __ROR4__(v197 + v262, 25);
      v199 = v193 ^ __ROR4__(v194 + v188, 25);
      v28 = v310-- == 1;
      v200 = v190 ^ __ROR4__(v199 + v194, 23);
      v201 = v192 ^ __ROR4__(v236 + v294, 23);
      v246 = v195 ^ __ROR4__(v286 + v270, 25);
      v202 = v191 ^ __ROR4__(v278 + v197, 23);
      v203 = v198 ^ __ROR4__(v246 + v286, 23);
      v204 = v188 ^ __ROR4__(v200 + v199, 19);
      v205 = v254 ^ __ROR4__(v201 + v236, 19);
      v206 = v262 ^ __ROR4__(v202 + v278, 19);
      v207 = v270 ^ __ROR4__(v203 + v246, 19);
      v208 = v294 ^ __ROR4__(v205 + v201, 14);
      v302 = v194 ^ __ROR4__(v204 + v200, 14);
      v209 = v197 ^ __ROR4__(v206 + v202, 14);
      v210 = v286 ^ __ROR4__(v207 + v203, 14);
      v188 = v204 ^ __ROR4__(v209 + v246, 25);
      v254 = v205 ^ __ROR4__(v302 + v278, 25);
      v211 = v207 ^ __ROR4__(v208 + v199, 25);
      v262 = v206 ^ __ROR4__(v210 + v236, 25);
      v190 = v200 ^ __ROR4__(v262 + v210, 23);
      v191 = v202 ^ __ROR4__(v211 + v208, 23);
      v192 = v201 ^ __ROR4__(v188 + v209, 23);
      v270 = v211;
      v198 = v203 ^ __ROR4__(v254 + v302, 23);
      v193 = v199 ^ __ROR4__(v191 + v211, 19);
      v195 = v246 ^ __ROR4__(v192 + v188, 19);
      v196 = v236 ^ __ROR4__(v190 + v262, 19);
      v189 = v278 ^ __ROR4__(v198 + v254, 19);
      v294 = v208 ^ __ROR4__(v193 + v191, 14);
      v286 = v210 ^ __ROR4__(v196 + v190, 14);
      v197 = v209 ^ __ROR4__(v195 + v192, 14);
      v194 = v302 ^ __ROR4__(v189 + v198, 14);
    }
    while ( !v28 );
    v28 = desta-- == 1;
    v108 = v294 + v316;
    src[17] = v270 + v328;
    src[18] = v191 + v340;
    src[19] = v193 + v352;
    src[20] = v196 + v364;
    src[21] = v286 + v376;
    src[23] = v190 + v400;
    src[22] = v262 + v388;
    src[24] = v192 + v412;
    src[25] = v195 + v424;
    src[26] = v197 + v430;
    src[16] = v294 + v316;
    src[27] = v188 + v436;
    src[29] = v198 + v450;
    src[28] = v254 + v444;
    src[30] = v189 + v458;
    src[31] = v194 + v464;
  }
  while ( !v28 );
  v526 = 1779033703;
  v527 = -1150833019;
  v528 = 1013904242;
  v529 = -1521486534;
  v530 = 1359893119;
  v531 = -1694144372;
  v532 = 528734635;
  v533 = 1541459225;
  sub_FBC8(&v526, a1, 1);
  v212 = a1[17];
  v213 = a1[18];
  v214 = a1[19];
  v545 = a1[16];
  v546 = v212;
  v547 = v213;
  v548 = v214;
  v549 = 128;
  v550 = 0;
  v551 = 0;
  v552 = 0;
  memset(v553, 0, 28);
  v553[7] = -2147352576;
  sub_FBC8(&v526, &v545, 1);
  v215 = v526;
  v216 = v527;
  v217 = v528;
  v218 = v529;
  a3[6] = 528734635;
  v535 = v215;
  v536 = v216;
  v537 = v217;
  v538 = v218;
  v219 = v530;
  v220 = v531;
  v221 = v532;
  v222 = v533;
  *a3 = 1779033703;
  a3[1] = -1150833019;
  a3[2] = 1013904242;
  a3[3] = -1521486534;
  a3[4] = 1359893119;
  a3[5] = -1694144372;
  a3[7] = 1541459225;
  v223 = desta;
  v539 = v219;
  v540 = v220;
  v541 = v221;
  v542 = v222;
  do
  {
    *(int *)((char *)&v545 + v223) = *(int *)((char *)&v535 + v223) ^ 0x5C5C5C5C;
    v223 += 4;
  }
  while ( v223 != 32 );
  memset(v553, 92, 32);
  sub_FBC8(a3, &v545, 0);
  v224 = 0;
  v526 = 1779033703;
  v527 = -1150833019;
  v528 = 1013904242;
  v529 = -1521486534;
  v530 = 1359893119;
  v531 = -1694144372;
  v532 = 528734635;
  v533 = 1541459225;
  do
  {
    *(int *)((char *)&v545 + v224) = *(int *)((char *)&v535 + v224) ^ 0x36363636;
    v224 += 4;
  }
  while ( v224 != 32 );
  memset(v553, 54, 32);
  sub_FBC8(&v526, &v545, 0);
  sub_FBC8(&v526, src, 1);
  sub_FBC8(&v526, &src[16], 1);
  sub_FBC8(&v526, dword_5AA04, 0);
  v545 = v526;
  v546 = v527;
  v547 = v528;
  v548 = v529;
  v549 = v530;
  v550 = v531;
  v551 = v532;
  v552 = v533;
  v553[0] = 0x80000000;
  memset(&v553[1], 0, 24);
  v553[7] = 768;
  return sub_FBC8(a3, &v545, 0);
}
// 5AA04: using guessed type int dword_5AA04[16];

//----- (00014D70) --------------------------------------------------------
const char *__fastcall sub_14D70(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_786A8, &dword_786A4) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( dword_786A8 > 23 || dword_786A4 > 59 || dword_786A8 < 0 || dword_786A4 < 0 )
    return "Invalid time set.";
  byte_7869C = 1;
  return 0;
}
// 7869C: using guessed type char byte_7869C;
// 786A4: using guessed type int dword_786A4;
// 786A8: using guessed type int dword_786A8;

//----- (00014DEC) --------------------------------------------------------
const char *__fastcall sub_14DEC(const char *a1)
{
  if ( sscanf(a1, "%d:%d", &dword_78424, &dword_78420) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( dword_78424 > 23 || dword_78420 > 59 || dword_78424 < 0 || dword_78420 < 0 )
    return "Invalid time set.";
  byte_78418 = 1;
  return 0;
}
// 78418: using guessed type char byte_78418;
// 78420: using guessed type int dword_78420;
// 78424: using guessed type int dword_78424;

//----- (00014E68) --------------------------------------------------------
int __fastcall sub_14E68(int a1)
{
  int i; // r1
  int result; // r0
  unsigned int *v4; // r2
  int v5[20]; // [sp+0h] [bp-20250h] BYREF
  _DWORD v6[32748]; // [sp+50h] [bp-20200h] BYREF

  v6[0] = 0;
  memset(&v6[1], 0, (size_t)sub_201FC);
  for ( i = 0; i != 19; ++i )
    v5[i] = bswap32(*(_DWORD *)(a1 + i * 4));
  v5[19] = bswap32(*(_DWORD *)(a1 + 76));
  result = sub_12220(v5, (int)v6, (int *)(a1 + 192));
  v4 = (unsigned int *)(a1 + 192);
  do
  {
    *v4 = bswap32(*v4);
    ++v4;
  }
  while ( v4 != (unsigned int *)(a1 + 224) );
  return result;
}

//----- (00014F08) --------------------------------------------------------
int __fastcall sub_14F08(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // r5
  int i; // r1
  unsigned int v5; // r4
  _BYTE v7[131592]; // [sp+8h] [bp-21284h] BYREF
  int v8[8]; // [sp+20210h] [bp-107Ch] BYREF
  int v9[20]; // [sp+20230h] [bp-105Ch] BYREF
  char v10[12]; // [sp+20280h] [bp-100Ch] BYREF

  v3 = *(_DWORD *)(a2 + 28);
  for ( i = 0; i != 19; ++i )
    v9[i] = bswap32(*(_DWORD *)(a1 + i * 4));
  v9[19] = bswap32(a3);
  sub_12220(v9, (int)v7, v8);
  v5 = bswap32(v8[7]);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v10, 0x1000u, "htarget %08lx diff1 %08lx hash %08lx", v3, 0xFFFF, v5);
    sub_385C8(7, v10, 0);
  }
  if ( v5 >= 0x10000 )
    return -1;
  else
    return v3 >= v5;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001519C) --------------------------------------------------------
int __fastcall sub_1519C(char *a1, size_t a2, time_t *a3)
{
  struct tm *v5; // r0
  time_t v7; // [sp+1Ch] [bp-8h] BYREF

  v7 = *a3;
  v5 = localtime(&v7);
  return snprintf(
           a1,
           a2,
           "[%d-%02d-%02d %02d:%02d:%02d]",
           v5->tm_year + 1900,
           v5->tm_mon + 1,
           v5->tm_mday,
           v5->tm_hour,
           v5->tm_min,
           v5->tm_sec);
}

//----- (00015218) --------------------------------------------------------
void sub_15218()
{
  int v0; // r7
  unsigned int v1; // r4
  int v2; // r8
  int *v3; // r6
  int *v4; // r3
  int v5; // t1
  unsigned int v6; // r2
  int v7; // t1
  unsigned int v8; // r5
  int v9; // r8
  int v10; // r6
  int v11; // r10
  _DWORD *v12; // t1
  char v13[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = dword_77FC0;
  if ( dword_77FC0 <= 0 )
  {
    v1 = 1;
  }
  else
  {
    v1 = -1;
    v2 = dword_78260 + 4 * dword_77FC0;
    v3 = (int *)dword_78260;
    v4 = (int *)dword_78260;
    do
    {
      v5 = *v4++;
      v6 = *(_DWORD *)(v5 + 56);
      if ( v6 && v1 >= v6 )
        v1 = v6;
    }
    while ( v4 != (int *)v2 );
    if ( v1 == -1 )
    {
      v1 = 1;
    }
    else
    {
      do
      {
        while ( 1 )
        {
          v7 = *v3++;
          v8 = *(_DWORD *)(v7 + 56);
          if ( v8 )
            break;
          if ( v3 == (int *)v2 )
            goto LABEL_13;
        }
        while ( v8 % v1 )
          --v1;
      }
      while ( v3 != (int *)v2 );
    }
LABEL_13:
    v9 = dword_78260 - 4;
    v10 = 0;
    v11 = dword_72430;
    do
    {
      v12 = *(_DWORD **)(v9 + 4);
      v9 += 4;
      ++v10;
      v12[16] = v12[16] * v11 / v1;
      v12[15] = v12[14] / v1;
    }
    while ( v10 < v0 );
  }
  dword_72430 = v1;
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v13, 0x1000u, "Global quota greatest common denominator set to %lu", v1);
    sub_385C8(7, v13, 0);
  }
}
// 72430: using guessed type int dword_72430;
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00015394) --------------------------------------------------------
char *__fastcall sub_15394(const char *a1, _DWORD *a2, int a3, int a4)
{
  char *result; // r0

  result = sub_586A0(a1, a2);
  if ( !result && (*a2 < a3 || *a2 > a4) )
    return "Value out of range";
  return result;
}

//----- (000153D4) --------------------------------------------------------
char *__fastcall sub_153D4(const char *a1)
{
  dword_73D34 = 2;
  return sub_15394(a1, &dword_78380, 0, 9999);
}
// 73D34: using guessed type int dword_73D34;
// 78380: using guessed type int dword_78380;

//----- (00015400) --------------------------------------------------------
char *__fastcall sub_15400(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 0, 9999);
}

//----- (0001540C) --------------------------------------------------------
char *__fastcall sub_1540C(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 0, 100);
}

//----- (00015418) --------------------------------------------------------
char *__fastcall sub_15418(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 1, 0xFFFF);
}

//----- (00015424) --------------------------------------------------------
char *__fastcall sub_15424(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 42, 62);
}

//----- (00015430) --------------------------------------------------------
char *__fastcall sub_15430(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 22, 55);
}

//----- (0001543C) --------------------------------------------------------
char *__fastcall sub_1543C(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 32, 63);
}

//----- (00015448) --------------------------------------------------------
char *__fastcall sub_15448(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 0, 4);
}

//----- (00015454) --------------------------------------------------------
char *__fastcall sub_15454(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 0, 200);
}

//----- (00015460) --------------------------------------------------------
char *__fastcall sub_15460(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 0, 255);
}

//----- (0001546C) --------------------------------------------------------
char *__fastcall sub_1546C(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 1, 10);
}

//----- (00015478) --------------------------------------------------------
char *__fastcall sub_15478(const char *a1, _DWORD *a2)
{
  return sub_15394(a1, a2, 0, 10);
}

//----- (00015484) --------------------------------------------------------
int __fastcall sub_15484(const char *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // r0

  result = sscanf(a1, "%d-%d", a2, a3);
  if ( result == 1 )
    *a3 = *a2;
  return result;
}

//----- (000154B4) --------------------------------------------------------
int __fastcall sub_154B4(int a1, char *a2)
{
  char *v5; // r0
  int v6; // r2

  sub_2A9C0(a1, a2);
  if ( !sub_2AAAC(a2, (_DWORD *)(a1 + 624), (char **)(a1 + 608)) || strncasecmp(a2, "stratum+tcp://", 0xEu) )
    return 0;
  v5 = _strdup(a2);
  v6 = *(_DWORD *)(a1 + 624);
  *(_BYTE *)(a1 + 664) = 1;
  *(_DWORD *)(a1 + 600) = v6;
  *(_DWORD *)(a1 + 196) = v5;
  return 1;
}

//----- (00015528) --------------------------------------------------------
const char *__fastcall sub_15528(const char *a1)
{
  if ( !a1 || !*a1 )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(a1, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  dword_73D38 = (int)a1;
  return 0;
}
// 73D38: using guessed type int dword_73D38;

//----- (00015580) --------------------------------------------------------
void *__fastcall sub_15580(void **a1)
{
  free(a1[444]);
  free(a1[449]);
  free(a1[454]);
  free(a1[452]);
  return memset(a1, 0, 0x7B0u);
}

//----- (000155BC) --------------------------------------------------------
char *__fastcall sub_155BC(int a1, int a2, int a3)
{
  int v4; // r7
  const char *v7; // r0
  const char *v8; // r0
  const char *v9; // r0
  char *result; // r0
  unsigned int v11[2]; // [sp+4h] [bp-8h] BYREF

  v4 = *(_DWORD *)(a1 + 1828);
  sub_15580((void **)a1);
  memcpy((void *)a1, (const void *)a2, 0x7B0u);
  *(_DWORD *)(a1 + 1828) = v4;
  v7 = *(const char **)(a2 + 1776);
  if ( v7 )
    *(_DWORD *)(a1 + 1776) = _strdup(v7);
  v8 = *(const char **)(a2 + 1808);
  if ( v8 )
    *(_DWORD *)(a1 + 1808) = _strdup(v8);
  v9 = *(const char **)(a2 + 1796);
  if ( v9 )
  {
    if ( a3 )
    {
      *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
      sub_29788(v11, *(unsigned __int8 **)(a2 + 1796), 4);
      v11[0] = bswap32(bswap32(v11[0]) + a3);
      *(_DWORD *)(a1 + 1796) = sub_29688((int)v11, 4);
    }
    else
    {
      *(_DWORD *)(a1 + 1796) = _strdup(v9);
    }
  }
  else if ( a3 )
  {
    *(_DWORD *)(a1 + 68) = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + a3);
  }
  result = *(char **)(a2 + 1816);
  if ( result )
  {
    result = _strdup(result);
    *(_DWORD *)(a1 + 1816) = result;
  }
  return result;
}

//----- (000156B8) --------------------------------------------------------
void __fastcall sub_156B8(void **a1)
{
  sub_15580(a1);
  free(a1);
}

//----- (000156D0) --------------------------------------------------------
int __fastcall sub_156D0(double a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double *v4; // r4

  v4 = (double *)LODWORD(a1);
  if ( v2 > 0.0 )
  {
    a1 = exp(a1);
    *v4 = (*v4 + (1.0 - 1.0 / (v2 / v3)) * (v1 / v2)) / (1.0 - 1.0 / (v2 / v3) + 1.0);
  }
  return LODWORD(a1);
}
// 156EC: variable 'v2' is possibly undefined
// 156F0: variable 'v3' is possibly undefined
// 15704: variable 'v1' is possibly undefined

//----- (00015724) --------------------------------------------------------
void __fastcall sub_15724(int a1)
{
  struct timeval v1; // [sp+0h] [bp-8h] BYREF

  if ( *(_DWORD *)(a1 + 368) )
  {
    sub_2A7A4(&v1);
    sub_2A97C();
  }
}

//----- (00015778) --------------------------------------------------------
void sub_15778()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_2A7A4(&v0);
  sub_2A97C();
}

//----- (000157A0) --------------------------------------------------------
void sub_157A0()
{
  struct timeval v0; // [sp+0h] [bp-Ch] BYREF

  sub_2A7A4(&v0);
  sub_2A97C();
}

//----- (000157C8) --------------------------------------------------------
int __fastcall sub_157C8(const char *a1)
{
  return wprintw((WINDOW *)dword_78258, "%s", a1);
}
// 78258: using guessed type int dword_78258;

//----- (000157E4) --------------------------------------------------------
_BYTE *__fastcall sub_157E4(int a1, unsigned int a2)
{
  _BYTE *result; // r0

  result = *(_BYTE **)(a1 + 1796);
  *(_DWORD *)(a1 + 68) = bswap32(a2);
  if ( result )
  {
    free(result);
    result = sub_29688(a1 + 68, 4);
    *(_DWORD *)(a1 + 1796) = result;
  }
  return result;
}

//----- (0001581C) --------------------------------------------------------
__int64 __fastcall sub_1581C(__int64 *a1)
{
  __int64 v2; // r0
  double v3; // d9
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d8
  double v8; // r0
  double v9; // d17
  double v10; // r0
  double v11; // d8
  int v12; // r1
  __int64 v13; // d16

  if ( !a1 )
    return 0;
  v2 = a1[27];
  v3 = 1.7668201e72;
  if ( !byte_78681 )
    v3 = 2.69595353e67;
  LODWORD(v4) = sub_59F08(v2);
  v5 = v4 * 6.27710174e57;
  LODWORD(v6) = sub_59F08(a1[26]);
  v7 = v5 + v6 * 3.40282367e38;
  LODWORD(v8) = sub_59F08(a1[25]);
  v9 = v8;
  LODWORD(v10) = sub_59F08(a1[24]);
  v11 = v7 + v9 * 1.84467441e19 + v10;
  if ( v11 == 0.0 )
    return 0;
  LODWORD(v13) = sub_5A000(v3 / v11);
  HIDWORD(v13) = v12;
  return v13;
}
// 15858: variable 'v4' is possibly undefined
// 1586C: variable 'v6' is possibly undefined
// 15878: variable 'v8' is possibly undefined
// 1588C: variable 'v10' is possibly undefined
// 158A8: variable 'v12' is possibly undefined
// 78681: using guessed type char byte_78681;

//----- (000158EC) --------------------------------------------------------
void __fastcall sub_158EC(int a1)
{
  int v2; // r3
  char v3[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( *(_BYTE *)(a1 + 1761) || *(_DWORD *)(a1 + 1728) || *(_BYTE *)(a1 + 1760) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(v3, "Discarded cloned or rolled work");
      sub_385C8(7, v3, 0);
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 1748);
    if ( v2 )
    {
      ++*(_DWORD *)(v2 + 156);
      --*(_DWORD *)(*(_DWORD *)(a1 + 1748) + 64);
      --*(_DWORD *)(*(_DWORD *)(a1 + 1748) + 68);
    }
    ++*(_QWORD *)&dword_785F0;
  }
  sub_156B8((void **)a1);
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 785F0: using guessed type int dword_785F0;

//----- (00015A00) --------------------------------------------------------
int __fastcall sub_15A00(int result)
{
  int v1; // r5
  int v2; // r7
  int *v3; // r3
  int v4; // r4
  int v5; // r1
  int v6; // t1
  int v7; // r2
  bool v8; // cc
  int v9; // r2
  int v10; // r3

  v1 = dword_77FC0;
  v2 = dword_77FC0 - 1;
  if ( dword_77FC0 > 0 )
  {
    v3 = (int *)dword_78260;
    v4 = dword_78260 + 4 * dword_77FC0;
    do
    {
      v6 = *v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= *(_DWORD *)(result + 4);
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != (int *)v4 );
  }
  if ( v2 > *(_DWORD *)result )
  {
    **(_DWORD **)(dword_78260 + 4 * v2) = *(_DWORD *)result;
    *(_DWORD *)(dword_78260 + 4 * *(_DWORD *)result) = *(_DWORD *)(dword_78260 + 4 * v2);
    v1 = dword_77FC0;
  }
  *(_DWORD *)result = v1;
  v10 = dword_77FC0;
  *(_BYTE *)(result + 137) = 1;
  dword_77FC0 = v10 - 1;
  return result;
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00015A9C) --------------------------------------------------------
void __fastcall sub_15A9C(FILE *s)
{
  const char *v1; // r11
  int v3; // r5
  const char *v4; // r10
  const char *v5; // r0
  const char *v6; // r9
  const char *v7; // r0
  const char *v8; // r0
  int v9; // r7
  const char *v10; // r0
  const char *v11; // r0
  const char *v12; // r0
  int v13; // r0
  int v14; // r4
  const char *v15; // r7
  const char *v16; // r0
  const char *v17; // r9
  const char *v18; // r0
  const char *v19; // r0
  int v20; // r3
  const char *v21; // r10
  const char *v22; // r0
  const char **v23; // r5
  char *v24; // r8
  char *v25; // r4
  int v26; // r2
  int (__fastcall *v27)(_BYTE *); // r3
  char *(__fastcall *v28)(const char *, float *); // r3
  const char **v29; // r3
  const char *v30; // r0
  int v31; // r1
  int v32; // r4
  int v33; // r5
  const char *v34; // [sp+14h] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, s);
  if ( dword_77FC0 > 0 )
  {
    v3 = 0;
    while ( 1 )
    {
      v13 = sub_11F70(v3);
      v9 = *(_DWORD *)(v13 + 56);
      v14 = v13;
      if ( v9 == 1 )
      {
        v15 = ",";
        if ( !v3 )
          v15 = "";
        if ( *(_DWORD *)(v13 + 216) )
        {
          v16 = sub_295E8(*(char **)(v13 + 212));
          v17 = sub_F7DC(v16);
          v18 = *(const char **)(v14 + 216);
          if ( v18 )
          {
            v19 = sub_F7DC(v18);
            v20 = *(_DWORD *)(v14 + 216);
            if ( v20 )
              v1 = delim;
            v21 = v19;
            if ( v20 )
              goto LABEL_20;
            goto LABEL_69;
          }
        }
        else
        {
          v17 = "";
        }
        v21 = "";
LABEL_69:
        v1 = "";
LABEL_20:
        v22 = sub_F7DC(*(const char **)(v14 + 196));
        fprintf(s, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v17, v21, v1, v22);
        goto LABEL_11;
      }
      v4 = ",";
      if ( !v3 )
        v4 = "";
      if ( !*(_DWORD *)(v13 + 216) )
        break;
      v5 = sub_295E8(*(char **)(v13 + 212));
      v6 = sub_F7DC(v5);
      v7 = *(const char **)(v14 + 216);
      if ( !v7 )
      {
        v9 = *(_DWORD *)(v14 + 56);
        goto LABEL_22;
      }
      v8 = sub_F7DC(v7);
      v9 = *(_DWORD *)(v14 + 56);
      v1 = v8;
      if ( !*(_DWORD *)(v14 + 216) )
        goto LABEL_23;
      v34 = delim;
LABEL_10:
      v10 = sub_F7DC(*(const char **)(v14 + 196));
      fprintf(s, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v4, v6, v1, v34, v9, v10);
LABEL_11:
      ++v3;
      v11 = sub_F7DC(*(const char **)(v14 + 204));
      fprintf(s, "\n\t\t\"user\" : \"%s\",", v11);
      v12 = sub_F7DC(*(const char **)(v14 + 208));
      fprintf(s, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
      if ( dword_77FC0 <= v3 )
        goto LABEL_24;
    }
    v6 = "";
LABEL_22:
    v1 = "";
LABEL_23:
    v34 = "";
    goto LABEL_10;
  }
LABEL_24:
  fwrite("\n]\n", 1u, 3u, s);
  if ( dword_72444 != 16 )
  {
    v23 = (const char **)&unk_7245C;
    while ( 1 )
    {
      v24 = _strdup(*(v23 - 7));
      v25 = strtok(v24, delim);
      if ( v25 )
        break;
LABEL_53:
      v23 += 7;
      free(v24);
      if ( *(v23 - 6) == (const char *)16 )
        goto LABEL_54;
    }
    while ( 1 )
    {
      if ( v25[1] == 45 && *(v23 - 1) != (const char *)&unk_9A558 )
      {
        v26 = (int)*(v23 - 6);
        if ( (v26 & 1) != 0
          && ((v27 = (int (__fastcall *)(_BYTE *))*(v23 - 5), v27 == sub_584B4) || v27 == sub_584C4)
          && **(v23 - 2) == (v27 == sub_584B4) )
        {
          fprintf(s, ",\n\"%s\" : true", v25 + 2);
        }
        else
        {
          if ( (v26 & 2) == 0 )
            goto LABEL_49;
          v28 = (char *(__fastcall *)(const char *, float *))*(v23 - 4);
          if ( (char *)v28 == (char *)sub_586A0
            || (char *)v28 == (char *)sub_15400
            || (char *)v28 == (char *)sub_15418
            || (char *)v28 == (char *)sub_15478
            || (char *)v28 == (char *)sub_1546C
            || (char *)v28 == (char *)sub_1540C
            || (char *)v28 == (char *)sub_15460
            || (char *)v28 == (char *)sub_15454
            || (char *)v28 == (char *)sub_15448
            || (char *)v28 == (char *)sub_1543C
            || (char *)v28 == (char *)sub_15430
            || (char *)v28 == (char *)sub_15424 )
          {
            fprintf(s, ",\n\"%s\" : \"%d\"", v25 + 2, *(_DWORD *)*(v23 - 2));
          }
          else
          {
            if ( v28 != sub_12138 && v28 != sub_120E8 )
            {
LABEL_49:
              if ( (v26 & 6) != 0 )
              {
                v29 = (const char **)*(v23 - 2);
                if ( v29 != (const char **)&unk_73D4C )
                {
                  if ( *v29 )
                  {
                    v30 = sub_F7DC(*v29);
                    fprintf(s, ",\n\"%s\" : \"%s\"", v25 + 2, v30);
                  }
                }
              }
              goto LABEL_28;
            }
            fprintf(s, ",\n\"%s\" : \"%.1f\"", v25 + 2, *(float *)*(v23 - 2));
          }
        }
      }
LABEL_28:
      v25 = strtok(0, delim);
      if ( !v25 )
        goto LABEL_53;
    }
  }
LABEL_54:
  v31 = dword_73D34;
  if ( dword_73D34 == 4 )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, s);
    v31 = dword_73D34;
    if ( dword_73D34 != 3 )
      goto LABEL_56;
  }
  else if ( dword_73D34 != 3 )
  {
    goto LABEL_56;
  }
  fwrite(",\n\"load-balance\" : true", 1u, 0x17u, s);
  v31 = dword_73D34;
LABEL_56:
  if ( v31 == 1 )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, s);
    v31 = dword_73D34;
  }
  if ( v31 == 2 )
    fprintf(s, ",\n\"rotate\" : \"%d\"", dword_78380);
  fwrite("\n}\n", 1u, 3u, s);
  v32 = dword_73A10;
  dword_73A10 = 0;
  if ( v32 )
  {
    do
    {
      v33 = *(_DWORD *)(v32 + 4);
      free(*(void **)v32);
      free((void *)v32);
      v32 = v33;
    }
    while ( v33 );
  }
}
// 15C20: variable 'v1' is possibly undefined
// 72444: using guessed type int dword_72444;
// 73A10: using guessed type int dword_73A10;
// 73D34: using guessed type int dword_73D34;
// 77FC0: using guessed type int dword_77FC0;
// 78380: using guessed type int dword_78380;

//----- (00015FEC) --------------------------------------------------------
int sub_15FEC()
{
  int result; // r0
  int *v1; // r3
  int v2; // r1
  int v3; // t1

  dword_72C04 = 0;
  dword_72C08 = 0;
  dword_73D50 = 0;
  dword_73D54 = 0;
  result = sub_114B8(0, (char *)&dword_72C04, 8u, 0);
  if ( dword_77FC0 > 0 )
  {
    result = 0;
    v1 = (int *)dword_78260;
    v2 = dword_78260 + 4 * dword_77FC0;
    do
    {
      v3 = *v1++;
      *(_DWORD *)(v3 + 400) = 0;
      *(_DWORD *)(v3 + 404) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  return result;
}
// 72C04: using guessed type int dword_72C04;
// 72C08: using guessed type int dword_72C08;
// 73D50: using guessed type int dword_73D50;
// 73D54: using guessed type int dword_73D54;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00016088) --------------------------------------------------------
char *__fastcall sub_16088(char *a1)
{
  size_t v2; // r0
  char *v3; // r12
  size_t v4; // r5
  char *v6; // r0

  if ( dword_73A14 && *(_BYTE *)dword_73A14 )
    return strcpy(a1, (const char *)dword_73A14);
  if ( getenv("HOME") && *getenv("HOME") )
  {
    v6 = getenv("HOME");
    *(_WORD *)stpcpy(a1, v6) = 47;
  }
  else
  {
    *a1 = 0;
  }
  strcat(a1, ".cgminer/");
  mkdir(a1, 0x1FFu);
  v2 = strlen(a1);
  v3 = &a1[v2];
  v4 = v2;
  *(_DWORD *)&a1[v4] = *(_DWORD *)"cgminer.conf";
  strcpy(v3 + 4, "ner.conf");
  return *(char **)"cgminer.conf";
}
// AC00: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 73A14: using guessed type int dword_73A14;

//----- (0001617C) --------------------------------------------------------
int __fastcall sub_1617C(int a1)
{
  double v1; // d0
  double v3; // d8
  double v4; // d8
  __int64 v5; // r0
  double v6; // r0
  double v7; // d8
  __int64 v8; // r0
  double v9; // r0
  double v10; // d8
  __int64 v11; // r0
  double v12; // r0
  int v13; // r1
  int v14; // r1
  __int64 v15; // r2
  __int64 v16; // r0
  __int64 v17; // r2
  char *v18; // r6
  unsigned int v20; // [sp+0h] [bp-1020h] BYREF
  int v21; // [sp+4h] [bp-101Ch]
  __int64 v22; // [sp+8h] [bp-1018h]
  __int64 v23; // [sp+10h] [bp-1010h]
  __int64 v24; // [sp+18h] [bp-1008h]
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( v1 == 0.0 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      strcpy(s, "Diff zero passed to set_target");
      sub_385C8(3, s, 0);
      v1 = 1.0;
    }
    else
    {
      v1 = 1.0;
    }
  }
  v3 = 1.7668201e72;
  if ( !byte_78681 )
    v3 = 2.69595353e67;
  v4 = v3 / v1;
  LODWORD(v5) = sub_5A000(v4 * 1.59309191e-58);
  v24 = v5;
  LODWORD(v6) = sub_59F08(v5);
  v7 = v4 - v6 * 6.27710174e57;
  LODWORD(v8) = sub_5A000(v7 * 2.93873588e-39);
  v23 = v8;
  LODWORD(v9) = sub_59F08(v8);
  v10 = v7 - v9 * 3.40282367e38;
  LODWORD(v11) = sub_5A000(v10 * 5.42101086e-20);
  v22 = v11;
  LODWORD(v12) = sub_59F08(v11);
  v20 = sub_5A000(v10 - v12 * 1.84467441e19);
  v21 = v13;
  if ( byte_75C49 )
  {
    v18 = sub_29688((int)&v20, 32);
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "Generated target %s", v18);
      sub_385C8(7, s, 0);
    }
    free(v18);
  }
  v14 = v21;
  v15 = v22;
  *(_DWORD *)a1 = v20;
  *(_DWORD *)(a1 + 4) = v14;
  *(_QWORD *)(a1 + 8) = v15;
  v16 = v23;
  v17 = v24;
  *(_QWORD *)(a1 + 16) = v23;
  *(_QWORD *)(a1 + 24) = v17;
  return v16;
}
// 16198: variable 'v1' is possibly undefined
// 161CC: variable 'v5' is possibly undefined
// 161E0: variable 'v6' is possibly undefined
// 161F0: variable 'v8' is possibly undefined
// 16204: variable 'v9' is possibly undefined
// 16214: variable 'v11' is possibly undefined
// 16228: variable 'v12' is possibly undefined
// 1623C: variable 'v13' is possibly undefined
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78681: using guessed type char byte_78681;

//----- (000163CC) --------------------------------------------------------
int __fastcall sub_163CC(char *a1, unsigned __int64 a2)
{
  bool v3; // cf
  char v4; // r3
  int v6; // r4
  size_t v7; // r2
  unsigned __int64 v8; // [sp+0h] [bp-Ch] BYREF

  v8 = a2;
  if ( a2 > 0xFC )
  {
    if ( a2 <= 0xFFFF )
    {
      v6 = 3;
      *a1 = -3;
      v7 = 2;
    }
    else
    {
      v3 = HIDWORD(a2) == 0;
      if ( !HIDWORD(a2) )
        v3 = 1;
      if ( v3 )
      {
        v6 = 5;
        v7 = 4;
      }
      else
      {
        v6 = 9;
        v7 = 8;
      }
      if ( v3 )
        v4 = -2;
      else
        v4 = -1;
      *a1 = v4;
    }
  }
  else
  {
    *a1 = a2;
    v6 = 1;
    v7 = 0;
  }
  memcpy(a1 + 1, &v8, v7);
  return v6;
}

//----- (0001646C) --------------------------------------------------------
int __fastcall sub_1646C(int a1)
{
  return dword_78770 - *(_DWORD *)(a1 + 232);
}
// 78770: using guessed type int dword_78770;

//----- (00016484) --------------------------------------------------------
bool __fastcall sub_16484(int a1, int a2)
{
  unsigned int v3; // r0

  *(_DWORD *)(a1 + 76) = a2;
  if ( byte_78681 )
    sub_14E68(a1);
  else
    sub_11E98(a1);
  if ( byte_78681 )
    v3 = 0xFFFF;
  else
    v3 = 0;
  return v3 >= *(_DWORD *)(a1 + 220);
}
// 78681: using guessed type char byte_78681;

//----- (000164D8) --------------------------------------------------------
bool __fastcall sub_164D8(int a1, int a2)
{
  double v2; // d0
  double v4; // d16
  unsigned __int64 v5; // r0

  *(_DWORD *)(a1 + 76) = a2;
  if ( byte_78681 )
    sub_14E68(a1);
  else
    sub_11E98(a1);
  v4 = 2.81470682e14;
  if ( !byte_78681 )
    v4 = 4294901760.0;
  LODWORD(v5) = sub_5A000(v4 / v2);
  return v5 >= *(_QWORD *)(a1 + 216);
}
// 16518: variable 'v2' is possibly undefined
// 1652C: variable 'v5' is possibly undefined
// 78681: using guessed type char byte_78681;

//----- (0001655C) --------------------------------------------------------
unsigned int __fastcall sub_1655C(int a1, int a2)
{
  int v4; // r5
  int v5; // r12
  int v6; // r3
  unsigned int v7; // r2
  unsigned int result; // r0
  int v9; // r1
  unsigned int v10; // r2
  unsigned int v11; // r3
  unsigned int v12; // r1
  unsigned int v13; // r1
  int v14; // r3
  int v15; // r2
  int v16; // r2
  int v17; // r1
  int v18; // r3
  int v19; // r3
  size_t v20; // r4
  _DWORD *v21; // r0
  _DWORD *v22; // r6
  int v23; // r3
  int v24; // r8
  int v25; // r3
  unsigned int v26; // r5
  _DWORD *v27; // r4
  _DWORD *v28; // r9
  int v29; // r5
  char *v30; // r7
  unsigned int v31; // r2
  int v32; // r3
  _DWORD *v33; // r3
  unsigned int v34; // r1
  unsigned int v35; // r2
  bool v36; // cc
  int v37; // r2
  int v38; // r3
  int v39; // r6
  void *v40; // r0
  void **v41; // r6
  void *v42; // r0
  unsigned int i; // [sp+4h] [bp-8h]

  ++*(_DWORD *)(a1 + 360);
  *(_DWORD *)(a2 + 1840) = 0;
  *(_DWORD *)(a2 + 1852) = a2 + 1828;
  *(_DWORD *)(a2 + 1856) = 4;
  v4 = *(_DWORD *)(a1 + 352);
  if ( v4 )
  {
    v5 = a2 + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 1832) + 16) + 8) = a2;
    *(_DWORD *)(a2 + 1836) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 16)
                           - *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 20);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 16) = a2 + 1832;
  }
  else
  {
    *(_DWORD *)(a1 + 352) = a2;
    *(_DWORD *)(a2 + 1836) = 0;
    v39 = *(_DWORD *)(a1 + 352);
    *(_DWORD *)(v39 + 1832) = malloc(0x2Cu);
    v40 = *(void **)(*(_DWORD *)(a1 + 352) + 1832);
    if ( !v40 )
      goto LABEL_31;
    memset(v40, 0, 0x2Cu);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 16) = *(_DWORD *)(a1 + 352) + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 4) = 32;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 8) = 5;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 20) = 1832;
    v41 = *(void ***)(*(_DWORD *)(a1 + 352) + 1832);
    *v41 = malloc(0x180u);
    v42 = **(void ***)(*(_DWORD *)(a1 + 352) + 1832);
    if ( !v42 )
      goto LABEL_31;
    memset(v42, 0, 0x180u);
    v5 = a2 + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 12);
  v6 = (*(unsigned __int8 *)(a2 + 1828)
      + 17973517
      + (*(unsigned __int8 *)(a2 + 1831) << 24)
      + (*(unsigned __int8 *)(a2 + 1830) << 16)
      + (*(unsigned __int8 *)(a2 + 1829) << 8))
     ^ 0x7F76D;
  v7 = (-1622558010 - v6) ^ (v6 << 8);
  result = (-17973517 - v6 - v7) ^ (v7 >> 13);
  *(_DWORD *)(a2 + 1832) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832);
  v9 = (v6 - v7 - result) ^ (result >> 12);
  v10 = (v7 - result - v9) ^ (v9 << 16);
  v11 = (result - v9 - v10) ^ (v10 >> 5);
  v12 = v9 - v10 - v11;
  v13 = (v11 - (v12 ^ (v11 >> 3)) - ((v10 - v11 - (v12 ^ (v11 >> 3))) ^ ((v12 ^ (v11 >> 3)) << 10)))
      ^ (((v10 - v11 - (v12 ^ (v11 >> 3))) ^ ((v12 ^ (v11 >> 3)) << 10)) >> 15);
  *(_DWORD *)(a2 + 1860) = v13;
  v14 = 12 * (v13 & (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 4) - 1));
  v15 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  ++*(_DWORD *)(v15 + 4);
  v16 = *(_DWORD *)(**(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14);
  *(_DWORD *)(a2 + 1844) = 0;
  *(_DWORD *)(a2 + 1848) = v16;
  v17 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  if ( *(_DWORD *)v17 )
  {
    *(_DWORD *)(*(_DWORD *)v17 + 12) = v5;
    v17 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  }
  *(_DWORD *)v17 = v5;
  v18 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832) + v14;
  if ( *(_DWORD *)(v18 + 4) >= (unsigned int)(10 * (*(_DWORD *)(v18 + 8) + 1)) )
  {
    v19 = *(_DWORD *)(a2 + 1832);
    if ( *(_DWORD *)(v19 + 36) != 1 )
    {
      v20 = 24 * *(_DWORD *)(v19 + 4);
      v21 = malloc(v20);
      v22 = v21;
      if ( v21 )
      {
        memset(v21, 0, v20);
        v23 = *(_DWORD *)(a2 + 1832);
        v24 = 0;
        *(_DWORD *)(v23 + 24) = (((2 * *(_DWORD *)(v23 + 4) - 1) & *(_DWORD *)(v23 + 12)) != 0)
                              + (*(_DWORD *)(v23 + 12) >> (*(_BYTE *)(v23 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a2 + 1832) + 28) = 0;
        v25 = *(_DWORD *)(a2 + 1832);
        v26 = *(_DWORD *)(v25 + 4);
        if ( v26 )
        {
          for ( i = 0; i < v26; ++i )
          {
            v27 = *(_DWORD **)(*(_DWORD *)v25 + v24);
            if ( v27 )
            {
              while ( 1 )
              {
                v28 = (_DWORD *)v27[4];
                v29 = 3 * ((2 * v26 - 1) & v27[7]);
                v30 = (char *)&v22[v29];
                v31 = *((_DWORD *)v30 + 1) + 1;
                *((_DWORD *)v30 + 1) = v31;
                if ( v31 > *(_DWORD *)(v25 + 24) )
                {
                  ++*(_DWORD *)(v25 + 28);
                  *((_DWORD *)v30 + 2) = *((_DWORD *)v30 + 1) / *(_DWORD *)(*(_DWORD *)(a2 + 1832) + 24);
                }
                v27[3] = 0;
                v27[4] = v22[v29];
                v32 = v22[v29];
                if ( v32 )
                  *(_DWORD *)(v32 + 12) = v27;
                v22[v29] = v27;
                v25 = *(_DWORD *)(a2 + 1832);
                if ( !v28 )
                  break;
                v26 = *(_DWORD *)(v25 + 4);
                v27 = v28;
              }
              v26 = *(_DWORD *)(v25 + 4);
            }
            v24 += 12;
          }
        }
        free(*(void **)v25);
        *(_DWORD *)(*(_DWORD *)(a2 + 1832) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a2 + 1832) + 8);
        **(_DWORD **)(a2 + 1832) = v22;
        v33 = *(_DWORD **)(a2 + 1832);
        v34 = v33[3];
        v35 = v33[7];
        v36 = v35 > v34 >> 1;
        if ( v35 <= v34 >> 1 )
          v37 = 0;
        else
          v37 = v33[8];
        if ( v36 )
          ++v37;
        v33[8] = v37;
        v38 = *(_DWORD *)(a2 + 1832);
        if ( *(_DWORD *)(v38 + 32) > 1u )
          *(_DWORD *)(v38 + 36) = 1;
        return result;
      }
LABEL_31:
      exit(-1);
    }
  }
  return result;
}

//----- (000169B8) --------------------------------------------------------
int __fastcall sub_169B8(int a1, void *s2, size_t n, const void *a4, int a5, size_t a6)
{
  int v6; // r5
  int v10; // r4

  v6 = a1;
  if ( a1 )
  {
    v10 = *(_DWORD *)(a1 + 1840);
    while ( memcmp((const void *)(v6 + 128), s2, n) || memcmp((const void *)(v6 + a5), a4, a6) )
    {
      v6 = v10;
      if ( !v10 )
        return 0;
      v10 = *(_DWORD *)(v10 + 1840);
    }
  }
  return v6;
}

//----- (00016A78) --------------------------------------------------------
void __fastcall sub_16A78(int a1, _DWORD *a2)
{
  int v3; // r3
  int v4; // r0
  int v5; // r12
  bool v6; // zf
  int v7; // r0
  int v8; // r0
  int v9; // r3
  int v10; // r0
  int v11; // r3
  int v12; // r3

  --*(_DWORD *)(a1 + 360);
  v3 = a2[459];
  if ( v3 || a2[460] )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832);
    v5 = *(_DWORD *)(v4 + 20);
    if ( (_DWORD *)(*(_DWORD *)(v4 + 16) - v5) == a2 )
    {
      *(_DWORD *)(v4 + 16) = v3 + v5;
      v3 = a2[459];
    }
    v6 = v3 == 0;
    if ( v3 )
    {
      v5 = *(_DWORD *)(a1 + 352);
      v4 = a2[460];
    }
    else
    {
      v3 = a2[460];
    }
    if ( v6 )
      *(_DWORD *)(a1 + 352) = v3;
    else
      v5 = *(_DWORD *)(v5 + 1832);
    if ( !v6 )
    {
      v3 += *(_DWORD *)(v5 + 20);
      *(_DWORD *)(v3 + 8) = v4;
    }
    v7 = a2[460];
    if ( !v6 )
      v3 = *(_DWORD *)(a1 + 352);
    if ( v7 )
    {
      *(_DWORD *)(v7 + *(_DWORD *)(*(_DWORD *)(v3 + 1832) + 20) + 4) = a2[459];
      v3 = *(_DWORD *)(a1 + 352);
    }
    v8 = **(_DWORD **)(v3 + 1832);
    v9 = 12 * ((*(_DWORD *)(*(_DWORD *)(v3 + 1832) + 4) - 1) & a2[465]);
    --*(_DWORD *)(v8 + v9 + 4);
    v10 = **(_DWORD **)(*(_DWORD *)(a1 + 352) + 1832);
    if ( *(_DWORD **)(v10 + v9) == a2 + 458 )
      *(_DWORD *)(v10 + v9) = a2[462];
    v11 = a2[461];
    if ( v11 )
      *(_DWORD *)(v11 + 16) = a2[462];
    v12 = a2[462];
    if ( v12 )
      *(_DWORD *)(v12 + 12) = a2[461];
    --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 1832) + 12);
  }
  else
  {
    free(**(void ***)(*(_DWORD *)(a1 + 352) + 1832));
    free(*(void **)(*(_DWORD *)(a1 + 352) + 1832));
    *(_DWORD *)(a1 + 352) = 0;
  }
}

//----- (00016BC0) --------------------------------------------------------
int __fastcall sub_16BC0(int result)
{
  if ( *(_DWORD *)(result + 32) != 1 )
    return (*(int (**)(void))(*(_DWORD *)(result + 4) + 16))();
  return result;
}

//----- (00016BE0) --------------------------------------------------------
void __fastcall __noreturn sub_16BE0(int a1)
{
  sub_1D26C(a1, 1);
}

//----- (00016BE8) --------------------------------------------------------
char *__fastcall sub_16BE8(char *a1)
{
  int *v2; // r0
  size_t v3; // r6
  size_t v4; // r6
  char *v5; // r0
  char *v6; // r4
  char v8[92]; // [sp+Ch] [bp-10FCh] BYREF
  char s[160]; // [sp+68h] [bp-10A0h] BYREF
  char v10[4096]; // [sp+108h] [bp-1000h] BYREF

  v2 = sub_567C4(a1, 0, v8);
  if ( v2 && !*v2 )
  {
    byte_73D58 = 1;
    return sub_16D24(v2, 1);
  }
  else
  {
    v3 = strlen(a1);
    v4 = v3 + strlen(s) + 35;
    v5 = (char *)malloc(v4);
    v6 = v5;
    if ( !v5 )
    {
      strcpy(v10, "Malloc failure in json error");
      sub_385C8(3, v10, 1);
      sub_16BE0(1);
    }
    snprintf(v5, v4, "JSON decode of file '%s' failed\n %s", a1, s);
  }
  return v6;
}
// 73D58: using guessed type char byte_73D58;

//----- (00016CD0) --------------------------------------------------------
char *__fastcall sub_16CD0(char *s)
{
  if ( !dword_73D5C )
    dword_73D5C = (int)_strdup(s);
  if ( ++dword_73D60 <= 10 )
    return sub_16BE8(s);
  else
    return "Too many levels of JSON includes (limit 10) or a loop";
}
// 73D5C: using guessed type int dword_73D5C;
// 73D60: using guessed type int dword_73D60;

//----- (00016D24) --------------------------------------------------------
char *__fastcall sub_16D24(_DWORD *a1, int a2)
{
  _DWORD *v4; // r6
  const char *v5; // r0
  char *v6; // r11
  _DWORD *v7; // r0
  _DWORD *v8; // r5
  int v9; // r2
  const char *v10; // r2
  int v11; // r3
  unsigned int v12; // r4
  _DWORD *v13; // r0
  _DWORD *v15; // r11
  _DWORD *v16; // r4
  _DWORD *v17; // r0
  char *v18; // r0
  const char *v19; // [sp+Ch] [bp-1010h]
  const char *v20; // [sp+Ch] [bp-1010h]
  char *ptr; // [sp+10h] [bp-100Ch]
  char *v22; // [sp+14h] [bp-1008h]
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( a2 && !dword_73E2C )
    dword_73E2C = 1;
  if ( dword_72444 == 16 )
    goto LABEL_46;
  if ( (dword_72444 & 8) != 0 )
    goto LABEL_28;
  v4 = &unk_7245C;
  while ( 2 )
  {
    v5 = (const char *)*(v4 - 7);
    if ( !v5 )
      goto LABEL_26;
    ptr = _strdup(v5);
    v6 = strtok(ptr, delim);
    if ( !v6 )
      goto LABEL_25;
    while ( 2 )
    {
      if ( v6[1] != 45 )
        goto LABEL_10;
      v7 = (_DWORD *)sub_571D8(a1, v6 + 2);
      v8 = v7;
      if ( !v7 )
        goto LABEL_10;
      v9 = *(v4 - 6);
      if ( (v9 & 6) == 0 )
        goto LABEL_17;
      if ( *v7 == 2 )
      {
        v16 = sub_57530(v7);
        v10 = (const char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v4 - 4))(v16, *(v4 - 2));
        if ( *(v4 - 6) == 4 )
        {
          v20 = v10;
          sub_5858C((int)v16, (_DWORD *)*(v4 - 2));
          v10 = v20;
        }
        goto LABEL_43;
      }
      if ( *v7 != 1 )
      {
LABEL_17:
        if ( (v9 & 1) == 0 || *v7 != 5 )
        {
          v10 = "Invalid value";
          goto LABEL_19;
        }
        v10 = (const char *)((int (__fastcall *)(_DWORD))*(v4 - 5))(*(v4 - 2));
LABEL_43:
        if ( !v10 )
          goto LABEL_10;
LABEL_19:
        if ( !a2 )
          goto LABEL_38;
        goto LABEL_20;
      }
      v12 = 0;
      v22 = v6;
      while ( 1 )
      {
        if ( v12 >= (unsigned int)sub_573A4(v8) )
          goto LABEL_10;
        v13 = sub_573C0(v8, v12);
        if ( !v13 )
          goto LABEL_10;
        if ( *v13 == 2 )
        {
          v15 = sub_57530(v13);
          v10 = (const char *)((int (__fastcall *)(_DWORD *, _DWORD))*(v4 - 4))(v15, *(v4 - 2));
          if ( *(v4 - 6) == 4 )
          {
            v19 = v10;
            sub_5858C((int)v15, (_DWORD *)*(v4 - 2));
            v10 = v19;
          }
        }
        else
        {
          if ( *v13 )
            goto LABEL_30;
          v10 = (const char *)sub_16D24();
        }
        if ( v10 )
          break;
LABEL_30:
        ++v12;
      }
      v6 = v22;
      if ( !a2 )
      {
LABEL_38:
        snprintf(byte_73D64, 0xC8u, "Parsing JSON option %s: %s", v6, v10);
        return byte_73D64;
      }
LABEL_20:
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        snprintf(s, 0x1000u, "Invalid config option %s: %s", v6, v10);
        sub_385C8(3, s, 0);
      }
      dword_73E2C = -1;
LABEL_10:
      v6 = strtok(0, delim);
      if ( v6 )
        continue;
      break;
    }
LABEL_25:
    free(ptr);
LABEL_26:
    v11 = v4[1];
    if ( v11 != 16 )
    {
      v4 += 7;
      if ( (v11 & 8) != 0 )
LABEL_28:
        _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x7A0u, "parse_config");
      continue;
    }
    break;
  }
LABEL_46:
  v17 = (_DWORD *)sub_571D8(a1, "include");
  if ( !v17 )
    return 0;
  if ( *v17 != 2 )
    return 0;
  v18 = (char *)sub_57530(v17);
  return (char *)sub_16CD0(v18);
}
// 72444: using guessed type int dword_72444;
// 73504: using guessed type int dword_73504;
// 73E2C: using guessed type int dword_73E2C;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00017038) --------------------------------------------------------
int __fastcall sub_17038(int a1, char *a2)
{
  char *v3; // r5
  int result; // r0
  char *v5; // r0
  char *v6; // r6
  char v7[4096]; // [sp+0h] [bp-1000h] BYREF

  v3 = sub_2AC38(a2, a1);
  result = sub_154B4(a1, v3);
  if ( !result )
  {
    sub_5858C((int)v3, (_DWORD *)(a1 + 196));
    result = strncmp(v3, "http://", 7u);
    if ( result )
    {
      result = strncmp(v3, "https://", 8u);
      if ( result )
      {
        v5 = (char *)malloc(0x100u);
        v6 = v5;
        if ( !v5 )
        {
          strcpy(v7, "Failed to malloc httpinput");
          sub_385C8(3, v7, 1);
          sub_16BE0(1);
        }
        strcpy(v5, "stratum+tcp://");
        strncat(v5, v3, 0xF2u);
        return sub_154B4(a1, v6);
      }
    }
  }
  return result;
}

//----- (00017148) --------------------------------------------------------
int sub_17148()
{
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  sub_2A7A4(&stru_73D3C);
  result = pthread_create(newthread, 0, sub_23138, 0);
  if ( result )
    sub_B310();
  return result;
}
// 73D3C: using guessed type struct timeval stru_73D3C;

//----- (0001718C) --------------------------------------------------------
int __fastcall sub_1718C(char *a1)
{
  char *v2; // r0
  bool v3; // zf
  int v4; // r5
  _DWORD *v6; // r8
  int v7; // r10
  int v8; // r11
  char *v9; // r0
  char *v10; // r12
  char *v11; // r9
  signed int v12; // r2
  size_t v13; // r0
  const char *v14; // r8
  size_t v15; // r11
  size_t v16; // r10
  size_t v17; // r5
  char *v18; // r0
  const char *v19; // r8
  char *v20; // r0
  int v21; // r0
  int v22; // r5
  _DWORD *v23; // r7
  int v24; // r1
  int v25; // r2
  int v26; // r3
  int v27; // r1
  int v28; // r2
  int v29; // r3
  _DWORD v30[4]; // [sp+14h] [bp-1500h] BYREF
  char *v31; // [sp+24h] [bp-14F0h]
  _BYTE v32[64]; // [sp+28h] [bp-14ECh] BYREF
  int v33[42]; // [sp+68h] [bp-14ACh] BYREF
  char s[1024]; // [sp+110h] [bp-1404h] BYREF
  char v35[4080]; // [sp+510h] [bp-1004h] BYREF

  if ( dword_73E30 )
  {
    if ( fgets(s, 1024, (FILE *)dword_73E30) )
      goto LABEL_3;
    if ( !dword_73E3C )
      goto LABEL_25;
LABEL_9:
    fclose((FILE *)dword_73E30);
    dword_73E30 = 0;
    return sub_1718C(a1);
  }
  else
  {
    if ( !dword_73E34 )
    {
      strcpy(v35, "BENCHFILE Invalid benchfile NULL");
      sub_385C8(3, v35, 1);
      sub_16BE0(1);
    }
    dword_73E30 = (int)fopen((const char *)dword_73E34, "r");
    if ( !dword_73E30 )
    {
      snprintf(v35, 0x1000u, "BENCHFILE Failed to open benchfile '%s'", (const char *)dword_73E34);
      sub_385C8(3, v35, 1);
      sub_16BE0(1);
    }
    dword_73E38 = 0;
    if ( !fgets(s, 1024, (FILE *)dword_73E30) )
    {
      snprintf(v35, 0x1000u, "BENCHFILE Failed to read benchfile '%s'", (const char *)dword_73E34);
      sub_385C8(3, v35, 1);
      sub_16BE0(1);
    }
    dword_73E3C = 0;
    while ( 1 )
    {
LABEL_3:
      v2 = s;
      v3 = s[0] == 35;
      if ( s[0] != 35 )
        v3 = s[0] == 0;
      ++dword_73E38;
      if ( !v3 && s[0] != 47 )
        break;
      if ( !fgets(s, 1024, (FILE *)dword_73E30) )
      {
        if ( dword_73E3C )
          goto LABEL_9;
LABEL_25:
        snprintf(v35, 0x1000u, "BENCHFILE No work in benchfile '%s'", dword_73E34);
        sub_385C8(3, v35, 1);
        sub_16BE0(1);
      }
    }
    v6 = v30;
    v7 = 0;
    v8 = 1;
    v30[0] = s;
    do
    {
      v9 = strchr(v2, 44);
      v6[1] = v9;
      if ( !v9 )
      {
        snprintf(
          v35,
          0x1000u,
          "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
          dword_73E38,
          v8,
          5);
        sub_385C8(3, v35, 1);
        sub_16BE0(1);
      }
      v10 = *(char **)((char *)&unk_5AA64 + v7);
      if ( v10 && &v9[-*v6] != v10 )
      {
        snprintf(
          v35,
          0x1000u,
          "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
          dword_73E38,
          v8,
          *(const char **)((char *)&unk_5AA64 + v7 + 4),
          &v9[-*v6],
          v10);
        sub_385C8(3, v35, 1);
        sub_16BE0(1);
      }
      ++v8;
      *v9 = 0;
      v7 += 8;
      v6[1] = v9 + 1;
      v2 = v9 + 1;
      ++v6;
    }
    while ( v8 != 5 );
    v11 = v31;
    v12 = strlen(v31);
    if ( v12 <= 9 )
    {
      snprintf(
        v35,
        0x1000u,
        "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
        dword_73E38,
        5,
        "NonceTime",
        v12,
        10);
      sub_385C8(3, v35, 1);
      sub_16BE0(1);
    }
    sprintf(v35, "0000000%c", *(unsigned __int8 *)v30[0]);
    v13 = strlen(v35);
    v14 = (const char *)(v30[2] + 56);
    v15 = v13 + 64;
    v16 = v13;
    v17 = v13;
    do
    {
      v18 = &v35[v17];
      v17 += 8;
      sprintf(v18, "%.8s", v14);
      v14 -= 8;
    }
    while ( v17 != v15 );
    v19 = (const char *)(v30[1] + 56);
    do
    {
      v20 = &v35[v17];
      v17 += 8;
      sprintf(v20, "%.8s", v19);
      v19 -= 8;
    }
    while ( v17 != v16 + 128 );
    v21 = strtol(v11, 0, 10);
    sprintf(&v35[v17], "%08lx", v21);
    v22 = 0;
    strcpy(&v35[v16 + 136], (const char *)v30[3]);
    memset(a1, 0, 0x7B0u);
    sub_29788(a1, (unsigned __int8 *)v35, (int)(v16 + 144) >> 1);
    do
    {
      *(_DWORD *)&v32[v22] = bswap32(*(_DWORD *)&a1[v22]);
      v22 += 4;
    }
    while ( v22 != 64 );
    v23 = a1 + 128;
    sub_30140(v33);
    sub_30174(v33, v32, 0x40u);
    v4 = 1;
    v24 = v33[35];
    v25 = v33[36];
    v26 = v33[37];
    ++dword_73E3C;
    *v23 = v33[34];
    v23[1] = v24;
    v23[2] = v25;
    v23[3] = v26;
    v23 += 4;
    v27 = v33[39];
    v28 = v33[40];
    v29 = v33[41];
    *v23 = v33[38];
    v23[1] = v27;
    v23[2] = v28;
    v23[3] = v29;
  }
  return v4;
}
// 73E30: using guessed type int dword_73E30;
// 73E34: using guessed type int dword_73E34;
// 73E38: using guessed type int dword_73E38;
// 73E3C: using guessed type int dword_73E3C;

//----- (0001767C) --------------------------------------------------------
int __fastcall sub_1767C(char *a1, size_t a2, int a3)
{
  double v3; // d0
  double v7; // r0
  double v8; // d17
  unsigned __int64 v9; // r4
  int v10; // r1
  unsigned __int64 v11; // r0
  size_t v12; // r11
  char v14[16]; // [sp+28h] [bp-1064h] BYREF
  char v15[16]; // [sp+38h] [bp-1054h] BYREF
  char s[64]; // [sp+48h] [bp-1044h] BYREF
  char v17[4100]; // [sp+88h] [bp-1004h] BYREF

  sub_15724(a3);
  LODWORD(v7) = sub_59F1C(*(_QWORD *)(a3 + 192));
  v8 = v7;
  LODWORD(v9) = sub_5A000(*(double *)(a3 + 48));
  HIDWORD(v9) = v10;
  LODWORD(v11) = sub_5A000(*(double *)(a3 + 80) / v3);
  sub_114B8(v11, v14, 0x10u, 4);
  sub_114B8(v9, v15, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", *(const char **)(*(_DWORD *)(a3 + 4) + 8), *(_DWORD *)(a3 + 8));
  (*(void (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 20))(a1, a2, a3);
  v12 = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    dword_72C0C,
    v15,
    v14,
    *(double *)(a3 + 200),
    *(double *)(a3 + 208),
    *(_DWORD *)(a3 + 44),
    v8 / v3 * 60.0);
  if ( a2 <= strlen(s) + v12 )
  {
    snprintf(v17, 0x1000u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3081);
    sub_385C8(3, v17, 1);
    sub_16BE0(1);
  }
  strcat(a1, s);
  return (*(int (__fastcall **)(char *, size_t, int))(*(_DWORD *)(a3 + 4) + 24))(a1, a2, a3);
}
// 176BC: variable 'v7' is possibly undefined
// 176DC: variable 'v10' is possibly undefined
// 176E0: variable 'v3' is possibly undefined
// 176F4: variable 'v11' is possibly undefined
// 16BE0: using guessed type void __fastcall __noreturn sub_16BE0(_DWORD);
// 72C0C: using guessed type int dword_72C0C;

//----- (00017830) --------------------------------------------------------
void __noreturn sub_17830()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  sub_2F2A8((int)sub_1AE2C, 0, 5000);
  strcpy(v0, "Shutdown signal received.");
  sub_385C8(3, v0, 1);
  sub_16BE0(0);
}

//----- (00017888) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_17888(int a1, int a2, int a3, int a4, int a5)
{
  __asm { POP             {PC} }
}
// 17890: positive sp value 1004 has been found
// 17890: unbalanced stack, ignored a potential tail call

//----- (00017894) --------------------------------------------------------
void __noreturn sub_17894()
{
  sigaction(15, &oact, 0);
  sigaction(2, &stru_78774, 0);
  sub_17830();
}

//----- (000178C8) --------------------------------------------------------
int __fastcall sub_178C8(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_mutex_init(a1, 0);
  if ( result )
    sub_B434(a2, a3);
  return result;
}

//----- (000178F4) --------------------------------------------------------
int __fastcall sub_178F4(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_init(a1, 0);
  if ( result )
    sub_B4A0(a2, a3);
  return result;
}

//----- (00017920) --------------------------------------------------------
int __fastcall sub_17920(int a1, const char *a2, int a3)
{
  int result; // r0

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    sub_B434(a2, a3);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    sub_B4A0(a2, a3);
  return result;
}

//----- (00017974) --------------------------------------------------------
char *sub_17974()
{
  char *v0; // r4
  int v1; // r3
  void *v2; // r0
  int v3; // r1
  _DWORD *v4; // r0
  int v5; // r12
  char v7[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = (char *)calloc(0x750u, 1u);
  if ( !v0 )
  {
    strcpy(v7, "Failed to malloc pool in add_pool");
    sub_385C8(3, v7, 1);
    sub_16BE0(1);
  }
  v1 = dword_77FC0;
  v2 = (void *)dword_78260;
  v3 = dword_77FC0 + 2;
  *((_DWORD *)v0 + 1) = dword_77FC0;
  *(_DWORD *)v0 = v1;
  v4 = realloc(v2, 4 * v3);
  v5 = dword_77FC0 + 1;
  dword_78260 = (int)v4;
  v4[dword_77FC0] = v0;
  dword_77FC0 = v5;
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 220), 0) )
    sub_B434("add_pool", 748);
  if ( pthread_cond_init((pthread_cond_t *)(v0 + 328), 0) )
  {
    strcpy(v7, "Failed to pthread_cond_init in add_pool");
    sub_385C8(3, v7, 1);
    sub_16BE0(1);
  }
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 244), 0) )
    sub_B434("add_pool", 751);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v0 + 268), 0) )
    sub_B4A0("add_pool", 751);
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 728), 0) )
    sub_B434("add_pool", 752);
  if ( pthread_mutex_init((pthread_mutex_t *)(v0 + 764), 0) )
    sub_B434("add_pool", 753);
  if ( pthread_rwlock_init((pthread_rwlock_t *)(v0 + 788), 0) )
    sub_B4A0("add_pool", 753);
  *((_DWORD *)v0 + 94) = v0 + 376;
  *((_DWORD *)v0 + 95) = v0 + 376;
  *((_DWORD *)v0 + 48) = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  *((_DWORD *)v0 + 42) = -1;
  *((_DWORD *)v0 + 54) = 0;
  *((_DWORD *)v0 + 14) = 1;
  sub_15218();
  return v0;
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00017B84) --------------------------------------------------------
const char *__fastcall sub_17B84(char *s)
{
  int v2; // r3
  _DWORD *v3; // r4
  char *v4; // r6
  char *v5; // r0
  char *v6; // r5
  int v7; // r3
  void *v8; // r0

  if ( dword_73E40 || dword_73E44 )
    return "Use only user + pass or userpass, but not both";
  v2 = dword_73E48 + 1;
  dword_73E48 = v2;
  if ( v2 > dword_77FC0 )
  {
    sub_17974();
    v2 = dword_73E48;
  }
  v3 = *(_DWORD **)(dword_78260 + 4 * (v2 - 1));
  v4 = _strdup(s);
  sub_5858C((int)s, v3 + 50);
  v5 = strtok(v4, ":");
  v3[51] = v5;
  if ( !v5 )
    return "Failed to find : delimited user info";
  v6 = strtok(0, ":");
  v3[52] = v6;
  if ( v6 )
    return 0;
  v8 = calloc(1u, 1u);
  v7 = 0;
  v3[52] = v8;
  return (const char *)v7;
}
// 73E40: using guessed type int dword_73E40;
// 73E44: using guessed type int dword_73E44;
// 73E48: using guessed type int dword_73E48;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00017C74) --------------------------------------------------------
const char *__fastcall sub_17C74(int a1)
{
  int v3; // r3

  if ( dword_73E48 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_73E40 + 1;
  dword_73E40 = v3;
  if ( v3 > dword_77FC0 )
  {
    sub_17974();
    v3 = dword_73E40;
  }
  sub_5858C(a1, (_DWORD *)(*(_DWORD *)(dword_78260 + 4 * (v3 - 1)) + 204));
  return 0;
}
// 73E40: using guessed type int dword_73E40;
// 73E48: using guessed type int dword_73E48;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00017CF0) --------------------------------------------------------
int sub_17CF0()
{
  int v0; // r3

  v0 = ++dword_73E4C;
  if ( dword_73E4C > dword_77FC0 )
  {
    sub_17974();
    v0 = dword_73E4C;
  }
  return *(_DWORD *)(dword_78260 + 4 * (v0 - 1));
}
// 73E4C: using guessed type int dword_73E4C;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00017D3C) --------------------------------------------------------
int __fastcall sub_17D3C(char *a1)
{
  int v2; // r0

  if ( *a1 )
  {
    v2 = sub_17CF0();
    sub_17038(v2, a1);
  }
  return 0;
}

//----- (00017EAC) --------------------------------------------------------
const char *__fastcall sub_17EAC(int a1)
{
  int v3; // r3

  if ( dword_73E48 )
    return "Use only user + pass or userpass, but not both";
  v3 = dword_73E44 + 1;
  dword_73E44 = v3;
  if ( v3 > dword_77FC0 )
  {
    sub_17974();
    v3 = dword_73E44;
  }
  sub_5858C(a1, (_DWORD *)(*(_DWORD *)(dword_78260 + 4 * (v3 - 1)) + 208));
  return 0;
}
// 73E44: using guessed type int dword_73E44;
// 73E48: using guessed type int dword_73E48;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00017F28) --------------------------------------------------------
int *__fastcall sub_17F28(int a1)
{
  _DWORD *v2; // r4
  int v3; // r6
  _DWORD *v4; // r5
  double v5; // d8
  int v6; // r2
  int **v7; // r3
  int v8; // r1
  int *v9; // r0
  bool v10; // zf
  int v11; // r2
  int v12; // r1
  int v13; // r1
  int v14; // r2
  int v15; // r2
  int v16; // r0
  int *result; // r0
  double v18; // d16
  double v19; // d17
  __int64 v20; // r2
  void **v21; // r11
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&mutex) )
    sub_B35C("clear_stratum_shares", 6986);
  v2 = (_DWORD *)dword_73E68;
  if ( dword_73E68 )
  {
    v3 = 0;
    v4 = *(_DWORD **)(dword_73E68 + 8);
    v5 = 0.0;
    while ( 1 )
    {
      if ( *(_DWORD *)(v2[9] + 1748) == a1 )
      {
        v6 = v2[1];
        if ( v6 || v2[2] )
        {
          v7 = (int **)dword_73E68;
          v8 = *(_DWORD *)dword_73E68;
          v9 = *(int **)(*(_DWORD *)dword_73E68 + 20);
          if ( (_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_73E68 + 16) - (_DWORD)v9) == v2 )
          {
            *(_DWORD *)(v8 + 16) = (char *)v9 + v6;
            v6 = v2[1];
          }
          v10 = v6 == 0;
          if ( v6 )
          {
            v9 = *v7;
            v8 = v2[2];
          }
          else
          {
            v6 = v2[2];
          }
          if ( v10 )
          {
            v7 = (int **)v6;
            dword_73E68 = v6;
          }
          else
          {
            v6 += v9[5];
          }
          if ( !v10 )
          {
            *(_DWORD *)(v6 + 8) = v8;
            v6 = v2[2];
          }
          if ( v6 )
            *(_DWORD *)(v6 + (*v7)[5] + 4) = v2[1];
          v11 = 3 * (((*v7)[1] - 1) & v2[7]);
          v12 = **v7 + 12 * (((*v7)[1] - 1) & v2[7]);
          --*(_DWORD *)(v12 + 4);
          v13 = **v7;
          if ( *(_DWORD **)(v13 + 4 * v11) == v2 )
            *(_DWORD *)(v13 + 4 * v11) = v2[4];
          v14 = v2[3];
          if ( v14 )
            *(_DWORD *)(v14 + 16) = v2[4];
          v15 = v2[4];
          if ( v15 )
            *(_DWORD *)(v15 + 12) = v2[3];
          --(*v7)[3];
        }
        else
        {
          v21 = (void **)dword_73E68;
          free(**(void ***)dword_73E68);
          free(*v21);
          dword_73E68 = 0;
        }
        v16 = v2[9];
        ++v3;
        v5 = v5 + *(double *)(v16 + 1864);
        sub_156B8((void **)v16);
        v2[9] = 0;
        --*(_DWORD *)(a1 + 756);
        free(v2);
        if ( !v4 )
          goto LABEL_28;
      }
      else if ( !v4 )
      {
        goto LABEL_28;
      }
      v2 = v4;
      v4 = (_DWORD *)v4[2];
    }
  }
  v3 = 0;
  v5 = 0.0;
LABEL_28:
  if ( pthread_mutex_unlock(&mutex) )
    sub_B50C("clear_stratum_shares", 6999);
  result = (int *)off_72D18();
  if ( v3 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      snprintf(s, 0x1000u, "Lost %d shares due to stratum disconnect on pool %d", v3, *(_DWORD *)a1);
      sub_385C8(4, s, 0);
    }
    v18 = *(double *)(a1 + 120) + v5;
    v19 = dbl_78250;
    result = &dword_78AA8;
    v20 = *(_QWORD *)&dword_78AA8;
    *(_DWORD *)(a1 + 152) += v3;
    *(_QWORD *)&dword_78AA8 = v20 + v3;
    *(double *)(a1 + 120) = v18;
    dbl_78250 = v19 + v5;
  }
  return result;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E68: using guessed type int dword_73E68;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 78250: using guessed type double dbl_78250;
// 78AA8: using guessed type int dword_78AA8;

//----- (00018200) --------------------------------------------------------
int __fastcall sub_18200(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r5
  pthread_mutex_t *v4; // r0
  int v5; // r5

  v2 = (pthread_mutex_t *)(a1 + 220);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 220)) )
    sub_B35C("pool_tclear", 784);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v4) )
    sub_B50C("pool_tclear", 787);
  off_72D18();
  return v5;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (00018274) --------------------------------------------------------
int __fastcall sub_18274(int a1, int a2)
{
  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("inc_dev_status", 8308);
  dword_786D0 = a1;
  dword_78948 = a2;
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("inc_dev_status", 8311);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();
// 786D0: using guessed type int dword_786D0;
// 78948: using guessed type int dword_78948;

//----- (000182F4) --------------------------------------------------------
int __fastcall sub_182F4(int a1, int a2)
{
  int v4; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "%s%d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_385C8(7, s, 0);
  }
  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("inc_hw_errors_with_diff", 8296);
  v4 = dword_786CC;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 44) += a2;
  dword_786CC = v4 + a2;
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("inc_hw_errors_with_diff", 8299);
  off_72D18();
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 786CC: using guessed type int dword_786CC;

//----- (0001842C) --------------------------------------------------------
int __fastcall sub_1842C(int a1, unsigned int a2)
{
  __time_t v5; // r4
  signed int v6; // r1
  int v7; // r4
  struct timeval v9; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  sub_2A7A4(&v9);
  v5 = a2 / 0x3E8 + v9.tv_sec;
  v6 = 1000 * a2 - 1000000 * (a2 / 0x3E8) + v9.tv_usec;
  if ( v6 > 999999 )
  {
    ++v5;
    v6 -= 1000000;
  }
  abstime.tv_sec = v5;
  abstime.tv_nsec = 1000 * v6;
  if ( pthread_mutex_lock(&stru_78454) )
    sub_B35C("restart_wait", 5249);
  if ( *(_BYTE *)(a1 + 62) )
    v7 = 0;
  else
    v7 = pthread_cond_timedwait(&cond, &stru_78454, &abstime);
  if ( pthread_mutex_unlock(&stru_78454) )
    sub_B50C("restart_wait", 5254);
  off_72D18();
  return v7;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001852C) --------------------------------------------------------
int sub_1852C()
{
  if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
    sub_B35C("wake_gws", 5204);
  pthread_cond_signal(&stru_77FC8);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
    sub_B50C("wake_gws", 5206);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();
// 73E6C: using guessed type int dword_73E6C;

//----- (0001859C) --------------------------------------------------------
int __fastcall sub_1859C(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r5
  pthread_mutex_t *v4; // r0
  int v5; // r5

  v2 = (pthread_mutex_t *)(a1 + 220);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 220)) )
    sub_B35C("pool_tset", 772);
  v4 = v2;
  v5 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v4) )
    sub_B50C("pool_tset", 775);
  off_72D18();
  return v5;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (00018610) --------------------------------------------------------
int __fastcall sub_18610(_DWORD *a1, int a2)
{
  char *v4; // r1
  int v6; // r2
  int v7; // r1
  int v8; // r3
  const char *v9; // lr
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // lr
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r0
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int v23; // r1
  int v24; // r2
  int v25; // r3
  struct timeval v26; // [sp+8h] [bp-1010h] BYREF
  struct timeval v27; // [sp+10h] [bp-1008h] BYREF
  _DWORD dest[1024]; // [sp+18h] [bp-1000h] BYREF

  if ( *((_BYTE *)a1 + 760) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf((char *)dest, 0x1000u, "Retrieving block template from pool %s", a1[49]);
      goto LABEL_64;
    }
  }
  else if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf((char *)dest, 0x1000u, "Testing pool %s", a1[49]);
LABEL_64:
    sub_385C8(7, (const char *)dest, 0);
  }
  if ( *((_BYTE *)a1 + 664) )
    goto LABEL_12;
  if ( !off_72C10 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      strcpy((char *)dest, "CURL initialisation failed");
      sub_385C8(3, (const char *)dest, 0);
      return 0;
    }
    return 0;
  }
  if ( *((_BYTE *)a1 + 131) )
    goto LABEL_8;
  if ( !byte_75C49 )
  {
    *((_BYTE *)a1 + 131) = 0;
    goto LABEL_8;
  }
  if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
  {
    strcpy((char *)dest, "Probing for GBT support");
    sub_385C8(7, (const char *)dest, 0);
    v7 = *((unsigned __int8 *)a1 + 760);
    v8 = (unsigned __int8)byte_75C49;
    *((_BYTE *)a1 + 131) = 0;
    if ( !v7 )
    {
      if ( !*((_BYTE *)a1 + 924) )
      {
        if ( !v8 )
          goto LABEL_8;
        goto LABEL_46;
      }
      if ( !v8 )
        goto LABEL_8;
LABEL_42:
      if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
      {
        strcpy((char *)dest, "GBT coinbase without append found, switching to GBT solo protocol");
        sub_385C8(7, (const char *)dest, 0);
      }
      goto LABEL_8;
    }
    if ( !v8 )
      goto LABEL_8;
LABEL_35:
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
      goto LABEL_8;
    v9 = "GBT coinbase + append support found, switching to GBT protocol";
    goto LABEL_39;
  }
  v6 = *((unsigned __int8 *)a1 + 760);
  *((_BYTE *)a1 + 131) = 0;
  if ( v6 )
    goto LABEL_35;
  if ( *((_BYTE *)a1 + 924) )
    goto LABEL_42;
LABEL_46:
  if ( byte_77B70 || byte_75C48 )
  {
    v9 = "No GBT coinbase + append support found, using getwork protocol";
LABEL_39:
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v14 = (int *)(v9 + 16);
    dest[0] = v10;
    dest[1] = v11;
    dest[2] = v12;
    dest[3] = v13;
    v15 = *v14;
    v16 = v14[1];
    v17 = v14[2];
    v18 = v14[3];
    v14 += 4;
    dest[4] = v15;
    dest[5] = v16;
    dest[6] = v17;
    dest[7] = v18;
    v19 = *v14;
    v20 = v14[1];
    v21 = v14[2];
    v22 = v14[3];
    v14 += 4;
    dest[8] = v19;
    dest[9] = v20;
    dest[10] = v21;
    dest[11] = v22;
    v23 = v14[1];
    v24 = v14[2];
    v25 = v14[3];
    dest[12] = *v14;
    dest[13] = v23;
    dest[14] = v24;
    LOWORD(dest[15]) = v25;
    BYTE2(dest[15]) = BYTE2(v25);
    sub_385C8(7, (const char *)dest, 0);
    goto LABEL_8;
  }
  if ( dword_73504 > 6 )
  {
    v9 = "No GBT coinbase + append support found, using getwork protocol";
    goto LABEL_39;
  }
LABEL_8:
  sub_2A7A4(&v26);
  sub_2A7A4(&v27);
  v4 = (char *)a1[150];
  if ( v4 && !byte_73E70 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf((char *)dest, 0x1000u, "Testing pool %d stratum %s", *a1, (const char *)a1[150]);
      sub_385C8(7, (const char *)dest, 0);
      v4 = (char *)a1[150];
    }
    sub_2A9C0((int)a1, v4);
    if ( sub_2AAAC((const char *)a1[150], a1 + 156, (char **)a1 + 152) )
    {
      if ( sub_2B840(a1) )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(
            (char *)dest,
            0x1000u,
            "Switching pool %d %s to %s",
            *a1,
            (const char *)a1[49],
            (const char *)a1[150]);
          sub_385C8(7, (const char *)dest, 0);
        }
        if ( !a1[49] )
          a1[49] = _strdup((const char *)a1[150]);
        goto LABEL_11;
      }
    }
  }
  if ( !sub_2B840(a1) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf((char *)dest, 0x1000u, "FAILED to retrieve work from pool %u %s", *a1, (const char *)a1[49]);
      sub_385C8(7, (const char *)dest, 0);
    }
    if ( !a2 && !*((_BYTE *)a1 + 129) && (byte_77B70 || byte_75C48 || dword_73504 > 3) )
    {
      snprintf((char *)dest, 0x1000u, "Pool %u slow/down or URL or credentials invalid", *a1);
      sub_385C8(4, (const char *)dest, 0);
    }
    return 0;
  }
LABEL_11:
  *((_BYTE *)a1 + 664) = 1;
LABEL_12:
  if ( sub_1859C((int)a1, (_BYTE *)a1 + 666) )
    return *((unsigned __int8 *)a1 + 665);
  if ( sub_2B840(a1) && sub_2E8A8(a1) )
  {
    nullsub_1(a1);
    byte_78AA1 = 1;
    if ( pthread_create(a1 + 180, 0, (void *(*)(void *))sub_21F30, a1) )
    {
      strcpy((char *)dest, "Failed to create stratum sthread");
      sub_385C8(3, (const char *)dest, 1);
      sub_16BE0(1);
    }
    if ( pthread_create(a1 + 181, 0, (void *(*)(void *))sub_1FFD0, a1) )
    {
      strcpy((char *)dest, "Failed to create stratum rthread");
      sub_385C8(3, (const char *)dest, 1);
      sub_16BE0(1);
    }
    return 1;
  }
  else
  {
    nullsub_1(a1);
    sub_18200((int)a1, (_BYTE *)a1 + 666);
    return 0;
  }
}
// 2B83C: using guessed type int __fastcall nullsub_1(_DWORD);
// 72C10: using guessed type char *off_72C10;
// 73504: using guessed type int dword_73504;
// 73E70: using guessed type char byte_73E70;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78AA1: using guessed type char byte_78AA1;

//----- (00018D24) --------------------------------------------------------
int __fastcall sub_18D24(int a1)
{
  int v2; // r3
  int v3; // r0
  int v4; // r2
  int v5; // r12
  int v6; // r1
  bool v7; // zf
  int v8; // r2
  int v9; // r0
  int v10; // r12
  int v11; // r2
  int v12; // r2
  struct timespec v14; // [sp+0h] [bp-1014h] BYREF
  struct timeval v15; // [sp+8h] [bp-100Ch] BYREF
  char v16[4080]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
    sub_B35C("hash_pop", 7702);
  if ( dword_73E74 && *(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 12) )
  {
    if ( !byte_782F0 )
      goto LABEL_18;
    goto LABEL_14;
  }
  if ( byte_73E78 && dword_72C14 < dword_72C18 )
  {
    ++dword_72C14;
    byte_73E78 = 0;
  }
  byte_73E79 = 1;
  if ( a1 )
  {
    do
    {
      sub_2A7A4(&v15);
      v14.tv_nsec = 1000 * v15.tv_usec;
      v14.tv_sec = v15.tv_sec + 10;
      pthread_cond_signal(&stru_77FC8);
      if ( pthread_cond_timedwait((pthread_cond_t *)(dword_78448 + 40), (pthread_mutex_t *)dword_73E6C, &v14) )
      {
        if ( !byte_782F0 )
        {
          byte_782F0 = 1;
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            strcpy(v16, "Waiting for work to be available from pools.");
            sub_385C8(4, v16, 0);
          }
        }
      }
    }
    while ( !dword_73E74 || !*(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 12) );
    if ( !byte_782F0 )
    {
LABEL_18:
      v2 = dword_73E74;
      if ( dword_73E74 )
      {
        v3 = *(_DWORD *)(dword_73E74 + 1832);
        if ( dword_73E7C < *(_DWORD *)(v3 + 12)
          && (a1 = *(_DWORD *)(dword_73E74 + 1840), !*(_BYTE *)(dword_73E74 + 1761))
          && *(_DWORD *)(dword_73E74 + 1764) )
        {
          while ( a1 )
          {
            if ( *(_BYTE *)(a1 + 1761) )
            {
              v4 = *(_DWORD *)(a1 + 1836);
              if ( v4 )
                goto LABEL_22;
              goto LABEL_61;
            }
            if ( !*(_DWORD *)(a1 + 1764) )
              break;
            a1 = *(_DWORD *)(a1 + 1840);
          }
        }
        else
        {
          a1 = dword_73E74;
        }
      }
      else
      {
        v3 = MEMORY[0x728];
        a1 = 0;
      }
      v4 = *(_DWORD *)(a1 + 1836);
      if ( !v4 )
      {
LABEL_61:
        if ( !*(_DWORD *)(a1 + 1840) )
        {
          free(*(void **)v3);
          free(*(void **)(dword_73E74 + 1832));
          dword_73E74 = 0;
LABEL_43:
          if ( !*(_BYTE *)(a1 + 1761) && *(_DWORD *)(a1 + 1764) )
            --dword_73E7C;
          pthread_cond_signal(&stru_77FC8);
          pthread_cond_signal((pthread_cond_t *)(dword_78448 + 40));
          dword_78770 = time(0);
          goto LABEL_45;
        }
      }
LABEL_22:
      v5 = *(_DWORD *)(v3 + 20);
      v6 = a1 + 1832;
      if ( *(_DWORD *)(v3 + 16) - v5 == a1 )
      {
        *(_DWORD *)(v3 + 16) = v4 + v5;
        v4 = *(_DWORD *)(a1 + 1836);
      }
      v7 = v4 == 0;
      if ( v4 )
      {
        v5 = *(_DWORD *)(v2 + 1832);
        v3 = *(_DWORD *)(a1 + 1840);
      }
      else
      {
        v4 = *(_DWORD *)(a1 + 1840);
      }
      if ( v7 )
      {
        v2 = v4;
        dword_73E74 = v4;
      }
      else
      {
        v4 += *(_DWORD *)(v5 + 20);
      }
      if ( !v7 )
      {
        *(_DWORD *)(v4 + 8) = v3;
        v4 = *(_DWORD *)(a1 + 1840);
      }
      if ( v4 )
        *(_DWORD *)(v4 + *(_DWORD *)(*(_DWORD *)(v2 + 1832) + 20) + 4) = *(_DWORD *)(a1 + 1836);
      v8 = 12 * ((*(_DWORD *)(*(_DWORD *)(v2 + 1832) + 4) - 1) & *(_DWORD *)(a1 + 1860));
      --*(_DWORD *)(**(_DWORD **)(v2 + 1832) + v8 + 4);
      v9 = **(_DWORD **)(v2 + 1832);
      v10 = *(_DWORD *)(v9 + v8);
      if ( v10 == v6 )
      {
        v2 = *(_DWORD *)(a1 + 1848);
        *(_DWORD *)(v9 + v8) = v2;
      }
      v11 = *(_DWORD *)(a1 + 1844);
      if ( v10 == v6 )
        v2 = dword_73E74;
      if ( v11 )
        *(_DWORD *)(v11 + 16) = *(_DWORD *)(a1 + 1848);
      v12 = *(_DWORD *)(a1 + 1848);
      if ( v12 )
        *(_DWORD *)(v12 + 12) = *(_DWORD *)(a1 + 1844);
      --*(_DWORD *)(*(_DWORD *)(v2 + 1832) + 12);
      goto LABEL_43;
    }
LABEL_14:
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      strcpy(v16, "Work available from pools, resuming.");
      sub_385C8(4, v16, 0);
    }
    byte_782F0 = 0;
    goto LABEL_18;
  }
LABEL_45:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
    sub_B50C("hash_pop", 7769);
  off_72D18();
  return a1;
}
// 72C14: using guessed type int dword_72C14;
// 72C18: using guessed type int dword_72C18;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E6C: using guessed type int dword_73E6C;
// 73E74: using guessed type int dword_73E74;
// 73E78: using guessed type char byte_73E78;
// 73E79: using guessed type char byte_73E79;
// 73E7C: using guessed type int dword_73E7C;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 782F0: using guessed type char byte_782F0;
// 78448: using guessed type int dword_78448;
// 78770: using guessed type int dword_78770;

//----- (000191B0) --------------------------------------------------------
int sub_191B0()
{
  int v0; // r5
  int v1; // r3

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
    sub_B35C("total_staged", 2907);
  if ( dword_73E74 )
    v1 = *(_DWORD *)(dword_73E74 + 1832);
  else
    v0 = 0;
  if ( dword_73E74 )
    v0 = *(_DWORD *)(v1 + 12);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
    sub_B50C("total_staged", 2909);
  off_72D18();
  return v0;
}
// 191DC: variable 'v1' is possibly undefined
// 191F8: variable 'v0' is possibly undefined
// 72D18: using guessed type int (*off_72D18)();
// 73E6C: using guessed type int dword_73E6C;
// 73E74: using guessed type int dword_73E74;

//----- (0001922C) --------------------------------------------------------
void __fastcall sub_1922C(_DWORD *a1)
{
  int v2; // r4
  int v3; // r7
  int v4; // r5
  int v5; // r1
  int v6; // r2
  int v7; // r0
  int v8; // r3
  int v9; // r12
  bool v10; // zf
  int v11; // r3
  int v12; // r1
  int v13; // r1
  int v14; // r12
  int v15; // r3
  int v16; // r3
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
    sub_B35C("clear_pool_work", 7016);
  v2 = dword_73E74;
  if ( dword_73E74 )
  {
    v4 = *(_DWORD *)(dword_73E74 + 1840);
    v3 = 0;
    while ( 1 )
    {
      if ( *(_DWORD **)(v2 + 1748) == a1 )
      {
        v5 = *(_DWORD *)(v2 + 1836);
        if ( v5 || *(_DWORD *)(v2 + 1840) )
        {
          v6 = dword_73E74;
          v7 = v2 + 1832;
          v8 = *(_DWORD *)(dword_73E74 + 1832);
          v9 = *(_DWORD *)(v8 + 20);
          if ( *(_DWORD *)(v8 + 16) - v9 == v2 )
          {
            *(_DWORD *)(v8 + 16) = v5 + v9;
            v5 = *(_DWORD *)(v2 + 1836);
          }
          v10 = v5 == 0;
          if ( v5 )
          {
            v9 = *(_DWORD *)(v6 + 1832);
            v8 = *(_DWORD *)(v2 + 1840);
          }
          else
          {
            v6 = *(_DWORD *)(v2 + 1840);
          }
          if ( v5 )
          {
            v5 += *(_DWORD *)(v9 + 20);
          }
          else
          {
            dword_73E74 = v6;
            v8 = v6;
          }
          if ( !v10 )
          {
            *(_DWORD *)(v5 + 8) = v8;
            v8 = *(_DWORD *)(v2 + 1840);
          }
          if ( v8 )
            *(_DWORD *)(v8 + *(_DWORD *)(*(_DWORD *)(v6 + 1832) + 20) + 4) = *(_DWORD *)(v2 + 1836);
          v11 = 3 * ((*(_DWORD *)(*(_DWORD *)(v6 + 1832) + 4) - 1) & *(_DWORD *)(v2 + 1860));
          v12 = **(_DWORD **)(v6 + 1832) + 12 * ((*(_DWORD *)(*(_DWORD *)(v6 + 1832) + 4) - 1) & *(_DWORD *)(v2 + 1860));
          --*(_DWORD *)(v12 + 4);
          v13 = **(_DWORD **)(v6 + 1832);
          v14 = *(_DWORD *)(v13 + 4 * v11);
          if ( v14 == v7 )
          {
            v6 = *(_DWORD *)(v2 + 1848);
            *(_DWORD *)(v13 + 4 * v11) = v6;
          }
          v15 = *(_DWORD *)(v2 + 1844);
          if ( v14 == v7 )
            v6 = dword_73E74;
          if ( v15 )
            *(_DWORD *)(v15 + 16) = *(_DWORD *)(v2 + 1848);
          v16 = *(_DWORD *)(v2 + 1848);
          if ( v16 )
            *(_DWORD *)(v16 + 12) = *(_DWORD *)(v2 + 1844);
          --*(_DWORD *)(*(_DWORD *)(v6 + 1832) + 12);
        }
        else
        {
          free(**(void ***)(dword_73E74 + 1832));
          free(*(void **)(dword_73E74 + 1832));
          dword_73E74 = 0;
        }
        ++v3;
        sub_156B8((void **)v2);
        if ( !v4 )
          goto LABEL_31;
      }
      else if ( !v4 )
      {
        goto LABEL_31;
      }
      v2 = v4;
      v4 = *(_DWORD *)(v4 + 1840);
    }
  }
  v3 = 0;
LABEL_31:
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
    sub_B50C("clear_pool_work", 7026);
  off_72D18();
  if ( v3 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "Cleared %d work items due to stratum disconnect on pool %d", v3, *a1);
    sub_385C8(7, s, 0);
  }
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E6C: using guessed type int dword_73E6C;
// 73E74: using guessed type int dword_73E74;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00019498) --------------------------------------------------------
int __fastcall sub_19498(int a1)
{
  int v2; // r1
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "%s %d: invalid nonce - HW error",
      *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
    sub_385C8(7, s, 1);
  }
  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("inc_hw_errors", 8283);
  v2 = dword_786CC;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 36) + 44);
  dword_786CC = v2 + 1;
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("inc_hw_errors", 8286);
  off_72D18();
  return (*(int (__fastcall **)(int))(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 84))(a1);
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 786CC: using guessed type int dword_786CC;

//----- (000195CC) --------------------------------------------------------
int sub_195CC()
{
  pthread_mutex_trylock(&stru_785D0);
  if ( !byte_73E80 )
  {
    if ( !pthread_mutex_unlock(&stru_785D0) )
      return off_72D18();
LABEL_5:
    sub_B50C("unlock_curses", 2930);
  }
  byte_72C1C = 0;
  byte_73E80 = 0;
  leaveok((WINDOW *)dword_78258, 0);
  leaveok((WINDOW *)dword_785E8, 0);
  leaveok((WINDOW *)dword_78AB8, 0);
  nocbreak();
  echo();
  delwin((WINDOW *)dword_78258);
  delwin((WINDOW *)dword_785E8);
  delwin((WINDOW *)dword_78AB8);
  endwin();
  if ( pthread_mutex_unlock(&stru_785D0) )
    goto LABEL_5;
  return off_72D18();
}
// 72C1C: using guessed type char byte_72C1C;
// 72D18: using guessed type int (*off_72D18)();
// 73E80: using guessed type char byte_73E80;
// 78258: using guessed type int dword_78258;
// 785E8: using guessed type int dword_785E8;
// 78AB8: using guessed type int dword_78AB8;

//----- (000196AC) --------------------------------------------------------
int sub_196AC()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_785D0) )
    sub_B35C("lock_curses", 2935);
  v0 = (unsigned __int8)byte_73E80;
  if ( byte_73E80 )
    return (unsigned __int8)byte_73E80;
  if ( pthread_mutex_unlock(&stru_785D0) )
    sub_B50C("unlock_curses", 2930);
  off_72D18();
  return v0;
}
// B35C: using guessed type void __fastcall __noreturn sub_B35C(_DWORD, _DWORD);
// B50C: using guessed type void __fastcall __noreturn sub_B50C(_DWORD, _DWORD);
// 72D18: using guessed type int (*off_72D18)();
// 73E80: using guessed type char byte_73E80;

//----- (00019730) --------------------------------------------------------
void sub_19730()
{
  int v0; // r2
  int v1; // r3
  int v2; // r1
  int v3; // r3
  int v4; // r2

  if ( byte_72C1C && sub_196AC() )
  {
    werase((WINDOW *)stdscr);
    if ( dword_785E8 )
      v0 = *(__int16 *)(dword_785E8 + 6);
    else
      v0 = -1;
    v1 = dword_73E84;
    if ( dword_785E8 )
      ++v0;
    if ( LINES - 1 <= dword_73E84 )
      v1 = LINES - 2;
    dword_73E88 = v1;
    dword_73E8C = v1;
    wresize((WINDOW *)dword_785E8, v1, v0);
    v3 = dword_78AB8;
    if ( dword_78AB8 )
      v2 = *(__int16 *)(dword_78AB8 + 4);
    else
      v3 = -1;
    if ( dword_78AB8 )
      v4 = *(__int16 *)(v3 + 6);
    else
      v4 = v3;
    if ( dword_78AB8 )
    {
      v3 = v2 + 1;
      ++v4;
    }
    wresize((WINDOW *)dword_78258, v3 - dword_73E8C, v4);
    mvwin((WINDOW *)dword_78258, dword_73E8C, 0);
    if ( pthread_mutex_unlock(&stru_785D0) )
      sub_B50C("unlock_curses", 2930);
    off_72D18();
  }
}
// 197C4: variable 'v2' is possibly undefined
// 72C1C: using guessed type char byte_72C1C;
// 72D18: using guessed type int (*off_72D18)();
// 739F8: using guessed type int stdscr;
// 739FC: using guessed type int LINES;
// 73E84: using guessed type int dword_73E84;
// 73E88: using guessed type int dword_73E88;
// 73E8C: using guessed type int dword_73E8C;
// 78258: using guessed type int dword_78258;
// 785E8: using guessed type int dword_785E8;
// 78AB8: using guessed type int dword_78AB8;

//----- (00019840) --------------------------------------------------------
void __fastcall sub_19840(int a1, int a2)
{
  int v2; // r2

  if ( byte_78768 )
  {
    v2 = dword_73E90;
  }
  else
  {
    v2 = dword_73E94;
    a2 = dword_73E90;
  }
  if ( !byte_78768 )
    v2 += a2;
  dword_73E84 = v2 + 1;
  dword_73E8C = v2 + 2;
  if ( pthread_mutex_unlock(&stru_785D0) )
    sub_B50C("unlock_curses", 2930);
  off_72D18();
  sub_19730();
}
// 72D18: using guessed type int (*off_72D18)();
// 73E84: using guessed type int dword_73E84;
// 73E8C: using guessed type int dword_73E8C;
// 73E90: using guessed type int dword_73E90;
// 73E94: using guessed type int dword_73E94;
// 78768: using guessed type char byte_78768;

//----- (000198BC) --------------------------------------------------------
int sub_198BC()
{
  int result; // r0
  int v1; // r2

  result = sub_196AC();
  if ( result )
  {
    if ( dword_78258 )
      v1 = *(__int16 *)(dword_78258 + 4);
    else
      v1 = -1;
    if ( dword_78258 )
      ++v1;
    wtouchln((WINDOW *)dword_78258, 0, v1, 1);
    wrefresh((WINDOW *)dword_78258);
    if ( pthread_mutex_unlock(&stru_785D0) )
      sub_B50C("unlock_curses", 2930);
    return off_72D18();
  }
  return result;
}
// 72D18: using guessed type int (*off_72D18)();
// 78258: using guessed type int dword_78258;

//----- (00019938) --------------------------------------------------------
int sub_19938()
{
  int result; // r0

  result = sub_196AC();
  if ( result )
  {
    werase((WINDOW *)stdscr);
    wclear((WINDOW *)dword_78258);
    if ( pthread_mutex_unlock(&stru_785D0) )
      sub_B50C("unlock_curses", 2930);
    return off_72D18();
  }
  return result;
}
// 72D18: using guessed type int (*off_72D18)();
// 739F8: using guessed type int stdscr;
// 78258: using guessed type int dword_78258;

//----- (000199A4) --------------------------------------------------------
int __fastcall sub_199A4(int a1, const char *a2, const char *a3)
{
  int result; // r0
  _BOOL4 v7; // r4
  int v8; // r2

  result = sub_196AC();
  if ( !result )
    return result;
  v7 = (unsigned int)(a1 - 3) <= 1;
  if ( byte_788F0 )
  {
    if ( v7 )
    {
      wprintw((WINDOW *)dword_78258, "%s%s\n", a2, a3);
LABEL_5:
      if ( dword_78258 )
        v8 = *(__int16 *)(dword_78258 + 4);
      else
        v8 = -1;
      if ( dword_78258 )
        ++v8;
      wtouchln((WINDOW *)dword_78258, 0, v8, 1);
      wrefresh((WINDOW *)dword_78258);
    }
  }
  else
  {
    wprintw((WINDOW *)dword_78258, "%s%s\n", a2, a3);
    if ( v7 )
      goto LABEL_5;
  }
  if ( pthread_mutex_unlock(&stru_785D0) )
    sub_B50C("unlock_curses", 2930);
  off_72D18();
  return 1;
}
// B50C: using guessed type void __fastcall __noreturn sub_B50C(_DWORD, _DWORD);
// 72D18: using guessed type int (*off_72D18)();
// 78258: using guessed type int dword_78258;
// 788F0: using guessed type char byte_788F0;

//----- (00019A98) --------------------------------------------------------
int __fastcall sub_19A98(const char *a1)
{
  int result; // r0

  result = sub_196AC();
  if ( result )
  {
    wprintw((WINDOW *)dword_78258, "%s", a1);
    if ( pthread_mutex_unlock(&stru_785D0) )
      sub_B50C("unlock_curses", 2930);
    return off_72D18();
  }
  return result;
}
// 72D18: using guessed type int (*off_72D18)();
// 78258: using guessed type int dword_78258;

//----- (00019B04) --------------------------------------------------------
int __fastcall sub_19B04(pthread_rwlock_t *a1, const char *a2, int a3)
{
  if ( pthread_rwlock_unlock(a1) )
    sub_B578(a2, a3);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();

//----- (00019B40) --------------------------------------------------------
unsigned __int64 __fastcall sub_19B40(int a1)
{
  double v1; // d9
  __int64 v3; // r0
  double v4; // r0
  double v5; // d8
  double v6; // r0
  double v7; // d8
  double v8; // r0
  double v9; // d8
  double v10; // r0
  double v11; // d0
  int v12; // r1
  unsigned __int64 v13; // r4
  int v14; // r7
  int v15; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = 1.7668201e72;
  v3 = *(_QWORD *)(a1 + 216);
  if ( !byte_78681 )
    v1 = 2.69595353e67;
  LODWORD(v4) = sub_59F08(v3);
  v5 = v4 * 6.27710174e57;
  LODWORD(v6) = sub_59F08(*(_QWORD *)(a1 + 208));
  v7 = v5 + v6 * 3.40282367e38;
  LODWORD(v8) = sub_59F08(*(_QWORD *)(a1 + 200));
  v9 = v7 + v8 * 1.84467441e19;
  LODWORD(v10) = sub_59F08(*(_QWORD *)(a1 + 192));
  v11 = v9 + v10;
  if ( v9 + v10 == 0.0 )
    v11 = 0.0;
  round(LODWORD(v10));
  LODWORD(v13) = sub_5A000(v1 / v11);
  HIDWORD(v13) = v12;
  if ( pthread_mutex_lock(&stru_78838) )
    sub_B35C("share_diff", 4986);
  if ( pthread_rwlock_wrlock(&stru_78850) )
    sub_B3C8("share_diff", 4986);
  if ( qword_73D50 < v13 )
  {
    v14 = 1;
    qword_73D50 = v13;
    sub_114B8(v13, (char *)&dword_72C04, 8u, 0);
  }
  else
  {
    v14 = 0;
  }
  v15 = *(_DWORD *)(a1 + 1748);
  if ( *(_QWORD *)(v15 + 400) < v13 )
    *(_QWORD *)(v15 + 400) = v13;
  if ( pthread_rwlock_unlock(&stru_78850) )
    sub_B578("share_diff", 4995);
  if ( pthread_mutex_unlock(&stru_78838) )
    sub_B50C("share_diff", 4995);
  off_72D18();
  if ( v14 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "New best share: %s", (const char *)&dword_72C04);
    sub_385C8(7, s, 0);
  }
  return v13;
}
// 19B80: variable 'v4' is possibly undefined
// 19B94: variable 'v6' is possibly undefined
// 19BA8: variable 'v8' is possibly undefined
// 19BB8: variable 'v10' is possibly undefined
// 19BE0: variable 'v12' is possibly undefined
// AD44: using guessed type int __fastcall round(_DWORD);
// 72C04: using guessed type int dword_72C04;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73D50: using guessed type __int64 qword_73D50;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78681: using guessed type char byte_78681;

//----- (00019DB8) --------------------------------------------------------
int __fastcall sub_19DB8(int a1, int a2)
{
  double v2; // d16
  double v5; // d8
  unsigned __int64 v6; // r0
  bool v7; // zf
  double v8; // r0
  double *v9; // r6
  double v10; // d8
  double v11; // r0
  __int64 v12; // r0
  int v13; // r7
  double v14; // r0
  __int64 v15; // r0
  int v16; // r4
  double v17; // r0
  __int64 v18; // r0
  int v19; // r4
  int v21; // r2
  int v22; // r0
  int v23; // r12
  int v24; // r0
  char v25[4096]; // [sp+0h] [bp-1000h] BYREF

  v5 = dbl_72C20;
  v6 = sub_19B40(a2);
  v7 = byte_78681 == 0;
  if ( byte_78681 )
    v2 = 65536.0;
  *(_QWORD *)(a2 + 1720) = v6;
  if ( !v7 )
    v5 = v5 * v2;
  LODWORD(v8) = sub_59F08(v6);
  if ( v5 <= v8 )
  {
    v21 = *(_DWORD *)(a2 + 1748);
    v22 = (unsigned __int8)byte_77B70;
    v23 = dword_786E0;
    *(_BYTE *)(a2 + 1771) = 1;
    v7 = v22 == 0;
    v24 = *(_DWORD *)(v21 + 32);
    dword_786E0 = v23 + 1;
    *(_DWORD *)(v21 + 32) = v24 + 1;
    *(_BYTE *)(a2 + 1770) = 1;
    if ( !v7 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(v25, 0x1000u, "Found block for pool %d!", **(_DWORD **)(a2 + 1748));
      sub_385C8(5, v25, 0);
    }
  }
  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("update_work_stats", 8370);
  v9 = (double *)(a2 + 1712);
  v10 = *(double *)(a2 + 1712);
  LODWORD(v11) = sub_59F1C(*(__int64 *)&dword_77F28);
  LODWORD(v12) = sub_59FC8(v11 + v10);
  v13 = *(_DWORD *)(a1 + 36);
  *(_QWORD *)&dword_77F28 = v12;
  LODWORD(v14) = sub_59F1C(*(_QWORD *)(v13 + 192));
  LODWORD(v15) = sub_59FC8(v10 + v14);
  *(_QWORD *)(v13 + 192) = v15;
  v16 = *(_DWORD *)(a2 + 1748);
  LODWORD(v17) = sub_59F1C(*(_QWORD *)(v16 + 40));
  LODWORD(v18) = sub_59FC8(v17 + *v9);
  *(_QWORD *)(v16 + 40) = v18;
  v19 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v19 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("update_work_stats", 8375);
  return off_72D18();
}
// 19DF4: variable 'v2' is possibly undefined
// 19E08: variable 'v8' is possibly undefined
// 19E38: variable 'v11' is possibly undefined
// 19E44: variable 'v12' is possibly undefined
// 19E58: variable 'v14' is possibly undefined
// 19E60: variable 'v15' is possibly undefined
// 19E7C: variable 'v17' is possibly undefined
// 19E84: variable 'v18' is possibly undefined
// 72C20: using guessed type double dbl_72C20;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 77F28: using guessed type int dword_77F28;
// 78681: using guessed type char byte_78681;
// 786E0: using guessed type int dword_786E0;

//----- (00019F9C) --------------------------------------------------------
int __fastcall sub_19F9C(int a1, int a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // r5
  int result; // r0
  char v9[4100]; // [sp+0h] [bp-1004h] BYREF

  v5 = a4;
  v4 = a4 == 0;
  if ( a4 )
    a4 = 0;
  if ( !v4 )
    *v5 = a4;
  if ( sub_16484(a2, a3) )
  {
    sub_19DB8(a1, a2);
    if ( sub_29EAC((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160)) )
    {
      return 1;
    }
    else
    {
      if ( v5 )
        *v5 = 1;
      result = (unsigned __int8)byte_75C49;
      if ( byte_75C49 )
      {
        if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 6 )
        {
          strcpy(v9, "Share above target");
          sub_385C8(7, v9, 0);
          return 0;
        }
      }
    }
  }
  else
  {
    sub_19498(a1);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001A0A0) --------------------------------------------------------
_DWORD *__fastcall sub_1A0A0(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r5
  _DWORD *v11; // r6

  v6 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B3C8("take_queued_work_bymidstate", 8969);
  v11 = (_DWORD *)sub_169B8(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( v11 )
    sub_16A78((int)a1, v11);
  if ( pthread_rwlock_unlock(v6) )
    sub_B578("take_queued_work_bymidstate", 8973);
  off_72D18();
  return v11;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001A154) --------------------------------------------------------
void __fastcall sub_1A154(pthread_rwlock_t *a1, void **a2)
{
  pthread_rwlock_t *v2; // r5

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B3C8("work_completed", 8956);
  sub_16A78((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_B578("work_completed", 8958);
  off_72D18();
  sub_156B8(a2);
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001A1D0) --------------------------------------------------------
int __fastcall sub_1A1D0(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B3C8("add_queued", 8812);
  sub_1655C((int)a1, a2);
  if ( pthread_rwlock_unlock(v2) )
    sub_B578("add_queued", 8814);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001A244) --------------------------------------------------------
int __fastcall sub_1A244(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r8
  int lock; // r5
  int i; // r4
  struct timeval v6; // [sp+0h] [bp-8h] BYREF

  v1 = a1 + 10;
  sub_2A7A4(&v6);
  if ( pthread_rwlock_wrlock(v1) )
    sub_B3C8("age_queued_work", 8937);
  lock = a1[11].__lock;
  if ( lock )
  {
    for ( i = *(_DWORD *)(lock + 1840); ; i = *(_DWORD *)(i + 1840) )
    {
      sub_2A97C();
      if ( !i )
        break;
    }
  }
  if ( pthread_rwlock_unlock(v1) )
    sub_B578("age_queued_work", 8947);
  off_72D18();
  return 0;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001A334) --------------------------------------------------------
int sub_1A334()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_78838) )
    sub_B35C("total_work_inc", 2273);
  if ( pthread_rwlock_wrlock(&stru_78850) )
    sub_B3C8("total_work_inc", 2273);
  v0 = dword_73E98++;
  if ( pthread_rwlock_unlock(&stru_78850) )
    sub_B578("total_work_inc", 2275);
  if ( pthread_mutex_unlock(&stru_78838) )
    sub_B50C("total_work_inc", 2275);
  off_72D18();
  return v0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73E98: using guessed type int dword_73E98;

//----- (0001A3F0) --------------------------------------------------------
int __fastcall sub_1A3F0(int a1)
{
  bool v2; // zf
  unsigned int v3; // r0
  int v4; // r2
  _BYTE *v5; // r5
  int result; // r0
  unsigned int v7[1024]; // [sp+0h] [bp-1004h] BYREF

  v2 = byte_75C49 == 0;
  v3 = bswap32(bswap32(*(_DWORD *)(a1 + 68)) + 1);
  v4 = dword_782F4 + 1;
  ++*(_DWORD *)(a1 + 1728);
  *(_DWORD *)(a1 + 68) = v3;
  *(_DWORD *)(a1 + 1736) = 0;
  dword_782F4 = v4;
  if ( !v2 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy((char *)v7, "Successfully rolled work");
    sub_385C8(7, (const char *)v7, 0);
  }
  v5 = *(_BYTE **)(a1 + 1796);
  if ( v5 )
  {
    sub_29788(v7, *(unsigned __int8 **)(a1 + 1796), 4);
    v7[0] = bswap32(bswap32(v7[0]) + 1);
    sub_29630(v5, (char *)v7, 4);
  }
  result = sub_1A334();
  *(_DWORD *)(a1 + 1828) = result;
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 782F4: using guessed type int dword_782F4;

//----- (0001A520) --------------------------------------------------------
_DWORD *sub_1A520()
{
  _DWORD *v0; // r4
  char v2[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = calloc(1u, 0x7B0u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc work in make_work");
    sub_385C8(3, v2, 1);
    sub_16BE0(1);
  }
  v0[457] = sub_1A334();
  return v0;
}

//----- (0001A598) --------------------------------------------------------
_DWORD *__fastcall sub_1A598(int a1, int a2)
{
  _DWORD *v4; // r4

  v4 = sub_1A520();
  sub_155BC((int)v4, a1, a2);
  return v4;
}

//----- (0001A5C0) --------------------------------------------------------
_DWORD *__fastcall sub_1A5C0(int a1)
{
  _DWORD *v1; // r4
  int v3; // r2

  v1 = sub_1A598(a1, 0);
  *((_BYTE *)v1 + 1761) = 1;
  sub_2A7A4((struct timeval *)v1 + 238);
  v3 = v1[438] - 1;
  *((_BYTE *)v1 + 1768) = 0;
  v1[438] = v3;
  *((_BYTE *)v1 + 1770) = 0;
  return v1;
}

//----- (0001A600) --------------------------------------------------------
int __fastcall sub_1A600(int a1)
{
  _DWORD *v2; // r6
  int v3; // r7
  int v4; // r12
  int *v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // t1
  int v9; // r2
  bool v10; // cc
  int v11; // r2
  char v12; // r3
  int v13; // r3
  int v14; // r4
  int v15; // r0
  int v16; // r0
  int v17; // r4
  int v19; // r3
  int v20; // r2
  int v21; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_78838) )
    sub_B35C("switch_pools", 5101);
  if ( pthread_rwlock_wrlock(&stru_78850) )
    sub_B3C8("switch_pools", 5101);
  v2 = (_DWORD *)dword_73E9C;
  v3 = *(_DWORD *)dword_73E9C;
  if ( a1 && (v4 = *(_DWORD *)(a1 + 4)) != 0 )
  {
    if ( dword_77FC0 > 0 )
    {
      v5 = (int *)dword_78260;
      v6 = dword_78260 + 4 * dword_77FC0;
      while ( 1 )
      {
        v8 = *v5++;
        v7 = v8;
        v9 = *(_DWORD *)(v8 + 4);
        v10 = v9 < v4;
        v11 = v9 + 1;
        if ( v10 )
          *(_DWORD *)(v7 + 4) = v11;
        if ( v5 == (int *)v6 )
          break;
        v4 = *(_DWORD *)(a1 + 4);
      }
    }
    *(_DWORD *)(a1 + 4) = 0;
    v12 = dword_73D34;
    if ( (unsigned int)dword_73D34 > 4 )
      goto LABEL_37;
  }
  else
  {
    v12 = dword_73D34;
    if ( (unsigned int)dword_73D34 > 4 )
      goto LABEL_37;
  }
  v13 = 1 << v12;
  if ( (v13 & 0x19) != 0 )
  {
    if ( dword_77FC0 > 0 )
    {
      v14 = 0;
      while ( 1 )
      {
        v15 = v14++;
        v16 = sub_11F70(v15);
        if ( !*(_BYTE *)(v16 + 129) && *(_DWORD *)(v16 + 132) == 1 )
          break;
        if ( dword_77FC0 <= v14 )
          goto LABEL_37;
      }
      v17 = *(_DWORD *)(dword_78260 + 4 * *(_DWORD *)v16);
      goto LABEL_21;
    }
LABEL_37:
    v17 = *(_DWORD *)(dword_78260 + 4 * v3);
    goto LABEL_21;
  }
  if ( (v13 & 6) == 0 )
    goto LABEL_37;
  if ( a1 && !*(_BYTE *)(a1 + 129) )
  {
    v17 = *(_DWORD *)(dword_78260 + 4 * *(_DWORD *)a1);
    goto LABEL_21;
  }
  if ( dword_77FC0 <= 1 )
    goto LABEL_37;
  v19 = v3;
  v20 = 1;
  while ( 1 )
  {
    ++v19;
    ++v20;
    v21 = 4 * v19;
    if ( v19 >= dword_77FC0 )
    {
      v19 = 0;
      v21 = 0;
    }
    v17 = *(_DWORD *)(dword_78260 + v21);
    if ( !*(_BYTE *)(v17 + 129) && *(_DWORD *)(v17 + 132) == 1 )
      break;
    if ( v20 == dword_77FC0 )
    {
      v17 = *(_DWORD *)(dword_78260 + 4 * v3);
      break;
    }
  }
LABEL_21:
  dword_73E9C = v17;
  if ( pthread_rwlock_unlock(&stru_78850) )
    sub_B578("switch_pools", 5163);
  if ( pthread_mutex_unlock(&stru_78838) )
    sub_B50C("switch_pools", 5163);
  off_72D18();
  if ( byte_7844D )
    sub_1859C(v17, (_BYTE *)(v17 + 130));
  if ( v2 != (_DWORD *)v17 && dword_73D34 != 3 && dword_73D34 != 4 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      snprintf(s, 0x1000u, "Switching to pool %d %s", *(_DWORD *)v17, *(const char **)(v17 + 196));
      sub_385C8(4, s, 0);
    }
    sub_1922C(v2);
  }
  if ( pthread_mutex_lock(&stru_73EA0) )
    sub_B35C("switch_pools", 5178);
  pthread_cond_broadcast(&stru_73EB8);
  if ( pthread_mutex_unlock(&stru_73EA0) )
    sub_B50C("switch_pools", 5180);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73D34: using guessed type int dword_73D34;
// 73E9C: using guessed type int dword_73E9C;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;
// 7844D: using guessed type char byte_7844D;

//----- (0001A95C) --------------------------------------------------------
void __fastcall sub_1A95C(pthread_rwlock_t *a1)
{
  void **nr_readers; // r5
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( a1 && !pthread_rwlock_trywrlock(a1 + 10) )
  {
    nr_readers = (void **)a1[11].__nr_readers;
    a1[11].__nr_readers = 0;
    if ( pthread_rwlock_unlock(a1 + 10) )
      sub_B578("flush_queue", 8991);
    off_72D18();
    if ( nr_readers )
    {
      sub_156B8(nr_readers);
      if ( byte_75C49 )
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
        {
          strcpy(v3, "Discarded queued work item");
          sub_385C8(7, v3, 0);
        }
      }
    }
  }
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001AA68) --------------------------------------------------------
int __fastcall sub_1AA68(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0

  result = pthread_rwlock_rdlock(a1);
  if ( result )
    sub_B5E4(a2, a3);
  return result;
}

//----- (0001AA90) --------------------------------------------------------
int __fastcall sub_1AA90(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_B5E4("get_thread", 614);
  v2 = *(_DWORD *)(dword_78408 + 4 * a1);
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_B578("get_thread", 616);
  off_72D18();
  return v2;
}
// 72D18: using guessed type int (*off_72D18)();
// 78408: using guessed type int dword_78408;

//----- (0001AB08) --------------------------------------------------------
int sub_1AB08()
{
  int v0; // r4
  int v1; // r0
  int v2; // r0
  int v3; // r2
  int v4; // r3
  char v6[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_75C49 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
      goto LABEL_31;
    strcpy(v6, "Received kill message");
    sub_385C8(7, v6, 1);
    if ( byte_75C49 )
    {
      if ( byte_77B70 || byte_75C48 )
      {
LABEL_7:
        strcpy(v6, "Killing off watchpool thread");
        sub_385C8(7, v6, 1);
        goto LABEL_8;
      }
LABEL_31:
      if ( dword_73504 <= 6 )
        goto LABEL_8;
      goto LABEL_7;
    }
  }
LABEL_8:
  sub_2F2A8((int)sub_2A36C, dword_77F24 + (dword_73EE8 << 6), 1000);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v6, "Killing off watchdog thread");
    sub_385C8(7, v6, 1);
  }
  sub_2F2A8((int)sub_2A36C, dword_77F24 + (dword_73EEC << 6), 1000);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v6, "Shutting down mining threads");
    sub_385C8(7, v6, 1);
  }
  if ( dword_78994 > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      v2 = sub_1AA90(v1);
      v3 = dword_78994;
      if ( v2 )
      {
        v4 = *(_DWORD *)(v2 + 36);
        if ( v4 )
          *(_BYTE *)(v4 + 364) = 1;
      }
    }
    while ( v0 < v3 );
  }
  sleep(1u);
  sub_2F2A8((int)sub_1AE44, 0, 3000);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v6, "Killing off API thread");
    sub_385C8(7, v6, 1);
  }
  return sub_2F2A8((int)sub_2A36C, dword_77F24 + (dword_73D30 << 6), 1000);
}
// 73504: using guessed type int dword_73504;
// 73D30: using guessed type int dword_73D30;
// 73EE8: using guessed type int dword_73EE8;
// 73EEC: using guessed type int dword_73EEC;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77F24: using guessed type int dword_77F24;
// 78994: using guessed type int dword_78994;

//----- (0001AE2C) --------------------------------------------------------
int sub_1AE2C()
{
  int result; // r0

  if ( byte_75AE8 )
    return sub_1AB08();
  return result;
}
// 75AE8: using guessed type char byte_75AE8;

//----- (0001AE44) --------------------------------------------------------
void sub_1AE44()
{
  int v0; // r4
  pthread_t v1; // r0
  int v2; // r0
  int v3; // r5
  char v4[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v4, "Killing off mining threads");
    sub_385C8(7, v4, 1);
  }
  if ( dword_78994 > 0 )
  {
    v0 = 0;
    do
    {
      while ( 1 )
      {
        v2 = sub_1AA90(v0);
        v3 = v2;
        if ( v2 )
        {
          if ( *(_DWORD *)(v2 + 12) )
            break;
        }
        ++v0;
        sub_2A36C(v2);
        if ( dword_78994 <= v0 )
          return;
      }
      sub_2A36C(v2);
      v1 = *(_DWORD *)(v3 + 12);
      if ( v1 )
        pthread_join(v1, 0);
      ++v0;
    }
    while ( dword_78994 > v0 );
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78994: using guessed type int dword_78994;

//----- (0001AF58) --------------------------------------------------------
int __fastcall sub_1AF58(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(sub_1AA90(a1) + 36) + 8);
}

//----- (0001AF6C) --------------------------------------------------------
void __fastcall sub_1AF6C(const char *a1, _DWORD *a2)
{
  int v4; // r10
  int v5; // r9
  char *v6; // r7
  char *v7; // r6
  char *v8; // r8
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // lr
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // lr
  int v17; // r1
  int v18; // [sp+20h] [bp-140Ch]
  int v19; // [sp+24h] [bp-1408h]
  char s[1024]; // [sp+28h] [bp-1404h] BYREF
  _DWORD v21[5]; // [sp+428h] [bp-1004h] BYREF
  __int16 v22; // [sp+43Ch] [bp-FF0h]

  if ( !dword_73B2C )
    return;
  v4 = a2[436];
  v5 = *(_DWORD *)(sub_1AA90(v4) + 36);
  v19 = a2[437];
  v18 = a2[480];
  v6 = sub_29688((int)(a2 + 40), 32);
  v7 = sub_29688((int)(a2 + 48), 32);
  v8 = sub_29688((int)a2, 128);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         v18,
         a1,
         v6,
         *(const char **)(v19 + 196),
         *(const char **)(*(_DWORD *)(v5 + 4) + 8),
         *(_DWORD *)(v5 + 8),
         v4,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 < 1024 )
  {
    if ( v9 < 0 )
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
        return;
      v11 = "sharelog printf error";
LABEL_11:
      v12 = *(_DWORD *)v11;
      v13 = *((_DWORD *)v11 + 1);
      v14 = *((_DWORD *)v11 + 2);
      v15 = *((_DWORD *)v11 + 3);
      v16 = v11 + 16;
      v21[0] = v12;
      v21[1] = v13;
      v21[2] = v14;
      v21[3] = v15;
      v17 = v16[1];
      v21[4] = *v16;
      v22 = v17;
      sub_385C8(3, (const char *)v21, 0);
      return;
    }
  }
  else
  {
    s[1023] = 0;
  }
  if ( pthread_mutex_lock(&stru_73EF0) )
    sub_B35C("sharelog", 673);
  v10 = fwrite(s, v9, 1u, (FILE *)dword_73B2C);
  fflush((FILE *)dword_73B2C);
  if ( pthread_mutex_unlock(&stru_73EF0) )
    sub_B50C("sharelog", 676);
  off_72D18();
  if ( v10 != 1 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
  {
    v11 = "sharelog fwrite error";
    goto LABEL_11;
  }
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73B2C: using guessed type int dword_73B2C;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0001B1A8) --------------------------------------------------------
int __fastcall sub_1B1A8(int a1)
{
  int v2; // r4

  if ( pthread_rwlock_rdlock(&stru_78528) )
    sub_B5E4("get_devices", 632);
  v2 = *(_DWORD *)(dword_78450 + 4 * a1);
  if ( pthread_rwlock_unlock(&stru_78528) )
    sub_B578("get_devices", 634);
  off_72D18();
  return v2;
}
// 72D18: using guessed type int (*off_72D18)();
// 78450: using guessed type int dword_78450;

//----- (0001B220) --------------------------------------------------------
int sub_1B220()
{
  int *v0; // r12
  int *v1; // r2
  int v2; // r4
  int v3; // t1
  int result; // r0
  int v5; // r7
  int v6; // r0
  int v7; // r6

  sub_2A7A4((struct timeval *)&dword_73F08);
  sub_2A488(dword_73F10, &dword_73F08);
  dbl_78AC0 = 0.0;
  v0 = (int *)&unk_73F18;
  dbl_78938 = 0.0;
  dbl_78120 = 0.0;
  dbl_78AB0 = 0.0;
  dbl_77AE8 = 0.0;
  do
  {
    *(_QWORD *)v0 = 0;
    v0 += 2;
  }
  while ( v0 != &dword_73F78 );
  byte_73F7C = 1;
  dword_786D0 = 0;
  dword_78948 = 0;
  dbl_72C28 = 1.0;
  dbl_72438 = 1.0;
  dword_73F78 = 0;
  dword_77C90 = 0;
  *(_QWORD *)&dword_78470 = 0;
  dword_786CC = 0;
  dbl_78410 = 0.0;
  dword_782F4 = 0;
  dbl_78498 = 0.0;
  dword_78264 = 0;
  dbl_78250 = 0.0;
  dword_786E0 = 0;
  qword_78248 = 0;
  qword_78520 = 0;
  *(_QWORD *)&dword_78AA8 = 0;
  *(_QWORD *)&dword_785F0 = 0;
  *(_QWORD *)&dword_77F28 = 0;
  if ( dword_77FC0 > 0 )
  {
    v1 = (int *)dword_78260;
    v2 = dword_78260 + 4 * dword_77FC0;
    do
    {
      v3 = *v1++;
      *(_QWORD *)(v3 + 104) = 0;
      *(_QWORD *)(v3 + 112) = 0;
      *(_QWORD *)(v3 + 120) = 0;
      *(_QWORD *)(v3 + 392) = 0;
      *(_DWORD *)(v3 + 148) = 0;
      *(_DWORD *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 12) = 0;
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 152) = 0;
      *(_DWORD *)(v3 + 156) = 0;
      *(_DWORD *)(v3 + 160) = 0;
      *(_DWORD *)(v3 + 164) = 0;
      *(_DWORD *)(v3 + 384) = 0;
      *(_DWORD *)(v3 + 40) = 0;
      *(_DWORD *)(v3 + 44) = 0;
    }
    while ( v1 != (int *)v2 );
  }
  result = sub_15FEC();
  if ( dword_78548 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = v5++;
      v7 = sub_1B1A8(v6);
      sub_2A488((_DWORD *)(v7 + 368), &dword_73F08);
      if ( pthread_mutex_lock(&stru_781AC) )
        sub_B35C("zero_stats", 5874);
      *(_QWORD *)(v7 + 80) = 0;
      *(_DWORD *)(v7 + 36) = 0;
      *(_QWORD *)(v7 + 192) = 0;
      *(_QWORD *)(v7 + 88) = 0;
      *(_DWORD *)(v7 + 40) = 0;
      *(_QWORD *)(v7 + 200) = 0;
      *(_DWORD *)(v7 + 44) = 0;
      *(_QWORD *)(v7 + 208) = 0;
      *(_DWORD *)(v7 + 220) = 0;
      *(_QWORD *)(v7 + 224) = 0;
      if ( pthread_mutex_unlock(&stru_781AC) )
        sub_B50C("zero_stats", 5885);
      off_72D18();
      result = (*(int (__fastcall **)(int))(*(_DWORD *)(v7 + 4) + 96))(v7);
    }
    while ( dword_78548 > v5 );
  }
  return result;
}
// 72438: using guessed type double dbl_72438;
// 72C28: using guessed type double dbl_72C28;
// 72D18: using guessed type int (*off_72D18)();
// 73F08: using guessed type int dword_73F08;
// 73F10: using guessed type _DWORD dword_73F10[2];
// 73F78: using guessed type int dword_73F78;
// 73F7C: using guessed type char byte_73F7C;
// 77AE8: using guessed type double dbl_77AE8;
// 77C90: using guessed type int dword_77C90;
// 77F28: using guessed type int dword_77F28;
// 77FC0: using guessed type int dword_77FC0;
// 78120: using guessed type double dbl_78120;
// 78248: using guessed type __int64 qword_78248;
// 78250: using guessed type double dbl_78250;
// 78260: using guessed type int dword_78260;
// 78264: using guessed type int dword_78264;
// 782F4: using guessed type int dword_782F4;
// 78410: using guessed type double dbl_78410;
// 78470: using guessed type int dword_78470;
// 78498: using guessed type double dbl_78498;
// 78520: using guessed type __int64 qword_78520;
// 78548: using guessed type int dword_78548;
// 785F0: using guessed type int dword_785F0;
// 786CC: using guessed type int dword_786CC;
// 786D0: using guessed type int dword_786D0;
// 786E0: using guessed type int dword_786E0;
// 78938: using guessed type double dbl_78938;
// 78948: using guessed type int dword_78948;
// 78AA8: using guessed type int dword_78AA8;
// 78AB0: using guessed type double dbl_78AB0;
// 78AC0: using guessed type double dbl_78AC0;

//----- (0001B514) --------------------------------------------------------
void __fastcall sub_1B514(int a1, __int64 a2)
{
  double v3; // d0
  int v6; // r7
  int v7; // r6
  int v8; // r0
  int v9; // r8
  double v10; // r0
  double v11; // d8
  double v12; // r0
  double v13; // r0
  double v14; // r0
  int v15; // r7
  int v16; // r0
  int v17; // r6
  double v18; // r0
  double v19; // r0
  double v20; // r0
  double v21; // r0
  double v22; // r0
  double v23; // d11
  int v24; // r3
  double v25; // d16
  int v26; // r3
  __int64 v27; // d16
  int v28; // r8
  int *v29; // r9
  double v30; // d8
  double v31; // r0
  int v32; // r1
  int v33; // r1
  double v34; // r0
  double v35; // r0
  double v36; // r0
  double v37; // r0
  int v38; // r0
  __int64 v39; // r0
  unsigned __int64 v40; // r0
  unsigned __int64 v41; // r0
  unsigned __int64 v42; // r0
  unsigned __int64 v43; // r0
  unsigned __int64 v44; // r0
  char v45[16]; // [sp+20h] [bp-1134h] BYREF
  char v46[16]; // [sp+30h] [bp-1124h] BYREF
  char v47[16]; // [sp+40h] [bp-1114h] BYREF
  char v48[256]; // [sp+50h] [bp-1104h] BYREF
  char s[4100]; // [sp+150h] [bp-1004h] BYREF

  sub_2A7A4((struct timeval *)&dword_73F80);
  sub_2A97C();
  v6 = dword_73F80;
  if ( dword_73F80 - dword_73F88 < dword_72C0C )
  {
    if ( a1 < 0 )
      return;
    sub_2A488(dword_73F10, &dword_73F80);
    v7 = 0;
  }
  else
  {
    dword_73F88 = dword_73F80;
    byte_73F8C ^= byte_73F8D;
    sub_2A488(dword_73F10, &dword_73F80);
    if ( a1 < 0 )
    {
      if ( pthread_mutex_lock(&stru_781AC) )
        sub_B35C("hashmeter", 6763);
      if ( dword_78994 > 0 )
      {
        v15 = 0;
        do
        {
          v16 = v15++;
          v17 = *(_DWORD *)(sub_1AA90(v16) + 36);
          sub_2A97C();
          sub_2A488((_DWORD *)(v17 + 140), &dword_73F80);
          HIDWORD(v18) = dword_72C0C;
          LODWORD(v18) = v17 + 48;
          sub_156D0(v18);
          LODWORD(v19) = v17 + 56;
          sub_156D0(v19);
          LODWORD(v20) = v17 + 64;
          sub_156D0(v20);
          LODWORD(v21) = v17 + 72;
          v3 = 0.0;
          sub_156D0(v21);
        }
        while ( dword_78994 > v15 );
      }
      if ( pthread_mutex_unlock(&stru_781AC) )
        sub_B50C("hashmeter", 6776);
      v7 = 1;
      off_72D18();
      goto LABEL_24;
    }
    v7 = 1;
  }
  v8 = sub_1AA90(a1);
  v9 = *(_DWORD *)(v8 + 36);
  sub_2A488((_DWORD *)(v8 + 44), &dword_73F80);
  *(_DWORD *)(v9 + 240) = v6;
  sub_2A97C();
  sub_2A488((_DWORD *)(v9 + 140), &dword_73F80);
  if ( pthread_mutex_lock(&stru_781AC) )
    sub_B35C("hashmeter", 6737);
  LODWORD(v10) = sub_59F08(a2);
  v11 = v10;
  HIDWORD(v10) = dword_72C0C;
  LODWORD(v10) = v9 + 48;
  *(double *)(v9 + 80) = *(double *)(v9 + 80) + v11;
  sub_156D0(v10);
  LODWORD(v12) = v9 + 56;
  sub_156D0(v12);
  LODWORD(v13) = v9 + 64;
  sub_156D0(v13);
  LODWORD(v14) = v9 + 72;
  v3 = v11;
  sub_156D0(v14);
  if ( pthread_mutex_unlock(&stru_781AC) )
    sub_B50C("hashmeter", 6743);
  off_72D18();
  sub_1767C(v48, 0x100u, v9);
  if ( byte_73E80 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "%s", v48);
      sub_385C8(7, s, 0);
    }
  }
  else
  {
    printf("%s          \r", v48);
    fflush((FILE *)stdout);
  }
LABEL_24:
  if ( pthread_mutex_lock(&stru_781AC) )
    sub_B35C("hashmeter", 6779);
  LODWORD(v22) = sub_59F08(a2);
  v23 = v22;
  dbl_77AE8 = v22 + dbl_77AE8;
  if ( v7 )
  {
    v26 = dword_73F78 + 1;
    v27 = 0;
    v28 = 0;
    v29 = (int *)dbl_73F18;
    if ( dword_73F78 + 1 > 11 )
      v26 = 0;
    dword_73F78 = v26;
    do
    {
      v30 = *(double *)v29;
      v29 += 2;
      if ( v30 >= 0.0 )
      {
        LODWORD(v31) = sub_59F08(v27);
        ++v28;
        LODWORD(v27) = sub_5A000(v30 + v31);
        HIDWORD(v27) = v32;
      }
    }
    while ( v29 != &dword_73F78 );
    if ( v28 )
    {
      LODWORD(a2) = sub_59F7C(v27, v28);
      HIDWORD(a2) = v33;
    }
    sub_59F08(a2);
    LODWORD(v34) = &dbl_78938;
    sub_156D0(v34);
    LODWORD(v35) = &dbl_78AC0;
    sub_156D0(v35);
    LODWORD(v36) = &dbl_78AB0;
    sub_156D0(v36);
    LODWORD(v37) = &dbl_78120;
    v38 = sub_156D0(v37);
    v3 = dbl_78938;
    v39 = llround(v38);
    v25 = 0.0;
    v24 = dword_73F78;
    dbl_73F18[dword_73F78] = 0.0;
    *(_QWORD *)&dword_788F8 = 1000000 * v39;
  }
  else
  {
    v24 = dword_73F78;
    v25 = dbl_73F18[dword_73F78];
  }
  dbl_73F18[v24] = v25 + v23;
  sub_2A97C();
  dbl_72438 = v3;
  if ( v3 - dbl_72C28 > 86400.0 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(s, 0x1000u, "cgminer time error total_secs = %f last_total_secs = %f", v3, dbl_72C28);
      sub_385C8(3, s, 0);
    }
    if ( pthread_mutex_unlock(&stru_781AC) )
      sub_B50C("hashmeter", 6819);
    off_72D18();
    sub_1B220();
    if ( pthread_mutex_lock(&stru_781AC) )
      sub_B35C("hashmeter", 6821);
  }
  else
  {
    dbl_72C28 = v3;
  }
  if ( v7 )
  {
    LODWORD(v40) = sub_5A000(dbl_77AE8 / dbl_72438 * 1000000.0);
    sub_114B8(v40, v45, 0x10u, 4);
    dbl_73F90 = dbl_78938 / 1000.0;
    LODWORD(v41) = sub_5A000(dbl_78938 * 1000000.0);
    sub_114B8(v41, v46, 0x10u, 4);
    LODWORD(v42) = sub_5A000(dbl_78AC0 * 1000000.0);
    sub_114B8(v42, v47, 0x10u, 4);
    LODWORD(v43) = sub_5A000(dbl_78AB0 * 1000000.0);
    sub_114B8(v43, v48, 0x10u, 4);
    LODWORD(v44) = sub_5A000(dbl_78120 * 1000000.0);
    sub_114B8(v44, s, 0x10u, 4);
    snprintf(byte_73F98, 0x100u, "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s", dword_72C0C, v46, v47, v48, s, v45);
  }
  if ( pthread_mutex_unlock(&stru_781AC) )
    sub_B50C("hashmeter", 6850);
  off_72D18();
  if ( v7 )
  {
    if ( byte_73E80 )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(s, 0x1000u, "%s", byte_73F98);
        sub_385C8(7, s, 0);
      }
    }
    else
    {
      printf("%s          \r", byte_73F98);
      fflush((FILE *)stdout);
    }
  }
}
// 1B5EC: variable 'v10' is possibly undefined
// 1B620: variable 'v12' is possibly undefined
// 1B634: variable 'v13' is possibly undefined
// 1B648: variable 'v14' is possibly undefined
// 1B7B0: variable 'v19' is possibly undefined
// 1B7C4: variable 'v20' is possibly undefined
// 1B7D8: variable 'v21' is possibly undefined
// 1B830: variable 'v22' is possibly undefined
// 1B880: variable 'v3' is possibly undefined
// 1BB84: variable 'v40' is possibly undefined
// 1BBB4: variable 'v41' is possibly undefined
// 1BBD8: variable 'v42' is possibly undefined
// 1BBFC: variable 'v43' is possibly undefined
// 1BC20: variable 'v44' is possibly undefined
// 1BA70: variable 'v31' is possibly undefined
// 1BA78: variable 'v32' is possibly undefined
// 1BA9C: variable 'v33' is possibly undefined
// 1BAC8: variable 'v34' is possibly undefined
// 1BADC: variable 'v35' is possibly undefined
// 1BAF0: variable 'v36' is possibly undefined
// 1BB04: variable 'v37' is possibly undefined
// B0D4: using guessed type __int64 __fastcall llround(_DWORD);
// 72438: using guessed type double dbl_72438;
// 72C0C: using guessed type int dword_72C0C;
// 72C28: using guessed type double dbl_72C28;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73A04: using guessed type int stdout;
// 73E80: using guessed type char byte_73E80;
// 73F10: using guessed type _DWORD dword_73F10[2];
// 73F18: using guessed type double dbl_73F18[12];
// 73F78: using guessed type int dword_73F78;
// 73F80: using guessed type int dword_73F80;
// 73F88: using guessed type int dword_73F88;
// 73F8C: using guessed type char byte_73F8C;
// 73F8D: using guessed type char byte_73F8D;
// 73F90: using guessed type double dbl_73F90;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77AE8: using guessed type double dbl_77AE8;
// 77B70: using guessed type char byte_77B70;
// 78120: using guessed type double dbl_78120;
// 788F8: using guessed type int dword_788F8;
// 78938: using guessed type double dbl_78938;
// 78994: using guessed type int dword_78994;
// 78AB0: using guessed type double dbl_78AB0;
// 78AC0: using guessed type double dbl_78AC0;

//----- (0001BFD8) --------------------------------------------------------
int sub_1BFD8()
{
  int v0; // r3
  double v1; // d9
  int v2; // r7
  int v3; // r5
  int v4; // r9
  double v5; // r0
  double v6; // d10
  double v7; // r0
  double v8; // d9
  __int64 v9; // r6
  __int64 v10; // r10
  int v11; // r1
  double v12; // d8
  double v13; // r0
  int v14; // r11
  int v15; // r1
  int v16; // r2
  __int64 v17; // r4
  __int64 v18; // kr08_8
  int v19; // r1
  double v20; // d8
  double v21; // r0
  int v22; // r4
  int v23; // r0
  int v24; // r0
  int v25; // r2
  double v26; // d16
  int v27; // r3
  const char *v29; // r2
  int v30; // [sp+18h] [bp-1114h]
  char v31[256]; // [sp+28h] [bp-1104h] BYREF
  char s[4100]; // [sp+128h] [bp-1004h] BYREF

  v0 = dword_73F80 - dword_73F08;
  if ( dword_73F84 - dword_73F0C < 0 )
    --v0;
  v1 = dbl_72438;
  v2 = v0 / 3600;
  v3 = v0 % 60;
  v4 = v0 % 3600 / 60;
  LODWORD(v5) = sub_59F1C(qword_78248);
  v6 = v5 / v1 * 60.0;
  LODWORD(v7) = sub_59F1C(*(__int64 *)&dword_77F28);
  v8 = v7 / v1 * 60.0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    strcpy(s, "\nSummary of runtime statistics:\n");
    sub_385C8(4, s, 0);
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      snprintf(s, 0x1000u, "Started at %s", byte_74098);
      sub_385C8(4, s, 0);
    }
  }
  if ( dword_77FC0 == 1 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      goto LABEL_28;
    snprintf(s, 0x1000u, "Pool: %s", *(const char **)(*(_DWORD *)dword_78260 + 196));
    sub_385C8(4, s, 0);
  }
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(s, 0x1000u, "Runtime: %d hrs : %d mins : %d secs", v2, v4, v3);
    sub_385C8(4, s, 0);
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      snprintf(s, 0x1000u, "Average hashrate: %.1f Mhash/s", dbl_77AE8 / dbl_72438);
      sub_385C8(4, s, 0);
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, "Solved blocks: %d", dword_786E0);
        sub_385C8(4, s, 0);
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(s, 0x1000u, "Best share difficulty: %s", (const char *)&dword_72C04);
          sub_385C8(4, s, 0);
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, "Share submissions: %lld", qword_78520 + qword_78248);
            sub_385C8(4, s, 0);
            if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
            {
              snprintf(s, 0x1000u, "Accepted shares: %lld", qword_78248);
              sub_385C8(4, s, 0);
              if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
              {
                snprintf(s, 0x1000u, "Rejected shares: %lld", qword_78520);
                sub_385C8(4, s, 0);
                if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
                {
                  snprintf(s, 0x1000u, "Accepted difficulty shares: %1.f", dbl_78410);
                  sub_385C8(4, s, 0);
                  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
                  {
                    snprintf(s, 0x1000u, "Rejected difficulty shares: %1.f", dbl_78498);
                    sub_385C8(4, s, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_28:
  v9 = qword_78248;
  if ( qword_78248 || qword_78520 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      goto LABEL_50;
    v10 = qword_78520;
    LODWORD(v12) = sub_59F1C(100 * qword_78520);
    HIDWORD(v12) = v11;
    LODWORD(v13) = sub_59F1C(v9 + v10);
    snprintf(s, 0x1000u, "Reject ratio: %.1f%%", v12 / v13);
    sub_385C8(4, s, 0);
  }
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(s, 0x1000u, "Hardware errors: %d", dword_786CC);
    sub_385C8(4, s, 0);
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      snprintf(s, 0x1000u, "Utility (accepted shares / min): %.2f/min", v6);
      sub_385C8(4, s, 0);
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v8);
        sub_385C8(4, s, 0);
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(s, 0x1000u, "Stale submissions discarded due to new blocks: %lld", *(_QWORD *)&dword_78AA8);
          sub_385C8(4, s, 0);
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, "Unable to get work from server occasions: %d", dword_78264);
            sub_385C8(4, s, 0);
            if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
            {
              snprintf(s, 0x1000u, "Work items generated locally: %d", dword_782F4);
              sub_385C8(4, s, 0);
              if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
              {
                snprintf(s, 0x1000u, "Submitting work remotely delay occasions: %d", dword_77C90);
                sub_385C8(4, s, 0);
                if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
                {
                  snprintf(s, 0x1000u, "New blocks detected on network: %d\n", dword_78944);
                  sub_385C8(4, s, 0);
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_50:
  if ( dword_77FC0 > 1 )
  {
    v30 = 0;
    while ( 1 )
    {
      v14 = *(_DWORD *)(dword_78260 + 4 * v30);
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
        break;
      snprintf(s, 0x1000u, "Pool: %s", *(const char **)(v14 + 196));
      sub_385C8(4, s, 0);
      v15 = *(_DWORD *)(v14 + 32);
      v16 = (unsigned __int8)byte_77B70;
      if ( !v15 )
        goto LABEL_103;
      if ( !byte_77B70 )
        goto LABEL_59;
LABEL_100:
      v29 = "S";
      if ( v15 <= 1 )
        v29 = "";
      snprintf(s, 0x1000u, "SOLVED %d BLOCK%s!", v15, v29);
      sub_385C8(4, s, 0);
      v16 = (unsigned __int8)byte_77B70;
LABEL_103:
      if ( !v16 )
      {
LABEL_104:
        if ( !byte_75C48 && dword_73504 <= 3 )
          goto LABEL_61;
      }
      snprintf(s, 0x1000u, " Share submissions: %lld", *(_QWORD *)(v14 + 16) + *(_QWORD *)(v14 + 8));
      sub_385C8(4, s, 0);
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, " Accepted shares: %lld", *(_QWORD *)(v14 + 8));
        sub_385C8(4, s, 0);
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(s, 0x1000u, " Rejected shares: %lld", *(_QWORD *)(v14 + 16));
          sub_385C8(4, s, 0);
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, " Accepted difficulty shares: %1.f", *(double *)(v14 + 104));
            sub_385C8(4, s, 0);
            if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
            {
              snprintf(s, 0x1000u, " Rejected difficulty shares: %1.f", *(double *)(v14 + 112));
              sub_385C8(4, s, 0);
            }
          }
        }
      }
LABEL_61:
      if ( !*(_QWORD *)(v14 + 8) && !*(_QWORD *)(v14 + 16) )
        goto LABEL_67;
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        v17 = *(_QWORD *)(v14 + 16);
        v18 = *(_QWORD *)(v14 + 8);
        LODWORD(v20) = sub_59F1C(100 * v17);
        HIDWORD(v20) = v19;
        LODWORD(v21) = sub_59F1C(v18 + v17);
        snprintf(s, 0x1000u, " Reject ratio: %.1f%%", v20 / v21);
        sub_385C8(4, s, 0);
LABEL_67:
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(s, 0x1000u, " Items worked on: %d", *(_DWORD *)(v14 + 68));
          sub_385C8(4, s, 0);
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, " Stale submissions discarded due to new blocks: %d", *(_DWORD *)(v14 + 152));
            sub_385C8(4, s, 0);
            if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
            {
              snprintf(s, 0x1000u, " Unable to get work from server occasions: %d", *(_DWORD *)(v14 + 160));
              sub_385C8(4, s, 0);
              if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
              {
                snprintf(s, 0x1000u, " Submitting work remotely delay occasions: %d\n", *(_DWORD *)(v14 + 164));
                sub_385C8(4, s, 0);
              }
            }
          }
        }
      }
      if ( dword_77FC0 <= ++v30 )
        goto LABEL_77;
    }
    v15 = *(_DWORD *)(v14 + 32);
    if ( !v15 )
      goto LABEL_104;
LABEL_59:
    if ( !byte_75C48 && dword_73504 <= 3 )
      goto LABEL_61;
    goto LABEL_100;
  }
LABEL_77:
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    strcpy(s, "Summary of per device statistics:\n");
    sub_385C8(4, s, 0);
  }
  if ( dword_78548 > 0 )
  {
    v22 = 0;
    do
    {
      v23 = v22++;
      v24 = sub_1B1A8(v23);
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 20) = nullsub_2;
      *(_DWORD *)(*(_DWORD *)(v24 + 4) + 24) = nullsub_4;
      sub_1767C(v31, 0xFFu, v24);
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, "%s", v31);
        sub_385C8(4, s, 0);
      }
    }
    while ( dword_78548 > v22 );
  }
  v25 = dword_740C0;
  if ( !dword_740C0 )
    goto LABEL_95;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(s, 0x1000u, "Mined %.0f accepted shares of %d requested\n", dbl_78410, dword_740C0);
    sub_385C8(4, s, 0);
    v25 = dword_740C0;
    v26 = dbl_78410;
    v27 = (unsigned __int8)byte_77B70;
    if ( (double)dword_740C0 <= dbl_78410 )
      goto LABEL_96;
    if ( byte_77B70 )
      goto LABEL_94;
  }
  else
  {
    v26 = dbl_78410;
    if ( (double)dword_740C0 <= dbl_78410 )
    {
LABEL_97:
      if ( !byte_75C48 && dword_73504 <= 3 )
        goto LABEL_99;
LABEL_98:
      strcpy(s, " ");
      sub_385C8(4, s, 0);
      goto LABEL_99;
    }
  }
  if ( byte_75C48 || dword_73504 > 3 )
  {
LABEL_94:
    snprintf(s, 0x1000u, "WARNING - Mined only %.0f shares of %d requested.", v26, v25);
    sub_385C8(4, s, 0);
LABEL_95:
    v27 = (unsigned __int8)byte_77B70;
LABEL_96:
    if ( v27 )
      goto LABEL_98;
    goto LABEL_97;
  }
LABEL_99:
  fflush((FILE *)stderr);
  return fflush((FILE *)stdout);
}
// 1C088: variable 'v5' is possibly undefined
// 1C0A0: variable 'v7' is possibly undefined
// 1C544: variable 'v11' is possibly undefined
// 1C568: variable 'v13' is possibly undefined
// 1C8E8: variable 'v19' is possibly undefined
// 1C90C: variable 'v21' is possibly undefined
// F6D0: using guessed type int nullsub_2();
// F6D4: using guessed type int nullsub_4();
// 72438: using guessed type double dbl_72438;
// 72C04: using guessed type int dword_72C04;
// 73504: using guessed type int dword_73504;
// 73A04: using guessed type int stdout;
// 73A08: using guessed type int stderr;
// 73F08: using guessed type int dword_73F08;
// 73F0C: using guessed type int dword_73F0C;
// 73F80: using guessed type int dword_73F80;
// 73F84: using guessed type int dword_73F84;
// 740C0: using guessed type int dword_740C0;
// 75C48: using guessed type char byte_75C48;
// 77AE8: using guessed type double dbl_77AE8;
// 77B70: using guessed type char byte_77B70;
// 77C90: using guessed type int dword_77C90;
// 77F28: using guessed type int dword_77F28;
// 77FC0: using guessed type int dword_77FC0;
// 78248: using guessed type __int64 qword_78248;
// 78260: using guessed type int dword_78260;
// 78264: using guessed type int dword_78264;
// 782F4: using guessed type int dword_782F4;
// 78410: using guessed type double dbl_78410;
// 78498: using guessed type double dbl_78498;
// 78520: using guessed type __int64 qword_78520;
// 78548: using guessed type int dword_78548;
// 786CC: using guessed type int dword_786CC;
// 786E0: using guessed type int dword_786E0;
// 78944: using guessed type int dword_78944;
// 78AA8: using guessed type int dword_78AA8;

//----- (0001D138) --------------------------------------------------------
void sub_1D138()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(v0, 0x1000u, "Attempting to restart %s", byte_73A2C);
    sub_385C8(4, v0, 0);
  }
  sub_2F2A8((int)sub_1AE2C, 0, 5000);
  sub_2A7A4((struct timeval *)&dword_73F80);
  sub_195CC();
  if ( dword_740C4 > 0 )
  {
    kill(dword_740C4, 15);
    dword_740C4 = 0;
  }
  execv(*(const char **)dword_740C8, (char *const *)dword_740C8);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    strcpy(v0, "Failed to restart application");
    sub_385C8(4, v0, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 73F80: using guessed type int dword_73F80;
// 740C4: using guessed type int dword_740C4;
// 740C8: using guessed type int dword_740C8;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0001D26C) --------------------------------------------------------
void __fastcall __noreturn sub_1D26C(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, (void *(*)(void *))sub_11B54, 0) )
  {
    if ( a2 )
    {
      sub_2A7A4((struct timeval *)&dword_73F80);
      sub_195CC();
      if ( !byte_78940 && byte_75AE8 )
        sub_1BFD8();
    }
    else
    {
      sub_195CC();
    }
    if ( dword_740C4 > 0 )
    {
      kill(dword_740C4, 15);
      dword_740C4 = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}
// 73F80: using guessed type int dword_73F80;
// 740C4: using guessed type int dword_740C4;
// 75AE8: using guessed type char byte_75AE8;
// 78940: using guessed type char byte_78940;

//----- (0001D324) --------------------------------------------------------
int __fastcall sub_1D324(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B5E4("find_queued_work_bymidstate", 8856);
  v11 = sub_169B8(a1[11].__lock, a2, a3, a4, a5, a6);
  if ( pthread_rwlock_unlock(v6) )
    sub_B578("find_queued_work_bymidstate", 8858);
  off_72D18();
  return v11;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001D3C8) --------------------------------------------------------
int __fastcall sub_1D3C8(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  int lock; // r3
  int v6; // r4

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B5E4("find_queued_work_byid", 8900);
  lock = a1[11].__lock;
  if ( lock && (v6 = *(_DWORD *)(lock + 1840), a2 != *(_DWORD *)(lock + 1828)) )
  {
    while ( v6 && a2 != *(_DWORD *)(v6 + 1828) )
      v6 = *(_DWORD *)(v6 + 1840);
  }
  else
  {
    v6 = lock;
  }
  if ( pthread_rwlock_unlock(v2) )
    sub_B578("find_queued_work_byid", 8902);
  off_72D18();
  return v6;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001D478) --------------------------------------------------------
_DWORD *__fastcall sub_1D478(pthread_rwlock_t *a1, void *a2, size_t a3, const void *a4, int a5, size_t a6)
{
  pthread_rwlock_t *v6; // r4
  int v11; // r0
  _DWORD *v12; // r5

  v6 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B5E4("clone_queued_work_bymidstate", 8867);
  v11 = sub_169B8(a1[11].__lock, a2, a3, a4, a5, a6);
  v12 = (_DWORD *)v11;
  if ( v11 )
    v12 = sub_1A598(v11, 0);
  if ( pthread_rwlock_unlock(v6) )
    sub_B578("clone_queued_work_bymidstate", 8871);
  off_72D18();
  return v12;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001D52C) --------------------------------------------------------
_DWORD *__fastcall sub_1D52C(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r5
  int lock; // r2
  _DWORD *v6; // r4
  int v7; // r0

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    sub_B5E4("clone_queued_work_byid", 8911);
  lock = a1[11].__lock;
  if ( lock )
  {
    v7 = *(_DWORD *)(lock + 1840);
    if ( a2 == *(_DWORD *)(lock + 1828) )
    {
      v7 = a1[11].__lock;
LABEL_12:
      v6 = sub_1A598(v7, 0);
    }
    else
    {
      while ( v7 )
      {
        if ( a2 == *(_DWORD *)(v7 + 1828) )
          goto LABEL_12;
        v7 = *(_DWORD *)(v7 + 1840);
      }
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( pthread_rwlock_unlock(v2) )
    sub_B578("clone_queued_work_byid", 8915);
  off_72D18();
  return v6;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0001D5F0) --------------------------------------------------------
int __fastcall sub_1D5F0(int a1, int a2)
{
  pthread_mutex_t *v2; // r6
  __int64 v5; // r2
  size_t v6; // r0
  int v7; // r2
  int v8; // lr
  int v9; // r0
  int v10; // r12
  int v11; // r11
  int v12; // r0
  int v13; // r12
  int v14; // lr
  int v15; // r12
  int v16; // r2
  int v17; // lr
  const char *v19; // r0
  char *v20; // r11
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  v2 = (pthread_mutex_t *)(a1 + 244);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 244)) )
    sub_B35C("gen_stratum_work", 7936);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B3C8("gen_stratum_work", 7936);
  v5 = *(_QWORD *)(a1 + 648);
  *(_QWORD *)(a2 + 1784) = v5;
  *(_QWORD *)(a1 + 648) = v5 + 1;
  *(_DWORD *)(a2 + 1792) = 2;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B578("gen_stratum_work", 7941);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B5E4("gen_stratum_work", 7941);
  if ( pthread_mutex_unlock(v2) )
    sub_B50C("gen_stratum_work", 7941);
  memset((void *)(a2 + 224), 0, 0x5CFu);
  memcpy((void *)(a2 + 224), (const void *)(a1 + 1604), 0x80u);
  v6 = strlen(*(const char **)(a1 + 636));
  sub_29788((_BYTE *)(a2 + 332), *(unsigned __int8 **)(a1 + 636), v6 >> 1);
  memcpy((void *)(a2 + 352 - *(_DWORD *)(a2 + 1792)), (const void *)(a2 + 1784), *(_DWORD *)(a2 + 1792));
  sub_163CC((char *)(a2 + 364), 0x540u);
  *(_QWORD *)(a2 + 1800) = *(_QWORD *)(a1 + 712);
  *(_DWORD *)(a2 + 1776) = _strdup(*(const char **)(a1 + 672));
  *(_DWORD *)(a2 + 1808) = _strdup(*(const char **)(a1 + 636));
  *(_DWORD *)(a2 + 1796) = _strdup(*(const char **)(a1 + 692));
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 268)) )
    sub_B578("gen_stratum_work", 7962);
  off_72D18();
  if ( byte_75C49 )
  {
    v19 = sub_29688(a2 + 224, 143);
    v20 = (char *)v19;
    if ( byte_75C49 )
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_18;
      snprintf(s, 0x1000u, "[THR%d] Generated stratum header %s", *(_DWORD *)(a2 + 1744), v19);
      sub_385C8(7, s, 0);
      if ( byte_75C49 )
      {
        if ( byte_77B70 || byte_75C48 )
        {
LABEL_16:
          snprintf(
            s,
            0x1000u,
            "[THR%d] job_id %s, nonce1 %s, nonce2 %llu, ntime %s",
            *(_DWORD *)(a2 + 1744),
            *(const char **)(a2 + 1776),
            *(const char **)(a2 + 1808),
            *(_QWORD *)(a2 + 1784),
            *(const char **)(a2 + 1796));
          sub_385C8(7, s, 0);
          goto LABEL_17;
        }
LABEL_18:
        if ( dword_73504 <= 6 )
          goto LABEL_17;
        goto LABEL_16;
      }
    }
LABEL_17:
    free(v20);
  }
  v7 = dword_73E98;
  v8 = *(_DWORD *)(a1 + 76);
  v9 = *(_DWORD *)(a1 + 80);
  v10 = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a2 + 160) = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a2 + 164) = v8;
  *(_DWORD *)(a2 + 168) = v9;
  *(_DWORD *)(a2 + 172) = v10;
  v11 = *(_DWORD *)(a1 + 88);
  v12 = *(_DWORD *)(a1 + 96);
  v13 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a2 + 180) = *(_DWORD *)(a1 + 92);
  v14 = dword_73E98;
  *(_DWORD *)(a2 + 188) = v13;
  v15 = v7 + 1;
  v16 = dword_782F4;
  *(_DWORD *)(a2 + 1828) = v14;
  v17 = dword_740CC;
  *(_DWORD *)(a2 + 184) = v12;
  *(_DWORD *)(a2 + 176) = v11;
  *(_DWORD *)(a2 + 1748) = a1;
  *(_DWORD *)(a2 + 1824) = v17;
  *(_BYTE *)(a2 + 1772) = 1;
  *(_BYTE *)(a2 + 1768) = 0;
  *(_BYTE *)(a2 + 1928) = 83;
  *(_DWORD *)(a2 + 1732) = 60;
  dword_73E98 = v15;
  dword_782F4 = v16 + 1;
  sub_11994(a2);
  return sub_2A7A4((struct timeval *)(a2 + 1752));
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E98: using guessed type int dword_73E98;
// 740CC: using guessed type int dword_740CC;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 782F4: using guessed type int dword_782F4;

//----- (0001D9A0) --------------------------------------------------------
int sub_1D9A0()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_78838) )
    sub_B35C("current_pool", 796);
  if ( pthread_rwlock_rdlock(&stru_78850) )
    sub_B5E4("current_pool", 796);
  if ( pthread_mutex_unlock(&stru_78838) )
    sub_B50C("current_pool", 796);
  v0 = dword_73E9C;
  if ( pthread_rwlock_unlock(&stru_78850) )
    sub_B578("current_pool", 798);
  off_72D18();
  return v0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73E9C: using guessed type int dword_73E9C;

//----- (0001DA54) --------------------------------------------------------
int __fastcall sub_1DA54(int a1)
{
  int v1; // r11
  unsigned __int64 v2; // d17
  int v3; // r5
  int v4; // r4
  int v6; // r8
  int v7; // r7
  int v8; // r6
  int v9; // lr
  int v10; // r4
  int v11; // r3
  int v12; // r12
  int v13; // r10
  size_t v14; // r0
  unsigned int v15; // r12
  unsigned __int8 *v16; // r3
  int v17; // r1
  size_t v18; // r4
  int v19; // r0
  unsigned int v20; // r2
  unsigned int v21; // r12
  int v22; // lr
  int v23; // r8
  int v24; // r7
  int v25; // r6
  unsigned int v26; // r0
  int v27; // r1
  unsigned int v28; // r12
  unsigned int v29; // r0
  int v30; // r1
  unsigned int v31; // r12
  unsigned int v32; // r0
  size_t v33; // r0
  _DWORD *v34; // r6
  int v35; // r1
  unsigned int v36; // r2
  unsigned int v37; // r3
  int v38; // r1
  unsigned int v39; // r2
  unsigned int v40; // r3
  int v41; // r1
  int v42; // r6
  char *v43; // r3
  char *v44; // r0
  int v45; // r7
  int v46; // r3
  int *v47; // r10
  int v48; // r6
  int v49; // r9
  int v50; // r2
  int v51; // r12
  int v52; // lr
  unsigned int v53; // r8
  int v54; // r3
  int v55; // r1
  int v56; // r0
  int *v57; // r0
  int v58; // r4
  bool v59; // zf
  int v60; // r3
  bool v61; // zf
  int v62; // r9
  int v63; // r3
  int v64; // r2
  int v65; // r0
  int v66; // r3
  _DWORD *v67; // r2
  int v68; // r3
  int v69; // r2
  int v70; // r3
  int v71; // r3
  _DWORD *v72; // r0
  _DWORD *v73; // r4
  void *v74; // r0
  int v75; // r3
  int v76; // r3
  int v77; // r1
  int v78; // r2
  int v79; // r3
  int v80; // r1
  int v81; // r2
  int v82; // r3
  int v83; // r11
  int v84; // r3
  unsigned int v85; // r10
  size_t v86; // r0
  unsigned int v87; // r9
  unsigned __int8 *v88; // r4
  int v89; // r8
  int v90; // r1
  int v91; // r12
  int v92; // r2
  int v93; // r0
  unsigned int v94; // r3
  unsigned int v95; // r10
  int v96; // r8
  unsigned int v97; // r2
  unsigned int v98; // r3
  int v99; // r1
  unsigned int v100; // r2
  unsigned int v101; // r3
  size_t v102; // r11
  int v103; // r0
  unsigned int v104; // r2
  unsigned int v105; // r3
  int v106; // r0
  unsigned int v107; // r2
  unsigned int v108; // r3
  unsigned int v109; // r0
  unsigned int v110; // r3
  _DWORD *v111; // r2
  int v112; // r3
  int v113; // r2
  int v114; // r2
  int v115; // r4
  size_t v116; // r6
  _DWORD *v117; // r0
  _DWORD *v118; // r8
  int v119; // r1
  unsigned int v120; // r6
  int v121; // r11
  int v122; // r5
  _DWORD *v123; // r4
  _DWORD *v124; // r10
  int v125; // r6
  char *v126; // r7
  unsigned int v127; // r3
  int v128; // r3
  _DWORD *v129; // r3
  unsigned int v130; // r1
  unsigned int v131; // r2
  bool v132; // cc
  int v133; // r2
  int v134; // r3
  signed int v135; // s16
  double v136; // r0
  double v137; // d8
  struct tm *v138; // r0
  int j; // r3
  int v140; // r1
  int v141; // r2
  int v142; // r3
  int v143; // r7
  int v144; // r1
  int v145; // r2
  int v146; // r3
  int v147; // r2
  char *v148; // r3
  unsigned __int64 v149; // r0
  int v150; // [sp+8h] [bp-107Ch]
  unsigned int i; // [sp+8h] [bp-107Ch]
  _DWORD *v152; // [sp+Ch] [bp-1078h]
  int v153; // [sp+10h] [bp-1074h]
  int v154; // [sp+14h] [bp-1070h]
  time_t timer; // [sp+18h] [bp-106Ch] BYREF
  int s2; // [sp+1Ch] [bp-1068h] BYREF
  int v157; // [sp+20h] [bp-1064h]
  int v158; // [sp+24h] [bp-1060h]
  int v159; // [sp+28h] [bp-105Ch]
  int v160; // [sp+2Ch] [bp-1058h]
  int v161; // [sp+30h] [bp-1054h]
  int v162; // [sp+34h] [bp-1050h]
  int v163; // [sp+38h] [bp-104Ch]
  char s[68]; // [sp+3Ch] [bp-1048h] BYREF
  char v165[4096]; // [sp+80h] [bp-1004h] BYREF

  v3 = a1;
  v152 = *(_DWORD **)(a1 + 1748);
  if ( *(_BYTE *)(a1 + 1770) )
    return 1;
  v6 = *(_DWORD *)(a1 + 28);
  v7 = *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 20);
  v9 = *(_DWORD *)(a1 + 12);
  v10 = *(_DWORD *)(a1 + 16);
  s2 = *(_DWORD *)(a1 + 32);
  v11 = *(_DWORD *)(a1 + 4);
  v12 = *(_DWORD *)(a1 + 8);
  v161 = v9;
  v157 = v6;
  v162 = v12;
  v163 = v11;
  v158 = v7;
  v159 = v8;
  v160 = v10;
  sub_29630(s, (char *)&s2, 32);
  if ( pthread_rwlock_rdlock(&stru_740D0) )
    sub_B5E4("block_exists", 5347);
  v13 = dword_740F0;
  if ( dword_740F0 )
  {
    v14 = strlen(s);
    v15 = -1640531527;
    v16 = (unsigned __int8 *)s;
    v17 = -1640531527;
    v18 = v14;
    v132 = v14 > 0xB;
    v19 = -17973521;
    v20 = v18;
    if ( v132 )
    {
      do
      {
        v20 -= 12;
        v1 = v16[7];
        v21 = (v16[6] << 16) + (v16[5] << 8) + v16[4] + (v1 << 24) + v15;
        v22 = (v16[2] << 16) + (v16[1] << 8) + *v16;
        v23 = v16[3];
        v24 = v16[11];
        v25 = (v16[10] << 16) + (v16[9] << 8) + v16[8];
        v16 += 12;
        v26 = v25 + (v24 << 24) + v19;
        v27 = (v22 + (v23 << 24) - v21 - v26 + v17) ^ (v26 >> 13);
        v28 = (v21 - v26 - v27) ^ (v27 << 8);
        v29 = (v26 - v27 - v28) ^ (v28 >> 13);
        v30 = (v27 - v28 - v29) ^ (v29 >> 12);
        v31 = (v28 - v29 - v30) ^ (v30 << 16);
        v32 = (v29 - v30 - v31) ^ (v31 >> 5);
        v17 = (v30 - v31 - v32) ^ (v32 >> 3);
        v15 = (v31 - v32 - v17) ^ (v17 << 10);
        v19 = (v32 - v17 - v15) ^ (v15 >> 15);
      }
      while ( v20 > 0xB );
    }
    v33 = v19 + v18;
    switch ( v20 )
    {
      case 1u:
        goto LABEL_21;
      case 2u:
        goto LABEL_20;
      case 3u:
        goto LABEL_19;
      case 4u:
        goto LABEL_18;
      case 5u:
        goto LABEL_17;
      case 6u:
        goto LABEL_16;
      case 7u:
        goto LABEL_15;
      case 8u:
        goto LABEL_14;
      case 9u:
        goto LABEL_13;
      case 0xAu:
        goto LABEL_12;
      case 0xBu:
        v33 += v16[10] << 24;
LABEL_12:
        v33 += v16[9] << 16;
LABEL_13:
        v33 += v16[8] << 8;
LABEL_14:
        v15 += v16[7] << 24;
LABEL_15:
        v15 += v16[6] << 16;
LABEL_16:
        v15 += v16[5] << 8;
LABEL_17:
        v15 += v16[4];
LABEL_18:
        v17 += v16[3] << 24;
LABEL_19:
        v17 += v16[2] << 16;
LABEL_20:
        v17 += v16[1] << 8;
LABEL_21:
        v17 += *v16;
        break;
      default:
        break;
    }
    v34 = *(_DWORD **)(dword_740F0 + 68);
    v35 = (v17 - v15 - v33) ^ (v33 >> 13);
    v36 = (v15 - v33 - v35) ^ (v35 << 8);
    v37 = (v33 - v35 - v36) ^ (v36 >> 13);
    v38 = (v35 - v36 - v37) ^ (v37 >> 12);
    v39 = (v36 - v37 - v38) ^ (v38 << 16);
    v40 = (v37 - v38 - v39) ^ (v39 >> 5);
    v41 = (v38 - v39 - v40) ^ (v40 >> 3);
    v13 = *(_DWORD *)(*v34
                    + 12
                    * (((v40 - v41 - ((v39 - v40 - v41) ^ (v41 << 10)))
                      ^ (((v39 - v40 - v41) ^ (v41 << 10)) >> 15))
                     & (v34[1] - 1)));
    if ( !v13 )
      goto LABEL_24;
    do
    {
      v13 -= v34[5];
LABEL_24:
      if ( !v13 || v18 == *(_DWORD *)(v13 + 92) && !memcmp(*(const void **)(v13 + 88), s, v18) )
        break;
      v13 = *(_DWORD *)(v13 + 84);
    }
    while ( v13 );
  }
  if ( pthread_rwlock_unlock(&stru_740D0) )
    sub_B578("block_exists", 5349);
  off_72D18();
  if ( v13 )
  {
    if ( !memcmp(v152 + 142, &s2, 0x20u) )
    {
      v4 = 1;
    }
    else if ( !memcmp(&s2, dword_740FC, 0x20u) )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(v165, 0x1000u, "Pool %d now up to date", *v152);
        sub_385C8(7, v165, 0);
      }
      v4 = 1;
      v77 = v157;
      v78 = v158;
      v79 = v159;
      v152[142] = s2;
      v152[143] = v77;
      v152[144] = v78;
      v152[145] = v79;
      v80 = v161;
      v81 = v162;
      v82 = v163;
      v152[146] = v160;
      v152[147] = v80;
      v152[148] = v81;
      v152[149] = v82;
    }
    else
    {
      v4 = (unsigned __int8)byte_75C49;
      if ( byte_75C49 )
      {
        if ( byte_77B70 || (v4 = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 6 )
        {
          v4 = 0;
          snprintf(v165, 0x1000u, "Stale data from pool %d", *v152);
          sub_385C8(7, v165, 0);
        }
      }
    }
    if ( *(_BYTE *)(v3 + 1768) )
    {
      v132 = (unsigned int)(dword_73D34 - 3) > 1;
      *(_DWORD *)(v3 + 1824) = ++dword_740CC;
      if ( !v132 || (v42 = *(_DWORD *)(v3 + 1748), v42 == sub_1D9A0()) )
      {
        if ( *(_BYTE *)(v3 + 1772) )
        {
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(v165, 0x1000u, "Stratum from pool %d requested work restart", *v152);
            sub_385C8(7, v165, 0);
          }
        }
        else if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          v43 = "";
          if ( *(_BYTE *)(v3 + 1812) )
            v43 = "GBT ";
          snprintf(v165, 0x1000u, "%sLONGPOLL from pool %d requested work restart", v43, **(_DWORD **)(v3 + 1748));
          sub_385C8(7, v165, 0);
        }
        sub_17148();
      }
    }
    goto LABEL_41;
  }
  v44 = (char *)calloc(0x68u, 1u);
  v45 = (int)v44;
  if ( !v44 )
  {
    strcpy(v165, "test_work_current OOM");
    sub_385C8(3, v165, 1);
    sub_16BE0(1);
  }
  strcpy(v44, s);
  v46 = dword_78944++;
  *(_DWORD *)(v45 + 100) = v46;
  if ( pthread_rwlock_wrlock(&stru_740D0) )
    sub_B3C8("test_work_current", 5414);
  v47 = &dword_73A10;
  v48 = dword_740F0;
  if ( !dword_740F0 )
  {
    *(_DWORD *)(v45 + 76) = 0;
    *(_DWORD *)(v45 + 88) = v45;
    v153 = 0;
    *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
    goto LABEL_105;
  }
  if ( *(_DWORD *)(*(_DWORD *)(dword_740F0 + 68) + 12) <= 6u )
  {
    *(_DWORD *)(v45 + 88) = v45;
    *(_DWORD *)(v45 + 76) = 0;
    v153 = 0;
    *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
    goto LABEL_137;
  }
  v49 = dword_740F0 + 68;
  v50 = 1;
  while ( 2 )
  {
    v51 = v49;
    v49 = 0;
    v52 = 0;
    v53 = 0;
    do
    {
      ++v53;
      if ( v50 )
      {
        v54 = *(_DWORD *)(v51 + 8);
        if ( v54 )
        {
          v56 = *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
          v55 = 1;
          for ( v54 += v56; v54; v54 += v56 )
          {
            if ( v55 == v50 )
              break;
            v54 = *(_DWORD *)(v54 + 8);
            ++v55;
            if ( !v54 )
              break;
          }
        }
        else
        {
          v55 = 1;
        }
      }
      else
      {
        v54 = v51;
        v55 = 0;
      }
      v57 = (int *)v51;
      v58 = v50;
      v51 = v54;
      while ( v55 )
      {
LABEL_69:
        v59 = v58 == 0;
        if ( v58 )
          v59 = v51 == 0;
        if ( v59 )
        {
          if ( !v57 )
            goto LABEL_128;
          v47 = (int *)v57[2];
          if ( v47 )
            v47 = (int *)((char *)v47 + *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20));
LABEL_76:
          --v55;
          if ( !v52 )
            goto LABEL_125;
LABEL_77:
          if ( v57 )
          {
            *(_DWORD *)(v52 + 8) = (char *)v57 - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
            v60 = v52 - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
            v52 = (int)v57;
            v57 = v47;
            goto LABEL_79;
          }
          *(_DWORD *)(v52 + 8) = 0;
          v52 = 0;
          v57 = v47;
        }
        else
        {
          v76 = *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
          v1 = *(_DWORD *)(v51 - v76 + 100);
          v47 = (int *)(*(int *)((char *)v57 - v76 + 100) - v1);
          if ( (int)v47 > 0 )
          {
            v1 = *(_DWORD *)(v51 + 8);
            if ( v1 )
              v1 += v76;
            goto LABEL_113;
          }
          if ( !v57 )
          {
LABEL_128:
            v47 = v57;
            goto LABEL_76;
          }
          v47 = (int *)v57[2];
          --v55;
          if ( v47 )
            v47 = (int *)((char *)v47 + v76);
          if ( v52 )
            goto LABEL_77;
LABEL_125:
          if ( v57 )
          {
            v52 = (int)v57;
            v60 = 0;
            v57 = v47;
            v49 = v52;
            goto LABEL_79;
          }
          v49 = 0;
          v57 = v47;
          v52 = 0;
        }
      }
      while ( 1 )
      {
        v61 = v51 == 0;
        if ( v51 )
          v61 = v58 == 0;
        if ( v61 )
          break;
        v75 = *(_DWORD *)(v51 + 8);
        if ( v75 )
          v47 = *(int **)(v48 + 68);
        else
          v1 = v55;
        if ( v75 )
        {
          v47 = (int *)v47[5];
          v1 = (int)v47 + v75;
        }
LABEL_113:
        --v58;
        if ( v52 )
        {
          v47 = v57;
          v57 = (int *)v51;
          v51 = v1;
          goto LABEL_77;
        }
        v52 = v51;
        v60 = 0;
        v51 = v1;
        v49 = v52;
LABEL_79:
        *(_DWORD *)(v52 + 4) = v60;
        if ( v55 )
          goto LABEL_69;
      }
    }
    while ( v51 );
    if ( v52 )
      *(_DWORD *)(v52 + 8) = 0;
    if ( v53 > 1 )
    {
      v50 *= 2;
      if ( !v49 )
      {
        v52 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) = v52;
  v62 = v49 - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
  dword_740F0 = v62;
  v63 = *(_DWORD *)(v62 + 72);
  v153 = *(_DWORD *)(v62 + 100);
  if ( v63 || *(_DWORD *)(v62 + 76) )
  {
    v64 = *(_DWORD *)(v62 + 68);
    v65 = *(_DWORD *)(v64 + 20);
    if ( v62 == *(_DWORD *)(v64 + 16) - v65 )
    {
      *(_DWORD *)(v64 + 16) = v63 + v65;
      v63 = *(_DWORD *)(v62 + 72);
    }
    if ( v63 )
    {
      v48 = v62;
      *(_DWORD *)(v63 + *(_DWORD *)(*(_DWORD *)(v62 + 68) + 20) + 8) = *(_DWORD *)(v62 + 76);
      v66 = *(_DWORD *)(v62 + 76);
    }
    else
    {
      v66 = *(_DWORD *)(v62 + 76);
      v48 = v66;
      dword_740F0 = v66;
    }
    if ( v66 )
      *(_DWORD *)(v66 + *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20) + 4) = *(_DWORD *)(v62 + 72);
    v67 = *(_DWORD **)(v48 + 68);
    v68 = 12 * ((v67[1] - 1) & *(_DWORD *)(v62 + 96));
    --*(_DWORD *)(*v67 + v68 + 4);
    v69 = **(_DWORD **)(v48 + 68);
    if ( *(_DWORD *)(v69 + v68) == v62 + 68 )
      *(_DWORD *)(v69 + v68) = *(_DWORD *)(v62 + 84);
    v70 = *(_DWORD *)(v62 + 80);
    if ( v70 )
      *(_DWORD *)(v70 + 16) = *(_DWORD *)(v62 + 84);
    v71 = *(_DWORD *)(v62 + 84);
    if ( v71 )
      *(_DWORD *)(v71 + 12) = *(_DWORD *)(v62 + 80);
    --*(_DWORD *)(*(_DWORD *)(v48 + 68) + 12);
  }
  else
  {
    v48 = 0;
    free(**(void ***)(v62 + 68));
    free(*(void **)(v62 + 68));
    dword_740F0 = 0;
  }
  free((void *)v62);
  *(_DWORD *)(v45 + 88) = v45;
  *(_DWORD *)(v45 + 76) = 0;
  *(_DWORD *)(v45 + 92) = strlen((const char *)v45);
  if ( !v48 )
  {
LABEL_105:
    *(_DWORD *)(v45 + 72) = 0;
    dword_740F0 = v45;
    v72 = malloc(0x2Cu);
    v73 = v72;
    *(_DWORD *)(v45 + 68) = v72;
    if ( v72 )
    {
      v150 = v45 + 68;
      *v72 = 0;
      v72[3] = 0;
      v72[4] = 0;
      v72[5] = 0;
      v72[6] = 0;
      v72[7] = 0;
      v72[8] = 0;
      v72[9] = 0;
      v72[10] = 0;
      v72[1] = 32;
      v72[4] = v45 + 68;
      v72[2] = 5;
      v72[5] = 68;
      v74 = malloc(0x180u);
      *v73 = v74;
      if ( v74 )
      {
        memset(v74, 0, 0x180u);
        v48 = v45;
        v73[10] = -1609490463;
        goto LABEL_138;
      }
    }
LABEL_251:
    exit(-1);
  }
LABEL_137:
  v150 = v45 + 68;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) + 8) = v45;
  *(_DWORD *)(v45 + 72) = *(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v48 + 68) + 20);
  *(_DWORD *)(*(_DWORD *)(v48 + 68) + 16) = v45 + 68;
  v73 = *(_DWORD **)(v48 + 68);
LABEL_138:
  v83 = -17973521;
  ++v73[3];
  v84 = *(_DWORD *)(v48 + 68);
  v85 = -1640531527;
  *(_DWORD *)(v45 + 96) = -17973521;
  *(_DWORD *)(v45 + 68) = v84;
  v86 = strlen((const char *)v45);
  v87 = v86;
  if ( v86 <= 0xB )
  {
    v89 = -1640531527;
    v88 = (unsigned __int8 *)v45;
  }
  else
  {
    v88 = (unsigned __int8 *)v45;
    v89 = -1640531527;
    do
    {
      v87 -= 12;
      v90 = (v88[2] << 16) + (v88[1] << 8) + *v88;
      v91 = v88[3];
      v92 = (v88[6] << 16) + (v88[5] << 8) + v88[4];
      v93 = v88[7];
      v94 = (v88[10] << 16) + (v88[9] << 8) + v88[8] + (v88[11] << 24) + v83;
      v88 += 12;
      v95 = v92 + (v93 << 24) + v85;
      v96 = (v90 + (v91 << 24) - v94 - v95 + v89) ^ (v94 >> 13);
      v97 = (v95 - v94 - v96) ^ (v96 << 8);
      v98 = (v94 - v96 - v97) ^ (v97 >> 13);
      v99 = (v96 - v97 - v98) ^ (v98 >> 12);
      v100 = (v97 - v98 - v99) ^ (v99 << 16);
      v101 = (v98 - v99 - v100) ^ (v100 >> 5);
      v89 = (v99 - v100 - v101) ^ (v101 >> 3);
      v85 = (v100 - v101 - v89) ^ (v89 << 10);
      v83 = (v101 - v89 - v85) ^ (v85 >> 15);
      *(_DWORD *)(v45 + 96) = v83;
    }
    while ( v87 > 0xB );
    v86 = strlen((const char *)v45);
  }
  v102 = v86 + v83;
  *(_DWORD *)(v45 + 96) = v102;
  switch ( v87 )
  {
    case 1u:
      goto LABEL_153;
    case 2u:
      goto LABEL_152;
    case 3u:
      goto LABEL_151;
    case 4u:
      goto LABEL_150;
    case 5u:
      goto LABEL_149;
    case 6u:
      goto LABEL_148;
    case 7u:
      goto LABEL_147;
    case 8u:
      goto LABEL_146;
    case 9u:
      goto LABEL_145;
    case 0xAu:
      goto LABEL_144;
    case 0xBu:
      v102 += v88[10] << 24;
      *(_DWORD *)(v45 + 96) = v102;
LABEL_144:
      v102 += v88[9] << 16;
      *(_DWORD *)(v45 + 96) = v102;
LABEL_145:
      v102 += v88[8] << 8;
      *(_DWORD *)(v45 + 96) = v102;
LABEL_146:
      v85 += v88[7] << 24;
LABEL_147:
      v85 += v88[6] << 16;
LABEL_148:
      v85 += v88[5] << 8;
LABEL_149:
      v85 += v88[4];
LABEL_150:
      v89 += v88[3] << 24;
LABEL_151:
      v89 += v88[2] << 16;
LABEL_152:
      v89 += v88[1] << 8;
LABEL_153:
      v89 += *v88;
      break;
    default:
      break;
  }
  v103 = (v89 - v85 - v102) ^ (v102 >> 13);
  v104 = (v85 - v102 - v103) ^ (v103 << 8);
  v105 = (v102 - v103 - v104) ^ (v104 >> 13);
  v106 = (v103 - v104 - v105) ^ (v105 >> 12);
  v107 = (v104 - v105 - v106) ^ (v106 << 16);
  v108 = (v105 - v106 - v107) ^ (v107 >> 5);
  v109 = v106 - v107 - v108;
  v110 = (v108 - (v109 ^ (v108 >> 3)) - ((v107 - v108 - (v109 ^ (v108 >> 3))) ^ ((v109 ^ (v108 >> 3)) << 10)))
       ^ (((v107 - v108 - (v109 ^ (v108 >> 3))) ^ ((v109 ^ (v108 >> 3)) << 10)) >> 15);
  *(_DWORD *)(v45 + 96) = v110;
  v111 = *(_DWORD **)(v48 + 68);
  v112 = 12 * (v110 & (v111[1] - 1));
  ++*(_DWORD *)(*v111 + v112 + 4);
  v113 = *(_DWORD *)(**(_DWORD **)(v48 + 68) + v112);
  *(_DWORD *)(v45 + 80) = 0;
  *(_DWORD *)(v45 + 84) = v113;
  v114 = **(_DWORD **)(v48 + 68) + v112;
  if ( *(_DWORD *)v114 )
  {
    *(_DWORD *)(*(_DWORD *)v114 + 12) = v150;
    v114 = **(_DWORD **)(v48 + 68) + v112;
  }
  *(_DWORD *)v114 = v150;
  if ( *(_DWORD *)(**(_DWORD **)(v48 + 68) + v112 + 4) >= (unsigned int)(10
                                                                       * (*(_DWORD *)(**(_DWORD **)(v48 + 68) + v112 + 8)
                                                                        + 1)) )
  {
    v115 = *(_DWORD *)(v45 + 68);
    if ( *(_DWORD *)(v115 + 36) != 1 )
    {
      v116 = 24 * *(_DWORD *)(v115 + 4);
      v117 = malloc(v116);
      v118 = v117;
      if ( !v117 )
        goto LABEL_251;
      memset(v117, 0, v116);
      *(_DWORD *)(v115 + 24) = (((2 * *(_DWORD *)(v115 + 4) - 1) & *(_DWORD *)(v115 + 12)) != 0)
                             + (*(_DWORD *)(v115 + 12) >> (*(_BYTE *)(v115 + 8) + 1));
      *(_DWORD *)(*(_DWORD *)(v45 + 68) + 28) = 0;
      v119 = *(_DWORD *)(v45 + 68);
      v120 = *(_DWORD *)(v119 + 4);
      if ( v120 )
      {
        v154 = v3;
        v121 = 0;
        v122 = v45;
        for ( i = 0; i < v120; ++i )
        {
          v123 = *(_DWORD **)(*(_DWORD *)v119 + v121);
          if ( v123 )
          {
            while ( 1 )
            {
              v124 = (_DWORD *)v123[4];
              v125 = 3 * ((2 * v120 - 1) & v123[7]);
              v126 = (char *)&v118[v125];
              v127 = *((_DWORD *)v126 + 1) + 1;
              *((_DWORD *)v126 + 1) = v127;
              if ( v127 > *(_DWORD *)(v119 + 24) )
              {
                ++*(_DWORD *)(v119 + 28);
                *((_DWORD *)v126 + 2) = *((_DWORD *)v126 + 1) / *(_DWORD *)(*(_DWORD *)(v122 + 68) + 24);
              }
              v123[3] = 0;
              v123[4] = v118[v125];
              v128 = v118[v125];
              if ( v128 )
                *(_DWORD *)(v128 + 12) = v123;
              v118[v125] = v123;
              v119 = *(_DWORD *)(v122 + 68);
              if ( !v124 )
                break;
              v120 = *(_DWORD *)(v119 + 4);
              v123 = v124;
            }
            v120 = *(_DWORD *)(v119 + 4);
          }
          v121 += 12;
        }
        v45 = v122;
        v3 = v154;
      }
      free(*(void **)v119);
      *(_DWORD *)(*(_DWORD *)(v45 + 68) + 4) *= 2;
      ++*(_DWORD *)(*(_DWORD *)(v45 + 68) + 8);
      **(_DWORD **)(v45 + 68) = v118;
      v129 = *(_DWORD **)(v45 + 68);
      v130 = v129[3];
      v131 = v129[7];
      v132 = v131 > v130 >> 1;
      if ( v131 <= v130 >> 1 )
        v133 = 0;
      else
        v133 = v129[8];
      if ( v132 )
        ++v133;
      v129[8] = v133;
      v134 = *(_DWORD *)(v45 + 68);
      if ( *(_DWORD *)(v134 + 32) > 1u )
        *(_DWORD *)(v134 + 36) = 1;
    }
  }
  LODWORD(v2) = 8 * (29 - *(unsigned __int8 *)(v3 + 72));
  v135 = bswap32(*(_DWORD *)(v3 + 72)) & 0xFFFFFF;
  LODWORD(v136) = sub_59F08(vshld_u64(0xFFFFu, v2));
  v137 = v136 / (double)v135;
  if ( v137 != dbl_72C20 )
  {
    LODWORD(v149) = sub_5A000(v137);
    sub_114B8(v149, byte_740F4, 8u, 0);
    dbl_72C20 = v137;
    if ( byte_75C49 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
      {
        snprintf(v165, 0x1000u, "Network diff set to %s", byte_740F4);
        sub_385C8(7, v165, 0);
      }
    }
  }
  if ( pthread_rwlock_unlock(&stru_740D0) )
    sub_B578("test_work_current", 5430);
  off_72D18();
  if ( v153 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v165, 0x1000u, "Deleted block %d from database", v153);
    sub_385C8(7, v165, 0);
  }
  if ( pthread_mutex_lock(&stru_78800) )
    sub_B35C("set_curblock", 5324);
  if ( pthread_rwlock_wrlock(&stru_78818) )
    sub_B3C8("set_curblock", 5324);
  sub_2A7A4((struct timeval *)&dword_77E98);
  strcpy(dest, s);
  timer = dword_77E98;
  dword_740FC[0] = s2;
  dword_740FC[1] = v157;
  dword_740FC[2] = v158;
  dword_740FC[3] = v159;
  unk_7410C = v160;
  unk_74110 = v161;
  unk_74114 = v162;
  unk_74118 = v163;
  v138 = localtime(&timer);
  snprintf(byte_7411C, 0x20u, "[%02d:%02d:%02d]", v138->tm_hour, v138->tm_min, v138->tm_sec);
  if ( pthread_rwlock_unlock(&stru_78818) )
    sub_B578("set_curblock", 5329);
  if ( pthread_mutex_unlock(&stru_78800) )
    sub_B50C("set_curblock", 5329);
  off_72D18();
  for ( j = 0; j != 57; ++j )
  {
    if ( dest[j] != 48 )
      break;
  }
  strncpy(byte_7413C, &dest[j], 8u);
  byte_74144 = 0;
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v165, 0x1000u, "New block: %s... diff %s", dest, byte_740F4);
    sub_385C8(7, v165, 0);
  }
  v140 = v157;
  v141 = v158;
  v142 = v159;
  v143 = dword_78944;
  v152[142] = s2;
  v152[143] = v140;
  v152[144] = v141;
  v152[145] = v142;
  v144 = v161;
  v145 = v162;
  v146 = v163;
  v152[146] = v160;
  v152[147] = v144;
  v152[148] = v145;
  v152[149] = v146;
  if ( v143 == 1 )
  {
    v4 = 0;
LABEL_41:
    *(_BYTE *)(v3 + 1768) = 0;
    return v4;
  }
  v147 = *(unsigned __int8 *)(v3 + 1768);
  *(_DWORD *)(v3 + 1824) = ++dword_740CC;
  if ( v147 )
  {
    if ( *(_BYTE *)(v3 + 1772) )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(v165, 0x1000u, "Stratum from pool %d detected new block", *v152);
        sub_385C8(7, v165, 0);
      }
    }
    else if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      v148 = "";
      if ( *(_BYTE *)(v3 + 1812) )
        v148 = "GBT ";
      snprintf(v165, 0x1000u, "%sLONGPOLL from pool %d detected new block", v148, **(_DWORD **)(v3 + 1748));
      sub_385C8(7, v165, 0);
    }
  }
  else if ( byte_78AA1 )
  {
    if ( !*((_BYTE *)v152 + 924) && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(v165, "New block detected on network before pool notification");
      sub_385C8(7, v165, 0);
    }
  }
  else if ( !*((_BYTE *)v152 + 924) && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v165, "New block detected on network");
    sub_385C8(7, v165, 0);
  }
  sub_17148();
  v4 = 1;
  *(_BYTE *)(v3 + 1768) = 0;
  return v4;
}
// 1DC38: control flows out of bounds to 1DC3C
// 1E5E0: control flows out of bounds to 1E5E4
// 1E2E8: variable 'v1' is possibly undefined
// 1E964: variable 'v2' is possibly undefined
// 1E97C: variable 'v136' is possibly undefined
// 1EFC8: variable 'v149' is possibly undefined
// 72C20: using guessed type double dbl_72C20;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73A10: using guessed type int dword_73A10;
// 73D34: using guessed type int dword_73D34;
// 740CC: using guessed type int dword_740CC;
// 740F0: using guessed type int dword_740F0;
// 740FC: using guessed type _DWORD dword_740FC[4];
// 74144: using guessed type char byte_74144;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77E98: using guessed type int dword_77E98;
// 78944: using guessed type int dword_78944;
// 78AA1: using guessed type char byte_78AA1;

//----- (0001F0C4) --------------------------------------------------------
int __fastcall sub_1F0C4(int a1)
{
  _DWORD *v1; // r11
  pthread_mutex_t *v3; // r0
  int v4; // r0
  int v5; // r6
  int v6; // r8
  int v7; // r9
  int v8; // r3
  unsigned int v9; // r2
  unsigned int v10; // r0
  int v11; // r1
  unsigned int v12; // r2
  unsigned int v13; // r3
  unsigned int v14; // r1
  unsigned int v15; // r3
  _DWORD *v16; // r2
  int v17; // r3
  int v18; // r2
  int v19; // r2
  int v20; // r7
  int v21; // r3
  size_t v22; // r6
  _DWORD *v23; // r0
  _DWORD *v24; // r8
  int v25; // r3
  int v26; // r1
  unsigned int v27; // r3
  _DWORD *v28; // r6
  int v29; // r7
  unsigned int v30; // r0
  int v31; // r3
  _DWORD *v32; // r3
  unsigned int v33; // r1
  unsigned int v34; // r2
  bool v35; // cc
  int v36; // r2
  int v37; // r3
  int v38; // r0
  int v39; // r10
  _DWORD *v40; // r12
  int v41; // lr
  unsigned int v42; // r8
  _DWORD *j; // r3
  int v44; // r2
  int v45; // r1
  int v46; // r1
  int v47; // r6
  bool v48; // zf
  int v49; // r3
  bool v50; // zf
  int v52; // r3
  int v53; // r3
  _DWORD *v54; // r0
  _DWORD *v55; // r7
  void *v56; // r0
  int v57; // r3
  void *v58; // r0
  int v59; // [sp+0h] [bp-100Ch]
  unsigned int i; // [sp+4h] [bp-1008h]
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "Pushing work from pool %d to hash queue", **(_DWORD **)(a1 + 1748));
    sub_385C8(7, s, 0);
  }
  *(_DWORD *)(a1 + 1824) = dword_740CC;
  sub_1DA54(a1);
  v3 = (pthread_mutex_t *)dword_73E6C;
  ++*(_DWORD *)(*(_DWORD *)(a1 + 1748) + 68);
  if ( pthread_mutex_lock(v3) )
    sub_B35C("hash_push", 5533);
  if ( !*(_BYTE *)(a1 + 1761) && *(_DWORD *)(a1 + 1764) )
    ++dword_73E7C;
  v4 = dword_78448;
  if ( *(_BYTE *)(dword_78448 + 8) )
    goto LABEL_72;
  v5 = dword_73E74;
  *(_DWORD *)(a1 + 1840) = *(unsigned __int8 *)(dword_78448 + 8);
  *(_DWORD *)(a1 + 1852) = a1 + 1828;
  *(_DWORD *)(a1 + 1856) = 4;
  if ( v5 )
  {
    v6 = a1 + 1832;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 1832) + 16) + 8) = a1;
    *(_DWORD *)(a1 + 1836) = *(_DWORD *)(*(_DWORD *)(v5 + 1832) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 1832) + 20);
    *(_DWORD *)(*(_DWORD *)(v5 + 1832) + 16) = a1 + 1832;
  }
  else
  {
    *(_DWORD *)(a1 + 1836) = 0;
    dword_73E74 = a1;
    v54 = malloc(0x2Cu);
    v55 = v54;
    *(_DWORD *)(a1 + 1832) = v54;
    if ( !v54 )
      goto LABEL_100;
    *v54 = 0;
    v54[3] = 0;
    v54[4] = 0;
    v6 = a1 + 1832;
    v54[5] = 0;
    v54[6] = 0;
    v54[7] = 0;
    v54[8] = 0;
    v54[9] = 0;
    v54[10] = 0;
    v54[4] = a1 + 1832;
    v54[1] = 32;
    v54[2] = 5;
    v54[5] = 1832;
    v56 = malloc(0x180u);
    v57 = dword_73E74;
    *v55 = v56;
    v58 = **(void ***)(v57 + 1832);
    if ( !v58 )
      goto LABEL_100;
    memset(v58, 0, 0x180u);
    v5 = dword_73E74;
    *(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 40) = -1609490463;
  }
  ++*(_DWORD *)(*(_DWORD *)(v5 + 1832) + 12);
  v7 = *(unsigned __int8 *)(a1 + 1830);
  v8 = (*(unsigned __int8 *)(a1 + 1828)
      + 17973517
      + (*(unsigned __int8 *)(a1 + 1831) << 24)
      + (v7 << 16)
      + (*(unsigned __int8 *)(a1 + 1829) << 8))
     ^ 0x7F76D;
  *(_DWORD *)(a1 + 1832) = *(_DWORD *)(v5 + 1832);
  v9 = (-1622558010 - v8) ^ (v8 << 8);
  v10 = (-17973517 - v8 - v9) ^ (v9 >> 13);
  v11 = (v8 - v9 - v10) ^ (v10 >> 12);
  v12 = (v9 - v10 - v11) ^ (v11 << 16);
  v13 = (v10 - v11 - v12) ^ (v12 >> 5);
  v14 = v11 - v12 - v13;
  v15 = (v13 - (v14 ^ (v13 >> 3)) - ((v12 - v13 - (v14 ^ (v13 >> 3))) ^ ((v14 ^ (v13 >> 3)) << 10)))
      ^ (((v12 - v13 - (v14 ^ (v13 >> 3))) ^ ((v14 ^ (v13 >> 3)) << 10)) >> 15);
  *(_DWORD *)(a1 + 1860) = v15;
  v16 = *(_DWORD **)(v5 + 1832);
  v17 = 12 * (v15 & (v16[1] - 1));
  ++*(_DWORD *)(*v16 + v17 + 4);
  v18 = *(_DWORD *)(**(_DWORD **)(v5 + 1832) + v17);
  *(_DWORD *)(a1 + 1844) = 0;
  *(_DWORD *)(a1 + 1848) = v18;
  v19 = **(_DWORD **)(v5 + 1832) + v17;
  if ( *(_DWORD *)v19 )
  {
    *(_DWORD *)(*(_DWORD *)v19 + 12) = v6;
    v19 = **(_DWORD **)(v5 + 1832) + v17;
  }
  *(_DWORD *)v19 = v6;
  v20 = dword_73E74;
  if ( *(_DWORD *)(**(_DWORD **)(dword_73E74 + 1832) + v17 + 4) >= (unsigned int)(10
                                                                                * (*(_DWORD *)(**(_DWORD **)(dword_73E74 + 1832)
                                                                                             + v17
                                                                                             + 8)
                                                                                 + 1)) )
  {
    v21 = *(_DWORD *)(a1 + 1832);
    if ( *(_DWORD *)(v21 + 36) != 1 )
    {
      v22 = 24 * *(_DWORD *)(v21 + 4);
      v23 = malloc(v22);
      v24 = v23;
      if ( v23 )
      {
        memset(v23, 0, v22);
        v25 = *(_DWORD *)(a1 + 1832);
        v7 = 0;
        *(_DWORD *)(v25 + 24) = (((2 * *(_DWORD *)(v25 + 4) - 1) & *(_DWORD *)(v25 + 12)) != 0)
                              + (*(_DWORD *)(v25 + 12) >> (*(_BYTE *)(v25 + 8) + 1));
        *(_DWORD *)(*(_DWORD *)(a1 + 1832) + 28) = 0;
        v26 = *(_DWORD *)(a1 + 1832);
        v27 = *(_DWORD *)(v26 + 4);
        if ( v27 )
        {
          v59 = 0;
          for ( i = 0; i < v27; ++i )
          {
            v28 = *(_DWORD **)(*(_DWORD *)v26 + v59);
            if ( v28 )
            {
              while ( 1 )
              {
                v1 = (_DWORD *)v28[4];
                v29 = 3 * ((2 * v27 - 1) & v28[7]);
                v7 = (int)&v24[3 * ((2 * v27 - 1) & v28[7])];
                v30 = *(_DWORD *)(v7 + 4) + 1;
                *(_DWORD *)(v7 + 4) = v30;
                if ( v30 > *(_DWORD *)(v26 + 24) )
                {
                  ++*(_DWORD *)(v26 + 28);
                  *(_DWORD *)(v7 + 8) = *(_DWORD *)(v7 + 4) / *(_DWORD *)(*(_DWORD *)(a1 + 1832) + 24);
                }
                v28[3] = 0;
                v28[4] = v24[v29];
                v31 = v24[v29];
                if ( v31 )
                  *(_DWORD *)(v31 + 12) = v28;
                v24[v29] = v28;
                v26 = *(_DWORD *)(a1 + 1832);
                if ( !v1 )
                  break;
                v27 = *(_DWORD *)(v26 + 4);
                v28 = v1;
              }
              v27 = *(_DWORD *)(v26 + 4);
            }
            v59 += 12;
          }
        }
        free(*(void **)v26);
        *(_DWORD *)(*(_DWORD *)(a1 + 1832) + 4) *= 2;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 1832) + 8);
        **(_DWORD **)(a1 + 1832) = v24;
        v32 = *(_DWORD **)(a1 + 1832);
        v20 = dword_73E74;
        v33 = v32[3];
        v34 = v32[7];
        v35 = v34 > v33 >> 1;
        if ( v34 <= v33 >> 1 )
          v36 = 0;
        else
          v36 = v32[8];
        if ( v35 )
          ++v36;
        v32[8] = v36;
        v37 = *(_DWORD *)(a1 + 1832);
        if ( *(_DWORD *)(v37 + 32) > 1u )
          *(_DWORD *)(v37 + 36) = 1;
        if ( !v20 )
        {
          v4 = dword_78448;
          goto LABEL_72;
        }
        goto LABEL_38;
      }
LABEL_100:
      exit(-1);
    }
  }
LABEL_38:
  v38 = 1;
  v39 = v20 + 1832;
  while ( 2 )
  {
    v40 = (_DWORD *)v39;
    v39 = 0;
    v41 = 0;
    v42 = 0;
    do
    {
      ++v42;
      if ( v38 )
      {
        j = (_DWORD *)v40[2];
        if ( j )
        {
          v45 = *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
          v44 = 1;
          for ( j = (_DWORD *)((char *)j + v45); j; j = (_DWORD *)((char *)j + v45) )
          {
            if ( v44 == v38 )
              break;
            j = (_DWORD *)j[2];
            ++v44;
            if ( !j )
              break;
          }
        }
        else
        {
          v44 = 1;
        }
      }
      else
      {
        j = v40;
        v44 = 0;
      }
      v46 = (int)v40;
      v47 = v38;
      v40 = j;
      while ( v44 )
      {
LABEL_50:
        v48 = v47 == 0;
        if ( v47 )
          v48 = v40 == 0;
        if ( v48 )
        {
          if ( !v46 )
            goto LABEL_94;
          v7 = *(_DWORD *)(v46 + 8);
          if ( v7 )
            v7 += *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
LABEL_57:
          --v44;
          if ( !v41 )
            goto LABEL_91;
LABEL_58:
          if ( v46 )
          {
            *(_DWORD *)(v41 + 8) = v46 - *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
            v49 = v41 - *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
            v41 = v46;
            v46 = v7;
            goto LABEL_60;
          }
          *(_DWORD *)(v41 + 8) = 0;
          v41 = 0;
          v46 = v7;
        }
        else
        {
          v53 = *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
          v1 = *(_DWORD **)((char *)v40 - v53 + 1752);
          v7 = *(_DWORD *)(v46 - v53 + 1752) - (_DWORD)v1;
          if ( v7 > 0 )
          {
            v1 = (_DWORD *)v40[2];
            if ( v1 )
              v1 = (_DWORD *)((char *)v1 + v53);
            goto LABEL_79;
          }
          if ( !v46 )
          {
LABEL_94:
            v7 = v46;
            goto LABEL_57;
          }
          v7 = *(_DWORD *)(v46 + 8);
          --v44;
          if ( v7 )
            v7 += v53;
          if ( v41 )
            goto LABEL_58;
LABEL_91:
          if ( v46 )
          {
            v41 = v46;
            v49 = 0;
            v46 = v7;
            v39 = v41;
            goto LABEL_60;
          }
          v39 = 0;
          v46 = v7;
          v41 = 0;
        }
      }
      while ( 1 )
      {
        v50 = v40 == 0;
        if ( v40 )
          v50 = v47 == 0;
        if ( v50 )
          break;
        v52 = v40[2];
        if ( v52 )
          v7 = *(_DWORD *)(v20 + 1832);
        else
          v1 = (_DWORD *)v44;
        if ( v52 )
        {
          v7 = *(_DWORD *)(v7 + 20);
          v1 = (_DWORD *)(v52 + v7);
        }
LABEL_79:
        --v47;
        if ( v41 )
        {
          v7 = v46;
          v46 = (int)v40;
          v40 = v1;
          goto LABEL_58;
        }
        v41 = (int)v40;
        v49 = 0;
        v40 = v1;
        v39 = v41;
LABEL_60:
        *(_DWORD *)(v41 + 4) = v49;
        if ( v44 )
          goto LABEL_50;
      }
    }
    while ( v40 );
    if ( v41 )
      *(_DWORD *)(v41 + 8) = 0;
    if ( v42 > 1 )
    {
      v38 *= 2;
      if ( !v39 )
      {
        v41 = 0;
        break;
      }
      continue;
    }
    break;
  }
  *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 16) = v41;
  v4 = dword_78448;
  dword_73E74 = v39 - *(_DWORD *)(*(_DWORD *)(v20 + 1832) + 20);
LABEL_72:
  pthread_cond_broadcast((pthread_cond_t *)(v4 + 40));
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
    sub_B50C("hash_push", 5544);
  return off_72D18();
}
// 1F6A8: variable 'v1' is possibly undefined
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E6C: using guessed type int dword_73E6C;
// 73E74: using guessed type int dword_73E74;
// 73E7C: using guessed type int dword_73E7C;
// 740CC: using guessed type int dword_740CC;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78448: using guessed type int dword_78448;

//----- (0001F880) --------------------------------------------------------
int __fastcall sub_1F880(int a1, int a2, int a3)
{
  int v6; // r1
  __int64 v7; // r2
  int v8; // r4
  int v10; // r0

  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("inc_work_stats", 8380);
  v6 = *(_DWORD *)(a1 + 36);
  v7 = *(_QWORD *)(v6 + 192) + a3;
  *(_QWORD *)&dword_77F28 += a3;
  *(_QWORD *)(v6 + 192) = v7;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v10 = sub_1D9A0();
    *(_QWORD *)(v10 + 40) += a3;
  }
  v8 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v8 + 232) = time(0);
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("inc_work_stats", 8393);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();
// 77F28: using guessed type int dword_77F28;

//----- (0001F95C) --------------------------------------------------------
void __fastcall sub_1F95C(int a1)
{
  int v2; // r0
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( !sub_1859C(a1, (_BYTE *)(a1 + 129)) )
  {
    sub_2A7A4((struct timeval *)(a1 + 168));
    v2 = sub_1D9A0();
    if ( v2 == a1 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, "Pool %d %s not responding!", *(_DWORD *)v2, *(const char **)(v2 + 196));
        sub_385C8(4, s, 0);
      }
      sub_1A600(0);
    }
    else if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "Pool %d %s failed to return work", *(_DWORD *)a1, *(const char **)(a1 + 196));
      sub_385C8(7, s, 0);
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001FA8C) --------------------------------------------------------
int __fastcall sub_1FA8C(int a1)
{
  int result; // r0

  result = sub_1859C(a1, (_BYTE *)(a1 + 129));
  if ( !result )
  {
    sub_2A7A4((struct timeval *)(a1 + 168));
    result = sub_1D9A0();
    if ( a1 == result )
      return sub_1A600(0);
  }
  return result;
}

//----- (0001FAC4) --------------------------------------------------------
int sub_1FAC4()
{
  int v0; // r4

  if ( pthread_mutex_lock(&stru_78838) )
    sub_B35C("cp_prio", 7036);
  if ( pthread_rwlock_rdlock(&stru_78850) )
    sub_B5E4("cp_prio", 7036);
  if ( pthread_mutex_unlock(&stru_78838) )
    sub_B50C("cp_prio", 7036);
  v0 = *(_DWORD *)(dword_73E9C + 4);
  if ( pthread_rwlock_unlock(&stru_78850) )
    sub_B578("cp_prio", 7038);
  off_72D18();
  return v0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73E9C: using guessed type int dword_73E9C;

//----- (0001FB7C) --------------------------------------------------------
void __fastcall sub_1FB7C(_DWORD *a1)
{
  int v1; // r3
  int v3; // r5
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = dword_73D34;
  a1[7] = 0;
  if ( v1 || (v3 = a1[1], v3 >= sub_1FAC4()) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "Pool %d %s alive", *a1, (const char *)a1[49]);
      sub_385C8(7, s, 0);
    }
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(s, 0x1000u, "Pool %d %s alive, testing stability", *a1, (const char *)a1[49]);
    sub_385C8(4, s, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 73D34: using guessed type int dword_73D34;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001FCAC) --------------------------------------------------------
void __fastcall sub_1FCAC(_DWORD *a1)
{
  char v2[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( sub_18200((int)a1, (_BYTE *)a1 + 129) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v2, 0x1000u, "Stratum connection to pool %d resumed", *a1);
      sub_385C8(7, v2, 0);
    }
    sub_1FB7C(a1);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001FD54) --------------------------------------------------------
void *__fastcall start_routine(_DWORD *a1)
{
  _BOOL4 v2; // r5
  int v3; // r5
  pthread_t v5; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( !*((_BYTE *)a1 + 139) )
  {
    v5 = pthread_self();
    pthread_detach(v5);
  }
  while ( !sub_18610(a1, 0) )
  {
    sub_1F95C((int)a1);
    sleep(5u);
  }
  sub_1859C((int)a1, (_BYTE *)a1 + 130);
  sub_18200((int)a1, (_BYTE *)a1 + 129);
  if ( pthread_mutex_lock(&stru_78838) )
    sub_B35C("test_pool_thread", 9995);
  if ( pthread_rwlock_wrlock(&stru_78850) )
    sub_B3C8("test_pool_thread", 9995);
  if ( byte_74148 )
  {
    v2 = 0;
  }
  else
  {
    v3 = *a1;
    dword_73E9C = (int)a1;
    byte_74148 = 1;
    v2 = v3 != 0;
  }
  if ( pthread_rwlock_unlock(&stru_78850) )
    sub_B578("test_pool_thread", 10003);
  if ( pthread_mutex_unlock(&stru_78838) )
    sub_B50C("test_pool_thread", 10003);
  off_72D18();
  if ( v2 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "Switching to pool %d %s - first alive pool", *a1, (const char *)a1[49]);
    sub_385C8(7, s, 0);
  }
  sub_1FB7C(a1);
  sub_1A600(0);
  *((_BYTE *)a1 + 316) = 0;
  return 0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E9C: using guessed type int dword_73E9C;
// 74148: using guessed type char byte_74148;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0001FF34) --------------------------------------------------------
int __fastcall sub_1FF34(int a1)
{
  int v3; // r4

  if ( *(_DWORD *)(a1 + 132) != 1 )
    return 0;
  if ( dword_73D34 == 4 || dword_73D34 == 3 || *(_BYTE *)(a1 + 664) && *(_BYTE *)(a1 + 129) )
    return 1;
  if ( a1 == sub_1D9A0() )
    return 1;
  if ( *(_DWORD *)(a1 + 756) )
    return 1;
  if ( !dword_73D34 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 < sub_1FAC4() )
      return 1;
  }
  return (unsigned __int8)byte_782F0;
}
// 73D34: using guessed type int dword_73D34;
// 782F0: using guessed type char byte_782F0;

//----- (0001FFD0) --------------------------------------------------------
void __fastcall sub_1FFD0(
        _DWORD *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r11
  pthread_t v15; // r0
  fd_set *v16; // r3
  int v17; // r3
  int v18; // r0
  int *v19; // r4
  int v20; // r1
  int v21; // r2
  int v22; // r3
  int *v23; // r0
  _DWORD *v24; // r0
  void **v25; // r5
  int v26; // r6
  unsigned int v27; // r3
  unsigned int v28; // r2
  unsigned int v29; // r0
  _DWORD *v30; // r7
  int v31; // r1
  unsigned int v32; // r2
  unsigned int v33; // r3
  int v34; // r1
  unsigned int v35; // r1
  int v36; // r3
  int v37; // r12
  int v38; // r12
  int v39; // r7
  time_t v40; // r0
  int v41; // r3
  double *v42; // r9
  double v43; // d0
  unsigned int v44; // r6
  int v45; // r1
  __int64 v46; // d8
  const char *v47; // r2
  unsigned int v48; // r3
  _DWORD *v49; // r6
  double v50; // d18
  double v51; // d16
  double v52; // d16
  double v53; // d17
  size_t v54; // r0
  size_t v55; // r3
  _BYTE *v56; // r9
  int v57; // r9
  double v58; // r0
  int v59; // r5
  int v60; // r3
  int v61; // r2
  _DWORD *v62; // r1
  bool v63; // zf
  int v64; // r3
  int v65; // r2
  int v66; // r2
  int v67; // r3
  int v68; // r3
  _DWORD *v69; // r0
  int v70; // r5
  int v71; // r3
  int v72; // r2
  int v73; // r4
  char *v74; // r6
  int v75; // r3
  int v76; // r3
  int v77; // r3
  double v78; // d8
  double v79; // d16
  double v80; // d17
  double v81; // d18
  double v82; // d16
  double v83; // d16
  int v84; // r3
  time_t v85; // r0
  int v86; // r1
  _DWORD *v87; // r0
  const char *v88; // r0
  double v89; // d16
  double v90; // d17
  size_t n; // [sp+1Ch] [bp-1268h]
  int *v92; // [sp+38h] [bp-124Ch]
  int v93; // [sp+40h] [bp-1244h]
  _DWORD *src; // [sp+44h] [bp-1240h]
  const char *srca; // [sp+44h] [bp-1240h]
  _DWORD *v96; // [sp+48h] [bp-123Ch]
  int s2; // [sp+50h] [bp-1234h] BYREF
  struct timeval timeout; // [sp+54h] [bp-1230h] BYREF
  char s[16]; // [sp+5Ch] [bp-1228h] BYREF
  char v100[20]; // [sp+6Ch] [bp-1218h] BYREF
  char v101[2]; // [sp+80h] [bp-1204h] BYREF
  char dest[30]; // [sp+82h] [bp-1202h] BYREF
  char v103[36]; // [sp+A0h] [bp-11E4h] BYREF
  char v104[60]; // [sp+C4h] [bp-11C0h] BYREF
  char v105; // [sp+100h] [bp-1184h] BYREF
  fd_set readfds; // [sp+104h] [bp-1180h] BYREF
  int v107[23]; // [sp+184h] [bp-1100h] BYREF
  char v108[160]; // [sp+1E0h] [bp-10A4h] BYREF
  _DWORD v109[1024]; // [sp+280h] [bp-1004h] BYREF
  _BYTE v110[4]; // [sp+1280h] [bp-4h] BYREF

  v15 = pthread_self();
  pthread_detach(v15);
  snprintf(s, 0x10u, "%d/RStratum", *a1);
  sub_2EF24(s);
  while ( !*((_BYTE *)a1 + 137) )
  {
    if ( !sub_2AD68((int)a1) && !sub_1FF34((int)a1) )
    {
      sub_2AE38((int)a1);
      sub_17F28((int)a1);
      sub_1922C(a1);
      while ( !sub_1FF34((int)a1) && (!a1[33] || a1 != (_DWORD *)sub_1D9A0() && dword_73D34 != 3 && dword_73D34 != 4) )
      {
        if ( pthread_mutex_lock(&stru_73EA0) )
          sub_B35C("wait_lpcurrent", 9235);
        pthread_cond_wait(&stru_73EB8, &stru_73EA0);
        if ( pthread_mutex_unlock(&stru_73EA0) )
          sub_B50C("wait_lpcurrent", 9237);
        off_72D18();
      }
      while ( !sub_2CE20((int)a1) )
      {
        v22 = *((unsigned __int8 *)a1 + 137);
        if ( *((_BYTE *)a1 + 137) )
          goto LABEL_27;
        sub_2A884();
      }
    }
    v16 = (fd_set *)&v105;
    do
    {
      v16->__fds_bits[1] = 0;
      v16 = (fd_set *)((char *)v16 + 4);
    }
    while ( v16 != (fd_set *)&readfds.__fds_bits[31] );
    v17 = a1[153];
    timeout.tv_usec = 0;
    timeout.tv_sec = 90;
    readfds.__fds_bits[v17 / 32] |= 1 << (v17 % 32);
    if ( sub_2AD68((int)a1) || (v18 = select(a1[153] + 1, &readfds, 0, 0, &timeout), v18 > 0) )
    {
      v19 = (int *)sub_2AF98((int)a1);
      if ( !v19 )
      {
        v71 = (unsigned __int8)byte_75C49;
        goto LABEL_121;
      }
      sub_1FCAC(a1);
      if ( sub_2CE98(a1, v19) )
        goto LABEL_10;
      v23 = sub_565E8(v19, 0, (char *)v107);
      v92 = v23;
      if ( v23 )
      {
        src = (_DWORD *)sub_571D8(v23, "result");
        v96 = (_DWORD *)sub_571D8(v92, "error");
        v24 = (_DWORD *)sub_571D8(v92, "id");
        if ( !v24 || *v24 == 7 )
        {
          if ( v96 )
          {
            v74 = (char *)sub_54C0C(v96, 3);
          }
          else
          {
            v74 = (char *)malloc(0x11u);
            if ( v74 )
              strcpy(v74, "(unknown reason)");
          }
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf((char *)v109, 0x1000u, "JSON-RPC non method decode failed: %s", v74);
            sub_385C8(7, (const char *)v109, 0);
          }
          v59 = 0;
          free(v74);
        }
        else
        {
          s2 = sub_57600((int)v24);
          if ( pthread_mutex_lock(&mutex) )
            sub_B35C("parse_stratum_response", 6921);
          v25 = (void **)dword_73E68;
          if ( dword_73E68 )
          {
            v26 = *(_DWORD *)dword_73E68;
            v27 = ((unsigned __int8)s2 + 17973517 + (HIBYTE(s2) << 24) + (BYTE2(s2) << 16) + (BYTE1(s2) << 8))
                ^ (unsigned int)&unk_7F76D;
            v28 = (-1622558010 - v27) ^ (v27 << 8);
            v29 = (-17973517 - v27 - v28) ^ (v28 >> 13);
            v30 = **(_DWORD ***)dword_73E68;
            v31 = (v27 - v28 - v29) ^ (v29 >> 12);
            v32 = (v28 - v29 - v31) ^ (v31 << 16);
            v33 = (v29 - v31 - v32) ^ (v32 >> 5);
            v34 = (v31 - v32 - v33) ^ (v33 >> 3);
            v35 = (v33 - v34 - ((v32 - v33 - v34) ^ (v34 << 10))) ^ (((v32 - v33 - v34) ^ (v34 << 10)) >> 15);
            v36 = 3 * (v35 & (*(_DWORD *)(*(_DWORD *)dword_73E68 + 4) - 1));
            v37 = v30[3 * (v35 & (*(_DWORD *)(*(_DWORD *)dword_73E68 + 4) - 1))];
            if ( v37 )
              v36 = *(_DWORD *)(v26 + 20);
            else
              v13 = 0;
            if ( v37 )
              v13 = v37 - v36;
            while ( v13 )
            {
              if ( *(_DWORD *)(v13 + 24) == 4 && !memcmp(*(const void **)(v13 + 20), &s2, 4u) )
              {
                v60 = *(_DWORD *)(v13 + 4);
                if ( v60 || *(_DWORD *)(v13 + 8) )
                {
                  v61 = *(_DWORD *)(v26 + 20);
                  v62 = (_DWORD *)(*(_DWORD *)(v26 + 16) - v61);
                  if ( (_DWORD *)v13 == v62 )
                  {
                    *(_DWORD *)(v26 + 16) = v60 + v61;
                    v60 = *(_DWORD *)(v13 + 4);
                  }
                  v63 = v60 == 0;
                  if ( v60 )
                  {
                    v62 = *v25;
                    v61 = *(_DWORD *)(v13 + 8);
                  }
                  else
                  {
                    v60 = *(_DWORD *)(v13 + 8);
                  }
                  if ( v63 )
                  {
                    v25 = (void **)v60;
                    dword_73E68 = v60;
                  }
                  else
                  {
                    v60 += v62[5];
                  }
                  if ( !v63 )
                  {
                    *(_DWORD *)(v60 + 8) = v61;
                    v60 = *(_DWORD *)(v13 + 8);
                  }
                  if ( v60 )
                    *(_DWORD *)(v60 + *((_DWORD *)*v25 + 5) + 4) = *(_DWORD *)(v13 + 4);
                  v64 = 3 * ((*((_DWORD *)*v25 + 1) - 1) & *(_DWORD *)(v13 + 28));
                  v65 = *(_DWORD *)*v25 + 12 * ((*((_DWORD *)*v25 + 1) - 1) & *(_DWORD *)(v13 + 28));
                  --*(_DWORD *)(v65 + 4);
                  v66 = *(_DWORD *)*v25;
                  if ( v13 == *(_DWORD *)(v66 + 4 * v64) )
                    *(_DWORD *)(v66 + 4 * v64) = *(_DWORD *)(v13 + 16);
                  v67 = *(_DWORD *)(v13 + 12);
                  if ( v67 )
                    *(_DWORD *)(v67 + 16) = *(_DWORD *)(v13 + 16);
                  v68 = *(_DWORD *)(v13 + 16);
                  if ( v68 )
                    *(_DWORD *)(v68 + 12) = *(_DWORD *)(v13 + 12);
                  --*((_DWORD *)*v25 + 3);
                }
                else
                {
                  free(v30);
                  free(*v25);
                  dword_73E68 = 0;
                }
                --a1[189];
                break;
              }
              v38 = *(_DWORD *)(v13 + 16);
              if ( !v38 )
              {
                v13 = 0;
                break;
              }
              v13 = v38 - *(_DWORD *)(v26 + 20);
            }
          }
          else
          {
            v13 = 0;
          }
          if ( pthread_mutex_unlock(&mutex) )
            sub_B50C("parse_stratum_response", 6928);
          off_72D18();
          if ( v13 )
          {
            v39 = *(_DWORD *)(v13 + 36);
            v40 = time(0);
            if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
            {
              snprintf(
                (char *)v109,
                0x1000u,
                "Pool %d stratum share result lag time %d seconds",
                **(_DWORD **)(v39 + 1748),
                v40 - *(_DWORD *)(v13 + 48));
              sub_385C8(7, (const char *)v109, 0);
            }
            v41 = 0;
            v109[0] = bswap32(*(_DWORD *)(v39 + 220));
            v109[1] = bswap32(*(_DWORD *)(v39 + 216));
            v109[2] = bswap32(*(_DWORD *)(v39 + 212));
            v109[3] = bswap32(*(_DWORD *)(v39 + 208));
            v109[4] = bswap32(*(_DWORD *)(v39 + 204));
            v109[5] = bswap32(*(_DWORD *)(v39 + 200));
            v109[6] = bswap32(*(_DWORD *)(v39 + 196));
            v109[7] = bswap32(*(_DWORD *)(v39 + 192));
            do
            {
              if ( *((_BYTE *)v109 + v41) )
                break;
              ++v41;
            }
            while ( v41 != 29 );
            v42 = (double *)(v39 + 1864);
            v43 = *(double *)(v39 + 1864);
            v44 = *(_DWORD *)((char *)v109 + v41);
            round(v110);
            LODWORD(v46) = sub_5A000(v43);
            HIDWORD(v46) = v45;
            sub_114B8(*(_QWORD *)(v39 + 1720), v103, 0x10u, 0);
            v47 = "";
            v48 = bswap32(v44);
            if ( *(_BYTE *)(v39 + 1771) )
              v47 = " BLOCK!";
            snprintf(v104, 0x40u, "%08lx Diff %s/%llu%s", v48, v103, v46, v47);
            v49 = *(_DWORD **)(v39 + 1748);
            v93 = *(_DWORD *)(sub_1AA90(*(_DWORD *)(v39 + 1744)) + 36);
            if ( src && (*src == 5 || *(_BYTE *)(v39 + 1812) && *src == 7) )
            {
              if ( pthread_mutex_lock(&stru_77B74) )
                sub_B35C("share_result", 3481);
              v81 = dbl_78410;
              ++*(_DWORD *)(v93 + 36);
              ++*((_QWORD *)v49 + 1);
              v82 = *(double *)(v93 + 200) + *v42;
              ++qword_78248;
              *(double *)(v93 + 200) = v82;
              v83 = *v42 + v81;
              *((double *)v49 + 13) = *((double *)v49 + 13) + *v42;
              dbl_78410 = v83;
              if ( pthread_mutex_unlock(&stru_77B74) )
                sub_B50C("share_result", 3488);
              off_72D18();
              v84 = *v49;
              v49[6] = 0;
              *(_DWORD *)(v93 + 216) = v84;
              v85 = time(0);
              v86 = (unsigned __int8)byte_75C49;
              *(_DWORD *)(v93 + 220) = v85;
              *(double *)(v93 + 224) = *v42;
              v49[96] = v85;
              *((double *)v49 + 49) = *v42;
              if ( v86 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                strcpy((char *)v109, "PROOF OF WORK RESULT: true (yay!!!)");
                sub_385C8(7, (const char *)v109, 0);
              }
              if ( !byte_78AA0 && !byte_78940 )
              {
                if ( dword_77FC0 <= 1 )
                {
                  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                  {
                    snprintf(
                      (char *)v109,
                      0x1000u,
                      "Accepted %s %s %d %s%s",
                      v104,
                      *(const char **)(*(_DWORD *)(v93 + 4) + 8),
                      *(_DWORD *)(v93 + 8),
                      "",
                      "");
                    sub_385C8(7, (const char *)v109, 0);
                  }
                }
                else if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                {
                  snprintf(
                    (char *)v109,
                    0x1000u,
                    "Accepted %s %s %d pool %d %s%s",
                    v104,
                    *(const char **)(*(_DWORD *)(v93 + 4) + 8),
                    *(_DWORD *)(v93 + 8),
                    **(_DWORD **)(v39 + 1748),
                    "",
                    "");
                  sub_385C8(7, (const char *)v109, 0);
                }
              }
              sub_1AF6C("accept", (_DWORD *)v39);
              if ( dword_740C0 && (double)dword_740C0 <= dbl_78410 )
              {
                if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
                {
                  snprintf(
                    (char *)v109,
                    0x1000u,
                    "Successfully mined %d accepted shares as requested and exiting.",
                    dword_740C0);
                  sub_385C8(4, (const char *)v109, 0);
                }
                sub_17830();
              }
              if ( v49[33] == 2 )
              {
                if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3
                  || (snprintf((char *)v109, 0x1000u, "Rejecting pool %d now accepting shares, re-enabling!", *v49),
                      sub_385C8(4, (const char *)v109, 0),
                      v49[33] != 1) )
                {
                  v49[33] = 1;
                  ++dword_7840C;
                }
                sub_1A600(0);
              }
              if ( *(_BYTE *)(v39 + 1771) )
                sub_17148();
            }
            else
            {
              if ( pthread_mutex_lock(&stru_77B74) )
                sub_B35C("share_result", 3531);
              v50 = dbl_78498;
              ++*(_DWORD *)(v93 + 40);
              ++*((_QWORD *)v49 + 2);
              v51 = *(double *)(v93 + 208) + *v42;
              ++qword_78520;
              *(double *)(v93 + 208) = v51;
              v52 = *v42;
              v53 = *((double *)v49 + 14) + *v42;
              ++v49[6];
              *((double *)v49 + 14) = v53;
              dbl_78498 = v52 + v50;
              if ( pthread_mutex_unlock(&stru_77B74) )
                sub_B50C("share_result", 3539);
              off_72D18();
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                strcpy((char *)v109, "PROOF OF WORK RESULT: false (booooo)");
                sub_385C8(7, (const char *)v109, 0);
              }
              if ( !byte_78AA0 && !byte_78940 )
              {
                strcpy(v103, "reject");
                memset(&v103[7], (unsigned __int8)byte_78940, 0x1Du);
                v101[0] = byte_78940;
                if ( dword_77FC0 <= 1 )
                  v100[0] = byte_78940;
                else
                  snprintf(v100, 0x14u, "pool %d", **(_DWORD **)(v39 + 1748));
                if ( !*(_BYTE *)(v39 + 1812) )
                  src = (_DWORD *)sub_571D8(v92, "reject-reason");
                if ( src )
                {
                  srca = (const char *)sub_57530(src);
                  v54 = strlen(srca);
                  qmemcpy(v101, " (", sizeof(v101));
                  if ( v54 >= 0x1C )
                    v55 = 28;
                  else
                    v55 = v54;
                  v56 = &v110[v55];
                  n = v55;
                  memcpy(dest, srca, v55);
                  *((_WORD *)v56 - 2303) = 41;
                  memcpy(&v103[7], srca, n);
                  v103[6] = 58;
                  *(v56 - 4569) = 0;
                }
                else if ( *(_BYTE *)(v39 + 1772) && v96 )
                {
                  if ( *v96 == 1 )
                  {
                    v87 = sub_573C0(v96, 1u);
                    if ( !v87 || *v87 != 2 )
                      goto LABEL_76;
                  }
                  else
                  {
                    if ( *v96 != 2 )
                      goto LABEL_76;
                    v87 = v96;
                  }
                  v88 = (const char *)sub_57530(v87);
                  snprintf(v101, 0x1Fu, " (%s)", v88);
                }
LABEL_76:
                if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                {
                  snprintf(
                    (char *)v109,
                    0x1000u,
                    "Rejected %s %s %d %s%s %s%s",
                    v104,
                    *(const char **)(*(_DWORD *)(v93 + 4) + 8),
                    *(_DWORD *)(v93 + 8),
                    v100,
                    v101,
                    "",
                    "");
                  sub_385C8(7, (const char *)v109, 0);
                }
                sub_1AF6C(v103, (_DWORD *)v39);
              }
              v57 = v49[6];
              if ( v57 > 10 && !*(_BYTE *)(v39 + 1769) )
              {
                if ( byte_78078 )
                {
                  if ( dword_7840C > 1 )
                  {
                    LODWORD(v58) = sub_59F1C(qword_78248);
                    if ( (double)v57 > v58 / dbl_72438 * 60.0 * 3.0 )
                    {
                      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
                      {
                        snprintf((char *)v109, 0x1000u, "Pool %d rejected %d sequential shares, disabling!", *v49, v57);
                        sub_385C8(4, (const char *)v109, 0);
                      }
                      if ( v49[33] == 1 )
                        --dword_7840C;
                      v49[33] = 2;
                      if ( v49 == (_DWORD *)sub_1D9A0() )
                        sub_1A600(0);
                      v49[6] = 0;
                    }
                  }
                }
              }
            }
            v59 = 1;
            sub_156B8(*(void ***)(v13 + 36));
            *(_DWORD *)(v13 + 36) = 0;
            free((void *)v13);
          }
          else if ( src )
          {
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
              sub_B35C("parse_stratum_response", 6938);
            if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 67)) )
              sub_B5E4("parse_stratum_response", 6938);
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
              sub_B50C("parse_stratum_response", 6938);
            v78 = *((double *)a1 + 230);
            if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
              sub_B578("parse_stratum_response", 6940);
            off_72D18();
            if ( *src == 5 )
            {
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                snprintf((char *)v109, 0x1000u, "Accepted untracked stratum share from pool %d", *a1);
                sub_385C8(7, (const char *)v109, 0);
              }
              if ( pthread_mutex_lock(&stru_77B74) )
                sub_B35C("parse_stratum_response", 6948);
              v89 = *((double *)a1 + 13) + v78;
              v90 = dbl_78410;
              ++*((_QWORD *)a1 + 1);
              ++qword_78248;
              *((double *)a1 + 13) = v89;
              dbl_78410 = v78 + v90;
              if ( pthread_mutex_unlock(&stru_77B74) )
                sub_B50C("parse_stratum_response", 6953);
            }
            else
            {
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                snprintf((char *)v109, 0x1000u, "Rejected untracked stratum share from pool %d", *a1);
                sub_385C8(7, (const char *)v109, 0);
              }
              if ( pthread_mutex_lock(&stru_77B74) )
                sub_B35C("parse_stratum_response", 6959);
              v79 = *((double *)a1 + 14) + v78;
              v80 = dbl_78498;
              ++*((_QWORD *)a1 + 2);
              ++qword_78520;
              *((double *)a1 + 14) = v79;
              dbl_78498 = v78 + v80;
              if ( pthread_mutex_unlock(&stru_77B74) )
                sub_B50C("parse_stratum_response", 6964);
            }
            v59 = 0;
            off_72D18();
          }
          else
          {
            v59 = 0;
          }
        }
        v75 = v92[1];
        if ( v75 != -1 )
        {
          v76 = v75 - 1;
          v92[1] = v76;
          if ( !v76 )
            sub_5779C((void **)v92);
        }
        if ( v59 )
        {
LABEL_10:
          if ( *((_BYTE *)a1 + 696) )
          {
            v69 = sub_1A520();
            *((_BYTE *)a1 + 696) = 0;
            v70 = (int)v69;
            sub_1D5F0((int)a1, (int)v69);
            *(_BYTE *)(v70 + 1768) = 1;
            sub_1DA54(v70);
            sub_156B8((void **)v70);
          }
          goto LABEL_12;
        }
        v77 = (unsigned __int8)byte_75C49;
        goto LABEL_156;
      }
      if ( !byte_75C49 )
        goto LABEL_12;
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_157;
      snprintf((char *)v109, 0x1000u, "JSON decode failed(%d): %s", v107[0], v108);
      sub_385C8(7, (const char *)v109, 0);
      v77 = (unsigned __int8)byte_75C49;
LABEL_156:
      if ( !v77 )
        goto LABEL_12;
LABEL_157:
      if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
      {
        snprintf((char *)v109, 0x1000u, "Unknown stratum msg: %s", (const char *)v19);
        sub_385C8(7, (const char *)v109, 0);
      }
LABEL_12:
      free(v19);
    }
    else
    {
      if ( !byte_75C49 )
        goto LABEL_126;
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
      {
LABEL_122:
        if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
        {
          snprintf((char *)v109, 0x1000u, "Stratum connection to pool %d interrupted", *a1);
          sub_385C8(7, (const char *)v109, 0);
        }
        goto LABEL_126;
      }
      snprintf((char *)v109, 0x1000u, "Stratum select failed on pool %d with value %d", *a1, v18);
      sub_385C8(7, (const char *)v109, 0);
      v71 = (unsigned __int8)byte_75C49;
LABEL_121:
      if ( v71 )
        goto LABEL_122;
LABEL_126:
      v72 = dword_78264;
      ++a1[40];
      dword_78264 = v72 + 1;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
        sub_B35C("supports_resume", 7101);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B5E4("supports_resume", 7101);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
        sub_B50C("supports_resume", 7101);
      v73 = a1[165];
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B578("supports_resume", 7103);
      off_72D18();
      if ( !v73 || byte_7846C )
        sub_17F28((int)a1);
      sub_1922C(a1);
      if ( a1 == (_DWORD *)sub_1D9A0() )
        sub_17148();
      while ( !sub_2CE20((int)a1) )
      {
        v22 = *((unsigned __int8 *)a1 + 137);
        if ( *((_BYTE *)a1 + 137) )
          goto LABEL_27;
        sub_2A884();
      }
    }
  }
  sub_2AE38((int)a1);
LABEL_27:
  sub_201FC(0, v20, v21, v22, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}
// 201F9: variable 'v20' is possibly undefined
// 201F9: variable 'v21' is possibly undefined
// 201F9: variable 'v22' is possibly undefined
// 2042C: variable 'v13' is possibly undefined
// 205C4: variable 'v45' is possibly undefined
// 20994: variable 'v58' is possibly undefined
// AD44: using guessed type int __fastcall round(_DWORD);
// 72438: using guessed type double dbl_72438;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73D34: using guessed type int dword_73D34;
// 73E68: using guessed type int dword_73E68;
// 740C0: using guessed type int dword_740C0;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77FC0: using guessed type int dword_77FC0;
// 78078: using guessed type char byte_78078;
// 78248: using guessed type __int64 qword_78248;
// 78264: using guessed type int dword_78264;
// 7840C: using guessed type int dword_7840C;
// 78410: using guessed type double dbl_78410;
// 7846C: using guessed type char byte_7846C;
// 78498: using guessed type double dbl_78498;
// 78520: using guessed type __int64 qword_78520;
// 78940: using guessed type char byte_78940;
// 78AA0: using guessed type char byte_78AA0;

//----- (000201FC) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_201FC(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  __asm { POP             {R4-R11,PC} }
}
// 20208: positive sp value 1294 has been found
// 20208: unbalanced stack, ignored a potential tail call

//----- (00021798) --------------------------------------------------------
void __noreturn sub_21798()
{
  int v0; // r2
  int v1; // r6
  int v2; // r4
  __int64 v3; // r10
  double v4; // r0
  double v5; // d16
  double v6; // d16
  int v7; // r5
  _DWORD *v8; // r3
  _DWORD *v9; // r2
  int v10; // r5
  int v11; // r3
  int v12; // r10
  int v13; // r12
  int v14; // r6
  int v15; // r3
  _DWORD *v16; // r3
  int v17; // lr
  int v18; // r3
  const char *v19; // r10
  int v20; // r11
  int v21; // r10
  int v22; // r3
  int v23; // r5
  int v24; // r6
  int v25; // r4
  int v26; // r1
  int **v27; // r3
  int v28; // r0
  int *v29; // r12
  bool v30; // zf
  int v31; // r1
  int v32; // r0
  int v33; // r0
  int v34; // r1
  int v35; // r1
  int v36; // r3
  __int64 v37; // r2
  int v38; // [sp+10h] [bp-1024h]
  void **v39; // [sp+10h] [bp-1024h]
  int v40; // [sp+14h] [bp-1020h]
  pthread_mutex_t *mutex; // [sp+18h] [bp-101Ch]
  pthread_mutex_t *mutexa; // [sp+18h] [bp-101Ch]
  int v43; // [sp+1Ch] [bp-1018h]
  struct timeval v44; // [sp+20h] [bp-1014h] BYREF
  struct timeval v45; // [sp+28h] [bp-100Ch] BYREF
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2EF24("Watchpool");
  sub_1202C();
  v40 = 0;
  while ( 1 )
  {
    sub_2A7A4(&v44);
    v0 = v40 + 1;
    if ( v40 + 1 > 20 )
      v0 = 0;
    v40 = v0;
    if ( dword_77FC0 > 0 )
    {
      v1 = 0;
      while ( 1 )
      {
        v2 = *(_DWORD *)(dword_78260 + 4 * v1);
        if ( byte_74149 || dword_73E34 )
          goto LABEL_11;
        mutex = (pthread_mutex_t *)(v2 + 220);
        sub_2A7A4(&v45);
        if ( pthread_mutex_lock((pthread_mutex_t *)(v2 + 220)) )
          sub_B35C("reap_curl", 9490);
        v8 = *(_DWORD **)(v2 + 376);
        v9 = v8 - 1;
        v10 = *v8 - 4;
        if ( (_DWORD *)(v2 + 376) == v8 )
        {
          v12 = 0;
          if ( pthread_mutex_unlock(mutex) )
            goto LABEL_95;
        }
        else
        {
          v11 = *(_DWORD *)(v2 + 320);
          v12 = 0;
          if ( v11 > 1 )
          {
            v13 = 0;
            v43 = v1;
            v14 = 0;
            do
            {
              if ( v45.tv_sec - v9[3] > 300 )
              {
                *(_DWORD *)(v2 + 320) = v11 - 1;
                v16 = (_DWORD *)v9[2];
                v17 = v9[1];
                ++v14;
                *(_DWORD *)(v17 + 4) = v16;
                *v16 = v17;
                v9[1] = v13;
                v9[2] = v13;
                v38 = v13;
                free(v9);
                v13 = v38;
              }
              v9 = (_DWORD *)v10;
              v15 = v10 + 4;
              v10 = *(_DWORD *)(v10 + 4) - 4;
              if ( v2 + 376 == v15 )
                break;
              v11 = *(_DWORD *)(v2 + 320);
            }
            while ( v11 > 1 );
            v12 = v14;
            v1 = v43;
          }
          if ( pthread_mutex_unlock(mutex) )
LABEL_95:
            sub_B50C("reap_curl", 9504);
        }
        off_72D18();
        if ( v12 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          v18 = v12;
          if ( v12 == 1 )
            v19 = "";
          else
            v19 = "s";
          snprintf(s, 0x1000u, "Reaped %d curl%s from pool %d", v18, v19, *(_DWORD *)v2);
          sub_385C8(7, s, 0);
        }
        mutexa = (pthread_mutex_t *)time(0);
        if ( pthread_mutex_lock(&::mutex) )
          sub_B35C("prune_stratum_shares", 9519);
        v20 = dword_73E68;
        if ( !dword_73E68 )
        {
          v21 = 0;
          goto LABEL_81;
        }
        v22 = v1;
        v23 = *(_DWORD *)(dword_73E68 + 8);
        v24 = v2;
        v21 = 0;
        v25 = v22;
        while ( v24 != *(_DWORD *)(*(_DWORD *)(v20 + 36) + 1748) || (int)mutexa <= *(_DWORD *)(v20 + 44) + 120 )
        {
          if ( !v23 )
            goto LABEL_80;
LABEL_56:
          v20 = v23;
          v23 = *(_DWORD *)(v23 + 8);
        }
        v26 = *(_DWORD *)(v20 + 4);
        if ( v26 || *(_DWORD *)(v20 + 8) )
        {
          v27 = (int **)dword_73E68;
          v28 = *(_DWORD *)dword_73E68;
          v29 = *(int **)(*(_DWORD *)dword_73E68 + 20);
          if ( v20 == *(_DWORD *)(*(_DWORD *)dword_73E68 + 16) - (_DWORD)v29 )
          {
            *(_DWORD *)(v28 + 16) = (char *)v29 + v26;
            v26 = *(_DWORD *)(v20 + 4);
          }
          v30 = v26 == 0;
          if ( v26 )
          {
            v29 = *v27;
            v28 = *(_DWORD *)(v20 + 8);
          }
          else
          {
            v26 = *(_DWORD *)(v20 + 8);
          }
          if ( v30 )
          {
            v27 = (int **)v26;
            dword_73E68 = v26;
          }
          else
          {
            v26 += v29[5];
          }
          if ( !v30 )
          {
            *(_DWORD *)(v26 + 8) = v28;
            v26 = *(_DWORD *)(v20 + 8);
          }
          if ( v26 )
            *(_DWORD *)(v26 + (*v27)[5] + 4) = *(_DWORD *)(v20 + 4);
          v31 = 3 * (((*v27)[1] - 1) & *(_DWORD *)(v20 + 28));
          v32 = **v27 + 12 * (((*v27)[1] - 1) & *(_DWORD *)(v20 + 28));
          --*(_DWORD *)(v32 + 4);
          v33 = **v27;
          if ( v20 == *(_DWORD *)(v33 + 4 * v31) )
            *(_DWORD *)(v33 + 4 * v31) = *(_DWORD *)(v20 + 16);
          v34 = *(_DWORD *)(v20 + 12);
          if ( v34 )
            *(_DWORD *)(v34 + 16) = *(_DWORD *)(v20 + 16);
          v35 = *(_DWORD *)(v20 + 16);
          if ( v35 )
            *(_DWORD *)(v35 + 12) = *(_DWORD *)(v20 + 12);
          --(*v27)[3];
        }
        else
        {
          v39 = (void **)dword_73E68;
          free(**(void ***)dword_73E68);
          free(*v39);
          dword_73E68 = 0;
        }
        ++v21;
        sub_156B8(*(void ***)(v20 + 36));
        *(_DWORD *)(v20 + 36) = 0;
        free((void *)v20);
        if ( v23 )
          goto LABEL_56;
LABEL_80:
        v36 = v25;
        v2 = v24;
        v1 = v36;
LABEL_81:
        if ( pthread_mutex_unlock(&::mutex) )
          sub_B50C("prune_stratum_shares", 9530);
        off_72D18();
        if ( v21 )
        {
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, "Lost %d shares due to no stratum share response from pool %d", v21, *(_DWORD *)v2);
            sub_385C8(4, s, 0);
          }
          v37 = *(_QWORD *)&dword_78AA8;
          *(_DWORD *)(v2 + 152) += v21;
          *(_QWORD *)&dword_78AA8 = v37 + v21;
        }
LABEL_11:
        if ( v40 == 20 )
        {
          v3 = *(_QWORD *)(v2 + 40);
          LODWORD(v4) = sub_59F1C(v3 - *(int *)(v2 + 184));
          v5 = *(double *)(v2 + 176);
          *(_DWORD *)(v2 + 184) = v3;
          v6 = (v5 + v4 * 0.63) / 1.63;
          *(double *)(v2 + 176) = v6;
          *(_DWORD *)(v2 + 188) = (int)v6;
        }
        if ( !*(_DWORD *)(v2 + 132) || *(_BYTE *)(v2 + 316) )
          goto LABEL_8;
        if ( !*(_BYTE *)(v2 + 129) )
        {
LABEL_7:
          if ( !dword_73D34 )
          {
            v7 = *(_DWORD *)(v2 + 4);
            if ( v7 < sub_1FAC4() && v44.tv_sec - *(_DWORD *)(v2 + 168) > 300 )
            {
              if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
              {
                snprintf(s, 0x1000u, "Pool %d %s stable for 5 mins", *(_DWORD *)v2, *(const char **)(v2 + 196));
                sub_385C8(4, s, 0);
              }
              sub_1A600(0);
            }
          }
          goto LABEL_8;
        }
        if ( v44.tv_sec - *(_DWORD *)(v2 + 168) <= 30 )
        {
LABEL_8:
          if ( dword_77FC0 <= ++v1 )
            break;
        }
        else
        {
          if ( sub_18610((_DWORD *)v2, 1) && sub_18200(v2, (_BYTE *)(v2 + 129)) )
            sub_1FB7C((_DWORD *)v2);
          else
            sub_2A7A4((struct timeval *)(v2 + 168));
          if ( !*(_BYTE *)(v2 + 129) )
            goto LABEL_7;
          if ( dword_77FC0 <= ++v1 )
            break;
        }
      }
    }
    if ( *(_BYTE *)(sub_1D9A0() + 129) )
    {
      sub_1A600(0);
      if ( dword_73D34 != 2 )
        goto LABEL_24;
    }
    else if ( dword_73D34 != 2 )
    {
      goto LABEL_24;
    }
    if ( v44.tv_sec - stru_7414C.tv_sec > 60 * dword_78380 )
    {
      sub_2A7A4(&stru_7414C);
      sub_1A600(0);
    }
LABEL_24:
    sub_2A884();
  }
}
// 2188C: variable 'v4' is possibly undefined
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73D34: using guessed type int dword_73D34;
// 73E34: using guessed type int dword_73E34;
// 73E68: using guessed type int dword_73E68;
// 74149: using guessed type char byte_74149;
// 7414C: using guessed type struct timeval stru_7414C;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;
// 78380: using guessed type int dword_78380;
// 78AA8: using guessed type int dword_78AA8;

//----- (00021F30) --------------------------------------------------------
void *__fastcall sub_21F30(_DWORD *a1)
{
  pthread_t v1; // r0
  char *v2; // r0
  const char **v3; // r5
  int **v4; // r4
  time_t v5; // r0
  _BYTE *v6; // r7
  char *v7; // r6
  int v8; // r3
  size_t v9; // r0
  int *v10; // r6
  size_t v11; // r0
  int **v12; // r5
  int *v13; // r6
  unsigned int v14; // r3
  unsigned int v15; // r2
  unsigned int v16; // r0
  int v17; // r1
  unsigned int v18; // r2
  unsigned int v19; // r3
  unsigned int v20; // r1
  unsigned int v21; // r3
  int v22; // r2
  int v23; // r3
  int *v24; // r1
  int v25; // r1
  int ***v26; // r0
  int v27; // r2
  int *v28; // r5
  size_t v29; // r6
  _DWORD *v30; // r0
  _DWORD *v31; // r7
  int v32; // r8
  void **v33; // r3
  void *v34; // r6
  void ***v35; // r11
  _DWORD *v36; // r5
  void *v37; // r4
  _DWORD *v38; // r9
  int v39; // r4
  char *v40; // r6
  unsigned int v41; // r2
  int v42; // r3
  int *v43; // r3
  unsigned int v44; // r1
  unsigned int v45; // r2
  bool v46; // cc
  int v47; // r2
  time_t v48; // r0
  int v49; // r3
  int *v50; // r2
  int *v52; // r0
  void *v53; // r0
  const char *v54; // r1
  _BOOL4 v55; // r7
  int v56; // r3
  unsigned int i; // [sp+1Ch] [bp-2020h]
  char s[16]; // [sp+28h] [bp-2014h] BYREF
  char v60[4096]; // [sp+38h] [bp-2004h] BYREF
  char v61[4100]; // [sp+1038h] [bp-1004h] BYREF

  v1 = pthread_self();
  pthread_detach(v1);
  snprintf(s, 0x10u, "%d/SStratum", *a1);
  sub_2EF24(s);
  v2 = sub_2A0C0();
  a1[188] = v2;
  if ( !v2 )
  {
    strcpy(v61, "Failed to create stratum_q in stratum_sthread");
    sub_385C8(3, v61, 1);
    sub_16BE0(1);
  }
  memset(v60, 0, sizeof(v60));
  if ( *((_BYTE *)a1 + 137) )
    goto LABEL_56;
  do
  {
    v3 = (const char **)sub_2A258(a1[188], 0);
    if ( !v3 )
    {
      strcpy(v61, "Stratum q returned empty work");
      sub_385C8(3, v61, 1);
      sub_16BE0(1);
    }
    v4 = (int **)calloc(0x34u, 1u);
    if ( !v4 )
    {
      snprintf(v61, 0x1000u, "%s: calloc() failed on sshare.", "stratum_sthread");
      sub_385C8(3, v61, 1);
      sub_16BE0(1);
    }
    v5 = time(0);
    v4[9] = (int *)v3;
    v4[11] = (int *)v5;
    v6 = sub_29688((int)(v3 + 83), 32);
    v7 = sub_29688((int)(v3 + 91), 1347);
    if ( pthread_mutex_lock(&mutex) )
      sub_B35C("stratum_sthread", 7275);
    v8 = dword_77F20++;
    v4[10] = (int *)v8;
    if ( pthread_mutex_unlock(&mutex) )
      sub_B50C("stratum_sthread", 7278);
    off_72D18();
    v9 = strlen(v3[452]);
    snprintf(
      v60,
      0x1000u,
      "{\"id\": %d, \"method\": \"mining.submit\", \"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"]}",
      v4[10],
      (const char *)a1[51],
      v3[444],
      v3[449],
      &v6[v9],
      v7);
    free(v6);
    free(v7);
    while ( 1 )
    {
      v10 = v4[11];
      if ( (int)v10 + 119 < time(0) )
        goto LABEL_50;
      v11 = strlen(v60);
      if ( sub_2B520((int)a1, v60, v11) )
      {
        if ( pthread_mutex_lock(&mutex) )
          sub_B35C("stratum_sthread", 7293);
        v4[2] = 0;
        v4[5] = (int *)(v4 + 10);
        v12 = (int **)dword_73E68;
        v4[6] = (int *)4;
        if ( v12 )
        {
          *(_DWORD *)((*v12)[4] + 8) = v4;
          v4[1] = (int *)((*v12)[4] - (*v12)[5]);
          (*v12)[4] = (int)v4;
          v13 = *v12;
        }
        else
        {
          v4[1] = 0;
          dword_73E68 = (int)v4;
          v52 = (int *)malloc(0x2Cu);
          v13 = v52;
          *v4 = v52;
          if ( !v52 )
            goto LABEL_62;
          *v52 = 0;
          v52[3] = 0;
          v52[4] = 0;
          v52[5] = 0;
          v52[6] = 0;
          v52[7] = 0;
          v52[8] = 0;
          v52[9] = 0;
          v52[10] = 0;
          v52[4] = (int)v4;
          v52[5] = 0;
          v52[1] = 32;
          v52[2] = 5;
          v53 = malloc(0x180u);
          *v13 = (int)v53;
          if ( !v53 )
            goto LABEL_62;
          memset(v53, 0, 0x180u);
          v12 = v4;
          v13[10] = -1609490463;
        }
        ++v13[3];
        v14 = (*((unsigned __int8 *)v4 + 40)
             + 17973517
             + (*((unsigned __int8 *)v4 + 43) << 24)
             + (*((unsigned __int8 *)v4 + 42) << 16)
             + (*((unsigned __int8 *)v4 + 41) << 8))
            ^ (unsigned int)&unk_7F76D;
        v15 = (-1622558010 - v14) ^ (v14 << 8);
        *v4 = *v12;
        v16 = (-17973517 - v14 - v15) ^ (v15 >> 13);
        v17 = (v14 - v15 - v16) ^ (v16 >> 12);
        v18 = (v15 - v16 - v17) ^ (v17 << 16);
        v19 = (v16 - v17 - v18) ^ (v18 >> 5);
        v20 = v17 - v18 - v19;
        v21 = (v19 - (v20 ^ (v19 >> 3)) - ((v18 - v19 - (v20 ^ (v19 >> 3))) ^ ((v20 ^ (v19 >> 3)) << 10)))
            ^ (((v18 - v19 - (v20 ^ (v19 >> 3))) ^ ((v20 ^ (v19 >> 3)) << 10)) >> 15);
        v4[7] = (int *)v21;
        v22 = 3 * (v21 & ((*v12)[1] - 1));
        v23 = 12 * (v21 & ((*v12)[1] - 1));
        ++*(_DWORD *)(**v12 + v23 + 4);
        v24 = *(int **)(**v12 + 4 * v22);
        v4[3] = 0;
        v4[4] = v24;
        v25 = **v12;
        v26 = (int ***)(v25 + v23);
        v27 = *(_DWORD *)(v25 + 4 * v22);
        if ( v27 )
        {
          *(_DWORD *)(v27 + 12) = v4;
          v26 = (int ***)(**v12 + v23);
        }
        *v26 = v4;
        if ( *(_DWORD *)(**v12 + v23 + 4) < (unsigned int)(10 * (*(_DWORD *)(**v12 + v23 + 8) + 1)) )
          goto LABEL_39;
        v28 = *v4;
        if ( (*v4)[9] == 1 )
          goto LABEL_39;
        v29 = 24 * v28[1];
        v30 = malloc(v29);
        v31 = v30;
        if ( v30 )
        {
          memset(v30, 0, v29);
          v32 = 0;
          v28[6] = (((2 * v28[1] - 1) & v28[3]) != 0) + ((unsigned int)v28[3] >> (*((_BYTE *)v28 + 8) + 1));
          (*v4)[7] = 0;
          v33 = (void **)*v4;
          v34 = (void *)(*v4)[1];
          if ( v34 )
          {
            v35 = (void ***)v4;
            for ( i = 0; i < (unsigned int)v34; ++i )
            {
              v36 = *(_DWORD **)((char *)*v33 + v32);
              if ( v36 )
              {
                v37 = v34;
                while ( 1 )
                {
                  v38 = (_DWORD *)v36[4];
                  v39 = 3 * ((2 * (_DWORD)v37 - 1) & v36[7]);
                  v40 = (char *)&v31[v39];
                  v41 = *((_DWORD *)v40 + 1) + 1;
                  *((_DWORD *)v40 + 1) = v41;
                  if ( v41 > (unsigned int)v33[6] )
                  {
                    v33[7] = (char *)v33[7] + 1;
                    *((_DWORD *)v40 + 2) = *((_DWORD *)v40 + 1) / (unsigned int)(*v35)[6];
                  }
                  v36[3] = 0;
                  v36[4] = v31[v39];
                  v42 = v31[v39];
                  if ( v42 )
                    *(_DWORD *)(v42 + 12) = v36;
                  v31[v39] = v36;
                  v33 = *v35;
                  if ( !v38 )
                    break;
                  v37 = v33[1];
                  v36 = v38;
                }
                v34 = v33[1];
              }
              v32 += 12;
            }
            v4 = (int **)v35;
          }
          free(*v33);
          (*v4)[1] *= 2;
          ++(*v4)[2];
          **v4 = (int)v31;
          v43 = *v4;
          v44 = (*v4)[3];
          v45 = (*v4)[7];
          v46 = v45 > v44 >> 1;
          if ( v45 <= v44 >> 1 )
            v47 = 0;
          else
            v47 = v43[8];
          if ( v46 )
            ++v47;
          v43[8] = v47;
          if ( (unsigned int)(*v4)[8] > 1 )
            (*v4)[9] = 1;
LABEL_39:
          ++a1[189];
          if ( pthread_mutex_unlock(&mutex) )
            sub_B50C("stratum_sthread", 7296);
          off_72D18();
          if ( sub_18200((int)a1, (_BYTE *)a1 + 128) && (byte_77B70 || byte_75C48 || dword_73504 > 3) )
          {
            snprintf(v61, 0x1000u, "Pool %d communication resumed, submitting work", *a1);
            sub_385C8(4, v61, 0);
          }
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            strcpy(v61, "Successfully submitted, adding to stratum_shares db");
            sub_385C8(7, v61, 0);
          }
          goto LABEL_50;
        }
LABEL_62:
        exit(-1);
      }
      if ( !sub_1859C((int)a1, (_BYTE *)a1 + 128) && sub_1FF34((int)a1) )
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(v61, 0x1000u, "Pool %d stratum share submission failure", *a1);
          sub_385C8(4, v61, 0);
        }
        v56 = a1[41];
        ++dword_77C90;
        a1[41] = v56 + 1;
      }
      if ( byte_7846C )
        break;
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
        sub_B35C("stratum_sthread", 7317);
      if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B5E4("stratum_sthread", 7317);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
        sub_B50C("stratum_sthread", 7317);
      v54 = (const char *)a1[159];
      if ( v54 )
        v55 = strcmp(v3[452], v54) == 0;
      else
        v55 = 0;
      if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
        sub_B578("stratum_sthread", 7319);
      off_72D18();
      if ( !v55 )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          strcpy(v61, "No matching session id for resubmitting stratum share");
          sub_385C8(7, v61, 0);
        }
        goto LABEL_50;
      }
      sleep(5u);
    }
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(v61, "Lowmem option prevents resubmitting stratum share");
      sub_385C8(7, v61, 0);
    }
LABEL_50:
    v48 = time(0);
    v49 = (unsigned __int8)byte_75C49;
    v50 = v4[11];
    v4[12] = (int *)v48;
    if ( v49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v61, 0x1000u, "Pool %d stratum share submission lag time %d seconds", *a1, v48 - (_DWORD)v50);
      sub_385C8(7, v61, 0);
    }
    memset(v60, 0, sizeof(v60));
  }
  while ( !*((_BYTE *)a1 + 137) );
LABEL_56:
  sub_2A188(a1[188]);
  return 0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E68: using guessed type int dword_73E68;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77C90: using guessed type int dword_77C90;
// 77F20: using guessed type int dword_77F20;
// 7846C: using guessed type char byte_7846C;

//----- (00022A8C) --------------------------------------------------------
int __fastcall sub_22A8C(int a1, int a2)
{
  int v5; // r7
  int v6; // r8
  int v7; // r7
  const char *v8; // lr
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int *v13; // lr
  int v14; // r0
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r1
  int v19; // r2
  int v20; // r9
  struct timeval v21; // [sp+0h] [bp-1008h] BYREF
  _DWORD v22[10]; // [sp+8h] [bp-1000h] BYREF
  __int16 v23; // [sp+30h] [bp-FD8h]

  if ( byte_74149 || dword_73E34 )
    return 0;
  if ( *(_DWORD *)(a1 + 1824) != dword_740CC )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy((char *)v22, "Work stale due to block mismatch");
      sub_385C8(7, (const char *)v22, 0);
      return 1;
    }
    return 1;
  }
  v5 = *(_DWORD *)(a1 + 1764);
  v6 = *(_DWORD *)(a1 + 1748);
  if ( v5 <= dword_72C30 )
    v5 = dword_72C34;
  if ( !a2 && *(_BYTE *)(v6 + 664) )
  {
    if ( !*(_BYTE *)(v6 + 665) || !*(_BYTE *)(v6 + 667) )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        strcpy((char *)v22, "Work stale due to stratum inactive");
        sub_385C8(7, (const char *)v22, 0);
        return 1;
      }
      return 1;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(v6 + 244)) )
      sub_B35C("stale_work", 4935);
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 268)) )
      sub_B5E4("stale_work", 4935);
    if ( pthread_mutex_unlock((pthread_mutex_t *)(v6 + 244)) )
      sub_B50C("stale_work", 4935);
    v20 = strcmp(*(const char **)(a1 + 1776), *(const char **)(v6 + 672));
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 268)) )
      sub_B578("stale_work", 4938);
    off_72D18();
    if ( v20 )
    {
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        return 1;
      v8 = "Work stale due to stratum job_id mismatch";
LABEL_42:
      v9 = *(_DWORD *)v8;
      v10 = *((_DWORD *)v8 + 1);
      v11 = *((_DWORD *)v8 + 2);
      v12 = *((_DWORD *)v8 + 3);
      v13 = (int *)(v8 + 16);
      v22[0] = v9;
      v22[1] = v10;
      v22[2] = v11;
      v22[3] = v12;
      v14 = *v13;
      v15 = v13[1];
      v16 = v13[2];
      v17 = v13[3];
      v13 += 4;
      v22[4] = v14;
      v22[5] = v15;
      v22[6] = v16;
      v22[7] = v17;
      v18 = v13[1];
      v19 = v13[2];
      v22[8] = *v13;
      v22[9] = v18;
      v23 = v19;
      sub_385C8(7, (const char *)v22, 0);
      return 1;
    }
  }
  v7 = v5 - (int)(*(double *)(v6 + 472) * 5.0 + 1.0);
  sub_2A7A4(&v21);
  if ( v7 < 5 )
    v7 = 5;
  if ( v21.tv_sec - *(_DWORD *)(a1 + 1752) >= v7 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy((char *)v22, "Work stale due to expiry");
      sub_385C8(7, (const char *)v22, 0);
      return 1;
    }
    return 1;
  }
  if ( byte_7844D && !a2 && v6 != sub_1D9A0() && !*(_BYTE *)(a1 + 1770) && dword_73D34 != 3 && dword_73D34 != 4 )
  {
    if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
      return 1;
    v8 = "Work stale due to fail only pool mismatch";
    goto LABEL_42;
  }
  return 0;
}
// 72C30: using guessed type int dword_72C30;
// 72C34: using guessed type int dword_72C34;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73D34: using guessed type int dword_73D34;
// 73E34: using guessed type int dword_73E34;
// 740CC: using guessed type int dword_740CC;
// 74149: using guessed type char byte_74149;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 7844D: using guessed type char byte_7844D;

//----- (00022ED0) --------------------------------------------------------
void sub_22ED0()
{
  _DWORD *v0; // r4
  int v1; // r6
  _DWORD *v2; // r5
  int v3; // r1
  int v4; // r2
  _DWORD *v5; // r0
  int v6; // r3
  int v7; // r12
  bool v8; // zf
  int v9; // r3
  _DWORD *v10; // r3
  int v11; // r1
  int v12; // r3
  _DWORD *v13; // r12
  int v14; // r3
  int v15; // r3
  char v16[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
    sub_B35C("discard_stale", 5214);
  v0 = (_DWORD *)dword_73E74;
  if ( dword_73E74 )
  {
    v2 = *(_DWORD **)(dword_73E74 + 1840);
    v1 = 0;
    while ( 1 )
    {
      if ( sub_22A8C((int)v0, 0) )
      {
        v3 = v0[459];
        if ( v3 || v0[460] )
        {
          v4 = dword_73E74;
          v5 = v0 + 458;
          v6 = *(_DWORD *)(dword_73E74 + 1832);
          v7 = *(_DWORD *)(v6 + 20);
          if ( (_DWORD *)(*(_DWORD *)(v6 + 16) - v7) == v0 )
          {
            *(_DWORD *)(v6 + 16) = v3 + v7;
            v3 = v0[459];
          }
          v8 = v3 == 0;
          if ( v3 )
            v7 = *(_DWORD *)(v4 + 1832);
          v9 = v0[460];
          if ( v3 )
          {
            v3 += *(_DWORD *)(v7 + 20);
          }
          else
          {
            v4 = v0[460];
            dword_73E74 = v4;
          }
          if ( !v8 )
          {
            *(_DWORD *)(v3 + 8) = v9;
            v9 = v0[460];
          }
          if ( v9 )
            *(_DWORD *)(v9 + *(_DWORD *)(*(_DWORD *)(v4 + 1832) + 20) + 4) = v0[459];
          v10 = *(_DWORD **)(v4 + 1832);
          v11 = 3 * ((v10[1] - 1) & v0[465]);
          --*(_DWORD *)(*v10 + 4 * v11 + 4);
          v12 = **(_DWORD **)(v4 + 1832);
          v13 = *(_DWORD **)(v12 + 4 * v11);
          if ( v13 == v5 )
          {
            v4 = v0[462];
            *(_DWORD *)(v12 + 4 * v11) = v4;
          }
          v14 = v0[461];
          if ( v13 == v5 )
            v4 = dword_73E74;
          if ( v14 )
            *(_DWORD *)(v14 + 16) = v0[462];
          v15 = v0[462];
          if ( v15 )
            *(_DWORD *)(v15 + 12) = v0[461];
          --*(_DWORD *)(*(_DWORD *)(v4 + 1832) + 12);
        }
        else
        {
          free(**(void ***)(dword_73E74 + 1832));
          free(*(void **)(dword_73E74 + 1832));
          dword_73E74 = 0;
        }
        ++v1;
        sub_158EC((int)v0);
      }
      if ( !v2 )
        break;
      v0 = v2;
      v2 = (_DWORD *)v2[460];
    }
  }
  else
  {
    v1 = 0;
  }
  pthread_cond_signal(&stru_77FC8);
  if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
    sub_B50C("discard_stale", 5225);
  off_72D18();
  if ( v1 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v16, 0x1000u, "Discarded %d stales that didn't match current hash", v1);
    sub_385C8(7, v16, 0);
  }
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73E6C: using guessed type int dword_73E6C;
// 73E74: using guessed type int dword_73E74;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00023138) --------------------------------------------------------
void *__fastcall sub_23138(void *a1)
{
  int v1; // r4
  pthread_t v2; // r0
  int v3; // r6
  int v4; // r4
  int v5; // r3
  pthread_rwlock_t *v6; // r5

  v1 = sub_1D9A0();
  v2 = pthread_self();
  pthread_detach(v2);
  sub_1859C(v1, (_BYTE *)(v1 + 130));
  sub_22ED0();
  if ( pthread_rwlock_rdlock(&rwlock) )
    sub_B5E4("restart_thread", 5270);
  v3 = dword_78994;
  if ( pthread_rwlock_unlock(&rwlock) )
    sub_B578("restart_thread", 5272);
  off_72D18();
  if ( v3 > 0 )
  {
    v4 = 0;
    do
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(dword_78408 + 4 * v4++);
        v6 = *(pthread_rwlock_t **)(v5 + 36);
        if ( v6 )
        {
          if ( !v6[1].__lock )
            break;
        }
        if ( v4 == v3 )
          goto LABEL_9;
      }
      *(_BYTE *)(v5 + 62) = 1;
      sub_1A95C(v6);
      (*(void (__fastcall **)(pthread_rwlock_t *))(v6->__nr_readers + 76))(v6);
    }
    while ( v4 != v3 );
  }
LABEL_9:
  if ( pthread_mutex_lock(&stru_78454) )
    sub_B35C("restart_thread", 5284);
  pthread_cond_broadcast(&cond);
  if ( pthread_mutex_unlock(&stru_78454) )
    sub_B50C("restart_thread", 5286);
  off_72D18();
  return 0;
}
// 72D18: using guessed type int (*off_72D18)();
// 78408: using guessed type int dword_78408;
// 78994: using guessed type int dword_78994;

//----- (0002328C) --------------------------------------------------------
void __noreturn sub_2328C()
{
  double v0; // d0
  int v1; // r4
  int v2; // r0
  int v3; // r5
  int v4; // r3
  int v5; // r6
  __time_t tv_sec; // r2
  int v7; // r3
  int v8; // r0
  int v9; // r5
  int v10; // r7
  int v11; // r3
  int v12; // r1
  int v13; // r1
  int v14; // r3
  int v15; // r4
  int *v16; // r3
  int v17; // r1
  int v18; // t1
  int v19; // r2
  int v20; // r4
  int v21; // r5
  bool v22; // cc
  int v23; // r1
  int v24; // r1
  int v25; // r3
  int v26; // r2
  bool v27; // zf
  int v28; // r0
  int v29; // r5
  int v30; // r6
  int v31; // r8
  int v32; // r0
  int v33; // r6
  char *v34; // r0
  const char *v35; // r1
  int v36; // r8
  int v37; // r10
  int v38; // r1
  double v39; // d8
  WINDOW *v40; // r0
  __int64 v41; // d11
  const char *v42; // r3
  size_t v43; // r0
  int v44; // r3
  const char *v45; // r3
  int v46; // r3
  double v47; // r0
  double v48; // d11
  unsigned __int64 v49; // r0
  unsigned __int64 v50; // r0
  double v51; // r0
  int v52; // r5
  int v53; // r2
  int v54; // r2
  int v55; // r0
  int v56; // r1
  double v57; // r0
  double v58; // d12
  int v59; // r6
  double v60; // d11
  double v61; // r0
  double v62; // d8
  int v63; // r0
  const char *v64; // r3
  double v65; // r0
  double v66; // r0
  unsigned __int64 v67; // r0
  unsigned __int64 v68; // r0
  double v69; // r0
  double v70; // r0
  double v71; // r0
  double v72; // r0
  double v73; // [sp+0h] [bp-119Ch]
  double v74; // [sp+8h] [bp-1194h]
  int v75; // [sp+10h] [bp-118Ch]
  int v76; // [sp+48h] [bp-1154h]
  struct timeval v77; // [sp+64h] [bp-1138h] BYREF
  char dest[12]; // [sp+6Ch] [bp-1130h] BYREF
  char v79[16]; // [sp+78h] [bp-1124h] BYREF
  struct timeval v80[2]; // [sp+88h] [bp-1114h] BYREF
  char s[256]; // [sp+98h] [bp-1104h] BYREF
  _DWORD v82[1018]; // [sp+198h] [bp-1004h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2EF24("Watchdog");
  sub_1202C();
  sub_2A7A4(&stru_7414C);
LABEL_2:
  while ( 1 )
  {
    sleep(2u);
    sub_22ED0();
    sub_1B514(-1, 0);
    if ( sub_196AC() )
      break;
LABEL_3:
    sub_2A7A4(v80);
    if ( byte_77FBC )
      goto LABEL_181;
    if ( !sub_1180C() )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(
          (char *)v82,
          0x1000u,
          "Pausing execution as per stop time %02d:%02d scheduled",
          dword_78424,
          dword_78420);
        sub_385C8(4, (const char *)v82, 0);
      }
      v15 = (unsigned __int8)byte_7869C;
      if ( !byte_7869C )
      {
        strcpy((char *)v82, "Terminating execution as planned");
        sub_385C8(3, (const char *)v82, 1);
        sub_16BE0(v15);
      }
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf((char *)v82, 0x1000u, "Will restart execution as scheduled at %02d:%02d", dword_786A8, dword_786A4);
        sub_385C8(4, (const char *)v82, 0);
      }
      byte_77FBC = 1;
      if ( pthread_rwlock_rdlock(&rwlock) )
        sub_B5E4("watchdog_thread", 9708);
      if ( dword_78994 > 0 )
      {
        v16 = (int *)dword_78408;
        v17 = dword_78408 + 4 * dword_78994;
        do
        {
          v18 = *v16++;
          *(_BYTE *)(v18 + 60) = 1;
        }
        while ( v16 != (int *)v17 );
      }
      if ( pthread_rwlock_unlock(&rwlock) )
        sub_B578("watchdog_thread", 9711);
      off_72D18();
      goto LABEL_22;
    }
    if ( byte_77FBC )
    {
LABEL_181:
      if ( sub_1180C() )
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(
            (char *)v82,
            0x1000u,
            "Restarting execution as per start time %02d:%02d scheduled",
            dword_786A8,
            dword_786A4);
          sub_385C8(4, (const char *)v82, 0);
        }
        if ( byte_78418 && (byte_77B70 || byte_75C48 || dword_73504 > 3) )
        {
          snprintf((char *)v82, 0x1000u, "Will pause execution as scheduled at %02d:%02d", dword_78424, dword_78420);
          sub_385C8(4, (const char *)v82, 0);
        }
        v1 = 0;
        byte_77FBC = 0;
        while ( dword_78994 > v1 )
        {
          v2 = v1++;
          v3 = sub_1AA90(v2);
          if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 32) != 1 )
          {
            v4 = (unsigned __int8)byte_75C49;
            *(_BYTE *)(v3 + 60) = 0;
            if ( v4 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
            {
              snprintf((char *)v82, 0x1000u, "Pushing sem post to thread %d", *(_DWORD *)v3);
              sub_385C8(7, (const char *)v82, 0);
            }
            sub_2F02C((sem_t *)(v3 + 16), "cgminer.c", "watchdog_thread", 9733);
          }
        }
      }
    }
LABEL_22:
    if ( dword_78548 > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        v8 = sub_1B1A8(v5);
        v9 = v8;
        v10 = **(_DWORD **)(v8 + 152);
        if ( !v10 )
          goto LABEL_35;
        (*(void (**)(void))(*(_DWORD *)(v8 + 4) + 32))();
        snprintf(s, 8u, "%s %d", *(const char **)(*(_DWORD *)(v9 + 4) + 8), *(_DWORD *)(v9 + 8));
        if ( *(_BYTE *)(v10 + 61) || *(_DWORD *)(v9 + 32) == 1 )
          goto LABEL_35;
        v11 = *(_DWORD *)(v9 + 96);
        v12 = *(_DWORD *)(v10 + 44);
        if ( v11 )
          break;
        tv_sec = v80[0].tv_sec;
        if ( v80[0].tv_sec - v12 <= 120 )
          goto LABEL_48;
        *(_QWORD *)(v9 + 48) = 0;
        v7 = (unsigned __int8)byte_77B70;
        *(_DWORD *)(v9 + 96) = 1;
        if ( v7 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf((char *)v82, 0x1000u, "%s: Idle for more than 60 seconds, declaring SICK!", s);
          sub_385C8(3, (const char *)v82, 0);
        }
        sub_2A7A4((struct timeval *)(v10 + 52));
        sub_2EBF8((_DWORD *)v9, 3);
        if ( !byte_72C4C )
          goto LABEL_35;
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf((char *)v82, 0x1000u, "%s: Attempting to restart", s);
          sub_385C8(3, (const char *)v82, 0);
        }
LABEL_34:
        sub_16BC0(v9);
LABEL_35:
        if ( dword_78548 <= ++v5 )
          goto LABEL_2;
      }
      tv_sec = v80[0].tv_sec;
      v13 = v80[0].tv_sec - v12;
      if ( v13 <= 119 )
      {
        if ( v11 != 4 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf((char *)v82, 0x1000u, "%s: Recovered, declaring WELL!", s);
          sub_385C8(3, (const char *)v82, 0);
        }
        *(_DWORD *)(v9 + 96) = 0;
        *(_DWORD *)(v9 + 240) = time(0);
        goto LABEL_35;
      }
      if ( v11 == 1 && v13 > 600 )
      {
        v14 = (unsigned __int8)byte_77B70;
        *(_DWORD *)(v9 + 96) = 2;
        if ( v14 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf((char *)v82, 0x1000u, "%s: Not responded for more than 10 minutes, declaring DEAD!", s);
          sub_385C8(3, (const char *)v82, 0);
        }
        sub_2A7A4((struct timeval *)(v10 + 52));
        sub_2EBF8((_DWORD *)v9, 4);
        goto LABEL_35;
      }
LABEL_48:
      if ( tv_sec - *(_DWORD *)(v10 + 52) <= 60 )
        goto LABEL_35;
      if ( (unsigned int)(v11 - 1) > 1 )
        goto LABEL_35;
      sub_2A7A4((struct timeval *)(v10 + 52));
      if ( !byte_72C4C )
        goto LABEL_35;
      goto LABEL_34;
    }
  }
  if ( dword_78AB8 )
  {
    v19 = *(__int16 *)(dword_78AB8 + 4);
    v20 = v19 + 1;
    v21 = *(__int16 *)(dword_78AB8 + 6) + 1;
    v22 = v21 <= 79;
    if ( v21 > 79 )
      v22 = v20 <= 24;
    if ( !v22 )
    {
      if ( v20 > dword_73E88 + 2 )
      {
        v23 = dword_73E84;
        if ( dword_73E88 < dword_73E84 )
        {
          if ( v19 <= dword_73E84 )
            v23 = v19 - 1;
          dword_73E88 = v23;
          dword_73E8C = v23 + 1;
          mvwin((WINDOW *)dword_78258, v23 + 1, 0);
          wresize((WINDOW *)dword_785E8, dword_73E88, v21);
        }
      }
      v24 = v20 - dword_73E8C;
      if ( dword_78258 )
        v25 = *(__int16 *)(dword_78258 + 4);
      else
        v25 = -1;
      if ( dword_78258 )
        v26 = *(__int16 *)(dword_78258 + 6);
      else
        v26 = v25;
      if ( dword_78258 )
      {
        ++v25;
        ++v26;
      }
      v27 = v21 == v26;
      if ( v21 == v26 )
        v27 = v24 == v25;
      if ( !v27 )
        wresize((WINDOW *)dword_78258, v24, v21);
    }
  }
  v28 = sub_1D9A0();
  if ( byte_74154 )
    v29 = 100;
  else
    v29 = 80;
  v76 = v28;
  wattr_on((WINDOW *)dword_785E8, 0x200000u, 0);
  snprintf((char *)v82, 0x100u, " cgminer version 4.9.0 - Started: %s", byte_74098);
  mvwprintw((WINDOW *)dword_785E8, 0, 0, "%s", (const char *)v82);
  wattr_off((WINDOW *)dword_785E8, 0x200000u, 0);
  if ( wmove((WINDOW *)dword_785E8, 1, 0) != -1 )
    whline((WINDOW *)dword_785E8, 0x2Du, v29);
  snprintf((char *)v82, 0x100u, " %s", byte_73F98);
  mvwprintw((WINDOW *)dword_785E8, 2, 0, "%s", (const char *)v82);
  wclrtoeol((WINDOW *)dword_785E8);
  v30 = (unsigned __int8)byte_74154;
  if ( byte_74154 )
  {
    v58 = dbl_78410;
    v59 = dword_786CC;
    v60 = dbl_78498;
    LODWORD(v61) = sub_59F1C(*(__int64 *)&dword_77F28);
    v62 = v61 / dbl_72438;
    v63 = sub_191B0();
    snprintf(
      (char *)v82,
      0x100u,
      " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m | ST: %d  SS: %lld  NB: %d  LW: %d  GF: %d  RF: %d",
      v58,
      v60,
      v59,
      v62 * 60.0,
      v63,
      *(_QWORD *)&dword_78AA8,
      dword_78944,
      dword_782F4,
      dword_78264,
      dword_77C90);
    mvwprintw((WINDOW *)dword_785E8, 3, 0, "%s", (const char *)v82);
  }
  else
  {
    v31 = (unsigned __int8)byte_73F8C;
    if ( byte_73F8C )
    {
      v32 = sub_191B0();
      snprintf(
        (char *)v82,
        0x100u,
        " ST: %d  SS: %lld  NB: %d  LW: %d  GF: %d  RF: %d",
        v32,
        *(_QWORD *)&dword_78AA8,
        dword_78944,
        dword_782F4,
        dword_78264,
        dword_77C90);
      mvwprintw((WINDOW *)dword_785E8, 3, v30, "%s", (const char *)v82);
    }
    else
    {
      v73 = dbl_78410;
      v75 = dword_786CC;
      v74 = dbl_78498;
      LODWORD(v57) = sub_59F1C(*(__int64 *)&dword_77F28);
      snprintf((char *)v82, 0x100u, " A:%.0f  R:%.0f  HW:%d  WU:%.1f/m", v73, v74, v75, v57 / dbl_72438 * 60.0);
      mvwprintw((WINDOW *)dword_785E8, 3, v31, "%s", (const char *)v82);
    }
  }
  wclrtoeol((WINDOW *)dword_785E8);
  if ( (unsigned int)(dword_73D34 - 3) > 1 || dword_77FC0 <= 1 )
  {
    v33 = *(unsigned __int8 *)(v76 + 664);
    if ( !*(_BYTE *)(v76 + 664) )
    {
      v34 = (char *)(unsigned __int8)byte_78AA1;
      if ( !byte_78AA1 )
        v34 = "out";
      v35 = "LP";
      if ( byte_78AA1 )
        v34 = "";
      if ( *(_BYTE *)(v76 + 760) )
        v35 = "GBT";
      snprintf(
        (char *)v82,
        0x100u,
        " Connected to %s diff %s with%s %s as user %s",
        *(const char **)(v76 + 624),
        (const char *)(v76 + 48),
        v34,
        v35,
        *(const char **)(v76 + 204));
      mvwprintw((WINDOW *)dword_785E8, 4, v33, "%s", (const char *)v82);
      goto LABEL_113;
    }
    snprintf(
      (char *)v82,
      0x100u,
      " Connected to %s diff %s with stratum as user %s",
      *(const char **)(v76 + 624),
      (const char *)(v76 + 48),
      *(const char **)(v76 + 204));
  }
  else
  {
    v64 = "out";
    if ( byte_78AA1 )
      v64 = "";
    snprintf((char *)v82, 0x100u, " Connected to multiple pools with%s block change notify", v64);
  }
  mvwprintw((WINDOW *)dword_785E8, 4, 0, "%s", (const char *)v82);
LABEL_113:
  wclrtoeol((WINDOW *)dword_785E8);
  snprintf(
    (char *)v82,
    0x100u,
    " Block: %s...  Diff:%s  Started: %s  Best share: %s   ",
    byte_7413C,
    byte_740F4,
    byte_7411C,
    (const char *)&dword_72C04);
  mvwprintw((WINDOW *)dword_785E8, 5, 0, "%s", (const char *)v82);
  if ( wmove((WINDOW *)dword_785E8, 6, 0) != -1 )
    whline((WINDOW *)dword_785E8, 0x2Du, v29);
  if ( wmove((WINDOW *)dword_785E8, dword_73E88 - 1, 0) != -1 )
    whline((WINDOW *)dword_785E8, 0x2Du, v29);
  strcpy((char *)v82, "[P]ool management [S]ettings [D]isplay options [Q]uit");
  mvwprintw((WINDOW *)dword_785E8, dword_73E90 - 1, 1, "%s", (const char *)v82);
  if ( dword_78548 <= 0 )
  {
LABEL_146:
    if ( dword_785E8 )
      v53 = *(__int16 *)(dword_785E8 + 4) + 1;
    else
      v53 = -1;
    wtouchln((WINDOW *)dword_785E8, 0, v53, 1);
    wrefresh((WINDOW *)dword_785E8);
    if ( dword_78258 )
      v54 = *(__int16 *)(dword_78258 + 4);
    else
      v54 = -1;
    if ( dword_78258 )
      ++v54;
    wtouchln((WINDOW *)dword_78258, 0, v54, 1);
    wrefresh((WINDOW *)dword_78258);
    if ( pthread_mutex_unlock(&stru_785D0) )
      sub_B50C("unlock_curses", 2930);
    off_72D18();
    goto LABEL_3;
  }
  v36 = 0;
  v37 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v52 = sub_1B1A8(v37);
      if ( !v52 )
        goto LABEL_142;
      if ( !byte_78768 )
      {
        v38 = v36 + dword_73E90;
        if ( LINES - 1 > v36 + dword_73E90 && dword_73E94 > v36 )
          break;
      }
      ++v37;
      ++v36;
      if ( dword_78548 <= v37 )
        goto LABEL_146;
    }
    if ( *(_DWORD *)(v52 + 368) )
    {
      sub_2A7A4(&v77);
      sub_2A97C();
      v38 = v36 + dword_73E90;
      v39 = v0;
    }
    else
    {
      v39 = dbl_72438;
    }
    v40 = (WINDOW *)dword_785E8;
    v41 = *(_QWORD *)(v52 + 192);
    if ( v39 < 1.0 )
      v39 = 1.0;
    *(double *)(v52 + 88) = (double)*(int *)(v52 + 36) / v39 * 60.0;
    wmove(v40, v38, 0);
    sub_11480(COERCE_DOUBLE(__PAIR64__(&dword_72C38, v37)));
    v42 = *(const char **)(v52 + 28);
    if ( v42 )
    {
      strcpy(dest, "        ");
      strncpy(dest, v42, 8u);
    }
    else
    {
      sprintf(dest, "%-8d", *(_DWORD *)(v52 + 8));
    }
    snprintf((char *)v82, 0x100u, " %*d: %s %-8s: ", dword_72C38, v37, *(const char **)(*(_DWORD *)(v52 + 4) + 8), dest);
    wprintw((WINDOW *)dword_785E8, "%s", (const char *)v82);
    s[0] = 0;
    (*(void (__fastcall **)(char *, int, int))(*(_DWORD *)(v52 + 4) + 20))(s, 256, v52);
    v43 = strlen(s);
    if ( v43 <= 0x16 )
      strncat(s, "                                        ", 23 - v43);
    snprintf((char *)v82, 0x100u, "%s | ", s);
    wprintw((WINDOW *)dword_785E8, "%s", (const char *)v82);
    v44 = *(_DWORD *)(v52 + 96);
    if ( v44 == 2 )
    {
      v45 = "DEAD  ";
    }
    else if ( v44 == 1 )
    {
      v45 = "SICK  ";
    }
    else
    {
      v46 = *(_DWORD *)(v52 + 32);
      if ( v46 == 1 )
      {
        v45 = "OFF   ";
      }
      else
      {
        if ( v46 != 2 )
        {
          LODWORD(v47) = sub_59F1C(v41);
          v48 = v47 / v39 * 60.0;
          if ( byte_74154 )
          {
            LODWORD(v67) = sub_5A000(*(double *)(v52 + 80) / v39 * 1000000.0);
            sub_114B8(v67, v79, 0x10u, 4);
            LODWORD(v68) = sub_5A000(*(double *)(v52 + 48) * 1000000.0);
            sub_114B8(v68, (char *)v80, 0x10u, 4);
            HIDWORD(v69) = &dword_72C3C;
            LODWORD(v69) = (int)v48;
            v70 = sub_11480(v69);
            LODWORD(v70) = &dword_72C40;
            v71 = sub_1144C(v70);
            LODWORD(v71) = &dword_72C44;
            *(float *)&v0 = *(double *)(v52 + 208);
            sub_1144C(v71);
            LODWORD(v72) = *(_DWORD *)(v52 + 44);
            HIDWORD(v72) = &dword_72C48;
            sub_11480(v72);
            snprintf(
              (char *)v82,
              0x100u,
              "%6s / %6sh/s WU:%*.1f/m A:%*.0f R:%*.0f HW:%*d",
              (const char *)v80,
              v79,
              dword_72C3C + 2,
              v48,
              dword_72C40,
              *(double *)(v52 + 200),
              dword_72C44,
              *(double *)(v52 + 208),
              dword_72C48,
              *(_DWORD *)(v52 + 44));
            wprintw((WINDOW *)dword_785E8, "%s", (const char *)v82);
          }
          else
          {
            if ( byte_73F8C )
            {
              LODWORD(v47) = &dword_72C40;
              v65 = sub_1144C(v47);
              LODWORD(v65) = &dword_72C44;
              *(float *)&v0 = *(double *)(v52 + 208);
              sub_1144C(v65);
              LODWORD(v66) = *(_DWORD *)(v52 + 44);
              HIDWORD(v66) = &dword_72C48;
              sub_11480(v66);
              snprintf(
                (char *)v82,
                0x100u,
                "A:%*.0f R:%*.0f HW:%*d",
                dword_72C40,
                *(double *)(v52 + 200),
                dword_72C44,
                *(double *)(v52 + 208),
                dword_72C48,
                *(_DWORD *)(v52 + 44));
            }
            else
            {
              LODWORD(v49) = sub_5A000(*(double *)(v52 + 80) / v39 * 1000000.0);
              sub_114B8(v49, v79, 0x10u, 4);
              LODWORD(v50) = sub_5A000(*(double *)(v52 + 48) * 1000000.0);
              sub_114B8(v50, (char *)v80, 0x10u, 4);
              HIDWORD(v51) = &dword_72C3C;
              LODWORD(v51) = (int)v48;
              sub_11480(v51);
              snprintf((char *)v82, 0x100u, "%6s / %6sh/s WU:%*.1f/m", (const char *)v80, v79, dword_72C3C + 2, v48);
            }
            wprintw((WINDOW *)dword_785E8, "%s", (const char *)v82);
          }
          goto LABEL_141;
        }
        v45 = "REST  ";
      }
    }
    v55 = *(_DWORD *)v45;
    v56 = *((_DWORD *)v45 + 1);
    LOWORD(v82[1]) = v56;
    v82[0] = v55;
    BYTE2(v82[1]) = BYTE2(v56);
    wprintw((WINDOW *)dword_785E8, "%s", (const char *)v82);
LABEL_141:
    s[0] = 0;
    ++v36;
    (*(void (__fastcall **)(char *, int, int))(*(_DWORD *)(v52 + 4) + 24))(s, 256, v52);
    snprintf((char *)v82, 0x100u, "%s", s);
    wprintw((WINDOW *)dword_785E8, "%s", (const char *)v82);
    wclrtoeol((WINDOW *)dword_785E8);
LABEL_142:
    if ( dword_78548 <= ++v37 )
      goto LABEL_146;
  }
}
// 24008: variable 'v47' is possibly undefined
// 2404C: variable 'v49' is possibly undefined
// 24070: variable 'v50' is possibly undefined
// 2427C: variable 'v57' is possibly undefined
// 242DC: variable 'v61' is possibly undefined
// 243D8: variable 'v0' is possibly undefined
// 244E8: variable 'v67' is possibly undefined
// 2450C: variable 'v68' is possibly undefined
// 72438: using guessed type double dbl_72438;
// 72C04: using guessed type int dword_72C04;
// 72C38: using guessed type int dword_72C38;
// 72C3C: using guessed type int dword_72C3C;
// 72C40: using guessed type int dword_72C40;
// 72C44: using guessed type int dword_72C44;
// 72C48: using guessed type int dword_72C48;
// 72C4C: using guessed type char byte_72C4C;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 739FC: using guessed type int LINES;
// 73D34: using guessed type int dword_73D34;
// 73E84: using guessed type int dword_73E84;
// 73E88: using guessed type int dword_73E88;
// 73E8C: using guessed type int dword_73E8C;
// 73E90: using guessed type int dword_73E90;
// 73E94: using guessed type int dword_73E94;
// 73F8C: using guessed type char byte_73F8C;
// 7414C: using guessed type struct timeval stru_7414C;
// 74154: using guessed type char byte_74154;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77C90: using guessed type int dword_77C90;
// 77F28: using guessed type int dword_77F28;
// 77FBC: using guessed type char byte_77FBC;
// 77FC0: using guessed type int dword_77FC0;
// 78258: using guessed type int dword_78258;
// 78264: using guessed type int dword_78264;
// 782F4: using guessed type int dword_782F4;
// 78408: using guessed type int dword_78408;
// 78410: using guessed type double dbl_78410;
// 78418: using guessed type char byte_78418;
// 78420: using guessed type int dword_78420;
// 78424: using guessed type int dword_78424;
// 78498: using guessed type double dbl_78498;
// 78548: using guessed type int dword_78548;
// 785E8: using guessed type int dword_785E8;
// 7869C: using guessed type char byte_7869C;
// 786A4: using guessed type int dword_786A4;
// 786A8: using guessed type int dword_786A8;
// 786CC: using guessed type int dword_786CC;
// 78768: using guessed type char byte_78768;
// 78944: using guessed type int dword_78944;
// 78994: using guessed type int dword_78994;
// 78AA1: using guessed type char byte_78AA1;
// 78AA8: using guessed type int dword_78AA8;
// 78AB8: using guessed type int dword_78AB8;

//----- (00024660) --------------------------------------------------------
int __fastcall sub_24660(int a1)
{
  int v2; // r4
  int v4; // r0

  v2 = *(_DWORD *)(a1 + 356);
  if ( v2 )
  {
    if ( sub_22A8C(*(_DWORD *)(a1 + 356), 0) )
    {
      v4 = v2;
      v2 = 0;
      sub_158EC(v4);
      sub_1852C();
    }
    else
    {
      sub_1655C(a1, v2);
    }
    *(_DWORD *)(a1 + 356) = 0;
  }
  return v2;
}

//----- (000246B8) --------------------------------------------------------
int __fastcall sub_246B8(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r4
  int v3; // r5

  v1 = a1 + 10;
  if ( pthread_rwlock_wrlock(a1 + 10) )
    sub_B3C8("get_queued", 8803);
  v3 = sub_24660((int)a1);
  if ( pthread_rwlock_unlock(v1) )
    sub_B578("get_queued", 8805);
  off_72D18();
  return v3;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0002472C) --------------------------------------------------------
int __fastcall sub_2472C(int a1, int a2)
{
  _DWORD *v4; // r5
  time_t v5; // r8
  int v6; // r4
  time_t v7; // r0
  int v8; // r3
  int v9; // r8
  double v10; // d16
  double *v11; // r3
  int result; // r0
  int v13; // r2
  int v14; // r3
  int v15; // r3
  char v16[4100]; // [sp+0h] [bp-1004h] BYREF

  v4 = *(_DWORD **)(a1 + 36);
  sub_FB90(a1);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v16, "Popping work from get queue to get work");
    sub_385C8(7, v16, 0);
  }
  v5 = time(0);
  do
  {
    while ( 1 )
    {
      v6 = sub_18D24(1);
      if ( !sub_22A8C(v6, 0) )
        break;
      sub_158EC(v6);
      sub_1852C();
    }
  }
  while ( !v6 );
  v7 = time(0);
  v8 = (unsigned __int8)byte_75C49;
  v9 = v7 - v5;
  if ( v9 > 0 )
  {
    if ( byte_75C49 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
      {
        snprintf(v16, 0x1000u, "Get work blocked for %d seconds", v9);
        sub_385C8(7, v16, 0);
        v8 = (unsigned __int8)byte_75C49;
      }
      else
      {
        v8 = 1;
      }
    }
    v4[58] += v9;
  }
  if ( v8 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v16, 0x1000u, "Got work from get queue to get work for thread %d", a2);
    sub_385C8(7, v16, 0);
  }
  *(_DWORD *)(v6 + 1744) = a2;
  if ( byte_74149 )
  {
    v14 = v4[95] + v4[96];
    v4[95] = v14;
    if ( v14 > 0 )
    {
      if ( v14 > 15 )
      {
        v15 = v4[94] + 1;
        v4[96] = -1;
        if ( v15 > 15 )
          v15 = 0;
        v4[94] = v15;
        memcpy((void *)v6, (char *)&unk_74158 + 160 * v15, 0xA0u);
        goto LABEL_17;
      }
    }
    else
    {
      v4[96] = 1;
    }
    memcpy((void *)v6, (char *)&unk_74B58 + 160 * v14, 0xA0u);
  }
LABEL_17:
  sub_FB5C(a1);
  *(_BYTE *)(v6 + 1760) = 1;
  v10 = *(double *)(v4[1] + 104);
  v11 = (double *)(v6 + 1712);
  result = v6;
  if ( v10 > *(double *)(v6 + 1864) )
    v10 = *(double *)(v6 + 1864);
  *v11 = v10;
  v13 = v4[1];
  if ( v10 < *(double *)(v13 + 120) )
    v10 = *(double *)(v13 + 120);
  *v11 = v10;
  return result;
}
// 73504: using guessed type int dword_73504;
// 74149: using guessed type char byte_74149;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00024CE0) --------------------------------------------------------
int __fastcall sub_24CE0(int a1, pthread_rwlock_t *a2, int a3)
{
  int v4; // r4

  v4 = sub_2472C(a1, a3);
  sub_1A1D0(a2, v4);
  return v4;
}

//----- (00024D08) --------------------------------------------------------
void __fastcall sub_24D08(int a1)
{
  int v1; // r1
  int v2; // r11
  int v3; // r5
  int v4; // r12
  int v5; // r2
  int v6; // r9
  int v7; // r7
  int v8; // r3
  int v9; // r12
  int v10; // r0
  double v11; // d8
  double *v12; // r4
  double v13; // d9
  double *v14; // r5
  int v15; // r3
  _DWORD *v16; // r5
  __int64 v17; // kr00_8
  __suseconds_t tv_usec; // r4
  __time_t tv_sec; // r3
  int v20; // r2
  int v21; // r1
  bool v22; // nf
  int v23; // r4
  int v24; // r4
  int v25; // r3
  double v26; // r0
  double v27; // d16
  bool v28; // zf
  double v29; // d8
  int v30; // r1
  unsigned int v31; // r0
  int v32; // r1
  __time_t v33; // [sp+Ch] [bp-1090h]
  __time_t v34; // [sp+Ch] [bp-1090h]
  unsigned int v35; // [sp+10h] [bp-108Ch]
  int v36; // [sp+14h] [bp-1088h]
  int v37; // [sp+14h] [bp-1088h]
  int v38; // [sp+14h] [bp-1088h]
  int v39; // [sp+14h] [bp-1088h]
  __int64 v40; // [sp+28h] [bp-1074h]
  int v41; // [sp+34h] [bp-1068h]
  int v42; // [sp+48h] [bp-1054h]
  _DWORD *v43; // [sp+4Ch] [bp-1050h]
  _DWORD *v44; // [sp+50h] [bp-104Ch]
  struct timeval *v45; // [sp+54h] [bp-1048h]
  int *v47; // [sp+5Ch] [bp-1040h]
  int v48; // [sp+60h] [bp-103Ch]
  unsigned int v49; // [sp+64h] [bp-1038h]
  int v50; // [sp+68h] [bp-1034h]
  int remaining; // [sp+70h] [bp-102Ch]
  int v52; // [sp+74h] [bp-1028h]
  struct timeval v53; // [sp+78h] [bp-1024h] BYREF
  struct timeval v54; // [sp+80h] [bp-101Ch] BYREF
  struct timeval v55; // [sp+88h] [bp-1014h] BYREF
  struct timeval v56; // [sp+90h] [bp-100Ch] BYREF
  struct timespec s[509]; // [sp+98h] [bp-1004h] BYREF

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_DWORD *)(a1 + 36);
  v3 = *(_DWORD *)a1;
  v4 = 1717986919 * dword_72C0C;
  v50 = *(_DWORD *)a1;
  v42 = *(_DWORD *)(v2 + 4);
  v5 = dword_72C0C / 5;
  if ( !(dword_72C0C / 5) )
    v5 = 1;
  if ( v1 )
    v3 = a1;
  else
    v4 = 1;
  v48 = v5;
  if ( v1 )
    remaining = *(unsigned __int8 *)(v3 + 8);
  else
    remaining = v4;
  v49 = (*(int (**)(void))(*(_DWORD *)(v2 + 4) + 48))();
  sub_2A7A4(&v53);
  sub_2A7A4(&v56);
  if ( !*(_BYTE *)(v2 + 364) )
  {
    v40 = 0;
    v6 = *(unsigned __int8 *)(v2 + 364);
    v7 = v6;
    v8 = 1000000 * v48 + 1023;
    if ( 1000000 * v48 >= 0 )
      v8 = 1000000 * v48;
    v52 = v8 >> 10;
    while ( 1 )
    {
      v10 = sub_2472C(a1, v50);
      *(_BYTE *)(a1 + 62) = 0;
      *(_BYTE *)(v2 + 172) = 1;
      v41 = v10;
      sub_2A7A4(&v55);
      *(_DWORD *)(v41 + 1736) = 0;
      *(_QWORD *)(v2 + 160) = 0;
      if ( !(*(int (__fastcall **)(int, int))(v42 + 56))(a1, v41) )
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf((char *)s, 0x1000u, "work prepare failed, exiting mining thread %d", v50);
          sub_385C8(3, (const char *)s, 0);
        }
        goto LABEL_82;
      }
      v11 = *(double *)(v42 + 104);
      v12 = (double *)(v41 + 1864);
      v13 = *(double *)(v41 + 1864);
      v14 = (double *)(v41 + 1712);
      v15 = (unsigned __int8)byte_78681;
      if ( v11 > v13 )
        v11 = *(double *)(v41 + 1864);
      *v14 = v11;
      if ( v11 < *(double *)(v42 + 120) )
        v11 = *(double *)(v42 + 120);
      *v14 = v11;
      if ( !v15 )
      {
        v47 = (int *)(v2 + 296);
        v43 = (_DWORD *)(v2 + 304);
        v45 = (struct timeval *)(v41 + 1912);
        v44 = (_DWORD *)(v2 + 312);
        goto LABEL_30;
      }
      LODWORD(v26) = sub_59F1C(*(__int64 *)&dword_77F28);
      if ( v26 / dbl_72438 * 60.0 <= 30.0 )
        break;
      v27 = *(double *)(v42 + 112);
      if ( v27 >= *(double *)(v42 + 104) || v13 <= v27 )
        goto LABEL_75;
      v28 = byte_75C49 == 0;
      v29 = v27 + 1.0;
      *(double *)(v42 + 112) = v27 + 1.0;
      if ( !v28 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf((char *)s, 0x1000u, "Driver %s working diff changed to %.0f", *(const char **)(v42 + 4), v27 + 1.0);
        sub_385C8(7, (const char *)s, 0);
        v29 = *(double *)(v42 + 112);
      }
      if ( *v12 < v29 )
        v29 = *v12;
      *v14 = v29;
LABEL_73:
      sub_1617C(v41 + 1929);
      v45 = (struct timeval *)(v41 + 1912);
      v47 = (int *)(v2 + 296);
      v43 = (_DWORD *)(v2 + 304);
      v44 = (_DWORD *)(v2 + 312);
      while ( 1 )
      {
LABEL_30:
        sub_2A7A4(&v54);
        sub_2A3A0(&v54, &v53.tv_sec);
        sub_2A3D4(&v53, v47);
        if ( sub_2A420(&v53, v43) )
          sub_2A488(v43, &v53);
        if ( sub_2A454(&v53, v44) )
          sub_2A488(v44, &v53);
        ++*(_DWORD *)(v2 + 292);
        v16 = *(_DWORD **)(v41 + 1748);
        sub_2A3D4(&v53, v16 + 103);
        if ( sub_2A420(&v53, v16 + 105) )
          sub_2A488(v16 + 105, &v53);
        if ( sub_2A454(&v53, v16 + 107) )
          sub_2A488(v16 + 107, &v53);
        ++v16[102];
        sub_2A7A4(v45);
        pthread_setcancelstate(1, 0);
        sub_FB5C(a1);
        v17 = ((__int64 (__fastcall *)(int, int, unsigned int, _DWORD))*(_DWORD *)(v42 + 64))(
                a1,
                v41,
                v49 + *(_DWORD *)(v41 + 1736),
                0);
        sub_FB90(a1);
        pthread_setcancelstate(0, 0);
        pthread_testcancel();
        sub_2A7A4(&v53);
        if ( v17 == -1 )
          break;
        v40 += v17;
        tv_usec = v53.tv_usec;
        if ( *(_QWORD *)(v2 + 160) < v17 )
          *(_QWORD *)(v2 + 160) = v17;
        tv_sec = v53.tv_sec;
        v20 = tv_usec - v54.tv_usec + (tv_usec - v54.tv_usec < 0 ? 0xF4000 : 0);
        if ( tv_usec - v54.tv_usec < 0 )
          v20 += 576;
        v7 += v20;
        v21 = v53.tv_sec - v54.tv_sec;
        if ( tv_usec - v54.tv_usec < 0 )
          --v21;
        v6 += v21;
        if ( v7 > 1000000 )
        {
          ++v6;
          v7 -= 1000000;
        }
        v9 = v53.tv_sec - v55.tv_sec;
        if ( tv_usec - v55.tv_usec < 0 )
          --v9;
        if ( v48 > v6 )
        {
          if ( v49 == -1 )
            goto LABEL_20;
          v30 = v7 + 1024;
          v33 = v53.tv_sec;
          if ( v7 + 1024 < 0 )
            v30 = v7 + 2047;
          v38 = v9;
          v35 = (sub_59AC8(1000000, v30 >> 10) + 16) * v48;
          tv_sec = v33;
          v9 = v38;
          if ( v49 <= 0xFFFFFC00 / v35 )
            v49 = (v49 * v35) >> 10;
          else
            v49 = -1;
        }
        else if ( v48 < v6 )
        {
          v49 = v48 * v49 / v6;
        }
        else if ( v7 > 100000 )
        {
          v34 = v53.tv_sec;
          v39 = v9;
          v31 = sub_59AC8(1000000 * v48 + v7, v52);
          tv_sec = v34;
          v9 = v39;
          v49 = (v49 << 10) / v31;
        }
        v23 = tv_usec - v56.tv_usec;
        v22 = v23 < 0;
        v24 = v23 + (v23 < 0 ? 0xF4000 : 0);
        v25 = tv_sec - v56.tv_sec;
        if ( v22 )
        {
          --v25;
          v24 += 576;
        }
        if ( v40 && (v25 > 0 || v24 > (int)&loc_30D40) || dword_72C0C <= v25 )
        {
          v36 = v9;
          sub_1B514(v50, v40);
          sub_2A488(&v56, &v53);
          v9 = v36;
          v40 = 0;
        }
        if ( *(_BYTE *)(a1 + 62) )
        {
          if ( !remaining )
          {
            v32 = *(_DWORD *)(a1 + 4);
            s[0].tv_sec = 0;
            s[0].tv_nsec = 250000000 * v32;
            nanosleep(s, 0);
          }
          goto LABEL_22;
        }
        if ( *(_BYTE *)(a1 + 60) || (v6 = *(_DWORD *)(v2 + 32)) != 0 )
        {
          v6 = 0;
          v37 = v9;
          v7 = 0;
          sub_11BC4(a1, v50, v42);
          v9 = v37;
        }
        else
        {
          v7 = 0;
        }
LABEL_20:
        if ( v9 > dword_72C30 || *(_QWORD *)(v2 + 160) > 0xFFFFFFFD || sub_22A8C(v41, 0) )
          goto LABEL_22;
      }
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        snprintf((char *)s, 0x1000u, "%s %d failure, disabling!", *(const char **)(v42 + 8), *(_DWORD *)(v2 + 8));
        sub_385C8(3, (const char *)s, 0);
      }
      *(_DWORD *)(v2 + 32) = 1;
      sub_2EBF8((_DWORD *)v2, 1);
      *(_BYTE *)(v2 + 364) = 1;
LABEL_22:
      sub_156B8((void **)v41);
      if ( *(_BYTE *)(v2 + 364) )
        goto LABEL_82;
    }
    v27 = *(double *)(v42 + 112);
LABEL_75:
    if ( v13 < v27 )
      *(double *)(v42 + 112) = v13;
    goto LABEL_73;
  }
LABEL_82:
  *(_DWORD *)(v2 + 32) = 1;
}
// 2527C: variable 'v26' is possibly undefined
// 72438: using guessed type double dbl_72438;
// 72C0C: using guessed type int dword_72C0C;
// 72C30: using guessed type int dword_72C30;
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77F28: using guessed type int dword_77F28;
// 78681: using guessed type char byte_78681;

//----- (000255FC) --------------------------------------------------------
void __fastcall sub_255FC(int a1)
{
  _DWORD *v2; // r5
  int v3; // r6
  double v4; // d16
  double v5; // d16
  double v6; // d17
  double v7; // d16
  int v8; // r2
  double v9; // d18
  double v10; // d16
  double v11; // d17
  double v12; // d16
  pthread_t v13; // [sp+Ch] [bp-1008h] BYREF
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( !*(_DWORD *)(a1 + 76) )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      strcpy(s, "Get A Error Data To Push!DROP!\r\n");
      sub_385C8(4, s, 0);
    }
    return;
  }
  v2 = *(_DWORD **)(a1 + 1748);
  sub_2A7A4((struct timeval *)(a1 + 1920));
  if ( byte_74149 )
  {
    v3 = *(_DWORD *)(sub_1AA90(*(_DWORD *)(a1 + 1744)) + 36);
    if ( pthread_mutex_lock(&stru_77B74) )
      sub_B35C("submit_work_async", 8223);
    ++*(_DWORD *)(v3 + 36);
    ++*((_QWORD *)v2 + 1);
    v4 = *(double *)(v3 + 200) + *(double *)(a1 + 1864);
    ++qword_78248;
    *(double *)(v3 + 200) = v4;
    v5 = *(double *)(a1 + 1864);
    v6 = *((double *)v2 + 13) + v5;
    v7 = v5 + dbl_78410;
    *((double *)v2 + 13) = v6;
    dbl_78410 = v7;
    if ( pthread_mutex_unlock(&stru_77B74) )
      sub_B50C("submit_work_async", 8230);
    off_72D18();
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(
        s,
        0x1000u,
        "Accepted %s %d benchmark share nonce %08x",
        *(const char **)(*(_DWORD *)(v3 + 4) + 8),
        *(_DWORD *)(v3 + 8),
        *(_DWORD *)(a1 + 76));
      sub_385C8(7, s, 0);
    }
    return;
  }
  if ( !sub_22A8C(a1, 1) )
  {
    v8 = (unsigned __int8)byte_75C49;
    goto LABEL_17;
  }
  if ( byte_72C4D )
  {
    v8 = (unsigned __int8)byte_75C49;
    if ( !byte_75C49 )
      goto LABEL_37;
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
      goto LABEL_36;
    snprintf(s, 0x1000u, "Pool %d stale share detected, submitting as user requested", *v2);
    goto LABEL_48;
  }
  if ( *((_BYTE *)v2 + 136) )
  {
    v8 = (unsigned __int8)byte_75C49;
    if ( !byte_75C49 )
    {
LABEL_37:
      *(_BYTE *)(a1 + 1769) = 1;
LABEL_17:
      if ( *(_BYTE *)(a1 + 1772) )
      {
        if ( v8 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(s, 0x1000u, "Pushing pool %d work to stratum queue", *v2);
          sub_385C8(7, s, 0);
        }
        if ( !sub_2A198(v2[188], a1) )
        {
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            strcpy(s, "Discarding work from removed pool");
            sub_385C8(7, s, 0);
          }
          sub_156B8((void **)a1);
        }
      }
      else
      {
        if ( v8 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          strcpy(s, "Pushing submit work to work thread");
          sub_385C8(7, s, 0);
        }
        if ( pthread_create(&v13, 0, sub_FB48, (void *)a1) )
        {
          strcpy(s, "Failed to create submit_work_thread");
          sub_385C8(3, s, 1);
          sub_16BE0(1);
        }
      }
      return;
    }
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
    {
LABEL_36:
      v8 = 1;
      goto LABEL_37;
    }
    snprintf(s, 0x1000u, "Pool %d stale share detected, submitting as pool requested", *v2);
LABEL_48:
    sub_385C8(7, s, 0);
    v8 = (unsigned __int8)byte_75C49;
    goto LABEL_37;
  }
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "Pool %d stale share detected, discarding", *v2);
    sub_385C8(7, s, 0);
  }
  sub_1AF6C("discard", (_DWORD *)a1);
  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("submit_work_async", 8248);
  v9 = *((double *)v2 + 15);
  ++v2[38];
  v10 = *(double *)(a1 + 1864);
  v11 = v9 + v10;
  ++*(_QWORD *)&dword_78AA8;
  v12 = v10 + dbl_78250;
  *((double *)v2 + 15) = v11;
  dbl_78250 = v12;
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("submit_work_async", 8253);
  off_72D18();
  sub_156B8((void **)a1);
}
// 72C4D: using guessed type char byte_72C4D;
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 74149: using guessed type char byte_74149;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78248: using guessed type __int64 qword_78248;
// 78250: using guessed type double dbl_78250;
// 78410: using guessed type double dbl_78410;
// 78AA8: using guessed type int dword_78AA8;

//----- (00025D80) --------------------------------------------------------
int __fastcall sub_25D80(int a1, int a2, int a3)
{
  _DWORD *v3; // r0

  *(_DWORD *)(a2 + 76) = a3;
  v3 = sub_1A598(a2, 0);
  sub_255FC((int)v3);
  return 1;
}

//----- (00025DA0) --------------------------------------------------------
void __fastcall sub_25DA0(int a1)
{
  _DWORD *v1; // r0

  v1 = sub_1A598(a1, 0);
  sub_255FC((int)v1);
}

//----- (00025DB4) --------------------------------------------------------
int __fastcall sub_25DB4(int a1, int a2)
{
  int result; // r0
  _DWORD *v5; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  sub_19DB8(a1, a2);
  if ( sub_29EAC((unsigned int *)(a2 + 192), (unsigned int *)(a2 + 160)) )
  {
    v5 = sub_1A598(a2, 0);
    sub_255FC((int)v5);
    return 1;
  }
  else if ( byte_75C49 )
  {
    if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 6 )
    {
      snprintf(
        s,
        0x1000u,
        "%s %s %d: Share above target",
        "submit_tested_work",
        *(const char **)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4) + 8),
        *(_DWORD *)(*(_DWORD *)(a1 + 36) + 8));
      sub_385C8(7, s, 0);
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00025EA0) --------------------------------------------------------
int __fastcall sub_25EA0(int a1, char *a2, unsigned int a3)
{
  if ( sub_F720(a1, a3) && sub_16484((int)a2, a3) )
  {
    sub_25DB4(a1, (int)a2);
    if ( dword_73E34 && byte_75558 )
    {
      sub_1174C(a2, a3);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_19498(a1);
    return 0;
  }
}
// 73E34: using guessed type int dword_73E34;
// 75558: using guessed type char byte_75558;

//----- (00025F34) --------------------------------------------------------
char *__fastcall sub_25F34(const char *a1)
{
  char *v2; // r4
  char v4[4100]; // [sp+0h] [bp-1004h] BYREF

  echo();
  v2 = (char *)malloc(0xFFu);
  if ( !v2 )
  {
    strcpy(v4, "Failed to malloc input");
    sub_385C8(3, v4, 1);
    sub_16BE0(1);
  }
  leaveok((WINDOW *)dword_78258, 0);
  snprintf(v4, 0x1000u, "%s:\n", a1);
  sub_19A98(v4);
  wgetnstr((WINDOW *)dword_78258, v2, 255);
  if ( !*v2 )
    strcpy(v2, "-1");
  leaveok((WINDOW *)dword_78258, 1);
  noecho();
  return v2;
}
// 78258: using guessed type int dword_78258;

//----- (00026028) --------------------------------------------------------
int __fastcall sub_26028(const char *a1)
{
  char *v1; // r4
  int v2; // r5

  v1 = sub_25F34(a1);
  v2 = strtol(v1, 0, 10);
  free(v1);
  return v2;
}

//----- (00026054) --------------------------------------------------------
void sub_26054()
{
  const char *v0; // r3
  char *v1; // r11
  char *v2; // r12
  char *v3; // lr
  const char *v4; // r11
  char *v5; // r12
  const char *v6; // lr
  const char *v7; // r12
  const char *v8; // r2
  const char *v9; // r2
  int v10; // r3
  char *v11; // r3
  int v12; // r3
  int v13; // r3
  const char *v14; // r3
  int v15; // r3
  char *v16; // r3
  int v17; // r0
  int v18; // r1
  int v19; // r12
  int v20; // r3
  bool v21; // zf
  unsigned int v22; // r0
  const char *v23; // [sp+0h] [bp-1034h]
  const char *v24; // [sp+4h] [bp-1030h]
  const char *v25; // [sp+8h] [bp-102Ch]
  const char *v26; // [sp+10h] [bp-1024h]
  char s1; // [sp+2Fh] [bp-1005h] BYREF
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  byte_788F0 = 1;
  immedok((WINDOW *)dword_78258, 1);
  sub_19938();
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            strcpy(s, "[N]ormal [C]lear [S]ilent mode (disable all output)\n");
            sub_19A98(s);
            v0 = "off";
            if ( byte_78680 )
              v1 = (char *)"on";
            else
              v1 = "off";
            v23 = v1;
            if ( byte_78AA0 )
              v2 = (char *)"on";
            else
              v2 = "off";
            v24 = v2;
            if ( byte_75C48 )
              v3 = (char *)"on";
            else
              v3 = "off";
            v25 = v3;
            if ( byte_781A8 )
              v4 = "on";
            else
              v4 = "off";
            if ( byte_78682 )
              v5 = (char *)"on";
            else
              v5 = "off";
            v26 = v5;
            if ( byte_78768 )
              v6 = "on";
            else
              v6 = "off";
            if ( byte_75C49 )
              v0 = "on";
            if ( byte_73F8D )
              v7 = "enabled";
            else
              v7 = "disabled";
            if ( byte_74154 )
              v8 = "enabled";
            else
              v8 = "disabled";
            snprintf(
              s,
              0x1000u,
              "[D]ebug:%s\n"
              "[P]er-device:%s\n"
              "[Q]uiet:%s\n"
              "[V]erbose:%s\n"
              "[R]PC debug:%s\n"
              "[W]orkTime details:%s\n"
              "co[M]pact: %s\n"
              "[T]oggle status switching:%s\n"
              "w[I]descreen:%s\n"
              "[Z]ero statistics\n"
              "[L]og interval:%d\n",
              v0,
              v23,
              v24,
              v25,
              v4,
              v26,
              v6,
              v7,
              v8,
              dword_72C0C);
            sub_19A98(s);
            strcpy(s, "Select an option or any other key to return\n");
            sub_19A98(s);
            sub_198BC();
            s1 = wgetch((WINDOW *)stdscr);
            if ( !strncasecmp(&s1, "q", 1u) )
            {
              v9 = "Quiet mode %s\n";
              v10 = (unsigned __int8)byte_78AA0 ^ 1;
              byte_78AA0 ^= 1u;
              if ( v10 )
                v11 = "enabled";
              else
                v11 = "disabled";
              goto LABEL_64;
            }
            if ( !strncasecmp(&s1, "v", 1u) )
            {
              v9 = "Verbose mode %s\n";
              v12 = (unsigned __int8)byte_75C48 ^ 1;
              byte_75C48 ^= 1u;
              if ( v12 )
              {
                byte_78AA0 = 0;
                v11 = "enabled";
              }
              else
              {
                v11 = "disabled";
              }
              goto LABEL_64;
            }
            if ( strncasecmp(&s1, "n", 1u) )
              break;
            byte_75C49 = 0;
            byte_75C48 = 0;
            byte_78AA0 = 0;
            byte_781A8 = 0;
            strcpy(s, "Output mode reset to normal\n");
            byte_78768 = 0;
            byte_78680 = 0;
            sub_19A98(s);
            v17 = sub_196AC();
            if ( v17 )
              goto LABEL_47;
          }
          if ( strncasecmp(&s1, "d", 1u) )
            break;
          v13 = (unsigned __int8)byte_75C49 ^ 1;
          byte_75C49 ^= 1u;
          byte_75C48 = v13;
          if ( v13 )
          {
            byte_78AA0 = 0;
            v14 = "enabled";
          }
          else
          {
            v14 = "disabled";
          }
          snprintf(s, 0x1000u, "Debug mode %s\n", v14);
          sub_19A98(s);
        }
        if ( strncasecmp(&s1, "m", 1u) )
          break;
        v15 = (unsigned __int8)byte_78768 ^ 1;
        byte_78768 ^= 1u;
        if ( v15 )
          v16 = "enabled";
        else
          v16 = "disabled";
        snprintf(s, 0x1000u, "Compact mode %s\n", v16);
        sub_19A98(s);
        v17 = sub_196AC();
        if ( v17 )
LABEL_47:
          sub_19840(v17, v18);
      }
      if ( !strncasecmp(&s1, "p", 1u) )
      {
        v9 = "Per-device stats %s\n";
        v19 = (unsigned __int8)byte_78680 ^ 1;
        byte_78680 ^= 1u;
        byte_75C48 = v19;
        if ( v19 )
          v11 = "enabled";
        else
          v11 = "disabled";
        goto LABEL_64;
      }
      if ( !strncasecmp(&s1, "r", 1u) )
      {
        v20 = (unsigned __int8)byte_781A8 ^ 1;
        byte_781A8 ^= 1u;
        v9 = "RPC protocol debugging %s\n";
        if ( v20 )
        {
          byte_78AA0 = 0;
          v11 = "enabled";
        }
        else
        {
          v11 = "disabled";
        }
        goto LABEL_64;
      }
      if ( !strncasecmp(&s1, "c", 1u) )
        goto LABEL_75;
      if ( strncasecmp(&s1, "l", 1u) )
        break;
      v22 = sub_26028("Interval in seconds");
      if ( v22 <= 0x270F )
      {
        dword_72C0C = v22;
        snprintf(s, 0x1000u, "Log interval set to %d seconds\n", v22);
      }
      else
      {
        strcpy(s, "Invalid selection\n");
      }
      sub_19A98(s);
    }
    if ( !strncasecmp(&s1, "s", 1u) )
      break;
    if ( !strncasecmp(&s1, "w", 1u) )
    {
      v11 = "enabled";
      v21 = byte_78682 == 1;
      byte_78682 ^= 1u;
      v9 = "WorkTime details %s\n";
      if ( v21 )
        v11 = "disabled";
LABEL_64:
      snprintf(s, 0x1000u, v9, v11);
      sub_19A98(s);
    }
    else if ( !strncasecmp(&s1, "t", 1u) )
    {
      byte_73F8D ^= 1u;
    }
    else if ( !strncasecmp(&s1, "i", 1u) )
    {
      byte_74154 ^= 1u;
    }
    else
    {
      if ( strncasecmp(&s1, "z", 1u) )
      {
LABEL_75:
        sub_19938();
        goto LABEL_76;
      }
      sub_1B220();
    }
  }
  byte_78940 = 1;
LABEL_76:
  immedok((WINDOW *)dword_78258, 0);
  byte_788F0 = 0;
}
// 2638C: variable 'v18' is possibly undefined
// 72C0C: using guessed type int dword_72C0C;
// 739F8: using guessed type int stdscr;
// 73F8D: using guessed type char byte_73F8D;
// 74154: using guessed type char byte_74154;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 781A8: using guessed type char byte_781A8;
// 78258: using guessed type int dword_78258;
// 78680: using guessed type char byte_78680;
// 78682: using guessed type char byte_78682;
// 78768: using guessed type char byte_78768;
// 788F0: using guessed type char byte_788F0;
// 78940: using guessed type char byte_78940;
// 78AA0: using guessed type char byte_78AA0;

//----- (00026708) --------------------------------------------------------
void sub_26708()
{
  int v0; // r3
  unsigned int v1; // r0
  int i; // r2
  char *v3; // r0
  char *v4; // r4
  FILE *v5; // r0
  FILE *v6; // r4
  int v7; // r0
  unsigned int v8; // r0
  char s1; // [sp+Fh] [bp-3091h] BYREF
  struct stat stat_buf; // [sp+10h] [bp-3090h] BYREF
  char filename[4052]; // [sp+6Ch] [bp-3034h] BYREF
  char v12[4052]; // [sp+106Ch] [bp-2034h] BYREF
  char v13[4116]; // [sp+206Ch] [bp-1034h] BYREF

  byte_788F0 = 1;
  immedok((WINDOW *)dword_78258, 1);
  sub_19938();
  v0 = dword_72C18;
  v1 = dword_72C30;
  for ( i = dword_72C34; ; i = dword_72C34 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          snprintf(
            v13,
            0x1000u,
            "[Q]ueue: %d\n[S]cantime: %d\n[E]xpiry: %d\n[W]rite config file\n[C]gminer restart\n",
            v0,
            v1,
            i);
          sub_19A98(v13);
          strcpy(v13, "Select an option or any other key to return\n");
          sub_19A98(v13);
          sub_198BC();
          s1 = wgetch((WINDOW *)stdscr);
          if ( strncasecmp(&s1, "q", 1u) )
            break;
          v7 = sub_26028("Extra work items to queue");
          v0 = v7;
          if ( (unsigned int)v7 > 0x270F )
            goto LABEL_18;
          dword_72C18 = v7;
          if ( v7 >= dword_72C14 )
          {
            v1 = dword_72C30;
            i = dword_72C34;
          }
          else
          {
            dword_72C14 = v7;
            i = dword_72C34;
            v1 = dword_72C30;
          }
        }
        if ( strncasecmp(&s1, "s", 1u) )
          break;
        v1 = sub_26028("Set scantime in seconds");
        if ( v1 > 0x270F )
          goto LABEL_18;
        dword_72C30 = v1;
        v0 = dword_72C18;
        i = dword_72C34;
      }
      if ( strncasecmp(&s1, "e", 1u) )
        break;
      v8 = sub_26028("Set expiry time in seconds");
      i = v8;
      if ( v8 > 0x270F )
      {
LABEL_18:
        strcpy(v13, "Invalid selection\n");
        sub_19A98(v13);
        v0 = dword_72C18;
        v1 = dword_72C30;
        i = dword_72C34;
      }
      else
      {
        dword_72C34 = v8;
        v0 = dword_72C18;
        v1 = dword_72C30;
      }
    }
    if ( strncasecmp(&s1, "w", 1u) )
      break;
    sub_16088(filename);
    snprintf(v13, 0x1032u, "Config filename to write (Enter for default) [%s]", filename);
    v3 = sub_25F34(v13);
    v4 = v3;
    if ( *v3 == 45 && v3[1] == 49 && !v3[2] )
    {
      free(v3);
LABEL_10:
      v5 = fopen(filename, "w");
      v6 = v5;
      if ( v5 )
      {
        sub_15A9C(v5);
        fclose(v6);
      }
      else
      {
        strcpy(v12, "Cannot open or create file\n");
        sub_19A98(v12);
      }
      goto LABEL_12;
    }
    strcpy(filename, v3);
    free(v4);
    if ( _xstat(3, filename, &stat_buf) )
      goto LABEL_10;
    strcpy(v12, "File exists, overwrite?\n");
    sub_19A98(v12);
    s1 = wgetch((WINDOW *)stdscr);
    if ( !strncasecmp(&s1, "y", 1u) )
      goto LABEL_10;
LABEL_12:
    v0 = dword_72C18;
    v1 = dword_72C30;
  }
  if ( !strncasecmp(&s1, "c", 1u)
    && (strcpy(v13, "Are you sure?\n"), sub_19A98(v13), s1 = wgetch((WINDOW *)stdscr), !strncasecmp(&s1, "y", 1u)) )
  {
    sub_1D138();
  }
  else
  {
    sub_19938();
  }
  immedok((WINDOW *)dword_78258, 0);
  byte_788F0 = 0;
}
// 72C14: using guessed type int dword_72C14;
// 72C18: using guessed type int dword_72C18;
// 72C30: using guessed type int dword_72C30;
// 72C34: using guessed type int dword_72C34;
// 739F8: using guessed type int stdscr;
// 78258: using guessed type int dword_78258;
// 788F0: using guessed type char byte_788F0;

//----- (00026B24) --------------------------------------------------------
int __fastcall sub_26B24(int a1, int a2, char *a3, const char *a4, const char *a5)
{
  char *v8; // r0
  size_t v9; // r8
  size_t v10; // r8
  char *v11; // r0
  int v12; // r1
  int *v13; // r2
  char v15[4096]; // [sp+8h] [bp-1000h] BYREF

  v8 = sub_2AC38(a3, a1);
  *(_DWORD *)(a1 + 204) = a4;
  *(_DWORD *)(a1 + 208) = a5;
  *(_DWORD *)(a1 + 196) = v8;
  v9 = strlen(a4);
  v10 = v9 + strlen(a5) + 2;
  v11 = (char *)malloc(v10);
  *(_DWORD *)(a1 + 200) = v11;
  if ( !v11 )
  {
    strcpy(v15, "Failed to malloc userpass");
    sub_385C8(3, v15, 1);
    sub_16BE0(1);
  }
  snprintf(v11, v10, "%s:%s", a4, a5);
  v12 = *(_DWORD *)(a1 + 132);
  v13 = (int *)(a2 ^ 1);
  *(_BYTE *)(a1 + 139) = a2 ^ 1;
  if ( v12 != 1 )
  {
    *(_DWORD *)(a1 + 132) = 1;
    v13 = &dword_7840C;
  }
  *(_BYTE *)(a1 + 316) = 1;
  *(_BYTE *)(a1 + 129) = 1;
  if ( v12 != 1 )
    ++*v13;
  pthread_create((pthread_t *)(a1 + 312), 0, (void *(*)(void *))start_routine, (void *)a1);
  if ( a2 )
    return 1;
  pthread_join(*(_DWORD *)(a1 + 312), 0);
  return (unsigned __int8)byte_74148;
}
// 74148: using guessed type char byte_74148;
// 7840C: using guessed type int dword_7840C;

//----- (00026C44) --------------------------------------------------------
void sub_26C44()
{
  JUMPOUT(0x26B8C);
}
// 26C50: control flows out of bounds to 26B8C

//----- (00026C68) --------------------------------------------------------
int __fastcall sub_26C68(int a1)
{
  char *v2; // r0
  char *v3; // r4
  char *v4; // r0
  char *v5; // r8
  char *v6; // r0
  void *v7; // r7
  char *v8; // r10
  char *v9; // r0
  char *v10; // r9
  int v11; // r6
  char v13[4096]; // [sp+8h] [bp-1000h] BYREF

  immedok((WINDOW *)dword_78258, 1);
  strcpy(v13, "Input server details.\n");
  sub_19A98(v13);
  v2 = sub_25F34("URL");
  v3 = v2;
  if ( *v2 == 45 && v2[1] == 49 && (v5 = (char *)(unsigned __int8)v2[2], !v2[2])
    || (v4 = sub_25F34("Username"), v5 = v4, *v4 == 45) && v4[1] == 49 && !v4[2] )
  {
    immedok((WINDOW *)dword_78258, 0);
    v7 = 0;
LABEL_19:
    v11 = 0;
    free(v3);
    free(v5);
    free(v7);
    return v11;
  }
  v6 = sub_25F34("Password");
  v7 = v6;
  if ( *v6 == 45 && v6[1] == 49 && !v6[2] )
  {
    free(v6);
    v7 = calloc(1u, 1u);
  }
  v8 = sub_17974();
  if ( !sub_154B4((int)v8, v3) && strncmp(v3, "http://", 7u) && strncmp(v3, "https://", 8u) )
  {
    v9 = (char *)malloc(0x100u);
    v10 = v9;
    if ( !v9 )
    {
      strcpy(v13, "Failed to malloc httpinput");
      sub_385C8(3, v13, 1);
      sub_16BE0(1);
    }
    strcpy(v9, "http://");
    strncat(v9, v3, 0xF8u);
    free(v3);
    v3 = v10;
  }
  v11 = sub_26B24((int)v8, a1, v3, v5, (const char *)v7);
  immedok((WINDOW *)dword_78258, 0);
  if ( !v11 )
    goto LABEL_19;
  return v11;
}
// 78258: using guessed type int dword_78258;

//----- (00026EA8) --------------------------------------------------------
void sub_26EA8()
{
  int v0; // r9
  char *v1; // r3
  const char *v2; // lr
  int v3; // r0
  int v4; // r0
  int v5; // r11
  int v6; // r11
  int v7; // r3
  const char *v8; // r3
  char *v9; // r11
  int i; // r9
  const char *v11; // t1
  int v12; // r3
  unsigned int v13; // r0
  int v14; // r9
  int v15; // r0
  int v16; // r9
  int v17; // r0
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  _DWORD *v22; // lr
  int v23; // r1
  int v24; // r0
  int v25; // r0
  int v26; // r11
  int v27; // r0
  int v28; // r9
  int v29; // r11
  int v30; // r0
  int v31; // r9
  int v32; // r2
  const char *v33; // r2
  const char *v34; // r3
  __int64 v35; // r10
  __int64 v36; // r2
  int v37; // r1
  double v38; // d8
  double v39; // r0
  int v40; // r3
  unsigned int v41; // [sp+10h] [bp-101Ch]
  unsigned int v42; // [sp+14h] [bp-1018h]
  char s1; // [sp+27h] [bp-1005h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  byte_788F0 = 1;
  immedok((WINDOW *)dword_78258, 1);
  sub_19938();
  v0 = 0;
LABEL_2:
  while ( 2 )
  {
    while ( v0 < dword_77FC0 )
    {
LABEL_23:
      v6 = *(_DWORD *)(dword_78260 + 4 * v0);
      if ( v6 == sub_1D9A0() )
        wattr_on((WINDOW *)dword_78258, 0x200000u, 0);
      if ( *(_DWORD *)(v6 + 132) != 1 )
        wattr_on((WINDOW *)dword_78258, 0x100000u, 0);
      snprintf(s, 0x1000u, "%d: ", *(_DWORD *)v6);
      sub_19A98(s);
      v7 = *(_DWORD *)(v6 + 132);
      if ( v7 == 1 )
      {
        strcpy(s, "Enabled ");
        sub_19A98(s);
      }
      else if ( v7 )
      {
        if ( v7 == 2 )
        {
          strcpy(s, "Rejecting ");
          sub_19A98(s);
        }
      }
      else
      {
        strcpy(s, "Disabled ");
        sub_19A98(s);
      }
      ++v0;
      v8 = "Alive";
      if ( *(_BYTE *)(v6 + 129) )
        v8 = "Dead";
      snprintf(
        s,
        0x1000u,
        "%s Quota %d Prio %d: %s  User:%s\n",
        v8,
        *(_DWORD *)(v6 + 56),
        *(_DWORD *)(v6 + 4),
        *(const char **)(v6 + 196),
        *(const char **)(v6 + 204));
      sub_19A98(s);
      wattr_off((WINDOW *)dword_78258, 0x300000u, 0);
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              snprintf(
                s,
                0x1000u,
                "\nCurrent pool management strategy: %s\n",
                (const char *)dword_72430[dword_73D34 + 520]);
              sub_19A98(s);
              if ( dword_73D34 == 2 )
              {
                snprintf(s, 0x1000u, "Set to rotate every %d minutes\n", dword_78380);
                sub_19A98(s);
              }
              v1 = "disabled";
              if ( byte_7844D )
                v1 = "enabled";
              snprintf(s, 0x1000u, "[F]ailover only %s\n", v1);
              sub_19A98(s);
              strcpy(s, "Pool [A]dd [R]emove [D]isable [E]nable [Q]uota change\n");
              sub_19A98(s);
              strcpy(s, "[C]hange management strategy [S]witch pool [I]nformation\n");
              sub_19A98(s);
              strcpy(s, "Or press any other key to continue\n");
              sub_19A98(s);
              sub_198BC();
              s1 = wgetch((WINDOW *)stdscr);
              if ( !strncasecmp(&s1, "a", 1u) )
              {
                v0 = 0;
                sub_26C68(1);
                goto LABEL_2;
              }
              if ( strncasecmp(&s1, "r", 1u) )
                break;
              if ( dword_77FC0 <= 1 )
              {
                v2 = "Cannot remove last pool";
                goto LABEL_47;
              }
              v3 = sub_26028("Select pool number");
              if ( v3 >= 0 && v3 < dword_77FC0 )
              {
                v26 = *(_DWORD *)(dword_78260 + 4 * v3);
                if ( v26 == sub_1D9A0() )
                {
                  sub_1A600(0);
                  if ( v26 != sub_1D9A0() )
                  {
LABEL_82:
                    v40 = *(_DWORD *)(v26 + 132);
                    v0 = 0;
                    *(_DWORD *)(v26 + 132) = 0;
                    if ( v40 == 1 )
                      --dword_7840C;
                    sub_15A00(v26);
                    goto LABEL_2;
                  }
                }
                else if ( v26 != sub_1D9A0() )
                {
                  goto LABEL_82;
                }
                strcpy(s, "Unable to remove pool due to activity\n");
                sub_19A98(s);
              }
              else
              {
LABEL_13:
                strcpy(s, "Invalid selection\n");
                sub_19A98(s);
              }
            }
            if ( !strncasecmp(&s1, "s", 1u) )
            {
              v24 = sub_26028("Select pool number");
              if ( v24 >= 0 && v24 < dword_77FC0 )
              {
                v25 = *(_DWORD *)(dword_78260 + 4 * v24);
                if ( *(_DWORD *)(v25 + 132) != 1 )
                {
                  *(_DWORD *)(v25 + 132) = 1;
                  ++dword_7840C;
                }
                goto LABEL_52;
              }
              goto LABEL_13;
            }
            if ( strncasecmp(&s1, "d", 1u) )
              break;
            if ( dword_7840C > 1 )
            {
              v4 = sub_26028("Select pool number");
              if ( v4 < 0 || v4 >= dword_77FC0 )
                goto LABEL_13;
              v5 = *(_DWORD *)(dword_78260 + 4 * v4);
              if ( *(_DWORD *)(v5 + 132) == 1 )
                --dword_7840C;
              v0 = 0;
              *(_DWORD *)(v5 + 132) = 0;
              if ( v5 == sub_1D9A0() )
              {
                sub_1A600(0);
                goto LABEL_2;
              }
              goto LABEL_22;
            }
            strcpy(s, "Cannot disable last pool");
            sub_19A98(s);
          }
          if ( strncasecmp(&s1, "e", 1u) )
            break;
          v27 = sub_26028("Select pool number");
          if ( v27 < 0 || v27 >= dword_77FC0 )
            goto LABEL_13;
          v28 = *(_DWORD *)(dword_78260 + 4 * v27);
          if ( *(_DWORD *)(v28 + 132) != 1 )
          {
            *(_DWORD *)(v28 + 132) = 1;
            ++dword_7840C;
          }
          v29 = *(_DWORD *)(v28 + 4);
          if ( v29 < *(_DWORD *)(sub_1D9A0() + 4) )
          {
            v25 = v28;
LABEL_52:
            v0 = 0;
            sub_1A600(v25);
            goto LABEL_2;
          }
LABEL_22:
          v0 = 0;
          if ( dword_77FC0 > 0 )
            goto LABEL_23;
        }
        if ( !strncasecmp(&s1, "c", 1u) )
        {
          v9 = &byte_72C4C;
          for ( i = 0; i != 5; ++i )
          {
            v11 = (const char *)*((_DWORD *)v9 + 1);
            v9 += 4;
            v12 = i;
            snprintf(s, 0x1000u, "%d: %s\n", v12, v11);
            sub_19A98(s);
          }
          v13 = sub_26028("Select strategy number type");
          v14 = v13;
          if ( v13 <= 4 )
          {
            if ( v13 != 2
              || (dword_78380 = sub_26028("Select interval in minutes"), (unsigned int)dword_78380 <= 0x270F) )
            {
              dword_73D34 = v14;
              v0 = 0;
              sub_1A600(0);
              goto LABEL_2;
            }
            dword_78380 = 0;
          }
          goto LABEL_13;
        }
        if ( strncasecmp(&s1, "i", 1u) )
          break;
        v30 = sub_26028("Select pool number");
        if ( v30 < 0 || v30 >= dword_77FC0 )
          goto LABEL_13;
        v31 = *(_DWORD *)(dword_78260 + 4 * v30);
        if ( sub_196AC() )
        {
          snprintf(s, 0x1000u, "Pool: %s\n", *(const char **)(v31 + 196));
          sub_157C8(s);
          v32 = *(_DWORD *)(v31 + 32);
          if ( v32 )
          {
            if ( v32 > 1 )
              v33 = "S";
            else
              v33 = "";
            snprintf(s, 0x1000u, "SOLVED %d BLOCK%s!\n", *(_DWORD *)(v31 + 32), v33);
            sub_157C8(s);
          }
          if ( !*(_BYTE *)(v31 + 664) )
          {
            v34 = "Does not have";
            if ( *(_DWORD *)(v31 + 140) )
              v34 = "Has";
            snprintf(s, 0x1000u, "%s own long-poll support\n", v34);
            sub_157C8(s);
          }
          snprintf(s, 0x1000u, " Queued work requests: %d\n", *(_DWORD *)(v31 + 148));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Share submissions: %lld\n", *(_QWORD *)(v31 + 8) + *(_QWORD *)(v31 + 16));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Accepted shares: %lld\n", *(_QWORD *)(v31 + 8));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Rejected shares: %lld\n", *(_QWORD *)(v31 + 16));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Accepted difficulty shares: %1.f\n", *(double *)(v31 + 104));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Rejected difficulty shares: %1.f\n", *(double *)(v31 + 112));
          sub_157C8(s);
          v35 = *(_QWORD *)(v31 + 8);
          v36 = *(_QWORD *)(v31 + 16);
          if ( v35 || v36 )
          {
            v42 = *(_DWORD *)(v31 + 16);
            v41 = *(_DWORD *)(v31 + 20);
            LODWORD(v38) = sub_59F1C(100 * v36);
            HIDWORD(v38) = v37;
            LODWORD(v39) = sub_59F1C(v35 + __PAIR64__(v41, v42));
            snprintf(s, 0x1000u, " Reject ratio: %.1f%%\n", v38 / v39);
            sub_157C8(s);
          }
          snprintf(s, 0x1000u, " Items worked on: %d\n", *(_DWORD *)(v31 + 68));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Discarded work due to new blocks: %d\n", *(_DWORD *)(v31 + 156));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Stale submissions discarded due to new blocks: %d\n", *(_DWORD *)(v31 + 152));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Unable to get work from server occasions: %d\n", *(_DWORD *)(v31 + 160));
          sub_157C8(s);
          snprintf(s, 0x1000u, " Submitting work remotely delay occasions: %d\n\n", *(_DWORD *)(v31 + 164));
          sub_157C8(s);
          if ( pthread_mutex_unlock(&stru_785D0) )
            sub_B50C("unlock_curses", 2930);
          off_72D18();
        }
      }
      if ( strncasecmp(&s1, "q", 1u) )
        break;
      v15 = sub_26028("Select pool number");
      if ( v15 < 0 || v15 >= dword_77FC0 )
        goto LABEL_13;
      v16 = *(_DWORD *)(dword_78260 + 4 * v15);
      v17 = sub_26028("Set quota");
      if ( v17 >= 0 )
      {
        *(_DWORD *)(v16 + 56) = v17;
        v0 = 0;
        sub_15218();
        goto LABEL_2;
      }
      v2 = "Invalid negative quota\n";
LABEL_47:
      v18 = *(_DWORD *)v2;
      v19 = *((_DWORD *)v2 + 1);
      v20 = *((_DWORD *)v2 + 2);
      v21 = *((_DWORD *)v2 + 3);
      v22 = v2 + 16;
      *(_DWORD *)s = v18;
      *(_DWORD *)&s[4] = v19;
      *(_DWORD *)&s[8] = v20;
      *(_DWORD *)&s[12] = v21;
      v23 = v22[1];
      *(_DWORD *)&s[16] = *v22;
      *(_DWORD *)&s[20] = v23;
      sub_19A98(s);
    }
    if ( !strncasecmp(&s1, "f", 1u) )
    {
      v0 = 0;
      byte_7844D ^= 1u;
      continue;
    }
    break;
  }
  sub_19938();
  immedok((WINDOW *)dword_78258, 0);
  byte_788F0 = 0;
}
// 276C0: variable 'v37' is possibly undefined
// 276E4: variable 'v39' is possibly undefined
// 72430: using guessed type int dword_72430[];
// 72C4C: using guessed type char byte_72C4C;
// 72D18: using guessed type int (*off_72D18)();
// 739F8: using guessed type int stdscr;
// 73D34: using guessed type int dword_73D34;
// 77FC0: using guessed type int dword_77FC0;
// 78258: using guessed type int dword_78258;
// 78260: using guessed type int dword_78260;
// 78380: using guessed type int dword_78380;
// 7840C: using guessed type int dword_7840C;
// 7844D: using guessed type char byte_7844D;
// 788F0: using guessed type char byte_788F0;

//----- (000279F0) --------------------------------------------------------
int sub_279F0()
{
  char s1[5]; // [sp+7h] [bp-5h] BYREF

  pthread_setcanceltype(1, 0);
  sub_2EF24("Input");
  if ( byte_73E80 )
  {
    do
    {
      while ( 1 )
      {
        s1[0] = wgetch((WINDOW *)stdscr);
        if ( !strncasecmp(s1, "q", 1u) )
          sub_17830();
        if ( strncasecmp(s1, "d", 1u) )
          break;
        sub_26054();
        if ( byte_78940 )
          goto LABEL_10;
      }
      if ( !strncasecmp(s1, "p", 1u) )
      {
        sub_26EA8();
      }
      else if ( !strncasecmp(s1, "s", 1u) )
      {
        sub_26708();
      }
    }
    while ( !byte_78940 );
LABEL_10:
    sub_195CC();
  }
  return 0;
}
// 739F8: using guessed type int stdscr;
// 73E80: using guessed type char byte_73E80;
// 78940: using guessed type char byte_78940;

//----- (00027AF8) --------------------------------------------------------
int sub_27AF8()
{
  int maxy; // r6
  WINDOW *v1; // r0
  int maxx; // r1

  if ( pthread_mutex_lock(&stru_785D0) )
    sub_B35C("lock_curses", 2935);
  if ( byte_73E80 )
  {
    if ( !pthread_mutex_unlock(&stru_785D0) )
      return off_72D18();
LABEL_14:
    sub_B50C("unlock_curses", 2930);
  }
  v1 = initscr();
  dword_78AB8 = (int)v1;
  if ( v1 )
    maxx = v1->_maxx;
  else
    maxy = -1;
  if ( v1 )
    maxy = v1->_maxy;
  else
    maxx = maxy;
  if ( v1 )
  {
    ++maxx;
    ++maxy;
  }
  dword_785E8 = (int)newwin(dword_73E84, maxx, 0, 0);
  leaveok((WINDOW *)dword_785E8, 1);
  dword_78258 = (int)newwin(maxy - dword_73E8C, 0, dword_73E8C, 0);
  idlok((WINDOW *)dword_78258, 1);
  scrollok((WINDOW *)dword_78258, 1);
  leaveok((WINDOW *)dword_78258, 1);
  cbreak();
  noecho();
  byte_73E80 = 1;
  dword_73E88 = dword_73E84;
  if ( pthread_mutex_unlock(&stru_785D0) )
    goto LABEL_14;
  return off_72D18();
}
// 27B44: variable 'maxy' is possibly undefined
// 27B48: variable 'maxx' is possibly undefined
// 72D18: using guessed type int (*off_72D18)();
// 73E80: using guessed type char byte_73E80;
// 73E84: using guessed type int dword_73E84;
// 73E88: using guessed type int dword_73E88;
// 73E8C: using guessed type int dword_73E8C;
// 78258: using guessed type int dword_78258;
// 785E8: using guessed type int dword_785E8;
// 78AB8: using guessed type int dword_78AB8;

//----- (00027C28) --------------------------------------------------------
int __fastcall sub_27C28(int result)
{
  if ( !*(_DWORD *)(result + 12) )
    *(_DWORD *)(result + 12) = nullsub_8;
  if ( !*(_DWORD *)(result + 16) )
    *(_DWORD *)(result + 16) = nullsub_3;
  if ( !*(_DWORD *)(result + 20) )
    *(_DWORD *)(result + 20) = nullsub_2;
  if ( !*(_DWORD *)(result + 24) )
    *(_DWORD *)(result + 24) = nullsub_4;
  if ( !*(_DWORD *)(result + 32) )
    *(_DWORD *)(result + 32) = sub_F6D8;
  if ( !*(_DWORD *)(result + 44) )
    *(_DWORD *)(result + 44) = sub_F6E0;
  if ( !*(_DWORD *)(result + 48) )
    *(_DWORD *)(result + 48) = sub_F6E8;
  if ( !*(_DWORD *)(result + 52) )
    *(_DWORD *)(result + 52) = sub_F6F4;
  if ( !*(_DWORD *)(result + 56) )
    *(_DWORD *)(result + 56) = sub_F6FC;
  if ( !*(_DWORD *)(result + 84) )
    *(_DWORD *)(result + 84) = nullsub_5;
  if ( !*(_DWORD *)(result + 88) )
    *(_DWORD *)(result + 88) = nullsub_6;
  if ( !*(_DWORD *)(result + 92) )
    *(_DWORD *)(result + 92) = nullsub_7;
  if ( !*(_DWORD *)(result + 60) )
    *(_DWORD *)(result + 60) = sub_24D08;
  if ( !*(_DWORD *)(result + 76) )
    *(_DWORD *)(result + 76) = nullsub_3;
  if ( !*(_DWORD *)(result + 80) )
    *(_DWORD *)(result + 80) = nullsub_3;
  if ( !*(_DWORD *)(result + 72) )
    *(_DWORD *)(result + 72) = sub_F6D8;
  if ( !*(_DWORD *)(result + 96) )
    *(_DWORD *)(result + 96) = nullsub_3;
  if ( *(double *)(result + 104) == 0.0 )
    *(_QWORD *)(result + 104) = 0x3FF0000000000000LL;
  return result;
}
// F6CC: using guessed type int nullsub_3();
// F6D0: using guessed type int nullsub_2();
// F6D4: using guessed type int nullsub_4();
// F704: using guessed type int nullsub_5();
// F708: using guessed type int nullsub_6();
// F70C: using guessed type int nullsub_7();
// F710: using guessed type int nullsub_8();

//----- (00027E68) --------------------------------------------------------
int __fastcall sub_27E68(pthread_rwlock_t *a1)
{
  int v2; // r2
  int v3; // r3
  unsigned int v4; // r1
  bool v5; // zf
  int *v6; // r3
  unsigned int nr_writers_queued; // r2
  int result; // r0

  a1[1].__lock = 0;
  if ( pthread_rwlock_wrlock(&stru_78528) )
    sub_B3C8("enable_device", 10375);
  v2 = dword_78450;
  v3 = dword_7555C++;
  a1->__lock = v3;
  *(_DWORD *)(v2 + 4 * v3) = a1;
  if ( pthread_rwlock_unlock(&stru_78528) )
    sub_B578("enable_device", 10377);
  off_72D18();
  v5 = byte_785F8 == 0;
  if ( byte_785F8 )
    v6 = (int *)dword_75560;
  else
    v6 = &dword_78994;
  if ( byte_785F8 )
  {
    nr_writers_queued = a1[4].__nr_writers_queued;
  }
  else
  {
    v4 = a1[4].__nr_writers_queued;
    nr_writers_queued = *v6;
  }
  if ( byte_785F8 )
    v6 = (int *)((char *)v6 + nr_writers_queued);
  else
    *v6 = v4 + nr_writers_queued;
  if ( !v5 )
    dword_75560 = (int)v6;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    sub_B4A0("enable_device", 10384);
  a1[11].__lock = 0;
  return result;
}
// 27EE8: variable 'v4' is possibly undefined
// 72D18: using guessed type int (*off_72D18)();
// 7555C: using guessed type int dword_7555C;
// 75560: using guessed type int dword_75560;
// 78450: using guessed type int dword_78450;
// 785F8: using guessed type char byte_785F8;
// 78994: using guessed type int dword_78994;

//----- (00027F60) --------------------------------------------------------
int __fastcall sub_27F60(_DWORD *a1)
{
  int v1; // r4
  const char *v2; // r6
  size_t v3; // r0
  unsigned int v4; // lr
  int v5; // r1
  unsigned __int8 *v6; // r3
  int v7; // r12
  size_t v8; // r5
  unsigned int i; // r2
  unsigned int v10; // lr
  int v11; // r0
  int v12; // r10
  int v13; // r8
  int v14; // r7
  unsigned int v15; // r1
  int v16; // r12
  unsigned int v17; // r0
  unsigned int v18; // r1
  int v19; // r12
  unsigned int v20; // r0
  unsigned int v21; // r1
  size_t v22; // r1
  _DWORD *v23; // r8
  int v24; // r0
  unsigned int v25; // r2
  unsigned int v26; // r3
  int v27; // r1
  unsigned int v28; // r2
  unsigned int v29; // r3
  int v30; // r1
  int v31; // r7
  int v32; // r3
  _DWORD *v33; // r5
  int v34; // r0
  char *v35; // r6
  _DWORD *v36; // r7
  int v37; // r9
  int v38; // r3
  unsigned int v39; // r10
  size_t v40; // r0
  unsigned int v41; // r11
  unsigned __int8 *v42; // r7
  int v43; // r8
  int v44; // r1
  int v45; // r12
  int v46; // r2
  int v47; // r0
  unsigned int v48; // r3
  unsigned int v49; // r10
  int v50; // r8
  unsigned int v51; // r2
  unsigned int v52; // r3
  int v53; // r1
  unsigned int v54; // r2
  unsigned int v55; // r3
  size_t v56; // r9
  int v57; // r3
  int v58; // r3
  int v59; // r2
  int v60; // r2
  int result; // r0
  int v62; // r1
  unsigned int v63; // r2
  unsigned int v64; // r3
  int v65; // r1
  unsigned int v66; // r2
  unsigned int v67; // r3
  unsigned int v68; // r1
  unsigned int v69; // r3
  _DWORD *v70; // r2
  int v71; // r3
  int v72; // r2
  int v73; // r1
  int v74; // r4
  size_t v75; // r6
  _DWORD *v76; // r0
  _DWORD *v77; // r7
  int v78; // r8
  int v79; // r2
  unsigned int v80; // r6
  _DWORD *v81; // r11
  _DWORD *v82; // r4
  _DWORD *v83; // r5
  int v84; // r6
  char *v85; // r9
  unsigned int v86; // r3
  int v87; // r3
  _DWORD *v88; // r3
  unsigned int v89; // r1
  unsigned int v90; // r2
  bool v91; // cc
  int v92; // r2
  int v93; // r3
  int v94; // r0
  size_t v95; // r0
  _DWORD *v96; // r0
  void *v97; // r0
  unsigned int j; // [sp+4h] [bp-8h]

  v1 = dword_75564;
  if ( dword_75564 )
  {
    v2 = *(const char **)(a1[1] + 8);
    v3 = strlen(v2);
    v4 = -1640531527;
    v5 = -17973521;
    v6 = *(unsigned __int8 **)(a1[1] + 8);
    v7 = -1640531527;
    v8 = v3;
    for ( i = v3; i > 0xB; v5 = (v21 - v7 - v4) ^ (v4 >> 15) )
    {
      i -= 12;
      v10 = (v6[6] << 16) + (v6[5] << 8) + v6[4] + (v6[7] << 24) + v4;
      v11 = (v6[2] << 16) + (v6[1] << 8) + *v6;
      v12 = v6[3];
      v13 = v6[11];
      v14 = (v6[10] << 16) + (v6[9] << 8) + v6[8];
      v6 += 12;
      v15 = v14 + (v13 << 24) + v5;
      v16 = (v11 + (v12 << 24) - v10 - v15 + v7) ^ (v15 >> 13);
      v17 = (v10 - v15 - v16) ^ (v16 << 8);
      v18 = (v15 - v16 - v17) ^ (v17 >> 13);
      v19 = (v16 - v17 - v18) ^ (v18 >> 12);
      v20 = (v17 - v18 - v19) ^ (v19 << 16);
      v21 = (v18 - v19 - v20) ^ (v20 >> 5);
      v7 = (v19 - v20 - v21) ^ (v21 >> 3);
      v4 = (v20 - v21 - v7) ^ (v7 << 10);
    }
    v22 = v5 + v8;
    switch ( i )
    {
      case 1u:
        goto LABEL_15;
      case 2u:
        goto LABEL_14;
      case 3u:
        goto LABEL_13;
      case 4u:
        goto LABEL_12;
      case 5u:
        goto LABEL_11;
      case 6u:
        goto LABEL_10;
      case 7u:
        goto LABEL_9;
      case 8u:
        goto LABEL_8;
      case 9u:
        goto LABEL_7;
      case 0xAu:
        goto LABEL_6;
      case 0xBu:
        v22 += v6[10] << 24;
LABEL_6:
        v22 += v6[9] << 16;
LABEL_7:
        v22 += v6[8] << 8;
LABEL_8:
        v4 += v6[7] << 24;
LABEL_9:
        v4 += v6[6] << 16;
LABEL_10:
        v4 += v6[5] << 8;
LABEL_11:
        v4 += v6[4];
LABEL_12:
        v7 += v6[3] << 24;
LABEL_13:
        v7 += v6[2] << 16;
LABEL_14:
        v7 += v6[1] << 8;
LABEL_15:
        v7 += *v6;
        break;
      default:
        break;
    }
    v23 = *(_DWORD **)(dword_75564 + 8);
    v24 = (v7 - v4 - v22) ^ (v22 >> 13);
    v25 = (v4 - v22 - v24) ^ (v24 << 8);
    v26 = (v22 - v24 - v25) ^ (v25 >> 13);
    v27 = (v24 - v25 - v26) ^ (v26 >> 12);
    v28 = (v25 - v26 - v27) ^ (v27 << 16);
    v29 = (v26 - v27 - v28) ^ (v28 >> 5);
    v30 = (v27 - v28 - v29) ^ (v29 >> 3);
    v31 = *(_DWORD *)(*v23
                    + 12
                    * (((v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10)))
                      ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15))
                     & (v23[1] - 1)));
    if ( v31 )
      v31 -= v23[5];
    while ( v31 )
    {
      if ( v8 == *(_DWORD *)(v31 + 32) && !memcmp(*(const void **)(v31 + 28), v2, v8) )
      {
        v57 = *(_DWORD *)(v31 + 4) + 1;
        *(_DWORD *)(v31 + 4) = v57;
        a1[2] = v57;
        goto LABEL_29;
      }
      v32 = *(_DWORD *)(v31 + 24);
      if ( !v32 )
        break;
      v31 = v32 - v23[5];
    }
    v33 = malloc(0x28u);
    v34 = *(_DWORD *)v2;
    v33[1] = 0;
    v35 = (char *)(v33 + 2);
    *v33 = v34;
    a1[2] = 0;
    v33[4] = 0;
    v33[7] = v33;
    v33[8] = strlen((const char *)v33);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) + 8) = v33;
    v33[3] = *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) - *(_DWORD *)(*(_DWORD *)(v1 + 8) + 20);
    *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) = v33 + 2;
    v36 = *(_DWORD **)(v1 + 8);
  }
  else
  {
    v33 = malloc(0x28u);
    v94 = **(_DWORD **)(a1[1] + 8);
    v33[1] = 0;
    *v33 = v94;
    a1[2] = 0;
    v33[4] = 0;
    v33[7] = v33;
    v95 = strlen((const char *)v33);
    v33[3] = 0;
    dword_75564 = (int)v33;
    v33[8] = v95;
    v96 = malloc(0x2Cu);
    v36 = v96;
    v33[2] = v96;
    if ( !v96 )
      goto LABEL_81;
    *v96 = 0;
    v96[3] = 0;
    v35 = (char *)(v33 + 2);
    v96[4] = 0;
    v96[5] = 0;
    v96[6] = 0;
    v96[7] = 0;
    v96[8] = 0;
    v96[9] = 0;
    v96[10] = 0;
    v96[4] = v33 + 2;
    v96[1] = 32;
    v96[2] = 5;
    v96[5] = 8;
    v97 = malloc(0x180u);
    *v36 = v97;
    if ( !v97 )
      goto LABEL_81;
    memset(v97, 0, 0x180u);
    v1 = (int)v33;
    v36[10] = -1609490463;
  }
  v37 = -17973521;
  ++v36[3];
  v38 = *(_DWORD *)(v1 + 8);
  v39 = -1640531527;
  v33[9] = -17973521;
  v33[2] = v38;
  v40 = strlen((const char *)v33);
  v41 = v40;
  if ( v40 <= 0xB )
  {
    v43 = -1640531527;
    v42 = (unsigned __int8 *)v33;
  }
  else
  {
    v42 = (unsigned __int8 *)v33;
    v43 = -1640531527;
    do
    {
      v41 -= 12;
      v44 = (v42[2] << 16) + (v42[1] << 8) + *v42;
      v45 = v42[3];
      v46 = (v42[6] << 16) + (v42[5] << 8) + v42[4];
      v47 = v42[7];
      v48 = (v42[10] << 16) + (v42[9] << 8) + v42[8] + (v42[11] << 24) + v37;
      v42 += 12;
      v49 = v46 + (v47 << 24) + v39;
      v50 = (v44 + (v45 << 24) - v48 - v49 + v43) ^ (v48 >> 13);
      v51 = (v49 - v48 - v50) ^ (v50 << 8);
      v52 = (v48 - v50 - v51) ^ (v51 >> 13);
      v53 = (v50 - v51 - v52) ^ (v52 >> 12);
      v54 = (v51 - v52 - v53) ^ (v53 << 16);
      v55 = (v52 - v53 - v54) ^ (v54 >> 5);
      v43 = (v53 - v54 - v55) ^ (v55 >> 3);
      v39 = (v54 - v55 - v43) ^ (v43 << 10);
      v37 = (v55 - v43 - v39) ^ (v39 >> 15);
      v33[9] = v37;
    }
    while ( v41 > 0xB );
    v40 = strlen((const char *)v33);
  }
  v56 = v40 + v37;
  v33[9] = v56;
  switch ( v41 )
  {
    case 1u:
      goto LABEL_49;
    case 2u:
      goto LABEL_48;
    case 3u:
      goto LABEL_47;
    case 4u:
      goto LABEL_46;
    case 5u:
      goto LABEL_45;
    case 6u:
      goto LABEL_44;
    case 7u:
      goto LABEL_43;
    case 8u:
      goto LABEL_42;
    case 9u:
      goto LABEL_41;
    case 0xAu:
      goto LABEL_40;
    case 0xBu:
      v56 += v42[10] << 24;
      v33[9] = v56;
LABEL_40:
      v56 += v42[9] << 16;
      v33[9] = v56;
LABEL_41:
      v56 += v42[8] << 8;
      v33[9] = v56;
LABEL_42:
      v39 += v42[7] << 24;
LABEL_43:
      v39 += v42[6] << 16;
LABEL_44:
      v39 += v42[5] << 8;
LABEL_45:
      v39 += v42[4];
LABEL_46:
      v43 += v42[3] << 24;
LABEL_47:
      v43 += v42[2] << 16;
LABEL_48:
      v43 += v42[1] << 8;
LABEL_49:
      v43 += *v42;
      break;
    default:
      break;
  }
  v62 = (v43 - v39 - v56) ^ (v56 >> 13);
  v63 = (v39 - v56 - v62) ^ (v62 << 8);
  v64 = (v56 - v62 - v63) ^ (v63 >> 13);
  v65 = (v62 - v63 - v64) ^ (v64 >> 12);
  v66 = (v63 - v64 - v65) ^ (v65 << 16);
  v67 = (v64 - v65 - v66) ^ (v66 >> 5);
  v68 = v65 - v66 - v67;
  v69 = (v67 - (v68 ^ (v67 >> 3)) - ((v66 - v67 - (v68 ^ (v67 >> 3))) ^ ((v68 ^ (v67 >> 3)) << 10)))
      ^ (((v66 - v67 - (v68 ^ (v67 >> 3))) ^ ((v68 ^ (v67 >> 3)) << 10)) >> 15);
  v33[9] = v69;
  v70 = *(_DWORD **)(v1 + 8);
  v71 = 12 * (v69 & (v70[1] - 1));
  ++*(_DWORD *)(*v70 + v71 + 4);
  v72 = *(_DWORD *)(**(_DWORD **)(v1 + 8) + v71);
  v33[5] = 0;
  v33[6] = v72;
  v73 = **(_DWORD **)(v1 + 8) + v71;
  if ( *(_DWORD *)v73 )
  {
    *(_DWORD *)(*(_DWORD *)v73 + 12) = v35;
    v73 = **(_DWORD **)(v1 + 8) + v71;
  }
  *(_DWORD *)v73 = v35;
  if ( *(_DWORD *)(**(_DWORD **)(v1 + 8) + v71 + 4) >= (unsigned int)(10
                                                                    * (*(_DWORD *)(**(_DWORD **)(v1 + 8) + v71 + 8) + 1)) )
  {
    v74 = v33[2];
    if ( *(_DWORD *)(v74 + 36) != 1 )
    {
      v75 = 24 * *(_DWORD *)(v74 + 4);
      v76 = malloc(v75);
      v77 = v76;
      if ( v76 )
      {
        memset(v76, 0, v75);
        v78 = 0;
        *(_DWORD *)(v74 + 24) = (((2 * *(_DWORD *)(v74 + 4) - 1) & *(_DWORD *)(v74 + 12)) != 0)
                              + (*(_DWORD *)(v74 + 12) >> (*(_BYTE *)(v74 + 8) + 1));
        *(_DWORD *)(v33[2] + 28) = 0;
        v79 = v33[2];
        v80 = *(_DWORD *)(v79 + 4);
        if ( v80 )
        {
          v81 = v33;
          for ( j = 0; j < v80; ++j )
          {
            v82 = *(_DWORD **)(*(_DWORD *)v79 + v78);
            if ( v82 )
            {
              while ( 1 )
              {
                v83 = (_DWORD *)v82[4];
                v84 = 3 * ((2 * v80 - 1) & v82[7]);
                v85 = (char *)&v77[v84];
                v86 = *((_DWORD *)v85 + 1) + 1;
                *((_DWORD *)v85 + 1) = v86;
                if ( v86 > *(_DWORD *)(v79 + 24) )
                {
                  ++*(_DWORD *)(v79 + 28);
                  *((_DWORD *)v85 + 2) = *((_DWORD *)v85 + 1) / *(_DWORD *)(v81[2] + 24);
                }
                v82[3] = 0;
                v82[4] = v77[v84];
                v87 = v77[v84];
                if ( v87 )
                  *(_DWORD *)(v87 + 12) = v82;
                v77[v84] = v82;
                v79 = v81[2];
                if ( !v83 )
                  break;
                v80 = *(_DWORD *)(v79 + 4);
                v82 = v83;
              }
              v80 = *(_DWORD *)(v79 + 4);
            }
            v78 += 12;
          }
          v33 = v81;
        }
        free(*(void **)v79);
        *(_DWORD *)(v33[2] + 4) *= 2;
        ++*(_DWORD *)(v33[2] + 8);
        *(_DWORD *)v33[2] = v77;
        v88 = (_DWORD *)v33[2];
        v89 = v88[3];
        v90 = v88[7];
        v91 = v90 > v89 >> 1;
        if ( v90 <= v89 >> 1 )
          v92 = 0;
        else
          v92 = v88[8];
        if ( v91 )
          ++v92;
        v88[8] = v92;
        v93 = v33[2];
        if ( *(_DWORD *)(v93 + 32) > 1u )
          *(_DWORD *)(v93 + 36) = 1;
        goto LABEL_29;
      }
LABEL_81:
      exit(-1);
    }
  }
LABEL_29:
  if ( pthread_rwlock_wrlock(&stru_78528) )
    sub_B3C8("add_cgpu", 10431);
  dword_78450 = (int)realloc((void *)dword_78450, 4 * (dword_78548 + dword_75568 + 2));
  if ( pthread_rwlock_unlock(&stru_78528) )
    sub_B578("add_cgpu", 10433);
  off_72D18();
  if ( pthread_mutex_lock(&stru_77B74) )
    sub_B35C("add_cgpu", 10435);
  a1[58] = time(0);
  if ( pthread_mutex_unlock(&stru_77B74) )
    sub_B50C("add_cgpu", 10437);
  off_72D18();
  if ( byte_785F8 )
  {
    v58 = dword_75568 + dword_78548;
    ++dword_75568;
    *(_DWORD *)(dword_78450 + 4 * v58) = a1;
    v59 = dword_78548;
  }
  else
  {
    v59 = dword_78548 + 1;
    *(_DWORD *)(dword_78450 + 4 * dword_78548) = a1;
    dword_78548 = v59;
  }
  v60 = v59 - dword_786D8;
  result = 1;
  if ( v60 > dword_73E94 )
    dword_73E94 = v60;
  return result;
}
// 280B4: control flows out of bounds to 280B8
// 283A4: control flows out of bounds to 283A8
// 72D18: using guessed type int (*off_72D18)();
// 73E94: using guessed type int dword_73E94;
// 75564: using guessed type int dword_75564;
// 75568: using guessed type int dword_75568;
// 78450: using guessed type int dword_78450;
// 78548: using guessed type int dword_78548;
// 785F8: using guessed type char byte_785F8;
// 786D8: using guessed type int dword_786D8;

//----- (00028A38) --------------------------------------------------------
int sub_28A38()
{
  return 0;
}

//----- (00028A40) --------------------------------------------------------
int __fastcall sub_28A40(int result)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(result + 616);
  if ( v1 )
    *v1 = 0;
  return result;
}

//----- (00028A54) --------------------------------------------------------
bool __fastcall sub_28A54(int a1, int a2)
{
  int v2; // lr
  fd_set *p_tv_usec; // r3
  int v4; // r0
  _DWORD *v5; // r4
  int v6; // r6
  int v7; // lr
  struct timeval timeout; // [sp+8h] [bp-88h] BYREF
  fd_set readfds; // [sp+10h] [bp-80h] BYREF
  _DWORD vars0[6]; // [sp+90h] [bp+0h] BYREF

  v2 = *(_DWORD *)(a1 + 612);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->__fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( p_tv_usec != (fd_set *)&readfds.__fds_bits[31] );
  v4 = v2 + 1;
  v5 = &vars0[v2 / 32];
  v6 = v2 % 32;
  v7 = *(v5 - 32);
  timeout.tv_usec = 0;
  *(v5 - 32) = v7 | (1 << v6);
  timeout.tv_sec = a2 & ~(a2 >> 31);
  return select(v4, &readfds, 0, 0, &timeout) > 0;
}

//----- (00028AF4) --------------------------------------------------------
int __fastcall sub_28AF4(int a1)
{
  unsigned int v2; // r2

  v2 = fcntl(a1, 3, 0) & 0xFFFFF7FF;
  return fcntl(a1, 4, v2);
}

//----- (00028B1C) --------------------------------------------------------
ssize_t __fastcall sub_28B1C(int a1)
{
  ssize_t result; // r0
  _BYTE buf[5]; // [sp+7h] [bp-5h] BYREF

  result = recv(a1, buf, 1u, 0);
  if ( result != -1 )
    return buf[0];
  return result;
}

//----- (00028B44) --------------------------------------------------------
int __fastcall sub_28B44(const char **a1, int a2, int a3)
{
  const char *v5; // r3
  const char *v6; // r12
  size_t v7; // r0
  ssize_t v8; // r0
  int v9; // r3
  unsigned __int8 *v10; // r6
  unsigned __int8 v11; // r0
  char v13; // [sp+Fh] [bp-1405h] BYREF
  char s; // [sp+10h] [bp-1404h] BYREF
  char v15; // [sp+11h] [bp-1403h]
  char v16; // [sp+12h] [bp-1402h]
  unsigned __int8 v17; // [sp+13h] [bp-1401h] BYREF
  char v18[4080]; // [sp+410h] [bp-1004h] BYREF

  v5 = a1[156];
  v6 = a1[152];
  if ( a3 )
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", v5, v6);
  else
    snprintf(&s, 0x400u, "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n", v5, v6, v5, v6);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v18, 0x1000u, "Sending proxy %s:%s - %s", a1[157], a1[158], &s);
    sub_385C8(7, v18, 0);
  }
  v7 = strlen(&s);
  send(a2, &s, v7, 0);
  v8 = recv(a2, &s, 0xCu, 0);
  if ( v8 <= 0 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      return 0;
    snprintf(v18, 0x1000u, "Couldn't read from proxy %s:%s after sending CONNECT", a1[157], a1[158]);
LABEL_22:
    sub_385C8(4, v18, 0);
    return 0;
  }
  v9 = (unsigned __int8)byte_75C49;
  *(&s + v8) = 0;
  if ( v9 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v18, 0x1000u, "Received from proxy %s:%s - %s", a1[157], a1[158], &s);
    sub_385C8(7, v18, 0);
  }
  if ( strcmp(&s, "HTTP/1.1 200") && strcmp(&s, "HTTP/1.0 200") )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      return 0;
    snprintf(v18, 0x1000u, "HTTP Error from proxy %s:%s - %s", a1[157], a1[158], &s);
    goto LABEL_22;
  }
  v10 = (unsigned __int8 *)&v13;
  while ( 1 )
  {
    v11 = sub_28B1C(a2);
    *++v10 = v11;
    if ( v11 == 255 )
      break;
    if ( v10 == &v17 )
    {
      while ( strncmp(&s, "\r\n\r\n", 4u) )
      {
        s = v15;
        v15 = v16;
        v16 = v17;
        v17 = sub_28B1C(a2);
        if ( v17 == 255 )
          goto LABEL_18;
      }
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        return 1;
      snprintf(v18, 0x1000u, "Success negotiating with %s:%s HTTP proxy", a1[157], a1[158]);
      sub_385C8(7, v18, 0);
      return 1;
    }
  }
LABEL_18:
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(v18, 0x1000u, "Couldn't read HTTP byte from proxy %s:%s", a1[157], a1[158]);
    goto LABEL_22;
  }
  return 0;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00028F20) --------------------------------------------------------
int __fastcall sub_28F20(const char **a1, int a2, int a3)
{
  const char *v6; // r0
  __int16 v7; // kr00_2
  unsigned int v8; // r6
  int v10; // r4
  const char *v11; // r0
  const char *v12; // r10
  signed int v13; // r0
  size_t v14; // r8
  unsigned int v15; // r6
  struct addrinfo *v16; // [sp+8h] [bp-122Ch] BYREF
  int v17; // [sp+Ch] [bp-1228h] BYREF
  _BYTE buf[4]; // [sp+2Ch] [bp-1208h] BYREF
  char v19; // [sp+30h] [bp-1204h]
  char v20; // [sp+31h] [bp-1203h]
  char v21; // [sp+32h] [bp-1202h]
  char v22; // [sp+33h] [bp-1201h]
  char v23[8]; // [sp+34h] [bp-1200h] BYREF
  _BYTE v24[500]; // [sp+3Ch] [bp-11F8h] BYREF
  struct addrinfo s[126]; // [sp+230h] [bp-1004h] BYREF

  v6 = a1[152];
  buf[0] = 4;
  buf[1] = 1;
  v7 = strtol(v6, 0, 10);
  buf[2] = HIBYTE(v7);
  buf[3] = v7;
  strcpy(v23, "CGMINER");
  v8 = bswap32(inet_addr(a1[156]));
  if ( v8 != -1 )
    goto LABEL_2;
  s[0].ai_family = 2;
  s[0].ai_flags = 0;
  v11 = a1[156];
  s[0].ai_socktype = 0;
  s[0].ai_protocol = 0;
  v16 = (struct addrinfo *)&v17;
  memset(&s[0].ai_addrlen, 0, 16);
  if ( !getaddrinfo(v11, 0, s, &v16) )
  {
    v15 = *(_DWORD *)&v16->ai_addr->sa_data[2];
    freeaddrinfo(v16);
    v8 = bswap32(v15);
    if ( v8 != -1 )
    {
LABEL_2:
      v19 = HIBYTE(v8);
      v22 = v8;
      v20 = BYTE2(v8);
      v21 = BYTE1(v8);
      send(a2, buf, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_22:
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      return 0;
    snprintf((char *)s, 0x1000u, "Invalid IP address specified for socks4 proxy: %s", a1[156]);
    goto LABEL_8;
  }
  if ( !a3 )
    goto LABEL_22;
  v12 = a1[156];
  v19 = 0;
  v22 = 1;
  v20 = 0;
  v21 = 0;
  v13 = strlen(v12);
  if ( v13 >= 255 )
    v14 = 255;
  else
    v14 = v13;
  memcpy(v24, v12, v14);
  v24[v14] = 0;
  send(a2, buf, v14 + 17, 0);
LABEL_3:
  if ( sub_28B1C(a2) || sub_28B1C(a2) != 90 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      return 0;
    snprintf((char *)s, 0x1000u, "Bad response from %s:%s SOCKS4 server", a1[157], a1[158]);
LABEL_8:
    sub_385C8(4, (const char *)s, 0);
    return 0;
  }
  v10 = 6;
  do
  {
    sub_28B1C(a2);
    --v10;
  }
  while ( v10 );
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000291C4) --------------------------------------------------------
int __fastcall sub_291C4(struct timespec *req)
{
  int result; // r0

  do
    result = clock_nanosleep(1, 1, req, 0);
  while ( result == 4 );
  return result;
}

//----- (000291EC) --------------------------------------------------------
_DWORD *__fastcall sub_291EC(_DWORD *a1, unsigned int a2)
{
  _DWORD *v4; // r0

  if ( a1 && *a1 == 1 && (unsigned int)sub_573A4(a1) >= a2 && (v4 = sub_573C0(a1, a2)) != 0 && *v4 == 2 )
    return sub_57530(v4);
  else
    return 0;
}

//----- (0002924C) --------------------------------------------------------
char *__fastcall sub_2924C(_DWORD *a1, unsigned int a2)
{
  char *result; // r0

  result = (char *)sub_291EC(a1, a2);
  if ( result )
    return _strdup(result);
  return result;
}

//----- (00029264) --------------------------------------------------------
int __fastcall sub_29264(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_rwlock_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (000292E0) --------------------------------------------------------
int __fastcall sub_292E0(pthread_mutex_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_mutex_unlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", a2, a3);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (0002935C) --------------------------------------------------------
int __fastcall sub_2935C(int a1, char *s, int a3)
{
  size_t v5; // r0
  signed int v6; // r10
  int v7; // r3
  int v8; // r5
  unsigned int v9; // r9
  _BYTE *v10; // r4
  int v11; // r8
  unsigned int v12; // r12
  int *v13; // r0
  _BYTE *v14; // r3
  ssize_t v15; // r0
  __int64 v16; // d16
  __int64 v18; // r2
  struct timeval timeout; // [sp+18h] [bp-8Ch] BYREF
  fd_set writefds; // [sp+20h] [bp-84h] BYREF
  _BYTE v22[4]; // [sp+A0h] [bp-4h] BYREF

  v5 = strlen(s);
  v6 = a3 + 1;
  v7 = *(_DWORD *)(a1 + 612);
  *(_WORD *)&s[v5] = 10;
  if ( v6 <= 0 )
  {
    v16 = 0;
    goto LABEL_11;
  }
  v8 = v7 + 1;
  v9 = 0;
  v10 = &v22[4 * (v7 / 32)];
  v11 = 1 << (v7 % 32);
  while ( 2 )
  {
    v12 = 0;
    timeout.tv_usec = 0;
    timeout.tv_sec = 1;
    while ( 1 )
    {
      if ( v12 <= 0x1F )
        goto LABEL_7;
      *((_DWORD *)v10 - 32) |= v11;
      if ( select(v8, 0, &writefds, 0, &timeout) > 0 )
        break;
      v13 = _errno_location();
      v12 = 0;
      if ( *v13 != 4 )
        return 1;
LABEL_7:
      v14 = &v22[4 * v12++];
      *((_DWORD *)v14 - 32) = 0;
    }
    v15 = send(*(_DWORD *)(a1 + 612), &s[v9], v6, 0x4000);
    if ( v15 >= 0 )
      goto LABEL_9;
    if ( *_errno_location() != 11 )
      return 2;
    v15 = 0;
LABEL_9:
    v6 -= v15;
    v9 += v15;
    if ( v6 > 0 )
      continue;
    break;
  }
  v16 = vshrd_n_s64(vdup_n_s32(v9).n64_i64[0], 0x20u);
LABEL_11:
  *(_QWORD *)(a1 + 528) += v16;
  v18 = *(_QWORD *)(a1 + 520);
  *(_QWORD *)(a1 + 536) += v16;
  *(_QWORD *)(a1 + 520) = v18 + 1;
  return 0;
}

//----- (00029500) --------------------------------------------------------
int __fastcall sub_29500(int a1)
{
  pthread_mutex_t *v1; // r5
  int v3; // r0

  v1 = (pthread_mutex_t *)(a1 + 728);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 728)) )
    sub_B650("clear_sock", 1955);
  do
    v3 = *(_DWORD *)(a1 + 612);
  while ( v3 && recv(v3, *(void **)(a1 + 616), 0x1FFCu, 0) > 0 );
  sub_292E0(v1, "clear_sock", 1964);
  off_72D18();
  return sub_28A40(a1);
}
// 72D18: using guessed type int (*off_72D18)();

//----- (00029584) --------------------------------------------------------
int __fastcall sub_29584(int a1, char a2)
{
  pthread_mutex_t *v2; // r5

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B650("tq_freezethaw", 1236);
  *(_BYTE *)(a1 + 8) = a2;
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_292E0(v2, "tq_freezethaw", 1239);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();

//----- (000295E8) --------------------------------------------------------
const char *__fastcall sub_295E8(char *a1)
{
  char **v2; // r3
  const char *result; // r0

  if ( !a1 )
    return "http:";
  v2 = &off_621FC;
  while ( 1 )
  {
    result = v2[2];
    v2 += 2;
    if ( !result )
      break;
    if ( v2[1] == a1 )
      return result;
  }
  return "invalid";
}
// 621FC: using guessed type char *off_621FC;

//----- (00029630) --------------------------------------------------------
_BYTE *__fastcall sub_29630(_BYTE *result, char *a2, int a3)
{
  _BYTE *v3; // r12
  char v4; // t1

  if ( a3 <= 0 )
  {
    v3 = result;
  }
  else
  {
    v3 = &result[2 * a3];
    do
    {
      *result = aClearSock[((unsigned __int8)*a2 >> 4) + 84];
      v4 = *a2++;
      result[1] = aClearSock[(v4 & 0xF) + 84];
      result += 2;
    }
    while ( v3 != result );
  }
  *v3 = 0;
  return result;
}

//----- (00029688) --------------------------------------------------------
_BYTE *__fastcall sub_29688(int a1, int a2)
{
  int v2; // r8
  _BYTE *result; // r0
  _BYTE *v6; // r3
  _BYTE *v7; // r2
  int v8; // r3
  unsigned int v9; // r12
  char v10; // r1
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v2 = 2 * a2;
  result = calloc(4 - (v2 + 1) % 4 + v2 + 1, 1u);
  if ( !result )
  {
    snprintf(s, 0x1000u, "Failed to calloc in %s %s():%d", "util.c", "bin2hex", 920);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v6 = result;
  if ( a2 > 0 )
  {
    v7 = result;
    v8 = 0;
    do
    {
      v9 = *(unsigned __int8 *)(a1 + v8++);
      v10 = aClearSock[(v9 & 0xF) + 84];
      LOBYTE(v9) = aClearSock[(v9 >> 4) + 84];
      v7[1] = v10;
      *v7 = v9;
      v7 += 2;
    }
    while ( v8 != a2 );
    v6 = &result[v2];
  }
  *v6 = 0;
  return result;
}

//----- (00029788) --------------------------------------------------------
bool __fastcall sub_29788(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int v3; // r3
  int v4; // r12
  unsigned __int8 *v5; // r1
  char *v6; // r3
  char *v7; // r12
  int v8; // r12
  bool v9; // zf
  int v10; // r3
  int v11; // r12
  int v12; // r3
  char v14[4100]; // [sp+0h] [bp-1004h] BYREF

  v3 = *a2;
  if ( !*a2 )
    return a3 == 0;
  if ( a3 )
  {
    v4 = a2[1];
    if ( a2[1] )
    {
      v5 = a2 + 2;
      v6 = &aClearSock[4 * v3];
      v7 = &aClearSock[4 * v4];
      while ( 1 )
      {
        v10 = *((_DWORD *)v6 + 27);
        v11 = *((_DWORD *)v7 + 27);
        if ( (v11 | v10) < 0 )
          break;
        --a3;
        *a1++ = v11 | (16 * v10);
        v12 = *v5;
        v9 = v12 == 0;
        v6 = &aClearSock[4 * v12];
        if ( v9 )
          return a3 == 0;
        if ( !a3 )
          return 0;
        v8 = v5[1];
        v5 += 2;
        v9 = v8 == 0;
        v7 = &aClearSock[4 * v8];
        if ( v9 )
          goto LABEL_11;
      }
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        strcpy(v14, "hex2bin scan failed");
        sub_385C8(3, v14, 0);
        return 0;
      }
    }
    else
    {
LABEL_11:
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        strcpy(v14, "hex2bin str truncated");
        sub_385C8(3, v14, 0);
      }
    }
  }
  return 0;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00029904) --------------------------------------------------------
int __fastcall sub_29904(int a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v5; // r1
  char *v6; // r5
  size_t v8; // r3
  void *v9; // r0
  size_t v10; // r6
  _BYTE *v11; // r0
  int v12; // r3
  int *v13; // r0
  int *v14; // r0
  int *v15; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  v5 = a3;
  if ( a3 )
    v5 = 1;
  v6 = sub_2924C(a2, v5);
  if ( !v6 )
    return 0;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 244)) )
    sub_B650("parse_extranonce_equihash", 2503);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 268)) )
  {
    v15 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v15,
      "util.c",
      "parse_extranonce_equihash",
      2503);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  free(*(void **)(a1 + 636));
  *(_DWORD *)(a1 + 636) = v6;
  v8 = strlen(v6) >> 1;
  v9 = *(void **)(a1 + 640);
  *(_DWORD *)(a1 + 1588) = v8;
  free(v9);
  v10 = *(_DWORD *)(a1 + 1588);
  v11 = calloc(v10, 1u);
  *(_DWORD *)(a1 + 640) = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x1000u,
      "%s: Failed to calloc pool->nonce1bin in %s %s():%d",
      "parse_extranonce_equihash",
      "util.c",
      "parse_extranonce_equihash",
      2511);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  sub_29788(v11, *(unsigned __int8 **)(a1 + 636), v10);
  v12 = 64 - *(_DWORD *)(a1 + 1588);
  *(_QWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 656) = v12;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 268)) )
  {
    v14 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v14,
      "util.c",
      "parse_extranonce_equihash",
      2517);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 244)) )
  {
    v13 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v13,
      "util.c",
      "parse_extranonce_equihash",
      2517);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  off_72D18();
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 5 )
    return 1;
  snprintf(s, 0x1000u, "Pool %d extranonce set to %s", *(_DWORD *)a1, v6);
  sub_385C8(6, s, 0);
  return 1;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00029BC8) --------------------------------------------------------
_BYTE *__fastcall sub_29BC8(_BYTE *a1, char *s)
{
  unsigned int v2; // r4
  signed int v4; // r0
  int v5; // r9
  int *v6; // r12
  int v7; // r8
  int v8; // r3
  __int64 v9; // r2
  char v10; // r12
  unsigned int v11; // r2
  unsigned int *v12; // r1
  _BYTE *result; // r0
  _BYTE *v14; // r3
  unsigned int v15; // t1
  int v17; // [sp+Ch] [bp-20h] BYREF
  unsigned int v18[5]; // [sp+10h] [bp-1Ch] BYREF
  unsigned int v19; // [sp+24h] [bp-8h]

  v2 = 0;
  v17 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  v4 = strlen(s);
  if ( v4 <= 0 )
  {
    v11 = 0;
    v10 = 0;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = &v17;
      v7 = 6;
      v8 = *(_DWORD *)&aClearSock[4 * (unsigned __int8)s[v5] + 1160];
      while ( 1 )
      {
        v9 = 58LL * v2 + (unsigned int)v8;
        --v7;
        v8 = BYTE4(v9) & 0x3F;
        v6[6] = v9;
        --v6;
        if ( v7 == -1 )
          break;
        v2 = v6[6];
      }
      if ( v4 == ++v5 )
        break;
      v2 = v19;
    }
    v10 = v17;
    v11 = bswap32(v18[0]);
  }
  v12 = v18;
  result = a1 + 29;
  *a1 = v10;
  v14 = a1 + 5;
  while ( 1 )
  {
    *((_DWORD *)v14 - 1) = v11;
    v14 += 4;
    if ( v14 == result )
      break;
    v15 = v12[1];
    ++v12;
    v11 = bswap32(v15);
  }
  return result;
}

//----- (00029D54) --------------------------------------------------------
int __fastcall sub_29D54(int a1, int a2)
{
  char v3; // r2
  int result; // r0
  int v5; // r2

  if ( a2 > 127 )
  {
    LOWORD(v5) = 16511;
    if ( a2 > 16511 )
    {
      HIWORD(v5) = 32;
      if ( a2 <= v5 )
        result = 4;
      else
        result = 5;
      if ( a2 <= v5 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(a1 + 1) = a2;
  *(_BYTE *)a1 = v3;
  return result;
}

//----- (00029EAC) --------------------------------------------------------
int __fastcall sub_29EAC(unsigned int *a1, unsigned int *a2)
{
  unsigned int *v2; // r12
  unsigned int *v3; // r2
  int v5; // r3
  unsigned int v6; // r5
  unsigned int v7; // t1
  unsigned int v8; // t1
  bool v9; // cf
  int v10; // r5
  unsigned int v12; // r1
  unsigned int v13; // r8
  unsigned int v14; // r7
  unsigned int v15; // r11
  unsigned int v16; // lr
  unsigned int v17; // r10
  unsigned int v18; // r12
  unsigned int v19; // r2
  unsigned int v20; // r10
  unsigned int v21; // r8
  unsigned int v22; // r7
  unsigned int v23; // r2
  unsigned int v24; // r3
  unsigned int v25; // lr
  unsigned int v26; // r12
  char *v27; // r7
  char *v28; // r6
  const char *v29; // r12
  _DWORD v30[8]; // [sp+8h] [bp-1044h] BYREF
  _DWORD v31[8]; // [sp+28h] [bp-1024h] BYREF
  char s[4088]; // [sp+48h] [bp-1004h] BYREF

  v2 = a1 + 8;
  v3 = a2 + 8;
  v5 = 7;
  while ( 1 )
  {
    v7 = *--v2;
    v6 = v7;
    --v5;
    v8 = *--v3;
    v9 = v6 >= v8;
    if ( v6 > v8 )
      break;
    if ( !v9 || v5 == -1 )
    {
      v10 = 1;
      goto LABEL_7;
    }
  }
  v10 = 0;
LABEL_7:
  if ( byte_75C49 )
  {
    v12 = a1[6];
    v13 = a1[3];
    v14 = a1[2];
    v15 = bswap32(a1[7]);
    v16 = a1[1];
    v17 = bswap32(a1[4]);
    v18 = *a1;
    v30[2] = bswap32(a1[5]);
    v30[3] = v17;
    v30[0] = v15;
    v19 = a2[7];
    v20 = a2[6];
    v30[4] = bswap32(v13);
    v21 = a2[5];
    v30[5] = bswap32(v14);
    v22 = a2[4];
    v31[0] = bswap32(v19);
    v23 = a2[1];
    v24 = *a2;
    v30[6] = bswap32(v16);
    v25 = a2[3];
    v30[7] = bswap32(v18);
    v26 = a2[2];
    v30[1] = bswap32(v12);
    v31[7] = bswap32(v24);
    v31[3] = bswap32(v22);
    v31[4] = bswap32(v25);
    v31[5] = bswap32(v26);
    v31[6] = bswap32(v23);
    v31[1] = bswap32(v20);
    v31[2] = bswap32(v21);
    v27 = sub_29688((int)v30, 32);
    v28 = sub_29688((int)v31, 32);
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      v29 = "no (false positive; hash > target)";
      if ( v10 )
        v29 = "YES (hash <= target)";
      snprintf(s, 0x1000u, " Proof: %s\nTarget: %s\nTrgVal? %s", v27, v28, v29);
      sub_385C8(7, s, 0);
    }
    free(v27);
    free(v28);
  }
  return v10;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0002A0C0) --------------------------------------------------------
char *sub_2A0C0()
{
  char *v0; // r0
  char *v1; // r4

  v0 = (char *)calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = v0;
    *((_DWORD *)v0 + 1) = v0;
    pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
    pthread_cond_init((pthread_cond_t *)(v1 + 40), 0);
  }
  return v1;
}

//----- (0002A100) --------------------------------------------------------
void __fastcall sub_2A100(char *a1)
{
  int v1; // r5
  _DWORD *v3; // r3
  int v4; // r2
  _DWORD *v5; // r4
  _DWORD *v6; // r1
  bool v7; // zf

  if ( a1 )
  {
    v3 = (_DWORD *)(*(_DWORD *)a1 - 4);
    v4 = **(_DWORD **)a1;
    if ( a1 != *(char **)a1 )
      v1 = 0;
    v5 = (_DWORD *)(v4 - 4);
    if ( a1 != *(char **)a1 )
    {
      do
      {
        v6 = (_DWORD *)v3[2];
        *(_DWORD *)(v4 + 4) = v6;
        *v6 = v4;
        v3[1] = v1;
        v3[2] = v1;
        free(v3);
        v4 = v5[1];
        v3 = v5;
        v7 = v5 + 1 == (_DWORD *)a1;
        v5 = (_DWORD *)(v4 - 4);
      }
      while ( !v7 );
    }
    pthread_cond_destroy((pthread_cond_t *)(a1 + 40));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 12));
    memset(a1, 0, 0x58u);
    free(a1);
  }
}
// 2A138: variable 'v1' is possibly undefined

//----- (0002A188) --------------------------------------------------------
int __fastcall sub_2A188(int a1)
{
  return sub_29584(a1, 1);
}

//----- (0002A190) --------------------------------------------------------
int __fastcall sub_2A190(int a1)
{
  return sub_29584(a1, 0);
}

//----- (0002A198) --------------------------------------------------------
int __fastcall sub_2A198(int a1, int a2)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r6
  int v6; // r8
  _DWORD *v7; // r4
  _DWORD *v8; // r3

  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( !v4 )
    return 0;
  *v4 = a2;
  v7 = v4 + 1;
  v4[1] = v4 + 1;
  v4[2] = v4 + 1;
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B650("tq_push", 1264);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v6 = 0;
    free(v5);
  }
  else
  {
    v8 = *(_DWORD **)(a1 + 4);
    v6 = 1;
    *(_DWORD *)(a1 + 4) = v7;
    v5[1] = a1;
    v5[2] = v8;
    *v8 = v7;
  }
  pthread_cond_signal((pthread_cond_t *)(a1 + 40));
  sub_292E0((pthread_mutex_t *)(a1 + 12), "tq_push", 1275);
  off_72D18();
  return v6;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0002A258) --------------------------------------------------------
int __fastcall sub_2A258(int a1, const struct timespec *a2)
{
  pthread_mutex_t *v2; // r5
  int *v5; // r3
  _DWORD *v6; // r1
  int v7; // r12
  int v8; // r4
  int v10; // r0

  v2 = (pthread_mutex_t *)(a1 + 12);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 12)) )
    sub_B650("tq_pop", 1286);
  v5 = *(int **)a1;
  if ( a1 != *(_DWORD *)a1 )
    goto LABEL_3;
  if ( a2 )
    v10 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 40), v2, a2);
  else
    v10 = pthread_cond_wait((pthread_cond_t *)(a1 + 40), v2);
  if ( v10 )
  {
    v8 = 0;
    goto LABEL_4;
  }
  v5 = *(int **)a1;
  if ( a1 == *(_DWORD *)a1 )
  {
    v8 = 0;
  }
  else
  {
LABEL_3:
    v6 = (_DWORD *)v5[1];
    v7 = *v5;
    v8 = *(v5 - 1);
    *(_DWORD *)(v7 + 4) = v6;
    *v6 = v7;
    *v5 = 0;
    v5[1] = 0;
    free(v5 - 1);
  }
LABEL_4:
  sub_292E0(v2, "tq_pop", 1305);
  off_72D18();
  return v8;
}
// 72D18: using guessed type int (*off_72D18)();

//----- (0002A334) --------------------------------------------------------
int __fastcall sub_2A334(int result)
{
  int v1; // r4
  pthread_t v2; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_join(v2, 0);
      *(_DWORD *)(v1 + 12) = 0;
    }
    return sem_destroy((sem_t *)(v1 + 16));
  }
  return result;
}

//----- (0002A36C) --------------------------------------------------------
int __fastcall sub_2A36C(int result)
{
  int v1; // r4
  pthread_t v2; // r0

  v1 = result;
  if ( result )
  {
    v2 = *(_DWORD *)(result + 12);
    if ( v2 )
    {
      pthread_cancel(v2);
      *(_DWORD *)(v1 + 12) = 0;
    }
    return sem_destroy((sem_t *)(v1 + 16));
  }
  return result;
}

//----- (0002A3A0) --------------------------------------------------------
int __fastcall sub_2A3A0(_DWORD *a1, int *a2)
{
  int v2; // r3
  int v3; // r2
  int result; // r0
  int v5; // r3

  v2 = a2[1];
  v3 = *a1 - *a2;
  *a2 = v3;
  result = a1[1];
  v5 = result - v2;
  a2[1] = v5;
  if ( v5 < 0 )
  {
    *a2 = v3 - 1;
    a2[1] = v5 + 1000000;
  }
  return result;
}

//----- (0002A3D4) --------------------------------------------------------
int __fastcall sub_2A3D4(_DWORD *a1, int *a2)
{
  int v2; // r3
  int v3; // r12
  int result; // r0
  int v5; // r3

  v2 = a2[1];
  v3 = *a1 + *a2;
  *a2 = v3;
  result = a1[1];
  v5 = result + v2;
  a2[1] = v5;
  if ( v5 > 999999 )
  {
    *a2 = v3 + 1;
    a2[1] = v5 - 1000000;
  }
  return result;
}

//----- (0002A420) --------------------------------------------------------
bool __fastcall sub_2A420(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] > a2[1];
  else
    return *a1 > *a2;
}

//----- (0002A454) --------------------------------------------------------
bool __fastcall sub_2A454(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == *a2 )
    return a1[1] < a2[1];
  else
    return *a1 < *a2;
}

//----- (0002A488) --------------------------------------------------------
_DWORD *__fastcall sub_2A488(_DWORD *result, _DWORD *a2)
{
  int v2; // r3

  v2 = a2[1];
  *result = *a2;
  result[1] = v2;
  return result;
}

//----- (0002A49C) --------------------------------------------------------
_DWORD *__fastcall sub_2A49C(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = a2[1] / 1000;
  return result;
}

//----- (0002A4C4) --------------------------------------------------------
_DWORD *__fastcall sub_2A4C4(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  result[1] = 1000 * a2[1];
  return result;
}

//----- (0002A4E0) --------------------------------------------------------
int __fastcall sub_2A4E0(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE04: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A518) --------------------------------------------------------
int __fastcall sub_2A518(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE04: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A558) --------------------------------------------------------
int __fastcall sub_2A558(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE04: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A5A0) --------------------------------------------------------
int __fastcall sub_2A5A0(_DWORD *a1)
{
  int result; // r0
  int v3; // r3
  _DWORD v4[4]; // [sp+8h] [bp-10h] BYREF

  result = lldiv(v4);
  v3 = 1000 * v4[2];
  *a1 = v4[0];
  a1[1] = v3;
  return result;
}
// AE04: using guessed type int __fastcall lldiv(_DWORD);

//----- (0002A5E0) --------------------------------------------------------
int *__fastcall sub_2A5E0(int *result, _DWORD *a2)
{
  int v2; // r4
  int v3; // r2
  int v4; // r3
  int v5; // r2
  int v6; // r1
  int v7; // r2
  int v8; // r1

  v2 = result[1];
  v3 = *result + *a2;
  *result = v3;
  v4 = v2 + a2[1];
  result[1] = v4;
  if ( v4 > 999999999 )
  {
    v5 = v3 + 1;
    do
    {
      v6 = v5++;
      v4 -= 1000000000;
    }
    while ( v4 > 999999999 );
    *result = v6;
    result[1] = v4;
  }
  if ( v4 < 0 )
  {
    v7 = *result - 1;
    do
    {
      v8 = v7--;
      v4 += 1000000000;
    }
    while ( v4 < 0 );
    *result = v8;
    result[1] = v4;
  }
  return result;
}

//----- (0002A670) --------------------------------------------------------
const char *__fastcall sub_2A670(const char *a1, const char *a2, int a3, int a4)
{
  bool v4; // zf
  signed int v7; // r10
  size_t v8; // r0
  bool v9; // zf
  int v10; // r4
  const __int32_t **v11; // r0
  int v12; // r3
  const __int32_t *v13; // r1
  const __int32_t **v14; // r0
  int v15; // r3
  const __int32_t *v16; // r1
  char *v17; // r0
  int v19; // [sp+0h] [bp-24h] BYREF

  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  v19 = a4;
  if ( v4 )
    return 0;
  v7 = strlen(a1);
  v8 = strlen(a2);
  v9 = v7 == 0;
  if ( v7 )
    v9 = v8 == 0;
  v10 = v8;
  if ( v9 )
    return 0;
  if ( v7 > 0 )
  {
    v11 = _ctype_tolower_loc();
    v12 = 0;
    v13 = *v11;
    do
    {
      *((_BYTE *)&v19 + v12) = v13[(unsigned __int8)a1[v12]];
      ++v12;
    }
    while ( v7 != v12 );
  }
  if ( v10 > 0 )
  {
    v14 = _ctype_tolower_loc();
    v15 = 0;
    v16 = *v14;
    do
    {
      *((_BYTE *)&v19 + v15) = v16[(unsigned __int8)a2[v15]];
      ++v15;
    }
    while ( v10 != v15 );
  }
  v17 = strstr((const char *)&v19, (const char *)&v19);
  if ( !v17 )
    return 0;
  else
    return &a1[v17 - (char *)&v19];
}

//----- (0002A758) --------------------------------------------------------
const char *__fastcall sub_2A758(const char **a1, const char *a2)
{
  const char *v3; // r4
  char *v4; // r0

  v3 = *a1;
  if ( *a1 && (v4 = strpbrk(*a1, a2)) != 0 )
  {
    *v4 = 0;
    *a1 = v4 + 1;
    return v3;
  }
  else
  {
    *a1 = 0;
    return v3;
  }
}

//----- (0002A7A4) --------------------------------------------------------
int __fastcall sub_2A7A4(struct timeval *a1)
{
  return gettimeofday(a1, 0);
}

//----- (0002A7AC) --------------------------------------------------------
int __fastcall sub_2A7AC(_DWORD *a1)
{
  return a1[1] / 1000000 + 1000 * *a1;
}

//----- (0002A7D4) --------------------------------------------------------
int __fastcall sub_2A7D4(_DWORD *a1, _DWORD *a2, int *a3)
{
  int v3; // r12
  int result; // r0
  int v5; // r3

  v3 = *a1 - *a2;
  *a3 = v3;
  result = a1[1];
  v5 = result - a2[1];
  if ( v5 < 0 )
  {
    *a3 = v3 - 1;
    a3[1] = v5 + 1000000000;
  }
  else
  {
    a3[1] = v5;
  }
  return result;
}

//----- (0002A810) --------------------------------------------------------
int __fastcall sub_2A810(struct timespec *tp)
{
  return clock_gettime(1, tp);
}

//----- (0002A81C) --------------------------------------------------------
int __fastcall sub_2A81C(_DWORD *a1)
{
  struct timespec v3; // [sp+0h] [bp-8h] BYREF

  sub_2A558(&v3);
  sub_2A5E0(&v3.tv_sec, a1);
  return sub_291C4(&v3);
}

//----- (0002A854) --------------------------------------------------------
int __fastcall sub_2A854(_DWORD *a1)
{
  struct timespec v3; // [sp+0h] [bp-8h] BYREF

  sub_2A518(&v3);
  sub_2A5E0(&v3.tv_sec, a1);
  return sub_291C4(&v3);
}

//----- (0002A884) --------------------------------------------------------
int sub_2A884()
{
  struct timespec v1; // [sp+0h] [bp-8h] BYREF

  sub_2A810(&v1);
  return sub_2A81C(&v1);
}

//----- (0002A8AC) --------------------------------------------------------
int sub_2A8AC()
{
  struct timespec tp; // [sp+8h] [bp-Ch] BYREF

  sub_2A810(&tp);
  return sub_2A854(&tp);
}

//----- (0002A8E0) --------------------------------------------------------
_DWORD *__fastcall sub_2A8E0(_DWORD *result, _DWORD *a2)
{
  if ( *result - *a2 <= 60 )
    return (_DWORD *)result[1];
  return result;
}

//----- (0002A97C) --------------------------------------------------------
void sub_2A97C()
{
  ;
}

//----- (0002A9C0) --------------------------------------------------------
void __fastcall sub_2A9C0(int a1, char *s)
{
  char *v3; // r0
  char *v4; // r6
  char v5[16]; // [sp+0h] [bp-1010h] BYREF
  char sa[4096]; // [sp+10h] [bp-1000h] BYREF

  v3 = strchr(s, 35);
  v4 = v3;
  if ( v3 )
  {
    if ( !*(_BYTE *)(a1 + 604) )
    {
      strcpy(v5, v3);
      *v4 = 0;
      if ( !strcmp(v5, "#xnsub") )
      {
        *(_BYTE *)(a1 + 604) = 1;
        if ( byte_75C49 )
        {
          if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
          {
            snprintf(sa, 0x1000u, "Pool %d extranonce subscribing enabled.", *(_DWORD *)a1);
            sub_385C8(7, sa, 0);
          }
        }
      }
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0002AAAC) --------------------------------------------------------
int __fastcall sub_2AAAC(const char *a1, _DWORD *a2, char **a3)
{
  const char *v4; // r4
  char *v6; // r0
  char *v7; // r5
  char *v8; // r0
  bool v9; // zf
  char *v10; // r8
  int v11; // r9
  char *v12; // r11
  int v13; // r6
  signed int v14; // r12
  const char *v15; // r11
  char *v16; // r0
  int v17; // r3
  char *v19; // r0
  size_t v20; // r0
  signed int v21; // [sp+Ch] [bp-110h]
  char v22[8]; // [sp+10h] [bp-10Ch] BYREF
  char s[260]; // [sp+18h] [bp-104h] BYREF

  *a2 = a1;
  v4 = a1;
  v6 = strstr(a1, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = v8 == 0;
  if ( v8 )
    v9 = v7 == 0;
  v10 = v8;
  v11 = !v9;
  if ( v9 || v7 >= v8 )
    v8 = (char *)v4;
  v12 = strchr(v8, 58);
  if ( v12 )
  {
    v13 = v12 - v4;
    v14 = ~(v12 - v4) + strlen(v4);
    if ( v14 <= 0 )
      return 0;
    v15 = v12 + 1;
  }
  else
  {
    v20 = strlen(v4);
    v14 = 0;
    v15 = 0;
    v13 = v20;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v11 && v7 < v10 )
  {
    v13 -= 2;
    ++v4;
  }
  v21 = v14;
  snprintf(s, 0xFEu, "%.*s", v13, v4);
  if ( v21 )
  {
    snprintf(v22, 6u, "%.*s", v21, v15);
    v19 = strchr(v22, 47);
    if ( v19 )
      *v19 = 0;
  }
  else
  {
    strcpy(v22, "80");
  }
  *a3 = _strdup(v22);
  v16 = _strdup(s);
  v17 = 1;
  *a2 = v16;
  return v17;
}

//----- (0002AC38) --------------------------------------------------------
char *__fastcall sub_2AC38(char *s1, int a2)
{
  const char *v2; // r4
  int v5; // r5
  size_t v6; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = "http:";
  v5 = 0;
  v6 = 5;
  *(_DWORD *)(a2 + 216) = 0;
  while ( strncmp(s1, v2, v6) )
  {
    ++v5;
    v2 = (&off_621FC)[2 * v5];
    if ( !v2 )
      return s1;
    v6 = strlen((&off_621FC)[2 * v5]);
  }
  v7 = strchr(s1, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)malloc(v7 - s1 + 1 - v6);
    *(_DWORD *)(a2 + 216) = v9;
    if ( !v9 )
    {
      snprintf(s, 0x1000u, "Failed to malloc rpc_proxy in %s %s():%d", "util.c", "get_proxy", 881);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    v10 = &s1[v6];
    s1 = v8 + 1;
    strcpy(v9, v10);
    sub_2AAAC(*(const char **)(a2 + 216), (_DWORD *)(a2 + 628), (char **)(a2 + 632));
    *(_DWORD *)(a2 + 212) = *(_DWORD *)&aClearSock[8 * v5 + 32];
  }
  return s1;
}
// 621FC: using guessed type char *off_621FC;

//----- (0002AD68) --------------------------------------------------------
bool __fastcall sub_2AD68(int a1)
{
  _BYTE *v1; // r3

  v1 = *(_BYTE **)(a1 + 616);
  return *v1 || sub_28A54(a1, (unsigned __int8)*v1);
}

//----- (0002AD84) --------------------------------------------------------
void **__fastcall sub_2AD84(void **result, unsigned int a2, size_t a3, const char *a4, const char *a5, int a6)
{
  _DWORD *v8; // r6
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v8 = result;
  if ( a3 != a2 )
  {
    result = (void **)realloc(*result, a3);
    *v8 = result;
    if ( !result )
    {
      snprintf(s, 0x1000u, "Failed to realloc in %s %s():%d", a4, a5, a6);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    if ( a3 > a2 )
      return (void **)memset((void *)(*v8 + a2), 0, a3 - a2);
  }
  return result;
}

//----- (0002AE38) --------------------------------------------------------
int __fastcall sub_2AE38(int a1)
{
  int v2; // r0
  int *v4; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "Closing socket for stratum pool %d", *(_DWORD *)a1);
    sub_385C8(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 728)) )
    sub_B650("suspend_stratum", 3335);
  sub_28A40(a1);
  v2 = *(_DWORD *)(a1 + 612);
  *(_BYTE *)(a1 + 667) = 0;
  *(_BYTE *)(a1 + 665) = 0;
  if ( v2 )
    close(v2);
  *(_DWORD *)(a1 + 612) = 0;
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 728)) )
  {
    v4 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v4, "util.c", "suspend_stratum", 3337);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0002AF98) --------------------------------------------------------
char *__fastcall sub_2AF98(int a1)
{
  char *v1; // r4
  signed int v3; // r5
  char *v4; // r0
  char *v5; // r7
  size_t v6; // r0
  signed int v7; // r4
  __int64 v8; // r0
  __int64 v9; // r8
  char *v11; // r10
  size_t v12; // r11
  size_t v13; // r9
  unsigned int v14; // r0
  bool v15; // cc
  ssize_t v16; // r4
  bool v17; // nf
  int v18; // r4
  size_t v19; // r11
  char *v20; // r0
  struct timeval v21; // [sp+8h] [bp-3014h] BYREF
  struct timeval v22; // [sp+10h] [bp-300Ch] BYREF
  char s[4072]; // [sp+18h] [bp-3004h] BYREF
  char v24[8196]; // [sp+1018h] [bp-2004h] BYREF

  v1 = *(char **)(a1 + 616);
  if ( !strchr(v1, 10) )
  {
    sub_2A7A4(&v21);
    if ( !sub_28A54(a1, 60) )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        strcpy(v24, "Timed out waiting for data on socket_full");
        sub_385C8(7, v24, 0);
      }
      goto LABEL_18;
    }
    while ( 1 )
    {
      memset(v24, 0, 0x2000u);
      v16 = recv(*(_DWORD *)(a1 + 612), v24, 0x1FFCu, 0);
      if ( !v16 )
        break;
      sub_2A7A4(&v22);
      v17 = v16 < 0;
      v18 = (int)((double)(v22.tv_sec - v21.tv_sec) + (double)(v22.tv_usec - v21.tv_usec) / 1000000.0);
      if ( v17 )
      {
        if ( *_errno_location() != 11 || !sub_28A54(a1, 60 - v18) )
        {
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            strcpy(s, "Failed to recv sock in recv_line");
            sub_385C8(7, s, 0);
          }
          goto LABEL_38;
        }
      }
      else
      {
        v11 = *(char **)(a1 + 616);
        v12 = strlen(v24);
        v13 = strlen(v11);
        v14 = v12 + v13 + 1;
        if ( v14 >= *(_DWORD *)(a1 + 620) )
        {
          v19 = (v14 & 0xFFFFE000) + 0x2000;
          v20 = (char *)realloc(v11, v19);
          *(_DWORD *)(a1 + 616) = v20;
          if ( !v20 )
          {
            snprintf(s, 0x1000u, "Failed to realloc pool sockbuf in %s %s():%d", "util.c", "recalloc_sock", 1997);
            sub_385C8(3, s, 1);
            sub_16BE0(1);
          }
          memset(&v20[v13], 0, v19 - v13);
          v11 = *(char **)(a1 + 616);
          *(_DWORD *)(a1 + 620) = v19;
        }
        strcat(v11, v24);
      }
      v15 = v18 <= 59;
      v1 = *(char **)(a1 + 616);
      if ( !v15 || strchr(*(const char **)(a1 + 616), 10) )
        goto LABEL_2;
    }
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(s, "Socket closed waiting in recv_line");
      sub_385C8(7, s, 0);
    }
LABEL_38:
    sub_2AE38(a1);
    v1 = *(char **)(a1 + 616);
  }
LABEL_2:
  v3 = strlen(v1);
  v4 = strtok(v1, ptr);
  if ( !v4 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(v24, "Failed to parse a \\n terminated string in recv_line");
      sub_385C8(7, v24, 0);
    }
    goto LABEL_18;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( v3 > (int)(v6 + 1) )
    memmove(*(void **)(a1 + 616), (const void *)(*(_DWORD *)(a1 + 616) + v6 + 1), v3 - v6 + 1);
  else
    **(_BYTE **)(a1 + 616) = 0;
  v8 = *(_QWORD *)(a1 + 560);
  v9 = *(_QWORD *)(a1 + 552) + v7;
  ++*(_QWORD *)(a1 + 544);
  *(_QWORD *)(a1 + 552) = v9;
  *(_QWORD *)(a1 + 560) = v7 + v8;
  if ( !v5 )
  {
LABEL_18:
    v5 = 0;
    sub_29500(a1);
    return v5;
  }
  if ( byte_781A8 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v24, 0x1000u, "RECVD: %s", v5);
    sub_385C8(7, v24, 0);
  }
  return v5;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 781A8: using guessed type char byte_781A8;

//----- (0002B520) --------------------------------------------------------
int __fastcall sub_2B520(int a1, char *a2, int a3)
{
  int v6; // r7
  int v7; // r5
  int *v9; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_781A8 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "SEND: %s", a2);
    sub_385C8(7, s, 0);
  }
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 728)) )
    sub_B650("stratum_send", 1893);
  if ( *(_BYTE *)(a1 + 665) )
  {
    v7 = sub_2935C(a1, a2, a3);
    v6 = v7 == 0;
  }
  else
  {
    v6 = *(unsigned __int8 *)(a1 + 665);
    v7 = 3;
  }
  if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 728)) )
  {
    v9 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v9, "util.c", "stratum_send", 1896);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  off_72D18();
  if ( v7 == 2 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(s, "Failed to send in stratum_send");
      sub_385C8(7, s, 0);
      sub_2AE38(a1);
      return v6;
    }
    goto LABEL_21;
  }
  if ( v7 != 3 )
  {
    if ( v7 != 1 )
      return v6;
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "Write select failed on pool %d sock", *(_DWORD *)a1);
      sub_385C8(7, s, 0);
    }
LABEL_21:
    sub_2AE38(a1);
    return v6;
  }
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(s, "Stratum send failed due to no pool stratum_active");
    sub_385C8(7, s, 0);
  }
  return v6;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 781A8: using guessed type char byte_781A8;

//----- (0002B840) --------------------------------------------------------
int *__fastcall sub_2B840(_DWORD *a1)
{
  int i; // r0
  int v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r0
  bool v7; // zf
  int v8; // r0
  struct addrinfo *v9; // r4
  char *v10; // r12
  int v11; // r0
  int v12; // r1
  int v13; // r2
  __int16 v14; // r3
  int v15; // r0
  int v16; // r7
  int v17; // r0
  int *v18; // r10
  unsigned int v19; // lr
  int *v20; // r5
  int v21; // r0
  char *v22; // r3
  int v23; // r0
  const char *v24; // r3
  int v25; // r2
  size_t v26; // r0
  void *v27; // r0
  const char *v28; // r0
  int v29; // r3
  int v30; // r2
  int v31; // r6
  int v32; // r3
  int v33; // r3
  const char *v35; // r3
  int *v36; // r0
  int *v37; // r7
  _DWORD *v38; // r6
  _DWORD *v39; // r0
  char *v40; // r4
  char *v41; // r0
  ssize_t v42; // r0
  const char *v43; // r10
  signed int v44; // r0
  size_t v45; // r5
  __int16 v46; // r0
  char *v47; // r12
  ssize_t v48; // r4
  char v49; // r0
  ssize_t v50; // r5
  int v51; // r0
  int v52; // r0
  int v53; // r2
  size_t v54; // r0
  char *v55; // r0
  int *v56; // r0
  int *v57; // r0
  int *v58; // r0
  int *v59; // r0
  struct timeval *timeout; // [sp+0h] [bp-3374h]
  int *v61; // [sp+18h] [bp-335Ch]
  char *name; // [sp+1Ch] [bp-3358h]
  char *service; // [sp+20h] [bp-3354h]
  int v64; // [sp+24h] [bp-3350h]
  pthread_mutex_t *mutex; // [sp+2Ch] [bp-3348h]
  int v66; // [sp+30h] [bp-3344h]
  struct addrinfo *pai; // [sp+38h] [bp-333Ch] BYREF
  int v68; // [sp+3Ch] [bp-3338h] BYREF
  socklen_t optlen; // [sp+40h] [bp-3334h] BYREF
  int optval; // [sp+44h] [bp-3330h] BYREF
  struct timeval v71; // [sp+48h] [bp-332Ch] BYREF
  addrinfo req; // [sp+50h] [bp-3324h] BYREF
  char v73[92]; // [sp+70h] [bp-3304h] BYREF
  char v74[160]; // [sp+CCh] [bp-32A8h] BYREF
  fd_set writefds; // [sp+16Ch] [bp-3208h] BYREF
  char s[4048]; // [sp+370h] [bp-3004h] BYREF
  char v77[8196]; // [sp+1370h] [bp-2004h] BYREF

  v61 = 0;
  v64 = 0;
  mutex = (pthread_mutex_t *)(a1 + 182);
  v66 = 0;
  for ( i = pthread_mutex_lock((pthread_mutex_t *)(a1 + 182)); ; i = pthread_mutex_lock(mutex) )
  {
    if ( i )
      sub_B650("setup_stratum_socket", 3148);
    v6 = a1[153];
    *((_BYTE *)a1 + 665) = 0;
    if ( v6 )
      close(v6);
    a1[153] = 0;
    if ( pthread_mutex_unlock(mutex) )
    {
      v58 = _errno_location();
      snprintf(
        s,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v58,
        "util.c",
        "setup_stratum_socket",
        3153);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    off_72D18();
    v7 = a1[54] == 0;
    req.ai_family = 0;
    req.ai_flags = 0;
    memset(&req.ai_protocol, 0, 20);
    req.ai_socktype = 1;
    if ( !v7
      || (v28 = (const char *)dword_759B4) != 0
      && (a1[54] = dword_759B4, sub_2AAAC(v28, a1 + 157, (char **)a1 + 158), v29 = a1[54], a1[53] = 3, v29) )
    {
      name = (char *)a1[157];
      service = (char *)a1[158];
      v8 = getaddrinfo(name, service, &req, &pai);
    }
    else
    {
      name = (char *)a1[156];
      service = (char *)a1[152];
      v8 = getaddrinfo(name, service, &req, &pai);
    }
    if ( v8 )
    {
      if ( *((_BYTE *)a1 + 131) )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(s, 0x1000u, "Failed to getaddrinfo for %s:%s", name, service);
          sub_385C8(7, s, 0);
        }
      }
      else
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(s, 0x1000u, "Failed to resolve (?wrong URL) %s:%s", name, service);
          sub_385C8(4, s, 0);
        }
        *((_BYTE *)a1 + 131) = 1;
      }
      goto LABEL_8;
    }
    v9 = pai;
    if ( !pai )
    {
LABEL_60:
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(s, 0x1000u, "Failed to connect to stratum on %s:%s", name, service);
        sub_385C8(7, s, 0);
      }
      freeaddrinfo(pai);
      goto LABEL_8;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v15 = socket(v9->ai_family, v9->ai_socktype, v9->ai_protocol);
        v16 = v15;
        if ( v15 != -1 )
          break;
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          v10 = s;
          v11 = *(_DWORD *)"Failed socket";
          v12 = *(_DWORD *)"ed socket";
          v13 = *(_DWORD *)"ocket";
          v14 = *(_WORD *)"t";
          goto LABEL_38;
        }
LABEL_39:
        v9 = v9->ai_next;
        if ( !v9 )
          goto LABEL_60;
      }
      v17 = fcntl(v15, 3, 0);
      fcntl(v16, 4, v17 | 0x800);
      if ( connect(v16, v9->ai_addr, v9->ai_addrlen) != -1 )
        break;
      v71.tv_sec = 1;
      v71.tv_usec = 0;
      v18 = _errno_location();
      if ( *v18 == 115 )
      {
        v19 = 0;
        v20 = &writefds.__fds_bits[v16 / 32];
        while ( 1 )
        {
          if ( v19 > 0x1F )
          {
            *v20 |= 1 << (v16 % 32);
            v21 = select(v16 + 1, 0, &writefds, 0, &v71);
            if ( v21 > 0 )
            {
              if ( ((*v20 >> (v16 % 32)) & 1) != 0 )
              {
                optlen = 4;
                if ( !getsockopt(v16, 1, 4, &optval, &optlen) && !optval )
                {
                  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                  {
                    strcpy(s, "Succeeded delayed connect");
                    sub_385C8(7, s, 0);
                  }
                  goto LABEL_71;
                }
              }
LABEL_47:
              close(v16);
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                qmemcpy(s, "Select timeout/f", 16);
                v10 = &s[16];
                v11 = *(_DWORD *)"ailed connect";
                v12 = *(_DWORD *)"d connect";
                v13 = *(_DWORD *)"nnect";
                v14 = *(_WORD *)"t";
LABEL_38:
                *(_DWORD *)v10 = v11;
                *((_DWORD *)v10 + 1) = v12;
                *((_DWORD *)v10 + 2) = v13;
                *((_WORD *)v10 + 6) = v14;
                sub_385C8(7, s, 0);
              }
              goto LABEL_39;
            }
            v19 = 0;
            if ( !v21 || *v18 != 4 )
              goto LABEL_47;
          }
          v22 = &v77[4 * v19++ + 0x2000];
          *((_DWORD *)v22 - 3201) = 0;
        }
      }
      close(v16);
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_39;
      strcpy(s, "Failed sock connect");
      sub_385C8(7, s, 0);
      v9 = v9->ai_next;
      if ( !v9 )
        goto LABEL_60;
    }
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      strcpy(s, "Succeeded immediate connect");
      sub_385C8(4, s, 0);
    }
LABEL_71:
    sub_28AF4(v16);
    freeaddrinfo(pai);
    if ( a1[54] )
    {
      switch ( a1[53] )
      {
        case 0:
          if ( !sub_28B44((const char **)a1, v16, 0) )
            break;
          if ( !a1[154] )
            goto LABEL_108;
          goto LABEL_84;
        case 1:
          if ( !sub_28B44((const char **)a1, v16, 1) )
            break;
          goto LABEL_83;
        case 2:
          if ( !sub_28F20((const char **)a1, v16, 0) )
            break;
          goto LABEL_83;
        case 3:
        case 5:
          LOBYTE(writefds.__fds_bits[0]) = 5;
          *(_WORD *)((char *)writefds.__fds_bits + 1) = 1;
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(
              s,
              0x1000u,
              "Attempting to negotiate with %s:%s SOCKS5 proxy",
              (const char *)a1[157],
              (const char *)a1[158]);
            sub_385C8(7, s, 0);
          }
          send(v16, &writefds, 3u, 0);
          if ( sub_28B1C(v16) != 5 )
            goto LABEL_100;
          v42 = sub_28B1C(v16);
          if ( v42 != BYTE2(writefds.__fds_bits[0]) )
            goto LABEL_100;
          v43 = (const char *)a1[156];
          writefds.__fds_bits[0] = 50331909;
          v44 = strlen(v43);
          v45 = v44 >= 255 ? 255 : v44;
          LOBYTE(writefds.__fds_bits[1]) = v45;
          memcpy((char *)&writefds.__fds_bits[1] + 1, v43, v45);
          v46 = strtol((const char *)a1[152], 0, 10);
          v47 = (char *)&writefds.__fds_bits[1] + v45;
          v47[2] = v46;
          v47[1] = HIBYTE(v46);
          send(v16, &writefds, v45 + 7, 0);
          if ( sub_28B1C(v16) != 5 )
            goto LABEL_100;
          v48 = sub_28B1C(v16);
          if ( v48 )
            goto LABEL_100;
          sub_28B1C(v16);
          v49 = sub_28B1C(v16);
          if ( v49 == 1 )
          {
            sub_28B1C(v16);
            sub_28B1C(v16);
            sub_28B1C(v16);
            sub_28B1C(v16);
LABEL_177:
            sub_28B1C(v16);
            sub_28B1C(v16);
            if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
            {
              snprintf(
                s,
                0x1000u,
                "Success negotiating with %s:%s SOCKS5 proxy",
                (const char *)a1[157],
                (const char *)a1[158]);
              sub_385C8(7, s, 0);
            }
            goto LABEL_83;
          }
          if ( v49 == 3 )
          {
            v50 = sub_28B1C(v16);
            if ( v50 > 0 )
            {
              do
              {
                ++v48;
                sub_28B1C(v16);
              }
              while ( v48 != v50 );
            }
            goto LABEL_177;
          }
LABEL_100:
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, "Bad response from %s:%s SOCKS5 server", (const char *)a1[157], (const char *)a1[158]);
            sub_385C8(4, s, 0);
          }
          break;
        case 4:
          if ( sub_28F20((const char **)a1, v16, 1) )
            goto LABEL_83;
          break;
        default:
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, "Unsupported proxy type for %s:%s", (const char *)a1[157], (const char *)a1[158]);
            sub_385C8(4, s, 0);
          }
          break;
      }
LABEL_8:
      v3 = 0;
      goto LABEL_9;
    }
LABEL_83:
    if ( !a1[154] )
    {
LABEL_108:
      v27 = calloc(0x2000u, 1u);
      a1[154] = v27;
      if ( !v27 )
      {
        snprintf(s, 0x1000u, "Failed to calloc pool sockbuf in %s %s():%d", "util.c", "setup_stratum_socket", 3292);
        sub_385C8(3, s, 1);
        sub_16BE0(1);
      }
      a1[155] = 0x2000;
    }
LABEL_84:
    a1[153] = v16;
    v68 = 1;
    optlen = 45;
    optval = 30;
    v23 = fcntl(v16, 3, 0);
    fcntl(v16, 4, v23 | 0x800);
    setsockopt(v16, 1, 9, &v68, 4u);
    if ( !byte_78B48 )
      fcntl(v16, 2, 1);
    setsockopt(v16, 6, 1, &v68, 4u);
    setsockopt(v16, 6, 6, &v68, 4u);
    setsockopt(v16, 6, 4, &optlen, 4u);
    setsockopt(v16, 6, 5, &optval, 4u);
    if ( v66 )
    {
      sub_29500((int)a1);
      v30 = dword_77F20++;
      sprintf(v77, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v30);
    }
    else
    {
      v24 = (const char *)a1[165];
      v25 = dword_77F20;
      if ( v24 )
      {
        ++dword_77F20;
        sprintf(
          v77,
          "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/4.9.0\", \"%s\"]}",
          v25,
          v24);
      }
      else
      {
        v35 = (const char *)a1[156];
        timeout = (struct timeval *)a1[152];
        ++dword_77F20;
        sprintf(
          v77,
          "{\"id\":%d, \"method\":\"mining.subscribe\", \"params\":[\"cgminer/4.9.0\", null, \"%s\", \"%s\"]}",
          v25,
          v35,
          (const char *)timeout);
      }
    }
    v26 = strlen(v77);
    if ( sub_2935C((int)a1, v77, v26) )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        v3 = 1;
        strcpy(s, "Failed to send s in initiate_stratum");
        sub_385C8(7, s, 0);
        goto LABEL_9;
      }
LABEL_121:
      v3 = 1;
      goto LABEL_9;
    }
    if ( !sub_28A54((int)a1, 60) )
    {
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_121;
      v3 = 1;
      strcpy(s, "Timed out waiting for response in initiate_stratum");
      sub_385C8(7, s, 0);
      goto LABEL_9;
    }
    v36 = (int *)sub_2AF98((int)a1);
    v37 = v36;
    if ( !v36 )
    {
      v3 = 1;
      goto LABEL_9;
    }
    v61 = sub_565E8(v36, 0, v73);
    free(v37);
    if ( !v61 )
    {
      if ( !byte_75C49 )
      {
        v66 = 1;
        v3 = 1;
        goto LABEL_9;
      }
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
      {
        v66 = 1;
        v3 = 1;
        goto LABEL_9;
      }
      v3 = 1;
      snprintf(s, 0x1000u, "JSON decode failed(%d): %s", *(_DWORD *)v73, v74);
      goto LABEL_204;
    }
    v38 = (_DWORD *)sub_571D8(v61, "result");
    v39 = (_DWORD *)sub_571D8(v61, "error");
    if ( !v38 || *v38 == 7 )
    {
      if ( v39 )
      {
LABEL_150:
        v40 = (char *)sub_54C0C(v39, 3);
      }
      else
      {
        v40 = (char *)malloc(0x11u);
        if ( v40 )
          strcpy(v40, "(unknown reason)");
      }
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(s, 0x1000u, "JSON-RPC decode failed: %s", v40);
        sub_385C8(7, s, 0);
      }
      v41 = v40;
      v3 = 1;
      free(v41);
      v66 = 1;
      goto LABEL_9;
    }
    if ( v39 && *v39 != 7 )
      goto LABEL_150;
    v51 = sub_29904((int)a1, v38, 1u);
    if ( v51 )
      break;
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      v3 = 1;
      snprintf(s, 0x1000u, "%s: Failed to get parse extranonce.", "initiate_stratum");
LABEL_204:
      sub_385C8(7, s, 0);
      v66 = 1;
      goto LABEL_9;
    }
    v3 = 1;
    v66 = 1;
LABEL_9:
    if ( (v66 & (v64 ^ 1)) == 0 )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        strcpy(s, "Initiate stratum failed");
        sub_385C8(7, s, 0);
      }
      if ( v3 )
      {
        sub_2AE38((int)a1);
        if ( v61 )
          goto LABEL_133;
      }
      else if ( v61 )
      {
LABEL_133:
        v31 = 0;
        goto LABEL_134;
      }
      return v61;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
      sub_B650("initiate_stratum", 3589);
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v56 = _errno_location();
      snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v56, "util.c", "initiate_stratum", 3589);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    free((void *)a1[165]);
    free((void *)a1[159]);
    a1[159] = 0;
    a1[165] = 0;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v59 = _errno_location();
      snprintf(
        s,
        0x1000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v59,
        "util.c",
        "initiate_stratum",
        3593);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
    {
      v57 = _errno_location();
      snprintf(
        s,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v57,
        "util.c",
        "initiate_stratum",
        3593);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    off_72D18();
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(s, "Failed to resume stratum, trying afresh");
      sub_385C8(7, s, 0);
    }
    if ( v61 )
    {
      v4 = v61[1];
      if ( v4 != -1 )
      {
        v5 = v4 - 1;
        v61[1] = v5;
        if ( !v5 )
          sub_5779C((void **)v61);
      }
    }
    v64 = 1;
  }
  v31 = v51;
  if ( !a1[150] )
    a1[150] = a1[156];
  v52 = (unsigned __int8)byte_781A8;
  *((_BYTE *)a1 + 665) = 1;
  *((_QWORD *)a1 + 230) = 0x3FF0000000000000LL;
  if ( v52 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
      *a1,
      (const char *)a1[159],
      a1[164]);
    sub_385C8(7, s, 0);
  }
  if ( *((_BYTE *)a1 + 604) )
  {
    v53 = dword_77F20++;
    sprintf(v77, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v53);
    v54 = strlen(v77);
    sub_2B520((int)a1, v77, v54);
    v55 = sub_2AF98((int)a1);
    if ( v55 )
    {
      free(v55);
    }
    else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      strcpy(s, "recv mining.extranonce.subscribe failed\n");
      sub_385C8(3, s, 0);
    }
  }
LABEL_134:
  v32 = v61[1];
  if ( v32 != -1 )
  {
    v33 = v32 - 1;
    v61[1] = v33;
    if ( !v33 )
      sub_5779C((void **)v61);
  }
  return (int *)v31;
}
// 2BF1C: control flows out of bounds to 2BF20
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 759B4: using guessed type int dword_759B4;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77F20: using guessed type int dword_77F20;
// 781A8: using guessed type char byte_781A8;
// 78B48: using guessed type char byte_78B48;

//----- (0002CE20) --------------------------------------------------------
int __fastcall sub_2CE20(int a1)
{
  if ( *(_BYTE *)(a1 + 665) )
    sub_2AE38(a1);
  if ( sub_2B840((_DWORD *)a1) && (!*(_BYTE *)(a1 + 604) || sub_2E50C((int *)a1)) && sub_2E8A8((_DWORD *)a1) )
  {
    sub_1FCAC((_DWORD *)a1);
    return 1;
  }
  else
  {
    sub_1F95C(a1);
    return 0;
  }
}

//----- (0002CE98) --------------------------------------------------------
int __fastcall sub_2CE98(_DWORD *a1, int *a2)
{
  char *v2; // r11
  double v3; // d0
  int *v5; // r0
  int *v6; // r4
  _DWORD *v7; // r8
  _DWORD *v8; // r7
  _DWORD *v9; // r6
  const char *v10; // r0
  const char *v11; // r5
  char *v12; // r0
  int v13; // r5
  int v14; // r3
  int v15; // r3
  const char *v17; // r0
  const char *v18; // r7
  int v19; // r0
  int v20; // r0
  size_t v21; // r0
  int v22; // r0
  _DWORD *v23; // r0
  double v24; // d9
  char *v25; // r8
  char *v26; // r7
  char *v27; // r10
  char *v28; // r9
  int v29; // r3
  _DWORD *v30; // r0
  bool v31; // zf
  bool v32; // zf
  bool v33; // zf
  double v34; // d16
  size_t v35; // r11
  size_t v36; // r0
  int v37; // r11
  size_t v38; // r6
  size_t v39; // r0
  size_t v40; // r1
  char *v41; // r0
  __int64 v42; // r2
  const char *v43; // r3
  int v44; // r6
  _DWORD *v45; // r0
  const char *v46; // r8
  const char *v47; // r10
  char *v48; // r9
  char *v49; // r1
  const char *v50; // r2
  const char *v51; // r3
  int v52; // r0
  int v53; // r0
  unsigned __int8 *v54; // r0
  unsigned __int8 *v55; // r6
  unsigned int v56; // r11
  unsigned int v57; // r12
  unsigned int v58; // lr
  unsigned int v59; // r3
  unsigned int v60; // r1
  unsigned int v61; // r9
  unsigned int v62; // r7
  _DWORD *v63; // r0
  _DWORD *v64; // r0
  _DWORD *v65; // r0
  _DWORD *v66; // r0
  int v67; // r0
  void *v68; // r0
  int v69; // r3
  void *v70; // r0
  int v71; // r3
  int *v72; // r0
  int *v73; // r0
  int *v74; // r0
  int *v75; // r0
  int *v76; // r0
  int *v77; // r0
  int *v78; // r0
  int *v79; // r0
  size_t maxlen; // [sp+1Ch] [bp-2228h]
  char *v81; // [sp+20h] [bp-2224h]
  char *v82; // [sp+24h] [bp-2220h]
  char *v83; // [sp+28h] [bp-221Ch]
  _BOOL4 v84; // [sp+2Ch] [bp-2218h]
  pthread_mutex_t *v85; // [sp+30h] [bp-2214h]
  pthread_rwlock_t *rwlock; // [sp+34h] [bp-2210h]
  int v87; // [sp+3Ch] [bp-2208h] BYREF
  char *v88; // [sp+40h] [bp-2204h] BYREF
  int v89[23]; // [sp+44h] [bp-2200h] BYREF
  char v90[160]; // [sp+A0h] [bp-21A4h] BYREF
  unsigned int v91[64]; // [sp+140h] [bp-2104h] BYREF
  char s[8192]; // [sp+240h] [bp-2004h] BYREF

  if ( !a2 )
    return 0;
  v5 = sub_565E8(a2, 0, (char *)v89);
  v6 = v5;
  if ( !v5 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      v13 = 0;
      snprintf(s, 0x1000u, "JSON decode failed(%d): %s", v89[0], v90);
      sub_385C8(7, s, 0);
      return v13;
    }
    return 0;
  }
  v7 = (_DWORD *)sub_571D8(v5, "method");
  if ( !v7 )
    goto LABEL_22;
  v8 = (_DWORD *)sub_571D8(v6, "error");
  v9 = (_DWORD *)sub_571D8(v6, "params");
  if ( v8 && *v8 != 7 )
  {
    v10 = (const char *)sub_54C0C(v8, 3);
    v11 = v10;
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "JSON-RPC method decode failed: %s", v10);
      sub_385C8(7, s, 0);
    }
    v12 = (char *)v11;
    v13 = 0;
    free(v12);
    goto LABEL_8;
  }
  v17 = (const char *)sub_57530(v7);
  v18 = v17;
  if ( !v17 )
    goto LABEL_22;
  if ( !strncasecmp(v17, "mining.notify", 0xDu) )
  {
    v25 = sub_2924C(v9, 0);
    v81 = sub_2924C(v9, 1u);
    v26 = sub_2924C(v9, 2u);
    v27 = sub_2924C(v9, 3u);
    v28 = sub_2924C(v9, 4u);
    v82 = sub_2924C(v9, 5u);
    v83 = sub_2924C(v9, 6u);
    if ( sub_573C0(v9, 7u) )
    {
      v30 = sub_573C0(v9, 7u);
      v29 = *v30 - 5;
      v84 = *v30 == 5;
    }
    else
    {
      v84 = 0;
    }
    v31 = v25 == 0;
    if ( v25 )
      v31 = v26 == 0;
    if ( v31 )
    {
      if ( !v25 )
      {
LABEL_140:
        if ( v26 )
          free(v26);
        if ( v28 )
          free(v28);
        if ( v27 )
          free(v27);
        if ( v81 )
          free(v81);
        if ( v83 )
          free(v83);
        v44 = 0;
        if ( v82 )
          free(v82);
        goto LABEL_130;
      }
    }
    else
    {
      v32 = v27 == 0;
      if ( v27 )
        v32 = v28 == 0;
      if ( !v32 )
      {
        v33 = v81 == 0;
        if ( v81 )
          v33 = v83 == 0;
        if ( !v33 && v82 )
        {
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            strcpy(s, "Valid Notify\n");
            sub_385C8(7, s, 0);
          }
          v85 = (pthread_mutex_t *)(a1 + 61);
          if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
            sub_B650("parse_notify_equihash", 2142);
          rwlock = (pthread_rwlock_t *)(a1 + 67);
          if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
          {
            v75 = _errno_location();
            snprintf(
              s,
              0x1000u,
              "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
              *v75,
              "util.c",
              "parse_notify_equihash",
              2142);
            sub_385C8(3, s, 1);
            sub_16BE0(1);
          }
          free((void *)a1[168]);
          free((void *)a1[169]);
          free((void *)a1[171]);
          free((void *)a1[172]);
          free((void *)a1[173]);
          a1[168] = v25;
          a1[169] = v26;
          a1[171] = v81;
          a1[172] = v83;
          a1[173] = v82;
          *((_BYTE *)a1 + 696) = v84;
          v34 = *((double *)a1 + 231);
          if ( v34 > 0.0 )
            *((double *)a1 + 89) = v34;
          if ( v84 )
            *((_QWORD *)a1 + 81) = 0;
          v35 = strlen(v81);
          v36 = strlen(v26);
          a1[464] = v36 + v35;
          v37 = (int)(v36 + v35) / 2;
          v38 = strlen(v82);
          v39 = strlen(v83);
          a1[464] = v37;
          v31 = byte_75C49 == 0;
          v40 = 2 * ((v39 >> 1) + (v38 >> 1) + 84 + v37) + 1;
          a1[176] = v40;
          if ( !v31 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(s, 0x1000u, "%s: pool->swork.header_len = %d", "parse_notify_equihash", v40);
            sub_385C8(7, s, 0);
            v40 = a1[176];
          }
          if ( (v40 & 3) != 0 )
          {
            v40 = (v40 & 0xFFFFFFFC) + 4;
            a1[176] = v40;
          }
          maxlen = v40;
          v41 = (char *)malloc(v40);
          v2 = v41;
          if ( !v41 )
          {
            snprintf(
              s,
              0x1000u,
              "%s: Failed to malloc header. in %s %s():%d",
              "parse_notify_equihash",
              "util.c",
              "parse_notify_equihash",
              2188);
            sub_385C8(3, s, 1);
            sub_16BE0(1);
          }
          snprintf(
            v41,
            maxlen,
            "%s%s%s%s%s%s%s",
            (const char *)a1[171],
            (const char *)a1[169],
            v27,
            v28,
            (const char *)a1[173],
            (const char *)a1[172],
            "0000000000000000000000000000000000000000");
          if ( sub_29788((_BYTE *)a1 + 1604, (unsigned __int8 *)v2, 128) )
          {
            v42 = *(_QWORD *)&dword_78470;
            ++a1[37];
            *(_QWORD *)&dword_78470 = v42 + 1;
            if ( pthread_rwlock_unlock(rwlock) )
            {
              v74 = _errno_location();
              snprintf(
                s,
                0x1000u,
                "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v74,
                "util.c",
                "parse_notify_equihash",
                2214);
              sub_385C8(3, s, 1);
              sub_16BE0(1);
            }
            sub_292E0(v85, "parse_notify_equihash", 2214);
            off_72D18();
            if ( a1 == (_DWORD *)sub_1D9A0() )
              byte_786D4 = 1;
            v29 = (unsigned __int8)byte_781A8;
            if ( !byte_781A8 )
              goto LABEL_129;
            v29 = (unsigned __int8)byte_75C49;
            if ( !byte_75C49 )
              goto LABEL_129;
            if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
            {
              snprintf(s, 0x1000u, "job_id: %s", v25);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
                goto LABEL_105;
            }
            if ( byte_75C48 || dword_73504 > 6 )
            {
LABEL_105:
              snprintf(s, 0x1000u, "version: %s", v81);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
                goto LABEL_109;
            }
            if ( byte_75C48 || dword_73504 > 6 )
            {
LABEL_109:
              snprintf(s, 0x1000u, "prev_hash: %s", v26);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
                goto LABEL_113;
            }
            if ( byte_75C48 || dword_73504 > 6 )
            {
LABEL_113:
              snprintf(s, 0x1000u, "merkle: %s", v27);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
                goto LABEL_117;
            }
            if ( byte_75C48 || dword_73504 > 6 )
            {
LABEL_117:
              snprintf(s, 0x1000u, "reserved: %s", v28);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
                goto LABEL_121;
            }
            if ( byte_75C48 || dword_73504 > 6 )
            {
LABEL_121:
              snprintf(s, 0x1000u, "nbit: %s", v83);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
                goto LABEL_218;
            }
            if ( byte_75C48 || dword_73504 > 6 )
            {
LABEL_218:
              snprintf(s, 0x1000u, "ntime: %s", v82);
              sub_385C8(7, s, 0);
              v29 = (unsigned __int8)byte_75C49;
              if ( !byte_75C49 )
                goto LABEL_129;
              if ( byte_77B70 )
              {
LABEL_126:
                v43 = "yes";
                if ( !v84 )
                  v43 = dword_63494;
                snprintf(s, 0x1000u, "clean: %s", v43);
                sub_385C8(7, s, 0);
                goto LABEL_129;
              }
            }
            if ( byte_75C48 )
              goto LABEL_126;
            v29 = dword_73504;
            if ( dword_73504 > 6 )
              goto LABEL_126;
LABEL_129:
            v44 = 1;
LABEL_130:
            if ( v2 )
              free(v2);
            if ( v44 )
              v29 = 1;
            else
              *((_BYTE *)a1 + 667) = 0;
            if ( v44 )
            {
              *((_BYTE *)a1 + 667) = v29;
              v13 = v29;
            }
            else
            {
              v13 = 0;
            }
            goto LABEL_8;
          }
          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
          {
            snprintf(s, 0x1000u, "%s: Failed to convert header to header_bin, got %s", "parse_notify_equihash", v2);
            sub_385C8(4, s, 0);
          }
          sub_29264(rwlock, "parse_notify_equihash", 2205);
          sub_292E0(v85, "parse_notify_equihash", 2205);
          off_72D18();
          sub_1FA8C((int)a1);
        }
      }
    }
    free(v25);
    goto LABEL_140;
  }
  if ( !strncasecmp(v18, "mining.set_extranonce", 0x15u) )
  {
    v13 = sub_29904((int)a1, v9, 0);
    goto LABEL_8;
  }
  if ( !strncasecmp(v18, "mining.set_difficulty", 0x15u) )
  {
    v23 = sub_573C0(v9, 0);
    sub_57730((int)v23);
    if ( v3 == 0.0 )
    {
      v13 = 0;
      goto LABEL_8;
    }
    if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
      sub_B650("parse_diff", 2464);
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v79 = _errno_location();
      snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v79, "util.c", "parse_diff", 2464);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    v24 = *((double *)a1 + 230);
    *((double *)a1 + 230) = v3;
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 67)) )
    {
      v77 = _errno_location();
      snprintf(s, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v77, "util.c", "parse_diff", 2467);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
    {
      v76 = _errno_location();
      snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v76, "util.c", "parse_diff", 2467);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    off_72D18();
    if ( v3 == v24 )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        v71 = *a1;
        v13 = 1;
        snprintf(s, 0x1000u, "Pool %d difficulty set to %f", v71, v3);
        sub_385C8(7, s, 0);
        goto LABEL_8;
      }
      goto LABEL_60;
    }
    if ( v3 == (double)(int)v3 )
    {
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_60;
      snprintf(s, 0x1000u, "Pool %d difficulty changed to %d", *a1, (int)v3);
    }
    else
    {
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_60;
      snprintf(s, 0x1000u, "Pool %d difficulty changed to %.1f", *a1, v3);
    }
    goto LABEL_59;
  }
  if ( !strncasecmp(v18, "client.reconnect", 0x10u) )
  {
    memset(v91, 0, 0xFFu);
    v45 = sub_573C0(v9, 0);
    v46 = (const char *)sub_57530(v45);
    if ( !v46 )
    {
      v46 = (const char *)a1[156];
      goto LABEL_184;
    }
    v47 = (const char *)a1[156];
    v48 = strchr(v47, 46);
    if ( v48 )
    {
      v49 = strchr(v46, 46);
      if ( v49 )
      {
        if ( !strcmp(v48, v49) )
        {
LABEL_184:
          v65 = sub_573C0(v9, 1u);
          v66 = sub_57530(v65);
          if ( !v66 )
            v66 = (_DWORD *)a1[152];
          snprintf((char *)v91, 0xFEu, "%s:%s", v46, v66);
          if ( sub_2AAAC((const char *)v91, &v87, &v88) )
          {
            if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
            {
              snprintf(s, 0x1000u, "Stratum reconnect requested from pool %d to %s", *a1, (const char *)v91);
              sub_385C8(4, s, 0);
            }
            sub_1922C(a1);
            if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 182)) )
              sub_B650("parse_reconnect", 2622);
            sub_28A40((int)a1);
            v67 = a1[153];
            *((_BYTE *)a1 + 667) = 0;
            *((_BYTE *)a1 + 665) = 0;
            if ( v67 )
              close(v67);
            v68 = (void *)a1[156];
            v69 = v87;
            a1[153] = 0;
            a1[150] = v69;
            a1[156] = v69;
            free(v68);
            v70 = (void *)a1[152];
            a1[152] = v88;
            free(v70);
            if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 182)) )
            {
              v78 = _errno_location();
              snprintf(
                s,
                0x1000u,
                "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                *v78,
                "util.c",
                "parse_reconnect",
                2631);
              sub_385C8(3, s, 1);
              sub_16BE0(1);
            }
            off_72D18();
            v13 = sub_2CE20(a1);
            goto LABEL_8;
          }
          goto LABEL_22;
        }
        if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
          goto LABEL_22;
        v50 = "Denied stratum reconnect request to non-matching domain url '%s'";
        v51 = v47;
      }
      else
      {
        if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
          goto LABEL_22;
        v51 = v46;
        v50 = "Denied stratum reconnect request to url without domain '%s'";
      }
    }
    else
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
        goto LABEL_22;
      v51 = v47;
      v50 = "Denied stratum reconnect request for pool without domain '%s'";
    }
    v13 = 0;
    snprintf(s, 0x1000u, v50, v51);
    sub_385C8(3, s, 0);
    goto LABEL_8;
  }
  if ( !strncasecmp(v18, "client.get_version", 0x12u) )
  {
    v22 = sub_571D8(v6, "id");
    if ( !v22 )
      goto LABEL_43;
    v52 = sub_571D8(v6, "id");
    v53 = sub_57600(v52);
    sprintf(s, "{\"id\": %d, \"result\": \"cgminer/4.9.0\", \"error\": null}", v53);
LABEL_42:
    v21 = strlen(s);
    v22 = sub_2B520((int)a1, s, v21);
LABEL_43:
    v13 = v22;
    goto LABEL_8;
  }
  if ( !strncasecmp(v18, "client.show_message", 0x13u) )
  {
    if ( !v9 )
      goto LABEL_22;
    if ( *v9 != 1 )
      goto LABEL_22;
    v63 = sub_573C0(v9, 0);
    v64 = sub_57530(v63);
    if ( !v64 )
      goto LABEL_22;
    if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
    {
LABEL_60:
      v13 = 1;
      goto LABEL_8;
    }
    snprintf(s, 0x1000u, "Pool %d message: %s", *a1, v64);
LABEL_59:
    sub_385C8(7, s, 0);
    goto LABEL_60;
  }
  if ( !strncasecmp(v18, "mining.ping", 0xBu) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "Pool %d ping", *a1);
      sub_385C8(7, s, 0);
    }
    if ( sub_571D8(v6, "id") )
    {
      v19 = sub_571D8(v6, "id");
      v20 = sub_57600(v19);
      sprintf(s, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v20);
      goto LABEL_42;
    }
  }
  else if ( !strncasecmp(v18, "mining.set_target", 0x11u) )
  {
    v54 = (unsigned __int8 *)sub_2924C(v9, 0);
    v55 = v54;
    if ( v54 )
    {
      sub_29788(v91, v54, 32);
      if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 61)) )
        sub_B650("parse_target", 2695);
      if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 67)) )
      {
        v73 = _errno_location();
        snprintf(s, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v73, "util.c", "parse_target", 2695);
        sub_385C8(3, s, 1);
        sub_16BE0(1);
      }
      v56 = bswap32(v91[7]);
      v57 = v91[4];
      v58 = bswap32(v91[6]);
      v59 = v91[3];
      v60 = bswap32(v91[5]);
      a1[25] = bswap32(v91[0]);
      v61 = v91[2];
      v62 = v91[1];
      a1[19] = v58;
      a1[20] = v60;
      a1[21] = bswap32(v57);
      a1[22] = bswap32(v59);
      a1[18] = v56;
      a1[23] = bswap32(v61);
      a1[24] = bswap32(v62);
      sub_29264((pthread_rwlock_t *)(a1 + 67), "parse_target", 2698);
      if ( pthread_mutex_unlock((pthread_mutex_t *)(a1 + 61)) )
      {
        v72 = _errno_location();
        snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v72, "util.c", "parse_target", 2698);
        sub_385C8(3, s, 1);
        sub_16BE0(1);
      }
      v13 = 1;
      off_72D18();
      free(v55);
      goto LABEL_8;
    }
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      strcpy(s, "parse_target: Missing an array value.");
      sub_385C8(7, s, 0);
    }
  }
LABEL_22:
  v13 = 0;
LABEL_8:
  v14 = v6[1];
  if ( v14 != -1 )
  {
    v15 = v14 - 1;
    v6[1] = v15;
    if ( !v15 )
      sub_5779C((void **)v6);
  }
  return v13;
}
// 2D25C: variable 'v3' is possibly undefined
// 2D9EC: variable 'v2' is possibly undefined
// 2DA08: variable 'v29' is possibly undefined
// 2CE20: using guessed type int __fastcall sub_2CE20(_DWORD);
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 781A8: using guessed type char byte_781A8;
// 78470: using guessed type int dword_78470;
// 786D4: using guessed type char byte_786D4;

//----- (0002E50C) --------------------------------------------------------
int __fastcall sub_2E50C(int *a1)
{
  int v1; // r2
  size_t v3; // r0
  int *v4; // r5
  int v5; // r4
  int *v7; // r6
  _DWORD *v8; // r7
  _DWORD *v9; // r0
  _DWORD *v10; // r5
  const char *v11; // r7
  char *v12; // r5
  int v13; // r3
  const char *v14; // r2
  int v15; // r3
  int v16; // r3
  char v17[252]; // [sp+Ch] [bp-3100h] BYREF
  char s[4088]; // [sp+108h] [bp-3004h] BYREF
  char v19[8196]; // [sp+1108h] [bp-2004h] BYREF

  v1 = dword_77F20++;
  sprintf(v19, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v1);
  v3 = strlen(v19);
  if ( !sub_2B520((int)a1, v19, v3) )
    return 0;
  while ( 1 )
  {
    if ( !sub_28A54((int)a1, 2) )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        strcpy(s, "Timed out waiting for response extranonce.subscribe");
        sub_385C8(7, s, 0);
      }
      return 1;
    }
    v4 = (int *)sub_2AF98((int)a1);
    if ( !v4 )
      return 0;
    if ( !sub_2CE98(a1, v4) )
      break;
    free(v4);
  }
  v7 = sub_565E8(v4, 0, v17);
  free(v4);
  v8 = (_DWORD *)sub_571D8(v7, "result");
  v9 = (_DWORD *)sub_571D8(v7, "error");
  v10 = v9;
  if ( !v8 || *v8 == 6 )
  {
    if ( !v9 )
    {
      v12 = (char *)malloc(0x11u);
      if ( v12 )
        strcpy(v12, "(unknown reason)");
      goto LABEL_22;
    }
    goto LABEL_18;
  }
  if ( v9 && *v9 != 7 )
  {
LABEL_18:
    v11 = (const char *)sub_291EC(v9, 1u);
    if ( !v11 && (v11 = (const char *)sub_57530(v10)) == 0
      || strcmp(v11, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v11, "Unrecognized request provided") )
    {
      v12 = (char *)sub_54C0C(v10, 3);
LABEL_22:
      if ( byte_77B70 || byte_75C48 || dword_73504 > 5 )
      {
        snprintf(s, 0x1000u, "Pool %d JSON extranonce subscribe failed: %s", *a1, v12);
        sub_385C8(6, s, 0);
      }
      v5 = 0;
      free(v12);
      goto LABEL_31;
    }
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 5 )
      goto LABEL_41;
    v13 = *a1;
    v14 = "Cannot subscribe to mining.extranonce for pool %d";
    goto LABEL_30;
  }
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 5 )
  {
LABEL_41:
    v5 = 1;
    goto LABEL_31;
  }
  v13 = *a1;
  v14 = "Stratum extranonce subscribe for pool %d";
LABEL_30:
  v5 = 1;
  snprintf(s, 0x1000u, v14, v13);
  sub_385C8(6, s, 0);
LABEL_31:
  if ( v7 )
  {
    v15 = v7[1];
    if ( v15 != -1 )
    {
      v16 = v15 - 1;
      v7[1] = v16;
      if ( !v16 )
        sub_5779C((void **)v7);
    }
  }
  return v5;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77F20: using guessed type int dword_77F20;

//----- (0002E8A8) --------------------------------------------------------
int __fastcall sub_2E8A8(_DWORD *a1)
{
  const char *v1; // r12
  const char *v3; // r3
  int v4; // r2
  size_t v5; // r0
  int *v6; // r4
  int v7; // r4
  int *v9; // r7
  _DWORD *v10; // r4
  _DWORD *v11; // r0
  char *v12; // r4
  char *v13; // r0
  int v14; // r3
  int v15; // r3
  int v16; // r2
  size_t v17; // r0
  int v18; // r2
  size_t v19; // r0
  char v20[252]; // [sp+Ch] [bp-3100h] BYREF
  char s[4088]; // [sp+108h] [bp-3004h] BYREF
  char v22[8196]; // [sp+1108h] [bp-2004h] BYREF

  v1 = (const char *)a1[52];
  v3 = (const char *)a1[51];
  v4 = dword_77F20++;
  sprintf(v22, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v4, v3, v1);
  v5 = strlen(v22);
  if ( sub_2B520((int)a1, v22, v5) )
  {
    while ( 1 )
    {
      v6 = (int *)sub_2AF98((int)a1);
      if ( !v6 )
        return 0;
      if ( !sub_2CE98(a1, v6) )
        break;
      free(v6);
    }
    v9 = sub_565E8(v6, 0, v20);
    free(v6);
    v10 = (_DWORD *)sub_571D8(v9, "result");
    v11 = (_DWORD *)sub_571D8(v9, "error");
    if ( !v10 || *v10 == 6 )
    {
      if ( !v11 )
      {
        v12 = (char *)malloc(0x11u);
        if ( v12 )
          strcpy(v12, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v11 || *v11 == 7 )
    {
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(s, 0x1000u, "Stratum authorisation success for pool %d", *a1);
        sub_385C8(7, s, 0);
      }
      *((_BYTE *)a1 + 131) = 1;
      byte_75AE8 = 1;
      if ( dword_7894C )
      {
        v18 = dword_77F20++;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v18, dword_7894C);
        v19 = strlen(v22);
        sub_2B520((int)a1, v22, v19);
      }
      if ( dword_72CF4 )
      {
        v16 = dword_77F20++;
        sprintf(v22, "{\"id\": %d, \"method\": \"mining.multi_version\", \"params\": [%d]}", v16, dword_72CF4);
        v7 = 1;
        v17 = strlen(v22);
        sub_2B520((int)a1, v22, v17);
      }
      else
      {
        v7 = 1;
      }
      goto LABEL_18;
    }
    v12 = (char *)sub_54C0C(v11, 3);
LABEL_13:
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "pool %d JSON stratum auth failed: %s", *a1, v12);
      sub_385C8(7, s, 0);
    }
    v13 = v12;
    v7 = 0;
    free(v13);
    sub_2AE38((int)a1);
LABEL_18:
    if ( v9 )
    {
      v14 = v9[1];
      if ( v14 != -1 )
      {
        v15 = v14 - 1;
        v9[1] = v15;
        if ( !v15 )
          sub_5779C((void **)v9);
      }
    }
    return v7;
  }
  return 0;
}
// 72CF4: using guessed type int dword_72CF4;
// 73504: using guessed type int dword_73504;
// 75AE8: using guessed type char byte_75AE8;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 77F20: using guessed type int dword_77F20;
// 7894C: using guessed type int dword_7894C;

//----- (0002EBF8) --------------------------------------------------------
time_t __fastcall sub_2EBF8(_DWORD *a1, int a2)
{
  time_t result; // r0

  result = time(0);
  a1[62] = a2;
  a1[61] = result;
  switch ( a2 )
  {
    case 0:
      ++a1[63];
      break;
    case 1:
      ++a1[64];
      break;
    case 2:
      ++a1[65];
      break;
    case 3:
      ++a1[66];
      break;
    case 4:
      ++a1[67];
      break;
    case 5:
      ++a1[68];
      break;
    case 6:
      ++a1[69];
      break;
    case 7:
      ++a1[70];
      break;
    case 8:
      ++a1[71];
      break;
    case 9:
      ++a1[72];
      break;
    default:
      return result;
  }
  return result;
}
// 2EC1C: control flows out of bounds to 2EC20

//----- (0002EDD4) --------------------------------------------------------
char *__fastcall sub_2EDD4(const char *a1)
{
  const char *v1; // r4
  size_t v2; // r0
  char *v3; // r0
  char *v4; // r6
  char *v5; // r5
  char v6; // r3
  int v7; // r2
  int v8; // t1
  char *v10; // r3
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v1 = a1;
  if ( !a1 )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(s, 0x1000u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3711);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(v1);
  v3 = (char *)malloc(4 * v2 + 5);
  v4 = v3;
  if ( !v3 )
  {
    snprintf(s, 0x1000u, "Failed to malloc txt in %s %s():%d", "util.c", "str_text", 3718);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v5 = v3;
  do
  {
    while ( 1 )
    {
      v8 = *(unsigned __int8 *)v1++;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) <= 0x5E )
        break;
      sprintf(v5, "0x%02x", v7);
      v6 = *(v1 - 1);
      v5 += 4;
      if ( !v6 )
        goto LABEL_9;
    }
    *v5++ = v7;
    v6 = *(v1 - 1);
  }
  while ( v6 );
LABEL_9:
  *v5 = v6;
  return v4;
}

//----- (0002EF24) --------------------------------------------------------
int __fastcall sub_2EF24(const char *a1)
{
  char s[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(s, 0x10u, "cg@%s", a1);
  return prctl(15, s, 0);
}

//----- (0002EF64) --------------------------------------------------------
int __fastcall sub_2EF64(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v8; // r7
  int *v9; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = sem_init(a1, 0, 0);
  v8 = result;
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x1000u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, a2, a3, a4);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (0002EFE4) --------------------------------------------------------
int __fastcall sub_2EFE4(int a1, const pthread_attr_t *a2, void *(*a3)(void *), void *a4)
{
  sub_2EF64((sem_t *)(a1 + 16), "util.c", "thr_info_create", 1312);
  return pthread_create((pthread_t *)(a1 + 12), a2, a3, a4);
}

//----- (0002F02C) --------------------------------------------------------
int __fastcall sub_2F02C(sem_t *a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int *v9; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = sem_post(a1);
  if ( result )
  {
    v9 = _errno_location();
    snprintf(s, 0x1000u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v9, a1, a2, a3, a4);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (0002F0AC) --------------------------------------------------------
void *__fastcall sub_2F0AC(sem_t *a1)
{
  pthread_setcanceltype(1, 0);
  ((void (__fastcall *)(_DWORD))a1[1].__align)(*(&a1[1].__align + 1));
  sub_2F02C(a1, "util.c", "completion_thread", 3944);
  return 0;
}

//----- (0002F0F0) --------------------------------------------------------
int __fastcall sub_2F0F0(sem_t *sem, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v9; // r3
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  while ( 1 )
  {
    result = sem_wait(sem);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 != 4 )
    {
      snprintf(s, 0x1000u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v9, sem, a2, a3, a4);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
  }
  return result;
}

//----- (0002F174) --------------------------------------------------------
int __fastcall sub_2F174(sem_t *a1, int a2, const char *a3, const char *a4, int a5)
{
  int result; // r0
  int v9; // r3
  struct timespec abstime; // [sp+10h] [bp-101Ch] BYREF
  _DWORD v11[2]; // [sp+18h] [bp-1014h] BYREF
  struct timeval v12; // [sp+20h] [bp-100Ch] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  sub_2A7A4(&v12);
  v11[1] = 1000 * v12.tv_usec;
  v11[0] = v12.tv_sec;
  sub_2A558(&abstime);
  while ( 1 )
  {
    sub_2A5E0(&abstime.tv_sec, v11);
    result = sem_timedwait(a1, &abstime);
    if ( !result )
      break;
    v9 = *_errno_location();
    if ( v9 == 110 )
      return 110;
    if ( v9 != 4 )
    {
      snprintf(s, 0x1000u, "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d", v9, a1, a3, a4, a5);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
  }
  return result;
}

//----- (0002F270) --------------------------------------------------------
int *__fastcall sub_2F270(sem_t *sem)
{
  int *result; // r0

  do
  {
    while ( 1 )
    {
      result = (int *)sem_trywait(sem);
      if ( (int)result < 0 )
        break;
      if ( result )
        return result;
    }
    result = _errno_location();
  }
  while ( *result == 4 );
  return result;
}

//----- (0002F2A8) --------------------------------------------------------
int __fastcall sub_2F2A8(int a1, int a2, int a3)
{
  sem_t *v6; // r0
  sem_t *v7; // r4
  _BOOL4 v8; // r5
  pthread_t newthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (sem_t *)malloc(0x18u);
  v7 = v6;
  if ( !v6 )
    return 0;
  sub_2EF64(v6, "util.c", "cg_completion_timeout", 3958);
  v7[1].__align = a1;
  *(&v7[1].__align + 1) = a2;
  pthread_create(newthread, 0, (void *(*)(void *))sub_2F0AC, v7);
  v8 = sub_2F174(v7, a3, "util.c", "cg_completion_timeout", 3964) != 0;
  if ( v8 )
  {
    pthread_cancel(newthread[0]);
  }
  else
  {
    pthread_join(newthread[0], 0);
    free(v7);
  }
  return !v8;
}

//----- (0002F4BC) --------------------------------------------------------
int __fastcall sub_2F4BC(int a1, char a2)
{
  int v3; // r1
  unsigned int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1
  unsigned int v7; // r1

  switch ( a1 )
  {
    case 1:
      return 1;
    case 2:
      if ( (a2 & 0x80) == 0 )
        return 1;
      return 2;
    case 4:
      v3 = a2 & 0xC0;
      switch ( v3 )
      {
        case 128:
          return 3;
        case 192:
          return 4;
        case 64:
          return 2;
        default:
          return 1;
      }
    case 8:
      v4 = a2 & 0xE0;
      if ( v4 == 128 )
        return 5;
      if ( v4 > 0x80 )
      {
        if ( v4 == 192 )
          return 7;
        if ( v4 == 224 )
          return 8;
        if ( v4 != 160 )
          return 1;
        return 6;
      }
      if ( v4 == 64 )
        return 3;
      if ( v4 == 96 )
        return 4;
      if ( v4 != 32 )
        return 1;
      return 2;
    case 16:
      v5 = a2 & 0xF0;
      if ( v5 == 128 )
        return 9;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
        {
          return 5;
        }
        else if ( v5 > 0x40 )
        {
          switch ( v5 )
          {
            case '`':
              return 7;
            case 'p':
              return 8;
            case 'P':
              return 6;
            default:
              return 1;
          }
        }
        else
        {
          switch ( v5 )
          {
            case 0x20u:
              return 3;
            case 0x30u:
              return 4;
            case 0x10u:
              return 2;
            default:
              return 1;
          }
        }
      }
      else if ( v5 == 192 )
      {
        return 13;
      }
      else if ( v5 > 0xC0 )
      {
        switch ( v5 )
        {
          case 0xE0u:
            return 15;
          case 0xF0u:
            return 16;
          case 0xD0u:
            return 14;
          default:
            return 1;
        }
      }
      else
      {
        switch ( v5 )
        {
          case 0xA0u:
            return 11;
          case 0xB0u:
            return 12;
          case 0x90u:
            return 10;
          default:
            return 1;
        }
      }
    case 32:
      v6 = (unsigned __int8)((a2 & 0xF8) - 8);
      if ( v6 > 0xF0 )
        return 1;
      return aClearSock[v6 + 1928];
    case 64:
      v7 = (unsigned __int8)((a2 & 0xFC) - 4);
      if ( v7 > 0xF8 )
        return 1;
      return aClearSock[v7 + 2172];
    default:
      return 0;
  }
}
// 2F4C8: control flows out of bounds to 2F4CC

//----- (0002F7A4) --------------------------------------------------------
void __fastcall sub_2F7A4(_DWORD *a1, char *a2, int a3)
{
  int v4; // r12
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  _DWORD *v11; // lr
  int v12; // r1
  int v13; // r2
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int v17; // r1
  int v18; // r2
  int v19; // r3
  char v20; // r3
  _DWORD *v21; // r2
  int i; // r3
  char v23; // r1
  _DWORD *v24; // r2
  int j; // r3
  char v26; // r1
  unsigned int *v27; // r2
  int k; // r3
  char v29; // r1
  char *v30; // r8
  char *v31; // r5
  char *v32; // r4
  char *v33; // r10
  char *v34; // r7
  char *v35; // r6
  __int64 v36; // kr00_8
  size_t v37; // r0
  bool v38; // zf
  unsigned __int64 v39; // r2
  int m; // r11
  size_t v41; // r0
  size_t v42; // r0
  size_t v43; // r0
  int v44; // r11
  size_t v45; // r0
  size_t v46; // r0
  _DWORD v49[8]; // [sp+30h] [bp-14B4h] BYREF
  _DWORD v50[2]; // [sp+50h] [bp-1494h] BYREF
  int v51; // [sp+58h] [bp-148Ch]
  int v52; // [sp+5Ch] [bp-1488h]
  int v53; // [sp+60h] [bp-1484h]
  int v54; // [sp+64h] [bp-1480h]
  int v55; // [sp+68h] [bp-147Ch]
  int v56; // [sp+6Ch] [bp-1478h]
  _DWORD v57[8]; // [sp+70h] [bp-1474h] BYREF
  unsigned int v58[20]; // [sp+90h] [bp-1454h] BYREF
  char s[1024]; // [sp+E0h] [bp-1404h] BYREF
  char v60[4064]; // [sp+4E0h] [bp-1004h] BYREF

  if ( dword_73A20 )
  {
    memset(s, 0, sizeof(s));
    v51 = 0;
    v52 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    memset(v58, 0, sizeof(v58));
    v4 = 0;
    v5 = a1[33];
    v6 = a1[34];
    v7 = a1[35];
    v49[0] = a1[32];
    v49[1] = v5;
    v49[2] = v6;
    v49[3] = v7;
    v8 = a1[37];
    v9 = a1[38];
    v10 = a1[39];
    v49[4] = a1[36];
    v49[5] = v8;
    v49[6] = v9;
    v49[7] = v10;
    v11 = v49;
    v12 = a1[17];
    v13 = a1[18];
    v50[0] = a1[16];
    v50[1] = v12;
    v51 = v13;
    v14 = a1[49];
    v15 = a1[50];
    v16 = a1[51];
    v57[0] = a1[48];
    v57[1] = v14;
    v57[2] = v15;
    v57[3] = v16;
    v17 = a1[53];
    v18 = a1[54];
    v19 = a1[55];
    v57[4] = a1[52];
    v57[5] = v17;
    v57[6] = v18;
    v57[7] = v19;
    do
    {
      v20 = *((_BYTE *)v49 + v4);
      *((_BYTE *)v49 + v4++) = *((_BYTE *)v11 + 31);
      *((_BYTE *)v11 + 31) = v20;
      v11 = (_DWORD *)((char *)v11 - 1);
    }
    while ( v4 != 16 );
    v21 = v50;
    for ( i = 0; i != 6; ++i )
    {
      v23 = *((_BYTE *)v50 + i);
      *((_BYTE *)v50 + i) = *((_BYTE *)v21 + 11);
      *((_BYTE *)v21 + 11) = v23;
      v21 = (_DWORD *)((char *)v21 - 1);
    }
    v24 = v57;
    for ( j = 0; j != 16; ++j )
    {
      v26 = *((_BYTE *)v57 + j);
      *((_BYTE *)v57 + j) = *((_BYTE *)v24 + 31);
      *((_BYTE *)v24 + 31) = v26;
      v24 = (_DWORD *)((char *)v24 - 1);
    }
    if ( byte_78681 )
    {
      memcpy(v58, a1, sizeof(v58));
      v27 = v58;
      for ( k = 0; k != 40; ++k )
      {
        v29 = *((_BYTE *)v58 + k);
        *((_BYTE *)v58 + k) = *((_BYTE *)v27 + 79);
        *((_BYTE *)v27 + 79) = v29;
        v27 = (unsigned int *)((char *)v27 - 1);
      }
      v58[0] = bswap32(16 * bswap32(v58[0]));
      v30 = sub_29688((int)v58, 80);
    }
    else
    {
      v30 = sub_29688((int)a1, 128);
    }
    v31 = sub_29688((int)v49, 32);
    v32 = sub_29688((int)v50, 12);
    v33 = sub_29688((int)a2, 4);
    v34 = sub_29688((int)a2, 5);
    v35 = sub_29688((int)v57, 32);
    v36 = sub_1581C((__int64 *)a1);
    if ( !strcmp((const char *)dword_73A20, "screen") )
    {
      if ( a3 )
      {
        sprintf(s, "work %s nonce %s", v30, v33);
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf(v60, 0x1000u, s);
          sub_385C8(3, v60, 0);
        }
        v43 = strlen(s);
        fwrite(s, v43, 1u, (FILE *)dword_75790);
        fwrite(ptr, 1u, 1u, (FILE *)dword_75790);
        fflush((FILE *)dword_75790);
      }
    }
    else
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        snprintf(v60, 0x1000u, s);
        sub_385C8(3, v60, 0);
      }
      if ( dword_75790 )
      {
        if ( a3 )
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
            "o",
            a1[457],
            v30,
            v31,
            v32,
            v34,
            v35,
            v36);
          v37 = strlen(s);
          fwrite(s, v37, 1u, (FILE *)dword_75790);
          fwrite(ptr, 1u, 1u, (FILE *)dword_75790);
          fflush((FILE *)dword_75790);
          if ( dword_7578C == 1 )
          {
            sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
            v46 = strlen(s);
            fwrite(s, v46, 1u, (FILE *)dword_75794[0]);
            fwrite(ptr, 1u, 1u, (FILE *)dword_75794[0]);
            fflush((FILE *)dword_75794[0]);
          }
          else
          {
            v38 = dword_7578C == 32;
            if ( dword_7578C != 32 )
              v38 = dword_7578C == 64;
            if ( v38 )
            {
              sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
              v44 = sub_2F4BC(dword_7578C, *a2);
              v45 = strlen(s);
              fwrite(s, v45, 1u, (FILE *)dword_75794[v44]);
              fwrite(ptr, 1u, 1u, (FILE *)dword_75794[v44]);
              fflush((FILE *)dword_75794[v44]);
            }
          }
          if ( byte_75898 )
          {
            v39 = v36;
            for ( m = 0; m != 64; ++m )
            {
              v39 >>= 1;
              if ( !v39 )
                break;
            }
            if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
            {
              snprintf(v60, 0x1000u, "work diff %lld diffnum %d", v36, m);
              sub_385C8(7, v60, 0);
            }
            sprintf(s, "midstate %s data %s nonce %s hash %s", v31, v32, v33, v35);
            v41 = strlen(s);
            fwrite(s, v41, 1u, *((FILE **)&unk_7589C + m));
            fwrite(ptr, 1u, 1u, *((FILE **)&unk_7589C + m));
            fflush(*((FILE **)&unk_7589C + m));
          }
        }
        else
        {
          sprintf(
            s,
            "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
            "x",
            a1[457],
            v30,
            v31,
            v32,
            v34,
            v35,
            v36);
          v42 = strlen(s);
          fwrite(s, v42, 1u, (FILE *)dword_75790);
          fwrite(ptr, 1u, 1u, (FILE *)dword_75790);
          fflush((FILE *)dword_75790);
        }
      }
    }
    if ( v30 )
      free(v30);
    if ( v31 )
      free(v31);
    if ( v32 )
      free(v32);
    if ( v33 )
      free(v33);
    if ( v34 )
      free(v34);
    if ( v35 )
      free(v35);
  }
}
// 73504: using guessed type int dword_73504;
// 73A20: using guessed type int dword_73A20;
// 7578C: using guessed type int dword_7578C;
// 75790: using guessed type int dword_75790;
// 75794: using guessed type int dword_75794[];
// 75898: using guessed type char byte_75898;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78681: using guessed type char byte_78681;

//----- (0002FEE4) --------------------------------------------------------
void __fastcall sub_2FEE4(_DWORD *a1, int a2, int a3)
{
  int v3; // [sp+0h] [bp-Ch] BYREF
  char v4; // [sp+4h] [bp-8h]

  if ( dword_73A20 )
  {
    v4 = 0;
    v3 = a2;
    sub_2F7A4(a1, (char *)&v3, a3);
  }
}
// 73A20: using guessed type int dword_73A20;

//----- (0002FF20) --------------------------------------------------------
unsigned int __fastcall sub_2FF20(unsigned int result, int a2, int a3)
{
  int *v3; // r1
  int v4; // r0
  int i; // r3
  unsigned int *v6; // r2
  _DWORD *v7; // r3
  int j; // r2
  int v9; // r12
  int *v10; // r2
  unsigned int v11; // r3
  int v12; // r1
  int *v13; // r0
  int v14; // r1
  int v15; // r3
  int v16; // r5
  int v17; // r4
  int v18; // r9
  unsigned int v19; // r2
  unsigned int v20; // r12
  unsigned int v21; // r6
  int v22; // r11
  int v23; // r8
  int v24; // r7
  int v25; // r8
  unsigned int v26; // r10
  int v27; // r1
  unsigned int v28; // r3
  int *v29; // [sp+0h] [bp-138h] BYREF
  int v30; // [sp+4h] [bp-134h]
  unsigned int v31; // [sp+8h] [bp-130h]
  unsigned int v32; // [sp+Ch] [bp-12Ch]
  int v33; // [sp+10h] [bp-128h]
  int v34; // [sp+14h] [bp-124h] BYREF
  _DWORD *v35; // [sp+18h] [bp-120h]
  _DWORD *v36; // [sp+1Ch] [bp-11Ch]
  _DWORD *v37; // [sp+20h] [bp-118h]
  unsigned int v38; // [sp+24h] [bp-114h]
  int v39; // [sp+28h] [bp-110h]
  int v40; // [sp+2Ch] [bp-10Ch]
  int v41; // [sp+30h] [bp-108h]
  int v42; // [sp+34h] [bp-104h] BYREF
  _BYTE v43[256]; // [sp+38h] [bp-100h] BYREF

  v33 = a3;
  v31 = result;
  v34 = a2;
  if ( a3 > 0 )
  {
    v29 = &v42;
    v30 = 0;
    do
    {
      v3 = &v42;
      v4 = v34 + (v30 << 6);
      for ( i = 0; i != 16; ++i )
      {
        v6 = (unsigned int *)(v4 + 4 * i);
        v3[1] = _byteswap_ulong(*v6);
        ++v3;
      }
      v7 = v43;
      for ( j = 0; j != 192; j += 4 )
      {
        v9 = *(_DWORD *)&v43[j];
        v7[16] = v7[9]
               + v9
               + (__ROR4__(v7[14], 17) ^ __ROR4__(v7[14], 19) ^ (v7[14] >> 10))
               + (__ROR4__(v7[1], 7) ^ __ROR4__(v7[1], 18) ^ (v7[1] >> 3));
        ++v7;
      }
      v10 = &v34;
      v11 = v31;
      v32 = v31;
      do
      {
        v12 = *(_DWORD *)(v11 + 136);
        v11 += 4;
        v13 = v29;
        v10[1] = v12;
        ++v10;
      }
      while ( v10 != v13 );
      v14 = 0;
      v15 = v39;
      v16 = v40;
      v17 = v41;
      v18 = v42;
      v19 = (unsigned int)v35;
      v20 = (unsigned int)v36;
      result = (unsigned int)v37;
      v21 = v38;
      while ( 1 )
      {
        v22 = *(_DWORD *)&v43[v14];
        v23 = *(_DWORD *)((char *)&unk_72E1C + v14);
        v14 += 4;
        v24 = v22 + v23 + (__ROR4__(v15, 6) ^ __ROR4__(v15, 11) ^ __ROR4__(v15, 25)) + (v17 & ~v15 ^ v16 & v15) + v18;
        v18 = v17;
        v25 = v21 + v24;
        v26 = ((v20 ^ result) & v19 ^ result & v20) + (__ROR4__(v19, 2) ^ __ROR4__(v19, 13) ^ __ROR4__(v19, 22)) + v24;
        v21 = result;
        if ( v14 == 256 )
          break;
        result = v20;
        v17 = v16;
        v20 = v19;
        v16 = v15;
        v19 = v26;
        v15 = v25;
      }
      v40 = v15;
      v27 = 0;
      v42 = v17;
      v39 = v25;
      v41 = v16;
      v35 = (_DWORD *)v26;
      v36 = (_DWORD *)v19;
      v37 = (_DWORD *)v20;
      v38 = result;
      v28 = v32;
      while ( 1 )
      {
        ++v27;
        *(_DWORD *)(v28 + 136) += v26;
        v28 += 4;
        if ( v27 == 8 )
          break;
        result = (unsigned int)&v29;
        v26 = (unsigned int)(&v29)[v27 + 6];
      }
      ++v30;
    }
    while ( v33 != v30 );
  }
  return result;
}

//----- (00030140) --------------------------------------------------------
_DWORD *__fastcall sub_30140(_DWORD *result)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r2
  int v3; // t1

  v1 = &unk_72F18;
  v2 = result;
  do
  {
    v3 = v1[1];
    ++v1;
    v2[34] = v3;
    ++v2;
  }
  while ( v1 != (_DWORD *)&unk_72F38 );
  result[1] = 0;
  *result = 0;
  return result;
}

//----- (00030174) --------------------------------------------------------
void *__fastcall sub_30174(int *a1, const void *a2, size_t n)
{
  int v4; // r0
  size_t v7; // r6
  int v8; // r0
  void *result; // r0
  unsigned int v10; // r3
  unsigned int v11; // r5
  size_t v12; // r8
  int v13; // r6
  int v14; // r3

  v4 = a1[1];
  v7 = 64 - v4;
  v8 = v4 + 8;
  if ( n < v7 )
    v7 = n;
  result = memcpy((char *)a1 + v8, a2, v7);
  v10 = n + a1[1];
  if ( v10 > 0x3F )
  {
    v11 = n - v7;
    v12 = v11 & 0x3F;
    v13 = (int)a2 + v7;
    v11 >>= 6;
    sub_2FF20((unsigned int)a1, (int)(a1 + 2), 1);
    sub_2FF20((unsigned int)a1, v13, v11);
    result = memcpy(a1 + 2, (const void *)(v13 + (v11 << 6)), v12);
    v14 = *a1;
    a1[1] = v12;
    *a1 = v14 + ((v11 + 1) << 6);
  }
  else
  {
    a1[1] = v10;
  }
  return result;
}

//----- (00030214) --------------------------------------------------------
_DWORD *__fastcall sub_30214(_DWORD *a1, int a2)
{
  int v3; // r3
  int v5; // r6
  char *v6; // r0
  int v7; // r6
  int v8; // r2
  size_t v9; // r2
  int v10; // r8
  int v11; // r10
  int v12; // r9
  int v13; // r11
  int v14; // r7
  int v15; // r6
  _DWORD *result; // r0
  int i; // r3
  _BYTE *v18; // r2

  v3 = a1[1];
  v5 = *a1;
  v6 = (char *)a1 + v3 + 8;
  v7 = v3 + v5;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v8 = 128;
  else
    v8 = 64;
  v9 = v8 - v3;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v10 = 31;
  else
    v10 = 15;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v11 = 125;
  else
    v11 = 61;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v12 = 126;
  else
    v12 = 62;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v13 = 127;
  else
    v13 = 63;
  if ( (v3 & 0x3Fu) >= 0x38 )
    v14 = 2;
  else
    v14 = 1;
  memset(v6, 0, v9);
  v15 = 8 * v7;
  *((_BYTE *)a1 + a1[1] + 8) = 0x80;
  *((_BYTE *)a1 + v13 + 8) = v15;
  *((_BYTE *)a1 + v12 + 8) = BYTE1(v15);
  *((_BYTE *)a1 + v11 + 8) = BYTE2(v15);
  LOBYTE(a1[v10 + 2]) = HIBYTE(v15);
  sub_2FF20((unsigned int)a1, (int)(a1 + 2), v14);
  result = a1;
  for ( i = 0; i != 8; ++i )
  {
    v18 = (_BYTE *)(a2 + 4 * i);
    v18[3] = result[34];
    v18[2] = BYTE1(result[34]);
    v18[1] = *((_WORD *)result + 69);
    LOBYTE(v18) = *((_BYTE *)result++ + 139);
    *(_BYTE *)(a2 + 4 * i) = (_BYTE)v18;
  }
  return result;
}

//----- (0003030C) --------------------------------------------------------
_DWORD *__fastcall sub_3030C(const void *a1, size_t n, int a3)
{
  _DWORD *v3; // r3
  char *v4; // r12
  int v6; // t1
  int v8[33]; // [sp+0h] [bp-A8h] BYREF
  char v9; // [sp+84h] [bp-24h] BYREF

  v3 = &unk_72F18;
  v4 = &v9;
  do
  {
    v6 = v3[1];
    ++v3;
    *((_DWORD *)v4 + 1) = v6;
    v4 += 4;
  }
  while ( v3 != (_DWORD *)&unk_72F38 );
  v8[0] = 0;
  v8[1] = 0;
  sub_30174(v8, a1, n);
  return sub_30214(v8, a3);
}

//----- (00030370) --------------------------------------------------------
char *__fastcall sub_30370(char *s, int a2)
{
  unsigned int v2; // r4
  char *v3; // r8
  char *v5; // r6
  char *v6; // r2
  unsigned int v7; // r3
  int v8; // r5
  unsigned int v9; // t1
  unsigned int v10; // t1
  size_t v12; // r5
  _BYTE *v13; // r0
  _BYTE *v14; // r3
  char *v15; // r2
  unsigned int v16; // t1
  char sa[4100]; // [sp+10h] [bp-1004h] BYREF

  v2 = (unsigned __int8)*s;
  v3 = s;
  if ( *s )
  {
    v5 = s;
    v6 = s;
    v7 = (unsigned __int8)*s;
    v8 = 0;
    while ( 1 )
    {
      if ( v7 == 61 )
        goto LABEL_10;
      if ( v7 <= 0x3D )
      {
        if ( v7 == 34 )
        {
          if ( a2 )
            goto LABEL_11;
          goto LABEL_5;
        }
        if ( v7 != 44 )
          goto LABEL_5;
LABEL_10:
        if ( !a2 )
          goto LABEL_11;
LABEL_5:
        v9 = (unsigned __int8)*++v6;
        v7 = v9;
        if ( !v9 )
          goto LABEL_12;
      }
      else
      {
        if ( v7 != 92 )
        {
          if ( v7 != 124 )
            goto LABEL_5;
          goto LABEL_10;
        }
LABEL_11:
        v10 = (unsigned __int8)*++v6;
        v7 = v10;
        ++v8;
        if ( !v10 )
        {
LABEL_12:
          if ( !v8 )
            return v3;
          v12 = v8 + 1 + strlen(s);
          v13 = malloc(v12);
          if ( !v13 )
          {
            snprintf(sa, 0x1000u, "Failed to malloc escape buf %d in %s %s():%d", v12, "api.c", "escape_string", 840);
            sub_385C8(3, sa, 1);
            sub_16BE0(1);
          }
          v14 = v13;
          v15 = v3 + 1;
          while ( 2 )
          {
            if ( !v2 )
            {
              v3 = v13;
              *v14 = 0;
              return v3;
            }
            if ( v2 == 61 )
            {
LABEL_28:
              if ( a2 )
                goto LABEL_21;
            }
            else
            {
              if ( v2 > 0x3D )
              {
                if ( v2 == 92 )
                {
                  *v14 = 92;
                  v14[1] = *(v15 - 1);
                  v14 += 2;
                }
                else
                {
                  if ( v2 == 124 )
                    goto LABEL_28;
LABEL_21:
                  *v14++ = v2;
                }
                v16 = (unsigned __int8)*++v5;
                v2 = v16;
                ++v15;
                continue;
              }
              if ( v2 != 34 )
              {
                if ( v2 == 44 )
                  goto LABEL_28;
                goto LABEL_21;
              }
              if ( !a2 )
                goto LABEL_21;
            }
            break;
          }
          *v14++ = 92;
          LOBYTE(v2) = *(v15 - 1);
          goto LABEL_21;
        }
      }
    }
  }
  return v3;
}

//----- (0003050C) --------------------------------------------------------
void sub_3050C()
{
  JUMPOUT(0x3043C);
}
// 30514: control flows out of bounds to 3043C

//----- (00030524) --------------------------------------------------------
void *__fastcall sub_30524(int a1, char *s)
{
  void **v2; // r5
  size_t v5; // r0
  char *v6; // r10
  unsigned int v7; // r1
  char *v8; // r6
  size_t v9; // r4
  size_t v10; // r9
  void *result; // r0
  int v12; // r11
  char sa[4100]; // [sp+18h] [bp-1004h] BYREF

  v2 = *(void ***)(a1 + 12);
  v5 = strlen(s);
  v6 = (char *)v2[1];
  v7 = (unsigned int)v2[2];
  v8 = (char *)*v2;
  v9 = v5;
  v10 = v5 + 1;
  if ( (unsigned int)&v6[v5 + 1] > v7 )
  {
    v12 = v5 + 4097 - (v10 & 0xFFF);
    v8 = (char *)realloc(*v2, v12 + v7);
    *v2 = v8;
    if ( !v8 )
    {
      snprintf(
        sa,
        0x1000u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v9,
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8),
        v12,
        "api.c",
        "add_item_buf",
        1179);
      sub_385C8(3, sa, 1);
      sub_16BE0(1);
    }
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8) += v12;
  }
  result = memcpy(&v6[(_DWORD)v8], s, v10);
  *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) += v9;
  return result;
}

//----- (00030638) --------------------------------------------------------
int __fastcall sub_30638(unsigned int *a1, char *s)
{
  size_t v4; // r5
  _BYTE *v5; // r0
  char *v6; // r3
  int v7; // r8
  unsigned int v8; // r2
  size_t v9; // r7
  char *v10; // r0

  v4 = strlen(s);
  v5 = (_BYTE *)a1[1];
  v6 = (char *)a1[2];
  v7 = v6 - v5;
  v8 = v6 - v5 + 12 + v4;
  if ( v8 > *a1 )
  {
    v9 = *a1 + 0x20000;
    if ( v8 > v9 )
      v9 = ((unsigned int)vcvts_n_f32_u32(v8, 0x10u) + 2) << 16;
    v10 = (char *)realloc(v5, v9);
    *a1 = v9;
    v6 = &v10[v7];
    a1[1] = (unsigned int)v10;
    a1[2] = (unsigned int)&v10[v7];
  }
  memcpy(v6, s, v4 + 1);
  a1[2] += v4;
  return 1;
}

//----- (000306CC) --------------------------------------------------------
void __fastcall sub_306CC(unsigned int *a1, char *s, int a3, _BYTE *a4)
{
  char *v6; // r5

  if ( *a4 )
  {
    if ( !a3 )
    {
      *a4 = 0;
      goto LABEL_5;
    }
    sub_30638(a1, "{");
    *a4 = 0;
    v6 = sub_30370(s, 1);
  }
  else
  {
    if ( !a3 )
    {
LABEL_5:
      v6 = sub_30370(s, a3);
      sub_30638(a1, "CMD=");
      sub_30638(a1, v6);
      sub_30638(a1, (char *)delim);
      if ( v6 == s )
        return;
      goto LABEL_6;
    }
    sub_30638(a1, (char *)",");
    v6 = sub_30370(s, 1);
  }
  sub_30638(a1, (char *)"\"");
  sub_30638(a1, v6);
  sub_30638(a1, "\":[");
  if ( v6 != s )
LABEL_6:
    free(v6);
}

//----- (000307D8) --------------------------------------------------------
int __fastcall sub_307D8(unsigned int *a1, char *s)
{
  _BYTE *v2; // r12

  v2 = (_BYTE *)a1[1];
  a1[2] = (unsigned int)v2;
  *v2 = 0;
  *((_BYTE *)a1 + 13) = 0;
  return sub_30638(a1, s);
}

//----- (000307F0) --------------------------------------------------------
int __fastcall sub_307F0(unsigned int *a1, int a2, int a3, int a4)
{
  char *v4; // r1
  int result; // r0

  if ( a4 )
    v4 = "{\"STATUS\":\"RESTART\"";
  else
    v4 = "RESTART";
  result = sub_307D8(a1, v4);
  byte_75AEC = 1;
  byte_75AED = 1;
  return result;
}
// 75AEC: using guessed type char byte_75AEC;
// 75AED: using guessed type char byte_75AED;

//----- (00030824) --------------------------------------------------------
int __fastcall sub_30824(unsigned int *a1, int a2, int a3, int a4)
{
  char *v4; // r1
  int result; // r0

  if ( a4 )
    v4 = "{\"STATUS\":\"BYE\"";
  else
    v4 = "BYE";
  result = sub_307D8(a1, v4);
  byte_75AEC = 1;
  byte_75AEE = 1;
  return result;
}
// 75AEC: using guessed type char byte_75AEC;
// 75AEE: using guessed type char byte_75AEE;

//----- (00030858) --------------------------------------------------------
bool __fastcall sub_30858(const struct sockaddr *a1, const char **a2, _BYTE *a3)
{
  char *v6; // r0
  int v7; // r7
  int v8; // r2
  char *v9; // r1
  int v10; // r3
  int v11; // r4
  int v12; // r0
  int v13; // t1
  int v14; // t1
  _BOOL4 result; // r0
  int v16; // r5
  char v17; // [sp+Fh] [bp-35h] BYREF
  _BOOL4 buf; // [sp+10h] [bp-34h] BYREF
  int v19; // [sp+14h] [bp-30h]
  int v20; // [sp+18h] [bp-2Ch]
  int v21; // [sp+1Ch] [bp-28h] BYREF
  char s[36]; // [sp+20h] [bp-24h] BYREF

  v6 = (char *)malloc(0x2Eu);
  *a2 = v6;
  getnameinfo(a1, 0x80u, v6, 0x2Eu, 0, 0, 1u);
  if ( a1->sa_family == 2 )
  {
    sprintf(s, "::ffff:%s", *a2);
    inet_pton(10, s, &buf);
  }
  else
  {
    inet_pton(10, *a2, &buf);
  }
  *a3 = (*_ctype_toupper_loc())[82];
  if ( dword_75AD4 )
  {
    if ( dword_75AF0 > 0 )
    {
      v7 = 0;
      v8 = dword_75AF4 - 1;
      do
      {
        v9 = &v17;
        v10 = v8;
        while ( 1 )
        {
          v11 = *(unsigned __int8 *)(v10 + 17);
          v13 = (unsigned __int8)*++v9;
          v12 = v13;
          v14 = *(unsigned __int8 *)++v10;
          if ( v14 != (v11 & v12) )
            break;
          if ( v9 == (char *)&v21 + 3 )
          {
            result = 1;
            *a3 = *(_BYTE *)(v8 + 33);
            return result;
          }
        }
        ++v7;
        v8 += 36;
      }
      while ( v7 != dword_75AF0 );
    }
    return 0;
  }
  else
  {
    v16 = (unsigned __int8)byte_785EC;
    if ( byte_785EC || !strcmp(*a2, "127.0.0.1") )
    {
      return 1;
    }
    else
    {
      result = buf;
      if ( buf )
      {
        return v16;
      }
      else if ( !v19 )
      {
        if ( v20 )
          return v19;
        else
          return v21 == 0x1000000;
      }
    }
  }
  return result;
}
// 75AD4: using guessed type int dword_75AD4;
// 75AF0: using guessed type int dword_75AF0;
// 75AF4: using guessed type int dword_75AF4;
// 785EC: using guessed type char byte_785EC;

//----- (000309F8) --------------------------------------------------------
void __fastcall sub_309F8(int a1, int a2, int a3)
{
  char *v4; // r7
  signed int v5; // r0
  const char *v6; // r3
  signed int v7; // r4
  int v8; // r5
  int v9; // r9
  _BOOL4 v10; // r3
  fd_set *p_tv_usec; // r3
  int v12; // r0
  ssize_t v13; // r0
  ssize_t v14; // r12
  int v15; // r0
  char *v16; // r0
  ssize_t v17; // [sp+8h] [bp-1094h]
  ssize_t v18; // [sp+8h] [bp-1094h]
  signed int v20; // [sp+Ch] [bp-1090h]
  struct timeval timeout; // [sp+10h] [bp-108Ch] BYREF
  fd_set writefds; // [sp+18h] [bp-1084h] BYREF
  char s[4072]; // [sp+98h] [bp-1004h] BYREF

  v4 = *(char **)(a1 + 4);
  if ( *(_BYTE *)(a1 + 13) )
  {
    *(_WORD *)&v4[strlen(*(const char **)(a1 + 4))] = 93;
    if ( !a3 )
      goto LABEL_3;
  }
  else if ( !a3 )
  {
    goto LABEL_3;
  }
  strcat(v4, ",\"id\":1}");
LABEL_3:
  v5 = strlen(v4);
  v20 = v5 + 1;
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    if ( v5 > 10 )
      v6 = "...";
    else
      v6 = "";
    snprintf(s, 0x1000u, "API: send reply: (%d) '%.10s%s'", v20, v4, v6);
    sub_385C8(7, s, 0);
  }
  v7 = v20;
  v8 = 0;
  v9 = 0;
  while ( 1 )
  {
    v10 = v7 > 0;
    if ( v9 > 4 )
      v10 = 0;
    if ( !v10 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->__fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( p_tv_usec != (fd_set *)&writefds.__fds_bits[31] );
    writefds.__fds_bits[a2 / 32] |= 1 << (a2 % 32);
    v12 = select(a2 + 1, 0, &writefds, 0, &timeout);
    if ( v12 <= 0 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, "API: send select failed (%d)", v12);
        sub_385C8(4, s, 0);
      }
      return;
    }
    v13 = send(a2, v4, v7, 0);
    ++v8;
    v14 = v13;
    if ( v13 < 0 )
    {
      v15 = *_errno_location();
      if ( v15 != 11 )
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          v16 = strerror(v15);
          snprintf(s, 0x1000u, "API: send (%d:%d) failed: %s", v20, v20 - v7, v16);
          sub_385C8(4, s, 0);
        }
        return;
      }
LABEL_25:
      ++v9;
    }
    else if ( v8 == 1 )
    {
      if ( v13 != v7 )
      {
        if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
          goto LABEL_24;
        v17 = v13;
        snprintf(s, 0x1000u, "API: sent %d of %d first go", v13, v7);
        goto LABEL_23;
      }
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        v18 = v13;
        snprintf(s, 0x1000u, "API: sent all of %d first go", v13);
        goto LABEL_41;
      }
LABEL_42:
      v7 -= v14;
      v4 += v14;
    }
    else
    {
      if ( v13 == v7 )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          v18 = v13;
          snprintf(s, 0x1000u, "API: sent all of remaining %d (sendc=%d)", v13, v8);
LABEL_41:
          sub_385C8(7, s, 0);
          v14 = v18;
          goto LABEL_42;
        }
        goto LABEL_42;
      }
      if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        goto LABEL_24;
      v17 = v13;
      snprintf(s, 0x1000u, "API: sent %d of remaining %d (sendc=%d)", v13, v7, v8);
LABEL_23:
      sub_385C8(7, s, 0);
      v14 = v17;
LABEL_24:
      v7 -= v14;
      v4 += v14;
      if ( !v14 )
        goto LABEL_25;
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00030EEC) --------------------------------------------------------
int sub_30EEC()
{
  struct addrinfo *v0; // r4
  struct addrinfo *i; // r3
  int v2; // r0
  int v3; // r9
  time_t v4; // r7
  int ai_family; // r3
  const char *v6; // r7
  size_t v7; // r0
  size_t v8; // r4
  int v9; // r5
  ssize_t v10; // r4
  _BOOL4 v11; // r12
  const char *v12; // r2
  int *v13; // r0
  char *v14; // r8
  struct addrinfo *v15; // r0
  int *v16; // r0
  char *v17; // r0
  int *v19; // r0
  char *v20; // r0
  const char *v21; // r4
  int v22; // r0
  struct addrinfo *v23; // r4
  int v24; // r0
  int v25; // r12
  size_t v26; // r0
  ssize_t v27; // r4
  int *v28; // r0
  char *v29; // r0
  int *v30; // r0
  char *v31; // r0
  int v32; // r0
  int v33; // r1
  int v34; // r2
  int v35; // r3
  _BOOL4 v36; // [sp+14h] [bp-18F0h]
  int v37; // [sp+14h] [bp-18F0h]
  size_t n; // [sp+18h] [bp-18ECh]
  char *v39; // [sp+1Ch] [bp-18E8h]
  int fd; // [sp+20h] [bp-18E4h]
  char v41; // [sp+2Bh] [bp-18D9h] BYREF
  socklen_t addr_len; // [sp+2Ch] [bp-18D8h] BYREF
  const char *v43; // [sp+30h] [bp-18D4h] BYREF
  struct addrinfo *pai; // [sp+34h] [bp-18D0h] BYREF
  int optval; // [sp+38h] [bp-18CCh] BYREF
  char v46[12]; // [sp+3Ch] [bp-18C8h] BYREF
  char s[12]; // [sp+48h] [bp-18BCh] BYREF
  char serv[12]; // [sp+54h] [bp-18B0h] BYREF
  struct addrinfo req; // [sp+60h] [bp-18A4h] BYREF
  struct sockaddr v50[8]; // [sp+80h] [bp-1884h] BYREF
  char v51[1024]; // [sp+100h] [bp-1804h] BYREF
  int v52; // [sp+500h] [bp-1404h] BYREF
  int v53; // [sp+504h] [bp-1400h]
  int v54; // [sp+508h] [bp-13FCh]
  int v55; // [sp+50Ch] [bp-13F8h]
  int v56; // [sp+510h] [bp-13F4h]
  char v57[4100]; // [sp+900h] [bp-1004h] BYREF

  strcpy(v46, "cgminer-");
  sprintf(s, "%d", dword_72CFC);
  memset(&req, 0, sizeof(req));
  if ( getaddrinfo(off_72D08[0], s, &req, &pai) )
  {
    strcpy(v57, "Invalid API Multicast Address");
    sub_385C8(3, v57, 1);
    sub_16BE0(1);
  }
  v0 = pai;
  if ( !pai )
  {
    v15 = 0;
LABEL_43:
    freeaddrinfo(v15);
    strcpy(v57, "API mcast could not open socket");
    sub_385C8(3, v57, 1);
    sub_16BE0(1);
  }
  for ( i = pai; ; i = pai )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      v3 = v2;
      goto LABEL_8;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  v3 = v2;
  if ( v2 == -1 )
  {
    v15 = pai;
    goto LABEL_43;
  }
LABEL_8:
  optval = 1;
  if ( setsockopt(v3, 1, 2, &optval, 4u) < 0 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
      return close(v3);
    v16 = _errno_location();
    v17 = strerror(*v16);
    snprintf(
      v57,
      0x1000u,
      "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
      v17,
      " - API multicast listener will not be available");
LABEL_48:
    sub_385C8(3, v57, 0);
    return close(v3);
  }
  v4 = time(0);
  while ( 1 )
  {
    if ( bind(v3, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        v52 = 0;
        v53 = 0;
        v52 = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(v3, 0, 35, &v52, 8u) < 0 )
        {
LABEL_97:
          if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
            return close(v3);
          v30 = _errno_location();
          v31 = strerror(*v30);
          snprintf(v57, 0x1000u, "API mcast join failed (%s)%s", v31, " - API multicast listener will not be available");
          goto LABEL_48;
        }
      }
      else if ( ai_family == 10 )
      {
        v32 = *(_DWORD *)&v0->ai_addr->sa_data[6];
        v33 = *(_DWORD *)&v0->ai_addr->sa_data[10];
        v34 = *(_DWORD *)&v0->ai_addr[1].sa_family;
        v35 = *(_DWORD *)&v0->ai_addr[1].sa_data[2];
        v56 = 0;
        v52 = v32;
        v53 = v33;
        v54 = v34;
        v55 = v35;
        if ( setsockopt(v3, 41, 20, &v52, 0x14u) < 0 )
          goto LABEL_97;
      }
      freeaddrinfo(pai);
      v6 = off_72D04[0];
      v7 = strlen(off_72D04[0]);
      v8 = v7 + 10;
      n = v7 + 9;
      v39 = (char *)malloc(v7 + 10);
      if ( !v39 )
      {
        strcpy(v57, "Failed to malloc mcast expect_code");
        sub_385C8(3, v57, 1);
        sub_16BE0(1);
      }
      v9 = 0;
      snprintf(v39, v8, "%s%s-", v46, v6);
      fd = -1;
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              do
              {
                while ( 1 )
                {
                  ++v9;
                  sub_2A884();
                  addr_len = 128;
                  v10 = recvfrom(v3, v51, 0x3FFu, 0, v50, &addr_len);
                  if ( v10 >= 0 )
                    break;
                  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                  {
                    v19 = _errno_location();
                    v20 = strerror(*v19);
                    snprintf(v57, 0x1000u, "API mcast failed count=%d (%s) (%d)", v9, v20, v3);
                    sub_385C8(7, v57, 0);
                  }
                }
                v11 = sub_30858(v50, &v43, &v41);
                if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                {
                  v12 = "Ignored";
                  v36 = v11;
                  if ( v11 )
                    v12 = "Accepted";
                  snprintf(v57, 0x1000u, "API mcast from %s - %s", v43, v12);
                  sub_385C8(7, v57, 0);
                  v11 = v36;
                }
              }
              while ( !v11 );
              v51[v10] = 0;
              if ( v10 && v50[7].sa_data[v10 + 13] == 10 )
                v51[--v10] = 0;
              getnameinfo(v50, addr_len, 0, 0, serv, 0xAu, 1u);
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                snprintf(v57, 0x1000u, "API mcast request rep=%d (%s) from [%s]:%s", v10, v51, v43, serv);
                sub_385C8(7, v57, 0);
              }
              if ( n < v10 && !memcmp(v51, v39, n) )
                break;
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                strcpy(v57, "API mcast request was no good");
                sub_385C8(7, v57, 0);
              }
            }
            v21 = &v51[n];
            v22 = strtol(&v51[n], 0, 10);
            if ( (unsigned int)(v22 - 1) <= 0xFFFE )
              break;
            if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
            {
              snprintf(v57, 0x1000u, "API mcast request ignored - invalid port (%s)", v21);
              sub_385C8(7, v57, 0);
            }
          }
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(v57, 0x1000u, "API mcast request OK port %s=%d", v21, v22);
            sub_385C8(7, v57, 0);
          }
          if ( !getaddrinfo(v43, v21, &req, &pai) )
            break;
          if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v57, 0x1000u, "Invalid client address %s", v43);
            goto LABEL_71;
          }
        }
        v23 = pai;
        if ( pai && (v24 = socket(pai->ai_family, 2, 0), v25 = -6348, fd = v24, v3 <= 0) )
        {
          while ( 1 )
          {
            v23 = v23->ai_next;
            if ( !v23 )
              break;
            v37 = v25;
            v24 = socket(*(_DWORD *)(*(_DWORD *)&v57[v25 + 4096] + 4), 2, 0);
            v25 = v37;
          }
          fd = v24;
          if ( v24 == -1 )
            goto LABEL_85;
LABEL_75:
          snprintf((char *)&v52, 0x400u, "cgm-FTW-%d-%s", dword_72D10, (const char *)off_72D00);
          v26 = strlen((const char *)&v52);
          v27 = sendto(fd, &v52, v26 + 1, 0, v23->ai_addr, v23->ai_addrlen);
          freeaddrinfo(pai);
          if ( v27 < 0 )
          {
            if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
            {
              v28 = _errno_location();
              v29 = strerror(*v28);
              snprintf(v57, 0x1000u, "API mcast send reply failed (%s) (%d)", v29, fd);
              sub_385C8(7, v57, 0);
            }
          }
          else if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(v57, 0x1000u, "API mcast send reply (%s) succeeded (%d) (%d)", (const char *)&v52, v27, fd);
            sub_385C8(7, v57, 0);
          }
          close(fd);
        }
        else
        {
          if ( fd != -1 )
            goto LABEL_75;
LABEL_85:
          freeaddrinfo(pai);
          if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v57, 0x1000u, "API mcast could not open socket to client %s", v43);
LABEL_71:
            sub_385C8(3, v57, 0);
          }
        }
      }
    }
    v13 = _errno_location();
    v14 = strerror(*v13);
    if ( time(0) - v4 > 61 )
      break;
    sub_2A884();
  }
  if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(
      v57,
      0x1000u,
      "API mcast bind to port %d failed (%s)%s",
      dword_72CFC,
      v14,
      " - API multicast listener will not be available");
    sub_385C8(3, v57, 0);
  }
  return close(v3);
}
// 72CFC: using guessed type int dword_72CFC;
// 72D00: using guessed type _UNKNOWN *off_72D00;
// 72D04: using guessed type char *off_72D04[3];
// 72D08: using guessed type char *off_72D08[2];
// 72D10: using guessed type int dword_72D10;
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00031B10) --------------------------------------------------------
int __fastcall sub_31B10(int a1)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  sub_2EF24("APIMcast");
  sub_30EEC();
  *(_DWORD *)(a1 + 12) = 0;
  return 0;
}

//----- (00031B4C) --------------------------------------------------------
_DWORD *__fastcall sub_31B4C(_DWORD *a1, const char *a2, int a3, const char *a4, char a5)
{
  _DWORD *v9; // r4
  char *v10; // r0
  bool v11; // zf
  int v12; // r3
  _DWORD *v14; // r0
  _QWORD *v15; // r0
  _WORD *v16; // r0
  _BYTE *v17; // r0
  _BYTE *v18; // r0
  _DWORD *v19; // r0
  int v20; // r1
  size_t v21; // r0
  char *v22; // r0
  char v23[4100]; // [sp+0h] [bp-1004h] BYREF

  v9 = malloc(0x18u);
  v10 = _strdup(a2);
  v11 = a1 == 0;
  *v9 = a3;
  if ( !a1 )
  {
    v9[4] = v9;
    a1 = v9;
    v9[5] = v9;
  }
  v9[1] = v10;
  if ( !v11 )
  {
    v9[4] = a1[4];
    a1[4] = v9;
    v12 = v9[4];
    v9[5] = a1;
    *(_DWORD *)(v12 + 20) = v9;
  }
  *((_BYTE *)v9 + 12) = a5;
  if ( !a4 )
  {
    *((_BYTE *)v9 + 12) = 0;
    a4 = "(null)";
    *v9 = 2;
    goto LABEL_9;
  }
  if ( !a5 )
  {
LABEL_9:
    v9[2] = a4;
    return a1;
  }
  switch ( a3 )
  {
    case 0:
    case 1:
    case 2:
      v21 = strlen(a4);
      v22 = (char *)malloc(v21 + 1);
      v9[2] = v22;
      strcpy(v22, a4);
      break;
    case 3:
      v17 = malloc(4u);
      v9[2] = v17;
      *v17 = *a4;
      break;
    case 4:
    case 5:
      v16 = malloc(4u);
      v9[2] = v16;
      *v16 = *(_WORD *)a4;
      break;
    case 6:
    case 7:
    case 8:
    case 9:
    case 16:
    case 19:
    case 22:
    case 26:
      v14 = malloc(4u);
      v9[2] = v14;
      *v14 = *(_DWORD *)a4;
      break;
    case 10:
    case 11:
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 21:
    case 23:
    case 24:
    case 25:
      v15 = malloc(8u);
      v9[2] = v15;
      *v15 = *(_QWORD *)a4;
      break;
    case 14:
      v18 = malloc(1u);
      v9[2] = v18;
      *v18 = *a4;
      break;
    case 15:
      v19 = malloc(8u);
      v9[2] = v19;
      v20 = *((_DWORD *)a4 + 1);
      *v19 = *(_DWORD *)a4;
      v19[1] = v20;
      break;
    default:
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        snprintf(v23, 0x1000u, "API: unknown1 data type %d ignored", a3);
        sub_385C8(3, v23, 0);
      }
      *v9 = 1;
      *((_BYTE *)v9 + 12) = 0;
      v9[2] = "Unknown";
      break;
  }
  return a1;
}
// 31BD0: control flows out of bounds to 31BD4
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00031DD4) --------------------------------------------------------
int __fastcall sub_31DD4(int result, int a2)
{
  int v2; // r4

  v2 = result;
  if ( !*(_BYTE *)(result + 13) )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  result = sub_30638((unsigned int *)result, (char *)word_686A0);
  *(_BYTE *)(v2 + 13) = 0;
  if ( a2 )
  {
LABEL_3:
    sub_30638((unsigned int *)v2, ",\"id\":1}");
    return sub_30638((unsigned int *)v2, (char *)word_686A0);
  }
  return result;
}

//----- (00031E34) --------------------------------------------------------
unsigned __int8 **__fastcall sub_31E34(unsigned __int8 **result, unsigned __int8 **a2)
{
  unsigned __int8 *v2; // r3
  int v3; // r2
  unsigned __int8 *v4; // r12
  unsigned __int8 *v5; // r2
  unsigned __int8 *v6; // r3

  v2 = *result;
  v3 = **result;
  if ( **result )
  {
    while ( v3 != 44 )
    {
      if ( v3 == 92 && (v4 = v2 + 1, v2[1]) )
        *result = v4;
      else
        v4 = *result;
      v5 = *a2;
      v2 = v4 + 1;
      *v5 = *v4;
      *a2 = v5 + 1;
      *result = v4 + 1;
      v3 = v4[1];
      if ( !v4[1] )
        goto LABEL_11;
    }
    *result = v2 + 1;
  }
LABEL_11:
  v6 = *a2;
  *v6 = 0;
  *a2 = v6 + 1;
  return result;
}

//----- (00031EBC) --------------------------------------------------------
int __fastcall sub_31EBC(unsigned __int8 *a1, unsigned __int8 **a2, _DWORD *a3, _DWORD *a4)
{
  size_t v7; // r0
  unsigned __int8 *v8; // r0
  unsigned __int8 *v9; // r4
  int v10; // r5
  unsigned __int8 *v12[2]; // [sp+4h] [bp-1010h] BYREF
  unsigned __int8 *v13; // [sp+Ch] [bp-1008h] BYREF
  char v14[4100]; // [sp+10h] [bp-1004h] BYREF

  v12[0] = a1;
  v7 = strlen((const char *)a1);
  v8 = (unsigned __int8 *)malloc(v7 + 1);
  v13 = v8;
  v9 = v8;
  if ( !v8 )
  {
    strcpy(v14, "Failed to malloc pooldetails buf");
    sub_385C8(3, v14, 1);
    sub_16BE0(1);
  }
  *a2 = v8;
  LOWORD(v10) = -4108;
  sub_31E34(v12, &v13);
  HIWORD(v10) = -1;
  if ( **(_BYTE **)&v14[v10 + 4096] && (*a3 = v13, sub_31E34(v12, &v13), **(_BYTE **)&v14[v10 + 4096]) )
  {
    *a4 = v13;
    sub_31E34(v12, &v13);
    return 1;
  }
  else
  {
    free(v9);
    return 0;
  }
}

//----- (00032000) --------------------------------------------------------
int __fastcall sub_32000(pthread_rwlock_t *a1, const char *a2, int a3)
{
  int result; // r0
  int *v6; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_rwlock_rdlock(a1);
  if ( result )
  {
    v6 = _errno_location();
    snprintf(s, 0x1000u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "api.c", a2, a3);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (0003207C) --------------------------------------------------------
int __fastcall sub_3207C(pthread_mutex_t *a1, const char *a2, int a3)
{
  if ( pthread_mutex_unlock(a1) )
    sub_B794(a2, a3);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();

//----- (000320B8) --------------------------------------------------------
int sub_320B8()
{
  char v1[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&stru_75AF8) )
    sub_B6BC("restart_thread", 4951);
  if ( pthread_mutex_unlock(&stru_75AF8) )
    sub_B794("restart_thread", 4952);
  off_72D18();
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v1, "API: restarting cgminer");
    sub_385C8(7, v1, 0);
  }
  sub_1D138();
  return 0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (000321B0) --------------------------------------------------------
void __noreturn sub_321B0()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( !pthread_mutex_lock(&stru_75AF8) )
  {
    if ( !pthread_mutex_unlock(&stru_75AF8) )
    {
      off_72D18();
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        strcpy(v0, "API: killing cgminer");
        sub_385C8(7, v0, 0);
      }
      sub_17830();
    }
    sub_B794("quit_thread", 4938);
  }
  sub_B6BC("quit_thread", 4937);
}
// 321B0: using guessed type void __noreturn sub_321B0();
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (000322AC) --------------------------------------------------------
int __fastcall sub_322AC(int *a1)
{
  int v2; // r0
  bool v3; // zf
  int v4; // r6
  void **v5; // r4
  void **v6; // r5

  if ( pthread_mutex_lock(&stru_75AF8) )
    sub_B6BC("tidyup", 4620);
  v2 = *a1;
  v3 = *a1 == -1;
  byte_75AEC = 1;
  if ( !v3 )
  {
    shutdown(v2, 2);
    close(*a1);
    *a1 = -1;
  }
  if ( dword_75AF4 )
  {
    free((void *)dword_75AF4);
    dword_75AF4 = 0;
  }
  v4 = dword_75B10;
  if ( dword_75B10 )
  {
    v5 = (void **)dword_75B10;
    do
    {
      v6 = (void **)v5[2];
      free(*((void **)*v5 + 1));
      free(*v5);
      free(v5);
      v5 = v6;
    }
    while ( (void **)v4 != v6 );
    dword_75B10 = 0;
  }
  if ( pthread_mutex_unlock(&stru_75AF8) )
    sub_B794("tidyup", 4641);
  return off_72D18();
}
// 72D18: using guessed type int (*off_72D18)();
// 75AEC: using guessed type char byte_75AEC;
// 75AF4: using guessed type int dword_75AF4;
// 75B10: using guessed type int dword_75B10;

//----- (000323A4) --------------------------------------------------------
int __fastcall sub_323A4(unsigned int *a1, int a2, int a3, int a4)
{
  int v8; // r5
  int v9; // r0
  int v10; // r8
  int v11; // r5
  int v12; // r0
  int v13; // r3
  int v14; // r2
  void *v15; // r0
  char *v16; // r1
  int v17; // r4
  int v18; // r4
  const char *v20; // r3
  char *v21; // r11
  char *v22; // r3
  int *v23; // r0
  int *v24; // r0
  char *ptr; // [sp+10h] [bp-104Ch]
  char s[64]; // [sp+18h] [bp-1044h] BYREF
  char v27[4100]; // [sp+58h] [bp-1004h] BYREF

  v8 = *(_DWORD *)(dword_75B14 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v8) )
    sub_B6BC("print_data", 1196);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v8 + 24)) )
  {
    v24 = _errno_location();
    snprintf(v27, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1196);
    sub_385C8(3, v27, 1);
    sub_16BE0(1);
  }
  v9 = sub_39094(dword_75B14, "api.c", "print_data", 1197);
  v10 = *(_DWORD *)(dword_75B14 + 8);
  v11 = v9;
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v10 + 24)) )
    sub_B728("print_data", 1198);
  if ( pthread_mutex_unlock((pthread_mutex_t *)v10) )
    sub_B794("print_data", 1198);
  off_72D18();
  *(_DWORD *)(*(_DWORD *)(v11 + 12) + 4) = 0;
  if ( a4 )
    sub_30524(v11, (char *)",");
  if ( a3 )
    sub_30524(v11, "{");
  if ( a2 )
  {
    v12 = v11;
    if ( a3 )
      goto LABEL_18;
LABEL_11:
    sub_30524(v12, *(char **)(a2 + 4));
    sub_30524(v11, "=");
    while ( 1 )
    {
      switch ( *(_DWORD *)a2 )
      {
        case 0:
          v21 = *(char **)(a2 + 8);
          v22 = sub_30370(v21, a3);
          ptr = v22;
          if ( a3 )
          {
            sub_30524(v11, (char *)"\"");
            sub_30524(v11, ptr);
            sub_30524(v11, (char *)"\"");
          }
          else
          {
            sub_30524(v11, v22);
          }
          if ( ptr != v21 )
            free(ptr);
          break;
        case 1:
        case 2:
          if ( a3 )
          {
            sub_30524(v11, (char *)"\"");
            sub_30524(v11, *(char **)(a2 + 8));
            sub_30524(v11, (char *)"\"");
          }
          else
          {
            sub_30524(v11, *(char **)(a2 + 8));
          }
          break;
        case 3:
          snprintf(s, 0x40u, "%u", **(unsigned __int8 **)(a2 + 8));
          goto LABEL_14;
        case 4:
          snprintf(s, 0x40u, "%d", **(__int16 **)(a2 + 8));
          goto LABEL_14;
        case 5:
          snprintf(s, 0x40u, "%u", **(unsigned __int16 **)(a2 + 8));
          goto LABEL_14;
        case 6:
          snprintf(s, 0x40u, "%d", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 7:
        case 8:
          snprintf(s, 0x40u, "%u", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 9:
          if ( a3 )
          {
            sub_30524(v11, (char *)"\"");
            snprintf(s, 0x40u, "0x%08x", **(_DWORD **)(a2 + 8));
            sub_30524(v11, s);
            sub_30524(v11, (char *)"\"");
          }
          else
          {
            snprintf(s, 0x40u, "0x%08x", **(_DWORD **)(a2 + 8));
            sub_30524(v11, s);
          }
          break;
        case 0xA:
          snprintf(s, 0x40u, "%llu", *(_QWORD *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xB:
          snprintf(s, 0x40u, "%lld", *(_QWORD *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xC:
          snprintf(s, 0x40u, "%f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xD:
          snprintf(s, 0x40u, "%.0f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0xE:
          v20 = "false";
          if ( **(_BYTE **)(a2 + 8) )
            v20 = "true";
          snprintf(s, 0x40u, "%s", v20);
          goto LABEL_14;
        case 0xF:
          snprintf(s, 0x40u, "%ld.%06ld", **(_DWORD **)(a2 + 8), *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4));
          goto LABEL_14;
        case 0x10:
          snprintf(s, 0x40u, "%lu", **(_DWORD **)(a2 + 8));
          goto LABEL_14;
        case 0x11:
        case 0x14:
        case 0x15:
          snprintf(s, 0x40u, "%.2f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x12:
          snprintf(s, 0x40u, "%.4f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x13:
          snprintf(s, 0x40u, "%.2f", **(float **)(a2 + 8));
          goto LABEL_14;
        case 0x16:
        case 0x1A:
          snprintf(s, 0x40u, "%.3f", **(float **)(a2 + 8));
          goto LABEL_14;
        case 0x17:
          snprintf(s, 0x40u, "%.15f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x18:
          snprintf(s, 0x40u, "%.8f", *(double *)*(_DWORD *)(a2 + 8));
          goto LABEL_14;
        case 0x19:
          snprintf(s, 0x40u, "%.4f", *(double *)*(_DWORD *)(a2 + 8) * 100.0);
LABEL_14:
          sub_30524(v11, s);
          break;
        default:
          if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v27, 0x1000u, "API: unknown2 data type %d ignored", *(_DWORD *)a2);
            sub_385C8(3, v27, 0);
          }
          if ( a3 )
          {
            sub_30524(v11, (char *)"\"");
            sub_30524(v11, "Unknown");
            sub_30524(v11, (char *)"\"");
          }
          else
          {
            sub_30524(v11, "Unknown");
          }
          break;
      }
      free(*(void **)(a2 + 4));
      if ( *(_BYTE *)(a2 + 12) )
      {
        free(*(void **)(a2 + 8));
        v13 = *(_DWORD *)(a2 + 20);
        if ( v13 == a2 )
        {
LABEL_20:
          free((void *)a2);
          break;
        }
      }
      else
      {
        v13 = *(_DWORD *)(a2 + 20);
        if ( v13 == a2 )
          goto LABEL_20;
      }
      v14 = *(_DWORD *)(a2 + 16);
      v15 = (void *)a2;
      a2 = v13;
      *(_DWORD *)(v13 + 16) = v14;
      *(_DWORD *)(v14 + 20) = v13;
      free(v15);
      sub_30524(v11, (char *)",");
      v12 = v11;
      if ( !a3 )
        goto LABEL_11;
LABEL_18:
      sub_30524(v12, (char *)"\"");
      sub_30524(v11, *(char **)(a2 + 4));
      sub_30524(v11, (char *)"\"");
      sub_30524(v11, (char *)":");
    }
  }
  if ( a3 )
    v16 = (char *)"}";
  else
    v16 = (char *)delim;
  sub_30524(v11, v16);
  sub_30638(a1, **(char ***)(v11 + 12));
  v17 = *(_DWORD *)(dword_75B14 + 8);
  if ( pthread_mutex_lock((pthread_mutex_t *)v17) )
    sub_B6BC("print_data", 1368);
  if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v17 + 24)) )
  {
    v23 = _errno_location();
    snprintf(v27, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "api.c", "print_data", 1368);
    sub_385C8(3, v27, 1);
    sub_16BE0(1);
  }
  sub_39208(dword_75B14, v11, "api.c", "print_data", 1369);
  v18 = *(_DWORD *)(dword_75B14 + 8);
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v18 + 24)) )
    sub_B728("print_data", 1370);
  if ( pthread_mutex_unlock((pthread_mutex_t *)v18) )
    sub_B794("print_data", 1370);
  off_72D18();
  return 0;
}
// 3249C: control flows out of bounds to 324A0
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 75B14: using guessed type int dword_75B14;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00032C68) --------------------------------------------------------
_DWORD *__fastcall sub_32C68(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 0, a3, a4);
}

//----- (00032C8C) --------------------------------------------------------
_DWORD *__fastcall sub_32C8C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 1, a3, a4);
}

//----- (00032CB0) --------------------------------------------------------
_DWORD *__fastcall sub_32CB0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 2, a3, a4);
}

//----- (00032CD4) --------------------------------------------------------
_DWORD *__fastcall sub_32CD4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 3, a3, a4);
}

//----- (00032CF8) --------------------------------------------------------
_DWORD *__fastcall sub_32CF8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 4, a3, a4);
}

//----- (00032D1C) --------------------------------------------------------
_DWORD *__fastcall sub_32D1C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 5, a3, a4);
}

//----- (00032D40) --------------------------------------------------------
_DWORD *__fastcall sub_32D40(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 6, a3, a4);
}

//----- (00032D64) --------------------------------------------------------
_DWORD *__fastcall sub_32D64(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 7, a3, a4);
}

//----- (00032D88) --------------------------------------------------------
_DWORD *__fastcall sub_32D88(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 8, a3, a4);
}

//----- (00032DAC) --------------------------------------------------------
_DWORD *__fastcall sub_32DAC(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 9, a3, a4);
}

//----- (00032DD0) --------------------------------------------------------
_DWORD *__fastcall sub_32DD0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 10, a3, a4);
}

//----- (00032DF4) --------------------------------------------------------
_DWORD *__fastcall sub_32DF4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 11, a3, a4);
}

//----- (00032E18) --------------------------------------------------------
_DWORD *__fastcall sub_32E18(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 12, a3, a4);
}

//----- (00032E3C) --------------------------------------------------------
_DWORD *__fastcall sub_32E3C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 13, a3, a4);
}

//----- (00032E60) --------------------------------------------------------
_DWORD *__fastcall sub_32E60(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 14, a3, a4);
}

//----- (00032E84) --------------------------------------------------------
_DWORD *__fastcall sub_32E84(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 15, a3, a4);
}

//----- (00032EA8) --------------------------------------------------------
_DWORD *__fastcall sub_32EA8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 16, a3, a4);
}

//----- (00032ECC) --------------------------------------------------------
int __fastcall sub_32ECC(unsigned int *a1, int a2, int a3, int a4, unsigned __int8 a5)
{
  int v8; // r12
  int *v9; // r1
  int v10; // lr
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r4
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  int result; // r0
  int v18; // lr
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  char *v21; // r2
  int v22; // [sp+4h] [bp-200Ch] BYREF
  char v23[4]; // [sp+8h] [bp-2008h] BYREF
  int v24; // [sp+Ch] [bp-2004h] BYREF
  char s[8176]; // [sp+10h] [bp-2000h] BYREF

  v22 = a2;
  if ( a5 )
    sub_30638(a1, "{\"STATUS\":[");
  v8 = dword_72F3C[0];
  if ( dword_72F3C[0] == 4 )
  {
LABEL_9:
    v11 = sub_32C8C(0, "STATUS", "F", 0);
    v12 = sub_32EA8(v11, "When", (const char *)&dword_75B18, 0);
    v24 = -1;
    v13 = sub_32D40(v12, "Code", (const char *)&v24, 0);
    sprintf(s, "%d", v22);
    v14 = v13;
    goto LABEL_10;
  }
  if ( dword_72F40 != v22 )
  {
    v9 = dword_72F3C;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[4];
      ++v10;
      v9 += 4;
      if ( v8 == 4 )
        goto LABEL_9;
      if ( v9[1] == v22 )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case 2:
      v23[0] = 73;
      break;
    case 3:
      v23[0] = 83;
      break;
    case 1:
      v23[0] = 87;
      break;
    default:
      v23[0] = 69;
      break;
  }
  v18 = 4 * v10;
  v23[1] = 0;
  switch ( dword_72F3C[v18 + 2] )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], a3);
      break;
    case 5:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], dword_77FC0);
      break;
    case 6:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], a3, dword_77FC0 - 1);
      break;
    case 7:
      sprintf(s, (const char *)dword_72F3C[v18 + 3]);
      break;
    case 8:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], "command");
      break;
    case 9:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], a3, *(_DWORD *)(*(_DWORD *)(dword_78260 + 4 * a3) + 196));
      break;
    case 10:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], a4);
      break;
    case 11:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], a3, a4);
      break;
    case 12:
      v21 = "false";
      if ( a3 )
        v21 = "true";
      sprintf(s, (const char *)dword_72F3C[v18 + 3], v21);
      break;
    case 13:
      sprintf(s, (const char *)dword_72F3C[v18 + 3], a4, a3);
      break;
    default:
      strcpy(s, (const char *)dword_72F3C[v18 + 3]);
      break;
  }
  v19 = sub_32C8C(0, "STATUS", v23, 0);
  v20 = sub_32EA8(v19, "When", (const char *)&dword_75B18, 0);
  v14 = sub_32D40(v20, "Code", (const char *)&v22, 0);
LABEL_10:
  v15 = sub_32C68(v14, "Msg", s, 0);
  v16 = sub_32C68(v15, "Description", (const char *)off_72D14, 0);
  result = sub_323A4(a1, (int)v16, a5, 0);
  if ( a5 )
    return sub_30638(a1, (char *)word_686A0);
  return result;
}
// 33080: control flows out of bounds to 33084
// 72D14: using guessed type _UNKNOWN *off_72D14;
// 72F3C: using guessed type int dword_72F3C[];
// 72F40: using guessed type int dword_72F40;
// 75B18: using guessed type int dword_75B18;
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (000332E4) --------------------------------------------------------
int __fastcall sub_332E4(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32ECC(a1, 124, 0, 0, a4);
}

//----- (000333B8) --------------------------------------------------------
int __fastcall sub_333B8(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32ECC(a1, 102, 0, 0, a4);
}

//----- (000333CC) --------------------------------------------------------
int __fastcall sub_333CC(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r5
  char *v7; // r0
  char *v8; // r7
  int v9; // r8
  int v10; // r10
  int v11; // r9
  int v12; // r2
  bool v13; // zf
  _BOOL4 v14; // r4
  const char *v16; // r3
  int v17; // r1
  unsigned __int8 v18; // [sp+20h] [bp+20h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = strchr(a3, 44);
    v8 = v7;
    if ( v7 && (*v7 = 0, v7 != (char *)-1) && (v9 = (unsigned __int8)v7[1], v7[1]) )
    {
      if ( !strcasecmp(a3, "all") )
      {
        v11 = 0;
        v10 = 1;
      }
      else
      {
        if ( strcasecmp(a3, "bestshare") )
        {
          v18 = a4;
          a1 = v5;
          v16 = a3;
          v17 = 95;
          return sub_32ECC(a1, v17, 0, (int)v16, v18);
        }
        v10 = 0;
        v11 = 1;
      }
      v12 = LOBYTE((*_ctype_tolower_loc())[v9]);
      v13 = v12 == 102;
      if ( v12 != 102 )
        v13 = v12 == 116;
      v8[1] = v12;
      if ( v13 )
      {
        v14 = v12 == 116;
        if ( v12 == 116 )
          sub_1BFD8();
        if ( v10 )
          sub_1B220();
        if ( v11 )
          sub_15FEC();
        a1 = v5;
        v16 = "All";
        if ( v14 )
        {
          v17 = 96;
          v18 = a4;
          if ( !v10 )
            v16 = "BestShare";
        }
        else
        {
          v18 = a4;
          v17 = 97;
          if ( !v10 )
            v16 = "BestShare";
        }
      }
      else
      {
        v18 = a4;
        a1 = v5;
        v16 = 0;
        v17 = 76;
      }
    }
    else
    {
      v18 = a4;
      a1 = v5;
      v16 = 0;
      v17 = 75;
    }
  }
  else
  {
    v18 = a4;
    v16 = 0;
    v17 = 94;
  }
  return sub_32ECC(a1, v17, 0, (int)v16, v18);
}

//----- (00033580) --------------------------------------------------------
int __fastcall sub_33580(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32ECC(a1, 88, 0, 0, a4);
}

//----- (00033594) --------------------------------------------------------
int __fastcall sub_33594(unsigned int *a1, int a2, const char *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r5
  char *v7; // r0
  int v8; // r2
  unsigned int v9; // r7
  int v10; // r3
  int v11; // r1
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = strchr(a3, 44);
    v8 = (int)v7;
    if ( v7 )
    {
      *v7 = 0;
      v9 = strtol(v7 + 1, 0, 10);
      if ( v9 > 0x270F )
      {
        v13 = a4;
        a1 = v5;
        v8 = v9;
        v10 = (int)a3;
        v11 = 84;
      }
      else
      {
        if ( !strcasecmp(a3, "queue") )
        {
          dword_72C18 = v9;
        }
        else if ( !strcasecmp(a3, "scantime") )
        {
          dword_72C30 = v9;
        }
        else
        {
          if ( strcasecmp(a3, "expiry") )
          {
            v13 = a4;
            a1 = v5;
            v8 = 0;
            v10 = (int)a3;
            v11 = 83;
            return sub_32ECC(a1, v11, v8, v10, v13);
          }
          dword_72C34 = v9;
        }
        v13 = a4;
        a1 = v5;
        v8 = v9;
        v10 = (int)a3;
        v11 = 82;
      }
    }
    else
    {
      v13 = a4;
      a1 = v5;
      v10 = (int)a3;
      v11 = 86;
    }
  }
  else
  {
    v8 = 0;
    v13 = a4;
    v10 = 0;
    v11 = 85;
  }
  return sub_32ECC(a1, v11, v8, v10, v13);
}
// 72C18: using guessed type int dword_72C18;
// 72C30: using guessed type int dword_72C30;
// 72C34: using guessed type int dword_72C34;

//----- (000336EC) --------------------------------------------------------
int __fastcall sub_336EC(int a1, int a2, _BYTE *a3, int a4)
{
  int v7; // r2
  int v8; // r3
  int v9; // r4
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  int result; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r1
  char *v25; // r2
  int v26; // r3

  if ( a3 )
  {
    v7 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*a3]);
    *a3 = v7;
    switch ( v7 )
    {
      case 'd':
        v8 = (unsigned __int8)byte_75C49 ^ 1;
        byte_75C49 ^= 1u;
        byte_75C48 = v8;
        if ( v8 )
          goto LABEL_4;
        break;
      case 'n':
        byte_75C48 = 0;
        byte_75C49 = 0;
        byte_78AA0 = 0;
        byte_781A8 = 0;
        byte_78680 = 0;
        byte_78682 = 0;
        break;
      case 'p':
        byte_78680 ^= 1u;
        byte_75C48 = byte_78680;
        break;
      case 'q':
        byte_78AA0 ^= 1u;
        break;
      case 'r':
        v25 = &byte_781A8;
        goto LABEL_15;
      case 's':
        byte_78940 = 1;
        break;
      case 'v':
        v25 = &byte_75C48;
LABEL_15:
        v26 = (unsigned __int8)*v25 ^ 1;
        *v25 = v26;
        if ( v26 )
LABEL_4:
          byte_78AA0 = 0;
        break;
      case 'w':
        byte_78682 ^= 1u;
        break;
      default:
        break;
    }
  }
  sub_32ECC((unsigned int *)a1, 79, 0, 0, a4);
  if ( a4 )
  {
    v9 = sub_30638((unsigned int *)a1, ",\"DEBUG\":[");
    v10 = sub_32E60(0, "Silent", &byte_78940, 0);
    v11 = sub_32E60(v10, "Quiet", &byte_78AA0, 0);
    v12 = sub_32E60(v11, "Verbose", &byte_75C48, 0);
    v13 = sub_32E60(v12, "Debug", &byte_75C49, 0);
    v14 = sub_32E60(v13, "RPCProto", &byte_781A8, 0);
    v15 = sub_32E60(v14, "PerDevice", &byte_78680, 0);
    v16 = sub_32E60(v15, "WorkTime", &byte_78682, 0);
    result = sub_323A4((unsigned int *)a1, (int)v16, 1, 0);
    if ( v9 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_30638((unsigned int *)a1, "DEBUG,");
    v18 = sub_32E60(0, "Silent", &byte_78940, 0);
    v19 = sub_32E60(v18, "Quiet", &byte_78AA0, 0);
    v20 = sub_32E60(v19, "Verbose", &byte_75C48, 0);
    v21 = sub_32E60(v20, "Debug", &byte_75C49, 0);
    v22 = sub_32E60(v21, "RPCProto", &byte_781A8, 0);
    v23 = sub_32E60(v22, "PerDevice", &byte_78680, 0);
    v24 = sub_32E60(v23, "WorkTime", &byte_78682, 0);
    return sub_323A4((unsigned int *)a1, (int)v24, 0, 0);
  }
  return result;
}
// 33724: control flows out of bounds to 33728
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 781A8: using guessed type char byte_781A8;
// 78680: using guessed type char byte_78680;
// 78682: using guessed type char byte_78682;
// 78940: using guessed type char byte_78940;
// 78AA0: using guessed type char byte_78AA0;

//----- (000339F8) --------------------------------------------------------
int __fastcall sub_339F8(unsigned int *a1, int a2, _BYTE *a3, unsigned __int8 a4)
{
  unsigned int *v5; // r6
  int v7; // r5
  int v8; // r1
  bool v9; // zf
  _BOOL4 v10; // r12
  int v11; // r1
  int v12; // r2
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  v5 = a1;
  if ( a3 && *a3 )
  {
    v7 = (unsigned __int8)*a3;
    v8 = LOBYTE((*_ctype_tolower_loc())[v7]);
    v9 = v8 == 102;
    if ( v8 != 102 )
      v9 = v8 == 116;
    *a3 = v8;
    if ( v9 )
    {
      v14 = a4;
      v10 = v8 == 116;
      a1 = v5;
      v11 = 77;
      byte_7844D = v10;
      v12 = v10;
    }
    else
    {
      v12 = 0;
      v14 = a4;
      a1 = v5;
      v11 = 76;
    }
  }
  else
  {
    v12 = 0;
    v14 = a4;
    v11 = 75;
  }
  return sub_32ECC(a1, v11, v12, 0, v14);
}
// 7844D: using guessed type char byte_7844D;

//----- (00033AA4) --------------------------------------------------------
int __fastcall sub_33AA4(int a1, int a2, const char *a3, int a4, unsigned __int8 a5)
{
  const char *v8; // r0
  _UNKNOWN **v9; // r4
  const char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r2
  int v13; // r8
  int v14; // r9
  char *v15; // r1
  int v16; // r10
  const char *v17; // r2
  _DWORD *v18; // r0
  const char *v19; // r2
  _DWORD *v20; // r0
  int result; // r0
  char s[100]; // [sp+Ch] [bp-64h] BYREF

  if ( !a3 || !*a3 )
    return sub_32ECC((unsigned int *)a1, 71, 0, 0, a4);
  v8 = (const char *)off_7336C;
  if ( off_7336C )
  {
    v9 = &off_7336C;
    while ( strcmp(v8, a3) )
    {
      v10 = (const char *)v9[3];
      v9 += 3;
      v8 = v10;
      if ( !v10 )
        goto LABEL_23;
    }
    sprintf(s, "|%s|", a3);
    v11 = _ctype_toupper_loc();
    v12 = (*v11)[a5];
    if ( v12 == (*v11)[87] || strstr(*((const char **)&unk_78B4C + v12 - (*v11)[65]), s) )
    {
      v13 = 1;
      v14 = 1;
    }
    else
    {
      v13 = 0;
      v14 = 1;
    }
  }
  else
  {
LABEL_23:
    v13 = (int)v8;
    v14 = (int)v8;
  }
  sub_32ECC((unsigned int *)a1, 72, 0, 0, a4);
  v15 = "CHECK,";
  if ( a4 )
    v15 = ",\"CHECK\":[";
  v16 = sub_30638((unsigned int *)a1, v15);
  if ( v14 )
    v17 = "Y";
  else
    v17 = "N";
  v18 = sub_32CB0(0, "Exists", v17, 0);
  if ( v13 )
    v19 = "Y";
  else
    v19 = "N";
  v20 = sub_32CB0(v18, "Access", v19, 0);
  result = sub_323A4((unsigned int *)a1, (int)v20, a4, 0);
  if ( (v16 & a4) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 7336C: using guessed type _UNKNOWN *off_7336C;

//----- (00033C3C) --------------------------------------------------------
int __fastcall sub_33C3C(int a1, int a2, int a3, int a4)
{
  int result; // r0
  int v7; // r10
  _DWORD *v8; // r9
  int v9; // r4
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  const char *v14; // r2
  _DWORD *v15; // r0
  const char *v16; // r2
  _DWORD *v17; // r0
  const char *v18; // r2
  _DWORD *v19; // r0
  _BOOL4 v20; // r3
  int v21; // [sp+Ch] [bp-4h] BYREF

  if ( !dword_78548 )
    return sub_32ECC((unsigned int *)a1, 10, 0, 0, a4);
  result = sub_32ECC((unsigned int *)a1, 69, 0, 0, a4);
  if ( a4 )
  {
    result = sub_30638((unsigned int *)a1, ",\"DEVDETAILS\":[");
    v7 = result;
  }
  else
  {
    v7 = 0;
  }
  v8 = 0;
  v21 = 0;
  if ( dword_78548 > 0 )
  {
    result = 0;
    do
    {
      v9 = sub_1B1A8(result);
      v10 = sub_32D40(v8, "DEVDETAILS", (const char *)&v21, 0);
      v11 = sub_32C8C(v10, "Name", *(const char **)(*(_DWORD *)(v9 + 4) + 8), 0);
      v12 = sub_32D40(v11, "ID", (const char *)(v9 + 8), 0);
      v13 = sub_32C8C(v12, "Driver", *(const char **)(*(_DWORD *)(v9 + 4) + 4), 0);
      v14 = *(const char **)(v9 + 168);
      if ( !v14 )
        v14 = "";
      v15 = sub_32CB0(v13, "Kernel", v14, 0);
      v16 = *(const char **)(v9 + 12);
      if ( !v16 )
        v16 = "";
      v17 = sub_32CB0(v15, "Model", v16, 0);
      v18 = *(const char **)(v9 + 16);
      if ( !v18 )
        v18 = "";
      v19 = sub_32CB0(v17, "Device Path", v18, 0);
      v20 = a4;
      if ( a4 )
        v20 = v21 > 0;
      v8 = (_DWORD *)sub_323A4((unsigned int *)a1, (int)v19, a4, v20);
      result = ++v21;
    }
    while ( v21 < dword_78548 );
  }
  if ( v7 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 78548: using guessed type int dword_78548;

//----- (00033DE0) --------------------------------------------------------
void __fastcall sub_33DE0(unsigned int *a1, int a2, char *nptr, int a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r3
  int v9; // r1
  int v10; // r0
  int v11; // r7
  int v12; // r4
  char *v13; // r0
  char *v14; // r8
  unsigned __int8 v15; // [sp+20h] [bp+18h]

  v6 = a1;
  if ( !dword_77FC0 )
  {
    v15 = a4;
    v7 = 0;
    v8 = 0;
    v9 = 8;
    goto LABEL_5;
  }
  if ( !nptr || !*nptr )
  {
    v7 = 0;
    v15 = a4;
    v8 = 0;
    v9 = 25;
LABEL_5:
    sub_32ECC(a1, v9, v7, v8, v15);
    return;
  }
  v10 = strtol(nptr, 0, 10);
  v11 = v10;
  if ( v10 < 0 || v10 >= dword_77FC0 )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 26;
    v8 = 0;
    goto LABEL_5;
  }
  if ( dword_77FC0 <= 1 )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 66;
    v8 = 0;
    goto LABEL_5;
  }
  v12 = *(_DWORD *)(dword_78260 + 4 * v10);
  if ( v12 == sub_1D9A0() )
    sub_1A600(0);
  if ( v12 == sub_1D9A0() )
  {
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v9 = 67;
    v8 = 0;
    goto LABEL_5;
  }
  v13 = *(char **)(v12 + 196);
  *(_DWORD *)(v12 + 132) = 0;
  v14 = sub_30370(v13, a4);
  if ( v14 == *(char **)(v12 + 196) )
  {
    sub_15A00(v12);
    v15 = a4;
    a1 = v6;
    v7 = v11;
    v8 = (int)v14;
    v9 = 68;
    goto LABEL_5;
  }
  sub_15A00(v12);
  sub_32ECC(v6, 68, v11, (int)v14, a4);
  free(v14);
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00033F8C) --------------------------------------------------------
int __fastcall sub_33F8C(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  unsigned __int8 v13; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_77FC0 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_77FC0 )
      {
        v13 = a4;
        a1 = v6;
        v7 = v10;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_78260 + 4 * v9);
        if ( *(_DWORD *)(v11 + 132) )
        {
          if ( dword_7840C <= 1 )
          {
            v13 = a4;
            a1 = v6;
            v7 = v10;
            v8 = 51;
          }
          else
          {
            *(_DWORD *)(v11 + 132) = 0;
            if ( v11 == sub_1D9A0() )
              sub_1A600(0);
            v13 = a4;
            a1 = v6;
            v7 = v10;
            v8 = 48;
          }
        }
        else
        {
          v13 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 50;
        }
      }
    }
    else
    {
      v7 = 0;
      v13 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v13 = a4;
    v8 = 8;
  }
  return sub_32ECC(a1, v8, v7, 0, v13);
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;
// 7840C: using guessed type int dword_7840C;

//----- (000340D4) --------------------------------------------------------
int __fastcall sub_340D4(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r0
  int v10; // r7
  int v11; // r4
  int v12; // r8
  unsigned __int8 v14; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_77FC0 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= dword_77FC0 )
      {
        v14 = a4;
        a1 = v6;
        v7 = v10;
        v8 = 26;
      }
      else
      {
        v11 = *(_DWORD *)(dword_78260 + 4 * v9);
        if ( *(_DWORD *)(v11 + 132) == 1 )
        {
          v14 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 49;
        }
        else
        {
          *(_DWORD *)(v11 + 132) = 1;
          v12 = *(_DWORD *)(v11 + 4);
          if ( v12 < *(_DWORD *)(sub_1D9A0() + 4) )
            sub_1A600(v11);
          v14 = a4;
          a1 = v6;
          v7 = v10;
          v8 = 47;
        }
      }
    }
    else
    {
      v7 = 0;
      v14 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v14 = a4;
    v8 = 8;
  }
  return sub_32ECC(a1, v8, v7, 0, v14);
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (000341F8) --------------------------------------------------------
int __fastcall sub_341F8(unsigned int *a1, int a2, char *s, unsigned __int8 a4, int a5)
{
  unsigned int *v7; // r7
  int v8; // r2
  char *v9; // r10
  int v10; // r0
  int v11; // r1
  char *v12; // r3
  int v14; // r4
  int v15; // r0
  int v16; // r5
  unsigned __int8 v17; // [sp+20h] [bp+20h]

  v7 = a1;
  v8 = dword_77FC0;
  if ( dword_77FC0 )
  {
    if ( s && *s )
    {
      v9 = strchr(s, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol(s, 0, 10);
        if ( v10 >= 0 && v10 < dword_77FC0 )
        {
          v14 = *(_DWORD *)(dword_78260 + 4 * v10);
          v15 = strtol(v9 + 1, 0, 10);
          v16 = v15;
          if ( v15 < 0 )
          {
            v12 = *(char **)(v14 + 196);
            a1 = v7;
            v17 = a4;
            v8 = v16;
            v11 = 121;
          }
          else
          {
            *(_DWORD *)(v14 + 56) = v15;
            sub_15218();
            v12 = *(char **)(v14 + 196);
            a1 = v7;
            v17 = a4;
            v8 = v16;
            v11 = 122;
          }
        }
        else
        {
          v8 = v10;
          v17 = a4;
          a1 = v7;
          v11 = 26;
          v12 = 0;
        }
      }
      else
      {
        v17 = a4;
        a1 = v7;
        v8 = 0;
        v12 = s;
        v11 = 86;
      }
    }
    else
    {
      v8 = 0;
      v17 = a4;
      v12 = 0;
      v11 = 25;
    }
  }
  else
  {
    v17 = a4;
    v11 = 8;
    v12 = 0;
  }
  return sub_32ECC(a1, v11, v8, (int)v12, v17);
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00034340) --------------------------------------------------------
int __fastcall sub_34340(unsigned int *a1, int a2, char *s, int a4)
{
  const char *v4; // r8
  _BYTE *v6; // r2
  _BYTE *v7; // r3
  int v8; // r5
  char *v9; // r10
  int v10; // r0
  int v11; // r1
  _BYTE *v12; // r2
  int v13; // r3
  int v14; // lr
  int v15; // r12
  int v16; // t1
  bool v17; // zf
  int v18; // lr
  int v19; // r12
  int v20; // r3
  int v21; // r2
  int v22; // [sp+0h] [bp-3Ch] BYREF
  _BYTE v23[4]; // [sp+8h] [bp-34h] BYREF
  unsigned int *v24; // [sp+Ch] [bp-30h]
  int v25; // [sp+10h] [bp-2Ch]
  int *v26; // [sp+14h] [bp-28h]

  v4 = s;
  v25 = a4;
  v24 = a1;
  v26 = &v22;
  if ( !dword_77FC0 )
    return sub_32ECC(a1, 8, 0, 0, a4);
  if ( !s || !*s )
    return sub_32ECC(v24, 25, 0, 0, v25);
  if ( dword_77FC0 > 0 )
  {
    v6 = &v23[dword_77FC0];
    v7 = v23;
    do
      *v7++ = 0;
    while ( v7 != v6 );
  }
  v8 = 0;
  while ( 1 )
  {
    v9 = strchr(v4, 44);
    if ( v9 )
      *v9++ = 0;
    v10 = strtol(v4, 0, 10);
    v4 = v9;
    if ( v10 < 0 )
      return sub_32ECC(v24, 26, v10, 0, v25);
    v11 = dword_77FC0;
    if ( dword_77FC0 <= v10 )
      return sub_32ECC(v24, 26, v10, 0, v25);
    if ( v23[v10] )
      return sub_32ECC(v24, 74, v10, 0, v25);
    *(_DWORD *)&v23[4 * v10] = v8;
    v23[v10] = 1;
    ++v8;
    if ( !v9 )
      break;
    if ( !*v9 )
    {
      if ( v11 <= 0 )
        goto LABEL_29;
      break;
    }
  }
  v12 = v23;
  v13 = 0;
  v14 = dword_78260;
  do
  {
    v16 = (unsigned __int8)*v12++;
    v15 = v16;
    v17 = v16 == 0;
    if ( v16 )
    {
      v15 = *(_DWORD *)(v14 + v13);
      v4 = *(const char **)&v23[v13];
    }
    v13 += 4;
    if ( !v17 )
      *(_DWORD *)(v15 + 4) = v4;
  }
  while ( v12 != &v23[v11] );
  v18 = dword_78260;
  v19 = 0;
LABEL_24:
  while ( 2 )
  {
    v20 = 0;
    while ( 1 )
    {
      if ( !v23[v20] )
      {
        v21 = *(_DWORD *)(v18 + 4 * v20);
        if ( *(_DWORD *)(v21 + 4) == v19 )
          break;
      }
      if ( ++v20 == v11 )
      {
        if ( ++v19 != v11 )
          goto LABEL_24;
        goto LABEL_29;
      }
    }
    ++v19;
    *(_DWORD *)(v21 + 4) = v8++;
    v23[v20] = 1;
    if ( v19 != v11 )
      continue;
    break;
  }
LABEL_29:
  if ( *(_DWORD *)(sub_1D9A0() + 4) )
    sub_1A600(0);
  return sub_32ECC(v24, 73, 0, 0, v25);
}
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00034598) --------------------------------------------------------
void __fastcall sub_34598(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v7; // r7
  int *v8; // r7
  char *v9; // r4
  char *s; // [sp+Ch] [bp-Ch] BYREF
  const char *v11; // [sp+10h] [bp-8h] BYREF
  const char *v12; // [sp+14h] [bp-4h] BYREF

  if ( a3 && *a3 )
  {
    if ( sub_31EBC((unsigned __int8 *)a3, (unsigned __int8 **)&s, &v11, &v12) )
    {
      v8 = (int *)sub_17974();
      sub_154B4((int)v8, s);
      sub_26B24((int)v8, 1, s, v11, v12);
      v9 = sub_30370(s, a4);
      sub_32ECC(a1, 55, *v8, (int)v9, a4);
      if ( v9 != s )
        free(v9);
    }
    else
    {
      v7 = sub_30370(a3, a4);
      sub_32ECC(a1, 53, 0, (int)v7, a4);
      if ( v7 != a3 )
        free(v7);
    }
  }
  else
  {
    sub_32ECC(a1, 52, 0, 0, a4);
  }
}

//----- (000346A0) --------------------------------------------------------
int __fastcall sub_346A0(unsigned int *a1, int a2, char *nptr, unsigned __int8 a4, int a5)
{
  unsigned int *v6; // r6
  int v7; // r2
  int v8; // r1
  int v9; // r7
  int v11; // r4
  unsigned __int8 v12; // [sp+18h] [bp+18h]

  v6 = a1;
  if ( dword_77FC0 )
  {
    if ( nptr && *nptr )
    {
      v9 = strtol(nptr, 0, 10);
      if ( pthread_mutex_lock(&stru_78838) )
        sub_B6BC("switchpool", 2907);
      sub_32000(&stru_78850, "switchpool", 2907);
      if ( pthread_mutex_unlock(&stru_78838) )
        sub_B794("switchpool", 2907);
      if ( v9 >= 0 && v9 < dword_77FC0 )
      {
        v11 = *(_DWORD *)(dword_78260 + 4 * v9);
        *(_DWORD *)(v11 + 132) = 1;
        if ( pthread_rwlock_unlock(&stru_78850) )
          sub_B728("switchpool", 2917);
        off_72D18();
        sub_1A600(v11);
        v12 = a4;
        a1 = v6;
        v7 = v9;
        v8 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&stru_78850) )
          sub_B728("switchpool", 2910);
        off_72D18();
        v12 = a4;
        a1 = v6;
        v7 = v9;
        v8 = 26;
      }
    }
    else
    {
      v7 = 0;
      v12 = a4;
      v8 = 25;
    }
  }
  else
  {
    v7 = 0;
    v12 = a4;
    v8 = 8;
  }
  return sub_32ECC(a1, v8, v7, 0, v12);
}
// 72D18: using guessed type int (*off_72D18)();
// 77FC0: using guessed type int dword_77FC0;
// 78260: using guessed type int dword_78260;

//----- (00034900) --------------------------------------------------------
int __fastcall sub_34900(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32ECC(a1, 10, 0, 0, a4);
}

//----- (00034914) --------------------------------------------------------
int __fastcall sub_34914(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32ECC(a1, 10, 0, 0, a4);
}

//----- (00034AD0) --------------------------------------------------------
int __fastcall sub_34AD0(int a1, int a2, int a3, int a4)
{
  int v6; // r4
  _DWORD *v7; // r0
  _DWORD *v8; // r0
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  int result; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r1

  sub_32ECC((unsigned int *)a1, 22, 0, 0, a4);
  if ( a4 )
  {
    v6 = sub_30638((unsigned int *)a1, ",\"VERSION\":[");
    v7 = sub_32C8C(0, "CGMiner", a49, 0);
    v8 = sub_32CB0(v7, "API", "3.1", 0);
    v9 = sub_32C8C(v8, "Miner", (const char *)&dword_759D0, 0);
    v10 = sub_32C8C(v9, "CompileTime", s, 0);
    v11 = sub_32C8C(v10, "Type", byte_7568C, 0);
    result = sub_323A4((unsigned int *)a1, (int)v11, 1, 0);
    if ( v6 )
      *(_BYTE *)(a1 + 13) = 1;
  }
  else
  {
    sub_30638((unsigned int *)a1, "VERSION,");
    v13 = sub_32C8C(0, "CGMiner", a49, 0);
    v14 = sub_32CB0(v13, "API", "3.1", 0);
    v15 = sub_32C8C(v14, "Miner", (const char *)&dword_759D0, 0);
    v16 = sub_32C8C(v15, "CompileTime", s, 0);
    v17 = sub_32C8C(v16, "Type", byte_7568C, 0);
    return sub_323A4((unsigned int *)a1, (int)v17, 0, 0);
  }
  return result;
}
// 759D0: using guessed type int dword_759D0;

//----- (00034C30) --------------------------------------------------------
void __fastcall sub_34C30(unsigned int *a1, int a2, char *a3, int a4)
{
  char *v4; // r4
  FILE *v7; // r0
  FILE *v8; // r5
  char *v9; // r5
  char *v10; // r8
  char v11[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = a3;
  if ( !a3 || !*a3 )
  {
    v4 = v11;
    sub_16088(v11);
  }
  v7 = fopen(v4, "w");
  v8 = v7;
  if ( v7 )
  {
    sub_15A9C(v7);
    fclose(v8);
    v9 = sub_30370(v4, a4);
    sub_32ECC(a1, 44, 0, (int)v9, a4);
    if ( v9 != v4 )
      free(v9);
  }
  else
  {
    v10 = sub_30370(v4, a4);
    sub_32ECC(a1, 43, 0, (int)v10, a4);
    if ( v10 != v4 )
      free(v10);
  }
}

//----- (00034D0C) --------------------------------------------------------
int __fastcall sub_34D0C(unsigned int *a1, int a2, int a3, unsigned __int8 a4)
{
  return sub_32ECC(a1, 46, 0, 0, a4);
}

//----- (00034D20) --------------------------------------------------------
_DWORD *__fastcall sub_34D20(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 17, a3, a4);
}

//----- (00034FC4) --------------------------------------------------------
int __fastcall sub_34FC4(unsigned int *a1, int a2, const char *a3, const char *a4, int a5, unsigned __int8 a6)
{
  _DWORD *v9; // r0
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  int v18; // r2
  int v19; // r1
  int v20; // r3
  _BOOL4 v21; // r3
  int v23; // [sp+4h] [bp-10h] BYREF
  double v24; // [sp+8h] [bp-Ch] BYREF

  v23 = a2;
  v24 = dbl_77AE8 / 1000.0 / dbl_72438;
  v9 = sub_32D40(0, "STATS", (const char *)&v23, 0);
  v10 = sub_32C8C(v9, "ID", a3, 0);
  v11 = sub_32E3C(v10, "Elapsed", (const char *)&dbl_72438, 0);
  v12 = sub_32D88(v11, "Calls", a4, 0);
  v13 = sub_32E84(v12, "Wait", a4 + 4, 0);
  v14 = sub_32E84(v13, "Max", a4 + 12, 0);
  v15 = sub_32E84(v14, "Min", a4 + 20, 0);
  v16 = sub_32C8C(v15, "GHS 5s", byte_759C0, 0);
  v17 = sub_34D20(v16, "GHS av", (const char *)&v24, 0);
  v19 = (int)v17;
  if ( a5 )
  {
    if ( v17 )
      v18 = v17[4];
    else
      v19 = a5;
    if ( v17 )
    {
      v20 = *(_DWORD *)(a5 + 16);
      *(_DWORD *)(a5 + 16) = v18;
      *(_DWORD *)(v17[4] + 20) = a5;
      *(_DWORD *)(v20 + 20) = v17;
      v17[4] = v20;
    }
  }
  if ( a6 )
    v21 = v23 > 0;
  else
    v21 = 0;
  sub_323A4(a1, v19, a6, v21);
  return v23 + 1;
}
// 34FC4: too many cbuild loops
// 350B4: variable 'v18' is possibly undefined
// 72438: using guessed type double dbl_72438;
// 77AE8: using guessed type double dbl_77AE8;

//----- (000353A0) --------------------------------------------------------
_DWORD *__fastcall sub_353A0(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 18, a3, a4);
}

//----- (000353C4) --------------------------------------------------------
_DWORD *__fastcall sub_353C4(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 19, a3, a4);
}

//----- (000353E8) --------------------------------------------------------
_DWORD *__fastcall sub_353E8(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 20, a3, a4);
}

//----- (0003540C) --------------------------------------------------------
_DWORD *__fastcall sub_3540C(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 21, a3, a4);
}

//----- (00035430) --------------------------------------------------------
_DWORD *__fastcall sub_35430(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 22, a3, a4);
}

//----- (00035454) --------------------------------------------------------
_DWORD *__fastcall sub_35454(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 23, a3, a4);
}

//----- (00035478) --------------------------------------------------------
_DWORD *__fastcall sub_35478(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 24, a3, a4);
}

//----- (00035624) --------------------------------------------------------
_DWORD *__fastcall sub_35624(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 25, a3, a4);
}

//----- (00035648) --------------------------------------------------------
int __fastcall sub_35648(int a1, int a2, int a3, int a4)
{
  char *v5; // r1
  int v6; // r9
  __int64 v7; // r0
  __int64 v8; // d9
  double v9; // r0
  double v10; // d8
  int v11; // r1
  double v12; // d16
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _DWORD *v26; // r0
  _DWORD *v27; // r0
  _DWORD *v28; // r0
  _DWORD *v29; // r0
  _DWORD *v30; // r0
  _DWORD *v31; // r0
  _DWORD *v32; // r0
  _DWORD *v33; // r12
  __int64 v34; // r0
  double v35; // d8
  double v36; // r0
  double v37; // d16
  _DWORD *v38; // r11
  double v39; // r0
  double v40; // d16
  _DWORD *v41; // r0
  double v42; // d16
  double v43; // d16
  _DWORD *v44; // r0
  double v45; // d16
  double v46; // d16
  _DWORD *v47; // r0
  _DWORD *v48; // r5
  int result; // r0
  time_t v50; // r0
  int v51; // r11
  int v52; // r11
  int v53; // r10
  time_t v54; // r0
  double v55; // d16
  int v56; // r11
  _DWORD *v58; // [sp+10h] [bp-44h]
  double v59; // [sp+18h] [bp-3Ch] BYREF
  double v60; // [sp+20h] [bp-34h] BYREF
  double v61; // [sp+28h] [bp-2Ch] BYREF
  double v62; // [sp+30h] [bp-24h] BYREF
  double v63; // [sp+38h] [bp-1Ch] BYREF
  double v64; // [sp+40h] [bp-14h] BYREF
  double v65; // [sp+48h] [bp-Ch] BYREF

  sub_32ECC((unsigned int *)a1, 11, 0, 0, a4);
  v5 = "SUMMARY,";
  if ( a4 )
    v5 = ",\"SUMMARY\":[";
  v6 = sub_30638((unsigned int *)a1, v5);
  if ( pthread_mutex_lock(&stru_781AC) )
    sub_B6BC("summary", 2793);
  LODWORD(v7) = sub_59FC8(dbl_78410 + dbl_78498 + dbl_78250);
  *(_QWORD *)&dword_77F28 = v7;
  v8 = v7;
  LODWORD(v9) = sub_59F1C(qword_78248);
  v10 = dbl_72438;
  v60 = dbl_77AE8 / 1000.0 / dbl_72438;
  if ( dbl_72438 == 0.0 )
  {
    v59 = v9 * 60.0;
    v10 = 1.0;
  }
  else
  {
    v59 = v9 / dbl_72438 * 60.0;
  }
  LODWORD(v12) = sub_59F1C(v8);
  HIDWORD(v12) = v11;
  v61 = v12 / v10 * 60.0;
  if ( byte_75C68 )
  {
    v50 = time(0);
    srand(v50);
    if ( *off_739C0 == 122 && off_739C0[1] == 57 && !off_739C0[2] )
    {
      v51 = dword_75C78;
      v52 = 14 * v51 + rand() % 2;
      v53 = v52 % 5;
    }
    else if ( !strcmp(off_739C0, "z9-mini") )
    {
      v56 = dword_75C78;
      v52 = 3 * v56 + 1 + rand() % 2;
      v53 = v52 % 5;
    }
    else
    {
      v53 = 4;
      v52 = 14;
    }
    v54 = time(0);
    srand(v54);
    v55 = (double)(rand() % 99) / 100.0;
    dbl_75C70 = (double)v52 + v55;
    v60 = (double)v52 + v55;
    v59 = v55 + (double)v53;
    v61 = (double)(rand() % 4 + 100) + 0.27;
    sprintf(byte_759C0, "%f", v60 + 0.79);
  }
  v13 = sub_32E3C(0, "Elapsed", (const char *)&dbl_72438, 1);
  v14 = sub_32C8C(v13, "GHS 5s", byte_759C0, 0);
  v15 = sub_34D20(v14, "GHS av", (const char *)&v60, 0);
  v16 = sub_32D64(v15, "Found Blocks", (const char *)&dword_786E0, 1);
  v17 = sub_32DF4(v16, "Getworks", (const char *)&dword_78470, 1);
  v18 = sub_32DF4(v17, "Accepted", (const char *)&qword_78248, 1);
  v19 = sub_32DF4(v18, "Rejected", (const char *)&qword_78520, 1);
  v20 = sub_32D40(v19, "Hardware Errors", (const char *)&dword_786CC, 1);
  v21 = sub_353E8(v20, "Utility", (const char *)&v59, 0);
  v22 = sub_32DF4(v21, "Discarded", (const char *)&dword_785F0, 1);
  v23 = sub_32DF4(v22, "Stale", (const char *)&dword_78AA8, 1);
  v24 = sub_32D64(v23, "Get Failures", (const char *)&dword_78264, 1);
  v25 = sub_32D64(v24, "Local Work", (const char *)&dword_782F4, 1);
  v26 = sub_32D64(v25, "Remote Failures", (const char *)&dword_77C90, 1);
  v27 = sub_32D64(v26, "Network Blocks", (const char *)&dword_78944, 1);
  v28 = sub_353A0(v27, "Total MH", (const char *)&dbl_77AE8, 1);
  v29 = sub_353E8(v28, "Work Utility", (const char *)&v61, 0);
  v30 = sub_35478(v29, "Difficulty Accepted", (const char *)&dbl_78410, 1);
  v31 = sub_35478(v30, "Difficulty Rejected", (const char *)&dbl_78498, 1);
  v32 = sub_35478(v31, "Difficulty Stale", (const char *)&dbl_78250, 1);
  v33 = sub_32DD0(v32, "Best Share", (const char *)&qword_73D50, 1);
  v34 = *(_QWORD *)&dword_77F28 + dword_786CC;
  if ( v34 )
  {
    v58 = v33;
    v35 = (double)dword_786CC;
    LODWORD(v36) = sub_59F1C(v34);
    v33 = v58;
    v37 = v35 / v36;
  }
  else
  {
    v37 = 0.0;
  }
  v62 = v37;
  v38 = sub_35624(v33, "Device Hardware%", (const char *)&v62, 0);
  if ( *(_QWORD *)&dword_77F28 )
  {
    LODWORD(v39) = sub_59F1C(*(__int64 *)&dword_77F28);
    v40 = dbl_78498 / v39;
  }
  else
  {
    v40 = 0.0;
  }
  v63 = v40;
  v41 = sub_35624(v38, "Device Rejected%", (const char *)&v63, 0);
  v42 = dbl_78498 + dbl_78410 + dbl_78250;
  if ( v42 == 0.0 )
    v43 = 0.0;
  else
    v43 = dbl_78498 / v42;
  v64 = v43;
  v44 = sub_35624(v41, "Pool Rejected%", (const char *)&v64, 0);
  v45 = dbl_78410 + dbl_78498 + dbl_78250;
  if ( v45 == 0.0 )
    v46 = 0.0;
  else
    v46 = dbl_78250 / v45;
  v65 = v46;
  v47 = sub_35624(v44, "Pool Stale%", (const char *)&v65, 0);
  v48 = sub_32EA8(v47, "Last getwork", (const char *)&dword_78770, 0);
  if ( pthread_mutex_unlock(&stru_781AC) )
    sub_B794("summary", 2862);
  off_72D18();
  result = sub_323A4((unsigned int *)a1, (int)v48, a4, 0);
  if ( (v6 & a4) != 0 )
    *(_BYTE *)(a1 + 13) = 1;
  return result;
}
// 356CC: variable 'v7' is possibly undefined
// 3570C: variable 'v9' is possibly undefined
// 35724: variable 'v11' is possibly undefined
// 358D4: variable 'v36' is possibly undefined
// 35910: variable 'v39' is possibly undefined
// 72438: using guessed type double dbl_72438;
// 72D18: using guessed type int (*off_72D18)();
// 739C0: using guessed type char *off_739C0;
// 73D50: using guessed type __int64 qword_73D50;
// 75C68: using guessed type char byte_75C68;
// 75C70: using guessed type double dbl_75C70;
// 75C78: using guessed type int dword_75C78;
// 77AE8: using guessed type double dbl_77AE8;
// 77C90: using guessed type int dword_77C90;
// 77F28: using guessed type int dword_77F28;
// 78248: using guessed type __int64 qword_78248;
// 78250: using guessed type double dbl_78250;
// 78264: using guessed type int dword_78264;
// 782F4: using guessed type int dword_782F4;
// 78410: using guessed type double dbl_78410;
// 78470: using guessed type int dword_78470;
// 78498: using guessed type double dbl_78498;
// 78520: using guessed type __int64 qword_78520;
// 785F0: using guessed type int dword_785F0;
// 786CC: using guessed type int dword_786CC;
// 786E0: using guessed type int dword_786E0;
// 78770: using guessed type int dword_78770;
// 78944: using guessed type int dword_78944;
// 78AA8: using guessed type int dword_78AA8;

//----- (00036270) --------------------------------------------------------
_DWORD *__fastcall sub_36270(_DWORD *a1, const char *a2, const char *a3, char a4)
{
  return sub_31B4C(a1, a2, 26, a3, a4);
}

//----- (00036294) --------------------------------------------------------
int __fastcall sub_36294(unsigned int *a1, int a2, int a3, int a4)
{
  int v5; // r2
  unsigned int v8; // r3
  const char *v9; // r7
  _DWORD *v10; // r0
  _DWORD *v11; // r0
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  _DWORD *v14; // r0
  _DWORD *v15; // r0
  _DWORD *v16; // r0
  _DWORD *v17; // r0
  _DWORD *v18; // r0
  _DWORD *v19; // r0
  _DWORD *v20; // r0
  _DWORD *v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r0
  _DWORD *v24; // r0
  _DWORD *v25; // r0
  _BOOL4 v26; // r3
  char v28[8]; // [sp+4h] [bp-8h] BYREF

  v5 = *(_DWORD *)(a3 + 244);
  *(_DWORD *)v28 = a2;
  if ( v5 )
  {
    v8 = *(_DWORD *)(a3 + 248);
    if ( v8 <= 8 )
      v9 = *(const char **)&aEscapeString[4 * v8 + 112];
    else
      v9 = "Unknown reason - code bug";
  }
  else
  {
    v9 = "None";
  }
  v10 = sub_32D40(0, "NOTIFY", v28, 0);
  v11 = sub_32C8C(v10, "Name", *(const char **)(*(_DWORD *)(a3 + 4) + 8), 0);
  v12 = sub_32D40(v11, "ID", (const char *)(a3 + 8), 0);
  v13 = sub_32EA8(v12, "Last Well", (const char *)(a3 + 240), 0);
  v14 = sub_32EA8(v13, "Last Not Well", (const char *)(a3 + 244), 0);
  v15 = sub_32C8C(v14, "Reason Not Well", v9, 0);
  v16 = sub_32D40(v15, "*Thread Fail Init", (const char *)(a3 + 252), 0);
  v17 = sub_32D40(v16, "*Thread Zero Hash", (const char *)(a3 + 256), 0);
  v18 = sub_32D40(v17, "*Thread Fail Queue", (const char *)(a3 + 260), 0);
  v19 = sub_32D40(v18, "*Dev Sick Idle 60s", (const char *)(a3 + 264), 0);
  v20 = sub_32D40(v19, "*Dev Dead Idle 600s", (const char *)(a3 + 268), 0);
  v21 = sub_32D40(v20, "*Dev Nostart", (const char *)(a3 + 272), 0);
  v22 = sub_32D40(v21, "*Dev Over Heat", (const char *)(a3 + 276), 0);
  v23 = sub_32D40(v22, "*Dev Thermal Cutoff", (const char *)(a3 + 280), 0);
  v24 = sub_32D40(v23, "*Dev Comms Error", (const char *)(a3 + 284), 0);
  v25 = sub_32D40(v24, "*Dev Throttle", (const char *)(a3 + 288), 0);
  if ( a4 )
    v26 = *(_DWORD *)v28 > 0;
  else
    v26 = 0;
  return sub_323A4(a1, (int)v25, a4, v26);
}

//----- (00036534) --------------------------------------------------------
int sub_36534()
{
  void *v0; // r0
  int result; // r0
  char v2[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy(v2, "Failed to calloc mcast thr");
    sub_385C8(3, v2, 1);
    sub_16BE0(1);
  }
  result = sub_2EFE4((int)v0, 0, (void *(*)(void *))sub_31B10, v0);
  if ( result )
  {
    strcpy(v2, "API mcast thread create failed");
    sub_385C8(3, v2, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (000365FC) --------------------------------------------------------
void __fastcall sub_365FC(int a1)
{
  double v1; // d0
  int *v2; // r0
  _BYTE *v3; // r0
  _DWORD *v4; // r0
  char *v5; // r3
  int v6; // r2
  bool v7; // zf
  char *v8; // r4
  size_t v9; // r5
  char *v10; // r0
  unsigned __int8 *v11; // r4
  char *v12; // r0
  char *v13; // r0
  int v14; // r3
  const __int32_t *v15; // r2
  int v16; // r8
  __int32_t v17; // r1
  unsigned __int8 *v18; // r6
  int v19; // r10
  char *v20; // r0
  char *v21; // r7
  const char *v22; // r9
  _UNKNOWN **v23; // r5
  int v24; // r4
  const char *v25; // t1
  const char *v26; // r4
  char *v27; // r3
  const char *v28; // r2
  _BYTE *v29; // r6
  char *v30; // r7
  const char *v31; // r9
  size_t v32; // r0
  int v33; // r5
  size_t v34; // r0
  char *v35; // r0
  int *v36; // r4
  const char *v37; // r5
  char *v38; // r7
  const char *v39; // t1
  size_t v40; // r0
  const char *v41; // t1
  const __int32_t *v42; // r2
  __int32_t v43; // r3
  int v44; // r5
  size_t v45; // r0
  char *v46; // r0
  const char *v47; // r5
  size_t v48; // r0
  char *v49; // r0
  char *v50; // r11
  char *v51; // r2
  size_t v52; // r0
  int v53; // r3
  int v54; // t1
  int v55; // r7
  int v56; // r3
  char *v57; // r6
  bool v58; // zf
  unsigned __int8 *v59; // r6
  int v60; // t1
  bool v61; // zf
  char *v62; // r0
  const unsigned __int16 **v63; // r0
  int v64; // r1
  const __int32_t *v65; // r3
  char v66; // r2
  char *v67; // r5
  int v68; // r9
  int v69; // r3
  char *v70; // r5
  unsigned __int8 v71; // r2
  char *v72; // r0
  int v73; // r9
  int i; // r3
  int j; // r3
  char v76; // t1
  int v77; // r0
  int v78; // r2
  int v79; // r2
  int v80; // r3
  char *v81; // r1
  int v82; // r0
  int v83; // r3
  char *v84; // r1
  int v85; // r12
  __int32_t v86; // r1
  unsigned __int8 *v87; // r4
  int v88; // r2
  char *v89; // r3
  struct addrinfo *v90; // r12
  struct addrinfo *v91; // r4
  int v92; // r0
  time_t v93; // r9
  int v94; // r9
  int *v95; // r11
  int v96; // r0
  _BOOL4 v97; // r5
  const char *v98; // r2
  ssize_t v99; // r0
  int v100; // r6
  int v101; // r3
  int v102; // r5
  time_t v103; // r0
  _BYTE *v104; // r1
  char *v105; // r0
  char *v106; // r10
  const char *v107; // r8
  size_t v108; // r0
  char *v109; // r7
  char *v110; // r0
  const char *v111; // r1
  _UNKNOWN **v112; // r10
  int v113; // r6
  const char *v114; // t1
  int v115; // r3
  int v116; // r6
  int v117; // r3
  int v118; // r3
  int *v119; // r0
  char *v120; // r10
  int *v121; // r0
  char *v122; // r0
  int *v123; // r0
  char *v124; // r0
  int v125; // r0
  int v126; // r12
  __int32_t v127; // r2
  char *v128; // r0
  int *v129; // r0
  char *v130; // r0
  const char *v131; // r3
  int *v132; // r0
  int *v133; // r0
  char *v134; // r0
  int *v135; // r0
  int *v136; // r0
  char *v137; // r0
  _DWORD *v138; // r0
  size_t v139; // r0
  int *v140; // r3
  char *v141; // r0
  int v142; // r3
  int v143; // r0
  int v144; // [sp+10h] [bp-539Ch]
  unsigned __int8 *v145; // [sp+14h] [bp-5398h]
  const __int32_t **v146; // [sp+20h] [bp-538Ch]
  char *dest; // [sp+28h] [bp-5384h]
  int *ptr; // [sp+2Ch] [bp-5380h]
  int fd; // [sp+34h] [bp-5378h]
  _DWORD *v150; // [sp+38h] [bp-5374h]
  char *haystack; // [sp+3Ch] [bp-5370h]
  __int16 v152; // [sp+40h] [bp-536Ch]
  char *s; // [sp+48h] [bp-5364h]
  char *v155; // [sp+6Ch] [bp-5340h]
  unsigned __int8 v156; // [sp+72h] [bp-533Ah] BYREF
  char v157; // [sp+73h] [bp-5339h] BYREF
  const char *v158; // [sp+74h] [bp-5338h] BYREF
  socklen_t addr_len; // [sp+78h] [bp-5334h] BYREF
  struct addrinfo *v160; // [sp+7Ch] [bp-5330h] BYREF
  int optval; // [sp+80h] [bp-532Ch] BYREF
  char service[12]; // [sp+84h] [bp-5328h] BYREF
  struct addrinfo req; // [sp+90h] [bp-531Ch] BYREF
  char v164[100]; // [sp+B0h] [bp-52FCh] BYREF
  struct sockaddr addr; // [sp+114h] [bp-5298h] BYREF
  char v166[252]; // [sp+194h] [bp-5218h] BYREF
  struct __jmp_buf_tag env; // [sp+290h] [bp-511Ch] BYREF
  char needle[4056]; // [sp+3A8h] [bp-5004h] BYREF
  int v169[2038]; // [sp+13A8h] [bp-4004h] BYREF
  char v170[8024]; // [sp+33A8h] [bp-2004h] BYREF

  v152 = dword_72D10;
  v2 = (int *)malloc(4u);
  v7 = byte_785F9 == 0;
  ptr = v2;
  *v2 = -1;
  if ( v7 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v170, 0x1000u, "API not running%s", " - API will not be available");
      sub_385C8(7, v170, 0);
    }
    goto LABEL_7;
  }
  v150 = malloc(0x10u);
  v3 = malloc(0x10000u);
  v150[1] = v3;
  v150[2] = v3;
  *((_BYTE *)v150 + 12) = 1;
  *v150 = 0x10000;
  *v3 = 0;
  *((_BYTE *)v150 + 13) = 0;
  v4 = malloc(0xCu);
  v5 = &byte_75AEC;
  v6 = dword_75B10;
  v7 = dword_75B10 == 0;
  *v4 = v150;
  if ( v7 )
  {
    v4[1] = v4;
    v4[2] = v4;
  }
  else
  {
    v4[2] = v6;
    v5 = *(char **)(v6 + 4);
  }
  if ( v7 )
  {
    *((_DWORD *)v5 + 9) = v4;
  }
  else
  {
    v4[1] = v5;
    *(_DWORD *)(v6 + 4) = v4;
    v5 = (char *)v4[1];
  }
  if ( !v7 )
    *((_DWORD *)v5 + 2) = v4;
  if ( pthread_mutex_init(&stru_75AF8, 0) )
  {
    v132 = _errno_location();
    snprintf(v170, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v132, "api.c", "api", 5297);
    sub_385C8(3, v170, 1);
    sub_16BE0(1);
  }
  if ( _sigsetjmp(&env, 0) )
  {
    sub_322AC(ptr);
    _pthread_unwind_next((__pthread_unwind_buf_t *)&env);
    goto LABEL_308;
  }
  _pthread_register_cancel((__pthread_unwind_buf_t *)&env);
  v8 = (char *)dword_7876C;
  dword_75B1C = a1;
  if ( dword_7876C )
  {
    v9 = strlen((const char *)dword_7876C) + 1;
  }
  else
  {
    v8 = "";
    v9 = 1;
  }
  v10 = (char *)malloc(v9);
  s = v10;
  if ( !v10 )
  {
    strcpy(v170, "Failed to malloc ipgroups buf");
    sub_385C8(3, v170, 1);
    sub_16BE0(1);
  }
  memcpy(v10, v8, v9);
  if ( !*s )
  {
    v146 = _ctype_toupper_loc();
    goto LABEL_69;
  }
  v11 = (unsigned __int8 *)s;
  v146 = _ctype_toupper_loc();
  while ( 2 )
  {
    v12 = strchr((const char *)v11, 44);
    v145 = (unsigned __int8 *)v12;
    if ( v12 )
    {
      *v12 = 0;
      v145 = (unsigned __int8 *)(v12 + 1);
    }
    if ( v11[1] != 58 )
    {
      v13 = strchr((const char *)v11, 58);
      if ( v13 )
        *v13 = 0;
      snprintf((char *)v169, 0x1000u, "API invalid group name '%s'", v11);
      sub_385C8(3, (const char *)v169, 1);
      sub_16BE0(1);
    }
    v14 = *v11;
    v15 = *v146;
    v16 = LOBYTE((*v146)[v14]);
    v17 = (*v146)[v16];
    if ( v17 < (*v146)[65] || v17 > v15[90] )
    {
      snprintf((char *)v169, 0x1000u, "API invalid group name '%c'", v14);
      sub_385C8(3, (const char *)v169, 1);
      sub_16BE0(1);
    }
    if ( v16 == v15[87] )
    {
      snprintf((char *)v169, 0x1000u, "API group name can't be '%c'", v16);
      sub_385C8(3, (const char *)v169, 1);
      sub_16BE0(1);
    }
    if ( v16 == v15[82] )
    {
      snprintf((char *)v169, 0x1000u, "API group name can't be '%c'", v16);
      sub_385C8(3, (const char *)v169, 1);
      sub_16BE0(1);
    }
    if ( *((_DWORD *)&unk_78B4C + v15[v16] - v15[65]) )
    {
      snprintf((char *)v169, 0x1000u, "API duplicate group name '%c'", *v11);
      sub_385C8(3, (const char *)v169, 1);
      sub_16BE0(1);
    }
    v18 = v11 + 2;
    v19 = 0;
    strcpy(v170, "|");
    if ( v11 == (unsigned __int8 *)-2 || !v11[2] )
      goto LABEL_61;
    dest = &v170[1];
    while ( 1 )
    {
      v20 = strchr((const char *)v18, 58);
      v21 = v20;
      if ( v20 )
      {
        *v20 = 0;
        v21 = v20 + 1;
      }
      if ( *v18 == 42 && !v18[1] )
      {
        v19 = 1;
        goto LABEL_42;
      }
      v22 = (const char *)off_7336C;
      if ( !off_7336C )
      {
LABEL_65:
        snprintf((char *)v169, 0x1000u, "API unknown command '%s' in group '%c'", v18, v16);
        sub_385C8(3, (const char *)v169, 1);
        sub_16BE0(1);
      }
      v23 = &off_7336C;
      v24 = 0;
      while ( strcasecmp((const char *)v18, v22) )
      {
        v25 = (const char *)v23[3];
        v23 += 3;
        v22 = v25;
        ++v24;
        if ( !v25 )
          goto LABEL_65;
      }
      sprintf(needle, "|%s|", v22);
      if ( !strstr(v170, needle) )
        break;
LABEL_42:
      if ( !v21 )
        goto LABEL_54;
LABEL_43:
      if ( !*v21 )
        goto LABEL_54;
      v18 = (unsigned __int8 *)v21;
    }
    v26 = (const char *)dword_72F3C[3 * v24 + 268];
    strcpy(dest, v26);
    v27 = &dest[strlen(v26)];
    *v27 = 124;
    dest = v27 + 1;
    v27[1] = 0;
    if ( v21 )
      goto LABEL_43;
LABEL_54:
    if ( v19 )
    {
      v28 = (const char *)off_7336C;
      if ( off_7336C )
      {
        v29 = &unk_73374;
        v30 = dest;
        do
        {
          while ( 1 )
          {
            if ( !*v29 )
            {
              sprintf(needle, "|%s|", v28);
              if ( !strstr(v170, needle) )
                break;
            }
            v29 += 12;
            v28 = (const char *)*((_DWORD *)v29 - 2);
            if ( !v28 )
              goto LABEL_61;
          }
          v31 = (const char *)*((_DWORD *)v29 - 2);
          v29 += 12;
          strcpy(v30, v31);
          v32 = strlen(v31);
          v30[v32] = 124;
          v30 += v32 + 1;
          *v30 = 0;
          v28 = (const char *)*((_DWORD *)v29 - 2);
        }
        while ( v28 );
      }
    }
LABEL_61:
    v33 = (*v146)[v16] - (*v146)[65];
    v34 = strlen(v170);
    v35 = (char *)malloc(v34 + 1);
    *((_DWORD *)&unk_78B4C + v33) = v35;
    if ( !v35 )
    {
      strcpy((char *)v169, "Failed to malloc group commands buf");
      sub_385C8(3, (const char *)v169, 1);
      sub_16BE0(1);
    }
    strcpy(v35, v170);
    if ( v145 && *v145 )
    {
      v11 = v145;
      continue;
    }
    break;
  }
LABEL_69:
  v36 = dword_72F3C;
  v37 = (const char *)off_7336C;
  if ( off_7336C )
    v36 = (int *)&off_7336C;
  strcpy(v170, "|");
  if ( off_7336C )
  {
    v38 = &v170[1];
    do
    {
      while ( *((_BYTE *)v36 + 8) )
      {
        v39 = (const char *)v36[3];
        v36 += 3;
        v37 = v39;
        if ( !v39 )
          goto LABEL_77;
      }
      strcpy(v38, v37);
      v40 = strlen(v37);
      v38[v40] = 124;
      v38 += v40 + 1;
      *v38 = 0;
      v41 = (const char *)v36[3];
      v36 += 3;
      v37 = v41;
    }
    while ( v41 );
  }
LABEL_77:
  v42 = *v146;
  v43 = (*v146)[82];
  if ( (unsigned int)(v43 + 128) < 0x180 )
    v43 = v42[v43];
  v44 = v43 - v42[65];
  v45 = strlen(v170);
  v46 = (char *)malloc(v45 + 1);
  *((_DWORD *)&unk_78B4C + v44) = v46;
  if ( !v46 )
  {
LABEL_308:
    strcpy((char *)v169, "Failed to malloc noprivgroup commands buf");
    sub_385C8(3, (const char *)v169, 1);
    sub_16BE0(1);
  }
  strcpy(v46, v170);
  free(s);
  v47 = (const char *)dword_75AD4;
  if ( !dword_75AD4 )
    goto LABEL_114;
  v48 = strlen((const char *)dword_75AD4);
  v49 = (char *)malloc(v48 + 1);
  v50 = v49;
  if ( !v49 )
  {
    strcpy(v170, "Failed to malloc ipaccess buf");
    sub_385C8(3, v170, 1);
    sub_16BE0(1);
  }
  strcpy(v49, v47);
  v51 = v50 - 1;
  v52 = 1;
  while ( 1 )
  {
    v54 = (unsigned __int8)*++v51;
    v53 = v54;
    if ( !v54 )
      break;
    if ( v53 == 44 )
      ++v52;
  }
  dword_75AF4 = (int)calloc(v52, 0x24u);
  if ( !dword_75AF4 )
  {
    strcpy(v170, "Failed to calloc ipaccess");
    sub_385C8(3, v170, 1);
    sub_16BE0(1);
  }
  v55 = 0;
  dword_75AF0 = 0;
  if ( !v50 || (v56 = (unsigned __int8)*v50, !*v50) )
  {
    free(v50);
    goto LABEL_158;
  }
  v57 = v50;
  do
  {
    v58 = v56 == 32;
    if ( v56 != 32 )
      v58 = v56 == 9;
    if ( v58 )
    {
      v59 = (unsigned __int8 *)(v57 + 1);
      do
      {
        v87 = v59;
        v60 = *v59++;
        v56 = v60;
        v61 = v60 == 32;
        if ( v60 != 32 )
          v61 = v56 == 9;
      }
      while ( v61 );
    }
    else
    {
      v87 = (unsigned __int8 *)v57;
    }
    if ( v56 == 44 )
    {
      v57 = (char *)(v87 + 1);
    }
    else
    {
      v62 = strchr((const char *)v87, 44);
      v57 = v62;
      if ( v62 )
      {
        *v62 = 0;
        v57 = v62 + 1;
      }
      v63 = _ctype_b_loc();
      v64 = *v87;
      v65 = *v146;
      v66 = *((_BYTE *)*v146 + 328);
      if ( ((*v63)[v64] & 0x400) != 0 && v87[1] == 58 )
      {
        v86 = v65[v64];
        if ( v86 == v65[87] || *((_DWORD *)&unk_78B4C + v86 - v65[65]) )
          v66 = v86;
        v87 += 2;
      }
      v67 = (char *)(dword_75AF4 + 36 * v55);
      v67[32] = v66;
      v68 = *v87;
      if ( v68 == 48 && v87[1] == 47 && v87[2] == 48 )
      {
        v69 = v87[3];
        if ( !v87[3] )
        {
          v70 = v67 - 1;
          v71 = v87[3];
          do
          {
            ++v69;
            *++v70 = v71;
            v70[16] = v71;
          }
          while ( v69 != 16 );
          goto LABEL_110;
        }
      }
      v72 = strchr((const char *)v87, 47);
      if ( !v72 )
      {
        v88 = 0;
        v89 = v67;
        do
        {
          ++v88;
          v89[16] = -1;
          ++v89;
        }
        while ( v88 != 16 );
        v68 = *v87;
        v72 = (char *)&v87[strlen((const char *)v87)];
      }
      if ( v68 == 91 && *(v72 - 1) == 93 )
      {
        v73 = 1;
        *v87++ = 0;
        *(v72 - 1) = 0;
      }
      else
      {
        v73 = 0;
      }
      if ( !*v72 )
        goto LABEL_124;
      *v72 = 0;
      v77 = strtol(v72 + 1, 0, 10);
      if ( v77 > 0 )
      {
        v78 = v73 ? 0 : 96;
        v79 = v77 + v78;
        if ( v79 <= 128 )
        {
          v80 = 0;
          v81 = v67;
          v82 = 0;
          do
          {
            ++v80;
            v81[16] = 0;
            ++v81;
          }
          while ( v80 != 16 );
          v83 = 7;
          while ( v79 > 0 )
          {
            v84 = &v67[v82];
            if ( !v83 )
              ++v82;
            --v79;
            v85 = (unsigned __int8)v84[16] | (1 << v83);
            if ( v83 )
              --v83;
            else
              v83 = 7;
            v84[16] = v85;
          }
LABEL_124:
          for ( i = 0; i != 16; ++i )
            v67[i] = 0;
          if ( v73 )
          {
            if ( inet_pton(10, (const char *)v87, v67) != 1 )
              goto LABEL_111;
          }
          else
          {
            sprintf(v170, "::ffff:%s", v87);
            v55 = dword_75AF0;
            v67 = (char *)(dword_75AF4 + 36 * dword_75AF0);
            if ( inet_pton(10, v170, v67) != 1 )
              goto LABEL_111;
          }
          for ( j = 0; j != 16; ++j )
          {
            v76 = *v67++;
            *(v67 - 1) = v76 & v67[15];
          }
LABEL_110:
          dword_75AF0 = ++v55;
        }
      }
    }
LABEL_111:
    if ( !v57 )
      break;
    v56 = (unsigned __int8)*v57;
  }
  while ( *v57 );
  free(v50);
  if ( !v55 )
  {
LABEL_158:
    if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
    {
      snprintf(v170, 0x1000u, "API not running (no valid IPs specified)%s", " - API will not be available");
      sub_385C8(4, v170, 0);
    }
    goto LABEL_7;
  }
LABEL_114:
  sub_2A884();
  sprintf(service, "%d", v152);
  req.ai_flags = 1;
  memset(&req.ai_family, 0, 28);
  if ( getaddrinfo(off_72D0C, service, &req, &v160) )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(v170, 0x1000u, "API failed to resolve %s", off_72D0C);
LABEL_119:
      sub_385C8(3, v170, 0);
    }
    goto LABEL_7;
  }
  v90 = v160;
  if ( v160 )
  {
    v91 = v160;
    while ( 1 )
    {
      v92 = socket(v90->ai_family, 1, 0);
      *ptr = v92;
      if ( v92 > 0 )
        break;
      v91 = v91->ai_next;
      if ( !v91 )
        goto LABEL_240;
      v90 = v160;
    }
  }
  else
  {
    v92 = *ptr;
LABEL_240:
    if ( v92 == -1 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        v121 = _errno_location();
        v122 = strerror(*v121);
        snprintf(v170, 0x1000u, "API initialisation failed (%s)%s", v122, " - API will not be available");
        sub_385C8(3, v170, 0);
      }
      freeaddrinfo(v160);
      free(ptr);
      return;
    }
    v91 = 0;
  }
  optval = 1;
  if ( setsockopt(v92, 1, 2, &optval, 4u) < 0 && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    v123 = _errno_location();
    v124 = strerror(*v123);
    snprintf(v170, 0x1000u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v124);
    sub_385C8(7, v170, 0);
  }
  v93 = time(0);
  while ( 2 )
  {
    if ( bind(*ptr, v91->ai_addr, v91->ai_addrlen) >= 0 )
    {
      freeaddrinfo(v160);
      if ( listen(*ptr, 100) < 0 )
      {
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          v133 = _errno_location();
          v134 = strerror(*v133);
          snprintf(v170, 0x1000u, "API3 initialisation failed (%s)%s", v134, " - API will not be available");
          sub_385C8(3, v170, 0);
        }
        close(*ptr);
        goto LABEL_7;
      }
      if ( !dword_75AD4 )
      {
        if ( byte_785EC )
        {
          if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
            goto LABEL_180;
          snprintf(v170, 0x1000u, "API running in UNRESTRICTED read access mode on port %d (%d)", v152, *ptr);
        }
        else
        {
          if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
            goto LABEL_180;
          snprintf(v170, 0x1000u, "API running in local read access mode on port %d (%d)", v152, *ptr);
        }
LABEL_179:
        sub_385C8(4, v170, 0);
        goto LABEL_180;
      }
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(v170, 0x1000u, "API running in IP access mode on port %d (%d)", v152, *ptr);
        goto LABEL_179;
      }
LABEL_180:
      if ( byte_7844C )
        sub_36534();
      dword_75B14 = (int)sub_38DD4("StrBufs", 12, 2, 0, 0, "api.c", "api", 5409);
      if ( !byte_75AEC )
      {
        v94 = 0;
        v95 = 0;
        while ( 1 )
        {
          v96 = *ptr;
          addr_len = 128;
          fd = accept(v96, &addr, &addr_len);
          if ( fd < 0 )
            break;
          v97 = sub_30858(&addr, &v158, &v156);
          if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            if ( v97 )
              LOWORD(v98) = 16280;
            else
              LOWORD(v98) = 16292;
            HIWORD(v98) = 6;
            snprintf(needle, 0x1000u, "API: connection from %s - %s", v158, v98);
            sub_385C8(7, needle, 0);
          }
          if ( v97 )
          {
            v99 = recv(fd, v169, 0x1FFFu, 0);
            v100 = v99;
            if ( v99 < 0 )
            {
              LOBYTE(v169[0]) = 0;
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                v136 = _errno_location();
                v137 = strerror(*v136);
                snprintf(needle, 0x1000u, "API: recv failed: %s", v137);
                sub_385C8(7, needle, 0);
              }
            }
            else
            {
              v101 = (unsigned __int8)byte_75C49;
              *((_BYTE *)v169 + v99) = 0;
              if ( v101 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                snprintf(needle, 0x1000u, "API: recv command: (%d) '%s'", v99, (const char *)v169);
                sub_385C8(7, needle, 0);
              }
              v102 = 0;
              v103 = time(0);
              v104 = (_BYTE *)v150[1];
              v150[2] = v104;
              dword_75B18 = v103;
              *v104 = 0;
              *((_BYTE *)v150 + 13) = 0;
              if ( LOBYTE(v169[0]) != 123 )
              {
                v105 = strchr((const char *)v169, 124);
                v106 = v105;
                if ( v105 )
                {
                  *v105 = 0;
                  v106 = v105 + 1;
                }
                else
                {
                  v102 = 0;
                }
                v107 = (const char *)v169;
LABEL_205:
                if ( strchr(v107, 43) )
                {
                  v157 = 1;
                  v108 = strlen(v107);
                  haystack = (char *)malloc(v108 + 3);
                  if ( !haystack )
                  {
                    snprintf(needle, 0x1000u, "OOM cmdsbuf in %s %s():%d", "api.c", "api", 5520);
                    sub_385C8(3, needle, 1);
                    sub_16BE0(1);
                  }
                  v94 = 1;
                  v106 = 0;
                  *(_WORD *)haystack = 124;
                }
                else
                {
                  haystack = 0;
                  v94 = 0;
                  v157 = 0;
                }
                v109 = (char *)v107;
                v155 = v106;
                while ( 2 )
                {
                  if ( !v94 )
                    goto LABEL_214;
                  v110 = strchr(v109, 43);
                  v107 = v110;
                  if ( v110 )
                  {
                    *v110 = 0;
                    v107 = v110 + 1;
                  }
                  if ( !*v109 )
                  {
LABEL_220:
                    v109 = (char *)v107;
                  }
                  else
                  {
LABEL_214:
                    v111 = (const char *)off_7336C;
                    if ( off_7336C )
                    {
                      v112 = &off_7336C;
                      v113 = 0;
                      while ( strcmp(v109, v111) )
                      {
                        v114 = (const char *)v112[3];
                        v112 += 3;
                        v111 = v114;
                        ++v113;
                        if ( !v114 )
                          goto LABEL_253;
                      }
                      sprintf(v164, "|%s|", v109);
                      if ( v94 )
                      {
                        if ( strstr(haystack, v164) )
                          goto LABEL_220;
                        v139 = strlen(haystack);
                        *(_WORD *)stpcpy(&haystack[v139], v109) = 124;
                        sub_306CC(v150, v109, v102, &v157);
                        v140 = &dword_72F3C[3 * v113];
                        if ( !*((_BYTE *)v140 + 1081) )
                        {
                          sub_32ECC(v150, 45, *((unsigned __int8 *)v140 + 1081), v140[268], v102);
                          sub_31DD4((int)v150, v102);
                          goto LABEL_220;
                        }
                      }
                      v126 = v156;
                      v127 = (*v146)[v156];
                      if ( v127 == (*v146)[87]
                        || (v144 = v156,
                            v128 = strstr(*((const char **)&unk_78B4C + v127 - (*v146)[65]), v164),
                            v126 = v144,
                            v128) )
                      {
                        ((void (__fastcall *)(_DWORD *, int, char *, int, int))dword_72F3C[3 * v113 + 269])(
                          v150,
                          fd,
                          v155,
                          v102,
                          v126);
                      }
                      else
                      {
                        sub_32ECC(v150, 45, 0, dword_72F3C[3 * v113 + 268], v102);
                        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                        {
                          snprintf(
                            needle,
                            0x1000u,
                            "API: access denied to '%s' for '%s' command",
                            v158,
                            (const char *)dword_72F3C[3 * v113 + 268]);
                          sub_385C8(7, needle, 0);
                        }
                      }
                      v125 = (int)v150;
                      if ( v94 )
                      {
LABEL_260:
                        sub_31DD4(v125, v102);
                        goto LABEL_220;
                      }
                    }
                    else
                    {
LABEL_253:
                      if ( v94 )
                      {
                        sub_306CC(v150, v109, v102, &v157);
                        sub_32ECC(v150, 14, 0, 0, v102);
                        v125 = (int)v150;
                        goto LABEL_260;
                      }
                      sub_32ECC(v150, 14, 0, 0, v102);
                      v125 = (int)v150;
                    }
                    sub_309F8(v125, fd, v102);
                  }
                  if ( v109 )
                    v115 = v94 & 1;
                  else
                    v115 = 0;
                  if ( !v115 )
                  {
                    v116 = v102;
                    goto LABEL_226;
                  }
                  continue;
                }
              }
              v135 = sub_5667C(v169, v100, 0, v166);
              v95 = v135;
              if ( v135 && !*v135 )
              {
                v138 = (_DWORD *)sub_571D8(v135, "command");
                if ( v138 )
                {
                  if ( *v138 == 2 )
                  {
                    v107 = (const char *)sub_57530(v138);
                    v141 = (char *)sub_571D8(v95, "parameter");
                    v106 = v141;
                    if ( v141 )
                    {
                      v142 = *(_DWORD *)v141;
                      if ( *(_DWORD *)v141 == 2 )
                      {
                        v102 = 1;
                        v106 = (char *)sub_57530(v141);
                        goto LABEL_205;
                      }
                      if ( v142 == 3 )
                      {
                        v143 = sub_57600((int)v141);
                        v102 = 1;
                        v106 = v170;
                        sprintf(v170, "%d", v143);
                        goto LABEL_205;
                      }
                      if ( v142 == 4 )
                      {
                        sub_576B0();
                        v102 = 1;
                        v106 = v170;
                        sprintf(v170, "%f", v1);
                        goto LABEL_205;
                      }
                      v106 = 0;
                    }
                    v102 = 1;
                    goto LABEL_205;
                  }
                  sub_32ECC(v150, 14, 0, 0, 1u);
                }
                else
                {
                  sub_32ECC(v150, 24, 0, 0, 1u);
                }
              }
              else
              {
                sub_32ECC(v150, 23, 0, 0, 1u);
              }
              sub_309F8((int)v150, fd, 1);
              v116 = (int)v95;
              v102 = 1;
              if ( v95 )
                v116 = 1;
LABEL_226:
              if ( v94 )
                sub_309F8((int)v150, fd, v102);
              if ( v116 )
              {
                if ( !*v95 )
                {
                  v117 = v95[1];
                  if ( v117 != -1 )
                  {
                    v118 = v117 - 1;
                    v95[1] = v118;
                    if ( !v118 )
                      sub_5779C((void **)v95);
                  }
                }
              }
            }
          }
          close(fd);
          if ( byte_75AEC )
            goto LABEL_265;
        }
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          v129 = _errno_location();
          v130 = strerror(*v129);
          snprintf(needle, 0x1000u, "API failed (%s)%s (%d)", v130, " - API will not be available", *ptr);
          sub_385C8(3, needle, 0);
        }
      }
LABEL_265:
      _pthread_unregister_cancel((__pthread_unwind_buf_t *)&env);
      sub_322AC(ptr);
      free(ptr);
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        if ( byte_75AEE )
        {
          v131 = "QUIT";
        }
        else if ( byte_75AED )
        {
          v131 = "RESTART";
        }
        else if ( byte_75AEC )
        {
          v131 = "BYE";
        }
        else
        {
          v131 = "UNKNOWN!";
        }
        snprintf(needle, 0x1000u, "API: terminating due to: %s", v131);
        sub_385C8(7, needle, 0);
      }
      if ( pthread_mutex_lock(&stru_75AF8) )
        sub_B6BC("api", 5619);
      if ( byte_75AED )
      {
        if ( sub_2EFE4((int)&env, 0, (void *(*)(void *))sub_320B8, &env) )
        {
          sub_3207C(&stru_75AF8, "api", 5625);
          strcpy(needle, "API failed to initiate a restart - aborting");
          sub_385C8(3, needle, 1);
          sub_16BE0(1);
        }
      }
      else
      {
        if ( !byte_75AEE )
        {
LABEL_280:
          if ( pthread_mutex_unlock(&stru_75AF8) )
            sub_B794("api", 5640);
          off_72D18();
          return;
        }
        if ( sub_2EFE4(
               (int)&env,
               (const pthread_attr_t *)(unsigned __int8)byte_75AED,
               (void *(*)(void *))sub_321B0,
               &env) )
        {
          sub_3207C(&stru_75AF8, "api", 5634);
          strcpy(needle, "API failed to initiate a clean quit - aborting");
          sub_385C8(3, needle, 1);
          sub_16BE0(1);
        }
      }
      pthread_detach(env.__jmpbuf[3]);
      goto LABEL_280;
    }
    v119 = _errno_location();
    v120 = strerror(*v119);
    if ( time(0) - v93 <= 61 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(v170, 0x1000u, "API bind to port %d failed - trying again in 30sec", v152);
        sub_385C8(4, v170, 0);
      }
      sub_2A884();
      continue;
    }
    break;
  }
  freeaddrinfo(v160);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(v170, 0x1000u, "API bind to port %d failed (%s)%s", v152, v120, " - API will not be available");
    goto LABEL_119;
  }
LABEL_7:
  free(ptr);
}
// 38584: variable 'v1' is possibly undefined
// AC00: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 321B0: using guessed type void __noreturn sub_321B0();
// 72C0C: using guessed type int dword_72C0C;
// 72D0C: using guessed type char *off_72D0C;
// 72D10: using guessed type int dword_72D10;
// 72D18: using guessed type int (*off_72D18)();
// 72F3C: using guessed type int dword_72F3C[];
// 7336C: using guessed type _UNKNOWN *off_7336C;
// 73504: using guessed type int dword_73504;
// 75AD4: using guessed type int dword_75AD4;
// 75AEC: using guessed type char byte_75AEC;
// 75AED: using guessed type char byte_75AED;
// 75AEE: using guessed type char byte_75AEE;
// 75AF0: using guessed type int dword_75AF0;
// 75AF4: using guessed type int dword_75AF4;
// 75B10: using guessed type int dword_75B10;
// 75B14: using guessed type int dword_75B14;
// 75B18: using guessed type int dword_75B18;
// 75B1C: using guessed type int dword_75B1C;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 7844C: using guessed type char byte_7844C;
// 785EC: using guessed type char byte_785EC;
// 785F9: using guessed type char byte_785F9;
// 7876C: using guessed type int dword_7876C;

//----- (000385C8) --------------------------------------------------------
void __fastcall sub_385C8(int a1, const char *a2, int a3)
{
  struct tm *v6; // r0
  int v7; // r0
  FILE *v8; // r8
  size_t v9; // r0
  size_t v10; // r0
  time_t tv_sec; // [sp+1Ch] [bp-4Ch] BYREF
  struct timeval v12; // [sp+20h] [bp-48h] BYREF
  char s[64]; // [sp+28h] [bp-40h] BYREF

  if ( byte_77B70 )
  {
    syslog(a1 | 0x80, "%s", a2);
    return;
  }
  v12.tv_sec = 0;
  v12.tv_usec = 0;
  sub_2A7A4(&v12);
  tv_sec = v12.tv_sec;
  v6 = localtime(&tv_sec);
  snprintf(
    s,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d] ",
    v6->tm_year + 1900,
    v6->tm_mon + 1,
    v6->tm_mday,
    v6->tm_hour,
    v6->tm_min,
    v6->tm_sec);
  v7 = fileno((FILE *)stderr);
  if ( isatty(v7) )
  {
    if ( byte_75B20 )
    {
LABEL_4:
      v8 = (FILE *)dword_75B24;
      if ( dword_75B24 || (v8 = fopen(dword_75B28, word_75C28), (dword_75B24 = (int)v8) != 0) )
      {
        v9 = strlen(s);
        fwrite(s, v9, 1u, v8);
        v10 = strlen(a2);
        fwrite(a2, v10, 1u, (FILE *)dword_75B24);
        fwrite(ptr, 1u, 1u, (FILE *)dword_75B24);
        fflush((FILE *)dword_75B24);
      }
    }
  }
  else
  {
    fprintf((FILE *)stderr, "%s%s\n", s, a2);
    fflush((FILE *)stderr);
    if ( byte_75B20 )
      goto LABEL_4;
  }
  sub_3888C(a1, s, a2, a3);
}
// 73A08: using guessed type int stderr;
// 75B20: using guessed type char byte_75B20;
// 75B24: using guessed type int dword_75B24;
// 77B70: using guessed type char byte_77B70;

//----- (0003877C) --------------------------------------------------------
int sub_3877C()
{
  int result; // r0
  int *v1; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_mutex_lock(&stru_785D0);
  if ( result )
  {
    v1 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v1, "logging.c", "my_log_curses", 47);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}
// 16BE0: using guessed type void __fastcall __noreturn sub_16BE0(_DWORD);
// 385C8: using guessed type int __fastcall sub_385C8(_DWORD, _DWORD, _DWORD);

//----- (00038804) --------------------------------------------------------
int __fastcall sub_38804(int a1)
{
  int result; // r0
  int *v3; // r0
  char s[4096]; // [sp+10h] [bp-1000h] BYREF

  result = pthread_mutex_unlock(&stru_785D0);
  if ( result )
  {
    v3 = _errno_location();
    snprintf(s, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v3, "logging.c", "my_log_curses", a1);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}
// 16BE0: using guessed type void __fastcall __noreturn sub_16BE0(_DWORD);
// 385C8: using guessed type int __fastcall sub_385C8(_DWORD, _DWORD, _DWORD);

//----- (0003888C) --------------------------------------------------------
int __fastcall sub_3888C(int result, const char *a2, const char *a3, int a4)
{
  int v4; // r6

  v4 = result;
  if ( !byte_78AA0 || result == 3 )
  {
    if ( a4 )
    {
      pthread_mutex_trylock(&stru_785D0);
      sub_38804(38);
      off_72D18();
      if ( byte_72C1C )
      {
LABEL_5:
        result = sub_199A4(v4, a2, a3);
        if ( result )
          return result;
      }
    }
    else if ( byte_72C1C )
    {
      goto LABEL_5;
    }
    sub_3877C();
    printf("%s%s%s", a2, a3, "                    \n");
    sub_38804(49);
    return off_72D18();
  }
  return result;
}
// 72C1C: using guessed type char byte_72C1C;
// 72D18: using guessed type int (*off_72D18)();
// 78AA0: using guessed type char byte_78AA0;

//----- (0003895C) --------------------------------------------------------
void __fastcall sub_3895C(int a1, const char *a2, int a3)
{
  int v6; // r0

  if ( byte_77B70 )
  {
    syslog(a1 | 0x80, "%s", a2);
  }
  else
  {
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", a2);
      fflush((FILE *)stderr);
    }
    sub_3888C(a1, "", a2, a3);
  }
}
// 73A08: using guessed type int stderr;
// 77B70: using guessed type char byte_77B70;

//----- (000389F0) --------------------------------------------------------
const char *__fastcall sub_389F0(const char **a1, const char *a2, const char *a3, int a4)
{
  const char *result; // r0
  int v6; // r3
  const char *v7; // r2
  size_t v8; // r6
  char *v9; // r0
  int v10; // r1
  const char *v11; // r0
  const char **v12; // r0
  const char **v13; // r5
  size_t v14; // lr
  const char *v15; // r1
  const char *v16; // r0
  const char **v17; // r3
  int v18; // r2
  const char *v19; // r1
  const char **v20; // r3
  int v21; // r2
  char *v22; // r0
  int v23; // r1
  const char *v24; // r0
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = (const char *)*((unsigned __int8 *)a1 + 4);
  if ( result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      *a1,
      "k_alloc_items",
      a2,
      a3,
      a4,
      "klist.c",
      "k_alloc_items",
      19);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v6 = (int)a1[10];
  if ( v6 <= 0 )
  {
    v8 = (size_t)a1[9];
  }
  else
  {
    v7 = a1[6];
    if ( v6 <= (int)v7 )
      return result;
    v8 = (size_t)a1[9];
    if ( v6 < (int)&v7[v8] )
      v8 = v6 - (_DWORD)v7;
  }
  v9 = (char *)a1[13];
  v10 = (int)(a1[12] + 1);
  a1[12] = (const char *)v10;
  v11 = (const char *)realloc(v9, 4 * v10);
  a1[13] = v11;
  if ( !v11 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      *a1,
      a1[12],
      "klist.c",
      "k_alloc_items",
      33);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v12 = (const char **)calloc(v8, 0x10u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      *a1,
      v8,
      a1[6],
      a1[10],
      "klist.c",
      "k_alloc_items",
      38);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v14 = v8 - 1;
  *(_DWORD *)&a1[13][4 * (_DWORD)(a1[12] - 1)] = v12;
  v15 = *a1;
  v16 = a1[6];
  a1[7] = (const char *)v8;
  a1[8] = (const char *)v8;
  a1[6] = &v16[v8];
  *v13 = v15;
  v13[1] = 0;
  v13[2] = (const char *)(v13 + 4);
  if ( (int)(v8 - 1) > 1 )
  {
    v17 = v13;
    v18 = 1;
    do
    {
      v19 = *a1;
      ++v18;
      v17[5] = (const char *)v17;
      v17[6] = (const char *)(v17 + 8);
      v17[4] = v19;
      v17 += 4;
    }
    while ( v18 != v14 );
  }
  v20 = &v13[4 * v14];
  *v20 = *a1;
  v20[1] = (const char *)&v13[4 * v8 - 8];
  v20[2] = 0;
  v21 = *((unsigned __int8 *)a1 + 44);
  a1[3] = (const char *)v13;
  if ( v21 )
    a1[4] = (const char *)v20;
  do
  {
    v22 = (char *)a1[15];
    v23 = (int)(a1[14] + 1);
    a1[14] = (const char *)v23;
    v24 = (const char *)realloc(v22, 4 * v23);
    a1[15] = v24;
    if ( !v24 )
    {
      snprintf(
        s,
        0x1000u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        *a1,
        a1[14],
        "klist.c",
        "k_alloc_items",
        69);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    result = (const char *)calloc(1u, (size_t)a1[5]);
    v13[3] = result;
    if ( !result )
    {
      snprintf(s, 0x1000u, "List %s failed to calloc item data in %s %s():%d", *a1, "klist.c", "k_alloc_items", 73);
      sub_385C8(3, s, 1);
      sub_16BE0(1);
    }
    *(_DWORD *)&a1[15][4 * (_DWORD)(a1[14] - 1)] = result;
    v13 = (const char **)v13[2];
  }
  while ( v13 );
  return result;
}

//----- (00038D2C) --------------------------------------------------------
_BYTE *__fastcall sub_38D2C(int a1)
{
  _BYTE *result; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = calloc(1u, 0x40u);
  if ( !result )
  {
    snprintf(
      s,
      0x1000u,
      "Failed to calloc store for %s in %s %s():%d",
      *(const char **)a1,
      "klist.c",
      "k_new_store",
      85);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  result[4] = 1;
  *((_DWORD *)result + 2) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)result = *(_DWORD *)a1;
  result[44] = *(_BYTE *)(a1 + 44);
  return result;
}

//----- (00038DD4) --------------------------------------------------------
_BYTE *__fastcall sub_38DD4(const char *a1, int a2, int a3, int a4, char a5, const char *a6, const char *a7, int a8)
{
  _BYTE *v12; // r4
  pthread_mutex_t *v13; // r0
  pthread_mutex_t *v14; // r10
  int *v16; // r0
  int *v17; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( a3 <= 0 )
  {
    snprintf(
      s,
      0x1000u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      a1,
      a3,
      "klist.c",
      "_k_new_list",
      100);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( a4 < 0 )
  {
    snprintf(
      s,
      0x1000u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      a1,
      a4,
      "klist.c",
      "_k_new_list",
      103);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v12 = calloc(1u, 0x40u);
  if ( !v12 )
  {
    snprintf(s, 0x1000u, "Failed to calloc list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 107);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v12[4] = 0;
  v13 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v14 = v13;
  *((_DWORD *)v12 + 2) = v13;
  if ( !v13 )
  {
    snprintf(s, 0x1000u, "Failed to calloc lock for list %s in %s %s():%d", a1, "klist.c", "_k_new_list", 113);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( pthread_mutex_init(v13, 0) )
  {
    v17 = _errno_location();
    snprintf(s, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v14[1], 0) )
  {
    v16 = _errno_location();
    snprintf(s, 0x1000u, "Failed to pthread_rwlock_init errno=%d in %s %s():%d", *v16, "klist.c", "_k_new_list", 115);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  *(_DWORD *)v12 = a1;
  *((_DWORD *)v12 + 5) = a2;
  *((_DWORD *)v12 + 9) = a3;
  *((_DWORD *)v12 + 10) = a4;
  v12[44] = a5;
  sub_389F0((const char **)v12, a6, a7, a8);
  return v12;
}

//----- (00039094) --------------------------------------------------------
int __fastcall sub_39094(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r4
  int v6; // r3

  v5 = *(_DWORD *)(a1 + 12);
  if ( !v5 )
  {
    if ( *(_BYTE *)(a1 + 4) )
      return v5;
    sub_389F0((const char **)a1, a2, a3, a4);
    if ( !*(_DWORD *)(a1 + 12) )
      return v5;
    v5 = *(_DWORD *)(a1 + 12);
  }
  v6 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(a1 + 12) = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 0;
  }
  else if ( *(_BYTE *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return v5;
}

//----- (00039114) --------------------------------------------------------
int __fastcall sub_39114(int a1, const char *a2, const char *a3, int a4)
{
  int v5; // r0
  int v6; // r4

  v5 = sub_39094(a1, a2, a3, a4);
  v6 = v5;
  if ( v5 )
    memset(*(void **)(v5 + 12), 0, *(_DWORD *)(a1 + 20));
  return v6;
}

//----- (00039140) --------------------------------------------------------
int __fastcall sub_39140(int a1, const char *a2, const char *a3, int a4)
{
  int result; // r0
  int v6; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( !*(_BYTE *)(a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *(const char **)a1,
      "_k_unlink_tail",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_unlink_tail",
      181);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    v6 = *(_DWORD *)(result + 4);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v6 )
      *(_DWORD *)(v6 + 8) = 0;
    else
      *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 4) = 0;
    --*(_DWORD *)(a1 + 28);
  }
  return result;
}

//----- (00039208) --------------------------------------------------------
const char *__fastcall sub_39208(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r3
  int v10; // r3
  int v11; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = *(const char **)a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_head",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_head",
      205);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  v9 = *(_DWORD *)(a1 + 12);
  if ( v9 )
    *(_DWORD *)(v9 + 4) = a2;
  v10 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = a2;
  if ( v10 && !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(a1 + 16) = a2;
  v11 = *(_DWORD *)(a1 + 32);
  ++*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 32) = v11 + 1;
  return result;
}

//----- (000392F8) --------------------------------------------------------
const char *__fastcall sub_392F8(const char **a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  const char *v9; // r3
  const char *v10; // r3
  bool v11; // zf
  const char *v12; // r3
  int v13; // r2
  const char *v14; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = *a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_add_tail",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      236);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_add_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_add_tail",
      241);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v9 = a1[4];
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = v9;
  v10 = a1[4];
  if ( v10 )
    *((_DWORD *)v10 + 2) = a2;
  v11 = a1[3] == 0;
  v12 = a1[8];
  v13 = (int)(a1[7] + 1);
  a1[4] = (const char *)a2;
  v14 = v12 + 1;
  if ( v11 )
    a1[3] = (const char *)a2;
  a1[7] = (const char *)v13;
  a1[8] = v14;
  return result;
}

//----- (00039450) --------------------------------------------------------
const char **__fastcall sub_39450(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  const char *v9; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_before",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      262);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x1000u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_before",
      267);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  *(_DWORD *)(a2 + 8) = a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  v8 = *(_DWORD *)(a3 + 4);
  if ( v8 )
    *(_DWORD *)(v8 + 8) = a2;
  else
    result[3] = (const char *)a2;
  *(_DWORD *)(a3 + 4) = a2;
  v9 = result[8];
  ++result[7];
  result[8] = v9 + 1;
  return result;
}

//----- (000395AC) --------------------------------------------------------
const char **__fastcall sub_395AC(const char **result, int a2, int a3, const char *a4, const char *a5, int a6)
{
  const char *v7; // r1
  int v8; // r3
  const char *v9; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *(const char **)a2;
  if ( v7 != *result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      *result,
      "_k_insert_after",
      v7,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      286);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( !a3 )
  {
    snprintf(
      s,
      0x1000u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      *result,
      a4,
      a5,
      a6,
      "klist.c",
      "_k_insert_after",
      291);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  v8 = *(_DWORD *)(a3 + 8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a2;
  }
  else if ( *((_BYTE *)result + 44) )
  {
    result[4] = (const char *)a2;
  }
  *(_DWORD *)(a3 + 8) = a2;
  v9 = result[8];
  ++result[7];
  result[8] = v9 + 1;
  return result;
}

//----- (00039718) --------------------------------------------------------
const char *__fastcall sub_39718(int a1, int a2, const char *a3, const char *a4, int a5)
{
  const char *result; // r0
  const char *v8; // r1
  int v9; // r3
  int v10; // r3
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  result = *(const char **)a1;
  v8 = *(const char **)a2;
  if ( v8 != result )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      result,
      "_k_unlink_item",
      v8,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_unlink_item",
      312);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v9 = *(_DWORD *)(a2 + 4);
  if ( v9 )
    *(_DWORD *)(v9 + 8) = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(a2 + 8);
  if ( v10 )
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(a1 + 12) == a2 )
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)(a1 + 44) && *(_DWORD *)(a1 + 16) == a2 )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  --*(_DWORD *)(a1 + 28);
  return result;
}

//----- (0003981C) --------------------------------------------------------
const char *__fastcall sub_3981C(const char **a1, int *a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *result; // r0
  int v9; // r1
  int v10; // r3
  const char *v11; // r2
  const char *v12; // r2
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *a1;
  result = (const char *)*a2;
  if ( v7 != (const char *)*a2 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v7,
      "_k_list_transfer_to_head",
      (const char *)*a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v9 = *((unsigned __int8 *)a1 + 44);
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_head",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( a1[3] )
  {
    v10 = a2[3];
    v11 = a1[4];
    if ( v10 )
    {
      *(_DWORD *)(v10 + 4) = v11;
    }
    else
    {
      v9 = 0;
      a2[4] = (int)v11;
    }
    if ( v10 )
      v9 = a2[3];
    *((_DWORD *)a1[4] + 2) = v9;
    a2[3] = (int)a1[3];
    a1[4] = 0;
    v12 = a1[7];
    a1[3] = 0;
    a2[7] += (int)v12;
    a1[7] = 0;
    a2[8] += (int)a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (0003999C) --------------------------------------------------------
const char *__fastcall sub_3999C(const char **a1, int *a2, const char *a3, const char *a4, int a5)
{
  const char *v7; // r1
  const char *result; // r0
  const char *v9; // r3
  int v10; // r2
  const char *v11; // r2
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  v7 = *a1;
  result = (const char *)*a2;
  if ( v7 != (const char *)*a2 )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      v7,
      "_k_list_transfer_to_tail",
      (const char *)*a2,
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( !*((_BYTE *)a1 + 44) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_list_transfer_to_tail",
      a3,
      a4,
      a5,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  v9 = a1[3];
  if ( v9 )
  {
    v10 = a2[4];
    if ( v10 )
      *(_DWORD *)(v10 + 8) = v9;
    else
      a2[3] = (int)v9;
    if ( v10 )
      v10 = a2[4];
    *((_DWORD *)a1[3] + 1) = v10;
    a2[4] = (int)a1[4];
    a1[4] = 0;
    v11 = a1[7];
    a1[3] = 0;
    a2[7] += (int)v11;
    a1[7] = 0;
    a2[8] += (int)a1[8];
    a1[8] = 0;
  }
  return result;
}

//----- (00039B14) --------------------------------------------------------
int __fastcall sub_39B14(const char **a1, const char *a2, const char *a3, int a4)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  char *v9; // r5
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( *((_BYTE *)a1 + 4) )
  {
    snprintf(
      s,
      0x1000u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      *a1,
      "_k_free_list",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_list",
      400);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  if ( (int)a1[12] > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(void **)&a1[13][4 * v5++];
      free(v6);
    }
    while ( (int)a1[12] > v5 );
  }
  free((void *)a1[13]);
  if ( (int)a1[14] > 0 )
  {
    v7 = 0;
    do
    {
      v8 = *(void **)&a1[15][4 * v7++];
      free(v8);
    }
    while ( (int)a1[14] > v7 );
  }
  free((void *)a1[15]);
  v9 = (char *)a1[2];
  pthread_rwlock_destroy((pthread_rwlock_t *)(v9 + 24));
  pthread_mutex_destroy((pthread_mutex_t *)v9);
  free((void *)a1[2]);
  free(a1);
  return 0;
}

//----- (00039C30) --------------------------------------------------------
int __fastcall sub_39C30(const char **ptr, const char *a2, const char *a3, int a4)
{
  char s[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( !*((_BYTE *)ptr + 4) )
  {
    snprintf(
      s,
      0x1000u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      *ptr,
      "_k_free_store",
      a2,
      a3,
      a4,
      "klist.c",
      "_k_free_store",
      424);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  free(ptr);
  return 0;
}

//----- (00039D8C) --------------------------------------------------------
int __fastcall sub_39D8C(__int64 a1, _QWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(a1 + 24);
  if ( v2 )
  {
    *(_QWORD *)HIDWORD(a1) = *(_QWORD *)(v2 + 16);
    a1 = *(_QWORD *)(v2 + 24);
    *a2 = a1;
  }
  else
  {
    *(_QWORD *)HIDWORD(a1) = 0;
    *a2 = 0;
  }
  return a1;
}

//----- (0003A1EC) --------------------------------------------------------
void sub_3A1EC()
{
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s %d", "reset_all_hash_board_low", 4070);
    sub_385C8(5, s, 0);
  }
  *(_DWORD *)(dword_75C50 + 52) = 0xFFFF;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50;
// 77B70: using guessed type char byte_77B70;

//----- (0003A28C) --------------------------------------------------------
void sub_3A28C()
{
  char v0[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(v0, "Updated Work!");
    sub_385C8(7, v0, 0);
  }
  byte_75C54 = 1;
  byte_75C55 = 1;
  byte_75C56 = 1;
  byte_75C57 = 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C54: using guessed type char byte_75C54;
// 75C55: using guessed type char byte_75C55;
// 75C56: using guessed type char byte_75C56;
// 75C57: using guessed type char byte_75C57;
// 77B70: using guessed type char byte_77B70;

//----- (0003A384) --------------------------------------------------------
_DWORD *sub_3A384()
{
  _DWORD *v0; // r0
  int v1; // r5
  _DWORD *v2; // r8
  const char *v3; // r2
  _DWORD *v4; // r0
  int v5; // r5
  _DWORD *v6; // r6
  const char *v7; // r2
  int i; // r5
  const char *v9; // r2
  _DWORD *v10; // r0
  _DWORD *v11; // r5
  __int64 v12; // r0
  __int64 v13; // r0
  int32x2_t v14; // d8
  double v15; // r0
  double v16; // d16
  int v17; // r6
  _DWORD *v18; // r0
  _DWORD *v19; // r5
  const char *v20; // r2
  int j; // r6
  char *v22; // r2
  int k; // r6
  _DWORD *v24; // r0
  int v25; // r8
  int v26; // r2
  int v27; // r4
  int v28; // r6
  int v29; // r7
  _DWORD *result; // r0
  const char *v31; // [sp+4h] [bp-28h]
  _DWORD s[4]; // [sp+8h] [bp-24h] BYREF
  _DWORD v33[5]; // [sp+18h] [bp-14h] BYREF

  v0 = sub_32CD4(0, "miner_count", &byte_9A49F, 0);
  v1 = 0;
  v2 = sub_32CD4(v0, "fan_num", &byte_9A4A0, 0);
  do
  {
    sprintf((char *)v33, "fan%d", v1 + 1);
    v3 = (char *)&unk_9A2A8 + 4 * v1++ + 457;
    v4 = sub_32D88(v2, (const char *)v33, v3, 0);
    v2 = v4;
  }
  while ( v1 != 6 );
  v5 = 0;
  v6 = sub_32CD4(v4, "temp_num", &byte_9A49F, 0);
  do
  {
    sprintf((char *)v33, "temp%d", v5 + 1);
    v7 = (char *)&unk_9A2A8 + 4 * v5++ + 621;
    v6 = sub_32CF8(v6, (const char *)v33, v7, 0);
  }
  while ( v5 != 4 );
  for ( i = 0; i != 4; ++i )
  {
    sprintf((char *)v33, "temp2_%d", i + 1);
    v9 = (char *)&unk_9A2A8 + 4 * i + 637;
    v10 = sub_32CF8(v6, (const char *)v33, v9, 0);
    v6 = v10;
  }
  v11 = sub_32D88(v10, "temp_max", (const char *)&dword_9A4AA, 0);
  LODWORD(v12) = sub_59FC8(dbl_78410 + dbl_78498 + dbl_78250);
  *(_QWORD *)&dword_77F28 = v12;
  v13 = v12 + dword_786CC;
  if ( v13 )
  {
    v14.n64_u32[0] = dword_786CC;
    v14.n64_u32[1] = dword_786CC;
    LODWORD(v15) = sub_59F1C(v13);
    v16 = vcvt_n_f64_s32(v14, 8u) / v15;
  }
  else
  {
    v16 = 0.0;
  }
  v17 = 0;
  *(double *)&dword_75C60 = v16;
  v18 = sub_35624(v11, "Device Hardware%", (const char *)&dword_75C60, 1);
  v19 = sub_32D40(v18, "no_matching_work", (const char *)&dword_786CC, 1);
  do
  {
    sprintf((char *)v33, "chain_acn%d", v17 + 1);
    v20 = (char *)&unk_9A2A8 + v17++ + 497;
    v19 = sub_32CD4(v19, (const char *)v33, v20, 0);
  }
  while ( v17 != 4 );
  for ( j = 0; j != 4; ++j )
  {
    sprintf((char *)v33, "chain_acs%d", j + 1);
    v22 = (char *)&unk_9A2A8 + 19 * j;
    v19 = sub_32C8C(v19, (const char *)v33, v22 + 323, 0);
  }
  for ( k = 0; k != 4; ++k )
  {
    sprintf((char *)v33, "chain_hw%d", k + 1);
    v24 = sub_32D88(v19, (const char *)v33, (const char *)&unk_9A2A8 + 4 * k + 211, 0);
    v19 = v24;
  }
  v25 = 0;
  do
  {
    memset(s, 0, sizeof(s));
    memset(v33, 0, 16);
    sprintf((char *)s, "frequency%d", v25 + 1);
    v26 = v25 + 280;
    ++v25;
    v31 = (char *)&unk_9A2A8 + 2 * v26 + 1;
    sprintf((char *)v33, "%u", *(unsigned __int16 *)v31);
    v19 = sub_32D1C(v19, (const char *)s, v31, 0);
  }
  while ( v25 != 4 );
  v27 = 0;
  do
  {
    v28 = v27 + 1;
    v29 = 16 * v27;
    sprintf((char *)v33, "chain_rate%d", v27 + 1);
    if ( byte_75C68 )
      sprintf(&byte_78ED0[v29], "%2.2f", dbl_75C70 / (double)dword_75C78);
    result = sub_32C8C(v19, (const char *)v33, &byte_78ED0[v29], 0);
    ++v27;
    v19 = result;
  }
  while ( v28 != 4 );
  return result;
}
// 3A4F0: variable 'v12' is possibly undefined
// 3A514: variable 'v15' is possibly undefined
// 75C60: using guessed type int dword_75C60;
// 75C68: using guessed type char byte_75C68;
// 75C70: using guessed type double dbl_75C70;
// 75C78: using guessed type int dword_75C78;
// 77F28: using guessed type int dword_77F28;
// 78250: using guessed type double dbl_78250;
// 78410: using guessed type double dbl_78410;
// 78498: using guessed type double dbl_78498;
// 786CC: using guessed type int dword_786CC;
// 9A49F: using guessed type char byte_9A49F;
// 9A4A0: using guessed type char byte_9A4A0;
// 9A4AA: using guessed type int dword_9A4AA;

//----- (0003A7B8) --------------------------------------------------------
int sub_3A7B8()
{
  int result; // r0

  if ( !byte_75C7C )
    return system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
  return result;
}
// 75C7C: using guessed type char byte_75C7C;

//----- (0003A7D8) --------------------------------------------------------
void sub_3A7D8()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  v0 = calloc(1u, 0x188u);
  v1 = v0;
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-zcash.c", 0x1B6Fu, "bitmain_ZCASH_detect");
  v0[37] = 1;
  v0[1] = &unk_73908;
  v0[8] = 0;
  v2 = calloc(0x4B4u, 1u);
  v1[5] = v2;
  if ( !v2 )
  {
    strcpy(v3, "Failed to calloc cgpu_info data");
    sub_385C8(3, v3, 1);
    sub_16BE0(1);
  }
  if ( !sub_27F60(v1) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-zcash.c", 0x1B77u, "bitmain_ZCASH_detect");
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v3, 0x1000u, "%s detect new device", "bitmain_ZCASH_detect");
    sub_385C8(7, v3, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0003A934) --------------------------------------------------------
void __noreturn sub_3A934()
{
  int v0; // r5
  int v1; // r8
  int v2; // r1
  unsigned int v3; // r3
  int v4; // r1
  unsigned int v5; // [sp+4h] [bp-8h]

  while ( 1 )
  {
    v0 = 2;
    dword_9A4A2 = 0;
    dword_9A4A6 = 0;
    do
    {
      v1 = 6;
      do
      {
        while ( 1 )
        {
          v5 = *(_DWORD *)(dword_75C50 + 4);
          if ( v5 == -1 )
            goto LABEL_9;
          v2 = (v5 >> 8) & 7;
          v3 = 120 * (unsigned __int8)v5;
          *(_DWORD *)((char *)&unk_9A2A8 + 4 * v2 + 457) = v3;
          if ( (_BYTE)v5 )
          {
            if ( !*((_BYTE *)&unk_9A2A8 + v2 + 427) )
            {
              *((_BYTE *)&unk_9A2A8 + v2 + 427) = 1;
              ++byte_9A4A0;
              dword_9A2BC |= 1 << v2;
            }
          }
          else if ( *((_BYTE *)&unk_9A2A8 + v2 + 427) == 1 )
          {
            *((_BYTE *)&unk_9A2A8 + v2 + 427) = 0;
            if ( 1 << v2 )
              v4 = 0;
            else
              v4 = dword_9A2BC & 1;
            dword_9A2BC = v4;
            --byte_9A4A0;
          }
          if ( v3 > dword_9A4A2 )
            dword_9A4A2 = 120 * (unsigned __int8)v5;
          if ( (v3 >= dword_9A4A6 || !v3) && dword_9A4A6 )
            break;
          dword_9A4A6 = 120 * (unsigned __int8)v5;
LABEL_9:
          sub_2A884();
          if ( !--v1 )
            goto LABEL_16;
        }
        sub_2A884();
        --v1;
      }
      while ( v1 );
LABEL_16:
      --v0;
    }
    while ( v0 );
    sleep(1u);
  }
}
// 75C50: using guessed type int dword_75C50;
// 9A2BC: using guessed type int dword_9A2BC;
// 9A4A0: using guessed type char byte_9A4A0;
// 9A4A2: using guessed type int dword_9A4A2;
// 9A4A6: using guessed type int dword_9A4A6;

//----- (0003AA8C) --------------------------------------------------------
void __noreturn sub_3AA8C()
{
  double *v0; // r5
  int v1; // r6
  int v2; // r3
  int v3; // r9
  int v4; // r2
  int v5; // r3
  _QWORD *v6; // r7
  int v7; // s28
  int v8; // s29
  int v9; // r4
  double v10; // d8
  int v12; // r10
  double v13; // r0
  double *v14; // r8
  int v15; // r3
  double v16; // d16
  double v17; // d17
  int v18; // r10
  double v19; // d16
  struct timeval v20; // [sp+8h] [bp-10h] BYREF
  struct timeval v21; // [sp+10h] [bp-8h] BYREF
  _DWORD v22[4]; // [sp+18h] [bp+0h] BYREF
  _DWORD s[81]; // [sp+28h] [bp+10h] BYREF

  memset(s, 0, 0x140u);
  memset(v22, 0, sizeof(v22));
  sub_2A7A4(&v20);
  sub_2A7A4(&v21);
  while ( 1 )
  {
    v0 = (double *)&unk_75C80;
    sub_2A7A4(&v21);
    v1 = 0;
    v2 = v21.tv_usec - v20.tv_usec + (v21.tv_usec - v20.tv_usec < 0 ? 0xF4000 : 0);
    v3 = 631471;
    v4 = v21.tv_sec - v20.tv_sec;
    if ( v21.tv_usec - v20.tv_usec < 0 )
      v2 += 576;
    v5 = v2 + 1;
    v6 = qword_75CA0;
    v7 = v21.tv_sec - v20.tv_sec;
    if ( v21.tv_usec - v20.tv_usec < 0 )
      --v4;
    v8 = v5;
    v9 = 0;
    if ( v21.tv_usec - v20.tv_usec < 0 )
      v7 = v4;
    v10 = 0.0;
    do
    {
      if ( *(unsigned __int8 *)++v3 )
      {
        v12 = v22[v1];
        LODWORD(v13) = sub_59F08(0x1FFFLL * *v6);
        *v6 = 0;
        v14 = (double *)&s[20 * v9];
        v15 = 10;
        *v0 = 0.0;
        v16 = 0.0;
        *(double *)&s[20 * v9 + 2 * v12] = v13 / ((double)v7 + (double)v8 / 1000000.0);
        do
        {
          --v15;
          v17 = *v14++;
          v16 = v16 + v17;
        }
        while ( v15 );
        *v0 = v16;
        v18 = v12 + 1;
        sprintf(&byte_78ED0[16 * v9], "%.2f", v16 / 1000.0 / 10.0);
        v19 = *v0 / 1000.0;
        if ( v18 > 9 )
          v18 = 0;
        v22[v1] = v18;
        v10 = v10 + v19 / 10.0;
      }
      ++v9;
      ++v1;
      ++v0;
      ++v6;
    }
    while ( v9 != 4 );
    sprintf(byte_759C0, "%.2f", v10);
    dbl_75CC0 = v10;
    sub_2A488(&v20, &v21);
    sleep(5u);
  }
}
// 3ABA4: variable 'v13' is possibly undefined
// 75CA0: using guessed type _QWORD qword_75CA0[4];
// 75CC0: using guessed type double dbl_75CC0;

//----- (0003AC78) --------------------------------------------------------
int sub_3AC78()
{
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  snprintf(s, 0x1000u, "%s input param error: str length = %u\n", "bm1740_makeup_set_config_cmd", 13);
  sub_385C8(3, s, 0);
  return -1;
}

//----- (0003ACC8) --------------------------------------------------------
int sub_3ACC8()
{
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  snprintf(s, 0x1000u, "%s input param error: str length = %u\n", "bm1740_makeup_get_status_cmd", 9);
  sub_385C8(3, s, 0);
  return -1;
}

//----- (0003AD18) --------------------------------------------------------
int __fastcall sub_3AD18(pthread_rwlock_t *a1)
{
  int result; // r0
  int *v2; // r0
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  result = pthread_rwlock_init(a1, 0);
  if ( result )
  {
    v2 = _errno_location();
    snprintf(
      s,
      0x1000u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v2,
      "driver-btm-zcash.c",
      "bitmain_ZCASH_prepare",
      7042);
    sub_385C8(3, s, 1);
    sub_16BE0(1);
  }
  return result;
}

//----- (0003AD9C) --------------------------------------------------------
int __fastcall sub_3AD9C(int a1)
{
  int v1; // r7
  char *v2; // r4
  unsigned __int8 *v3; // r3
  unsigned __int8 *v4; // r10
  unsigned int v5; // r6
  int v6; // r8
  char *v7; // r3
  int *v8; // r3
  int v9; // t1
  char *v10; // r3
  _DWORD *v11; // r2
  unsigned int v12; // r0
  unsigned int v13; // t1
  unsigned int v14; // t1
  bool v15; // cc
  int v16; // r0
  int v17; // r3
  unsigned int v19; // r0
  unsigned int v20; // r12
  char *v21; // r8
  char *v22; // r2
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int v27; // [sp+14h] [bp-1738h]
  unsigned int v28; // [sp+18h] [bp-1734h]
  pthread_mutex_t *mutex; // [sp+1Ch] [bp-1730h]
  int v30; // [sp+20h] [bp-172Ch]
  _DWORD *v31; // [sp+34h] [bp-1718h]
  char v33[4]; // [sp+44h] [bp-1708h] BYREF
  int v34; // [sp+48h] [bp-1704h]
  struct timeval v35; // [sp+4Ch] [bp-1700h] BYREF
  int v36[3]; // [sp+54h] [bp-16F8h] BYREF
  _DWORD v37[8]; // [sp+60h] [bp-16ECh] BYREF
  _BYTE v38[32]; // [sp+80h] [bp-16CCh] BYREF
  char v39[360]; // [sp+A0h] [bp-16ACh] BYREF
  _BYTE s[1344]; // [sp+208h] [bp-1544h] BYREF
  char v41[4088]; // [sp+748h] [bp-1004h] BYREF

  v31 = *(_DWORD **)(a1 + 36);
  mutex = (pthread_mutex_t *)v31[5];
  memset(s, 0, sizeof(s));
  sub_2A7A4(&v35);
  dbl_75C58 = 0.0;
  pthread_mutex_lock(&stru_75CC8);
  v1 = dword_79088;
  pthread_mutex_unlock(&stru_75CC8);
  if ( pthread_mutex_lock(mutex) )
  {
    v23 = _errno_location();
    snprintf(
      v41,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v23,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      5806);
    sub_385C8(3, v41, 1);
    sub_16BE0(1);
  }
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)&mutex[1]) )
  {
    v26 = _errno_location();
    snprintf(
      v41,
      0x1000u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v26,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      5806);
    sub_385C8(3, v41, 1);
    sub_16BE0(1);
  }
  if ( pthread_mutex_unlock(mutex) )
  {
    v25 = _errno_location();
    snprintf(
      v41,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v25,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      5806);
    sub_385C8(3, v41, 1);
    sub_16BE0(1);
  }
  if ( !v1 )
    goto LABEL_28;
  v2 = 0;
  do
  {
    --v1;
    pthread_mutex_lock(&stru_75CC8);
    v3 = (unsigned __int8 *)&dword_79080 + 1357 * dword_79084;
    --dword_79088;
    v4 = v3 + 1360;
    v5 = v3[1368];
    v6 = v3[1357];
    v30 = v3[1358];
    v28 = v3[1356];
    memcpy(s, v3 + 12, sizeof(s));
    v34 = *((_DWORD *)v4 + 1);
    pthread_mutex_unlock(&stru_75CC8);
    if ( v5 > 4 && (byte_77B70 || byte_75C48 || dword_73504 > 4) )
    {
      snprintf(v41, 0x1000u, "Error:scanhash chainid=%u\n", v5);
      sub_385C8(5, v41, 0);
    }
    pthread_mutex_lock(&stru_75CE0);
    v7 = &mutex[4].__size[4 * v6 + 16];
    v9 = *(_DWORD *)(v7 + 6);
    v8 = (int *)(v7 + 6);
    if ( v9 )
      v2 = (char *)sub_1A598(*v8, 0);
    pthread_mutex_unlock(&stru_75CE0);
    if ( !v2 )
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
        goto LABEL_24;
      snprintf(v41, 0x1000u, "%s %d: work %02x not find error", *(const char **)(v31[1] + 8), v31[2], v6);
LABEL_34:
      sub_385C8(3, v41, 0);
      goto LABEL_24;
    }
    *((_DWORD *)v2 + 85) = v34;
    memcpy(v2 + 367, s, 0x540u);
    v36[0] = 200;
    v36[2] = (int)v39;
    v36[1] = 9;
    sub_4D714(v39, 200, 9);
    sub_537BC((int)v39, v2 + 224, 0x8Cu);
    memset(v38, 0, sizeof(v38));
    memset(v37, 0, sizeof(v37));
    memset(v41, 0, 0x5CFu);
    memcpy(v41, v2 + 224, 0x5CFu);
    sub_54160((int)v41, 1487, v37);
    sub_54160((int)v37, 32, v38);
    v10 = v39;
    v11 = v2 + 192;
    while ( 1 )
    {
      v13 = (unsigned __int8)*--v10;
      v12 = v13;
      v14 = *((unsigned __int8 *)v11 - 1);
      v11 = (_DWORD *)((char *)v11 - 1);
      v15 = v12 > v14;
      if ( v12 < v14 )
      {
LABEL_18:
        v16 = sub_4CEC0(v36, (unsigned int)s);
        if ( !v16 )
        {
          sub_25D80(a1, (int)v2, 1);
          goto LABEL_36;
        }
LABEL_19:
        if ( v16 == 2 )
        {
          v21 = (char *)&unk_9A2A8 + 12 * v5 + 4 * (unsigned __int8)(v28 / (unsigned __int8)byte_9A4C7) + 272;
          ++*(_DWORD *)(v21 + 3);
          ++*(_DWORD *)((char *)&unk_9A2A8 + 4 * v5 + 211);
        }
        if ( byte_73F7C )
        {
          byte_73F7C = 0;
          memset(&unk_9A37B, 0, 0x10u);
        }
LABEL_23:
        sub_2F7A4(v2, v33, 1);
        sub_156B8((void **)v2);
        v2 = 0;
        goto LABEL_24;
      }
      if ( v15 )
        break;
      if ( v10 == v38 )
        goto LABEL_18;
    }
    v16 = sub_4CEC0(v36, (unsigned int)s);
    if ( v16 )
      goto LABEL_19;
LABEL_36:
    ++*(_QWORD *)&dbl_75C58;
    ++qword_75CA0[v5];
    v19 = v28 / (unsigned __int8)byte_9A4C7;
    v20 = (unsigned __int8)v19;
    if ( !byte_75C49 || !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
    {
      if ( v5 <= 4 )
        goto LABEL_41;
      goto LABEL_49;
    }
    v27 = (unsigned __int8)v19;
    snprintf(v41, 0x1000u, "%s: chain %d which_asic_nonce %d ", "bitmain_scanhash", v5, (unsigned __int8)v19);
    sub_385C8(7, v41, 0);
    v20 = v27;
    if ( v5 > 4 )
      goto LABEL_49;
LABEL_41:
    if ( !*((_BYTE *)&unk_9A2A8 + v5 + 8) )
    {
LABEL_49:
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
        goto LABEL_24;
      snprintf(v41, 0x1000u, "ChainID Cause Error! ChainID:[%d]", v5);
      goto LABEL_34;
    }
    if ( v20 <= 2 )
    {
      v22 = (char *)&unk_9A2A8 + 12 * v5 + 4 * v20 + 224;
      ++*(_DWORD *)(v22 + 3);
      goto LABEL_23;
    }
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v41, 0x1000u, "Which Nonce Cause Err![%d] %08x", v20, v30);
      sub_385C8(7, v41, 0);
    }
LABEL_24:
    pthread_mutex_lock(&stru_75CC8);
    if ( (unsigned int)dword_79084 > 0x62 )
      v17 = 0;
    else
      v17 = dword_79084 + 1;
    dword_79084 = v17;
    pthread_mutex_unlock(&stru_75CC8);
  }
  while ( v1 );
LABEL_28:
  if ( pthread_rwlock_unlock((pthread_rwlock_t *)&mutex[1]) )
  {
    v24 = _errno_location();
    snprintf(
      v41,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v24,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      5906);
    sub_385C8(3, v41, 1);
    sub_16BE0(1);
  }
  off_72D18();
  *(_QWORD *)&dbl_75C58 = vshld_n_s64(*(__int64 *)&dbl_75C58, 0xDu) - *(_QWORD *)&dbl_75C58;
  return 0;
}
// 72D18: using guessed type int (*off_72D18)();
// 73504: using guessed type int dword_73504;
// 73F7C: using guessed type char byte_73F7C;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C58: using guessed type double dbl_75C58;
// 75CA0: using guessed type _QWORD qword_75CA0[4];
// 77B70: using guessed type char byte_77B70;
// 79080: using guessed type int dword_79080;
// 79084: using guessed type int dword_79084;
// 79088: using guessed type int dword_79088;
// 9A4C7: using guessed type char byte_9A4C7;

//----- (0003B5B8) --------------------------------------------------------
int sub_3B5B8()
{
  int fd; // r0
  void *v1; // r1
  int v2; // r0
  void *v3; // r1

  fd = open("/dev/axi_fpga_dev", 2);
  dword_78BB8 = fd;
  if ( fd < 0 )
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    return -1;
  }
  else
  {
    v1 = mmap(0, 0x1200u, 3, 1, fd, 0);
    dword_75C50 = (int)v1;
    if ( v1 )
    {
      printf("mmap axi_fpga_addr = 0x%x\n", v1);
      printf("axi_fpga_addr data = 0x%x\n", *(unsigned __int16 *)dword_75C50);
      v2 = open("/dev/fpga_mem", 2);
      dword_78F10 = v2;
      if ( v2 < 0 )
      {
        printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n", v2);
        return -1;
      }
      else
      {
        v3 = mmap(0, 0x1000000u, 3, 1, v2, 0);
        dword_75CF8 = (int)v3;
        if ( v3 )
        {
          printf("mmap fpga_mem_addr = 0x%x\n", v3);
          return 0;
        }
        else
        {
          printf("mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", 0);
          return -1;
        }
      }
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", 0);
      return -1;
    }
  }
}
// 75C50: using guessed type int dword_75C50;
// 75CF8: using guessed type int dword_75CF8;
// 78BB8: using guessed type int dword_78BB8;
// 78F10: using guessed type int dword_78F10;

//----- (0003B6F8) --------------------------------------------------------
int sub_3B6F8()
{
  printf("\n\n--- %s\n", "bitmain_axi_close");
  if ( munmap((void *)dword_75C50, 0x1200u) < 0 )
    puts("munmap failed!");
  if ( munmap((void *)dword_75CF8, 0x1000000u) < 0 )
    puts("munmap failed!");
  close(dword_78BB8);
  return close(dword_78F10);
}
// 75C50: using guessed type int dword_75C50;
// 75CF8: using guessed type int dword_75CF8;
// 78BB8: using guessed type int dword_78BB8;
// 78F10: using guessed type int dword_78F10;

//----- (0003B808) --------------------------------------------------------
int __fastcall sub_3B808(int a1)
{
  return *(_DWORD *)(dword_75C50 + 4 * a1);
}
// 75C50: using guessed type int dword_75C50;

//----- (0003B834) --------------------------------------------------------
int __fastcall sub_3B834(int result, int a2)
{
  *(_DWORD *)(dword_75C50 + 4 * result) = a2;
  return result;
}
// 75C50: using guessed type int dword_75C50;

//----- (0003B848) --------------------------------------------------------
int sub_3B848()
{
  printf("\n--- %s\n", "init_fpga");
  *(_DWORD *)(dword_75C50 + 128) = -2147450880;
  do
    sub_2A8AC();
  while ( *(int *)(dword_75C50 + 128) < 0 );
  return sub_2A8AC();
}
// 75C50: using guessed type int dword_75C50;

//----- (0003B8DC) --------------------------------------------------------
int __fastcall sub_3B8DC(int a1)
{
  int result; // r0

  switch ( a1 )
  {
    case 0:
      result = 1;
      break;
    case 1:
      result = 3;
      break;
    case 2:
      result = 5;
      break;
    case 6:
      result = 13;
      break;
    case 26:
      goto LABEL_3;
    default:
      printf("%s: Don't support ASIC baud = %d, error!!!\n", "asic_baud_to_fpga_baud", a1);
LABEL_3:
      result = 53;
      break;
  }
  return result;
}
// 3B8E8: control flows out of bounds to 3B8EC

//----- (0003B998) --------------------------------------------------------
int __fastcall sub_3B998(int a1)
{
  int result; // r0

  result = sub_3B8DC(a1);
  *(_DWORD *)(dword_75C50 + 60) = result;
  return result;
}
// 75C50: using guessed type int dword_75C50;

//----- (0003B9B4) --------------------------------------------------------
int __fastcall sub_3B9B4(int a1)
{
  int result; // r0

  switch ( a1 )
  {
    case 0:
      result = HIWORD(*(_DWORD *)(dword_75C50 + 4352)) & 0x3FF;
      break;
    case 1:
      result = *(_DWORD *)(dword_75C50 + 4352) & 0x3FF;
      break;
    case 2:
      result = HIWORD(*(_DWORD *)(dword_75C50 + 4356)) & 0x3FF;
      break;
    case 3:
      result = *(_DWORD *)(dword_75C50 + 4356) & 0x3FF;
      break;
    case 4:
      result = HIWORD(*(_DWORD *)(dword_75C50 + 4360)) & 0x3FF;
      break;
    case 5:
      result = *(_DWORD *)(dword_75C50 + 4360) & 0x3FF;
      break;
    case 6:
      result = HIWORD(*(_DWORD *)(dword_75C50 + 4364)) & 0x3FF;
      break;
    case 7:
      result = *(_DWORD *)(dword_75C50 + 4364) & 0x3FF;
      break;
    case 8:
      result = HIWORD(*(_DWORD *)(dword_75C50 + 4368)) & 0x3FF;
      break;
    case 9:
      result = *(_DWORD *)(dword_75C50 + 4368) & 0x3FF;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
      result = 0;
      break;
  }
  return result;
}
// 3B9C4: control flows out of bounds to 3B9C8
// 75C50: using guessed type int dword_75C50;

//----- (0003BBA8) --------------------------------------------------------
int __fastcall sub_3BBA8(int a1, _BYTE *a2, unsigned int a3)
{
  int v3; // r3
  int v4; // r10
  unsigned int v5; // r9
  int result; // r0
  _BYTE *v7; // r3
  int v8; // r12
  int v9; // r2
  _BYTE *v10; // r2
  int v11; // [sp+4h] [bp-4h]

  switch ( a1 )
  {
    case 0:
      v3 = 4400;
      v4 = 1101;
      goto LABEL_3;
    case 1:
      v3 = 4408;
      v4 = 1103;
      goto LABEL_3;
    case 2:
      v3 = 4416;
      v4 = 1105;
      goto LABEL_3;
    case 3:
      v3 = 4424;
      v4 = 1107;
      goto LABEL_3;
    case 4:
      v3 = 4432;
      v4 = 1109;
      goto LABEL_3;
    case 5:
      v3 = 4440;
      v4 = 1111;
      goto LABEL_3;
    case 6:
      v3 = 4448;
      v4 = 1113;
      goto LABEL_3;
    case 7:
      v3 = 4456;
      v4 = 1115;
      goto LABEL_3;
    case 8:
      v3 = 4464;
      v4 = 1117;
      goto LABEL_3;
    case 9:
      v3 = 4472;
      v4 = 1119;
LABEL_3:
      v5 = a3 >> 2;
      *(_DWORD *)(dword_75C50 + v3) = a3 & 0x3FF | 0x80000000;
      if ( a3 >> 2 )
      {
        result = 4 * v5;
        v7 = a2;
        do
        {
          v8 = *(_DWORD *)(dword_75C50 + 4 * v4);
          v7[3] = v8;
          *v7 = HIBYTE(v8);
          v7[1] = BYTE2(v8);
          v7[2] = BYTE1(v8);
          v7 += 4;
        }
        while ( v7 != &a2[4 * v5] );
      }
      else
      {
        result = 0;
      }
      v9 = a3 & 3;
      if ( v9 )
      {
        v11 = *(_DWORD *)(dword_75C50 + 4 * v4);
        if ( v9 == 2 )
        {
          a2[4 * v5] = HIBYTE(v11);
          a2[result + 1] = BYTE2(v11);
          result += 2;
        }
        else if ( v9 == 3 )
        {
          v10 = &a2[result];
          a2[4 * v5] = HIBYTE(v11);
          v10[1] = BYTE2(v11);
          v10[2] = BYTE1(v11);
          result += 3;
        }
        else
        {
          ++result;
          a2[4 * v5] = HIBYTE(v11);
        }
      }
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", a3);
      result = 0;
      break;
  }
  return result;
}
// 3BBB8: control flows out of bounds to 3BBBC
// 75C50: using guessed type int dword_75C50;

//----- (0003BD70) --------------------------------------------------------
int __fastcall sub_3BD70(int a1)
{
  int v2; // r10
  char v3; // r8
  int v4; // r4
  int v5; // r5

  printf("--- %s\n", "clear_uart_send_fifo");
  pthread_mutex_lock(&stru_75CFC[a1]);
  switch ( a1 )
  {
    case 0:
      v2 = 4096;
      v3 = 24;
      goto LABEL_3;
    case 1:
      v2 = 4096;
      v3 = 16;
      goto LABEL_3;
    case 2:
      v2 = 4096;
      v3 = 8;
      goto LABEL_3;
    case 3:
      v2 = 4096;
      v3 = 0;
      goto LABEL_3;
    case 4:
      v2 = 4100;
      v3 = 24;
      goto LABEL_3;
    case 5:
      v2 = 4100;
      v3 = 16;
      goto LABEL_3;
    case 6:
      v2 = 4100;
      v3 = 8;
      goto LABEL_3;
    case 7:
      v2 = 4100;
      v3 = 0;
      goto LABEL_3;
    case 8:
      v2 = 4104;
      v3 = 24;
      goto LABEL_3;
    case 9:
      v2 = 4104;
      v3 = 16;
LABEL_3:
      v4 = 21;
      break;
    default:
      v5 = 1;
      printf("%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", a1);
      pthread_mutex_unlock(&stru_75CFC[a1]);
      return v5;
  }
  while ( 1 )
  {
    v5 = (unsigned __int8)(*(_DWORD *)(dword_75C50 + v2) >> v3);
    if ( v5 == 255 )
      break;
    printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", a1);
    usleep(0xBB8u);
    if ( !--v4 )
    {
      printf("%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", a1);
      pthread_mutex_unlock(&stru_75CFC[a1]);
      return v5;
    }
  }
  v5 = 0;
  pthread_mutex_unlock(&stru_75CFC[a1]);
  return v5;
}
// 3BDA4: control flows out of bounds to 3BDA8
// 75C50: using guessed type int dword_75C50;
// 75CFC: using guessed type pthread_mutex_t stru_75CFC[10];

//----- (0003BF04) --------------------------------------------------------
int __fastcall sub_3BF04(int a1)
{
  pthread_mutex_t *v2; // r5
  size_t v3; // r0
  unsigned int v4; // r6
  _BYTE *v5; // r7
  int v6; // r0

  v2 = (pthread_mutex_t *)((char *)&unk_75DEC + 24 * a1);
  pthread_mutex_lock(v2);
  v3 = sub_3B9B4(a1);
  v4 = v3;
  if ( v3 )
  {
    v5 = malloc(v3);
    if ( v5 )
    {
      v6 = sub_3BBA8(a1, v5, v4);
      if ( v6 != v4 )
        printf("%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", a1, v4, v6);
      free(v5);
    }
    usleep((__useconds_t)&unk_7A120);
    pthread_mutex_unlock(v2);
    return 1;
  }
  else
  {
    pthread_mutex_unlock(v2);
    return 0;
  }
}

//----- (0003BFB4) --------------------------------------------------------
size_t __fastcall sub_3BFB4(int a1, const void *a2, size_t a3)
{
  int v5; // r2
  int v6; // r10
  char v7; // r6
  int v8; // r9
  int v9; // r4
  int v11; // r7
  size_t v12; // r7
  unsigned __int8 *v13; // r2
  int v14; // r12
  int v15; // r0
  int v16; // r1
  int v17; // r3
  int v18; // r2
  _DWORD *v19; // r7
  int v20; // r2
  pthread_mutex_t *mutex; // [sp+0h] [bp-21Ch]
  int v22; // [sp+4h] [bp-218h]
  int v23; // [sp+8h] [bp-214h]
  _DWORD s[129]; // [sp+18h] [bp-204h] BYREF

  memset(s, 0, 0x200u);
  mutex = &stru_75CFC[a1];
  pthread_mutex_lock(mutex);
  switch ( a1 )
  {
    case 0:
      v6 = 4096;
      v7 = 24;
      v22 = 1028;
      v23 = 1029;
      goto LABEL_3;
    case 1:
      v6 = 4096;
      v7 = 16;
      v22 = 1030;
      v23 = 1031;
      goto LABEL_3;
    case 2:
      v6 = 4096;
      v7 = 8;
      v22 = 1032;
      v23 = 1033;
      goto LABEL_3;
    case 3:
      v6 = 4096;
      v7 = 0;
      v22 = 1034;
      v23 = 1035;
      goto LABEL_3;
    case 4:
      v6 = 4100;
      v7 = 24;
      v22 = 1036;
      v23 = 1037;
      goto LABEL_3;
    case 5:
      v6 = 4100;
      v7 = 16;
      v22 = 1038;
      v23 = 1039;
      goto LABEL_3;
    case 6:
      v6 = 4100;
      v7 = 8;
      v22 = 1040;
      v23 = 1041;
      goto LABEL_3;
    case 7:
      v6 = 4100;
      v7 = 0;
      v22 = 1042;
      v23 = 1043;
      goto LABEL_3;
    case 8:
      v6 = 4104;
      v7 = 24;
      v22 = 1044;
      v23 = 1045;
      goto LABEL_3;
    case 9:
      v6 = 4104;
      v7 = 16;
      v22 = 1046;
      v23 = 1047;
LABEL_3:
      v8 = 21;
      break;
    default:
      a3 = 0;
      printf("%s: The uart%d is not supported!!!\n", "uart_send", v5);
      return a3;
  }
  while ( 1 )
  {
    v9 = dword_75C50;
    if ( a3 <= (unsigned __int8)(*(_DWORD *)(dword_75C50 + v6) >> v7) )
      break;
    usleep(0xBB8u);
    if ( !--v8 )
    {
      a3 = 0;
      pthread_mutex_unlock(mutex);
      printf("%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", a1);
      return a3;
    }
  }
  if ( *(int *)(dword_75C50 + 4 * v22) < 0 )
  {
    v11 = 21;
    while ( 1 )
    {
      usleep(0xBB8u);
      v9 = dword_75C50;
      if ( *(int *)(dword_75C50 + 4 * v22) >= 0 )
        break;
      if ( !--v11 )
      {
        a3 = 0;
        pthread_mutex_unlock(mutex);
        printf("%s: uart%d always busy, break\n", "uart_send", a1);
        return a3;
      }
    }
  }
  memcpy(s, a2, a3);
  v12 = a3 >> 2;
  if ( a3 >> 2 )
  {
    v13 = (unsigned __int8 *)s;
    do
    {
      v14 = *v13;
      v15 = v13[3];
      v16 = v13[2];
      v17 = v13[1] << 16;
      v13 += 4;
      *(_DWORD *)(v9 + 4 * v23) = v17 | (v14 << 24) | v15 | (v16 << 8);
      v9 = dword_75C50;
    }
    while ( v13 != (unsigned __int8 *)&s[v12] );
  }
  v18 = a3 & 3;
  if ( (a3 & 3) != 0 )
  {
    v19 = &s[v12 + 128];
    if ( v18 == 2 )
    {
      v20 = (*((unsigned __int8 *)v19 - 512) << 24) | (*((unsigned __int8 *)v19 - 511) << 16);
    }
    else if ( v18 == 3 )
    {
      v20 = (*((unsigned __int8 *)v19 - 510) << 8)
          | (*((unsigned __int8 *)v19 - 511) << 16)
          | (*((unsigned __int8 *)v19 - 512) << 24);
    }
    else
    {
      v20 = *((unsigned __int8 *)v19 - 512) << 24;
    }
    *(_DWORD *)(v9 + 4 * v23) = v20;
    v9 = dword_75C50;
  }
  *(_DWORD *)(v9 + 4 * v22) = a3 | 0x80000000;
  pthread_mutex_unlock(mutex);
  return a3;
}
// 3BFF8: control flows out of bounds to 3BFFC
// 3C0B0: variable 'v5' is possibly undefined
// 75C50: using guessed type int dword_75C50;
// 75CFC: using guessed type pthread_mutex_t stru_75CFC[10];

//----- (0003C2F4) --------------------------------------------------------
int __fastcall sub_3C2F4(int a1, _BYTE *a2, unsigned int a3)
{
  pthread_mutex_t *v6; // r5
  unsigned int v7; // r0
  int v8; // r4

  v6 = (pthread_mutex_t *)((char *)&unk_75DEC + 24 * a1);
  pthread_mutex_lock(v6);
  v7 = sub_3B9B4(a1);
  if ( v7 >= a3 )
  {
    v8 = sub_3BBA8(a1, a2, a3);
  }
  else if ( v7 )
  {
    v8 = sub_3BBA8(a1, a2, v7);
  }
  else
  {
    v8 = 0;
  }
  pthread_mutex_unlock(v6);
  return v8;
}

//----- (0003C378) --------------------------------------------------------
int __fastcall sub_3C378(int a1)
{
  int v2; // r4
  int result; // r0

  v2 = 22;
  do
  {
    result = 5000;
    if ( *(int *)(dword_75C50 + 48) < 0 )
    {
      *(_DWORD *)(dword_75C50 + 48) = a1;
      return result;
    }
    usleep(0x1388u);
    --v2;
  }
  while ( v2 );
  return printf("%s: i2c always busy, break\n", "i2c_write");
}
// 75C50: using guessed type int dword_75C50;

//----- (0003C3E8) --------------------------------------------------------
int __fastcall sub_3C3E8(int a1)
{
  int v1; // r4
  int v2; // r3

  sub_3C378(a1 | 0x2000000);
  v1 = 22;
  do
  {
    usleep(0x1388u);
    v2 = *(_DWORD *)(dword_75C50 + 48);
    if ( v2 < 0 )
      return (unsigned __int8)v2;
    --v1;
  }
  while ( v1 );
  printf("%s: i2c always busy, break\n", "i2c_read");
  return 255;
}
// 75C50: using guessed type int dword_75C50;

//----- (0003C460) --------------------------------------------------------
int __fastcall sub_3C460(int a1)
{
  return sub_3C378(a1 | (dword_75EDC << 16) | 0xA00000);
}
// 75EDC: using guessed type int dword_75EDC;

//----- (0003C478) --------------------------------------------------------
int sub_3C478()
{
  return sub_3C3E8((dword_75EDC << 16) | 0xA00000);
}
// 75EDC: using guessed type int dword_75EDC;

//----- (0003C490) --------------------------------------------------------
int __fastcall sub_3C490(char a1, char a2, int a3, int a4)
{
  char v4; // r8
  int v5; // r0
  int v6; // r1
  char v7; // r12
  unsigned int v8; // r12
  unsigned int v9; // r2
  _BYTE *v10; // r2
  __int16 v11; // t1
  int v12; // r7
  char *v13; // r3
  int v14; // r3
  unsigned __int8 v15; // r4
  int *v16; // r4
  int v18; // [sp+Ch] [bp-1024h] BYREF
  int v19; // [sp+10h] [bp-1020h]
  int v20; // [sp+14h] [bp-101Ch] BYREF
  int v21; // [sp+18h] [bp-1018h]
  int v22; // [sp+1Ch] [bp-1014h]
  char v23; // [sp+20h] [bp-1010h]
  _BYTE v24[15]; // [sp+21h] [bp-100Fh] BYREF
  char v25[4048]; // [sp+30h] [bp-1000h] BYREF
  _DWORD savedregs[8]; // [sp+1030h] [bp+0h] BYREF

  v4 = 2 * a1;
  v5 = 0;
  memset(&v24[3], 0, 12);
  v24[4] = a2;
  v6 = (int)savedregs;
  v20 = 0;
  v19 = 255;
  v24[0] = -86;
  v21 = 0;
  v23 = 85;
  if ( a4 > 0 )
    v6 = 0;
  v24[3] = v4;
  v24[2] = 50;
  v24[1] = a4 + 6;
  v22 = 0;
  if ( a4 > 0 )
  {
    do
    {
      v7 = *(_BYTE *)(a3 + v6);
      v6 = (unsigned __int8)(v6 + 1);
      v24[v5 + 5] = v7;
      v5 = v6;
    }
    while ( a4 > v6 );
  }
  if ( a4 >= -3 )
  {
    LOWORD(v8) = 0;
    v10 = v24;
    do
    {
      v11 = (unsigned __int8)*++v10;
      v8 = (unsigned __int16)(v8 + v11);
    }
    while ( v10 != &v24[a4 + 4] );
    v9 = v8 >> 8;
  }
  else
  {
    LOBYTE(v8) = 0;
    LOBYTE(v9) = 0;
  }
  v12 = (unsigned __int8)(a4 + 6) + 1;
  v13 = &v25[a4];
  *(v13 - 10) = v9;
  *(v13 - 9) = v8;
  pthread_mutex_lock(&stru_75EE0);
  v14 = 0;
  v15 = 0;
  do
  {
    sub_3C460((unsigned __int8)v24[v14 - 1]);
    v14 = ++v15;
  }
  while ( v15 <= v12 );
  v16 = (int *)((char *)&v18 + 3);
  usleep(0x30D40u);
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  do
  {
    *((_BYTE *)v16 + 1) = sub_3C478();
    v16 = (int *)((char *)v16 + 1);
  }
  while ( v16 != &v20 );
  pthread_mutex_unlock(&stru_75EE0);
  if ( BYTE1(v19) == 50 && BYTE2(v19) == 1 )
    return 0;
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
    return -1;
  snprintf(
    v25,
    0x1000u,
    "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n\n",
    "write_dc_dc",
    (unsigned __int8)v19,
    BYTE1(v19),
    BYTE2(v19),
    HIBYTE(v19));
  sub_385C8(5, v25, 0);
  return -1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0003C6E8) --------------------------------------------------------
int __fastcall sub_3C6E8(char a1, __int16 a2, int a3, int a4)
{
  unsigned __int8 v6; // r4
  int i; // r0
  int v8; // r5
  int v9; // r4
  int v11; // r2
  int v12; // r3
  _BYTE v13[4]; // [sp+14h] [bp-1020h]
  unsigned __int8 v14; // [sp+18h] [bp-101Ch]
  char v15; // [sp+19h] [bp-101Bh]
  char v16; // [sp+1Ah] [bp-101Ah]
  char v17; // [sp+1Bh] [bp-1019h]
  char v18; // [sp+1Ch] [bp-1018h]
  int v19; // [sp+20h] [bp-1014h]
  int v20; // [sp+24h] [bp-1010h]
  int v21; // [sp+28h] [bp-100Ch]
  int v22; // [sp+2Ch] [bp-1008h]
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  v15 = a2;
  v13[1] = -86;
  v13[3] = 50;
  v14 = (2 * a1) | 1;
  v16 = a4;
  v20 = 0;
  v21 = 0;
  v6 = 0;
  v13[2] = 7;
  v19 = 255;
  v17 = (unsigned __int16)((unsigned __int8)a4 + a2 + v14 + 57) >> 8;
  v18 = a4 + a2 + v14 + 57;
  v22 = 0;
  v13[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = (unsigned __int8)v13[v6] )
  {
    sub_3C460(i);
    if ( ++v6 == 9 )
      break;
  }
  v8 = 0;
  sub_2A884();
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if ( a4 + 4 < 0 )
  {
    pthread_mutex_unlock(&stru_75EE0);
    sleep(1u);
    goto LABEL_8;
  }
  LOBYTE(v9) = 0;
  do
  {
    v9 = (unsigned __int8)(v9 + 1);
    *((_BYTE *)&v19 + v8) = sub_3C478();
    v8 = v9;
  }
  while ( v9 <= a4 + 4 );
  v8 = BYTE1(v19);
  pthread_mutex_unlock(&stru_75EE0);
  sleep(1u);
  if ( v8 != 50 || BYTE2(v19) != 1 )
  {
LABEL_8:
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
      return -1;
    snprintf(
      s,
      0x1000u,
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
      "read_dc_dc",
      (unsigned __int8)v19,
      v8,
      BYTE2(v19),
      HIBYTE(v19));
    sub_385C8(5, s, 0);
    return -1;
  }
  if ( a4 > 0 )
  {
    v11 = 0;
    v12 = 0;
    do
    {
      *(_BYTE *)(a3 + v12) = *((_BYTE *)&v19 + v11 + 3);
      v12 = (unsigned __int8)(v12 + 1);
      v11 = v12;
    }
    while ( a4 > v12 );
  }
  return 0;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0003C92C) --------------------------------------------------------
int __fastcall sub_3C92C(_BYTE *a1, int a2)
{
  int v2; // r5
  int v3; // r3
  char v4; // r8
  int v5; // r9
  int v6; // r6
  char v7; // r7
  unsigned __int8 v8; // r12
  unsigned int v9; // r2
  int v10; // r4
  unsigned __int8 v11; // r8
  int v12; // r10
  int result; // r0

  if ( a2 )
  {
    v2 = 1;
    LOBYTE(v3) = 0;
    v4 = 1;
    v5 = 1;
    v6 = 1;
    v7 = 1;
    v8 = 0;
    v9 = 128;
    while ( 1 )
    {
      ++v8;
      v3 = (unsigned __int8)(v3 + 1);
      if ( ((unsigned __int8)v9 & *a1) != 0 )
        LOBYTE(v10) = v7 ^ 1;
      else
        LOBYTE(v10) = v7;
      v9 >>= 1;
      v10 = (unsigned __int8)v10;
      if ( v3 == 8 )
        ++a1;
      v11 = v4 ^ v10;
      if ( v3 == 8 )
      {
        LOBYTE(v3) = 0;
        v9 = 128;
      }
      v12 = v11;
      v7 = v6;
      v4 = v2;
      if ( v8 == a2 )
        break;
      v6 = v5;
      v2 = (unsigned __int8)v10;
      v5 = v12;
    }
    if ( !v6 )
    {
      result = 0;
      goto LABEL_15;
    }
  }
  else
  {
    v10 = 1;
    v2 = 1;
    v12 = 1;
    v5 = 1;
  }
  result = 16;
LABEL_15:
  if ( v5 )
    result = (unsigned __int8)result | 8;
  if ( v12 )
    result = (unsigned __int8)result | 4;
  if ( v2 )
    result = (unsigned __int8)result | 2;
  if ( v10 )
    return (unsigned __int8)result | 1;
  return result;
}

//----- (0003CA18) --------------------------------------------------------
int __fastcall sub_3CA18(int a1)
{
  char v2; // r0
  char v3; // r3
  char v4; // r3
  int v5; // r0
  int v7; // [sp+0h] [bp-8h] BYREF
  char v8; // [sp+4h] [bp-4h]

  v8 = 0;
  v7 = 1363;
  v2 = sub_3C92C(&v7, 32);
  v3 = v8;
  *(_BYTE *)a1 = 85;
  *(_BYTE *)(a1 + 1) = -86;
  v4 = v3 & 0xE0 | v2 & 0x1F;
  v5 = v7;
  *(_BYTE *)(a1 + 6) = v4;
  *(_DWORD *)(a1 + 2) = v5;
  return 7;
}

//----- (0003CA8C) --------------------------------------------------------
int __fastcall sub_3CA8C(int a1, char a2, char a3, char a4, unsigned int a5)
{
  char v6; // r0
  int v7; // r1
  __int16 v8; // r2
  char v9; // r3
  int v11; // [sp+Ch] [bp-10h] BYREF
  _BYTE v12[6]; // [sp+10h] [bp-Ch]
  char v13; // [sp+16h] [bp-6h]

  v12[0] = a3;
  v12[1] = a4;
  BYTE2(v11) = (16 * (a2 & 1)) | 0x41;
  LOWORD(v11) = -21931;
  HIBYTE(v11) = 9;
  *(_DWORD *)&v12[2] = bswap32(a5);
  v13 &= 0x1Fu;
  v6 = sub_3C92C((_BYTE *)&v11 + 2, 64);
  v13 = v13 & 0xE0 | v6 & 0x1F;
  v7 = *(_DWORD *)v12;
  v8 = *(_WORD *)&v12[4];
  v9 = v13;
  *(_DWORD *)a1 = v11;
  *(_DWORD *)(a1 + 4) = v7;
  *(_WORD *)(a1 + 8) = v8;
  *(_BYTE *)(a1 + 10) = v9;
  return 11;
}

//----- (0003CB3C) --------------------------------------------------------
int __fastcall sub_3CB3C(int a1, unsigned __int8 a2)
{
  char v3; // r0
  char v4; // r3
  char v5; // r3
  int v6; // r0
  int v8; // [sp+0h] [bp-8h] BYREF
  char v9; // [sp+4h] [bp-4h]

  HIWORD(v8) = a2;
  v9 = 0;
  LOWORD(v8) = 1344;
  v3 = sub_3C92C(&v8, 32);
  v4 = v9;
  *(_BYTE *)a1 = 85;
  *(_BYTE *)(a1 + 1) = -86;
  v5 = v4 & 0xE0 | v3 & 0x1F;
  v6 = v8;
  *(_BYTE *)(a1 + 6) = v5;
  *(_DWORD *)(a1 + 2) = v6;
  return 7;
}

//----- (0003CBB0) --------------------------------------------------------
int __fastcall sub_3CBB0(int a1, char a2, char a3, char a4)
{
  char v5; // r0
  int v6; // t1
  __int16 v7; // r3
  int v9; // [sp+0h] [bp-Ch] BYREF
  __int16 v10; // [sp+4h] [bp-8h]
  char v11; // [sp+6h] [bp-6h]

  LOBYTE(v10) = a3;
  HIBYTE(v10) = a4;
  BYTE2(v9) = (16 * (a2 & 1)) | 0x42;
  v11 &= 0x1Fu;
  LOWORD(v9) = -21931;
  HIBYTE(v9) = 5;
  v5 = sub_3C92C((_BYTE *)&v9 + 2, 32);
  v6 = v9;
  *(_BYTE *)(a1 + 6) = v11 & 0xE0 | v5 & 0x1F;
  v7 = v10;
  *(_DWORD *)a1 = v6;
  *(_WORD *)(a1 + 4) = v7;
  return 7;
}

//----- (0003CC84) --------------------------------------------------------
unsigned int __fastcall sub_3CC84(unsigned int result, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3; // r2
  int v4; // t1

  if ( a3 )
  {
    v3 = &a2[a3];
    do
    {
      v4 = *a2++;
      result = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v4 ^ (result >> 8)) + 424] ^ ((_WORD)result << 8));
    }
    while ( a2 != v3 );
  }
  return result;
}

//----- (0003CCC0) --------------------------------------------------------
int __fastcall sub_3CCC0(__int16 a1, __int16 a2)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  int v5; // r4
  int v6; // r5
  int result; // r0
  _BYTE v8[7]; // [sp+10h] [bp-1008h] BYREF
  char v9; // [sp+17h] [bp-1001h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v8[4] = a1;
  v8[1] = -86;
  v8[3] = 1;
  v9 = a2 + a1 + 7;
  v2 = v8;
  v8[5] = a2;
  v8[6] = (unsigned __int16)(a2 + a1 + 7) >> 8;
  v8[0] = 85;
  v8[2] = 6;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v2 == &v9 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x186A0u);
  v5 = sub_3C478();
  v6 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  if ( v5 == 1 && v6 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "set_PIC16F1704_flash_pointer_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_flash_pointer_new",
      dword_75EDC,
      v5,
      v6);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003CE6C) --------------------------------------------------------
int __fastcall sub_3CE6C(int a1)
{
  int v1; // r3
  __int16 v2; // r2
  __int16 v3; // r12
  int v4; // r1
  _DWORD *v5; // r3
  char v6; // t1
  _WORD *v7; // r4
  int v8; // t1
  int v9; // r4
  int v10; // r5
  int result; // r0
  _BYTE v12[17]; // [sp+Fh] [bp-1019h] BYREF
  int v13; // [sp+20h] [bp-1008h] BYREF
  __int16 v14; // [sp+24h] [bp-1004h] BYREF
  char s[4056]; // [sp+28h] [bp-1000h] BYREF

  v1 = 0;
  v2 = 22;
  memset(&v12[1], 0, 16);
  v13 = 0;
  v14 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a1 + v1++);
    v2 += v3;
  }
  while ( v1 != 16 );
  v4 = a1 - 1;
  v5 = &v12[4];
  *(_DWORD *)&v12[1] = 34908757;
  do
  {
    v6 = *(_BYTE *)++v4;
    *((_BYTE *)v5 + 1) = v6;
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v13 + 3) );
  LOBYTE(v14) = HIBYTE(v2);
  v7 = v12;
  HIBYTE(v14) = v2;
  pthread_mutex_lock(&stru_75EE0);
  do
  {
    v8 = *((unsigned __int8 *)v7 + 1);
    v7 = (_WORD *)((char *)v7 + 1);
    sub_3C460(v8);
  }
  while ( v7 != (__int16 *)((char *)&v14 + 1) );
  usleep(0x186A0u);
  v9 = sub_3C478();
  v10 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  if ( v9 == 2 && v10 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "send_data_to_PIC16F1704_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "send_data_to_PIC16F1704_new",
      dword_75EDC,
      v9,
      v10);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003D744) --------------------------------------------------------
int sub_3D744()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v7 = 8;
  v6[2] = 4;
  v6[3] = 4;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C478();
  v4 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( v3 == 4 && v4 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "erase_PIC16F1704_flash_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "erase_PIC16F1704_flash_new",
      dword_75EDC,
      v3,
      v4);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003D8E8) --------------------------------------------------------
int sub_3D8E8()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v6[2] = 4;
  v6[3] = 5;
  v7 = 9;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x30D40u);
  v3 = sub_3C478();
  v4 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( v3 == 5 && v4 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok\n\n", "write_data_into_PIC16F1704_flash_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_data_into_PIC16F1704_flash_new",
      dword_75EDC,
      v3,
      v4);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003DA90) --------------------------------------------------------
int sub_3DA90()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v6[2] = 4;
  v6[3] = 6;
  v7 = 10;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C478();
  v4 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep((__useconds_t)sub_493E0);
  if ( v3 == 6 && v4 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "jump_from_loader_to_app_PIC16F1704_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "jump_from_loader_to_app_PIC16F1704_new",
      dword_75EDC,
      v3,
      v4);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003DC38) --------------------------------------------------------
int sub_3DC38()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[5]; // [sp+10h] [bp-1008h] BYREF
  char v7; // [sp+15h] [bp-1003h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v0 = v6;
  v6[4] = 0;
  v6[1] = -86;
  v6[2] = 4;
  v6[3] = 7;
  v7 = 11;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == &v7 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C478();
  v4 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0xF4240u);
  if ( v3 == 7 && v4 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "reset_PIC16F1704_pic_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "reset_PIC16F1704_pic_new",
      dword_75EDC,
      v3,
      v4);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003E224) --------------------------------------------------------
int __fastcall sub_3E224(char a1, _WORD *a2)
{
  __int16 v4; // [sp+4h] [bp-8h] BYREF

  v4 = 0;
  sub_3C6E8(a1, 33, (int)&v4, 2);
  *a2 = (unsigned __int8)v4 | (HIBYTE(v4) << 8);
  return 0;
}

//----- (0003E264) --------------------------------------------------------
void __fastcall sub_3E264(int a1)
{
  int v1; // r4
  __int16 *v2; // r6
  char v3; // r0
  bool v4; // zf
  int v5; // r12
  unsigned __int16 v7; // [sp+16h] [bp-FEAh] BYREF
  char s[4072]; // [sp+18h] [bp-FE8h] BYREF

  v1 = 0;
  v2 = &word_75EF8[3 * a1 - 1];
  do
  {
    v3 = byte_73988[v1];
    v7 = 0;
    sub_3E224(v3, &v7);
    v4 = byte_77B70 == 0;
    v5 = v7;
    v2[1] = v7;
    ++v2;
    if ( !v4 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "chain %d asic = %d vol=%u\n", a1, v1, v5);
      sub_385C8(5, s, 0);
    }
    ++v1;
  }
  while ( v1 != 3 );
}
// 73504: using guessed type int dword_73504;
// 73988: using guessed type _BYTE byte_73988[3];
// 75C48: using guessed type char byte_75C48;
// 75EF8: using guessed type __int16 word_75EF8[];
// 77B70: using guessed type char byte_77B70;

//----- (0003E348) --------------------------------------------------------
int sub_3E348()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1
  int result; // r0

  v0 = 0;
  v1 = 631471;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = v0;
      sub_3E264(v0);
      result = pthread_mutex_unlock(&stru_75F10);
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 75EDC: using guessed type int dword_75EDC;

//----- (0003E3A0) --------------------------------------------------------
int __fastcall sub_3E3A0(char a1, unsigned int a2)
{
  int v3; // r7
  int v4; // r8
  int v5; // r12
  char v7; // [sp+Ch] [bp-1018h]
  unsigned int v8; // [sp+10h] [bp-1014h]
  int v9; // [sp+14h] [bp-1010h]
  char v10; // [sp+1Bh] [bp-1009h] BYREF
  _BYTE v11[2]; // [sp+1Ch] [bp-1008h] BYREF
  unsigned __int16 v12; // [sp+1Eh] [bp-1006h] BYREF
  char s[4064]; // [sp+20h] [bp-1004h] BYREF

  if ( a2 - 800 > 0x50 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      v3 = 840;
      snprintf(s, 0x1000u, "illegal voltage [%d, %d], set default voltage %d\n", 800, 880, 840);
      sub_385C8(5, s, 0);
      LOBYTE(v8) = 3;
      v9 = 844;
      v7 = 72;
    }
    else
    {
      v9 = 844;
      LOBYTE(v8) = 3;
      v7 = 72;
      v3 = 840;
    }
  }
  else
  {
    v3 = a2;
    v7 = a2;
    v8 = a2 >> 8;
    v9 = a2 + 4;
  }
  LOBYTE(v4) = 4;
  v12 = 0;
  while ( 1 )
  {
    v10 = -1;
    sub_3C490(a1, 0, (int)&v10, 1);
    sub_2A884();
    v11[1] = v8;
    v11[0] = v7;
    sub_3C490(a1, 33, (int)v11, 2);
    sub_2A884();
    sub_2A884();
    sub_3E224(a1, &v12);
    v5 = v12;
    if ( v12 <= v9 && v12 >= v3 - 4 )
      break;
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "set vol %d, get vol %d, set again!\n", v3, v12);
      sub_385C8(5, s, 0);
    }
    sub_2A884();
    v4 = (unsigned __int8)(v4 - 1);
    if ( !v4 )
      return v12;
  }
  return v5;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0003E610) --------------------------------------------------------
int __fastcall sub_3E610(char a1, int a2)
{
  char v2; // r5
  int v4; // r3
  int v6; // r6
  char v7; // [sp+Bh] [bp-1009h] BYREF
  char v8; // [sp+Ch] [bp-1008h] BYREF
  char v9; // [sp+Dh] [bp-1007h] BYREF
  unsigned __int16 v10; // [sp+Eh] [bp-1006h] BYREF
  char s[4080]; // [sp+10h] [bp-1004h] BYREF

  v2 = a2;
  if ( (unsigned int)(a2 - 800) <= 0x50 )
  {
    v7 = -1;
    sub_3C490(a1, 0, (int)&v7, 1);
    v8 = 26;
    sub_3C490(a1, 2, (int)&v8, 1);
    sub_2A884();
    v9 = 64;
    sub_3C490(a1, 1, (int)&v9, 1);
    sub_2A884();
    s[0] = v2;
    s[1] = 3;
    sub_3C490(a1, 33, (int)s, 2);
    sub_2A884();
    v9 = 0x80;
    sub_3C490(a1, 1, (int)&v9, 1);
    sub_2A884();
    LOBYTE(v6) = 5;
    v10 = 0;
    sub_2A884();
    sub_3E224(a1, &v10);
    while ( 1 )
    {
      v4 = v10;
      if ( v10 )
        break;
      sub_2A884();
      sub_3E224(a1, &v10);
      v6 = (unsigned __int8)(v6 - 1);
      if ( !v6 )
        return v10;
    }
  }
  else if ( byte_77B70 || (v4 = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "illegal voltage [%d, %d]\n", 800, 880);
    sub_385C8(5, s, 0);
    return 0;
  }
  return v4;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0003E820) --------------------------------------------------------
int __fastcall sub_3E820(int a1)
{
  __int16 *v1; // r6
  int i; // r4
  unsigned int v4; // r5
  unsigned int v5; // t1
  int v6; // lr
  int result; // r0
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  v1 = &word_75EF8[3 * a1 - 1];
  for ( i = 0; i != 3; ++i )
  {
    v5 = (unsigned __int16)v1[1];
    ++v1;
    v4 = v5;
    v6 = sub_3E3A0(byte_73988[i], v5);
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(
        s,
        0x1000u,
        "chain%d asic%d addr %02x, %s set vol %d, get vol %d",
        a1,
        i,
        (unsigned __int8)byte_73988[i],
        "every_asic_set_isl_voltage",
        v4,
        v6);
      sub_385C8(5, s, 0);
    }
    result = sub_2A884();
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 73988: using guessed type _BYTE byte_73988[3];
// 75C48: using guessed type char byte_75C48;
// 75EF8: using guessed type __int16 word_75EF8[];
// 77B70: using guessed type char byte_77B70;

//----- (0003E908) --------------------------------------------------------
int sub_3E908()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1
  int result; // r0

  v0 = 0;
  v1 = 631471;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = v0;
      sub_3E820(v0);
      sub_2A884();
      result = pthread_mutex_unlock(&stru_75F10);
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 75EDC: using guessed type int dword_75EDC;

//----- (0003E968) --------------------------------------------------------
int __fastcall sub_3E968(int a1, int a2, int a3)
{
  char v6; // r0
  unsigned __int16 v8; // [sp+6h] [bp-2h] BYREF

  pthread_mutex_lock(&stru_75F10);
  v8 = 0;
  v6 = *((_BYTE *)&unk_73908 + a2 + 128);
  dword_75EDC = a1;
  sub_3E224(v6, &v8);
  if ( v8 > a3 + 5 || v8 < a3 - 5 )
  {
    sub_3E3A0(*((_BYTE *)&unk_73908 + a2 + 128), (unsigned __int16)a3);
    sub_2A884();
  }
  return pthread_mutex_unlock(&stru_75F10);
}
// 75EDC: using guessed type int dword_75EDC;

//----- (0003E9FC) --------------------------------------------------------
unsigned int __fastcall sub_3E9FC(int a1)
{
  int v2; // r6
  int i; // r4
  int v4; // t1

  v2 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
    {
      sub_3E968(i, 0, a1);
      sub_3E968(i, 1, a1);
      sub_3E968(i, 2, a1);
    }
  }
  return sleep(1u);
}

//----- (0003EB90) --------------------------------------------------------
int __fastcall sub_3EB90(int a1)
{
  char *v1; // r4
  int i; // r0
  int v4; // t1
  int v5; // r4
  int v6; // r5
  int result; // r0
  _BYTE v8[6]; // [sp+10h] [bp-100Ch] BYREF
  char v9; // [sp+16h] [bp-1006h] BYREF
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v9 = a1 + 21;
  v8[3] = 16;
  v1 = v8;
  v8[5] = (unsigned __int16)(a1 + 21) >> 8;
  v8[4] = a1;
  v8[1] = -86;
  v8[0] = 85;
  v8[2] = 5;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v1 == &v9 )
      break;
    v4 = (unsigned __int8)*++v1;
  }
  usleep(0x30D40u);
  v5 = sub_3C478();
  v6 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( v5 == 16 && v6 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok, voltage = 0x%02x", "set_PIC16F1704_voltage_new", a1);
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_voltage_new",
      dword_75EDC,
      v5,
      v6);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003ED44) --------------------------------------------------------
int __fastcall sub_3ED44(int a1)
{
  int v1; // r3
  __int16 v2; // r2
  __int16 v3; // r12
  int v4; // r1
  _DWORD *v5; // r3
  char v6; // t1
  _WORD *v7; // r4
  int v8; // t1
  int v9; // r4
  int v10; // r5
  int result; // r0
  _BYTE v12[13]; // [sp+13h] [bp-1015h] BYREF
  int v13; // [sp+20h] [bp-1008h] BYREF
  __int16 v14; // [sp+24h] [bp-1004h] BYREF
  char s[4056]; // [sp+28h] [bp-1000h] BYREF

  v1 = 0;
  v2 = 34;
  memset(&v12[1], 0, 12);
  v13 = 0;
  v14 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a1 + v1++);
    v2 += v3;
  }
  while ( v1 != 12 );
  v4 = a1 - 1;
  v5 = &v12[4];
  *(_DWORD *)&v12[1] = 303082069;
  do
  {
    v6 = *(_BYTE *)++v4;
    *((_BYTE *)v5 + 1) = v6;
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v13 + 3) );
  LOBYTE(v14) = HIBYTE(v2);
  v7 = v12;
  HIBYTE(v14) = v2;
  pthread_mutex_lock(&stru_75EE0);
  do
  {
    v8 = *((unsigned __int8 *)v7 + 1);
    v7 = (_WORD *)((char *)v7 + 1);
    sub_3C460(v8);
  }
  while ( v7 != (__int16 *)((char *)&v14 + 1) );
  usleep(0x30D40u);
  v9 = sub_3C478();
  v10 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( v9 == 18 && v10 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "write_hash_ID_PIC16F1704_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_hash_ID_PIC16F1704_new",
      dword_75EDC,
      v9,
      v10);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003EF54) --------------------------------------------------------
int __fastcall sub_3EF54(int a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  char *v5; // r4
  int v6; // r5
  int result; // r0
  char v8; // r3
  int v9; // r6
  char *j; // r2
  char v11; // t1
  _BYTE v12[5]; // [sp+40h] [bp-1018h] BYREF
  char v13; // [sp+45h] [bp-1013h] BYREF
  char v14; // [sp+47h] [bp-1011h] BYREF
  int v15; // [sp+48h] [bp-1010h] BYREF
  int v16; // [sp+4Ch] [bp-100Ch]
  int v17; // [sp+50h] [bp-1008h]
  int v18; // [sp+54h] [bp-1004h] BYREF
  char s[4072]; // [sp+58h] [bp-1000h] BYREF

  v16 = 0;
  v15 = 255;
  v17 = 0;
  v18 = 0;
  v12[4] = 0;
  v12[1] = -86;
  v2 = v12;
  v12[2] = 4;
  v12[3] = 19;
  v13 = 23;
  v12[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v2 == &v13 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x30D40u);
  v5 = &v14;
  do
    *++v5 = sub_3C478();
  while ( v5 != (char *)&v18 + 3 );
  pthread_mutex_unlock(&stru_75EE0);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    v6 = BYTE1(v15);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\trea"
      "d_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_back_"
      "data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_data["
      "12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
      "read_hash_id_PIC16F1704_new",
      (unsigned __int8)v15,
      BYTE1(v15),
      BYTE2(v15),
      HIBYTE(v15),
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16),
      (unsigned __int8)v17,
      BYTE1(v17),
      BYTE2(v17),
      HIBYTE(v17),
      (unsigned __int8)v18,
      BYTE1(v18),
      BYTE2(v18),
      HIBYTE(v18));
    sub_385C8(5, s, 0);
    if ( v6 != 19 )
      goto LABEL_9;
  }
  else if ( BYTE1(v15) != 19 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v15 != 16 )
  {
LABEL_9:
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, aSChainDFailed_0, "read_hash_id_PIC16F1704_new", dword_75EDC);
    goto LABEL_13;
  }
  v8 = BYTE2(v15);
  if ( BYTE2(v18) != (unsigned __int16)(BYTE1(v18)
                                      + (unsigned __int8)v18
                                      + HIBYTE(v17)
                                      + BYTE2(v17)
                                      + BYTE1(v17)
                                      + (unsigned __int8)v17
                                      + HIBYTE(v16)
                                      + BYTE2(v16)
                                      + BYTE1(v16)
                                      + (unsigned __int8)v16
                                      + BYTE2(v15)
                                      + HIBYTE(v15)
                                      + 35) >> 8
    || HIBYTE(v18) != (unsigned __int8)(BYTE1(v18)
                                      + v18
                                      + HIBYTE(v17)
                                      + BYTE2(v17)
                                      + BYTE1(v17)
                                      + v17
                                      + HIBYTE(v16)
                                      + BYTE2(v16)
                                      + BYTE1(v16)
                                      + v16
                                      + BYTE2(v15)
                                      + HIBYTE(v15)
                                      + 35) )
  {
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(
      s,
      0x1000u,
      "%s failed! crc = 0x%04x",
      "read_hash_id_PIC16F1704_new",
      (unsigned __int16)(BYTE1(v18)
                       + (unsigned __int8)v18
                       + HIBYTE(v17)
                       + BYTE2(v17)
                       + BYTE1(v17)
                       + (unsigned __int8)v17
                       + HIBYTE(v16)
                       + BYTE2(v16)
                       + BYTE1(v16)
                       + (unsigned __int8)v16
                       + BYTE2(v15)
                       + HIBYTE(v15)
                       + 35));
LABEL_13:
    sub_385C8(3, s, 0);
    return 0;
  }
  v9 = a1 - 1;
  for ( j = (char *)&v15 + 2; ; ++j )
  {
    *(_BYTE *)++v9 = v8;
    if ( j == (char *)&v18 + 1 )
      break;
    v11 = j[1];
    v8 = v11;
  }
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok", "read_hash_id_PIC16F1704_new");
  sub_385C8(5, s, 0);
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003F304) --------------------------------------------------------
int sub_3F304()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[4]; // [sp+10h] [bp-1008h] BYREF
  __int16 v7; // [sp+14h] [bp-1004h]
  char v8; // [sp+16h] [bp-1002h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v7 = 1;
  v6[2] = 5;
  v6[3] = 21;
  v6[1] = -86;
  v0 = v6;
  v8 = 27;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == &v8 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C478();
  v4 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  if ( v3 == 21 && v4 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "enable_PIC16F1704_dc_dc_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "enable_PIC16F1704_dc_dc_new",
      dword_75EDC,
      v3,
      v4);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003F4AC) --------------------------------------------------------
int sub_3F4AC()
{
  char *v0; // r4
  int i; // r0
  int v2; // t1
  int v3; // r4
  int v4; // r5
  int result; // r0
  _BYTE v6[4]; // [sp+10h] [bp-1008h] BYREF
  __int16 v7; // [sp+14h] [bp-1004h]
  char v8; // [sp+16h] [bp-1002h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v6[0] = 85;
  v7 = 0;
  v6[2] = 5;
  v6[1] = -86;
  v6[3] = 21;
  v0 = v6;
  v8 = 26;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == &v8 )
      break;
    v2 = (unsigned __int8)*++v0;
  }
  usleep(0x186A0u);
  v3 = sub_3C478();
  v4 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  if ( v3 == 21 && v4 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "disable_PIC16F1704_dc_dc_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "disable_PIC16F1704_dc_dc_new",
      dword_75EDC,
      v3,
      v4);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003F64C) --------------------------------------------------------
int sub_3F64C()
{
  _WORD *v0; // r4
  int i; // r0
  int v2; // t1
  _WORD *v3; // r4
  int v4; // r4
  int result; // r0
  int v6; // [sp+14h] [bp-1014h] BYREF
  int v7; // [sp+18h] [bp-1010h]
  __int16 v8; // [sp+1Ch] [bp-100Ch] BYREF
  _BYTE v9[4]; // [sp+20h] [bp-1008h] BYREF
  __int16 v10; // [sp+24h] [bp-1004h] BYREF
  char s[4056]; // [sp+28h] [bp-1000h] BYREF

  v9[1] = -86;
  v7 = 255;
  v10 = 6656;
  v8 = 0;
  v9[2] = 4;
  v9[3] = 22;
  v0 = v9;
  v9[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v2 )
  {
    sub_3C460(i);
    if ( v0 == (__int16 *)((char *)&v10 + 1) )
      break;
    v2 = *((unsigned __int8 *)v0 + 1);
    v0 = (_WORD *)((char *)v0 + 1);
  }
  usleep(0x186A0u);
  v3 = (_WORD *)((char *)&v6 + 3);
  do
  {
    *((_BYTE *)v3 + 1) = sub_3C478();
    v3 = (_WORD *)((char *)v3 + 1);
  }
  while ( v3 != (__int16 *)((char *)&v8 + 1) );
  pthread_mutex_unlock(&stru_75EE0);
  v4 = BYTE1(v7);
  if ( BYTE1(v7) == 22 && (result = BYTE2(v7), BYTE2(v7) == 1) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "%s ok", "heart_beat_PIC16F1704_new");
      sub_385C8(7, s, 0);
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(s, 0x1000u, "%s chain %d failed!", "heart_beat_PIC16F1704_new", dword_75EDC);
    sub_385C8(3, s, 0);
    if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
    {
      v6 = HIBYTE(v8);
      snprintf(
        s,
        0x1000u,
        "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
        "heart_beat_PIC16F1704_new",
        (unsigned __int8)v7,
        v4,
        BYTE2(v7),
        HIBYTE(v7),
        (unsigned __int8)v8,
        v6);
      sub_385C8(3, s, 0);
      return 0;
    }
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003F8BC) --------------------------------------------------------
void __noreturn sub_3F8BC()
{
  int v0; // r5
  int i; // r4
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(v3, "pic_heart_beat_func_new");
    sub_385C8(5, v3, 0);
  }
  while ( 1 )
  {
    v0 = 631471;
    sleep(0xAu);
    for ( i = 0; i != 4; ++i )
    {
      if ( *(unsigned __int8 *)++v0 )
      {
        if ( byte_7398B )
        {
          pthread_mutex_lock(&stru_75F10);
          dword_75EDC = i;
          sub_3F64C();
          sub_2A884();
          pthread_mutex_unlock(&stru_75F10);
        }
      }
    }
  }
}
// 73504: using guessed type int dword_73504;
// 7398B: using guessed type char byte_7398B;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003F9B0) --------------------------------------------------------
int __fastcall sub_3F9B0(_BYTE *a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r5
  int v8; // r2
  unsigned int v9; // r3
  char v10; // [sp+17h] [bp-1015h] BYREF
  int v11; // [sp+18h] [bp-1014h]
  unsigned __int8 v12; // [sp+1Ch] [bp-1010h] BYREF
  _BYTE v13[5]; // [sp+20h] [bp-100Ch] BYREF
  char v14; // [sp+25h] [bp-1007h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  v13[1] = -86;
  v11 = 255;
  v13[4] = 0;
  v12 = 0;
  v2 = v13;
  v13[2] = 4;
  v13[3] = 23;
  v14 = 27;
  v13[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v2 == &v14 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep((__useconds_t)"-P");
  v5 = (unsigned __int8 *)&v10;
  do
    *++v5 = sub_3C478();
  while ( v5 != &v12 );
  pthread_mutex_unlock(&stru_75EE0);
  if ( byte_75C49 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
    {
      v6 = BYTE1(v11);
      snprintf(
        s,
        0x1000u,
        "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
        "_back_data[4] = 0x%x",
        "get_PIC16F1704_software_version_new",
        (unsigned __int8)v11,
        BYTE1(v11),
        BYTE2(v11),
        HIBYTE(v11),
        v12);
      sub_385C8(7, s, 0);
      if ( v6 != 23 )
        goto LABEL_9;
      goto LABEL_25;
    }
    v6 = BYTE1(v11);
  }
  else
  {
    v6 = BYTE1(v11);
  }
  if ( v6 != 23 )
  {
LABEL_9:
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
      return 0;
    snprintf(s, 0x1000u, "%s chain %d failed!", "get_PIC16F1704_software_version_new", dword_75EDC);
    sub_385C8(3, s, 0);
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
      return 0;
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_b"
      "ack_data[4] = 0x%x",
      "get_PIC16F1704_software_version_new",
      (unsigned __int8)v11,
      v6,
      BYTE2(v11),
      HIBYTE(v11),
      v12);
    goto LABEL_14;
  }
LABEL_25:
  if ( (unsigned __int8)v11 != 5 )
    goto LABEL_9;
  v8 = BYTE2(v11);
  v9 = BYTE2(v11) + 28;
  if ( HIBYTE(v11) != v9 >> 8 || v12 != (unsigned __int8)v9 )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
      return 0;
    snprintf(s, 0x1000u, "%s failed! crc = 0x%04x", "get_PIC16F1704_software_version_new", BYTE2(v11) + 28);
LABEL_14:
    sub_385C8(3, s, 0);
    return 0;
  }
  *a1 = BYTE2(v11);
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok, version = 0x%02x", "get_PIC16F1704_software_version_new", v8);
  sub_385C8(5, s, 0);
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (0003FD3C) --------------------------------------------------------
int __fastcall sub_3FD3C(_BYTE *a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r5
  int result; // r0
  int v8; // r2
  unsigned int v9; // r3
  char v10; // [sp+17h] [bp-1015h] BYREF
  int v11; // [sp+18h] [bp-1014h]
  unsigned __int8 v12; // [sp+1Ch] [bp-1010h] BYREF
  _BYTE v13[5]; // [sp+20h] [bp-100Ch] BYREF
  char v14; // [sp+25h] [bp-1007h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  v13[1] = -86;
  v11 = 255;
  v13[4] = 0;
  v12 = 0;
  v2 = v13;
  v13[2] = 4;
  v13[3] = 24;
  v14 = 28;
  v13[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v2 == &v14 )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x30D40u);
  v5 = (unsigned __int8 *)&v10;
  do
    *++v5 = sub_3C478();
  while ( v5 != &v12 );
  pthread_mutex_unlock(&stru_75EE0);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    v6 = BYTE1(v11);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_b"
      "ack_data[4] = 0x%x\n",
      "get_PIC16F1704_voltage_new",
      (unsigned __int8)v11,
      BYTE1(v11),
      BYTE2(v11),
      HIBYTE(v11),
      v12);
    sub_385C8(5, s, 0);
    if ( v6 != 24 )
      goto LABEL_9;
  }
  else if ( BYTE1(v11) != 24 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v11 != 5 )
  {
LABEL_9:
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "%s chain %d failed!", "get_PIC16F1704_voltage_new", dword_75EDC);
    goto LABEL_13;
  }
  v8 = BYTE2(v11);
  v9 = BYTE2(v11) + 29;
  if ( HIBYTE(v11) != v9 >> 8 || v12 != (unsigned __int8)v9 )
  {
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "%s failed! crc = 0x%04x", "get_PIC16F1704_voltage_new", BYTE2(v11) + 29);
LABEL_13:
    sub_385C8(3, s, 0);
    return 0;
  }
  *a1 = BYTE2(v11);
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok, voltage = 0x%02x", "get_PIC16F1704_voltage_new", v8);
  sub_385C8(5, s, 0);
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00040018) --------------------------------------------------------
int __fastcall sub_40018(int a1)
{
  int v1; // r3
  __int16 v2; // r2
  __int16 v3; // r12
  int v4; // r1
  _DWORD *v5; // r3
  char v6; // t1
  char *v7; // r4
  int v8; // t1
  int v9; // r4
  int v10; // r5
  int result; // r0
  char v12; // [sp+7h] [bp-1011h] BYREF
  _DWORD v13[2]; // [sp+8h] [bp-1010h] BYREF
  int v14; // [sp+10h] [bp-1008h] BYREF
  __int16 v15; // [sp+14h] [bp-1004h] BYREF
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v1 = 0;
  v2 = 46;
  v13[1] = 0;
  v13[0] = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    v3 = *(unsigned __int8 *)(a1 + v1++);
    v2 += v3;
  }
  while ( v1 != 8 );
  v4 = a1 - 1;
  v5 = (_DWORD *)((char *)v13 + 3);
  v13[0] = 571255381;
  do
  {
    v6 = *(_BYTE *)++v4;
    *((_BYTE *)v5 + 1) = v6;
    v5 = (_DWORD *)((char *)v5 + 1);
  }
  while ( v5 != (int *)((char *)&v14 + 3) );
  LOBYTE(v15) = HIBYTE(v2);
  v7 = &v12;
  HIBYTE(v15) = v2;
  pthread_mutex_lock(&stru_75EE0);
  do
  {
    v8 = (unsigned __int8)*++v7;
    sub_3C460(v8);
  }
  while ( v7 != (char *)&v15 + 1 );
  usleep(0x30D40u);
  v9 = sub_3C478();
  v10 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( v9 == 34 && v10 == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s ok", "write_temperature_offset_PIC16F1704_new");
      sub_385C8(5, s, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "write_temperature_offset_PIC16F1704_new",
      v9,
      v10);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00040214) --------------------------------------------------------
int __fastcall sub_40214(int a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  char *v5; // r4
  int v6; // r5
  int result; // r0
  char v8; // r3
  unsigned int v9; // r2
  int v10; // r6
  char *j; // r2
  char v12; // t1
  _BYTE v13[3]; // [sp+34h] [bp-1014h] BYREF
  char v14[4]; // [sp+37h] [bp-1011h] BYREF
  char v15; // [sp+3Bh] [bp-100Dh] BYREF
  int v16; // [sp+3Ch] [bp-100Ch] BYREF
  int v17; // [sp+40h] [bp-1008h]
  int v18; // [sp+44h] [bp-1004h] BYREF
  char s[4088]; // [sp+48h] [bp-1000h] BYREF

  v17 = 0;
  v18 = 0;
  v16 = 255;
  v14[2] = 39;
  v13[2] = 4;
  v13[1] = -86;
  v2 = v13;
  strcpy(v14, "#");
  v13[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v2 == &v14[2] )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep(0x30D40u);
  v5 = &v15;
  do
    *++v5 = sub_3C478();
  while ( v5 != (char *)&v18 + 3 );
  pthread_mutex_unlock(&stru_75EE0);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    v6 = BYTE1(v16);
    snprintf(
      s,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\tre"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
      "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
      "read_temperature_offset_PIC16F1704_new",
      (unsigned __int8)v16,
      BYTE1(v16),
      BYTE2(v16),
      HIBYTE(v16),
      (unsigned __int8)v17,
      BYTE1(v17),
      BYTE2(v17),
      HIBYTE(v17),
      (unsigned __int8)v18,
      BYTE1(v18),
      BYTE2(v18),
      HIBYTE(v18));
    sub_385C8(5, s, 0);
    if ( v6 != 35 )
      goto LABEL_9;
  }
  else if ( BYTE1(v16) != 35 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v16 != 12 )
  {
LABEL_9:
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "%s failed!", "read_temperature_offset_PIC16F1704_new");
    goto LABEL_13;
  }
  v8 = BYTE2(v16);
  v9 = BYTE1(v18)
     + (unsigned __int8)v18
     + HIBYTE(v17)
     + BYTE2(v17)
     + BYTE1(v17)
     + (unsigned __int8)v17
     + BYTE2(v16)
     + HIBYTE(v16)
     + 47;
  if ( BYTE2(v18) != v9 >> 8 || HIBYTE(v18) != (unsigned __int8)v9 )
  {
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(
      s,
      0x1000u,
      "%s failed! crc = 0x%04x",
      "read_temperature_offset_PIC16F1704_new",
      BYTE1(v18)
    + (unsigned __int8)v18
    + HIBYTE(v17)
    + BYTE2(v17)
    + BYTE1(v17)
    + (unsigned __int8)v17
    + BYTE2(v16)
    + HIBYTE(v16)
    + 47);
LABEL_13:
    sub_385C8(3, s, 0);
    return 0;
  }
  v10 = a1 - 1;
  for ( j = (char *)&v16 + 2; ; ++j )
  {
    *(_BYTE *)++v10 = v8;
    if ( j == (char *)&v18 + 1 )
      break;
    v12 = j[1];
    v8 = v12;
  }
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "%s ok", "read_temperature_offset_PIC16F1704_new");
  sub_385C8(5, s, 0);
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0004057C) --------------------------------------------------------
int sub_4057C()
{
  int v0; // r4
  int result; // r0
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  sub_3CCC0(6, 0);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash_new", 76);
    sub_385C8(5, s, 0);
  }
  v0 = 76;
  do
  {
    result = sub_3D744();
    --v0;
  }
  while ( v0 );
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00040624) --------------------------------------------------------
void sub_40624()
{
  FILE *v0; // r0
  FILE *v1; // r5
  _BYTE *v2; // r4
  __int16 v3; // r0
  int i; // r10
  int *v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int j; // r9
  char nptr[8]; // [sp+10h] [bp-23A4h] BYREF
  int v12; // [sp+18h] [bp-239Ch] BYREF
  int v13; // [sp+1Ch] [bp-2398h]
  int v14; // [sp+20h] [bp-2394h]
  int v15; // [sp+24h] [bp-2390h]
  char s[4056]; // [sp+28h] [bp-238Ch] BYREF
  _BYTE v17[5000]; // [sp+1028h] [bp-138Ch] BYREF

  memset(v17, 0, sizeof(v17));
  v13 = 0;
  nptr[0] = 0;
  v14 = 0;
  v12 = 0;
  v15 = 0;
  nptr[1] = 0;
  nptr[2] = 0;
  nptr[3] = 0;
  nptr[4] = 0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(s, "PIC1704_update_pic_app_program_new");
    sub_385C8(5, s, 0);
  }
  v0 = fopen("/sbin/pic.txt", "r");
  v1 = v0;
  if ( !v0 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(s, 0x1000u, "%s: open pic16f1704_app_new.txt failed\n", "PIC1704_update_pic_app_program_new");
      sub_385C8(3, s, 0);
    }
    return;
  }
  fseek(v0, 0, 0);
  memset(v17, 0, sizeof(v17));
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s: pic_flash_length = %d\n", "PIC1704_update_pic_app_program_new", 2432);
    sub_385C8(5, s, 0);
  }
  v2 = v17;
  do
  {
    fgets(nptr, 1023, v1);
    v3 = strtoul(nptr, 0, 16);
    v2[1] = v3;
    *v2 = HIBYTE(v3);
    v2 += 2;
  }
  while ( v2 != &v17[4864] );
  fclose(v1);
  if ( !sub_3DC38() )
  {
LABEL_11:
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(s, 0x1000u, "%s: reset pic error!\n\n", "PIC1704_update_pic_app_program_new");
LABEL_15:
      sub_385C8(3, s, 0);
      return;
    }
    return;
  }
  if ( sub_4057C() )
  {
    if ( !sub_3CCC0(6, 0) )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        snprintf(s, 0x1000u, "%s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program_new");
        goto LABEL_15;
      }
      return;
    }
    for ( i = 0; i != 304; ++i )
    {
      v5 = (int *)&v17[16 * i];
      v6 = *v5;
      v7 = v5[1];
      v8 = v5[2];
      v9 = v5[3];
      v12 = v6;
      v13 = v7;
      v14 = v8;
      v15 = v9;
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "send pic program time: %d", i);
        sub_385C8(5, s, 0);
      }
      for ( j = 0; j != 16; ++j )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(s, 0x1000u, "buf[%d] = 0x%02x", j, *((unsigned __int8 *)&v12 + j));
          sub_385C8(7, s, 0);
        }
      }
      sub_3CE6C((int)&v12);
      sub_3D8E8();
    }
    if ( sub_3DC38() )
      return;
    goto LABEL_11;
  }
  if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(s, 0x1000u, "%s: erase flash error!\n\n", "PIC1704_update_pic_app_program_new");
    goto LABEL_15;
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00040A98) --------------------------------------------------------
int sub_40A98()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v0 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "chain%d %s", i, "every_chain_reset_PIC16F1704_pic_new");
        sub_385C8(5, s, 0);
      }
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = i;
      sub_3DC38();
      sub_2A884();
      pthread_mutex_unlock(&stru_75F10);
    }
  }
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00040B80) --------------------------------------------------------
int sub_40B80()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  int v4; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v0 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "chain%d %s", i, "every_chain_jump_from_loader_to_app_PIC16F1704_new");
        sub_385C8(5, s, 0);
      }
      v4 = pthread_mutex_lock(&stru_75F10);
      dword_75EDC = i;
      sub_3DA90(v4);
      sub_2A884();
      pthread_mutex_unlock(&stru_75F10);
    }
  }
  return sub_2A884();
}
// 3DA90: using guessed type int __fastcall sub_3DA90(_DWORD);
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00040C68) --------------------------------------------------------
int sub_40C68()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char v4[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(v4, "every_chain_disable_PIC16F1704_dc_dc_new");
    sub_385C8(5, v4, 0);
  }
  v0 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = i;
      sub_3F4AC();
      sub_2A884();
      pthread_mutex_unlock(&stru_75F10);
    }
  }
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00040D4C) --------------------------------------------------------
int sub_40D4C()
{
  sub_40C68();
  sub_3A1EC();
  sub_2A884();
  sub_2A36C(dword_78E88);
  sub_2A36C(dword_79078);
  sub_2A36C(dword_78E84);
  return sub_2A36C(dword_78F54);
}
// 78E84: using guessed type int dword_78E84;
// 78E88: using guessed type int dword_78E88;
// 78F54: using guessed type int dword_78F54;
// 79078: using guessed type int dword_79078;

//----- (00040DA4) --------------------------------------------------------
void sub_40DA4()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char v3[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(v3, "every_chain_enable_PIC16F1704_dc_dc_new");
    sub_385C8(5, v3, 0);
  }
  v0 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = i;
      sub_3F304();
      sub_2A884();
      pthread_mutex_unlock(&stru_75F10);
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00040E7C) --------------------------------------------------------
int sub_40E7C()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9A2A0 = (int)calloc(1u, 0x40u);
  if ( !sub_2EFE4(dword_9A2A0, 0, (void *(*)(void *))sub_3F8BC, (void *)dword_9A2A0) )
    return pthread_detach(*(_DWORD *)(dword_9A2A0 + 12));
  if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(v1, 0x1000u, "%s: create thread error for pic_heart_beat_func", "send_heart_beat_to_every_chain");
    sub_385C8(3, v1, 0);
  }
  return -3;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 9A2A0: using guessed type int dword_9A2A0;

//----- (00040F40) --------------------------------------------------------
pthread_mutex_t *sub_40F40()
{
  int v0; // r5
  int v1; // r3
  bool v2; // r3
  unsigned int v3; // r4
  _BOOL4 v4; // r3
  pthread_mutex_t *result; // r0
  int v6; // r6
  int v7; // r4
  int v8; // [sp+Ch] [bp-1008h]
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(s, "check_whether_need_update_pic_program");
    sub_385C8(5, s, 0);
  }
  v0 = 0;
  v8 = 631471;
  do
  {
    v1 = *(unsigned __int8 *)++v8;
    if ( v1 != 1 )
      goto LABEL_6;
    pthread_mutex_lock(&stru_75F10);
    dword_75EDC = v0;
    sub_3DC38();
    sub_2A884();
    sub_3DA90();
    sub_2A884();
    v7 = sub_3F9B0(&byte_75F28[v0]);
    sub_2A884();
    pthread_mutex_unlock(&stru_75F10);
    if ( byte_75F28[v0] <= 0x80u )
      v2 = v7 == 1;
    else
LABEL_6:
      v2 = 0;
    v3 = 0;
    while ( 1 )
    {
      v4 = v3 <= 2 && v2;
      result = &stru_75F10;
      if ( !v4 )
        break;
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = v0;
      sub_40624();
      sub_2A884();
      sub_3DA90();
      sub_2A884();
      v3 = (unsigned __int8)(v3 + 1);
      v6 = sub_3F9B0(&byte_75F28[v0]);
      pthread_mutex_unlock(&stru_75F10);
      sub_2A884();
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "%s: Chain%d pic update for %d times", "check_whether_need_update_pic_program", v0, v3);
        sub_385C8(5, s, 0);
      }
      v2 = 1;
      if ( byte_75F28[v0] == 129 )
        v2 = v6 == 0;
    }
    ++v0;
  }
  while ( v0 != 4 );
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 75F28: using guessed type unsigned __int8[4];
// 77B70: using guessed type char byte_77B70;

//----- (00041158) --------------------------------------------------------
int __fastcall sub_41158(unsigned int a1)
{
  char *v1; // r4
  int i; // r0
  int v3; // t1
  int v4; // r4
  int v5; // r5
  int result; // r0
  _BYTE v7[7]; // [sp+8h] [bp-1008h] BYREF
  char v8; // [sp+Fh] [bp-1001h] BYREF
  char s[4080]; // [sp+10h] [bp-1000h] BYREF

  v7[5] = a1;
  v7[1] = -86;
  v7[3] = 36;
  v8 = BYTE1(a1) + a1 + 42;
  v7[4] = BYTE1(a1);
  v7[6] = (unsigned __int16)((a1 >> 8) + (unsigned __int8)a1 + 42) >> 8;
  v1 = v7;
  v7[0] = 85;
  v7[2] = 6;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v3 )
  {
    sub_3C460(i);
    if ( v1 == &v8 )
      break;
    v3 = (unsigned __int8)*++v1;
  }
  usleep((__useconds_t)sub_493E0);
  v4 = sub_3C478();
  v5 = sub_3C478();
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( v4 == 36 && v5 == 1 )
  {
    if ( byte_75C49 )
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 6 )
        return 1;
      snprintf(s, 0x1000u, "\n--- %s ok\n\n", "save_freq_PIC16F1704_new");
      sub_385C8(7, s, 0);
    }
    return 1;
  }
  else if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "save_freq_PIC16F1704_new",
      v4,
      v5);
    sub_385C8(3, s, 0);
    return 0;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (0004131C) --------------------------------------------------------
int __fastcall sub_4131C(_WORD *a1)
{
  char *v2; // r4
  int i; // r0
  int v4; // t1
  char *v5; // r4
  int v6; // r5
  int result; // r0
  unsigned int v8; // r3
  int v9; // r2
  char v10; // [sp+17h] [bp-1015h] BYREF
  int v11; // [sp+18h] [bp-1014h]
  __int16 v12; // [sp+1Ch] [bp-1010h] BYREF
  _BYTE v13[3]; // [sp+20h] [bp-100Ch] BYREF
  char v14[5]; // [sp+23h] [bp-1009h] BYREF
  char s[4056]; // [sp+28h] [bp-1004h] BYREF

  v13[1] = -86;
  v11 = 255;
  v12 = 0;
  v2 = v13;
  v13[2] = 4;
  strcpy(v14, "%");
  v14[2] = 41;
  v13[0] = 85;
  pthread_mutex_lock(&stru_75EE0);
  for ( i = 85; ; i = v4 )
  {
    sub_3C460(i);
    if ( v2 == &v14[2] )
      break;
    v4 = (unsigned __int8)*++v2;
  }
  usleep((__useconds_t)sub_493E0);
  v5 = &v10;
  do
    *++v5 = sub_3C478();
  while ( v5 != (char *)&v12 + 1 );
  pthread_mutex_unlock(&stru_75EE0);
  usleep(0x30D40u);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    v6 = BYTE1(v11);
    snprintf(
      s,
      0x1000u,
      "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
      "get_PIC16F1704_freq_new",
      (unsigned __int8)v11,
      BYTE1(v11),
      BYTE2(v11),
      HIBYTE(v11),
      (unsigned __int8)v12,
      HIBYTE(v12));
    sub_385C8(5, s, 0);
    if ( v6 != 37 )
      goto LABEL_9;
  }
  else if ( BYTE1(v11) != 37 )
  {
    goto LABEL_9;
  }
  if ( (unsigned __int8)v11 != 6 )
  {
LABEL_9:
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "\n--- %s failed!\n\n", "get_PIC16F1704_freq_new");
    goto LABEL_13;
  }
  v8 = BYTE2(v11) + HIBYTE(v11) + 43;
  if ( (unsigned __int8)v12 != v8 >> 8 || HIBYTE(v12) != (unsigned __int8)v8 )
  {
    if ( !byte_77B70 )
    {
      result = (unsigned __int8)byte_75C48;
      if ( !byte_75C48 && dword_73504 <= 2 )
        return result;
    }
    snprintf(s, 0x1000u, "\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq_new", BYTE2(v11) + HIBYTE(v11) + 43);
LABEL_13:
    sub_385C8(3, s, 0);
    return 0;
  }
  v9 = HIBYTE(v11) | (BYTE2(v11) << 8);
  *a1 = _byteswap_ushort(HIWORD(v11));
  if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
    return 1;
  snprintf(s, 0x1000u, "\n--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq_new", v9);
  sub_385C8(5, s, 0);
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00041828) --------------------------------------------------------
int __fastcall sub_41828(unsigned int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s %u", "set freq:", a1);
    sub_385C8(5, s, 0);
  }
  v2 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
    {
      pthread_mutex_lock(&stru_75F10);
      dword_75EDC = i;
      sub_41158(a1);
      sub_2A884();
      pthread_mutex_unlock(&stru_75F10);
    }
  }
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00041A88) --------------------------------------------------------
int sub_41A88()
{
  int v0; // r4
  char v2; // [sp+6h] [bp-2Eh] BYREF
  char v3; // [sp+7h] [bp-2Dh] BYREF
  _DWORD v4[2]; // [sp+8h] [bp-2Ch] BYREF
  _DWORD v5[2]; // [sp+10h] [bp-24h] BYREF
  _DWORD v6[3]; // [sp+18h] [bp-1Ch] BYREF
  _DWORD v7[4]; // [sp+24h] [bp-10h] BYREF

  v2 = 0;
  v0 = 0;
  v3 = 0;
  v6[0] = 218893066;
  v6[1] = 286265102;
  v6[2] = 353637138;
  memset(v7, 0, 12);
  v5[0] = 0;
  v5[1] = 0;
  v4[0] = 387323156;
  v4[1] = 454695192;
  sub_3DC38();
  sub_40624();
  sub_3DA90();
  sub_3F9B0(&v2);
  sub_3ED44((int)v6);
  sub_3EF54((int)v7);
  sub_40018((int)v4);
  sub_40214((int)v5);
  sub_3EB90(120);
  sub_3FD3C(&v3);
  sub_3F304();
  sub_3F304();
  sub_3F64C();
  usleep(0x1E8480u);
  sub_3F64C();
  usleep(0x1E8480u);
  sub_3F64C();
  usleep(0x1E8480u);
  do
  {
    printf("i = %d\n", v0++);
    usleep(0x1E8480u);
  }
  while ( v0 != 35 );
  sub_3F64C();
  usleep(0x1E8480u);
  sub_3F64C();
  usleep(0x1E8480u);
  sub_3F64C();
  return usleep(0x1E8480u);
}

//----- (00041BC0) --------------------------------------------------------
int __fastcall sub_41BC0(int a1, int a2)
{
  int result; // r0

  switch ( a2 % 8 )
  {
    case 0:
      result = *(_BYTE *)(a1 + a2 / 8) & 1;
      break;
    case 1:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 1) & 1;
      break;
    case 2:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 2) & 1;
      break;
    case 3:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 3) & 1;
      break;
    case 4:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 4) & 1;
      break;
    case 5:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 5) & 1;
      break;
    case 6:
      result = (*(unsigned __int8 *)(a1 + a2 / 8) >> 6) & 1;
      break;
    case 7:
      result = *(unsigned __int8 *)(a1 + a2 / 8) >> 7;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 41BDC: control flows out of bounds to 41BE0

//----- (00041CC8) --------------------------------------------------------
int __fastcall sub_41CC8(_BYTE *a1, int a2)
{
  int v2; // r2
  unsigned __int8 *v4; // r2
  char v5; // r1
  unsigned int v6; // r3
  int v7; // t1
  char v8[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( a2 == 146 )
  {
    v4 = a1 + 2;
    v5 = a1[2];
    v6 = 0xFFFF;
    *a1 = 85;
    a1[2] = v5 & 0x1F | 0x20;
    a1[1] = -86;
    do
    {
      v7 = *v4++;
      v6 = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v7 ^ (v6 >> 8)) + 424] ^ ((_WORD)v6 << 8));
    }
    while ( v4 != a1 + 144 );
    v2 = 146;
    *((_WORD *)a1 + 72) = (v6 >> 8) | ((_WORD)v6 << 8);
  }
  else if ( byte_77B70 || (v2 = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 3 )
  {
    snprintf(v8, 0x1000u, "%s len error\n", "bm1740_makeup_work");
    sub_385C8(4, v8, 0);
    return 0;
  }
  return v2;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00041DBC) --------------------------------------------------------
int __fastcall sub_41DBC(int *a1)
{
  pthread_t v2; // r0
  int v3; // r8
  int v4; // r4
  char *v5; // r3
  int v6; // r3
  int v7; // r1
  int v8; // r7
  int v9; // r11
  int v11; // [sp+10h] [bp-10BCh]
  int v12; // [sp+14h] [bp-10B8h]
  int *v13; // [sp+1Ch] [bp-10B0h]
  struct timeval v14; // [sp+24h] [bp-10A8h] BYREF
  struct timeval v15; // [sp+2Ch] [bp-10A0h] BYREF
  _BYTE v16[148]; // [sp+34h] [bp-1098h] BYREF
  char s[4088]; // [sp+C8h] [bp-1004h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *a1;
  v4 = *((unsigned __int8 *)a1 + 4);
  v13 = *(int **)(v3 + 630);
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "Start To Fill Work!ChainIndex:[%d]", v4);
    sub_385C8(7, s, 0);
  }
  v12 = 0;
  sub_2A7A4(&v14);
  sub_2A7A4(&v15);
LABEL_7:
  while ( 1 )
  {
    v5 = (char *)&dword_75C50 + v4;
    if ( *((_BYTE *)&dword_75C50 + v4 + 748) )
      return 0;
    while ( 1 )
    {
      if ( !v5[732] || byte_75F30 || byte_75C68 )
      {
        sub_2A884();
        goto LABEL_7;
      }
      sub_2A7A4(&v14);
      v6 = v14.tv_usec - v15.tv_usec + (v14.tv_usec - v15.tv_usec < 0 ? 0xF4000 : 0);
      if ( v14.tv_usec - v15.tv_usec < 0 )
        v6 += 576;
      v7 = v14.tv_sec - v15.tv_sec;
      if ( v14.tv_usec - v15.tv_usec < 0 )
        --v7;
      if ( !*((_BYTE *)&dword_75C50 + v4 + 4) && v6 + 1000000 * v7 < (unsigned int)dword_9A2B8 )
        break;
      sub_2A7A4(&v15);
      while ( 1 )
      {
        pthread_mutex_lock(&stru_75CE0);
        v8 = sub_2472C((int)v13, *v13);
        pthread_mutex_unlock(&stru_75CE0);
        if ( v8 )
          break;
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf(s, 0x1000u, "Work Error![%d]", v12);
          sub_385C8(3, s, 0);
        }
      }
      v9 = *(_DWORD *)(v8 + 1828) & 0x7F;
      *((_BYTE *)&dword_75C50 + v4 + 4) = 0;
      memset(v16, 0, 0x92u);
      v12 = (unsigned __int8)v9;
      v16[3] = v9;
      v16[2] = 32;
      memcpy(&v16[4], (const void *)(v8 + 224), 0x8Cu);
      v11 = v3 + 4 * (v9 + 28);
      sub_41CC8(v16, 146);
      pthread_mutex_lock(&stru_75CE0);
      if ( *(_DWORD *)(v11 + 6) )
      {
        sub_156B8(*(void ***)(v11 + 6));
        *(_WORD *)(v11 + 6) = 0;
        *(_WORD *)(v11 + 8) = 0;
      }
      *(_DWORD *)(v3 + 4 * (v9 + 28) + 6) = sub_1A598(v8, 0);
      pthread_mutex_unlock(&stru_75CE0);
      if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(s, 0x1000u, "ChainID[%d] Wirte Work. workid=%d", v4, v9);
        sub_385C8(7, s, 0);
      }
      sub_3BFB4(v4, v16, 0x92u);
      byte_75F31 = 1;
      sub_2A7A4((struct timeval *)&dword_75F34);
      sub_2A8AC();
      sub_156B8((void **)v8);
      v5 = (char *)&dword_75C50 + v4;
      if ( *((_BYTE *)&dword_75C50 + v4 + 748) )
        return 0;
    }
    sub_2A8AC();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C50: using guessed type int dword_75C50;
// 75C68: using guessed type char byte_75C68;
// 75F30: using guessed type char byte_75F30;
// 75F31: using guessed type char byte_75F31;
// 75F34: using guessed type int dword_75F34;
// 77B70: using guessed type char byte_77B70;
// 9A2B8: using guessed type int dword_9A2B8;

//----- (00042188) --------------------------------------------------------
size_t __fastcall sub_42188(unsigned __int8 a1)
{
  size_t v2; // r0
  int v4; // [sp+0h] [bp-8h] BYREF
  __int16 v5; // [sp+4h] [bp-4h]
  char v6; // [sp+6h] [bp-2h]

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v2 = sub_3CA18((int)&v4);
  return sub_3BFB4(a1, &v4, v2);
}

//----- (00042200) --------------------------------------------------------
int __fastcall sub_42200(int a1)
{
  unsigned __int8 v1; // r5
  int v2; // r8
  char v3; // r1
  int v4; // r5
  unsigned __int8 v5; // r1
  size_t v6; // r0
  int result; // r0
  int s; // [sp+10h] [bp-1000h] BYREF
  __int16 v9; // [sp+14h] [bp-FFCh]
  char v10; // [sp+16h] [bp-FFAh]

  v1 = a1;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(
      (char *)&s,
      0x1000u,
      "%s chainID%d asics %d addrInterval %d",
      "software_set_address_chain",
      a1,
      *((unsigned __int8 *)&unk_9A2A8 + a1 + 497),
      (unsigned __int8)byte_9A4C7);
    sub_385C8(5, (const char *)&s, 0);
  }
  v2 = v1;
  sub_42188(v1);
  sub_2A884();
  v3 = byte_9A4C7;
  v4 = 0;
  while ( 1 )
  {
    v5 = v4 * v3;
    s = 0;
    ++v4;
    v9 = 0;
    v10 = 0;
    v6 = sub_3CB3C((int)&s, v5);
    sub_3BFB4(v2, &s, v6);
    result = sub_2A884();
    if ( v4 == 3 )
      break;
    v3 = byte_9A4C7;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 9A4C7: using guessed type char byte_9A4C7;

//----- (00042318) --------------------------------------------------------
int sub_42318()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1

  v0 = 0;
  v1 = 631471;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
      sub_42200(v0);
    ++v0;
  }
  while ( v0 != 4 );
  return sub_2A884();
}

//----- (00042358) --------------------------------------------------------
int __fastcall sub_42358(int a1, unsigned int a2)
{
  _DWORD v5[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v6; // [sp+14h] [bp-1008h]
  char v7; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v5[1] = 0;
  v6 = 0;
  v5[0] = 0;
  v7 = 0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "chainid%d %s: core timeout = %08x", a1, "set_core_timeout_chain", a2);
    sub_385C8(5, s, 0);
  }
  dword_7398C = a2;
  sub_3CA8C((int)v5, 1, 0, 40, a2);
  sub_3BFB4(a1, v5, 0xBu);
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 7398C: using guessed type int dword_7398C;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00042454) --------------------------------------------------------
int __fastcall sub_42454(unsigned int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1

  v2 = 631471;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      sub_42358(i, a1);
  }
  return sub_2A884();
}

//----- (000424A0) --------------------------------------------------------
int __fastcall sub_424A0(int a1)
{
  int v2; // r4
  _DWORD v4[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v5; // [sp+14h] [bp-1008h]
  char v6; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v4[1] = 0;
  v4[0] = 0;
  v5 = 0;
  v2 = dword_73990 & 0xFFFF0FFF | 0x3000;
  v6 = 0;
  dword_73990 = v2;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "chainid%d %s: IO drive = %08x", a1, "set_io_drive_strength_chain", v2);
    sub_385C8(5, s, 0);
  }
  sub_3CA8C((int)v4, 1, 0, 48, v2);
  sub_3BFB4(a1, v4, 0xBu);
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 73990: using guessed type int dword_73990;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000425A4) --------------------------------------------------------
int sub_425A4()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1

  v0 = 0;
  v1 = 631471;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
      sub_424A0(v0);
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
  return sub_2A884();
}

//----- (000425E8) --------------------------------------------------------
int __fastcall sub_425E8(int a1, int a2)
{
  int v4; // r2
  int v5; // r12
  int v6; // lr
  _DWORD v8[2]; // [sp+Ch] [bp-100Ch] BYREF
  __int16 v9; // [sp+14h] [bp-1004h]
  char v10; // [sp+16h] [bp-1002h]
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v8[1] = 0;
  v8[0] = 0;
  v9 = 0;
  v10 = 0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "chainid%d %s freq=%d", a1, "set_frequency_chain", a2);
    sub_385C8(5, s, 0);
  }
  v4 = 0;
  while ( 1 )
  {
    v5 = *(_DWORD *)&aD_0[16 * v4];
    v6 = 16 * v4++;
    if ( a2 == v5 )
      break;
    if ( v4 == 100 )
    {
      v6 = 64;
      break;
    }
  }
  dword_73994 = *(_DWORD *)&aResetAllHashBo[v6 + 2132];
  sub_3CA8C((int)v8, 1, 0, 12, dword_73994);
  sub_3BFB4(a1, v8, 0xBu);
  *(_WORD *)((char *)&unk_9A2A8 + 2 * a1 + 561) = a2;
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 73994: using guessed type int dword_73994;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (0004273C) --------------------------------------------------------
int __fastcall sub_4273C(int a1, int a2, int a3)
{
  char v4; // r6
  int v6; // r3
  int v7; // r12
  int v8; // r2
  _DWORD v10[2]; // [sp+14h] [bp-100Ch] BYREF
  __int16 v11; // [sp+1Ch] [bp-1004h]
  char v12; // [sp+1Eh] [bp-1002h]
  char s[4064]; // [sp+20h] [bp-1000h] BYREF

  v4 = a2;
  v10[1] = 0;
  v10[0] = 0;
  v11 = 0;
  v12 = 0;
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "%s %d %d freq=%d\n", "set_freq_asic", a1, a2, a3);
    sub_385C8(7, s, 0);
  }
  v6 = 0;
  while ( 1 )
  {
    v7 = *(_DWORD *)&aD_0[16 * v6];
    v8 = 16 * v6++;
    if ( a3 == v7 )
      break;
    if ( v6 == 100 )
    {
      v8 = 64;
      break;
    }
  }
  sub_3CA8C((int)v10, 0, byte_9A4C7 * v4, 12, *(_DWORD *)&aResetAllHashBo[v8 + 2132]);
  sub_3BFB4(a1, v10, 0xBu);
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 9A4C7: using guessed type char byte_9A4C7;

//----- (00042894) --------------------------------------------------------
void __noreturn sub_42894()
{
  FILE *v0; // r0
  int v1; // r4
  unsigned __int8 *v2; // r11
  char *v3; // r12
  FILE *v4; // r10
  int v5; // t1
  int v6; // r5
  int *v7; // r7
  int v8; // r3
  FILE *v9; // r0
  char *v10; // r10
  int v11; // lr
  _DWORD *v12; // r0
  unsigned __int8 *v13; // r5
  _DWORD *v14; // r12
  int v15; // t1
  int v16; // r3
  int v17; // r1
  int v18; // r3
  int v19; // r1
  _DWORD *v20; // r3
  unsigned __int8 *v21; // r5
  int v22; // t1
  int v23; // r6
  char *v24; // lr
  int v25; // r5
  char *v26; // r11
  int v27; // t1
  int v28; // r6
  char *v29; // r7
  int v30; // t1
  unsigned int v31; // r12
  unsigned int v32; // r3
  const char *v33; // r2
  int j; // r3
  int v35; // r1
  int v36; // r3
  int v37; // r2
  int v38; // r5
  int v39; // r9
  int v40; // r3
  int v41; // r7
  _DWORD *v42; // r6
  int *v43; // r11
  int *v44; // r4
  int v46; // r3
  const char *v47; // r0
  int v48; // r1
  const char *v49; // r2
  int v50; // r12
  int i; // r3
  int v52; // r12
  int v53; // r3
  int v54; // r2
  int v55; // r2
  char *v56; // [sp+1Ch] [bp-1080h]
  int v57; // [sp+1Ch] [bp-1080h]
  unsigned __int8 *v58; // [sp+20h] [bp-107Ch]
  int v59; // [sp+34h] [bp-1068h] BYREF
  _DWORD v60[12]; // [sp+38h] [bp-1064h] BYREF
  _DWORD v61[12]; // [sp+68h] [bp-1034h] BYREF
  char s[4072]; // [sp+98h] [bp-1004h] BYREF

  v0 = fopen("/config/chips_freq.config", "r");
  if ( v0 )
  {
    v1 = 0;
    v2 = (unsigned __int8 *)&unk_9A2AF;
    v3 = (char *)&unk_78F58;
    v4 = v0;
    do
    {
      while ( 1 )
      {
        v5 = *++v2;
        if ( v5 == 1 )
          break;
        if ( ++v1 == 4 )
          goto LABEL_10;
      }
      v6 = 0;
      v7 = (int *)&v3[12 * v1 + 192];
      do
      {
        ++v6;
        v59 = 0;
        v56 = v3;
        fscanf(v4, "%d", &v59);
        v8 = v59;
        if ( (unsigned int)(v59 - 650) >= 0x65 )
          v8 = 681;
        *v7++ = v8;
        v3 = v56;
      }
      while ( v6 != 3 );
      ++v1;
    }
    while ( v1 != 4 );
LABEL_10:
    v9 = v4;
    v10 = v3;
    fclose(v9);
    v11 = 0;
    v12 = v61;
    memset(v60, 0, sizeof(v60));
    v13 = (unsigned __int8 *)&unk_9A2AF;
    v14 = &unk_78F58;
    memset(v61, 0, sizeof(v61));
    do
    {
      v15 = *++v13;
      if ( v15 == 1 )
      {
        v16 = v14[49];
        v17 = v14[48];
        *v12 = 681;
        LOWORD(v17) = v17 + v16;
        v18 = v14[50];
        v12[1] = 681;
        v12[2] = 681;
        *(_WORD *)((char *)&unk_9A2A8 + 2 * v11 + 561) = (__int16)(v17 + v18) / 3;
      }
      ++v11;
      v12 += 3;
      v14 += 3;
    }
    while ( v11 != 4 );
    while ( !byte_75F2C )
LABEL_49:
      sub_2A884();
    while ( 1 )
    {
      v38 = 0;
      v39 = 0;
      v58 = (unsigned __int8 *)&unk_9A2AF;
      do
      {
        v40 = *++v58;
        if ( v40 == 1 )
        {
          v41 = 0;
          v42 = &v60[3 * v38];
          v43 = (int *)&v10[12 * v38 + 192];
          v44 = &v61[3 * v38];
          do
          {
            if ( *v42++ )
            {
              ++v39;
            }
            else
            {
              v46 = *v43;
              if ( (unsigned int)*v43 <= 0x2A8 )
              {
                v55 = *v43;
                *v44 = v46;
                sub_4273C((unsigned __int8)v38, (unsigned __int8)v41, v55);
                *(v42 - 1) = 1;
              }
              else if ( v46 == 681 )
              {
                *(v42 - 1) = 1;
              }
              else
              {
                v47 = "d";
                v48 = 1;
                v49 = "d";
                do
                {
                  v50 = *((_DWORD *)v49 + 4);
                  v49 += 16;
                  if ( v46 == v50 )
                    goto LABEL_59;
                  ++v48;
                }
                while ( v48 != 100 );
                v48 = -1;
LABEL_59:
                if ( *v44 == 100 )
                {
                  i = 0;
                }
                else
                {
                  for ( i = 1; i != 100; ++i )
                  {
                    v52 = *((_DWORD *)v47 + 4);
                    v47 += 16;
                    if ( *v44 == v52 )
                      goto LABEL_63;
                  }
                  i = -1;
                }
LABEL_63:
                if ( v48 - i <= 1 )
                  v53 = i + 1;
                else
                  v53 = i + 2;
                v54 = *(_DWORD *)&aResetAllHashBo[16 * v53 + 2120];
                *v44 = v54;
                v57 = v54;
                sub_4273C((unsigned __int8)v38, (unsigned __int8)v41, v54);
                if ( v57 == *v43 )
                  *(v42 - 1) = 1;
              }
            }
            ++v41;
            ++v44;
            ++v43;
          }
          while ( v41 != 3 );
        }
        ++v38;
      }
      while ( v38 != 4 );
      if ( 3 * (unsigned __int8)byte_9A49F <= v39 )
        break;
      sleep(3u);
      if ( !byte_75F2C )
        goto LABEL_49;
    }
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      strcpy(s, "All asics arrive target freq\n");
      sub_385C8(5, s, 0);
    }
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "open %s failed\n", "/config/chips_freq.config");
    sub_385C8(5, s, 0);
    v10 = (char *)&unk_78F58;
  }
  else
  {
    v10 = (char *)&unk_78F58;
  }
  v19 = 0;
  v20 = &unk_78F58;
  v21 = (unsigned __int8 *)&unk_9A2AF;
  do
  {
    while ( 1 )
    {
      v22 = *++v21;
      if ( v22 == 1 )
        break;
      ++v19;
      v20 += 3;
      if ( v19 == 4 )
        goto LABEL_22;
    }
    v23 = 3 * v19++;
    v24 = &v10[4 * v23];
    *(_DWORD *)v24 = 0;
    *((_DWORD *)v24 + 12) = 0;
    *((_DWORD *)v24 + 36) = 731;
    *((_DWORD *)v24 + 24) = 650;
    v20[1] = 0;
    v20[13] = 0;
    v20[37] = 731;
    v20[25] = 650;
    v20[2] = 0;
    v20[14] = 0;
    v20[38] = 731;
    v20[26] = 650;
    v20 += 3;
  }
  while ( v19 != 4 );
  while ( 1 )
  {
    do
    {
LABEL_22:
      sleep(1u);
      pthread_mutex_lock(&stru_75F40);
      pthread_cond_wait(&stru_78EA0, &stru_75F40);
      pthread_mutex_unlock(&stru_75F40);
      v25 = (unsigned __int8)byte_75C7C;
    }
    while ( byte_75C7C );
    v26 = &byte_9A2B0;
    if ( byte_9A2B0 == 1 )
    {
LABEL_26:
      v28 = 0;
      v29 = &v10[12 * v25 + 48];
      if ( *(_DWORD *)v29 == 1 )
      {
LABEL_29:
        v31 = *((_DWORD *)v29 + 36);
        v32 = *((_DWORD *)v29 + 12);
        if ( v31 > v32 )
        {
          if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
          {
            snprintf(
              s,
              0x1000u,
              "low freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
              v25,
              v28,
              v31,
              v32,
              *((_DWORD *)v29 + 24),
              *((_DWORD *)v29 - 12),
              1);
            sub_385C8(5, s, 0);
            v31 = *((_DWORD *)v29 + 36);
          }
          if ( v31 == 100 )
          {
            v36 = -1;
          }
          else
          {
            v33 = "d";
            for ( j = 1; j != 100; ++j )
            {
              v35 = *((_DWORD *)v33 + 4);
              v33 += 16;
              if ( v35 == v31 )
              {
                v36 = j - 1;
                goto LABEL_39;
              }
            }
            v36 = -2;
          }
LABEL_39:
          v37 = *(_DWORD *)&aResetAllHashBo[16 * v36 + 2120];
          *((_DWORD *)v29 + 36) = v37;
          sub_4273C((unsigned __int8)v25, (unsigned __int8)v28, v37);
        }
      }
      while ( ++v28 != 3 )
      {
        v30 = *((_DWORD *)v29 + 1);
        v29 += 4;
        if ( v30 == 1 )
          goto LABEL_29;
      }
    }
    while ( ++v25 != 4 )
    {
      v27 = (unsigned __int8)*++v26;
      if ( v27 == 1 )
        goto LABEL_26;
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C7C: using guessed type char byte_75C7C;
// 75F2C: using guessed type char byte_75F2C;
// 77B70: using guessed type char byte_77B70;
// 9A2B0: using guessed type char byte_9A2B0;
// 9A49F: using guessed type char byte_9A49F;

//----- (00042FD8) --------------------------------------------------------
void __noreturn sub_42FD8()
{
  int v0; // r1
  char *v1; // r2
  int v2; // t1
  int v3; // r5
  char *v4; // r9
  int v5; // t1
  int v6; // r6
  unsigned int v7; // r3
  unsigned int *v8; // r4
  unsigned int v9; // t1
  unsigned int v10; // r12
  unsigned int v11; // r1
  const char *v12; // r2
  int i; // r3
  int v14; // r1
  int v15; // r3
  int v16; // r2
  int v17; // r0
  char *v18; // r3
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  v0 = 631471;
  v1 = (char *)&unk_78F58;
  do
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      v17 = 0;
      do
      {
        *(_DWORD *)&v1[v17] = 0;
        v18 = &v1[v17];
        v17 += 4;
        *((_DWORD *)v18 + 12) = 0;
        *((_DWORD *)v18 + 48) = 681;
        *((_DWORD *)v18 + 36) = 731;
        *((_DWORD *)v18 + 24) = 650;
      }
      while ( v17 != 12 );
    }
    v1 += 12;
  }
  while ( v0 != 631475 );
  while ( 1 )
  {
    do
    {
      sleep(1u);
      pthread_mutex_lock(&stru_75F40);
      pthread_cond_wait(&stru_78EA0, &stru_75F40);
      pthread_mutex_unlock(&stru_75F40);
      v3 = (unsigned __int8)byte_75C7C;
    }
    while ( byte_75C7C );
    v4 = &byte_9A2B0;
    if ( byte_9A2B0 == 1 )
      goto LABEL_8;
    while ( ++v3 != 4 )
    {
      v5 = (unsigned __int8)*++v4;
      if ( v5 == 1 )
      {
LABEL_8:
        v6 = 0;
        v8 = (unsigned int *)((char *)&unk_78F58 + 12 * v3);
        v7 = *v8;
        if ( *v8 <= 0xA )
          goto LABEL_9;
        while ( 2 )
        {
          v10 = v8[48];
          v11 = v8[24];
          if ( v10 > v11 )
          {
            if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
            {
              snprintf(
                s,
                0x1000u,
                "low freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
                v3,
                v6,
                v10,
                v11,
                v8[36],
                v7,
                v8[12]);
              sub_385C8(5, s, 0);
              v10 = v8[48];
            }
            if ( v10 == 100 )
            {
              v15 = -1;
            }
            else
            {
              v12 = "d";
              for ( i = 1; i != 100; ++i )
              {
                v14 = *((_DWORD *)v12 + 4);
                v12 += 16;
                if ( v14 == v10 )
                {
                  v15 = i - 1;
                  goto LABEL_22;
                }
              }
              v15 = -2;
            }
LABEL_22:
            v16 = *(_DWORD *)&aResetAllHashBo[16 * v15 + 2120];
            v8[48] = v16;
            sub_4273C((unsigned __int8)v3, (unsigned __int8)v6, v16);
          }
LABEL_10:
          if ( ++v6 != 3 )
          {
            v9 = v8[1];
            ++v8;
            v7 = v9;
            if ( v9 > 0xA )
              continue;
LABEL_9:
            if ( v8[12] != 1 )
              goto LABEL_10;
            continue;
          }
          break;
        }
      }
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C7C: using guessed type char byte_75C7C;
// 77B70: using guessed type char byte_77B70;
// 9A2B0: using guessed type char byte_9A2B0;

//----- (00043204) --------------------------------------------------------
int __fastcall sub_43204(int a1)
{
  int v2; // r5
  int i; // r4
  int v4; // t1

  v2 = 631471;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      sub_425E8(i, a1);
  }
  return sub_2A884();
}

//----- (00043250) --------------------------------------------------------
int __fastcall sub_43250(int a1, char a2)
{
  _DWORD v4[2]; // [sp+Ch] [bp-10h] BYREF
  __int16 v5; // [sp+14h] [bp-8h]
  char v6; // [sp+16h] [bp-6h]

  dword_73998 = dword_73998 & 0xFFFFE0FF | ((a2 & 0x1F) << 8);
  v4[0] = 0;
  v4[1] = 0;
  v5 = 0;
  v6 = 0;
  sub_3CA8C((int)v4, 1, 0, 28, dword_73998);
  sub_3BFB4(a1, v4, 0xBu);
  return sub_2A884();
}
// 73998: using guessed type int dword_73998;

//----- (000432BC) --------------------------------------------------------
int __fastcall sub_432BC(int a1)
{
  int v1; // r6
  char v2; // r7
  int v3; // r5
  int i; // r4
  int v5; // t1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = (unsigned __int8)a1;
  v2 = a1;
  byte_9A4C9 = a1;
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "%s: bt8d = %d", "set_baud", a1);
    sub_385C8(7, s, 0);
  }
  v3 = 631471;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v5 = *(unsigned __int8 *)++v3;
    if ( v5 == 1 )
      sub_43250(i, v2);
  }
  sleep(1u);
  sub_3B998(v1);
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 9A4C9: using guessed type char byte_9A4C9;

//----- (000433BC) --------------------------------------------------------
int __fastcall sub_433BC(int a1, int a2)
{
  unsigned __int8 v3; // r5
  _DWORD v5[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v6; // [sp+14h] [bp-1008h]
  char v7; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v3 = a2;
  v5[1] = 0;
  v5[0] = 0;
  v6 = 0;
  v7 = 0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s chainID%d ticket_mask = 0x%08x", "set_ticket_mask_chain", a1, a2);
    sub_385C8(5, s, 0);
  }
  dword_7399C = v3;
  sub_3CA8C((int)v5, 1, 0, 20, v3);
  sub_3BFB4(a1, v5, 0xBu);
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 7399C: using guessed type int dword_7399C;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000434BC) --------------------------------------------------------
int __fastcall sub_434BC(int result)
{
  int v1; // r6
  int v2; // r5
  int i; // r4
  int v4; // t1

  v1 = result;
  v2 = 631471;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v4 = *(unsigned __int8 *)++v2;
    if ( v4 == 1 )
      result = sub_433BC(i, v1);
  }
  return result;
}

//----- (00043500) --------------------------------------------------------
int __fastcall sub_43500(int a1, int a2, int a3)
{
  char v4; // r7
  char v5; // r6
  _DWORD v7[2]; // [sp+14h] [bp-1010h] BYREF
  __int16 v8; // [sp+1Ch] [bp-1008h]
  char v9; // [sp+1Eh] [bp-1006h]
  char s[4064]; // [sp+20h] [bp-1004h] BYREF

  v7[1] = 0;
  v8 = 0;
  v4 = a2;
  v5 = a3;
  v7[0] = 0;
  v9 = 0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "chainID%d %s txndata %d txnzero %d", a1, "set_txn_data_chain", a2, a3);
    sub_385C8(5, s, 0);
  }
  dword_739A0 = (2 * (v4 & 1)) | v5 & 1;
  sub_3CA8C((int)v7, 1, 0, 88, dword_739A0);
  sub_3BFB4(a1, v7, 0xBu);
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 739A0: using guessed type int dword_739A0;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00043614) --------------------------------------------------------
int __fastcall sub_43614(int result, int a2)
{
  int v2; // r7
  int v3; // r5
  int i; // r4
  int v6; // t1

  v2 = result;
  v3 = 631471;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v6 = *(unsigned __int8 *)++v3;
    if ( v6 == 1 )
      result = sub_43500(i, v2, a2);
  }
  return result;
}

//----- (00043660) --------------------------------------------------------
unsigned int __fastcall sub_43660(unsigned int a1)
{
  return a1 >> 7;
}

//----- (00043668) --------------------------------------------------------
void sub_43668()
{
  int v0; // r8
  int i; // r7
  int v3; // r4
  int v4; // r6
  unsigned int v5; // r4
  int v6; // r10
  int v7; // r12
  int v8; // r12
  int v9; // r3
  int v10; // r2
  int v11; // [sp+8h] [bp-100Ch]
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  v0 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    if ( *(unsigned __int8 *)++v0 )
    {
      v3 = *(unsigned __int8 *)(v0 + 489);
      if ( *(_BYTE *)(v0 + 489) )
      {
        v4 = 0;
        v5 = 0;
        v11 = 8 * i;
        v6 = 19 * i + 631464;
        do
        {
          if ( (v5 & 7) == 0 )
          {
            v7 = v5 + v4;
            if ( (int)(v5 + v4) > 19 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
            {
              snprintf(s, 0x1000u, "offset[%d] ERR", v5 + v4);
              sub_385C8(3, s, 0);
              v7 = v5 + v4;
            }
            v4 = (unsigned __int8)(v4 + 1);
            *(_BYTE *)(v6 + v7 + 323) = 32;
          }
          v8 = v5 + v4;
          if ( (int)(v5 + v4) > 19 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
          {
            snprintf(s, 0x1000u, "offset[%d] ERR", v5 + v4);
            sub_385C8(3, s, 0);
            v8 = v5 + v4;
          }
          *(_BYTE *)(v6 + v8 + 323) = 111;
          v9 = 4 * (3 * i + v5 + 56) + 631464;
          v5 = (unsigned __int8)(v5 + 1);
          v10 = *(_DWORD *)(v9 + 4);
          *(_BYTE *)(v9 + 3) = 0;
          *(_DWORD *)(v9 + 4) = v10 & 0xFF000000;
        }
        while ( *(unsigned __int8 *)(v0 + 489) > v5 );
        v3 = v5 + v4;
        if ( v3 > 19 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(s, 0x1000u, "offset[%d] ERR", v3);
          sub_385C8(3, s, 0);
        }
      }
      else
      {
        v11 = 8 * i;
      }
      *((_BYTE *)&unk_9A2A8 + 2 * v11 + 2 * i + i + v3 + 323) = 0;
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000439A0) --------------------------------------------------------
int __fastcall sub_439A0(int result, int a2)
{
  int v2; // r4
  int v4; // r3
  int v5; // r7
  int v6; // [sp+8h] [bp-100Ch] BYREF
  char v7; // [sp+Ch] [bp-1008h]
  char s[4080]; // [sp+10h] [bp-1004h] BYREF

  v2 = result;
  if ( *((_BYTE *)&unk_9A2A8 + result + 8) )
  {
    v4 = (unsigned __int8)byte_77B70;
    dword_78E8C[result] = result;
    if ( v4 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s chainid = %d", "tty_init_chain", result);
      sub_385C8(5, s, 0);
    }
    *((_BYTE *)&dword_75C50 + v2 + 776) = 1;
    if ( sub_2EFE4(a2 + (v2 << 6) + 890, 0, (void *(*)(void *))sub_49DEC, &dword_78E8C[v2]) )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
      {
        snprintf(s, 0x1000u, "create rx read thread for chain %d failed", v2);
        goto LABEL_11;
      }
    }
    else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(s, 0x1000u, "create rx read thread for chain %d ok", v2);
LABEL_11:
      sub_385C8(3, s, 0);
    }
    sub_2A884();
    v6 = a2;
    v7 = v2;
    v5 = sub_2EFE4(a2 + (v2 << 6) + 634, 0, (void *(*)(void *))sub_41DBC, &v6);
    sub_2A884();
    if ( v5 )
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
        goto LABEL_22;
      snprintf(s, 0x1000u, "create tx read thread for chain %d failed", v2);
    }
    else
    {
      if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 2 )
        goto LABEL_22;
      snprintf(s, 0x1000u, "create tx read thread for chain %d ok", v2);
    }
    sub_385C8(3, s, 0);
    if ( byte_77B70 || byte_75C48 )
    {
LABEL_19:
      strcpy(s, "open device over");
      sub_385C8(5, s, 0);
      return sub_2A884();
    }
LABEL_22:
    if ( dword_73504 <= 4 )
      return sub_2A884();
    goto LABEL_19;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50;
// 77B70: using guessed type char byte_77B70;
// 78E8C: using guessed type _DWORD dword_78E8C[5];

//----- (00043C74) --------------------------------------------------------
int __fastcall sub_43C74(int a1)
{
  int v2; // r4
  int v3; // r0
  char v5[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(v5, "tty_init");
    sub_385C8(5, v5, 0);
  }
  v2 = 0;
  do
  {
    v3 = v2;
    v2 = (unsigned __int8)(v2 + 1);
    sub_439A0(v3, a1);
  }
  while ( v2 != 4 );
  return sub_2A884();
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00043D20) --------------------------------------------------------
size_t __fastcall sub_43D20(unsigned __int8 a1, const void *a2, size_t a3)
{
  return sub_3BFB4(a1, a2, a3);
}

//----- (00043D28) --------------------------------------------------------
int __fastcall sub_43D28(unsigned __int8 a1, _BYTE *a2, unsigned int a3)
{
  return sub_3C2F4(a1, a2, a3);
}

//----- (00043D30) --------------------------------------------------------
void sub_43D30()
{
  int v0; // r4
  char *v1; // r5
  int v2; // r11
  int v3; // r12
  char s[4088]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(s, "check_chain");
    sub_385C8(5, s, 0);
  }
  v0 = 0;
  byte_9A49F = 0;
  v1 = (char *)&unk_9A2A8;
  v2 = *(_DWORD *)(dword_75C50 + 8);
  do
  {
    if ( ((v2 >> v0) & 1) != 0 )
    {
      v3 = (unsigned __int8)byte_77B70;
      v1[8] = 1;
      ++byte_9A49F;
      if ( v3 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "Chain %d existed!", v0);
        sub_385C8(5, s, 0);
      }
    }
    else
    {
      v1[8] = 0;
    }
    ++v0;
    ++v1;
  }
  while ( v0 != 4 );
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50;
// 77B70: using guessed type char byte_77B70;
// 9A49F: using guessed type char byte_9A49F;

//----- (00043E78) --------------------------------------------------------
int __fastcall sub_43E78(int a1)
{
  char s[100]; // [sp+4h] [bp-64h] BYREF

  byte_739A4 ^= 1u;
  if ( a1 )
  {
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", 0, 942);
    system(s);
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)byte_739A4, 941);
  }
  else
  {
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", 0, 941);
    system(s);
    sprintf(s, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)byte_739A4, 942);
  }
  return system(s);
}
// 739A4: using guessed type char byte_739A4;

//----- (00043F14) --------------------------------------------------------
void __noreturn sub_43F14()
{
  int v0; // r3
  int v1; // r0
  int v2; // r3
  int v3; // r5
  int v4; // r4
  int v5; // t1
  int v6; // r12
  _DWORD *v7; // r4
  _DWORD *v8; // lr
  int v9; // r0
  int v10; // r1
  int v11; // r2
  int v12; // r3
  int v13; // r5
  unsigned int v14; // r7
  unsigned int v15; // r9
  int v16; // r6
  unsigned int v18; // r4
  int v19; // r12
  int v20; // r7
  int v21; // r12
  int v22; // r9
  unsigned int v24; // r4
  int v25; // r6
  _DWORD *v26; // r5
  unsigned int v27; // r4
  int v28; // r10
  int v29; // r3
  bool v30; // zf
  int v31; // r3
  int v32; // r3
  char *v33; // r3
  int v34; // r2
  int v35; // r4
  int v36; // r1
  int v37; // [sp+20h] [bp-1044h]
  int v38; // [sp+20h] [bp-1044h]
  int v39; // [sp+20h] [bp-1044h]
  int v40; // [sp+20h] [bp-1044h]
  int v41; // [sp+20h] [bp-1044h]
  int v42; // [sp+20h] [bp-1044h]
  char *v43; // [sp+24h] [bp-1040h]
  unsigned int v44; // [sp+2Ch] [bp-1038h]
  int v45; // [sp+30h] [bp-1034h]
  int v46; // [sp+38h] [bp-102Ch] BYREF
  int v47; // [sp+3Ch] [bp-1028h]
  struct timeval v48; // [sp+40h] [bp-1024h] BYREF
  struct timeval v49; // [sp+48h] [bp-101Ch] BYREF
  int v50; // [sp+50h] [bp-1014h]
  int v51; // [sp+54h] [bp-1010h]
  int v52; // [sp+58h] [bp-100Ch]
  int v53; // [sp+5Ch] [bp-1008h]
  char s[4064]; // [sp+60h] [bp-1004h] BYREF

  v47 = 0;
  v46 = 0;
  sub_2A7A4(&v48);
  sub_2A7A4(&v49);
  sub_2A488(&v46, &v48);
  sub_2A488(&dword_75F34, &v49);
  v51 = 0;
  v52 = 0;
  v50 = 0;
  v53 = 0;
  while ( 1 )
  {
    sub_2A7A4(&v48);
    sub_2A7A4(&v49);
    v2 = v48.tv_sec - v46;
    if ( v48.tv_usec - v47 < 0 )
      --v2;
    if ( v2 > 11999 )
    {
      sub_2A488(&v46, &v48);
LABEL_58:
      v6 = 631739;
      v7 = &unk_78F58;
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v53 = 0;
      do
      {
        v8 = v7;
        v9 = *(_DWORD *)v6;
        v7 += 4;
        v10 = *(_DWORD *)(v6 + 4);
        v11 = *(_DWORD *)(v6 + 8);
        v12 = *(_DWORD *)(v6 + 12);
        v6 += 16;
        *v8 = v9;
        v8[1] = v10;
        v8[2] = v11;
        v8[3] = v12;
      }
      while ( (_UNKNOWN *)v6 != &unk_9A3EB );
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 631471;
      do
      {
        if ( *(unsigned __int8 *)++v16 )
        {
          v15 += *(unsigned __int8 *)(v16 + 489);
          if ( *(_BYTE *)(v16 + 489) )
          {
            v18 = 0;
            do
            {
              v19 = *(_DWORD *)((char *)&unk_9A2A8 + 12 * v13 + 4 * v18 + 227);
              v14 += v19;
              if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
              {
                snprintf(s, 0x1000u, "%s: chain %d asic %d asic_nonce_num %d", "check_miner_status", v13, v18, v19);
                sub_385C8(7, s, 0);
              }
              ++v18;
            }
            while ( *(unsigned __int8 *)(v16 + 489) > v18 );
          }
        }
        ++v13;
      }
      while ( v13 != 4 );
      if ( v15 )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(s, 0x1000u, "%s: avg_num %d asic_num %d", "check_miner_status", v14, v15);
          sub_385C8(7, s, 0);
        }
        v44 = (v14 / v15) >> 3;
      }
      else
      {
        v44 = 1;
      }
      v20 = 631471;
      v21 = 0;
      v22 = 0;
      while ( 2 )
      {
        if ( !*(unsigned __int8 *)++v20 )
          goto LABEL_115;
        v24 = *(unsigned __int8 *)(v20 + 489);
        if ( !*(_BYTE *)(v20 + 489) )
        {
          v45 = 8 * v22;
          goto LABEL_114;
        }
        v45 = 8 * v22;
        v25 = 0;
        v26 = (_DWORD *)((char *)&unk_78F58 + 12 * v22 + 48);
        v27 = 0;
        v43 = (char *)&unk_9A2A8 + 19 * v22;
LABEL_83:
        if ( (v27 & 7) == 0 )
        {
          v28 = v25 + v27;
          if ( v25 + v27 > 0x13 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
          {
            v37 = v21;
            snprintf(s, 0x1000u, aAsicNumErrD, v25 + v27);
            sub_385C8(3, s, 0);
            v21 = v37;
          }
          ++v25;
          v43[v28 + 323] = 32;
        }
        if ( v44 >= *(_DWORD *)((char *)&unk_9A2A8 + 12 * v22 + 4 * v27 + 227) )
        {
          v29 = (unsigned __int8)byte_75C68;
          *v26 = 1;
          if ( v29 )
            goto LABEL_117;
          if ( v25 + v27 > 0x13 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
          {
            v38 = v21;
            snprintf(s, 0x1000u, aAsicNumErrD, v25 + v27);
            sub_385C8(3, s, 0);
            v21 = v38;
          }
          v30 = byte_75C49 == 0;
          v31 = *(int *)((char *)&v50 + v21);
          v43[v25 + 323 + v27] = 120;
          *(int *)((char *)&v50 + v21) = v31 + 1;
          if ( !v30 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            v39 = v21;
            snprintf(
              s,
              0x1000u,
              "x chain%d asic%d nonce_num=%d avg_num=%d\n",
              v22,
              v27,
              *(_DWORD *)((char *)&unk_9A2A8 + 12 * v22 + 4 * v27 + 227),
              v44);
            sub_385C8(7, s, 0);
            v21 = v39;
          }
        }
        else
        {
          *v26 = 0;
LABEL_117:
          if ( v25 + v27 > 0x13 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
          {
            v42 = v21;
            snprintf(s, 0x1000u, aAsicNumErrD, v25 + v27);
            sub_385C8(3, s, 0);
            v21 = v42;
          }
          v43[v25 + 323 + v27] = 111;
        }
        if ( v27 > 0x13 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          v40 = v21;
          snprintf(s, 0x1000u, aAsicNumErrD, v27);
          sub_385C8(3, s, 0);
          v21 = v40;
        }
        v32 = 3 * v22 + v27++;
        ++v26;
        v33 = (char *)&unk_9A2A8 + 4 * v32 + 224;
        v34 = *((_DWORD *)v33 + 1);
        v33[3] = 0;
        *((_DWORD *)v33 + 1) = v34 & 0xFF000000;
        if ( *(unsigned __int8 *)(v20 + 489) <= v27 )
        {
          v24 = v25 + v27;
          if ( v24 > 0x13 && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
          {
            v41 = v21;
            snprintf(s, 0x1000u, aAsicNumErrD, v24);
            sub_385C8(3, s, 0);
            v21 = v41;
          }
LABEL_114:
          *((_BYTE *)&unk_9A2A8 + 2 * v45 + 2 * v22 + v22 + v24 + 323) = 0;
LABEL_115:
          ++v22;
          v21 += 4;
          if ( v22 == 4 )
          {
            pthread_mutex_lock(&stru_75F40);
            pthread_cond_signal(&stru_78EA0);
            pthread_mutex_unlock(&stru_75F40);
            memset(&unk_9A3BB, 0, 0x30u);
            memset(&unk_9A38B, 0, 0x30u);
            sub_2A488(&v46, &v48);
            goto LABEL_37;
          }
          continue;
        }
        goto LABEL_83;
      }
    }
    if ( v2 > 120 )
      goto LABEL_58;
LABEL_37:
    if ( dword_9A4AA > 80 || dword_9A4AE > 110 )
    {
      if ( (unsigned __int8)++byte_75F5C <= 2u )
      {
        if ( !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Temperature pcb:%d/chip:%d is higher than %d/%d'C for %d time, PWM is %d",
            dword_9A4AA,
            dword_9A4AE,
            80,
            110,
            (unsigned __int8)byte_75F5C,
            (unsigned __int8)byte_9A49E);
          sub_385C8(3, s, 0);
        }
      }
      else
      {
        byte_75F5D = 1;
        if ( !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "%s: the temperature pcb:%d/chip:%d is too high, close PIC and need reboot!!!",
            "check_miner_status",
            dword_9A4AA,
            dword_9A4AE);
          sub_385C8(3, s, 0);
        }
      }
    }
    else
    {
      byte_75F5C = 0;
      byte_75F5D = 0;
    }
    v0 = v49.tv_sec - dword_75F34;
    if ( v49.tv_usec - dword_75F38 < 0 )
      --v0;
    if ( v0 > 120 )
    {
      byte_75F5E = 1;
      if ( !byte_75C7C && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(
          s,
          0x1000u,
          "%s: We have lost internet for %d seconds, so don't send work to hashboard anymore",
          "check_miner_status",
          v0);
        sub_385C8(7, s, 0);
      }
    }
    else
    {
      byte_75F5E = 0;
    }
    if ( (unsigned __int8)byte_9A4A0 <= 1u )
    {
      v35 = 1;
    }
    else
    {
      if ( dword_9A2BC == 1 )
      {
        if ( dword_9A471 < (unsigned int)((unsigned __int64)(12686672634000LL * (unsigned __int8)dword_9A4CC) >> 32) >> 6 )
        {
          v35 = 2;
          goto LABEL_124;
        }
        if ( byte_9A49E == 100 && (unsigned int)dword_9A471 <= 0x1517 )
          goto LABEL_158;
      }
      if ( dword_9A2BC != 2 )
        goto LABEL_21;
      if ( dword_9A475 >= (unsigned int)((unsigned __int64)(9092115387700LL * (unsigned __int8)dword_9A4CC) >> 32) >> 6 )
      {
        if ( byte_9A49E != 100 || (unsigned int)dword_9A475 > 0xF1D )
        {
LABEL_21:
          dword_75F60 = 0;
LABEL_22:
          byte_75F65 = 0;
          goto LABEL_23;
        }
LABEL_158:
        v35 = 4;
        goto LABEL_124;
      }
      v35 = 3;
    }
LABEL_124:
    v36 = ++dword_75F60;
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(
        s,
        0x1000u,
        "ret:%d [%d:%d]fan_error_num:%d fan_num %d fan_pwm %d fan_speed_value[0] %d fan_speed_value[1] %d",
        v35,
        dword_9A2BC == 1,
        dword_9A2BC == 2,
        v36,
        (unsigned __int8)byte_9A4A0,
        (unsigned __int8)dword_9A4CC,
        dword_9A471,
        dword_9A475);
      sub_385C8(7, s, 0);
      v36 = dword_75F60;
    }
    if ( v36 <= 10 )
      goto LABEL_22;
    byte_75F65 = 1;
    switch ( v35 )
    {
      case 3:
        if ( !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Fan Err! Disable PIC! Fan2 speed is too low %d pwm %d ",
            dword_9A475,
            (unsigned __int8)byte_9A49E);
LABEL_151:
          sub_385C8(3, s, 0);
        }
        break;
      case 4:
        if ( !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Fan Err! Disable PIC! Fan1:%d Fan2:%d pwm %d",
            dword_9A471,
            dword_9A475,
            (unsigned __int8)byte_9A49E);
          sub_385C8(3, s, 0);
        }
        break;
      case 2:
        if ( !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(
            s,
            0x1000u,
            "Fan Err! Disable PIC! Fan1 speed is too low %d pwm %d ",
            dword_9A471,
            (unsigned __int8)byte_9A49E);
          goto LABEL_151;
        }
        break;
      default:
        if ( !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
        {
          snprintf(s, 0x1000u, "Fan Err! Disable PIC! Fan num is %d", (unsigned __int8)byte_9A4A0);
          sub_385C8(3, s, 0);
        }
        break;
    }
LABEL_23:
    if ( byte_75C68 )
      byte_75F5E = 0;
    if ( byte_75F64 || byte_75F5E || byte_75F5D || byte_75F65 || byte_75F66 )
    {
      v1 = 1;
      byte_75F30 = 1;
      if ( !byte_75F67 && (byte_75F5D || byte_75F65) )
      {
        v3 = 631471;
        v4 = 0;
        byte_75C7C = 1;
        byte_75F67 = 1;
        do
        {
          v5 = *(unsigned __int8 *)++v3;
          if ( v5 == 1 )
          {
            pthread_mutex_lock(&stru_75F10);
            dword_75EDC = v4;
            sub_3F4AC();
            sub_2A884();
            pthread_mutex_unlock(&stru_75F10);
          }
          ++v4;
        }
        while ( v4 != 4 );
        v1 = (unsigned __int8)byte_75F30;
      }
    }
    else
    {
      v1 = (unsigned __int8)byte_75F67;
      byte_75F30 = 0;
      byte_75C7C = 0;
      if ( byte_75F67 )
      {
        v1 = 1;
        byte_75F30 = 1;
        byte_75C7C = 1;
      }
    }
    sub_43E78(v1);
    sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C68: using guessed type char byte_75C68;
// 75C7C: using guessed type char byte_75C7C;
// 75EDC: using guessed type int dword_75EDC;
// 75F30: using guessed type char byte_75F30;
// 75F34: using guessed type int dword_75F34;
// 75F38: using guessed type int dword_75F38;
// 75F5C: using guessed type char byte_75F5C;
// 75F5D: using guessed type char byte_75F5D;
// 75F5E: using guessed type char byte_75F5E;
// 75F60: using guessed type int dword_75F60;
// 75F64: using guessed type char byte_75F64;
// 75F65: using guessed type char byte_75F65;
// 75F66: using guessed type char byte_75F66;
// 75F67: using guessed type char byte_75F67;
// 77B70: using guessed type char byte_77B70;
// 9A2BC: using guessed type int dword_9A2BC;
// 9A471: using guessed type int dword_9A471;
// 9A475: using guessed type int dword_9A475;
// 9A49E: using guessed type char byte_9A49E;
// 9A4A0: using guessed type char byte_9A4A0;
// 9A4AA: using guessed type int dword_9A4AA;
// 9A4AE: using guessed type int dword_9A4AE;
// 9A4CC: using guessed type int dword_9A4CC;

//----- (00044D74) --------------------------------------------------------
int __fastcall sub_44D74(_BYTE *a1, _DWORD *a2)
{
  int v2; // r3

  v2 = *(_DWORD *)(dword_75C50 + 4);
  *a2 = (unsigned __int8)v2;
  *a1 = BYTE1(v2) & 7;
  return v2;
}
// 75C50: using guessed type int dword_75C50;

//----- (00044DB4) --------------------------------------------------------
void sub_44DB4()
{
  int v0; // r5
  int v1; // r1
  unsigned int v2; // r3
  int v3; // r1
  unsigned int v4; // [sp+Ch] [bp-1008h]
  char s[4080]; // [sp+10h] [bp-1004h] BYREF

  v0 = 0;
  dword_9A4A2 = 0;
  dword_9A4A6 = 0;
  while ( 1 )
  {
    if ( v0 <= 5 )
      goto LABEL_13;
    if ( (unsigned __int8)byte_9A4A0 > 1u )
      break;
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "No %d Fan find, check again", 2);
      sub_385C8(5, s, 0);
    }
    v0 = 0;
    sub_2A884();
LABEL_13:
    v4 = *(_DWORD *)(dword_75C50 + 4);
    if ( v4 != -1 )
    {
      v1 = (v4 >> 8) & 7;
      v2 = 120 * (unsigned __int8)v4;
      *(_DWORD *)((char *)&unk_9A2A8 + 4 * v1 + 457) = v2;
      if ( (_BYTE)v4 )
      {
        if ( !*((_BYTE *)&unk_9A2A8 + v1 + 427) )
        {
          *((_BYTE *)&unk_9A2A8 + v1 + 427) = 1;
          ++byte_9A4A0;
          dword_9A2BC |= 1 << v1;
        }
      }
      else if ( *((_BYTE *)&unk_9A2A8 + v1 + 427) == 1 )
      {
        *((_BYTE *)&unk_9A2A8 + v1 + 427) = v4;
        if ( 1 << v1 )
          v3 = 0;
        else
          v3 = dword_9A2BC & 1;
        dword_9A2BC = v3;
        --byte_9A4A0;
      }
      if ( v2 > dword_9A4A2 )
        dword_9A4A2 = 120 * (unsigned __int8)v4;
      if ( v2 < dword_9A4A6 && v2 || !dword_9A4A6 )
        dword_9A4A6 = 120 * (unsigned __int8)v4;
    }
    ++v0;
    sub_2A884();
  }
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "fan-num %d fan-map %d\n", (unsigned __int8)byte_9A4A0, dword_9A2BC);
    sub_385C8(5, s, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50;
// 77B70: using guessed type char byte_77B70;
// 9A2BC: using guessed type int dword_9A2BC;
// 9A4A0: using guessed type char byte_9A4A0;
// 9A4A2: using guessed type int dword_9A4A2;
// 9A4A6: using guessed type int dword_9A4A6;

//----- (00044FEC) --------------------------------------------------------
int __fastcall sub_44FEC(int a1)
{
  __int64 v1; // r0

  if ( a1 <= 39 )
  {
    a1 = 40;
  }
  else if ( a1 > 100 )
  {
    v1 = 0x6400640000LL;
    goto LABEL_4;
  }
  if ( byte_75F66 )
  {
    v1 = 0x6400640000LL;
  }
  else
  {
    BYTE4(v1) = a1;
    LODWORD(v1) = (100 - a1) | (a1 << 16);
  }
LABEL_4:
  byte_9A49E = BYTE4(v1);
  *(_DWORD *)(dword_75C50 + 132) = v1;
  return v1;
}
// 75C50: using guessed type int dword_75C50;
// 75F66: using guessed type char byte_75F66;
// 9A49E: using guessed type char byte_9A49E;

//----- (0004504C) --------------------------------------------------------
void sub_4504C()
{
  ;
}

//----- (00045120) --------------------------------------------------------
void sub_45120()
{
  float v0; // s0
  int v1; // r5
  int v2; // r3
  char v3; // r1
  int v4; // r3
  _BOOL4 v5; // r3
  int v6; // r3
  char v7; // r0
  int v8; // r7
  int v9; // r3
  int v10; // r3
  char v11; // r1
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = dword_9A4AA;
  dword_75F68 = dword_9A4AA;
  if ( byte_9A4CB )
  {
    v2 = (unsigned __int8)dword_9A4CC;
    if ( (unsigned __int8)dword_9A4CC <= 0x64u )
    {
      if ( (unsigned __int8)dword_9A4CC < 0x28u )
        v2 = 40;
      if ( byte_75F66 )
      {
        v4 = 6553600;
        v3 = 100;
      }
      else
      {
        v3 = v2;
        v4 = (100 - v2) | (v2 << 16);
      }
      byte_9A49E = v3;
      *(_DWORD *)(dword_75C50 + 132) = v4;
      return;
    }
  }
  v5 = dword_9A4AA > 62;
  if ( !dword_9A4AA )
    v5 = 1;
  if ( v5 )
  {
    byte_9A49E = 100;
    *(_DWORD *)(dword_75C50 + 132) = 6553600;
    LOBYTE(dword_9A4CC) = 100;
    return;
  }
  if ( dword_9A4AA > 35 )
  {
    if ( (unsigned int)(dword_9A4AA - dword_75F6C + 1) <= 2 )
      return;
    sub_4504C();
    v8 = (int)v0 & ~((int)v0 >> 31);
    LOBYTE(dword_9A4CC) = (int)v0 & ~((int)v0 >> 31);
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(s, 0x1000u, "%s: Set PWM percent : %d", "set_PWM_according_to_temperature", (int)v0 & ~((int)v0 >> 31));
      sub_385C8(7, s, 0);
      v1 = dword_75F68;
    }
    v9 = (unsigned __int8)v8;
    if ( (unsigned __int8)v8 <= 0x27u )
    {
      v9 = 40;
    }
    else if ( (unsigned __int8)v8 > 0x64u )
    {
      goto LABEL_29;
    }
    if ( !byte_75F66 )
    {
      v11 = v9;
      v10 = (100 - v9) | (v9 << 16);
      goto LABEL_30;
    }
LABEL_29:
    v10 = 6553600;
    v11 = 100;
LABEL_30:
    byte_9A49E = v11;
    dword_75F6C = v1;
    *(_DWORD *)(dword_75C50 + 132) = v10;
    return;
  }
  v6 = 2621500;
  if ( byte_75F66 )
    v7 = 100;
  else
    v7 = 40;
  if ( byte_75F66 )
    v6 = 6553600;
  byte_9A49E = v7;
  *(_DWORD *)(dword_75C50 + 132) = v6;
  LOBYTE(dword_9A4CC) = 40;
}
// 45234: variable 'v0' is possibly undefined
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C50: using guessed type int dword_75C50;
// 75F66: using guessed type char byte_75F66;
// 75F68: using guessed type int dword_75F68;
// 75F6C: using guessed type int dword_75F6C;
// 77B70: using guessed type char byte_77B70;
// 9A49E: using guessed type char byte_9A49E;
// 9A4AA: using guessed type int dword_9A4AA;
// 9A4CB: using guessed type char byte_9A4CB;
// 9A4CC: using guessed type int dword_9A4CC;

//----- (00045310) --------------------------------------------------------
int __fastcall sub_45310(int a1)
{
  int result; // r0
  unsigned int v3; // r4
  _DWORD v4[2]; // [sp+Ch] [bp-100Ch] BYREF
  __int16 v5; // [sp+14h] [bp-1004h]
  char v6; // [sp+16h] [bp-1002h]
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  result = *((unsigned __int8 *)&unk_9A2A8 + a1 + 8);
  v4[1] = 0;
  v5 = 0;
  v6 = 0;
  v3 = dword_73998 | 0x4060;
  dword_73998 |= 0x4060u;
  v4[0] = 0;
  if ( result == 1 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "%s: reg_value=0x%08x chainid %u", "enable_read_temperature_from_asic_chain", v3, a1);
      sub_385C8(5, s, 0);
    }
    sub_3CA8C((int)v4, 0, byte_75F70, 28, v3);
    sub_3BFB4((unsigned __int8)a1, v4, 0xBu);
    sub_2A884();
    sub_3CA8C((int)v4, 0, byte_75F71, 28, v3);
    sub_3BFB4((unsigned __int8)a1, v4, 0xBu);
    return sub_2A884();
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 73998: using guessed type int dword_73998;
// 75C48: using guessed type char byte_75C48;
// 75F70: using guessed type char byte_75F70;
// 75F71: using guessed type char byte_75F71;
// 77B70: using guessed type char byte_77B70;

//----- (00045464) --------------------------------------------------------
int sub_45464()
{
  sub_45310(0);
  sub_45310(1);
  sub_45310(2);
  return sub_45310(3);
}

//----- (0004548C) --------------------------------------------------------
void __fastcall sub_4548C(int a1, int a2)
{
  unsigned int v3; // r4
  _DWORD v4[2]; // [sp+Ch] [bp-100Ch] BYREF
  __int16 v5; // [sp+14h] [bp-1004h]
  char v6; // [sp+16h] [bp-1002h]
  char s[4072]; // [sp+18h] [bp-1000h] BYREF

  v4[1] = 0;
  v5 = 0;
  v4[0] = 0;
  v3 = a2 & 0xFFFFFFF8;
  v6 = 0;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s: analog_mux_reg_value = %08x", "select_core_to_check_temperature_chain", a2);
    sub_385C8(5, s, 0);
  }
  if ( *((_BYTE *)&unk_9A2A8 + a1 + 8) == 1 )
  {
    sub_3CA8C((int)v4, 0, byte_75F70[0], 64, v3);
    sub_3BFB4((unsigned __int8)a1, v4, 0xBu);
    sub_2A884();
    sub_3CA8C((int)v4, 0, byte_75F71, 64, v3);
    sub_3BFB4((unsigned __int8)a1, v4, 0xBu);
    sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75F71: using guessed type char byte_75F71;
// 77B70: using guessed type char byte_77B70;

//----- (000455CC) --------------------------------------------------------
void __fastcall sub_455CC(int a1)
{
  int i; // r4
  int v3; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s: analog_mux_reg_value = %08x", "select_core_to_check_temperature", a1);
    sub_385C8(5, s, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    v3 = i;
    sub_4548C(v3, a1);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00045674) --------------------------------------------------------
int __fastcall sub_45674(int a1, int a2, char a3, unsigned __int8 a4, unsigned __int8 a5)
{
  unsigned int v5; // r12
  char v7; // r2
  _DWORD v9[2]; // [sp+Ch] [bp-10h] BYREF
  __int16 v10; // [sp+14h] [bp-8h]
  char v11; // [sp+16h] [bp-6h]

  v5 = dword_739A8 & 0xFE0100FF | 0x1000000 | ((a3 & 0x7F) << 17) | (a4 << 8);
  v7 = *((_BYTE *)&dword_75C50[200] + a2);
  v9[0] = 0;
  v9[1] = 0;
  v10 = 0;
  v11 = 0;
  sub_3CA8C((int)v9, 0, v7, 32, v5 & 0xFFFFFF00 | a5 | 0x10000);
  sub_3BFB4(a1, v9, 0xBu);
  return sub_2A884();
}
// 739A8: using guessed type int dword_739A8;
// 75C50: using guessed type int dword_75C50[];

//----- (00045700) --------------------------------------------------------
int __fastcall sub_45700(int a1, int a2)
{
  char *v4; // r3
  int v5; // r0
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(s, 0x1000u, "%s chainid %d", "reset_chain", a2);
    sub_385C8(4, s, 0);
  }
  pthread_mutex_lock(&stru_75F10);
  dword_75EDC = a2;
  sub_3F4AC();
  pthread_mutex_unlock(&stru_75F10);
  v4 = (char *)&dword_75C50 + a2;
  v4[732] = 0;
  v4[776] = 0;
  v4[748] = 1;
  sub_2A334(a1 + (a2 << 6) + 634);
  sub_2A334(a1 + (a2 << 6) + 890);
  byte_7398B = 0;
  pthread_mutex_lock(&stru_75F10);
  dword_75EDC = a2;
  sub_3DC38();
  v5 = sub_2A884();
  sub_3DA90(v5);
  sub_2A884();
  pthread_mutex_unlock(&stru_75F10);
  byte_7398B = 1;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s %d", "reset_hash_board_low", a2);
    sub_385C8(5, s, 0);
  }
  *(_DWORD *)(dword_75C50 + 52) = 1 << a2;
  sub_2A884();
  pthread_mutex_lock(&stru_75F10);
  dword_75EDC = a2;
  sub_3F304();
  pthread_mutex_unlock(&stru_75F10);
  sleep(1u);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s %d", "reset_hash_board_high", a2);
    sub_385C8(5, s, 0);
  }
  *(_DWORD *)(dword_75C50 + 52) = 0;
  *((_BYTE *)&dword_75C50 + a2 + 748) = 0;
  sub_439A0(a2, a1);
  sub_3B998(26);
  sub_2A884();
  sub_43250(a2, 0);
  sub_2A884();
  sub_3B998(0);
  return sub_2A884();
}
// 3DA90: using guessed type int __fastcall sub_3DA90(_DWORD);
// 73504: using guessed type int dword_73504;
// 7398B: using guessed type char byte_7398B;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50;
// 75EDC: using guessed type int dword_75EDC;
// 77B70: using guessed type char byte_77B70;

//----- (00045970) --------------------------------------------------------
int __fastcall sub_45970(int result)
{
  char v1[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( result != 1 && result != 2 )
  {
    if ( (unsigned int)(result - 3) > 1 )
    {
      if ( (unsigned int)(result - 5) > 3 )
      {
        if ( (unsigned int)(result - 9) > 7 )
        {
          if ( (unsigned int)(result - 17) > 0xF )
          {
            if ( (unsigned int)(result - 33) > 0x1F )
            {
              if ( (unsigned int)(result - 65) > 0x3F )
              {
                if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
                {
                  snprintf(v1, 0x1000u, "actual_asic_number = %d, but it is error\n", result);
                  sub_385C8(7, v1, 0);
                  return -1;
                }
                else
                {
                  return -1;
                }
              }
              else
              {
                return 128;
              }
            }
            else
            {
              return 64;
            }
          }
          else
          {
            return 32;
          }
        }
        else
        {
          return 16;
        }
      }
      else
      {
        return 8;
      }
    }
    else
    {
      return 4;
    }
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;

//----- (00045A7C) --------------------------------------------------------
int sub_45A7C()
{
  int v0; // r0
  int result; // r0
  char v2; // r2
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v0 = sub_45970(3);
  result = (unsigned __int8)sub_59AC8(256, v0);
  byte_9A4C7 = result;
  v2 = result;
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s:addrInterval = %d", "calculate_address_interval", (unsigned __int8)result);
    sub_385C8(5, s, 0);
    v2 = byte_9A4C7;
  }
  byte_75F71 = 2 * v2;
  byte_75F70 = 0;
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75F70: using guessed type char byte_75F70;
// 75F71: using guessed type char byte_75F71;
// 77B70: using guessed type char byte_77B70;
// 9A4C7: using guessed type char byte_9A4C7;

//----- (00045B48) --------------------------------------------------------
int sub_45B48()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9A2A4 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_9A2A4, 0, (void *(*)(void *))sub_46090, 0) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_scan_freq_pthread");
      sub_385C8(7, v1, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_9A2A4 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 9A2A4: using guessed type int dword_9A2A4;

//----- (00045C28) --------------------------------------------------------
int sub_45C28()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9A2A4 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_9A2A4, 0, (void *(*)(void *))sub_42FD8, 0) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_balance_mode_monitor_pthread");
      sub_385C8(7, v1, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_9A2A4 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 9A2A4: using guessed type int dword_9A2A4;

//----- (00045D08) --------------------------------------------------------
int sub_45D08()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_9A2A4 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_9A2A4, 0, (void *(*)(void *))sub_42894, 0) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_turbo_mode_monitor_pthread");
      sub_385C8(7, v1, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_9A2A4 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 9A2A4: using guessed type int dword_9A2A4;

//----- (00045DE8) --------------------------------------------------------
int sub_45DE8()
{
  char v1[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( access("/config/chips_freq.config", 0) )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      strcpy(v1, "Goto scan mode and find the best frequency\n");
      sub_385C8(5, v1, 0);
    }
    return sub_45B48();
  }
  else if ( *(unsigned __int16 *)((char *)&dword_9A4CC + 1) == 681 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      strcpy(v1, "Goto balance mode\n");
      sub_385C8(5, v1, 0);
    }
    return sub_45C28();
  }
  else
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      strcpy(v1, "Goto turbo mode\n");
      sub_385C8(5, v1, 0);
    }
    return sub_45D08();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;
// 9A4CC: using guessed type int dword_9A4CC;

//----- (00045F7C) --------------------------------------------------------
int sub_45F7C()
{
  FILE *v0; // r7
  int v1; // r5
  char *v2; // r6
  int v3; // t1
  int i; // r4
  char *v6; // r3
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v0 = fopen("/config/chips_freq.config", "w+");
  if ( v0 )
  {
    v1 = 631471;
    v2 = (char *)&unk_78F58;
    do
    {
      v3 = *(unsigned __int8 *)++v1;
      if ( v3 == 1 )
      {
        for ( i = 0; i != 12; i += 4 )
        {
          v6 = &v2[i];
          fprintf(v0, "%d ", *((_DWORD *)v6 + 48));
        }
      }
      v2 += 12;
    }
    while ( v1 != 631475 );
    fclose(v0);
    return 0;
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%s open %s failed\n", "scan_freq_save_freq", "/config/chips_freq.config");
    sub_385C8(5, s, 0);
    return -1;
  }
  else
  {
    return -1;
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00046090) --------------------------------------------------------
void __noreturn sub_46090()
{
  char *v0; // r1
  int j; // r2
  int v2; // t1
  int v3; // r5
  int v4; // r11
  int v5; // t1
  _DWORD *v6; // r5
  int v7; // r10
  int v8; // r6
  int v9; // r9
  int ii; // r4
  int v11; // t1
  int v12; // r0
  _BOOL4 v13; // r3
  int v14; // r4
  int v15; // r6
  int v16; // r0
  int *v17; // r4
  int v18; // r3
  int v19; // lr
  int v20; // r12
  int k; // r2
  int v22; // r1
  int m; // r1
  int v24; // lr
  unsigned int v25; // r1
  int v26; // r12
  int v27; // r2
  const char *v28; // r3
  int v29; // t1
  int v30; // r1
  int v31; // lr
  const char *v32; // r3
  int n; // r2
  int v34; // r12
  int v35; // lr
  const char *v36; // r3
  int v37; // r12
  int v38; // r3
  char *v39; // lr
  bool v40; // zf
  char *v41; // r12
  int v42; // r12
  char *v43; // r3
  int i; // [sp+24h] [bp-1008h]
  char s[4100]; // [sp+28h] [bp-1004h] BYREF

  for ( i = 731; ; i = 750 )
  {
    v0 = (char *)&unk_78F58;
    for ( j = 631471; j != 631475; ++j )
    {
      v2 = *(unsigned __int8 *)(j + 1);
      if ( v2 == 1 )
      {
        v42 = 0;
        do
        {
          *(_DWORD *)&v0[v42] = 0;
          v43 = &v0[v42];
          v42 += 4;
          *((_DWORD *)v43 + 12) = 0;
          *((_DWORD *)v43 + 48) = 681;
          *((_DWORD *)v43 + 36) = i;
          *((_DWORD *)v43 + 24) = 650;
          *((_DWORD *)v43 + 60) = 0;
        }
        while ( v42 != 12 );
      }
      v0 += 12;
    }
    do
    {
      do
      {
LABEL_5:
        sleep(1u);
        pthread_mutex_lock(&stru_75F40);
        pthread_cond_wait(&stru_78EA0, &stru_75F40);
        pthread_mutex_unlock(&stru_75F40);
        v3 = (unsigned __int8)byte_75C7C;
      }
      while ( byte_75C7C );
      v4 = 631471;
      do
      {
        v5 = *(unsigned __int8 *)++v4;
        if ( v5 != 1 )
          goto LABEL_8;
        v15 = 0;
        v17 = (int *)((char *)&unk_78F58 + 12 * v3 + 48);
        v16 = *v17;
        if ( *v17 )
          goto LABEL_48;
        while ( 2 )
        {
          v18 = *(v17 - 12);
          if ( (unsigned int)v18 <= 5 )
          {
            v19 = v17[36];
            v20 = v17[24];
            if ( v20 == v19 )
            {
LABEL_76:
              v17[48] = 1;
              goto LABEL_46;
            }
            v17[12] = v19;
            if ( v19 == 100 )
            {
              k = v16;
LABEL_28:
              if ( v20 == 100 )
                goto LABEL_70;
            }
            else
            {
              v18 = (int)"d";
              for ( k = 1; k != 100; ++k )
              {
                v22 = *(_DWORD *)(v18 + 16);
                v18 += 16;
                if ( v19 == v22 )
                  goto LABEL_28;
              }
              k = -1;
              if ( v20 == 100 )
              {
LABEL_70:
                m = 0;
                goto LABEL_32;
              }
            }
            v18 = (int)"d";
            for ( m = 1; m != 100; ++m )
            {
              v24 = *(_DWORD *)(v18 + 16);
              v18 += 16;
              if ( v20 == v24 )
                goto LABEL_32;
            }
            m = -1;
LABEL_32:
            v25 = m - k;
            if ( v25 == 1 )
              ++k;
            else
              v18 = v25 + (v25 >> 31);
            if ( v25 != 1 )
            {
              v25 = 1;
              k += v18 >> 1;
            }
            goto LABEL_37;
          }
LABEL_48:
          v30 = v17[12];
          v31 = v17[36];
          if ( v30 == v31 )
            goto LABEL_76;
          if ( v31 == 100 )
          {
            v35 = -1;
LABEL_54:
            if ( v30 == 100 )
              goto LABEL_74;
            goto LABEL_55;
          }
          v32 = "d";
          for ( n = 1; n != 100; ++n )
          {
            v34 = *((_DWORD *)v32 + 4);
            v32 += 16;
            if ( v31 == v34 )
            {
              v35 = n - 1;
              goto LABEL_54;
            }
          }
          v35 = -2;
          if ( v30 == 100 )
          {
LABEL_74:
            k = 0;
            goto LABEL_58;
          }
LABEL_55:
          v36 = "d";
          for ( k = 1; k != 100; ++k )
          {
            v37 = *((_DWORD *)v36 + 4);
            v36 += 16;
            if ( v30 == v37 )
              goto LABEL_58;
          }
          k = -1;
LABEL_58:
          v38 = v35 - k;
          v39 = &aResetAllHashBo[16 * v35];
          v40 = v38 == 1;
          v25 = -1;
          if ( v38 == 1 )
            ++k;
          else
            v38 += (unsigned int)v38 >> 31;
          if ( !v40 )
            k += v38 >> 1;
          v17[24] = *((_DWORD *)v39 + 530);
LABEL_37:
          v26 = (unsigned __int8)byte_75C49;
          v27 = *(_DWORD *)&aResetAllHashBo[16 * k + 2120];
          v17[36] = v27;
          if ( v26 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            if ( v25 == 1 )
              v28 = "up";
            else
              v28 = "down";
            snprintf(
              s,
              0x1000u,
              "%s freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
              v28,
              v3,
              v15,
              v27,
              v17[12],
              v17[24],
              *(v17 - 12),
              v16);
            sub_385C8(7, s, 0);
            v27 = v17[36];
          }
          sub_4273C((unsigned __int8)v3, (unsigned __int8)v15, v27);
LABEL_46:
          if ( ++v15 != 3 )
          {
            v29 = v17[1];
            ++v17;
            v16 = v29;
            if ( !v29 )
              continue;
            goto LABEL_48;
          }
          break;
        }
LABEL_8:
        ++v3;
      }
      while ( v3 != 4 );
      v6 = &unk_78F58;
      v7 = 0;
      v8 = 631471;
      v9 = 0;
      for ( ii = 0; ii != 4; ++ii )
      {
        v11 = *(unsigned __int8 *)++v8;
        if ( v11 == 1 )
        {
          v41 = (char *)&unk_78F58 + 12 * ii;
          v7 += *((_DWORD *)v41 + 48) + v6[49] + v6[50];
          v9 += *((_DWORD *)v41 + 60) + v6[61] + v6[62];
          if ( byte_75C49 )
          {
            if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
            {
              snprintf(s, 0x1000u, "chain%d %d %d %d\n", ii, v6[48], v6[49], v6[50]);
              sub_385C8(7, s, 0);
            }
          }
        }
        v6 += 3;
      }
    }
    while ( v9 != 3 * (unsigned __int8)byte_9A49F );
    v12 = sub_59AC8(v7, v9);
    v13 = i == 750;
    if ( v12 > 718 )
      v13 = 1;
    v14 = v12;
    if ( v13 )
    {
      sub_45F7C();
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "scan freq done, avg freq %d max %d, reboot cgminer\n", v14, i);
        sub_385C8(5, s, 0);
      }
      system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
      goto LABEL_5;
    }
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(s, 0x1000u, "scan freq again, avg freq %d max %d\n", v12, 750);
      sub_385C8(5, s, 0);
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C7C: using guessed type char byte_75C7C;
// 77B70: using guessed type char byte_77B70;
// 9A49F: using guessed type char byte_9A49F;

//----- (00046654) --------------------------------------------------------
void __fastcall sub_46654(int a1)
{
  pthread_t v2; // r0
  int v3; // r4
  char v4[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(v4, 0x1000u, "%s Begin\n", "bitmain_ZCASH_reinit_chain");
    sub_385C8(5, v4, 0);
  }
  v2 = pthread_self();
  pthread_detach(v2);
  pthread_mutex_lock(&stru_75F74);
  v3 = *(unsigned __int8 *)(a1 + 4);
  sub_45700(*(_DWORD *)a1, v3);
  sub_42200(v3);
  sub_2A884();
  sub_425E8(v3, *(unsigned __int16 *)((char *)&unk_9A2A8 + 2 * v3 + 561));
  sub_2A884();
  sub_42358(v3, 0x13880u);
  sub_2A884();
  sub_433BC(v3, dword_7399C);
  sub_2A884();
  sub_45310(v3);
  *((_BYTE *)&dword_75C50[183] + v3) = 1;
  sleep(1u);
  pthread_mutex_unlock(&stru_75F74);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(v4, 0x1000u, "%s Done\n", "bitmain_ZCASH_reinit_chain");
    sub_385C8(5, v4, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 7399C: using guessed type int dword_7399C;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50[];
// 77B70: using guessed type char byte_77B70;

//----- (000467E4) --------------------------------------------------------
int __fastcall sub_467E4(unsigned __int64 a1, char *a2, size_t a3, int a4, char a5)
{
  __int64 v7; // r0
  double v8; // r0
  double v9; // d8
  __int64 v11; // r0
  double v12; // d0
  double v13; // r0
  int v14; // r3
  int v15; // [sp+0h] [bp-24h]
  char v16[8]; // [sp+1Ch] [bp-8h] BYREF

  *(_WORD *)v16 = 0;
  if ( a1 > 0x3B9AC9FF )
  {
    LODWORD(v7) = sub_59F7C(a1, 1000000);
    LODWORD(v8) = sub_59F08(v7);
    *(_WORD *)v16 = 71;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0xF423F )
  {
    LODWORD(v11) = sub_59F7C(a1, 1000);
    LODWORD(v8) = sub_59F08(v11);
    *(_WORD *)v16 = 77;
    v9 = v8 / 1000.0;
    goto LABEL_3;
  }
  if ( a1 > 0x3E7 )
  {
    LODWORD(v8) = sub_59F08(a1);
    *(_WORD *)v16 = 75;
    v9 = v8 / 1000.0;
LABEL_3:
    if ( !a4 )
      return snprintf(a2, a3, "%.3g%s", v9, v16);
    goto LABEL_7;
  }
  LODWORD(v8) = sub_59F08(a1);
  v9 = v8;
  if ( !a4 )
    return snprintf(a2, a3, "%d%s", (unsigned int)v8, v16);
LABEL_7:
  if ( v9 <= 0.0 )
  {
    v12 = 0.0;
  }
  else
  {
    v12 = v9;
    v13 = log10(v8);
    floor(v13);
  }
  v14 = a4 + 1;
  v15 = (int)((double)(a4 - 1) - v12);
  if ( a5 )
    return snprintf(a2, a3, "%*.*f%s", v14, v15, v9, v16);
  else
    return snprintf(a2, a3, "%*.*f", v14, v15, v9);
}
// 4683C: variable 'v7' is possibly undefined
// 4684C: variable 'v8' is possibly undefined
// 468A0: variable 'v11' is possibly undefined

//----- (000469B8) --------------------------------------------------------
int sub_469B8()
{
  unsigned __int64 v0; // d8
  _QWORD *v1; // r9
  int v2; // r11
  int i; // r10
  unsigned int v5; // r3
  int k; // r4
  unsigned int v8; // r3
  char *v9; // r5
  int v10; // r4
  char *v11; // r5
  __int64 v12; // r6
  int v13; // lr
  int j; // r4
  int v15; // t1
  int v16; // r12
  double v17; // r0
  char *v18; // r5
  int v19; // lr
  int v20; // t1
  int v21; // r12
  double v22; // r0
  __int64 v23; // [sp+10h] [bp-1014h]
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  v0 = 0;
  v1 = &unk_75F90;
  v2 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    while ( !*(unsigned __int8 *)++v2 )
    {
LABEL_7:
      ++i;
      ++v1;
      if ( i == 4 )
        return sub_467E4(v0, byte_759C0, 0x10u, 6, 0);
    }
    if ( !byte_75FB0[i] )
    {
      v5 = (unsigned __int8)(byte_75FB4[i] + 1);
      byte_75FB4[i] = v5;
      if ( v5 > 3 || byte_75C7C )
      {
        *v1 = 0;
        sub_467E4(0, &byte_78ED0[16 * i], 0x10u, 6, 1);
      }
      goto LABEL_7;
    }
    if ( byte_75FB0[i] > 2u )
    {
      v9 = (char *)&byte_75FB0[512 * i];
      v10 = (unsigned __int8)byte_739AC;
      if ( byte_739AC )
      {
        v11 = v9 + 516;
        v12 = 0;
        v13 = (unsigned __int8)byte_75C49;
        for ( j = 0; j != 3; ++j )
        {
          v15 = *((_DWORD *)v11 + 1);
          v11 += 4;
          v16 = v15 & 0x7FFFFFFF;
          v12 += v15 & 0x7FFFFFFF;
          if ( v13 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(s, 0x1000u, "%s: RT g_HASH_RATE_reg_value[%d][%d] = 0x%08x", "calculate_hash_rate", i, j, v16);
            sub_385C8(7, s, 0);
            v13 = (unsigned __int8)byte_75C49;
          }
        }
        if ( v13 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          LODWORD(v17) = sub_59F08(v12);
          snprintf(s, 0x1000u, "%s: chain%d RT hash rate is %0.2fGHz/s", "calculate_hash_rate", i, v17 / 1000000.0);
          sub_385C8(7, s, 0);
        }
        byte_75FB4[i] = 0;
        *v1 = 1000000 * v12;
        sub_467E4(1000000 * v12, &byte_78ED0[16 * i], 0x10u, 6, 0);
        v0 += *v1;
      }
      else
      {
        v18 = v9 + 516;
        v19 = (unsigned __int8)byte_75C49;
        v23 = 0;
        do
        {
          v20 = *((_DWORD *)v18 + 1);
          v18 += 4;
          v21 = v20 & 0x7FFFFFFF;
          v23 += v20 & 0x7FFFFFFF;
          if ( v19 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
          {
            snprintf(s, 0x1000u, "%s: avg g_HASH_RATE_reg_value[%d][%d] = 0x%08x", "calculate_hash_rate", i, v10, v21);
            sub_385C8(7, s, 0);
            v19 = (unsigned __int8)byte_75C49;
          }
          ++v10;
        }
        while ( v10 != 3 );
        if ( v19 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          LODWORD(v22) = sub_59F08(v23);
          snprintf(s, 0x1000u, "%s: chain%d avg hash rate is %0.2fGHz/s", "calculate_hash_rate", i, v22 / 1000000.0);
          sub_385C8(7, s, 0);
        }
        v0 += *v1;
        byte_75FB4[i] = 0;
      }
    }
    else
    {
      for ( k = 0; k != 3; ++k )
      {
        if ( !byte_75FB4[128 * i + 4] && !byte_75C7C && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(
            s,
            0x1000u,
            "%s: Chain%d ASIC%d didn't send back HASH_RATE register value",
            "calculate_hash_rate",
            i,
            k);
          sub_385C8(7, s, 0);
        }
      }
      v8 = (unsigned __int8)(byte_75FB4[i] + 1);
      byte_75FB4[i] = v8;
      if ( v8 > 3 || byte_75C7C )
      {
        *v1 = 0;
        sub_467E4(0, &byte_78ED0[16 * i], 0x10u, 6, 1);
      }
      v0 += *v1;
    }
    ++v1;
  }
  return sub_467E4(v0, byte_759C0, 0x10u, 6, 0);
}
// 46CC8: variable 'v17' is possibly undefined
// 46E64: variable 'v22' is possibly undefined
// 73504: using guessed type int dword_73504;
// 739AC: using guessed type char byte_739AC;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C7C: using guessed type char byte_75C7C;
// 75FB0: using guessed type unsigned __int8 byte_75FB0[4];
// 75FB4: using guessed type _BYTE byte_75FB4[2564];
// 77B70: using guessed type char byte_77B70;

//----- (00046EEC) --------------------------------------------------------
int sub_46EEC()
{
  pthread_mutex_lock(&stru_769B8);
  dword_78BBC = 0;
  dword_78BC0 = 0;
  dword_78BC4 = 0;
  return pthread_mutex_unlock(&stru_769B8);
}
// 78BBC: using guessed type int dword_78BBC;
// 78BC0: using guessed type int dword_78BC0;
// 78BC4: using guessed type int dword_78BC4;

//----- (00046F24) --------------------------------------------------------
int __fastcall sub_46F24(int a1, int a2, int a3, int a4)
{
  size_t v8; // r0
  int v9; // r3
  unsigned int v10; // r5
  int v11; // r9
  int v12; // r10
  int v13; // r7
  int v14; // r5
  int v15; // r3
  int v16; // r1
  int v17; // r2
  unsigned int v18; // r3
  unsigned int v20; // r1
  char *v21; // r0
  _WORD *v22; // r12
  int v23; // [sp+14h] [bp-1020h]
  int v24; // [sp+28h] [bp-100Ch] BYREF
  __int16 v25; // [sp+2Ch] [bp-1008h]
  char v26; // [sp+2Eh] [bp-1006h]
  char s[4048]; // [sp+30h] [bp-1004h] BYREF

  v25 = 0;
  v24 = 0;
  v26 = 0;
  sub_46EEC();
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(s, 0x1000u, "%s: check chain J%d mode %d chipaddr %02x regaddr %02x", "check_asic_reg", a1, a4, a2, a3);
    sub_385C8(7, s, 0);
  }
  v8 = sub_3CBB0((int)&v24, a4, a2, a3);
  sub_3BFB4(a1, &v24, v8);
  if ( !a3 && *((_BYTE *)&dword_75C50 + a1 + 3456) )
    *((_BYTE *)&unk_9A2A8 + a1 + 497) = 0;
  v9 = a3;
  v10 = 0;
  v11 = a2;
  v12 = v9;
  do
  {
LABEL_10:
    usleep((__useconds_t)sub_493E0);
    pthread_mutex_lock(&stru_769B8);
    v13 = dword_78BC4;
    pthread_mutex_unlock(&stru_769B8);
    if ( v13 )
    {
      v14 = 0;
      while ( 1 )
      {
        pthread_mutex_lock(&stru_769B8);
        v15 = dword_78BC0;
        v16 = *((unsigned __int8 *)&dword_78BBC + 7 * dword_78BC0 + 18);
        if ( v16 != a1 )
        {
          ++dword_78BC0;
          --dword_78BC4;
          if ( v15 == 99 )
            dword_78BC0 = 0;
          if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
          {
            snprintf(
              s,
              0x1000u,
              "%s: the return data is from chain%d, but it should be from chain%d chipaddr=0x%02x reg=0x%02x\n",
              "check_asic_reg",
              v16,
              a1,
              v11,
              v12);
            sub_385C8(5, s, 0);
          }
          goto LABEL_18;
        }
        v17 = *((unsigned __int8 *)&dword_78BBC + 7 * dword_78BC0 + 17);
        v18 = bswap32(*(int *)((char *)&dword_78BBC + 7 * dword_78BC0 + 13));
        switch ( v12 )
        {
          case 0:
            if ( *((_BYTE *)&dword_75C50 + a1 + 3456) )
            {
              ++*((_BYTE *)&unk_9A2A8 + a1 + 497);
              goto LABEL_23;
            }
            if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic address is 0x%08x", "check_asic_reg", v18);
            goto LABEL_31;
          case 12:
            if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic freq is 0x%08x", "check_asic_reg", v18);
            goto LABEL_31;
          case 20:
            if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic tm is 0x%08x", "check_asic_reg", v18);
            goto LABEL_31;
          case 28:
            if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic misc is 0x%08x", "check_asic_reg", v18);
            goto LABEL_31;
        }
        if ( v12 != 32 )
        {
          if ( v12 == 84 )
          {
            if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the start nonce offset is 0x%08x", "check_asic_reg", v18);
          }
          else
          {
            if ( v12 != 48 || !byte_77B70 && !byte_75C48 && dword_73504 <= 4 )
              goto LABEL_23;
            snprintf(s, 0x1000u, "%s: the asic IO strength is 0x%08x", "check_asic_reg", v18);
          }
LABEL_31:
          sub_385C8(5, s, 0);
          goto LABEL_23;
        }
        v20 = v18 & 0xC0000000;
        if ( (v18 & 0xC0000000) == 0 )
        {
          v23 = v18 & 0xFF00;
          v21 = (char *)&unk_769F4 + 8 * a1;
          v22 = (_WORD *)((char *)&unk_9A2A8 + 16 * a1 + 128);
          if ( (unsigned __int8)byte_75F70[0] == v17 )
          {
LABEL_61:
            if ( (v18 & 0xFF00) != 0 )
            {
              switch ( v23 )
              {
                case 256:
                  v21[1] = 1;
                  v22[1] = (unsigned __int8)v18;
                  break;
                case 4352:
                  byte_769D4[4 * a1 + v20] = v18;
                  v21[2] = 1;
                  break;
                case 65024:
                  byte_769E4[4 * a1 + v20] = v18;
                  v21[3] = 1;
                  break;
              }
            }
            else
            {
              *v21 = 1;
              *v22 = (unsigned __int8)v18;
            }
          }
          while ( 1 )
          {
            ++v20;
            v22 += 4;
            v21 += 4;
            if ( v20 == 2 )
              break;
            if ( (unsigned __int8)byte_75F70[v20] == v17 )
              goto LABEL_61;
          }
        }
LABEL_23:
        ++dword_78BC0;
        --dword_78BC4;
        if ( dword_78BC0 == 100 )
          dword_78BC0 = 0;
LABEL_18:
        ++v14;
        pthread_mutex_unlock(&stru_769B8);
        if ( v14 == v13 )
        {
          v10 = 0;
          goto LABEL_10;
        }
      }
    }
    ++v10;
    usleep(0x186A0u);
  }
  while ( v10 <= 2 );
  if ( !v12 )
  {
    if ( (unsigned __int8)byte_9A4C8 < (unsigned int)*((unsigned __int8 *)&unk_9A2A8 + a1 + 497) )
      byte_9A4C8 = *((_BYTE *)&unk_9A2A8 + a1 + 497);
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(
        s,
        0x1000u,
        "%s: chain J%d has %d ASIC",
        "check_asic_reg",
        a1,
        *((unsigned __int8 *)&unk_9A2A8 + a1 + 497));
      sub_385C8(5, s, 0);
    }
  }
  return sub_46EEC();
}
// 493E0: using guessed type int sub_493E0();
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C50: using guessed type int dword_75C50;
// 769D4: using guessed type _BYTE byte_769D4[16];
// 769E4: using guessed type _BYTE byte_769E4[16];
// 77B70: using guessed type char byte_77B70;
// 78BBC: using guessed type int dword_78BBC;
// 78BC0: using guessed type int dword_78BC0;
// 78BC4: using guessed type int dword_78BC4;
// 9A4C8: using guessed type char byte_9A4C8;

//----- (000475A0) --------------------------------------------------------
void __fastcall sub_475A0(int a1, int a2, char a3, unsigned int a4)
{
  int v8; // r9
  int v9; // r4
  char *v10; // r9
  _DWORD v11[2]; // [sp+Ch] [bp-1010h] BYREF
  __int16 v12; // [sp+14h] [bp-1008h]
  char v13; // [sp+16h] [bp-1006h]
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v11[1] = 0;
  v12 = 0;
  v11[0] = 0;
  v13 = 0;
  sub_2A884();
  if ( a4 < 2 )
  {
    v8 = a4;
  }
  else if ( a4 == 17 )
  {
    v8 = 2;
  }
  else
  {
    if ( a4 != 254 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
      {
        snprintf(s, 0x1000u, "%s unknow reg_type %d\n", "read_i2c_reg", a4);
        sub_385C8(4, s, 0);
      }
      return;
    }
    v8 = 3;
  }
  v9 = 3;
  v10 = (char *)&dword_75C50[2 * a1 + a2] + v8;
  sub_3CA8C(
    (int)v11,
    0,
    *((_BYTE *)&dword_75C50[200] + a2),
    32,
    dword_739A8 & 0xFE000000 | 0x1000000 | ((a3 & 0x7F) << 17) | (unsigned __int16)((unsigned __int8)a4 << 8));
  sub_3BFB4(a1, v11, 0xBu);
  sub_2A884();
  v10[3492] = 0;
  do
  {
    sub_2A884();
    sub_46F24(a1, *((unsigned __int8 *)&dword_75C50[200] + a2), 32, 0);
    if ( v10[3492] )
      break;
    --v9;
  }
  while ( v9 );
}
// 73504: using guessed type int dword_73504;
// 739A8: using guessed type int dword_739A8;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50[];
// 77B70: using guessed type char byte_77B70;

//----- (00047748) --------------------------------------------------------
void __noreturn sub_47748()
{
  char *v0; // r9
  int v1; // r6
  int v2; // r4
  int v3; // r7
  int v4; // t1
  __int16 *v5; // r5
  int v6; // r4
  int v7; // r11
  int v8; // r10
  int v9; // t1
  int v10; // r3
  char *v11; // r3
  char *v12; // r7
  char *v13; // r8
  __int16 *v14; // r9
  int v15; // r5
  int v16; // r4
  char *v17; // r12
  int v18; // r2
  __int16 v19; // r2
  __int16 v20; // r2
  int v21; // r2
  int v22; // r12
  char *v23; // r0
  int v24; // r1
  int v25; // r2
  char *v26; // [sp+14h] [bp-1028h]
  char *v27; // [sp+14h] [bp-1028h]
  int v28; // [sp+18h] [bp-1024h]
  char v29[4100]; // [sp+38h] [bp-1004h] BYREF

  if ( byte_75C49 )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 6 )
    {
      v0 = (char *)&unk_9A2A8;
      strcpy(v29, "read_temp_func");
      sub_385C8(7, v29, 0);
    }
    else
    {
      v0 = (char *)&unk_9A2A8;
    }
  }
  else
  {
    v0 = (char *)&unk_9A2A8;
  }
  while ( 1 )
  {
    v1 = 631471;
    sleep(1u);
    v2 = 0;
    v3 = 631471;
    do
    {
      v4 = *(unsigned __int8 *)++v3;
      if ( v4 == 1 && byte_75F2C[v2] )
      {
        sub_475A0((unsigned __int8)v2, 0, 76, 1u);
        sub_475A0((unsigned __int8)v2, 0, 76, 0);
        sub_475A0((unsigned __int8)v2, 1, 76, 1u);
        sub_475A0((unsigned __int8)v2, 1, 76, 0);
      }
      ++v2;
      sub_2A884();
    }
    while ( v2 != 4 );
    v5 = (__int16 *)&unk_9A2A8;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v28 = 0;
    do
    {
      v9 = *(unsigned __int8 *)++v1;
      if ( v9 == 1 && byte_75F2C[v6] )
      {
        v11 = v0;
        v12 = &v0[16 * v6 + 130];
        v13 = (char *)&unk_769F4 + 8 * v6;
        v14 = v5;
        v15 = v6;
        v16 = 0;
        v17 = v11;
        do
        {
          if ( *v13 )
          {
            v28 = 1;
          }
          else
          {
            v18 = v28;
            if ( v13[1] )
              v18 = 1;
            v28 = v18;
          }
          v19 = *((_WORD *)v12 - 1);
          if ( v8 < v19 )
          {
            if ( v19 > 80 && !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
            {
              v8 = v19;
              v26 = v17;
              snprintf(
                v29,
                0x1000u,
                "%s: Chain%d sensor%d local temp is %d `C, higher than MAX_TEMP",
                "read_temp_func",
                v15,
                v16,
                v19);
              sub_385C8(3, v29, 0);
              v17 = v26;
            }
            else
            {
              v8 = v19;
            }
          }
          v20 = *(_WORD *)v12;
          if ( *(__int16 *)v12 > v7 )
          {
            if ( v20 > 110 && !byte_75C7C && (byte_77B70 || byte_75C48 || dword_73504 > 2) )
            {
              v7 = v20;
              v27 = v17;
              snprintf(
                v29,
                0x1000u,
                "%s: Chain%d sensor%d remote temp is %d `C, higher than MAX_CHIP_TEMP",
                "read_temp_func",
                v15,
                v16,
                v20);
              sub_385C8(3, v29, 0);
              v17 = v27;
            }
            else
            {
              v7 = v20;
            }
          }
          ++v16;
          v13 += 4;
          v12 += 8;
        }
        while ( v16 != 2 );
        v6 = v15;
        v5 = v14;
        v21 = v14[68];
        v0 = v17;
        v22 = v5[64];
        v23 = &v0[4 * v6];
        v24 = v5[65];
        if ( v22 < v21 )
          v22 = v21;
        v25 = v5[69];
        *(_DWORD *)(v23 + 621) = v22 & ~(v22 >> 31);
        if ( v24 >= v25 )
          v25 = v24;
        *(_DWORD *)(v23 + 637) = v25 & ~(v25 >> 31);
      }
      ++v6;
      v5 += 8;
    }
    while ( v6 != 4 );
    *(_DWORD *)(v0 + 514) = v8;
    *(_DWORD *)(v0 + 518) = v7;
    if ( v28 )
    {
      byte_75F66 = 0;
    }
    else
    {
      byte_75F66 = 1;
      if ( !byte_75C7C && byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
      {
        snprintf(
          v29,
          0x1000u,
          "%s: can't read all sensor's temperature, close PIC and need reboot!!!",
          "read_temp_func");
        sub_385C8(7, v29, 0);
      }
    }
    if ( byte_75F30 )
    {
      v10 = dword_75C50[0];
      v0[502] = 100;
      *(_DWORD *)(v10 + 132) = 6553600;
    }
    else
    {
      sub_45120();
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C50: using guessed type int dword_75C50[];
// 75C7C: using guessed type char byte_75C7C;
// 75F30: using guessed type char byte_75F30;
// 75F66: using guessed type char byte_75F66;
// 77B70: using guessed type char byte_77B70;

//----- (00047C4C) --------------------------------------------------------
void sub_47C4C()
{
  int v0; // r6
  int i; // r4
  int v2; // t1
  int j; // r5
  char s[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    strcpy(s, "check_sensor_ID");
    sub_385C8(7, s, 0);
  }
  v0 = 631471;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      for ( j = 0; j != 2; ++j )
      {
        sub_475A0((unsigned __int8)i, (unsigned __int8)j, 76, 0xFEu);
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf(
            s,
            0x1000u,
            "%s: Chain%d Sensor%d Manufacturer ID = 0x%02x",
            "check_sensor_ID",
            i,
            j,
            (char)byte_769E4[4 * i + j]);
          sub_385C8(3, s, 0);
        }
      }
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 769E4: using guessed type _BYTE byte_769E4[16];
// 77B70: using guessed type char byte_77B70;

//----- (00047DA0) --------------------------------------------------------
void __fastcall sub_47DA0(int a1, int a2)
{
  char *v4; // r6
  int v5; // r3
  char s[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    snprintf(s, 0x1000u, "Chain %d %s", a1, "set_temperature_offset_value_chain_sensor");
    sub_385C8(4, s, 0);
  }
  v4 = (char *)&dword_75C50[a1] + a2;
  sub_45674(a1, a2, 76, 0x11u, v4[3524]);
  sub_2A884();
  sub_475A0(a1, a2, 76, 0x11u);
  v5 = v4[3460];
  if ( v5 == v4[3524] )
  {
    if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
    {
      snprintf(
        s,
        0x1000u,
        "%s: Chain%d Sensor%d temp offset : %02d, ",
        "set_temperature_offset_value_chain_sensor",
        a1,
        a2,
        v4[3460]);
      sub_385C8(5, s, 0);
    }
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s: Chain%d Sensor%d temp offset value set error. It should be %02d, but read back is %02d\n",
      "set_temperature_offset_value_chain_sensor",
      a1,
      a2,
      v4[3524],
      v5);
    sub_385C8(3, s, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50[];
// 77B70: using guessed type char byte_77B70;

//----- (00047F54) --------------------------------------------------------
void __fastcall sub_47F54(int a1)
{
  int v2; // r6
  _BYTE *v3; // r7
  __int16 *v4; // r5
  int v5; // r8
  __int16 v6; // r2
  __int16 v7; // r3
  int v8; // r11
  char s[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(s, 0x1000u, "%d %s", a1, "calibration_sensor_offset_chain");
    sub_385C8(5, s, 0);
  }
  v2 = 0;
  v3 = (char *)&unk_76A14 + 4 * a1;
  v4 = (__int16 *)((char *)&unk_9A2A8 + 16 * a1 + 128);
  do
  {
    LOBYTE(v5) = 11;
    do
    {
      sub_475A0(a1, v2, 76, 1u);
      sub_475A0(a1, v2, 76, 0);
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        snprintf(s, 0x1000u, "chain:%d local:%d remote:%d", a1, *v4, v4[1]);
        sub_385C8(5, s, 0);
      }
      v6 = *v4;
      v7 = v4[1];
      v8 = *v4 - v7;
      if ( v8 < 0 )
        v8 = v7 - v6;
      *v3 = v6 + *v3 - v7;
      if ( v8 <= 2 )
        break;
      sub_47DA0(a1, v2);
      v5 = (unsigned __int8)(v5 - 1);
    }
    while ( v5 );
    ++v3;
    v4 += 4;
    v2 = (unsigned __int8)(v2 + 1);
  }
  while ( v2 != 2 );
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000480FC) --------------------------------------------------------
int sub_480FC()
{
  int v0; // r4
  int v1; // r5
  int v2; // t1
  int result; // r0

  v0 = 0;
  v1 = 631471;
  do
  {
    v2 = *(unsigned __int8 *)++v1;
    if ( v2 == 1 )
    {
      sub_47F54(v0);
      result = sub_2A884();
    }
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
  return result;
}

//----- (00048140) --------------------------------------------------------
int __fastcall sub_48140(int result)
{
  int v1; // r6
  int v2; // r7
  int v3; // r4
  int v4; // t1
  int v5; // [sp+0h] [bp-Ch] BYREF
  __int16 v6; // [sp+4h] [bp-8h]
  char v7; // [sp+6h] [bp-6h]

  v1 = 631471;
  v2 = result;
  v3 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  do
  {
    v4 = *(unsigned __int8 *)++v1;
    if ( v4 == 1 )
    {
      sub_3CBB0((int)&v5, 1, 0, v2);
      sub_3BFB4(v3, &v5, 7u);
      sub_2A884();
      result = sub_46F24(v3, 0, v2, 1);
    }
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
  return result;
}

//----- (000481D0) --------------------------------------------------------
int __fastcall sub_481D0(int result, char a2)
{
  if ( *((_BYTE *)&unk_9A2A8 + result + 8) )
  {
    *((_BYTE *)&dword_75C50 + result + 3456) = a2;
    return sub_46F24(result, 0, 0, 1);
  }
  return result;
}
// 75C50: using guessed type int dword_75C50;

//----- (0004821C) --------------------------------------------------------
int __fastcall sub_4821C(char a1)
{
  int v2; // r4
  int result; // r0
  char v4[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(v4, "check_every_chain_asic_number");
    sub_385C8(5, v4, 0);
  }
  v2 = 0;
  do
  {
    sub_481D0(v2, a1);
    v2 = (unsigned __int8)(v2 + 1);
    result = sub_2A884();
  }
  while ( (unsigned __int8)v2 != 4 );
  return result;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000482D0) --------------------------------------------------------
void sub_482D0()
{
  int v0; // r5
  int i; // r4
  int v2; // t1
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    strcpy(v3, "check_every_chain_asic_pll");
    sub_385C8(5, v3, 0);
  }
  v0 = 631471;
  for ( i = 0; i != 4; i = (unsigned __int8)(i + 1) )
  {
    v2 = *(unsigned __int8 *)++v0;
    if ( v2 == 1 )
    {
      sub_46F24(i, 0, 12, 1);
      sub_2A884();
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (000483A4) --------------------------------------------------------
void __fastcall sub_483A4(int a1, int a2)
{
  char v4[4100]; // [sp+0h] [bp-1004h] BYREF

  pthread_mutex_lock(&stru_75F74);
  sub_45700(a1, a2);
  pthread_mutex_unlock(&stru_75F74);
  sub_46EEC();
  sub_2A884();
  sub_481D0(a2, 1);
  sub_2A884();
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(v4, 0x1000u, "%s DONE!", "recheck_asic_num");
    sub_385C8(5, v4, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 77B70: using guessed type char byte_77B70;

//----- (00048470) --------------------------------------------------------
int sub_48470()
{
  pthread_mutex_lock(&stru_75CC8);
  dword_79080 = 0;
  dword_79084 = 0;
  dword_79088 = 0;
  sub_3BF04(0);
  sub_3BF04(1);
  sub_3BF04(2);
  sub_3BF04(3);
  return pthread_mutex_unlock(&stru_75CC8);
}
// 79080: using guessed type int dword_79080;
// 79084: using guessed type int dword_79084;
// 79088: using guessed type int dword_79088;

//----- (000484C8) --------------------------------------------------------
int __fastcall sub_484C8(int a1)
{
  int v1; // r0
  _DWORD *v2; // r3
  char v3; // t1
  int v4; // r8
  int v5; // r5
  int v6; // r7
  int v7; // r4
  _DWORD v10[7]; // [sp+0h] [bp-20h] BYREF
  int v11; // [sp+1Ch] [bp-4h] BYREF

  v1 = a1 + 32;
  v2 = (_DWORD *)((char *)&v10[-1] + 3);
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  do
  {
    v3 = *(_BYTE *)--v1;
    *((_BYTE *)v2 + 1) = v3;
    v2 = (_DWORD *)((char *)v2 + 1);
  }
  while ( v2 != (int *)((char *)&v11 + 3) );
  v4 = 0;
  v5 = 0;
LABEL_4:
  v6 = v5 + 8;
  v7 = 7;
  while ( !sub_41BC0((int)v10 + v4, v7--) )
  {
    if ( ++v5 == v6 )
    {
      if ( ++v4 != 32 )
        goto LABEL_4;
      return v5;
    }
  }
  return v5;
}

//----- (00048564) --------------------------------------------------------
int __fastcall sub_48564(int a1, int a2)
{
  int v2; // r3
  unsigned int v3; // r12
  unsigned int v4; // r2

  v2 = 31;
  while ( 1 )
  {
    v3 = *(unsigned __int8 *)(a1 + v2);
    v4 = *(unsigned __int8 *)(a2 + v2--);
    if ( v3 < v4 )
      return 1;
    if ( v3 > v4 )
      break;
    if ( v2 == -1 )
      return 1;
  }
  return 0;
}

//----- (00048598) --------------------------------------------------------
int sub_48598()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_79078 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_79078, 0, (void *(*)(void *))sub_3A934, 0) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_check_fan_pthread");
      sub_385C8(7, v1, 0);
    }
    return -8;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_79078 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 79078: using guessed type int dword_79078;

//----- (00048678) --------------------------------------------------------
int sub_48678()
{
  int v0; // r4
  int v2; // r5
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( (unsigned __int8)byte_9A4A0 <= 1u )
  {
    v0 = 1;
    goto LABEL_12;
  }
  if ( dword_9A2BC != 1 )
    goto LABEL_6;
  if ( dword_9A471 < (unsigned int)((unsigned __int64)(12686672634000LL * (unsigned __int8)dword_9A4CC) >> 32) >> 6 )
  {
    v0 = 2;
    goto LABEL_12;
  }
  if ( byte_9A49E != 100 || (unsigned int)dword_9A471 > 0x1517 )
  {
LABEL_6:
    if ( dword_9A2BC != 2 )
    {
LABEL_7:
      v0 = 0;
      dword_75F60 = 0;
      return v0;
    }
    if ( dword_9A475 < (unsigned int)((unsigned __int64)(9092115387700LL * (unsigned __int8)dword_9A4CC) >> 32) >> 6 )
    {
      v0 = 3;
      goto LABEL_12;
    }
    if ( byte_9A49E != 100 || (unsigned int)dword_9A475 > 0xF1D )
      goto LABEL_7;
  }
  v0 = 4;
LABEL_12:
  v2 = ++dword_75F60;
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(
      s,
      0x1000u,
      "ret:%d [%d:%d]fan_error_num:%d fan_num %d fan_pwm %d fan_speed_value[0] %d fan_speed_value[1] %d",
      v0,
      dword_9A2BC == 1,
      dword_9A2BC == 2,
      v2,
      (unsigned __int8)byte_9A4A0,
      (unsigned __int8)dword_9A4CC,
      dword_9A471,
      dword_9A475);
    sub_385C8(7, s, 0);
    v2 = dword_75F60;
  }
  if ( v2 <= 10 )
    return 0;
  return v0;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75F60: using guessed type int dword_75F60;
// 77B70: using guessed type char byte_77B70;
// 9A2BC: using guessed type int dword_9A2BC;
// 9A471: using guessed type int dword_9A471;
// 9A475: using guessed type int dword_9A475;
// 9A49E: using guessed type char byte_9A49E;
// 9A4A0: using guessed type char byte_9A4A0;
// 9A4CC: using guessed type int dword_9A4CC;

//----- (00048840) --------------------------------------------------------
int __fastcall sub_48840(void *a1)
{
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  dword_78E88 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_78E88, 0, (void *(*)(void *))sub_43F14, a1) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v3, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_check_miner_status_pthread");
      sub_385C8(7, v3, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_78E88 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78E88: using guessed type int dword_78E88;

//----- (0004892C) --------------------------------------------------------
int sub_4892C()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_78E84 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_78E84, 0, (void *(*)(void *))sub_3AA8C, (void *)dword_78E84) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(
        v1,
        0x1000u,
        "%s: create thread for get hashrate from asic failed",
        "create_bitmain_get_hash_rate_pthread");
      sub_385C8(7, v1, 0);
    }
    return -6;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_78E84 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78E84: using guessed type int dword_78E84;

//----- (00048A0C) --------------------------------------------------------
int __fastcall sub_48A0C(int a1)
{
  int v1; // r4
  int v2; // r6

  v1 = (a1 << 16) | 0x1900000;
  pthread_mutex_lock(&stru_75EE0);
  v2 = sub_3C3E8(v1);
  sub_3C3E8(v1);
  sub_2A884();
  pthread_mutex_unlock(&stru_75EE0);
  return v2;
}

//----- (00048A54) --------------------------------------------------------
int sub_48A54()
{
  char v1[4096]; // [sp+0h] [bp-1000h] BYREF

  dword_78F54 = (int)calloc(1u, 0x40u);
  if ( sub_2EFE4(dword_78F54, 0, (void *(*)(void *))sub_47748, (void *)dword_78F54) )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(v1, 0x1000u, "%s: create thread for read temp", "create_bitmain_read_temp_pthread");
      sub_385C8(7, v1, 0);
    }
    return -7;
  }
  else
  {
    pthread_detach(*(_DWORD *)(dword_78F54 + 12));
    return sub_2A884();
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78F54: using guessed type int dword_78F54;

//----- (00048B34) --------------------------------------------------------
int __fastcall sub_48B34(int a1)
{
  int v2; // lr
  int v3; // lr
  char v4; // r2
  int v5; // r1
  int result; // r0
  int *v7; // r2
  unsigned int v8; // r3
  int v9; // t1
  int v10; // r3
  int v11; // r2
  int v12; // r2
  int v13; // r10
  char *v14; // r9
  int v15; // t1
  int v16; // r8
  char v17; // r2
  int v18; // r8
  int v19; // r11
  int v20; // r12
  int v21; // [sp+18h] [bp-104Ch]
  char v22; // [sp+1Ch] [bp-1048h]
  int v23; // [sp+20h] [bp-1044h]
  int v24; // [sp+24h] [bp-1040h]
  int v25; // [sp+28h] [bp-103Ch]
  int v26; // [sp+2Ch] [bp-1038h]
  int v27; // [sp+30h] [bp-1034h]
  int v28; // [sp+34h] [bp-1030h]
  int v29; // [sp+38h] [bp-102Ch]
  int v30; // [sp+3Ch] [bp-1028h]
  int v31; // [sp+40h] [bp-1024h] BYREF
  int v32; // [sp+44h] [bp-1020h]
  int v33; // [sp+48h] [bp-101Ch]
  int v34; // [sp+4Ch] [bp-1018h]
  int v35; // [sp+50h] [bp-1014h]
  int v36; // [sp+54h] [bp-1010h]
  int v37; // [sp+58h] [bp-100Ch]
  int v38; // [sp+5Ch] [bp-1008h] BYREF
  char s[4064]; // [sp+60h] [bp-1004h] BYREF

  v23 = *(_DWORD *)(a1 + 1170);
  v24 = *(_DWORD *)(a1 + 1174);
  v25 = *(_DWORD *)(a1 + 1178);
  v26 = *(_DWORD *)(a1 + 1182);
  v27 = *(_DWORD *)(a1 + 1186);
  v28 = *(_DWORD *)(a1 + 1190);
  v29 = *(_DWORD *)(a1 + 1194);
  v30 = *(_DWORD *)(a1 + 1198);
  sub_3B5B8();
  sub_3B848();
  sub_3B998(26);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
  {
    strcpy(s, "bitmain_ZCASH_init");
    sub_385C8(4, s, 0);
  }
  v31 = v23;
  v32 = v24;
  v33 = v25;
  v34 = v26;
  v2 = (unsigned __int8)dword_739B0;
  byte_9A4C7 = 1;
  v35 = v27;
  v36 = v28;
  v37 = v29;
  v38 = v30;
  strcpy((char *)&dword_759D0, "9.0.0.5");
  if ( (unsigned __int8)dword_739B0 <= 0x27u )
  {
    v2 = 40;
  }
  else if ( (unsigned __int8)dword_739B0 > 0x64u )
  {
    v3 = 6553600;
    v4 = 100;
    goto LABEL_7;
  }
  if ( byte_75F66 )
  {
    v3 = 6553600;
    v4 = 100;
  }
  else
  {
    v4 = v2;
    v3 = (100 - v2) | (v2 << 16);
  }
LABEL_7:
  byte_9A49E = v4;
  *(_DWORD *)(dword_75C50[0] + 132) = v3;
  sub_44DB4();
  v5 = (unsigned __int8)v31;
  if ( (unsigned __int8)v31 == 81 )
  {
    v7 = &v31;
    v8 = 255;
    while ( 1 )
    {
      v8 = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v5 ^ (v8 >> 8)) + 424] ^ ((_WORD)v8 << 8));
      if ( v7 == (int *)((char *)&v38 + 1) )
        break;
      v9 = *((unsigned __int8 *)v7 + 1);
      v7 = (int *)((char *)v7 + 1);
      v5 = v9;
    }
    if ( HIWORD(v38) == v8 )
    {
      v10 = 0;
      do
      {
        v11 = v10 + 28;
        ++v10;
        v12 = a1 + 4 * v11;
        *(_WORD *)(v12 + 6) = 0;
        *(_WORD *)(v12 + 8) = 0;
      }
      while ( v10 != 128 );
      sub_43D30();
      if ( byte_75C68 )
      {
        BYTE2(v34) = 50;
        dword_75C78 = (unsigned __int8)byte_9A49F;
        LOBYTE(v33) = v33 | 2;
      }
      sub_40A98();
      sub_40B80();
      sleep(1u);
      result = sub_40E7C();
      if ( result != -3 )
      {
        v22 = v33;
        dword_9A4CC = dword_9A4CC & 0xFF0000FF | 0x2CE00;
        sub_3A1EC();
        sub_2A884();
        sub_40C68();
        sub_2A884();
        sub_3E9FC(870);
        sub_2A884();
        sub_40DA4();
        sub_2A884();
        if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
        {
          snprintf(s, 0x1000u, "%s %d", "reset_all_hash_board_high", 4076);
          sub_385C8(5, s, 0);
        }
        v13 = 0;
        v14 = &byte_9A2B0;
        *(_DWORD *)(dword_75C50[0] + 52) = 0;
        sub_2A884();
        sub_43C74(a1);
        sleep(3u);
        sub_432BC(v32);
        sub_2A884();
        sub_45A7C();
        byte_9A4C6 = 1;
        sub_46EEC();
        sub_2A884();
        sleep(2u);
        sub_4821C(1);
        sub_2A884();
        do
        {
          v15 = (unsigned __int8)*v14++;
          if ( v15 == 1 )
          {
            v19 = 3;
            byte_76A24[v13] = 1;
            while ( 1 )
            {
              v20 = (unsigned __int8)v14[488];
              if ( v20 == 3 )
                break;
              v21 = (unsigned __int8)byte_77B70;
              byte_76A24[v13] = 1;
              if ( !v21 && !byte_75C48 && dword_73504 <= 4
                || (snprintf(
                      s,
                      0x1000u,
                      "recheck: chainid %d exist %d asicnum %d realnum %d",
                      v13,
                      (unsigned __int8)*(v14 - 1),
                      v20,
                      3),
                    sub_385C8(5, s, 0),
                    byte_76A24[v13]) )
              {
                sub_483A4(a1, (unsigned __int8)v13);
                if ( --v19 )
                  continue;
              }
              goto LABEL_40;
            }
            byte_76A24[v13] = 0;
          }
LABEL_40:
          ++v13;
        }
        while ( v13 != 4 );
        sub_43204(681);
        sub_45DE8();
        sub_434BC(dword_7399C);
        sub_2A884();
        sub_42318();
        sub_2A884();
        sub_42454(dword_739B4);
        sub_2A884();
        sub_45464();
        if ( (v22 & 4) != 0 )
        {
          dword_9A2B8 = 10000000;
          if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
          {
            snprintf(s, 0x1000u, "dev.timeout = %d us", 10000000);
            sub_385C8(5, s, 0);
          }
        }
        result = sub_48A54();
        if ( result != -7 )
        {
          v16 = BYTE2(v34);
          byte_9A4CB = (v33 & 2) != 0;
          LOBYTE(dword_9A4CC) = BYTE2(v34);
          if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
          {
            snprintf(s, 0x1000u, "%s: fan_eft : %d  fan_pwm : %d", "bitmain_ZCASH_init", (v33 & 2) != 0, BYTE2(v34));
            sub_385C8(5, s, 0);
          }
          if ( (v22 & 2) != 0 && (unsigned int)v16 <= 0x64 )
          {
            if ( v16 < 40 )
              v16 = 40;
            if ( byte_75F66 )
            {
              v18 = 6553600;
              v17 = 100;
            }
            else
            {
              v17 = v16;
              v18 = (100 - v16) | (v16 << 16);
            }
            byte_9A49E = v17;
            *(_DWORD *)(dword_75C50[0] + 132) = v18;
          }
          else
          {
            sub_45120();
          }
          result = sub_48598();
          if ( result != -8 )
          {
            sleep(1u);
            result = sub_48840((void *)a1);
            if ( result != -5 )
            {
              result = sub_4892C();
              if ( result != -6 )
              {
                sub_43668();
                byte_75F2C[0] = 1;
                byte_75F2D = 1;
                byte_75F2E = 1;
                byte_75F2F = 1;
                if ( byte_77B70 || (result = (unsigned __int8)byte_75C48, byte_75C48) || dword_73504 > 4 )
                {
                  snprintf(s, 0x1000u, "% done", "bitmain_ZCASH_init");
                  sub_385C8(5, s, 0);
                  return 0;
                }
              }
            }
          }
        }
      }
    }
    else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(
        s,
        0x1000u,
        "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x",
        "bitmain_ZCASH_init",
        HIWORD(v38),
        v8);
      sub_385C8(3, s, 0);
      return -2;
    }
    else
    {
      return -2;
    }
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(
      s,
      0x1000u,
      "%s: config_parameter.token_type != 0x%x, it is 0x%x",
      "bitmain_ZCASH_init",
      81,
      (unsigned __int8)v31);
    sub_385C8(3, s, 0);
    return -1;
  }
  else
  {
    return -1;
  }
  return result;
}
// 73504: using guessed type int dword_73504;
// 7399C: using guessed type int dword_7399C;
// 739B0: using guessed type int dword_739B0;
// 739B4: using guessed type int dword_739B4;
// 759D0: using guessed type int dword_759D0;
// 75C48: using guessed type char byte_75C48;
// 75C50: using guessed type int dword_75C50[];
// 75C68: using guessed type char byte_75C68;
// 75C78: using guessed type int dword_75C78;
// 75F2D: using guessed type char byte_75F2D;
// 75F2E: using guessed type char byte_75F2E;
// 75F2F: using guessed type char byte_75F2F;
// 75F66: using guessed type char byte_75F66;
// 76A24: using guessed type _BYTE byte_76A24[4];
// 77B70: using guessed type char byte_77B70;
// 9A2B0: using guessed type char byte_9A2B0;
// 9A2B8: using guessed type int dword_9A2B8;
// 9A49E: using guessed type char byte_9A49E;
// 9A49F: using guessed type char byte_9A49F;
// 9A4C6: using guessed type char byte_9A4C6;
// 9A4C7: using guessed type char byte_9A4C7;
// 9A4CB: using guessed type char byte_9A4CB;
// 9A4CC: using guessed type int dword_9A4CC;

//----- (00049290) --------------------------------------------------------
void __fastcall sub_49290(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r4
  int v14; // r2
  int *v15; // r3
  unsigned int v16; // r12
  int v17; // t1
  int v18; // r1
  int v19; // r2
  int v20; // r3
  int v21; // [sp+0h] [bp-24h] BYREF
  int v22; // [sp+4h] [bp-20h]
  int v23; // [sp+8h] [bp-1Ch]
  int v24; // [sp+Ch] [bp-18h]
  __int64 v25; // [sp+10h] [bp-14h] BYREF
  int v26; // [sp+18h] [bp-Ch]
  int v27; // [sp+1Ch] [bp-8h] BYREF

  v13 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 20);
  *(_DWORD *)(v13 + 630) = a1;
  if ( pthread_mutex_init((pthread_mutex_t *)(v13 + 1146), 0) )
    sub_B800(7041);
  if ( pthread_mutex_init((pthread_mutex_t *)v13, 0) )
    sub_B800(7042);
  sub_3AD18((pthread_rwlock_t *)(v13 + 24));
  HIWORD(v23) = 0;
  v14 = 81;
  v27 = 4;
  BYTE2(v24) = dword_739B0;
  v15 = &v21;
  LOBYTE(v23) = ~(~(((2 * (byte_76A28 & 1)) | 1u) << 30) >> 30);
  v22 = 0;
  v26 = 0;
  v16 = 255;
  LOWORD(v25) = dword_739B8;
  v21 = 1572945;
  BYTE1(v23) = 7;
  LOWORD(v24) = 774;
  HIBYTE(v24) = 80;
  BYTE2(v25) = 7;
  strcpy((char *)&v25 + 3, "%\n\n");
  HIBYTE(v25) = 0;
  while ( 1 )
  {
    LOWORD(v16) = *(_WORD *)&aResetAllHashBo[2 * (v14 ^ (v16 >> 8)) + 424] ^ ((_WORD)v16 << 8);
    if ( v15 == (int *)((char *)&v27 + 1) )
      break;
    v17 = *((unsigned __int8 *)v15 + 1);
    v15 = (int *)((char *)v15 + 1);
    v14 = v17;
  }
  HIWORD(v27) = v16;
  v18 = v22;
  v19 = v23;
  v20 = v24;
  *(_DWORD *)(v13 + 1170) = v21;
  *(_DWORD *)(v13 + 1174) = v18;
  *(_DWORD *)(v13 + 1178) = v19;
  *(_DWORD *)(v13 + 1182) = v20;
  sub_493E0(v25, SHIDWORD(v25), v26, v27, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}
// 739B0: using guessed type int dword_739B0;
// 739B8: using guessed type int dword_739B8;
// 76A28: using guessed type char byte_76A28;

//----- (000493E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_493E0(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  int v13; // r4

  *(_DWORD *)(v13 + 1186) = a1;
  *(_DWORD *)(v13 + 1190) = a2;
  *(_DWORD *)(v13 + 1194) = a3;
  *(_DWORD *)(v13 + 1198) = a4;
  sub_48B34(v13);
  __asm { POP             {R4-R11,PC} }
}
// 49400: positive sp value 24 has been found
// 49400: unbalanced stack, ignored a potential tail call
// 493E0: variable 'v13' is possibly undefined

//----- (00049428) --------------------------------------------------------
int *__fastcall sub_49428(int *result, int a2)
{
  int v2; // r3

  v2 = *result + 1;
  if ( v2 >= a2 )
    v2 = 0;
  *result = v2;
  return result;
}

//----- (00049440) --------------------------------------------------------
int __fastcall sub_49440(int a1, int a2)
{
  if ( a1 )
    return a1 - 1;
  else
    return a2 - 1;
}

//----- (00049450) --------------------------------------------------------
int __fastcall sub_49450(int a1, int a2)
{
  if ( a2 - 1 <= a1 )
    return 0;
  else
    return a1 + 1;
}

//----- (00049464) --------------------------------------------------------
int __fastcall sub_49464(int a1, int a2, int a3, int a4, char a5)
{
  unsigned __int8 v6; // r0
  int v7; // r5
  int v9; // r8
  int v10; // r6
  int v11; // r10
  unsigned __int8 *v12; // r2
  unsigned int v13; // r3
  unsigned __int8 *v14; // r0
  int v15; // t1
  int v16; // r11
  int v17; // r2
  int v18; // r3
  char v19; // r1
  int v20; // r3
  int v21; // r1
  int v22; // r2
  int v23; // r12
  int v24; // r0
  int v25; // r3
  int v26; // r0
  int v27; // r2
  int v28; // r12
  int v29; // r3
  int v30; // r3
  int v31; // r0
  int v32; // r4
  char *v33; // r5
  char *v34; // r7
  int v35; // r1
  void *v36; // r0
  unsigned int v37; // r6
  char *v38; // r12
  __int16 s1; // [sp+16h] [bp-1006h] BYREF
  char s[4072]; // [sp+18h] [bp-1004h] BYREF

  v6 = *(_BYTE *)(a3 + 3) / (unsigned __int8)byte_9A4C7;
  v7 = v6;
  if ( v6 > 2u )
  {
    if ( !byte_77B70 && !byte_75C48 && dword_73504 <= 3 )
      return -1;
    snprintf(s, 0x1000u, "%s chipid %d is not exist", "nonce_handle", v6);
LABEL_6:
    sub_385C8(4, s, 0);
    return -1;
  }
  v9 = *(_BYTE *)(a3 + 2) & 0xF;
  v10 = a2 + 1456 * v6;
  memcpy((void *)(v10 + 91 * v9), (const void *)(a3 + 2), 0x5Bu);
  if ( v9 == 15 )
  {
    v11 = 0;
    while ( 1 )
    {
      v12 = (unsigned __int8 *)(v10 + 91 * v11);
      v13 = 0xFFFF;
      v14 = v12 + 89;
      do
      {
        v15 = *v12++;
        v13 = (unsigned __int16)(*(_WORD *)&aResetAllHashBo[2 * (v15 ^ (v13 >> 8)) + 424] ^ ((_WORD)v13 << 8));
      }
      while ( v12 != v14 );
      v16 = (unsigned __int16)((v13 >> 8) | ((_WORD)v13 << 8));
      s1 = (v13 >> 8) | ((_WORD)v13 << 8);
      if ( memcmp(&s1, (const void *)(v10 + 91 * v11 + 89), 2u) )
        break;
      if ( ++v11 == 16 )
      {
        v17 = 0;
        v18 = 0;
        while ( 1 )
        {
          v19 = *(_BYTE *)(v10 + v17);
          v17 += 91;
          if ( v18 != (v19 & 0xF) )
            break;
          if ( ++v18 == 16 )
          {
            v20 = *(unsigned __int8 *)(v10 + 1);
            v21 = v10;
            v22 = v10;
            v23 = 15;
            while ( 1 )
            {
              v24 = *(unsigned __int8 *)(v22 + 92);
              v22 += 91;
              if ( v24 != v20 )
                break;
              if ( !--v23 )
              {
                v25 = *(unsigned __int8 *)(v10 + 2);
                v26 = v10;
                v27 = 15;
                while ( 1 )
                {
                  v28 = *(unsigned __int8 *)(v26 + 93);
                  v26 += 91;
                  if ( v28 != v25 )
                    break;
                  if ( !--v27 )
                  {
                    v30 = *(unsigned __int8 *)(v10 + 3);
                    while ( 1 )
                    {
                      v31 = *(unsigned __int8 *)(v21 + 94);
                      ++v27;
                      v21 += 91;
                      if ( v31 != v30 )
                        break;
                      if ( v27 == 15 )
                      {
                        v32 = 0;
                        v33 = (char *)(a1 + 1357 * v7);
                        v34 = v33;
                        do
                        {
                          v35 = v10 + 91 * v32;
                          v36 = v34;
                          ++v32;
                          v34 += 85;
                          memcpy(v36, (const void *)(v35 + 4), 0x55u);
                        }
                        while ( v32 != 15 );
                        memcpy(v33 + 1275, (const void *)(v10 + 1369), 0x45u);
                        *((_DWORD *)v33 + 338) = *(_DWORD *)(v10 + 1450);
                        v33[1344] = *(_BYTE *)(v10 + 1366);
                        v33[1345] = *(_BYTE *)(v10 + 1367);
                        v33[1346] = *(_BYTE *)(v10 + 1368);
                        v33[1347] = *(_BYTE *)(v10 + 1441);
                        *((_DWORD *)v33 + 337) = *(_DWORD *)(v10 + 1442);
                        pthread_mutex_lock(&stru_75CC8);
                        v37 = dword_79080;
                        v38 = (char *)&dword_79080 + 1357 * dword_79080;
                        v38[1368] = a5;
                        v38[1356] = v33[1344];
                        v38[1357] = v33[1345] & 0x7F;
                        v38[1358] = v33[1346];
                        v38[1359] = v33[1347];
                        *((_DWORD *)v38 + 340) = *((_DWORD *)v33 + 337);
                        *((_DWORD *)v38 + 341) = *((_DWORD *)v33 + 338);
                        memcpy(v38 + 12, v33, 0x540u);
                        if ( v37 > 0x62 )
                          dword_79080 = 0;
                        else
                          dword_79080 = v37 + 1;
                        if ( (unsigned int)dword_79088 > 0x63 )
                        {
                          dword_79088 = 100;
                          if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
                          {
                            snprintf(s, 0x1000u, "%s: nonce fifo full!!!", "nonce_handle");
                            sub_385C8(4, s, 0);
                          }
                          pthread_mutex_unlock(&stru_75CC8);
                          sub_48470();
                          return 0;
                        }
                        else
                        {
                          ++dword_79088;
                          pthread_mutex_unlock(&stru_75CC8);
                          return 0;
                        }
                      }
                    }
                    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
                    {
                      snprintf(s, 0x1000u, "nonceID is different %02x != %02x chipid=%d\n", v30, v31, v7);
                      goto LABEL_28;
                    }
                    goto LABEL_30;
                  }
                }
                if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
                {
                  snprintf(s, 0x1000u, "workID is different %02x != %02x\n", v25, v28);
                  goto LABEL_28;
                }
                goto LABEL_30;
              }
            }
            if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
            {
              snprintf(s, 0x1000u, "chip_addr is different %02x != %02x\n", v20, v24);
              goto LABEL_28;
            }
            goto LABEL_30;
          }
        }
        if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
        {
          snprintf(s, 0x1000u, "nonce is not continous i=%d\n", v18);
          goto LABEL_28;
        }
        goto LABEL_30;
      }
    }
    if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
    {
      snprintf(
        s,
        0x1000u,
        "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
        "bm1740_verify_nonce_integrality",
        v16,
        *(unsigned __int8 *)(v10 + 91 * v11 + 89),
        *(unsigned __int8 *)(v10 + 91 * v11 + 90));
LABEL_28:
      sub_385C8(3, s, 0);
      if ( byte_77B70 )
        goto LABEL_31;
    }
    if ( byte_75C48 )
      goto LABEL_31;
LABEL_30:
    if ( dword_73504 <= 3 )
      return -1;
LABEL_31:
    v29 = dword_76A2C++;
    snprintf(s, 0x1000u, "receive a error nonce. total = %u", v29);
    goto LABEL_6;
  }
  return 1;
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 76A2C: using guessed type int dword_76A2C;
// 77B70: using guessed type char byte_77B70;
// 79080: using guessed type int dword_79080;
// 79088: using guessed type int dword_79088;
// 9A4C7: using guessed type char byte_9A4C7;

//----- (00049A18) --------------------------------------------------------
void __fastcall sub_49A18(_BYTE *a1, char a2, int a3)
{
  int v5; // r0
  char s[4096]; // [sp+18h] [bp-1000h] BYREF

  v5 = sub_3C92C(a1 + 2, (unsigned __int8)(8 * a2 - 21));
  if ( (a1[8] & 0x1F) == v5 )
  {
    if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
    {
      snprintf(
        s,
        0x1000u,
        "chain[%d] asic[%d] %02x %02x %02x %02x\n",
        a3,
        (unsigned __int8)(a1[7] / (unsigned __int8)byte_9A4C7),
        (unsigned __int8)a1[3],
        (unsigned __int8)a1[4],
        (unsigned __int8)a1[5],
        (unsigned __int8)a1[6]);
      sub_385C8(7, s, 0);
    }
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(s, 0x1000u, "%s chain%d CRC error crc = %02x\n", "pm_handle", a3, v5);
    sub_385C8(3, s, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 9A4C7: using guessed type char byte_9A4C7;

//----- (00049B74) --------------------------------------------------------
void __fastcall sub_49B74(int a1, int a2, char a3)
{
  int v5; // r0
  int v6; // r3
  bool v7; // cc
  char *v8; // r1
  char *v9; // r2
  char v10; // r1
  char s[4096]; // [sp+8h] [bp-1000h] BYREF

  v5 = sub_3C92C((_BYTE *)(a1 + 2), 51);
  if ( (*(_BYTE *)(a1 + 8) & 0x1F) == v5 )
  {
    if ( (unsigned int)dword_78BC4 > 0x63 || (unsigned int)dword_78BBC > 0x63 )
    {
      if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
      {
        strcpy(s, "Will Clean!");
        sub_385C8(5, s, 0);
      }
      sub_46EEC();
    }
    else
    {
      pthread_mutex_lock(&stru_769B8);
      v6 = dword_78BBC;
      v7 = (unsigned int)dword_78BBC > 0x62;
      v8 = (char *)&dword_78BBC + 7 * dword_78BBC;
      if ( (unsigned int)dword_78BBC > 0x62 )
        v6 = 0;
      v9 = v8 + 8;
      *(_DWORD *)(v8 + 13) = *(_DWORD *)(a1 + 3);
      v8[17] = *(_BYTE *)(a1 + 7);
      v10 = *(_BYTE *)(a1 + 2);
      v9[10] = a3;
      if ( v7 )
        dword_78BBC = v6;
      v9[4] = v10;
      if ( !v7 )
      {
        if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(s, 0x1000u, "%s: p_wr = %d reg_value_num = %d", "reg_handle", v6, dword_78BC4);
          sub_385C8(7, s, 0);
          v6 = dword_78BBC;
        }
        dword_78BBC = v6 + 1;
      }
      if ( (unsigned int)dword_78BC4 > 0x63 )
      {
        dword_78BC4 = 100;
        if ( byte_77B70 || byte_75C48 || dword_73504 > 3 )
        {
          snprintf(s, 0x1000u, "%s: reg fifo full!!!", "reg_handle");
          sub_385C8(4, s, 0);
        }
      }
      else
      {
        ++dword_78BC4;
      }
      pthread_mutex_unlock(&stru_769B8);
    }
  }
  else if ( byte_77B70 || byte_75C48 || dword_73504 > 2 )
  {
    snprintf(s, 0x1000u, "%s CRC error crc = %02x\n", "reg_handle", v5);
    sub_385C8(3, s, 0);
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 77B70: using guessed type char byte_77B70;
// 78BBC: using guessed type int dword_78BBC;
// 78BC4: using guessed type int dword_78BC4;

//----- (00049DEC) --------------------------------------------------------
int *__fastcall sub_49DEC(int *a1)
{
  pthread_t v2; // r0
  int v3; // r5
  int v4; // r4
  int v5; // r12
  int *result; // r0
  int v7; // r0
  char *v8; // r3
  char v9; // t1
  int v10; // r7
  int v11; // r5
  char *v12; // r12
  unsigned __int8 *v13; // r2
  int v14; // r3
  char v15; // r1
  char *v16; // r3
  char v17; // r2
  char *v18; // r3
  char v19; // r2
  char *v20; // r3
  char v21; // r2
  int v22; // [sp+Ch] [bp-149E8h]
  char *v23; // [sp+Ch] [bp-149E8h]
  char *v24; // [sp+Ch] [bp-149E8h]
  char *v25; // [sp+Ch] [bp-149E8h]
  int v26; // [sp+10h] [bp-149E4h]
  int v27; // [sp+18h] [bp-149DCh]
  _BYTE v28[3]; // [sp+23h] [bp-149D1h] BYREF
  unsigned __int8 v29; // [sp+26h] [bp-149CEh] BYREF
  char v30; // [sp+27h] [bp-149CDh] BYREF
  _BYTE v31[95]; // [sp+28h] [bp-149CCh] BYREF
  char v32; // [sp+87h] [bp-1496Dh] BYREF
  _BYTE s[1488]; // [sp+88h] [bp-1496Ch] BYREF
  int v34; // [sp+658h] [bp-1439Ch] BYREF
  _BYTE v35[4352]; // [sp+1640h] [bp-133B4h] BYREF
  char v36[74404]; // [sp+2750h] [bp-122A4h] BYREF

  memset(s, 0, sizeof(s));
  v26 = *a1;
  v2 = pthread_self();
  pthread_detach(v2);
  if ( byte_77B70 || byte_75C48 || dword_73504 > 4 )
  {
    snprintf(v36, 0x1000u, "Start A New Asic Response.Chain Id:[%d]", v26);
    sub_385C8(5, v36, 0);
  }
  if ( byte_75C49 && (byte_77B70 || byte_75C48 || dword_73504 > 6) )
  {
    snprintf(v36, 0x1000u, "%s %d", "get_asic_response", v26);
    sub_385C8(7, v36, 0);
  }
  memset(v36, 0, (size_t)&loc_122A0);
  v3 = 0;
  memset(v31, 0, 0x5Du);
  v4 = 0;
  v5 = -84428;
LABEL_10:
  while ( 1 )
  {
    result = &dword_75C50;
    if ( !*((_BYTE *)&dword_75C50 + v26 + 776) )
      return result;
    v22 = v5;
    sub_2A8AC();
    v7 = sub_3C2F4((unsigned __int8)v26, s, 0x5D0u);
    v5 = v22;
    if ( v7 > 0 )
    {
      v8 = &v32;
      do
      {
        v9 = *++v8;
        v36[v3++] = v9;
        if ( v3 > 74399 )
          v3 = 0;
      }
      while ( v8 != &s[v7 - 1] );
    }
    if ( v3 != v4 )
    {
      v10 = v4 >= v3 ? 74400 - v4 + v3 : v3 - v4;
      if ( v10 > 2 )
      {
        v27 = v3;
        v11 = v22;
        v12 = &v31[8];
        while ( 1 )
        {
          v13 = v28;
          v29 = 0;
          v14 = v4;
          *(_WORD *)&v36[v11 + 74400] = 0;
          do
          {
            v15 = v36[v14++];
            *++v13 = v15;
            if ( v14 > 74399 )
              v14 = 0;
          }
          while ( v13 != &v29 );
          if ( (unsigned __int8)v36[v11 + 74400] == 170 && v28[2] == 85 )
          {
            if ( (v29 & 0xF0) == 0xE0 )
            {
              if ( v10 <= 92 )
                goto LABEL_29;
              v18 = &v30;
              do
              {
                v19 = v36[v4++];
                *++v18 = v19;
                if ( v4 > 74399 )
                  v4 = 0;
              }
              while ( v18 != &v31[92] );
              v24 = v12;
              sub_49464((int)&v34, (int)v35, (int)v31, 93, v26);
              v10 -= 93;
              v12 = v24;
            }
            else if ( v29 == 204 )
            {
              if ( v10 <= 8 )
              {
LABEL_29:
                v5 = v11;
                v3 = v27;
                goto LABEL_10;
              }
              v20 = &v30;
              do
              {
                v21 = v36[v4++];
                *++v20 = v21;
                if ( v4 > 74399 )
                  v4 = 0;
              }
              while ( v20 != v12 );
              v10 -= 9;
              v25 = v12;
              sub_49A18(v31, 9, (unsigned __int8)v26);
              v12 = v25;
            }
            else
            {
              if ( v10 <= 8 )
                goto LABEL_29;
              v16 = &v30;
              do
              {
                v17 = v36[v4++];
                *++v16 = v17;
                if ( v4 > 74399 )
                  v4 = 0;
              }
              while ( v16 != v12 );
              v10 -= 9;
              v23 = v12;
              sub_49B74((int)v31, 9, v26);
              v12 = v23;
            }
          }
          else
          {
            ++v4;
            --v10;
            if ( v4 > 74399 )
              v4 = 0;
          }
          if ( v10 <= 2 )
            goto LABEL_29;
        }
      }
    }
  }
}
// 73504: using guessed type int dword_73504;
// 75C48: using guessed type char byte_75C48;
// 75C49: using guessed type char byte_75C49;
// 75C50: using guessed type int dword_75C50;
// 77B70: using guessed type char byte_77B70;

//----- (0004A218) --------------------------------------------------------
int __fastcall sub_4A218(_DWORD *a1, unsigned int *a2)
{
  unsigned int v2; // r2
  unsigned int v3; // r4
  int v4; // r3
  int v5; // r12
  int v6; // r3
  int v7; // r0
  int v8; // r8
  int v9; // r2
  int v10; // r3
  int v11; // r4
  unsigned int v12; // r5
  int v13; // r12
  int v14; // r4
  int v15; // r6
  int v16; // r0
  int v17; // r8
  int v18; // r12
  int v19; // r2
  int v20; // r3
  int v21; // r5
  int v22; // r11
  int v23; // r6
  int v24; // r4
  int v25; // r10
  int v26; // r7
  int v27; // r12
  int v28; // r7
  int v29; // r3
  int v30; // r0
  int v31; // r3
  int v32; // r11
  int v33; // r8
  int v34; // r10
  int v35; // r6
  int v36; // r10
  int v37; // r5
  int v38; // r2
  int v39; // r7
  int v40; // r0
  int v41; // r3
  int v42; // r11
  int v43; // r8
  int v44; // r9
  int v45; // r4
  int v46; // r12
  int v47; // r6
  int v48; // r10
  int v49; // r1
  int v50; // r7
  int v51; // r2
  int v52; // r12
  int v53; // r3
  int v54; // r0
  int v55; // r11
  int v56; // r4
  int v57; // r8
  int v58; // r5
  int v59; // r10
  int v60; // r6
  int v61; // r9
  int v62; // r2
  int v63; // r12
  int v64; // r1
  int v65; // r11
  int v66; // r3
  int v67; // r0
  int v68; // r8
  int v69; // r5
  int v70; // r10
  int v71; // r6
  int v72; // r9
  int v73; // r7
  int v74; // r4
  int v75; // r8
  int v76; // r12
  int v77; // r6
  int v78; // r1
  int v79; // r6
  int v80; // r0
  int v81; // r3
  int v82; // r1
  int v83; // r10
  int v84; // r9
  int v85; // r7
  int v86; // r2
  int v87; // r8
  int v88; // r12
  int v89; // r3
  int v90; // r5
  int v91; // r0
  int v92; // r6
  int v93; // r10
  int v94; // r5
  int v95; // r1
  int v96; // r7
  int v97; // r2
  int v98; // r4
  int v99; // r7
  int v100; // r12
  int v101; // r3
  int v102; // r7
  int v103; // r0
  int v104; // r6
  int v105; // r10
  int v106; // r1
  int v107; // r5
  int v108; // r10
  int v109; // r2
  int v110; // r4
  int v111; // r7
  int v112; // r12
  int v113; // r3
  int v114; // r6
  int v115; // r10
  int v116; // r0
  int v117; // r7
  int v118; // r1
  int v119; // r6
  int v120; // r5
  int v121; // r8
  int v122; // r2
  int v123; // r4
  int v124; // r12
  int v125; // r3
  int v126; // r5
  int v127; // r0
  int v128; // r10
  int v129; // r5
  int v130; // r1
  int v131; // r6
  int v132; // r4
  int v133; // r2
  int v134; // r8
  int v135; // r5
  int v136; // r12
  int v137; // r3
  int v138; // r10
  int v139; // r0
  int v140; // r7
  int v141; // r5
  int v142; // r1
  int v143; // r6
  unsigned int v144; // r9
  int v145; // r10
  int v146; // r2
  int v147; // r4
  int v148; // r5
  int v149; // r3
  int v150; // r12
  int v151; // r8
  int v152; // r7
  int v153; // r0
  int v154; // r5
  int v155; // r6
  int v156; // r1
  int v157; // r5
  int v158; // r4
  int v159; // r2
  int v160; // r5
  int v161; // r12
  int v162; // r3
  int v163; // r8
  int v164; // r0
  int v165; // r6
  unsigned int v166; // r5
  int v167; // r1
  int v168; // r9
  unsigned int v169; // r4
  int v170; // r2
  int v171; // r12
  int v172; // r3
  unsigned int v173; // r5
  int v174; // r0
  int v175; // r6
  int v176; // r0
  unsigned int v177; // r11
  int v178; // r12
  int v179; // r6
  int v180; // r1
  unsigned int v181; // r5
  int v182; // r4
  int v183; // r9
  int v184; // r2
  int v185; // r12
  int v186; // r4
  int v187; // r12
  int v188; // r5
  int result; // r0
  int v190; // [sp+4h] [bp-6Ch]
  int v191; // [sp+8h] [bp-68h]
  int v192; // [sp+Ch] [bp-64h]
  int v193; // [sp+10h] [bp-60h]
  int v194; // [sp+14h] [bp-5Ch]
  int v195; // [sp+18h] [bp-58h]
  int v196; // [sp+1Ch] [bp-54h]
  int v197; // [sp+20h] [bp-50h]
  int v198; // [sp+24h] [bp-4Ch]
  int v199; // [sp+24h] [bp-4Ch]
  int v200; // [sp+24h] [bp-4Ch]
  unsigned int v201; // [sp+24h] [bp-4Ch]
  unsigned int v202; // [sp+24h] [bp-4Ch]
  int v203; // [sp+24h] [bp-4Ch]
  int v204; // [sp+24h] [bp-4Ch]
  unsigned int v205; // [sp+28h] [bp-48h]
  int v206; // [sp+28h] [bp-48h]
  int v207; // [sp+28h] [bp-48h]
  unsigned int v208; // [sp+28h] [bp-48h]
  unsigned int v209; // [sp+28h] [bp-48h]
  unsigned int v210; // [sp+28h] [bp-48h]
  int v211; // [sp+2Ch] [bp-44h]
  int v212; // [sp+2Ch] [bp-44h]
  int v213; // [sp+2Ch] [bp-44h]
  unsigned int v214; // [sp+2Ch] [bp-44h]
  unsigned int v215; // [sp+2Ch] [bp-44h]
  unsigned int v216; // [sp+2Ch] [bp-44h]
  int v217; // [sp+30h] [bp-40h]
  unsigned int v218; // [sp+30h] [bp-40h]
  unsigned int v219; // [sp+30h] [bp-40h]
  unsigned int v220; // [sp+30h] [bp-40h]
  int v221; // [sp+30h] [bp-40h]
  unsigned int v222; // [sp+34h] [bp-3Ch]
  unsigned int v223; // [sp+34h] [bp-3Ch]
  unsigned int v224; // [sp+34h] [bp-3Ch]
  unsigned int v225; // [sp+34h] [bp-3Ch]
  int v226; // [sp+34h] [bp-3Ch]
  unsigned int v227; // [sp+38h] [bp-38h]
  unsigned int v228; // [sp+38h] [bp-38h]
  unsigned int v229; // [sp+38h] [bp-38h]
  int v230; // [sp+38h] [bp-38h]
  unsigned int v231; // [sp+3Ch] [bp-34h]
  unsigned int v232; // [sp+3Ch] [bp-34h]
  unsigned int v233; // [sp+3Ch] [bp-34h]
  unsigned int v234; // [sp+3Ch] [bp-34h]
  unsigned int v235; // [sp+40h] [bp-30h]
  unsigned int v236; // [sp+40h] [bp-30h]
  unsigned int v237; // [sp+40h] [bp-30h]
  unsigned int v238; // [sp+40h] [bp-30h]
  unsigned int v239; // [sp+44h] [bp-2Ch]
  unsigned int v240; // [sp+44h] [bp-2Ch]
  unsigned int v241; // [sp+44h] [bp-2Ch]
  unsigned int v242; // [sp+44h] [bp-2Ch]
  unsigned int v243; // [sp+48h] [bp-28h]
  unsigned int v244; // [sp+48h] [bp-28h]
  unsigned int v245; // [sp+48h] [bp-28h]
  unsigned int v246; // [sp+48h] [bp-28h]
  unsigned int v247; // [sp+4Ch] [bp-24h]
  unsigned int v248; // [sp+4Ch] [bp-24h]
  unsigned int v249; // [sp+4Ch] [bp-24h]
  unsigned int v250; // [sp+4Ch] [bp-24h]
  unsigned int v251; // [sp+50h] [bp-20h]
  unsigned int v252; // [sp+50h] [bp-20h]
  unsigned int v253; // [sp+50h] [bp-20h]
  unsigned int v254; // [sp+54h] [bp-1Ch]
  unsigned int v255; // [sp+54h] [bp-1Ch]
  unsigned int v256; // [sp+54h] [bp-1Ch]
  unsigned int v257; // [sp+58h] [bp-18h]
  unsigned int v258; // [sp+58h] [bp-18h]
  unsigned int v259; // [sp+58h] [bp-18h]
  unsigned int v260; // [sp+5Ch] [bp-14h]
  unsigned int v261; // [sp+5Ch] [bp-14h]
  unsigned int v262; // [sp+5Ch] [bp-14h]
  unsigned int v263; // [sp+60h] [bp-10h]
  unsigned int v264; // [sp+60h] [bp-10h]
  unsigned int v265; // [sp+60h] [bp-10h]
  unsigned int v267; // [sp+68h] [bp-8h]
  unsigned int v268; // [sp+68h] [bp-8h]
  unsigned int v269; // [sp+6Ch] [bp-4h]

  v193 = a1[6];
  v191 = a1[8];
  v197 = a1[2];
  v192 = a1[7];
  v196 = a1[3];
  v195 = a1[4];
  v190 = a1[9];
  v269 = _byteswap_ulong(*a2);
  v2 = v190
     + 1116352408
     + (__ROR4__(v193, 6) ^ __ROR4__(v193, 11) ^ __ROR4__(v193, 25))
     + ((v191 ^ v192) & v193 ^ v191)
     + v269;
  v3 = v2 + a1[5];
  v205 = ((v196 | v197) & v195 | v196 & v197) + (__ROR4__(v197, 2) ^ __ROR4__(v197, 13) ^ __ROR4__(v197, 22)) + v2;
  v222 = _byteswap_ulong(a2[1]);
  v194 = a1[5];
  v4 = v191 + 1899447441 + v222 + (v3 & (v192 ^ v193) ^ v192) + (__ROR4__(v3, 6) ^ __ROR4__(v3, 11) ^ __ROR4__(v3, 25));
  v5 = v4 + v195;
  v227 = _byteswap_ulong(a2[2]);
  v211 = ((v205 | v197) & v196 | v205 & v197) + (__ROR4__(v205, 2) ^ __ROR4__(v205, 13) ^ __ROR4__(v205, 22)) + v4;
  v6 = v192 - 1245643825 + v227 + (v5 & (v3 ^ v193) ^ v193) + (__ROR4__(v5, 6) ^ __ROR4__(v5, 11) ^ __ROR4__(v5, 25));
  v7 = v6 + v196;
  v198 = ((v211 | v205) & v197 | v211 & v205) + (__ROR4__(v211, 2) ^ __ROR4__(v211, 13) ^ __ROR4__(v211, 22)) + v6;
  v231 = _byteswap_ulong(a2[3]);
  v8 = v193 - 373957723 + v231 + (v7 & (v5 ^ v3) ^ v3) + (__ROR4__(v7, 6) ^ __ROR4__(v7, 11) ^ __ROR4__(v7, 25));
  v235 = _byteswap_ulong(a2[4]);
  v9 = v8 + v197;
  v10 = ((v198 | v211) & v205 | v198 & v211) + (__ROR4__(v198, 2) ^ __ROR4__(v198, 13) ^ __ROR4__(v198, 22)) + v8;
  v11 = v235
      + 961987163
      + v3
      + ((v8 + v197) & (v7 ^ v5) ^ v5)
      + (__ROR4__(v8 + v197, 6) ^ __ROR4__(v8 + v197, 11) ^ __ROR4__(v8 + v197, 25));
  v12 = v11 + v205;
  v206 = ((v10 | v198) & v211 | v10 & v198) + (__ROR4__(v10, 2) ^ __ROR4__(v10, 13) ^ __ROR4__(v10, 22)) + v11;
  v239 = _byteswap_ulong(a2[5]);
  v13 = v239
      + 1508970993
      + v5
      + (v12 & ((v8 + v197) ^ v7) ^ v7)
      + (__ROR4__(v12, 6) ^ __ROR4__(v12, 11) ^ __ROR4__(v12, 25));
  v14 = v211;
  v212 = ((v206 | v10) & v198 | v206 & v10) + (__ROR4__(v206, 2) ^ __ROR4__(v206, 13) ^ __ROR4__(v206, 22)) + v13;
  v243 = _byteswap_ulong(a2[6]);
  v15 = v13 + v14;
  v16 = v243
      - 1841331548
      + v7
      + (v15 & (v12 ^ v9) ^ v9)
      + (__ROR4__(v13 + v14, 6) ^ __ROR4__(v13 + v14, 11) ^ __ROR4__(v15, 25));
  v17 = v198;
  v199 = ((v212 | v206) & v10 | v212 & v206) + (__ROR4__(v212, 2) ^ __ROR4__(v212, 13) ^ __ROR4__(v212, 22)) + v16;
  v18 = v16 + v17;
  v247 = _byteswap_ulong(a2[7]);
  v19 = v247
      - 1424204075
      + v9
      + (v18 & (v15 ^ v12) ^ v12)
      + (__ROR4__(v16 + v17, 6) ^ __ROR4__(v16 + v17, 11) ^ __ROR4__(v18, 25));
  v20 = v19 + v10;
  v217 = ((v199 | v212) & v206 | v199 & v212) + (__ROR4__(v199, 2) ^ __ROR4__(v199, 13) ^ __ROR4__(v199, 22)) + v19;
  v267 = _byteswap_ulong(a2[8]);
  v21 = v267
      - 670586216
      + v12
      + (v20 & ((v16 + v17) ^ v15) ^ v15)
      + (__ROR4__(v20, 6) ^ __ROR4__(v20, 11) ^ __ROR4__(v20, 25));
  v22 = v21 + v206;
  v207 = ((v217 | v199) & v212 | v217 & v199) + (__ROR4__(v217, 2) ^ __ROR4__(v217, 13) ^ __ROR4__(v217, 22)) + v21;
  v251 = _byteswap_ulong(a2[9]);
  v23 = v251 + 310598401 + v15 + (v22 & (v20 ^ v18) ^ v18) + (__ROR4__(v22, 6) ^ __ROR4__(v22, 11) ^ __ROR4__(v22, 25));
  v24 = v212;
  v213 = ((v207 | v217) & v199 | v207 & v217) + (__ROR4__(v207, 2) ^ __ROR4__(v207, 13) ^ __ROR4__(v207, 22)) + v23;
  v25 = v23 + v24;
  v254 = _byteswap_ulong(a2[10]);
  v26 = v254
      + 607225278
      + v16
      + v17
      + (v25 & (v22 ^ v20) ^ v20)
      + (__ROR4__(v25, 6) ^ __ROR4__(v25, 11) ^ __ROR4__(v25, 25));
  v257 = _byteswap_ulong(a2[11]);
  v27 = v26 + v199;
  v28 = ((v213 | v207) & v217 | v213 & v207) + (__ROR4__(v213, 2) ^ __ROR4__(v213, 13) ^ __ROR4__(v213, 22)) + v26;
  v29 = v257
      + 1426881987
      + v20
      + (v27 & ((v23 + v24) ^ v22) ^ v22)
      + (__ROR4__(v27, 6) ^ __ROR4__(v27, 11) ^ __ROR4__(v27, 25));
  v30 = v29 + v217;
  v31 = ((v28 | v213) & v207 | v28 & v213) + (__ROR4__(v28, 2) ^ __ROR4__(v28, 13) ^ __ROR4__(v28, 22)) + v29;
  v260 = _byteswap_ulong(a2[12]);
  v32 = v260 + 1925078388 + v22 + (v30 & (v27 ^ v25) ^ v25) + (__ROR4__(v30, 6) ^ __ROR4__(v30, 11) ^ __ROR4__(v30, 25));
  v33 = v32 + v207;
  v200 = ((v31 | v28) & v213 | v31 & v28) + (__ROR4__(v31, 2) ^ __ROR4__(v31, 13) ^ __ROR4__(v31, 22)) + v32;
  v263 = _byteswap_ulong(a2[13]);
  v34 = v263
      - 2132889090
      + v23
      + v24
      + ((v32 + v207) & (v30 ^ v27) ^ v27)
      + (__ROR4__(v32 + v207, 6) ^ __ROR4__(v32 + v207, 11) ^ __ROR4__(v32 + v207, 25));
  v208 = _byteswap_ulong(a2[14]);
  v35 = v34 + v213;
  v36 = ((v200 | v31) & v28 | v200 & v31) + (__ROR4__(v200, 2) ^ __ROR4__(v200, 13) ^ __ROR4__(v200, 22)) + v34;
  v37 = v208 - 1680079193 + v27 + (v35 & (v33 ^ v30) ^ v30) + (__ROR4__(v35, 6) ^ __ROR4__(v35, 11) ^ __ROR4__(v35, 25));
  v214 = _byteswap_ulong(a2[15]);
  v38 = ((v36 | v200) & v31 | v36 & v200) + (__ROR4__(v36, 2) ^ __ROR4__(v36, 13) ^ __ROR4__(v36, 22)) + v37;
  v39 = v37 + v28;
  v40 = v214 - 1046744716 + v30 + (v39 & (v35 ^ v33) ^ v33) + (__ROR4__(v39, 6) ^ __ROR4__(v39, 11) ^ __ROR4__(v39, 25));
  v41 = v40 + v31;
  v218 = v251
       + v269
       + (__ROR4__(v208, 17) ^ __ROR4__(v208, 19) ^ (v208 >> 10))
       + (__ROR4__(v222, 7) ^ __ROR4__(v222, 18) ^ (v222 >> 3));
  v42 = ((v38 | v36) & v200 | v38 & v36) + (__ROR4__(v38, 2) ^ __ROR4__(v38, 13) ^ __ROR4__(v38, 22)) + v40;
  v43 = v218 - 459576895 + v33 + (v41 & (v39 ^ v35) ^ v35) + (__ROR4__(v41, 6) ^ __ROR4__(v41, 11) ^ __ROR4__(v41, 25));
  v44 = ((v42 | v38) & v36 | v42 & v38) + (__ROR4__(v42, 2) ^ __ROR4__(v42, 13) ^ __ROR4__(v42, 22)) + v43;
  v45 = v43 + v200;
  v46 = __ROR4__(v43 + v200, 6);
  v201 = v254
       + v222
       + (__ROR4__(v214, 17) ^ __ROR4__(v214, 19) ^ (v214 >> 10))
       + (__ROR4__(v227, 7) ^ __ROR4__(v227, 18) ^ (v227 >> 3));
  v47 = v201 - 272742522 + v35 + (v45 & (v41 ^ v39) ^ v39) + (v46 ^ __ROR4__(v45, 11) ^ __ROR4__(v45, 25));
  v48 = v47 + v36;
  v49 = ((v44 | v42) & v38 | v44 & v42) + (__ROR4__(v44, 2) ^ __ROR4__(v44, 13) ^ __ROR4__(v44, 22)) + v47;
  v223 = v257
       + v227
       + (__ROR4__(v231, 7) ^ __ROR4__(v231, 18) ^ (v231 >> 3))
       + (__ROR4__(v218, 17) ^ __ROR4__(v218, 19) ^ (v218 >> 10));
  v50 = v223 + 264347078 + v39 + (v48 & (v45 ^ v41) ^ v41) + (__ROR4__(v48, 6) ^ __ROR4__(v48, 11) ^ __ROR4__(v48, 25));
  v51 = v50 + v38;
  v52 = ((v49 | v44) & v42 | v49 & v44) + (__ROR4__(v49, 2) ^ __ROR4__(v49, 13) ^ __ROR4__(v49, 22)) + v50;
  v228 = v260
       + v231
       + (__ROR4__(v235, 7) ^ __ROR4__(v235, 18) ^ (v235 >> 3))
       + (__ROR4__(v201, 17) ^ __ROR4__(v201, 19) ^ (v201 >> 10));
  v53 = v228 + 604807628 + v41 + (v51 & (v48 ^ v45) ^ v45) + (__ROR4__(v51, 6) ^ __ROR4__(v51, 11) ^ __ROR4__(v51, 25));
  v54 = ((v52 | v49) & v44 | v52 & v49) + (__ROR4__(v52, 2) ^ __ROR4__(v52, 13) ^ __ROR4__(v52, 22)) + v53;
  v55 = v53 + v42;
  v232 = v263
       + v235
       + (__ROR4__(v239, 7) ^ __ROR4__(v239, 18) ^ (v239 >> 3))
       + (__ROR4__(v223, 17) ^ __ROR4__(v223, 19) ^ (v223 >> 10));
  v56 = v232 + 770255983 + v45 + (v55 & (v51 ^ v48) ^ v48) + (__ROR4__(v55, 6) ^ __ROR4__(v55, 11) ^ __ROR4__(v55, 25));
  v57 = v56 + v44;
  v58 = ((v54 | v52) & v49 | v54 & v52) + (__ROR4__(v54, 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + v56;
  v236 = v208
       + v239
       + (__ROR4__(v243, 7) ^ __ROR4__(v243, 18) ^ (v243 >> 3))
       + (__ROR4__(v228, 17) ^ __ROR4__(v228, 19) ^ (v228 >> 10));
  v59 = v236 + 1249150122 + v48 + (v57 & (v55 ^ v51) ^ v51) + (__ROR4__(v57, 6) ^ __ROR4__(v57, 11) ^ __ROR4__(v57, 25));
  v60 = v59 + v49;
  v61 = ((v58 | v54) & v52 | v58 & v54) + (__ROR4__(v58, 2) ^ __ROR4__(v58, 13) ^ __ROR4__(v58, 22)) + v59;
  v240 = v214
       + v243
       + (__ROR4__(v247, 7) ^ __ROR4__(v247, 18) ^ (v247 >> 3))
       + (__ROR4__(v232, 17) ^ __ROR4__(v232, 19) ^ (v232 >> 10));
  v62 = v240 + 1555081692 + v51 + (v60 & (v57 ^ v55) ^ v55) + (__ROR4__(v60, 6) ^ __ROR4__(v60, 11) ^ __ROR4__(v60, 25));
  v63 = v62 + v52;
  v64 = ((v61 | v58) & v54 | v61 & v58) + (__ROR4__(v61, 2) ^ __ROR4__(v61, 13) ^ __ROR4__(v61, 22)) + v62;
  v244 = (__ROR4__(v267, 7) ^ __ROR4__(v267, 18) ^ (v267 >> 3))
       + v247
       + v218
       + (__ROR4__(v236, 17) ^ __ROR4__(v236, 19) ^ (v236 >> 10));
  v65 = v244 + 1996064986 + v55 + (v63 & (v60 ^ v57) ^ v57) + (__ROR4__(v63, 6) ^ __ROR4__(v63, 11) ^ __ROR4__(v63, 25));
  v66 = ((v64 | v61) & v58 | v64 & v61) + (__ROR4__(v64, 2) ^ __ROR4__(v64, 13) ^ __ROR4__(v64, 22)) + v65;
  v67 = v65 + v54;
  v248 = (__ROR4__(v251, 7) ^ __ROR4__(v251, 18) ^ (v251 >> 3))
       + v267
       + v201
       + (__ROR4__(v240, 17) ^ __ROR4__(v240, 19) ^ (v240 >> 10));
  v68 = v248 - 1740746414 + v57 + (v67 & (v63 ^ v60) ^ v60) + (__ROR4__(v67, 6) ^ __ROR4__(v67, 11) ^ __ROR4__(v67, 25));
  v69 = v68 + v58;
  v70 = ((v66 | v64) & v61 | v66 & v64) + (__ROR4__(v66, 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + v68;
  v252 = (__ROR4__(v254, 7) ^ __ROR4__(v254, 18) ^ (v254 >> 3))
       + v251
       + v223
       + (__ROR4__(v244, 17) ^ __ROR4__(v244, 19) ^ (v244 >> 10));
  v71 = v252 - 1473132947 + v60 + (v69 & (v67 ^ v63) ^ v63) + (__ROR4__(v69, 6) ^ __ROR4__(v69, 11) ^ __ROR4__(v69, 25));
  v72 = v71 + v61;
  v73 = ((v70 | v66) & v64 | v70 & v66) + (__ROR4__(v70, 2) ^ __ROR4__(v70, 13) ^ __ROR4__(v70, 22)) + v71;
  v255 = (__ROR4__(v257, 7) ^ __ROR4__(v257, 18) ^ (v257 >> 3))
       + v254
       + v228
       + (__ROR4__(v248, 17) ^ __ROR4__(v248, 19) ^ (v248 >> 10));
  v74 = v255 - 1341970488 + v63 + (v72 & (v69 ^ v67) ^ v67) + (__ROR4__(v72, 6) ^ __ROR4__(v72, 11) ^ __ROR4__(v72, 25));
  v75 = v74 + v64;
  v76 = ((v73 | v70) & v66 | v73 & v70) + (__ROR4__(v73, 2) ^ __ROR4__(v73, 13) ^ __ROR4__(v73, 22)) + v74;
  v77 = (__ROR4__(v260, 7) ^ __ROR4__(v260, 18) ^ (v260 >> 3))
      + v257
      + v232
      + (__ROR4__(v252, 17) ^ __ROR4__(v252, 19) ^ (v252 >> 10));
  v78 = v77
      - 1084653625
      + v67
      + ((v74 + v64) & (v72 ^ v69) ^ v69)
      + (__ROR4__(v74 + v64, 6) ^ __ROR4__(v75, 11) ^ __ROR4__(v75, 25));
  v258 = v77;
  v79 = v78 + v66;
  v80 = ((v76 | v73) & v70 | v76 & v73) + (__ROR4__(v76, 2) ^ __ROR4__(v76, 13) ^ __ROR4__(v76, 22)) + v78;
  v261 = (__ROR4__(v263, 7) ^ __ROR4__(v263, 18) ^ (v263 >> 3))
       + v260
       + v236
       + (__ROR4__(v255, 17) ^ __ROR4__(v255, 19) ^ (v255 >> 10));
  v81 = v261 - 958395405 + v69 + (v79 & (v75 ^ v72) ^ v72) + (__ROR4__(v79, 6) ^ __ROR4__(v79, 11) ^ __ROR4__(v79, 25));
  v82 = ((v80 | v76) & v73 | v80 & v76) + (__ROR4__(v80, 2) ^ __ROR4__(v80, 13) ^ __ROR4__(v80, 22)) + v81;
  v83 = v81 + v70;
  v264 = (__ROR4__(v208, 7) ^ __ROR4__(v208, 18) ^ (v208 >> 3))
       + v263
       + v240
       + (__ROR4__(v258, 17) ^ __ROR4__(v258, 19) ^ (v258 >> 10));
  v84 = v264 - 710438585 + v72 + (v83 & (v79 ^ v75) ^ v75) + (__ROR4__(v83, 6) ^ __ROR4__(v83, 11) ^ __ROR4__(v83, 25));
  v85 = v84 + v73;
  v86 = ((v82 | v80) & v76 | v82 & v80) + (__ROR4__(v82, 2) ^ __ROR4__(v82, 13) ^ __ROR4__(v82, 22)) + v84;
  v209 = (__ROR4__(v214, 7) ^ __ROR4__(v214, 18) ^ (v214 >> 3))
       + v208
       + v244
       + (__ROR4__(v261, 17) ^ __ROR4__(v261, 19) ^ (v261 >> 10));
  v87 = v209 + 113926993 + v75 + (v85 & (v83 ^ v79) ^ v79) + (__ROR4__(v85, 6) ^ __ROR4__(v85, 11) ^ __ROR4__(v85, 25));
  v88 = v87 + v76;
  v89 = ((v86 | v82) & v80 | v86 & v82) + (__ROR4__(v86, 2) ^ __ROR4__(v86, 13) ^ __ROR4__(v86, 22)) + v87;
  v215 = (__ROR4__(v218, 7) ^ __ROR4__(v218, 18) ^ (v218 >> 3))
       + v214
       + v248
       + (__ROR4__(v264, 17) ^ __ROR4__(v264, 19) ^ (v264 >> 10));
  v90 = v215 + 338241895 + v79 + (v88 & (v85 ^ v83) ^ v83) + (__ROR4__(v88, 6) ^ __ROR4__(v88, 11) ^ __ROR4__(v88, 25));
  v91 = v90 + v80;
  v92 = ((v89 | v86) & v82 | v89 & v86) + (__ROR4__(v89, 2) ^ __ROR4__(v89, 13) ^ __ROR4__(v89, 22)) + v90;
  v219 = (__ROR4__(v201, 7) ^ __ROR4__(v201, 18) ^ (v201 >> 3))
       + v218
       + v252
       + (__ROR4__(v209, 17) ^ __ROR4__(v209, 19) ^ (v209 >> 10));
  v93 = v219 + 666307205 + v83 + (v91 & (v88 ^ v85) ^ v85) + (__ROR4__(v91, 6) ^ __ROR4__(v91, 11) ^ __ROR4__(v91, 25));
  v94 = ((v92 | v89) & v86 | v92 & v89) + (__ROR4__(v92, 2) ^ __ROR4__(v92, 13) ^ __ROR4__(v92, 22)) + v93;
  v202 = (__ROR4__(v223, 7) ^ __ROR4__(v223, 18) ^ (v223 >> 3))
       + v201
       + v255
       + (__ROR4__(v215, 17) ^ __ROR4__(v215, 19) ^ (v215 >> 10));
  v95 = v93 + v82;
  v96 = v202 + 773529912 + v85 + (v95 & (v91 ^ v88) ^ v88) + (__ROR4__(v95, 6) ^ __ROR4__(v95, 11) ^ __ROR4__(v95, 25));
  v97 = v96 + v86;
  v98 = ((v94 | v92) & v89 | v94 & v92) + (__ROR4__(v94, 2) ^ __ROR4__(v94, 13) ^ __ROR4__(v94, 22)) + v96;
  v224 = (__ROR4__(v228, 7) ^ __ROR4__(v228, 18) ^ (v228 >> 3))
       + v223
       + v258
       + (__ROR4__(v219, 17) ^ __ROR4__(v219, 19) ^ (v219 >> 10));
  v99 = v224 + 1294757372 + v88 + (v97 & (v95 ^ v91) ^ v91) + (__ROR4__(v97, 6) ^ __ROR4__(v97, 11) ^ __ROR4__(v97, 25));
  v100 = ((v98 | v94) & v92 | v98 & v94) + (__ROR4__(v98, 2) ^ __ROR4__(v98, 13) ^ __ROR4__(v98, 22)) + v99;
  v101 = v99 + v89;
  v229 = (__ROR4__(v232, 7) ^ __ROR4__(v232, 18) ^ (v232 >> 3))
       + v228
       + v261
       + (__ROR4__(v202, 17) ^ __ROR4__(v202, 19) ^ (v202 >> 10));
  v102 = v229
       + 1396182291
       + v91
       + (v101 & (v97 ^ v95) ^ v95)
       + (__ROR4__(v101, 6) ^ __ROR4__(v101, 11) ^ __ROR4__(v101, 25));
  v103 = ((v100 | v98) & v94 | v100 & v98) + (__ROR4__(v100, 2) ^ __ROR4__(v100, 13) ^ __ROR4__(v100, 22)) + v102;
  v104 = v102 + v92;
  v233 = (__ROR4__(v236, 7) ^ __ROR4__(v236, 18) ^ (v236 >> 3))
       + v232
       + v264
       + (__ROR4__(v224, 17) ^ __ROR4__(v224, 19) ^ (v224 >> 10));
  v105 = v233
       + 1695183700
       + v95
       + (v104 & (v101 ^ v97) ^ v97)
       + (__ROR4__(v104, 6) ^ __ROR4__(v104, 11) ^ __ROR4__(v104, 25));
  v106 = ((v103 | v100) & v98 | v103 & v100) + (__ROR4__(v103, 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + v105;
  v107 = v105 + v94;
  v237 = (__ROR4__(v240, 7) ^ __ROR4__(v240, 18) ^ (v240 >> 3))
       + v236
       + v209
       + (__ROR4__(v229, 17) ^ __ROR4__(v229, 19) ^ (v229 >> 10));
  v108 = v237
       + 1986661051
       + v97
       + (v107 & (v104 ^ v101) ^ v101)
       + (__ROR4__(v107, 6) ^ __ROR4__(v107, 11) ^ __ROR4__(v107, 25));
  v109 = ((v106 | v103) & v100 | v106 & v103) + (__ROR4__(v106, 2) ^ __ROR4__(v106, 13) ^ __ROR4__(v106, 22)) + v108;
  v110 = v108 + v98;
  v241 = (__ROR4__(v244, 7) ^ __ROR4__(v244, 18) ^ (v244 >> 3))
       + v240
       + v215
       + (__ROR4__(v233, 17) ^ __ROR4__(v233, 19) ^ (v233 >> 10));
  v111 = v241
       - 2117940946
       + v101
       + (v110 & (v107 ^ v104) ^ v104)
       + (__ROR4__(v110, 6) ^ __ROR4__(v110, 11) ^ __ROR4__(v110, 25));
  v112 = v111 + v100;
  v113 = ((v109 | v106) & v103 | v109 & v106) + (__ROR4__(v109, 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22)) + v111;
  v245 = (__ROR4__(v248, 7) ^ __ROR4__(v248, 18) ^ (v248 >> 3))
       + v244
       + v219
       + (__ROR4__(v237, 17) ^ __ROR4__(v237, 19) ^ (v237 >> 10));
  v114 = v245
       - 1838011259
       + v104
       + (v112 & (v110 ^ v107) ^ v107)
       + (__ROR4__(v112, 6) ^ __ROR4__(v112, 11) ^ __ROR4__(v112, 25));
  v115 = ((v113 | v109) & v106 | v113 & v109) + (__ROR4__(v113, 2) ^ __ROR4__(v113, 13) ^ __ROR4__(v113, 22)) + v114;
  v116 = v114 + v103;
  v249 = (__ROR4__(v252, 7) ^ __ROR4__(v252, 18) ^ (v252 >> 3))
       + v248
       + v202
       + (__ROR4__(v241, 17) ^ __ROR4__(v241, 19) ^ (v241 >> 10));
  v117 = v249
       - 1564481375
       + v107
       + (v116 & (v112 ^ v110) ^ v110)
       + (__ROR4__(v116, 6) ^ __ROR4__(v116, 11) ^ __ROR4__(v116, 25));
  v118 = v117 + v106;
  v119 = ((v115 | v113) & v109 | v115 & v113) + (__ROR4__(v115, 2) ^ __ROR4__(v115, 13) ^ __ROR4__(v115, 22)) + v117;
  v253 = (__ROR4__(v255, 7) ^ __ROR4__(v255, 18) ^ (v255 >> 3))
       + v252
       + v224
       + (__ROR4__(v245, 17) ^ __ROR4__(v245, 19) ^ (v245 >> 10));
  v120 = v253
       - 1474664885
       + v110
       + (v118 & (v116 ^ v112) ^ v112)
       + (__ROR4__(v118, 6) ^ __ROR4__(v118, 11) ^ __ROR4__(v118, 25));
  v121 = ((v119 | v115) & v113 | v119 & v115) + (__ROR4__(v119, 2) ^ __ROR4__(v119, 13) ^ __ROR4__(v119, 22)) + v120;
  v122 = v120 + v109;
  v256 = (__ROR4__(v258, 7) ^ __ROR4__(v258, 18) ^ (v258 >> 3))
       + v255
       + v229
       + (__ROR4__(v249, 17) ^ __ROR4__(v249, 19) ^ (v249 >> 10));
  v123 = v256
       - 1035236496
       + v112
       + (v122 & (v118 ^ v116) ^ v116)
       + (__ROR4__(v122, 6) ^ __ROR4__(v122, 11) ^ __ROR4__(v122, 25));
  v124 = ((v121 | v119) & v115 | v121 & v119) + (__ROR4__(v121, 2) ^ __ROR4__(v121, 13) ^ __ROR4__(v121, 22)) + v123;
  v125 = v123 + v113;
  v259 = (__ROR4__(v261, 7) ^ __ROR4__(v261, 18) ^ (v261 >> 3))
       + v258
       + v233
       + (__ROR4__(v253, 17) ^ __ROR4__(v253, 19) ^ (v253 >> 10));
  v126 = v259
       - 949202525
       + v116
       + (v125 & (v122 ^ v118) ^ v118)
       + (__ROR4__(v125, 6) ^ __ROR4__(v125, 11) ^ __ROR4__(v125, 25));
  v127 = ((v124 | v121) & v119 | v124 & v121) + (__ROR4__(v124, 2) ^ __ROR4__(v124, 13) ^ __ROR4__(v124, 22)) + v126;
  v128 = v126 + v115;
  v262 = (__ROR4__(v264, 7) ^ __ROR4__(v264, 18) ^ (v264 >> 3))
       + v261
       + v237
       + (__ROR4__(v256, 17) ^ __ROR4__(v256, 19) ^ (v256 >> 10));
  v129 = v262
       - 778901479
       + v118
       + (v128 & (v125 ^ v122) ^ v122)
       + (__ROR4__(v128, 6) ^ __ROR4__(v128, 11) ^ __ROR4__(v128, 25));
  v130 = ((v127 | v124) & v121 | v127 & v124) + (__ROR4__(v127, 2) ^ __ROR4__(v127, 13) ^ __ROR4__(v127, 22)) + v129;
  v131 = v129 + v119;
  v265 = (__ROR4__(v209, 7) ^ __ROR4__(v209, 18) ^ (v209 >> 3))
       + v264
       + v241
       + (__ROR4__(v259, 17) ^ __ROR4__(v259, 19) ^ (v259 >> 10));
  v132 = v265
       - 694614492
       + v122
       + (v131 & (v128 ^ v125) ^ v125)
       + (__ROR4__(v131, 6) ^ __ROR4__(v131, 11) ^ __ROR4__(v131, 25));
  v133 = ((v130 | v127) & v124 | v130 & v127) + (__ROR4__(v130, 2) ^ __ROR4__(v130, 13) ^ __ROR4__(v130, 22)) + v132;
  v134 = v132 + v121;
  v210 = (__ROR4__(v215, 7) ^ __ROR4__(v215, 18) ^ (v215 >> 3))
       + v209
       + v245
       + (__ROR4__(v262, 17) ^ __ROR4__(v262, 19) ^ (v262 >> 10));
  v135 = v210
       - 200395387
       + v125
       + (v134 & (v131 ^ v128) ^ v128)
       + (__ROR4__(v134, 6) ^ __ROR4__(v134, 11) ^ __ROR4__(v134, 25));
  v136 = v135 + v124;
  v137 = ((v133 | v130) & v127 | v133 & v130) + (__ROR4__(v133, 2) ^ __ROR4__(v133, 13) ^ __ROR4__(v133, 22)) + v135;
  v216 = (__ROR4__(v219, 7) ^ __ROR4__(v219, 18) ^ (v219 >> 3))
       + v215
       + v249
       + (__ROR4__(v265, 17) ^ __ROR4__(v265, 19) ^ (v265 >> 10));
  v138 = v216
       + 275423344
       + v128
       + (v136 & (v134 ^ v131) ^ v131)
       + (__ROR4__(v136, 6) ^ __ROR4__(v136, 11) ^ __ROR4__(v136, 25));
  v139 = v138 + v127;
  v140 = ((v137 | v133) & v130 | v137 & v133) + (__ROR4__(v137, 2) ^ __ROR4__(v137, 13) ^ __ROR4__(v137, 22)) + v138;
  v268 = (__ROR4__(v202, 7) ^ __ROR4__(v202, 18) ^ (v202 >> 3))
       + v219
       + v253
       + (__ROR4__(v210, 17) ^ __ROR4__(v210, 19) ^ (v210 >> 10));
  v141 = v268
       + 430227734
       + v131
       + (v139 & (v136 ^ v134) ^ v134)
       + (__ROR4__(v139, 6) ^ __ROR4__(v139, 11) ^ __ROR4__(v139, 25));
  v142 = v141 + v130;
  v143 = ((v140 | v137) & v133 | v140 & v137) + (__ROR4__(v140, 2) ^ __ROR4__(v140, 13) ^ __ROR4__(v140, 22)) + v141;
  v144 = (__ROR4__(v224, 7) ^ __ROR4__(v224, 18) ^ (v224 >> 3))
       + v202
       + v256
       + (__ROR4__(v216, 17) ^ __ROR4__(v216, 19) ^ (v216 >> 10));
  v145 = v144
       + 506948616
       + v134
       + (v142 & (v139 ^ v136) ^ v136)
       + (__ROR4__(v142, 6) ^ __ROR4__(v142, 11) ^ __ROR4__(v142, 25));
  v146 = v145 + v133;
  v147 = ((v143 | v140) & v137 | v143 & v140) + (__ROR4__(v143, 2) ^ __ROR4__(v143, 13) ^ __ROR4__(v143, 22)) + v145;
  v220 = (__ROR4__(v229, 7) ^ __ROR4__(v229, 18) ^ (v229 >> 3))
       + v224
       + v259
       + (__ROR4__(v268, 17) ^ __ROR4__(v268, 19) ^ (v268 >> 10));
  v148 = v220
       + 659060556
       + v136
       + (v146 & (v142 ^ v139) ^ v139)
       + (__ROR4__(v146, 6) ^ __ROR4__(v146, 11) ^ __ROR4__(v146, 25));
  v149 = v148 + v137;
  v150 = ((v147 | v143) & v140 | v147 & v143) + (__ROR4__(v147, 2) ^ __ROR4__(v147, 13) ^ __ROR4__(v147, 22)) + v148;
  v225 = (__ROR4__(v233, 7) ^ __ROR4__(v233, 18) ^ (v233 >> 3))
       + v229
       + v262
       + (__ROR4__(v144, 17) ^ __ROR4__(v144, 19) ^ (v144 >> 10));
  v151 = v225
       + 883997877
       + v139
       + (v149 & (v146 ^ v142) ^ v142)
       + (__ROR4__(v149, 6) ^ __ROR4__(v149, 11) ^ __ROR4__(v149, 25));
  v152 = v151 + v140;
  v153 = ((v150 | v147) & v143 | v150 & v147) + (__ROR4__(v150, 2) ^ __ROR4__(v150, 13) ^ __ROR4__(v150, 22)) + v151;
  v234 = (__ROR4__(v237, 7) ^ __ROR4__(v237, 18) ^ (v237 >> 3))
       + v233
       + v265
       + (__ROR4__(v220, 17) ^ __ROR4__(v220, 19) ^ (v220 >> 10));
  v154 = v234
       + 958139571
       + v142
       + (v152 & (v149 ^ v146) ^ v146)
       + (__ROR4__(v152, 6) ^ __ROR4__(v152, 11) ^ __ROR4__(v152, 25));
  v155 = v154 + v143;
  v156 = ((v153 | v150) & v147 | v153 & v150) + (__ROR4__(v153, 2) ^ __ROR4__(v153, 13) ^ __ROR4__(v153, 22)) + v154;
  v238 = (__ROR4__(v241, 7) ^ __ROR4__(v241, 18) ^ (v241 >> 3))
       + v237
       + v210
       + (__ROR4__(v225, 17) ^ __ROR4__(v225, 19) ^ (v225 >> 10));
  v157 = v238
       + 1322822218
       + v146
       + (v155 & (v152 ^ v149) ^ v149)
       + (__ROR4__(v155, 6) ^ __ROR4__(v155, 11) ^ __ROR4__(v155, 25));
  v158 = v157 + v147;
  v159 = ((v156 | v153) & v150 | v156 & v153) + (__ROR4__(v156, 2) ^ __ROR4__(v156, 13) ^ __ROR4__(v156, 22)) + v157;
  v242 = (__ROR4__(v245, 7) ^ __ROR4__(v245, 18) ^ (v245 >> 3))
       + v241
       + v216
       + (__ROR4__(v234, 17) ^ __ROR4__(v234, 19) ^ (v234 >> 10));
  v160 = v242
       + 1537002063
       + v149
       + (v158 & (v155 ^ v152) ^ v152)
       + (__ROR4__(v158, 6) ^ __ROR4__(v158, 11) ^ __ROR4__(v158, 25));
  v161 = v160 + v150;
  v162 = ((v159 | v156) & v153 | v159 & v156) + (__ROR4__(v159, 2) ^ __ROR4__(v159, 13) ^ __ROR4__(v159, 22)) + v160;
  v246 = (__ROR4__(v249, 7) ^ __ROR4__(v249, 18) ^ (v249 >> 3))
       + v245
       + v268
       + (__ROR4__(v238, 17) ^ __ROR4__(v238, 19) ^ (v238 >> 10));
  v163 = v246
       + 1747873779
       + v152
       + (v161 & (v158 ^ v155) ^ v155)
       + (__ROR4__(v161, 6) ^ __ROR4__(v161, 11) ^ __ROR4__(v161, 25));
  v164 = v163 + v153;
  v203 = ((v162 | v159) & v156 | v162 & v159) + (__ROR4__(v162, 2) ^ __ROR4__(v162, 13) ^ __ROR4__(v162, 22)) + v163;
  v250 = (__ROR4__(v253, 7) ^ __ROR4__(v253, 18) ^ (v253 >> 3))
       + v249
       + v144
       + (__ROR4__(v242, 17) ^ __ROR4__(v242, 19) ^ (v242 >> 10));
  v165 = v250
       + 1955562222
       + v155
       + (v164 & (v161 ^ v158) ^ v158)
       + (__ROR4__(v164, 6) ^ __ROR4__(v164, 11) ^ __ROR4__(v164, 25));
  v230 = v165 + v156;
  v166 = (__ROR4__(v256, 7) ^ __ROR4__(v256, 18) ^ (v256 >> 3))
       + v253
       + v220
       + (__ROR4__(v246, 17) ^ __ROR4__(v246, 19) ^ (v246 >> 10));
  v167 = ((v203 | v162) & v159 | v203 & v162) + (__ROR4__(v203, 2) ^ __ROR4__(v203, 13) ^ __ROR4__(v203, 22)) + v165;
  v168 = v166
       + 2024104815
       + v158
       + (v230 & (v164 ^ v161) ^ v161)
       + (__ROR4__(v230, 6) ^ __ROR4__(v230, 11) ^ __ROR4__(v230, 25));
  v221 = ((v167 | v203) & v162 | v167 & v203) + (__ROR4__(v167, 2) ^ __ROR4__(v167, 13) ^ __ROR4__(v167, 22)) + v168;
  v169 = (__ROR4__(v259, 7) ^ __ROR4__(v259, 18) ^ (v259 >> 3))
       + v256
       + v225
       + (__ROR4__(v250, 17) ^ __ROR4__(v250, 19) ^ (v250 >> 10));
  v170 = v168 + v159;
  v171 = v169
       - 2067236844
       + v161
       + (v170 & (v230 ^ v164) ^ v164)
       + (__ROR4__(v170, 6) ^ __ROR4__(v170, 11) ^ __ROR4__(v170, 25));
  v226 = ((v221 | v167) & v203 | v221 & v167) + (__ROR4__(v221, 2) ^ __ROR4__(v221, 13) ^ __ROR4__(v221, 22)) + v171;
  v172 = v171 + v162;
  v173 = (__ROR4__(v262, 7) ^ __ROR4__(v262, 18) ^ (v262 >> 3))
       + v259
       + v234
       + (__ROR4__(v166, 17) ^ __ROR4__(v166, 19) ^ (v166 >> 10));
  v174 = v173
       - 1933114872
       + v164
       + (v172 & (v170 ^ v230) ^ v230)
       + (__ROR4__(v172, 6) ^ __ROR4__(v172, 11) ^ __ROR4__(v172, 25));
  v175 = v174 + v203;
  v176 = ((v226 | v221) & v167 | v226 & v221) + (__ROR4__(v226, 2) ^ __ROR4__(v226, 13) ^ __ROR4__(v226, 22)) + v174;
  v204 = v175;
  v177 = (__ROR4__(v265, 7) ^ __ROR4__(v265, 18) ^ (v265 >> 3))
       + v262
       + v238
       + (__ROR4__(v169, 17) ^ __ROR4__(v169, 19) ^ (v169 >> 10));
  v178 = v177
       - 1866530822
       + v230
       + (v175 & (v172 ^ v170) ^ v170)
       + (__ROR4__(v175, 6) ^ __ROR4__(v175, 11) ^ __ROR4__(v175, 25));
  v179 = v178 + v167;
  v180 = ((v176 | v226) & v221 | v176 & v226) + (__ROR4__(v176, 2) ^ __ROR4__(v176, 13) ^ __ROR4__(v176, 22)) + v178;
  v181 = (__ROR4__(v210, 7) ^ __ROR4__(v210, 18) ^ (v210 >> 3))
       + v265
       + v242
       + (__ROR4__(v173, 17) ^ __ROR4__(v173, 19) ^ (v173 >> 10));
  v182 = v181
       - 1538233109
       + v170
       + (v179 & (v204 ^ v172) ^ v172)
       + (__ROR4__(v179, 6) ^ __ROR4__(v179, 11) ^ __ROR4__(v179, 25));
  v183 = v182 + v221;
  v184 = ((v180 | v176) & v226 | v180 & v176) + (__ROR4__(v180, 2) ^ __ROR4__(v180, 13) ^ __ROR4__(v180, 22)) + v182;
  v185 = v210
       - 1090935817
       + (__ROR4__(v216, 7) ^ __ROR4__(v216, 18) ^ (v216 >> 3))
       + v246
       + (__ROR4__(v177, 17) ^ __ROR4__(v177, 19) ^ (v177 >> 10))
       + v172
       + ((v182 + v221) & (v179 ^ v204) ^ v204)
       + (__ROR4__(v182 + v221, 6) ^ __ROR4__(v182 + v221, 11) ^ __ROR4__(v182 + v221, 25));
  v186 = ((v184 | v180) & v176 | v184 & v180) + (__ROR4__(v184, 2) ^ __ROR4__(v184, 13) ^ __ROR4__(v184, 22)) + v185;
  v187 = v185 + v226;
  v188 = v216
       - 965641998
       + (__ROR4__(v268, 7) ^ __ROR4__(v268, 18) ^ (v268 >> 3))
       + v250
       + (__ROR4__(v181, 17) ^ __ROR4__(v181, 19) ^ (v181 >> 10))
       + v204
       + (v187 & (v183 ^ v179) ^ v179)
       + (__ROR4__(v187, 6) ^ __ROR4__(v187, 11) ^ __ROR4__(v187, 25));
  result = v176 + v193 + v188;
  a1[2] = (__ROR4__(v186, 2) ^ __ROR4__(v186, 13) ^ __ROR4__(v186, 22))
        + ((v186 | v184) & v180 | v186 & v184)
        + v197
        + v188;
  a1[5] = v180 + v194;
  a1[6] = result;
  a1[3] = v186 + v196;
  a1[7] = v187 + v192;
  a1[4] = v184 + v195;
  a1[8] = v183 + v191;
  a1[9] = v179 + v190;
  return result;
}

//----- (0004C914) --------------------------------------------------------
unsigned int *__fastcall sub_4C914(unsigned int *result, unsigned int *a2, int a3)
{
  signed int v3; // r7
  unsigned int *v4; // r6
  unsigned int *v5; // r8
  unsigned int v6; // r10
  unsigned int v7; // r3
  int v8; // r10
  int v9; // r4
  _BOOL4 v10; // r3
  int v11; // r5
  unsigned int *v12; // r4
  unsigned int *v13; // r1
  unsigned int v14; // r7
  int v15; // r2

  v3 = a3;
  v4 = result;
  v5 = a2;
  if ( a3 > 0 )
  {
    v6 = *result;
    v7 = a3 + *result;
    *result = v7;
    v8 = v6 & 0x3F;
    v9 = 64 - v8;
    if ( a3 > v7 )
      ++result[1];
    v10 = a3 >= v9;
    if ( !v8 )
      v10 = 0;
    if ( v10 )
    {
      v3 = a3 - v9;
      memcpy((char *)result + v8 + 40, a2, 64 - v8);
      v5 = (unsigned int *)((char *)v5 + v9);
      result = (unsigned int *)sub_4A218(v4, v4 + 10);
      v8 = 0;
    }
    if ( v3 > 63 )
    {
      v11 = v3;
      v12 = v5;
      do
      {
        v13 = v12;
        v11 -= 64;
        v12 += 16;
        result = (unsigned int *)sub_4A218(v4, v13);
      }
      while ( v11 > 63 );
      v14 = v3 - 64;
      v15 = (v14 >> 6) + 1;
      v3 = v14 - (v14 >> 6 << 6);
      v5 += 16 * v15;
    }
    if ( v3 > 0 )
      return (unsigned int *)memcpy((char *)v4 + v8 + 40, v5, v3);
  }
  return result;
}

//----- (0004C9F4) --------------------------------------------------------
unsigned int *__fastcall sub_4C9F4(int a1, _BYTE *a2)
{
  unsigned int v4; // r2
  int v5; // r1
  int v6; // r3
  int v7; // r2
  unsigned int *result; // r0
  unsigned int v9; // [sp+0h] [bp-Ch] BYREF
  char v10; // [sp+4h] [bp-8h]
  char v11; // [sp+5h] [bp-7h]
  char v12; // [sp+6h] [bp-6h]
  char v13; // [sp+7h] [bp-5h]

  v4 = *(_DWORD *)a1 & 0x3F;
  v5 = *(_QWORD *)a1 >> 29;
  v6 = 8 * *(_DWORD *)a1;
  if ( v4 > 0x37 )
    v7 = 120 - v4;
  else
    v7 = 56 - v4;
  HIBYTE(v9) = *(_QWORD *)a1 >> 29;
  BYTE1(v9) = BYTE2(v5);
  BYTE2(v9) = BYTE1(v5);
  v11 = BYTE2(v6);
  v12 = BYTE1(v6);
  v13 = v6;
  LOBYTE(v9) = HIBYTE(v5);
  v10 = HIBYTE(v6);
  sub_4C914((unsigned int *)a1, dword_692DC, v7);
  result = sub_4C914((unsigned int *)a1, &v9, 8);
  *a2 = *(_BYTE *)(a1 + 11);
  a2[1] = *(_WORD *)(a1 + 10);
  a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
  a2[3] = *(_DWORD *)(a1 + 8);
  a2[4] = *(_BYTE *)(a1 + 15);
  a2[5] = *(_WORD *)(a1 + 14);
  a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
  a2[7] = *(_DWORD *)(a1 + 12);
  a2[8] = *(_BYTE *)(a1 + 19);
  a2[9] = *(_WORD *)(a1 + 18);
  a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
  a2[11] = *(_DWORD *)(a1 + 16);
  a2[12] = *(_BYTE *)(a1 + 23);
  a2[13] = *(_WORD *)(a1 + 22);
  a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
  a2[15] = *(_DWORD *)(a1 + 20);
  a2[16] = *(_BYTE *)(a1 + 27);
  a2[17] = *(_WORD *)(a1 + 26);
  a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
  a2[19] = *(_DWORD *)(a1 + 24);
  a2[20] = *(_BYTE *)(a1 + 31);
  a2[21] = *(_WORD *)(a1 + 30);
  a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
  a2[23] = *(_DWORD *)(a1 + 28);
  a2[24] = *(_BYTE *)(a1 + 35);
  a2[25] = *(_WORD *)(a1 + 34);
  a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
  a2[27] = *(_DWORD *)(a1 + 32);
  a2[28] = *(_BYTE *)(a1 + 39);
  a2[29] = *(_WORD *)(a1 + 38);
  a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
  a2[31] = *(_DWORD *)(a1 + 36);
  return result;
}
// 692DC: using guessed type unsigned int dword_692DC[16];

//----- (0004CC58) --------------------------------------------------------
int __fastcall sub_4CC58(void *src, int a2, void *a3, unsigned __int8 a4)
{
  int srca; // [sp+4h] [bp-170h] BYREF
  _BYTE dest[364]; // [sp+8h] [bp-16Ch] BYREF

  srca = a2;
  memcpy(dest, src, 0x168u);
  sub_537BC((int)dest, (char *)&srca, 4u);
  return sub_53A04((int)dest, a3, a4);
}

//----- (0004CCAC) --------------------------------------------------------
int __fastcall compar(const void *a1, const void *a2)
{
  return memcmp(a1, a2, dword_739D0);
}
// 739D0: using guessed type int dword_739D0;

//----- (0004CCBC) --------------------------------------------------------
unsigned int __fastcall sub_4CCBC(unsigned int a1, int a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int result; // r0
  int v8; // r11
  int v9; // r4
  unsigned int v10; // r6
  unsigned int v11; // r5
  int v12; // t1
  _BYTE *v13; // r3
  unsigned int v14; // r3
  _BYTE *v15; // r2
  unsigned int v16; // [sp+0h] [bp-1Ch]
  int v18; // [sp+10h] [bp-Ch]

  if ( a5 <= 7 )
    _assert_fail("bit_len >= 8", "sort-verify.c", 0x40u, "expandArray");
  if ( a5 + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "sort-verify.c", 0x41u, "expandArray");
  v16 = a6 + ((a5 + 7) >> 3);
  result = v16 * 8 * a2 / a5;
  if ( result != a4 )
    _assert_fail("out_len == 8 * out_width * in_len / bit_len", "sort-verify.c", 0x44u, "expandArray");
  if ( a2 )
  {
    v8 = 0;
    v18 = a3 + a6;
    v9 = a1 + a2;
    result = a1;
    v10 = 0;
    v11 = 0;
    do
    {
      v11 += 8;
      v12 = *(unsigned __int8 *)result++;
      v10 = v12 | (v10 << 8);
      if ( a5 <= v11 )
      {
        v11 -= a5;
        if ( a6 )
        {
          v13 = (_BYTE *)(a3 + v8);
          do
            *v13++ = 0;
          while ( v13 != (_BYTE *)(v18 + v8) );
        }
        if ( a6 < v16 )
        {
          v14 = v11 + 8 * (((a5 + 7) >> 3) + 0x1FFFFFFF);
          v15 = (_BYTE *)(a3 + v8 + a6);
          do
          {
            *v15++ = (v10 >> v14) & ((unsigned int)~(-1 << a5) >> (v14 - v11));
            v14 -= 8;
          }
          while ( v15 != (_BYTE *)(a3 + v16 + v8) );
        }
        v8 += v16;
      }
    }
    while ( result != v9 );
  }
  return result;
}

//----- (0004CE5C) --------------------------------------------------------
unsigned int *__fastcall sub_4CE5C(unsigned int *result, int a2)
{
  unsigned int *v2; // r3
  int v3; // r2
  int v4; // r5
  unsigned int v5; // r12
  unsigned int v6; // r4

  v2 = &result[a2];
  if ( a2 )
  {
    v3 = 0;
    v4 = 0;
    do
    {
      v5 = *result;
      v6 = *v2;
      if ( v4 || v5 > v6 )
      {
        *result = v6;
        v4 = 1;
        *v2 = v5;
      }
      else if ( v5 < v6 )
      {
        return result;
      }
      ++v3;
      ++result;
      ++v2;
    }
    while ( v3 != a2 );
  }
  return result;
}

//----- (0004CEC0) --------------------------------------------------------
int __fastcall sub_4CEC0(int *a1, unsigned int a2)
{
  int v2; // r5
  int v3; // r9
  int v5; // r6
  int v6; // r0
  int v7; // r1
  char *v8; // r0
  _DWORD *v9; // r2
  int v10; // r0
  int v11; // r4
  int v12; // r3
  int v13; // r5
  int v14; // r11
  int v15; // r0
  int v16; // r1
  char *v17; // r6
  int v18; // r9
  int v19; // r0
  int i; // r3
  char *j; // r3
  int v22; // r4
  _BYTE *v24; // r12
  int v25; // r3
  int v26; // t1
  size_t v27; // r6
  int v28; // r12
  size_t v29; // r4
  unsigned int v30; // r5
  int v31; // r9
  int v32; // r3
  int v33; // r12
  int v34; // r9
  char *v35; // r0
  int v36; // r9
  char *v37; // r1
  bool v38; // zf
  char *v39; // r3
  int v40; // r3
  int k; // r6
  int v42; // r9
  unsigned int *v43; // r0
  char *v44; // r4
  int *v45; // r6
  int v46; // r9
  int v47; // r0
  unsigned int v48; // t1
  _BYTE *v49; // r0
  size_t v50; // r6
  unsigned int v51; // r5
  int v52; // r12
  int v53; // r9
  size_t v54; // r4
  int v55; // r12
  int m; // r3
  int v57; // r9
  char *v58; // r0
  int v59; // r9
  char *v60; // r1
  char *v61; // r3
  int v62; // r2
  char *v63; // r0
  unsigned int v64; // r1
  unsigned int v65; // r3
  char *v66; // lr
  _BYTE *v67; // r0
  _WORD *v68; // r5
  _BYTE *v69; // r0
  int v70; // r1
  int v71; // r2
  int v72; // r3
  int v73; // r1
  int v74; // r2
  int v75; // r3
  int v76; // t1
  unsigned int v77; // [sp+0h] [bp-78h]
  int v78; // [sp+Ch] [bp-6Ch]
  int v79; // [sp+Ch] [bp-6Ch]
  int v80; // [sp+Ch] [bp-6Ch]
  unsigned int v81; // [sp+10h] [bp-68h]
  unsigned int v82; // [sp+10h] [bp-68h]
  int v83; // [sp+14h] [bp-64h]
  unsigned int nmemb; // [sp+18h] [bp-60h]
  int v85; // [sp+1Ch] [bp-5Ch]
  size_t v86; // [sp+1Ch] [bp-5Ch]
  int v87; // [sp+1Ch] [bp-5Ch]
  int v88; // [sp+20h] [bp-58h]
  int v89; // [sp+24h] [bp-54h]
  int v90; // [sp+28h] [bp-50h]
  int v91; // [sp+28h] [bp-50h]
  char *ptr; // [sp+2Ch] [bp-4Ch]
  void *v93; // [sp+30h] [bp-48h]
  char *v94; // [sp+34h] [bp-44h]
  int v95; // [sp+44h] [bp-34h]
  int v96; // [sp+48h] [bp-30h]
  int v97; // [sp+4Ch] [bp-2Ch]
  unsigned int v98; // [sp+54h] [bp-24h] BYREF
  int v99; // [sp+58h] [bp-20h] BYREF
  int v100; // [sp+5Ch] [bp-1Ch]
  int v101; // [sp+60h] [bp-18h]
  int v102; // [sp+64h] [bp-14h]
  int v103; // [sp+68h] [bp-10h]
  int v104; // [sp+6Ch] [bp-Ch]
  int v105; // [sp+70h] [bp-8h]
  __int16 v106; // [sp+74h] [bp-4h] BYREF
  char v107; // [sp+77h] [bp-1h] BYREF
  _BYTE v108[28]; // [sp+78h] [bp+0h] BYREF
  __int16 v109; // [sp+94h] [bp+1Ch]
  _BYTE src[31]; // [sp+98h] [bp+20h] BYREF
  char v111; // [sp+B7h] [bp+3Fh] BYREF
  _BYTE v112[1336]; // [sp+B8h] [bp+40h] BYREF
  char v113; // [sp+5F7h] [bp+57Fh] BYREF
  _BYTE v114[2040]; // [sp+5F8h] [bp+580h] BYREF
  _BYTE v115[1992]; // [sp+DF8h] [bp+D80h] BYREF
  int v116; // [sp+15F8h] [bp+1580h] BYREF

  v2 = a1[1];
  v3 = *a1;
  v5 = v2 + 1;
  v93 = (void *)a1[2];
  v6 = sub_59AC8(*a1, v2 + 1);
  v77 = v6 + 1;
  v81 = v6;
  dword_739D0 = 3;
  v7 = ((v6 + 1) << v2) + 7;
  if ( (v6 + 1) << v2 >= 0 )
    v7 = v77 << v2;
  sub_4CCBC(a2, v7 >> 3, (int)v114, 2048, v77, 1u);
  v99 = 0;
  v100 = 0;
  v101 = 0;
  v102 = 0;
  v103 = 0;
  v104 = 0;
  v105 = 0;
  v106 = 0;
  ptr = (char *)malloc(0x4400u);
  v8 = (char *)malloc(0x4400u);
  v9 = v114;
  memset(v108, 0, sizeof(v108));
  v109 = 0;
  v94 = v8;
  v10 = 0;
  while ( ++v10 != 512 )
  {
    if ( *v9 == v9[1] )
    {
LABEL_27:
      v22 = 1;
      goto LABEL_21;
    }
    v24 = &v114[4 * v10];
    v25 = v10;
    while ( ++v25 != 512 )
    {
      v26 = *((_DWORD *)v24 + 1);
      v24 += 4;
      if ( *v9 == v26 )
        goto LABEL_27;
    }
    ++v9;
  }
  v11 = 0;
  v12 = v81 + 7;
  if ( (int)(v81 + 7) < 0 )
    v12 = v81 + 14;
  v13 = 0;
  v14 = (v12 >> 3) * v5;
  v15 = sub_59AC8(512, v3);
  v16 = v3 + 7;
  v17 = ptr;
  if ( v3 >= 0 )
    v16 = v3;
  v85 = v3;
  v90 = v14 + 4;
  v89 = v16 >> 3;
  v83 = v15;
  v88 = v3 * v15 / 8;
  do
  {
    v18 = 4 * v13;
    v78 = bswap32(*(_DWORD *)&v114[4 * v13]);
    v19 = sub_59AC8(v78, v83);
    sub_4CC58(v93, v19, v115, v88);
    sub_4CCBC((unsigned int)&v115[v85 * (v78 % v83) / 8], v89, (int)v112, v14, v81, 0);
    if ( v14 )
    {
      for ( i = 0; ; LOBYTE(v11) = *((_BYTE *)&v99 + i) )
      {
        *((_BYTE *)&v99 + i) = v11 ^ v112[i];
        if ( v14 == ++i )
          break;
      }
      v11 = (unsigned __int8)v99;
    }
    ++v13;
    memcpy(v17, v112, v14);
    *(_DWORD *)&v17[v14] = *(_DWORD *)&v114[v18];
    v17 += v90;
  }
  while ( v13 != 512 );
  for ( j = (char *)&v99 + 1; ; v11 = (unsigned __int8)*(j - 1) )
  {
    ++j;
    if ( v11 )
    {
      v22 = 2;
      goto LABEL_21;
    }
    if ( j == &v107 )
      break;
  }
  v27 = 4;
  v99 = 0;
  v95 = 9;
  v100 = 0;
  nmemb = 512;
  v101 = 0;
  v102 = 0;
  v103 = 0;
  v104 = 0;
  v105 = 0;
  v106 = 0;
  v97 = v85;
  while ( 1 )
  {
    v86 = v27 + v14;
    qsort(ptr, nmemb, v27 + v14, compar);
    if ( nmemb )
    {
      v96 = 2 * v27;
      v28 = 0;
      v29 = v27 + v14;
      v30 = 0;
      v31 = 0;
      do
      {
        if ( v14 )
        {
          v32 = 0;
          v33 = v86 * v28;
          do
          {
            v108[v32] = ptr[v29 + v32] ^ ptr[v33 + v32];
            ++v32;
          }
          while ( v14 != v32 );
        }
        else
        {
          v33 = v86 * v28;
        }
        v79 = v33;
        v34 = (2 * v27 + v14) * (v31 >> 1);
        ++v30;
        v35 = &v94[v34];
        v36 = v34 + v14;
        memcpy(v35, v108, v14);
        memcpy(&v94[v36], &ptr[v79 + v14], v27);
        v37 = &ptr[v14 + v29];
        v29 += 2 * v86;
        memcpy(&v94[v36 + v27], v37, v27);
        v31 = 2 * v30;
        v28 = 2 * v30;
      }
      while ( 2 * v30 < nmemb );
    }
    else
    {
      v30 = 0;
      v96 = 2 * v27;
    }
    v38 = v95-- == 1;
    dword_739D0 += 3;
    if ( v38 )
      break;
    v39 = ptr;
    nmemb = v30;
    v27 = v96;
    ptr = v94;
    v94 = v39;
  }
  v40 = v95;
  do
  {
    *(_DWORD *)&v115[v40] = bswap32(*(_DWORD *)&v94[v14 + v40]);
    v40 += 4;
  }
  while ( v40 != 2048 );
  for ( k = 0; k != 9; ++k )
  {
    v42 = 0;
    do
    {
      v43 = (unsigned int *)&v115[4 * v42];
      v42 += 2 << k;
      sub_4CE5C(v43, 1 << k);
    }
    while ( v42 <= 511 );
  }
  v44 = v94;
  v45 = (int *)v115;
  do
  {
    v46 = *v45;
    v47 = sub_59AC8(*v45, v83);
    sub_4CC58(v93, v47, v112, v88);
    sub_4CCBC((unsigned int)&v112[v97 * (v46 % v83) / 8], v89, (int)src, v14, v81, 0);
    v48 = *v45++;
    v98 = bswap32(v48);
    memcpy(v44, src, v14);
    *(_DWORD *)&v44[v14] = v98;
    v49 = sub_29688((int)v44, 34);
    v44 += v90;
    free(v49);
  }
  while ( v45 != &v116 );
  v50 = 4;
  v91 = 9;
  v82 = 512;
  while ( 1 )
  {
    if ( v82 )
    {
      v52 = 0;
      v87 = 2 * v50;
      v51 = 0;
      v53 = 0;
      v54 = v50 + v14;
      do
      {
        v55 = (v50 + v14) * v52;
        if ( v14 )
        {
          for ( m = 0; m != v14; ++m )
            v108[m] = v94[v54 + m] ^ v94[v55 + m];
        }
        v80 = v55;
        v57 = (2 * v50 + v14) * (v53 >> 1);
        ++v51;
        v58 = &ptr[v57];
        v59 = v57 + v14;
        memcpy(v58, v108, v14);
        memcpy(&ptr[v59], &v94[v80 + v14], v50);
        v60 = &v94[v14 + v54];
        v54 += 2 * (v50 + v14);
        memcpy(&ptr[v59 + v50], v60, v50);
        v53 = 2 * v51;
        v52 = 2 * v51;
      }
      while ( 2 * v51 < v82 );
    }
    else
    {
      v87 = 2 * v50;
      v51 = 0;
    }
    v38 = v91-- == 1;
    dword_739D0 += 3;
    if ( v38 )
      break;
    v61 = v94;
    v82 = v51;
    v50 = v87;
    v94 = ptr;
    ptr = v61;
  }
  v62 = v91;
  v63 = &v111;
  v64 = v91;
  v65 = v91;
  do
  {
    v66 = &ptr[v14 + v62];
    if ( v65 <= 7 )
    {
      v62 += 4;
      v65 += 21;
      v64 = ((v66[1] & 0x1F) << 16) | ((unsigned __int8)v66[2] << 8) | (v64 << 21) | (unsigned __int8)v66[3];
    }
    v65 -= 8;
    *++v63 = v64 >> v65;
  }
  while ( v63 != &v113 );
  v67 = sub_29688((int)v112, 1344);
  v68 = (_WORD *)((char *)&v98 + 3);
  free(v67);
  v69 = sub_29688((int)ptr, v87 + v14);
  free(v69);
  v70 = *((_DWORD *)ptr + 1);
  v71 = *((_DWORD *)ptr + 2);
  v72 = *((_DWORD *)ptr + 3);
  v99 = *(_DWORD *)ptr;
  v100 = v70;
  v101 = v71;
  v102 = v72;
  v73 = *((_DWORD *)ptr + 5);
  v74 = *((_DWORD *)ptr + 6);
  v75 = *((_DWORD *)ptr + 7);
  v103 = *((_DWORD *)ptr + 4);
  v104 = v73;
  v105 = v74;
  v106 = v75;
  while ( 1 )
  {
    v76 = *((unsigned __int8 *)v68 + 1);
    v68 = (_WORD *)((char *)v68 + 1);
    v22 = v76;
    if ( v76 )
      break;
    if ( v68 == (__int16 *)((char *)&v106 + 1) )
      goto LABEL_21;
  }
  v22 = 3;
LABEL_21:
  free(ptr);
  free(v94);
  return v22;
}
// 739D0: using guessed type int dword_739D0;

//----- (0004D714) --------------------------------------------------------
int __fastcall sub_4D714(char *a1, int a2, int a3)
{
  int v6; // r0
  _DWORD v8[16]; // [sp+0h] [bp-40h] BYREF

  memset(v8, 0, sizeof(v8));
  HIWORD(v8[0]) = 257;
  v6 = sub_59AC8(512, a2);
  v8[14] = a2;
  v8[15] = a3;
  qmemcpy(&v8[12], "ZcashPoW", 8);
  LOBYTE(v8[0]) = a2 * v6 / 8;
  return sub_535FC(a1, (unsigned __int8 *)v8);
}

//----- (0004D798) --------------------------------------------------------
int __fastcall sub_4D798(int a1, unsigned __int8 *a2)
{
  __int64 *v2; // r12
  unsigned __int8 *v3; // r6
  unsigned int v4; // r2
  unsigned int v5; // d16.s[0]
  __int64 v6; // d19
  int v7; // r12
  __int64 *v8; // r1
  __int64 v9; // t1
  __int64 v10; // r2
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // d18
  unsigned int v13; // r12
  unsigned int v14; // r1
  __int64 v15; // r2
  __int64 v16; // r4
  __int64 v17; // r8
  __int64 v18; // r2
  signed __int64 v19; // r2
  unsigned __int64 v20; // r10
  __int64 v21; // r2
  unsigned __int64 v22; // r4
  __int64 v23; // r4
  __int64 v24; // r2
  __int64 v25; // r6
  unsigned __int64 v26; // r8
  __int64 v27; // r4
  signed __int64 v28; // r2
  unsigned __int64 v29; // r6
  __int64 v30; // r0
  __int64 v31; // r10
  __int64 v32; // r2
  __int64 v33; // r4
  __int64 v34; // r0
  __int64 v35; // r4
  __int64 v36; // r6
  unsigned __int64 v37; // r4
  __int64 v38; // r2
  __int64 v39; // r4
  unsigned __int64 v40; // r6
  signed __int64 v41; // r0
  __int64 v42; // r4
  unsigned __int64 v43; // r0
  unsigned __int64 v44; // r6
  __int64 v45; // r4
  __int64 v46; // r0
  __int64 v47; // r8
  __int64 v48; // r4
  unsigned __int64 v49; // r10
  __int64 v50; // r2
  __int64 v51; // r10
  __int64 v52; // r2
  __int64 v53; // r6
  signed __int64 v54; // r4
  signed __int64 v55; // r0
  signed __int64 v56; // r6
  __int64 v57; // r2
  signed __int64 v58; // r0
  __int64 v59; // r0
  unsigned __int64 v60; // r10
  __int64 v61; // r8
  unsigned __int64 v62; // r4
  int v63; // r12
  unsigned __int64 v64; // r6
  signed __int64 v65; // r0
  __int64 v66; // r2
  __int64 v67; // r8
  __int64 v68; // r4
  __int64 v69; // r0
  __int64 v70; // r2
  unsigned __int64 v71; // r6
  __int64 v72; // r6
  signed __int64 v73; // r2
  __int64 v74; // r4
  __int64 v75; // r0
  unsigned __int64 v76; // r4
  __int64 v77; // r0
  unsigned __int64 v78; // r6
  unsigned __int64 v79; // r4
  __int64 v80; // r4
  __int64 v81; // r0
  unsigned __int64 v82; // r6
  unsigned __int64 v83; // r4
  int v84; // r12
  unsigned __int64 v85; // r10
  __int64 v86; // r0
  __int64 v87; // r10
  signed __int64 v88; // r2
  __int64 v89; // r2
  signed __int64 v90; // r0
  unsigned __int64 v91; // r0
  __int64 v92; // r4
  unsigned __int64 v93; // r6
  signed __int64 v94; // r0
  unsigned __int64 v95; // r2
  unsigned int v96; // r12
  __int64 v97; // r4
  __int64 v98; // r6
  __int64 v99; // r2
  unsigned __int64 v100; // r4
  __int64 v101; // r6
  __int64 v102; // r8
  __int64 v103; // r4
  __int64 v104; // r8
  __int64 v105; // r6
  signed __int64 v106; // r2
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // r4
  __int64 v109; // r2
  __int64 v110; // r2
  unsigned __int64 v111; // r8
  signed __int64 v112; // r4
  __int64 v113; // r6
  __int64 v114; // r2
  __int64 v115; // r6
  __int64 v116; // r4
  unsigned __int64 v117; // r8
  __int64 v118; // r0
  __int64 v119; // r6
  unsigned __int64 v120; // r8
  __int64 v121; // r4
  __int64 v122; // r4
  unsigned __int64 v123; // r4
  __int64 v124; // r2
  __int64 v125; // r4
  __int64 v126; // r2
  unsigned __int64 v127; // r4
  __int64 v128; // r0
  __int64 v129; // r2
  unsigned __int64 v130; // r4
  unsigned __int64 v131; // r10
  __int64 v132; // r4
  int v133; // r12
  __int64 v134; // r4
  __int64 v135; // r2
  __int64 v136; // r2
  __int64 v137; // r2
  __int64 v138; // r4
  __int64 v139; // r6
  __int64 v140; // r0
  unsigned __int64 v141; // r4
  signed __int64 v142; // r4
  unsigned __int64 v143; // r6
  __int64 v144; // r0
  unsigned __int64 v145; // r2
  __int64 v146; // r0
  __int64 v147; // r2
  unsigned __int64 v148; // r2
  __int64 v149; // r0
  __int64 v150; // r8
  __int64 v151; // r4
  __int64 v152; // r2
  signed __int64 v153; // r4
  __int64 v154; // r8
  signed __int64 v155; // r2
  __int64 v156; // r0
  __int64 v157; // r4
  __int64 v158; // r10
  signed __int64 v159; // r0
  unsigned __int64 v160; // r4
  __int64 v161; // r0
  __int64 v162; // r2
  __int64 v163; // r4
  __int64 v164; // r0
  __int64 v165; // r2
  __int64 v166; // r6
  __int64 v167; // r6
  __int64 v168; // r6
  __int64 v169; // r4
  __int64 v170; // r2
  unsigned __int64 v171; // r8
  unsigned __int64 v172; // r10
  signed __int64 v173; // r0
  __int64 v174; // r10
  __int64 v175; // r2
  __int64 v176; // r0
  unsigned __int64 v177; // r4
  __int64 v178; // r2
  unsigned __int64 v179; // r6
  unsigned __int64 v180; // r10
  __int64 v181; // r4
  unsigned __int64 v182; // r0
  __int64 v183; // r8
  __int64 v184; // r2
  __int64 v185; // r2
  __int64 v186; // r6
  unsigned __int64 v187; // r0
  __int64 v188; // r4
  __int64 v189; // r0
  __int64 v190; // r6
  unsigned __int64 v191; // r4
  __int64 v192; // r6
  __int64 v193; // r2
  __int64 v194; // r6
  __int64 v195; // r2
  __int64 v196; // r4
  unsigned __int64 v197; // r0
  __int64 v198; // r2
  unsigned __int64 v199; // r8
  __int64 v200; // r10
  __int64 v201; // r4
  __int64 v202; // r0
  __int64 v203; // r2
  __int64 v204; // r4
  __int64 v205; // r0
  __int64 v206; // r6
  unsigned __int64 v207; // r2
  unsigned __int64 v208; // r10
  signed __int64 v209; // r8
  signed __int64 v210; // r2
  unsigned __int64 v211; // r4
  unsigned __int64 v212; // r8
  __int64 v213; // r2
  int v214; // r12
  unsigned __int64 v215; // r6
  __int64 v216; // r10
  unsigned __int64 v217; // r8
  __int64 v218; // r6
  __int64 v219; // r2
  __int64 v220; // r4
  unsigned __int64 v221; // r2
  unsigned __int64 v222; // r4
  unsigned __int64 v223; // r0
  unsigned __int64 v224; // r10
  __int64 v225; // r2
  unsigned __int64 v226; // r4
  unsigned __int64 v227; // r4
  __int64 v228; // r0
  __int64 v229; // r4
  __int64 v230; // r0
  unsigned __int64 v231; // r6
  unsigned __int64 v232; // r10
  unsigned int v233; // kr54_4
  __int64 v234; // r2
  __int64 v235; // r0
  unsigned __int64 v236; // r10
  __int64 v237; // r6
  __int64 v238; // r2
  __int64 v239; // r10
  unsigned __int64 v240; // r0
  __int64 v241; // r4
  unsigned __int64 v242; // r10
  __int64 v243; // r0
  __int64 v244; // r4
  __int64 v245; // r2
  __int64 v246; // r2
  signed __int64 v247; // r4
  __int64 v248; // r0
  __int64 v249; // r2
  __int64 v250; // r4
  unsigned __int64 v251; // r10
  __int64 v252; // r0
  int v253; // r12
  unsigned __int64 v254; // r2
  unsigned __int64 v255; // r6
  unsigned __int64 v256; // r4
  __int64 v257; // r4
  __int64 v258; // r0
  __int64 v259; // r6
  __int64 v260; // r0
  __int64 v261; // r4
  unsigned __int64 v262; // r0
  __int64 v263; // r2
  unsigned __int64 v264; // r8
  __int64 v265; // r2
  __int64 v266; // r6
  __int64 v267; // r4
  __int64 v268; // r0
  __int64 v269; // r4
  unsigned __int64 v270; // r6
  unsigned __int64 v271; // r4
  signed __int64 v272; // r0
  __int64 v273; // r2
  __int64 v274; // r6
  signed __int64 v275; // r0
  __int64 v276; // r0
  unsigned __int64 v277; // r6
  __int64 v278; // r10
  unsigned int v279; // kr74_4
  unsigned int v280; // kr78_4
  signed __int64 v281; // r2
  unsigned __int64 v282; // r10
  signed __int64 v283; // r0
  unsigned __int64 v284; // r4
  unsigned __int64 v285; // r2
  unsigned __int64 v286; // r4
  __int64 v287; // r0
  unsigned __int64 v288; // r4
  unsigned __int64 v289; // r6
  int v290; // r12
  __int64 v291; // r4
  __int64 v292; // r0
  __int64 v293; // r4
  unsigned __int64 v294; // r8
  unsigned __int64 v295; // r2
  unsigned __int64 v296; // r4
  __int64 v297; // r4
  __int64 v298; // r2
  __int64 v299; // r0
  __int64 v300; // r6
  __int64 v301; // r2
  __int64 v302; // r4
  __int64 v303; // r4
  unsigned __int64 v304; // r10
  __int64 v305; // r2
  unsigned __int64 v306; // r4
  unsigned __int64 v307; // r2
  unsigned __int64 v308; // r0
  signed __int64 v309; // r0
  __int64 v310; // r4
  signed __int64 v311; // r2
  signed __int64 v312; // r6
  unsigned __int64 v313; // r8
  __int64 v314; // r6
  __int64 v315; // r8
  signed __int64 v316; // r4
  __int64 v317; // r6
  unsigned __int64 v318; // r8
  signed __int64 v319; // r6
  unsigned __int64 v320; // r10
  __int64 v321; // r8
  signed __int64 v322; // r0
  __int64 v323; // r2
  int v324; // r12
  unsigned __int64 v325; // r10
  int result; // r0
  __int64 v327; // r8
  unsigned __int64 v328; // r6
  __int64 v329; // r4
  unsigned __int64 v330; // r2
  __int64 v331; // r2
  unsigned __int64 v332; // r2
  __int64 v333; // r6
  unsigned __int64 v334; // r10
  __int64 v335; // r4
  __int64 v336; // r2
  _QWORD *v337; // r12
  __int64 v338; // r8
  __int64 *v339; // r6
  _QWORD *i; // r1
  __int64 v341; // t1
  unsigned __int64 v342; // t1
  unsigned __int64 v343; // [sp+0h] [bp-220h]
  unsigned __int64 v344; // [sp+0h] [bp-220h]
  unsigned __int64 v345; // [sp+0h] [bp-220h]
  __int64 v346; // [sp+0h] [bp-220h]
  unsigned __int64 v347; // [sp+0h] [bp-220h]
  unsigned __int64 v348; // [sp+0h] [bp-220h]
  unsigned __int64 v349; // [sp+0h] [bp-220h]
  __int64 v350; // [sp+0h] [bp-220h]
  unsigned __int64 v351; // [sp+0h] [bp-220h]
  unsigned __int64 v352; // [sp+0h] [bp-220h]
  unsigned __int64 v353; // [sp+0h] [bp-220h]
  unsigned __int64 v354; // [sp+0h] [bp-220h]
  unsigned __int64 v355; // [sp+0h] [bp-220h]
  unsigned __int64 v356; // [sp+0h] [bp-220h]
  unsigned __int64 v357; // [sp+0h] [bp-220h]
  unsigned __int64 v358; // [sp+0h] [bp-220h]
  unsigned __int64 v359; // [sp+0h] [bp-220h]
  unsigned __int64 v360; // [sp+0h] [bp-220h]
  unsigned __int64 v361; // [sp+8h] [bp-218h]
  unsigned __int64 v362; // [sp+8h] [bp-218h]
  unsigned __int64 v363; // [sp+8h] [bp-218h]
  unsigned __int64 v364; // [sp+8h] [bp-218h]
  __int64 v365; // [sp+8h] [bp-218h]
  unsigned __int64 v366; // [sp+8h] [bp-218h]
  unsigned __int64 v367; // [sp+8h] [bp-218h]
  unsigned __int64 v368; // [sp+8h] [bp-218h]
  unsigned __int64 v369; // [sp+8h] [bp-218h]
  unsigned __int64 v370; // [sp+8h] [bp-218h]
  __int64 v371; // [sp+8h] [bp-218h]
  unsigned __int64 v372; // [sp+8h] [bp-218h]
  unsigned __int64 v373; // [sp+8h] [bp-218h]
  __int64 v374; // [sp+8h] [bp-218h]
  __int64 v375; // [sp+10h] [bp-210h]
  __int64 v376; // [sp+10h] [bp-210h]
  __int64 v377; // [sp+10h] [bp-210h]
  __int64 v378; // [sp+10h] [bp-210h]
  unsigned __int64 v379; // [sp+10h] [bp-210h]
  unsigned __int64 v380; // [sp+10h] [bp-210h]
  unsigned __int64 v381; // [sp+10h] [bp-210h]
  unsigned __int64 v382; // [sp+10h] [bp-210h]
  __int64 v383; // [sp+10h] [bp-210h]
  __int64 v384; // [sp+10h] [bp-210h]
  unsigned __int64 v385; // [sp+10h] [bp-210h]
  __int64 v386; // [sp+10h] [bp-210h]
  __int64 v387; // [sp+10h] [bp-210h]
  __int64 v388; // [sp+10h] [bp-210h]
  __int64 v389; // [sp+18h] [bp-208h]
  unsigned __int64 v390; // [sp+18h] [bp-208h]
  unsigned __int64 v391; // [sp+18h] [bp-208h]
  unsigned __int64 v392; // [sp+18h] [bp-208h]
  unsigned __int64 v393; // [sp+18h] [bp-208h]
  __int64 v394; // [sp+18h] [bp-208h]
  __int64 v395; // [sp+18h] [bp-208h]
  unsigned __int64 v396; // [sp+18h] [bp-208h]
  unsigned __int64 v397; // [sp+18h] [bp-208h]
  __int64 v398; // [sp+18h] [bp-208h]
  __int64 v399; // [sp+18h] [bp-208h]
  __int64 v400; // [sp+18h] [bp-208h]
  unsigned __int64 v401; // [sp+18h] [bp-208h]
  __int64 v402; // [sp+18h] [bp-208h]
  __int64 v403; // [sp+18h] [bp-208h]
  __int64 v404; // [sp+18h] [bp-208h]
  __int64 v405; // [sp+18h] [bp-208h]
  unsigned __int64 v406; // [sp+20h] [bp-200h]
  unsigned __int64 v407; // [sp+20h] [bp-200h]
  unsigned __int64 v408; // [sp+20h] [bp-200h]
  __int64 v409; // [sp+20h] [bp-200h]
  unsigned __int64 v410; // [sp+20h] [bp-200h]
  unsigned __int64 v411; // [sp+20h] [bp-200h]
  unsigned __int64 v412; // [sp+20h] [bp-200h]
  unsigned __int64 v413; // [sp+20h] [bp-200h]
  unsigned __int64 v414; // [sp+20h] [bp-200h]
  unsigned __int64 v415; // [sp+20h] [bp-200h]
  unsigned __int64 v416; // [sp+20h] [bp-200h]
  unsigned __int64 v417; // [sp+20h] [bp-200h]
  unsigned __int64 v418; // [sp+20h] [bp-200h]
  unsigned __int64 v419; // [sp+20h] [bp-200h]
  __int64 v420; // [sp+28h] [bp-1F8h]
  unsigned __int64 v421; // [sp+28h] [bp-1F8h]
  unsigned __int64 v422; // [sp+28h] [bp-1F8h]
  unsigned __int64 v423; // [sp+28h] [bp-1F8h]
  unsigned __int64 v424; // [sp+28h] [bp-1F8h]
  unsigned __int64 v425; // [sp+28h] [bp-1F8h]
  unsigned __int64 v426; // [sp+28h] [bp-1F8h]
  __int64 v427; // [sp+28h] [bp-1F8h]
  unsigned __int64 v428; // [sp+28h] [bp-1F8h]
  unsigned __int64 v429; // [sp+28h] [bp-1F8h]
  unsigned __int64 v430; // [sp+28h] [bp-1F8h]
  unsigned __int64 v431; // [sp+28h] [bp-1F8h]
  unsigned __int64 v432; // [sp+28h] [bp-1F8h]
  unsigned __int64 v433; // [sp+28h] [bp-1F8h]
  unsigned __int64 v434; // [sp+30h] [bp-1F0h]
  unsigned __int64 v435; // [sp+30h] [bp-1F0h]
  __int64 v436; // [sp+30h] [bp-1F0h]
  __int64 v437; // [sp+30h] [bp-1F0h]
  unsigned __int64 v438; // [sp+30h] [bp-1F0h]
  __int64 v439; // [sp+30h] [bp-1F0h]
  unsigned __int64 v440; // [sp+30h] [bp-1F0h]
  unsigned __int64 v441; // [sp+30h] [bp-1F0h]
  __int64 v442; // [sp+30h] [bp-1F0h]
  unsigned __int64 v443; // [sp+30h] [bp-1F0h]
  unsigned __int64 v444; // [sp+30h] [bp-1F0h]
  __int64 v445; // [sp+30h] [bp-1F0h]
  __int64 v446; // [sp+30h] [bp-1F0h]
  unsigned __int64 v447; // [sp+30h] [bp-1F0h]
  __int64 v448; // [sp+30h] [bp-1F0h]
  __int64 v449; // [sp+30h] [bp-1F0h]
  __int64 v450; // [sp+30h] [bp-1F0h]
  __int64 v451; // [sp+30h] [bp-1F0h]
  __int64 v452; // [sp+30h] [bp-1F0h]
  unsigned __int64 v453; // [sp+30h] [bp-1F0h]
  __int64 v454; // [sp+30h] [bp-1F0h]
  __int64 v455; // [sp+30h] [bp-1F0h]
  unsigned __int64 v456; // [sp+30h] [bp-1F0h]
  unsigned __int64 v457; // [sp+30h] [bp-1F0h]
  unsigned __int64 v458; // [sp+30h] [bp-1F0h]
  unsigned __int64 v459; // [sp+30h] [bp-1F0h]
  __int64 v460; // [sp+30h] [bp-1F0h]
  unsigned __int64 v461; // [sp+38h] [bp-1E8h]
  unsigned __int64 v462; // [sp+38h] [bp-1E8h]
  unsigned __int64 v463; // [sp+38h] [bp-1E8h]
  unsigned __int64 v464; // [sp+38h] [bp-1E8h]
  __int64 v465; // [sp+38h] [bp-1E8h]
  unsigned __int64 v466; // [sp+38h] [bp-1E8h]
  __int64 v467; // [sp+38h] [bp-1E8h]
  unsigned __int64 v468; // [sp+38h] [bp-1E8h]
  unsigned __int64 v469; // [sp+38h] [bp-1E8h]
  __int64 v470; // [sp+38h] [bp-1E8h]
  unsigned __int64 v471; // [sp+38h] [bp-1E8h]
  unsigned __int64 v472; // [sp+38h] [bp-1E8h]
  unsigned __int64 v473; // [sp+38h] [bp-1E8h]
  unsigned __int64 v474; // [sp+38h] [bp-1E8h]
  unsigned __int64 v475; // [sp+38h] [bp-1E8h]
  unsigned __int64 v476; // [sp+38h] [bp-1E8h]
  __int64 v477; // [sp+38h] [bp-1E8h]
  __int64 v478; // [sp+40h] [bp-1E0h]
  unsigned __int64 v479; // [sp+40h] [bp-1E0h]
  unsigned __int64 v480; // [sp+40h] [bp-1E0h]
  unsigned __int64 v481; // [sp+40h] [bp-1E0h]
  unsigned __int64 v482; // [sp+40h] [bp-1E0h]
  unsigned __int64 v483; // [sp+40h] [bp-1E0h]
  unsigned __int64 v484; // [sp+40h] [bp-1E0h]
  __int64 v485; // [sp+40h] [bp-1E0h]
  unsigned __int64 v486; // [sp+40h] [bp-1E0h]
  __int64 v487; // [sp+40h] [bp-1E0h]
  unsigned __int64 v488; // [sp+40h] [bp-1E0h]
  __int64 v489; // [sp+40h] [bp-1E0h]
  __int64 v490; // [sp+40h] [bp-1E0h]
  __int64 v491; // [sp+40h] [bp-1E0h]
  __int64 v492; // [sp+40h] [bp-1E0h]
  __int64 v493; // [sp+40h] [bp-1E0h]
  __int64 v494; // [sp+40h] [bp-1E0h]
  __int64 v495; // [sp+40h] [bp-1E0h]
  unsigned __int64 v496; // [sp+40h] [bp-1E0h]
  __int64 v497; // [sp+40h] [bp-1E0h]
  unsigned __int64 v498; // [sp+40h] [bp-1E0h]
  __int64 v499; // [sp+40h] [bp-1E0h]
  __int64 v500; // [sp+40h] [bp-1E0h]
  unsigned __int64 v501; // [sp+40h] [bp-1E0h]
  unsigned __int64 v502; // [sp+40h] [bp-1E0h]
  __int64 v503; // [sp+40h] [bp-1E0h]
  unsigned __int64 v504; // [sp+40h] [bp-1E0h]
  unsigned __int64 v505; // [sp+40h] [bp-1E0h]
  unsigned __int64 v506; // [sp+40h] [bp-1E0h]
  unsigned __int64 v507; // [sp+40h] [bp-1E0h]
  __int64 v508; // [sp+40h] [bp-1E0h]
  __int64 v509; // [sp+40h] [bp-1E0h]
  __int64 v510; // [sp+48h] [bp-1D8h]
  unsigned __int64 v511; // [sp+48h] [bp-1D8h]
  unsigned __int64 v512; // [sp+48h] [bp-1D8h]
  __int64 v513; // [sp+48h] [bp-1D8h]
  unsigned __int64 v514; // [sp+48h] [bp-1D8h]
  __int64 v515; // [sp+48h] [bp-1D8h]
  unsigned __int64 v516; // [sp+48h] [bp-1D8h]
  __int64 v517; // [sp+48h] [bp-1D8h]
  unsigned __int64 v518; // [sp+48h] [bp-1D8h]
  __int64 v519; // [sp+48h] [bp-1D8h]
  __int64 v520; // [sp+48h] [bp-1D8h]
  unsigned __int64 v521; // [sp+48h] [bp-1D8h]
  __int64 v522; // [sp+48h] [bp-1D8h]
  __int64 v523; // [sp+48h] [bp-1D8h]
  unsigned __int64 v524; // [sp+48h] [bp-1D8h]
  unsigned __int64 v525; // [sp+48h] [bp-1D8h]
  unsigned __int64 v526; // [sp+48h] [bp-1D8h]
  unsigned __int64 v527; // [sp+48h] [bp-1D8h]
  unsigned __int64 v528; // [sp+48h] [bp-1D8h]
  unsigned __int64 v529; // [sp+48h] [bp-1D8h]
  unsigned __int64 v530; // [sp+48h] [bp-1D8h]
  unsigned __int64 v531; // [sp+48h] [bp-1D8h]
  __int64 v532; // [sp+48h] [bp-1D8h]
  __int64 v533; // [sp+48h] [bp-1D8h]
  unsigned __int64 v534; // [sp+48h] [bp-1D8h]
  unsigned __int64 v535; // [sp+48h] [bp-1D8h]
  unsigned __int64 v536; // [sp+48h] [bp-1D8h]
  unsigned __int64 v537; // [sp+48h] [bp-1D8h]
  unsigned __int64 v538; // [sp+48h] [bp-1D8h]
  unsigned __int64 v539; // [sp+50h] [bp-1D0h]
  unsigned __int64 v540; // [sp+50h] [bp-1D0h]
  __int64 v541; // [sp+50h] [bp-1D0h]
  unsigned __int64 v542; // [sp+50h] [bp-1D0h]
  unsigned __int64 v543; // [sp+50h] [bp-1D0h]
  __int64 v544; // [sp+50h] [bp-1D0h]
  __int64 v545; // [sp+50h] [bp-1D0h]
  unsigned __int64 v546; // [sp+50h] [bp-1D0h]
  unsigned __int64 v547; // [sp+50h] [bp-1D0h]
  unsigned __int64 v548; // [sp+50h] [bp-1D0h]
  __int64 v549; // [sp+50h] [bp-1D0h]
  unsigned __int64 v550; // [sp+50h] [bp-1D0h]
  unsigned __int64 v551; // [sp+50h] [bp-1D0h]
  unsigned __int64 v552; // [sp+50h] [bp-1D0h]
  unsigned __int64 v553; // [sp+50h] [bp-1D0h]
  __int64 v554; // [sp+50h] [bp-1D0h]
  __int64 v555; // [sp+50h] [bp-1D0h]
  unsigned __int64 v556; // [sp+50h] [bp-1D0h]
  unsigned __int64 v557; // [sp+50h] [bp-1D0h]
  __int64 v558; // [sp+50h] [bp-1D0h]
  unsigned __int64 v559; // [sp+50h] [bp-1D0h]
  __int64 v560; // [sp+50h] [bp-1D0h]
  __int64 v561; // [sp+50h] [bp-1D0h]
  __int64 v562; // [sp+50h] [bp-1D0h]
  __int64 v563; // [sp+50h] [bp-1D0h]
  unsigned __int64 v564; // [sp+50h] [bp-1D0h]
  unsigned __int64 v565; // [sp+50h] [bp-1D0h]
  __int64 v566; // [sp+50h] [bp-1D0h]
  __int64 v567; // [sp+50h] [bp-1D0h]
  unsigned __int64 v568; // [sp+50h] [bp-1D0h]
  unsigned __int64 v569; // [sp+50h] [bp-1D0h]
  unsigned __int64 v570; // [sp+50h] [bp-1D0h]
  unsigned __int64 v571; // [sp+50h] [bp-1D0h]
  __int64 v572; // [sp+58h] [bp-1C8h]
  unsigned __int64 v573; // [sp+58h] [bp-1C8h]
  unsigned __int64 v574; // [sp+58h] [bp-1C8h]
  __int64 v575; // [sp+58h] [bp-1C8h]
  unsigned __int64 v576; // [sp+58h] [bp-1C8h]
  __int64 v577; // [sp+58h] [bp-1C8h]
  __int64 v578; // [sp+58h] [bp-1C8h]
  __int64 v579; // [sp+58h] [bp-1C8h]
  unsigned __int64 v580; // [sp+58h] [bp-1C8h]
  unsigned __int64 v581; // [sp+58h] [bp-1C8h]
  unsigned __int64 v582; // [sp+58h] [bp-1C8h]
  unsigned __int64 v583; // [sp+58h] [bp-1C8h]
  __int64 v584; // [sp+58h] [bp-1C8h]
  unsigned __int64 v585; // [sp+58h] [bp-1C8h]
  unsigned __int64 v586; // [sp+58h] [bp-1C8h]
  unsigned __int64 v587; // [sp+58h] [bp-1C8h]
  __int64 v588; // [sp+58h] [bp-1C8h]
  __int64 v589; // [sp+58h] [bp-1C8h]
  __int64 v590; // [sp+58h] [bp-1C8h]
  unsigned __int64 v591; // [sp+58h] [bp-1C8h]
  unsigned __int64 v592; // [sp+58h] [bp-1C8h]
  __int64 v593; // [sp+58h] [bp-1C8h]
  __int64 v594; // [sp+58h] [bp-1C8h]
  __int64 v595; // [sp+58h] [bp-1C8h]
  __int64 v596; // [sp+58h] [bp-1C8h]
  unsigned __int64 v597; // [sp+58h] [bp-1C8h]
  unsigned __int64 v598; // [sp+58h] [bp-1C8h]
  unsigned __int64 v599; // [sp+58h] [bp-1C8h]
  unsigned __int64 v600; // [sp+58h] [bp-1C8h]
  unsigned __int64 v601; // [sp+58h] [bp-1C8h]
  unsigned __int64 v602; // [sp+58h] [bp-1C8h]
  __int64 v603; // [sp+60h] [bp-1C0h]
  unsigned __int64 v604; // [sp+60h] [bp-1C0h]
  unsigned __int64 v605; // [sp+60h] [bp-1C0h]
  unsigned __int64 v606; // [sp+60h] [bp-1C0h]
  __int64 v607; // [sp+60h] [bp-1C0h]
  __int64 v608; // [sp+60h] [bp-1C0h]
  __int64 v609; // [sp+60h] [bp-1C0h]
  __int64 v610; // [sp+60h] [bp-1C0h]
  __int64 v611; // [sp+60h] [bp-1C0h]
  __int64 v612; // [sp+60h] [bp-1C0h]
  __int64 v613; // [sp+60h] [bp-1C0h]
  __int64 v614; // [sp+60h] [bp-1C0h]
  unsigned __int64 v615; // [sp+60h] [bp-1C0h]
  unsigned __int64 v616; // [sp+60h] [bp-1C0h]
  unsigned __int64 v617; // [sp+60h] [bp-1C0h]
  unsigned __int64 v618; // [sp+60h] [bp-1C0h]
  unsigned __int64 v619; // [sp+60h] [bp-1C0h]
  unsigned __int64 v620; // [sp+60h] [bp-1C0h]
  unsigned __int64 v621; // [sp+60h] [bp-1C0h]
  unsigned __int64 v622; // [sp+60h] [bp-1C0h]
  unsigned __int64 v623; // [sp+60h] [bp-1C0h]
  __int64 v624; // [sp+60h] [bp-1C0h]
  __int64 v625; // [sp+60h] [bp-1C0h]
  __int64 v626; // [sp+60h] [bp-1C0h]
  __int64 v627; // [sp+60h] [bp-1C0h]
  __int64 v628; // [sp+60h] [bp-1C0h]
  unsigned __int64 v629; // [sp+60h] [bp-1C0h]
  unsigned __int64 v630; // [sp+60h] [bp-1C0h]
  unsigned __int64 v631; // [sp+60h] [bp-1C0h]
  __int64 v632; // [sp+60h] [bp-1C0h]
  __int64 v633; // [sp+60h] [bp-1C0h]
  unsigned __int64 v634; // [sp+68h] [bp-1B8h]
  __int64 v635; // [sp+68h] [bp-1B8h]
  unsigned __int64 v636; // [sp+68h] [bp-1B8h]
  unsigned __int64 v637; // [sp+68h] [bp-1B8h]
  __int64 v638; // [sp+68h] [bp-1B8h]
  unsigned __int64 v639; // [sp+68h] [bp-1B8h]
  unsigned __int64 v640; // [sp+68h] [bp-1B8h]
  __int64 v641; // [sp+68h] [bp-1B8h]
  __int64 v642; // [sp+68h] [bp-1B8h]
  unsigned __int64 v643; // [sp+68h] [bp-1B8h]
  __int64 v644; // [sp+68h] [bp-1B8h]
  __int64 v645; // [sp+68h] [bp-1B8h]
  __int64 v646; // [sp+68h] [bp-1B8h]
  __int64 v647; // [sp+68h] [bp-1B8h]
  __int64 v648; // [sp+68h] [bp-1B8h]
  __int64 v649; // [sp+68h] [bp-1B8h]
  __int64 v650; // [sp+68h] [bp-1B8h]
  __int64 v651; // [sp+68h] [bp-1B8h]
  __int64 v652; // [sp+68h] [bp-1B8h]
  __int64 v653; // [sp+68h] [bp-1B8h]
  __int64 v654; // [sp+68h] [bp-1B8h]
  unsigned __int64 v655; // [sp+68h] [bp-1B8h]
  unsigned __int64 v656; // [sp+68h] [bp-1B8h]
  unsigned __int64 v657; // [sp+68h] [bp-1B8h]
  unsigned __int64 v658; // [sp+68h] [bp-1B8h]
  unsigned __int64 v659; // [sp+68h] [bp-1B8h]
  __int64 v660; // [sp+68h] [bp-1B8h]
  __int64 v661; // [sp+68h] [bp-1B8h]
  __int64 v662; // [sp+68h] [bp-1B8h]
  __int64 v663; // [sp+68h] [bp-1B8h]
  unsigned __int64 v664; // [sp+70h] [bp-1B0h]
  __int64 v665; // [sp+70h] [bp-1B0h]
  unsigned __int64 v666; // [sp+70h] [bp-1B0h]
  __int64 v667; // [sp+70h] [bp-1B0h]
  __int64 v668; // [sp+70h] [bp-1B0h]
  __int64 v669; // [sp+70h] [bp-1B0h]
  __int64 v670; // [sp+70h] [bp-1B0h]
  __int64 v671; // [sp+70h] [bp-1B0h]
  __int64 v672; // [sp+70h] [bp-1B0h]
  __int64 v673; // [sp+70h] [bp-1B0h]
  __int64 v674; // [sp+70h] [bp-1B0h]
  __int64 v675; // [sp+70h] [bp-1B0h]
  __int64 v676; // [sp+70h] [bp-1B0h]
  __int64 v677; // [sp+70h] [bp-1B0h]
  __int64 v678; // [sp+70h] [bp-1B0h]
  __int64 v679; // [sp+70h] [bp-1B0h]
  unsigned __int64 v680; // [sp+70h] [bp-1B0h]
  unsigned __int64 v681; // [sp+70h] [bp-1B0h]
  __int64 v682; // [sp+70h] [bp-1B0h]
  __int64 v683; // [sp+70h] [bp-1B0h]
  __int64 v684; // [sp+70h] [bp-1B0h]
  __int64 v685; // [sp+70h] [bp-1B0h]
  unsigned __int64 v686; // [sp+70h] [bp-1B0h]
  unsigned __int64 v687; // [sp+70h] [bp-1B0h]
  unsigned __int64 v688; // [sp+70h] [bp-1B0h]
  unsigned __int64 v689; // [sp+70h] [bp-1B0h]
  unsigned __int64 v690; // [sp+70h] [bp-1B0h]
  unsigned __int64 v691; // [sp+78h] [bp-1A8h]
  unsigned __int64 v692; // [sp+78h] [bp-1A8h]
  __int64 v693; // [sp+78h] [bp-1A8h]
  __int64 v694; // [sp+78h] [bp-1A8h]
  __int64 v695; // [sp+78h] [bp-1A8h]
  __int64 v696; // [sp+78h] [bp-1A8h]
  __int64 v697; // [sp+78h] [bp-1A8h]
  __int64 v698; // [sp+78h] [bp-1A8h]
  __int64 v699; // [sp+78h] [bp-1A8h]
  __int64 v700; // [sp+78h] [bp-1A8h]
  __int64 v701; // [sp+78h] [bp-1A8h]
  __int64 v702; // [sp+78h] [bp-1A8h]
  __int64 v703; // [sp+78h] [bp-1A8h]
  unsigned __int64 v704; // [sp+78h] [bp-1A8h]
  __int64 v705; // [sp+78h] [bp-1A8h]
  unsigned __int64 v706; // [sp+78h] [bp-1A8h]
  __int64 v707; // [sp+78h] [bp-1A8h]
  __int64 v708; // [sp+78h] [bp-1A8h]
  __int64 v709; // [sp+78h] [bp-1A8h]
  __int64 v710; // [sp+78h] [bp-1A8h]
  __int64 v711; // [sp+78h] [bp-1A8h]
  __int64 v712; // [sp+78h] [bp-1A8h]
  __int64 v713; // [sp+78h] [bp-1A8h]
  __int64 v714; // [sp+78h] [bp-1A8h]
  __int64 v715; // [sp+78h] [bp-1A8h]
  __int64 v716; // [sp+78h] [bp-1A8h]
  unsigned __int64 v717; // [sp+78h] [bp-1A8h]
  __int64 v718; // [sp+78h] [bp-1A8h]
  unsigned __int64 v719; // [sp+80h] [bp-1A0h]
  unsigned __int64 v720; // [sp+80h] [bp-1A0h]
  __int64 v721; // [sp+80h] [bp-1A0h]
  unsigned __int64 v722; // [sp+80h] [bp-1A0h]
  unsigned __int64 v723; // [sp+80h] [bp-1A0h]
  __int64 v724; // [sp+80h] [bp-1A0h]
  __int64 v725; // [sp+80h] [bp-1A0h]
  __int64 v726; // [sp+80h] [bp-1A0h]
  unsigned __int64 v727; // [sp+80h] [bp-1A0h]
  __int64 v728; // [sp+80h] [bp-1A0h]
  __int64 v729; // [sp+80h] [bp-1A0h]
  __int64 v730; // [sp+80h] [bp-1A0h]
  __int64 v731; // [sp+80h] [bp-1A0h]
  unsigned __int64 v732; // [sp+80h] [bp-1A0h]
  unsigned __int64 v733; // [sp+80h] [bp-1A0h]
  __int64 v734; // [sp+80h] [bp-1A0h]
  unsigned __int64 v735; // [sp+80h] [bp-1A0h]
  __int64 v736; // [sp+80h] [bp-1A0h]
  __int64 v737; // [sp+80h] [bp-1A0h]
  __int64 v738; // [sp+80h] [bp-1A0h]
  unsigned __int64 v739; // [sp+88h] [bp-198h]
  unsigned __int64 v740; // [sp+88h] [bp-198h]
  unsigned __int64 v741; // [sp+88h] [bp-198h]
  unsigned __int64 v742; // [sp+88h] [bp-198h]
  unsigned __int64 v743; // [sp+88h] [bp-198h]
  unsigned __int64 v744; // [sp+88h] [bp-198h]
  unsigned __int64 v745; // [sp+90h] [bp-190h]
  unsigned __int64 v746; // [sp+90h] [bp-190h]
  __int64 v747; // [sp+98h] [bp-188h]
  unsigned __int64 v748; // [sp+98h] [bp-188h]
  __int64 v749; // [sp+A0h] [bp-180h]
  __int64 v750; // [sp+A0h] [bp-180h]
  __int64 v751; // [sp+A0h] [bp-180h]
  unsigned __int64 v752; // [sp+A0h] [bp-180h]
  __int64 v753; // [sp+A0h] [bp-180h]
  __int64 v754; // [sp+A0h] [bp-180h]
  __int64 v755; // [sp+A0h] [bp-180h]
  __int64 v756; // [sp+A0h] [bp-180h]
  __int64 v757; // [sp+A0h] [bp-180h]
  __int64 v758; // [sp+A0h] [bp-180h]
  unsigned __int64 v759; // [sp+A0h] [bp-180h]
  __int64 v760; // [sp+A0h] [bp-180h]
  __int64 v761; // [sp+A0h] [bp-180h]
  __int64 v762; // [sp+A8h] [bp-178h]
  unsigned __int64 v763; // [sp+B0h] [bp-170h]
  unsigned __int64 v764; // [sp+B0h] [bp-170h]
  unsigned __int64 v765; // [sp+B8h] [bp-168h]
  unsigned __int64 v766; // [sp+B8h] [bp-168h]
  unsigned __int64 v767; // [sp+C0h] [bp-160h]
  __int64 v768; // [sp+C8h] [bp-158h]
  __int64 v769; // [sp+D0h] [bp-150h]
  unsigned __int64 v770; // [sp+D0h] [bp-150h]
  unsigned __int64 v771; // [sp+D0h] [bp-150h]
  unsigned __int64 v772; // [sp+D8h] [bp-148h]
  unsigned __int64 v773; // [sp+E0h] [bp-140h]
  unsigned __int64 v774; // [sp+E0h] [bp-140h]
  __int64 v775; // [sp+E8h] [bp-138h]
  unsigned __int64 v776; // [sp+F0h] [bp-130h]
  __int64 v777; // [sp+F8h] [bp-128h]
  __int64 v778; // [sp+F8h] [bp-128h]
  __int64 v779; // [sp+F8h] [bp-128h]
  __int64 v780; // [sp+F8h] [bp-128h]
  __int64 v781; // [sp+F8h] [bp-128h]
  __int64 v782; // [sp+F8h] [bp-128h]
  unsigned __int64 v783; // [sp+F8h] [bp-128h]
  unsigned __int64 v784; // [sp+F8h] [bp-128h]
  __int64 v785; // [sp+F8h] [bp-128h]
  __int64 v786; // [sp+F8h] [bp-128h]
  __int64 v787; // [sp+108h] [bp-118h]
  __int64 v789; // [sp+118h] [bp-108h] BYREF
  __int64 v790; // [sp+120h] [bp-100h]
  __int64 v791; // [sp+128h] [bp-F8h]
  __int64 v792; // [sp+130h] [bp-F0h]
  __int64 v793; // [sp+138h] [bp-E8h]
  __int64 v794; // [sp+140h] [bp-E0h]
  __int64 v795; // [sp+148h] [bp-D8h]
  __int64 v796; // [sp+150h] [bp-D0h]
  __int64 v797; // [sp+158h] [bp-C8h]
  __int64 v798; // [sp+160h] [bp-C0h]
  __int64 v799; // [sp+168h] [bp-B8h]
  __int64 v800; // [sp+170h] [bp-B0h]
  __int64 v801; // [sp+178h] [bp-A8h]
  __int64 v802; // [sp+180h] [bp-A0h]
  __int64 v803; // [sp+188h] [bp-98h]
  __int64 v804; // [sp+190h] [bp-90h]
  __int64 v805; // [sp+198h] [bp-88h] BYREF
  __int64 v806; // [sp+1A0h] [bp-80h] BYREF
  unsigned __int64 v807; // [sp+1A8h] [bp-78h]
  unsigned __int64 v808; // [sp+1B0h] [bp-70h]
  __int64 v809; // [sp+1B8h] [bp-68h]
  __int64 v810; // [sp+1C0h] [bp-60h]
  __int64 v811; // [sp+1C8h] [bp-58h]
  __int64 v812; // [sp+1D0h] [bp-50h]
  __int64 v813; // [sp+1D8h] [bp-48h] BYREF
  _QWORD v814[8]; // [sp+1E0h] [bp-40h] BYREF

  v2 = &v789;
  v3 = a2 + 128;
  do
  {
    v4 = a2[7];
    v5 = a2[6];
    v6 = vshld_n_s64(a2[5], 0x28u)
       | vshld_n_s64(a2[4], 0x20u)
       | vshld_n_s64(a2[3], 0x18u)
       | *a2
       | vshld_n_s64(a2[2], 0x10u)
       | vshld_n_s64(a2[1], 8u);
    a2 += 8;
    v2[1] = vshld_n_s64(v4, 0x38u) | vshld_n_s64(v5, 0x30u) | v6;
    ++v2;
  }
  while ( a2 != v3 );
  v7 = a1 - 8;
  v8 = &v805;
  do
  {
    v9 = *(_QWORD *)(v7 + 8);
    v7 += 8;
    v8[1] = v9;
    ++v8;
  }
  while ( v8 != &v813 );
  v10 = v807 + v811 + v792;
  v11 = __PAIR64__(
          *(_DWORD *)(a1 + 72) ^ 0x2B3E6C1F ^ (unsigned int)v10,
          (*(_QWORD *)(a1 + 72) ^ 0x9B05688C2B3E6C1FLL ^ v10) >> 32);
  v12 = __PAIR64__(
          *(_DWORD *)(a1 + 72) ^ 0x2B3E6C1F ^ (unsigned int)v10,
          (*(_QWORD *)(a1 + 72) ^ 0x9B05688C2B3E6C1FLL ^ v10) >> 32)
      - 0x4498517A7B3558C5LL;
  v13 = (__int64)((__PAIR64__(
                     *(_DWORD *)(a1 + 72) ^ 0x2B3E6C1F ^ (unsigned int)v10,
                     (*(_QWORD *)(a1 + 72) ^ 0x9B05688C2B3E6C1FLL ^ v10) >> 32)
                 - 0x4498517A7B3558C5LL)
                ^ v811) >> 24;
  v14 = ((unsigned int)((v12 ^ v811) >> 32) >> 24) | (((unsigned int)v12 ^ (unsigned int)v811) << 8);
  v461 = v10 + v793 + __PAIR64__(v14, v13);
  v15 = *(_QWORD *)(a1 + 80) ^ 0x1F83D9ABFB41BD6BLL;
  v16 = *(_QWORD *)(a1 + 64) ^ 0x510E527FADE682D1LL ^ (v806 + v810 + v790);
  HIDWORD(v739) = *(_DWORD *)(a1 + 88) ^ 0x137E2179 ^ (v809 + v813 + v796);
  LODWORD(v739) = (*(_QWORD *)(a1 + 88) ^ 0x5BE0CD19137E2179LL ^ (unsigned __int64)(v809 + v813 + v796)) >> 32;
  v719 = __PAIR64__(v15 ^ (v812 + v808 + v794), (v15 ^ (v812 + v808 + v794)) >> 32);
  v17 = v11 ^ v461;
  LODWORD(v375) = v17 >> 16;
  v361 = __PAIR64__(v15 ^ (v812 + v808 + v794), (v15 ^ (v812 + v808 + v794)) >> 32) + 0x3C6EF372FE94F82BLL;
  HIDWORD(v375) = HIWORD(HIDWORD(v17)) | ((_DWORD)v17 << 16);
  v18 = (v739 - 0x5AB00AC5A0E2C90FLL) ^ v813;
  LODWORD(v389) = ((((_DWORD)v739 + 1595750129) ^ (unsigned int)v813) >> 24) | (HIDWORD(v18) << 8);
  HIDWORD(v389) = HIBYTE(HIDWORD(v18)) | ((((_DWORD)v739 + 1595750129) ^ (unsigned int)v813) << 8);
  LODWORD(v762) = (__int64)(v361 ^ v812) >> 24;
  LODWORD(v769) = (__int64)((__PAIR64__(v16, HIDWORD(v16)) + 0x6A09E667F3BCC908LL) ^ v810) >> 24;
  HIDWORD(v769) = ((unsigned int)(((__PAIR64__(v16, HIDWORD(v16)) + 0x6A09E667F3BCC908LL) ^ v810) >> 32) >> 24)
                | (((HIDWORD(v16) - 205731576) ^ (unsigned int)v810) << 8);
  v572 = v375 + v12;
  v19 = (v375 + v12) ^ __PAIR64__(v14, v13);
  HIDWORD(v762) = ((unsigned int)((v361 ^ v812) >> 32) >> 24) | (((unsigned int)v361 ^ (unsigned int)v812) << 8);
  HIDWORD(v773) = v19 >> 31;
  v603 = v809 + v813 + v796 + v797 + v389;
  LODWORD(v773) = (2 * v19) | (HIDWORD(v19) >> 31);
  v478 = v806 + v810 + v790 + v791 + v769;
  v510 = v812 + v808 + v794 + v795 + v762;
  LODWORD(v691) = (__int64)(v603 ^ v739) >> 16;
  HIDWORD(v691) = ((unsigned int)((v603 ^ v739) >> 32) >> 16) | (((unsigned int)v603 ^ (unsigned int)v739) << 16);
  LODWORD(v406) = (__int64)(v510 ^ v719) >> 16;
  HIDWORD(v406) = ((unsigned int)((v510 ^ v719) >> 32) >> 16) | (((unsigned int)v510 ^ (unsigned int)v719) << 16);
  HIDWORD(v20) = (v478 + v798 + v773) ^ v691;
  LODWORD(v20) = ((v478 + v798 + v773) ^ v691) >> 32;
  v21 = (v406 + v361) ^ v762;
  v539 = v20 + v406 + v361;
  LODWORD(v17) = (__int64)(v478 ^ __PAIR64__(v16, HIDWORD(v16))) >> 16;
  HIDWORD(v17) = ((HIDWORD(v478) ^ (unsigned int)v16) >> 16) | (((unsigned int)v478 ^ HIDWORD(v16)) << 16);
  LODWORD(v343) = (__int64)(v539 ^ v773) >> 24;
  HIDWORD(v343) = ((unsigned int)((v539 ^ v773) >> 32) >> 24) | (((unsigned int)v539 ^ (unsigned int)v773) << 8);
  HIDWORD(v361) = v21 >> 31;
  LODWORD(v361) = (2 * v21) | (HIDWORD(v21) >> 31);
  v634 = v478 + v798 + v773 + v799 + v343;
  v479 = v17 + __PAIR64__(v16, HIDWORD(v16)) + 0x6A09E667F3BCC908LL;
  v664 = v461 + v800 + v361;
  LODWORD(v461) = (__int64)(v634 ^ v20) >> 16;
  v22 = v691 + v739 - 0x5AB00AC5A0E2C90FLL;
  v434 = __PAIR64__((unsigned int)v17 ^ (unsigned int)v664, (v17 ^ v664) >> 32);
  v692 = __PAIR64__((unsigned int)v17 ^ (unsigned int)v664, (v17 ^ v664) >> 32) + v22;
  v23 = v22 ^ v389;
  HIDWORD(v461) = ((unsigned int)((v634 ^ v20) >> 32) >> 16) | (((unsigned int)v634 ^ (unsigned int)v20) << 16);
  LODWORD(v389) = (2 * (v479 ^ v769)) | ((unsigned int)((v479 ^ v769) >> 32) >> 31);
  v540 = v461 + v539;
  LODWORD(v420) = (2 * v23) | (HIDWORD(v23) >> 31);
  HIDWORD(v420) = v23 >> 31;
  v665 = v664 + v801;
  HIDWORD(v389) = (__int64)(v479 ^ v769) >> 31;
  v24 = v692 ^ v361;
  v25 = v603 + v804 + v389;
  v362 = __PAIR64__((unsigned int)v25 ^ (unsigned int)v406, (v25 ^ v406) >> 32);
  v407 = v25 + v805;
  v749 = v510 + v802 + v420 + v803;
  v26 = (v510 + v802 + v420) ^ v375;
  v635 = v634 + v804;
  v376 = (2 * (v540 ^ v343)) | ((unsigned int)((v540 ^ v343) >> 32) >> 31);
  v27 = (v362 + v572) ^ v389;
  v390 = __PAIR64__(HIBYTE(HIDWORD(v24)) | ((_DWORD)v24 << 8), v24 >> 24);
  LODWORD(v343) = v27 >> 24;
  HIDWORD(v343) = HIBYTE(HIDWORD(v27)) | ((_DWORD)v27 << 8);
  v604 = v25 + v805 + v343;
  v28 = (v665 + __PAIR64__(HIBYTE(HIDWORD(v24)) | ((_DWORD)v24 << 8), v24 >> 24)) ^ v434;
  v29 = __PAIR64__(v26, HIDWORD(v26));
  v30 = (v407 + v343) ^ v362;
  LODWORD(v407) = v28 >> 16;
  v480 = __PAIR64__(v26, HIDWORD(v26)) + v479;
  HIDWORD(v407) = HIWORD(HIDWORD(v28)) | ((_DWORD)v28 << 16);
  LODWORD(v434) = v30 >> 16;
  v720 = v665 + v390 + v794 + v376;
  HIDWORD(v434) = HIWORD(HIDWORD(v30)) | ((_DWORD)v30 << 16);
  v31 = v362 + v572;
  v573 = v407 + v692;
  LODWORD(v26) = (__int64)(v480 ^ v420) >> 24;
  HIDWORD(v26) = ((unsigned int)((v480 ^ v420) >> 32) >> 24) | (((unsigned int)v480 ^ (unsigned int)v420) << 8);
  v32 = (v407 + v692) ^ v390;
  v33 = (v434 + v31) ^ v343;
  LODWORD(v362) = (2 * v32) | (HIDWORD(v32) >> 31);
  HIDWORD(v362) = v32 >> 31;
  LODWORD(v420) = (2 * v33) | (HIDWORD(v33) >> 31);
  v34 = (v749 + v26) ^ v29;
  HIDWORD(v420) = v33 >> 31;
  LODWORD(v32) = v34 >> 16;
  HIDWORD(v32) = HIWORD(HIDWORD(v34)) | ((_DWORD)v34 << 16);
  v391 = v635 + v420;
  v740 = (v749 + v26 + v799 + v362) ^ v434;
  v344 = __PAIR64__((unsigned int)v720 ^ (unsigned int)v32, (v720 ^ v32) >> 32);
  v408 = __PAIR64__((v635 + v420) ^ v407, ((v635 + v420) ^ v407) >> 32);
  v481 = v32 + v480;
  v636 = __PAIR64__((unsigned int)v720 ^ (unsigned int)v32, (v720 ^ v32) >> 32) + v434 + v31;
  HIDWORD(v29) = (v749 + v26 + v799 + v362) ^ v434;
  v750 = v749 + v26 + v799 + v362 + v805;
  v693 = v391 + v800;
  v435 = __PAIR64__(HIDWORD(v29), HIDWORD(v740));
  v666 = __PAIR64__(HIDWORD(v29), HIDWORD(v740)) + v540;
  v35 = v481 ^ v26;
  v511 = v408 + v481;
  v36 = (v408 + v481) ^ v420;
  LODWORD(v31) = (__int64)(v636 ^ v376) >> 24;
  HIDWORD(v31) = ((unsigned int)((v636 ^ v376) >> 32) >> 24) | (((unsigned int)v636 ^ (unsigned int)v376) << 8);
  LODWORD(v391) = (2 * (v481 ^ v26)) | ((unsigned int)((v481 ^ v26) >> 32) >> 31);
  LODWORD(v26) = v36 >> 24;
  v721 = v720 + v798 + v31;
  HIDWORD(v391) = v35 >> 31;
  v482 = __PAIR64__(
           ((unsigned int)(((v435 + v540) ^ v362) >> 32) >> 24)
         | (((HIDWORD(v740) + (_DWORD)v540) ^ (unsigned int)v362) << 8),
           (__int64)((v435 + v540) ^ v362) >> 24);
  HIDWORD(v26) = HIBYTE(HIDWORD(v36)) | ((_DWORD)v36 << 8);
  v37 = __PAIR64__(
          ((unsigned int)(((v435 + v540) ^ v362) >> 32) >> 24)
        | (((HIDWORD(v740) + (_DWORD)v540) ^ (unsigned int)v362) << 8),
          (__int64)((v435 + v540) ^ v362) >> 24);
  v541 = v693 + v26;
  v694 = v750 + v37;
  LODWORD(v420) = (__int64)(v721 ^ v344) >> 16;
  HIDWORD(v420) = ((unsigned int)((v721 ^ v344) >> 32) >> 16) | (((unsigned int)v721 ^ (unsigned int)v344) << 16);
  v38 = (v750 + v37) ^ v435;
  LODWORD(v376) = (__int64)(v541 ^ v408) >> 16;
  HIDWORD(v376) = ((unsigned int)((v541 ^ v408) >> 32) >> 16) | (((unsigned int)v541 ^ (unsigned int)v408) << 16);
  v436 = v420 + v636;
  v39 = (v420 + v636) ^ v31;
  v345 = __PAIR64__(HIWORD(HIDWORD(v38)) | ((_DWORD)v38 << 16), v38 >> 16);
  v512 = v376 + v511;
  v637 = __PAIR64__(HIWORD(HIDWORD(v38)) | ((_DWORD)v38 << 16), v38 >> 16) + v666;
  LODWORD(v362) = (2 * v39) | (HIDWORD(v39) >> 31);
  v40 = v604 + v803 + v391;
  v41 = (__PAIR64__(HIWORD(HIDWORD(v38)) | ((_DWORD)v38 << 16), v38 >> 16) + v666) ^ v482;
  HIDWORD(v362) = v39 >> 31;
  LODWORD(v408) = (2 * (v512 ^ v26)) | ((unsigned int)((v512 ^ v26) >> 32) >> 31);
  HIDWORD(v38) = (__int64)(v512 ^ v26) >> 31;
  LODWORD(v26) = (v40 ^ v461) >> 32;
  HIDWORD(v26) = v40 ^ v461;
  v483 = v26 + v573;
  HIDWORD(v408) = HIDWORD(v38);
  v42 = (v26 + v573) ^ v391;
  LODWORD(v391) = v42 >> 24;
  HIDWORD(v391) = HIBYTE(HIDWORD(v42)) | ((_DWORD)v42 << 8);
  HIDWORD(v461) = v41 >> 31;
  LODWORD(v461) = (2 * v41) | (HIDWORD(v41) >> 31);
  v542 = v541 + v791 + v362;
  v43 = v40 + v796 + v391;
  v44 = v721 + v790 + v461;
  v45 = v43 + v795;
  v46 = v43 ^ v26;
  v47 = v44 ^ v376;
  v48 = v45 + v408;
  v777 = v44 + v792;
  LODWORD(v38) = v46 >> 16;
  HIDWORD(v38) = HIWORD(HIDWORD(v46)) | ((_DWORD)v46 << 16);
  v49 = v345;
  v346 = v542 ^ v38;
  LODWORD(v46) = (v48 ^ v49) >> 32;
  v484 = v38 + v483;
  HIDWORD(v46) = v48 ^ v49;
  v667 = v46 + v436;
  v751 = v542 + v802;
  v377 = (2 * (v484 ^ v391)) | ((unsigned int)((v484 ^ v391) >> 32) >> 31);
  v50 = (v46 + v436) ^ v408;
  v51 = v694 + v801 + v377;
  LODWORD(v436) = v50 >> 24;
  HIDWORD(v436) = HIBYTE(HIDWORD(v50)) | ((_DWORD)v50 << 8);
  v695 = v48 + v793 + v436;
  v52 = v51 ^ v420;
  v574 = __PAIR64__(v346, HIDWORD(v346)) + v637;
  v53 = v695 ^ v46;
  v605 = __PAIR64__(v47, HIDWORD(v47)) + v484;
  v54 = (__PAIR64__(v346, HIDWORD(v346)) + v637) ^ v362;
  v421 = __PAIR64__(HIWORD(HIDWORD(v53)) | ((_DWORD)v53 << 16), v53 >> 16);
  v55 = (__PAIR64__(v47, HIDWORD(v47)) + v484) ^ v461;
  v485 = v51 + v797;
  v363 = __PAIR64__(v52, HIDWORD(v52));
  v543 = __PAIR64__(v52, HIDWORD(v52)) + v512;
  LODWORD(v408) = v54 >> 24;
  v668 = __PAIR64__(HIWORD(HIDWORD(v53)) | ((_DWORD)v53 << 16), v53 >> 16) + v667;
  v56 = (__PAIR64__(v52, HIDWORD(v52)) + v512) ^ v377;
  v722 = __PAIR64__(HIBYTE(HIDWORD(v55)) | ((_DWORD)v55 << 8), v55 >> 24);
  v57 = v668 ^ v436;
  HIDWORD(v408) = HIBYTE(HIDWORD(v54)) | ((_DWORD)v54 << 8);
  LODWORD(v461) = (2 * v57) | (HIDWORD(v57) >> 31);
  v437 = v777 + __PAIR64__(HIBYTE(HIDWORD(v55)) | ((_DWORD)v55 << 8), v55 >> 24);
  v58 = (v751 + v408) ^ __PAIR64__(v346, HIDWORD(v346));
  HIDWORD(v461) = v57 >> 31;
  LODWORD(v51) = v56 >> 24;
  HIDWORD(v51) = HIBYTE(HIDWORD(v56)) | ((_DWORD)v56 << 8);
  LODWORD(v391) = v58 >> 16;
  v638 = v485 + v51;
  HIDWORD(v391) = HIWORD(HIDWORD(v58)) | ((_DWORD)v58 << 16);
  LODWORD(v56) = (__int64)(v437 ^ __PAIR64__(v47, HIDWORD(v47))) >> 16;
  v752 = v751 + v408 + v801 + v461;
  HIDWORD(v56) = ((unsigned int)((v437 ^ __PAIR64__(v47, HIDWORD(v47))) >> 32) >> 16)
               | (((unsigned int)v437 ^ HIDWORD(v47)) << 16);
  v486 = v391 + v574;
  v59 = (v391 + v574) ^ v408;
  v513 = v56 + v605;
  v364 = __PAIR64__(
           ((unsigned int)((v638 ^ v363) >> 32) >> 16) | (((unsigned int)v638 ^ (unsigned int)v363) << 16),
           (__int64)(v638 ^ v363) >> 16);
  LODWORD(v377) = (2 * v59) | (HIDWORD(v59) >> 31);
  HIDWORD(v377) = v59 >> 31;
  v347 = __PAIR64__((unsigned int)v56 ^ (unsigned int)v752, (v56 ^ v752) >> 32);
  LODWORD(v408) = (2 * (v513 ^ v722)) | ((unsigned int)((v513 ^ v722) >> 32) >> 31);
  v60 = v51 ^ (v364 + v543);
  HIDWORD(v408) = (__int64)((v56 + v605) ^ v722) >> 31;
  v606 = __PAIR64__((unsigned int)v56 ^ (unsigned int)v752, (v56 ^ v752) >> 32) + v364 + v543;
  v575 = v752 + v798;
  v61 = v437 + v802 + v377;
  v62 = v606 ^ v461;
  v63 = (__int64)(v606 ^ v461) >> 24;
  v778 = v695 + v805;
  v462 = __PAIR64__((unsigned int)v61 ^ (unsigned int)v364, (v61 ^ v364) >> 32);
  v696 = v61 + v790;
  v438 = __PAIR64__((v638 + v795 + v408) ^ v421, ((v638 + v795 + v408) ^ v421) >> 32);
  v753 = v638 + v795 + v408 + v792;
  v64 = __PAIR64__((v638 + v795 + v408) ^ v421, ((v638 + v795 + v408) ^ v421) >> 32);
  LODWORD(v421) = v63;
  v639 = v64 + v486;
  HIDWORD(v421) = HIBYTE(HIDWORD(v62)) | ((_DWORD)v62 << 8);
  v544 = __PAIR64__((unsigned int)v61 ^ (unsigned int)v364, (v61 ^ v364) >> 32) + v668;
  v65 = (__PAIR64__((unsigned int)v61 ^ (unsigned int)v364, (v61 ^ v364) >> 32) + v668) ^ v377;
  v365 = (2 * v60) | (HIDWORD(v60) >> 31);
  v66 = (v64 + v486) ^ v408;
  v67 = v778 + v365;
  v779 = v778 + v365 + v803;
  LODWORD(v60) = v65 >> 24;
  v68 = (v575 + v421) ^ v347;
  HIDWORD(v60) = HIBYTE(HIDWORD(v65)) | ((_DWORD)v65 << 8);
  v409 = v67 ^ v391;
  HIDWORD(v486) = HIBYTE(HIDWORD(v66)) | ((_DWORD)v66 << 8);
  LODWORD(v486) = v66 >> 24;
  v789 = v575 + v421 + v800;
  v669 = v753 + v486;
  v69 = (v696 + v60) ^ v462;
  v70 = (v753 + v486) ^ v438;
  HIDWORD(v391) = HIWORD(HIDWORD(v68)) | ((_DWORD)v68 << 16);
  v697 = v696 + v60 + v793;
  LODWORD(v391) = v68 >> 16;
  v576 = __PAIR64__(v409, HIDWORD(v409));
  v71 = __PAIR64__(v409, HIDWORD(v409));
  v410 = __PAIR64__(HIWORD(HIDWORD(v69)) | ((_DWORD)v69 << 16), v69 >> 16);
  v439 = v71 + v513;
  v72 = (v71 + v513) ^ v365;
  HIDWORD(v347) = HIWORD(HIDWORD(v70)) | ((_DWORD)v70 << 16);
  LODWORD(v347) = v70 >> 16;
  v514 = v391 + v606;
  v607 = __PAIR64__(HIWORD(HIDWORD(v69)) | ((_DWORD)v69 << 16), v69 >> 16) + v544;
  LODWORD(v462) = v72 >> 24;
  LODWORD(v377) = (2 * (v514 ^ v63)) | ((unsigned int)((v514 ^ v421) >> 32) >> 31);
  v73 = (__PAIR64__(HIWORD(HIDWORD(v69)) | ((_DWORD)v69 << 16), v69 >> 16) + v544) ^ v60;
  HIDWORD(v462) = HIBYTE(HIDWORD(v72)) | ((_DWORD)v72 << 8);
  v74 = (v347 + v639) ^ v486;
  LODWORD(v365) = (2 * (((v69 >> 16) + v544) ^ v60)) | (HIDWORD(v73) >> 31);
  HIDWORD(v365) = v73 >> 31;
  v75 = (v779 + v462) ^ v576;
  HIDWORD(v377) = (__int64)(v514 ^ v421) >> 31;
  LODWORD(v60) = (2 * v74) | (HIDWORD(v74) >> 31);
  HIDWORD(v60) = v74 >> 31;
  LODWORD(v73) = v75 >> 16;
  HIDWORD(v73) = HIWORD(HIDWORD(v75)) | ((_DWORD)v75 << 16);
  v577 = v73 + v439;
  v76 = (v697 + v60) ^ v391;
  v422 = __PAIR64__((v789 + v365) ^ v73, ((v789 + v365) ^ (unsigned __int64)v73) >> 32);
  v698 = v697 + v60 + v796;
  v77 = (v73 + v439) ^ v462;
  v440 = __PAIR64__(v76, HIDWORD(v76));
  v78 = __PAIR64__((v789 + v365) ^ v73, ((v789 + v365) ^ (unsigned __int64)v73) >> 32) + v347 + v639;
  LODWORD(v391) = (2 * v77) | (HIDWORD(v77) >> 31);
  v578 = __PAIR64__(v76, HIDWORD(v76)) + v577;
  HIDWORD(v77) = v77 >> 31;
  v79 = v578 ^ v60;
  LODWORD(v77) = (__int64)(v78 ^ v365) >> 24;
  HIDWORD(v391) = HIDWORD(v77);
  HIDWORD(v77) = ((unsigned int)((v78 ^ v365) >> 32) >> 24) | (((unsigned int)v78 ^ (unsigned int)v365) << 8);
  LODWORD(v60) = (__int64)(v578 ^ v60) >> 24;
  HIDWORD(v60) = HIBYTE(HIDWORD(v79)) | ((_DWORD)v79 << 8);
  v545 = v789 + v365 + v804 + v77;
  v723 = v698 + v60;
  v80 = (v698 + v60) ^ v440;
  HIDWORD(v365) = ((unsigned int)(HIDWORD(v545) ^ HIDWORD(v422)) >> 16)
                | (((unsigned int)v545 ^ (unsigned int)v422) << 16);
  LODWORD(v365) = (__int64)(v545 ^ v422) >> 16;
  LODWORD(v486) = v80 >> 16;
  HIDWORD(v486) = HIWORD(HIDWORD(v80)) | ((_DWORD)v80 << 16);
  v441 = v365 + v78;
  v579 = v486 + v578;
  v81 = v77 ^ (v365 + v78);
  v82 = v669 + v797 + v391;
  v83 = v779 + v462 + v799 + v377;
  LODWORD(v422) = (2 * v81) | (HIDWORD(v81) >> 31);
  HIDWORD(v422) = v81 >> 31;
  v640 = v82 ^ v410;
  v84 = (2 * (v579 ^ v60)) | ((unsigned int)((v579 ^ v60) >> 32) >> 31);
  HIDWORD(v410) = (__int64)(v579 ^ v60) >> 31;
  v463 = __PAIR64__((unsigned int)v83 ^ (unsigned int)v347, (v83 ^ v347) >> 32);
  v670 = v82 + v791;
  v608 = __PAIR64__((unsigned int)v83 ^ (unsigned int)v347, (v83 ^ v347) >> 32) + v607;
  v754 = v545 + v797;
  LODWORD(v82) = (v608 ^ v377) >> 24;
  v780 = v698 + v60 + v793 + v422 + v791;
  HIDWORD(v82) = ((unsigned int)((v608 ^ (unsigned __int64)v377) >> 32) >> 24)
               | (((unsigned int)v608 ^ (unsigned int)v377) << 8);
  v85 = v83 + v794 + v82;
  v348 = __PAIR64__(v640, HIDWORD(v640)) + v514;
  LODWORD(v410) = v84;
  v86 = v85 + v801;
  v87 = v85 ^ v463;
  v699 = v86;
  LODWORD(v83) = v87 >> 16;
  HIDWORD(v83) = HIWORD(HIDWORD(v87)) | ((_DWORD)v87 << 16);
  v88 = (__PAIR64__(v640, HIDWORD(v640)) + v514) ^ v391;
  v515 = v83 + v608;
  LODWORD(v87) = v88 >> 24;
  HIDWORD(v87) = HIBYTE(HIDWORD(v88)) | ((_DWORD)v88 << 8);
  v89 = (v83 + v608) ^ v82;
  LODWORD(v391) = (2 * v89) | (HIDWORD(v89) >> 31);
  HIDWORD(v391) = v89 >> 31;
  v90 = (v670 + v87) ^ __PAIR64__(v640, HIDWORD(v640));
  LODWORD(v89) = v90 >> 16;
  HIDWORD(v89) = HIWORD(HIDWORD(v90)) | ((_DWORD)v90 << 16);
  LODWORD(v377) = ((v545 + v797 + v391) ^ v486) >> 32;
  v91 = (v670 + v87 + v803 + v410) ^ v83;
  HIDWORD(v377) = (v545 + v797 + v391) ^ v486;
  v487 = v377 + v89 + v348;
  v92 = (v89 + v348) ^ v87;
  v464 = __PAIR64__(v89 ^ (v723 + v793 + v422), (v89 ^ (v723 + v793 + v422)) >> 32);
  v641 = v670 + v87 + v803 + v410 + v802;
  v609 = __PAIR64__(v89 ^ (v723 + v793 + v422), (v89 ^ (v723 + v793 + v422)) >> 32) + v515;
  v741 = __PAIR64__(v91, HIDWORD(v91));
  LODWORD(v348) = (__int64)(v487 ^ v391) >> 24;
  v93 = __PAIR64__(v91, HIDWORD(v91)) + v441;
  HIDWORD(v348) = ((unsigned int)((v487 ^ v391) >> 32) >> 24) | (((unsigned int)v487 ^ (unsigned int)v391) << 8);
  v94 = (__PAIR64__(v89 ^ (v723 + v793 + v422), (v89 ^ (v723 + v793 + v422)) >> 32) + v515) ^ v422;
  v546 = v93;
  LODWORD(v87) = (2 * v92) | (HIDWORD(v92) >> 31);
  HIDWORD(v87) = v92 >> 31;
  v95 = v93 ^ v410;
  LODWORD(v723) = v94 >> 24;
  v671 = v699 + v87;
  v96 = (__int64)(v93 ^ v410) >> 24;
  v516 = v754 + v391 + v799 + v348;
  HIDWORD(v723) = HIBYTE(HIDWORD(v94)) | ((_DWORD)v94 << 8);
  v423 = __PAIR64__(HIBYTE(HIDWORD(v95)) | ((_DWORD)v95 << 8), v96);
  v392 = __PAIR64__(
           ((unsigned int)((v516 ^ v377) >> 32) >> 16)
         | ((((_DWORD)v754 + (_DWORD)v391 + (_DWORD)v799 + (_DWORD)v348) ^ (unsigned int)v377) << 16),
           (__int64)(v516 ^ v377) >> 16);
  v642 = v641 + __PAIR64__(HIBYTE(HIDWORD(v95)) | ((_DWORD)v95 << 8), v96);
  v366 = __PAIR64__((v699 + v87) ^ v365, ((v699 + v87) ^ (unsigned __int64)v365) >> 32);
  v97 = (v780 + v723) ^ v464;
  v700 = v366 + v579;
  v580 = v392 + v487;
  v98 = (v392 + v487) ^ v348;
  LODWORD(v410) = v97 >> 16;
  v99 = v700 ^ v87;
  LODWORD(v87) = (__int64)(v642 ^ v741) >> 16;
  LODWORD(v377) = (2 * v98) | (HIDWORD(v98) >> 31);
  HIDWORD(v377) = v98 >> 31;
  HIDWORD(v87) = ((unsigned int)((v642 ^ v741) >> 32) >> 16) | (((unsigned int)v642 ^ (unsigned int)v741) << 16);
  HIDWORD(v410) = HIWORD(HIDWORD(v97)) | ((_DWORD)v97 << 16);
  LODWORD(v464) = v99 >> 24;
  HIDWORD(v464) = HIBYTE(HIDWORD(v99)) | ((_DWORD)v99 << 8);
  v610 = v410 + v609;
  v547 = v87 + v546;
  v100 = v671 + v804 + v464;
  v101 = v547 ^ v423;
  v755 = v780 + v723 + v795;
  LODWORD(v348) = (2 * (v547 ^ v423)) | ((unsigned int)((v547 ^ v423) >> 32) >> 31);
  v102 = v100 + v805;
  v103 = v100 ^ v366;
  v104 = v102 + v377;
  LODWORD(v423) = v103 >> 16;
  HIDWORD(v423) = HIWORD(HIDWORD(v103)) | ((_DWORD)v103 << 16);
  LODWORD(v366) = (2 * (v610 ^ v723)) | ((unsigned int)((v610 ^ v723) >> 32) >> 31);
  HIDWORD(v348) = v101 >> 31;
  v488 = __PAIR64__((unsigned int)v104 ^ (unsigned int)v87, HIDWORD(v104) ^ HIDWORD(v87));
  HIDWORD(v366) = (__int64)(v610 ^ v723) >> 31;
  v672 = v423 + v700;
  v724 = v516 + v792;
  v105 = v423 + v700;
  v701 = __PAIR64__((unsigned int)v104 ^ (unsigned int)v87, HIDWORD(v104) ^ HIDWORD(v87)) + v610;
  v517 = v755 + v348;
  v442 = (2 * (v105 ^ v464)) | ((unsigned int)((v105 ^ v464) >> 32) >> 31);
  v106 = (__PAIR64__((unsigned int)v104 ^ (unsigned int)v87, HIDWORD(v104) ^ HIDWORD(v87)) + v610) ^ v377;
  v378 = v104 + v798;
  v611 = v642 + v794 + v442;
  LODWORD(v105) = v106 >> 24;
  v107 = (v755 + v348) ^ v392;
  HIDWORD(v105) = HIBYTE(HIDWORD(v106)) | ((_DWORD)v106 << 8);
  v756 = v378 + v105;
  v393 = (v724 + v366) ^ v423;
  v108 = v611 ^ v410;
  v109 = v378 + v105;
  v379 = v517 + v800;
  v110 = v109 ^ v488;
  v411 = __PAIR64__(v107, HIDWORD(v107));
  v725 = v724 + v366 + v796;
  v781 = v611 + v790;
  v612 = __PAIR64__(v107, HIDWORD(v107)) + v672;
  LODWORD(v464) = v110 >> 16;
  HIDWORD(v464) = HIWORD(HIDWORD(v110)) | ((_DWORD)v110 << 16);
  v111 = __PAIR64__(v393, HIDWORD(v393));
  v518 = __PAIR64__(v393, HIDWORD(v393)) + v547;
  v424 = __PAIR64__(v108, HIDWORD(v108));
  v702 = v464 + v701;
  v112 = (__PAIR64__(v393, HIDWORD(v393)) + v547) ^ v366;
  v643 = v424 + v580;
  v113 = v105 ^ v702;
  LODWORD(v488) = (2 * v113) | (HIDWORD(v113) >> 31);
  v114 = (v424 + v580) ^ v442;
  HIDWORD(v488) = v113 >> 31;
  LODWORD(v393) = v112 >> 24;
  HIDWORD(v393) = HIBYTE(HIDWORD(v112)) | ((_DWORD)v112 << 8);
  HIDWORD(v366) = ((unsigned int)((v612 ^ v348) >> 32) >> 24) | (((unsigned int)v612 ^ (unsigned int)v348) << 8);
  LODWORD(v366) = (__int64)(v612 ^ v348) >> 24;
  LODWORD(v348) = v114 >> 24;
  HIDWORD(v348) = HIBYTE(HIDWORD(v114)) | ((_DWORD)v114 << 8);
  v548 = v379 + v366;
  v115 = (v725 + v393) ^ v111;
  v673 = v781 + v348;
  v116 = (v379 + v366) ^ v411;
  v117 = v725 + v393 + v799 + v488;
  LODWORD(v379) = v115 >> 16;
  v118 = (v781 + v348) ^ v424;
  v782 = v117 + v790;
  LODWORD(v114) = v116 >> 16;
  HIDWORD(v114) = HIWORD(HIDWORD(v116)) | ((_DWORD)v116 << 16);
  HIDWORD(v379) = HIWORD(HIDWORD(v115)) | ((_DWORD)v115 << 16);
  LODWORD(v424) = v118 >> 16;
  HIDWORD(v424) = HIWORD(HIDWORD(v118)) | ((_DWORD)v118 << 16);
  v581 = v379 + v518;
  v443 = __PAIR64__((unsigned int)v114 ^ (unsigned int)v117, (v114 ^ v117) >> 32);
  v119 = (v379 + v518) ^ v393;
  v519 = v114 + v612;
  v120 = __PAIR64__((unsigned int)v114 ^ (unsigned int)v117, (v114 ^ v117) >> 32) + v424 + v643;
  v121 = (v114 + v612) ^ v366;
  LODWORD(v411) = (2 * v119) | (HIDWORD(v119) >> 31);
  HIDWORD(v411) = v119 >> 31;
  LODWORD(v87) = (2 * (v519 ^ v366)) | ((unsigned int)((v519 ^ v366) >> 32) >> 31);
  HIDWORD(v114) = ((unsigned int)((v120 ^ v488) >> 32) >> 24) | (((unsigned int)v120 ^ (unsigned int)v488) << 8);
  HIDWORD(v87) = v121 >> 31;
  LODWORD(v114) = (__int64)(v120 ^ v488) >> 24;
  v489 = v782 + v114;
  v122 = (v782 + v114) ^ v443;
  LODWORD(v366) = v122 >> 16;
  HIDWORD(v366) = HIWORD(HIDWORD(v122)) | ((_DWORD)v122 << 16);
  v444 = v366 + v120;
  v394 = (2 * ((v424 + v643) ^ v348)) | ((unsigned int)(((v424 + v643) ^ v348) >> 32) >> 31);
  v123 = v548 + v795 + v411;
  v124 = v114 ^ (v366 + v120);
  v425 = __PAIR64__((unsigned int)v123 ^ (unsigned int)v424, (v123 ^ v424) >> 32);
  v549 = v123 + v797;
  v349 = __PAIR64__((v673 + v792 + v87) ^ v464, ((v673 + v792 + v87) ^ v464) >> 32);
  v644 = v673 + v792 + v87 + v794;
  v613 = v425 + v702;
  v582 = __PAIR64__((v673 + v792 + v87) ^ v464, ((v673 + v792 + v87) ^ v464) >> 32) + v581;
  v465 = (v756 + v800 + v394) ^ v379;
  HIDWORD(v379) = v124 >> 31;
  v125 = (v425 + v702) ^ v411;
  v674 = v756 + v800 + v394 + v805;
  LODWORD(v411) = v125 >> 24;
  v703 = v489 + v804;
  LODWORD(v119) = (__int64)(v582 ^ v87) >> 24;
  HIDWORD(v411) = HIBYTE(HIDWORD(v125)) | ((_DWORD)v125 << 8);
  HIDWORD(v119) = ((unsigned int)((v582 ^ v87) >> 32) >> 24) | (((unsigned int)v582 ^ (unsigned int)v87) << 8);
  LODWORD(v118) = (v549 + v411) ^ v425;
  LODWORD(v379) = (2 * v124) | (HIDWORD(v124) >> 31);
  v126 = (v644 + v119) ^ v349;
  HIDWORD(v118) = (unsigned int)(((v549 + v411) ^ v425) >> 32) >> 16;
  LODWORD(v425) = (__int64)((v549 + v411) ^ v425) >> 16;
  v127 = __PAIR64__(v465, HIDWORD(v465));
  v726 = v549 + v411 + v801;
  HIDWORD(v425) = HIDWORD(v118) | ((_DWORD)v118 << 16);
  v520 = __PAIR64__(v465, HIDWORD(v465)) + v519;
  LODWORD(v118) = v520 ^ v394;
  LODWORD(v465) = v126 >> 16;
  v490 = v425 + v613;
  HIDWORD(v465) = HIWORD(HIDWORD(v126)) | ((_DWORD)v126 << 16);
  HIDWORD(v118) = (unsigned int)((v520 ^ (unsigned __int64)v394) >> 32) >> 24;
  LODWORD(v394) = (v520 ^ v394) >> 24;
  HIDWORD(v394) = HIDWORD(v118) | ((_DWORD)v118 << 8);
  v645 = v644 + v119 + v796;
  v350 = (2 * ((v425 + v613) ^ v411)) | ((unsigned int)(((v425 + v613) ^ v411) >> 32) >> 31);
  v128 = (v465 + v582) ^ v119;
  LODWORD(v119) = (2 * v128) | (HIDWORD(v128) >> 31);
  v129 = (v674 + v394) ^ v127;
  v614 = v674 + v394;
  HIDWORD(v119) = v128 >> 31;
  LODWORD(v120) = v129 >> 16;
  HIDWORD(v120) = HIWORD(HIDWORD(v129)) | ((_DWORD)v129 << 16);
  v130 = (v703 + v350) ^ v120;
  v131 = __PAIR64__(v130, HIDWORD(v130));
  v583 = __PAIR64__(v130, HIDWORD(v130)) + v465 + v582;
  v132 = (v120 + v520) ^ v394;
  v133 = (2 * ((v120 + v520) ^ v394)) | (HIDWORD(v132) >> 31);
  v395 = v726 + v119 + v802;
  v367 = __PAIR64__((v726 + v119) ^ v366, ((v726 + v119) ^ v366) >> 32);
  LODWORD(v411) = v133;
  v550 = v367 + v120 + v520;
  HIDWORD(v411) = v132 >> 31;
  v134 = v550 ^ v119;
  LODWORD(v120) = (__int64)(v583 ^ v350) >> 24;
  HIDWORD(v120) = ((unsigned int)((v583 ^ v350) >> 32) >> 24) | (((unsigned int)v583 ^ (unsigned int)v350) << 8);
  LODWORD(v119) = (__int64)(v550 ^ v119) >> 24;
  HIDWORD(v119) = HIBYTE(HIDWORD(v134)) | ((_DWORD)v134 << 8);
  v521 = v703 + v350 + v791 + v120;
  v675 = v645 + v411;
  v646 = v395 + v119;
  v135 = v395 + v119;
  LODWORD(v395) = (__int64)(v521 ^ v131) >> 16;
  HIDWORD(v395) = ((unsigned int)(HIDWORD(v521) ^ HIDWORD(v131)) >> 16)
                | (((unsigned int)v521 ^ (unsigned int)v131) << 16);
  v136 = v135 ^ v367;
  v351 = __PAIR64__((unsigned int)v675 ^ (unsigned int)v425, (v675 ^ v425) >> 32);
  v584 = v395 + v583;
  LODWORD(v425) = v136 >> 16;
  HIDWORD(v425) = HIWORD(HIDWORD(v136)) | ((_DWORD)v136 << 16);
  v704 = v351 + v444;
  v551 = v425 + v550;
  v137 = (v351 + v444) ^ v411;
  HIDWORD(v367) = (__int64)(v584 ^ v120) >> 31;
  v676 = v675 + v798;
  LODWORD(v367) = (2 * (v584 ^ v120)) | ((unsigned int)((v584 ^ v120) >> 32) >> 31);
  v138 = v551 ^ v119;
  LODWORD(v411) = (2 * (v551 ^ v119)) | ((unsigned int)((v551 ^ v119) >> 32) >> 31);
  v139 = (v614 + v793 + v379) ^ v465;
  HIDWORD(v411) = v138 >> 31;
  v491 = __PAIR64__(v139, HIDWORD(v139)) + v490;
  LODWORD(v465) = v137 >> 24;
  HIDWORD(v465) = HIBYTE(HIDWORD(v137)) | ((_DWORD)v137 << 8);
  LODWORD(v131) = (__int64)(v491 ^ v379) >> 24;
  HIDWORD(v131) = ((unsigned int)((v491 ^ v379) >> 32) >> 24) | (((unsigned int)v491 ^ (unsigned int)v379) << 8);
  v140 = (v676 + v465) ^ v351;
  v141 = v614 + v793 + v379 + v803 + v131;
  v757 = v141 + v798;
  v142 = v141 ^ __PAIR64__(v139, HIDWORD(v139));
  LODWORD(v120) = v140 >> 16;
  v143 = v676 + v465 + v790 + v411;
  LODWORD(v137) = v142 >> 16;
  HIDWORD(v137) = HIWORD(HIDWORD(v142)) | ((_DWORD)v142 << 16);
  HIDWORD(v120) = HIWORD(HIDWORD(v140)) | ((_DWORD)v140 << 16);
  v445 = v137 + v491;
  v144 = v143 ^ v137;
  v145 = v646 + v796 + v367;
  v492 = v144;
  v727 = v120 ^ v145;
  v146 = v445 ^ v131;
  v647 = v145 + v800;
  v147 = (v120 + v704) ^ v465;
  LODWORD(v131) = (2 * (v445 ^ v131)) | ((unsigned int)((v445 ^ v131) >> 32) >> 31);
  HIDWORD(v131) = v146 >> 31;
  LODWORD(v379) = (2 * v147) | (HIDWORD(v147) >> 31);
  HIDWORD(v379) = v147 >> 31;
  v148 = (v521 + v792 + v131) ^ v425;
  v149 = (v757 + v379) ^ v395;
  v466 = __PAIR64__(v148, HIDWORD(v148)) + v120 + v704;
  HIDWORD(v395) = ((unsigned int)((v466 ^ v131) >> 32) >> 24) | (((unsigned int)v466 ^ (unsigned int)v131) << 8);
  v352 = __PAIR64__(v492, HIDWORD(v492));
  LODWORD(v395) = (__int64)(v466 ^ v131) >> 24;
  v150 = __PAIR64__(v492, HIDWORD(v492)) + v584;
  v493 = __PAIR64__(v727, HIDWORD(v727)) + v445;
  v446 = v521 + v792 + v131 + v802 + v395;
  v522 = v150;
  v552 = __PAIR64__(v149, HIDWORD(v149)) + v551;
  v151 = v150 ^ v411;
  LODWORD(v411) = (__int64)(__PAIR64__(v148, HIDWORD(v148)) ^ v446) >> 16;
  HIDWORD(v411) = (((unsigned int)v148 ^ HIDWORD(v446)) >> 16) | ((HIDWORD(v148) ^ (unsigned int)v446) << 16);
  v368 = __PAIR64__(
           ((unsigned int)((v493 ^ v367) >> 32) >> 24) | (((unsigned int)v493 ^ (unsigned int)v367) << 8),
           (__int64)(v493 ^ v367) >> 24);
  v585 = v411 + v466;
  v152 = (v411 + v466) ^ v395;
  LODWORD(v131) = v151 >> 24;
  LODWORD(v741) = (__int64)(v552 ^ v379) >> 24;
  v467 = v647 + v368;
  HIDWORD(v131) = HIBYTE(HIDWORD(v151)) | ((_DWORD)v151 << 8);
  HIDWORD(v741) = ((unsigned int)((v552 ^ v379) >> 32) >> 24) | (((unsigned int)v552 ^ (unsigned int)v379) << 8);
  v153 = (v647 + v368) ^ __PAIR64__(v727, HIDWORD(v727));
  v615 = v143 + v801 + v131;
  v154 = v757 + v379 + v793;
  LODWORD(v379) = (2 * v152) | (HIDWORD(v152) >> 31);
  v648 = v154 + v741;
  HIDWORD(v379) = v152 >> 31;
  LODWORD(v395) = v153 >> 16;
  v155 = (v154 + v741) ^ __PAIR64__(v149, HIDWORD(v149));
  HIDWORD(v395) = HIWORD(HIDWORD(v153)) | ((_DWORD)v153 << 16);
  LODWORD(v154) = (__int64)(v615 ^ v352) >> 16;
  HIDWORD(v154) = ((unsigned int)((v615 ^ v352) >> 32) >> 16) | (((unsigned int)v615 ^ (unsigned int)v352) << 16);
  HIDWORD(v352) = HIWORD(HIDWORD(v155)) | ((_DWORD)v155 << 16);
  LODWORD(v352) = v155 >> 16;
  v523 = v154 + v522;
  v494 = v395 + v493;
  v156 = v494 ^ v368;
  v553 = v352 + v552;
  v677 = v446 + v794;
  LODWORD(v425) = (2 * (v523 ^ v131)) | ((unsigned int)((v523 ^ v131) >> 32) >> 31);
  HIDWORD(v425) = (__int64)(v523 ^ v131) >> 31;
  v157 = (v648 + v791 + v379) ^ v154;
  v447 = __PAIR64__(v157, HIDWORD(v157));
  v728 = v615 + v805;
  LODWORD(v368) = (2 * v156) | (HIDWORD(v156) >> 31);
  HIDWORD(v368) = v156 >> 31;
  v616 = v467 + v797 + v425;
  v158 = v648 + v791 + v379 + v799;
  LODWORD(v467) = (2 * (v553 ^ v741)) | ((unsigned int)((v553 ^ v741) >> 32) >> 31);
  v649 = __PAIR64__(v157, HIDWORD(v157)) + v494;
  HIDWORD(v467) = (__int64)(v553 ^ v741) >> 31;
  v159 = (__PAIR64__(v157, HIDWORD(v157)) + v494) ^ v379;
  v380 = v677 + v368;
  v729 = v728 + v467;
  v160 = (v677 + v368) ^ v352;
  LODWORD(v143) = v159 >> 24;
  HIDWORD(v143) = HIBYTE(HIDWORD(v159)) | ((_DWORD)v159 << 8);
  v161 = v729 ^ v395;
  v678 = v158 + v143;
  v412 = __PAIR64__((unsigned int)v616 ^ (unsigned int)v411, (v616 ^ v411) >> 32);
  v705 = v616 + v795;
  v162 = (v158 + v143) ^ v447;
  v396 = __PAIR64__(v160, HIDWORD(v160));
  v617 = v412 + v553;
  v448 = __PAIR64__(v160, HIDWORD(v160)) + v523;
  v353 = __PAIR64__(v161, HIDWORD(v161));
  v163 = (v412 + v553) ^ v425;
  HIDWORD(v494) = HIWORD(HIDWORD(v162)) | ((_DWORD)v162 << 16);
  LODWORD(v494) = v162 >> 16;
  v586 = __PAIR64__(v161, HIDWORD(v161)) + v585;
  v164 = v448 ^ v368;
  LODWORD(v368) = v163 >> 24;
  v554 = v494 + v649;
  v165 = v586 ^ v467;
  v166 = v143 ^ (v494 + v649);
  LODWORD(v467) = (2 * v166) | (HIDWORD(v166) >> 31);
  HIDWORD(v467) = v166 >> 31;
  v167 = v380 + v803;
  HIDWORD(v380) = HIBYTE(HIDWORD(v164)) | ((_DWORD)v164 << 8);
  LODWORD(v380) = v164 >> 24;
  HIDWORD(v368) = HIBYTE(HIDWORD(v163)) | ((_DWORD)v163 << 8);
  LODWORD(v425) = v165 >> 24;
  HIDWORD(v425) = HIBYTE(HIDWORD(v165)) | ((_DWORD)v165 << 8);
  v168 = v167 + v380;
  v524 = v729 + v804 + v425;
  v169 = v168 + v802 + v467;
  v170 = (v705 + v368) ^ v412;
  v397 = __PAIR64__(
           ((unsigned int)((v168 ^ v396) >> 32) >> 16) | (((unsigned int)v168 ^ (unsigned int)v396) << 16),
           (__int64)(v168 ^ v396) >> 16);
  v171 = v524 ^ v353;
  LODWORD(v164) = v170 >> 16;
  HIDWORD(v164) = HIWORD(HIDWORD(v170)) | ((_DWORD)v170 << 16);
  LODWORD(v353) = (__int64)(v524 ^ v353) >> 16;
  v449 = v397 + v448;
  HIDWORD(v353) = HIWORD(HIDWORD(v171)) | ((_DWORD)v171 << 16);
  v650 = v169 + v795;
  v172 = v353 + v586;
  LODWORD(v168) = HIDWORD(v169) ^ HIDWORD(v164);
  v587 = v164 + v617;
  HIDWORD(v168) = v169 ^ v164;
  LODWORD(v412) = (2 * (v449 ^ v380)) | ((unsigned int)((v449 ^ v380) >> 32) >> 31);
  HIDWORD(v412) = (__int64)(v449 ^ v380) >> 31;
  v618 = __PAIR64__((unsigned int)v169 ^ (unsigned int)v164, HIDWORD(v169) ^ HIDWORD(v164)) + v172;
  v173 = (__PAIR64__((unsigned int)v169 ^ (unsigned int)v164, HIDWORD(v169) ^ HIDWORD(v164)) + v172) ^ v467;
  v468 = v705 + v368 + v791 + v412;
  LODWORD(v169) = v173 >> 24;
  v174 = v172 ^ v425;
  HIDWORD(v169) = HIBYTE(HIDWORD(v173)) | ((_DWORD)v173 << 8);
  v706 = v468 ^ v353;
  LODWORD(v171) = (2 * (v587 ^ v368)) | ((unsigned int)((v587 ^ v368) >> 32) >> 31);
  HIDWORD(v171) = (__int64)(v587 ^ v368) >> 31;
  v175 = (v650 + v169) ^ v168;
  v354 = v650 + v169;
  LODWORD(v368) = v175 >> 16;
  HIDWORD(v368) = HIWORD(HIDWORD(v175)) | ((_DWORD)v175 << 16);
  v426 = __PAIR64__(v706, HIDWORD(v706));
  v619 = v368 + v618;
  HIDWORD(v380) = v174 >> 31;
  v555 = __PAIR64__(v706, HIDWORD(v706)) + v554;
  v176 = v619 ^ v169;
  v651 = v468 + v805;
  LODWORD(v380) = (2 * v174) | (HIDWORD(v174) >> 31);
  v177 = v524 + v804 + v171;
  v178 = v555 ^ v412;
  v413 = v678 + v794 + v380;
  v679 = v177 + v803;
  v179 = v177 ^ v494;
  v469 = v177 ^ v494;
  v495 = v413 + v800;
  v707 = v354 + v790;
  v414 = __PAIR64__((unsigned int)v413 ^ (unsigned int)v397, (v413 ^ v397) >> 32);
  v180 = __PAIR64__(v469, HIDWORD(v469));
  v398 = (2 * v176) | (HIDWORD(v176) >> 31);
  v450 = __PAIR64__(v179, HIDWORD(v179)) + v449;
  v181 = (v414 + v587) ^ v380;
  v182 = v450 ^ v171;
  LODWORD(v179) = v178 >> 24;
  HIDWORD(v179) = HIBYTE(HIDWORD(v178)) | ((_DWORD)v178 << 8);
  LODWORD(v469) = v181 >> 24;
  LODWORD(v354) = (__int64)(v450 ^ v171) >> 24;
  HIDWORD(v469) = HIBYTE(HIDWORD(v181)) | ((_DWORD)v181 << 8);
  v183 = v651 + v179;
  v184 = (v651 + v179) ^ v426;
  HIDWORD(v354) = HIBYTE(HIDWORD(v182)) | ((_DWORD)v182 << 8);
  v652 = v495 + v469;
  LODWORD(v380) = v184 >> 16;
  HIDWORD(v380) = HIWORD(HIDWORD(v184)) | ((_DWORD)v184 << 16);
  v185 = (v679 + v354) ^ v180;
  LODWORD(v180) = (__int64)((v495 + v469) ^ v414) >> 16;
  HIDWORD(v426) = HIWORD(HIDWORD(v185)) | ((_DWORD)v185 << 16);
  HIDWORD(v180) = ((unsigned int)((v652 ^ v414) >> 32) >> 16) | (((unsigned int)v652 ^ (unsigned int)v414) << 16);
  v186 = v179 ^ (v380 + v555);
  v187 = v180 + v414 + v587;
  v588 = v380 + v555;
  LODWORD(v426) = v185 >> 16;
  v556 = v187;
  LODWORD(v414) = (2 * v186) | (HIDWORD(v186) >> 31);
  v188 = v187 ^ v469;
  HIDWORD(v414) = v186 >> 31;
  v189 = (v426 + v450) ^ v354;
  HIDWORD(v469) = v188 >> 31;
  v190 = v679 + v354 + v799;
  LODWORD(v469) = (2 * v188) | (HIDWORD(v188) >> 31);
  LODWORD(v354) = (2 * v189) | (HIDWORD(v189) >> 31);
  v191 = (v707 + v414) ^ v180;
  v192 = v190 + v469;
  HIDWORD(v354) = v189 >> 31;
  v730 = v707 + v414 + v797;
  v193 = v183 + v796 + v354;
  v525 = __PAIR64__(v191, HIDWORD(v191)) + v426 + v450;
  v708 = v192 + v792;
  v496 = __PAIR64__((unsigned int)v193 ^ (unsigned int)v368, (v193 ^ v368) >> 32);
  v369 = __PAIR64__((unsigned int)v192 ^ (unsigned int)v380, (v192 ^ v380) >> 32);
  v557 = v496 + v556;
  v680 = __PAIR64__((unsigned int)v192 ^ (unsigned int)v380, (v192 ^ v380) >> 32) + v619;
  v194 = v193 + v793;
  LODWORD(v380) = (__int64)(v525 ^ v414) >> 24;
  HIDWORD(v380) = ((unsigned int)((v525 ^ v414) >> 32) >> 24) | (((unsigned int)v525 ^ (unsigned int)v414) << 8);
  LODWORD(v180) = (__int64)(v557 ^ v354) >> 24;
  HIDWORD(v180) = ((unsigned int)((v557 ^ v354) >> 32) >> 24) | (((unsigned int)v557 ^ (unsigned int)v354) << 8);
  LODWORD(v354) = (__int64)(v680 ^ v469) >> 24;
  HIDWORD(v193) = ((unsigned int)((v680 ^ v469) >> 32) >> 24) | (((unsigned int)v680 ^ (unsigned int)v469) << 8);
  v470 = v730 + v380;
  LODWORD(v193) = (v730 + v380) ^ HIDWORD(v191);
  HIDWORD(v354) = HIDWORD(v193);
  HIDWORD(v193) = ((v730 + v380) >> 32) ^ v191;
  v731 = v194 + v180;
  LODWORD(v414) = v193 >> 16;
  v451 = v708 + v354;
  HIDWORD(v414) = HIWORD(HIDWORD(v193)) | ((_DWORD)v193 << 16);
  v195 = (v708 + v354) ^ v369;
  v526 = v414 + v525;
  v370 = __PAIR64__(
           ((unsigned int)(((v194 + v180) ^ v496) >> 32) >> 16)
         | ((((_DWORD)v194 + (_DWORD)v180) ^ (unsigned int)v496) << 16),
           (__int64)((v194 + v180) ^ v496) >> 16);
  LODWORD(v194) = v195 >> 16;
  HIDWORD(v194) = HIWORD(HIDWORD(v195)) | ((_DWORD)v195 << 16);
  v620 = v370 + v557;
  v196 = v526 ^ v380;
  v497 = v194 + v680;
  v197 = (v370 + v557) ^ v180;
  LODWORD(v380) = (2 * (v526 ^ v380)) | ((unsigned int)((v526 ^ v380) >> 32) >> 31);
  v653 = v652 + v798 + v398;
  v198 = (v194 + v680) ^ v354;
  HIDWORD(v380) = v196 >> 31;
  v558 = v653 + v801;
  v355 = __PAIR64__((unsigned int)v653 ^ (unsigned int)v426, (v653 ^ v426) >> 32);
  v654 = v470 + v803;
  v199 = v731 + v797 + v380;
  v200 = v355 + v588;
  v589 = v199 ^ v194;
  v427 = (2 * v197) | (HIDWORD(v197) >> 31);
  LODWORD(v470) = (v200 ^ v398) >> 24;
  HIDWORD(v470) = ((unsigned int)((v200 ^ (unsigned __int64)v398) >> 32) >> 24)
                | (((unsigned int)v200 ^ (unsigned int)v398) << 8);
  v399 = (2 * v198) | (HIDWORD(v198) >> 31);
  v201 = (v558 + v470) ^ v355;
  LODWORD(v194) = v201 >> 16;
  HIDWORD(v194) = HIWORD(HIDWORD(v201)) | ((_DWORD)v201 << 16);
  v202 = v558 + v470 + v793 + v399;
  v203 = (v194 + v200) ^ v470;
  v559 = __PAIR64__(v589, HIDWORD(v589)) + v194 + v200;
  LODWORD(v355) = (2 * v203) | (HIDWORD(v203) >> 31);
  v415 = v202 ^ v414;
  HIDWORD(v355) = v203 >> 31;
  v204 = v202 + v799;
  v205 = (v451 + v802 + v427) ^ v194;
  v709 = v204;
  v758 = v451 + v802 + v427 + v791;
  v206 = v654 + v355;
  v207 = (v654 + v355) ^ v370;
  v655 = v199
       + v804
       + __PAIR64__(
           ((unsigned int)((v559 ^ v380) >> 32) >> 24) | (((unsigned int)v559 ^ (unsigned int)v380) << 8),
           (__int64)(v559 ^ v380) >> 24);
  v208 = __PAIR64__(v207, HIDWORD(v207));
  v209 = __PAIR64__(v589, HIDWORD(v589)) ^ v655;
  v590 = __PAIR64__(v207, HIDWORD(v207)) + v497;
  v471 = __PAIR64__(HIWORD(HIDWORD(v209)) | ((_DWORD)v209 << 16), v209 >> 16);
  v210 = (__PAIR64__(v207, HIDWORD(v207)) + v497) ^ v355;
  v498 = __PAIR64__(v415, HIDWORD(v415));
  v211 = __PAIR64__(v415, HIDWORD(v415));
  v416 = __PAIR64__(v205, HIDWORD(v205));
  v681 = v211 + v620;
  v621 = __PAIR64__(HIWORD(HIDWORD(v209)) | ((_DWORD)v209 << 16), v209 >> 16) + v559;
  v527 = __PAIR64__(v205, HIDWORD(v205)) + v526;
  v212 = __PAIR64__(
           ((unsigned int)((v559 ^ v380) >> 32) >> 24) | (((unsigned int)v559 ^ (unsigned int)v380) << 8),
           (__int64)(v559 ^ v380) >> 24);
  v381 = __PAIR64__(HIBYTE(HIDWORD(v210)) | ((_DWORD)v210 << 8), v210 >> 24);
  LODWORD(v370) = (2 * (v621 ^ v212)) | ((unsigned int)((v621 ^ v212) >> 32) >> 31);
  v213 = v527 ^ v427;
  v214 = (__int64)(v621 ^ v212) >> 31;
  v215 = v206 + v801 + v381;
  v216 = v208 ^ v215;
  HIDWORD(v355) = ((unsigned int)((v681 ^ v399) >> 32) >> 24) | (((unsigned int)v681 ^ (unsigned int)v399) << 8);
  LODWORD(v355) = (__int64)(v681 ^ v399) >> 24;
  LODWORD(v427) = (__int64)(v527 ^ v427) >> 24;
  LODWORD(v399) = v216 >> 16;
  HIDWORD(v427) = HIBYTE(HIDWORD(v213)) | ((_DWORD)v213 << 8);
  HIDWORD(v399) = HIWORD(HIDWORD(v216)) | ((_DWORD)v216 << 16);
  v217 = v215 + v795;
  v218 = (v709 + v355) ^ v498;
  HIDWORD(v370) = v214;
  v710 = v709 + v355;
  v732 = v217 + v370;
  v499 = v399 + v590;
  v219 = (v399 + v590) ^ v381;
  LODWORD(v205) = v218 >> 16;
  v220 = (v758 + v427) ^ v416;
  HIDWORD(v205) = HIWORD(HIDWORD(v218)) | ((_DWORD)v218 << 16);
  LODWORD(v416) = (2 * v219) | (HIDWORD(v219) >> 31);
  v382 = __PAIR64__(HIWORD(HIDWORD(v220)) | ((_DWORD)v220 << 16), v220 >> 16);
  HIDWORD(v416) = v219 >> 31;
  v221 = __PAIR64__(HIWORD(HIDWORD(v220)) | ((_DWORD)v220 << 16), v220 >> 16) + v527;
  v222 = (v217 + v370) ^ v205;
  v591 = v205 + v681;
  v223 = __PAIR64__(v222, HIDWORD(v222)) + v221;
  v224 = __PAIR64__(v222, HIDWORD(v222));
  v225 = v221 ^ v427;
  v528 = v223;
  LODWORD(v223) = v223 ^ v370;
  LODWORD(v451) = (2 * (v591 ^ v355)) | ((unsigned int)((v591 ^ v355) >> 32) >> 31);
  HIDWORD(v451) = (__int64)(v591 ^ v355) >> 31;
  v356 = __PAIR64__((v710 + v792 + v416) ^ v382, ((v710 + v792 + v416) ^ v382) >> 32);
  v226 = v710 + v792 + v416;
  HIDWORD(v223) = (unsigned int)((v528 ^ v370) >> 32) >> 24;
  LODWORD(v370) = (__int64)(v528 ^ v370) >> 24;
  v711 = v758 + v427 + v798 + v451;
  v560 = v226 + v800;
  v622 = v356 + v621;
  HIDWORD(v370) = HIDWORD(v223) | ((_DWORD)v223 << 8);
  HIDWORD(v382) = v225 >> 31;
  v227 = v711 ^ v471;
  LODWORD(v382) = (2 * v225) | (HIDWORD(v225) >> 31);
  v472 = v732 + v790 + v370;
  v733 = __PAIR64__(v227, HIDWORD(v227));
  LODWORD(v217) = (__int64)(v622 ^ v416) >> 24;
  HIDWORD(v217) = ((unsigned int)((v622 ^ v416) >> 32) >> 24) | (((unsigned int)v622 ^ (unsigned int)v416) << 8);
  v656 = v655 + v805 + v382;
  HIDWORD(v427) = ((unsigned int)((v472 ^ v224) >> 32) >> 16) | (((unsigned int)v472 ^ (unsigned int)v224) << 16);
  v561 = v560 + v217;
  LODWORD(v427) = (__int64)(v472 ^ v224) >> 16;
  LODWORD(v225) = v561 ^ v356;
  v417 = __PAIR64__((unsigned int)v656 ^ (unsigned int)v399, (v656 ^ v399) >> 32);
  v529 = v427 + v528;
  v682 = v656 + v794;
  v592 = __PAIR64__((unsigned int)v656 ^ (unsigned int)v399, (v656 ^ v399) >> 32) + v591;
  v500 = __PAIR64__(v227, HIDWORD(v227)) + v499;
  LODWORD(v218) = v592 ^ v382;
  LODWORD(v399) = (2 * (v529 ^ v370)) | ((unsigned int)((v529 ^ v370) >> 32) >> 31);
  v228 = v500 ^ v451;
  HIDWORD(v225) = (unsigned int)((v561 ^ v356) >> 32) >> 16;
  LODWORD(v356) = (__int64)(v561 ^ v356) >> 16;
  HIDWORD(v356) = HIDWORD(v225) | ((_DWORD)v225 << 16);
  HIDWORD(v399) = (__int64)(v529 ^ v370) >> 31;
  v657 = v356 + v622;
  LODWORD(v382) = (__int64)(v592 ^ v382) >> 24;
  v452 = v472 + v796;
  v229 = (v356 + v622) ^ v217;
  HIDWORD(v382) = ((unsigned int)(HIDWORD(v592) ^ HIDWORD(v382)) >> 24) | ((_DWORD)v218 << 8);
  LODWORD(v370) = v228 >> 24;
  HIDWORD(v370) = HIBYTE(HIDWORD(v228)) | ((_DWORD)v228 << 8);
  v623 = v711 + v796 + v370;
  v230 = (v682 + v382) ^ v417;
  v231 = v682 + v382 + v804 + v399;
  LODWORD(v217) = v230 >> 16;
  HIDWORD(v472) = v229 >> 31;
  LODWORD(v472) = (2 * v229) | (HIDWORD(v229) >> 31);
  v683 = v231 + v799;
  HIDWORD(v217) = HIWORD(HIDWORD(v230)) | ((_DWORD)v230 << 16);
  v232 = v452 + ((2 * v229) | (HIDWORD(v229) >> 31));
  HIDWORD(v229) = ((unsigned int)(HIDWORD(v623) ^ HIDWORD(v733)) >> 16)
                | (((unsigned int)v623 ^ (unsigned int)v733) << 16);
  v712 = v452 + v472 + v805;
  v233 = (__int64)(v623 ^ v733) >> 16;
  v234 = __PAIR64__(HIDWORD(v229), v233) + v500;
  v453 = __PAIR64__(v233 ^ (unsigned int)v231, HIDWORD(v229) ^ HIDWORD(v231));
  v501 = v217 + v592;
  v658 = __PAIR64__(v233 ^ (unsigned int)v231, HIDWORD(v229) ^ HIDWORD(v231)) + v657;
  v235 = v234 ^ v370;
  v236 = __PAIR64__((unsigned int)v217 ^ (unsigned int)v232, (v217 ^ v232) >> 32);
  LODWORD(v417) = (2 * (v501 ^ v382)) | ((unsigned int)((v501 ^ v382) >> 32) >> 31);
  v237 = v658 ^ v399;
  v593 = v236 + v234;
  HIDWORD(v417) = (__int64)(v501 ^ v382) >> 31;
  LODWORD(v399) = (2 * (v234 ^ v370)) | ((unsigned int)((v234 ^ v370) >> 32) >> 31);
  v238 = (v236 + v234) ^ v472;
  LODWORD(v217) = v237 >> 24;
  HIDWORD(v382) = HIBYTE(HIDWORD(v238)) | ((_DWORD)v238 << 8);
  LODWORD(v382) = v238 >> 24;
  HIDWORD(v217) = HIBYTE(HIDWORD(v237)) | ((_DWORD)v237 << 8);
  v684 = v683 + v217;
  HIDWORD(v399) = v235 >> 31;
  v239 = v236 ^ (v712 + v382);
  HIDWORD(v472) = ((unsigned int)((v684 ^ v453) >> 32) >> 16) | (((unsigned int)v684 ^ (unsigned int)v453) << 16);
  LODWORD(v472) = (__int64)(v684 ^ v453) >> 16;
  LODWORD(v370) = v239 >> 16;
  HIDWORD(v370) = HIWORD(HIDWORD(v239)) | ((_DWORD)v239 << 16);
  v659 = v472 + v658;
  v594 = v370 + v593;
  HIDWORD(v453) = (__int64)(v659 ^ v217) >> 31;
  v240 = v623 + v801 + v417;
  v241 = v561 + v790 + v399;
  LODWORD(v453) = (2 * (v659 ^ v217)) | ((unsigned int)((v659 ^ v217) >> 32) >> 31);
  v624 = v240 + v793;
  v562 = v241 + v798;
  v428 = __PAIR64__((unsigned int)v241 ^ (unsigned int)v427, (v241 ^ (unsigned __int64)v427) >> 32);
  v242 = __PAIR64__((unsigned int)v240 ^ (unsigned int)v356, (v240 ^ v356) >> 32);
  v502 = v428 + v501;
  v357 = __PAIR64__((unsigned int)v240 ^ (unsigned int)v356, (v240 ^ v356) >> 32) + v529;
  v243 = v399;
  v400 = (2 * (v594 ^ v382)) | ((unsigned int)((v594 ^ v382) >> 32) >> 31);
  v530 = v712 + v382 + v802 + v453;
  LODWORD(v382) = (v502 ^ v243) >> 24;
  LODWORD(v237) = (__int64)(v357 ^ v417) >> 24;
  HIDWORD(v382) = ((unsigned int)((v502 ^ (unsigned __int64)v243) >> 32) >> 24)
                | (((unsigned int)v502 ^ (unsigned int)v243) << 8);
  HIDWORD(v237) = ((unsigned int)((v357 ^ v417) >> 32) >> 24) | (((unsigned int)v357 ^ (unsigned int)v417) << 8);
  v244 = (v241 + v798 + v382) ^ v428;
  v245 = (v624 + v237) ^ v242;
  v625 = v624 + v237 + v791;
  LODWORD(v243) = v244 >> 16;
  HIDWORD(v243) = HIWORD(HIDWORD(v244)) | ((_DWORD)v244 << 16);
  LODWORD(v242) = v245 >> 16;
  HIDWORD(v242) = HIWORD(HIDWORD(v245)) | ((_DWORD)v245 << 16);
  v503 = v243 + v502;
  v358 = v242 + v357;
  v759 = v562 + v382 + v800 + v400;
  LODWORD(v417) = (2 * (v503 ^ v382)) | ((unsigned int)((v503 ^ v382) >> 32) >> 31);
  HIDWORD(v417) = (__int64)(v503 ^ v382) >> 31;
  v783 = v759 ^ v242;
  v429 = __PAIR64__((unsigned int)v243 ^ (unsigned int)v530, (v243 ^ v530) >> 32);
  v563 = v530 + v792;
  v383 = (2 * (v358 ^ v237)) | ((unsigned int)((v358 ^ v237) >> 32) >> 31);
  v531 = __PAIR64__((unsigned int)v243 ^ (unsigned int)v530, (v243 ^ v530) >> 32) + v358;
  v734 = v684 + v803 + v383;
  v246 = (v429 + v358) ^ v453;
  v359 = __PAIR64__((unsigned int)v734 ^ (unsigned int)v370, (v734 ^ v370) >> 32);
  LODWORD(v242) = v246 >> 24;
  v473 = __PAIR64__((v625 + v417) ^ v472, ((v625 + v417) ^ v472) >> 32);
  HIDWORD(v242) = HIBYTE(HIDWORD(v246)) | ((_DWORD)v246 << 8);
  v713 = v625 + v417 + v794;
  v626 = __PAIR64__((unsigned int)v734 ^ (unsigned int)v370, (v734 ^ v370) >> 32) + v503;
  v685 = v473 + v594;
  v247 = (__PAIR64__((unsigned int)v734 ^ (unsigned int)v370, (v734 ^ v370) >> 32) + v503) ^ v383;
  v248 = (v473 + v594) ^ v417;
  v595 = v563 + v242;
  LODWORD(v453) = v248 >> 24;
  LODWORD(v370) = v247 >> 24;
  HIDWORD(v453) = HIBYTE(HIDWORD(v248)) | ((_DWORD)v248 << 8);
  v249 = (v563 + v242) ^ v429;
  LODWORD(v383) = v249 >> 16;
  HIDWORD(v370) = HIBYTE(HIDWORD(v247)) | ((_DWORD)v247 << 8);
  HIDWORD(v383) = HIWORD(HIDWORD(v249)) | ((_DWORD)v249 << 16);
  v564 = v734 + v797 + v370;
  v504 = __PAIR64__(v783, HIDWORD(v783));
  v714 = v713 + v453;
  v784 = __PAIR64__(v783, HIDWORD(v783)) + v659;
  v532 = v383 + v531;
  LODWORD(v429) = (__int64)(v564 ^ v359) >> 16;
  LODWORD(v217) = (__int64)(v714 ^ v473) >> 16;
  LODWORD(v417) = (2 * (v532 ^ v242)) | ((unsigned int)((v532 ^ v242) >> 32) >> 31);
  HIDWORD(v417) = (__int64)(v532 ^ v242) >> 31;
  HIDWORD(v429) = ((unsigned int)(HIDWORD(v564) ^ HIDWORD(v359)) >> 16)
                | (((unsigned int)v564 ^ (unsigned int)v359) << 16);
  HIDWORD(v217) = ((unsigned int)((v714 ^ v473) >> 32) >> 16) | (((unsigned int)v714 ^ (unsigned int)v473) << 16);
  v627 = v429 + v626;
  LODWORD(v473) = (__int64)(v784 ^ v400) >> 24;
  HIDWORD(v473) = ((unsigned int)((v784 ^ v400) >> 32) >> 24) | (((unsigned int)v784 ^ (unsigned int)v400) << 8);
  v660 = v217 + v685;
  v250 = (v217 + v685) ^ v453;
  v251 = v759 + v795 + v473;
  v252 = v627 ^ v370;
  HIDWORD(v359) = v250 >> 31;
  v253 = (2 * (v627 ^ v370)) | ((unsigned int)((v627 ^ v370) >> 32) >> 31);
  v254 = v251 ^ v504;
  LODWORD(v359) = (2 * v250) | (HIDWORD(v250) >> 31);
  v255 = (v564 + v798 + v417) ^ v217;
  LODWORD(v370) = (__int64)(v251 ^ v504) >> 16;
  v505 = __PAIR64__(v255, HIDWORD(v255));
  HIDWORD(v370) = HIWORD(HIDWORD(v254)) | ((_DWORD)v254 << 16);
  HIDWORD(v400) = v252 >> 31;
  LODWORD(v400) = v253;
  v686 = __PAIR64__(v255, HIDWORD(v255)) + v370 + v784;
  v454 = (2 * ((v370 + v784) ^ v473)) | ((unsigned int)(((v370 + v784) ^ v473) >> 32) >> 31);
  v735 = v251 + v791 + v359;
  v715 = v714 + v797 + v400;
  v596 = v595 + v800 + v454;
  LODWORD(v255) = (__int64)(v686 ^ v417) >> 24;
  v384 = v735 ^ v383;
  HIDWORD(v255) = ((unsigned int)((v686 ^ v417) >> 32) >> 24) | (((unsigned int)v686 ^ (unsigned int)v417) << 8);
  v256 = v596 ^ v429;
  v565 = v564 + v798 + v417 + v794 + v255;
  v785 = v735 + v795;
  v430 = __PAIR64__((unsigned int)v715 ^ (unsigned int)v370, (v715 ^ v370) >> 32);
  v760 = v715 + v796;
  HIDWORD(v473) = v384;
  LODWORD(v384) = HIDWORD(v256);
  HIDWORD(v417) = ((unsigned int)((v565 ^ v505) >> 32) >> 16) | (((unsigned int)v565 ^ (unsigned int)v505) << 16);
  HIDWORD(v251) = HIDWORD(v384);
  v736 = v596 + v792;
  HIDWORD(v384) = v256;
  LODWORD(v473) = HIDWORD(v251);
  LODWORD(v417) = (__int64)(v565 ^ v505) >> 16;
  v597 = v417 + v686;
  v257 = (v473 + v627) ^ v359;
  v533 = __PAIR64__((unsigned int)v715 ^ (unsigned int)v370, (v715 ^ v370) >> 32) + v532;
  v258 = (v384 + v660) ^ v454;
  LODWORD(v454) = v257 >> 24;
  v259 = v255 ^ (v417 + v686);
  LODWORD(v370) = (2 * v259) | (HIDWORD(v259) >> 31);
  HIDWORD(v370) = v259 >> 31;
  LODWORD(v251) = v258 >> 24;
  HIDWORD(v251) = HIBYTE(HIDWORD(v258)) | ((_DWORD)v258 << 8);
  HIDWORD(v454) = HIBYTE(HIDWORD(v257)) | ((_DWORD)v257 << 8);
  LODWORD(v359) = (v533 ^ v400) >> 24;
  HIDWORD(v359) = ((unsigned int)((v533 ^ (unsigned __int64)v400) >> 32) >> 24) | (((unsigned int)v533 ^ v253) << 8);
  v260 = (v785 + v454) ^ v473;
  v401 = __PAIR64__(
           ((unsigned int)(((v736 + v251) ^ v384) >> 32) >> 16)
         | ((((_DWORD)v736 + (_DWORD)v251) ^ (unsigned int)v384) << 16),
           (__int64)((v736 + v251) ^ v384) >> 16);
  v261 = (v715 + v796 + v359) ^ v430;
  LODWORD(v254) = v260 >> 16;
  HIDWORD(v254) = HIWORD(HIDWORD(v260)) | ((_DWORD)v260 << 16);
  LODWORD(v430) = v261 >> 16;
  HIDWORD(v430) = HIWORD(HIDWORD(v261)) | ((_DWORD)v261 << 16);
  v506 = __PAIR64__(
           ((unsigned int)(((v736 + v251) ^ v384) >> 32) >> 16)
         | ((((_DWORD)v736 + (_DWORD)v251) ^ (unsigned int)v384) << 16),
           (__int64)((v736 + v251) ^ v384) >> 16)
       + v384
       + v660;
  v687 = v254 + v473 + v627;
  v262 = (v736 + v251 + v805 + v370) ^ v254;
  LODWORD(v384) = (2 * (v506 ^ v251)) | ((unsigned int)((v506 ^ v251) >> 32) >> 31);
  v263 = v430 + v533;
  v534 = __PAIR64__(v262, HIDWORD(v262)) + v430 + v533;
  v264 = __PAIR64__(v262, HIDWORD(v262));
  HIDWORD(v384) = (__int64)(v506 ^ v251) >> 31;
  v265 = v263 ^ v359;
  LODWORD(v262) = (__int64)(v534 ^ v370) >> 24;
  HIDWORD(v262) = ((unsigned int)((v534 ^ v370) >> 32) >> 24) | (((unsigned int)v534 ^ (unsigned int)v370) << 8);
  v266 = v736 + v251 + v805 + v370 + v801;
  LODWORD(v370) = (2 * (v687 ^ v454)) | ((unsigned int)((v687 ^ v454) >> 32) >> 31);
  v716 = v266 + v262;
  LODWORD(v473) = (__int64)((v266 + v262) ^ v264) >> 16;
  HIDWORD(v473) = ((unsigned int)((v716 ^ v264) >> 32) >> 16) | (((unsigned int)v716 ^ (unsigned int)v264) << 16);
  HIDWORD(v370) = (__int64)(v687 ^ v454) >> 31;
  v535 = v473 + v534;
  v267 = v785 + v454;
  v455 = v565 + v799;
  v268 = v262 ^ v535;
  v269 = v267 + v803 + v384;
  v270 = v760 + v359 + v793 + v370;
  v628 = v269 + v790;
  LODWORD(v359) = (2 * v268) | (HIDWORD(v268) >> 31);
  v271 = v269 ^ v430;
  v418 = v270 ^ v417;
  v566 = v270 + v802;
  v431 = __PAIR64__(v271, HIDWORD(v271));
  HIDWORD(v359) = v268 >> 31;
  v272 = (__PAIR64__(v271, HIDWORD(v271)) + v597) ^ v384;
  LODWORD(v270) = (2 * v265) | (HIDWORD(v265) >> 31);
  v598 = __PAIR64__(v271, HIDWORD(v271)) + v597;
  LODWORD(v264) = v272 >> 24;
  HIDWORD(v270) = v265 >> 31;
  HIDWORD(v264) = HIBYTE(HIDWORD(v272)) | ((_DWORD)v272 << 8);
  v737 = v455 + v270 + v804;
  v661 = v628 + v264;
  LODWORD(v271) = ((v455 + v270) ^ v401) >> 32;
  HIDWORD(v271) = (v455 + v270) ^ v401;
  v456 = v271 + v687;
  v273 = (v628 + v264) ^ v431;
  v385 = __PAIR64__(v418, HIDWORD(v418));
  v274 = v270 ^ (v271 + v687);
  v629 = __PAIR64__(v418, HIDWORD(v418)) + v506;
  LODWORD(v401) = v274 >> 24;
  HIDWORD(v401) = HIBYTE(HIDWORD(v274)) | ((_DWORD)v274 << 8);
  v275 = (__PAIR64__(v418, HIDWORD(v418)) + v506) ^ v370;
  HIDWORD(v431) = HIWORD(HIDWORD(v273)) | ((_DWORD)v273 << 16);
  LODWORD(v431) = v273 >> 16;
  LODWORD(v418) = v275 >> 24;
  HIDWORD(v273) = HIBYTE(HIDWORD(v275)) | ((_DWORD)v275 << 8);
  v276 = (v737 + v401) ^ v271;
  v688 = v431 + v598;
  HIDWORD(v418) = HIDWORD(v273);
  v567 = v566 + v418;
  v371 = (2 * ((v431 + v598) ^ v264)) | ((unsigned int)(((v431 + v598) ^ v264) >> 32) >> 31);
  v277 = v737 + v401 + v792 + v359;
  HIDWORD(v264) = HIWORD(HIDWORD(v276)) | ((_DWORD)v276 << 16);
  v278 = v716 + v790 + v371;
  HIDWORD(v271) = ((unsigned int)(HIDWORD(v567) ^ HIDWORD(v385)) >> 16)
                | (((unsigned int)v567 ^ (unsigned int)v385) << 16);
  v279 = v276 >> 16;
  v599 = __PAIR64__(HIDWORD(v264), v279) + v456;
  v280 = (__int64)(v567 ^ v385) >> 16;
  v689 = __PAIR64__(v280 ^ (unsigned int)v277, HIDWORD(v271) ^ HIDWORD(v277)) + v688;
  v457 = __PAIR64__(v279 ^ (unsigned int)v278, HIDWORD(v264) ^ HIDWORD(v278));
  HIDWORD(v385) = (__int64)(v599 ^ v401) >> 31;
  v281 = (__PAIR64__(HIDWORD(v271), v280) + v629) ^ v418;
  v630 = __PAIR64__(v279 ^ (unsigned int)v278, HIDWORD(v264) ^ HIDWORD(v278)) + __PAIR64__(HIDWORD(v271), v280) + v629;
  LODWORD(v385) = (2 * (v599 ^ v401)) | ((unsigned int)((v599 ^ v401) >> 32) >> 31);
  LODWORD(v418) = (__int64)(v630 ^ v371) >> 24;
  v717 = v567 + v794 + v385;
  LODWORD(v264) = (__int64)(v689 ^ v359) >> 24;
  HIDWORD(v264) = ((unsigned int)((v689 ^ v359) >> 32) >> 24) | (((unsigned int)v689 ^ (unsigned int)v359) << 8);
  HIDWORD(v418) = ((unsigned int)((v630 ^ v371) >> 32) >> 24) | (((unsigned int)v630 ^ (unsigned int)v371) << 8);
  v568 = v277 + v793 + v264;
  LODWORD(v401) = (2 * v281) | (HIDWORD(v281) >> 31);
  HIDWORD(v401) = v281 >> 31;
  v282 = v278 + v791 + v418;
  v283 = v568 ^ __PAIR64__(v280 ^ (unsigned int)v277, HIDWORD(v271) ^ HIDWORD(v277));
  v284 = v717 ^ v431;
  LODWORD(v431) = v283 >> 16;
  HIDWORD(v431) = HIWORD(HIDWORD(v283)) | ((_DWORD)v283 << 16);
  v285 = v282 ^ v457;
  v690 = v431 + v689;
  HIDWORD(v283) = ((unsigned int)v282 ^ (unsigned int)v457) >> 16;
  v458 = __PAIR64__(v284, HIDWORD(v284));
  LODWORD(v371) = HIDWORD(v283) | (HIDWORD(v285) << 16);
  HIDWORD(v371) = HIWORD(HIDWORD(v285)) | ((_DWORD)v285 << 16);
  v536 = __PAIR64__(v284, HIDWORD(v284)) + v535;
  v507 = v371 + v630;
  HIDWORD(v359) = (__int64)(v690 ^ v264) >> 31;
  v738 = v717 + v795;
  LODWORD(v359) = (2 * (v690 ^ v264)) | ((unsigned int)((v690 ^ v264) >> 32) >> 31);
  v286 = v661 + v796 + v401;
  v287 = (v371 + v630) ^ v418;
  v662 = v286 + v797;
  v288 = v286 ^ v473;
  v289 = __PAIR64__(v288, HIDWORD(v288));
  v631 = v282 + v798 + v359;
  v761 = v568 + v800;
  v718 = v631 + v799;
  v600 = __PAIR64__(v288, HIDWORD(v288)) + v599;
  LODWORD(v282) = (2 * v287) | (HIDWORD(v287) >> 31);
  HIDWORD(v282) = v287 >> 31;
  v290 = (__int64)(v536 ^ v385) >> 24;
  HIDWORD(v385) = ((unsigned int)((v536 ^ v385) >> 32) >> 24) | (((unsigned int)v536 ^ (unsigned int)v385) << 8);
  LODWORD(v385) = v290;
  LODWORD(v418) = (__int64)(v600 ^ v401) >> 24;
  HIDWORD(v418) = ((unsigned int)((v600 ^ v401) >> 32) >> 24) | (((unsigned int)v600 ^ (unsigned int)v401) << 8);
  v291 = (v738 + v385) ^ v458;
  v292 = (v662 + v418) ^ v289;
  v402 = v662 + v418 + v804;
  LODWORD(v264) = v291 >> 16;
  HIDWORD(v264) = HIWORD(HIDWORD(v291)) | ((_DWORD)v291 << 16);
  LODWORD(v285) = v292 >> 16;
  HIDWORD(v285) = HIWORD(HIDWORD(v292)) | ((_DWORD)v292 << 16);
  v474 = v264 + v536;
  v569 = (v402 + v282) ^ v264;
  v459 = v285 + v600;
  v786 = v402 + v282 + v805;
  v403 = (2 * ((v264 + v536) ^ v385)) | ((unsigned int)(((v264 + v536) ^ v385) >> 32) >> 31);
  LODWORD(v289) = (2 * (v459 ^ v418)) | ((unsigned int)((v459 ^ v418) >> 32) >> 31);
  HIDWORD(v289) = (__int64)((v285 + v600) ^ v418) >> 31;
  v293 = v738 + v385 + v802;
  v294 = __PAIR64__((unsigned int)v285 ^ (unsigned int)v631, (v285 ^ v631) >> 32);
  v632 = v761 + v403 + v801;
  v475 = v294 + v474;
  v295 = (v293 + v289) ^ v431;
  v432 = __PAIR64__(v295, HIDWORD(v295));
  v663 = v293 + v289 + v803;
  v372 = __PAIR64__((v761 + v403) ^ v371, ((v761 + v403) ^ (unsigned __int64)v371) >> 32);
  HIDWORD(v385) = ((unsigned int)((v475 ^ v359) >> 32) >> 24) | (((unsigned int)v475 ^ (unsigned int)v359) << 8);
  LODWORD(v385) = (__int64)(v475 ^ v359) >> 24;
  v601 = v372 + v459;
  v537 = __PAIR64__(v295, HIDWORD(v295)) + v507;
  v360 = __PAIR64__(v569, HIDWORD(v569));
  v296 = v372 + v459;
  v460 = v718 + v385;
  v297 = v296 ^ v403;
  v570 = __PAIR64__(v569, HIDWORD(v569)) + v690;
  v298 = v570 ^ v282;
  v299 = v537 ^ v289;
  v300 = (v718 + v385) ^ v294;
  LODWORD(v403) = v300 >> 16;
  HIDWORD(v403) = HIWORD(HIDWORD(v300)) | ((_DWORD)v300 << 16);
  LODWORD(v294) = v297 >> 24;
  LODWORD(v282) = v299 >> 24;
  LODWORD(v718) = v298 >> 24;
  v476 = v403 + v475;
  HIDWORD(v294) = HIBYTE(HIDWORD(v297)) | ((_DWORD)v297 << 8);
  HIDWORD(v282) = HIBYTE(HIDWORD(v299)) | ((_DWORD)v299 << 8);
  HIDWORD(v718) = HIBYTE(HIDWORD(v298)) | ((_DWORD)v298 << 8);
  v508 = v632 + v294;
  v633 = v663 + v282;
  LODWORD(v418) = (2 * (v476 ^ v385)) | ((unsigned int)((v476 ^ v385) >> 32) >> 31);
  HIDWORD(v418) = (__int64)(v476 ^ v385) >> 31;
  v301 = (v663 + v282) ^ v432;
  LODWORD(v385) = (__int64)(v508 ^ v372) >> 16;
  v302 = (v786 + v718) ^ v360;
  HIDWORD(v385) = ((unsigned int)((v508 ^ v372) >> 32) >> 16) | (((unsigned int)v508 ^ (unsigned int)v372) << 16);
  LODWORD(v372) = v301 >> 16;
  HIDWORD(v372) = HIWORD(HIDWORD(v301)) | ((_DWORD)v301 << 16);
  LODWORD(v360) = v302 >> 16;
  v602 = v385 + v601;
  HIDWORD(v360) = HIWORD(HIDWORD(v302)) | ((_DWORD)v302 << 16);
  v538 = v372 + v537;
  v303 = v538 ^ v282;
  v304 = v508 + v794 + v418;
  LODWORD(v432) = (2 * v303) | (HIDWORD(v303) >> 31);
  HIDWORD(v432) = v303 >> 31;
  v742 = __PAIR64__((unsigned int)v304 ^ (unsigned int)v372, (v304 ^ v372) >> 32);
  HIDWORD(v768) = (__int64)(v602 ^ v294) >> 31;
  LODWORD(v768) = (2 * (v602 ^ v294)) | ((unsigned int)((v602 ^ v294) >> 32) >> 31);
  LODWORD(v738) = (2 * ((v360 + v570) ^ v718)) | ((unsigned int)(((v360 + v570) ^ v718) >> 32) >> 31);
  v373 = __PAIR64__((unsigned int)v304 ^ (unsigned int)v372, (v304 ^ v372) >> 32) + v360 + v570;
  HIDWORD(v738) = (__int64)((v360 + v570) ^ v718) >> 31;
  v305 = v403;
  v404 = v460 + v804 + v738;
  v306 = (v786 + v718 + v803 + v432) ^ v305;
  v307 = (v633 + v799 + v768) ^ v360;
  LODWORD(v300) = (__int64)(v373 ^ v418) >> 24;
  HIDWORD(v300) = ((unsigned int)((v373 ^ v418) >> 32) >> 24) | (((unsigned int)v373 ^ (unsigned int)v418) << 8);
  v308 = v404 ^ v385;
  v386 = v304 + v798 + v300;
  v770 = __PAIR64__(v306, HIDWORD(v306));
  v509 = v786 + v718 + v803 + v432 + v796;
  v772 = __PAIR64__(v308, HIDWORD(v308));
  v765 = __PAIR64__(
           ((unsigned int)((v386 ^ v742) >> 32) >> 16) | (((unsigned int)v386 ^ (unsigned int)v742) << 16),
           (__int64)(v386 ^ v742) >> 16);
  v571 = __PAIR64__(v307, HIDWORD(v307));
  v309 = (__PAIR64__(v306, HIDWORD(v306)) + v602) ^ v432;
  v310 = (v772 + v538) ^ v738;
  v433 = __PAIR64__(v307, HIDWORD(v307)) + v476;
  v419 = __PAIR64__(
           ((unsigned int)((v386 ^ v742) >> 32) >> 16) | (((unsigned int)v386 ^ (unsigned int)v742) << 16),
           (__int64)(v386 ^ v742) >> 16)
       + v373;
  v311 = (__PAIR64__(v307, HIDWORD(v307)) + v476) ^ v768;
  v312 = v300
       ^ (__PAIR64__(
            ((unsigned int)((v386 ^ v742) >> 32) >> 16) | (((unsigned int)v386 ^ (unsigned int)v742) << 16),
            (__int64)(v386 ^ v742) >> 16)
        + v373);
  LODWORD(v738) = (2 * v312) | (HIDWORD(v312) >> 31);
  v477 = v386 + v790;
  HIDWORD(v738) = v312 >> 31;
  LODWORD(v745) = v310 >> 24;
  HIDWORD(v745) = HIBYTE(HIDWORD(v310)) | ((_DWORD)v310 << 8);
  LODWORD(v747) = v311 >> 24;
  v313 = v404 + v800 + v745;
  HIDWORD(v747) = HIBYTE(HIDWORD(v311)) | ((_DWORD)v311 << 8);
  v314 = v313 + v791;
  v315 = v313 ^ v772;
  v387 = v509 + __PAIR64__(HIBYTE(HIDWORD(v309)) | ((_DWORD)v309 << 8), v309 >> 24);
  v405 = v633 + v799 + v768 + v805 + v747;
  v316 = (v509 + __PAIR64__(HIBYTE(HIDWORD(v309)) | ((_DWORD)v309 << 8), v309 >> 24)) ^ v770;
  v317 = v314 + v738;
  LODWORD(v763) = v315 >> 16;
  HIDWORD(v763) = HIWORD(HIDWORD(v315)) | ((_DWORD)v315 << 16);
  v374 = v317 + v802;
  LODWORD(v311) = v316 >> 16;
  v318 = v772 + v538;
  HIDWORD(v311) = HIWORD(HIDWORD(v316)) | ((_DWORD)v316 << 16);
  LODWORD(v772) = (__int64)(v405 ^ v571) >> 16;
  HIDWORD(v772) = ((unsigned int)((v405 ^ v571) >> 32) >> 16) | (((unsigned int)v405 ^ (unsigned int)v571) << 16);
  v319 = v317 ^ v311;
  v320 = v311 + v770 + v602;
  v771 = v763 + v318;
  v767 = v320;
  v321 = (v763 + v318) ^ v745;
  v322 = v320 ^ __PAIR64__(HIBYTE(HIDWORD(v309)) | ((_DWORD)v309 << 8), v309 >> 24);
  v743 = __PAIR64__(v319, HIDWORD(v319)) + v772 + v433;
  LODWORD(v768) = (2 * v321) | (HIDWORD(v321) >> 31);
  v323 = (v772 + v433) ^ v747;
  HIDWORD(v768) = v321 >> 31;
  v324 = (2 * v322) | (HIDWORD(v322) >> 31);
  LODWORD(v745) = (2 * v323) | (HIDWORD(v323) >> 31);
  LODWORD(v762) = (__int64)(v743 ^ v738) >> 24;
  HIDWORD(v762) = ((unsigned int)((v743 ^ v738) >> 32) >> 24) | (((unsigned int)v743 ^ (unsigned int)v738) << 8);
  HIDWORD(v322) = v322 >> 31;
  HIDWORD(v745) = v323 >> 31;
  LODWORD(v322) = (v374 + v762) ^ HIDWORD(v319);
  HIDWORD(v738) = HIDWORD(v322);
  HIDWORD(v322) = ((unsigned __int64)(v374 + v762) >> 32) ^ v319;
  LODWORD(v738) = v324;
  v806 = v374 + v762;
  LODWORD(v323) = v322 >> 16;
  HIDWORD(v323) = HIWORD(HIDWORD(v322)) | ((_DWORD)v322 << 16);
  v748 = __PAIR64__((v477 + v745) ^ v763, ((v477 + v745) ^ v763) >> 32);
  v325 = v323 + v743;
  v814[7] = v323;
  v744 = __PAIR64__((v477 + v745) ^ v763, ((v477 + v745) ^ v763) >> 32) + v767;
  v388 = v387 + v795;
  v775 = v325 ^ v762;
  result = 8;
  v814[2] = v325;
  v327 = v405 + v801 + v738;
  v776 = (v388 + v768) ^ v772;
  LODWORD(v325) = (__int64)((__PAIR64__((v477 + v745) ^ v763, ((v477 + v745) ^ v763) >> 32) + v767) ^ v745) >> 24;
  HIDWORD(v325) = ((unsigned int)((v744 ^ v745) >> 32) >> 24) | (((unsigned int)v744 ^ (unsigned int)v745) << 8);
  HIDWORD(v763) = v327 ^ v765;
  v328 = __PAIR64__(v776, HIDWORD(v776));
  LODWORD(v763) = (v327 ^ v765) >> 32;
  v766 = v763 + v771;
  v774 = __PAIR64__(v776, HIDWORD(v776)) + v419;
  v807 = v477 + v745 + v792 + v325;
  v329 = (v763 + v771) ^ v738;
  v330 = __PAIR64__(v776, HIDWORD(v776)) + v419;
  LODWORD(v776) = v329 >> 24;
  v331 = v330 ^ v768;
  LODWORD(v787) = v331 >> 24;
  HIDWORD(v787) = HIBYTE(HIDWORD(v331)) | ((_DWORD)v331 << 8);
  HIDWORD(v776) = HIBYTE(HIDWORD(v329)) | ((_DWORD)v329 << 8);
  v808 = v327 + v797 + v776;
  v809 = v388 + v768 + v793 + v787;
  v746 = __PAIR64__(
           ((unsigned int)((v807 ^ v748) >> 32) >> 16)
         | ((((_DWORD)v477 + (_DWORD)v745 + (_DWORD)v792 + (_DWORD)v325) ^ (unsigned int)v748) << 16),
           (__int64)(v807 ^ v748) >> 16);
  v332 = v809 ^ v328;
  v814[3] = v746 + v744;
  LODWORD(v768) = (__int64)(v809 ^ v328) >> 16;
  v764 = __PAIR64__(
           ((unsigned int)((v808 ^ v763) >> 32) >> 16) | (((unsigned int)v808 ^ (unsigned int)v763) << 16),
           (__int64)(v808 ^ v763) >> 16);
  v333 = (v746 + v744) ^ v325;
  HIDWORD(v768) = HIWORD(HIDWORD(v332)) | ((_DWORD)v332 << 16);
  v334 = v764 + v766;
  LODWORD(v811) = (2 * v775) | (HIDWORD(v775) >> 31);
  v814[1] = v768 + v774;
  v335 = (v764 + v766) ^ v776;
  HIDWORD(v811) = v775 >> 31;
  v336 = (v768 + v774) ^ v787;
  LODWORD(v812) = (2 * v333) | (HIDWORD(v333) >> 31);
  v814[4] = v746;
  LODWORD(v813) = (2 * v335) | (HIDWORD(v335) >> 31);
  HIDWORD(v812) = v333 >> 31;
  HIDWORD(v813) = v335 >> 31;
  LODWORD(v810) = (2 * v336) | (HIDWORD(v336) >> 31);
  v814[5] = v764;
  v814[0] = v764 + v766;
  v814[6] = v768;
  HIDWORD(v810) = v336 >> 31;
  v337 = (_QWORD *)a1;
  v338 = v374 + v762;
  v339 = &v806;
  for ( i = v814; ; ++i )
  {
    --result;
    *v337++ ^= v338 ^ v334;
    if ( !result )
      break;
    v341 = v339[1];
    ++v339;
    v338 = v341;
    v342 = i[1];
    v334 = v342;
  }
  return result;
}
// 4D798: too many cbuild loops

//----- (000535FC) --------------------------------------------------------
int __fastcall sub_535FC(char *a1, unsigned __int8 *a2)
{
  char *v4; // r12
  char *v5; // r4
  __int64 v6; // t1
  unsigned __int8 *v7; // r1
  _QWORD *v8; // r0
  __int64 v9; // d18
  __int64 v10; // d21
  __int64 v11; // d17
  unsigned int v12; // r2
  __int64 v13; // d19

  memset(a1, 0, 0x168u);
  v4 = "";
  v5 = a1 - 8;
  do
  {
    v6 = *((_QWORD *)v4 + 1);
    v4 += 8;
    *((_QWORD *)v5 + 1) = v6;
    v5 += 8;
  }
  while ( v4 != (char *)&unk_693E0 );
  v7 = a2;
  v8 = a1;
  do
  {
    v9 = vshld_n_s64(v7[2], 0x10u) | vshld_n_s64(v7[1], 8u);
    LODWORD(v9) = *v7 | (unsigned int)v9;
    v10 = vshld_n_s64(v7[4], 0x20u) | vshld_n_s64(v7[3], 0x18u) | v9;
    v11 = vshld_n_s64(v7[5], 0x28u);
    v12 = v7[7];
    v13 = vshld_n_s64(v7[6], 0x30u);
    v7 += 8;
    *v8++ ^= vshld_n_s64(v12, 0x38u) | v13 | v11 | v10;
  }
  while ( v7 != a2 + 64 );
  return 0;
}

//----- (00053700) --------------------------------------------------------
int __fastcall sub_53700(char *a1, int a2)
{
  unsigned __int8 v3[18]; // [sp+0h] [bp-44h] BYREF
  __int16 v4; // [sp+12h] [bp-32h]
  __int16 v5; // [sp+14h] [bp-30h]
  __int16 v6; // [sp+16h] [bp-2Eh]
  __int16 v7; // [sp+18h] [bp-2Ch]
  __int16 v8; // [sp+1Ah] [bp-2Ah]
  __int16 v9; // [sp+1Ch] [bp-28h]
  __int16 v10; // [sp+1Eh] [bp-26h]
  int v11; // [sp+20h] [bp-24h]
  int v12; // [sp+24h] [bp-20h]
  int v13; // [sp+28h] [bp-1Ch]
  int v14; // [sp+2Ch] [bp-18h]
  int v15; // [sp+30h] [bp-14h]
  int v16; // [sp+34h] [bp-10h]
  int v17; // [sp+38h] [bp-Ch]
  int v18; // [sp+3Ch] [bp-8h]

  if ( (unsigned int)(a2 - 1) > 0x3F )
    return -1;
  v3[0] = a2;
  v3[2] = 1;
  v3[1] = 0;
  memset(&v3[4], 0, 14);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v3[3] = 1;
  return sub_535FC(a1, v3);
}

//----- (000537BC) --------------------------------------------------------
int __fastcall sub_537BC(int a1, char *src, unsigned __int64 n)
{
  unsigned __int64 v3; // r4
  int v6; // r3
  int v7; // r10
  int v8; // r6
  int v9; // r12
  unsigned __int64 v10; // r2
  void *srca; // [sp+4h] [bp-8h]

  v3 = n;
  if ( n )
  {
    v6 = *(_DWORD *)(a1 + 352);
    srca = (void *)(a1 + 224);
    while ( 1 )
    {
      v7 = 256 - v6;
      v8 = 256 - v6;
      if ( (unsigned int)(256 - v6) >= v3 )
        break;
      memcpy((void *)(a1 + v6 + 96), src, 256 - v6);
      v9 = *(_DWORD *)(a1 + 352);
      v10 = *(_QWORD *)(a1 + 64) + 128LL;
      *(_QWORD *)(a1 + 64) = v10;
      src += v7;
      *(_QWORD *)(a1 + 72) += v10 <= 0x7F;
      *(_DWORD *)(a1 + 352) = v9 + v7;
      v3 -= (unsigned int)v8;
      sub_4D798(a1, (unsigned __int8 *)(a1 + 96));
      memcpy((void *)(a1 + 96), srca, 0x80u);
      v6 = *(_DWORD *)(a1 + 352) - 128;
      *(_DWORD *)(a1 + 352) = v6;
      if ( !v3 )
        return 0;
    }
    memcpy((void *)(a1 + v6 + 96), src, v3);
    *(_DWORD *)(a1 + 352) += v3;
  }
  return 0;
}

//----- (000538C8) --------------------------------------------------------
int __fastcall sub_538C8(char *a1, int a2, const void *a3, size_t a4)
{
  bool v7; // zf
  unsigned __int8 v9[18]; // [sp+0h] [bp-C4h] BYREF
  __int16 v10; // [sp+12h] [bp-B2h]
  __int16 v11; // [sp+14h] [bp-B0h]
  __int16 v12; // [sp+16h] [bp-AEh]
  __int16 v13; // [sp+18h] [bp-ACh]
  __int16 v14; // [sp+1Ah] [bp-AAh]
  __int16 v15; // [sp+1Ch] [bp-A8h]
  __int16 v16; // [sp+1Eh] [bp-A6h]
  int v17; // [sp+20h] [bp-A4h]
  int v18; // [sp+24h] [bp-A0h]
  int v19; // [sp+28h] [bp-9Ch]
  int v20; // [sp+2Ch] [bp-98h]
  int v21; // [sp+30h] [bp-94h]
  int v22; // [sp+34h] [bp-90h]
  int v23; // [sp+38h] [bp-8Ch]
  int v24; // [sp+3Ch] [bp-88h]
  char s[132]; // [sp+40h] [bp-84h] BYREF

  if ( (unsigned int)(a2 - 1) > 0x3F )
    return -1;
  v7 = a3 == 0;
  if ( a3 )
    v7 = a4 == 0;
  if ( v7 )
    return -1;
  if ( a4 > 0x40 )
    return -1;
  v9[1] = a4;
  v9[0] = a2;
  memset(&v9[4], 0, 14);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v9[2] = 1;
  v9[3] = 1;
  if ( sub_535FC(a1, v9) < 0 )
    return -1;
  memset(s, 0, 0x80u);
  memcpy(s, a3, a4);
  sub_537BC((int)a1, s, 0x80u);
  off_739D4(s, 0, 0x80u);
  return 0;
}
// 739D4: using guessed type void *(*off_739D4)(void *s, int c, size_t n);

//----- (00053A04) --------------------------------------------------------
int __fastcall sub_53A04(int a1, void *a2, size_t a3)
{
  bool v6; // zf
  unsigned int v7; // r2
  unsigned __int8 *v8; // r9
  __int64 v9; // r6
  int v10; // r3
  unsigned __int64 v11; // r0
  int v12; // r0
  int v13; // r11
  char *v14; // r12
  __int64 v15; // t1
  __int64 v17; // r4
  unsigned __int64 v18; // r6
  size_t v19; // r2
  _BYTE v20[64]; // [sp+0h] [bp-44h] BYREF
  char v21; // [sp+40h] [bp-4h] BYREF

  memset(v20, 0, sizeof(v20));
  v6 = a2 == 0;
  if ( a2 )
    v6 = a3 == 0;
  if ( v6 || a3 > 0x40 || *(_QWORD *)(a1 + 80) )
    return -1;
  v7 = *(_DWORD *)(a1 + 352);
  v8 = (unsigned __int8 *)(a1 + 96);
  if ( v7 > 0x80 )
  {
    v17 = *(_QWORD *)(a1 + 72);
    v18 = *(_QWORD *)(a1 + 64) + 128LL;
    *(_QWORD *)(a1 + 64) = v18;
    *(_QWORD *)(a1 + 72) = v17 + (v18 <= 0x7F);
    sub_4D798(a1, (unsigned __int8 *)(a1 + 96));
    v19 = *(_DWORD *)(a1 + 352) - 128;
    *(_DWORD *)(a1 + 352) = v19;
    memcpy((void *)(a1 + 96), (const void *)(a1 + 224), v19);
    v7 = *(_DWORD *)(a1 + 352);
  }
  v9 = *(_QWORD *)(a1 + 72);
  v10 = *(unsigned __int8 *)(a1 + 356);
  v11 = *(_QWORD *)(a1 + 64) + v7;
  *(_QWORD *)(a1 + 64) = v11;
  *(_QWORD *)(a1 + 72) = v9 + (v11 < v7);
  if ( v10 )
    *(_QWORD *)(a1 + 88) = -1;
  *(_QWORD *)(a1 + 80) = -1;
  memset((void *)(a1 + v7 + 96), 0, 256 - v7);
  v12 = a1;
  v13 = a1 - 8;
  sub_4D798(v12, v8);
  v14 = v20;
  do
  {
    v15 = *(_QWORD *)(v13 + 8);
    v13 += 8;
    *(_QWORD *)v14 = v15;
    v14 += 8;
  }
  while ( v14 != &v21 );
  memcpy(a2, v20, a3);
  return 0;
}

//----- (00053CA0) --------------------------------------------------------
int __fastcall sub_53CA0(unsigned __int8 *a1)
{
  char *v1; // r2
  unsigned __int8 *v2; // r3
  int v3; // r12
  int v4; // r0
  int v5; // r1
  unsigned __int8 *v6; // r1
  int i; // r3
  int v8; // r9
  int v9; // r3
  unsigned int v10; // r6
  unsigned int v11; // r5
  int v12; // r6
  _BYTE *v13; // r2
  _BYTE *v14; // r5
  int v15; // r6
  _BYTE *v16; // r7
  _BYTE *v17; // r11
  _BYTE *v18; // r12
  int v19; // r1
  int v20; // r8
  int v21; // r4
  int v22; // r12
  int v23; // r0
  int v24; // r1
  int v25; // r4
  int v26; // r12
  unsigned __int8 *v27; // r2
  int k; // r3
  int result; // r0
  int v30; // [sp+0h] [bp-B8h] BYREF
  int v31; // [sp+4h] [bp-B4h]
  int j; // [sp+8h] [bp-B0h]
  char *v33; // [sp+Ch] [bp-ACh]
  int v34; // [sp+10h] [bp-A8h]
  unsigned __int8 *v35; // [sp+14h] [bp-A4h]
  _DWORD v36[7]; // [sp+18h] [bp-A0h]
  char v37; // [sp+34h] [bp-84h] BYREF
  _BYTE var44[100]; // [sp+74h] [bp-44h] BYREF

  v1 = &v37;
  v2 = a1;
  v35 = a1;
  do
  {
    v3 = v2[43];
    v4 = v2[42];
    v5 = (v2[41] << 16) + (v2[40] << 24);
    v2 += 4;
    *((_DWORD *)v1 + 1) = v5 + v3 + (v4 << 8);
    v1 += 4;
  }
  while ( v1 != var44 );
  v6 = v35;
  for ( i = 0; i != 8; ++i )
    v36[i] = *(_DWORD *)&v6[i * 4];
  for ( j = 0; j != 64; j += 16 )
  {
    v8 = 0;
    v9 = 7;
    v33 = (char *)&unk_693E8 + 4 * j;
    do
    {
      v20 = v9 - 1;
      v21 = v36[((_BYTE)v9 - 3) & 7];
      v22 = v36[(v9 - 1) & 7];
      v23 = __ROR4__(v21, 6) ^ __ROR4__(v21, 11) ^ __ROR4__(v21, 25);
      v24 = (v22 ^ v36[((_BYTE)v9 - 2) & 7]) & v21 ^ v22;
      v25 = v36[v9 & 7];
      v26 = *(_DWORD *)&v33[v8];
      if ( j )
      {
        v10 = *(_DWORD *)&var44[4 * ((5 - (_BYTE)v9) & 0xF) + 4];
        v11 = *(_DWORD *)&var44[4 * ((-8 - (_BYTE)v9) & 0xF) + 4];
        v31 = *(_DWORD *)&var44[4 * (-v9 & 0xF) + 4];
        v30 = __ROR4__(v10, 17) ^ __ROR4__(v10, 19);
        v34 = __ROR4__(v11, 7);
        v31 += *(_DWORD *)&var44[v8 + 4];
        v12 = v31 + (v30 ^ (v10 >> 10)) + (v34 ^ __ROR4__(v11, 18) ^ (v11 >> 3));
      }
      else
      {
        v12 = *(int *)((char *)&v30 + v8 + 56);
      }
      *(_DWORD *)&var44[v8 + 4] = v12;
      v13 = &var44[4 * (v9 & 7) + 68];
      v14 = &var44[4 * (((_BYTE)v9 - 4) & 7) + 68];
      v15 = v25 + v26 + v23 + v24 + v12;
      v16 = &var44[4 * (((_BYTE)v9 - 7) & 7) + 68];
      *((_DWORD *)v13 - 40) = v15;
      v17 = &var44[4 * (((_BYTE)v9 - 6) & 7) + 68];
      v18 = &var44[4 * (((_BYTE)v9 - 5) & 7) + 68];
      *((_DWORD *)v14 - 40) += v15;
      --v9;
      v19 = *((_DWORD *)v16 - 40);
      v8 += 4;
      *((_DWORD *)v13 - 40) += (__ROR4__(v19, 2) ^ __ROR4__(v19, 13) ^ __ROR4__(v19, 22))
                             + ((v19 | *((_DWORD *)v17 - 40)) & *((_DWORD *)v18 - 40) | v19 & *((_DWORD *)v17 - 40));
    }
    while ( v20 != -9 );
  }
  v27 = v35;
  for ( k = 0; k != 8; ++k )
  {
    result = *(_DWORD *)&v27[k * 4];
    *(_DWORD *)&v27[k * 4] = result + v36[k];
  }
  return result;
}

//----- (00053F30) --------------------------------------------------------
int __fastcall sub_53F30(int result)
{
  *(_DWORD *)result = 1779033703;
  *(_DWORD *)(result + 4) = -1150833019;
  *(_DWORD *)(result + 8) = 1013904242;
  *(_DWORD *)(result + 12) = -1521486534;
  *(_DWORD *)(result + 16) = 1359893119;
  *(_DWORD *)(result + 20) = -1694144372;
  *(_DWORD *)(result + 24) = 528734635;
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 28) = 1541459225;
  return result;
}

//----- (00053F9C) --------------------------------------------------------
int __fastcall sub_53F9C(int result, int a2, int a3)
{
  __int64 v3; // r4
  int v4; // r7
  int v5; // r3
  int v6; // r8
  int v7; // r6
  int v9; // r2

  v3 = *(_QWORD *)(result + 32);
  v4 = result;
  v5 = v3 & 0x3F;
  if ( a3 )
  {
    v6 = a2 + a3;
    v7 = a2 + 1;
    while ( 1 )
    {
      v9 = v4 + v5++;
      *(_BYTE *)(v9 + 40) = *(_BYTE *)(v7 - 1);
      *(_QWORD *)(v4 + 32) = v3 + 1;
      if ( v5 == 64 )
      {
        result = sub_53CA0((unsigned __int8 *)v4);
        v5 = 0;
      }
      if ( v7++ == v6 )
        break;
      v3 = *(_QWORD *)(v4 + 32);
    }
  }
  return result;
}

//----- (00054004) --------------------------------------------------------
_BYTE *__fastcall sub_54004(int a1, _BYTE *a2)
{
  __int64 v2; // d16
  __int64 v5; // r4
  char v6; // r3
  int v7; // r7
  int v8; // r2
  int v9; // r3
  _BYTE *result; // r0
  _BYTE *v11; // r2
  int v12; // r3
  int v13; // r1

  v2 = *(_QWORD *)(a1 + 32);
  v5 = vshld_n_s64(v2, 3u);
  v6 = (v2 & 0x3F) + 1;
  *(_BYTE *)(a1 + (v2 & 0x3F) + 40) = 0x80;
  if ( (v2 & 0x3F) != 0x37 )
  {
    do
    {
      while ( 1 )
      {
        v7 = v6 & 0x3F;
        v6 = v7 + 1;
        if ( v7 )
          break;
        sub_53CA0((unsigned __int8 *)a1);
        *(_BYTE *)(a1 + 40) = v7;
        v6 = 1;
      }
      *(_BYTE *)(a1 + v7 + 40) = 0;
    }
    while ( v7 != 55 );
  }
  v8 = a1;
  v9 = 56;
  do
  {
    ++v9;
    *(_BYTE *)(v8 + 96) = HIBYTE(v5);
    v5 <<= 8;
    ++v8;
  }
  while ( v9 != 64 );
  sub_53CA0((unsigned __int8 *)a1);
  result = a2 + 32;
  v11 = a2;
  v12 = 0;
  do
  {
    a2[v12] = HIBYTE(*(_DWORD *)(a1 + v12));
    v11[1] = BYTE2(*(_DWORD *)(a1 + v12));
    v11[2] = BYTE1(*(_DWORD *)(a1 + v12));
    v13 = *(_DWORD *)(a1 + v12);
    v12 += 4;
    v11[3] = v13;
    v11 += 4;
  }
  while ( result != v11 );
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)a1 = 1779033703;
  *(_DWORD *)(a1 + 4) = -1150833019;
  *(_DWORD *)(a1 + 8) = 1013904242;
  *(_DWORD *)(a1 + 12) = -1521486534;
  *(_DWORD *)(a1 + 16) = 1359893119;
  *(_DWORD *)(a1 + 20) = -1694144372;
  *(_DWORD *)(a1 + 24) = 528734635;
  *(_DWORD *)(a1 + 28) = 1541459225;
  return result;
}

//----- (00054160) --------------------------------------------------------
_BYTE *__fastcall sub_54160(int a1, int a2, _BYTE *a3)
{
  _DWORD v5[8]; // [sp+0h] [bp-68h] BYREF
  double v6; // [sp+20h] [bp-48h]

  v6 = 0.0;
  v5[0] = 1779033703;
  v5[1] = -1150833019;
  v5[2] = 1013904242;
  v5[3] = -1521486534;
  v5[4] = 1359893119;
  v5[5] = -1694144372;
  v5[6] = 528734635;
  v5[7] = 1541459225;
  sub_53F9C((int)v5, a1, a2);
  return sub_54004((int)v5, a3);
}

//----- (00054200) --------------------------------------------------------
int __fastcall sub_54200(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 < *a2 )
    return -1;
  else
    return *a1 != *a2;
}

//----- (00054224) --------------------------------------------------------
int __fastcall sub_54224(char *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4)
{
  char *v8; // r0
  int v9; // r1
  char *v10; // r6
  char *v11; // r5
  char *v13; // r0
  bool v14; // zf
  unsigned int v15; // r2
  int v16; // r3
  int v17; // [sp+4h] [bp-18h] BYREF
  char s[20]; // [sp+8h] [bp-14h] BYREF

  if ( !((int (__fastcall *)(const char *, int))a2)("\"", 1) )
  {
    while ( 1 )
    {
      v10 = a1;
      while ( *a1 )
      {
        v13 = sub_56FD0(a1, &v17);
        v11 = v13;
        if ( !v13 )
          return -1;
        v14 = v17 == 92;
        if ( v17 != 92 )
          v14 = v17 == 34;
        if ( v14 || v17 <= 31 || (a4 & 0x400) != 0 && v17 == 47 || (a4 & 0x40) != 0 && v17 > 127 )
          goto LABEL_13;
        a1 = v13;
      }
      v11 = a1;
LABEL_13:
      if ( a1 != v10 && a2(v10, a1 - v10, a3) )
        return -1;
      if ( v11 == a1 )
        return a2((char *)"\"", 1, a3);
      if ( v17 == 12 )
      {
        v9 = 2;
        v8 = "\\f";
        goto LABEL_8;
      }
      if ( v17 <= 12 )
        break;
      if ( v17 == 34 )
      {
        v8 = "\\\"";
        v9 = 2;
        goto LABEL_8;
      }
      if ( v17 > 34 )
      {
        if ( v17 == 47 )
        {
          v9 = 2;
          v8 = "\\/";
        }
        else
        {
          if ( v17 == 92 )
          {
            v9 = 2;
            v8 = "\\\\";
            goto LABEL_8;
          }
LABEL_6:
          if ( v17 >= 0x10000 )
          {
            v15 = ((unsigned int)(v17 - 0x10000) >> 10) & 0x3FF | 0xD800;
            v16 = (v17 - 0x10000) & 0x3FF | 0xDC00;
            v17 -= 0x10000;
            sprintf(s, "\\u%04x\\u%04x", v15, v16);
            v8 = s;
            v9 = 12;
          }
          else
          {
            sprintf(s, "\\u%04x", v17);
            v8 = s;
            v9 = 6;
          }
        }
        goto LABEL_8;
      }
      if ( v17 != 13 )
        goto LABEL_6;
      if ( a2("\\r", 2, a3) )
        return -1;
LABEL_9:
      a1 = v11;
    }
    switch ( v17 )
    {
      case 9:
        v9 = 2;
        v8 = "\\t";
        break;
      case 10:
        v9 = 2;
        v8 = "\\n";
        break;
      case 8:
        v9 = 2;
        v8 = "\\b";
        break;
      default:
        goto LABEL_6;
    }
LABEL_8:
    if ( !a2(v8, v9, a3) )
      goto LABEL_9;
  }
  return -1;
}

//----- (00054448) --------------------------------------------------------
int __fastcall sub_54448(int a1, int a2)
{
  return strcmp(*(const char **)(a1 + 4), *(const char **)(a2 + 4));
}

//----- (00054454) --------------------------------------------------------
int __fastcall sub_54454(const void *a1, size_t a2, FILE *s)
{
  if ( fwrite(a1, a2, 1u, s) == 1 )
    return 0;
  else
    return -1;
}

//----- (00054474) --------------------------------------------------------
int __fastcall sub_54474(void *src, size_t n, const void **a3)
{
  return sub_56A68(a3, src, n);
}

//----- (0005448C) --------------------------------------------------------
int __fastcall sub_5448C(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int v5; // r8
  int v9; // r4

  v5 = a1 & 0x1F;
  if ( (a1 & 0x1F) != 0 )
  {
    if ( !a4(ptr, 1, a5) )
    {
      if ( a2 <= 0 )
        return 0;
      v9 = 0;
      while ( 1 )
      {
        ++v9;
        if ( a4("                                ", v5, a5) )
          break;
        if ( v9 == a2 )
          return 0;
      }
    }
    return -1;
  }
  else
  {
    if ( !a3 || (a1 & 0x20) != 0 )
      return 0;
    return a4(" ", 1, a5);
  }
}

//----- (00054530) --------------------------------------------------------
int __fastcall sub_54530(_DWORD *a1, int a2, int a3, int (__fastcall *a4)(char *, int, int), int a5)
{
  int (__fastcall *v7)(char *, int, int); // r4
  int v8; // r5
  __int64 v9; // r0
  int v10; // r1
  int result; // r0
  const char *v12; // r2
  int v13; // r11
  _DWORD *v14; // r8
  int v15; // r9
  int v16; // r10
  int v17; // r10
  char *v18; // r0
  int v19; // r0
  _DWORD *v20; // r9
  int v21; // r10
  signed int i; // r8
  _DWORD *v23; // r0
  char *v24; // r0
  char *v25; // r0
  int v26; // r5
  unsigned int v27; // r11
  char *v28; // r4
  char *v29; // r6
  unsigned int v30; // r8
  int (*v31)(const void *, const void *); // r3
  char *v32; // r11
  int v33; // r10
  char *v35; // [sp+Ch] [bp-88h]
  size_t nmemb; // [sp+10h] [bp-84h]
  void *base; // [sp+14h] [bp-80h]
  int v38; // [sp+18h] [bp-7Ch]
  unsigned int v39; // [sp+1Ch] [bp-78h]
  int v40; // [sp+20h] [bp-74h]
  int (__fastcall *v41)(char *, int, int); // [sp+24h] [bp-70h]
  char s[104]; // [sp+2Ch] [bp-68h] BYREF

  v7 = a4;
  v8 = a5;
  if ( !a1 )
    return -1;
  switch ( *a1 )
  {
    case 0:
      v12 = ":";
      if ( (a2 & 0x20) != 0 )
        v13 = 1;
      else
        v13 = 2;
      if ( (a2 & 0x20) == 0 )
        v12 = ": ";
      v35 = (char *)v12;
      if ( a1[8] )
        goto LABEL_22;
      a1[8] = 1;
      v14 = sub_57254(a1);
      if ( v7("{", 1, a5) )
        goto LABEL_22;
      if ( v14 )
      {
        v15 = a3 + 1;
        v16 = sub_5448C(a2, a3 + 1, 0, (int (__fastcall *)(const char *, int, int))v7, a5);
        if ( !v16 )
        {
          if ( (a2 & 0x180) != 0 )
          {
            nmemb = (size_t)sub_571BC(a1);
            v25 = (char *)sub_56924(8 * nmemb);
            base = v25;
            if ( v25 )
            {
              v38 = v13;
              v41 = v7;
              v26 = (int)v14;
              v27 = 0;
              v40 = a2;
              v28 = v25;
              while ( 1 )
              {
                *(_DWORD *)&v28[v16] = sub_552F4(v26);
                v29 = &v28[v16];
                v16 += 8;
                *((_DWORD *)v29 + 1) = sub_572CC(v26);
                v26 = sub_572A0(a1, v26);
                if ( !v26 )
                  break;
                ++v27;
              }
              v30 = 0;
              v8 = a5;
              v39 = v27;
              v7 = v41;
              if ( nmemb != v27 + 1 )
                _assert_fail("i == size", "dump.c", 0x141u, "do_dump");
              v31 = (int (*)(const void *, const void *))sub_54448;
              if ( (v40 & 0x80) == 0 )
                v31 = (int (*)(const void *, const void *))sub_54200;
              qsort(base, nmemb, 8u, v31);
              if ( !nmemb )
              {
LABEL_65:
                sub_5694C(base);
LABEL_43:
                a1[8] = 0;
                return v7((char *)"}", 1, v8);
              }
              while ( 1 )
              {
                v32 = (char *)*((_DWORD *)base + 2 * v30 + 1);
                v33 = sub_571D8(a1, v32);
                if ( !v33 )
                  _assert_fail("value", "dump.c", 0x151u, "do_dump");
                sub_54224(v32, v41, a5, v40);
                if ( v41(v35, v38, a5) || sub_54530(v33, v40, v15, v41, a5) )
                  break;
                if ( v39 > v30 )
                {
                  if ( v41((char *)",", 1, a5)
                    || sub_5448C(v40, v15, 1, (int (__fastcall *)(const char *, int, int))v41, a5) )
                  {
                    break;
                  }
                }
                else if ( sub_5448C(v40, a3, 0, (int (__fastcall *)(const char *, int, int))v41, a5) )
                {
                  break;
                }
                if ( nmemb == ++v30 )
                  goto LABEL_65;
              }
              sub_5694C(base);
            }
          }
          else
          {
            while ( 1 )
            {
              v17 = sub_572A0(a1, (int)v14);
              v18 = (char *)sub_572CC((int)v14);
              sub_54224(v18, v7, a5, a2);
              if ( v7(v35, v13, a5) )
                goto LABEL_22;
              v19 = sub_572D8((int)v14);
              if ( sub_54530(v19, a2, v15, v7, a5) )
                goto LABEL_22;
              if ( !v17 )
                break;
              if ( !v7((char *)",", 1, a5) )
              {
                v14 = (_DWORD *)v17;
                if ( !sub_5448C(a2, v15, 1, (int (__fastcall *)(const char *, int, int))v7, a5) )
                  continue;
              }
              goto LABEL_22;
            }
            if ( !sub_5448C(a2, a3, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
              goto LABEL_43;
          }
        }
LABEL_22:
        a1[8] = 0;
        return -1;
      }
      a1[8] = 0;
      result = v7((char *)"}", 1, a5);
      break;
    case 1:
      if ( a1[5] )
        goto LABEL_36;
      a1[5] = 1;
      v20 = sub_573A4(a1);
      if ( v7("[", 1, a5) )
        goto LABEL_36;
      if ( !v20 )
        goto LABEL_44;
      v21 = a3 + 1;
      if ( sub_5448C(a2, a3 + 1, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
        goto LABEL_36;
      if ( (int)v20 <= 0 )
        goto LABEL_44;
      for ( i = 0; (_DWORD *)i != v20; ++i )
      {
        v23 = sub_573C0(a1, i);
        if ( sub_54530(v23, a2, v21, v7, a5) )
        {
LABEL_36:
          a1[5] = 0;
          return -1;
        }
        if ( (int)v20 - 1 > i )
        {
          if ( v7((char *)",", 1, a5) || sub_5448C(a2, v21, 1, (int (__fastcall *)(const char *, int, int))v7, a5) )
            goto LABEL_36;
        }
        else if ( sub_5448C(a2, a3, 0, (int (__fastcall *)(const char *, int, int))v7, a5) )
        {
          goto LABEL_36;
        }
      }
LABEL_44:
      a1[5] = 0;
      return v7((char *)word_686A0, 1, a5);
    case 2:
      v24 = (char *)sub_57530(a1);
      return sub_54224(v24, v7, a5, a2);
    case 3:
      v9 = sub_57600((int)a1);
      v10 = snprintf(s, 0x64u, "%lld", v9);
      if ( (unsigned int)v10 > 0x63 )
        return -1;
      return v7(s, v10, a5);
    case 4:
      sub_576B0();
      v10 = sub_56C60(s, 0x64u);
      if ( v10 < 0 )
        return -1;
      return v7(s, v10, a5);
    case 5:
      return a4("true", 4, a5);
    case 6:
      return a4("false", 5, a5);
    case 7:
      return a4("null", 4, a5);
    default:
      return -1;
  }
  return result;
}
// 5455C: control flows out of bounds to 54560

//----- (00054B5C) --------------------------------------------------------
int __fastcall sub_54B5C(_DWORD *a1, int (__fastcall *a2)(char *, int, int), int a3, __int16 a4)
{
  if ( (a4 & 0x200) != 0 || a1 && *a1 <= 1u )
    return sub_54530(a1, a4, 0, a2, a3);
  else
    return -1;
}

//----- (00054BA8) --------------------------------------------------------
int __fastcall sub_54BA8(_DWORD *a1, int a2, __int16 a3)
{
  return sub_54B5C(a1, (int (__fastcall *)(char *, int, int))sub_54454, a2, a3);
}

//----- (00054BBC) --------------------------------------------------------
int __fastcall sub_54BBC(_DWORD *a1, char *filename, __int16 a3)
{
  FILE *v5; // r4
  int v6; // r5

  v5 = fopen(filename, "w");
  if ( !v5 )
    return -1;
  v6 = sub_54BA8(a1, (int)v5, a3);
  fclose(v5);
  return v6;
}

//----- (00054C0C) --------------------------------------------------------
void *__fastcall sub_54C0C(_DWORD *a1, __int16 a2)
{
  void *v4; // r4
  const char *v6; // r0
  _DWORD v7[3]; // [sp+4h] [bp-Ch] BYREF

  v4 = (void *)sub_569D4(v7);
  if ( v4 )
    return 0;
  if ( !sub_54B5C(a1, (int (__fastcall *)(char *, int, int))sub_54474, (int)v7, a2) )
  {
    v6 = (const char *)sub_56A4C((int)v7);
    v4 = sub_5696C(v6);
  }
  sub_56A0C((int)v7);
  return v4;
}

//----- (00054C78) --------------------------------------------------------
int __fastcall sub_54C78(int result, int a2, _DWORD *a3)
{
  _DWORD *v3; // r3
  int v4; // r12
  int v5; // r3

  v3 = *(_DWORD **)a2;
  if ( *(_DWORD *)a2 == result + 12 && v3 == *(_DWORD **)(a2 + 4) )
  {
    v4 = *(_DWORD *)(result + 12);
    a3[1] = v3;
    *a3 = v4;
    v5 = *(_DWORD *)(result + 12);
    *(_DWORD *)(result + 12) = a3;
    *(_DWORD *)(v5 + 4) = a3;
    *(_DWORD *)(a2 + 4) = a3;
    *(_DWORD *)a2 = a3;
  }
  else
  {
    *a3 = *v3;
    a3[1] = v3;
    result = *v3;
    *v3 = a3;
    *(_DWORD *)(result + 4) = a3;
    *(_DWORD *)a2 = a3;
  }
  return result;
}

//----- (00054CD4) --------------------------------------------------------
int __fastcall sub_54CD4(int a1, int *a2, char *s2, int a4)
{
  int v4; // r4

  v4 = *a2;
  if ( *a2 == a1 + 12 && v4 == a2[1] )
    return 0;
  while ( *(_DWORD *)(v4 - 4) != a4 || strcmp((const char *)(v4 + 16), s2) )
  {
    if ( a2[1] == v4 )
      return 0;
    v4 = *(_DWORD *)(v4 + 4);
  }
  return v4 - 4;
}

//----- (00054D4C) --------------------------------------------------------
void __fastcall sub_54D4C(int a1)
{
  int v1; // r3
  int v2; // r6
  int v3; // r0
  void *v4; // r5
  int v5; // r4
  int v6; // r1

  v1 = *(_DWORD *)(a1 + 16);
  v2 = a1 + 12;
  if ( v1 != a1 + 12 )
  {
    do
    {
      v3 = *(_DWORD *)(v1 + 8);
      v4 = (void *)(v1 - 4);
      v5 = *(_DWORD *)(v1 + 4);
      if ( v3 )
      {
        v6 = *(_DWORD *)(v3 + 4);
        if ( v6 != -1 )
        {
          *(_DWORD *)(v3 + 4) = v6 - 1;
          if ( v6 == 1 )
            sub_5779C();
        }
      }
      sub_5694C(v4);
      v1 = v5;
    }
    while ( v5 != v2 );
  }
}
// 5779C: using guessed type int sub_5779C(void);

//----- (00054DAC) --------------------------------------------------------
int __fastcall sub_54DAC(_DWORD *a1)
{
  char *v2; // r2
  _DWORD *v3; // r1
  int v4; // r0
  int v5; // r12
  int v6; // r12
  int v7; // r3

  *a1 = 0;
  a1[2] = 0;
  v2 = (char *)sub_56924(0x28u);
  a1[1] = v2;
  if ( !v2 )
    return -1;
  v3 = a1 + 3;
  v4 = a1[2];
  a1[4] = a1 + 3;
  a1[3] = a1 + 3;
  v5 = dword_6956C[v4];
  if ( v5 )
  {
    v6 = 8 * v5;
    v7 = 0;
    do
    {
      *(_DWORD *)&v2[v7 + 4] = v3;
      *(_DWORD *)&v2[v7] = v3;
      v7 += 8;
    }
    while ( v7 != v6 );
  }
  return 0;
}
// 6956C: using guessed type _DWORD dword_6956C[29];

//----- (00054E2C) --------------------------------------------------------
void __fastcall sub_54E2C(int a1)
{
  sub_54D4C(a1);
  sub_5694C(*(void **)(a1 + 4));
}

//----- (00054E44) --------------------------------------------------------
int __fastcall sub_54E44(int a1, char *a2, int a3, int a4)
{
  unsigned int v6; // r1
  char *v7; // r9
  int v8; // r12
  char *v9; // lr
  unsigned int v10; // r4
  int v11; // r5
  int v12; // t1
  int *v13; // r9
  int v14; // r0
  int v15; // r5
  int v16; // r0
  int v17; // r3
  int v18; // r3
  int v20; // r3
  unsigned int v21; // r4
  int v22; // r11
  int v23; // r3
  _DWORD *v24; // r10
  int v25; // r1
  _DWORD *v26; // r2
  size_t v27; // r0
  void *v28; // r0
  _DWORD *v29; // r11

  v6 = dword_6956C[*(_DWORD *)(a1 + 8)];
  if ( *(_DWORD *)a1 >= v6 )
  {
    sub_5694C(*(void **)(a1 + 4));
    v20 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v20;
    v21 = dword_6956C[v20];
    v7 = (char *)sub_56924(8 * v21);
    *(_DWORD *)(a1 + 4) = v7;
    if ( !v7 )
      return -1;
    v6 = dword_6956C[*(_DWORD *)(a1 + 8)];
    if ( v6 )
    {
      v22 = a1 + 12;
      v23 = 0;
      do
      {
        *(_DWORD *)&v7[v23 + 4] = v22;
        *(_DWORD *)&v7[v23] = v22;
        v23 += 8;
      }
      while ( v23 != 8 * v6 );
    }
    else
    {
      v22 = a1 + 12;
    }
    v24 = *(_DWORD **)(a1 + 16);
    *(_DWORD *)(a1 + 12) = v22;
    *(_DWORD *)(a1 + 16) = v22;
    if ( v24 != (_DWORD *)v22 )
    {
      while ( 1 )
      {
        v25 = *(v24 - 1) % v21;
        v26 = v24;
        v24 = (_DWORD *)v24[1];
        sub_54C78(a1, (int)&v7[8 * v25], v26);
        if ( (_DWORD *)v22 == v24 )
          break;
        v7 = *(char **)(a1 + 4);
      }
      v7 = *(char **)(a1 + 4);
      v6 = dword_6956C[*(_DWORD *)(a1 + 8)];
    }
  }
  else
  {
    v7 = *(char **)(a1 + 4);
  }
  v8 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v9 = a2;
    v10 = 5381;
    do
    {
      v11 = v8 + 32 * v10;
      v12 = (unsigned __int8)*++v9;
      v8 = v12;
      v10 += v11;
    }
    while ( v12 );
  }
  else
  {
    v10 = 5381;
  }
  v13 = (int *)&v7[8 * (v10 % v6)];
  v14 = sub_54CD4(a1, v13, a2, v10);
  v15 = v14;
  if ( !v14 )
  {
    v27 = strlen(a2);
    v28 = sub_56924(v27 + 21);
    v29 = v28;
    if ( v28 )
    {
      *(_DWORD *)v28 = v10;
      *((_DWORD *)v28 + 4) = a3;
      strcpy((char *)v28 + 20, a2);
      v29[2] = v29 + 1;
      v29[3] = a4;
      v29[1] = v29 + 1;
      sub_54C78(a1, (int)v13, v29 + 1);
      ++*(_DWORD *)a1;
      return 0;
    }
    return -1;
  }
  v16 = *(_DWORD *)(v14 + 12);
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4);
    if ( v17 != -1 )
    {
      v18 = v17 - 1;
      *(_DWORD *)(v16 + 4) = v18;
      if ( !v18 )
        sub_5779C((void **)v16);
    }
  }
  *(_DWORD *)(v15 + 12) = a4;
  return 0;
}
// 6956C: using guessed type _DWORD dword_6956C[29];

//----- (0005504C) --------------------------------------------------------
int __fastcall sub_5504C(int a1, char *a2)
{
  int v2; // r3
  char *v3; // r12
  unsigned int v4; // r4
  int v5; // lr
  int v6; // t1
  int result; // r0

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v3 = a2;
    v4 = 5381;
    do
    {
      v5 = v2 + 32 * v4;
      v6 = (unsigned __int8)*++v3;
      v2 = v6;
      v4 += v5;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  result = sub_54CD4(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v4 % dword_6956C[*(_DWORD *)(a1 + 8)])), a2, v4);
  if ( result )
    return *(_DWORD *)(result + 12);
  return result;
}
// 6956C: using guessed type _DWORD dword_6956C[29];

//----- (000550C4) --------------------------------------------------------
int __fastcall sub_550C4(_DWORD *a1, char *a2)
{
  int v2; // r3
  char *v4; // r12
  unsigned int v5; // r4
  int v6; // lr
  int v7; // t1
  int v8; // r7
  int *v9; // r6
  int v10; // r8
  _DWORD *v11; // r0
  _DWORD *v12; // r4
  _DWORD *v13; // r3
  int v14; // r2
  int v15; // r3
  int v16; // r0
  int v17; // r3
  int v18; // r3
  _DWORD *v20; // r3

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v4 = a2;
    v5 = 5381;
    do
    {
      v6 = v2 + 32 * v5;
      v7 = (unsigned __int8)*++v4;
      v2 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  else
  {
    v5 = 5381;
  }
  v8 = a1[1];
  v9 = (int *)(v8 + 8 * (v5 % dword_6956C[a1[2]]));
  v10 = v5 % dword_6956C[a1[2]];
  v11 = (_DWORD *)sub_54CD4((int)a1, v9, a2, v5);
  v12 = v11;
  if ( !v11 )
    return -1;
  v13 = v11 + 1;
  v14 = v9[1];
  if ( v11 + 1 == *(_DWORD **)(v8 + 8 * v10) )
  {
    if ( v13 == (_DWORD *)v14 )
    {
      v20 = a1 + 3;
      v9[1] = (int)(a1 + 3);
    }
    else
    {
      v20 = (_DWORD *)v11[2];
    }
    *(_DWORD *)(v8 + 8 * v10) = v20;
  }
  else if ( v13 == (_DWORD *)v14 )
  {
    v9[1] = v11[1];
  }
  v15 = v11[1];
  v16 = v11[3];
  *(_DWORD *)(v15 + 4) = v12[2];
  *(_DWORD *)v12[2] = v15;
  if ( v16 )
  {
    v17 = *(_DWORD *)(v16 + 4);
    if ( v17 != -1 )
    {
      v18 = v17 - 1;
      *(_DWORD *)(v16 + 4) = v18;
      if ( !v18 )
        sub_5779C((void **)v16);
    }
  }
  sub_5694C(v12);
  --*a1;
  return 0;
}
// 6956C: using guessed type _DWORD dword_6956C[29];

//----- (000551E0) --------------------------------------------------------
void __fastcall sub_551E0(_DWORD *a1)
{
  int v2; // r4
  int v3; // r1
  int v4; // r4
  _DWORD *v5; // r2
  int v6; // r3

  sub_54D4C((int)a1);
  v2 = dword_6956C[a1[2]];
  if ( v2 )
  {
    v3 = a1[1];
    v4 = 8 * v2;
    v5 = a1 + 3;
    v6 = 0;
    do
    {
      *(_DWORD *)(v3 + v6 + 4) = v5;
      *(_DWORD *)(v3 + v6) = v5;
      v6 += 8;
    }
    while ( v6 != v4 );
  }
  else
  {
    v5 = a1 + 3;
  }
  a1[4] = v5;
  a1[3] = v5;
  *a1 = 0;
}
// 6956C: using guessed type _DWORD dword_6956C[29];

//----- (0005525C) --------------------------------------------------------
int __fastcall sub_5525C(int a1, char *a2)
{
  int v2; // r3
  char *v3; // r12
  unsigned int v4; // r4
  int v5; // lr
  int v6; // t1
  int result; // r0

  v2 = (unsigned __int8)*a2;
  if ( *a2 )
  {
    v3 = a2;
    v4 = 5381;
    do
    {
      v5 = v2 + 32 * v4;
      v6 = (unsigned __int8)*++v3;
      v2 = v6;
      v4 += v5;
    }
    while ( v6 );
  }
  else
  {
    v4 = 5381;
  }
  result = sub_54CD4(a1, (int *)(*(_DWORD *)(a1 + 4) + 8 * (v4 % dword_6956C[*(_DWORD *)(a1 + 8)])), a2, v4);
  if ( result )
    result += 4;
  return result;
}
// 6956C: using guessed type _DWORD dword_6956C[29];

//----- (000552F4) --------------------------------------------------------
int __fastcall sub_552F4(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00055304) --------------------------------------------------------
void __fastcall sub_55304(int a1, int a2)
{
  int v3; // r0
  int v5; // r2
  int v6; // r2

  v3 = *(_DWORD *)(a1 + 8);
  if ( !v3 || (v5 = *(_DWORD *)(v3 + 4), v5 == -1) || (v6 = v5 - 1, (*(_DWORD *)(v3 + 4) = v6) != 0) )
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  else
  {
    sub_5779C((void **)v3);
    *(_DWORD *)(a1 + 8) = a2;
  }
}

//----- (0005534C) --------------------------------------------------------
int __fastcall sub_5534C(_DWORD *a1)
{
  int v1; // r2
  int result; // r0

  v1 = a1[1];
  result = *(unsigned __int8 *)(*a1 + v1);
  if ( !result )
    return -1;
  a1[1] = v1 + 1;
  return result;
}

//----- (0005536C) --------------------------------------------------------
int __fastcall sub_5536C(_DWORD *a1)
{
  unsigned int v1; // r3
  unsigned int v2; // r2
  int v3; // r3

  v1 = a1[2];
  if ( v1 >= a1[1] )
    return -1;
  v2 = v1 + 1;
  v3 = *(unsigned __int8 *)(*a1 + v1);
  a1[2] = v2;
  return v3;
}

//----- (00055390) --------------------------------------------------------
int __fastcall sub_55390(_DWORD *a1)
{
  unsigned int v1; // r3
  int result; // r0
  int (__fastcall *v4)(_DWORD *, int, _DWORD); // r3
  int v5; // r0

  v1 = a1[257];
  if ( v1 < a1[256] )
    goto LABEL_2;
  v4 = (int (__fastcall *)(_DWORD *, int, _DWORD))a1[258];
  a1[257] = 0;
  v5 = v4(a1, 1024, a1[259]);
  a1[256] = v5;
  if ( (unsigned int)(v5 - 1) <= 0xFFFFFFFD )
  {
    v1 = a1[257];
LABEL_2:
    result = *((unsigned __int8 *)a1 + v1);
    a1[257] = v1 + 1;
    return result;
  }
  return -1;
}

//----- (000553EC) --------------------------------------------------------
int sub_553EC(int result, _DWORD *a2, const char *a3, ...)
{
  int v3; // r5
  const char *v5; // r0
  int v6; // r10
  int v7; // r6
  int v8; // r8
  char *v9; // r3
  char s[160]; // [sp+10h] [bp-144h] BYREF
  char v11[159]; // [sp+B0h] [bp-A4h] BYREF
  char v12; // [sp+14Fh] [bp-5h]
  const char *varg_r2; // [sp+170h] [bp+1Ch]
  va_list varg_r3; // [sp+174h] [bp+20h] BYREF

  va_start(varg_r3, a3);
  varg_r2 = a3;
  v3 = result;
  if ( result )
  {
    vsnprintf(s, 0xA0u, varg_r2, varg_r3);
    s[159] = 0;
    if ( a2 )
    {
      v5 = (const char *)sub_56A4C((int)(a2 + 10));
      v6 = a2[6];
      v7 = a2[7];
      v8 = a2[9];
      if ( v5 && *v5 )
      {
        if ( a2[11] <= 0x14u )
        {
          snprintf(v11, 0xA0u, "%s near '%s'", s, v5);
          v9 = v11;
          v12 = 0;
        }
        else
        {
          v9 = s;
        }
      }
      else
      {
        v9 = s;
        if ( a2[5] != -2 )
        {
          snprintf(v11, 0xA0u, "%s near end of file", s);
          v9 = v11;
          v12 = 0;
        }
      }
    }
    else
    {
      v7 = -1;
      v9 = s;
      v8 = 0;
      v6 = -1;
    }
    return sub_58450(v3, v6, v7, v8, (char *)"%s", v9);
  }
  return result;
}

//----- (0005550C) --------------------------------------------------------
int __fastcall sub_5550C(int a1, int a2, int a3)
{
  int result; // r0
  int v5; // r3
  bool v6; // zf

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 24) = 1;
  result = sub_569D4((_DWORD *)(a1 + 40));
  v6 = result == 0;
  if ( result )
    result = -1;
  else
    v5 = -1;
  if ( v6 )
    *(_DWORD *)(a1 + 52) = v5;
  return result;
}
// 55550: variable 'v5' is possibly undefined

//----- (00055558) --------------------------------------------------------
void __fastcall sub_55558(int a1)
{
  if ( *(_DWORD *)(a1 + 52) == 256 )
    sub_5694C(*(void **)(a1 + 56));
  sub_56A0C(a1 + 40);
}

//----- (00055584) --------------------------------------------------------
int __fastcall sub_55584(_BYTE *a1)
{
  int v1; // r1
  int i; // r3
  int v3; // r2
  int v4; // r4
  int v5; // r1

  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x120u, "decode_unicode_escape");
  v1 = 0;
  for ( i = 1; i != 5; ++i )
  {
    v3 = (unsigned __int8)a1[i];
    v4 = 16 * v1;
    v5 = v3 - 48;
    if ( (unsigned __int8)(v3 - 48) <= 9u )
      goto LABEL_7;
    if ( (unsigned int)(v3 - 97) <= 0x19 )
    {
      v5 = v3 - 87;
LABEL_7:
      v1 = v5 + v4;
      continue;
    }
    if ( (unsigned int)(v3 - 65) > 0x19 )
      _assert_fail(word_60FDC, "load.c", 0x12Cu, "decode_unicode_escape");
    v1 = v3 - 55 + v4;
  }
  return v1;
}

//----- (0005562C) --------------------------------------------------------
_DWORD *__fastcall sub_5562C(_DWORD *result, int a2)
{
  _DWORD *v3; // r4
  int v4; // r3
  int v5; // r3
  int v6; // r3

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      v6 = result[6];
      result[7] = result[8];
      result[6] = v6 - 1;
    }
    else
    {
      result = (_DWORD *)sub_56E7C((unsigned __int8)a2);
      if ( result )
        --v3[7];
    }
    v4 = v3[4];
    if ( !v4 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xE0u, "stream_unget");
    v5 = v4 - 1;
    v3[4] = v5;
    if ( *((unsigned __int8 *)v3 + v5 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (000556E4) --------------------------------------------------------
int __fastcall sub_556E4(int a1, int a2)
{
  int v3; // r5
  int v5; // r3
  int v6; // r0
  int v7; // r1
  int v8; // r3
  int v10; // r2
  int v11; // r3
  int v12; // r7
  bool v13; // cc
  int v14; // r0
  int v15; // r10
  int v16; // r5
  int v17; // r8
  int v18; // r1
  int v19; // r3

  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
    return v3;
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(unsigned __int8 *)(a1 + v5 + 8);
  if ( v6 )
  {
    v7 = v5 + 1;
    goto LABEL_5;
  }
  v6 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
  v12 = v6;
  if ( v6 == -1 )
  {
    *(_DWORD *)(a1 + 20) = -1;
    return -1;
  }
  *(_DWORD *)(a1 + 16) = 0;
  v13 = (unsigned int)(v6 - 128) > 0x7F;
  v6 = (unsigned __int8)v6;
  if ( v13 )
    *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 8) = v6;
  if ( v13 )
  {
    v7 = 1;
  }
  else
  {
    v14 = sub_56E7C((unsigned __int8)v6);
    v15 = v14;
    if ( !v14 )
      goto LABEL_23;
    if ( v14 <= 1 )
      _assert_fail("count >= 2", "load.c", 0xAFu, "stream_get");
    v16 = a1;
    v17 = a1 - 1 + v14;
    do
    {
      *(_BYTE *)(v16 + 9) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
      ++v16;
    }
    while ( v16 != v17 );
    if ( !sub_56EF8((char *)(a1 + 8), v15, 0) )
    {
LABEL_23:
      v3 = -2;
      *(_DWORD *)(a1 + 20) = -2;
      sub_553EC(a2, (_DWORD *)a1, "unable to decode byte 0x%x", v12);
      return v3;
    }
    v18 = *(_DWORD *)(a1 + 16);
    v19 = a1 + v18;
    *(_BYTE *)(a1 + v15 + 8) = 0;
    v7 = v18 + 1;
    v6 = *(unsigned __int8 *)(v19 + 8);
  }
LABEL_5:
  v8 = *(_DWORD *)(a1 + 36);
  v3 = v6;
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 36) = v8 + 1;
  if ( v6 != 10 )
  {
    if ( sub_56E7C(v6) )
      ++*(_DWORD *)(a1 + 28);
    return v3;
  }
  v10 = *(_DWORD *)(a1 + 28);
  v11 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = v10;
  *(_DWORD *)(a1 + 24) = v11 + 1;
  return 10;
}

//----- (00055868) --------------------------------------------------------
_DWORD *__fastcall sub_55868(_DWORD *result, int a2)
{
  _DWORD *v3; // r5
  int v4; // r1
  int v5; // r2

  v3 = result;
  if ( (unsigned int)(a2 + 2) > 1 )
  {
    sub_5562C(result, a2);
    result = (_DWORD *)sub_56B78(v3 + 10, v4, v5);
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}
// 55888: variable 'v4' is possibly undefined
// 55888: variable 'v5' is possibly undefined

//----- (000558B4) --------------------------------------------------------
int __fastcall sub_558B4(int a1, int a2)
{
  int v3; // r4

  v3 = sub_556E4(a1, a2);
  if ( (unsigned int)(v3 + 2) > 1 )
    DataWriter::WriteByte((const void **)(a1 + 40), v3);
  return v3;
}

//----- (000558E4) --------------------------------------------------------
unsigned int __fastcall sub_558E4(int a1, int a2)
{
  const void **v2; // r7
  int v5; // r0
  bool v6; // zf
  unsigned int v7; // r4
  bool v8; // zf
  bool v9; // zf
  bool v10; // zf
  bool v11; // zf
  bool v12; // cc
  unsigned __int8 i; // r1
  int v14; // r2
  int v15; // r3
  int v17; // r0
  const char *v18; // r4
  int v19; // r0
  bool v20; // zf
  const char *v21; // r4
  int *v22; // r7
  __int64 v23; // r2
  int v24; // r0
  int v25; // r1
  unsigned int v26; // r4
  int v27; // r0
  bool v28; // zf
  bool v29; // zf
  bool v30; // zf
  double v31; // r2
  bool v32; // zf
  int v33; // r8
  bool v34; // cc
  _BYTE *v35; // r0
  _BYTE *v36; // r8
  unsigned __int8 *v37; // r7
  int v38; // r2
  unsigned int v39; // r2
  int v40; // r0
  int v41; // r2
  int v42; // r0
  int v43; // r0
  int v44; // [sp+8h] [bp-24h]
  int v45; // [sp+Ch] [bp-20h]
  _BYTE src[4]; // [sp+14h] [bp-18h] BYREF
  size_t n; // [sp+18h] [bp-14h] BYREF
  char *endptr; // [sp+1Ch] [bp-10h] BYREF
  double v49; // [sp+20h] [bp-Ch] BYREF

  v2 = (const void **)(a1 + 40);
  sub_56A38(a1 + 40);
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    sub_5694C(*(void **)(a1 + 56));
    *(_DWORD *)(a1 + 56) = 0;
  }
  while ( 1 )
  {
    v5 = sub_556E4(a1, a2);
    v6 = v5 == 32;
    if ( v5 != 32 )
      v6 = v5 == 9;
    v7 = v5;
    if ( !v6 )
    {
      v8 = v5 == 10;
      if ( v5 != 10 )
        v8 = v5 == 13;
      if ( !v8 )
        break;
    }
  }
  if ( v5 == -1 )
  {
    *(_DWORD *)(a1 + 52) = 0;
    return 0;
  }
  if ( v5 == -2 )
  {
LABEL_33:
    v7 = -1;
LABEL_34:
    *(_DWORD *)(a1 + 52) = v7;
    return v7;
  }
  DataWriter::WriteByte(v2, v5);
  v9 = v7 == 123;
  if ( v7 != 123 )
    v9 = v7 == 125;
  if ( v9 )
    goto LABEL_34;
  v10 = v7 == 91;
  if ( v7 != 91 )
    v10 = v7 == 93;
  if ( v10 )
    goto LABEL_34;
  v11 = v7 == 58;
  if ( v7 != 58 )
    v11 = v7 == 44;
  if ( v11 )
    goto LABEL_34;
  if ( v7 != 34 )
  {
    v12 = v7 > 0x2D;
    if ( v7 != 45 )
      v12 = v7 - 48 > 9;
    if ( !v12 )
    {
      *(_DWORD *)(a1 + 52) = -1;
      if ( v7 == 45 )
        v7 = sub_558B4(a1, a2);
      if ( v7 == 48 )
      {
        v19 = sub_558B4(a1, a2);
        if ( (unsigned int)(v19 - 48) <= 9 )
          goto LABEL_97;
      }
      else
      {
        if ( v7 - 48 > 9 )
        {
          sub_55868((_DWORD *)a1, v7);
          return *(_DWORD *)(a1 + 52);
        }
        do
          v19 = sub_558B4(a1, a2);
        while ( (unsigned int)(v19 - 48) <= 9 );
      }
      v20 = v19 == 69;
      if ( v19 != 69 )
        v20 = v19 == 46;
      if ( v20 )
      {
        if ( v19 == 46 )
        {
          v43 = sub_556E4(a1, a2);
          if ( (unsigned int)(v43 - 48) > 9 )
          {
            sub_5562C((_DWORD *)a1, v43);
            return *(_DWORD *)(a1 + 52);
          }
          DataWriter::WriteByte(v2, v43);
          do
            v19 = sub_558B4(a1, a2);
          while ( (unsigned int)(v19 - 48) <= 9 );
        }
        if ( (v19 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_79;
      }
      else if ( v19 != 101 )
      {
        sub_55868((_DWORD *)a1, v19);
        v21 = (const char *)sub_56A4C((int)v2);
        v22 = _errno_location();
        *v22 = 0;
        v23 = strtoll(v21, &endptr, 10);
        if ( *v22 == 34 )
        {
          if ( v23 >= 0 )
            sub_553EC(a2, (_DWORD *)a1, "too big integer");
          else
            sub_553EC(a2, (_DWORD *)a1, "too big negative integer");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          if ( endptr != &v21[*(_DWORD *)(a1 + 44)] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x206u, "lex_scan_number");
          *(_QWORD *)(a1 + 56) = v23;
          v7 = 257;
          *(_DWORD *)(a1 + 52) = 257;
        }
        return v7;
      }
      v19 = sub_558B4(a1, a2);
      v32 = v19 == 43;
      if ( v19 != 43 )
        v32 = v19 == 45;
      if ( v32 )
        v19 = sub_558B4(a1, a2);
      if ( (unsigned int)(v19 - 48) <= 9 )
      {
        do
          v19 = sub_558B4(a1, a2);
        while ( (unsigned int)(v19 - 48) <= 9 );
LABEL_79:
        sub_55868((_DWORD *)a1, v19);
        if ( sub_56BA0((int)v2, &v49) )
        {
          sub_553EC(a2, (_DWORD *)a1, "real number overflow");
          return *(_DWORD *)(a1 + 52);
        }
        else
        {
          v31 = v49;
          v7 = 258;
          *(_DWORD *)(a1 + 52) = 258;
          *(double *)(a1 + 56) = v31;
        }
        return v7;
      }
LABEL_97:
      sub_55868((_DWORD *)a1, v19);
      return *(_DWORD *)(a1 + 52);
    }
    if ( (v7 & 0xFFFFFFDF) - 65 <= 0x19 )
    {
      do
        v17 = sub_558B4(a1, a2);
      while ( (v17 & 0xFFFFFFDF) - 65 <= 0x19 );
      sub_55868((_DWORD *)a1, v17);
      v18 = (const char *)sub_56A4C((int)v2);
      if ( !strcmp(v18, "true") )
      {
        v7 = 259;
        *(_DWORD *)(a1 + 52) = 259;
        return v7;
      }
      if ( !strcmp(v18, "false") )
      {
        v7 = 260;
        *(_DWORD *)(a1 + 52) = 260;
        return v7;
      }
      if ( !strcmp(v18, "null") )
      {
        v7 = 261;
        *(_DWORD *)(a1 + 52) = 261;
        return v7;
      }
    }
    else
    {
      for ( i = *(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8); i; i = *(_BYTE *)(a1 + v15 + 8) )
      {
        DataWriter::WriteByte(v2, i);
        v14 = *(_DWORD *)(a1 + 36);
        v15 = *(_DWORD *)(a1 + 16) + 1;
        *(_DWORD *)(a1 + 16) = v15;
        *(_DWORD *)(a1 + 36) = v14 + 1;
      }
    }
    goto LABEL_33;
  }
  v24 = a1;
  v25 = a2;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 52) = -1;
LABEL_58:
  v26 = sub_558B4(v24, v25);
LABEL_59:
  while ( v26 != 34 )
  {
    if ( v26 == -2 )
      goto LABEL_104;
    if ( v26 == -1 )
    {
      sub_553EC(a2, (_DWORD *)a1, "premature end of input");
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v24 = a1;
    if ( v26 <= 0x1F )
    {
      sub_55868((_DWORD *)a1, v26);
      if ( v26 == 10 )
        sub_553EC(a2, (_DWORD *)a1, "unexpected newline");
      else
        sub_553EC(a2, (_DWORD *)a1, "control character 0x%x", v26);
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v25 = a2;
    if ( v26 != 92 )
      goto LABEL_58;
    v27 = sub_558B4(a1, a2);
    if ( v27 == 117 )
    {
      v33 = 4;
      v26 = sub_558B4(a1, a2);
      while ( 1 )
      {
        v34 = v26 - 65 > 5;
        if ( v26 - 65 > 5 )
          v34 = v26 - 48 > 9;
        if ( v34 && v26 - 97 > 5 )
          break;
        --v33;
        v26 = sub_558B4(a1, a2);
        if ( !v33 )
          goto LABEL_59;
      }
LABEL_149:
      sub_553EC(a2, (_DWORD *)a1, "invalid escape");
      v35 = *(_BYTE **)(a1 + 56);
      goto LABEL_102;
    }
    v28 = v27 == 34;
    if ( v27 != 34 )
      v28 = v27 == 92;
    if ( !v28 )
    {
      v29 = v27 == 47;
      if ( v27 != 47 )
        v29 = v27 == 98;
      if ( !v29 && (v27 & 0xFFFFFFF7) != 0x66 )
      {
        v30 = v27 == 114;
        if ( v27 != 114 )
          v30 = v27 == 116;
        if ( !v30 )
          goto LABEL_149;
      }
    }
    v26 = sub_558B4(a1, a2);
  }
  v35 = sub_56924(*(_DWORD *)(a1 + 44) + 1);
  v36 = v35;
  *(_DWORD *)(a1 + 56) = v35;
  if ( !v35 )
    goto LABEL_102;
  v37 = (unsigned __int8 *)(sub_56A4C((int)v2) + 1);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v38 = *v37;
        if ( v38 == 34 )
        {
          v7 = 256;
          *v36 = 0;
          *(_DWORD *)(a1 + 52) = 256;
          return v7;
        }
        if ( v38 == 92 )
          break;
        *v36++ = v38;
        ++v37;
      }
      v39 = v37[1];
      if ( v39 == 117 )
        break;
      if ( v39 == 102 )
      {
        *v36 = 12;
        goto LABEL_122;
      }
      if ( v39 > 0x66 )
      {
        switch ( v39 )
        {
          case 'r':
            *v36 = 13;
            break;
          case 't':
            *v36 = 9;
            break;
          case 'n':
            *v36 = 10;
            break;
          default:
            goto LABEL_117;
        }
      }
      else
      {
        if ( v39 == 92 )
          goto LABEL_135;
        if ( v39 <= 0x5C )
        {
          if ( v39 != 34 && v39 != 47 )
LABEL_117:
            _assert_fail(word_60FDC, "load.c", 0x1BCu, "lex_scan_string");
LABEL_135:
          *v36 = v39;
          goto LABEL_122;
        }
        if ( v39 != 98 )
          goto LABEL_117;
        *v36 = 8;
      }
LABEL_122:
      ++v36;
      v37 += 2;
    }
    v40 = sub_55584(v37 + 1);
    v41 = v40;
    if ( (unsigned int)(v40 - 55296) > 0x3FF )
      break;
    if ( v37[6] != 92 || v37[7] != 117 )
    {
LABEL_103:
      sub_553EC(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X'", v40);
      goto LABEL_104;
    }
    v44 = v40 - 55296;
    v45 = v40;
    v42 = sub_55584(v37 + 7);
    v37 += 12;
    if ( (unsigned int)(v42 - 56320) > 0x3FF )
    {
      sub_553EC(a2, (_DWORD *)a1, "invalid Unicode '\\u%04X\\u%04X'", v45, v42);
      goto LABEL_104;
    }
    v41 = v42 - 56320 + (v44 << 10) + 0x10000;
LABEL_131:
    if ( sub_56D94(v41, src, &n) )
      _assert_fail(word_60FDC, "load.c", 0x1AEu, "lex_scan_string");
    memcpy(v36, src, n);
    v36 += n;
  }
  if ( (unsigned int)(v40 - 56320) <= 0x3FF )
    goto LABEL_103;
  if ( v40 )
  {
    v37 += 6;
    goto LABEL_131;
  }
  sub_553EC(a2, (_DWORD *)a1, "\\u0000 is not allowed");
LABEL_104:
  v35 = *(_BYTE **)(a1 + 56);
LABEL_102:
  sub_5694C(v35);
  return *(_DWORD *)(a1 + 52);
}
// 558E4: too many cbuild loops

//----- (000560B8) --------------------------------------------------------
int *__fastcall sub_560B8(double a1, int a2)
{
  int v2; // r4
  int v3; // r3
  int v4; // r8
  int *v6; // r7
  int v8; // r3
  void *v9; // r10
  int v10; // r0
  int *v11; // r6
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r3
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int *v19; // r0
  int v20; // r3
  int v21; // r3
  void **v22; // r0
  double v23; // r0
  int v24; // r3
  int v25; // r3
  double v26; // [sp+0h] [bp-Ch] BYREF

  v2 = LODWORD(a1);
  v3 = *(_DWORD *)(LODWORD(a1) + 52);
  LODWORD(a1) = 257;
  v4 = HIDWORD(a1);
  if ( v3 != 257 )
  {
    if ( v3 > 257 )
    {
      if ( v3 == 259 )
        return (int *)sub_57778();
      if ( v3 < 259 )
        return (int *)sub_57654(a1);
      if ( v3 == 260 )
        return (int *)sub_57784();
      if ( v3 == 261 )
        return (int *)sub_57790();
LABEL_7:
      v6 = 0;
      sub_553EC(a2, (_DWORD *)v2, "unexpected token");
      return v6;
    }
    if ( v3 == 91 )
    {
      v6 = sub_57338();
      if ( v6 )
      {
        sub_558E4(v2, a2);
        v16 = *(_DWORD *)(v2 + 52);
        if ( v16 == 93 )
          return v6;
        if ( v16 )
        {
          while ( 1 )
          {
            v19 = (int *)sub_560B8(v2, v4, a2);
            v11 = v19;
            if ( !v19 )
              break;
            if ( v19[1] != -1 )
              ++v19[1];
            if ( sub_57AA0(v6, v19) )
            {
              v24 = v11[1];
              if ( v24 != -1 )
              {
LABEL_60:
                v25 = v24 - 1;
                v11[1] = v25;
                if ( !v25 )
                  sub_5779C((void **)v11);
              }
              goto LABEL_49;
            }
            v17 = v11[1];
            if ( v17 != -1 )
            {
              v11[1] = v17 - 1;
              if ( v17 == 1 )
                sub_5779C((void **)v11);
            }
            sub_558E4(v2, a2);
            v18 = *(_DWORD *)(v2 + 52);
            if ( v18 != 44 )
            {
              if ( v18 == 93 )
                return v6;
              goto LABEL_63;
            }
            sub_558E4(v2, a2);
            if ( !*(_DWORD *)(v2 + 52) )
              goto LABEL_63;
          }
        }
        else
        {
LABEL_63:
          sub_553EC(a2, (_DWORD *)v2, "']' expected");
        }
        goto LABEL_49;
      }
    }
    else
    {
      if ( v3 <= 91 )
      {
        if ( v3 == -1 )
        {
          v6 = 0;
          sub_553EC(a2, (_DWORD *)v2, "invalid token");
          return v6;
        }
        goto LABEL_7;
      }
      if ( v3 != 123 )
      {
        if ( v3 == 256 )
          return sub_574A4(*(const char **)(v2 + 56));
        goto LABEL_7;
      }
      v6 = sub_57160();
      if ( v6 )
      {
        sub_558E4(v2, a2);
        v8 = *(_DWORD *)(v2 + 52);
        if ( v8 == 125 )
          return v6;
        if ( v8 != 256 )
        {
LABEL_64:
          sub_553EC(a2, (_DWORD *)v2, "string or '}' expected");
          goto LABEL_49;
        }
        v9 = *(void **)(v2 + 56);
        *(_DWORD *)(v2 + 56) = 0;
        if ( v9 )
        {
          while ( 1 )
          {
            if ( (v4 & 1) != 0 && sub_571D8(v6, (char *)v9) )
            {
              sub_5694C(v9);
              sub_553EC(a2, (_DWORD *)v2, "duplicate object key");
              goto LABEL_49;
            }
            sub_558E4(v2, a2);
            if ( *(_DWORD *)(v2 + 52) != 58 )
            {
              sub_5694C(v9);
              sub_553EC(a2, (_DWORD *)v2, "':' expected");
              goto LABEL_49;
            }
            sub_558E4(v2, a2);
            v10 = sub_560B8(v2, v4, a2);
            v11 = (int *)v10;
            if ( !v10 )
            {
              sub_5694C(v9);
              goto LABEL_49;
            }
            v12 = *(_DWORD *)(v10 + 4);
            if ( v12 != -1 )
              *(_DWORD *)(v10 + 4) = v12 + 1;
            if ( sub_57BD8(v6, (char *)v9, v10) )
            {
              sub_5694C(v9);
              v24 = v11[1];
              if ( v24 != -1 )
                goto LABEL_60;
              goto LABEL_49;
            }
            v13 = v11[1];
            if ( v13 != -1 )
            {
              v14 = v13 - 1;
              v11[1] = v14;
              if ( !v14 )
                sub_5779C((void **)v11);
            }
            sub_5694C(v9);
            sub_558E4(v2, a2);
            v15 = *(_DWORD *)(v2 + 52);
            if ( v15 != 44 )
              break;
            sub_558E4(v2, a2);
            if ( *(_DWORD *)(v2 + 52) != 256 )
              goto LABEL_64;
            v9 = *(void **)(v2 + 56);
            *(_DWORD *)(v2 + 56) = 0;
            if ( !v9 )
              return 0;
          }
          if ( v15 == 125 )
            return v6;
          sub_553EC(a2, (_DWORD *)v2, "'}' expected");
LABEL_49:
          v20 = v6[1];
          if ( v20 != -1 )
          {
            v21 = v20 - 1;
            v6[1] = v21;
            if ( !v21 )
            {
              v22 = (void **)v6;
              v6 = 0;
              sub_5779C(v22);
              return v6;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( (BYTE4(a1) & 8) == 0 )
    return (int *)sub_575D4(*(_QWORD *)(v2 + 56));
  LODWORD(v23) = sub_56BA0(v2 + 40, &v26);
  if ( !LODWORD(v23) )
    return (int *)sub_57654(v23);
  v6 = 0;
  sub_553EC(a2, (_DWORD *)v2, "real number overflow");
  return v6;
}
// 560B8: too many cbuild loops
// 563DC: variable 'v23' is possibly undefined

//----- (0005650C) --------------------------------------------------------
int *__fastcall sub_5650C(_DWORD *a1, unsigned int a2, int a3)
{
  int *v6; // r7
  int v8; // r3
  int v9; // r3
  void **v10; // r0

  sub_558E4((int)a1, a3);
  v6 = (int *)(a2 & 4);
  if ( (a2 & 4) == 0 && (a1[13] & 0xFFFFFFDF) != 0x5B )
  {
    sub_553EC(a3, a1, "'[' or '{' expected");
    return v6;
  }
  v6 = sub_560B8(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), a3);
  if ( !v6 )
    return 0;
  if ( (a2 & 2) == 0 )
  {
    sub_558E4((int)a1, a3);
    if ( a1[13] )
    {
      sub_553EC(a3, a1, "end of file expected");
      v8 = v6[1];
      if ( v8 != -1 )
      {
        v9 = v8 - 1;
        v6[1] = v9;
        if ( !v9 )
        {
          v10 = (void **)v6;
          v6 = 0;
          sub_5779C(v10);
          return v6;
        }
      }
      return 0;
    }
  }
  if ( a3 )
    *(_DWORD *)(a3 + 8) = a1[9];
  return v6;
}

//----- (000565E8) --------------------------------------------------------
int *__fastcall sub_565E8(int *a1, unsigned int a2, char *a3)
{
  _DWORD v7[2]; // [sp+0h] [bp-48h] BYREF
  _DWORD v8[16]; // [sp+8h] [bp-40h] BYREF

  sub_583CC(a3, "<string>");
  if ( a1 )
  {
    v7[0] = a1;
    a1 = 0;
    v7[1] = 0;
    if ( !sub_5550C((int)v8, (int)sub_5534C, (int)v7) )
    {
      a1 = sub_5650C(v8, a2, (int)a3);
      sub_55558((int)v8);
    }
  }
  else
  {
    sub_553EC((int)a3, 0, "wrong arguments");
  }
  return a1;
}

//----- (0005667C) --------------------------------------------------------
int *__fastcall sub_5667C(int *a1, int a2, unsigned int a3, char *a4)
{
  _DWORD v9[3]; // [sp+4h] [bp-50h] BYREF
  _DWORD v10[17]; // [sp+10h] [bp-44h] BYREF

  sub_583CC(a4, "<buffer>");
  if ( a1 )
  {
    v9[0] = a1;
    v9[1] = a2;
    a1 = 0;
    v9[2] = 0;
    if ( !sub_5550C((int)v10, (int)sub_5536C, (int)v9) )
    {
      a1 = sub_5650C(v10, a3, (int)a4);
      sub_55558((int)v10);
    }
  }
  else
  {
    sub_553EC((int)a4, 0, "wrong arguments");
  }
  return a1;
}

//----- (00056718) --------------------------------------------------------
int *__fastcall sub_56718(int *a1, unsigned int a2, char *a3)
{
  int *v5; // r4
  char *v6; // r1
  _DWORD v8[16]; // [sp+0h] [bp-40h] BYREF

  v5 = a1;
  if ( a1 == (int *)stdin )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  sub_583CC(a3, v6);
  if ( v5 )
  {
    if ( sub_5550C((int)v8, (int)fgetc, (int)v5) )
    {
      return 0;
    }
    else
    {
      v5 = sub_5650C(v8, a2, (int)a3);
      sub_55558((int)v8);
    }
  }
  else
  {
    sub_553EC((int)a3, 0, "wrong arguments");
  }
  return v5;
}
// 73A00: using guessed type int stdin;

//----- (000567C4) --------------------------------------------------------
int *__fastcall sub_567C4(char *a1, unsigned int a2, char *a3)
{
  FILE *v6; // r0
  FILE *v7; // r7
  int *v8; // r6
  int *v10; // r0
  char *v11; // r0

  sub_583CC(a3, a1);
  if ( a1 )
  {
    v6 = fopen(a1, "rb");
    v7 = v6;
    if ( v6 )
    {
      v8 = sub_56718(&v6->_flags, a2, a3);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      sub_553EC((int)a3, 0, "unable to open %s: %s", a1, v11);
    }
  }
  else
  {
    v8 = 0;
    sub_553EC((int)a3, 0, "wrong arguments");
  }
  return v8;
}

//----- (00056924) --------------------------------------------------------
void *__fastcall sub_56924(size_t a1)
{
  if ( a1 )
    return off_739D8(a1);
  else
    return 0;
}
// 739D8: using guessed type void *(*off_739D8)(size_t size);

//----- (0005694C) --------------------------------------------------------
void __fastcall sub_5694C(void *a1)
{
  if ( a1 )
    off_739DC(a1);
}
// 739DC: using guessed type void (*off_739DC)(void *ptr);

//----- (0005696C) --------------------------------------------------------
void *__fastcall sub_5696C(const char *a1)
{
  size_t v2; // r0
  size_t v3; // r4
  void *v5; // r0
  void *v6; // r5

  v2 = strlen(a1);
  if ( v2 == -1 )
    return 0;
  v3 = v2 + 1;
  v5 = off_739D8(v2 + 1);
  v6 = v5;
  if ( !v5 )
    return 0;
  memcpy(v5, a1, v3);
  return v6;
}
// 739D8: using guessed type void *(*off_739D8)(size_t size);

//----- (000569C4) --------------------------------------------------------
void *(*__fastcall sub_569C4(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  off_739D8 = result;
  off_739DC = a2;
  return result;
}
// 739D8: using guessed type void *(*off_739D8)(size_t size);
// 739DC: using guessed type void (*off_739DC)(void *ptr);

//----- (000569D4) --------------------------------------------------------
int __fastcall sub_569D4(_DWORD *a1)
{
  _BYTE *v2; // r0

  a1[2] = 16;
  a1[1] = 0;
  v2 = sub_56924(0x10u);
  *a1 = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (00056A0C) --------------------------------------------------------
void __fastcall sub_56A0C(int a1)
{
  void *v2; // r0

  v2 = *(void **)a1;
  if ( v2 )
    sub_5694C(v2);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
}

//----- (00056A38) --------------------------------------------------------
int __fastcall sub_56A38(int result)
{
  _BYTE *v1; // r2

  v1 = *(_BYTE **)result;
  *(_DWORD *)(result + 4) = 0;
  *v1 = 0;
  return result;
}

//----- (00056A4C) --------------------------------------------------------
int __fastcall sub_56A4C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00056A54) --------------------------------------------------------
int __fastcall sub_56A54(int *a1)
{
  int result; // r0

  result = *a1;
  *a1 = 0;
  return result;
}

//----- (00056A68) --------------------------------------------------------
int __fastcall sub_56A68(const void **a1, void *src, size_t n)
{
  size_t v4; // r3
  int v6; // r0
  char *v8; // r6
  unsigned int v9; // r0
  size_t v10; // r8
  char *v11; // r0
  char *v12; // r2
  size_t v13; // r5

  v4 = (size_t)a1[1];
  v6 = (int)a1[2];
  if ( v6 - v4 > n )
  {
    v8 = (char *)*a1;
LABEL_10:
    memcpy(&v8[v4], src, n);
    v12 = (char *)*a1;
    v13 = (size_t)a1[1] + n;
    a1[1] = (const void *)v13;
    v12[v13] = 0;
    return 0;
  }
  if ( v6 >= 0 && n != -1 && v4 <= -2 - n )
  {
    v9 = 2 * v6;
    v10 = v4 + 1 + n;
    if ( v10 < v9 )
      v10 = v9;
    v11 = (char *)sub_56924(v10);
    v8 = v11;
    if ( v11 )
    {
      memcpy(v11, *a1, (size_t)a1[1]);
      sub_5694C((void *)*a1);
      v4 = (size_t)a1[1];
      *a1 = v8;
      a1[2] = (const void *)v10;
      goto LABEL_10;
    }
  }
  return -1;
}

//----- (00056B2C) --------------------------------------------------------
int __fastcall DataWriter::WriteByte(const void **this, unsigned __int8 a2)
{
  unsigned __int8 v3; // [sp+7h] [bp-5h] BYREF

  v3 = a2;
  return sub_56A68(this, &v3, 1u);
}

//----- (00056B50) --------------------------------------------------------
int __fastcall luaL_addstring(const void **a1, char *s)
{
  size_t v4; // r0

  v4 = strlen(s);
  return sub_56A68(a1, s, v4);
}

//----- (00056B78) --------------------------------------------------------
int __fastcall sub_56B78(int *a1, int a2, int a3)
{
  int v3; // r3
  bool v4; // zf
  int result; // r0

  v3 = a1[1];
  v4 = v3 == 0;
  if ( v3 )
  {
    a3 = v3 - 1;
    a1[1] = v3 - 1;
    a2 = *a1;
    LOBYTE(v3) = 0;
    result = *(unsigned __int8 *)(*a1 + a3);
  }
  else
  {
    result = 0;
  }
  if ( !v4 )
    *(_BYTE *)(a2 + a3) = v3;
  return result;
}

//----- (00056BA0) --------------------------------------------------------
int __fastcall sub_56BA0(int a1, double *a2)
{
  double v2; // d0
  struct lconv *v5; // r0
  const char *v6; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *endptr; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  v6 = *(const char **)a1;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(*(const char **)a1, 46);
    if ( v8 )
    {
      *v8 = v7;
      v6 = *(const char **)a1;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(v6, &endptr);
  if ( endptr != (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x46u, "jsonp_strtod");
  if ( *v9 == 34 && v2 != 0.0 )
    return -1;
  result = 0;
  *a2 = v2;
  return result;
}
// 56C20: variable 'v2' is possibly undefined

//----- (00056C60) --------------------------------------------------------
int __fastcall sub_56C60(char *a1, size_t a2)
{
  double v2; // d0
  int v5; // r0
  int v6; // r4
  int v7; // r6
  int v8; // r1
  char *v9; // r0
  char *v10; // r3
  char *v11; // r4
  char *v12; // r7
  char *v13; // r3

  v5 = snprintf(a1, a2, "%.17g", v2);
  v6 = v5;
  if ( v5 >= 0 )
  {
    v7 = v5;
    if ( a2 > v5 )
    {
      v8 = *(unsigned __int8 *)localeconv()->decimal_point;
      if ( v8 != 46 )
      {
        v9 = strchr(a1, v8);
        if ( v9 )
          *v9 = 46;
      }
      if ( strchr(a1, 46) )
      {
LABEL_7:
        v10 = strchr(a1, 101);
        if ( !v10 )
          return v7;
LABEL_8:
        v11 = v10 + 2;
        if ( v10[1] == 45 )
          v12 = v10 + 2;
        else
          v12 = v10 + 1;
        if ( v10[2] == 48 )
        {
          v13 = v10 + 3;
          do
            v11 = v13++;
          while ( *v11 == 48 );
        }
        if ( v11 != v12 )
        {
          memmove(v12, v11, a1 - v11 + v7);
          v7 += v12 - v11;
        }
        return v7;
      }
      v10 = strchr(a1, 101);
      if ( v10 )
        goto LABEL_8;
      if ( a2 > v6 + 3 )
      {
        v7 = v6 + 2;
        a1[v6] = 46;
        a1[v6 + 1] = 48;
        a1[v6 + 2] = 0;
        goto LABEL_7;
      }
    }
  }
  return -1;
}
// 56C78: variable 'v2' is possibly undefined

//----- (00056D94) --------------------------------------------------------
int __fastcall sub_56D94(int a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // r4
  int v4; // r12
  int v5; // r3

  if ( a1 >= 0 )
  {
    if ( a1 <= 127 )
    {
      *a2 = a1;
      *a3 = 1;
      return 0;
    }
    if ( a1 < 2048 )
    {
      *a2 = (((unsigned int)a1 >> 6) & 0x1F) - 64;
      a2[1] = (a1 & 0x3F) + 0x80;
      *a3 = 2;
      return 0;
    }
    if ( a1 < 0x10000 )
    {
      a2[1] = (((unsigned int)a1 >> 6) & 0x3F) + 0x80;
      a2[2] = (a1 & 0x3F) + 0x80;
      *a2 = ((unsigned __int16)a1 >> 12) - 32;
      *a3 = 3;
      return 0;
    }
    if ( a1 < 1114112 )
    {
      v3 = ((unsigned int)a1 >> 18) & 7;
      v4 = ((unsigned int)a1 >> 12) & 0x3F;
      v5 = ((unsigned int)a1 >> 6) & 0x3F;
      a2[3] = (a1 & 0x3F) + 0x80;
      a2[2] = v5 + 0x80;
      *a2 = v3 - 16;
      a2[1] = v4 + 0x80;
      *a3 = 4;
      return 0;
    }
  }
  return -1;
}

//----- (00056E7C) --------------------------------------------------------
int __fastcall sub_56E7C(int a1)
{
  if ( (a1 & 0x80) == 0 )
    return 1;
  if ( (a1 ^ 0x80u) <= 0x3F || (unsigned __int8)(a1 + 64) <= 1u )
    return 0;
  if ( (unsigned __int8)(a1 + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(a1 + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(a1 + 16) > 4u )
    return 0;
  return 4;
}

//----- (00056EF8) --------------------------------------------------------
int __fastcall sub_56EF8(char *a1, int a2, int *a3)
{
  char v3; // r4
  int v4; // r4
  int result; // r0
  int v6; // r12
  int v7; // r3
  bool v8; // zf
  bool v9; // zf
  _BOOL4 v10; // r0

  v3 = *a1;
  switch ( a2 )
  {
    case 2:
      v4 = v3 & 0x1F;
      break;
    case 3:
      v4 = v3 & 0xF;
      break;
    case 4:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = (unsigned __int8)a1[1];
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = 1;
  while ( 1 )
  {
    ++v7;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( a2 <= v7 )
      break;
    v6 = (unsigned __int8)a1[v7];
    if ( (v6 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) <= 0x7FF )
    return 0;
  v8 = v4 == 127;
  if ( v4 <= 127 )
    v8 = a2 == 2;
  if ( v8 )
    return 0;
  result = 0;
  v9 = v4 == 2047;
  if ( v4 <= 2047 )
    v9 = a2 == 3;
  if ( !v9 )
  {
    v10 = v4 < 0x10000;
    if ( a2 != 4 )
      v10 = 0;
    if ( !v10 )
    {
      result = 1;
      if ( a3 )
        *a3 = v4;
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00056FD0) --------------------------------------------------------
char *__fastcall sub_56FD0(char *a1, _DWORD *a2)
{
  char *v2; // r4
  int v3; // r5
  int v5; // r0
  int v6; // r6
  int v8; // [sp+4h] [bp-8h] BYREF

  v2 = a1;
  v3 = (unsigned __int8)*a1;
  if ( !*a1 )
    return v2;
  v5 = sub_56E7C((unsigned __int8)*a1);
  v6 = v5;
  if ( v5 <= 0 )
    return 0;
  if ( v5 == 1 )
  {
    v8 = v3;
    goto LABEL_6;
  }
  if ( !sub_56EF8(v2, v5, &v8) )
    return 0;
LABEL_6:
  v2 += v6;
  if ( a2 )
    *a2 = v8;
  return v2;
}

//----- (00057044) --------------------------------------------------------
int __fastcall sub_57044(const char *a1, signed int a2)
{
  signed int v2; // r8
  int v4; // r4
  int v5; // r5
  char *v6; // r0

  v2 = a2;
  if ( a2 == -1 )
    v2 = strlen(a1);
  if ( v2 <= 0 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_56E7C((unsigned __int8)a1[v4]);
    v6 = (char *)&a1[v4];
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( v2 < v4 + v5 )
        break;
      v4 += v5 - 1;
      if ( !sub_56EF8(v6, v5, 0) )
        break;
    }
    if ( v2 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (000570D8) --------------------------------------------------------
void *__fastcall sub_570D8(_DWORD *a1, int a2, int a3)
{
  unsigned int v5; // r3
  void *v6; // r5
  unsigned int v8; // r1
  unsigned int v9; // r3
  unsigned int v10; // r7
  void *v11; // r0

  v5 = a1[2];
  if ( a2 + a1[3] <= v5 )
    return (void *)a1[4];
  v8 = a2 + v5;
  v9 = 2 * v5;
  if ( v8 < v9 )
    v10 = v9;
  else
    v10 = v8;
  v6 = (void *)a1[4];
  v11 = sub_56924(4 * v10);
  if ( !v11 )
    return 0;
  a1[2] = v10;
  a1[4] = v11;
  if ( a3 )
  {
    memcpy(v11, v6, 4 * a1[3]);
    sub_5694C(v6);
    return (void *)a1[4];
  }
  return v6;
}

//----- (00057160) --------------------------------------------------------
_DWORD *sub_57160()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4

  v0 = sub_56924(0x24u);
  v1 = v0;
  if ( !v0 )
    return 0;
  v0[1] = 1;
  *v0 = 0;
  if ( sub_54DAC(v0 + 2) )
  {
    sub_5694C(v1);
    return 0;
  }
  else
  {
    v1[7] = 0;
    v1[8] = 0;
    return v1;
  }
}

//----- (000571BC) --------------------------------------------------------
_DWORD *__fastcall sub_571BC(_DWORD *result)
{
  if ( result )
  {
    if ( *result )
      return 0;
    else
      return (_DWORD *)result[2];
  }
  return result;
}

//----- (000571D8) --------------------------------------------------------
int __fastcall sub_571D8(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return 0;
  else
    return sub_5504C((int)(a1 + 2), a2);
}

//----- (000571FC) --------------------------------------------------------
int __fastcall sub_571FC(_DWORD *a1, char *a2)
{
  if ( !a1 || *a1 )
    return -1;
  else
    return sub_550C4(a1 + 2, a2);
}

//----- (00057220) --------------------------------------------------------
int __fastcall sub_57220(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  sub_551E0(a1 + 2);
  a1[7] = 0;
  return 0;
}

//----- (00057254) --------------------------------------------------------
_DWORD *__fastcall sub_57254(_DWORD *a1)
{
  _DWORD *v1; // r3
  _DWORD *v2; // r0
  _DWORD *result; // r0

  if ( !a1 || *a1 )
    return 0;
  v2 = a1 + 2;
  v1 = v2 + 3;
  result = (_DWORD *)v2[4];
  if ( result == v1 )
    return 0;
  return result;
}

//----- (00057278) --------------------------------------------------------
int __fastcall sub_57278(_DWORD *a1, char *a2)
{
  bool v2; // zf

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  if ( v2 || *a1 )
    return 0;
  else
    return sub_5525C((int)(a1 + 2), a2);
}

//----- (000572A0) --------------------------------------------------------
int __fastcall sub_572A0(_DWORD *a1, int a2)
{
  if ( !a1 || *a1 || !a2 )
    return 0;
  if ( *(_DWORD **)(a2 + 4) == a1 + 5 )
    return 0;
  return *(_DWORD *)(a2 + 4);
}

//----- (000572CC) --------------------------------------------------------
int __fastcall sub_572CC(int result)
{
  if ( result )
    result += 16;
  return result;
}

//----- (000572D8) --------------------------------------------------------
int __fastcall sub_572D8(int result)
{
  if ( result )
    return *(_DWORD *)(result + 8);
  return result;
}

//----- (000572E4) --------------------------------------------------------
int __fastcall sub_572E4(_DWORD *a1, int a2, int a3)
{
  bool v3; // zf

  if ( !a1 || *a1 )
    return -1;
  v3 = a2 == 0;
  if ( a2 )
    v3 = a3 == 0;
  if ( v3 )
    return -1;
  sub_55304(a2, a3);
  return 0;
}

//----- (0005732C) --------------------------------------------------------
int __fastcall sub_5732C(int result)
{
  if ( result )
    result -= 16;
  return result;
}

//----- (00057338) --------------------------------------------------------
_DWORD *sub_57338()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r5

  v0 = sub_56924(0x18u);
  v1 = v0;
  if ( !v0 )
    return 0;
  *v0 = 1;
  v0[1] = 1;
  v0[3] = 0;
  v0[2] = 8;
  v2 = sub_56924(0x20u);
  v1[4] = v2;
  if ( v2 )
  {
    v1[5] = 0;
    return v1;
  }
  else
  {
    sub_5694C(v1);
    return 0;
  }
}

//----- (000573A4) --------------------------------------------------------
_DWORD *__fastcall sub_573A4(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 1 )
      return (_DWORD *)result[3];
    else
      return 0;
  }
  return result;
}

//----- (000573C0) --------------------------------------------------------
_DWORD *__fastcall sub_573C0(_DWORD *result, unsigned int a2)
{
  if ( result )
  {
    if ( *result == 1 && result[3] > a2 )
      return *(_DWORD **)(result[4] + 4 * a2);
    else
      return 0;
  }
  return result;
}

//----- (000573F4) --------------------------------------------------------
int __fastcall sub_573F4(_DWORD *a1, _DWORD *a2)
{
  size_t v4; // r2
  char *v5; // r1
  char *v6; // r0
  int v7; // r3
  int v8; // t1

  if ( !a1 || *a1 != 1 || !a2 || *a2 != 1 || !sub_570D8(a1, a2[3], 1) )
    return -1;
  v4 = a2[3];
  v5 = (char *)a2[4];
  if ( v4 )
  {
    v4 *= 4;
    v6 = (char *)a2[4];
    do
    {
      v8 = *(_DWORD *)v6;
      v6 += 4;
      v7 = v8;
      if ( v8 )
      {
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
      }
    }
    while ( v6 != &v5[v4] );
  }
  memcpy((void *)(a1[4] + 4 * a1[3]), v5, v4);
  a1[3] += a2[3];
  return 0;
}

//----- (000574A4) --------------------------------------------------------
_DWORD *__fastcall sub_574A4(const char *a1)
{
  _DWORD *v2; // r4
  void *v3; // r5
  _DWORD *result; // r0

  if ( !a1 )
    return 0;
  v2 = sub_56924(0xCu);
  if ( !v2 )
    return 0;
  *v2 = 2;
  v2[1] = 1;
  v3 = sub_5696C(a1);
  result = v2;
  v2[2] = v3;
  if ( !v3 )
  {
    sub_5694C(v2);
    return 0;
  }
  return result;
}

//----- (00057500) --------------------------------------------------------
_DWORD *__fastcall sub_57500(const char *a1)
{
  if ( a1 && sub_57044(a1, -1) )
    return sub_574A4(a1);
  else
    return 0;
}

//----- (00057530) --------------------------------------------------------
_DWORD *__fastcall sub_57530(_DWORD *result)
{
  if ( result )
  {
    if ( *result == 2 )
      return (_DWORD *)result[2];
    else
      return 0;
  }
  return result;
}

//----- (0005754C) --------------------------------------------------------
int __fastcall sub_5754C(int a1, const char *a2)
{
  void *v3; // r5

  if ( !a1 )
    return -1;
  if ( *(_DWORD *)a1 != 2 )
    return -1;
  if ( !a2 )
    return -1;
  v3 = sub_5696C(a2);
  if ( !v3 )
    return -1;
  sub_5694C(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v3;
  return 0;
}

//----- (00057598) --------------------------------------------------------
int __fastcall sub_57598(int a1, const char *a2)
{
  if ( a2 && sub_57044(a2, -1) )
    return sub_5754C(a1, a2);
  else
    return -1;
}

//----- (000575D4) --------------------------------------------------------
_QWORD *__fastcall sub_575D4(__int64 a1)
{
  _QWORD *result; // r0

  result = sub_56924(0x10u);
  if ( result )
  {
    result[1] = a1;
    *(_DWORD *)result = 3;
    *((_DWORD *)result + 1) = 1;
  }
  return result;
}

//----- (00057600) --------------------------------------------------------
__int64 __fastcall sub_57600(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}

//----- (0005762C) --------------------------------------------------------
int __fastcall sub_5762C(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}

//----- (00057654) --------------------------------------------------------
_QWORD *__fastcall sub_57654(double a1)
{
  __int64 v1; // d0
  double v2; // r0
  _QWORD *result; // r0

  LODWORD(v2) = _isnan(a1);
  if ( LODWORD(v2) )
    return 0;
  if ( _isinf(v2) )
    return 0;
  result = sub_56924(0x10u);
  if ( !result )
    return 0;
  result[1] = v1;
  *(_DWORD *)result = 4;
  *((_DWORD *)result + 1) = 1;
  return result;
}
// 57670: variable 'v2' is possibly undefined
// 57698: variable 'v1' is possibly undefined

//----- (000576B0) --------------------------------------------------------
void sub_576B0()
{
  ;
}

//----- (000576E0) --------------------------------------------------------
int __fastcall sub_576E0(double a1)
{
  __int64 v1; // d0
  int v2; // r4
  double v3; // r0
  int result; // r0

  v2 = LODWORD(a1);
  if ( !LODWORD(a1) )
    return -1;
  if ( *(_DWORD *)LODWORD(a1) != 4 )
    return -1;
  LODWORD(v3) = _isnan(a1);
  if ( LODWORD(v3) )
    return -1;
  result = _isinf(v3);
  if ( result )
    return -1;
  *(_QWORD *)(v2 + 8) = v1;
  return result;
}
// 57710: variable 'v3' is possibly undefined
// 5771C: variable 'v1' is possibly undefined

//----- (00057730) --------------------------------------------------------
int __fastcall sub_57730(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)result == 3 )
      return sub_59F1C(*(_QWORD *)(result + 8));
  }
  return result;
}

//----- (00057778) --------------------------------------------------------
void *sub_57778()
{
  return &unk_739E0;
}

//----- (00057784) --------------------------------------------------------
void *sub_57784()
{
  return &unk_739E8;
}

//----- (00057790) --------------------------------------------------------
void *sub_57790()
{
  return &unk_739F0;
}

//----- (0005779C) --------------------------------------------------------
void __fastcall sub_5779C(void **a1)
{
  void *v2; // r3
  void *v3; // r1
  _DWORD *v4; // r12
  unsigned int i; // r5
  int v6; // r0
  int v7; // r3

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
    {
      if ( v2 == (void *)1 )
      {
        v3 = a1[3];
        v4 = a1[4];
        if ( v3 )
        {
          for ( i = 0; i < (unsigned int)v3; ++i )
          {
            v6 = v4[i];
            if ( v6 )
            {
              v7 = *(_DWORD *)(v6 + 4);
              if ( v7 != -1 )
              {
                *(_DWORD *)(v6 + 4) = v7 - 1;
                if ( v7 == 1 )
                {
                  sub_5779C();
                  v4 = a1[4];
                  v3 = a1[3];
                }
              }
            }
          }
        }
        sub_5694C(v4);
        sub_5694C(a1);
      }
      else if ( v2 == (void *)2 )
      {
        sub_5694C(a1[2]);
        sub_5694C(a1);
      }
      else if ( v2 == (void *)3 || v2 == (void *)4 )
      {
        sub_5694C(a1);
      }
    }
    else
    {
      sub_54E2C((int)(a1 + 2));
      sub_5694C(a1);
    }
  }
}

//----- (00057870) --------------------------------------------------------
int __fastcall sub_57870(_DWORD *a1)
{
  unsigned int v2; // r1
  unsigned int i; // r4
  int v4; // r0
  int v5; // r3

  if ( !a1 || *a1 != 1 )
    return -1;
  v2 = a1[3];
  if ( v2 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(_DWORD *)(a1[4] + 4 * i);
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 4);
        if ( v5 != -1 )
        {
          *(_DWORD *)(v4 + 4) = v5 - 1;
          if ( v5 == 1 )
          {
            sub_5779C((void **)v4);
            v2 = a1[3];
          }
        }
      }
    }
  }
  a1[3] = 0;
  return 0;
}

//----- (000578EC) --------------------------------------------------------
int __fastcall sub_578EC(_DWORD *a1, unsigned int a2)
{
  unsigned int v4; // r3
  int v5; // r6
  int v6; // r0
  int v7; // r2
  int v8; // r2
  unsigned int v9; // r3

  if ( a1 )
  {
    if ( *a1 == 1 )
    {
      v4 = a1[3];
      if ( v4 > a2 )
      {
        v5 = 4 * a2;
        v6 = *(_DWORD *)(a1[4] + 4 * a2);
        if ( !v6 || (v7 = *(_DWORD *)(v6 + 4), v7 == -1) || (v8 = v7 - 1, (*(_DWORD *)(v6 + 4) = v8) != 0) )
        {
          v9 = v4 - 1;
          if ( a2 >= v9 )
          {
LABEL_8:
            a1[3] = v9;
            return 0;
          }
        }
        else
        {
          sub_5779C((void **)v6);
          v9 = a1[3] - 1;
          if ( a2 >= v9 )
            goto LABEL_8;
        }
        memmove((void *)(a1[4] + v5), (const void *)(a1[4] + 4 * (a2 + 1)), 4 * (v9 - a2));
        v9 = a1[3] - 1;
        goto LABEL_8;
      }
    }
  }
  return -1;
}

//----- (000579A0) --------------------------------------------------------
int __fastcall sub_579A0(int a1, unsigned int a2, int a3)
{
  char *v6; // r0
  char *v7; // r6
  char *v8; // r1
  int v10; // r3
  int v11; // r3
  int v12; // r3

  if ( !a3 )
    return -1;
  if ( !a1
    || *(_DWORD *)a1 != 1
    || a1 == a3
    || *(_DWORD *)(a1 + 12) < a2
    || (v6 = (char *)sub_570D8((_DWORD *)a1, 1, 0), (v7 = v6) == 0) )
  {
    v11 = *(_DWORD *)(a3 + 4);
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      *(_DWORD *)(a3 + 4) = v12;
      if ( !v12 )
        sub_5779C((void **)a3);
    }
    return -1;
  }
  v8 = *(char **)(a1 + 16);
  if ( v8 == v6 )
  {
    memmove(&v8[4 * a2 + 4], &v8[4 * a2], 4 * (*(_DWORD *)(a1 + 12) - a2));
  }
  else
  {
    memcpy(*(void **)(a1 + 16), v6, 4 * a2);
    memcpy((void *)(*(_DWORD *)(a1 + 16) + 4 * (a2 + 1)), &v7[4 * a2], 4 * (*(_DWORD *)(a1 + 12) - a2));
    sub_5694C(v7);
  }
  v10 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * a2) = a3;
  *(_DWORD *)(a1 + 12) = v10 + 1;
  return 0;
}

//----- (00057AA0) --------------------------------------------------------
int __fastcall sub_57AA0(int *a1, int *a2)
{
  int v4; // r3
  int v6; // r3
  int v7; // r3

  if ( a2 )
  {
    if ( a1 && *a1 == 1 && a1 != a2 && sub_570D8(a1, 1, *a1) )
    {
      v4 = a1[3];
      *(_DWORD *)(a1[4] + 4 * v4) = a2;
      a1[3] = v4 + 1;
      return 0;
    }
    v6 = a2[1];
    if ( v6 != -1 )
    {
      v7 = v6 - 1;
      a2[1] = v7;
      if ( !v7 )
        sub_5779C((void **)a2);
    }
  }
  return -1;
}

//----- (00057B24) --------------------------------------------------------
int __fastcall sub_57B24(_DWORD *a1, unsigned int a2, int a3)
{
  int v5; // r6
  int *v6; // r2
  int v7; // r0
  int v8; // r3
  int v9; // r3
  int v11; // r3
  int v12; // r3

  if ( !a3 )
    return -1;
  if ( !a1 || *a1 != 1 || a1 == (_DWORD *)a3 || a1[3] <= a2 )
  {
    v11 = *(_DWORD *)(a3 + 4);
    if ( v11 != -1 )
    {
      v12 = v11 - 1;
      *(_DWORD *)(a3 + 4) = v12;
      if ( !v12 )
        sub_5779C((void **)a3);
    }
    return -1;
  }
  v5 = 4 * a2;
  v6 = (int *)(a1[4] + 4 * a2);
  v7 = *v6;
  if ( *v6 )
  {
    v8 = *(_DWORD *)(v7 + 4);
    if ( v8 != -1 )
    {
      v9 = v8 - 1;
      *(_DWORD *)(v7 + 4) = v9;
      if ( !v9 )
      {
        sub_5779C((void **)v7);
        v6 = (int *)(a1[4] + v5);
      }
    }
  }
  *v6 = a3;
  return 0;
}

//----- (00057BD8) --------------------------------------------------------
int __fastcall sub_57BD8(_DWORD *a1, char *a2, int a3)
{
  bool v4; // zf
  int v5; // r2
  int result; // r0
  int v7; // r3
  int v8; // r3

  if ( !a3 )
    return -1;
  v4 = a1 == 0;
  if ( a1 )
    v4 = a2 == 0;
  if ( v4
    || *a1
    || a1 == (_DWORD *)a3
    || (v5 = a1[7], a1[7] = v5 + 1, (result = sub_54E44((int)(a1 + 2), a2, v5, a3)) != 0) )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_5779C((void **)a3);
    }
    return -1;
  }
  return result;
}

//----- (00057C58) --------------------------------------------------------
int __fastcall sub_57C58(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r0
  int v7; // r8

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_57254(a2);
  for ( i = (char *)sub_572CC((int)v4); i; i = (char *)sub_572CC(v6) )
  {
    v7 = sub_572D8((int)(i - 16));
    if ( !v7 )
      break;
    if ( !sub_571D8(a1, i) )
    {
      if ( *(_DWORD *)(v7 + 4) != -1 )
        ++*(_DWORD *)(v7 + 4);
      sub_57BD8(a1, i, v7);
    }
    v6 = sub_572A0(a2, (int)(i - 16));
  }
  return 0;
}

//----- (00057D14) --------------------------------------------------------
int __fastcall sub_57D14(_DWORD *a1, char *a2, int a3)
{
  int v7; // r3
  int v8; // r3

  if ( a2 && sub_57044(a2, -1) )
    return sub_57BD8(a1, a2, a3);
  if ( a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      *(_DWORD *)(a3 + 4) = v8;
      if ( !v8 )
        sub_5779C((void **)a3);
    }
  }
  return -1;
}

//----- (00057D88) --------------------------------------------------------
int __fastcall sub_57D88(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r0
  int v7; // r0

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_57254(a2);
  for ( i = (char *)sub_572CC((int)v4); i; i = (char *)sub_572CC(v6) )
  {
    v7 = sub_572D8((int)(i - 16));
    if ( !v7 )
      break;
    if ( *(_DWORD *)(v7 + 4) != -1 )
      ++*(_DWORD *)(v7 + 4);
    if ( sub_57BD8(a1, i, v7) )
      return -1;
    v6 = sub_572A0(a2, (int)(i - 16));
  }
  return 0;
}

//----- (00057E34) --------------------------------------------------------
int __fastcall sub_57E34(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // r0
  char *i; // r4
  int v6; // r5
  int v7; // r0

  if ( !a1 || *a1 || !a2 || *a2 )
    return -1;
  v4 = sub_57254(a2);
  for ( i = (char *)sub_572CC((int)v4); i; i = (char *)sub_572CC(v7) )
  {
    v6 = sub_572D8((int)(i - 16));
    if ( !v6 )
      break;
    if ( sub_571D8(a1, i) )
    {
      if ( *(_DWORD *)(v6 + 4) != -1 )
        ++*(_DWORD *)(v6 + 4);
      sub_57BD8(a1, i, v6);
    }
    v7 = sub_572A0(a2, (int)(i - 16));
  }
  return 0;
}

//----- (00057EE8) --------------------------------------------------------
bool __fastcall sub_57EE8(int *a1, int *a2)
{
  bool v2; // zf
  int v3; // r2
  int v6; // r3
  _DWORD *v8; // r0
  int v9; // r7
  int v10; // r0
  int v11; // r5
  int v12; // r0
  char *v13; // r1
  int v14; // r7
  int v15; // r0
  int v16; // r7
  unsigned int v17; // r5
  int v18; // r2
  int v19; // r1
  int v20; // r0

  v2 = a1 == 0;
  if ( a1 )
    v2 = a2 == 0;
  v3 = v2;
  if ( v2 )
    return 0;
  v6 = *a1;
  if ( *a1 != *a2 )
    return v3;
  if ( a1 == a2 )
    return 1;
  switch ( v6 )
  {
    case 0:
      if ( a1[2] == a2[2] )
      {
        v8 = sub_57254(a1);
        v9 = sub_572CC((int)v8);
        if ( v9 )
        {
          while ( 1 )
          {
            v11 = v9 - 16;
            v12 = sub_572D8(v9 - 16);
            v13 = (char *)v9;
            v14 = v12;
            if ( !v12 )
              break;
            v15 = sub_571D8(a2, v13);
            if ( !sub_57EE8(v14, v15) )
              return 0;
            v10 = sub_572A0(a1, v11);
            v9 = sub_572CC(v10);
            if ( !v9 )
              return 1;
          }
        }
        return 1;
      }
      return 0;
    case 1:
      v16 = a1[3];
      if ( v16 == a2[3] )
      {
        if ( v16 )
        {
          v17 = v3;
          v18 = *a1;
          while ( 1 )
          {
            v20 = v18 == 1 && a1[3] > v17 ? *(_DWORD *)(a1[4] + 4 * v17) : 0;
            v19 = v6 == 1 && a2[3] > v17 ? *(_DWORD *)(a2[4] + 4 * v17) : 0;
            if ( !sub_57EE8(v20, v19) )
              break;
            if ( ++v17 == v16 )
              return 1;
            v18 = *a1;
            v6 = *a2;
          }
          return 0;
        }
        return 1;
      }
      return 0;
    case 2:
      return strcmp((const char *)a1[2], (const char *)a2[2]) == 0;
    case 3:
      return *((_QWORD *)a1 + 1) == *((_QWORD *)a2 + 1);
  }
  if ( v6 != 4 )
    return v3;
  return *((double *)a1 + 1) == *((double *)a2 + 1);
}

//----- (000580AC) --------------------------------------------------------
int *__fastcall sub_580AC(double a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  _DWORD *v4; // r7
  _DWORD *v5; // r0
  char *j; // r5
  int v7; // r3
  int v8; // r0
  int *v9; // r6
  unsigned int v10; // r3
  unsigned int i; // r5
  int *v12; // r1

  v1 = (_DWORD *)LODWORD(a1);
  if ( !LODWORD(a1) )
    return 0;
  v2 = *(_DWORD *)LODWORD(a1);
  if ( *(_DWORD *)LODWORD(a1) )
  {
    switch ( v2 )
    {
      case 1:
        v9 = sub_57338();
        if ( v9 )
        {
          if ( *v1 == 1 )
          {
            v10 = v1[3];
            if ( v10 )
            {
              for ( i = 0; i < v10; ++i )
              {
                v12 = 0;
                if ( v10 > i )
                {
                  v12 = *(int **)(v1[4] + 4 * i);
                  if ( v12 )
                  {
                    if ( v12[1] != -1 )
                      ++v12[1];
                  }
                }
                sub_57AA0(v9, v12);
                if ( *v1 != 1 )
                  break;
                v10 = v1[3];
              }
            }
          }
        }
        return v9;
      case 2:
        return sub_574A4(*(const char **)(LODWORD(a1) + 8));
      case 3:
        return (int *)sub_575D4(*(_QWORD *)(LODWORD(a1) + 8));
      case 4:
        return (int *)sub_57654(a1);
      default:
        if ( (unsigned int)(v2 - 5) <= 2 )
          return v1;
        return 0;
    }
  }
  else
  {
    v4 = sub_57160();
    if ( v4 )
    {
      v5 = sub_57254(v1);
      for ( j = (char *)sub_572CC((int)v5); j; j = (char *)sub_572CC(v8) )
      {
        v7 = sub_572D8((int)(j - 16));
        if ( !v7 )
          break;
        if ( *(_DWORD *)(v7 + 4) != -1 )
          ++*(_DWORD *)(v7 + 4);
        sub_57BD8(v4, j, v7);
        v8 = sub_572A0(v1, (int)(j - 16));
      }
    }
    return v4;
  }
}

//----- (00058220) --------------------------------------------------------
int *__fastcall sub_58220(double a1)
{
  _DWORD *v1; // r4
  int v2; // r3
  _DWORD *v4; // r7
  _DWORD *j; // r5
  char *v6; // r6
  int v7; // r0
  int v8; // r0
  int *v9; // r6
  unsigned int v10; // r3
  unsigned int i; // r5
  int v12; // r0
  int *v13; // r0

  v1 = (_DWORD *)LODWORD(a1);
  if ( !LODWORD(a1) )
    return v1;
  v2 = *(_DWORD *)LODWORD(a1);
  if ( *(_DWORD *)LODWORD(a1) )
  {
    switch ( v2 )
    {
      case 1:
        v9 = sub_57338();
        if ( v9 )
        {
          if ( *v1 == 1 )
          {
            v10 = v1[3];
            if ( v10 )
            {
              for ( i = 0; i < v10; ++i )
              {
                v12 = 0;
                if ( i < v10 )
                  v12 = *(_DWORD *)(v1[4] + 4 * i);
                v13 = (int *)sub_58220(v12);
                sub_57AA0(v9, v13);
                if ( *v1 != 1 )
                  break;
                v10 = v1[3];
              }
            }
          }
        }
        return v9;
      case 2:
        return sub_574A4(*(const char **)(LODWORD(a1) + 8));
      case 3:
        return (int *)sub_575D4(*(_QWORD *)(LODWORD(a1) + 8));
      case 4:
        return (int *)sub_57654(a1);
      default:
        if ( (unsigned int)(v2 - 5) > 2 )
          return 0;
        return v1;
    }
  }
  else
  {
    v4 = sub_57160();
    if ( v4 )
    {
      for ( j = sub_57254(v1); j; j = (_DWORD *)sub_572A0(v1, (int)j) )
      {
        v6 = (char *)sub_572CC((int)j);
        v7 = sub_572D8((int)j);
        v8 = sub_58220(v7);
        sub_57BD8(v4, v6, v8);
      }
    }
    return v4;
  }
}

//----- (00058368) --------------------------------------------------------
char *__fastcall sub_58368(char *result, char *s)
{
  bool v2; // zf
  int v4; // r5
  size_t v5; // r0

  v2 = result == 0;
  if ( result )
    v2 = s == 0;
  v4 = (int)result;
  if ( !v2 )
  {
    v5 = strlen(s);
    if ( v5 <= 0x4F )
    {
      return (char *)memcpy((void *)(v4 + 12), s, v5 + 1);
    }
    else
    {
      strcpy((char *)(v4 + 12), "...");
      return strcpy((char *)(v4 + 15), &s[v5 - 76]);
    }
  }
  return result;
}

//----- (000583CC) --------------------------------------------------------
char *__fastcall sub_583CC(char *result, char *s)
{
  if ( result )
  {
    result[92] = 0;
    *((_DWORD *)result + 2) = 0;
    *(_DWORD *)result = -1;
    *((_DWORD *)result + 1) = -1;
    if ( s )
      return sub_58368(result, s);
    else
      result[12] = 0;
  }
  return result;
}

//----- (00058410) --------------------------------------------------------
int __fastcall sub_58410(int result, int a2, int a3, int a4, char *format, __gnuc_va_list arg)
{
  int v6; // r4

  v6 = result;
  if ( result )
  {
    if ( !*(_BYTE *)(result + 92) )
    {
      *(_DWORD *)result = a2;
      *(_DWORD *)(result + 4) = a3;
      *(_DWORD *)(result + 8) = a4;
      result = vsnprintf((char *)(result + 92), 0xA0u, format, arg);
      *(_BYTE *)(v6 + 251) = 0;
    }
  }
  return result;
}

//----- (00058450) --------------------------------------------------------
int sub_58450(int a1, int a2, int a3, int a4, char *format, ...)
{
  va_list __varargs; // [sp+1Ch] [bp+8h] BYREF

  va_start(__varargs, format);
  return sub_58410(a1, a2, a3, a4, format, __varargs);
}

//----- (00058478) --------------------------------------------------------
char *__fastcall sub_58478(const char *a1, const char *a2)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(a1);
  v5 = strlen(a2);
  v6 = (char *)malloc(v5 + v4);
  sprintf(v6, a1, a2);
  return v6;
}

//----- (000584B4) --------------------------------------------------------
int __fastcall sub_584B4(_BYTE *a1)
{
  *a1 = 1;
  return 0;
}

//----- (000584C4) --------------------------------------------------------
int __fastcall sub_584C4(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

//----- (000584D8) --------------------------------------------------------
char *__fastcall sub_584D8(const char *a1, _BYTE *a2)
{
  if ( !strcasecmp(a1, "yes") || !strcasecmp(a1, "true") )
  {
    *a2 = 1;
    return 0;
  }
  else if ( !strcasecmp(a1, dword_63494) || !strcasecmp(a1, "false") )
  {
    *a2 = 0;
    return 0;
  }
  else
  {
    return sub_59140(a1);
  }
}

//----- (0005856C) --------------------------------------------------------
char *__fastcall sub_5856C(const char *a1, _BYTE *a2)
{
  char *result; // r0

  result = sub_584D8(a1, a2);
  if ( !result )
    *a2 ^= 1u;
  return result;
}

//----- (0005858C) --------------------------------------------------------
int __fastcall sub_5858C(int a1, _DWORD *a2)
{
  *a2 = a1;
  return 0;
}

//----- (00058598) --------------------------------------------------------
char *__fastcall sub_58598(const char *a1, _DWORD *a2)
{
  int v2; // s0
  int *v5; // r5
  _BYTE *v6; // r3
  char *result; // r0
  _BYTE *v8; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(a1, &v8);
  v6 = v8;
  *a2 = v2;
  if ( *v6 || !*a1 )
    return sub_58478("'%s' is not a number", a1);
  result = (char *)*v5;
  if ( *v5 )
    return sub_58478("'%s' is out of range", a1);
  return result;
}
// 585C8: variable 'v2' is possibly undefined
// AED0: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0005861C) --------------------------------------------------------
char *__fastcall sub_5861C(const char *a1, int *a2)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endptr; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(a1, &endptr, 0);
  v6 = endptr;
  *a2 = v5;
  if ( *v6 || !*a1 )
    return sub_58478("'%s' is not a number", a1);
  result = (char *)*v4;
  if ( *v4 )
    return sub_58478("'%s' is out of range", a1);
  return result;
}

//----- (000586A0) --------------------------------------------------------
char *__fastcall sub_586A0(const char *a1, _DWORD *a2)
{
  char *result; // r0
  int v4; // [sp+4h] [bp-4h] BYREF

  result = sub_5861C(a1, &v4);
  if ( !result )
    *a2 = v4;
  return result;
}

//----- (00058760) --------------------------------------------------------
int __fastcall sub_58760(_DWORD *a1)
{
  ++*a1;
  return 0;
}

//----- (00058778) --------------------------------------------------------
void __fastcall __noreturn sub_58778(const char *a1)
{
  puts(a1);
  fflush((FILE *)stdout);
  exit(0);
}
// 73A04: using guessed type int stdout;

//----- (00058798) --------------------------------------------------------
void __fastcall __noreturn sub_58798(int a1)
{
  const char *v1; // r0

  v1 = (const char *)sub_595C4(dword_9A554, a1);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 595C4: using guessed type int __fastcall sub_595C4(_DWORD, _DWORD);
// 73A04: using guessed type int stdout;
// 9A554: using guessed type int dword_9A554;

//----- (000587D8) --------------------------------------------------------
char *__fastcall sub_587D8(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "false";
  if ( v2 )
    v3 = "true";
  return strncpy(a1, v3, 0x50u);
}

//----- (000587FC) --------------------------------------------------------
char *__fastcall sub_587FC(char *a1, unsigned __int8 *a2)
{
  int v2; // r12
  const char *v3; // r1

  v2 = *a2;
  v3 = "true";
  if ( v2 )
    v3 = "false";
  return strncpy(a1, v3, 0x50u);
}

//----- (00058820) --------------------------------------------------------
char *__fastcall sub_58820(_BYTE *a1, const char **a2)
{
  size_t v4; // r0
  const char *v5; // r1
  bool v6; // cc
  size_t v7; // r5
  char *v8; // r0
  _BYTE *v9; // r4
  char *result; // r0

  v4 = strlen(*a2);
  *a1 = 34;
  v5 = *a2;
  v6 = v4 > 0x4E;
  v7 = v4;
  v8 = a1 + 1;
  if ( v6 )
  {
    result = strncpy(v8, v5, 0x4Eu);
    a1[79] = 34;
  }
  else
  {
    v9 = &a1[v7];
    result = strncpy(v8, v5, v7);
    v9[1] = 34;
    if ( v7 != 78 )
      v9[2] = 0;
  }
  return result;
}

//----- (00058880) --------------------------------------------------------
int __fastcall sub_58880(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%i", *a2);
}

//----- (00058894) --------------------------------------------------------
int __fastcall sub_58894(char *a1, float *a2)
{
  return snprintf(a1, 0x50u, "%.1f", *a2);
}

//----- (000588C0) --------------------------------------------------------
int __fastcall sub_588C0(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%u", *a2);
}

//----- (000588D4) --------------------------------------------------------
int __fastcall sub_588D4(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%li", *a2);
}

//----- (000588E8) --------------------------------------------------------
int __fastcall sub_588E8(char *a1, _DWORD *a2)
{
  return snprintf(a1, 0x50u, "%lu", *a2);
}

//----- (000588FC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_588FC(int a1, _DWORD *a2)
{
  unsigned __int8 *v2; // r4
  int v3; // r3
  bool v4; // zf
  int v5; // r2
  int v6; // r12
  unsigned __int8 *v7; // r12
  int v8; // r3
  int v9; // t1
  unsigned __int8 *result; // r0

  v2 = (unsigned __int8 *)(a1 + *a2);
  v3 = *v2;
  v4 = v3 == 32;
  if ( v3 != 32 )
    v4 = v3 == 61;
  if ( v4 )
    return 0;
  v5 = 0;
  if ( !*(_BYTE *)(a1 + *a2) )
    return 0;
  v6 = v2[2];
  result = v2 + 2;
  if ( v2[2] )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v7 = v2 + 2;
      do
      {
        v9 = *++v7;
        v8 = v9;
        ++v5;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  else
  {
    v5 = v2[2];
  }
  *a2 = v5;
  return result;
}

//----- (000589A4) --------------------------------------------------------
_BYTE *__fastcall sub_589A4(unsigned int *a1, _DWORD *a2)
{
  _DWORD *v2; // r3
  int v3; // r4
  unsigned int v4; // r12
  _BYTE *result; // r0
  int v6; // r2
  int v7; // r12
  int v8; // r3
  int v9; // t1

  *a1 = 0;
  if ( !dword_9A548 )
    return 0;
  v2 = (_DWORD *)dword_9A550;
  if ( *(_DWORD *)(dword_9A550 + 4) == 8 )
  {
    v3 = dword_9A550 + 28;
    v4 = 1;
    do
    {
      *a1 = v4;
      v2 = (_DWORD *)v3;
      v3 += 28;
      if ( dword_9A548 <= v4++ )
        return 0;
    }
    while ( v2[1] == 8 );
  }
  result = (_BYTE *)(*v2 + 1);
  v6 = (unsigned __int8)*result;
  if ( *result )
  {
    if ( v6 == 124 || v6 == 61 || v6 == 32 )
    {
      v6 = 0;
    }
    else
    {
      v7 = *v2 + 1;
      v6 = 0;
      do
      {
        v9 = *(unsigned __int8 *)++v7;
        v8 = v9;
        ++v6;
      }
      while ( v9 && v8 != 124 && v8 != 61 && v8 != 32 );
    }
  }
  *a2 = v6;
  return result;
}
// 9A548: using guessed type int dword_9A548;
// 9A550: using guessed type int dword_9A550;

//----- (00058A8C) --------------------------------------------------------
unsigned __int8 *__fastcall sub_58A8C(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3)
{
  unsigned int i; // r3
  _DWORD *v7; // r4
  _BYTE *v9; // r1
  int v10; // r3
  int v11; // r2
  int v12; // r3
  int v13; // t1

  for ( i = *a2; dword_9A548 > i; *a2 = ++i )
  {
    v7 = (_DWORD *)(dword_9A550 + 28 * i);
    if ( v7[1] != 8 )
    {
      if ( !a1 )
      {
        v9 = (_BYTE *)(*v7 + 1);
        v10 = (unsigned __int8)*v9;
        if ( *v9 && v10 != 124 && v10 != 61 && v10 != 32 )
        {
          v11 = *v7 + 1;
          do
          {
            v13 = *(unsigned __int8 *)++v11;
            v12 = v13;
            ++a1;
          }
          while ( v13 && v12 != 124 && v12 != 61 && v12 != 32 );
        }
        *a3 = a1;
        return v9;
      }
      a1 = sub_588FC((int)a1, a3);
      if ( a1 )
        return a1;
      i = *a2;
    }
  }
  return 0;
}
// 9A548: using guessed type int dword_9A548;
// 9A550: using guessed type int dword_9A550;

//----- (00058B80) --------------------------------------------------------
unsigned __int8 *__fastcall sub_58B80(const char **a1)
{
  unsigned int v1; // r1
  bool v2; // cc
  int v4; // r3
  const char *v5; // r2
  int v6; // r1
  unsigned __int8 *v7; // r12
  const char *v8; // r1
  int v9; // r2
  int v10; // t1
  const char *v11; // r2
  bool v12; // zf
  int v13; // r1
  const char *v14; // r0
  int v15; // r1
  bool v16; // zf
  unsigned __int8 *result; // r0
  int i; // [sp+Ch] [bp-4h] BYREF

  v1 = (unsigned int)a1[1];
  v2 = v1 > 4;
  if ( v1 != 4 )
    v2 = v1 - 1 > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", *a1, a1[1]);
  v4 = 0;
  v5 = *a1;
  if ( !a1[6] )
    errx(1, "Option %s: description cannot be NULL", v5);
  if ( *v5 != 45 )
    errx(1, "Option %s: does not begin with '-'", v5);
  v6 = *((unsigned __int8 *)v5 + 1);
  v7 = (unsigned __int8 *)(v5 + 1);
  if ( v5[1] )
  {
    if ( v6 != 124 && v6 != 61 && v6 != 32 )
    {
      v8 = v5 + 1;
      do
      {
        v10 = *(unsigned __int8 *)++v8;
        v9 = v10;
        ++v4;
      }
      while ( v10 && v9 != 124 && v9 != 61 && v9 != 32 );
    }
  }
  else
  {
    v4 = *((unsigned __int8 *)v5 + 1);
  }
  for ( i = v4; ; v4 = i )
  {
    if ( *v7 == 45 )
    {
      if ( v4 == 1 )
        errx(1, "Option %s: invalid long option '--'", *a1);
      v14 = a1[1];
      ++dword_9A540;
    }
    else
    {
      if ( v4 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", *a1, v4 + 1, (const char *)v7 - 1);
      v11 = a1[1];
      v12 = v11 == (const char *)2;
      if ( v11 != (const char *)2 )
        v12 = v11 == (const char *)4;
      v13 = ++dword_9A544;
      if ( v12 )
        v13 = dword_9A54C;
      v14 = v11;
      if ( v12 )
        dword_9A54C = v13 + 1;
    }
    if ( v14 == (const char *)1 )
    {
      v15 = v7[v4];
      v16 = v15 == 32;
      if ( v15 != 32 )
        v16 = v15 == 61;
      if ( v16 )
        errx(1, "Option %s: does not take arguments '%s'", *a1, (const char *)&v7[v4 + 1]);
    }
    result = sub_588FC((int)v7, &i);
    v7 = result;
    if ( !result )
      break;
  }
  return result;
}
// 9A540: using guessed type int dword_9A540;
// 9A544: using guessed type int dword_9A544;
// 9A54C: using guessed type int dword_9A54C;

//----- (00058D60) --------------------------------------------------------
int __fastcall sub_58D60(int *a1)
{
  char *v2; // r0
  int v3; // r10
  int v4; // r8
  char *v5; // r12
  int v6; // r0
  int v7; // r1
  int v8; // r2
  int v9; // r3
  int result; // r0
  int v11; // r1
  int v12; // r2

  v2 = (char *)realloc((void *)dword_9A550, 28 * (dword_9A548 + 1));
  v3 = dword_9A548 + 1;
  v4 = (int)v2;
  v5 = &v2[28 * dword_9A548];
  v6 = *a1;
  v7 = a1[1];
  v8 = a1[2];
  v9 = a1[3];
  a1 += 4;
  dword_9A550 = v4;
  *(_DWORD *)v5 = v6;
  *((_DWORD *)v5 + 1) = v7;
  *((_DWORD *)v5 + 2) = v8;
  *((_DWORD *)v5 + 3) = v9;
  v5 += 16;
  result = *a1;
  v11 = a1[1];
  v12 = a1[2];
  dword_9A548 = v3;
  *(_DWORD *)v5 = result;
  *((_DWORD *)v5 + 1) = v11;
  *((_DWORD *)v5 + 2) = v12;
  return result;
}
// 9A548: using guessed type int dword_9A548;
// 9A550: using guessed type int dword_9A550;

//----- (00058DC0) --------------------------------------------------------
unsigned __int8 *__fastcall sub_58DC0(unsigned int *a1, unsigned __int8 **a2)
{
  unsigned __int8 *v4; // r0

  v4 = sub_589A4(a1, a2);
  if ( !v4 )
    return 0;
  while ( *v4 != 45 )
  {
    v4 = sub_58A8C(v4, a1, a2);
    if ( !v4 )
      return 0;
  }
  --*a2;
  return v4 + 1;
}

//----- (00058E18) --------------------------------------------------------
unsigned __int8 *__fastcall sub_58E18(unsigned __int8 *a1, unsigned int *a2, unsigned __int8 **a3)
{
  unsigned __int8 *v5; // r0

  v5 = sub_58A8C(a1, a2, a3);
  if ( !v5 )
    return 0;
  while ( *v5 != 45 )
  {
    v5 = sub_58A8C(v5, a2, a3);
    if ( !v5 )
      return 0;
  }
  --*a3;
  return v5 + 1;
}

//----- (00058E70) --------------------------------------------------------
unsigned __int8 *__fastcall sub_58E70(unsigned int *a1)
{
  unsigned __int8 *result; // r0
  unsigned __int8 *v3; // [sp+4h] [bp-8h] BYREF

  v3 = 0;
  result = sub_589A4(a1, &v3);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = sub_58A8C(result, a1, &v3);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00058ECC) --------------------------------------------------------
unsigned __int8 *__fastcall sub_58ECC(unsigned __int8 *a1, unsigned int *a2)
{
  unsigned __int8 *result; // r0
  int v4; // [sp+4h] [bp-8h] BYREF

  v4 = 1;
  result = sub_58A8C(a1, a2, (unsigned __int8 **)&v4);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = sub_58A8C(result, a2, (unsigned __int8 **)&v4);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00058F70) --------------------------------------------------------
int __fastcall sub_58F70(int result, int a2)
{
  const char **v3; // r5
  int v4; // r6
  const char *v5; // r3
  const char **v6; // r4
  int v7[7]; // [sp+4h] [bp-1Ch] BYREF

  v3 = (const char **)result;
  v4 = dword_9A548;
  if ( a2 )
  {
    v7[6] = a2;
    v7[0] = 0;
    memset(&v7[2], 0, 16);
    v7[1] = 8;
    result = sub_58D60(v7);
  }
  v5 = v3[1];
  if ( v5 != (const char *)16 )
  {
    v6 = v3 + 7;
    do
    {
      if ( v5 == (const char *)8 )
      {
        result = sub_58F70(*v3, v3[6]);
      }
      else
      {
        sub_58B80(v3);
        result = sub_58D60((int *)v3);
      }
      v3 = v6;
      v6 += 7;
      v5 = *(v6 - 6);
    }
    while ( v5 != (const char *)16 );
  }
  if ( a2 )
    *(_DWORD *)(dword_9A550 + 28 * v4 + 20) = dword_9A548 - v4;
  return result;
}
// 9A548: using guessed type int dword_9A548;
// 9A550: using guessed type int dword_9A550;

//----- (0005903C) --------------------------------------------------------
bool __fastcall sub_5903C(_DWORD *a1, const char **a2, void (*a3)(const char *, ...))
{
  const char *v4; // r1
  int v7; // r0
  int v9; // [sp+4h] [bp-8h] BYREF

  v4 = *a2;
  v9 = 0;
  dword_9A554 = (int)v4;
  do
    v7 = sub_591A4(a1, a2, &v9, a3);
  while ( v7 == 1 );
  return v7 == 0;
}
// 9A554: using guessed type int dword_9A554;

//----- (00059098) --------------------------------------------------------
void sub_59098()
{
  free((void *)dword_9A550);
  dword_9A550 = 0;
}
// 9A550: using guessed type int dword_9A550;

//----- (000590B8) --------------------------------------------------------
int sub_590B8(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  return fputc(10, (FILE *)stderr);
}
// 73A08: using guessed type int stderr;

//----- (00059100) --------------------------------------------------------
void __noreturn sub_59100(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, a1);
  vfprintf((FILE *)stderr, a1, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 73A08: using guessed type int stderr;

//----- (00059140) --------------------------------------------------------
char *__fastcall sub_59140(const char *a1)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(a1);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", a1);
  return v3;
}

//----- (00059170) --------------------------------------------------------
void *__fastcall sub_59170(_DWORD *a1, int a2, int a3)
{
  void *result; // r0

  result = memmove((void *)(a2 + 4 * a3), (const void *)(a2 + 4 * (a3 + 1)), 4 * (*a1 - a3));
  --*a1;
  return result;
}

//----- (000591A4) --------------------------------------------------------
int __fastcall sub_591A4(_DWORD *a1, const char **a2, int *a3, void (*a4)(const char *, ...))
{
  char *v8; // r0
  const char *v9; // r12
  const char **v10; // r6
  int v12; // r5
  unsigned __int8 *v13; // r11
  const char *v14; // r3
  int v15; // r0
  size_t v16; // r0
  int v17; // r4
  unsigned __int8 *i; // r11
  int v19; // r0
  unsigned int v20; // r1
  const char *v21; // r11
  int v22; // lr
  int v23; // r12
  char *v24; // r4
  const char *v25; // r12
  const char **v26; // r4
  const char *v27; // t1
  _BYTE *ptr; // [sp+8h] [bp-14h]
  char *ptra; // [sp+8h] [bp-14h]
  const char *v30; // [sp+Ch] [bp-10h]
  unsigned int v31; // [sp+10h] [bp-Ch] BYREF
  size_t n[2]; // [sp+14h] [bp-8h] BYREF

  v8 = getenv("POSIXLY_CORRECT");
  v9 = a2[1];
  if ( !v8 )
  {
    if ( v9 )
    {
      if ( *v9 == 45 )
      {
        v10 = a2 + 1;
        v12 = 1;
        goto LABEL_6;
      }
      v26 = a2 + 2;
      v12 = 1;
      while ( 1 )
      {
        v10 = v26;
        v27 = *v26++;
        v9 = v27;
        ++v12;
        if ( !v27 )
          break;
        if ( *v9 == 45 )
          goto LABEL_6;
      }
    }
    return 0;
  }
  v10 = a2 + 1;
  if ( !v9 || *v9 != 45 )
    return 0;
  v12 = 1;
LABEL_6:
  if ( v9[1] == 45 )
  {
    v17 = *((unsigned __int8 *)v9 + 2);
    if ( !v9[2] )
    {
      sub_59170(a1, (int)a2, v12);
      return v17;
    }
    if ( *a3 )
      _assert_fail("*offset == 0", "opt/parse.c", 0x3Bu, "parse_one");
    for ( i = sub_58DC0(&v31, (unsigned __int8 **)n); i; i = sub_58E18(i, &v31, (unsigned __int8 **)n) )
    {
      v30 = *v10;
      ptr = (_BYTE *)n[0];
      v19 = strncmp(*v10 + 2, (const char *)i, n[0]);
      v14 = v30;
      if ( !v19 )
      {
        if ( ptr[(_DWORD)v30 + 2] == 61 )
        {
          v20 = v31;
          v24 = &ptr[(_DWORD)v30 + 3];
          v21 = (const char *)(i - 2);
          n[0] = (size_t)(ptr + 2);
          v22 = dword_9A550 + 28 * v31;
          v23 = *(_DWORD *)(v22 + 4);
          if ( v23 != 1 )
          {
            if ( v24 )
              goto LABEL_39;
            goto LABEL_48;
          }
          if ( v24 )
          {
            a4("%s: %.*s: %s", *a2, (int)(ptr + 2), v21, "doesn't allow an argument");
            return -1;
          }
LABEL_18:
          v24 = 0;
          v25 = (const char *)(*(int (__fastcall **)(_DWORD))(v22 + 8))(*(_DWORD *)(v22 + 20));
LABEL_19:
          if ( v25 )
          {
            ptra = (char *)v25;
            a4("%s: %.*s: %s", *a2, n[0], v21, v25);
            free(ptra);
            return -1;
          }
          if ( *a3 )
          {
            if ( !(*v10)[*a3 + 1] )
            {
              *a3 = 0;
              goto LABEL_23;
            }
          }
          else
          {
LABEL_23:
            sub_59170(a1, (int)a2, v12);
            if ( v24 )
            {
              if ( *v10 == v24 )
                sub_59170(a1, (int)a2, v12);
            }
          }
          return 1;
        }
        if ( !ptr[(_DWORD)v30 + 2] )
        {
          v20 = v31;
          v21 = (const char *)(i - 2);
          n[0] = (size_t)(ptr + 2);
          v22 = dword_9A550 + 28 * v31;
          v23 = *(_DWORD *)(v22 + 4);
          if ( v23 == 1 )
            goto LABEL_18;
LABEL_48:
          v15 = *a3;
          goto LABEL_37;
        }
      }
    }
LABEL_10:
    v16 = strlen(*v10);
    a4("%s: %.*s: %s", *a2, v16, *v10, "unrecognized option");
    return -1;
  }
  v13 = sub_58E70(&v31);
  if ( !v13 )
    goto LABEL_10;
  while ( 1 )
  {
    v14 = *v10;
    v15 = *a3 + 1;
    if ( (unsigned __int8)(*v10)[v15] == *v13 )
      break;
    v13 = sub_58ECC(v13, &v31);
    if ( !v13 )
      goto LABEL_10;
  }
  v20 = v31;
  v21 = (const char *)(v13 - 1);
  *a3 = v15;
  n[0] = 2;
  v22 = dword_9A550 + 28 * v20;
  v23 = *(_DWORD *)(v22 + 4);
  if ( v23 == 1 )
    goto LABEL_18;
LABEL_37:
  if ( v15 )
  {
    v24 = (char *)&v14[v15 + 1];
    if ( *v24 )
    {
      *a3 = 0;
      goto LABEL_39;
    }
  }
  v24 = (char *)a2[v12 + 1];
  if ( v24 )
  {
LABEL_39:
    if ( v23 == 4 )
    {
      sub_5858C((int)v24, *(_DWORD **)(v22 + 20));
      v20 = v31;
    }
    v25 = (const char *)(*(int (__fastcall **)(char *, _DWORD))(dword_9A550 + 28 * v20 + 12))(
                          v24,
                          *(_DWORD *)(dword_9A550 + 28 * v20 + 20));
    goto LABEL_19;
  }
  a4("%s: %.*s: %s", *a2, n[0], v21, "requires an argument");
  return -1;
}
// 9A550: using guessed type int dword_9A550;

//----- (000595C4) --------------------------------------------------------
char *__fastcall sub_595C4(const char *a1, char *a2)
{
  size_t v2; // r4
  unsigned int v3; // r11
  size_t v4; // r8
  int v5; // r4
  unsigned int v6; // r5
  const char *v7; // r7
  size_t v8; // r8
  size_t v9; // r0
  size_t v10; // r8
  size_t v11; // r9
  size_t v12; // r0
  char *v13; // r0
  char *v14; // r4
  char *v15; // r5
  unsigned __int8 *v16; // r2
  int v17; // r9
  int v18; // r0
  char *v19; // r5
  int v20; // r4
  unsigned int v21; // r7
  unsigned int v22; // r9
  int v23; // r2
  unsigned int v24; // r9
  unsigned int v25; // r9
  int v26; // r3
  const char *v27; // r2
  char *v29; // r2
  int v30; // r2
  int v31; // r3
  size_t v32; // r5
  char *v33; // [sp+0h] [bp-6Ch]
  char *v34; // [sp+4h] [bp-68h]
  char *s; // [sp+8h] [bp-64h]
  unsigned int v37; // [sp+10h] [bp-5Ch] BYREF
  char v38[80]; // [sp+14h] [bp-58h] BYREF
  int v39; // [sp+64h] [bp-8h]

  s = a2;
  if ( a2 )
  {
    v2 = strlen(a1);
    v3 = dword_9A548;
    v4 = dword_9A544 + 20 + v2 + strlen(s);
    if ( !dword_9A548 )
      goto LABEL_12;
    v5 = dword_9A550;
  }
  else
  {
    v3 = dword_9A548;
    if ( !dword_9A548 )
    {
      s = "";
      v4 = dword_9A544 + 20 + strlen(a1);
      goto LABEL_12;
    }
    v30 = 0;
    v5 = dword_9A550;
    v31 = dword_9A550;
    do
    {
      ++v30;
      if ( *(void (__fastcall __noreturn **)(int))(v31 + 8) == sub_58798 && *(_DWORD *)(v31 + 20) )
      {
        s = *(char **)(v31 + 20);
        v32 = strlen(s);
        goto LABEL_45;
      }
      v31 += 28;
    }
    while ( v30 != dword_9A548 );
    v32 = 0;
    s = "";
LABEL_45:
    v4 = dword_9A544 + 20 + strlen(a1) + v32;
  }
  v6 = 0;
  do
  {
    while ( 1 )
    {
      v11 = v4 + 6;
      if ( *(_DWORD *)(v5 + 4) != 8 )
        break;
      ++v6;
      v12 = strlen(*(const char **)(v5 + 24));
      v5 += 28;
      v4 += 3 + v12;
      if ( v3 <= v6 )
        goto LABEL_12;
    }
    v7 = *(const char **)(v5 + 24);
    if ( v7 != (const char *)&unk_9A558 )
    {
      v8 = strlen(*(const char **)v5);
      v9 = v11 + v8 + strlen(v7);
      v10 = v9 + 21;
      if ( *(_DWORD *)(v5 + 16) )
        v10 = v9 + 118;
      v4 = v10 + 1;
    }
    ++v6;
    v5 += 28;
  }
  while ( v3 > v6 );
LABEL_12:
  v13 = (char *)malloc(v4);
  v34 = v13;
  if ( v13 )
  {
    v14 = &v13[sprintf(v13, "Usage: %s", a1)];
    v15 = v14 + 3;
    strcpy(v14, " [-");
    v16 = sub_58E70(&v37);
    if ( v16 )
    {
      v17 = 0;
      do
      {
        if ( *(_UNKNOWN **)(dword_9A550 + 28 * v37 + 24) != &unk_9A558 )
          v15[v17++] = *v16;
        v16 = sub_58ECC(v16, &v37);
      }
      while ( v16 );
      if ( v17 )
      {
        v14 = &v15[v17 + 1];
        *(_WORD *)&v15[v17] = 93;
      }
    }
    v18 = sprintf(v14, " %s", s);
    *(_WORD *)&v14[v18] = 10;
    v19 = &v14[v18 + 1];
    if ( dword_9A548 )
    {
      v20 = 0;
      v21 = 0;
      do
      {
        v26 = dword_9A550 + v20;
        v27 = *(const char **)(dword_9A550 + v20 + 24);
        if ( v27 != (const char *)&unk_9A558 )
        {
          if ( *(_DWORD *)(v26 + 4) == 8 )
          {
            v19 += sprintf(v19, "%s:\n", v27);
          }
          else
          {
            v22 = sprintf(v19, "%s", *(const char **)v26);
            if ( *(_DWORD *)(dword_9A550 + v20 + 4) == 2 )
            {
              v33 = *(char **)(dword_9A550 + v20);
              if ( !strchr(v33, 32) && !strchr(v33, 61) )
              {
                v29 = &v19[v22];
                *(_DWORD *)&v19[v22] = *(_DWORD *)" <arg>";
                v22 += 6;
                strcpy(v29 + 4, "g>");
              }
            }
            if ( v22 > 0x13 )
              v23 = 1;
            else
              v23 = 20 - v22;
            v24 = sprintf(&v19[v22], "%.*s", v23, "                    ", v33) + v22;
            v25 = v24 + sprintf(&v19[v24], "%s", *(const char **)(dword_9A550 + v20 + 24));
            if ( *(_DWORD *)(dword_9A550 + v20 + 16) )
            {
              v39 = 3026478;
              (*(void (__fastcall **)(char *, _DWORD))(dword_9A550 + v20 + 16))(
                v38,
                *(_DWORD *)(dword_9A550 + v20 + 20));
              v25 += sprintf(&v19[v25], " (default: %s)", v38);
            }
            *(_WORD *)&v19[v25] = 10;
            v19 += v25 + 1;
          }
        }
        ++v21;
        v20 += 28;
      }
      while ( dword_9A548 > v21 );
    }
    *v19 = 0;
  }
  return v34;
}
// 597E0: variable 'v33' is possibly undefined
// 9A544: using guessed type int dword_9A544;
// 9A548: using guessed type int dword_9A548;
// 9A550: using guessed type int dword_9A550;

//----- (00059AC8) --------------------------------------------------------
int __fastcall sub_59AC8(int a1, int a2)
{
  if ( !a2 )
    JUMPOUT(0x59FB8);
  return divsi3_skip_div0_test();
}
// 59BA0: control flows out of bounds to 59FB8
// 59AD0: using guessed type int divsi3_skip_div0_test(void);

//----- (00059AD0) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  int v3; // r12
  unsigned int v4; // r3
  char v5; // r0
  unsigned int v6; // r1
  unsigned int v7; // r2
  bool v8; // zf

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      v5 = __clz(a2) - __clz(v4);
      v6 = a2 << v5;
      v7 = 1 << v5;
      result = 0;
      while ( 1 )
      {
        if ( v4 >= v6 )
        {
          v4 -= v6;
          result |= v7;
        }
        if ( v4 >= v6 >> 1 )
        {
          v4 -= v6 >> 1;
          result |= v7 >> 1;
        }
        if ( v4 >= v6 >> 2 )
        {
          v4 -= v6 >> 2;
          result |= v7 >> 2;
        }
        if ( v4 >= v6 >> 3 )
        {
          v4 -= v6 >> 3;
          result |= v7 >> 3;
        }
        v8 = v4 == 0;
        if ( v4 )
        {
          v7 >>= 4;
          v8 = v7 == 0;
        }
        if ( v8 )
          break;
        v6 >>= 4;
      }
      if ( v3 < 0 )
        return -result;
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 59AD4: variable 'v2' is possibly undefined

//----- (00059BC4) --------------------------------------------------------
int __fastcall sub_59BC4(__int64 a1, __int64 a2)
{
  int v2; // r4
  int v3; // r5
  bool v4; // zf
  int v5; // r4
  bool v6; // vf
  char v7; // cc
  int v8; // r5
  __int64 v9; // r2
  int v10; // r4
  char v11; // lr
  unsigned int v12; // r12
  __int64 v13; // r0
  bool v14; // nf
  char v15; // r5
  _BOOL1 v16; // off
  _BOOL1 v17; // cf
  int v18; // off
  int v19; // r4
  bool v20; // zf
  unsigned int v21; // r3
  int v22; // r3
  bool v23; // cc
  int v24; // r2
  int v25; // r4
  int v26; // r4
  char v27; // r4
  bool v28; // zf
  bool v29; // zf

  HIDWORD(a1) ^= 0x80000000;
  v2 = 2 * HIDWORD(a1);
  v3 = 2 * HIDWORD(a2);
  v4 = 2 * HIDWORD(a1) == 2 * HIDWORD(a2);
  if ( 2 * HIDWORD(a1) == 2 * HIDWORD(a2) )
    v4 = (unsigned int)a1 == (unsigned int)a2;
  if ( !v4 )
  {
    v4 = (v2 | (unsigned int)a1) == 0;
    if ( v2 | (unsigned int)a1 )
    {
      v4 = (v3 | (unsigned int)a2) == 0;
      if ( v3 | (unsigned int)a2 )
      {
        v4 = v2 >> 21 == -1;
        if ( v2 >> 21 != -1 )
          v4 = v3 >> 21 == -1;
      }
    }
  }
  if ( v4 )
  {
    v28 = v2 >> 21 == -1;
    if ( v2 >> 21 != -1 )
      v28 = v3 >> 21 == -1;
    if ( v28 )
    {
      if ( v2 >> 21 != -1 )
        return a2;
    }
    else
    {
      v29 = v2 == v3;
      if ( v2 == v3 )
        v29 = (unsigned int)a1 == (unsigned int)a2;
      if ( v29 )
      {
        if ( HIDWORD(a1) != HIDWORD(a2) )
        {
          LODWORD(a1) = 0;
          return a1;
        }
        if ( !((unsigned int)v2 >> 21) )
        {
          LODWORD(a1) = 2 * a1;
          return a1;
        }
        if ( (unsigned int)v2 < 0xFFC00000 )
          return a1;
        goto LABEL_68;
      }
      if ( !(v2 | (unsigned int)a1) )
        LODWORD(a1) = a2;
    }
  }
  else
  {
    v5 = (unsigned int)v2 >> 21;
    v6 = __OFSUB__((unsigned int)v3 >> 21, v5);
    v8 = ((unsigned int)v3 >> 21) - v5;
    v7 = (v8 < 0) ^ v6 | (v8 == 0);
    if ( v8 < 0 != v6 )
      v8 = -v8;
    if ( !v7 )
    {
      v5 += v8;
      v9 = a1 ^ a2;
      a1 ^= v9;
      a2 = a1 ^ v9;
    }
    if ( (unsigned int)v8 <= 0x36 )
    {
      v4 = a1 >= 0;
      HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
      if ( !v4 )
        a1 = -a1;
      v4 = a2 >= 0;
      HIDWORD(a2) = HIDWORD(a2) & 0xFFFFF | 0x100000;
      if ( !v4 )
        a2 = -a2;
      if ( v5 == v8 )
      {
        HIDWORD(a2) ^= 0x100000u;
        if ( v5 )
        {
          --v8;
        }
        else
        {
          HIDWORD(a1) ^= 0x100000u;
          v5 = 1;
        }
      }
      v10 = v5 - 1;
      v11 = 32 - v8;
      if ( v8 > 32 )
      {
        v15 = v8 - 32;
        v12 = HIDWORD(a2) << (v11 + 32);
        if ( (_DWORD)a2 )
          v12 |= 2u;
        LODWORD(a1) = a1 + (SHIDWORD(a2) >> v15);
        HIDWORD(a1) += (SHIDWORD(a2) >> 31) + __CFSHR__(HIDWORD(a2), 31);
        v14 = a1 < 0;
      }
      else
      {
        v12 = (_DWORD)a2 << v11;
        v13 = a1 + ((unsigned int)a2 >> v8);
        LODWORD(a1) = v13 + (HIDWORD(a2) << v11);
        HIDWORD(a1) = (SHIDWORD(a2) >> v8) + __CFSHR__(HIDWORD(a2), v8) + HIDWORD(v13);
        v14 = a1 < 0;
      }
      if ( v14 )
      {
        v17 = v12 == 0;
        v12 = -v12;
        v16 = v17;
        v17 = __CFSUB__(0, (_DWORD)a1, v17);
        LODWORD(a1) = -(a1 + !v16);
        HIDWORD(a1) = -(HIDWORD(a1) + !v17);
      }
      if ( HIDWORD(a1) >= 0x100000 )
      {
        if ( HIDWORD(a1) < 0x200000 )
          goto LABEL_30;
        v17 = a1 & 1;
        LODWORD(a1) = a1 >> 1;
        v12 = (v12 >> 1) | (v17 << 31);
        if ( (unsigned int)((v10 + 1) << 21) < 0xFFC00000 )
          goto LABEL_30;
LABEL_68:
        JUMPOUT(0x59E40);
      }
      v17 = __CFSHL__(v12, 1);
      v12 *= 2;
      v18 = v17 + (_DWORD)a1;
      v17 = __CFADD__(v17, (_DWORD)a1) | __CFADD__((_DWORD)a1, v18);
      LODWORD(a1) = a1 + v18;
      HIDWORD(a1) += v17 + HIDWORD(a1);
      v19 = v10 - 1;
      if ( (a1 & 0x10000000000000LL) != 0 )
      {
LABEL_30:
        v17 = v12 >= 0x80000000;
        if ( v12 == 0x80000000 )
          v17 = a1 & 1;
        LODWORD(a1) = v17 + (_DWORD)a1;
        return a1;
      }
      v20 = HIDWORD(a1) == 0;
      if ( !HIDWORD(a1) )
      {
        HIDWORD(a1) = a1;
        LODWORD(a1) = 0;
      }
      v21 = __clz(HIDWORD(a1));
      if ( v20 )
        v21 += 32;
      v22 = v21 - 11;
      v24 = v22 - 32;
      v23 = v22 <= 32;
      if ( v22 < 32 )
      {
        v23 = v24 <= -12;
        if ( v24 > -12 )
        {
          LODWORD(a1) = HIDWORD(a1) << v22;
          HIDWORD(a1) >>= 32 - v22;
LABEL_46:
          v7 = v19 < v22;
          v25 = v19 - v22;
          if ( v7 )
          {
            v26 = ~v25;
            v7 = v26 < 31;
            v27 = v26 - 31;
            if ( v7 )
              LODWORD(a1) = ((unsigned int)a1 >> (v27 + 32)) | (HIDWORD(a1) << -v27);
            else
              LODWORD(a1) = HIDWORD(a1) >> v27;
          }
          return a1;
        }
        LOBYTE(v24) = v22;
      }
      if ( v23 )
        LOBYTE(v12) = 32 - v24;
      HIDWORD(a1) <<= v24;
      if ( v23 )
      {
        HIDWORD(a1) |= (unsigned int)a1 >> v12;
        LODWORD(a1) = (_DWORD)a1 << v24;
      }
      goto LABEL_46;
    }
  }
  return a1;
}
// 59E3C: control flows out of bounds to 59E40

//----- (00059F08) --------------------------------------------------------
int __fastcall sub_59F08(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x59F38);
  return a1;
}
// 59F18: control flows out of bounds to 59F38

//----- (00059F1C) --------------------------------------------------------
int __fastcall sub_59F1C(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  int v9; // r4
  int v10; // r4
  char v11; // r4
  int v12; // r4
  unsigned int v13; // r12
  int v14; // r2
  int v15; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
    a1 = -a1;
  v12 = 1074;
  v13 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v14 = 3;
    if ( HIDWORD(a1) >> 25 )
      v14 = 6;
    if ( HIDWORD(a1) >> 28 )
      v14 += 3;
    v15 = v14 + (HIDWORD(a1) >> 31);
    v13 = (_DWORD)a1 << (32 - v15);
    LODWORD(a1) = ((unsigned int)a1 >> v15) | (HIDWORD(a1) << (32 - v15));
    HIDWORD(a1) >>= v15;
    v12 = v15 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v13 = (v13 >> 1) | (v1 << 31);
      if ( (unsigned int)((v12 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v13, 1);
  v13 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v12 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v13 >= 0x80000000;
    if ( v13 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v13) = 32 - v8;
    HIDWORD(a1) <<= v8;
    if ( v7 )
    {
      HIDWORD(a1) |= (unsigned int)a1 >> v13;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v9 = v3 - v6;
  if ( v7 )
  {
    v10 = ~v9;
    v7 = v10 < 31;
    v11 = v10 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v11 + 32)) | (HIDWORD(a1) << -v11);
    else
      LODWORD(a1) = HIDWORD(a1) >> v11;
  }
  return a1;
}

//----- (00059F7C) --------------------------------------------------------
int __fastcall sub_59F7C(__int64 a1, __int64 a2)
{
  __int64 v3; // [sp+8h] [bp-8h] BYREF

  if ( a2 )
    return _gnu_uldivmod_helper(a1, a2, &v3);
  else
    return raise(8);
}

//----- (00059FC8) --------------------------------------------------------
int __fastcall sub_59FC8(double a1)
{
  __int64 v1; // r0
  __int64 v2; // r0

  if ( a1 >= 0.0 )
  {
    LODWORD(v2) = sub_5A000(a1);
  }
  else
  {
    HIDWORD(a1) ^= 0x80000000;
    LODWORD(v1) = sub_5A000(a1);
    return -v1;
  }
  return v2;
}
// 59FF0: variable 'v1' is possibly undefined

//----- (0005A000) --------------------------------------------------------
unsigned int __fastcall sub_5A000(double a1)
{
  return (unsigned int)(a1 - (double)(unsigned int)(a1 * 2.32830644e-10) * 4294967300.0);
}

//----- (0005A048) --------------------------------------------------------
int __fastcall _gnu_ldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r0

  LODWORD(v5) = sub_5A0C0(a1, a2);
  *a3 = a1 - a2 * v5;
  return v5;
}
// 5A06C: variable 'v5' is possibly undefined

//----- (0005A084) --------------------------------------------------------
int __fastcall _gnu_uldivmod_helper(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // r0

  LODWORD(v5) = sub_5A518(a1, HIDWORD(a1), a2, HIDWORD(a2));
  *a3 = a1 - v5 * a2;
  return v5;
}
// 5A0A4: variable 'v5' is possibly undefined

//----- (0005A0C0) --------------------------------------------------------
int __fastcall sub_5A0C0(__int64 a1, __int64 a2)
{
  __int64 v2; // kr00_8
  __int64 v3; // kr08_8
  int v4; // r4
  unsigned int v5; // r6
  unsigned int v6; // r9
  __int64 v7; // r10
  unsigned int v8; // r3
  unsigned int v9; // r5
  int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r8
  unsigned int v14; // r0
  unsigned int v15; // r10
  unsigned int v16; // r7
  unsigned int v17; // r12
  unsigned int v18; // r6
  int v19; // r12
  unsigned int v20; // r3
  unsigned int v21; // r7
  int v22; // r5
  unsigned int v23; // r8
  unsigned int v24; // r7
  int v25; // r0
  unsigned int v26; // r3
  unsigned int v27; // r2
  int v28; // r11
  unsigned int v29; // r0
  unsigned int v30; // r1
  unsigned int v31; // r9
  unsigned int v32; // r5
  unsigned int v33; // r8
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r2
  int v37; // r7
  unsigned int v38; // r0
  unsigned int v39; // r10
  unsigned int v40; // r9
  unsigned int v41; // r12
  unsigned int v42; // r6
  unsigned int v43; // r10
  bool v44; // cf
  unsigned int v45; // r6
  unsigned int v46; // r7
  unsigned int v47; // r9
  int v48; // r0
  unsigned int v49; // r1
  unsigned int v50; // r2
  int v51; // r3
  unsigned int v52; // r0
  unsigned int v53; // r1
  unsigned int v54; // r11
  unsigned int v55; // r12
  unsigned int v56; // r11
  unsigned __int64 v57; // r2
  bool v58; // r3
  __int64 v59; // r0
  unsigned int v61; // [sp+4h] [bp-8h]

  v2 = a1;
  v3 = a2;
  if ( a1 < 0 )
  {
    v4 = -1;
    v2 = -a1;
  }
  else
  {
    v4 = 0;
  }
  if ( a2 < 0 )
  {
    v4 = ~v4;
    v3 = -a2;
  }
  v5 = v3;
  v6 = HIDWORD(v2);
  LODWORD(v7) = v2;
  if ( !HIDWORD(v3) )
  {
    if ( (unsigned int)v3 > HIDWORD(v2) )
    {
      v8 = __clz(v3);
      if ( v8 )
      {
        v5 = (_DWORD)v3 << v8;
        LODWORD(v7) = (_DWORD)v2 << v8;
        v6 = ((unsigned int)v2 >> (32 - v8)) | (HIDWORD(v2) << v8);
      }
      v9 = HIWORD(v5);
      v10 = v6 / HIWORD(v5);
      v11 = WORD1(v7) | ((v6 % HIWORD(v5)) << 16);
      v12 = (unsigned __int16)v5 * v10;
      if ( v11 < v12 )
      {
        v44 = __CFADD__(v11, v5);
        v11 += v5;
        v13 = v10 - 1;
        if ( !v44 && v11 < v12 )
        {
          v13 = v10 - 2;
          v11 += v5;
        }
      }
      else
      {
        v13 = v6 / v9;
      }
      v14 = (v11 - v12) / v9;
      v15 = (unsigned __int16)v7 | (((v11 - v12) % v9) << 16);
      v16 = (unsigned __int16)v5 * v14;
      if ( v15 < v16 )
      {
        v44 = __CFADD__(v15, v5);
        v18 = v15 + v5;
        v17 = v14 - 1;
        if ( !v44 && v18 < v16 )
          v17 = v14 - 2;
      }
      else
      {
        v17 = (v11 - v12) / v9;
      }
      v19 = v17 | (v13 << 16);
      goto LABEL_70;
    }
    if ( !(_DWORD)v3 )
      v5 = 1 / 0u;
    v20 = __clz(v5);
    if ( v20 )
    {
      v5 <<= v20;
      HIDWORD(v7) = HIDWORD(v2) >> (32 - v20);
      v23 = HIWORD(v5);
      v24 = ((unsigned int)v2 >> (32 - v20)) | (HIDWORD(v2) << v20);
      LODWORD(v7) = (_DWORD)v2 << v20;
      v25 = HIDWORD(v7) / HIWORD(v5);
      v26 = HIWORD(v24) | ((HIDWORD(v7) % HIWORD(v5)) << 16);
      v27 = (unsigned __int16)v5 * v25;
      if ( v26 < v27 )
      {
        v44 = __CFADD__(v26, v5);
        v26 += v5;
        v28 = v25 - 1;
        if ( !v44 && v26 < v27 )
        {
          v28 = v25 - 2;
          v26 += v5;
        }
      }
      else
      {
        v28 = HIDWORD(v7) / v23;
      }
      v29 = (v26 - v27) / v23;
      v30 = (unsigned __int16)v24 | (((v26 - v27) % v23) << 16);
      v31 = (unsigned __int16)v5 * v29;
      if ( v30 < v31 )
      {
        v44 = __CFADD__(v30, v5);
        v30 += v5;
        v32 = v29 - 1;
        if ( !v44 && v30 < v31 )
        {
          v32 = v29 - 2;
          v30 += v5;
        }
      }
      else
      {
        v32 = (v26 - v27) / v23;
      }
      v21 = v30 - v31;
      v22 = v32 | (v28 << 16);
    }
    else
    {
      v21 = HIDWORD(v2) - v5;
      v22 = 1;
    }
    v33 = HIWORD(v5);
    v34 = v21 / HIWORD(v5);
    HIDWORD(v7) = v21 % HIWORD(v5);
    v35 = v7 >> 16;
    v36 = (unsigned __int16)v5 * v34;
    if ( v35 < v36 )
    {
      v44 = __CFADD__(v35, v5);
      v35 += v5;
      v37 = v34 - 1;
      if ( !v44 && v35 < v36 )
      {
        v37 = v34 - 2;
        v35 += v5;
      }
    }
    else
    {
      v37 = v21 / v33;
    }
    v38 = (v35 - v36) / v33;
    v39 = (unsigned __int16)v7 | (((v35 - v36) % v33) << 16);
    v40 = (unsigned __int16)v5 * v38;
    if ( v39 < v40 )
    {
      v44 = __CFADD__(v39, v5);
      v42 = v39 + v5;
      v41 = v38 - 1;
      if ( !v44 && v42 < v40 )
        v41 = v38 - 2;
    }
    else
    {
      v41 = (v35 - v36) / v33;
    }
    v19 = v41 | (v37 << 16);
    goto LABEL_73;
  }
  if ( HIDWORD(v3) > HIDWORD(v2) )
  {
    v22 = 0;
LABEL_72:
    v19 = 0;
    goto LABEL_73;
  }
  v43 = __clz(HIDWORD(v3));
  if ( !v43 )
  {
    v44 = HIDWORD(v2) >= HIDWORD(v3);
    if ( HIDWORD(v2) <= HIDWORD(v3) )
      v44 = (unsigned int)v2 >= (unsigned int)v3;
    if ( v44 )
    {
      v19 = 1;
      v22 = 0;
      goto LABEL_73;
    }
    v22 = 0;
    goto LABEL_72;
  }
  v45 = ((unsigned int)v3 >> (32 - v43)) | (HIDWORD(v3) << v43);
  v46 = ((unsigned int)v2 >> (32 - v43)) | (HIDWORD(v2) << v43);
  v47 = HIWORD(v45);
  v61 = HIDWORD(v2) >> (32 - v43);
  v48 = v61 / HIWORD(v45);
  v49 = HIWORD(v46) | ((v61 % HIWORD(v45)) << 16);
  v50 = (unsigned __int16)v45 * v48;
  if ( v49 < v50 )
  {
    v44 = __CFADD__(v49, v45);
    v49 += v45;
    v51 = v48 - 1;
    if ( !v44 && v49 < v50 )
    {
      v51 = v48 - 2;
      v49 += v45;
    }
  }
  else
  {
    v51 = v61 / v47;
  }
  v52 = (v49 - v50) / v47;
  v53 = (unsigned __int16)v46 | (((v49 - v50) % v47) << 16);
  v54 = (unsigned __int16)v45 * v52;
  if ( v53 < v54 )
  {
    v44 = __CFADD__(v53, v45);
    v53 += v45;
    v55 = v52 - 1;
    if ( !v44 && v53 < v54 )
    {
      v55 = v52 - 2;
      v53 += v45;
    }
  }
  else
  {
    v55 = v52;
  }
  v19 = v55 | (v51 << 16);
  v56 = v53 - v54;
  v57 = (unsigned int)v19 * (unsigned __int64)(unsigned int)((_DWORD)v3 << v43);
  if ( HIDWORD(v57) > v56
    || ((v58 = HIDWORD(v57) == v56, (unsigned int)v57 > (_DWORD)v2 << v43) ? (v22 = v58) : (v22 = 0), v22) )
  {
    --v19;
LABEL_70:
    v22 = 0;
  }
LABEL_73:
  LODWORD(v59) = v19;
  if ( v4 )
    return -__SPAIR64__(v22, v19);
  return v59;
}

//----- (0005A518) --------------------------------------------------------
int __fastcall sub_5A518(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // r4
  unsigned int v6; // r7
  unsigned int v7; // r10
  unsigned int v8; // r3
  unsigned int v9; // r5
  int v10; // r0
  unsigned int v11; // r3
  unsigned int v12; // r2
  int v13; // r6
  unsigned int v14; // r0
  unsigned int v15; // r7
  unsigned int v16; // r8
  unsigned int v17; // r3
  unsigned int v18; // r4
  int result; // r0
  unsigned int v20; // r3
  unsigned int v21; // r10
  unsigned int v22; // r6
  unsigned int v23; // r8
  int v24; // r0
  unsigned int v25; // r3
  unsigned int v26; // r2
  unsigned int v27; // r1
  unsigned int v28; // r10
  unsigned int v29; // r6
  int v30; // r0
  unsigned int v31; // r3
  unsigned int v32; // r2
  int v33; // r10
  unsigned int v34; // r0
  unsigned int v35; // r7
  unsigned int v36; // r8
  unsigned int v37; // r3
  unsigned int v38; // r4
  unsigned int v39; // r7
  bool v40; // cf
  unsigned int v41; // r11
  unsigned int v42; // r4
  unsigned int v43; // r5
  unsigned int v44; // r10
  int v45; // r0
  unsigned int v46; // r12
  unsigned int v47; // r3
  int v48; // r11
  unsigned int v49; // r0
  unsigned int v50; // r1
  unsigned int v51; // r9
  unsigned int v52; // r3
  unsigned int v53; // r9
  unsigned __int64 v54; // r2
  _BOOL4 v55; // r5

  v5 = a3;
  v6 = a1;
  v7 = a2;
  if ( !a4 )
  {
    if ( a3 <= a2 )
    {
      if ( !a3 )
        v5 = 1 / 0u;
      v20 = __clz(v5);
      if ( v20 )
      {
        v5 <<= v20;
        v6 = a1 << v20;
        v22 = HIWORD(v5);
        v23 = (a1 >> (32 - v20)) | (a2 << v20);
        v24 = (a2 >> (32 - v20)) / HIWORD(v5);
        v25 = HIWORD(v23) | (((a2 >> (32 - v20)) % HIWORD(v5)) << 16);
        v26 = (unsigned __int16)v5 * v24;
        if ( v25 < v26 )
        {
          v40 = __CFADD__(v25, v5);
          v25 += v5;
          if ( !v40 && v25 < v26 )
            v25 += v5;
        }
        v27 = (unsigned __int16)v23 | (((v25 - v26) % v22) << 16);
        v28 = (unsigned __int16)v5 * ((v25 - v26) / v22);
        if ( v27 < v28 )
        {
          v40 = __CFADD__(v27, v5);
          v27 += v5;
          if ( !v40 && v27 < v28 )
            v27 += v5;
        }
        v21 = v27 - v28;
      }
      else
      {
        v21 = a2 - v5;
      }
      v29 = HIWORD(v5);
      v30 = v21 / HIWORD(v5);
      v31 = HIWORD(v6) | ((v21 % HIWORD(v5)) << 16);
      v32 = (unsigned __int16)v5 * v30;
      if ( v31 < v32 )
      {
        v40 = __CFADD__(v31, v5);
        v31 += v5;
        v33 = v30 - 1;
        if ( !v40 && v31 < v32 )
        {
          v33 = v30 - 2;
          v31 += v5;
        }
      }
      else
      {
        v33 = v21 / v29;
      }
      v34 = (v31 - v32) / v29;
      v35 = (unsigned __int16)v6 | (((v31 - v32) % v29) << 16);
      v36 = (unsigned __int16)v5 * v34;
      if ( v35 < v36 )
      {
        v40 = __CFADD__(v35, v5);
        v38 = v35 + v5;
        v37 = v34 - 1;
        if ( !v40 && v38 < v36 )
          v37 = v34 - 2;
      }
      else
      {
        v37 = (v31 - v32) / v29;
      }
      return v37 | (v33 << 16);
    }
    else
    {
      v8 = __clz(a3);
      if ( v8 )
      {
        v5 = a3 << v8;
        v6 = a1 << v8;
        v7 = (a1 >> (32 - v8)) | (a2 << v8);
      }
      v9 = HIWORD(v5);
      v10 = v7 / HIWORD(v5);
      v11 = HIWORD(v6) | ((v7 % HIWORD(v5)) << 16);
      v12 = (unsigned __int16)v5 * v10;
      if ( v11 < v12 )
      {
        v40 = __CFADD__(v11, v5);
        v11 += v5;
        v13 = v10 - 1;
        if ( !v40 && v11 < v12 )
        {
          v13 = v10 - 2;
          v11 += v5;
        }
      }
      else
      {
        v13 = v7 / v9;
      }
      v14 = (v11 - v12) / v9;
      v15 = (unsigned __int16)v6 | (((v11 - v12) % v9) << 16);
      v16 = (unsigned __int16)v5 * v14;
      if ( v15 < v16 )
      {
        v40 = __CFADD__(v15, v5);
        v18 = v15 + v5;
        v17 = v14 - 1;
        if ( !v40 && v18 < v16 )
          v17 = v14 - 2;
      }
      else
      {
        v17 = (v11 - v12) / v9;
      }
      return v17 | (v13 << 16);
    }
  }
  if ( a4 > a2 )
    return 0;
  v39 = __clz(a4);
  if ( !v39 )
  {
    v40 = a2 >= a4;
    if ( a2 <= a4 )
      return a1 >= a3;
    return v40;
  }
  v41 = a2 >> (32 - v39);
  v42 = (a3 >> (32 - v39)) | (a4 << v39);
  v43 = (a1 >> (32 - v39)) | (a2 << v39);
  v44 = HIWORD(v42);
  v45 = v41 / HIWORD(v42);
  v46 = HIWORD(v43) | ((v41 % HIWORD(v42)) << 16);
  v47 = (unsigned __int16)v42 * v45;
  if ( v46 < v47 )
  {
    v40 = __CFADD__(v46, v42);
    v46 += v42;
    v48 = v45 - 1;
    if ( !v40 && v46 < v47 )
    {
      v48 = v45 - 2;
      v46 += v42;
    }
  }
  else
  {
    v48 = v41 / v44;
  }
  v49 = (v46 - v47) / v44;
  v50 = (unsigned __int16)v43 | (((v46 - v47) % v44) << 16);
  v51 = (unsigned __int16)v42 * v49;
  if ( v50 < v51 )
  {
    v40 = __CFADD__(v50, v42);
    v50 += v42;
    v52 = v49 - 1;
    if ( !v40 && v50 < v51 )
    {
      v52 = v49 - 2;
      v50 += v42;
    }
  }
  else
  {
    v52 = (v46 - v47) / v44;
  }
  result = v52 | (v48 << 16);
  v53 = v50 - v51;
  v54 = (unsigned int)result * (unsigned __int64)(a3 << v39);
  if ( HIDWORD(v54) > v53 || ((unsigned int)v54 > a1 << v39 ? (v55 = HIDWORD(v54) == v53) : (v55 = 0), v55) )
    --result;
  return result;
}

//----- (0005A8F8) --------------------------------------------------------
void __fastcall init(int a1, int a2, int a3)
{
  int v6; // r6
  unsigned int v7; // r5
  int v8; // r4
  void (__fastcall *v9)(int, int, int); // t1

  init_proc();
  v6 = &off_72004 - off_72000;
  if ( v6 )
  {
    v7 = 0x71FFCu;
    v8 = 0;
    do
    {
      ++v8;
      v9 = *(void (__fastcall **)(int, int, int))(v7 + 4);
      v7 += 4;
      v9(a1, a2, a3);
    }
    while ( v8 != v6 );
  }
}
// 72000: using guessed type int (*off_72000[2])();
// 72004: using guessed type int (*off_72004)();

//----- (0005A960) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=1185 queued=765 decompiled=765 lumina nreq=0 worse=0 better=0
// ALL OK, 765 function(s) have been successfully decompiled
