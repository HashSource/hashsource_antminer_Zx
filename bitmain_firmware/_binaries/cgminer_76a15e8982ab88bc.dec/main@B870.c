void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int v3; // r0
  int (*v4)(void); // r3
  int (**v5)(); // r12
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r5
  int v11; // r4
  int v12; // r7
  const char **v13; // r8
  char *v14; // r0
  char *v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  int *v48; // r12
  unsigned int v49; // r3
  int v50; // r2
  unsigned int v51; // r0
  unsigned int v52; // r3
  unsigned int v53; // r2
  unsigned int v54; // r3
  _DWORD *v55; // r2
  int v56; // r3
  int v57; // r2
  _DWORD *v58; // r2
  int v59; // r1
  int v60; // r5
  size_t v61; // r6
  _DWORD *v62; // r0
  _DWORD *v63; // r7
  _DWORD *v64; // r0
  unsigned int v65; // r3
  _DWORD *v66; // r1
  _DWORD *v67; // r5
  unsigned int n; // r6
  _DWORD *v69; // r9
  int v70; // r6
  char *v71; // r8
  unsigned int v72; // r3
  int v73; // r3
  _DWORD *v74; // r3
  unsigned int v75; // r1
  unsigned int v76; // r2
  bool v77; // cc
  int v78; // r2
  int v79; // r3
  int v80; // r5
  char *v81; // r9
  _DWORD *v82; // r0
  const char *v83; // r2
  _DWORD *v84; // r3
  int v85; // r0
  int v86; // r1
  int v87; // r2
  int v88; // r3
  int v89; // r3
  int v90; // r4
  int v91; // r5
  int v92; // r9
  FILE *v93; // r4
  signed int v94; // r0
  char *v95; // r0
  const char *v96; // r1
  char *v97; // r4
  char *v98; // r0
  char *v99; // r4
  unsigned __int8 *v100; // r3
  unsigned __int8 *v101; // r3
  unsigned __int8 *v102; // r3
  size_t v103; // r0
  _BYTE *v104; // r1
  _BYTE *v105; // lr
  unsigned __int8 *v106; // r3
  int v107; // r2
  bool v108; // zf
  int v109; // r0
  bool v110; // zf
  int *__attribute__((__org_arrdim(0,2))) v111; // r12
  FILE *v112; // r0
  int v113; // r3
  int v114; // r3
  bool v115; // zf
  int *v116; // r6
  char *v117; // r9
  int v118; // r10
  FILE *v119; // r0
  int v120; // r3
  char *v121; // r6
  int v122; // r10
  char *v123; // r9
  char *v124; // r4
  FILE *v125; // r0
  int v126; // r3
  int *__attribute__((__org_arrdim(0,2))) v127; // r12
  int v128; // r5
  int v129; // r6
  pthread_rwlock_t *v130; // r0
  char *v131; // r7
  int v132; // r5
  char *v133; // r8
  unsigned int v134; // r6
  int v135; // r3
  int v136; // r3
  int *__attribute__((__org_arrdim(0,2))) v137; // r12
  int *__attribute__((__org_arrdim(0,2))) v138; // r12
  int *v139; // r3
  int v140; // r0
  int v141; // t1
  int *__attribute__((__org_arrdim(0,2))) v142; // r12
  int *__attribute__((__org_arrdim(0,2))) v143; // r12
  int v144; // r6
  char *v145; // r7
  int v146; // r9
  int v147; // r3
  const char *v148; // r10
  size_t v149; // r0
  size_t v150; // r4
  char *v151; // r0
  int *__attribute__((__org_arrdim(0,2))) v152; // r12
  int v153; // r2
  unsigned __int8 *v154; // r7
  __sighandler_t v155; // r8
  __sighandler_t v156; // r0
  bool v157; // zf
  __pid_t v158; // r0
  __pid_t v159; // r8
  int *__attribute__((__org_arrdim(0,2))) v160; // r12
  _DWORD *v161; // r0
  _DWORD *v162; // r7
  void *v163; // r0
  FILE *v164; // r0
  int v165; // r3
  int *__attribute__((__org_arrdim(0,2))) v166; // r12
  int *__attribute__((__org_arrdim(0,2))) v167; // r12
  int v168; // r3
  int v169; // r12
  int v170; // r1
  int v171; // r2
  void *v172; // r6
  int v173; // r6
  int v174; // r9
  int v175; // r8
  int v176; // r7
  _DWORD *v177; // r4
  int v178; // r6
  _DWORD *v179; // r0
  int v180; // r3
  sem_t *v181; // r0
  sem_t *v182; // r6
  char *v183; // r4
  int v184; // r3
  int *v185; // r1
  int v186; // r12
  int v187; // r0
  int j; // r1
  int v189; // lr
  int v190; // r6
  int v191; // r9
  const char *v192; // r1
  int v193; // r6
  int v194; // r12
  int v195; // r2
  int v196; // lr
  int v197; // r2
  int v198; // r3
  int v199; // r1
  int *__attribute__((__org_arrdim(0,2))) v200; // r12
  int *__attribute__((__org_arrdim(0,2))) v201; // r12
  int v202; // r7
  int v203; // r6
  int v204; // r3
  int v205; // r3
  char *v206; // r0
  int v207; // r0
  int v208; // r8
  int v209; // r0
  int v210; // r2
  int *v211; // lr
  int v212; // r0
  int v213; // r3
  int v214; // t1
  int v215; // r9
  int v216; // t1
  int v217; // r3
  int v218; // r9
  int v219; // r3
  int v220; // r3
  int v221; // r0
  int v222; // r1
  int v223; // r12
  int v224; // r0
  struct timeval *v225; // r6
  char *v226; // r9
  _DWORD *v227; // r3
  int *__attribute__((__org_arrdim(0,2))) v228; // r12
  int *__attribute__((__org_arrdim(0,2))) v229; // r12
  int *__attribute__((__org_arrdim(0,2))) v230; // r12
  int *v231; // r3
  int v232; // r1
  int v233; // t1
  int v234; // r9
  int v235; // r2
  int *v236; // lr
  int v237; // r0
  int v238; // r3
  int v239; // t1
  int v240; // r6
  int v241; // t1
  int v242; // r3
  int v243; // r6
  int v244; // r3
  int v245; // r3
  int v246; // r0
  int v247; // r1
  int v248; // r12
  int v249; // r0
  int v250; // r6
  _DWORD *v251; // r8
  char *v252; // r9
  char *v253; // lr
  int v254; // r1
  int v255; // r2
  int v256; // r3
  int v257; // r1
  int v258; // r2
  int v259; // r3
  int v260; // r3
  int *__attribute__((__org_arrdim(0,2))) v261; // r12
  char *v262; // r0
  int *__attribute__((__org_arrdim(0,2))) v263; // r12
  int *__attribute__((__org_arrdim(0,2))) v264; // r12
  int *__attribute__((__org_arrdim(0,2))) v265; // r12
  int *__attribute__((__org_arrdim(0,2))) v266; // r12
  int k; // r6
  int v268; // r3
  int v269; // r8
  char *v270; // r10
  char *v271; // r9
  int m; // r8
  int *__attribute__((__org_arrdim(0,2))) v273; // r12
  const char *v274; // r1
  int v275; // r2
  int *__attribute__((__org_arrdim(0,2))) v276; // r12
  int *__attribute__((__org_arrdim(0,2))) v277; // r12
  char v278; // [sp+10h] [bp-31FCh] BYREF
  char v279[500]; // [sp+1018h] [bp-21F4h] BYREF
  _BYTE v280[3588]; // [sp+120Ch] [bp-2000h] BYREF
  const char *v281; // [sp+2024h] [bp-11E8h]
  int *v282; // [sp+2028h] [bp-11E4h]
  void (**v283)(void); // [sp+202Ch] [bp-11E0h]
  char *v284; // [sp+2030h] [bp-11DCh]
  int *v285; // [sp+2034h] [bp-11D8h]
  char *v286; // [sp+2038h] [bp-11D4h]
  const char **v287; // [sp+203Ch] [bp-11D0h]
  char *v288; // [sp+2040h] [bp-11CCh]
  char *v289; // [sp+2044h] [bp-11C8h]
  int *v290; // [sp+2048h] [bp-11C4h]
  int v291; // [sp+204Ch] [bp-11C0h] BYREF
  struct sigaction v292; // [sp+2054h] [bp-11B8h] BYREF
  char v293[256]; // [sp+20E0h] [bp-112Ch] BYREF
  int v294[11]; // [sp+21E0h] [bp-102Ch] BYREF

  v287 = a2;
  v291 = a1;
  strcpy(dword_75B28, "cgminer.log");
  byte_75B20 = 0;
  strcpy(word_75C28, "a+");
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v4 = sched_yield;
    v5 = &off_72D18;
  }
  v7 = 4 * (v291 + 1);
  if ( v6 )
    *v5 = v4;
  v8 = malloc(v7);
  v9 = v291;
  v10 = v8;
  dword_740C8 = (int)v8;
  if ( v291 > 0 )
  {
    v11 = 0;
    v12 = 0;
    v13 = v287;
    do
    {
      ++v12;
      v14 = _strdup(v13[v11]);
      v9 = v291;
      v10[v11++] = v14;
    }
    while ( v9 > v12 );
  }
  v10[v9] = 0;
  sub_178C8(&stru_781AC, "main", 10680);
  sub_178C8(&stru_78684, "main", 10681);
  sub_178C8(&stru_785D0, "main", 10682);
  sub_17920((int)&stru_78838, "main", 10683);
  sub_178C8(&stru_77B74, "main", 10684);
  sub_178C8(&stru_73EF0, "main", 10685);
  sub_17920((int)&stru_78800, "main", 10686);
  sub_178C8(&mutex, "main", 10687);
  sub_178F4(&stru_740D0, "main", 10688);
  sub_178F4(&stru_78100, "main", 10689);
  sub_178F4(&rwlock, "main", 10690);
  sub_178F4(&stru_78528, "main", 10691);
  sub_178C8(&stru_73EA0, "main", 10693);
  if ( pthread_cond_init(&stru_73EB8, 0) )
  {
    strcpy((char *)v294, "Failed to pthread_cond_init lp_cond");
    sub_385C8(3, (const char *)v294, 1);
    sub_1D26C(1, 0);
  }
  sub_178C8(&stru_78454, "main", 10697);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v294, "Failed to pthread_cond_init restart_cond");
    sub_385C8(3, (const char *)v294, 1);
    sub_1D26C(1, 0);
  }
  if ( pthread_cond_init(&stru_77FC8, 0) )
  {
    strcpy((char *)v294, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2A0C0();
    dword_78448 = (int)v15;
    if ( v15 )
    {
      dword_73E6C = (int)(v15 + 12);
      snprintf(byte_73A2C, 0x100u, "%s %s", "cgminer", a49);
      v292.sa_flags = 0;
      v292.sa_handler = (__sighandler_t)sub_17894;
      sigemptyset(&v292.sa_mask);
      sigaction(15, &v292, &oact);
      sigaction(2, &v292, &stru_78774);
      signal(13, (__sighandler_t)1);
      dword_78A9C = (int)v279;
      strcpy(v279, "/usr/bin");
      dword_786DC = (int)&v278;
      v16 = _strdup(*v287);
      v17 = (char *)dword_786DC;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_786DC + strlen((const char *)dword_786DC)) = 47;
      dword_73E90 = 8;
      dword_73E84 = 9;
      dword_73E8C = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        v288 = (char *)v294;
        strcpy((char *)v294, "main OOM");
        sub_385C8(3, (const char *)v294, 1);
        sub_16BE0(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_740F0;
      v6 = dword_740F0 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_740F0 = (int)v20;
        v161 = malloc(0x2Cu);
        v162 = v161;
        *((_DWORD *)v20 + 17) = v161;
        if ( !v161 )
          goto LABEL_317;
        memset(v161, 0, 0x2Cu);
        v290 = (int *)(v20 + 68);
        v162[4] = v20 + 68;
        v162[1] = 32;
        v162[2] = 5;
        v162[5] = 68;
        v163 = malloc(0x180u);
        *v162 = v163;
        if ( !v163 )
          goto LABEL_317;
        memset(v163, 0, 0x180u);
        v24 = (int)v20;
        v162[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v290 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_22;
        case 0xAu:
          goto LABEL_21;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_21:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_22:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_23:
          v27 += v22[7] << 24;
LABEL_24:
          v27 += v22[6] << 16;
LABEL_25:
          v27 += v22[5] << 8;
LABEL_26:
          v27 += v22[4];
LABEL_27:
          v28 += v22[3] << 24;
LABEL_28:
          v28 += v22[2] << 16;
LABEL_29:
          v28 += v22[1] << 8;
LABEL_30:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = v290;
      v49 = (v45 - v46 - v47) ^ (v47 >> 13);
      v50 = (v46 - v47 - v49) ^ (v49 >> 12);
      v51 = (v47 - v49 - v50) ^ (v50 << 16);
      v52 = (v49 - v50 - v51) ^ (v51 >> 5);
      v53 = v50 - v51 - v52;
      v54 = (v52 - (v53 ^ (v52 >> 3)) - ((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)))
          ^ (((v51 - v52 - (v53 ^ (v52 >> 3))) ^ ((v53 ^ (v52 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v54;
      v55 = *(_DWORD **)(v24 + 68);
      v56 = 12 * (v54 & (v55[1] - 1));
      ++*(_DWORD *)(*v55 + v56 + 4);
      v57 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v57;
      v58 = *(_DWORD **)(v24 + 68);
      v59 = *(_DWORD *)(*v58 + v56);
      if ( v59 )
      {
        *(_DWORD *)(v59 + 12) = v290;
        v58 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v58 + v56) = v48;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v56 + 8)
                                                                          + 1))
        || (v60 = *((_DWORD *)v20 + 17), *(_DWORD *)(v60 + 36) == 1) )
      {
LABEL_56:
        strcpy(dest, v20);
        dword_78268 = (int)&dword_78268;
        dword_7826C = (int)&dword_78268;
        sub_58F70((int)&off_72440, (int)"Options for both config file and command line");
        sub_58F70((int)&off_72C64, (int)"Options for command line only");
        sub_5903C(&v291, v287, (void (*)(const char *, ...))sub_11B7C);
        if ( v291 != 1 )
        {
          strcpy((char *)v294, "Unexpected extra commandline arguments");
          sub_385C8(3, (const char *)v294, 1);
          sub_1D26C(1, 0);
        }
        v80 = (unsigned __int8)byte_73D58;
        if ( !byte_73D58 )
        {
          dword_73D5C = (int)malloc(0x1000u);
          sub_16088((char *)dword_73D5C);
          if ( access((const char *)dword_73D5C, 4) )
          {
            free((void *)dword_73D5C);
            dword_73D5C = v80;
          }
          else
          {
            sub_16CD0((char *)dword_73D5C);
          }
        }
        if ( byte_74149 || dword_73E34 )
        {
          if ( byte_78681 )
          {
            v288 = (char *)v294;
            strcpy((char *)v294, "Cannot use benchmark mode with scrypt");
            sub_385C8(3, (const char *)v294, 1);
            sub_16BE0(1);
          }
          v288 = (char *)v294;
          v81 = sub_17974();
          v82 = malloc(0xFFu);
          if ( dword_73E34 )
            v83 = "Benchfile";
          else
            v83 = "Benchmark";
          *((_DWORD *)v81 + 49) = v82;
          v84 = v82;
          v85 = *(_DWORD *)v83;
          v86 = *((_DWORD *)v83 + 1);
          v87 = *((_DWORD *)v83 + 2);
          *v84 = v85;
          v84[1] = v86;
          *((_WORD *)v84 + 4) = v87;
          v88 = *((_DWORD *)v81 + 49);
          *((_DWORD *)v81 + 51) = v88;
          *((_DWORD *)v81 + 52) = v88;
          *((_DWORD *)v81 + 50) = v88;
          *((_DWORD *)v81 + 156) = v88;
          strncpy(v81 + 48, "?", 7u);
          v89 = *((_DWORD *)v81 + 33);
          v81[55] = 0;
          if ( v89 != 1 )
          {
            *((_DWORD *)v81 + 33) = 1;
            ++dword_7840C;
          }
          v90 = 0;
          v81[129] = 0;
          byte_75AE8 = 1;
          do
          {
            v91 = 324 * v90;
            v92 = 5 * v90++;
            v92 *= 32;
            sub_29788(&byte_74158[v92], (unsigned __int8 *)&a000000029c6bf4[v91], 160);
            sub_29788(&byte_74B58[v92], (unsigned __int8 *)&a00000002c01f50[v91], 160);
          }
          while ( v90 != 16 );
          sub_1617C((int)dword_7556C);
        }
        else
        {
          v288 = (char *)v294;
        }
        if ( !dword_73A28 )
        {
          v99 = (char *)byte_75A08;
          v286 = &byte_77B70;
          goto LABEL_108;
        }
        v93 = fopen((const char *)dword_73A28, "rb");
        memset(v293, 0, sizeof(v293));
        if ( v93 )
        {
          v94 = fread(v293, 1u, 0x100u, v93);
          if ( v94 > 0 )
          {
            v95 = strchr(v293, 10);
            v96 = v293;
            v97 = v95;
            v6 = v95 == 0;
            v98 = s;
            if ( !v6 )
            {
              memcpy(s, v293, v97 - v293);
              v98 = byte_7568C;
              v96 = v97 + 1;
            }
            strcpy(v98, v96);
            v99 = (char *)byte_75A08;
            v100 = &byte_75A08[strlen(s) - 1];
            if ( *(v100 - 1148) == 10 )
              *(v100 - 1148) = 0;
            v101 = &byte_75A08[strlen(s) - 1];
            if ( *(v101 - 1148) == 13 )
              *(v101 - 1148) = 0;
            v102 = &byte_75A08[strlen(byte_7568C) - 1];
            if ( *(v102 - 892) == 10 )
              *(v102 - 892) = 0;
            v103 = strlen(byte_7568C) - 1;
            v106 = &byte_75A08[v103];
            v107 = byte_75A08[v103 - 892];
            v108 = v107 == 13;
            if ( v107 == 13 )
            {
              v104 = v280;
              v107 = 31600;
            }
            else
            {
              v105 = v280;
            }
            if ( v108 )
              HIWORD(v107) = 7;
            else
              v103 = 31600;
            if ( v108 )
            {
              *((_DWORD *)v104 + 907) = v107;
              LOBYTE(v107) = 0;
            }
            else
            {
              HIWORD(v103) = 7;
            }
            if ( v108 )
              *(v106 - 892) = v107;
            else
              *((_DWORD *)v105 + 907) = v103;
            goto LABEL_103;
          }
          v286 = &byte_77B70;
          if ( byte_77B70 || (v284 = &byte_75C48, byte_75C48) || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Read miner version file %s error %d", (const char *)dword_73A28, v94);
            goto LABEL_257;
          }
        }
        else
        {
          v286 = &byte_77B70;
          if ( byte_77B70 || (v284 = &byte_75C48, byte_75C48) || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Open miner version file %s error", (const char *)dword_73A28);
LABEL_257:
            v99 = (char *)byte_75A08;
            sub_385C8(3, v288, 0);
LABEL_103:
            if ( *v286 )
            {
LABEL_107:
              snprintf(v288, 0x1000u, "Miner compile time: %s type: %s", s, byte_7568C);
              sub_385C8(3, v288, 0);
              goto LABEL_108;
            }
            v284 = &byte_75C48;
            goto LABEL_105;
          }
        }
        v99 = (char *)byte_75A08;
LABEL_105:
        if ( *v284 || dword_73504 > 2 )
          goto LABEL_107;
LABEL_108:
        if ( dword_73A18 )
        {
          byte_75B20 = 1;
          strcpy(dword_75B28, (const char *)dword_73A18);
          if ( dword_73A24 )
            strcpy(word_75C28, (const char *)dword_73A24);
          if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 2) )
          {
            snprintf(v288, 0x1000u, "Log file path: %s Open flag: %s", dword_75B28, word_75C28);
            sub_385C8(3, v288, 0);
          }
        }
        if ( dword_73A20 )
        {
          memset(v293, 0, sizeof(v293));
          if ( dword_73A1C )
          {
            if ( !*(_BYTE *)dword_73A1C )
            {
              v160 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Log work asic num empty";
              strcpy((char *)v160 + 4, "work asic num empty");
              sub_385C8(3, v288, 1);
              sub_16BE0(1);
            }
            v109 = strtol((const char *)dword_73A1C, 0, 10);
            v110 = v109 == 32;
            if ( v109 != 32 )
              v110 = v109 == 1;
            dword_7578C = v109;
            if ( !v110 && v109 != 64 )
            {
              v111 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy((char *)v111 + 4, "work asic num must be 1, 32, 64");
              sub_385C8(3, v288, 1);
              sub_16BE0(1);
            }
            if ( *v286 || byte_75C48 || dword_73504 > 2 )
            {
              snprintf(
                v288,
                0x1000u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_73A20,
                (const char *)dword_73A1C);
              sub_385C8(3, v288, 0);
            }
          }
          else if ( *v286 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Log work path: %s", (const char *)dword_73A20);
            sub_385C8(3, v288, 0);
          }
          sprintf(v293, "%s.txt", (const char *)dword_73A20);
          v112 = fopen(v293, "a+");
          v113 = (unsigned __int8)*v286;
          dword_75790 = (int)v112;
          if ( v113 || byte_75C48 || dword_73504 > 2 )
          {
            snprintf(v288, 0x1000u, "Log work open file %s", v293);
            sub_385C8(3, v288, 0);
          }
          v114 = dword_7578C;
          if ( dword_7578C == 1 )
          {
            sprintf(v293, "%s%02d.txt", (const char *)dword_73A20, 1);
            v164 = fopen(v293, "a+");
            v165 = (unsigned __int8)*v286;
            dword_75794[0] = (int)v164;
            if ( v165 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 2) )
            {
              snprintf(v288, 0x1000u, "Log work open asic %d file %s", dword_7578C, v293);
              sub_385C8(3, v288, 0);
            }
          }
          else
          {
            v115 = dword_7578C == 32;
            if ( dword_7578C != 32 )
              v115 = dword_7578C == 64;
            if ( v115 && dword_7578C >= 0 )
            {
              v116 = &dword_75790;
              v117 = v288;
              v118 = 0;
              do
              {
                sprintf(v293, "%s%02d_%02d.txt", (const char *)dword_73A20, v114, v118);
                v119 = fopen(v293, "a+");
                v120 = (unsigned __int8)*v286;
                v116[1] = (int)v119;
                ++v116;
                if ( v120 || byte_75C48 || dword_73504 > 2 )
                {
                  snprintf(v117, 0x1000u, "Log work open asic %d file %s", dword_7578C, v293);
                  sub_385C8(3, v117, 0);
                }
                v114 = dword_7578C;
                ++v118;
              }
              while ( dword_7578C >= v118 );
            }
          }
          if ( byte_75898 )
          {
            v121 = &byte_75898;
            v122 = 0;
            v290 = (int *)byte_75A08;
            v123 = v288;
            v124 = v286;
            do
            {
              sprintf(v293, "%s_diff_%02d.txt", (const char *)dword_73A20, v122);
              v125 = fopen(v293, "a+");
              v126 = (unsigned __int8)*v124;
              *((_DWORD *)v121 + 1) = v125;
              v121 += 4;
              if ( v126 || byte_75C48 || dword_73504 > 2 )
              {
                snprintf(v123, 0x1000u, "Log work open diff file %s", v293);
                sub_385C8(3, v123, 0);
              }
              ++v122;
            }
            while ( v122 != 65 );
            v99 = (char *)v290;
          }
        }
        if ( byte_78940 )
        {
          v285 = dword_72430;
          byte_72C1C = 0;
        }
        else
        {
          v285 = dword_72430;
          if ( byte_72C1C )
            sub_27AF8();
        }
        if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
        {
          snprintf(v288, 0x1000u, "Started %s", byte_73A2C);
          sub_385C8(4, v288, 0);
        }
        if ( !dword_73D5C )
        {
LABEL_172:
          *(_WORD *)(dword_78A9C + strlen((const char *)dword_78A9C)) = 47;
          if ( byte_78680 )
            byte_75C48 = 1;
          if ( v285[512] < 0 )
          {
            if ( byte_78681 )
              v136 = 30;
            else
              v136 = 60;
            v285[512] = v136;
          }
          *((_DWORD *)v99 - 26) = 8;
          dword_77F24 = (int)calloc(8u, 0x40u);
          if ( !dword_77F24 )
          {
            v167 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Failed to calloc control_thr";
            strcpy((char *)v167 + 4, "ed to calloc control_thr");
            sub_385C8(3, v288, 1);
            sub_1D26C(1, 0);
          }
          v128 = 0;
          dword_759A4 = 0;
          v281 = (const char *)&unk_78550;
          sub_27C28((int)&unk_78550);
          sub_27C28((int)&unk_77AF0);
          sub_27C28((int)&unk_78600);
          sub_27C28((int)&unk_78270);
          sub_27C28((int)&unk_73908);
          sub_27C28((int)&unk_78AC8);
          sub_27C28((int)&unk_78300);
          sub_27C28((int)&unk_784A0);
          sub_27C28((int)&unk_78870);
          sub_27C28((int)&unk_77B90);
          sub_27C28((int)&unk_78998);
          sub_27C28((int)&unk_77C98);
          sub_27C28((int)&unk_78128);
          sub_27C28((int)&unk_78080);
          sub_27C28((int)&unk_77D98);
          sub_27C28((int)&unk_786E8);
          sub_27C28((int)&unk_77EA0);
          sub_27C28((int)&unk_77E18);
          sub_27C28((int)&unk_78388);
          sub_27C28((int)&unk_781C8);
          sub_27C28((int)&unk_77FF8);
          sub_27C28((int)&unk_78A18);
          sub_27C28((int)&unk_77D18);
          sub_27C28((int)&unk_77C10);
          (*((void (__fastcall **)(_DWORD))v281 + 3))(0);
          off_77AFC(0);
          off_7860C(0);
          off_7827C(0);
          off_73914();
          off_78AD4(0);
          off_7830C(0);
          off_784AC(0);
          off_7887C(0);
          off_77B9C(0);
          ((void (__fastcall *)(_DWORD))off_789A4)(0);
          off_77CA4(0);
          off_78134(0);
          off_7808C(0);
          off_77DA4(0);
          off_786F4(0);
          ((void (__fastcall *)(_DWORD))off_77EAC)(0);
          off_77E24(0);
          off_78394(0);
          off_781D4(0);
          off_78004(0);
          off_78A24(0);
          ((void (__fastcall *)(_DWORD))off_77D24)(0);
          off_77C1C(0);
          v129 = dword_78548;
          dword_78994 = 0;
          if ( dword_78548 > 0 )
          {
            v290 = &dword_78450;
            do
            {
              v130 = *(pthread_rwlock_t **)(dword_78450 + 4 * v128++);
              sub_27E68(v130);
              v129 = dword_78548;
            }
            while ( dword_78548 > v128 );
          }
          if ( !v129 )
          {
            v166 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy((char *)v166 + 4, "devices disabled, cannot mine!");
            sub_385C8(3, v288, 1);
            sub_1D26C(1, 0);
          }
          dword_73E94 = v129;
          if ( !dword_73D38 )
          {
            v290 = &dword_78450;
            sub_1AA68(&stru_78528, "load_temp_cutoffs", 1152);
            v168 = 0;
            v169 = *v290;
            v170 = dword_78548;
            while ( v168 < v170 )
            {
              v171 = *(_DWORD *)(v169 + 4 * v168++);
              if ( !*(_DWORD *)(v171 + 184) )
                *(_DWORD *)(v171 + 184) = 95;
            }
            sub_19B04(&stru_78528, "load_temp_cutoffs", 1158);
            goto LABEL_203;
          }
          v131 = strtok((char *)dword_73D38, ",");
          if ( v131 )
          {
            v132 = 0;
            v290 = &dword_78450;
            v133 = v288;
            do
            {
              if ( v132 >= dword_78548 )
              {
                strcpy(v133, "Too many values passed to set temp cutoff");
                sub_385C8(3, v133, 1);
                sub_16BE0(1);
              }
              v134 = strtol(v131, 0, 10);
              if ( v134 > 0xC8 )
              {
                strcpy(v133, "Invalid value passed to set temp cutoff");
                sub_385C8(3, v133, 1);
                sub_16BE0(1);
              }
              sub_1AA68(&stru_78528, "load_temp_cutoffs", 1145);
              v135 = *(_DWORD *)(dword_78450 + 4 * v132++);
              *(_DWORD *)(v135 + 184) = v134;
              sub_19B04(&stru_78528, "load_temp_cutoffs", 1147);
              v131 = strtok(0, ",");
            }
            while ( v131 );
            if ( v132 != 1 )
              goto LABEL_203;
          }
          else
          {
            v132 = 0;
            v134 = 0;
            v290 = &dword_78450;
          }
          sub_1AA68(&stru_78528, "load_temp_cutoffs", 1164);
          v197 = dword_78548;
          v198 = *v290;
          while ( v132 < v197 )
          {
            v199 = *(_DWORD *)(v198 + 4 * v132++);
            *(_DWORD *)(v199 + 184) = v134;
          }
          sub_19B04(&stru_78528, "load_temp_cutoffs", 1167);
LABEL_203:
          if ( dword_78548 > 0 )
          {
            v139 = (int *)*v290;
            v140 = *v290 + 4 * dword_78548;
            do
            {
              v141 = *v139++;
              *(_DWORD *)(v141 + 312) = 99999999;
            }
            while ( v139 != (int *)v140 );
          }
          if ( !byte_78768 )
          {
            dword_73E84 += dword_73E94;
            dword_73E8C = dword_73E84 + 1;
            sub_19730();
          }
          if ( !dword_77FC0 )
          {
            if ( *v286 || byte_75C48 || dword_73504 > 3 )
            {
              v142 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy((char *)v142 + 4, " to specify at least one pool server.");
              sub_385C8(4, v288, 0);
            }
            if ( !*((_BYTE *)v285 + 2028) || !sub_26C68(0) )
            {
              v143 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Pool setup failed";
              strcpy((char *)v143 + 4, " setup failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
          }
          if ( dword_77FC0 > 0 )
          {
            v144 = 0;
            v145 = v99;
            do
            {
              v146 = *(_DWORD *)(dword_78260 + 4 * v144);
              v147 = *(_DWORD *)(v146 + 200);
              *(_DWORD *)(v146 + 428) = 99999999;
              *(_DWORD *)(v146 + 464) = 99999999;
              if ( !v147 )
              {
                if ( !*(_DWORD *)(v146 + 208) )
                  *(_DWORD *)(v146 + 208) = calloc(1u, 1u);
                v148 = *(const char **)(v146 + 204);
                if ( !v148 )
                {
                  snprintf(
                    v288,
                    0x1000u,
                    "No login credentials supplied for pool %u %s",
                    v144,
                    *(const char **)(v146 + 196));
                  sub_385C8(3, v288, 1);
                  sub_1D26C(1, 0);
                }
                v149 = strlen(*(const char **)(v146 + 204));
                v281 = *(const char **)(v146 + 208);
                v150 = v149 + strlen(v281) + 2;
                v151 = (char *)malloc(v150);
                *(_DWORD *)(v146 + 200) = v151;
                if ( !v151 )
                {
                  v277 = (int *)v288;
                  *(_DWORD *)v288 = *(_DWORD *)"Failed to malloc userpass";
                  strcpy((char *)v277 + 4, "ed to malloc userpass");
                  sub_385C8(3, v288, 1);
                  sub_1D26C(1, 0);
                }
                snprintf(v151, v150, "%s:%s", v148, v281);
              }
              ++v144;
            }
            while ( dword_77FC0 > v144 );
            v99 = v145;
          }
          v153 = (unsigned __int8)*v286;
          dword_73E9C = *(_DWORD *)dword_78260;
          if ( v153 )
            openlog("cgminer", 1, 8);
          v154 = byte_75A08;
          if ( *((_DWORD *)v99 - 24) )
          {
            if ( pipe((int *)v288) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v294[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(*((_DWORD *)v288 + 1)) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v155 = signal(13, (__sighandler_t)1);
            v156 = signal(13, (__sighandler_t)1);
            v157 = (__sighandler_t)((char *)v156 + 1) == 0;
            if ( v156 != (__sighandler_t)-1 )
              v157 = (__sighandler_t)((char *)v155 + 1) == 0;
            if ( v157 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v158 = fork();
            v159 = v158;
            dword_740C4 = v158;
            if ( v158 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v158 )
            {
              if ( dup2(v294[0], 0) >= 0 )
              {
                close(v294[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_759A8, v159);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v294[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          v172 = calloc(dword_78994, 4u);
          if ( v172 )
            v154 = 0;
          dword_78408 = (int)v172;
          if ( !v172 )
          {
            v273 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy((char *)v273 + 4, "ed to calloc mining_thr");
            v274 = v288;
            goto LABEL_491;
          }
          while ( (int)v154 < dword_78994 )
          {
            v173 = dword_78408;
            *(_DWORD *)(v173 + 4 * (_DWORD)v154) = calloc(1u, 0x40u);
            v172 = *(void **)(dword_78408 + 4 * (_DWORD)v154);
            if ( !v172 )
            {
              snprintf(v288, 0x1000u, "Failed to calloc mining_thr[%d]", v154);
              v274 = v288;
LABEL_491:
              sub_385C8(3, v274, 1);
              sub_1D26C(1, (int)v172);
            }
            ++v154;
          }
          v174 = 0;
          v175 = 0;
          v289 = v99;
          while ( v175 < dword_78548 )
          {
            v176 = 0;
            v177 = *(_DWORD **)(*v290 + 4 * v175);
            v178 = v177[37];
            v179 = malloc(4 * (v178 + 1));
            v177[38] = v179;
            v179[v178] = 0;
            v180 = v177[37];
            v177[24] = 4;
            if ( v180 > 0 )
            {
              do
              {
                v181 = (sem_t *)sub_1AA90(v174);
                v181->__align = v174;
                v182 = v181;
                *(&v181[2].__align + 1) = (int)v177;
                *(&v181->__align + 1) = v176;
                if ( (*(int (**)(void))(v177[1] + 44))() )
                {
                  if ( sub_2EFE4((int)v182, 0, (void *(*)(void *))sub_11D5C, v182) )
                  {
                    snprintf(v288, 0x1000u, "thread %d create failed", v182->__align);
                    sub_385C8(3, v288, 1);
                    sub_1D26C(1, 0);
                  }
                  *(_DWORD *)(v177[38] + 4 * v176) = v182;
                  if ( v177[8] != 1 )
                  {
                    if ( byte_75C49 && (*v286 || byte_75C48 || dword_73504 > 6) )
                    {
                      snprintf(v288, 0x1000u, "Pushing sem post to thread %d", v182->__align);
                      sub_385C8(7, v288, 0);
                    }
                    sub_2F02C(v182 + 1, "cgminer.c", "main", 11085);
                  }
                }
                ++v176;
                ++v174;
              }
              while ( v177[37] > v176 );
            }
            ++v175;
          }
          v183 = v289;
          if ( byte_74149 || (v184 = dword_73E34) != 0 )
          {
LABEL_304:
            v185 = (int *)dbl_73F18;
            dbl_77AE8 = 0.0;
            do
            {
              *(_QWORD *)v185 = 0;
              v185 += 2;
            }
            while ( v185 != &dword_73F78 );
            v186 = dword_78548;
            dword_73F78 = 0;
            v187 = *v290;
            for ( j = 0; j < v186; ++j )
            {
              v189 = *(_DWORD *)(v187 + 4 * j);
              *(_QWORD *)(v189 + 80) = 0;
              *(_QWORD *)(v189 + 48) = 0;
            }
            sub_2A7A4((struct timeval *)&dword_73F08);
            sub_2A7A4((struct timeval *)&dword_73F80);
            sub_2A7A4((struct timeval *)dword_73F10);
            sub_1519C(byte_74098, 0x28u, &dword_73F08);
            v190 = dword_77F24;
            dword_73EE8 = 2;
            if ( sub_2EFE4(dword_77F24 + 128, 0, (void *(*)(void *))sub_21798, 0) )
            {
              v265 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"watchpool thread create failed";
              strcpy((char *)v265 + 4, "hpool thread create failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
            pthread_detach(*(_DWORD *)(v190 + 140));
            dword_73EEC = 3;
            v281 = (const char *)dword_77F24;
            if ( sub_2EFE4(dword_77F24 + 192, 0, (void *(*)(void *))sub_2328C, 0) )
            {
              v200 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"watchdog thread create failed";
              strcpy((char *)v200 + 4, "hdog thread create failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
            pthread_detach(*((_DWORD *)v281 + 51));
            dword_73D30 = 5;
            if ( sub_2EFE4(dword_77F24 + 320, 0, (void *(*)(void *))sub_1209C, (void *)(dword_77F24 + 320)) )
            {
              v264 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"API thread create failed";
              strcpy((char *)v264 + 4, "thread create failed");
              v192 = v288;
LABEL_316:
              sub_385C8(3, v192, 1);
              sub_1D26C(1, 0);
            }
            v191 = dword_77F24;
            *((_DWORD *)v183 - 23) = 7;
            if ( sub_2EFE4(v191 + 448, 0, (void *(*)(void *))sub_279F0, (void *)(v191 + 448)) )
            {
              v263 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"input thread create failed";
              strcpy((char *)v263 + 4, "t thread create failed");
              sub_385C8(3, v288, 1);
              sub_1D26C(1, 0);
            }
            pthread_detach(*(_DWORD *)(v191 + 460));
            if ( dword_759A0 != 8 )
            {
              snprintf(v288, 0x1000u, "incorrect total_control_threads (%d) should be 8", dword_759A0);
              v192 = v288;
              goto LABEL_316;
            }
            if ( nice(-10) )
            {
              v284 = &byte_75C48;
              v282 = &dword_73504;
              v287 = (const char **)&byte_75C49;
            }
            else
            {
              v287 = (const char **)&byte_75C49;
              if ( byte_75C49 )
              {
                if ( *v286 )
                {
                  v284 = &byte_75C48;
                  v282 = &dword_73504;
                }
                else
                {
                  v284 = &byte_75C48;
                  if ( byte_75C48 )
                  {
                    v282 = &dword_73504;
                  }
                  else
                  {
                    v282 = &dword_73504;
                    if ( dword_73504 <= 6 )
                      goto LABEL_338;
                  }
                }
                v201 = (int *)v288;
                *(_DWORD *)v288 = *(_DWORD *)"Unable to set thread to high priority";
                strcpy((char *)v201 + 4, "le to set thread to high priority");
                sub_385C8(7, v288, 0);
              }
              else
              {
                v284 = &byte_75C48;
                v282 = &dword_73504;
              }
            }
LABEL_338:
            v289 = 0;
            v283 = (void (**)(void))&off_72D18;
            while ( 1 )
            {
              while ( 1 )
              {
                v202 = v285[505];
                if ( byte_786D4 )
                {
                  if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                  {
                    v230 = (int *)v288;
                    *(_DWORD *)v288 = *(_DWORD *)"Work update message received";
                    strcpy((char *)v230 + 4, " update message received");
                    sub_385C8(7, v288, 0);
                  }
                  sub_2A7A4(&stru_73D44);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B5E4("signal_work_update", 5314);
                  if ( dword_78994 > 0 )
                  {
                    v231 = (int *)dword_78408;
                    v232 = dword_78408 + 4 * dword_78994;
                    do
                    {
                      v233 = *v231++;
                      *(_BYTE *)(v233 + 63) = 1;
                    }
                    while ( v231 != (int *)v232 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B578("signal_work_update", 5317);
                  (*v283)();
                }
                byte_786D4 = 0;
                sub_1D9A0();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_73E6C) )
                  sub_B35C("main", 11222);
                v203 = dword_73E74;
                if ( dword_73E74 )
                  v203 = *(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 12);
                if ( v202 < v203 )
                {
                  if ( byte_73E79 )
                  {
                    v204 = v285[505];
                    if ( v204 < v285[506] )
                    {
                      dword_72C14 = v204 + 1;
                      byte_73E79 = 0;
                    }
                  }
                  byte_73E78 = 1;
                  pthread_cond_wait(&stru_77FC8, (pthread_mutex_t *)dword_73E6C);
                  v203 = dword_73E74;
                  if ( dword_73E74 )
                    v203 = *(_DWORD *)(*(_DWORD *)(dword_73E74 + 1832) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_73E6C) )
                  sub_B50C("main", 11240);
                (*v283)();
                if ( v203 <= v202 )
                  break;
                if ( byte_73E79 )
                {
                  v205 = v285[505];
                  if ( v205 < v285[506] )
                  {
                    dword_72C14 = v205 + 1;
                    byte_73E79 = 0;
                  }
                }
                byte_73E78 = 1;
                v206 = (char *)sub_18D24(0);
                v289 = v206;
                if ( v206 )
                {
                  sub_158EC((int)v206);
                  v289 = 0;
                }
              }
              if ( v289 )
                sub_158EC((int)v289);
              v289 = (char *)sub_1A520();
              v207 = sub_1D9A0();
              v208 = v207;
              if ( dword_73D34 == 4 )
              {
                v208 = sub_12188(v207);
              }
              else if ( dword_73D34 == 3 )
              {
                v235 = dword_77FC0;
                if ( dword_77FC0 <= 0 )
                  goto LABEL_440;
                if ( *(_DWORD *)(*(_DWORD *)dword_78260 + 60) <= *(_DWORD *)(*(_DWORD *)dword_78260 + 64) )
                {
                  v236 = (int *)dword_78260;
                  v237 = dword_78260;
                  v238 = 0;
                  while ( ++v238 != dword_77FC0 )
                  {
                    v239 = *(_DWORD *)(v237 + 4);
                    v237 += 4;
                    if ( *(_DWORD *)(v239 + 64) < *(_DWORD *)(v239 + 60) )
                      goto LABEL_442;
                  }
                  v240 = dword_78260 + 4 * dword_77FC0;
                  do
                  {
                    v241 = *v236++;
                    *(_DWORD *)(v241 + 64) = 0;
                  }
                  while ( v236 != (int *)v240 );
LABEL_440:
                  v242 = *((_DWORD *)v183 - 22) + 1;
                  *((_DWORD *)v183 - 22) = v242;
                  if ( v242 >= v235 )
                    dword_759B0 = 0;
                }
LABEL_442:
                v243 = 0;
                while ( 1 )
                {
                  v77 = v243++ < v235;
                  if ( !v77 )
                    break;
                  v245 = *((_DWORD *)v183 - 22);
                  v246 = *(_DWORD *)(dword_78260 + 4 * v245);
                  v247 = *(_DWORD *)(v246 + 64);
                  v248 = *(_DWORD *)(v246 + 60);
                  *(_DWORD *)(v246 + 64) = v247 + 1;
                  if ( v247 < v248 )
                  {
                    if ( !*(_BYTE *)(v246 + 129)
                      && *(_DWORD *)(v246 + 132) == 1
                      && (!*(_BYTE *)(v246 + 664) || *(_BYTE *)(v246 + 665)) )
                    {
                      goto LABEL_454;
                    }
                    if ( byte_7844D )
                    {
                      v249 = sub_11F70(0);
                      v245 = *((_DWORD *)v183 - 22);
                      v235 = dword_77FC0;
                      --*(_DWORD *)(v249 + 64);
                    }
                  }
                  v244 = v245 + 1;
                  *((_DWORD *)v183 - 22) = v244;
                  if ( v244 >= v235 )
                    dword_759B0 = 0;
                }
                if ( v235 > 0 )
                {
                  v250 = 0;
                  while ( 1 )
                  {
                    v246 = sub_11F70(v250);
                    if ( !*(_BYTE *)(v246 + 129) && *(_DWORD *)(v246 + 132) == 1 )
                      break;
                    if ( ++v250 >= dword_77FC0 )
                      goto LABEL_360;
                  }
LABEL_454:
                  v208 = v246;
                }
              }
LABEL_360:
              if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
              {
                snprintf(v288, 0x1000u, "Selecting pool %d for work", *(_DWORD *)v208);
                sub_385C8(7, v288, 0);
              }
              if ( *(_BYTE *)(v208 + 664) )
              {
                while ( !*(_BYTE *)(v208 + 665) || !*(_BYTE *)(v208 + 667) )
                {
                  v209 = sub_1D9A0();
                  v290 = (int *)v209;
                  if ( dword_73D34 == 4 )
                  {
                    v290 = (int *)sub_12188(v209);
                  }
                  else if ( dword_73D34 == 3 || !byte_7844D )
                  {
                    v210 = dword_77FC0;
                    if ( dword_77FC0 <= 0 )
                      goto LABEL_379;
                    if ( *(_DWORD *)(*(_DWORD *)dword_78260 + 60) <= *(_DWORD *)(*(_DWORD *)dword_78260 + 64) )
                    {
                      v211 = (int *)dword_78260;
                      v212 = dword_78260;
                      v213 = 0;
                      while ( ++v213 != dword_77FC0 )
                      {
                        v214 = *(_DWORD *)(v212 + 4);
                        v212 += 4;
                        if ( *(_DWORD *)(v214 + 64) < *(_DWORD *)(v214 + 60) )
                          goto LABEL_381;
                      }
                      v215 = dword_78260 + 4 * dword_77FC0;
                      do
                      {
                        v216 = *v211++;
                        *(_DWORD *)(v216 + 64) = 0;
                      }
                      while ( v211 != (int *)v215 );
LABEL_379:
                      v217 = *((_DWORD *)v183 - 22) + 1;
                      *((_DWORD *)v183 - 22) = v217;
                      if ( v217 >= v210 )
                        dword_759B0 = 0;
                    }
LABEL_381:
                    v218 = 0;
                    while ( 1 )
                    {
                      v77 = v218++ < v210;
                      if ( !v77 )
                        break;
                      v220 = *((_DWORD *)v183 - 22);
                      v221 = *(_DWORD *)(dword_78260 + 4 * v220);
                      v222 = *(_DWORD *)(v221 + 64);
                      v223 = *(_DWORD *)(v221 + 60);
                      *(_DWORD *)(v221 + 64) = v222 + 1;
                      if ( v222 < v223 )
                      {
                        if ( !*(_BYTE *)(v221 + 129)
                          && *(_DWORD *)(v221 + 132) == 1
                          && (!*(_BYTE *)(v221 + 664) || *(_BYTE *)(v221 + 665)) )
                        {
                          goto LABEL_393;
                        }
                        if ( byte_7844D )
                        {
                          v224 = sub_11F70(0);
                          v220 = *((_DWORD *)v183 - 22);
                          v210 = dword_77FC0;
                          --*(_DWORD *)(v224 + 64);
                        }
                      }
                      v219 = v220 + 1;
                      *((_DWORD *)v183 - 22) = v219;
                      if ( v219 >= v210 )
                        dword_759B0 = 0;
                    }
                    if ( v210 > 0 )
                    {
                      v234 = 0;
                      while ( 1 )
                      {
                        v221 = sub_11F70(v234);
                        if ( !*(_BYTE *)(v221 + 129) && *(_DWORD *)(v221 + 132) == 1 )
                          break;
                        if ( ++v234 >= dword_77FC0 )
                          goto LABEL_394;
                      }
LABEL_393:
                      v290 = (int *)v221;
                    }
                  }
LABEL_394:
                  if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                  {
                    snprintf(v288, 0x1000u, "Selecting pool %d for work", *v290);
                    sub_385C8(7, v288, 0);
                  }
                  sub_2A884();
                  if ( (int *)v208 != v290 )
                  {
                    v208 = (int)v290;
                    if ( !*((_BYTE *)v290 + 664) )
                      goto LABEL_401;
                  }
                }
                sub_1D5F0(v208, (int)v289);
                if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                {
                  v229 = (int *)v288;
                  *(_DWORD *)v288 = *(_DWORD *)"Generated stratum work";
                  strcpy((char *)v229 + 4, "rated stratum work");
                  sub_385C8(7, v288, 0);
                }
LABEL_468:
                v262 = v289;
                v289 = 0;
                sub_1F0C4((int)v262);
              }
              else
              {
LABEL_401:
                if ( dword_73E34 )
                {
                  v225 = (struct timeval *)(v289 + 1888);
                  v226 = v289;
                  sub_1718C(v289);
                  v227 = (_DWORD *)dword_78260;
                  v226[1770] = 1;
                  *((_DWORD *)v226 + 437) = *v227;
                  sub_2A7A4(v225);
                  sub_2A488(&v225[1].tv_sec, v225);
                  v226[1928] = 66;
                  sub_11994((int)v289);
                  if ( *(_BYTE *)v287 && (*v286 || *v284 || *v282 > 6) )
                  {
                    v228 = (int *)v288;
                    *(_DWORD *)v288 = *(_DWORD *)"Generated benchfile work";
                    strcpy((char *)v228 + 4, "rated benchfile work");
                    sub_385C8(7, v288, 0);
                  }
                  goto LABEL_468;
                }
                if ( byte_74149 )
                {
                  v251 = (_DWORD *)dword_78260;
                  v252 = v289;
                  v253 = v289 + 160;
                  *((_QWORD *)v289 + 233) = 0x4040000000000000LL;
                  v254 = dword_7556C[1];
                  v255 = dword_7556C[2];
                  v256 = dword_7556C[3];
                  *((_DWORD *)v252 + 40) = dword_7556C[0];
                  *((_DWORD *)v253 + 1) = v254;
                  *((_DWORD *)v253 + 2) = v255;
                  *((_DWORD *)v253 + 3) = v256;
                  v257 = unk_75580;
                  v258 = unk_75584;
                  v259 = unk_75588;
                  *((_DWORD *)v253 + 4) = unk_7557C;
                  *((_DWORD *)v253 + 5) = v257;
                  *((_DWORD *)v253 + 6) = v258;
                  *((_DWORD *)v253 + 7) = v259;
                  *((_DWORD *)v252 + 433) = 0;
                  v252[1770] = 1;
                  *((_DWORD *)v252 + 437) = *v251;
                  sub_2A7A4((struct timeval *)v252 + 236);
                  sub_2A488((_DWORD *)v252 + 474, (_DWORD *)v252 + 472);
                  v260 = *(unsigned __int8 *)v287;
                  v289[1928] = 66;
                  if ( v260 && (*v286 || *v284 || *v282 > 6) )
                  {
                    v261 = (int *)v288;
                    *(_DWORD *)v288 = *(_DWORD *)"Generated benchmark work";
                    strcpy((char *)v261 + 4, "rated benchmark work");
                    sub_385C8(7, v288, 0);
                  }
                  goto LABEL_468;
                }
              }
            }
          }
          v193 = dword_78260;
          v194 = dword_77FC0;
          while ( v184 < v194 )
          {
            v195 = *(_DWORD *)(v193 + 4 * v184++);
            v196 = *(_DWORD *)(v195 + 132);
            *(_BYTE *)(v195 + 129) = 1;
            if ( v196 != 1 )
            {
              *(_DWORD *)(v195 + 132) = 1;
              ++dword_7840C;
            }
          }
          v287 = (const char **)&byte_75C49;
          if ( byte_75C49 )
          {
            if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 6) )
            {
              v266 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Probing for an alive pool";
              strcpy((char *)v266 + 4, "ing for an alive pool");
              sub_385C8(7, v288, 0);
            }
          }
          for ( k = 0; k < dword_77FC0; ++k )
          {
            v268 = *(_DWORD *)(dword_78260 + 4 * k);
            *(_BYTE *)(v268 + 316) = 1;
            pthread_create((pthread_t *)(v268 + 312), 0, (void *(*)(void *))start_routine, (void *)v268);
          }
          v269 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_74148 )
              break;
            if ( !--v269 )
              goto LABEL_496;
          }
          v269 = 0;
LABEL_496:
          v270 = v288;
          v271 = v286;
          while ( 1 )
          {
            if ( byte_74148 )
              goto LABEL_304;
            if ( !v269 )
            {
              if ( ((*v271 || byte_75C48 || dword_73504 > 2)
                 && ((strcpy(v270, "No servers were found that could be used to get work from."),
                      sub_385C8(3, v270, 0),
                      *v271)
                  || byte_75C48)
                 || dword_73504 > 2)
                && ((strcpy(v270, "Please check the details from the list below of the servers you have input"),
                     sub_385C8(3, v270, 0),
                     *v271)
                 || byte_75C48)
                || dword_73504 > 2 )
              {
                strcpy(
                  v270,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_385C8(3, v270, 0);
              }
              for ( m = 0; m < dword_77FC0; ++m )
              {
                if ( *v271 || byte_75C48 || dword_73504 > 3 )
                {
                  snprintf(
                    v270,
                    0x1000u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    m,
                    *(const char **)(*(_DWORD *)(dword_78260 + 4 * m) + 196),
                    *(const char **)(*(_DWORD *)(dword_78260 + 4 * m) + 204),
                    *(const char **)(*(_DWORD *)(dword_78260 + 4 * m) + 208));
                  sub_385C8(4, v270, 0);
                }
              }
              if ( !*((_BYTE *)v285 + 2028) )
              {
LABEL_530:
                v276 = (int *)v288;
                *(_DWORD *)v288 = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy((char *)v276 + 4, "ervers could be used! Exiting.");
                sub_385C8(3, v288, 1);
                sub_1D26C(0, 0);
              }
              if ( !*v271 && !byte_75C48 && dword_73504 <= 2 )
              {
                v269 = 1;
                goto LABEL_524;
              }
              v269 = 1;
              strcpy(v270, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_385C8(3, v270, 0);
            }
            if ( !*((_BYTE *)v285 + 2028) )
              goto LABEL_530;
LABEL_524:
            if ( dword_78258 )
              v275 = *(__int16 *)(dword_78258 + 4);
            else
              v275 = -1;
            v281 = (const char *)&dword_78258;
            if ( dword_78258 )
              ++v275;
            wtouchln((WINDOW *)dword_78258, 0, v275, 1);
            wrefresh(*(WINDOW **)v281);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_530;
            cbreak();
          }
        }
        v287 = (const char **)&byte_75C49;
        if ( byte_75C49 && (*v286 || byte_75C48 || dword_73504 > 6) )
        {
          snprintf(v288, 0x1000u, "Loaded configuration file %s", (const char *)dword_73D5C);
          sub_385C8(7, v288, 0);
        }
        if ( dword_73E2C == -1 )
        {
          if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
          {
            v137 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy((char *)v137 + 4, "r in configuration file, partially loaded.");
            sub_385C8(4, v288, 0);
          }
          if ( *((_BYTE *)v285 + 2028) )
          {
            if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
            {
              v138 = (int *)v288;
              *(_DWORD *)v288 = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
              strcpy((char *)v138 + 4, "t cgminer with -T to see what failed to load.");
              sub_385C8(4, v288, 0);
            }
          }
          goto LABEL_171;
        }
        if ( !dword_73E2C )
        {
          if ( *v286 || byte_75C48 || (v282 = &dword_73504, dword_73504 > 3) )
          {
            v152 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy((char *)v152 + 4, "l JSON error in configuration file.");
            sub_385C8(4, v288, 0);
            if ( *v286 || byte_75C48 )
              goto LABEL_170;
            v282 = &dword_73504;
          }
          if ( *v282 > 3 )
          {
LABEL_170:
            v127 = (int *)v288;
            *(_DWORD *)v288 = *(_DWORD *)"Configuration file could not be used.";
            strcpy((char *)v127 + 4, "iguration file could not be used.");
            sub_385C8(4, v288, 0);
          }
        }
LABEL_171:
        free((void *)dword_73D5C);
        dword_73D5C = 0;
        goto LABEL_172;
      }
      v61 = 24 * *(_DWORD *)(v60 + 4);
      v62 = malloc(v61);
      v63 = v62;
      if ( v62 )
      {
        memset(v62, 0, v61);
        *(_DWORD *)(v60 + 24) = (((2 * *(_DWORD *)(v60 + 4) - 1) & *(_DWORD *)(v60 + 12)) != 0)
                              + (*(_DWORD *)(v60 + 12) >> (*(_BYTE *)(v60 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v64 = (_DWORD *)*((_DWORD *)v20 + 17);
        v65 = v64[1];
        v66 = v64;
        if ( v65 )
        {
          v290 = 0;
          v289 = 0;
          do
          {
            v67 = *(_DWORD **)((char *)v290 + *v64);
            if ( v67 )
            {
              for ( n = v65; ; n = v66[1] )
              {
                v69 = (_DWORD *)v67[4];
                v70 = 3 * ((2 * n - 1) & v67[7]);
                v71 = (char *)&v63[v70];
                v72 = *((_DWORD *)v71 + 1) + 1;
                *((_DWORD *)v71 + 1) = v72;
                if ( v72 > v66[6] )
                {
                  ++v66[7];
                  *((_DWORD *)v71 + 2) = *((_DWORD *)v71 + 1) / *(_DWORD *)(*((_DWORD *)v20 + 17) + 24);
                }
                v67[3] = 0;
                v67[4] = v63[v70];
                v73 = v63[v70];
                if ( v73 )
                  *(_DWORD *)(v73 + 12) = v67;
                v63[v70] = v67;
                if ( !v69 )
                  break;
                v66 = (_DWORD *)*((_DWORD *)v20 + 17);
                v67 = v69;
              }
              v64 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v64[1];
            ++v289;
            v66 = v64;
            v290 += 3;
          }
          while ( v65 > (unsigned int)v289 );
        }
        free((void *)*v64);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v63;
        v74 = (_DWORD *)*((_DWORD *)v20 + 17);
        v75 = v74[3];
        v76 = v74[7];
        v77 = v76 > v75 >> 1;
        if ( v76 <= v75 >> 1 )
          v78 = 0;
        else
          v78 = v74[8];
        if ( v77 )
          ++v78;
        v74[8] = v78;
        v79 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v79 + 32) > 1u )
          *(_DWORD *)(v79 + 36) = 1;
        goto LABEL_56;
      }
LABEL_317:
      exit(-1);
    }
    strcpy((char *)v294, "Failed to create getq");
  }
  sub_385C8(3, (const char *)v294, 1);
  sub_1D26C(1, 0);
}
