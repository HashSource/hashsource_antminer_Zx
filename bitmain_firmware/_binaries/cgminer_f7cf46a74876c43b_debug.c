/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_11F00();
int j_pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// FILE *fdopen(int fd, const char *modes);
// void *calloc(size_t nmemb, size_t size);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int sem_wait(sem_t *sem);
// void _pthread_register_cancel(__pthread_unwind_buf_t *buf);
int __fastcall sub_11F78(const char *s1, const char *s2); // idb
// int strcmp(const char *s1, const char *s2);
// int strtol(const char *nptr, char **endptr, int base);
// int sem_post(sem_t *sem);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strcspn(const char *s, const char *reject);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int fflush(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
void __fastcall sub_12000(void *ptr); // idb
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_detach(pthread_t th);
// int nanosleep(const struct timespec *requested_time, struct timespec *remaining);
// int inet_pton(int af, const char *cp, void *buf);
// pthread_t pthread_self(void);
void *__fastcall sub_12058(void *dest, const void *src, size_t n); // idb
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// time_t time(time_t *timer);
// int pthread_mutex_trylock(pthread_mutex_t *mutex);
int j_memcmp(const void *s1, const void *s2, size_t n);
// int memcmp(const void *s1, const void *s2, size_t n);
// int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// unsigned int sleep(unsigned int seconds);
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_setcancelstate(int state, int *oldstate);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int sysconf(int name);
// int dup2(int fd, int fd2);
// void *realloc(void *ptr, size_t size);
// int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *req, struct timespec *rem);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int strcasecmp(const char *s1, const char *s2);
// void perror(const char *s);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int sigaction_0(int sig, const struct sigaction *act, struct sigaction *oact);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
char *j_strcpy(char *dest, const char *src);
// char *strcpy(char *dest, const char *src);
int j_gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int sched_yield(void);
int j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// double floor(double x);
// int __fastcall strtof(_DWORD, _DWORD); weak
// char *getenv(const char *name);
// int puts(const char *s);
// void *malloc(size_t size);
// int settimeofday(const struct timeval *tv, const struct timezone *tz);
// double log10(double x);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
int j_system(const char *command);
// int system(const char *command);
// struct tm *localtime(const time_t *timer);
// const __int32_t **_ctype_tolower_loc(void);
// char *dirname(char *path);
// const __int32_t **_ctype_toupper_loc(void);
// int _gmon_start__(void); weak
// int sem_trywait(sem_t *sem);
// int open(const char *file, int oflag, ...);
// int kill(__pid_t pid, int sig);
// const unsigned __int16 **_ctype_b_loc(void);
// void exit(int status);
// int sem_timedwait(sem_t *sem, const struct timespec *abstime);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int round(void); weak
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// void srand(unsigned int seed);
// int pthread_setcanceltype(int type, int *oldtype);
// int nice(int inc);
// int fprintf(FILE *stream, const char *format, ...);
// __int64 llround(void); weak
int j_fcntl(int fd, int cmd, ...);
// int fcntl(int fd, int cmd, ...);
// int execv(const char *path, char *const argv[]);
// int pthread_attr_init(pthread_attr_t *attr);
// int *_errno_location(void);
// int strncasecmp(const char *s1, const char *s2, size_t n);
int j_snprintf(char *s, size_t maxlen, const char *format, ...);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
char *j___strdup(const char *s);
// char *_strdup(const char *s);
// int mkdir(const char *path, __mode_t mode);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sem_init(sem_t *sem, int pshared, unsigned int value);
void *j_memset(void *s, int c, size_t n);
// void *memset(void *s, int c, size_t n);
// void _pthread_unregister_cancel(__pthread_unwind_buf_t *buf);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
char *j_strncpy(char *dest, const char *src, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int pthread_cancel(pthread_t th);
// int fscanf(FILE *stream, const char *format, ...);
// int fgetc(FILE *stream);
// int prctl(int option, ...);
// double strtod(const char *nptr, char **endptr);
// int fileno(FILE *stream);
// void _pthread_unwind_next(__pthread_unwind_buf_t *buf);
// int access(const char *name, int type);
// int rand(void);
// int fclose(FILE *stream);
// int pipe(int pipedes[2]);
// int munmap(void *addr, size_t len);
// char *strtok(char *s, const char *delim);
// int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int shutdown(int fd, int how);
// int sigemptyset(sigset_t *set);
// int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
// __pid_t fork(void);
// void errx(int status, const char *format, ...);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// int execl(const char *path, const char *arg, ...);
// int listen(int fd, int n);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int pthread_join(pthread_t th, void **thread_return);
// int _sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int fputc(int c, FILE *stream);
void j_syslog(int pri, const char *fmt, ...);
// void syslog(int pri, const char *fmt, ...);
// int sscanf(const char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// void openlog(const char *ident, int option, int facility);
// double exp(double x);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *strpbrk(const char *s, const char *accept);
// int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// void freeaddrinfo(struct addrinfo *ai);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int socket(int domain, int type, int protocol);
int j_clock_gettime(clockid_t clock_id, struct timespec *tp);
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// in_addr_t inet_addr(const char *cp);
// void pthread_testcancel(void);
// int fseek(FILE *stream, int off, int whence);
// char *strncat(char *dest, const char *src, size_t n);
int j_sem_destroy(sem_t *sem);
// int sem_destroy(sem_t *sem);
// int isatty(int fd);
// int fputs(const char *s, FILE *stream);
// int strncmp(const char *s1, const char *s2, size_t n);
// int pthread_cond_signal(pthread_cond_t *cond);
// void abort(void);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
int j_close(int fd);
// int close(int fd);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
int __fastcall main(int argc, const char **argv, const char **envp);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...);
int call_weak_fn();
int deregister_tm_clones();
int register_tm_clones();
int _do_global_dtors_aux();
char *__fastcall set_balance(pool_strategy *strategy);
char *__fastcall set_loadbalance(pool_strategy *strategy);
char *__fastcall set_rr(pool_strategy *strategy);
char *__fastcall enable_debug(bool *flag);
char *__fastcall set_null(const char *arg);
void __fastcall noop_reinit_device(cgpu_info *cgpu);
void __fastcall blank_get_statline_before(char *buf, size_t bufsiz, cgpu_info *cgpu);
bool __fastcall noop_get_stats(cgpu_info *cgpu);
uint64_t __fastcall noop_can_limit_work(thr_info *thr);
bool __fastcall noop_prepare_work(thr_info *thr, work *work);
void __fastcall noop_detect(bool hotplug);
api_data *__fastcall noop_get_api_stats(cgpu_info *cgpu);
void __fastcall SHA256_Transform(uint32_t *state, const uint32_t *block, int swap);
void __fastcall benchfile_dspwork(work *work, uint32_t nonce);
void __fastcall suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits);
char *__fastcall set_logfile_path(const char *arg);
char *__fastcall set_logwork_asicnum(const char *arg);
char *__fastcall set_logwork_path(const char *arg);
char *__fastcall set_logfile_openflag(const char *arg);
char *__fastcall set_version_path(const char *arg);
char *__fastcall set_default_config(const char *arg);
char *__fastcall set_sharelog(char *arg);
char *__fastcall json_escape(char *str);
void __fastcall thread_reportout(thr_info *thr);
void __fastcall thread_reportin(thr_info *thr);
void __fastcall regen_hash(work *work);
void *__fastcall submit_work_thread(void *userdata);
void *__fastcall miner_thread(void *userdata);
void *__fastcall killall_thread(void *arg);
void __fastcall calc_diff(work *work, double known); // idb
void __noreturn applog_and_exit(const char *a1, ...);
void __fastcall __noreturn opt_verusage_and_exit(const char *a1);
void __fastcall enable_pool(pool *pool); // idb
pool *__fastcall priority_pool_0(int choice);
pool *__fastcall priority_pool(int choice);
int __fastcall new_nonce(thr_info *thr, __time_t nonce);
char *__fastcall set_sched_start(const char *arg);
int should_run();
char *__fastcall set_float_100_to_250(const char *arg, float *i);
char *__fastcall set_float_125_to_500(const char *arg, float *i);
void __fastcall mt_disable(thr_info *mythr, int thr_id, device_drv *drv);
void set_lowprio_0(); // idb
void set_lowprio(); // idb
void *__fastcall api_thread(void *userdata);
char *__fastcall set_int_42_to_65(const char *arg, int *i);
char *__fastcall set_int_22_to_55(const char *arg, int *i);
char *__fastcall set_int_32_to_63(const char *arg, int *i);
char *__fastcall set_int_0_to_4(const char *arg, int *i);
char *__fastcall set_int_0_to_200(const char *arg, int *i);
char *__fastcall set_int_0_to_255(const char *arg, int *i);
char *__fastcall set_int_0_to_100(const char *arg, int *i);
char *__fastcall set_int_1_to_10(const char *arg, int *i);
char *__fastcall set_int_0_to_10(const char *arg, int *i);
char *__fastcall set_int_1_to_65535(const char *arg, int *i);
char *__fastcall set_int_0_to_9999(const char *arg, int *i);
char *__fastcall set_rotate(const char *arg, char *i);
void __fastcall decay_time_0(double f, double fadd, double fsecs, double interval);
void __fastcall flush_queue_0(cgpu_info *cgpu); // idb
int __fastcall submit_tested_work_0(thr_info *thr, work *work);
int noop_get_statline(); // weak
int noop_hash_work(); // weak
int noop_thread_prepare();
int noop_thread_init();
int noop_hw_error(); // weak
int noop_thread_shutdown(); // weak
int noop_thread_enable(); // weak
pool *__fastcall select_balanced(pool *cp);
char *__fastcall set_sched_stop(const char *arg);
void __fastcall scrypt_1024_1_1_256_sp(const uint32_t *input, char *scratchpad, uint32_t *ostate);
void __fastcall scrypt_regenhash(work *work);
void __fastcall rebuild_hash(work *work);
int __fastcall scrypt_test(unsigned __int8 *pdata, const unsigned __int8 *ptarget, uint32_t nonce);
bool __fastcall scanhash_scrypt(thr_info *thr, const unsigned __int8 *pmidstate, unsigned __int8 *pdata, unsigned __int8 *phash1, unsigned __int8 *phash, const unsigned __int8 *ptarget, uint32_t max_nonce, uint32_t *last_nonce, uint32_t n);
void __fastcall get_datestamp(char *f, size_t fsiz, timeval *tv);
void adjust_quota_gcd(); // idb
char *__fastcall set_int_range(const char *arg, int *i, int min, int max);
void __fastcall get_intrange(char *arg, int *val1, int *val2);
bool __fastcall detect_stratum(pool *pool, char *url);
char *__fastcall set_temp_cutoff(char *arg);
void __fastcall clean_work(work *work);
void __fastcall copy_work(work *work, const work *base_work, int noffset);
void __fastcall free_work(work *work);
void __fastcall decay_time(double f, double fadd, double fsecs, double interval);
double __fastcall cgpu_runtime(cgpu_info *cgpu);
double tsince_restart(); // idb
double tsince_update(); // idb
void app_restart(); // idb
void __fastcall set_work_ntime(work *work, int ntime);
uint64_t __fastcall share_ndiff(const work *work);
void __fastcall discard_work(work *work);
void __fastcall remove_pool(pool *pool);
void __fastcall write_config(FILE *fcfg);
void zero_bestshare(); // idb
void __fastcall default_save_file(char *filename);
void __fastcall set_target(unsigned __int8 *dest_target, double diff); // idb
int __fastcall add_var_int(uint8_t *msg, int a2, uint64_t var_int);
int __fastcall share_work_tdiff(cgpu_info *cgpu);
bool __fastcall test_nonce(work *work, uint32_t nonce);
bool __fastcall test_nonce_diff(work *work, uint32_t nonce, double diff); // idb
void __fastcall _add_queued(cgpu_info *cgpu, work *work);
work *__fastcall _find_work_bymidstate(work *que, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen);
work *__fastcall _find_work_byid(work *que, uint32_t id);
void __fastcall _work_completed(cgpu_info *cgpu, work *work);
void __fastcall reinit_device(cgpu_info *cgpu);
void __fastcall __noreturn _quit(int a1, int a2);
void __noreturn kill_work();
void __fastcall sighandler(int sig);
void __fastcall setup_url(pool *pool, char *arg);
int __fastcall get_statline(char *a1, size_t a2, cgpu_info *cgpu);
void __noreturn restart_threads_0();
int restart_threads();
char *__fastcall load_config_0(const char *arg, void *unused); // idb
char *__fastcall load_config(const char *arg, void *unused);
char *__fastcall parse_config(const json_t *a1, int a2);
bool __fastcall benchfile_get_work(work *work);
void __fastcall __noreturn mutex_init(pthread_mutex_t *lock, const char *file, const char *func, const int line);
void __fastcall mutex_init_0(pthread_mutex_t *lock, pthread_mutex_t *file, const char *func, const int line);
void __fastcall __noreturn rwlock_init(pthread_rwlock_t *lock, const char *file, const char *func, const int line);
void __fastcall rwlock_init_0(pthread_rwlock_t *lock, pthread_rwlock_t *file, const char *func, const int line);
int __fastcall cglock_init_constprop_65(int a1, pthread_mutex_t *a2, const char *a3);
void __fastcall __noreturn wr_lock(pthread_rwlock_t *lock, const char *file, const char *func, const int line);
void __fastcall __noreturn mutex_lock(pthread_mutex_t *lock, const char *file, const char *func, const int line);
void __fastcall __noreturn mutex_unlock_noyield(pthread_mutex_t *lock, const char *file, const char *func, const int line);
int __fastcall pool_tset(int a1, _BYTE *a2);
int __fastcall pool_tclear(int a1, _BYTE *a2);
bool __fastcall pool_active(pool *pool, bool pinging);
int __fastcall inc_dev_status(int a1, int a2);
int wake_gws();
int __fastcall restart_wait(int a1, unsigned int a2);
void __fastcall __noreturn rw_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line);
uint32_t total_work_inc();
void __fastcall roll_work(work *work);
work *make_work(); // idb
work *__fastcall copy_work_noffset(work *base_work, int noffset);
work *__fastcall make_clone(work *work);
int __fastcall add_queued(cgpu_info *a1, work *a2);
void __fastcall work_completed(cgpu_info *a1, work *a2);
work *__fastcall take_queued_work_bymidstate(cgpu_info *a1, char *a2, size_t a3, char *a4, int offset, size_t datalen);
int __fastcall age_queued_work(pthread_rwlock_t *a1);
void __fastcall flush_queue(pthread_rwlock_t *a1);
void __fastcall __noreturn rd_lock(pthread_rwlock_t *lock, const char *file, const char *func, const int line);
work *__fastcall clone_queued_work_byid(pthread_rwlock_t *a1, int a2);
work *__fastcall clone_queued_work_bymidstate(cgpu_info *cgpu, char *midstate, size_t midstatelen, char *data, int offset, size_t datalen);
unsigned int __fastcall find_queued_work_byid(pthread_rwlock_t *a1, int a2);
work *__fastcall find_queued_work_bymidstate(int a1, char *a2, size_t a3, char *a4, int offset, size_t datalen);
cgpu_info *__fastcall get_devices(int a1);
void zero_stats();
void print_summary(); // idb
thr_info *__fastcall get_thread(int a1);
int __fastcall dev_from_id(int thr_id);
void _kill_work_0(); // idb
void _kill_work(); // idb
void kill_mining(); // idb
pool *current_pool();
int __fastcall inc_work_stats(int a1, int a2, int a3);
int cp_prio();
void __fastcall pool_resus(pool *pool);
void __fastcall stratum_resumed_0(pool *pool);
void __fastcall stratum_resumed(pool *pool);
bool __fastcall cnx_needed(pool *pool);
pool *add_pool(); // idb
char *__fastcall set_userpass(const char *arg);
char *__fastcall set_user(const char *arg);
pool *add_url(); // idb
char *__fastcall set_url(char *arg);
char *__fastcall set_quota(char *arg);
char *__fastcall set_pass(const char *arg);
void __fastcall inc_hw_errors_with_diff(thr_info *thr, int diff);
void __fastcall inc_hw_errors(thr_info *thr);
uint64_t __fastcall share_diff(const work *work);
void __fastcall update_work_stats(thr_info *thr, work *work);
bool __fastcall submit_nonce_1(thr_info *thr, work *work, uint32_t nonce, int *nofull);
void __fastcall clear_pool_work(pool *pool);
void __fastcall switch_pools(pool *selected);
void __fastcall pool_failed(pool *pool);
void __fastcall pool_died(pool *pool);
void *__fastcall test_pool_thread(void *arg);
void *__fastcall __noreturn watchpool_thread(void *userdata);
void __fastcall clear_stratum_shares(pool *pool);
work *__fastcall hash_pop(bool blocking);
void __fastcall sharelog(const char *disposition, const work *work);
void __fastcall gen_stratum_work(pool *pool, work *work);
bool __fastcall stale_work(work *work, bool share);
work *__fastcall get_work(thr_info *thr, const int thr_id);
work *__fastcall get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id);
work *__fastcall _get_queued(cgpu_info *cgpu);
work *__fastcall get_queued(cgpu_info *a1);
void discard_stale(); // idb
int restart_thread();
int __fastcall stratum_sthread(pool *a1);
void __fastcall hashmeter(int thr_id, int a2, uint64_t hashes_done);
void __fastcall hash_queued_work(thr_info *mythr);
void __fastcall hash_driver_work(thr_info *mythr);
void __fastcall hash_sole_work(thr_info *mythr);
void *__fastcall __noreturn watchdog_thread(void *userdata);
int __fastcall test_work_current(int a1);
void __fastcall stage_work(work *work);
void __fastcall submit_work_async(work *work);
bool __fastcall submit_tested_work(thr_info *thr, work *work);
bool __fastcall submit_nonce(thr_info *thr, work *work, uint32_t nonce);
void __fastcall submit_nonce_2(work *work);
bool __fastcall submit_nonce_direct(thr_info *thr, work *work, uint32_t nonce);
bool __fastcall submit_noffset_nonce(thr_info *thr, work *work_in, uint32_t nonce, int noffset);
void *__fastcall stratum_rthread(void *userdata);
void __fastcall quit(int status);
bool __fastcall add_pool_details(pool *pool, bool live, char *url, char *user, char *pass);
void __fastcall fill_device_drv(device_drv *drv);
void __fastcall null_device_drv(device_drv *drv);
int __fastcall enable_device(pthread_rwlock_t *a1);
int __fastcall add_cgpu(cgpu_info *a1);
device_drv *__fastcall copy_drv(device_drv *drv);
int no_yield(); // idb
send_ret __fastcall _stratum_send(pool *pool, char *s, ssize_t len);
bool __fastcall http_negotiate(pool *pool, int sockd, bool http0);
void __fastcall _suspend_stratum(pool *pool);
void __fastcall block_socket(int fd);
bool __fastcall socks4_negotiate(pool *pool, int sockd, bool socks4a);
bool __fastcall socket_full(int pool, int wait);
char *__fastcall _json_array_string(json_t *val, unsigned int entry);
char *__fastcall json_array_string(json_t *val, unsigned int entry);
void __fastcall cgsem_post_0(cgsem_t *cgsem, const char *file, const char *func, const int line);
void __fastcall mutex_unlock_noyield_0(pthread_mutex_t *lock, const char *file, const char *func, const int line); // idb
void __fastcall __noreturn mutex_lock_0(pthread_mutex_t *lock, const char *file, const char *func, const int line);
void __fastcall clear_sock(pool *pool);
void __fastcall tq_freezethaw(thread_q *tq, bool frozen);
const char *__fastcall proxytype(proxytypes_t proxytype);
void __fastcall _bin2hex(char *s, const unsigned __int8 *p, size_t len);
char *__fastcall bin2hex(const unsigned __int8 *p, size_t len);
bool __fastcall hex2bin(unsigned __int8 *p, const char *hexstr, size_t len);
bool __fastcall parse_extranonce_equihash(pool *pool, json_t *val, int type);
void __fastcall b58tobin(unsigned __int8 *b58bin, const char *b58);
void __fastcall address_to_pubkeyhash(unsigned __int8 *pkh, const char *addr);
int __fastcall ser_number(unsigned __int8 *s, int32_t val);
unsigned __int8 *__fastcall ser_string(char *s, int *slen);
bool __fastcall fulltest(const unsigned __int8 *hash, const unsigned __int8 *target);
thread_q *tq_new(); // idb
void __fastcall tq_free(thread_q *tq);
void __fastcall tq_freeze(thread_q *tq);
void __fastcall tq_thaw(thread_q *tq);
bool __fastcall tq_push(thread_q *tq, void *data);
void *__fastcall tq_pop(thread_q *tq, const timespec *abstime);
void __fastcall thr_info_join(thr_info *thr);
void __fastcall thr_info_cancel(thr_info *thr);
void __fastcall subtime(timeval *a, timeval *b);
void __fastcall addtime(timeval *a, timeval *b);
bool __fastcall time_more(timeval *a, timeval *b);
bool __fastcall time_less(timeval *a, timeval *b);
void __fastcall copy_time(timeval *dest, const timeval *src);
void __fastcall timespec_to_val(timeval *val, const timespec *spec);
void __fastcall timeval_to_spec(timespec *spec, const timeval *val);
void __fastcall us_to_timeval(timeval *val, int a2, int64_t us);
void __fastcall us_to_timespec(timespec *spec, int a2, int64_t us);
void __fastcall ms_to_timespec(timespec *spec, int a2, int64_t ms);
void __fastcall ms_to_timeval(timeval *val, int a2, int64_t ms);
void __fastcall timeraddspec(timespec *a, const timespec *b);
char *__fastcall Strcasestr(char *haystack, const char *needle);
char *__fastcall Strsep(char **stringp, const char *delim);
void __fastcall cgtime(timeval *tv);
int __fastcall cgtimer_to_ms(cgtimer_t *cgt);
void __fastcall cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res);
void __fastcall cgtimer_time(cgtimer_t *ts_start);
void __fastcall cgsleep_ms_r(cgtimer_t *ts_start, int ms);
void __fastcall cgsleep_us_r(cgtimer_t *ts_start, int a2, int64_t us);
void __fastcall cgsleep_ms(int ms);
void __fastcall cgsleep_us(int64_t us);
double __fastcall us_tdiff(timeval *end, timeval *start);
int __fastcall ms_tdiff(timeval *end, timeval *start);
double __fastcall tdiff(timeval *end, timeval *start);
void __fastcall check_extranonce_option(pool *pool, char *url);
bool __fastcall extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port);
char *__fastcall get_proxy(char *url, pool *pool);
bool __fastcall sock_full(pool *pool);
void __fastcall recalloc(void **ptr, size_t old, size_t new, const char *file, const char *func, const int line);
void __fastcall suspend_stratum(pool *pool);
bool __fastcall stratum_send(pool *pool, char *s, ssize_t len);
char *__fastcall recv_line(pool *pool);
void __fastcall extranonce_subscribe_stratum(pool *pool);
bool __fastcall initiate_stratum(pool *pool);
bool __fastcall restart_stratum(pool *pool);
bool __fastcall parse_method_0(pool *pool, char *s);
bool __fastcall parse_method(pool *pool, char *s);
bool __fastcall auth_stratum(pool *pool);
bool __fastcall subscribe_extranonce(pool *pool);
void __fastcall dev_error(cgpu_info *dev, dev_reason reason);
void *__fastcall realloc_strcat(char *ptr, char *s);
void *__fastcall str_text(char *ptr);
void __fastcall RenameThread(const char *name);
void __fastcall cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line);
int __fastcall thr_info_create(thr_info *thr, pthread_attr_t *attr, void *(*start)(void *), void *arg);
void __fastcall cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line);
void *__fastcall completion_thread(void *arg);
void __fastcall cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line);
int __fastcall cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line);
void __fastcall cgsem_reset(cgsem_t *cgsem);
bool __fastcall cg_completion_timeout(void *fn, void *fnarg, int timeout);
void __fastcall cg_memcpy(void *dest, const void *src, unsigned int n, const char *file, const char *func, const int line);
int __fastcall cg_timeval_subtract(timeval *result, timeval *x, timeval *y);
void __fastcall rev(unsigned __int8 *s, size_t l);
int __fastcall check_asicnum(int asic_num, unsigned __int8 nonce);
void __fastcall cg_logwork_0(work *work, unsigned __int8 *nonce_bin, bool ok);
void __fastcall cg_logwork(work *work, unsigned __int8 *nonce_bin, bool ok);
void __fastcall cg_logwork_uint32(work *work, uint32_t nonce, bool ok);
void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb);
void __fastcall sha256_init(sha256_ctx *ctx);
void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len);
void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest);
void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest);
api_data *__fastcall api_add_data_full(api_data *root, char *name, api_data_type type, void *data, bool copy_data);
bool __fastcall io_add(io_data *io_data, char *buf);
void __fastcall doquit(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall dorestart(io_data *io_data, int c, char *param, bool isjson, char group);
char *__fastcall escape_string(char *str, bool isjson);
void __fastcall head_join(io_data *io_data, char *cmdptr, bool isjson, bool *firstjoin);
bool __fastcall check_connect(sockaddr_storage *cli, char **connectaddr, char *group);
void mcast(); // idb
void *__fastcall mcast_thread(void *userdata);
void __fastcall tail_join(io_data *io_data, bool isjson);
void __fastcall add_item_buf(K_ITEM *item, const char *str); // idb
void __fastcall send_result(io_data *io_data, int c, int isjson, int a4);
void __fastcall copyadvanceafter(unsigned __int8 **ch, char **param, char **buf);
bool __fastcall pooldetails(char *param, char **url, char **user, char **pass);
void __fastcall rd_lock_0(pthread_rwlock_t *lock, const char *file, const char *func, const int line); // idb
void __fastcall __noreturn mutex_lock_1(pthread_mutex_t *lock, const char *file, const char *func, const int line);
void __fastcall __noreturn rw_unlock_0(pthread_rwlock_t *lock, const char *file, const char *func, const int line);
void __fastcall __noreturn mutex_unlock_noyield_1(pthread_mutex_t *lock, const char *file, const char *func, const int line);
void __fastcall tidyup(void *arg);
void *__fastcall quit_thread(void *userdata);
void *__fastcall restart_thread_0(void *userdata);
api_data *__fastcall print_data(io_data *io_data, api_data *root, bool isjson, bool precom);
void __fastcall message(io_data *io_data, int messageid, int paramid, char *param2, bool isjson);
void __fastcall privileged(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall dosave(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall lockstats(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall dohotplug(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall dozero(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall usbstats(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall setconfig(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall failoveronly(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall removepool(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall disablepool(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall enablepool(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall poolquota(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall poolpriority(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall addpool(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall switchpool(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall devstatus(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall edevstatus(io_data *a1, int a2, int a3, bool a4);
void __fastcall asccount(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall debugstate(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall checkcommand(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall devdetails(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall pgacount(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall minerconfig(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall apiversion(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall lcddisplay(io_data *io_data, int c, char *param, bool isjson, char group);
int __fastcall itemstats(io_data *io_data, int i, char *id, cgminer_stats *stats, api_data *pool_stats, api_data *extra, cgpu_info *cgpu, bool isjson);
void __fastcall minerestats(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall minerstats(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall minecoin(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall summary(io_data *io_data, int c, char *param, bool isjson, char group);
void __fastcall poolstatus(io_data *io_data, int c, char *param, bool isjson, char group);
api_data *__fastcall api_add_escape(api_data *root, char *name, char *data, bool copy_data);
api_data *__fastcall api_add_string(api_data *root, char *name, char *data, bool copy_data);
api_data *__fastcall api_add_const(api_data *root, char *name, const char *data, bool copy_data);
api_data *__fastcall api_add_uint8(api_data *root, char *name, uint8_t *data, bool copy_data);
api_data *__fastcall api_add_int16(api_data *root, char *name, int16_t *data, bool copy_data);
api_data *__fastcall api_add_uint16(api_data *root, char *name, uint16_t *data, bool copy_data);
api_data *__fastcall api_add_int(api_data *root, char *name, int *data, bool copy_data);
api_data *__fastcall api_add_uint(api_data *root, char *name, unsigned int *data, bool copy_data);
api_data *__fastcall api_add_uint32(api_data *root, char *name, uint32_t *data, bool copy_data);
api_data *__fastcall api_add_hex32(api_data *root, char *name, uint32_t *data, bool copy_data);
api_data *__fastcall api_add_uint64(api_data *root, char *name, uint64_t *data, bool copy_data);
api_data *__fastcall api_add_int64(api_data *root, char *name, int64_t *data, bool copy_data);
api_data *__fastcall api_add_double(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_elapsed(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_bool(api_data *root, char *name, bool *data, bool copy_data);
api_data *__fastcall api_add_timeval(api_data *root, char *name, timeval *data, bool copy_data);
api_data *__fastcall api_add_time(api_data *root, char *name, time_t *data, bool copy_data);
api_data *__fastcall api_add_mhs(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_mhtotal(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_temp(api_data *root, char *name, float *data, bool copy_data);
api_data *__fastcall api_add_utility(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_freq(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_volts(api_data *root, char *name, float *data, bool copy_data);
api_data *__fastcall api_add_hs(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_diff(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_percent(api_data *root, char *name, double *data, bool copy_data);
api_data *__fastcall api_add_avg(api_data *root, char *name, float *data, bool copy_data);
void __fastcall notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, char group);
void __fastcall notify(io_data *io_data, int c, char *param, bool isjson, char group);
void mcast_init(); // idb
void __fastcall api(int api_thr_id);
void __fastcall applog(int prio, const char *str, bool force);
void __fastcall mutex_unlock_noyield_2(pthread_mutex_t *lock, const char *file, const char *func, const int line); // idb
void __fastcall mutex_lock_2(pthread_mutex_t *lock, const char *file, const char *func, const int line); // idb
void __fastcall my_log_curses(pthread_mutex_t *prio, const char *datetime, const char *str, bool force);
void __fastcall simplelog(int prio, const char *str, bool force);
void __fastcall k_alloc_items(K_LIST *list, const char *file, const char *func, const int line);
K_LIST *__fastcall k_new_store(K_LIST *list);
K_LIST *__fastcall k_new_list(const char *name, size_t siz, int allocate, int limit, bool do_tail, const char *file, const char *func, const int line);
K_ITEM *__fastcall k_unlink_head(K_LIST *list, const char *file, const char *func, const int line);
K_ITEM *__fastcall k_unlink_head_zero(K_LIST *list, const char *file, const char *func, const int line);
K_ITEM *__fastcall k_unlink_tail(K_LIST *list, const char *file, const char *func, const int line);
void __fastcall k_add_head(K_LIST *list, K_ITEM *item, const char *file, const char *func, const int line);
void __fastcall k_add_tail(K_LIST *list, K_ITEM *item, const char *file, const char *func, const int line);
void __fastcall k_insert_before(K_LIST *list, K_ITEM *item, K_ITEM *before, const char *file, const char *func, const int line);
void __fastcall k_insert_after(K_LIST *list, K_ITEM *item, K_ITEM *after, const char *file, const char *func, const int line);
void __fastcall k_unlink_item(K_LIST *list, K_ITEM *item, const char *file, const char *func, const int line);
void __fastcall k_list_transfer_to_head(K_LIST *from, K_LIST *to, const char *file, const char *func, const int line);
void __fastcall k_list_transfer_to_tail(K_LIST *from, K_LIST *to, const char *file, const char *func, const int line);
K_LIST *__fastcall k_free_list(K_LIST *list, const char *file, const char *func, const int line);
K_LIST *__fastcall k_free_store(K_LIST *store, const char *file, const char *func, const int line);
void __fastcall dupalloc(cgpu_info *cgpu, int timelimit);
void __fastcall dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups);
bool __fastcall isdupnonce(cgpu_info *cgpu, work *work, uint32_t nonce);
unsigned __int16 __fastcall crc16(const unsigned __int8 *buffer, int len);
void reset_all_hash_board_low(); // idb
void __fastcall bitmain_ZCASH_update(cgpu_info *bitmain);
int64_t __fastcall bitmain_ZCASH_scanhash(thr_info *thr);
api_data *__fastcall bitmain_api_stats(cgpu_info *cgpu);
void __fastcall bitmain_ZCASH_reinit_device(cgpu_info *bitmain);
void bitmain_ZCASH_detect();
void *__fastcall __noreturn check_fan_thr(void *arg);
void __noreturn get_hash_rate();
void __fastcall i2c_write_0(unsigned int config_data); // idb
int __fastcall i2c_read_0(unsigned int config_data);
int __fastcall bm1740_makeup_work_0(uint8_t *str, int len); // idb
int __fastcall calculate_asic_number_0(unsigned int actual_asic_number);
void __fastcall rwlock_init_1(pthread_rwlock_t *lock, const char *file, const char *func, const int line); // idb
void *__fastcall bitmain_scanhash(void *arg);
void __fastcall __noreturn mutex_init_1(pthread_mutex_t *lock, const char *file, const char *func, const int line);
int bitmain_axi_init(); // idb
int bitmain_axi_close(); // idb
void __fastcall print_bin(uint8_t *cmd, size_t len);
unsigned int __fastcall read_axi_fpga(unsigned int address);
void __fastcall write_axi_fpga(unsigned int address, unsigned int data);
void check_fpga_version(); // idb
void init_fpga(); // idb
unsigned __int8 __fastcall asic_baud_to_fpga_baud(unsigned __int8 asic_baud);
void __fastcall set_fpga_baud(unsigned __int8 asic_baud);
unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 which_uart);
unsigned int __fastcall read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length);
unsigned int __fastcall clear_uart_send_fifo(unsigned __int8 which_chain);
unsigned int __fastcall clear_uart_rx_fifo(unsigned __int8 which_chain);
unsigned int __fastcall uart_send(unsigned __int8 which_uart, volatile unsigned __int8 *buf, unsigned int length);
void *__fastcall ZCASH_fill_work(void *usrdata);
unsigned int __fastcall uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length);
void __fastcall i2c_write(unsigned int config_data);
unsigned __int8 __fastcall i2c_read(unsigned int config_data);
void __fastcall write_pic(unsigned __int8 data);
int read_pic();
int __fastcall write_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t *data, int len);
int __fastcall read_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t *value, int len);
unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len);
int __fastcall bm1740_makeup_get_status_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr); // idb
int __fastcall bm1740_makeup_get_status_cmd_0(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint8_t regaddr); // idb
int __fastcall bm1740_makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len); // idb
int __fastcall bm1740_makeup_set_config_cmd(uint8_t *str, uint32_t str_len, uint8_t all, uint8_t chip_addr, uint32_t regaddr, uint32_t regdata);
int __fastcall bm1740_makeup_set_address_cmd(uint8_t *str, uint32_t str_len, uint8_t chip_addr); // idb
unsigned __int16 __fastcall CRC16(unsigned __int8 *buffer, int len);
uint16_t __fastcall crc_itu_t(uint16_t crc, const uint8_t *buffer, int len);
int __fastcall set_PIC16F1704_flash_pointer_new(unsigned __int8 flash_addr_h, unsigned __int8 flash_addr_l);
int __fastcall send_data_to_PIC16F1704_new(unsigned __int8 *buf);
int __fastcall read_PIC16F1704_flash_pointer_new(unsigned __int8 *flash_addr_h, unsigned __int8 *flash_addr_l);
int __fastcall read_PIC16F1704_flash_data_new(unsigned __int8 *buf);
bool erase_PIC16F1704_flash_new();
bool write_data_into_PIC16F1704_flash_new();
bool jump_from_loader_to_app_PIC16F1704_new();
bool reset_PIC16F1704_pic_new();
int __fastcall PIC16F1704_i2c_forward_send(uint8_t dev_addr, int rw_flag, uint8_t reg_addr, int len, uint8_t *data);
int __fastcall ISL_get_voltage(uint8_t i2c_dev_addr, uint16_t *voltage);
void __fastcall every_asic_get_isl_voltage(int which_chain);
void every_chain_get_isl_voltage(); // idb
int __fastcall ISL_set_i2c_data(uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len);
int __fastcall ISL_get_i2c_data(uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len);
int __fastcall XDPED_update_asics_vol(uint32_t vol);
uint16_t __fastcall ISL_set_voltage_dynamic(uint8_t i2c_dev_addr, uint16_t vol);
uint16_t __fastcall ISL_set_voltage(uint8_t i2c_dev_addr, uint16_t voltage);
void __fastcall every_asic_set_isl_voltage(int which_chain);
void every_chain_set_isl_voltage(); // idb
void __fastcall update_asic_vol(int which_chain, int which_asic, int vol);
void __fastcall update_asics_vol(int vol);
void __fastcall update_asics_voltage(int vol);
void __fastcall init_vol_table(unsigned __int16 vol);
void dump_vol_table(); // idb
int __fastcall set_PIC16F1704_voltage_new(unsigned __int8 voltage);
int __fastcall write_hash_ID_PIC16F1704_new(unsigned __int8 *buf);
int __fastcall read_hash_id_PIC16F1704_new(unsigned __int8 *buf);
bool enable_PIC16F1704_dc_dc_new();
bool disable_PIC16F1704_dc_dc_new();
int heart_beat_PIC16F1704_new(); // idb
void *__fastcall __noreturn pic_heart_beat_func_new(void *arg);
int __fastcall get_PIC16F1704_software_version_new(unsigned __int8 *version);
void every_chain_get_pic_version(); // idb
int __fastcall get_PIC16F1704_voltage_new(unsigned __int8 *voltage);
int __fastcall write_temperature_offset_PIC16F1704_new(unsigned __int8 *buf);
int __fastcall read_temperature_offset_PIC16F1704_new(unsigned __int8 *buf);
bool erase_PIC16F1704_app_flash_new();
int PIC1704_update_pic_app_program_new(); // idb
void every_chain_reset_PIC16F1704_pic_new(); // idb
void every_chain_jump_from_loader_to_app_PIC16F1704_new(); // idb
void every_chain_disable_PIC16F1704_dc_dc_new(); // idb
void __fastcall bitmain_ZCASH_shutdown(thr_info *thr);
void every_chain_enable_PIC16F1704_dc_dc_new(); // idb
int send_heart_beat_to_every_chain(); // idb
void check_whether_need_update_pic_program(); // idb
int __fastcall save_freq_PIC16F1704_new(unsigned __int16 freq);
int __fastcall get_PIC16F1704_freq_new(unsigned __int16 *freq);
int __fastcall write_data_to_PIC16F1704_flash(unsigned __int8 *buf, unsigned int offset, int buf_len);
int __fastcall read_data_from_PIC16F1704_flash(unsigned __int8 *buf, unsigned __int8 offset, unsigned __int8 read_len);
void __fastcall every_chain_set_voltage_PIC16F1704_new(unsigned __int16 voltage);
void __fastcall every_chain_get_voltage_PIC16F1704_new(unsigned __int16 voltage);
void __fastcall every_chain_save_freq_PIC16F1704_new(unsigned __int16 freq);
void every_chain_get_PIC16F1704_freq_new(); // idb
void pic_test_new(); // idb
unsigned __int8 __fastcall bit_read(unsigned __int8 *y, int x);
int __fastcall bm1740_makeup_work(uint8_t *str, int len);
void __fastcall chain_inactive(const int which_chain);
void __fastcall set_address(const int which_chain, unsigned __int8 chip_addr);
void __fastcall software_set_address_chain(unsigned int which_chain);
void software_set_address(); // idb
void __fastcall set_core_timeout_chain(unsigned __int8 which_chain, unsigned int timeout);
void __fastcall set_nonce_shift_chain(unsigned __int8 which_chain, int shift);
void __fastcall set_core_timeout(uint32_t timeout);
void __fastcall set_nonce_shift(int shift);
void __fastcall set_io_drive_strength_chain(unsigned __int8 which_chain);
void set_io_drive_strength(); // idb
void __fastcall set_analog_mux_control_chain(unsigned __int8 which_chain, uint32_t value);
void __fastcall set_analog_mux_control(uint32_t value);
void __fastcall set_frequency_chain(unsigned __int8 which_chain, unsigned int frequency);
void __fastcall set_freq_asic(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned int frequency);
void __noreturn turbo_mode_monitor();
void __fastcall set_frequency(unsigned int frequency);
void __fastcall set_baud_chain(unsigned __int8 which_chain, unsigned int bt8d);
void __fastcall set_baud(unsigned int bt8d);
void __fastcall set_ticket_mask_chain(unsigned __int8 which_chain, uint32_t ticket_mask);
void __fastcall set_ticket_mask(unsigned int ticket_mask);
void __fastcall set_txn_data_chain(unsigned __int8 which_chain, int txn_shalow, int txn_zero);
void __fastcall set_txn_data(int txn_shalow, int txn_zero);
int __fastcall is_nonce_or_reg_value(unsigned __int8 data);
void init_asic_display_status(); // idb
speed_t __fastcall tiospeed_t(int baud);
void __fastcall tty_init_chain(uint8_t which_chain, bitmain_ZCASH_info *info);
void __fastcall tty_init(bitmain_ZCASH_info *info);
int __fastcall ZCASH_write(int fd, volatile uint8_t *buf, size_t bufLen);
int __fastcall ZCASH_read(int uart_fd, unsigned __int8 *buf, size_t MAX_READ_BYTES);
void check_chain(); // idb
void __fastcall set_led(bool stop);
void *__fastcall __noreturn check_miner_status(void *arg);
int __fastcall get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed);
void fan_power_on(); // idb
void check_fan_speed(); // idb
void __fastcall set_PWM(unsigned __int8 pwm_percent);
float __fastcall adjust_pwm_bm1744_4chips(int temp);
void set_PWM_according_to_temperature(); // idb
void __fastcall enable_read_temperature_from_asic_chain(unsigned int which_chain);
void enable_read_temperature_from_asic(); // idb
void __fastcall select_core_to_check_temperature_chain(unsigned int which_chain, uint32_t analog_mux_reg_value);
void __fastcall select_core_to_check_temperature(uint32_t analog_mux_reg_value);
void __fastcall write_i2c_reg(unsigned __int8 which_chain, unsigned __int8 which_sensor, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr, uint8_t i2c_reg_data);
void enable_sensor_extend_mode(); // idb
void __fastcall reset_chain(bitmain_ZCASH_info *info, uint8_t chain);
int __fastcall calculate_asic_number(unsigned int actual_asic_number);
void calculate_address_interval(); // idb
int create_bitmain_scan_freq_pthread(); // idb
int create_bitmain_turbo_mode_monitor_pthread(); // idb
int __fastcall every_chain_read_pic_freq_data(unsigned __int8 (*freq_table)[9]);
int __fastcall every_chain_write_freq_to_pic(unsigned __int8 (*freq_table)[9]);
int clear_every_chain_freq_to_pic(); // idb
void scan_freq_init_freq(); // idb
int scan_freq_save_freq(); // idb
void __noreturn scan_freq_handle();
void __fastcall set_miner_name(char *name);
void *__fastcall bitmain_ZCASH_reinit_chain(void *usrdata);
void __fastcall suffix_string_ZCASH(uint64_t val, char *buf, size_t bufsiz, int sigdigits, bool display);
void calculate_hash_rate(); // idb
void clear_register_value_buf(); // idb
void __fastcall check_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode);
void check_every_chain_asic_pll(); // idb
void __fastcall check_chain_asic_number(unsigned __int8 which_chain, bool whether_update_asic_num);
void __fastcall check_every_chain_asic_number(bool whether_update_asic_num);
void __fastcall get_reg_value(uint8_t regaddr);
void __fastcall read_i2c_reg(unsigned __int8 which_chain, unsigned __int8 which_sensor, uint8_t i2c_dev_addr, uint8_t i2c_reg_addr);
void __fastcall set_temperature_offset_value_chain_sensor(unsigned __int8 which_chain, unsigned __int8 which_sensor);
void __fastcall calibration_sensor_offset_chain(unsigned __int8 which_chain);
void calibration_sensor_offset(); // idb
void check_sensor_ID(); // idb
void __noreturn read_temp_func();
void __fastcall recheck_asic_num(bitmain_ZCASH_info *info, uint8_t chain);
void clear_nonce_fifo(); // idb
int __fastcall target_zero_cal(uint8_t *target);
bool __fastcall target_match(unsigned __int8 *result_value, unsigned __int8 *target);
int create_bitmain_check_fan_pthread(); // idb
int __fastcall create_bitmain_check_miner_status_pthread(bitmain_ZCASH_info *info);
int create_bitmain_get_hash_rate_pthread(); // idb
unsigned __int8 __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 which_chain);
int create_bitmain_read_temp_pthread(); // idb
int __fastcall bitmain_ZCASH_init(bitmain_ZCASH_info *info);
bool __fastcall bitmain_ZCASH_prepare(thr_info *thr);
int __fastcall nonce_handle(nonce_rb_format (*g_nonce)[1], uint8_t (*g_nonce_list)[1][16][91], uint8_t *str, int len, uint32_t chainid);
void __fastcall pm_handle(uint8_t *str, int len, uint8_t chainid);
void __fastcall reg_handle(uint8_t *str, int len, uint32_t chainid);
void *__fastcall get_asic_response(void *arg);
void __fastcall sha2_starts(sha2_context *ctx);
void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data);
void __fastcall sha2_update_0(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen);
void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output);
void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output);
int __fastcall compareSR(const void *p1, const void *p2);
void __fastcall generateHash(blake2b_state *S, const uint32_t g, uint8_t *hash, const size_t hashLen);
void __fastcall expandArray(const unsigned __int8 *in, const size_t in_len, unsigned __int8 *out, const size_t out_len, const size_t bit_len, const size_t byte_pad);
void __fastcall sort_pair(uint32_t *a, uint32_t len);
int __fastcall sortValidator(void *data, const unsigned __int8 *soln);
bool __fastcall HasCollision(const uint8_t *a, const uint8_t *b, int l);
bool __fastcall IndicesBefore(const uint8_t *a, const uint8_t *b, size_t hashLen, uint32_t indicesLen);
bool __fastcall DistinctIndices(const uint8_t *a, const uint8_t *b, size_t hashLen, uint32_t indicesLen);
bool __fastcall IsZero(const uint8_t *a, size_t len);
int __fastcall IsValidSolution(blake2b_state *base_state, unsigned __int8 *soln);
void __fastcall digestInit(blake2b_state *S, const int n, const int k);
int __fastcall blake2b_compress(blake2b_state *S, const uint8_t *block);
int __fastcall blake2b_init_param(blake2b_state *S, const blake2b_param *P);
int __fastcall blake2b_init(blake2b_state *S, const uint8_t outlen);
int __fastcall blake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen);
int __fastcall blake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen);
int __fastcall blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen);
int __fastcall blake2b(uint8_t *out, const void *in, const void *key, const uint8_t outlen, const uint64_t inlen, uint8_t keylen);
void __fastcall Sha256_WriteByteBlock(CSha256 *p);
void __fastcall Sha256_Init(CSha256 *p);
void __fastcall Sha256_Update(CSha256 *p, const uint8_t *data, size_t size);
void __fastcall Sha256_Final(CSha256 *p, uint8_t *digest);
void __fastcall Sha256_Onestep(const uint8_t *data, size_t size, uint8_t *digest);
void *__fastcall statusServiceThread(void *param);
void *__fastcall httpListenThread(void *param);
void start_http_thread(); // idb
void __fastcall xxtea_encode(uint32_t *v, int n, const uint32_t *key);
void __fastcall xxtea_decode(uint32_t *v, int n, const uint32_t *key);
int __fastcall object_key_compare_serials(const void *key1, const void *key2);
int __fastcall dump_to_strbuffer(const char *buffer, size_t size, void *data);
int __fastcall dump_to_file(const char *buffer, size_t size, void *data);
int __fastcall object_key_compare_keys(const void *key1, const void *key2);
int __fastcall dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data);
int __fastcall dump_string(const char *str, json_dump_callback_t dump, void *data, size_t flags);
int __fastcall do_dump(int a1, size_t a2, size_t a3, int (*a4)(const char *, size_t, void *), void *data);
int __fastcall json_dump_callback(const json_t *json, json_dump_callback_t callback, void *data, size_t flags);
char *__fastcall json_dumps(const json_t *json, size_t flags);
int __fastcall json_dumpf(const json_t *json, FILE *output, size_t flags);
int __fastcall json_dump_file(const json_t *json, const char *path, size_t flags);
pair_t *__fastcall hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const char *key, size_t hash);
void __fastcall hashtable_do_clear(hashtable_t *hashtable);
int __fastcall hashtable_init(hashtable_t *hashtable);
void __fastcall hashtable_close(hashtable_t *hashtable);
int __fastcall hashtable_set(hashtable_t *hashtable, const char *key, size_t serial, json_t *value);
void *__fastcall hashtable_get(hashtable_t *hashtable, const char *key);
int __fastcall hashtable_del(hashtable_t *hashtable, const char *key);
void __fastcall hashtable_clear(hashtable_t *hashtable);
void *__fastcall hashtable_iter(hashtable_t *hashtable);
void *__fastcall hashtable_iter_at(hashtable_t *hashtable, const char *key);
void *__fastcall hashtable_iter_next(hashtable_t *hashtable, void *iter);
void *__fastcall hashtable_iter_key(void *iter);
size_t __fastcall hashtable_iter_serial(void *iter);
void *__fastcall hashtable_iter_value(void *iter);
void __fastcall hashtable_iter_set(void *iter, json_t *value);
int __fastcall string_get(void *data);
int __fastcall buffer_get(void *data);
int __fastcall callback_get(void *data);
void error_set(json_error_t *error, const lex_t *lex, const char *a3, ...);
void __fastcall lex_close(lex_t *lex);
int32_t __fastcall decode_unicode_escape(const char *str);
_DWORD *__fastcall stream_unget(_DWORD *result, int a2);
int __fastcall stream_get_part_3(const lex_t *a1, json_error_t *a2);
int __fastcall lex_get_save(lex_t *lex, json_error_t *error);
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2);
int __fastcall lex_scan(lex_t *lex, json_error_t *error);
json_t *__fastcall parse_value(lex_t *lex, size_t flags, json_error_t *error);
json_t *__fastcall parse_json(lex_t *lex, size_t flags, json_error_t *error);
json_t *__fastcall json_loads(const char *string, size_t flags, json_error_t *error);
json_t *__fastcall json_loadb(const char *buffer, size_t buflen, size_t flags, json_error_t *error);
json_t *__fastcall json_loadf(FILE *input, size_t flags, json_error_t *error);
json_t *__fastcall json_load_file(const char *path, size_t flags, json_error_t *error);
json_t *__fastcall json_load_callback(json_load_callback_t callback, void *arg, size_t flags, json_error_t *error);
void *__fastcall jsonp_malloc(size_t size);
void __fastcall jsonp_free(void *ptr);
char *__fastcall jsonp_strdup(const char *str);
void __fastcall json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
int __fastcall strbuffer_init(strbuffer_t *strbuff);
void __fastcall strbuffer_close(strbuffer_t *strbuff);
void __fastcall strbuffer_clear(strbuffer_t *strbuff);
const char *__fastcall strbuffer_value(const strbuffer_t *strbuff);
char *__fastcall strbuffer_steal_value(strbuffer_t *strbuff);
int __fastcall strbuffer_append_bytes(strbuffer_t *strbuff, const char *data, size_t size);
int __fastcall strbuffer_append(strbuffer_t *strbuff, const char *string);
int __fastcall strbuffer_append_byte(strbuffer_t *strbuff, char byte);
char __fastcall strbuffer_pop(strbuffer_t *strbuff);
int __fastcall jsonp_strtod(strbuffer_t *strbuffer, double *out);
int __fastcall jsonp_dtostr(char *buffer, size_t size, double value); // idb
int __fastcall utf8_encode(int32_t codepoint, char *buffer, int *size);
int __fastcall utf8_check_first(char byte);
int __fastcall utf8_check_full(const char *buffer, int size, int32_t *codepoint);
const char *__fastcall utf8_iterate(const char *buffer, int32_t *codepoint);
int __fastcall utf8_check_string(const char *string, int length);
json_t *__fastcall json_integer_copy(const json_t *integer);
json_t **__fastcall json_array_grow(json_array_t *array, size_t amount, int copy);
int __fastcall json_equal_0(json_t *json1, json_t *json2);
json_t_0 *json_object(); // idb
size_t __fastcall json_object_size(const json_t *json);
json_t *__fastcall json_object_get(const json_t *json, const char *key);
int __fastcall json_object_del(json_t *json, const char *key);
int __fastcall json_object_clear(json_t *json);
void *__fastcall json_object_iter(json_t *json);
void *__fastcall json_object_iter_at(json_t *json, const char *key);
void *__fastcall json_object_iter_next(json_t *json, void *iter);
const char *__fastcall json_object_iter_key(void *iter);
json_t *__fastcall json_object_iter_value(void *iter);
int __fastcall json_object_iter_set_new(json_t *json, void *iter, json_t *value);
void *__fastcall json_object_key_to_iter(const char *key);
json_t *json_array(); // idb
size_t __fastcall json_array_size(const json_t *json);
json_t *__fastcall json_array_get(const json_t *json, size_t index);
int __fastcall json_array_extend(json_t *json, json_t *other_json);
json_t *__fastcall json_string_nocheck(const char *value);
json_t *__fastcall json_string(const char *value);
const char *__fastcall json_string_value(const json_t *json);
int __fastcall json_string_set_nocheck(json_t *json, const char *value);
int __fastcall json_string_set(json_t *json, const char *value);
json_t *__fastcall json_integer(json_int_t value);
json_int_t __fastcall json_integer_value(const json_t *json);
int __fastcall json_integer_set(json_t *json, int a2, json_t value);
json_t *__fastcall json_real(double value); // idb
double __fastcall json_real_value(const json_t *json);
int __fastcall json_real_set(json_t *json, double value); // idb
double __fastcall json_number_value(const json_t *json);
json_t *json_true(); // idb
json_t *json_false(); // idb
json_t *json_null(); // idb
void __fastcall json_delete(json_t *json);
int __fastcall json_array_clear(json_t *json);
int __fastcall json_array_remove(json_t *json, size_t index);
int __fastcall json_array_set_new(json_t *json, size_t index, json_t *value);
int __fastcall json_object_set_new_nocheck(json_t *json, const char *key, json_t *value);
int __fastcall json_object_update(json_t *object, json_t *other);
int __fastcall json_object_update_existing(json_t *object, json_t *other);
int __fastcall json_object_update_missing(json_t *object, json_t *other);
int __fastcall json_object_set_new(json_t *json, const char *key, json_t *value);
int __fastcall json_array_insert_new(json_t *json, size_t index, json_t *value);
int __fastcall json_array_append_new(json_t *json, json_t *value);
int __fastcall json_equal(json_t *json1, json_t *json2);
json_t *__fastcall json_copy(json_t *json);
json_t *__fastcall json_deep_copy(const json_t *json);
void __fastcall jsonp_error_set_source_0(json_error_t *error, const char *source);
void __fastcall jsonp_error_init(json_error_t *error, const char *source);
void __fastcall jsonp_error_set_source(json_error_t *error, const char *source);
void jsonp_error_set(json_error_t *error, int line, int column, int position, const char *msg, ...);
void __fastcall jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const char *msg, va_list ap);
char *__fastcall arg_bad(const char *fmt, const char *arg);
char *__fastcall opt_set_bool(bool *b);
char *__fastcall opt_set_invbool(bool *b);
char *__fastcall opt_set_bool_arg(const char *arg, bool *b);
char *__fastcall opt_set_invbool_arg(const char *arg, bool *b);
char *__fastcall opt_set_charp(const char *arg, char **p);
char *__fastcall opt_set_floatval(const char *arg, float *f);
char *__fastcall opt_set_longval(const char *arg, int *l);
char *__fastcall opt_set_intval(const char *arg, int *i);
char *__fastcall opt_set_uintval(const char *arg, unsigned int *ui);
char *__fastcall opt_set_ulongval(const char *arg, unsigned int *ul);
char *__fastcall opt_inc_intval(int *i);
char *__fastcall opt_version_and_exit(const char *version);
char *__fastcall opt_usage_and_exit(const char *extra);
void __fastcall opt_show_bool(char *buf, const bool *b);
void __fastcall opt_show_invbool(char *buf, const bool *b);
void __fastcall opt_show_charp(char *buf, char *const *p);
void __fastcall opt_show_intval(char *buf, const int *i);
void __fastcall opt_show_floatval(char *buf, const float *f);
void __fastcall opt_show_uintval(char *buf, const unsigned int *ui);
void __fastcall opt_show_longval(char *buf, const int *l);
void __fastcall opt_show_ulongval(char *buf, const unsigned int *ul);
const char *__fastcall first_opt(unsigned int *i, unsigned int *len);
const char *__fastcall next_name(const char *names, unsigned int *len);
const char *__fastcall next_opt(const char *p, unsigned int *i, unsigned int *len);
void __fastcall check_opt(const opt_table *entry);
void __fastcall add_opt(const opt_table *entry);
const char *__fastcall first_lopt(unsigned int *i, unsigned int *len);
const char *__fastcall next_lopt(const char *p, unsigned int *i, unsigned int *len);
const char *__fastcall first_sopt(unsigned int *i);
const char *__fastcall next_sopt(const char *p, unsigned int *i);
void __fastcall opt_register(const char *names, opt_type type, char *(*cb)(void *), char *(*cb_arg)(const char *, void *), void (*show)(char *, const void *), const void *arg, const char *desc);
void __fastcall opt_register_table(const opt_table *entry, const char *desc);
bool __fastcall opt_parse(int *argc, char **argv, void (*errlog)(const char *, ...));
void opt_free_table(); // idb
void opt_log_stderr(const char *fmt, ...);
void opt_log_stderr_exit(const char *fmt, ...);
char *__fastcall opt_invalid_argument(const char *arg);
void __fastcall consume_option(int *argc, char **argv, unsigned int optnum);
int __fastcall parse_one(int *argc, char **argv, unsigned int *offset, void (*errlog)(const char *, ...));
char *__fastcall opt_usage(const char *argv0, const char *extra);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2); // idb
int _aeabi_ldiv0();
UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp);
void __fastcall init(int argc, char **argv, char **envp);
void _libc_csu_fini(); // idb
bool __fastcall j_io_add(io_data *io_data, char *buf);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN loc_1229C; weak
// extern _UNKNOWN loc_122A0; weak
_UNKNOWN loc_13880; // weak
_UNKNOWN loc_1869E; // weak
_UNKNOWN loc_201FC; // weak
_UNKNOWN loc_24020; // weak
_UNKNOWN loc_30D3E; // weak
_UNKNOWN loc_493DE; // weak
_UNKNOWN loc_4BD38; // weak
const char _func___16862[13] = "miner_thread"; // idb
_UNKNOWN innerpad_13357; // weak
const uint32_t ihash_finalblk_13384 = 1u; // idb
benchfile_layout benchfile_data[5] =
{
  { 1, "Version" },
  { 64, "MerkleRoot" },
  { 64, "PrevHash" },
  { 8, "DifficultyBits" },
  { 10, "NonceTime" }
}; // idb
const pthread_mutex_t _func___14516 = { { 1819242352, 1702065247u, 116, 1819242352, 1818457183u, { 7496037 } } }; // idb
const pthread_mutex_t _func___16532 = { { 1600351849, 1601594724u, 1952543859, 29557, 1701536119u, { 1937205087 } } }; // idb
const pthread_mutex_t _func___15752 = { { 1953719666, 1601466977u, 1953063287, 0, 1635020660u, { 1870094188 } } }; // idb
const pthread_rwlock_t _func___16717 =
{
  {
    1600414817u,
    1969583473u,
    25701u,
    1802661751u,
    1836016479u,
    1952803952u,
    101u,
    100u,
    0u,
    0u,
    1701536116
  }
}; // idb
const pthread_rwlock_t _func___16796 =
{
  {
    1600481121u,
    1969583473u,
    2002740325u,
    7041647u,
    1937075302u,
    1970364264u,
    101u,
    117u,
    101u,
    0u,
    1852796003
  }
}; // idb
const pthread_rwlock_t _func___16758 =
{
  {
    1852796003u,
    1970364261u,
    1684370789u,
    1919907679u,
    2036490091u,
    1935960429u,
    116u,
    97u,
    116u,
    101u,
    0
  }
}; // idb
const pthread_rwlock_t _func___16774 =
{
  {
    1684957542u,
    1702195551u,
    1600415093u,
    1802661751u,
    1769562719u,
    100u,
    102u,
    105u,
    110u,
    100u,
    1702195551
  }
}; // idb
const pthread_rwlock_t _func___14460 =
{
  {
    1601463655u,
    1769366884u,
    7562595u,
    1869768058u,
    1635021663u,
    29556u,
    103u,
    101u,
    116u,
    95u,
    1701996660
  }
}; // idb
const pthread_mutex_t _func___14527 = { { 1920103779, 1601465957u, 1819242352, 0, 1600351849u, { 1802661751 } } }; // idb
const pthread_mutex_t _func___16209 = { { 1885302883, 7301490u, 1600414817, 1819242352, 0u, { 1600351849 } } }; // idb
const pthread_mutex_t _func___15639 = { { 1818326131, 1870094181u, 27506, 1601463655, 1969583473u, { 25701 } } }; // idb
const pthread_rwlock_t _func___15760 =
{
  {
    1953719666u,
    1601466977u,
    1701996660u,
    25697u,
    1634890867u,
    1601009012u,
    115u,
    116u,
    104u,
    114u,
    6578533
  }
}; // idb
const pthread_mutex_t _func___16149 = { { 1936875888, 1953718117u, 1970561394, 1701994349, 1852797043u, { 25971 } } }; // idb
const pthread_rwlock_t _func___17121 =
{
  {
    1650552421u,
    1683973484u,
    1667855973u,
    101u,
    1600414817u,
    1970300771u,
    0u,
    0u,
    0u,
    0u,
    1852399981
  }
}; // idb
const pthread_rwlock_t _func___14711 =
{
  {
    1684107116u,
    1835365471u,
    1969446768u,
    1717989236u,
    115u,
    1852270963u,
    97u,
    108u,
    95u,
    119u,
    1600877167
  }
}; // idb
const char bench_lodiffs[5184] =
{
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  'c',
  '0',
  '1',
  'f',
  '5',
  '0',
  '2',
  'c',
  'b',
  '3',
  'e',
  '9',
  'f',
  'd',
  'b',
  '0',
  '5',
  '3',
  '2',
  '3',
  '0',
  'e',
  'c',
  '1',
  '2',
  'a',
  '4',
  '9',
  '5',
  '4',
  'c',
  '1',
  '0',
  '2',
  '1',
  'a',
  '6',
  'b',
  '3',
  '5',
  '8',
  '6',
  '2',
  'b',
  '5',
  'e',
  '2',
  '9',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '4',
  'd',
  '1',
  'b',
  '8',
  '3',
  'a',
  'e',
  '4',
  '4',
  '0',
  '5',
  '7',
  '0',
  '2',
  '5',
  'e',
  '8',
  'c',
  '5',
  'b',
  '5',
  '7',
  '5',
  '6',
  'b',
  '4',
  '4',
  'f',
  '0',
  '4',
  'd',
  'f',
  '5',
  'f',
  'f',
  'f',
  'e',
  '4',
  'a',
  '7',
  'a',
  '3',
  '0',
  'e',
  '5',
  'c',
  '1',
  '2',
  'd',
  '1',
  '2',
  'a',
  '9',
  '7',
  'a',
  '7',
  'a',
  '4',
  'c',
  '2',
  'e',
  'a',
  '5',
  '3',
  '6',
  'd',
  'c',
  'e',
  '4',
  '3',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'b',
  '6',
  'd',
  '6',
  '0',
  'e',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'd',
  '0',
  '8',
  'f',
  '7',
  'e',
  '1',
  '4',
  'c',
  '5',
  '0',
  'd',
  'a',
  'd',
  '7',
  '7',
  'd',
  'c',
  '2',
  '3',
  '8',
  'b',
  '4',
  'd',
  'b',
  '2',
  '9',
  '0',
  '1',
  'a',
  '0',
  '5',
  '7',
  '8',
  'e',
  '6',
  '5',
  '7',
  'b',
  '1',
  '9',
  '5',
  '4',
  '7',
  '7',
  '9',
  'a',
  'b',
  '9',
  'c',
  'd',
  '8',
  '2',
  'a',
  '7',
  '3',
  '8',
  '2',
  '9',
  'e',
  'd',
  'f',
  '7',
  'f',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'c',
  '1',
  'a',
  '1',
  '7',
  '4',
  '2',
  '5',
  '4',
  'a',
  '6',
  '5',
  '9',
  '3',
  'f',
  'f',
  'b',
  'a',
  '9',
  '8',
  '7',
  'f',
  '6',
  '8',
  'f',
  'e',
  '2',
  '6',
  'e',
  '7',
  '1',
  '6',
  'e',
  '3',
  'c',
  '1',
  '2',
  '9',
  'a',
  '7',
  'f',
  '3',
  '3',
  'a',
  '9',
  'c',
  '4',
  '3',
  'a',
  'e',
  '7',
  'e',
  'c',
  'f',
  '9',
  '0',
  'c',
  '8',
  'c',
  'd',
  '0',
  'd',
  '2',
  'c',
  '5',
  '3',
  '6',
  'd',
  'c',
  '4',
  'e',
  '6',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '8',
  'f',
  '8',
  '1',
  '0',
  '0',
  '1',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '6',
  '7',
  '0',
  '0',
  'a',
  'e',
  'e',
  'd',
  'a',
  'd',
  'a',
  '2',
  'b',
  '3',
  '8',
  '7',
  '7',
  '9',
  '0',
  '0',
  'b',
  '5',
  '8',
  'a',
  '1',
  '8',
  '3',
  'c',
  '4',
  '2',
  'c',
  '4',
  '0',
  '9',
  '4',
  '9',
  '9',
  '5',
  '6',
  'b',
  'b',
  '8',
  'b',
  '4',
  'a',
  '8',
  'd',
  '2',
  '1',
  '4',
  '8',
  '1',
  'f',
  '8',
  '9',
  '3',
  '6',
  'b',
  '5',
  '7',
  '2',
  '9',
  '2',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '3',
  '8',
  'c',
  'f',
  '4',
  'b',
  '6',
  '1',
  'd',
  'f',
  'f',
  '7',
  '4',
  'e',
  '3',
  'c',
  '2',
  '6',
  'b',
  '2',
  'd',
  '8',
  '0',
  '0',
  '4',
  '5',
  '0',
  '6',
  '4',
  'e',
  '8',
  'a',
  'b',
  '4',
  '8',
  '0',
  '2',
  '5',
  '2',
  '1',
  'b',
  'a',
  'b',
  '2',
  'c',
  'd',
  'a',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '7',
  '1',
  'e',
  'e',
  'f',
  '6',
  '4',
  'a',
  '7',
  'e',
  'f',
  '4',
  'e',
  '4',
  '7',
  'c',
  'd',
  'a',
  '1',
  '6',
  'e',
  '9',
  '6',
  '6',
  '7',
  '3',
  '1',
  '9',
  '7',
  'd',
  '3',
  '6',
  'c',
  '7',
  '2',
  '3',
  '5',
  'a',
  '4',
  'a',
  'a',
  'd',
  'd',
  '2',
  '3',
  'c',
  '2',
  '1',
  'a',
  '3',
  '8',
  'c',
  'e',
  '5',
  '3',
  '8',
  '2',
  '7',
  'd',
  '1',
  'f',
  '8',
  'b',
  'c',
  '5',
  '3',
  '6',
  'd',
  'c',
  '4',
  'd',
  '7',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'e',
  '9',
  '6',
  'b',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  '7',
  '3',
  '0',
  'c',
  'f',
  '7',
  'a',
  '6',
  'b',
  '8',
  'a',
  '8',
  '5',
  'e',
  'b',
  '1',
  'c',
  'c',
  '0',
  '1',
  '7',
  'b',
  '1',
  '0',
  '9',
  'd',
  '2',
  '3',
  'c',
  '3',
  '9',
  '2',
  '4',
  '6',
  '4',
  'f',
  '9',
  '9',
  'a',
  'a',
  '8',
  'c',
  '0',
  '2',
  '0',
  'e',
  'a',
  '1',
  '0',
  '7',
  'c',
  '5',
  '2',
  '5',
  'b',
  '6',
  '7',
  '1',
  'a',
  'd',
  'd',
  'e',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'f',
  'e',
  '2',
  'c',
  '6',
  'b',
  '9',
  '2',
  '6',
  '4',
  '6',
  '8',
  '5',
  '6',
  '5',
  'e',
  '5',
  '2',
  '4',
  'a',
  'b',
  '7',
  'c',
  '2',
  'f',
  '1',
  '1',
  '1',
  '0',
  '3',
  '5',
  'd',
  'c',
  'd',
  'e',
  '7',
  'c',
  '6',
  '0',
  '9',
  '5',
  '5',
  '8',
  '4',
  '2',
  '1',
  '1',
  '1',
  '9',
  '3',
  '0',
  '5',
  '8',
  '9',
  'e',
  'c',
  'c',
  'b',
  '4',
  '1',
  '0',
  'f',
  '8',
  '3',
  '5',
  '3',
  '6',
  'd',
  'c',
  '6',
  '6',
  'b',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'f',
  '4',
  '2',
  '9',
  '0',
  '0',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '2',
  '7',
  'd',
  'b',
  'b',
  '3',
  '7',
  '4',
  'a',
  '9',
  '7',
  'f',
  '1',
  '5',
  'c',
  '5',
  '9',
  '5',
  '8',
  '7',
  '2',
  '5',
  '6',
  '6',
  '6',
  '2',
  'f',
  '3',
  '6',
  '9',
  '0',
  '4',
  'd',
  '0',
  '7',
  '5',
  'd',
  '0',
  'e',
  '6',
  '1',
  'f',
  '7',
  '4',
  '9',
  '6',
  '1',
  '8',
  '1',
  '8',
  '2',
  '7',
  '1',
  '1',
  '2',
  '8',
  '8',
  'a',
  'c',
  '6',
  '1',
  '7',
  'c',
  '7',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '3',
  '0',
  '7',
  '3',
  '3',
  '8',
  '5',
  'e',
  '0',
  '5',
  'c',
  '2',
  '9',
  'f',
  '0',
  '4',
  '3',
  '5',
  'a',
  '6',
  '0',
  '0',
  '1',
  'c',
  '8',
  'e',
  'c',
  'a',
  '9',
  'c',
  '8',
  'd',
  '5',
  '6',
  '0',
  '2',
  '8',
  '9',
  '0',
  'a',
  'e',
  'f',
  'f',
  '9',
  'd',
  '4',
  'd',
  '1',
  '0',
  '3',
  'd',
  '3',
  '3',
  '8',
  '3',
  'c',
  'f',
  '8',
  '0',
  'd',
  'a',
  'e',
  '5',
  '5',
  '3',
  '6',
  'd',
  'c',
  '5',
  '7',
  'c',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '8',
  '2',
  '1',
  'd',
  '0',
  '0',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '7',
  'd',
  'a',
  '3',
  'b',
  '9',
  '7',
  'e',
  '8',
  '2',
  'c',
  '0',
  'c',
  '3',
  '1',
  '2',
  '5',
  'a',
  '5',
  '8',
  'd',
  'a',
  'd',
  '8',
  'a',
  '0',
  'd',
  '1',
  'd',
  '0',
  '3',
  '6',
  '9',
  '2',
  '4',
  '4',
  '7',
  '3',
  '1',
  'f',
  '3',
  'b',
  '0',
  '9',
  '6',
  'e',
  '9',
  '7',
  '2',
  '4',
  '8',
  '4',
  '2',
  '9',
  '8',
  'd',
  '1',
  '5',
  'b',
  '8',
  '4',
  '3',
  'd',
  '9',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '9',
  'c',
  'a',
  '5',
  '5',
  'e',
  '5',
  'f',
  '1',
  'b',
  'c',
  '0',
  '3',
  '2',
  '8',
  'c',
  '8',
  '4',
  'f',
  '3',
  '5',
  '8',
  'f',
  'd',
  'd',
  'a',
  'd',
  'c',
  '1',
  '3',
  'c',
  'b',
  '2',
  '3',
  '2',
  '5',
  '9',
  '9',
  'b',
  'c',
  '2',
  'c',
  'a',
  '9',
  'd',
  'b',
  'e',
  '1',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'b',
  '5',
  'b',
  '4',
  'd',
  '1',
  '9',
  'c',
  '2',
  '0',
  'a',
  '7',
  'f',
  'c',
  '2',
  'b',
  '1',
  '7',
  '4',
  'f',
  'f',
  '6',
  '7',
  '3',
  'c',
  '0',
  '0',
  '6',
  'e',
  'd',
  'd',
  '2',
  '2',
  '4',
  '7',
  'c',
  '4',
  'b',
  '2',
  '3',
  '3',
  '6',
  '5',
  '7',
  '1',
  '8',
  '6',
  '4',
  'd',
  'f',
  '9',
  '3',
  'e',
  'b',
  '7',
  'e',
  'c',
  '0',
  'c',
  '8',
  'c',
  '2',
  '7',
  '6',
  '5',
  '3',
  '6',
  'd',
  'f',
  'e',
  '0',
  '4',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'e',
  '6',
  '3',
  'c',
  '0',
  '0',
  '5',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '1',
  '5',
  '1',
  '4',
  'b',
  'd',
  '5',
  '8',
  '6',
  '5',
  '1',
  '1',
  'e',
  '5',
  '3',
  '1',
  'e',
  '2',
  'b',
  '6',
  '2',
  '7',
  '7',
  'a',
  '6',
  'd',
  '1',
  '1',
  '2',
  'b',
  '1',
  '7',
  '1',
  'f',
  '9',
  'e',
  '0',
  '0',
  '8',
  'd',
  '5',
  '6',
  'e',
  'f',
  '4',
  'a',
  '9',
  '7',
  '1',
  'e',
  '6',
  '1',
  '9',
  'a',
  'c',
  'f',
  '2',
  '2',
  'e',
  '7',
  '5',
  '0',
  '7',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '3',
  'e',
  '3',
  '0',
  '3',
  '0',
  '6',
  '2',
  '9',
  'f',
  'f',
  '4',
  '2',
  '5',
  '8',
  '0',
  '5',
  '6',
  'd',
  'c',
  '9',
  'e',
  'f',
  'a',
  'f',
  '9',
  '2',
  '2',
  'b',
  'd',
  '1',
  '7',
  '3',
  'a',
  '6',
  '5',
  'f',
  '6',
  '5',
  'e',
  'e',
  '7',
  '9',
  '9',
  'b',
  '0',
  'c',
  '7',
  '6',
  '5',
  '0',
  '9',
  '7',
  'd',
  '3',
  'd',
  'e',
  'e',
  'd',
  'd',
  'e',
  'f',
  '1',
  '0',
  '5',
  '3',
  '6',
  'd',
  'c',
  '4',
  'd',
  '8',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '1',
  '4',
  '4',
  '3',
  '0',
  '0',
  '6',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'd',
  'c',
  'b',
  '7',
  '7',
  'a',
  '9',
  'c',
  '3',
  '6',
  'd',
  '8',
  '9',
  '4',
  'd',
  '2',
  'd',
  'b',
  'c',
  '3',
  '1',
  '4',
  '3',
  '7',
  'e',
  '5',
  'c',
  '2',
  'a',
  '1',
  '5',
  '6',
  '4',
  'e',
  '9',
  '2',
  '7',
  '9',
  '3',
  '7',
  '8',
  '4',
  '8',
  'e',
  'a',
  '2',
  'e',
  'b',
  '2',
  '0',
  'b',
  '3',
  '8',
  '6',
  '3',
  '8',
  'a',
  'f',
  'c',
  '6',
  '4',
  'b',
  '9',
  '6',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '5',
  '5',
  '1',
  '3',
  'c',
  '2',
  '2',
  'b',
  'b',
  '9',
  '9',
  'e',
  '9',
  'd',
  'a',
  'a',
  '9',
  '9',
  '3',
  '6',
  'b',
  '0',
  'd',
  'f',
  '5',
  'd',
  'c',
  'e',
  '6',
  '4',
  'd',
  '7',
  '7',
  '3',
  '7',
  'e',
  '3',
  '7',
  '0',
  '6',
  'b',
  'e',
  '9',
  '9',
  'e',
  '5',
  '0',
  '9',
  '8',
  'd',
  '1',
  '1',
  '2',
  '0',
  '0',
  '2',
  '4',
  '9',
  '2',
  'c',
  'f',
  '8',
  '1',
  'b',
  '5',
  '3',
  '6',
  'd',
  'c',
  '5',
  '6',
  '9',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'd',
  '4',
  '4',
  '1',
  '0',
  '0',
  '7',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  'd',
  '8',
  '9',
  '6',
  '2',
  '6',
  '7',
  'f',
  'd',
  'a',
  '5',
  'd',
  'd',
  'a',
  '0',
  'f',
  '8',
  '5',
  '3',
  '0',
  '8',
  'e',
  '7',
  '7',
  'f',
  '7',
  '5',
  '4',
  'c',
  '8',
  'b',
  '9',
  '4',
  'b',
  '7',
  'b',
  '8',
  '8',
  'e',
  '3',
  'c',
  'b',
  '3',
  '1',
  '5',
  '4',
  '7',
  '5',
  'c',
  'd',
  '9',
  'e',
  'f',
  'd',
  '1',
  '6',
  '4',
  '0',
  '1',
  'e',
  '3',
  'c',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  'e',
  '1',
  '5',
  '5',
  'f',
  '0',
  '7',
  'e',
  '6',
  '5',
  '2',
  'e',
  '4',
  'd',
  '6',
  '7',
  '1',
  'c',
  'a',
  '4',
  'd',
  'b',
  '5',
  '1',
  'b',
  'b',
  'd',
  'e',
  '1',
  '4',
  'd',
  '2',
  'b',
  '5',
  'a',
  'e',
  '3',
  '4',
  'e',
  'e',
  '6',
  '7',
  'e',
  'c',
  'c',
  '7',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '4',
  'a',
  'f',
  '5',
  'c',
  'f',
  'f',
  'd',
  '7',
  'e',
  '5',
  'a',
  '7',
  '0',
  '8',
  '7',
  'f',
  '1',
  'b',
  '4',
  '8',
  '4',
  'b',
  '5',
  '2',
  '6',
  'c',
  '7',
  '3',
  '5',
  '0',
  'c',
  '8',
  '6',
  'd',
  '8',
  '3',
  '8',
  '9',
  '2',
  '8',
  '3',
  '5',
  '0',
  '9',
  'c',
  'a',
  '8',
  '7',
  '8',
  '5',
  '0',
  '2',
  'f',
  '7',
  '9',
  '2',
  '1',
  '1',
  '5',
  'e',
  '8',
  'd',
  'c',
  '5',
  '3',
  '6',
  'd',
  'c',
  '6',
  'a',
  'd',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '9',
  '9',
  '9',
  'd',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '3',
  '3',
  '9',
  '3',
  '5',
  '4',
  '5',
  '6',
  '8',
  'f',
  '5',
  '0',
  '6',
  'a',
  'c',
  '3',
  'c',
  'd',
  '6',
  '9',
  'b',
  'b',
  '4',
  '2',
  '7',
  'b',
  '1',
  'a',
  'f',
  '8',
  '3',
  'a',
  '0',
  '4',
  '7',
  '3',
  'b',
  '8',
  '7',
  'c',
  '1',
  '6',
  'b',
  'f',
  '3',
  'b',
  '5',
  '6',
  '2',
  'a',
  '9',
  '3',
  'd',
  '0',
  'a',
  '2',
  'f',
  'f',
  'c',
  '5',
  '3',
  'e',
  '5',
  '4',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '9',
  'c',
  'a',
  '5',
  '5',
  'e',
  '5',
  'f',
  '1',
  'b',
  'c',
  '0',
  '3',
  '2',
  '8',
  'c',
  '8',
  '4',
  'f',
  '3',
  '5',
  '8',
  'f',
  'd',
  'd',
  'a',
  'd',
  'c',
  '1',
  '3',
  'c',
  'b',
  '2',
  '3',
  '2',
  '5',
  '9',
  '9',
  'b',
  'c',
  '2',
  'c',
  'a',
  '9',
  'd',
  'b',
  'e',
  '1',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '5',
  '9',
  '2',
  '5',
  'a',
  '6',
  '2',
  '4',
  'e',
  '5',
  'c',
  '8',
  '4',
  'f',
  '9',
  '6',
  'd',
  '2',
  'c',
  '3',
  '4',
  'd',
  'c',
  'e',
  '3',
  'b',
  '6',
  'a',
  '7',
  '3',
  '6',
  'a',
  'd',
  'd',
  'b',
  '8',
  '9',
  '1',
  '7',
  '2',
  '4',
  'b',
  '4',
  '8',
  'a',
  '3',
  '6',
  '3',
  '2',
  '0',
  'c',
  '7',
  '4',
  '9',
  '4',
  '4',
  '3',
  '5',
  'f',
  '9',
  'c',
  '9',
  '1',
  '5',
  '5',
  '3',
  '6',
  'd',
  'f',
  'e',
  '6',
  '2',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '1',
  '4',
  'f',
  'b',
  '0',
  '0',
  '9',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '8',
  '3',
  '6',
  '2',
  '0',
  '0',
  '9',
  'c',
  '0',
  '7',
  'c',
  'f',
  '4',
  '8',
  '2',
  '4',
  '9',
  'f',
  '4',
  '8',
  '1',
  'b',
  'e',
  '6',
  'b',
  '7',
  '9',
  'e',
  '6',
  '7',
  '2',
  '4',
  '7',
  'c',
  'a',
  'b',
  '1',
  'd',
  '2',
  '0',
  '0',
  '5',
  '0',
  'c',
  'f',
  '1',
  '1',
  'c',
  '2',
  '7',
  '6',
  '0',
  '8',
  '5',
  'b',
  '9',
  '0',
  '7',
  '3',
  '2',
  '1',
  '1',
  '0',
  'c',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  'e',
  '1',
  '5',
  '5',
  'f',
  '0',
  '7',
  'e',
  '6',
  '5',
  '2',
  'e',
  '4',
  'd',
  '6',
  '7',
  '1',
  'c',
  'a',
  '4',
  'd',
  'b',
  '5',
  '1',
  'b',
  'b',
  'd',
  'e',
  '1',
  '4',
  'd',
  '2',
  'b',
  '5',
  'a',
  'e',
  '3',
  '4',
  'e',
  'e',
  '6',
  '7',
  'e',
  'c',
  'c',
  '7',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '1',
  'e',
  '6',
  '9',
  'f',
  '1',
  'd',
  '6',
  '5',
  '0',
  '7',
  'f',
  '4',
  'b',
  '7',
  'b',
  '5',
  '0',
  '9',
  '8',
  '0',
  '9',
  '3',
  '0',
  'f',
  '7',
  'd',
  '8',
  '0',
  '8',
  '9',
  '8',
  '3',
  '4',
  'f',
  'b',
  'e',
  '6',
  '5',
  'f',
  '0',
  '9',
  '8',
  '0',
  'b',
  '8',
  '5',
  '9',
  '2',
  'd',
  '5',
  '3',
  'c',
  'd',
  'd',
  'a',
  '0',
  '8',
  'e',
  '5',
  '0',
  'd',
  '2',
  '4',
  '5',
  '3',
  '6',
  'd',
  'c',
  '7',
  'd',
  'a',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '5',
  'e',
  'e',
  'b',
  '0',
  '0',
  'a',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  'e',
  '4',
  'f',
  '6',
  '5',
  '4',
  'd',
  '2',
  '6',
  'a',
  'b',
  '8',
  'c',
  '9',
  '1',
  '6',
  '4',
  'f',
  'f',
  '3',
  '1',
  '1',
  '6',
  '5',
  '7',
  'a',
  '9',
  'f',
  '9',
  'c',
  '4',
  'c',
  'd',
  'c',
  '0',
  'e',
  '8',
  'a',
  '0',
  '9',
  '3',
  '3',
  '4',
  '9',
  '2',
  '5',
  'f',
  '7',
  'c',
  '0',
  '2',
  '1',
  '3',
  '8',
  '8',
  '1',
  '9',
  'd',
  '7',
  'e',
  '6',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '6',
  '4',
  '9',
  '2',
  '3',
  'b',
  '6',
  '3',
  'f',
  '5',
  '3',
  'c',
  '7',
  '2',
  'c',
  '0',
  '4',
  'e',
  'b',
  'e',
  '6',
  'c',
  '1',
  'c',
  '9',
  '1',
  '4',
  '0',
  'b',
  '6',
  '3',
  '7',
  '7',
  '1',
  '3',
  '2',
  'b',
  '6',
  'e',
  '5',
  '0',
  '8',
  '6',
  '5',
  '8',
  '1',
  '4',
  'f',
  'e',
  '5',
  '6',
  '2',
  '2',
  '9',
  '1',
  'b',
  'd',
  '0',
  '2',
  '3',
  'd',
  '3',
  '4',
  '8',
  '5',
  '3',
  '6',
  'd',
  'c',
  '6',
  '5',
  'a',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'c',
  '5',
  '2',
  'e',
  '0',
  '0',
  'b',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '5',
  '5',
  'd',
  'b',
  '9',
  '1',
  'a',
  '2',
  '5',
  '4',
  '0',
  '1',
  'a',
  '8',
  '9',
  'd',
  'a',
  'f',
  '9',
  'f',
  'f',
  '7',
  'd',
  '7',
  '9',
  '5',
  '4',
  'b',
  'a',
  'b',
  '7',
  '2',
  '2',
  'b',
  '8',
  '9',
  '4',
  'b',
  'a',
  '4',
  '8',
  '0',
  'f',
  'e',
  'f',
  'a',
  'f',
  '1',
  'f',
  '0',
  'a',
  '9',
  '5',
  'a',
  'a',
  'f',
  '5',
  'f',
  '6',
  '0',
  '0',
  '5',
  '6',
  '7',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'e',
  'e',
  '9',
  '8',
  '1',
  '7',
  '1',
  '6',
  '0',
  'e',
  '3',
  '5',
  'd',
  '4',
  '4',
  '1',
  '0',
  '6',
  '0',
  '1',
  'c',
  '8',
  'd',
  'c',
  '7',
  '4',
  '1',
  'c',
  '1',
  'a',
  '8',
  '1',
  '0',
  'c',
  '4',
  '8',
  '5',
  'f',
  '3',
  'b',
  '4',
  '0',
  'a',
  '0',
  '8',
  '5',
  '9',
  'b',
  'e',
  '5',
  'f',
  '5',
  '8',
  'f',
  '0',
  'b',
  'f',
  '6',
  'e',
  'f',
  '1',
  '6',
  '9',
  '4',
  '5',
  '3',
  '6',
  'd',
  'c',
  '6',
  '3',
  '2',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '6',
  'e',
  '1',
  'f',
  '0',
  '0',
  'c',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'a',
  'e',
  '2',
  '1',
  '5',
  '7',
  '8',
  '5',
  '1',
  '7',
  '8',
  'f',
  'f',
  '6',
  '3',
  '5',
  '0',
  '0',
  '6',
  '4',
  '0',
  '6',
  '0',
  'e',
  'b',
  'b',
  'b',
  '2',
  '1',
  '9',
  'a',
  '7',
  '1',
  '7',
  '1',
  '6',
  'a',
  '1',
  '0',
  'e',
  '8',
  '8',
  '5',
  '2',
  '8',
  'f',
  'c',
  '4',
  'b',
  'b',
  '1',
  'c',
  'b',
  '5',
  'c',
  '8',
  'f',
  'd',
  'd',
  '0',
  'c',
  'f',
  '6',
  '0',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '9',
  'c',
  'a',
  '5',
  '5',
  'e',
  '5',
  'f',
  '1',
  'b',
  'c',
  '0',
  '3',
  '2',
  '8',
  'c',
  '8',
  '4',
  'f',
  '3',
  '5',
  '8',
  'f',
  'd',
  'd',
  'a',
  'd',
  'c',
  '1',
  '3',
  'c',
  'b',
  '2',
  '3',
  '2',
  '5',
  '9',
  '9',
  'b',
  'c',
  '2',
  'c',
  'a',
  '9',
  'd',
  'b',
  'e',
  '1',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '1',
  'e',
  '5',
  '1',
  '4',
  'c',
  'f',
  '7',
  '3',
  '8',
  '4',
  '5',
  '5',
  'a',
  '5',
  '4',
  'f',
  '0',
  '0',
  '4',
  'e',
  'c',
  '8',
  '6',
  'e',
  'd',
  'a',
  'f',
  'c',
  'f',
  'd',
  '9',
  'f',
  'd',
  '2',
  '0',
  '2',
  '2',
  '0',
  '1',
  '7',
  'b',
  'b',
  '3',
  '1',
  'c',
  '2',
  '4',
  '5',
  '3',
  '4',
  '0',
  '3',
  '5',
  '3',
  '9',
  '1',
  '1',
  '7',
  '4',
  '4',
  'f',
  'b',
  '7',
  '5',
  '3',
  '6',
  'd',
  'f',
  'e',
  '1',
  'f',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '2',
  '6',
  '5',
  'f',
  '0',
  '0',
  'd',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'd',
  'c',
  'a',
  'f',
  'a',
  'a',
  '8',
  '6',
  'd',
  'e',
  'f',
  'e',
  '8',
  '5',
  '0',
  'b',
  '0',
  '5',
  '7',
  'a',
  'e',
  '7',
  '4',
  'f',
  '7',
  '2',
  '1',
  '8',
  'a',
  '7',
  '9',
  'b',
  '0',
  'e',
  'd',
  'e',
  '0',
  '8',
  '6',
  'a',
  '1',
  '9',
  '6',
  'f',
  '1',
  '8',
  'f',
  '0',
  'e',
  '7',
  'c',
  '5',
  '8',
  '5',
  'e',
  'b',
  '8',
  '8',
  'd',
  '1',
  '1',
  '3',
  '9',
  'a',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '5',
  'e',
  'd',
  'b',
  'd',
  '5',
  '3',
  'f',
  'c',
  'c',
  '6',
  '4',
  '8',
  '5',
  '0',
  'b',
  '5',
  '3',
  '3',
  '4',
  '6',
  '7',
  '8',
  '1',
  '9',
  '9',
  'd',
  '7',
  '6',
  '9',
  '5',
  '1',
  '4',
  '8',
  '1',
  '8',
  'f',
  'b',
  'c',
  'c',
  '7',
  '9',
  '8',
  '6',
  '1',
  'f',
  'c',
  '7',
  '7',
  'e',
  '5',
  '7',
  '2',
  'b',
  'b',
  '4',
  '7',
  '5',
  '3',
  'b',
  '7',
  'f',
  'e',
  '2',
  '5',
  '3',
  '6',
  'd',
  'c',
  '5',
  'd',
  '9',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '9',
  '3',
  '8',
  '9',
  '0',
  '0',
  'e',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '5',
  'e',
  '6',
  '5',
  '3',
  'd',
  'f',
  '5',
  '9',
  '5',
  '6',
  'e',
  'c',
  'e',
  '5',
  '1',
  '8',
  'a',
  '7',
  '8',
  'a',
  '5',
  'd',
  '1',
  '1',
  '2',
  '9',
  '7',
  '4',
  '3',
  '1',
  'a',
  'f',
  '9',
  '4',
  'c',
  'e',
  '8',
  'b',
  'a',
  '9',
  '1',
  'd',
  '8',
  '0',
  'c',
  'f',
  'b',
  '2',
  'a',
  'a',
  '8',
  'c',
  '5',
  'b',
  '3',
  '0',
  '9',
  '5',
  'f',
  'a',
  '2',
  '5',
  '6',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'b',
  'f',
  '5',
  '3',
  'e',
  'f',
  '3',
  '4',
  '3',
  'a',
  '5',
  '0',
  'f',
  '7',
  '5',
  '9',
  '9',
  '6',
  '0',
  '1',
  'f',
  '8',
  '4',
  '9',
  'c',
  '9',
  '3',
  'e',
  'c',
  'c',
  'e',
  '6',
  '3',
  '5',
  '3',
  '0',
  'b',
  '0',
  'b',
  '4',
  '4',
  '9',
  'a',
  '4',
  '4',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '5',
  '9',
  '6',
  'f',
  'c',
  '4',
  'a',
  'a',
  '5',
  'd',
  'a',
  '8',
  '3',
  '9',
  'b',
  'a',
  '2',
  '6',
  '7',
  'c',
  '3',
  '6',
  'a',
  'a',
  '1',
  'a',
  '5',
  'b',
  '2',
  '9',
  'd',
  '8',
  '1',
  '3',
  '7',
  '4',
  '7',
  'b',
  '2',
  '2',
  '7',
  '3',
  'd',
  'c',
  '0',
  '3',
  'a',
  'a',
  '9',
  'e',
  '4',
  '0',
  '4',
  'c',
  '4',
  'd',
  'a',
  '0',
  '2',
  '3',
  '8',
  'e',
  '2',
  'b',
  '5',
  '3',
  '6',
  'd',
  'c',
  '4',
  'c',
  'c',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '9',
  'e',
  '7',
  '0',
  '0',
  '0',
  'f',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  'e',
  '2',
  '3',
  '8',
  '0',
  '6',
  'a',
  '5',
  '3',
  '3',
  'b',
  'd',
  '9',
  '5',
  '6',
  '7',
  '8',
  '7',
  'e',
  'e',
  'f',
  '5',
  '2',
  'd',
  'd',
  '8',
  'e',
  'd',
  'e',
  'e',
  '4',
  '5',
  '6',
  'c',
  '6',
  '0',
  'd',
  '6',
  'c',
  'e',
  'c',
  'b',
  'b',
  '6',
  '1',
  '7',
  '5',
  '4',
  '5',
  '8',
  'e',
  'e',
  '5',
  '3',
  'f',
  'c',
  '8',
  'c',
  '6',
  'c',
  '8',
  '1',
  '3',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
const char bench_hidiffs[5184] =
{
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '9',
  'c',
  '6',
  'b',
  'f',
  '4',
  '6',
  '9',
  'a',
  'b',
  'e',
  '4',
  'a',
  'd',
  '3',
  '7',
  '6',
  '0',
  '5',
  'c',
  '0',
  '9',
  '7',
  'a',
  '8',
  '6',
  '0',
  'c',
  'f',
  'f',
  '3',
  'c',
  'f',
  '5',
  'c',
  '1',
  'e',
  'f',
  '4',
  '3',
  '7',
  '7',
  '6',
  '1',
  '8',
  'f',
  '7',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '2',
  'b',
  '1',
  '5',
  '1',
  '4',
  'e',
  '7',
  'b',
  '6',
  '5',
  '6',
  '5',
  '9',
  '4',
  '1',
  'e',
  '5',
  '8',
  '2',
  '4',
  'f',
  '0',
  '8',
  '4',
  '2',
  '9',
  '2',
  '1',
  '6',
  '4',
  'e',
  'c',
  '5',
  'f',
  '9',
  '7',
  'e',
  '7',
  'e',
  'a',
  '2',
  '0',
  'c',
  '4',
  '9',
  '4',
  'b',
  'd',
  '9',
  '6',
  'e',
  '5',
  '2',
  '4',
  'd',
  '4',
  '7',
  '8',
  '9',
  '7',
  '7',
  'b',
  '5',
  '3',
  '6',
  'd',
  'd',
  '2',
  '2',
  '6',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '8',
  'b',
  '1',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '6',
  '4',
  'e',
  '4',
  'e',
  '3',
  'b',
  'e',
  'c',
  'c',
  '0',
  '1',
  '0',
  '6',
  '4',
  'd',
  '8',
  '0',
  '8',
  '2',
  '6',
  '9',
  'b',
  '3',
  '3',
  '0',
  'f',
  '4',
  '0',
  'f',
  '4',
  'd',
  'e',
  '8',
  '2',
  'd',
  'c',
  '9',
  '2',
  'e',
  '8',
  '9',
  '4',
  'd',
  '6',
  '3',
  '5',
  '0',
  '2',
  '5',
  'd',
  'a',
  'a',
  '3',
  'e',
  '2',
  'e',
  '2',
  'c',
  '4',
  '1',
  '0',
  'b',
  '4',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  'e',
  '7',
  '9',
  '0',
  'c',
  '2',
  '3',
  '9',
  '8',
  '7',
  '1',
  '8',
  '1',
  '9',
  '5',
  '0',
  'e',
  'e',
  'b',
  '1',
  '4',
  '4',
  '5',
  '9',
  '1',
  'c',
  '3',
  'a',
  'c',
  '4',
  'd',
  '0',
  '6',
  'c',
  '0',
  '7',
  '0',
  '5',
  'f',
  '2',
  '8',
  '0',
  '1',
  'd',
  '0',
  '9',
  '7',
  '6',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '9',
  'e',
  'b',
  'b',
  'c',
  'e',
  '2',
  'f',
  '5',
  'f',
  '0',
  'd',
  '6',
  'c',
  'c',
  '0',
  'a',
  'c',
  'a',
  '2',
  '8',
  '4',
  'e',
  'c',
  'b',
  '1',
  '0',
  '5',
  '9',
  'c',
  '8',
  '5',
  '6',
  'e',
  'f',
  '2',
  'f',
  '7',
  'f',
  '4',
  '2',
  'e',
  '7',
  'e',
  'd',
  'd',
  '4',
  '0',
  '3',
  'd',
  '2',
  '4',
  '6',
  '7',
  '5',
  '4',
  'e',
  'e',
  '4',
  'c',
  '9',
  '0',
  '5',
  'a',
  '5',
  '3',
  '6',
  'd',
  'd',
  '2',
  'a',
  '9',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'c',
  'f',
  'd',
  'a',
  '0',
  '3',
  '1',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '4',
  'a',
  '7',
  '8',
  'd',
  'a',
  'f',
  '1',
  'b',
  '5',
  'e',
  'b',
  '3',
  '3',
  '9',
  '7',
  'a',
  'f',
  '1',
  'c',
  '0',
  '0',
  'd',
  'b',
  'd',
  '9',
  'b',
  '0',
  '6',
  '6',
  '5',
  '9',
  'c',
  'd',
  'c',
  '0',
  '4',
  '1',
  '8',
  '3',
  'c',
  '8',
  'b',
  'a',
  'a',
  'f',
  '5',
  'b',
  'e',
  '1',
  'd',
  'b',
  'f',
  '3',
  '2',
  'f',
  '7',
  '9',
  'e',
  '0',
  '0',
  '4',
  '5',
  '9',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'e',
  '9',
  '1',
  'f',
  'c',
  'e',
  '7',
  '3',
  '0',
  '0',
  'a',
  '7',
  '9',
  '2',
  'b',
  'f',
  'b',
  'a',
  'a',
  '0',
  'c',
  '7',
  '6',
  'e',
  '1',
  'a',
  'a',
  '5',
  'f',
  '9',
  'b',
  '5',
  '4',
  '6',
  'c',
  '1',
  'd',
  'b',
  '5',
  '8',
  '2',
  'a',
  'e',
  'e',
  '4',
  'f',
  'f',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'f',
  '0',
  '4',
  '6',
  '5',
  '0',
  'a',
  '8',
  'e',
  '7',
  '4',
  '8',
  'd',
  '2',
  'e',
  '6',
  'f',
  'd',
  'e',
  '8',
  '6',
  'a',
  '8',
  'a',
  '9',
  '2',
  '0',
  'b',
  '2',
  '8',
  '5',
  'f',
  '3',
  'e',
  '2',
  '2',
  '3',
  '9',
  '8',
  'f',
  '5',
  '8',
  '3',
  '7',
  '0',
  '0',
  '2',
  '3',
  '6',
  '9',
  '5',
  '8',
  '3',
  '2',
  '3',
  'e',
  'f',
  '9',
  'e',
  'a',
  '8',
  '3',
  '2',
  '1',
  '5',
  '3',
  '6',
  'd',
  'c',
  'f',
  '4',
  '3',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'b',
  '4',
  '5',
  '7',
  '0',
  'e',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  'a',
  '1',
  'd',
  '6',
  '5',
  '4',
  'a',
  'e',
  '2',
  'b',
  '0',
  '6',
  'f',
  '2',
  '1',
  '9',
  'c',
  'c',
  'f',
  '4',
  '6',
  '0',
  '1',
  '9',
  '3',
  '3',
  'f',
  'a',
  'b',
  '4',
  '0',
  '8',
  'd',
  'e',
  '1',
  'c',
  '3',
  'b',
  '7',
  'c',
  '8',
  'c',
  '9',
  'c',
  '8',
  '5',
  'e',
  '0',
  '3',
  '2',
  '3',
  '1',
  'd',
  '4',
  'a',
  'a',
  'f',
  '5',
  'a',
  '2',
  '6',
  'c',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'e',
  '9',
  '1',
  'f',
  'c',
  'e',
  '7',
  '3',
  '0',
  '0',
  'a',
  '7',
  '9',
  '2',
  'b',
  'f',
  'b',
  'a',
  'a',
  '0',
  'c',
  '7',
  '6',
  'e',
  '1',
  'a',
  'a',
  '5',
  'f',
  '9',
  'b',
  '5',
  '4',
  '6',
  'c',
  '1',
  'd',
  'b',
  '5',
  '8',
  '2',
  'a',
  'e',
  'e',
  '4',
  'f',
  'f',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '7',
  '4',
  'b',
  '3',
  '9',
  '1',
  '3',
  '4',
  'c',
  '2',
  '9',
  '3',
  '0',
  'd',
  '2',
  'f',
  '2',
  'e',
  '7',
  '3',
  '3',
  '9',
  'f',
  '9',
  'd',
  '5',
  '0',
  '2',
  'c',
  '7',
  '7',
  '6',
  'c',
  '4',
  '4',
  'd',
  '6',
  'e',
  'e',
  '5',
  '9',
  '9',
  'f',
  '7',
  'e',
  'f',
  'e',
  'b',
  'e',
  'c',
  '6',
  'c',
  '9',
  'b',
  'b',
  'd',
  '0',
  '4',
  '7',
  '8',
  '7',
  'a',
  'a',
  'e',
  '5',
  '3',
  '6',
  'd',
  'c',
  'e',
  '5',
  '6',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'e',
  '2',
  '7',
  '1',
  '0',
  'f',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '9',
  '4',
  'e',
  '6',
  '0',
  'c',
  '1',
  '1',
  '8',
  '0',
  '0',
  '2',
  '2',
  'f',
  '3',
  '3',
  '7',
  '2',
  '3',
  '2',
  'a',
  'b',
  '3',
  'd',
  '2',
  '9',
  '8',
  'f',
  '8',
  '3',
  '8',
  '3',
  '0',
  '4',
  'b',
  '6',
  '0',
  '0',
  '8',
  'a',
  'b',
  '2',
  '3',
  '7',
  'c',
  'f',
  '7',
  'e',
  '1',
  '7',
  '1',
  '7',
  'f',
  '1',
  '9',
  '3',
  '3',
  '4',
  '0',
  '7',
  'e',
  '5',
  '9',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'e',
  '9',
  '1',
  'f',
  'c',
  'e',
  '7',
  '3',
  '0',
  '0',
  'a',
  '7',
  '9',
  '2',
  'b',
  'f',
  'b',
  'a',
  'a',
  '0',
  'c',
  '7',
  '6',
  'e',
  '1',
  'a',
  'a',
  '5',
  'f',
  '9',
  'b',
  '5',
  '4',
  '6',
  'c',
  '1',
  'd',
  'b',
  '5',
  '8',
  '2',
  'a',
  'e',
  'e',
  '4',
  'f',
  'f',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'c',
  '5',
  'b',
  '8',
  '2',
  '1',
  'f',
  'b',
  '0',
  'b',
  '2',
  '6',
  'd',
  '6',
  '3',
  'b',
  '0',
  '0',
  'c',
  'c',
  '2',
  '6',
  'e',
  '7',
  'a',
  'c',
  '4',
  'd',
  '6',
  'c',
  'f',
  'd',
  '1',
  'd',
  '3',
  'f',
  'c',
  '1',
  '0',
  '9',
  'b',
  '0',
  'd',
  'b',
  '1',
  '8',
  '8',
  'e',
  '7',
  'e',
  '7',
  '9',
  '2',
  'e',
  '3',
  'd',
  '1',
  '8',
  '3',
  '4',
  '2',
  '9',
  '1',
  '9',
  '5',
  '3',
  '6',
  'd',
  'c',
  'e',
  '5',
  '0',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'e',
  'd',
  '4',
  '8',
  '0',
  '5',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'a',
  '2',
  '9',
  '0',
  'e',
  'a',
  'c',
  '6',
  '1',
  '6',
  '4',
  '2',
  '9',
  '4',
  '9',
  'c',
  '0',
  '0',
  'd',
  '1',
  '7',
  'f',
  '7',
  'c',
  'd',
  '5',
  '9',
  '8',
  '0',
  'a',
  'b',
  'e',
  'd',
  'b',
  '8',
  '6',
  '4',
  '7',
  'f',
  'c',
  '5',
  'd',
  'f',
  '9',
  '9',
  '5',
  '5',
  'd',
  'c',
  'f',
  'e',
  '4',
  'd',
  '5',
  '6',
  'a',
  '5',
  '0',
  'a',
  '0',
  'c',
  '5',
  '6',
  '4',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  'e',
  '7',
  '9',
  '0',
  'c',
  '2',
  '3',
  '9',
  '8',
  '7',
  '1',
  '8',
  '1',
  '9',
  '5',
  '0',
  'e',
  'e',
  'b',
  '1',
  '4',
  '4',
  '5',
  '9',
  '1',
  'c',
  '3',
  'a',
  'c',
  '4',
  'd',
  '0',
  '6',
  'c',
  '0',
  '7',
  '0',
  '5',
  'f',
  '2',
  '8',
  '0',
  '1',
  'd',
  '0',
  '9',
  '7',
  '6',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '6',
  'e',
  '9',
  'd',
  '9',
  '4',
  'b',
  'f',
  '5',
  'a',
  '0',
  'a',
  'b',
  '7',
  'b',
  '2',
  '0',
  '2',
  'd',
  '3',
  '9',
  'e',
  '1',
  '2',
  '0',
  '0',
  'a',
  'f',
  '9',
  '6',
  '0',
  '7',
  '4',
  'e',
  '4',
  'f',
  '6',
  '4',
  '1',
  'f',
  '4',
  'e',
  '5',
  '5',
  'e',
  '3',
  'e',
  '9',
  'e',
  '3',
  'a',
  'e',
  'e',
  '7',
  '2',
  'a',
  'a',
  '0',
  '0',
  'a',
  '7',
  '0',
  'e',
  '9',
  '5',
  '3',
  '6',
  'd',
  'd',
  '2',
  'a',
  'e',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '6',
  '0',
  'f',
  '7',
  '0',
  '1',
  '5',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '1',
  '4',
  '7',
  '7',
  'c',
  'a',
  '8',
  '5',
  '3',
  '6',
  '7',
  '0',
  '2',
  'e',
  'a',
  'c',
  'b',
  'd',
  '6',
  '5',
  'a',
  '6',
  'a',
  '1',
  '6',
  '2',
  'c',
  'f',
  'e',
  '9',
  '0',
  'd',
  '6',
  '2',
  '0',
  '1',
  '6',
  'a',
  '1',
  '4',
  'f',
  'f',
  'e',
  '5',
  '8',
  'd',
  '5',
  '2',
  'b',
  '7',
  'd',
  'd',
  '4',
  'c',
  '3',
  '6',
  '2',
  '8',
  'a',
  '2',
  '7',
  'e',
  '5',
  'b',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '9',
  '4',
  'b',
  'b',
  '5',
  'b',
  '4',
  'f',
  '8',
  'a',
  'c',
  '3',
  '3',
  '9',
  '2',
  'f',
  'b',
  'd',
  '6',
  '6',
  'f',
  '3',
  'd',
  'd',
  '3',
  'e',
  '9',
  'd',
  'c',
  'd',
  'b',
  '2',
  '2',
  '3',
  '7',
  '0',
  'e',
  '3',
  '8',
  '0',
  '8',
  '3',
  '7',
  'f',
  'e',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '3',
  'b',
  'b',
  'b',
  '2',
  '5',
  '0',
  'f',
  '2',
  'd',
  'c',
  '2',
  '3',
  '7',
  '1',
  '7',
  'e',
  '8',
  '1',
  '9',
  '2',
  'c',
  '0',
  'b',
  '8',
  'b',
  'e',
  'c',
  '6',
  'a',
  '1',
  '7',
  '5',
  'c',
  'd',
  '0',
  '5',
  '9',
  'e',
  '4',
  '0',
  '8',
  '9',
  'd',
  '3',
  '2',
  '5',
  '0',
  '0',
  '6',
  'e',
  'a',
  'e',
  'e',
  '3',
  '4',
  '4',
  '6',
  '2',
  '5',
  '4',
  'c',
  '9',
  '5',
  '3',
  '6',
  'd',
  'd',
  '3',
  '9',
  'e',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '1',
  '6',
  '9',
  '8',
  '0',
  'c',
  '6',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '6',
  '8',
  'd',
  'b',
  '5',
  '9',
  '9',
  'd',
  '6',
  'b',
  '7',
  'a',
  '5',
  '5',
  'f',
  'd',
  '6',
  '1',
  'd',
  '4',
  '2',
  '4',
  '4',
  'a',
  '3',
  'd',
  'f',
  'a',
  '4',
  '6',
  '5',
  '0',
  '5',
  '5',
  'e',
  'a',
  'd',
  '6',
  'b',
  '5',
  'c',
  '0',
  'a',
  '3',
  '7',
  'c',
  '7',
  'a',
  '3',
  'd',
  '4',
  '5',
  '5',
  '5',
  'b',
  '5',
  '8',
  'e',
  '9',
  '9',
  '0',
  '6',
  '5',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '3',
  'e',
  '9',
  '1',
  'f',
  'c',
  'e',
  '7',
  '3',
  '0',
  '0',
  'a',
  '7',
  '9',
  '2',
  'b',
  'f',
  'b',
  'a',
  'a',
  '0',
  'c',
  '7',
  '6',
  'e',
  '1',
  'a',
  'a',
  '5',
  'f',
  '9',
  'b',
  '5',
  '4',
  '6',
  'c',
  '1',
  'd',
  'b',
  '5',
  '8',
  '2',
  'a',
  'e',
  'e',
  '4',
  'f',
  'f',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '7',
  '2',
  'e',
  '1',
  '7',
  'b',
  'a',
  'b',
  'd',
  '4',
  '0',
  '8',
  '9',
  'b',
  '2',
  '0',
  '4',
  '7',
  '9',
  '7',
  'c',
  'e',
  'b',
  'd',
  'a',
  '7',
  'd',
  'c',
  '6',
  'e',
  '2',
  '7',
  '7',
  '9',
  '5',
  '0',
  'e',
  'a',
  'b',
  '1',
  'b',
  '2',
  '9',
  '0',
  '8',
  '9',
  '9',
  '1',
  'a',
  'e',
  '1',
  'd',
  '7',
  '2',
  '3',
  '3',
  '5',
  'f',
  '8',
  '2',
  'd',
  '2',
  '0',
  '4',
  '5',
  '3',
  '6',
  'd',
  'c',
  'f',
  '4',
  '4',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '5',
  'f',
  '2',
  'd',
  '0',
  '9',
  '7',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'c',
  '7',
  'd',
  '6',
  '0',
  '1',
  'c',
  'e',
  '3',
  'b',
  '0',
  '1',
  'e',
  '5',
  '6',
  '9',
  'a',
  '4',
  '9',
  '5',
  '0',
  '8',
  'd',
  '5',
  '4',
  '1',
  'b',
  'b',
  'c',
  'b',
  'a',
  '9',
  'b',
  '3',
  'c',
  '8',
  '3',
  '9',
  '4',
  'b',
  '1',
  '8',
  '3',
  '4',
  '5',
  '2',
  '3',
  'e',
  'f',
  '1',
  'e',
  '5',
  'c',
  'b',
  '2',
  'c',
  '6',
  '0',
  'b',
  'd',
  '3',
  '4',
  'a',
  '3',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '9',
  'c',
  '6',
  'b',
  'f',
  '4',
  '6',
  '9',
  'a',
  'b',
  'e',
  '4',
  'a',
  'd',
  '3',
  '7',
  '6',
  '0',
  '5',
  'c',
  '0',
  '9',
  '7',
  'a',
  '8',
  '6',
  '0',
  'c',
  'f',
  'f',
  '3',
  'c',
  'f',
  '5',
  'c',
  '1',
  'e',
  'f',
  '4',
  '3',
  '7',
  '7',
  '6',
  '1',
  '8',
  'f',
  '7',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '2',
  '3',
  '8',
  '8',
  'b',
  '6',
  'f',
  '0',
  '2',
  '2',
  '1',
  '4',
  '4',
  'd',
  'b',
  '1',
  '3',
  '4',
  'a',
  'f',
  '1',
  'b',
  'c',
  '8',
  'e',
  '6',
  '1',
  'b',
  '3',
  '8',
  '5',
  'c',
  'a',
  '3',
  '7',
  'c',
  'a',
  'e',
  '0',
  '3',
  '8',
  'c',
  '1',
  'd',
  '1',
  '6',
  '5',
  'a',
  'e',
  '9',
  '8',
  'c',
  '4',
  '9',
  '6',
  'b',
  '3',
  'b',
  '4',
  '1',
  'e',
  '8',
  'b',
  '5',
  '3',
  '6',
  'd',
  'd',
  '2',
  '1',
  '0',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'a',
  '8',
  'e',
  'a',
  '0',
  'e',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '4',
  '1',
  '0',
  '7',
  '6',
  '1',
  'e',
  '9',
  '7',
  'e',
  '6',
  '7',
  'b',
  '4',
  '9',
  '4',
  'f',
  'd',
  '5',
  '4',
  '7',
  'c',
  'f',
  'e',
  '9',
  'f',
  'f',
  'b',
  'b',
  '3',
  '6',
  '8',
  '9',
  '3',
  'd',
  'a',
  '7',
  'a',
  'e',
  'c',
  '7',
  '5',
  'c',
  '6',
  'b',
  '5',
  '1',
  'b',
  '8',
  'd',
  '5',
  'f',
  '3',
  '8',
  'f',
  '8',
  '7',
  'b',
  '5',
  'd',
  '6',
  '3',
  'c',
  'f',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '9',
  'c',
  '6',
  'b',
  'f',
  '4',
  '6',
  '9',
  'a',
  'b',
  'e',
  '4',
  'a',
  'd',
  '3',
  '7',
  '6',
  '0',
  '5',
  'c',
  '0',
  '9',
  '7',
  'a',
  '8',
  '6',
  '0',
  'c',
  'f',
  'f',
  '3',
  'c',
  'f',
  '5',
  'c',
  '1',
  'e',
  'f',
  '4',
  '3',
  '7',
  '7',
  '6',
  '1',
  '8',
  'f',
  '7',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'e',
  '1',
  'f',
  '0',
  'c',
  'f',
  'd',
  'f',
  '5',
  'a',
  'd',
  '8',
  '2',
  '4',
  '8',
  'f',
  'c',
  '4',
  '5',
  '2',
  '0',
  'f',
  '3',
  'b',
  'b',
  '0',
  'b',
  '2',
  '0',
  '4',
  '0',
  '2',
  '2',
  '6',
  '4',
  '3',
  '0',
  '3',
  '4',
  '8',
  'c',
  'd',
  'd',
  'e',
  'f',
  'f',
  '5',
  'c',
  'a',
  '9',
  '1',
  '8',
  '1',
  'b',
  'e',
  'e',
  'b',
  '7',
  '8',
  '8',
  '7',
  '0',
  'd',
  '5',
  '3',
  '6',
  'd',
  'd',
  '2',
  '1',
  '6',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '0',
  'd',
  '6',
  '0',
  '0',
  'f',
  '9',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'a',
  'd',
  '1',
  'a',
  '8',
  'd',
  '3',
  '5',
  '4',
  'a',
  '7',
  'e',
  '8',
  'b',
  '1',
  '3',
  'e',
  'c',
  '4',
  '7',
  'f',
  '4',
  'c',
  '3',
  'd',
  '9',
  '0',
  '7',
  'd',
  '0',
  '0',
  '9',
  '4',
  '5',
  'a',
  '6',
  '1',
  'e',
  '8',
  '6',
  '0',
  '5',
  '9',
  'f',
  '4',
  '9',
  '4',
  '3',
  'e',
  '4',
  '2',
  'c',
  '1',
  'e',
  '5',
  '2',
  '3',
  '9',
  '8',
  'e',
  'b',
  'a',
  '5',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '9',
  '4',
  'b',
  'b',
  '5',
  'b',
  '4',
  'f',
  '8',
  'a',
  'c',
  '3',
  '3',
  '9',
  '2',
  'f',
  'b',
  'd',
  '6',
  '6',
  'f',
  '3',
  'd',
  'd',
  '3',
  'e',
  '9',
  'd',
  'c',
  'd',
  'b',
  '2',
  '2',
  '3',
  '7',
  '0',
  'e',
  '3',
  '8',
  '0',
  '8',
  '3',
  '7',
  'f',
  'e',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '2',
  '3',
  '2',
  'a',
  '1',
  '6',
  'd',
  '3',
  '8',
  'c',
  'c',
  '0',
  'e',
  '1',
  '3',
  'e',
  '4',
  'b',
  '1',
  '6',
  'd',
  '9',
  '1',
  '7',
  'b',
  'f',
  'f',
  '4',
  'c',
  '3',
  '4',
  '7',
  '2',
  '7',
  'd',
  'e',
  'b',
  '3',
  'b',
  '5',
  'c',
  '5',
  '0',
  'e',
  '4',
  '2',
  '4',
  'f',
  'b',
  '8',
  '4',
  '5',
  '3',
  'f',
  'f',
  '9',
  'b',
  '2',
  'a',
  'd',
  'c',
  'b',
  '4',
  '5',
  '3',
  '6',
  'd',
  'd',
  '4',
  '2',
  '3',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'b',
  'f',
  '1',
  '0',
  '0',
  '2',
  'a',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  'a',
  'd',
  'c',
  '6',
  '7',
  'd',
  '3',
  '8',
  'f',
  '3',
  '1',
  'f',
  '5',
  '8',
  '9',
  'b',
  '1',
  '8',
  'b',
  '9',
  'd',
  '8',
  'e',
  '5',
  '3',
  '1',
  'b',
  '9',
  '9',
  '4',
  'c',
  'e',
  '5',
  '7',
  '3',
  '3',
  'c',
  '0',
  '2',
  '1',
  'a',
  '0',
  '3',
  'd',
  '8',
  '8',
  'd',
  '3',
  '8',
  '6',
  '1',
  '1',
  'e',
  'e',
  '6',
  'b',
  '4',
  'c',
  '2',
  '7',
  '1',
  '0',
  'a',
  '5',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '9',
  '4',
  'b',
  'b',
  '5',
  'b',
  '4',
  'f',
  '8',
  'a',
  'c',
  '3',
  '3',
  '9',
  '2',
  'f',
  'b',
  'd',
  '6',
  '6',
  'f',
  '3',
  'd',
  'd',
  '3',
  'e',
  '9',
  'd',
  'c',
  'd',
  'b',
  '2',
  '2',
  '3',
  '7',
  '0',
  'e',
  '3',
  '8',
  '0',
  '8',
  '3',
  '7',
  'f',
  'e',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'a',
  '2',
  '8',
  '6',
  '0',
  '4',
  '7',
  '1',
  '2',
  '7',
  '7',
  'b',
  '4',
  'a',
  '9',
  '3',
  'f',
  'e',
  'a',
  '2',
  'a',
  '8',
  'b',
  '6',
  'd',
  '8',
  'c',
  '2',
  '8',
  '1',
  'f',
  'a',
  'b',
  '7',
  'b',
  'd',
  'e',
  '3',
  'b',
  '7',
  '8',
  'f',
  '2',
  'a',
  'c',
  'd',
  '1',
  'b',
  'f',
  'd',
  'c',
  '8',
  '9',
  'd',
  '4',
  '6',
  '4',
  'e',
  'd',
  '3',
  'b',
  'b',
  '3',
  'c',
  '5',
  '3',
  '6',
  'd',
  'd',
  '3',
  '5',
  'e',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '9',
  'd',
  '3',
  '0',
  '0',
  '4',
  'b',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '5',
  '3',
  '7',
  '6',
  '8',
  '6',
  'c',
  '6',
  '1',
  '1',
  'a',
  'a',
  'e',
  '4',
  '3',
  '9',
  '7',
  'c',
  '7',
  'c',
  '0',
  '4',
  'b',
  '2',
  'c',
  '1',
  '9',
  '0',
  '7',
  '0',
  '8',
  '4',
  '5',
  '3',
  'd',
  '0',
  '0',
  'e',
  '8',
  'c',
  '9',
  '5',
  '6',
  '3',
  '5',
  '2',
  '5',
  '6',
  '1',
  '0',
  'c',
  '3',
  '1',
  'b',
  'a',
  '4',
  '6',
  'e',
  '8',
  '0',
  'd',
  'b',
  'c',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '9',
  '4',
  'b',
  'b',
  '5',
  'b',
  '4',
  'f',
  '8',
  'a',
  'c',
  '3',
  '3',
  '9',
  '2',
  'f',
  'b',
  'd',
  '6',
  '6',
  'f',
  '3',
  'd',
  'd',
  '3',
  'e',
  '9',
  'd',
  'c',
  'd',
  'b',
  '2',
  '2',
  '3',
  '7',
  '0',
  'e',
  '3',
  '8',
  '0',
  '8',
  '3',
  '7',
  'f',
  'e',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'f',
  '3',
  '7',
  '0',
  '2',
  '3',
  '0',
  '6',
  '0',
  '7',
  '9',
  '9',
  '8',
  'f',
  'b',
  'b',
  'd',
  '1',
  '0',
  '2',
  '7',
  '5',
  'c',
  '5',
  '8',
  '9',
  '0',
  '8',
  '8',
  '5',
  'f',
  'c',
  'd',
  '8',
  '1',
  'b',
  '6',
  '8',
  '0',
  '1',
  '8',
  'b',
  'a',
  '2',
  '3',
  '7',
  '3',
  'a',
  'b',
  'f',
  '0',
  'f',
  '9',
  '3',
  'a',
  '0',
  '6',
  'd',
  '0',
  '2',
  'a',
  'b',
  '2',
  '8',
  '5',
  '3',
  '6',
  'd',
  'd',
  '3',
  '3',
  'e',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '3',
  '7',
  '7',
  '5',
  '0',
  'b',
  'c',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '1',
  'f',
  'd',
  'd',
  'a',
  '9',
  '5',
  '2',
  'd',
  'a',
  '6',
  'a',
  'b',
  'd',
  '7',
  '0',
  '0',
  '2',
  '2',
  'a',
  '6',
  'e',
  '5',
  'f',
  '2',
  'b',
  '9',
  'd',
  'c',
  '5',
  'e',
  '1',
  'b',
  '6',
  '6',
  '0',
  '1',
  '1',
  '1',
  '2',
  '8',
  'c',
  '3',
  'f',
  'a',
  '2',
  '4',
  '9',
  'f',
  '0',
  'b',
  '7',
  '4',
  '3',
  '9',
  'f',
  '0',
  '0',
  'd',
  '5',
  '9',
  '4',
  '3',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  'c',
  '0',
  'a',
  '2',
  'c',
  '9',
  '1',
  'f',
  'c',
  '4',
  '1',
  '2',
  '5',
  '4',
  '5',
  '3',
  '9',
  'a',
  '5',
  'b',
  '2',
  'a',
  '2',
  '7',
  'b',
  'e',
  '2',
  '8',
  'd',
  'e',
  '2',
  'a',
  '6',
  '1',
  '8',
  '7',
  'e',
  '2',
  'a',
  'f',
  '3',
  'f',
  '1',
  '2',
  '9',
  'd',
  '6',
  '3',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '5',
  'e',
  '4',
  '5',
  'f',
  'f',
  'c',
  '5',
  '1',
  '2',
  'd',
  '5',
  'c',
  'a',
  '3',
  'b',
  'c',
  '4',
  'd',
  '2',
  '0',
  '6',
  '3',
  'd',
  'd',
  '3',
  'a',
  'f',
  '1',
  '6',
  '6',
  '9',
  'c',
  '2',
  '9',
  '6',
  'a',
  'e',
  '1',
  '2',
  '6',
  'a',
  '5',
  'a',
  '2',
  'e',
  'f',
  '8',
  '9',
  '6',
  'd',
  '1',
  'e',
  '1',
  '9',
  '0',
  'c',
  'e',
  'd',
  'f',
  '6',
  '7',
  'b',
  '9',
  '5',
  '3',
  '6',
  'd',
  'd',
  '4',
  '6',
  'b',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  'd',
  '5',
  '5',
  'b',
  '0',
  '0',
  'd',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '0',
  '7',
  '0',
  '9',
  '4',
  'd',
  '6',
  'c',
  'b',
  'e',
  '7',
  '6',
  '5',
  '3',
  '8',
  'a',
  '8',
  '8',
  '6',
  '1',
  '2',
  '6',
  '2',
  '4',
  'f',
  'c',
  '5',
  'e',
  '6',
  '5',
  '5',
  'c',
  'c',
  '4',
  '0',
  '5',
  'c',
  'b',
  '8',
  '1',
  '9',
  '8',
  'd',
  'c',
  'a',
  'd',
  '5',
  '1',
  '6',
  'b',
  '8',
  '8',
  'd',
  'b',
  'a',
  'c',
  '5',
  'b',
  'f',
  '8',
  'b',
  '9',
  '0',
  '6',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '9',
  '4',
  'b',
  'b',
  '5',
  'b',
  '4',
  'f',
  '8',
  'a',
  'c',
  '3',
  '3',
  '9',
  '2',
  'f',
  'b',
  'd',
  '6',
  '6',
  'f',
  '3',
  'd',
  'd',
  '3',
  'e',
  '9',
  'd',
  'c',
  'd',
  'b',
  '2',
  '2',
  '3',
  '7',
  '0',
  'e',
  '3',
  '8',
  '0',
  '8',
  '3',
  '7',
  'f',
  'e',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '7',
  'c',
  '5',
  '4',
  '8',
  '8',
  '1',
  '5',
  '1',
  '2',
  '7',
  'c',
  '1',
  '2',
  '5',
  '1',
  '4',
  '7',
  'a',
  'f',
  '9',
  '1',
  'c',
  '3',
  '5',
  '6',
  'c',
  '2',
  '9',
  '3',
  'f',
  '0',
  'd',
  'e',
  'f',
  'b',
  'd',
  '2',
  '7',
  '7',
  '1',
  'f',
  '8',
  'd',
  'c',
  '3',
  'b',
  '1',
  '1',
  '4',
  '2',
  'b',
  '3',
  '6',
  '7',
  '5',
  '2',
  '8',
  '6',
  '5',
  '6',
  'd',
  'b',
  '5',
  '3',
  '6',
  'd',
  'd',
  '3',
  '7',
  'c',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '9',
  '6',
  '7',
  '7',
  '0',
  'a',
  'e',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '1',
  'b',
  'd',
  'b',
  'b',
  '3',
  'b',
  '1',
  'b',
  'e',
  '7',
  '2',
  '1',
  '6',
  '8',
  '7',
  '2',
  'e',
  'a',
  '7',
  '8',
  '7',
  '6',
  '2',
  '7',
  'b',
  '0',
  '3',
  'c',
  '3',
  '8',
  '9',
  'a',
  '5',
  '2',
  '7',
  '4',
  '5',
  '1',
  'f',
  '6',
  'd',
  'd',
  '8',
  '3',
  '2',
  'd',
  '8',
  '5',
  '4',
  '0',
  '8',
  '7',
  '4',
  '3',
  '0',
  '6',
  'f',
  '9',
  'c',
  '0',
  '7',
  'c',
  '6',
  '\0',
  '\0',
  '\0',
  '\0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '2',
  '1',
  '9',
  '4',
  'b',
  'b',
  '5',
  'b',
  '4',
  'f',
  '8',
  'a',
  'c',
  '3',
  '3',
  '9',
  '2',
  'f',
  'b',
  'd',
  '6',
  '6',
  'f',
  '3',
  'd',
  'd',
  '3',
  'e',
  '9',
  'd',
  'c',
  'd',
  'b',
  '2',
  '2',
  '3',
  '7',
  '0',
  'e',
  '3',
  '8',
  '0',
  '8',
  '3',
  '7',
  'f',
  'e',
  '4',
  '4',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  'a',
  'd',
  'e',
  'f',
  '7',
  '5',
  '8',
  '7',
  '7',
  '0',
  'b',
  'b',
  '9',
  '0',
  'c',
  '5',
  'b',
  '1',
  '3',
  '7',
  '6',
  '9',
  'c',
  '5',
  'b',
  '6',
  '1',
  'a',
  'f',
  'f',
  'b',
  '3',
  '2',
  '2',
  'b',
  '2',
  '4',
  'c',
  '7',
  '4',
  '7',
  '5',
  '7',
  '3',
  'b',
  '3',
  '8',
  'e',
  'b',
  'e',
  '2',
  'e',
  'e',
  '8',
  '1',
  '7',
  '4',
  '8',
  'd',
  '0',
  'b',
  '5',
  '5',
  '7',
  '5',
  '3',
  '6',
  'd',
  'd',
  '4',
  '0',
  '7',
  '1',
  '9',
  '0',
  '0',
  '8',
  '9',
  '6',
  'c',
  '2',
  '9',
  'f',
  '0',
  '0',
  '1',
  'f',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '0',
  '8',
  '0',
  '0',
  '2',
  '0',
  '0',
  '0',
  '0',
  '1',
  'a',
  'c',
  '8',
  'e',
  'e',
  'a',
  '6',
  '3',
  '2',
  '8',
  '5',
  '3',
  '5',
  '3',
  '9',
  '4',
  '4',
  'e',
  '4',
  '0',
  'e',
  'e',
  'c',
  '5',
  '4',
  'd',
  '2',
  'd',
  'd',
  '6',
  'c',
  'd',
  '0',
  '9',
  '9',
  '4',
  'b',
  '4',
  '4',
  '7',
  '4',
  '2',
  '9',
  'b',
  'b',
  '0',
  'e',
  'd',
  '0',
  '5',
  '9',
  '8',
  'd',
  '3',
  '8',
  'f',
  '4',
  '2',
  'd',
  'a',
  '0',
  'e',
  '2',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_4F67C = 124; // weak
__int16 word_4F7A8 = 47; // weak
_UNKNOWN unk_4FCAC; // weak
_UNKNOWN unk_4FCD0; // weak
char aFailedToCalloc[29] = "Failed to calloc control_thr"; // weak
char aAllDevicesDisa[35] = "All devices disabled, cannot mine!"; // weak
_UNKNOWN unk_5320C; // weak
__int16 word_53210 = 48; // weak
const char _func___12024[11] = "clear_sock"; // idb
const pthread_mutex_t _func___11739 = { { 1717530996, 2053465458u, 1634235493, 119, 343552u, { 0 } } }; // idb
const pthread_mutex_t _func___11752 = { { 1885303156, 6845301u, 1885303156, 28783, 1601463655u, { 2020569712 } } }; // idb
const pthread_mutex_t _func___12181 = { { 1936875888, 1768185701u, 26214, 1936875888, 1701994341u, { 1852731235 } } }; // idb
const pthread_mutex_t _func___12266 = { { 1936875888, 1635016549u, 1952802674, 0, 1818322290u, { 1600352108 } } }; // idb
int dword_54574 = 28526; // weak
const pthread_mutex_t _func___12372 = { { 2036623732, 28789u, 1953068401, 1919448159, 6578533u, { 1953719666 } } }; // idb
const pthread_mutex_t _func___11933 = { { 1953068915, 1869637731u, 27759, 1701734765, 1852403555u, { 0 } } }; // idb
const pthread_mutex_t _func___11888 = { { 1835890035, 7959137u, 352132, 352156, 352180u, { 352208 } } }; // idb
const pthread_mutex_t _func___12699 = { { 6910049, 1414734459u, 1398101057, 1109539362, 2245977u, { 4544834 } } }; // idb
const char _FUNCTION___15596[25] = "reset_all_hash_board_low"; // idb
freq_pll_str freq_pll[119] =
{
  { 100u, 131136u, 1056u, 2097729u },
  { 125u, 163904u, 1056u, 2622017u },
  { 150u, 196672u, 1056u, 3146305u },
  { 175u, 229440u, 1056u, 3670593u },
  { 200u, 262208u, 1056u, 4194881u },
  { 225u, 294976u, 1056u, 4719169u },
  { 250u, 327744u, 1056u, 5243457u },
  { 275u, 360512u, 1056u, 5767745u },
  { 300u, 393280u, 1056u, 6292033u },
  { 325u, 426048u, 1056u, 6816321u },
  { 350u, 458816u, 1056u, 7340609u },
  { 375u, 491584u, 1056u, 7864897u },
  { 400u, 524352u, 1056u, 8389185u },
  { 404u, 397376u, 800u, 6357553u },
  { 406u, 266304u, 544u, 4260385u },
  { 408u, 401472u, 800u, 6423089u },
  { 412u, 270400u, 544u, 4325921u },
  { 416u, 409664u, 800u, 6554161u },
  { 418u, 274496u, 544u, 4391457u },
  { 420u, 413760u, 800u, 6619697u },
  { 425u, 278592u, 544u, 4456993u },
  { 429u, 421952u, 800u, 6750769u },
  { 431u, 282688u, 544u, 4522529u },
  { 433u, 426048u, 800u, 6816305u },
  { 437u, 286784u, 544u, 4588065u },
  { 441u, 434240u, 800u, 6947377u },
  { 443u, 290880u, 544u, 4653601u },
  { 445u, 438336u, 800u, 7012913u },
  { 450u, 294976u, 544u, 4719137u },
  { 454u, 446528u, 800u, 7143985u },
  { 456u, 299072u, 544u, 4784673u },
  { 458u, 450624u, 800u, 7209521u },
  { 462u, 303168u, 544u, 4850209u },
  { 466u, 458816u, 800u, 7340593u },
  { 468u, 307264u, 544u, 4915745u },
  { 470u, 462912u, 800u, 7406129u },
  { 475u, 311360u, 544u, 4981281u },
  { 479u, 471104u, 800u, 7537201u },
  { 481u, 315456u, 544u, 5046817u },
  { 483u, 475200u, 800u, 7602737u },
  { 487u, 319552u, 544u, 5112353u },
  { 491u, 483392u, 800u, 7733809u },
  { 493u, 323648u, 544u, 5177889u },
  { 495u, 487488u, 800u, 7799345u },
  { 500u, 327744u, 544u, 5243425u },
  { 504u, 495680u, 800u, 7930417u },
  { 506u, 331840u, 544u, 5308961u },
  { 508u, 499776u, 800u, 7995953u },
  { 512u, 335936u, 544u, 5374497u },
  { 516u, 507968u, 800u, 8127025u },
  { 518u, 340032u, 544u, 5440033u },
  { 520u, 512064u, 800u, 8192561u },
  { 525u, 344128u, 544u, 5505569u },
  { 529u, 520256u, 800u, 8323633u },
  { 531u, 348224u, 544u, 5571105u },
  { 533u, 524352u, 800u, 8389169u },
  { 537u, 352320u, 544u, 5636641u },
  { 543u, 356416u, 544u, 5702177u },
  { 550u, 360512u, 544u, 5767713u },
  { 556u, 364608u, 544u, 5833249u },
  { 562u, 368704u, 544u, 5898785u },
  { 568u, 372800u, 544u, 5964321u },
  { 575u, 376896u, 544u, 6029857u },
  { 581u, 380992u, 544u, 6095393u },
  { 587u, 385088u, 544u, 6160929u },
  { 593u, 389184u, 544u, 6226465u },
  { 600u, 393280u, 544u, 6292001u },
  { 606u, 397376u, 544u, 6357537u },
  { 612u, 401472u, 544u, 6423073u },
  { 618u, 405568u, 544u, 6488609u },
  { 625u, 409664u, 544u, 6554145u },
  { 631u, 413760u, 544u, 6619681u },
  { 637u, 417856u, 544u, 6685217u },
  { 643u, 421952u, 544u, 6750753u },
  { 650u, 426048u, 544u, 6816289u },
  { 656u, 430144u, 544u, 6881825u },
  { 662u, 434240u, 544u, 6947361u },
  { 668u, 438336u, 544u, 7012897u },
  { 675u, 442432u, 544u, 7078433u },
  { 681u, 446528u, 544u, 7143969u },
  { 687u, 450624u, 544u, 7209505u },
  { 693u, 454720u, 544u, 7275041u },
  { 700u, 458816u, 544u, 7340577u },
  { 706u, 462912u, 544u, 7406113u },
  { 712u, 467008u, 544u, 7471649u },
  { 718u, 471104u, 544u, 7537185u },
  { 725u, 475200u, 544u, 7602721u },
  { 731u, 479296u, 544u, 7668257u },
  { 737u, 483392u, 544u, 7733793u },
  { 743u, 487488u, 544u, 7799329u },
  { 750u, 491584u, 544u, 7864865u },
  { 756u, 495680u, 544u, 7930401u },
  { 762u, 499776u, 544u, 7995937u },
  { 768u, 503872u, 544u, 8061473u },
  { 775u, 507968u, 544u, 8127009u },
  { 781u, 512064u, 544u, 8192545u },
  { 787u, 516160u, 544u, 8258081u },
  { 793u, 520256u, 544u, 8323617u },
  { 800u, 524352u, 544u, 8389153u },
  { 805u, 0u, 0u, 10551633u },
  { 810u, 0u, 0u, 10617169u },
  { 815u, 0u, 0u, 10682705u },
  { 820u, 0u, 0u, 10748241u },
  { 825u, 270400u, 288u, 4325905u },
  { 830u, 0u, 0u, 10879313u },
  { 835u, 0u, 0u, 10944849u },
  { 840u, 0u, 0u, 11010385u },
  { 845u, 0u, 0u, 11075921u },
  { 850u, 0u, 0u, 4456737u },
  { 855u, 0u, 0u, 11206993u },
  { 860u, 0u, 0u, 11272529u },
  { 865u, 0u, 0u, 11338065u },
  { 870u, 0u, 0u, 11403601u },
  { 875u, 0u, 0u, 4587809u },
  { 880u, 0u, 0u, 11534673u },
  { 885u, 0u, 0u, 11600209u },
  { 890u, 0u, 0u, 11665745u },
  { 895u, 0u, 0u, 11731281u },
  { 900u, 0u, 0u, 4718881u }
}; // idb
const uint32_t sec_key[4][4] =
{
  { 1247682123u, 2864226106u, 844204680u, 3273377919u },
  { 1636791911u, 1043122042u, 2987555706u, 4260209467u },
  { 238953303u, 3892754125u, 2985757524u, 3282280827u },
  { 1729424927u, 241745595u, 1151814430u, 4249952408u }
}; // idb
const char aSChainDFailed_0[] = "%s chain %d failed!\n"; // idb
__int16 word_58FE4 = 10; // weak
const char aSEraseFlashErr[] = "%s: erase flash error!\n\n"; // idb
char byte_59398 = '\0'; // weak
const char aAsicNumErrD[] = "asic num err![%d"; // idb
__int16 word_59A90 = 93; // weak
_UNKNOWN unk_59E9C; // weak
_UNKNOWN unk_59F0C; // weak
const unsigned __int8 sha2_padding[64] =
{
  128u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const uint64_t blake2b_IV[8] =
{
  7640891576956012808uLL,
  13503953896175478587uLL,
  4354685564936845355uLL,
  11912009170470909681uLL,
  5840696475078001361uLL,
  11170449401992604703uLL,
  2270897969802886507uLL,
  6620516959819538809uLL
}; // idb
const uint32_t K[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
char aStatusservicet[45] = "statusServiceThread not support http command"; // weak
char aStatusservicet_1[45] = "statusServiceThread send http response error"; // weak
const size_t primes[29] =
{
  5u,
  13u,
  23u,
  53u,
  97u,
  193u,
  389u,
  769u,
  1543u,
  3079u,
  6151u,
  12289u,
  24593u,
  49157u,
  98317u,
  196613u,
  393241u,
  786433u,
  1572869u,
  3145739u,
  6291469u,
  12582917u,
  25165843u,
  50331653u,
  100663319u,
  201326611u,
  402653189u,
  805306457u,
  1610612741u
}; // idb
_UNKNOWN *_frame_dummy_init_array_entry = (_UNKNOWN *)0x15001; // weak
_UNKNOWN *_do_global_dtors_aux_fini_array_entry = (_UNKNOWN *)0x14FE9; // weak
unsigned int global_quota_gcd = 1u; // idb
double total_secs = 1.0; // idb
opt_table opt_config_table[70] =
{
  {
    "--version-file",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x16855,
    NULL,
    { &opt_hidden },
    "Set miner version file"
  },
  {
    "--logfile-openflag",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x16845,
    NULL,
    { &opt_hidden },
    "Set log file open flag, default: a+"
  },
  {
    "--logwork",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x16835,
    NULL,
    { &opt_hidden },
    "Set log work file path, following: minertext"
  },
  {
    "--logwork-asicnum",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x16825,
    NULL,
    { &opt_hidden },
    "Set log work asic num, following: 1, 32, 64"
  },
  {
    "--logwork-diff",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_logwork_diff },
    "Allow log work diff"
  },
  {
    "--logfile",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x16811,
    NULL,
    { &opt_hidden },
    "Set log file, default: cgminer.log"
  },
  {
    "--api-allow",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_allow },
    "Allow API access only to the given list of [G:]IP[/Prefix] addresses[/subnets]"
  },
  {
    "--api-description",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_description },
    "Description placed in the API status header, default: cgminer version"
  },
  {
    "--api-groups",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_groups },
    "API one letter groups G:cmd:cmd[,P:cmd:*...] defining the cmds a groups can use"
  },
  {
    "--api-listen",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_api_listen },
    "Enable API, default: disabled"
  },
  {
    "--api-mcast",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_api_mcast },
    "Enable API Multicast listener, default: disabled"
  },
  {
    "--api-mcast-addr",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_mcast_addr },
    "API Multicast listen address"
  },
  {
    "--api-mcast-code",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_mcast_code },
    "Code expected in the API Multicast message, don't use '-'"
  },
  {
    "--api-mcast-des",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_mcast_des },
    "Description appended to the API Multicast reply, default: ''"
  },
  {
    "--api-mcast-port",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x17459,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_api_mcast_port },
    "API Multicast listen port"
  },
  {
    "--api-network",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_api_network },
    "Allow API (if enabled) to listen on/for any address, default: only 127.0.0.1"
  },
  {
    "--api-port",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x17459,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_api_port },
    "Port number of miner API"
  },
  {
    "--api-host",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_api_host },
    "Specify API listen address, default: 0.0.0.0"
  },
  {
    "--balance",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x15009,
    NULL,
    NULL,
    { &pool_strategy_0 },
    "Change multipool strategy from failover to even share balance"
  },
  {
    "--benchfile",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_benchfile },
    "Run cgminer in benchmark mode using a work file - produces no shares"
  },
  {
    "--benchfile-display",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_benchfile_display },
    "Display each benchfile nonce found"
  },
  {
    "--benchmark",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_benchmark },
    "Run cgminer in benchmark mode - produces no shares"
  },
  {
    "--bitmain-fan-ctrl",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_bitmain_fan_ctrl },
    "Enable bitmain miner fan controlling"
  },
  {
    "--bitmain-fan-pwm",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x173F9,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_bitmain_fan_pwm },
    "Set bitmain fan pwm percentage 0~100"
  },
  {
    "--bitmain-freq",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_bitmain_ZCASH_freq },
    "Set frequency"
  },
  {
    "--bitmain-voltage",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_bitmain_ZCASH_vol },
    "Set voltage"
  },
  {
    "--bitmain-core-timeout",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_bitmain_core_timeout },
    "Set voltage"
  },
  {
    "--debug|-D",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x15021,
    NULL,
    NULL,
    { &opt_debug },
    "Enable debug output"
  },
  {
    "--disable-rejecting",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_disable_pool },
    "Automatically disable pools that continually reject shares"
  },
  {
    "--expiry|-E",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_expiry },
    "Upper bound on how many seconds after getting work we consider a share from it stale"
  },
  {
    "--failover-only",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_fail_only },
    "Don't leak work to backup pools when primary pool is lagging"
  },
  {
    "--fix-protocol",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_fix_protocol },
    "Do not redirect to a different getwork protocol (eg. stratum)"
  },
  {
    "--hotplug",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    NULL,
    { &hotplug_time },
    &opt_hidden
  },
  {
    "--load-balance",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x15011,
    NULL,
    NULL,
    { &pool_strategy_0 },
    "Change multipool strategy from failover to quota based balance"
  },
  {
    "--log|-l",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_log_interval },
    "Interval in seconds between log output"
  },
  {
    "--lowmem",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_lowmem },
    "Minimise caching of shares for low memory applications"
  },
  {
    "--monitor|-m",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_stderr_cmd },
    "Use custom pipe cmd for output messages"
  },
  {
    "--net-delay",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_delaynet },
    "Impose small delays in networking to not overload slow routers"
  },
  {
    "--no-pool-disable",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACF5,
    NULL,
    NULL,
    { &opt_disable_pool },
    &opt_hidden
  },
  {
    "--no-submit-stale",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACF5,
    NULL,
    NULL,
    { &opt_submit_stale },
    "Don't submit shares if they are detected as stale"
  },
  {
    "--pass|-p",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1DDC5,
    NULL,
    { &opt_set_null },
    "Password for bitcoin JSON-RPC server"
  },
  {
    "--per-device-stats",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &want_per_device_stats },
    "Force verbose mode and output per-device statistics"
  },
  {
    "--pools",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4ACED,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    "--protocol-dump|-P",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_protocol },
    "Verbose dump of protocol-level activities"
  },
  {
    "--queue|-Q",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_queue },
    "Maximum number of work items to have queued"
  },
  {
    "--quiet|-q",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_quiet },
    "Disable logging output, display status and errors"
  },
  {
    "--quota|-U",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1DCE5,
    NULL,
    { &opt_set_null },
    "quota;URL combination for server with load-balance strategy quotas"
  },
  {
    "--real-quiet",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_realquiet },
    "Disable all output"
  },
  {
    "--retries",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x15035,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    "--retry-pause",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x15035,
    NULL,
    { &opt_set_null },
    &opt_hidden
  },
  {
    "--rotate",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x174A1,
    NULL,
    { &opt_set_null },
    "Change multipool strategy from failover to regularly rotate at N minutes"
  },
  {
    "--round-robin",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x15019,
    NULL,
    NULL,
    { &pool_strategy_0 },
    "Change multipool strategy from failover to round robin on failure"
  },
  {
    "--scan-time|-s",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1747D,
    (void (*)(char *, const void *))0x4AF75,
    { &opt_scantime },
    "Upper bound on time spent scanning current work, in seconds"
  },
  {
    "--sched-start",
    opt_type::OPT_PROCESSARG,
    NULL,
    (char *(*)(const char *, void *))0x16F65,
    NULL,
    { &opt_set_sched_start },
    "Set a time of day in HH:MM to start mining (a once off without a stop time)"
  },
  {
    "--sched-stop",
    opt_type::OPT_PROCESSARG,
    NULL,
    (char *(*)(const char *, void *))0x17619,
    NULL,
    { &opt_set_sched_stop },
    "Set a time of day in HH:MM to stop mining (will quit without a start time)"
  },
  {
    "--sharelog",
    opt_type::OPT_PROCESSARG,
    NULL,
    (char *(*)(const char *, void *))0x16875,
    NULL,
    { &opt_set_sharelog },
    "Append share log to file"
  },
  {
    "--scrypt",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_scrypt },
    "Use the scrypt algorithm for mining (litecoin only)"
  },
  {
    "--shares",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AE1D,
    NULL,
    { &opt_shares },
    "Quit after mining N shares (default: unlimited)"
  },
  {
    "--socks-proxy",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AD75,
    NULL,
    { &opt_socks_proxy },
    "Set socks4 proxy (host:port)"
  },
  {
    "--suggest-diff",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AE1D,
    NULL,
    { &opt_suggest_diff },
    "Suggest miner difficulty for pool to user (default: none)"
  },
  {
    "--multi-version",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x4AE1D,
    NULL,
    { &opt_multi_version },
    "Multi version"
  },
  {
    "--syslog",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &use_syslog },
    "Use system log for output messages (default: standard error)"
  },
  {
    "--text-only|-T",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACF5,
    NULL,
    NULL,
    { &use_curses },
    &opt_hidden
  },
  {
    "--url|-o",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1DCD1,
    NULL,
    { &opt_set_null },
    "URL for bitcoin JSON-RPC server"
  },
  {
    "--user|-u",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1DC31,
    NULL,
    { &opt_set_null },
    "Username for bitcoin JSON-RPC server"
  },
  {
    "--userpass|-O",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1DB7D,
    NULL,
    { &opt_set_null },
    "Username:Password pair for bitcoin JSON-RPC server"
  },
  {
    "--verbose",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_log_output },
    "Log verbose output to stderr as well as status output"
  },
  {
    "--widescreen",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_widescreen },
    "Use extra wide display without toggling"
  },
  {
    "--worktime",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4ACED,
    NULL,
    NULL,
    { &opt_worktime },
    "Display extra work time debug information"
  },
  { NULL, opt_type::OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
char best_share[8] = { '0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
int opt_log_interval = 5; // idb
char *curly = ":D"; // idb
double last_total_secs = 1.0; // idb
double current_diff = 1.84467441e19; // idb
int max_queue = 1; // idb
int opt_queue = 1; // idb
int opt_scantime = -1; // idb
int opt_expiry = 120; // idb
bool opt_restart = true; // idb
bool opt_submit_stale = true; // idb
opt_table opt_cmdline_table[5] =
{
  {
    "--config|-c",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x1AB5D,
    NULL,
    { &opt_set_null },
    "Load a JSON-format configuration file\nSee example.conf for an example configuration."
  },
  {
    "--default-config",
    opt_type::OPT_HASARG,
    NULL,
    (char *(*)(const char *, void *))0x16865,
    NULL,
    { &opt_set_null },
    "Specify the filename of the default config file\nLoaded at start and used when saving without a name."
  },
  {
    "--help|-h",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x16DE9,
    NULL,
    NULL,
    { NULL },
    "Print this message"
  },
  {
    "--version|-V",
    opt_type::OPT_NOARG,
    (char *(*)(void *))0x4AEA1,
    NULL,
    NULL,
    { &packagename },
    "Display version and exit"
  },
  { NULL, opt_type::OPT_END, NULL, NULL, NULL, { NULL }, NULL }
}; // idb
int opt_multi_version = 1; // idb
int opt_api_mcast_port = 4028; // idb
char *opt_api_mcast_des = &byte_59398; // idb
char *opt_api_mcast_code = "FTW"; // idb
char *opt_api_mcast_addr = "224.0.0.75"; // idb
char *opt_api_host = "0.0.0.0"; // idb
int opt_api_port = 4028; // idb
char *opt_api_description = &unk_53204; // idb
strategies strategies_0[] = { { "Failover" } }; // idb
int (*selective_yield)(void) = (int (*)(void))0x26829; // idb
uint32_t sha256_k[64] =
{
  1116352408u,
  1899447441u,
  3049323471u,
  3921009573u,
  961987163u,
  1508970993u,
  2453635748u,
  2870763221u,
  3624381080u,
  310598401u,
  607225278u,
  1426881987u,
  1925078388u,
  2162078206u,
  2614888103u,
  3248222580u,
  3835390401u,
  4022224774u,
  264347078u,
  604807628u,
  770255983u,
  1249150122u,
  1555081692u,
  1996064986u,
  2554220882u,
  2821834349u,
  2952996808u,
  3210313671u,
  3336571891u,
  3584528711u,
  113926993u,
  338241895u,
  666307205u,
  773529912u,
  1294757372u,
  1396182291u,
  1695183700u,
  1986661051u,
  2177026350u,
  2456956037u,
  2730485921u,
  2820302411u,
  3259730800u,
  3345764771u,
  3516065817u,
  3600352804u,
  4094571909u,
  275423344u,
  430227734u,
  506948616u,
  659060556u,
  883997877u,
  958139571u,
  1322822218u,
  1537002063u,
  1747873779u,
  1955562222u,
  2024104815u,
  2227730452u,
  2361852424u,
  2428436474u,
  2756734187u,
  3204031479u,
  3329325298u
}; // idb
uint32_t sha256_h0[8] =
{
  1779033703u,
  3144134277u,
  1013904242u,
  2773480762u,
  1359893119u,
  2600822924u,
  528734635u,
  1541459225u
}; // idb
CODES codes[67] =
{
  { code_severity::SEVERITY_SUCC, 7, code_parameters::PARAM_PMAX, "%d Pool(s)" },
  { code_severity::SEVERITY_ERR, 8, code_parameters::PARAM_NONE, "No pools" },
  { code_severity::SEVERITY_SUCC, 9, code_parameters::PARAM_DMAX, NULL },
  { code_severity::SEVERITY_ERR, 10, code_parameters::PARAM_NONE, "No " },
  { code_severity::SEVERITY_SUCC, 11, code_parameters::PARAM_NONE, "Summary" },
  {
    code_severity::SEVERITY_ERR,
    14,
    code_parameters::PARAM_NONE,
    "Invalid command"
  },
  {
    code_severity::SEVERITY_ERR,
    15,
    code_parameters::PARAM_NONE,
    "Missing device id parameter"
  },
  { code_severity::SEVERITY_SUCC, 59, code_parameters::PARAM_NONE, "PGA count" },
  {
    code_severity::SEVERITY_SUCC,
    104,
    code_parameters::PARAM_NONE,
    "ASC count"
  },
  {
    code_severity::SEVERITY_SUCC,
    22,
    code_parameters::PARAM_NONE,
    "CGMiner versions"
  },
  {
    code_severity::SEVERITY_ERR,
    23,
    code_parameters::PARAM_NONE,
    "Invalid JSON"
  },
  {
    code_severity::SEVERITY_ERR,
    24,
    code_parameters::PARAM_CMD,
    "Missing JSON '%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    25,
    code_parameters::PARAM_NONE,
    "Missing pool id parameter"
  },
  {
    code_severity::SEVERITY_ERR,
    26,
    code_parameters::PARAM_POOLMAX,
    "Invalid pool id %d - range is 0 - %d"
  },
  {
    code_severity::SEVERITY_SUCC,
    27,
    code_parameters::PARAM_POOL,
    "Switching to pool %d:'%s'"
  },
  {
    code_severity::SEVERITY_SUCC,
    33,
    code_parameters::PARAM_NONE,
    "CGMiner config"
  },
  {
    code_severity::SEVERITY_ERR,
    42,
    code_parameters::PARAM_NONE,
    "Missing save filename parameter"
  },
  {
    code_severity::SEVERITY_ERR,
    43,
    code_parameters::PARAM_STR,
    "Can't open or create save file '%s'"
  },
  {
    code_severity::SEVERITY_SUCC,
    44,
    code_parameters::PARAM_STR,
    "Configuration saved to file '%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    45,
    code_parameters::PARAM_STR,
    "Access denied to '%s' command"
  },
  {
    code_severity::SEVERITY_SUCC,
    46,
    code_parameters::PARAM_NONE,
    "Privileged access OK"
  },
  {
    code_severity::SEVERITY_SUCC,
    47,
    code_parameters::PARAM_POOL,
    "Enabling pool %d:'%s'"
  },
  {
    code_severity::SEVERITY_SUCC,
    73,
    code_parameters::PARAM_NONE,
    "Changed pool priorities"
  },
  {
    code_severity::SEVERITY_ERR,
    74,
    code_parameters::PARAM_PID,
    "Duplicate pool specified %d"
  },
  {
    code_severity::SEVERITY_SUCC,
    48,
    code_parameters::PARAM_POOL,
    "Disabling pool %d:'%s'"
  },
  {
    code_severity::SEVERITY_INFO,
    49,
    code_parameters::PARAM_POOL,
    "Pool %d:'%s' already enabled"
  },
  {
    code_severity::SEVERITY_INFO,
    50,
    code_parameters::PARAM_POOL,
    "Pool %d:'%s' already disabled"
  },
  {
    code_severity::SEVERITY_ERR,
    51,
    code_parameters::PARAM_POOL,
    "Cannot disable last active pool %d:'%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    52,
    code_parameters::PARAM_NONE,
    "Missing addpool details"
  },
  {
    code_severity::SEVERITY_ERR,
    53,
    code_parameters::PARAM_STR,
    "Invalid addpool details '%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    54,
    code_parameters::PARAM_NONE,
    "Reached maximum number of pools (%d)"
  },
  {
    code_severity::SEVERITY_SUCC,
    55,
    code_parameters::PARAM_POOL,
    "Added pool %d: '%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    66,
    code_parameters::PARAM_POOL,
    "Cannot remove last pool %d:'%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    67,
    code_parameters::PARAM_POOL,
    "Cannot remove active pool %d:'%s'"
  },
  {
    code_severity::SEVERITY_SUCC,
    68,
    code_parameters::PARAM_BOTH,
    "Removed pool %d:'%s'"
  },
  { code_severity::SEVERITY_SUCC, 60, code_parameters::PARAM_NONE, "Notify" },
  {
    code_severity::SEVERITY_SUCC,
    69,
    code_parameters::PARAM_NONE,
    "Device Details"
  },
  {
    code_severity::SEVERITY_SUCC,
    70,
    code_parameters::PARAM_NONE,
    "CGMiner stats"
  },
  {
    code_severity::SEVERITY_ERR,
    71,
    code_parameters::PARAM_NONE,
    "Missing check cmd"
  },
  {
    code_severity::SEVERITY_SUCC,
    72,
    code_parameters::PARAM_NONE,
    "Check command"
  },
  {
    code_severity::SEVERITY_ERR,
    75,
    code_parameters::PARAM_NONE,
    "Missing parameter: true/false"
  },
  {
    code_severity::SEVERITY_ERR,
    76,
    code_parameters::PARAM_NONE,
    "Invalid parameter should be true or false"
  },
  {
    code_severity::SEVERITY_SUCC,
    77,
    code_parameters::PARAM_BOOL,
    "Failover-Only set to %s"
  },
  {
    code_severity::SEVERITY_SUCC,
    78,
    code_parameters::PARAM_NONE,
    "CGMiner coin"
  },
  {
    code_severity::SEVERITY_SUCC,
    79,
    code_parameters::PARAM_NONE,
    "Debug settings"
  },
  {
    code_severity::SEVERITY_SUCC,
    82,
    code_parameters::PARAM_SET,
    "Set config '%s' to %d"
  },
  {
    code_severity::SEVERITY_ERR,
    83,
    code_parameters::PARAM_STR,
    "Unknown config '%s'"
  },
  {
    code_severity::SEVERITY_ERR,
    84,
    code_parameters::PARAM_BOTH,
    "Invalid number (%d) for '%s' range is 0-9999"
  },
  {
    code_severity::SEVERITY_ERR,
    121,
    code_parameters::PARAM_BOTH,
    "Invalid negative number (%d) for '%s'"
  },
  {
    code_severity::SEVERITY_SUCC,
    122,
    code_parameters::PARAM_SET,
    "Set pool '%s' to quota %d'"
  },
  {
    code_severity::SEVERITY_ERR,
    85,
    code_parameters::PARAM_NONE,
    "Missing config parameters 'name,N'"
  },
  {
    code_severity::SEVERITY_ERR,
    86,
    code_parameters::PARAM_STR,
    "Missing config value N for '%s,N'"
  },
  {
    code_severity::SEVERITY_SUCC,
    87,
    code_parameters::PARAM_NONE,
    "USB Statistics"
  },
  {
    code_severity::SEVERITY_INFO,
    88,
    code_parameters::PARAM_NONE,
    "No USB Statistics"
  },
  {
    code_severity::SEVERITY_ERR,
    94,
    code_parameters::PARAM_NONE,
    "Missing zero parameters"
  },
  {
    code_severity::SEVERITY_ERR,
    95,
    code_parameters::PARAM_STR,
    "Invalid zero parameter '%s'"
  },
  {
    code_severity::SEVERITY_SUCC,
    96,
    code_parameters::PARAM_STR,
    "Zeroed %s stats with summary"
  },
  {
    code_severity::SEVERITY_SUCC,
    97,
    code_parameters::PARAM_STR,
    "Zeroed %s stats without summary"
  },
  {
    code_severity::SEVERITY_ERR,
    99,
    code_parameters::PARAM_STR,
    "Invalid value for hotplug (%s) must be 0..9999"
  },
  {
    code_severity::SEVERITY_SUCC,
    100,
    code_parameters::PARAM_INT,
    "Hotplug check set to %ds"
  },
  {
    code_severity::SEVERITY_SUCC,
    101,
    code_parameters::PARAM_NONE,
    "Hotplug disabled"
  },
  {
    code_severity::SEVERITY_WARN,
    102,
    code_parameters::PARAM_NONE,
    "Hotplug is not available"
  },
  {
    code_severity::SEVERITY_ERR,
    103,
    code_parameters::PARAM_NONE,
    "Missing hotplug parameter"
  },
  { code_severity::SEVERITY_SUCC, 125, code_parameters::PARAM_NONE, "LCD" },
  {
    code_severity::SEVERITY_SUCC,
    123,
    code_parameters::PARAM_NONE,
    "Lock stats created"
  },
  {
    code_severity::SEVERITY_WARN,
    124,
    code_parameters::PARAM_NONE,
    "Lock stats not enabled"
  },
  { code_severity::SEVERITY_FAIL, 0, code_parameters::PARAM_PGA, NULL }
}; // idb
CMDS cmds[34] =
{
  {
    (char *)0x53020,
    (void (*)(io_data *, int, char *, bool, char))0x2F62D,
    false,
    true
  },
  {
    (char *)0x5627C,
    (void (*)(io_data *, int, char *, bool, char))0x2F4B5,
    false,
    true
  },
  { "devs", (void (*)(io_data *, int, char *, bool, char))0x2ED89, false, true },
  {
    "edevs",
    (void (*)(io_data *, int, char *, bool, char))0x2ED95,
    false,
    true
  },
  {
    "pools",
    (void (*)(io_data *, int, char *, bool, char))0x3040D,
    false,
    true
  },
  {
    (char *)0x56708,
    (void (*)(io_data *, int, char *, bool, char))0x2FDF1,
    false,
    true
  },
  {
    "pgacount",
    (void (*)(io_data *, int, char *, bool, char))0x2F42D,
    false,
    true
  },
  {
    "switchpool",
    (void (*)(io_data *, int, char *, bool, char))0x2EC69,
    true,
    false
  },
  {
    "addpool",
    (void (*)(io_data *, int, char *, bool, char))0x2EBCD,
    true,
    false
  },
  {
    "poolpriority",
    (void (*)(io_data *, int, char *, bool, char))0x2EA3D,
    true,
    false
  },
  {
    "poolquota",
    (void (*)(io_data *, int, char *, bool, char))0x2E969,
    true,
    false
  },
  {
    "enablepool",
    (void (*)(io_data *, int, char *, bool, char))0x2E8B9,
    true,
    false
  },
  {
    "disablepool",
    (void (*)(io_data *, int, char *, bool, char))0x2E7F1,
    true,
    false
  },
  {
    "removepool",
    (void (*)(io_data *, int, char *, bool, char))0x2E6FD,
    true,
    false
  },
  { "save", (void (*)(io_data *, int, char *, bool, char))0x2E3ED, true, false },
  { "quit", (void (*)(io_data *, int, char *, bool, char))0x2C4C1, true, false },
  {
    "privileged",
    (void (*)(io_data *, int, char *, bool, char))0x2E3E1,
    true,
    false
  },
  {
    "notify",
    (void (*)(io_data *, int, char *, bool, char))0x30CCD,
    false,
    true
  },
  {
    "devdetails",
    (void (*)(io_data *, int, char *, bool, char))0x2F2D5,
    false,
    true
  },
  {
    (char *)0x51108,
    (void (*)(io_data *, int, char *, bool, char))0x2C501,
    true,
    false
  },
  {
    (char *)0x564E0,
    (void (*)(io_data *, int, char *, bool, char))0x2FB21,
    false,
    true
  },
  {
    "estats",
    (void (*)(io_data *, int, char *, bool, char))0x2FA71,
    false,
    true
  },
  {
    "check",
    (void (*)(io_data *, int, char *, bool, char))0x2F10D,
    false,
    false
  },
  {
    "failover-only",
    (void (*)(io_data *, int, char *, bool, char))0x2E691,
    true,
    false
  },
  {
    (char *)0x56578,
    (void (*)(io_data *, int, char *, bool, char))0x2FCAD,
    false,
    true
  },
  {
    "debug",
    (void (*)(io_data *, int, char *, bool, char))0x2EE29,
    true,
    false
  },
  {
    "setconfig",
    (void (*)(io_data *, int, char *, bool, char))0x2E5BD,
    true,
    false
  },
  {
    "usbstats",
    (void (*)(io_data *, int, char *, bool, char))0x2E5B1,
    false,
    true
  },
  { "zero", (void (*)(io_data *, int, char *, bool, char))0x2E499, true, false },
  {
    "hotplug",
    (void (*)(io_data *, int, char *, bool, char))0x2E48D,
    true,
    false
  },
  {
    "asccount",
    (void (*)(io_data *, int, char *, bool, char))0x2EDA1,
    false,
    true
  },
  { "lcd", (void (*)(io_data *, int, char *, bool, char))0x2F781, false, true },
  {
    "lockstats",
    (void (*)(io_data *, int, char *, bool, char))0x2E481,
    true,
    true
  },
  { NULL, NULL, false, false }
}; // idb
int opt_log_level = 5; // idb
unsigned int crc16_table[256] =
{
  0u,
  4129u,
  8258u,
  12387u,
  16516u,
  20645u,
  24774u,
  28903u,
  33032u,
  37161u,
  41290u,
  45419u,
  49548u,
  53677u,
  57806u,
  61935u,
  4657u,
  528u,
  12915u,
  8786u,
  21173u,
  17044u,
  29431u,
  25302u,
  37689u,
  33560u,
  45947u,
  41818u,
  54205u,
  50076u,
  62463u,
  58334u,
  9314u,
  13379u,
  1056u,
  5121u,
  25830u,
  29895u,
  17572u,
  21637u,
  42346u,
  46411u,
  34088u,
  38153u,
  58862u,
  62927u,
  50604u,
  54669u,
  13907u,
  9842u,
  5649u,
  1584u,
  30423u,
  26358u,
  22165u,
  18100u,
  46939u,
  42874u,
  38681u,
  34616u,
  63455u,
  59390u,
  55197u,
  51132u,
  18628u,
  22757u,
  26758u,
  30887u,
  2112u,
  6241u,
  10242u,
  14371u,
  51660u,
  55789u,
  59790u,
  63919u,
  35144u,
  39273u,
  43274u,
  47403u,
  23285u,
  19156u,
  31415u,
  27286u,
  6769u,
  2640u,
  14899u,
  10770u,
  56317u,
  52188u,
  64447u,
  60318u,
  39801u,
  35672u,
  47931u,
  43802u,
  27814u,
  31879u,
  19684u,
  23749u,
  11298u,
  15363u,
  3168u,
  7233u,
  60846u,
  64911u,
  52716u,
  56781u,
  44330u,
  48395u,
  36200u,
  40265u,
  32407u,
  28342u,
  24277u,
  20212u,
  15891u,
  11826u,
  7761u,
  3696u,
  65439u,
  61374u,
  57309u,
  53244u,
  48923u,
  44858u,
  40793u,
  36728u,
  37256u,
  33193u,
  45514u,
  41451u,
  53516u,
  49453u,
  61774u,
  57711u,
  4224u,
  161u,
  12482u,
  8419u,
  20484u,
  16421u,
  28742u,
  24679u,
  33721u,
  37784u,
  41979u,
  46042u,
  49981u,
  54044u,
  58239u,
  62302u,
  689u,
  4752u,
  8947u,
  13010u,
  16949u,
  21012u,
  25207u,
  29270u,
  46570u,
  42443u,
  38312u,
  34185u,
  62830u,
  58703u,
  54572u,
  50445u,
  13538u,
  9411u,
  5280u,
  1153u,
  29798u,
  25671u,
  21540u,
  17413u,
  42971u,
  47098u,
  34713u,
  38840u,
  59231u,
  63358u,
  50973u,
  55100u,
  9939u,
  14066u,
  1681u,
  5808u,
  26199u,
  30326u,
  17941u,
  22068u,
  55628u,
  51565u,
  63758u,
  59695u,
  39368u,
  35305u,
  47498u,
  43435u,
  22596u,
  18533u,
  30726u,
  26663u,
  6336u,
  2273u,
  14466u,
  10403u,
  52093u,
  56156u,
  60223u,
  64286u,
  35833u,
  39896u,
  43963u,
  48026u,
  19061u,
  23124u,
  27191u,
  31254u,
  2801u,
  6864u,
  10931u,
  14994u,
  64814u,
  60687u,
  56684u,
  52557u,
  48554u,
  44427u,
  40424u,
  36297u,
  31782u,
  27655u,
  23652u,
  19525u,
  15522u,
  11395u,
  7392u,
  3265u,
  61215u,
  65342u,
  53085u,
  57212u,
  44955u,
  49082u,
  36825u,
  40952u,
  28183u,
  32310u,
  20053u,
  24180u,
  11923u,
  16050u,
  3793u,
  7920u
}; // idb
device_drv bitmainZCASH_drv =
{
  drv_driver::DRIVER_bitmainZCASH,
  "Bitmain_ZCASH",
  (char *)0x5A918,
  (void (*)(bool))0x33CAD,
  (void (*)(cgpu_info *))0x33C91,
  (void (*)(char *, size_t, cgpu_info *))0x337E9,
  NULL,
  (api_data *(*)(cgpu_info *))0x33905,
  NULL,
  NULL,
  NULL,
  (bool (*)(thr_info *))0x3F2C1,
  NULL,
  NULL,
  NULL,
  (void (*)(thr_info *))0x21C65,
  NULL,
  (int64_t (*)(thr_info *))0x338CD,
  NULL,
  NULL,
  (void (*)(cgpu_info *))0x33861,
  NULL,
  (void (*)(thr_info *))0x38C9D,
  NULL,
  NULL,
  false,
  0.0,
  0.0,
  0.0
}; // idb
uint8_t isl_dev_addr[3] = { 80u, 84u, 88u }; // idb
bool send_heart = true; // idb
uint32_t default_core_timeout_reg = 4294967295u; // idb
uint32_t default_nonce_shift_reg = 20u; // idb
uint32_t default_io_drive_strength_reg = 34689297u; // idb
uint32_t default_pll_reg = 2150105409u; // idb
uint32_t default_misc_reg = 117455361u; // idb
uint32_t default_ticket_mask_reg = 16u; // idb
uint32_t default_txn_data = 3u; // idb
char blink_15605 = '\x01'; // weak
uint32_t default_i2c_reg = 16777216u; // idb
bool is_rt = true; // idb
int opt_bitmain_fan_pwm = 50; // idb
int opt_bitmain_core_timeout = 84000; // idb
int opt_bitmain_ZCASH_freq = 800; // idb
char *cert_devname = &byte_5A90C; // idb
int compare_size = 3; // idb
void *(*memset_v_6360)(void *s, int c, size_t n) = &memset; // weak
int freq_scan_status = 1; // idb
int listen_sockfd = -1; // idb
json_malloc_t do_malloc = &malloc; // idb
json_free_t do_free = &free; // idb
json_t the_true_9029 = { JSON_TRUE, 4294967295u }; // idb
json_t the_false_9033 = { JSON_FALSE, 4294967295u }; // idb
json_t the_null_9037 = { JSON_NULL, 4294967295u }; // idb
int stderr; // weak
int stdin; // weak
int stdout; // weak
char completed_10529; // weak
char *opt_logfile_path; // idb
char *opt_logwork_asicnum; // idb
char *opt_logwork_path; // idb
char *opt_logfile_openflag; // idb
char *opt_version_path; // idb
char *default_config; // idb
FILE *sharelog_file; // idb
JE *jedata; // idb
char exit_buf[512]; // idb
char packagename[256]; // idb
int api_thr_id; // idb
pool_strategy pool_strategy_0; // idb
char *temp_cutoff_str; // idb
timeval restart_tv_start; // idb
timeval update_tv_start; // idb
timeval total_tv_end; // idb
int forkpid; // idb
char **initial_args; // idb
char *opt_set_null; // idb
uint64_t best_diff; // idb
bool config_loaded; // idb
char *cnfbuf; // idb
int include_count; // idb
char err_buf_15170[200]; // idb
int fileconf_load; // idb
FILE *benchfile_in; // idb
char *opt_benchfile; // idb
int benchfile_line; // idb
int benchfile_work; // idb
bool opt_fix_protocol; // idb
pthread_mutex_t *stgd_lock; // idb
uint32_t total_work; // idb
timeval total_tv_start; // idb
timeval tv_hashmeter; // idb
double g_local_mhashes_dones[12]; // idb
int g_local_mhashes_index; // idb
bool zero_stats_flag; // idb
char datestamp[40]; // idb
int opt_shares; // idb
int watchpool_thr_id; // idb
int watchdog_thr_id; // idb
pool *currentpool; // idb
int total_users; // idb
int total_passes; // idb
int total_userpasses; // idb
int total_urls; // idb
work *staged_work; // idb
pthread_mutex_t lp_lock; // idb
pthread_cond_t lp_cond; // idb
bool pools_active; // idb
bool opt_benchmark; // idb
pthread_mutex_t sshare_lock; // idb
stratum_share *stratum_shares; // idb
timeval rotate_tv; // idb
bool work_filled; // idb
bool work_emptied; // idb
int staged_rollable; // idb
pthread_mutex_t sharelog_lock; // idb
unsigned int work_block; // idb
unsigned __int8 bench_hidiff_bins[16][160]; // idb
unsigned __int8 bench_lodiff_bins[16][160]; // idb
time_t hashdisplay_t; // idb
double g_displayed_rolling; // idb
char statusline[256]; // idb
pthread_rwlock_t blk_lock; // idb
block *blocks; // idb
char block_diff[8]; // idb
char current_block[32]; // idb
char blocktime[32]; // idb
char prev_block[12]; // idb
bool opt_benchfile_display; // idb
int cgminer_id_count; // idb
int new_threads; // idb
int devids_17132; // weak
int new_devices; // idb
int most_devices; // idb
unsigned __int8 bench_target[32]; // idb
char g_miner_compiletime[256]; // idb
char g_miner_type[256]; // idb
int g_logwork_asicnum; // idb
FILE *g_logwork_file; // idb
FILE *g_logwork_files[65]; // idb
bool opt_logwork_diff; // idb
FILE *g_logwork_diffs[65]; // idb
char *opt_socks_proxy; // idb
char displayed_hash_rate[16]; // idb
char g_miner_version[256]; // idb
char *opt_api_allow; // idb
char set_os_time_12121; // weak
bool successful_connect; // idb
bool bye; // idb
bool do_a_quit; // idb
bool do_a_restart; // idb
IPACCESS *ipaccess; // idb
int ips; // idb
pthread_mutex_t quit_restart_lock; // idb
io_list *io_head; // idb
K_LIST *strbufs; // idb
time_t when; // idb
bool g_logfile_enable; // idb
FILE *g_log_file; // idb
char g_logfile_openflag[32]; // idb
char g_logfile_path[256]; // idb
bool opt_log_output; // idb
bool opt_debug; // idb
unsigned int *axi_fpga_addr; // idb
bool new_block[4]; // idb
uint64_t h; // idb
double hwp; // idb
bool certification_firmware; // idb
double rt_hashrate_total; // idb
int rt_chain_num; // idb
bool status_error; // idb
double each_chain_h_avg[4]; // idb
uint64_t h_each_chain[4]; // idb
double geach_chain_h_all; // idb
pthread_mutex_t nonce_mutex; // idb
pthread_mutex_t work_queue_mutex; // idb
unsigned int *fpga_mem_addr; // idb
pthread_mutex_t uart_send_mutex[10]; // idb
pthread_mutex_t uart_receive_mutex[10]; // idb
bool start_send[4]; // idb
bool stop; // idb
bool gBegin_get_nonce; // idb
timeval tv_send_job; // idb
int i2c_slave_addr; // idb
pthread_mutex_t i2c_mutex; // idb
unsigned __int16 isl_vol[4][3]; // idb
pthread_mutex_t iic_mutex; // idb
unsigned __int8 pic_version[4]; // idb
pthread_mutex_t each_chain_err_asic_mutex; // idb
bool gMinerStatus_Not_read_all_sensor; // idb
int temp_highest; // idb
int last_temperature; // idb
unsigned __int8 TempChipAddr[4]; // idb
pthread_mutex_t reinit_mutex; // idb
uint64_t rate[4]; // idb
unsigned __int8 g_HASH_RATE_reg_value_num[4]; // idb
unsigned __int8 rate_error[4]; // idb
bool g_HASH_RATE_reg_value_from_which_asic[4][128]; // idb
unsigned int g_HASH_RATE_reg_value[4][128]; // idb
pthread_mutex_t reg_mutex; // idb
bool update_asic_num[4]; // idb
bool g_chip_temp_return[4][3][4]; // idb
char send_back_gTempOffsetValue[16]; // idb
char sensor_id[16]; // idb
char gTempOffsetValue[16]; // idb
bool need_recheck[4]; // idb
bool opt_bitmain_fan_ctrl; // idb
uint32_t total_error_16509; // idb
bool ExitServer; // idb
char *opt_api_groups; // idb
schedtime schedstop; // idb
int64_t total_stale; // idb
char current_hash[68]; // idb
int hw_errors; // idb
double total_diff_accepted; // idb
bool opt_quiet; // idb
int64_t total_discarded; // idb
device_drv hashfast_drv; // idb
bool no_work; // idb
bool want_per_device_stats; // idb
double total_diff_rejected; // idb
bool opt_protocol; // idb
device_drv cointerra_drv; // idb
schedtime schedstart; // idb
int total_pools; // idb
device_drv bitmain_drv; // idb
unsigned int found_blocks; // idb
bool sched_paused; // idb
device_drv minion_drv; // idb
int opt_rotate_period; // idb
device_drv klondike_drv; // idb
device_drv avalon_drv; // idb
cgpu_info **devices; // idb
device_drv bitmain_c5_drv; // idb
device_drv blockerupter_drv; // idb
unsigned __int64 global_hashrate; // idb
bool hotplug_mode; // idb
bool opt_api_mcast; // idb
int opt_suggest_diff; // idb
bool use_curses; // idb
device_drv knc_drv; // idb
int swork_id; // idb
unsigned int total_ro; // idb
int zombie_devs; // idb
bool opt_worktime; // idb
time_t last_getwork; // idb
thr_info **mining_thr; // idb
pthread_rwlock_t mining_thr_lock; // idb
pool **pools; // idb
pthread_cond_t gws_cond; // idb
bool use_syslog; // idb
bool opt_delaynet; // idb
bool have_longpoll; // idb
device_drv avalon2_drv; // idb
cglock_t ch_lock; // idb
device_drv bmsc_drv; // idb
cglock_t control_lock; // idb
device_drv sp10_drv; // idb
int enabled_pools; // idb
char *cgminer_path; // idb
int g_max_fan; // idb
int g_max_temp; // idb
device_drv bab_drv; // idb
int mining_threads; // idb
double total_rolling; // idb
thr_info *control_thr; // idb
bool opt_realquiet; // idb
pthread_rwlock_t netacc_lock; // idb
int total_devices; // idb
char *opt_kernel_path; // idb
device_drv drillbit_drv; // idb
unsigned int total_go; // idb
bool opt_fail_only; // idb
device_drv bitmineA1_drv; // idb
device_drv bitfury_drv; // idb
int64_t total_accepted; // idb
thread_q *getq; // idb
int64_t total_getworks; // idb
timeval block_timeval; // idb
sigaction termhandler; // idb
bool opt_lowmem; // idb
bool opt_api_listen; // idb
device_drv modminer_drv; // idb
double rolling5; // idb
double rolling1; // idb
double rolling15; // idb
device_drv icarus_drv; // idb
double total_mhashes_done; // idb
bool opt_compact; // idb
double total_diff_stale; // idb
pthread_mutex_t stats_lock; // idb
unsigned int new_blocks; // idb
device_drv bflsc_drv; // idb
bool opt_disable_pool; // idb
pthread_mutex_t console_lock; // idb
pthread_cond_t restart_cond; // idb
sigaction inthandler; // idb
bool opt_api_network; // idb
list_head scan_devices; // idb
pthread_mutex_t update_job_lock; // idb
device_drv sp30_drv; // idb
device_drv bitforce_drv; // idb
unsigned int local_work; // idb
int64_t total_rejected; // idb
bool opt_work_update; // idb
pthread_mutex_t restart_lock; // idb
pthread_rwlock_t devices_lock; // idb
pthread_mutex_t hash_lock; // idb
bool opt_scrypt; // idb
device_drv hashratio_drv; // idb
int64_t total_diff1; // idb
device_drv avalon4_drv; // idb
APIGROUPS apigroups[26]; // idb
thr_info *auto_freq_id; // idb
thr_info *read_hash_rate; // idb
scan_freq_status g_scan_freq_info; // idb
int fd_fpga_mem; // idb
thr_info *check_fan_id; // idb
thr_info *pic_heart_beat; // idb
char displayed_rate[64]; // idb
thr_info *check_miner_status_id; // idb
all_parameters dev; // idb
pthread_cond_t each_chain_err_asic_cond; // idb
reg_buf reg_fifo; // idb
thr_info *read_temp_id; // idb
int fpga_fd; // idb
dev_info dev_info_0[4]; // idb
nonce_buf nonce_fifo; // idb
unsigned int opt_num_short_arg; // idb
unsigned int opt_num_long; // idb
unsigned int opt_num_short; // idb
opt_table *opt_table_0; // idb
const char *opt_argv0; // idb
unsigned int opt_count; // idb
const char opt_hidden[]; // idb
// extern _UNKNOWN __gmon_start__; weak


//----- (00011EF4) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return call_weak_fn();
}

//----- (00011F00) --------------------------------------------------------
void sub_11F00()
{
  JUMPOUT(0);
}
// 11F0C: control flows out of bounds to 0

//----- (00011F14) --------------------------------------------------------
// attributes: thunk
int j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (00011F78) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_11F78(const char *s1, const char *s2)
{
  return strcmp(s1, s2);
}

//----- (00012000) --------------------------------------------------------
// attributes: thunk
void __fastcall sub_12000(void *ptr)
{
  free(ptr);
}

//----- (00012058) --------------------------------------------------------
// attributes: thunk
void *__fastcall sub_12058(void *dest, const void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (00012098) --------------------------------------------------------
// attributes: thunk
int j_memcmp(const void *s1, const void *s2, size_t n)
{
  return memcmp(s1, s2, n);
}

//----- (000121BC) --------------------------------------------------------
// attributes: thunk
char *j_strcpy(char *dest, const char *src)
{
  return strcpy(dest, src);
}

//----- (000121CC) --------------------------------------------------------
// attributes: thunk
int j_gettimeofday(struct timeval *tv, __timezone_ptr_t tz)
{
  return gettimeofday(tv, tz);
}

//----- (000121F4) --------------------------------------------------------
// attributes: thunk
int j_pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)
{
  return pthread_create(newthread, attr, start_routine, arg);
}

//----- (00012270) --------------------------------------------------------
// attributes: thunk
int j_system(const char *command)
{
  return system(command);
}

//----- (0001237C) --------------------------------------------------------
// attributes: thunk
int j_fcntl(int fd, int cmd, ...)
{
  return fcntl(fd, cmd);
}

//----- (000123BC) --------------------------------------------------------
// attributes: thunk
int j_snprintf(char *s, size_t maxlen, const char *format, ...)
{
  return snprintf(s, maxlen, format);
}

//----- (000123CC) --------------------------------------------------------
// attributes: thunk
char *j___strdup(const char *s)
{
  return _strdup(s);
}

//----- (00012400) --------------------------------------------------------
// attributes: thunk
void *j_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (00012428) --------------------------------------------------------
// attributes: thunk
char *j_strncpy(char *dest, const char *src, size_t n)
{
  return strncpy(dest, src, n);
}

//----- (00012588) --------------------------------------------------------
// attributes: thunk
void j_syslog(int pri, const char *fmt, ...)
{
  syslog(pri, fmt);
}

//----- (00012634) --------------------------------------------------------
// attributes: thunk
int j_clock_gettime(clockid_t clock_id, struct timespec *tp)
{
  return clock_gettime(clock_id, tp);
}

//----- (00012674) --------------------------------------------------------
// attributes: thunk
int j_sem_destroy(sem_t *sem)
{
  return sem_destroy(sem);
}

//----- (000126CC) --------------------------------------------------------
// attributes: thunk
int j_close(int fd)
{
  return close(fd);
}

//----- (00012700) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // r0
  int (*v4)(void); // r2
  int (**v5)(void); // r3
  bool v6; // zf
  int v7; // r0
  char **v8; // r0
  int v9; // r3
  char **v10; // r5
  char **v11; // r6
  int v12; // r4
  char **v13; // r8
  const char *v14; // t1
  char *v15; // r0
  int v16; // r3
  int v17; // r3
  int v18; // r3
  int v19; // r3
  int v20; // r3
  int v21; // r3
  int v22; // r3
  int v23; // r3
  int v24; // r3
  int v25; // r3
  thread_q *v26; // r0
  char *v27; // r0
  char *v28; // r0
  char *v29; // r6
  char *v30; // r5
  char *v31; // r0
  char *v32; // r4
  size_t v33; // r0
  __int16 v34; // r3
  char *v35; // r6
  int v36; // r8
  size_t v37; // r0
  bool *v38; // r3
  int v39; // r3
  int v40; // r2
  unsigned int v41; // r5
  device_drv *v42; // r9
  int64_t (*scanwork)(thr_info *); // r3
  size_t v44; // r8
  int v45; // r3
  unsigned __int8 *v46; // lr
  int v47; // r4
  int v48; // r2
  int v49; // r9
  int v50; // r1
  unsigned __int8 *v51; // r12
  int v52; // r0
  unsigned int v53; // r2
  unsigned int v54; // r5
  int v55; // r4
  unsigned int v56; // r5
  unsigned int v57; // r2
  int v58; // r4
  unsigned int v59; // r5
  unsigned int v60; // r3
  unsigned __int8 *v61; // r10
  size_t v62; // r0
  size_t v63; // r2
  int v64; // r3
  unsigned int v65; // r5
  unsigned int v66; // r2
  int v67; // r3
  unsigned int v68; // r5
  unsigned int v69; // r2
  int v70; // r3
  unsigned int v71; // r3
  int v72; // r0
  int v73; // r3
  int64_t (*v74)(thr_info *); // r2
  int v75; // r3
  __int64 v76; // kr08_8
  int v77; // r4
  char *v78; // r4
  pool *v79; // r5
  char *v80; // r0
  char **v81; // r3
  char *rpc_url; // r3
  pool_enable enabled; // r3
  unsigned __int8 *v84; // r9
  int v85; // r4
  unsigned __int8 *v86; // r5
  unsigned __int8 *v87; // r0
  const char *v88; // r1
  double v89; // r2
  const char *v90; // r0
  FILE *v91; // r5
  signed int v92; // r0
  char *v93; // r0
  char *v94; // r5
  bool *v95; // r11
  bool *v96; // r3
  bool *v97; // r3
  bool *v98; // r3
  bool *v99; // r3
  char **v100; // r4
  const char *v101; // r1
  const char *v102; // r1
  const char *v103; // r4
  const char *v104; // r0
  int v105; // r0
  FILE *v106; // r0
  _BOOL4 v107; // r3
  int v108; // r3
  int v109; // r4
  bool *v110; // r8
  FILE *v111; // r0
  _BOOL4 v112; // r3
  int v113; // r3
  bool *v114; // r8
  int v115; // r4
  FILE *v116; // r0
  _BOOL4 v117; // r3
  const char *v118; // r3
  char *v119; // r3
  char **v120; // r4
  int v121; // r3
  thr_info *v122; // r4
  char **v123; // r3
  device_drv *v124; // r2
  device_drv *v125; // r3
  int v126; // r0
  int v127; // r2
  device_drv *v128; // r0
  device_drv *v129; // r3
  device_drv *v130; // r2
  device_drv *v131; // r12
  device_drv *v132; // r12
  device_drv *v133; // r3
  device_drv *v134; // r12
  device_drv *v135; // r12
  device_drv *v136; // r12
  device_drv *v137; // r12
  device_drv *v138; // r12
  size_t *v139; // r12
  int v140; // r1
  int v141; // r5
  pthread_rwlock_t *v142; // r0
  char *v143; // r0
  int v144; // r4
  unsigned int v145; // r5
  char *i; // r0
  const char *v147; // r2
  int v148; // r3
  _DWORD *v149; // r8
  unsigned int v150; // r0
  unsigned int v151; // r3
  int v152; // r0
  char *v153; // r11
  _DWORD *v154; // r5
  _DWORD *v155; // r6
  int v156; // r4
  char *v157; // r9
  unsigned int v158; // r2
  int v159; // r3
  _DWORD *v160; // r3
  unsigned int v161; // r2
  unsigned int v162; // r1
  bool v163; // cc
  int v164; // r2
  int v165; // r3
  bool *v166; // r3
  _DWORD *v167; // r0
  _DWORD *v168; // r4
  void *v169; // r0
  char *v170; // r0
  char **v171; // r5
  char **v172; // r5
  char *v173; // r4
  char *v174; // r5
  int v175; // r0
  int v176; // r1
  int v177; // r2
  int v178; // r3
  _DWORD *v179; // r4
  _DWORD *v180; // r5
  int v181; // r1
  char v182; // r3
  char *v183; // r5
  FILE *v184; // r0
  _BOOL4 v185; // r3
  int v186; // r0
  const char *v187; // r2
  int v188; // r3
  int v189; // r2
  cgpu_info **v190; // r4
  cgpu_info *v191; // r3
  const char *v192; // r2
  int v193; // r3
  int v194; // r0
  drv_driver drv_id; // r4
  int j; // r3
  int v197; // r2
  int v198; // r9
  char *v199; // r3
  int v200; // r4
  int v201; // r3
  size_t v202; // r5
  size_t v203; // r5
  char *v204; // r0
  __int64 v205; // kr10_8
  _BOOL4 v206; // r2
  __sighandler_t v207; // r4
  __sighandler_t v208; // r0
  __pid_t v209; // r0
  __pid_t v210; // r4
  thr_info **v211; // r4
  int *v212; // r6
  signed int k; // r5
  int v214; // r4
  int v215; // r5
  cgpu_info *v216; // r6
  size_t v217; // r4
  thr_info **v218; // r0
  thr_info *thread; // r0
  device_drv *v220; // r3
  thr_info *v221; // r4
  int *v222; // r0
  const char *v223; // r2
  int v224; // r3
  int v225; // r2
  cgpu_info **v226; // r3
  cgpu_info *v227; // r1
  const char *v228; // r2
  int v229; // r3
  int *v230; // r0
  int v231; // r4
  int v232; // r1
  drv_driver v233; // r0
  int v234; // r5
  int v235; // r4
  int v236; // r5
  int m; // r4
  int v238; // r3
  thr_info *v239; // r4
  thr_info *v240; // r10
  thr_info *v241; // r3
  int v242; // r3
  int v243; // r4
  int v244; // r3
  int *v245; // r5
  bool *v246; // r6
  device_drv *v247; // r10
  signed int v248; // r5
  char *v249; // r3
  char **v250; // r0
  pthread_mutex_t *v251; // r1
  signed int v252; // r3
  char **v253; // r4
  char *v254; // r4
  signed int v255; // r3
  unsigned int *v256; // r1
  work *v257; // r0
  device_drv *work; // r10
  pool *v259; // r0
  pool *v260; // r5
  char *v261; // r3
  pool *v262; // r4
  pool *v263; // r0
  pool *v264; // r10
  char *v265; // r3
  pool *v266; // r5
  int v267; // r3
  int v268; // r2
  char *v269; // r1
  __int64 v270; // kr18_8
  int kk; // r3
  int v272; // r5
  int v273; // r3
  pool *v274; // r5
  int mm; // r4
  int v276; // r2
  __int64 v277; // kr20_8
  int v278; // r2
  char **v279; // r3
  void (*v280)(cgpu_info *); // r1
  char *(*v281)(cgpu_info *, char *, char *, char *); // r2
  bool (*v282)(thr_info *); // r3
  uint64_t (*v283)(thr_info *); // r0
  bool (*v284)(thr_info *); // r1
  bool (*v285)(thr_info *, work *); // r2
  device_drv *v286; // r3
  device_drv *v287; // r3
  const char *v288; // r5
  int v289; // r0
  int v290; // r1
  int v291; // r2
  int v292; // r3
  _DWORD *v293; // r5
  int v294; // r1
  int v295; // r2
  work *v296; // r0
  char **v297; // r3
  double v298; // r2
  int nn; // r4
  pool *v300; // r0
  pool *v301; // r0
  int v302; // r3
  int v303; // r2
  char *v304; // r1
  __int64 v305; // kr28_8
  int v306; // r3
  int ii; // r3
  int v308; // r9
  __int64 v309; // kr30_8
  pool *v310; // r0
  int v311; // r3
  int jj; // r9
  pool *v313; // r0
  int *v314; // r0
  const char *v315; // r2
  int v316; // r4
  int v317; // r0
  signed int v318; // r1
  int v319; // r3
  int v320; // r4
  int *v321; // r0
  int *v322; // r0
  int v323; // r4
  int n; // r3
  int v325; // r4
  char v327; // [sp+10h] [bp-2010h] BYREF
  char v328[4088]; // [sp+1018h] [bp-1008h] BYREF
  const char *v329; // [sp+2010h] [bp-10h]
  thr_info **v330; // [sp+2020h] [bp+0h]
  char **v331; // [sp+2024h] [bp+4h]
  unsigned int *v332; // [sp+2028h] [bp+8h]
  size_t *v333; // [sp+202Ch] [bp+Ch]
  device_drv *v334; // [sp+2030h] [bp+10h]
  device_drv *v335; // [sp+2034h] [bp+14h]
  device_drv *v336; // [sp+2038h] [bp+18h]
  device_drv *v337; // [sp+203Ch] [bp+1Ch]
  device_drv *v338; // [sp+2040h] [bp+20h]
  device_drv *v339; // [sp+2044h] [bp+24h]
  device_drv *v340; // [sp+2048h] [bp+28h]
  device_drv *v341; // [sp+204Ch] [bp+2Ch]
  device_drv *v342; // [sp+2050h] [bp+30h]
  device_drv *v343; // [sp+2054h] [bp+34h]
  device_drv *v344; // [sp+2058h] [bp+38h]
  __int64 v345; // [sp+205Ch] [bp+3Ch]
  bool *v346; // [sp+2064h] [bp+44h]
  device_drv *v347; // [sp+2068h] [bp+48h]
  device_drv *drv; // [sp+206Ch] [bp+4Ch]
  char **argva; // [sp+2070h] [bp+50h]
  bool *v350; // [sp+2074h] [bp+54h]
  char **v351; // [sp+2078h] [bp+58h]
  int argca; // [sp+207Ch] [bp+5Ch] BYREF
  struct sigaction act; // [sp+2084h] [bp+64h] BYREF
  char s[256]; // [sp+2110h] [bp+F0h] BYREF
  char str[4100]; // [sp+2210h] [bp+1F0h] BYREF

  argva = (char **)argv;
  argca = argc;
  strcpy(g_logfile_path, "cgminer.log");
  drv = (device_drv *)&g_logfile_enable;
  strcpy(g_logfile_openflag, "a+");
  g_logfile_enable = 0;
  LODWORD(v345) = g_logfile_openflag;
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v5 = &selective_yield;
    v4 = sched_yield;
  }
  v7 = argca + 1;
  if ( v6 )
    *v5 = v4;
  v351 = &opt_logfile_path;
  v8 = (char **)malloc(4 * v7);
  v9 = argca;
  v10 = v8;
  initial_args = v8;
  if ( argca > 0 )
  {
    v11 = v8 - 1;
    v12 = 0;
    v13 = argva - 1;
    do
    {
      v14 = v13[1];
      ++v13;
      ++v12;
      v15 = _strdup(v14);
      v9 = argca;
      v11[1] = v15;
      ++v11;
    }
    while ( v9 > v12 );
  }
  v10[v9] = 0;
  mutex_init_0(
    &hash_lock,
    (pthread_mutex_t *)(&_func___17121.__align + 7),
    (const char *)0x29C5,
    (unsigned __int16)&bench_lodiff_bins[2][12]);
  mutex_init_0(&update_job_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29C6, v16);
  mutex_init_0(&console_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29C7, v17);
  cglock_init_constprop_65((int)&control_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29C8);
  mutex_init_0(&stats_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29C9, v18);
  v350 = (bool *)&bench_lodiff_bins[2][12];
  mutex_init_0(
    &sharelog_lock,
    (pthread_mutex_t *)(&_func___17121.__align + 7),
    (const char *)0x29CA,
    (const int)&bench_lodiff_bins[2][12]);
  cglock_init_constprop_65((int)&ch_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29CB);
  mutex_init_0(&sshare_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29CC, v19);
  rwlock_init_0(&blk_lock, (pthread_rwlock_t *)(&_func___17121.__align + 7), (const char *)0x29CD, v20);
  rwlock_init_0(&netacc_lock, (pthread_rwlock_t *)(&_func___17121.__align + 7), (const char *)0x29CE, v21);
  rwlock_init_0(&mining_thr_lock, (pthread_rwlock_t *)(&_func___17121.__align + 7), (const char *)0x29CF, v22);
  rwlock_init_0(&devices_lock, (pthread_rwlock_t *)(&_func___17121.__align + 7), (const char *)0x29D0, v23);
  mutex_init_0(&lp_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29D2, v24);
  if ( pthread_cond_init(&lp_cond, 0) )
  {
    strcpy(str, "Failed to pthread_cond_init lp_cond");
    applog(3, str, 1);
    _quit(1, 0);
  }
  mutex_init_0(&restart_lock, (pthread_mutex_t *)(&_func___17121.__align + 7), (const char *)0x29D6, v25);
  if ( pthread_cond_init(&restart_cond, 0) )
  {
    strcpy(str, "Failed to pthread_cond_init restart_cond");
    goto LABEL_169;
  }
  v346 = (bool *)pthread_cond_init(&gws_cond, 0);
  if ( v346 )
  {
    strcpy(str, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v26 = tq_new();
    getq = v26;
    if ( v26 )
    {
      v329 = (const char *)&unk_5320C;
      v351[273] = (char *)&v26->mutex;
      snprintf(packagename, 0x100u, "%s %s", "cgminer", v329);
      act.sa_handler = sighandler;
      act.sa_flags = (int)v346;
      sigemptyset(&act.sa_mask);
      sigaction_0(15, &act, &termhandler);
      sigaction_0(2, &act, &inthandler);
      signal(13, (__sighandler_t)1);
      opt_kernel_path = v328;
      v343 = (device_drv *)&opt_kernel_path;
      strcpy(v328, "/usr/local/bin");
      cgminer_path = &v327;
      v27 = *argva;
      HIDWORD(v345) = &word_4F7A8;
      v28 = _strdup(v27);
      v29 = cgminer_path;
      v30 = v28;
      v31 = dirname(v28);
      strcpy(v29, v31);
      free(v30);
      v32 = cgminer_path;
      v33 = strlen(cgminer_path);
      v34 = *(_WORD *)HIDWORD(v345);
      *((_DWORD *)v350 + 660) = 9;
      *(_WORD *)&v32[v33] = v34;
      v35 = (char *)calloc(0x68u, 1u);
      if ( !v35 )
      {
        strcpy(str, "main OOM");
        goto LABEL_174;
      }
      v36 = 36;
      do
      {
        --v36;
        *(_WORD *)&v35[strlen(v35)] = 48;
      }
      while ( v36 );
      *((_DWORD *)v35 + 19) = 0;
      *((_DWORD *)v35 + 22) = v35;
      v37 = strlen(v35);
      v38 = v350;
      *((_DWORD *)v35 + 23) = v37;
      v39 = *((_DWORD *)v38 + 632);
      if ( v39 )
      {
        v40 = *(_DWORD *)(v39 + 68);
        v347 = (device_drv *)(v35 + 68);
        *(_DWORD *)(*(_DWORD *)(v40 + 16) + 8) = v35;
        *((_DWORD *)v35 + 18) = *(_DWORD *)(*(_DWORD *)(v39 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v39 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v39 + 68) + 16) = v35 + 68;
      }
      else
      {
        v166 = v350;
        *((_DWORD *)v35 + 18) = 0;
        *((_DWORD *)v166 + 632) = v35;
        v167 = malloc(0x2Cu);
        v168 = v167;
        *((_DWORD *)v35 + 17) = v167;
        if ( !v167 )
          goto LABEL_164;
        memset(v167 + 3, 0, 0x20u);
        v168[1] = 32;
        v347 = (device_drv *)(v35 + 68);
        v168[2] = 5;
        v168[4] = v35 + 68;
        v168[5] = 68;
        v169 = calloc(0x180u, 1u);
        *v168 = v169;
        if ( !v169 )
          goto LABEL_164;
        v168[10] = -1609490463;
      }
      LOWORD(v41) = 31161;
      v42 = (device_drv *)*((_DWORD *)v350 + 632);
      ++*((_DWORD *)v42->scanwork + 3);
      scanwork = v42->scanwork;
      *((_DWORD *)v35 + 24) = -17973521;
      *((_DWORD *)v35 + 17) = scanwork;
      v44 = strlen(v35);
      if ( v44 <= 0xB )
      {
        HIWORD(v41) = -25033;
        v61 = (unsigned __int8 *)v35;
        v47 = v41;
      }
      else
      {
        HIWORD(v41) = -25033;
        v45 = -17973521;
        v46 = (unsigned __int8 *)(v35 + 12);
        v47 = v41;
        v344 = v42;
        do
        {
          v48 = *(v46 - 2);
          v44 -= 12;
          v49 = *(v46 - 3);
          v50 = *(v46 - 6);
          v51 = v46;
          v52 = *(v46 - 10);
          v46 += 12;
          v53 = (v48 << 16) + (v49 << 8) + *(v46 - 16) + (*(v46 - 13) << 24) + v45;
          v54 = v41 + (v50 << 16) + (*(v46 - 19) << 8) + *(v46 - 20) + (*(v46 - 17) << 24);
          v55 = (v47 + (v52 << 16) + (*(v46 - 23) << 8) + *(v46 - 24) + (*(v46 - 21) << 24) - v53 - v54) ^ (v53 >> 13);
          v56 = (v54 - v53 - v55) ^ (v55 << 8);
          v57 = (v53 - v55 - v56) ^ (v56 >> 13);
          v58 = (v55 - v56 - v57) ^ (v57 >> 12);
          v59 = (v56 - v57 - v58) ^ (v58 << 16);
          v60 = (v57 - v58 - v59) ^ (v59 >> 5);
          v47 = (v58 - v59 - v60) ^ (v60 >> 3);
          v41 = (v59 - v60 - v47) ^ (v47 << 10);
          v45 = (v60 - v47 - v41) ^ (v41 >> 15);
          *((_DWORD *)v35 + 24) = v45;
        }
        while ( v44 > 0xB );
        v42 = v344;
        v61 = v51;
      }
      v62 = strlen(v35) + *((_DWORD *)v35 + 24);
      *((_DWORD *)v35 + 24) = v62;
      v63 = v62;
      switch ( v44 )
      {
        case 1u:
          goto LABEL_32;
        case 2u:
          goto LABEL_31;
        case 3u:
          goto LABEL_30;
        case 4u:
          goto LABEL_29;
        case 5u:
          goto LABEL_28;
        case 6u:
          goto LABEL_27;
        case 7u:
          goto LABEL_26;
        case 8u:
          goto LABEL_25;
        case 9u:
          goto LABEL_24;
        case 0xAu:
          goto LABEL_23;
        case 0xBu:
          v63 = v62 + (v61[10] << 24);
          *((_DWORD *)v35 + 24) = v63;
LABEL_23:
          v63 += v61[9] << 16;
          *((_DWORD *)v35 + 24) = v63;
LABEL_24:
          v63 += v61[8] << 8;
          *((_DWORD *)v35 + 24) = v63;
LABEL_25:
          v41 += v61[7] << 24;
LABEL_26:
          v41 += v61[6] << 16;
LABEL_27:
          v41 += v61[5] << 8;
LABEL_28:
          v41 += v61[4];
LABEL_29:
          v47 += v61[3] << 24;
LABEL_30:
          v47 += v61[2] << 16;
LABEL_31:
          v47 += v61[1] << 8;
LABEL_32:
          v47 += *v61;
          break;
        default:
          break;
      }
      v64 = (v47 - v41 - v63) ^ (v63 >> 13);
      v65 = (v41 - v63 - v64) ^ (v64 << 8);
      v66 = (v63 - v64 - v65) ^ (v65 >> 13);
      v67 = (v64 - v65 - v66) ^ (v66 >> 12);
      v68 = (v65 - v66 - v67) ^ (v67 << 16);
      v69 = (v66 - v67 - v68) ^ (v68 >> 5);
      v70 = (v67 - v68 - v69) ^ (v69 >> 3);
      v71 = (v69 - v70 - ((v68 - v69 - v70) ^ (v70 << 10))) ^ (((v68 - v69 - v70) ^ (v70 << 10)) >> 15);
      *((_DWORD *)v35 + 24) = v71;
      v72 = 12 * (v71 & (*((_DWORD *)v42->scanwork + 1) - 1));
      ++*(_DWORD *)(*(_DWORD *)v42->scanwork + v72 + 4);
      v73 = *(_DWORD *)(*(_DWORD *)v42->scanwork + v72);
      *((_DWORD *)v35 + 20) = 0;
      *((_DWORD *)v35 + 21) = v73;
      v74 = v42->scanwork;
      v75 = *(_DWORD *)(*(_DWORD *)v74 + v72);
      if ( v75 )
      {
        *(_DWORD *)(v75 + 12) = v347;
        v74 = v42->scanwork;
      }
      *(_DWORD *)(*(_DWORD *)v74 + v72) = v347;
      v76 = *(_QWORD *)(v72 + *(_DWORD *)v42->scanwork + 4);
      if ( (unsigned int)v76 < 10 * HIDWORD(v76) + 10 || (v77 = *((_DWORD *)v35 + 17), *(_DWORD *)(v77 + 36) == 1) )
      {
LABEL_37:
        strcpy(current_hash, v35);
        scan_devices.next = &scan_devices;
        scan_devices.prev = &scan_devices;
        opt_register_table(opt_config_table, "Options for both config file and command line");
        opt_register_table(opt_cmdline_table, "Options for command line only");
        opt_parse(&argca, argva, (void (*)(const char *, ...))applog_and_exit);
        if ( argca != 1 )
        {
          strcpy(str, "Unexpected extra commandline arguments");
          applog(3, str, 1);
          _quit(1, 0);
        }
        v78 = (char *)*((unsigned __int8 *)v351 + 856);
        if ( !*((_BYTE *)v351 + 856) )
        {
          v170 = (char *)malloc(0x1000u);
          v171 = v351;
          v351[215] = v170;
          default_save_file(v170);
          if ( access(v171[215], 4) )
          {
            v172 = v351;
            free(v351[215]);
            v172[215] = v78;
          }
          else
          {
            load_config(v171[215], 0);
          }
        }
        if ( *((_BYTE *)v351 + 1377) || v351[269] )
        {
          if ( opt_scrypt )
          {
            strcpy(str, "Cannot use benchmark mode with scrypt");
            applog(3, str, 1);
            _quit(1, 1);
          }
          v79 = add_pool();
          v80 = (char *)malloc(0xFFu);
          v81 = v351;
          v79->rpc_url = v80;
          if ( v81[269] )
            strcpy(v80, "Benchfile");
          else
            strcpy(v80, "Benchmark");
          rpc_url = v79->rpc_url;
          v79->rpc_user = rpc_url;
          v79->rpc_pass = rpc_url;
          v79->rpc_userpass = rpc_url;
          v79->sockaddr_url = rpc_url;
          strncpy(v79->diff, "?", 7u);
          enabled = v79->enabled;
          v79->diff[7] = 0;
          if ( enabled != pool_enable::POOL_ENABLED )
            enable_pool((pool *)&v79->enabled);
          v84 = bench_hidiff_bins[0];
          v85 = 0;
          v79->idle = 0;
          v86 = bench_lodiff_bins[0];
          successful_connect = 1;
          do
          {
            v87 = v84;
            v84 += 160;
            hex2bin(v87, &bench_hidiffs[v85], 0xA0u);
            v88 = &bench_lodiffs[v85];
            v85 += 324;
            hex2bin(v86, v88, 0xA0u);
            v86 += 160;
          }
          while ( v85 != 5184 );
          set_target(bench_target, v89);
        }
        v90 = v351[4];
        if ( !v90 )
          goto LABEL_65;
        v91 = fopen(v90, "rb");
        memset(s, 0, sizeof(s));
        if ( v91 )
        {
          v92 = fread(s, 1u, 0x100u, v91);
          if ( v92 <= 0 )
          {
            v95 = &use_syslog;
            if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
              goto LABEL_196;
            snprintf(str, 0x1000u, "Read miner version file %s error %d", v351[4], v92);
            applog(3, str, 0);
          }
          else
          {
            v93 = strchr(s, 10);
            v94 = v93;
            if ( v93 )
            {
              memcpy(g_miner_compiletime, s, v93 - s);
              strcpy(g_miner_type, v94 + 1);
            }
            else
            {
              strcpy(g_miner_compiletime, s);
            }
            LOWORD(v95) = 8008;
            v96 = &v350[strlen(g_miner_compiletime) - 1];
            if ( v96[2676] == 10 )
              v96[2676] = 0;
            v97 = &v350[strlen(g_miner_compiletime) - 1];
            if ( v97[2676] == 13 )
              v97[2676] = 0;
            v98 = &v350[strlen(g_miner_type) - 1];
            if ( v98[2932] == 10 )
              v98[2932] = 0;
            v99 = &v350[strlen(g_miner_type) - 1];
            HIWORD(v95) = 7;
            if ( v99[2932] == 13 )
              v99[2932] = 0;
          }
        }
        else
        {
          v95 = &use_syslog;
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
            goto LABEL_196;
          snprintf(str, 0x1000u, "Open miner version file %s error", v351[4]);
          applog(3, str, 0);
        }
        if ( *v95 || opt_log_output )
          goto LABEL_64;
LABEL_196:
        if ( opt_log_level > 2 )
        {
LABEL_64:
          snprintf(str, 0x1000u, "Miner compile time: %s type: %s", g_miner_compiletime, g_miner_type);
          applog(3, str, 0);
        }
LABEL_65:
        v100 = v351;
        v101 = *v351;
        if ( *v351 )
        {
          LOBYTE(drv->drv_id) = 1;
          strcpy(g_logfile_path, v101);
          v102 = v100[3];
          if ( v102 )
            strcpy(g_logfile_openflag, v102);
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
          {
            v103 = v351[2];
            if ( !v103 )
            {
LABEL_178:
              if ( opt_log_level <= 3 )
              {
LABEL_103:
                v118 = v351[215];
                if ( !v118 )
                  goto LABEL_116;
                if ( opt_debug )
                {
                  if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
                  {
                    v119 = v351[267];
                    if ( v119 != (char *)-1 )
                    {
LABEL_109:
                      if ( !v119 )
                      {
                        if ( (use_syslog || opt_log_output || opt_log_level > 3)
                          && ((strcpy(str, "Fatal JSON error in configuration file."), applog(4, str, 0), use_syslog)
                           || opt_log_output)
                          || opt_log_level > 3 )
                        {
                          strcpy(str, "Configuration file could not be used.");
                          applog(4, str, 0);
                        }
                      }
                      goto LABEL_115;
                    }
LABEL_187:
                    if ( !opt_log_output && opt_log_level <= 3 )
                    {
                      if ( !use_curses )
                        goto LABEL_115;
                      goto LABEL_190;
                    }
LABEL_208:
                    strcpy(str, "Error in configuration file, partially loaded.");
                    applog(4, str, 0);
                    if ( !use_curses )
                      goto LABEL_115;
                    if ( use_syslog || opt_log_output )
                      goto LABEL_191;
LABEL_190:
                    if ( opt_log_level > 3 )
                    {
LABEL_191:
                      strcpy(str, "Start cgminer with -T to see what failed to load.");
                      applog(4, str, 0);
                    }
LABEL_115:
                    v120 = v351;
                    free(v351[215]);
                    v120[215] = 0;
LABEL_116:
                    *(_WORD *)(v343->drv_id + strlen((const char *)v343->drv_id)) = *(_WORD *)HIDWORD(v345);
                    if ( want_per_device_stats )
                      opt_log_output = 1;
                    v332 = &global_quota_gcd;
                    if ( opt_scantime < 0 )
                    {
                      if ( opt_scrypt )
                        v121 = 30;
                      else
                        v121 = 60;
                      v332[504] = v121;
                    }
                    *((_DWORD *)v350 + 930) = 8;
                    v122 = (thr_info *)calloc(8u, 0x40u);
                    v330 = &control_thr;
                    control_thr = v122;
                    if ( v122 )
                    {
                      argva = (char **)&modminer_drv;
                      fill_device_drv(&bitforce_drv);
                      v331 = argva;
                      fill_device_drv((device_drv *)argva);
                      fill_device_drv(&bitmain_drv);
                      fill_device_drv(&bitmain_c5_drv);
                      fill_device_drv(&bitmainZCASH_drv);
                      drv = (device_drv *)(unsigned __int16)&avalon4_drv;
                      argva = (char **)(unsigned __int16)&avalon2_drv;
                      fill_device_drv(&bmsc_drv);
                      LOWORD(v123) = (_WORD)argva;
                      HIWORD(v123) = (unsigned int)&avalon2_drv >> 16;
                      argva = v123;
                      fill_device_drv(&avalon_drv);
                      LOWORD(v124) = (_WORD)drv;
                      HIDWORD(v345) = (unsigned __int16)&bitfury_drv;
                      HIWORD(v124) = (unsigned int)&avalon4_drv >> 16;
                      v347 = (device_drv *)(unsigned __int16)&bflsc_drv;
                      drv = v124;
                      fill_device_drv((device_drv *)argva);
                      LOWORD(v125) = (_WORD)v347;
                      HIWORD(v125) = (unsigned int)&bflsc_drv >> 16;
                      v347 = v125;
                      fill_device_drv(drv);
                      LOWORD(v126) = WORD2(v345);
                      v344 = (device_drv *)(unsigned __int16)&cointerra_drv;
                      LODWORD(v345) = (unsigned __int16)&blockerupter_drv;
                      HIWORD(v126) = (unsigned int)&bitfury_drv >> 16;
                      HIDWORD(v345) = v126;
                      fill_device_drv(v347);
                      LOWORD(v127) = v345;
                      HIWORD(v127) = (unsigned int)&blockerupter_drv >> 16;
                      LODWORD(v345) = v127;
                      fill_device_drv((device_drv *)HIDWORD(v345));
                      LOWORD(v128) = (_WORD)v344;
                      v343 = (device_drv *)(unsigned __int16)&hashfast_drv;
                      v342 = (device_drv *)(unsigned __int16)&hashratio_drv;
                      HIWORD(v128) = (unsigned int)&cointerra_drv >> 16;
                      v344 = v128;
                      fill_device_drv((device_drv *)v345);
                      LOWORD(v129) = (_WORD)v343;
                      HIWORD(v129) = (unsigned int)&hashfast_drv >> 16;
                      v343 = v129;
                      fill_device_drv(v344);
                      LOWORD(v130) = (_WORD)v342;
                      v341 = (device_drv *)(unsigned __int16)&icarus_drv;
                      HIWORD(v130) = (unsigned int)&hashratio_drv >> 16;
                      v340 = (device_drv *)(unsigned __int16)&klondike_drv;
                      v342 = v130;
                      fill_device_drv(v343);
                      LOWORD(v131) = (_WORD)v341;
                      HIWORD(v131) = (unsigned int)&icarus_drv >> 16;
                      v341 = v131;
                      fill_device_drv(v342);
                      LOWORD(v132) = (_WORD)v340;
                      HIWORD(v132) = (unsigned int)&klondike_drv >> 16;
                      v340 = v132;
                      v339 = (device_drv *)(unsigned __int16)&knc_drv;
                      v338 = (device_drv *)(unsigned __int16)&bitmineA1_drv;
                      fill_device_drv(v341);
                      LOWORD(v133) = (_WORD)v339;
                      HIWORD(v133) = (unsigned int)&knc_drv >> 16;
                      v339 = v133;
                      fill_device_drv(v340);
                      LOWORD(v134) = (_WORD)v338;
                      HIWORD(v134) = (unsigned int)&bitmineA1_drv >> 16;
                      v338 = v134;
                      v337 = (device_drv *)(unsigned __int16)&drillbit_drv;
                      v336 = (device_drv *)(unsigned __int16)&bab_drv;
                      fill_device_drv(v339);
                      LOWORD(v135) = (_WORD)v337;
                      HIWORD(v135) = (unsigned int)&drillbit_drv >> 16;
                      v337 = v135;
                      fill_device_drv(v338);
                      LOWORD(v136) = (_WORD)v336;
                      HIWORD(v136) = (unsigned int)&bab_drv >> 16;
                      v336 = v136;
                      v335 = (device_drv *)(unsigned __int16)&minion_drv;
                      v334 = (device_drv *)(unsigned __int16)&sp10_drv;
                      fill_device_drv(v337);
                      LOWORD(v137) = (_WORD)v335;
                      HIWORD(v137) = (unsigned int)&minion_drv >> 16;
                      v335 = v137;
                      fill_device_drv(v336);
                      LOWORD(v138) = (_WORD)v334;
                      HIWORD(v138) = (unsigned int)&sp10_drv >> 16;
                      v334 = v138;
                      v333 = (size_t *)(unsigned __int16)&mining_threads;
                      fill_device_drv(v335);
                      fill_device_drv(v334);
                      LOWORD(v139) = (_WORD)v333;
                      HIWORD(v139) = (unsigned int)&mining_threads >> 16;
                      v333 = v139;
                      fill_device_drv(&sp30_drv);
                      (*(void (__fastcall **)(_DWORD))(v140 + 12))(0);
                      ((void (__fastcall *)(_DWORD))v331[3])(0);
                      bitmain_drv.drv_detect(0);
                      bitmain_c5_drv.drv_detect(0);
                      ((void (__fastcall *)())bitmainZCASH_drv.drv_detect)();
                      bmsc_drv.drv_detect(0);
                      avalon_drv.drv_detect(0);
                      v141 = 0;
                      CONTAINING_RECORD(argva, device_drv, dname)->reinit_device(0);
                      drv->drv_detect(0);
                      v347->drv_detect(0);
                      (*(void (__fastcall **)(_DWORD))(HIDWORD(v345) + offsetof(device_drv, drv_detect)))(0);
                      (*(void (__fastcall **)(_DWORD))(v345 + offsetof(device_drv, drv_detect)))(0);
                      v344->drv_detect(0);
                      v343->drv_detect(0);
                      v342->drv_detect(0);
                      v341->drv_detect(0);
                      v340->drv_detect(0);
                      v339->drv_detect(0);
                      v338->drv_detect(0);
                      v337->drv_detect(0);
                      v336->drv_detect(0);
                      v335->drv_detect(0);
                      v334->drv_detect(0);
                      sp30_drv.drv_detect(0);
                      *v333 = 0;
                      while ( total_devices > v141 )
                      {
                        v142 = (pthread_rwlock_t *)devices[v141++];
                        enable_device(v142);
                      }
                      if ( total_devices )
                      {
                        v143 = v351[202];
                        *((_DWORD *)v350 + 659) = total_devices;
                        if ( v143 )
                        {
                          v144 = 0;
                          v145 = 0;
                          for ( i = strtok(v143, ","); i; i = strtok((char *)argva, ",") )
                          {
                            if ( total_devices <= v144 )
                            {
                              strcpy(str, "Too many values passed to set temp cutoff");
LABEL_174:
                              applog(3, str, 1);
                              _quit(1, 1);
                            }
                            v145 = strtol(i, 0, 10);
                            if ( v145 > 0xC8 )
                            {
                              v173 = "ssed to set temp cutoff";
                              qmemcpy(str, "Invalid value pa", 16);
                              v174 = &str[16];
                              goto LABEL_206;
                            }
                            if ( pthread_rwlock_rdlock(&devices_lock) )
                              rd_lock((pthread_rwlock_t *)&_func___14711, (const char *)0x479, v147, v148);
                            devices[v144]->cutofftemp = v145;
                            if ( pthread_rwlock_unlock(&devices_lock) )
                            {
                              v222 = _errno_location();
                              snprintf(
                                str,
                                0x1000u,
                                "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                                *v222,
                                "cgminer.c",
                                (const char *)&_func___14711,
                                1147);
                              goto LABEL_207;
                            }
                            ++v144;
                            argva = 0;
                            selective_yield();
                          }
                          if ( v144 > 1 )
                          {
                            drv = (device_drv *)&devices;
                            goto LABEL_232;
                          }
                          if ( pthread_rwlock_rdlock(&devices_lock) )
                            rd_lock((pthread_rwlock_t *)&_func___14711, (const char *)0x48C, v223, v224);
                          v225 = total_devices;
                          drv = (device_drv *)&devices;
                          v226 = devices;
                          while ( v144 < v225 )
                          {
                            v227 = v226[v144++];
                            v227->cutofftemp = v145;
                          }
                          if ( pthread_rwlock_unlock(&devices_lock) )
                            rw_unlock((pthread_rwlock_t *)&_func___14711, (const char *)0x48F, v228, v229);
                        }
                        else
                        {
                          v186 = pthread_rwlock_rdlock(&devices_lock);
                          if ( v186 )
                            rd_lock((pthread_rwlock_t *)&_func___14711, (const char *)0x480, v187, v188);
                          v189 = total_devices;
                          drv = (device_drv *)&devices;
                          v190 = devices;
                          while ( v186 < v189 )
                          {
                            v191 = v190[v186];
                            if ( !v191->cutofftemp )
                              v191->cutofftemp = 95;
                            ++v186;
                          }
                          if ( pthread_rwlock_unlock(&devices_lock) )
                            rw_unlock((pthread_rwlock_t *)&_func___14711, (const char *)0x486, v192, v193);
                        }
                        selective_yield();
LABEL_232:
                        v194 = total_devices;
                        drv_id = drv->drv_id;
                        for ( j = 0; v194 > j; ++j )
                        {
                          v197 = *(_DWORD *)(drv_id + 4 * j);
                          *(_DWORD *)(v197 + 312) = 99999999;
                        }
                        if ( !opt_compact )
                          *((_DWORD *)v350 + 660) += *((_DWORD *)v350 + 659);
                        if ( !total_pools )
                        {
                          if ( use_syslog || opt_log_output || opt_log_level > 3 )
                          {
                            strcpy(str, "Need to specify at least one pool server.");
                            applog(4, str, 0);
                          }
                          strcpy(str, "Pool setup failed");
                          applog(3, str, 1);
                          _quit(1, 0);
                        }
                        v198 = 0;
                        argva = (char **)&pools;
                        v347 = (device_drv *)"%s:%s";
                        while ( 1 )
                        {
                          v199 = *argva;
                          if ( total_pools <= v198 )
                            break;
                          v200 = *(_DWORD *)&v199[4 * v198];
                          v201 = *(_DWORD *)(v200 + 200);
                          *(_DWORD *)(v200 + 428) = 99999999;
                          *(_DWORD *)(v200 + 464) = 99999999;
                          if ( !v201 )
                          {
                            if ( !*(_DWORD *)(v200 + 208) )
                              *(_DWORD *)(v200 + 208) = calloc(1u, 1u);
                            if ( !*(_DWORD *)(v200 + 204) )
                            {
                              snprintf(
                                str,
                                0x1000u,
                                "No login credentials supplied for pool %u %s",
                                v198,
                                *(const char **)(v200 + 196));
                              applog(3, str, 1);
                              _quit(1, 0);
                            }
                            LODWORD(v345) = *(_DWORD *)(v200 + 204);
                            v202 = strlen((const char *)v345);
                            HIDWORD(v345) = *(_DWORD *)(v200 + 208);
                            v203 = v202 + strlen((const char *)HIDWORD(v345)) + 2;
                            v204 = (char *)malloc(v203);
                            v205 = v345;
                            *(_DWORD *)(v200 + 200) = v204;
                            if ( !v204 )
                            {
                              strcpy(str, "Failed to malloc userpass");
                              goto LABEL_169;
                            }
                            snprintf(v204, v203, (const char *)v347, (_DWORD)v205, HIDWORD(v205));
                          }
                          ++v198;
                        }
                        v206 = use_syslog;
                        v351[319] = *(char **)v199;
                        if ( v206 )
                          openlog("cgminer", 1, 8);
                        if ( *((_DWORD *)v350 + 931) )
                        {
                          if ( pipe((int *)str) < 0 )
                          {
                            perror("pipe - failed to create pipe for --monitor");
                            exit(1);
                          }
                          fflush((FILE *)stderr);
                          if ( dup2(*(int *)&str[4], 2) < 0 )
                          {
                            perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                            exit(1);
                          }
                          if ( close(*(int *)&str[4]) < 0 )
                          {
                            perror("close - failed to close write end of pipe for --monitor");
                            exit(1);
                          }
                          v207 = signal(13, (__sighandler_t)1);
                          v208 = signal(13, (__sighandler_t)1);
                          if ( v207 == (__sighandler_t)-1 || v208 == (__sighandler_t)-1 )
                          {
                            perror("signal - failed to edit signal mask for --monitor");
                            exit(1);
                          }
                          v209 = fork();
                          v210 = v209;
                          v351[209] = (char *)v209;
                          if ( v209 < 0 )
                          {
                            perror("fork - failed to fork child process for --monitor");
                            exit(1);
                          }
                          if ( !v209 )
                          {
                            if ( dup2(*(int *)str, v209) >= 0 )
                            {
                              close(*(int *)str);
                              execl("/bin/bash", "/bin/bash", "-c", *((_DWORD *)v350 + 931), v210);
                              perror("execl - in child failed to exec user specified command for --monitor");
                              exit(1);
                            }
                            perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                            exit(1);
                          }
                          if ( close(*(int *)str) < 0 )
                          {
                            perror("close - failed to close read end of pipe for --monitor");
                            exit(1);
                          }
                        }
                        v211 = (thr_info **)calloc(*v333, 4u);
                        LODWORD(v345) = &mining_thr;
                        mining_thr = v211;
                        if ( !v211 )
                        {
                          strcpy(str, "Failed to calloc mining_thr");
LABEL_277:
                          applog(3, str, 1);
                          _quit(1, 0);
                        }
                        v212 = (int *)v345;
                        for ( k = 0; (int)*v333 > k; ++k )
                        {
                          v214 = *v212;
                          *(_DWORD *)(v214 + 4 * k) = calloc(1u, 0x40u);
                          if ( !*(_DWORD *)(*v212 + 4 * k) )
                          {
                            snprintf(str, 0x1000u, "Failed to calloc mining_thr[%d]", k);
                            goto LABEL_277;
                          }
                        }
                        v347 = 0;
                        HIDWORD(v345) = 0;
                        v344 = (device_drv *)miner_thread;
                        v343 = (device_drv *)&opt_debug;
                        while ( total_devices > (int)v347 )
                        {
                          v215 = 0;
                          v216 = *(cgpu_info **)(drv->drv_id + 4 * (_DWORD)v347);
                          v217 = v216->threads + 1;
                          v218 = (thr_info **)malloc(v217 * 4);
                          v216->thr = v218;
                          v218[v217 - 1] = 0;
                          v216->status = alive::LIFE_INIT;
                          while ( v216->threads > v215 )
                          {
                            v342 = (device_drv *)(HIDWORD(v345) + v215);
                            thread = get_thread(HIDWORD(v345) + v215);
                            v220 = v342;
                            v221 = thread;
                            thread->cgpu = v216;
                            thread->device_thread = v215;
                            thread->id = (int)v220;
                            if ( ((int (*)(void))v216->drv->thread_prepare)() )
                            {
                              if ( thr_info_create(v221, 0, (void *(*)(void *))v344, v221) )
                              {
                                snprintf(str, 0x1000u, "thread %d create failed", v221->id);
                                applog(3, str, 1);
                                _quit(1, 0);
                              }
                              v216->thr[v215] = v221;
                              if ( v216->deven != dev_enable::DEV_DISABLED )
                              {
                                if ( LOBYTE(v343->drv_id) && (use_syslog || opt_log_output || opt_log_level > 6) )
                                {
                                  snprintf(str, 0x1000u, "Pushing sem post to thread %d", v221->id);
                                  applog(7, str, 0);
                                }
                                cgsem_post(&v221->sem, "cgminer.c", &_func___17121.__size[28], 11098);
                              }
                            }
                            ++v215;
                          }
                          HIDWORD(v345) += v215;
                          v347 = (device_drv *)((char *)v347 + 1);
                        }
                        if ( !*((_BYTE *)v351 + 1377) )
                        {
                          v235 = (int)v351[269];
                          if ( !v235 )
                          {
                            while ( total_pools > v235 )
                            {
                              v236 = *(_DWORD *)&(*argva)[4 * v235];
                              if ( *(_DWORD *)(v236 + 132) != 1 )
                                enable_pool((pool *)(v236 + 132));
                              ++v235;
                              *(_BYTE *)(v236 + 129) = 1;
                            }
                            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                            {
                              strcpy(str, "Probing for an alive pool");
                              applog(7, str, 0);
                            }
                            for ( m = 0; m < total_pools; ++m )
                            {
                              v238 = *(_DWORD *)&(*argva)[4 * m];
                              *(_BYTE *)(v238 + 316) = 1;
                              pthread_create((pthread_t *)(v238 + 312), 0, test_pool_thread, (void *)v238);
                            }
                            v243 = 0;
                            do
                            {
                              ++v243;
                              sleep(1u);
                              if ( v243 == 60 )
                                v244 = 0;
                              else
                                v244 = (*((_BYTE *)v351 + 1376) ^ 1) & 1;
                            }
                            while ( v244 );
                            v245 = &opt_log_level;
                            v344 = (device_drv *)"Pool: %d  URL: %s  User: %s  Password: %s";
                            v347 = (device_drv *)&use_curses;
                            while ( 1 )
                            {
                              if ( *((_BYTE *)v351 + 1376) )
                                goto begin_bench;
                              if ( v244 )
                                goto LABEL_340;
                              if ( ((use_syslog || opt_log_output || *v245 > 2)
                                 && ((strcpy(str, "No servers were found that could be used to get work from."),
                                      applog(3, str, 0),
                                      use_syslog)
                                  || opt_log_output)
                                 || *v245 > 2)
                                && ((strcpy(
                                       str,
                                       "Please check the details from the list below of the servers you have input"),
                                     applog(3, str, 0),
                                     use_syslog)
                                 || opt_log_output)
                                || *v245 > 2 )
                              {
                                strcpy(
                                  str,
                                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                                applog(3, str, 0);
                              }
                              v323 = 0;
                              HIDWORD(v345) = v245;
                              while ( total_pools > v323 )
                              {
                                if ( use_syslog || opt_log_output || (int)*(_DWORD *)HIDWORD(v345) > 3 )
                                {
                                  snprintf(
                                    str,
                                    0x1000u,
                                    (const char *)v344,
                                    v323,
                                    *(_DWORD *)(*(_DWORD *)&(*argva)[4 * v323] + 196),
                                    *(_DWORD *)(*(_DWORD *)&(*argva)[4 * v323] + 204),
                                    *(_DWORD *)(*(_DWORD *)&(*argva)[4 * v323] + 208));
                                  applog(4, str, 0);
                                }
                                ++v323;
                              }
                              v245 = (int *)HIDWORD(v345);
                              if ( !LOBYTE(v347->drv_id) )
                              {
LABEL_489:
                                strcpy(str, "No servers could be used! Exiting.");
                                applog(3, str, 1);
                                _quit(0, 0);
                              }
                              if ( use_syslog || opt_log_output || (int)*(_DWORD *)HIDWORD(v345) > 2 )
                                break;
LABEL_341:
                              v244 = 1;
                            }
                            strcpy(str, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                            applog(3, str, 0);
LABEL_340:
                            if ( !LOBYTE(v347->drv_id) )
                              goto LABEL_489;
                            goto LABEL_341;
                          }
                        }
begin_bench:
                        v230 = (int *)g_local_mhashes_dones;
                        total_mhashes_done = 0.0;
                        do
                        {
                          *(_QWORD *)v230 = 0;
                          v230 += 2;
                        }
                        while ( &g_local_mhashes_index != v230 );
                        v231 = total_devices;
                        v232 = (int)v346;
                        v233 = drv->drv_id;
                        v351[304] = 0;
                        while ( v231 > v232 )
                        {
                          v234 = *(_DWORD *)(v233 + 4 * v232++);
                          *(_QWORD *)(v234 + 80) = 0;
                          *(_QWORD *)(v234 + 48) = 0;
                        }
                        cgtime(&total_tv_start);
                        cgtime(&total_tv_end);
                        cgtime(&tv_hashmeter);
                        get_datestamp(datestamp, 0x28u, &total_tv_start);
                        v239 = *v330;
                        v351[317] = (char *)2;
                        if ( thr_info_create(v239 + 2, 0, (void *(*)(void *))watchpool_thread, 0) )
                        {
                          strcpy(str, "watchpool thread create failed");
                          applog(3, str, 1);
                          _quit(1, 0);
                        }
                        pthread_detach(v239[2].pth);
                        v240 = *v330;
                        v351[318] = (char *)3;
                        if ( thr_info_create(v240 + 3, 0, (void *(*)(void *))watchdog_thread, 0) )
                        {
                          strcpy(str, "watchdog thread create failed");
                          applog(3, str, 1);
                          _quit(1, 0);
                        }
                        pthread_detach(v240[3].pth);
                        v241 = *v330;
                        v351[200] = (char *)5;
                        if ( thr_info_create(v241 + 5, 0, api_thread, &v241[5]) )
                        {
                          strcpy(str, "API thread create failed");
                          applog(3, str, 1);
                          _quit(1, 0);
                        }
                        v242 = *((_DWORD *)v350 + 930);
                        if ( v242 != 8 )
                        {
                          snprintf(str, 0x1000u, "incorrect total_control_threads (%d) should be 8", v242);
LABEL_169:
                          applog(3, str, 1);
                          _quit(1, 0);
                        }
                        if ( !nice(-10) && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          strcpy(str, "Unable to set thread to high priority");
                          applog(7, str, 0);
                        }
                        v246 = v350;
                        v247 = 0;
                        v350 = &use_syslog;
                        HIDWORD(v345) = &opt_work_update;
                        drv = (device_drv *)&opt_debug;
                        v346 = &opt_fail_only;
                        while ( 1 )
                        {
                          while ( 1 )
                          {
                            v248 = v332[502];
                            if ( *(_BYTE *)HIDWORD(v345) )
                            {
                              if ( LOBYTE(drv->drv_id) && (*v350 || opt_log_output || opt_log_level > 6) )
                              {
                                strcpy(str, "Work update message received");
                                applog(7, str, 0);
                              }
                              cgtime(&update_tv_start);
                              v317 = pthread_rwlock_rdlock(&mining_thr_lock);
                              if ( v317 )
                              {
                                v321 = _errno_location();
                                snprintf(
                                  str,
                                  0x1000u,
                                  "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                                  *v321,
                                  "cgminer.c",
                                  &_func___14711.__align + 5,
                                  5314);
                                goto LABEL_207;
                              }
                              v318 = *v333;
                              v319 = *(_DWORD *)v345;
                              while ( v317 < v318 )
                              {
                                v320 = *(_DWORD *)(v319 + 4 * v317++);
                                *(_BYTE *)(v320 + 63) = 1;
                              }
                              if ( pthread_rwlock_unlock(&mining_thr_lock) )
                              {
                                v322 = _errno_location();
                                snprintf(
                                  str,
                                  0x1000u,
                                  "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                                  *v322,
                                  "cgminer.c",
                                  &_func___14711.__align + 5,
                                  5317);
LABEL_207:
                                applog(3, str, 1);
                                _quit(1, 1);
                              }
                              selective_yield();
                            }
                            *(_BYTE *)HIDWORD(v345) = 0;
                            current_pool();
                            if ( pthread_mutex_lock((pthread_mutex_t *)v351[273]) )
                            {
                              v314 = _errno_location();
                              v315 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
                              v316 = 11235;
LABEL_474:
                              snprintf(str, 0x1000u, v315, *v314, "cgminer.c", &_func___17121.__align + 7, v316);
                              goto LABEL_207;
                            }
                            v249 = v351[324];
                            if ( v249 )
                              v249 = *(char **)(*((_DWORD *)v249 + 458) + 12);
                            v250 = v351;
                            v251 = (pthread_mutex_t *)v351[273];
                            if ( v248 < (int)v249 )
                              break;
                            if ( pthread_mutex_unlock((pthread_mutex_t *)v351[273]) )
                              goto LABEL_513;
                            selective_yield();
LABEL_368:
                            if ( v247 )
                              discard_work((work *)v247);
                            work = (device_drv *)make_work();
                            v259 = current_pool();
                            v260 = v259;
                            v261 = v351[201];
                            if ( v261 == (char *)4 )
                            {
                              v262 = select_balanced(v259);
                            }
                            else if ( v261 == (char *)3 )
                            {
                              v302 = 0;
                              v303 = total_pools;
                              v304 = *argva;
                              while ( v302 < total_pools )
                              {
                                v305 = *(_QWORD *)(*(_DWORD *)&v304[4 * v302] + 60);
                                if ( SHIDWORD(v305) < (int)v305 )
                                  goto LABEL_449;
                                ++v302;
                              }
                              for ( n = 0; v303 > n; ++n )
                              {
                                v325 = *(_DWORD *)&v304[4 * n];
                                *(_DWORD *)(v325 + 64) = 0;
                              }
                              v306 = *((_DWORD *)v246 + 932) + 1;
                              *((_DWORD *)v246 + 932) = v306;
                              if ( v303 <= v306 )
                                *((_DWORD *)v246 + 932) = 0;
LABEL_449:
                              for ( ii = 0; ; ii = v308 )
                              {
                                v308 = ii + 1;
                                if ( ii >= total_pools )
                                  break;
                                v262 = *(pool **)&(*argva)[4 * *((_DWORD *)v246 + 932)];
                                v309 = *(_QWORD *)&v262->quota_gcd;
                                v262->quota_used = HIDWORD(v309) + 1;
                                if ( SHIDWORD(v309) < (int)v309 )
                                {
                                  if ( !v262->idle
                                    && v262->enabled == pool_enable::POOL_ENABLED
                                    && (!v262->has_stratum || v262->stratum_active) )
                                  {
                                    goto LABEL_373;
                                  }
                                  if ( *v346 )
                                  {
                                    v310 = priority_pool(0);
                                    --v310->quota_used;
                                  }
                                }
                                v311 = *((_DWORD *)v246 + 932) + 1;
                                v163 = v311 < total_pools;
                                *((_DWORD *)v246 + 932) = v311;
                                if ( !v163 )
                                  *((_DWORD *)v246 + 932) = 0;
                              }
                              for ( jj = 0; ; ++jj )
                              {
                                if ( jj >= total_pools )
                                  goto LABEL_372;
                                v313 = priority_pool(jj);
                                if ( !v313->idle && v313->enabled == pool_enable::POOL_ENABLED )
                                  break;
                              }
                              v262 = v313;
                            }
                            else
                            {
LABEL_372:
                              v262 = v260;
                            }
LABEL_373:
                            if ( LOBYTE(drv->drv_id) && (*v350 || opt_log_output || opt_log_level > 6) )
                            {
                              snprintf(str, 0x1000u, "Selecting pool %d for work", v262->pool_no);
                              applog(7, str, 0);
                              v347 = work;
                            }
                            else
                            {
                              v347 = work;
                            }
LABEL_378:
                            if ( v262->has_stratum )
                            {
                              while ( !v262->stratum_active || !v262->stratum_notify )
                              {
                                v263 = current_pool();
                                v264 = v263;
                                v265 = v351[201];
                                if ( v265 == (char *)4 )
                                {
                                  v266 = select_balanced(v263);
                                }
                                else if ( v265 == (char *)3 || !*v346 )
                                {
                                  v267 = 0;
                                  v268 = total_pools;
                                  v269 = *argva;
                                  while ( v267 < total_pools )
                                  {
                                    v270 = *(_QWORD *)(*(_DWORD *)&v269[4 * v267] + 60);
                                    if ( SHIDWORD(v270) < (int)v270 )
                                      goto LABEL_401;
                                    ++v267;
                                  }
                                  for ( kk = 0; v268 > kk; ++kk )
                                  {
                                    v272 = *(_DWORD *)&v269[4 * kk];
                                    *(_DWORD *)(v272 + 64) = 0;
                                  }
                                  v273 = *((_DWORD *)v246 + 932) + 1;
                                  *((_DWORD *)v246 + 932) = v273;
                                  if ( v268 <= v273 )
                                    *((_DWORD *)v246 + 932) = 0;
LABEL_401:
                                  v274 = v262;
                                  for ( mm = 0; mm < total_pools; ++mm )
                                  {
                                    v276 = *(_DWORD *)&(*argva)[4 * *((_DWORD *)v246 + 932)];
                                    v277 = *(_QWORD *)(v276 + 60);
                                    *(_DWORD *)(v276 + 64) = HIDWORD(v277) + 1;
                                    if ( SHIDWORD(v277) < (int)v277 )
                                    {
                                      if ( !*(_BYTE *)(v276 + 129)
                                        && *(_DWORD *)(v276 + 132) == 1
                                        && (!*(_BYTE *)(v276 + 664) || *(_BYTE *)(v276 + 665)) )
                                      {
                                        v262 = v274;
                                        v266 = (pool *)v276;
                                        goto LABEL_385;
                                      }
                                      if ( *v346 )
                                      {
                                        v301 = priority_pool(0);
                                        --v301->quota_used;
                                      }
                                    }
                                    v278 = *((_DWORD *)v246 + 932) + 1;
                                    v163 = v278 < total_pools;
                                    *((_DWORD *)v246 + 932) = v278;
                                    if ( !v163 )
                                      *((_DWORD *)v246 + 932) = 0;
                                  }
                                  for ( nn = 0; nn < total_pools; ++nn )
                                  {
                                    v300 = priority_pool(nn);
                                    if ( !v300->idle && v300->enabled == pool_enable::POOL_ENABLED )
                                    {
                                      v262 = v274;
                                      v266 = v300;
                                      goto LABEL_385;
                                    }
                                  }
                                  v262 = v274;
                                  v266 = v264;
                                }
                                else
                                {
                                  v266 = v263;
                                }
LABEL_385:
                                if ( LOBYTE(drv->drv_id) && (*v350 || opt_log_output || opt_log_level > 6) )
                                {
                                  snprintf(str, 0x1000u, "Selecting pool %d for work", v266->pool_no);
                                  applog(7, str, 0);
                                }
                                cgsleep_ms(5000);
                                if ( v262 != v266 )
                                {
                                  v262 = v266;
                                  goto LABEL_378;
                                }
                              }
                              v247 = v347;
                              gen_stratum_work(v262, (work *)v347);
                              if ( LOBYTE(drv->drv_id) && (*v350 || opt_log_output || opt_log_level > 6) )
                              {
                                strcpy(str, "Generated stratum work");
                                applog(7, str, 0);
                              }
                              goto LABEL_420;
                            }
                            v247 = v347;
                            if ( v351[269] )
                            {
                              benchfile_get_work((work *)v347);
                              v297 = argva;
                              BYTE2(v247[13].max_diff) = 1;
                              v247[13].hw_error = *(void (**)(thr_info *))*v297;
                              cgtime((timeval *)&v247[14].zero_stats);
                              copy_time((timeval *)&v247[14].max_diff, (const timeval *)&v247[14].zero_stats);
                              HIDWORD(v298) = 66;
                              LOBYTE(v247[15].name) = 66;
                              calc_diff((work *)v247, v298);
                              if ( LOBYTE(drv->drv_id) && (*v350 || opt_log_output || opt_log_level > 6) )
                              {
                                v288 = "Generated benchfile work";
                                goto LABEL_419;
                              }
LABEL_420:
                              v296 = (work *)v247;
                              v247 = 0;
                              stage_work(v296);
                            }
                            else if ( *((_BYTE *)v351 + 1377) )
                            {
                              *(_QWORD *)&v347[14].queue_full = 0x4040000000000000LL;
                              v279 = argva;
                              v247[13].scanwork = 0;
                              BYTE2(v247[13].max_diff) = 1;
                              v347 = (device_drv *)*v279;
                              v280 = *(void (**)(cgpu_info *))&bench_target[4];
                              v281 = *(char *(**)(cgpu_info *, char *, char *, char *))&bench_target[8];
                              v282 = *(bool (**)(thr_info *))&bench_target[12];
                              v247[1].get_stats = *(bool (**)(cgpu_info *))bench_target;
                              v247[1].identify_device = v280;
                              v247[1].set_device = v281;
                              v247[1].thread_prepare = v282;
                              v283 = *(uint64_t (**)(thr_info *))&bench_target[16];
                              v284 = *(bool (**)(thr_info *))&bench_target[20];
                              v285 = *(bool (**)(thr_info *, work *))&bench_target[24];
                              v247[1].hash_work = *(void (**)(thr_info *))&bench_target[28];
                              v286 = v347;
                              v247[1].prepare_work = v285;
                              v247[1].can_limit_work = v283;
                              v247[1].thread_init = v284;
                              v247[13].hw_error = (void (*)(thr_info *))v286->drv_id;
                              cgtime((timeval *)&v247[14].zero_stats);
                              copy_time((timeval *)&v247[14].max_diff, (const timeval *)&v247[14].zero_stats);
                              v287 = drv;
                              LOBYTE(v247[15].name) = 66;
                              if ( LOBYTE(v287->drv_id) && (*v350 || opt_log_output || opt_log_level > 6) )
                              {
                                v288 = "Generated benchmark work";
LABEL_419:
                                v289 = *(_DWORD *)v288;
                                v290 = *((_DWORD *)v288 + 1);
                                v291 = *((_DWORD *)v288 + 2);
                                v292 = *((_DWORD *)v288 + 3);
                                v293 = v288 + 16;
                                *(_DWORD *)str = v289;
                                *(_DWORD *)&str[4] = v290;
                                *(_DWORD *)&str[8] = v291;
                                *(_DWORD *)&str[12] = v292;
                                v294 = v293[1];
                                v295 = v293[2];
                                *(_DWORD *)&str[16] = *v293;
                                *(_DWORD *)&str[20] = v294;
                                str[24] = v295;
                                applog(7, str, 0);
                                goto LABEL_420;
                              }
                              goto LABEL_420;
                            }
                          }
                          if ( *((_BYTE *)v351 + 1417) )
                          {
                            v252 = v332[502];
                            if ( v252 < (int)v332[503] )
                            {
                              v332[502] = v252 + 1;
                              *((_BYTE *)v250 + 1417) = 0;
                            }
                          }
                          v253 = v351;
                          *((_BYTE *)v351 + 1416) = 1;
                          pthread_cond_wait(&gws_cond, v251);
                          v254 = v253[324];
                          if ( v254 )
                            v254 = *(char **)(*((_DWORD *)v254 + 458) + 12);
                          if ( pthread_mutex_unlock((pthread_mutex_t *)v351[273]) )
                          {
LABEL_513:
                            v314 = _errno_location();
                            v315 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
                            v316 = 11253;
                            goto LABEL_474;
                          }
                          selective_yield();
                          if ( (int)v254 <= v248 )
                            goto LABEL_368;
                          if ( *((_BYTE *)v351 + 1417) )
                          {
                            v255 = v332[502];
                            v256 = v332;
                            if ( v255 < (int)v332[503] )
                            {
                              *((_BYTE *)v351 + 1417) = 0;
                              v256[502] = v255 + 1;
                            }
                          }
                          *((_BYTE *)v351 + 1416) = 1;
                          v257 = hash_pop(0);
                          v247 = (device_drv *)v257;
                          if ( v257 )
                          {
                            discard_work(v257);
                            v247 = 0;
                          }
                        }
                      }
                      qmemcpy(str, "All devices disabled, cannot mine!", 34);
                      v182 = aAllDevicesDisa[34];
                      v183 = &str[34];
                    }
                    else
                    {
                      qmemcpy(str, "Failed to calloc control_thr", 28);
                      v182 = aFailedToCalloc[28];
                      v183 = &str[28];
                    }
                    *v183 = v182;
                    applog(3, str, 1);
                    _quit(1, 0);
                  }
                  snprintf(str, 0x1000u, "Loaded configuration file %s", v118);
                  applog(7, str, 0);
                }
                v119 = v351[267];
                if ( v119 != (char *)-1 )
                  goto LABEL_109;
                if ( use_syslog )
                  goto LABEL_208;
                goto LABEL_187;
              }
LABEL_102:
              snprintf(str, 0x1000u, "Started %s", packagename);
              applog(4, str, 0);
              goto LABEL_103;
            }
LABEL_72:
            memset(s, 0, sizeof(s));
            v104 = v351[1];
            if ( v104 )
            {
              if ( !*v104 )
              {
                v173 = "Log work asic num empty";
                v174 = str;
LABEL_206:
                v175 = *(_DWORD *)v173;
                v176 = *((_DWORD *)v173 + 1);
                v177 = *((_DWORD *)v173 + 2);
                v178 = *((_DWORD *)v173 + 3);
                v179 = v173 + 16;
                *(_DWORD *)v174 = v175;
                *((_DWORD *)v174 + 1) = v176;
                *((_DWORD *)v174 + 2) = v177;
                *((_DWORD *)v174 + 3) = v178;
                v180 = v174 + 16;
                v181 = v179[1];
                *v180 = *v179;
                v180[1] = v181;
                goto LABEL_207;
              }
              v105 = strtol(v104, 0, 10);
              *((_DWORD *)v350 + 797) = v105;
              if ( ((v105 - 32) & 0xFFFFFFDF) != 0 && v105 != 1 )
              {
                strcpy(str, "Log work asic num must be 1, 32, 64");
                applog(3, str, 1);
                _quit(1, 1);
              }
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf(str, 0x1000u, "Log work path: %s Asic num: %s", v351[2], v351[1]);
                applog(3, str, 0);
              }
            }
            else if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf(str, 0x1000u, "Log work path: %s", v103);
              applog(3, str, 0);
            }
            sprintf(s, "%s.txt", v351[2]);
            v106 = fopen(s, "a+");
            v107 = use_syslog;
            *((_DWORD *)v350 + 798) = v106;
            if ( v107 || opt_log_output || opt_log_level > 2 )
            {
              snprintf(str, 0x1000u, "Log work open file %s", s);
              applog(3, str, 0);
            }
            v108 = *((_DWORD *)v350 + 797);
            if ( v108 == 1 )
            {
              sprintf(s, "%s%02d.txt", v351[2], 1);
              v184 = fopen(s, "a+");
              v185 = use_syslog;
              *((_DWORD *)v350 + 799) = v184;
              if ( v185 || opt_log_output || opt_log_level > 2 )
              {
                snprintf(str, 0x1000u, "Log work open asic %d file %s", *((_DWORD *)v350 + 797), s);
                applog(3, str, 0);
              }
            }
            else if ( ((v108 - 32) & 0xFFFFFFDF) == 0 )
            {
              argva = (char **)"a+";
              v109 = 0;
              v110 = v350;
              while ( 1 )
              {
                v113 = *((_DWORD *)v110 + 797);
                if ( v113 < v109 )
                  break;
                sprintf(s, "%s%02d_%02d.txt", v351[2], v113, v109);
                v111 = fopen(s, (const char *)argva);
                v112 = use_syslog;
                g_logwork_files[v109] = v111;
                if ( v112 || opt_log_output || opt_log_level > 2 )
                {
                  snprintf(str, 0x1000u, "Log work open asic %d file %s", *((_DWORD *)v110 + 797), s);
                  applog(3, str, 0);
                }
                ++v109;
              }
            }
            if ( v350[3456] )
            {
              v114 = &opt_logwork_diff;
              v115 = 0;
              argva = (char **)"Log work open diff file %s";
              do
              {
                sprintf(s, "%s_diff_%02d.txt", v351[2], v115);
                v116 = fopen(s, "a+");
                v117 = use_syslog;
                *((_DWORD *)v114 + 1) = v116;
                v114 += 4;
                if ( v117 || opt_log_output || opt_log_level > 2 )
                {
                  snprintf(str, 0x1000u, (const char *)argva, s);
                  applog(3, str, 0);
                }
                ++v115;
              }
              while ( v115 != 65 );
            }
LABEL_100:
            if ( use_syslog || opt_log_output )
              goto LABEL_102;
            goto LABEL_178;
          }
          snprintf(str, 0x1000u, "Log file path: %s Open flag: %s", g_logfile_path, (const char *)v345);
          applog(3, str, 0);
        }
        v103 = v351[2];
        if ( !v103 )
          goto LABEL_100;
        goto LABEL_72;
      }
      v149 = calloc(24 * *(_DWORD *)(v77 + 4), 1u);
      if ( v149 )
      {
        v150 = *(_DWORD *)(v77 + 12);
        v151 = v150 >> (*(_QWORD *)(v77 + 8) + 1);
        if ( ((2 * *(_DWORD *)(v77 + 4) - 1) & v150) != 0 )
          ++v151;
        *(_DWORD *)(v77 + 24) = v151;
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 28) = 0;
        v152 = *((_DWORD *)v35 + 17);
        if ( *(_DWORD *)(v152 + 4) )
        {
          v153 = v35;
          v347 = 0;
          do
          {
            v154 = *(_DWORD **)(*(_DWORD *)v152 + 12 * (_DWORD)v347);
            if ( v154 )
            {
              do
              {
                v155 = (_DWORD *)v154[4];
                v156 = 3 * ((2 * *(_DWORD *)(v152 + 4) - 1) & v154[7]);
                v157 = (char *)&v149[3 * ((2 * *(_DWORD *)(v152 + 4) - 1) & v154[7])];
                v158 = *((_DWORD *)v157 + 1) + 1;
                *((_DWORD *)v157 + 1) = v158;
                if ( v158 > *(_DWORD *)(v152 + 24) )
                {
                  ++*(_DWORD *)(v152 + 28);
                  *((_DWORD *)v157 + 2) = *((_DWORD *)v157 + 1) / *(_DWORD *)(*((_DWORD *)v153 + 17) + 24);
                }
                v154[3] = 0;
                v154[4] = v149[v156];
                v159 = v149[v156];
                if ( v159 )
                  *(_DWORD *)(v159 + 12) = v154;
                v149[v156] = v154;
                v154 = v155;
                v152 = *((_DWORD *)v153 + 17);
              }
              while ( v155 );
            }
            v163 = *(_DWORD *)(v152 + 4) > (unsigned int)&v347->drv_id + 1;
            v347 = (device_drv *)((char *)v347 + 1);
          }
          while ( v163 );
          v35 = v153;
        }
        free(*(void **)v152);
        *(_DWORD *)(*((_DWORD *)v35 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v35 + 17) + 8);
        **((_DWORD **)v35 + 17) = v149;
        v160 = (_DWORD *)*((_DWORD *)v35 + 17);
        v161 = v160[7];
        v162 = v160[3];
        v163 = v161 > v162 >> 1;
        if ( v161 <= v162 >> 1 )
          v164 = 0;
        else
          v164 = v160[8];
        if ( v163 )
          ++v164;
        v160[8] = v164;
        v165 = *((_DWORD *)v35 + 17);
        if ( *(_DWORD *)(v165 + 32) > 1u )
          *(_DWORD *)(v165 + 36) = 1;
        goto LABEL_37;
      }
LABEL_164:
      exit(-1);
    }
    strcpy(str, "Failed to create getq");
  }
  applog(3, str, 1);
  _quit(1, 0);
}
// 12780: variable 'v4' is possibly undefined
// 12780: variable 'v5' is possibly undefined
// 127E0: variable 'v16' is possibly undefined
// 127F2: variable 'v17' is possibly undefined
// 12816: variable 'v18' is possibly undefined
// 1284A: variable 'v19' is possibly undefined
// 12858: variable 'v20' is possibly undefined
// 1286A: variable 'v21' is possibly undefined
// 1287C: variable 'v22' is possibly undefined
// 1288E: variable 'v23' is possibly undefined
// 1289A: variable 'v24' is possibly undefined
// 128BC: variable 'v25' is possibly undefined
// 12E2A: variable 'v89' is possibly undefined
// 13574: variable 'v140' is possibly undefined
// 141DC: variable 'v147' is possibly undefined
// 141DC: variable 'v148' is possibly undefined
// 1421C: variable 'v187' is possibly undefined
// 1421C: variable 'v188' is possibly undefined
// 142CA: variable 'v228' is possibly undefined
// 142CA: variable 'v229' is possibly undefined
// 142D4: variable 'v223' is possibly undefined
// 142D4: variable 'v224' is possibly undefined
// 14304: variable 'v192' is possibly undefined
// 14304: variable 'v193' is possibly undefined
// 149C8: variable 'v298' is possibly undefined
// 16DB8: using guessed type void __noreturn applog_and_exit();
// 4F7A8: using guessed type __int16 word_4F7A8;
// 53210: using guessed type __int16 word_53210;
// 6D848: using guessed type int stderr;

//----- (00014F44) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main((int (*)(int, char **, char **))main, v4, (char **)&va, (void (*)())init, _libc_csu_fini, a1, &va);
  abort();
}
// 14F4E: positive sp value 4 has been found
// 14F60: variable 'v4' is possibly undefined

//----- (00014F74) --------------------------------------------------------
int call_weak_fn()
{
  int result; // r0

  if ( &__gmon_start__ )
    return _gmon_start__();
  return result;
}
// 122B0: using guessed type int _gmon_start__(void);

//----- (00014F98) --------------------------------------------------------
int deregister_tm_clones()
{
  return 448584;
}

//----- (00014FBC) --------------------------------------------------------
int register_tm_clones()
{
  return 448584;
}

//----- (00014FE8) --------------------------------------------------------
int _do_global_dtors_aux()
{
  int result; // r0

  if ( !completed_10529 )
  {
    result = deregister_tm_clones();
    completed_10529 = 1;
  }
  return result;
}
// 6D858: using guessed type char completed_10529;

//----- (00015008) --------------------------------------------------------
char *__fastcall set_balance(pool_strategy *strategy)
{
  *strategy = pool_strategy::POOL_BALANCE;
  return 0;
}

//----- (00015010) --------------------------------------------------------
char *__fastcall set_loadbalance(pool_strategy *strategy)
{
  *strategy = pool_strategy::POOL_LOADBALANCE;
  return 0;
}

//----- (00015018) --------------------------------------------------------
char *__fastcall set_rr(pool_strategy *strategy)
{
  *strategy = pool_strategy::POOL_ROUNDROBIN;
  return 0;
}

//----- (00015020) --------------------------------------------------------
char *__fastcall enable_debug(bool *flag)
{
  *flag = 1;
  opt_log_output = 1;
  return 0;
}

//----- (00015034) --------------------------------------------------------
char *__fastcall set_null(const char *arg)
{
  return 0;
}

//----- (00015040) --------------------------------------------------------
bool __fastcall noop_get_stats(cgpu_info *cgpu)
{
  return 1;
}

//----- (00015044) --------------------------------------------------------
uint64_t __fastcall noop_can_limit_work(thr_info *thr)
{
  return 0xFFFFFFFFLL;
}

//----- (0001504C) --------------------------------------------------------
bool __fastcall noop_prepare_work(thr_info *thr, work *work)
{
  return 1;
}

//----- (00015054) --------------------------------------------------------
api_data *__fastcall noop_get_api_stats(cgpu_info *cgpu)
{
  return 0;
}

//----- (00015058) --------------------------------------------------------
void __fastcall SHA256_Transform(uint32_t *state, const uint32_t *block, int swap)
{
  const uint32_t *v3; // r1
  uint32_t *v4; // r2
  unsigned int v5; // t1
  uint32_t *v6; // r7
  uint32_t *v7; // r8
  __int64 v8; // kr00_8
  __int64 v9; // kr08_8
  uint32_t v10; // r3
  uint32_t v11; // r1
  uint32_t v12; // r2
  uint32_t v13; // r3
  uint32_t v14; // r1
  uint32_t v15; // r2
  uint32_t v16; // r3
  uint32_t v17; // r6
  uint32_t v18; // r0
  uint32_t v19; // r6
  uint32_t v20; // lr
  uint32_t v21; // r11
  int v22; // r9
  uint32_t v23; // lr
  uint32_t v24; // r12
  uint32_t v25; // r1
  int v26; // r3
  uint32_t v27; // r12
  uint32_t v28; // r3
  uint32_t v29; // r2
  uint32_t v30; // r9
  uint32_t v31; // r7
  uint32_t v32; // r6
  uint32_t v33; // r0
  uint32_t v34; // r8
  uint32_t v35; // lr
  uint32_t v36; // r8
  int v37; // r10
  int v38; // r5
  uint32_t v39; // r12
  uint32_t v40; // r11
  uint32_t v41; // r9
  uint32_t v42; // r7
  int v43; // r10
  uint32_t v44; // r3
  int v45; // r1
  int v46; // r0
  uint32_t v47; // r8
  int v48; // r0
  int v49; // r2
  int v50; // lr
  int v51; // r2
  int v52; // r10
  uint32_t v53; // r6
  int v54; // r5
  int v55; // r11
  int v56; // r12
  int v57; // r3
  int v58; // r7
  int v59; // r8
  int v60; // r1
  int v61; // r10
  int v62; // r7
  int v63; // r0
  int v64; // lr
  int v65; // r4
  int v66; // r2
  int v67; // r10
  int v68; // lr
  int v69; // r5
  int v70; // r10
  int v71; // r12
  int v72; // r3
  int v73; // r8
  int v74; // r7
  int v75; // r1
  int v76; // r10
  int v77; // r8
  int v78; // r0
  int v79; // r10
  int v80; // r4
  int v81; // r2
  int v82; // lr
  int v83; // r12
  int v84; // r5
  int v85; // r10
  int v86; // lr
  int v87; // r3
  int v88; // r10
  int v89; // r7
  int v90; // r1
  int v91; // r8
  int v92; // r4
  int v93; // r0
  int v94; // r10
  int v95; // r8
  int v96; // r2
  int v97; // r10
  int v98; // r12
  int v99; // r5
  int v100; // lr
  int v101; // r7
  int v102; // r3
  int v103; // r10
  int v104; // lr
  int v105; // r1
  int v106; // r10
  int v107; // r4
  int v108; // r0
  int v109; // r8
  int v110; // r12
  int v111; // r2
  int v112; // r10
  int v113; // r8
  int v114; // r5
  int v115; // r10
  int v116; // r7
  int v117; // r3
  int v118; // lr
  int v119; // r4
  int v120; // r1
  int v121; // r10
  int v122; // lr
  int v123; // r0
  int v124; // r10
  int v125; // r12
  int v126; // r2
  int v127; // r8
  int v128; // r7
  int v129; // r5
  int v130; // r10
  int v131; // r8
  int v132; // r3
  int v133; // r10
  int v134; // r4
  int v135; // r1
  int v136; // lr
  int v137; // r12
  int v138; // r0
  int v139; // r10
  int v140; // lr
  int v141; // r2
  int v142; // r10
  int v143; // r7
  int v144; // r5
  int v145; // r8
  int v146; // r4
  int v147; // r3
  int v148; // r10
  int v149; // r8
  int v150; // r1
  int v151; // r10
  int v152; // r12
  int v153; // r0
  int v154; // lr
  int v155; // r7
  int v156; // r2
  int v157; // r10
  int v158; // lr
  int v159; // r5
  int v160; // r10
  int v161; // r4
  int v162; // r3
  int v163; // r8
  int v164; // r12
  int v165; // r1
  int v166; // r10
  int v167; // r8
  int v168; // r0
  int v169; // r10
  int v170; // r7
  int v171; // r2
  int v172; // lr
  int v173; // r4
  int v174; // r5
  int v175; // r10
  int v176; // r12
  int v177; // r3
  int v178; // r10
  int v179; // lr
  int v180; // r1
  int v181; // r8
  int v182; // r7
  int v183; // r0
  int v184; // r10
  int v185; // r5
  int v186; // r2
  int v187; // r11
  int v188; // r6
  int v189; // r12
  int v190; // r10
  int v191; // lr
  int v192; // r3
  int v193; // r10
  int v194; // r8
  int v195; // r1
  int v196; // r5
  uint32_t v197; // r7
  int v198; // r2
  int v199; // r0
  int v200; // r11
  uint32_t v201; // r5
  uint32_t v202; // r7
  uint32_t v203; // r6
  uint32_t v204; // r9
  int v205; // r4
  uint32_t v206; // lr
  uint32_t v207; // r1
  uint32_t v208; // lr
  uint32_t v209; // r2
  uint32_t v210; // r3
  uint32_t *v211; // r1
  uint32_t *v212; // r4
  uint32_t *v213; // r7
  uint32_t v214; // t1
  uint32_t v215; // t1
  const uint32_t *v216; // r5
  uint32_t v217; // r0
  uint32_t v218; // r1
  uint32_t v219; // r2
  uint32_t v220; // r3
  uint32_t v221; // r0
  uint32_t v222; // r1
  uint32_t v223; // r2
  uint32_t v224; // r3
  uint32_t v225; // r0
  uint32_t v226; // r1
  uint32_t v227; // r2
  uint32_t v228; // r3
  uint32_t v229; // r1
  uint32_t v230; // r2
  uint32_t v231; // r3
  uint32_t *v232; // [sp+4h] [bp-130h]
  uint32_t *statea; // [sp+8h] [bp-12Ch]
  uint32_t v234; // [sp+Ch] [bp-128h]
  uint32_t S[8]; // [sp+10h] [bp-124h] BYREF
  uint32_t W[65]; // [sp+30h] [bp-104h] BYREF

  statea = state;
  if ( swap )
  {
    v3 = block - 1;
    v4 = &S[7];
    do
    {
      v5 = v3[1];
      ++v3;
      v4[1] = bswap32(v5);
      ++v4;
    }
    while ( &W[15] != v4 );
    v232 = W;
  }
  else
  {
    v216 = block;
    v232 = W;
    v217 = *block;
    v218 = block[1];
    v219 = v216[2];
    v220 = v216[3];
    v216 += 4;
    W[0] = v217;
    W[1] = v218;
    W[2] = v219;
    W[3] = v220;
    v221 = *v216;
    v222 = v216[1];
    v223 = v216[2];
    v224 = v216[3];
    v216 += 4;
    W[4] = v221;
    W[5] = v222;
    W[6] = v223;
    W[7] = v224;
    v225 = *v216;
    v226 = v216[1];
    v227 = v216[2];
    v228 = v216[3];
    v216 += 4;
    W[8] = v225;
    W[9] = v226;
    W[10] = v227;
    W[11] = v228;
    v229 = v216[1];
    v230 = v216[2];
    v231 = v216[3];
    W[12] = *v216;
    W[13] = v229;
    W[14] = v230;
    W[15] = v231;
  }
  v6 = v232;
  v7 = v232;
  do
  {
    v8 = *((_QWORD *)v6 + 7);
    v9 = *(_QWORD *)(v6 + 1);
    v10 = v9
        + v6[10]
        + (__ROR4__(HIDWORD(v8), 19) ^ __ROR4__(HIDWORD(v8), 17) ^ (HIDWORD(v8) >> 10))
        + (__ROR4__(HIDWORD(v9), 18) ^ __ROR4__(HIDWORD(v9), 7) ^ (HIDWORD(v9) >> 3));
    v6[16] = (__ROR4__(v8, 19) ^ __ROR4__(v8, 17) ^ ((unsigned int)v8 >> 10))
           + v6[9]
           + *v6
           + (__ROR4__(v9, 18) ^ __ROR4__(v9, 7) ^ ((unsigned int)v9 >> 3));
    v6[17] = v10;
    v6 += 2;
  }
  while ( &W[48] != v6 );
  v232 = v7;
  v11 = statea[1];
  v12 = statea[2];
  v13 = statea[3];
  S[0] = *statea;
  S[1] = v11;
  S[2] = v12;
  S[3] = v13;
  v14 = statea[5];
  v15 = statea[6];
  v16 = statea[7];
  S[4] = statea[4];
  S[5] = v14;
  S[6] = v15;
  S[7] = v16;
  v234 = S[2];
  v17 = v16
      + *v7
      + 1116352408
      + (__ROR4__(S[4], 11) ^ __ROR4__(S[4], 6) ^ __ROR4__(S[4], 25))
      + ((v14 ^ v15) & S[4] ^ v15);
  v18 = S[3] + v17;
  v19 = v17 + ((S[1] | S[2]) & S[0] | S[1] & S[2]) + (__ROR4__(S[0], 13) ^ __ROR4__(S[0], 2) ^ __ROR4__(S[0], 22));
  v20 = v15
      + v7[1]
      + 1899447441
      + ((S[4] ^ S[5]) & v18 ^ S[5])
      + (__ROR4__(v18, 11) ^ __ROR4__(v18, 6) ^ __ROR4__(v18, 25));
  v21 = S[2] + v20;
  v22 = __ROR4__(S[2] + v20, 11);
  v23 = v20 + ((S[0] | S[1]) & v19 | S[0] & S[1]) + (__ROR4__(v19, 13) ^ __ROR4__(v19, 2) ^ __ROR4__(v19, 22));
  v24 = v14 + v7[2] - 1245643825 + ((S[4] ^ v18) & v21 ^ S[4]) + (v22 ^ __ROR4__(v21, 6) ^ __ROR4__(v21, 25));
  v25 = S[1] + v24;
  v26 = __ROR4__(S[1] + v24, 11);
  v27 = v24 + (__ROR4__(v23, 13) ^ __ROR4__(v23, 2) ^ __ROR4__(v23, 22)) + ((S[0] | v19) & v23 | S[0] & v19);
  v28 = ((v18 ^ v21) & v25 ^ v18) + v7[3] + S[4] - 373957723 + (v26 ^ __ROR4__(v25, 6) ^ __ROR4__(v25, 25));
  v29 = S[0] + v28;
  v30 = ((v19 | v23) & v27 | v19 & v23) + (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + v28;
  v31 = (__ROR4__(S[0] + v28, 11) ^ __ROR4__(v29, 6) ^ __ROR4__(v29, 25))
      + v18
      + v7[4]
      + 961987163
      + ((v21 ^ v25) & (S[0] + v28) ^ v21);
  v32 = v19 + v31;
  v33 = ((v23 | v27) & v30 | v23 & v27) + (__ROR4__(v30, 13) ^ __ROR4__(v30, 2) ^ __ROR4__(v30, 22)) + v31;
  v34 = (__ROR4__(v32, 11) ^ __ROR4__(v32, 6) ^ __ROR4__(v32, 25))
      + ((v25 ^ (S[0] + v28)) & v32 ^ v25)
      + v21
      + v7[5]
      + 1508970993;
  v35 = v23 + v34;
  v36 = v34 + (__ROR4__(v33, 13) ^ __ROR4__(v33, 2) ^ __ROR4__(v33, 22)) + ((v27 | v30) & v33 | v27 & v30);
  v37 = (__ROR4__(v35, 11) ^ __ROR4__(v35, 6) ^ __ROR4__(v35, 25))
      + v25
      + v232[6]
      - 1841331548
      + ((v29 ^ v32) & v35 ^ v29);
  v38 = ((v30 | v33) & v36 | v30 & v33) + (__ROR4__(v36, 13) ^ __ROR4__(v36, 2) ^ __ROR4__(v36, 22)) + v37;
  v39 = v27 + v37;
  v40 = (__ROR4__(v39, 11) ^ __ROR4__(v39, 6) ^ __ROR4__(v39, 25))
      + S[0]
      + v28
      + v232[7]
      - 1424204075
      + ((v32 ^ v35) & v39 ^ v32);
  v41 = v30 + v40;
  v42 = ((v33 | v36) & v38 | v33 & v36) + (__ROR4__(v38, 13) ^ __ROR4__(v38, 2) ^ __ROR4__(v38, 22)) + v40;
  v43 = (__ROR4__(v41, 11) ^ __ROR4__(v41, 6) ^ __ROR4__(v41, 25))
      + v32
      + v232[8]
      - 670586216
      + ((v35 ^ v39) & v41 ^ v35);
  v44 = v33 + v43;
  v45 = ((v36 | v38) & v42 | v36 & v38) + (__ROR4__(v42, 13) ^ __ROR4__(v42, 2) ^ __ROR4__(v42, 22)) + v43;
  v46 = (__ROR4__(v33 + v43, 11) ^ __ROR4__(v33 + v43, 6) ^ __ROR4__(v33 + v43, 25))
      + v35
      + v232[9]
      + 310598401
      + ((v39 ^ v41) & (v33 + v43) ^ v39);
  v47 = v36 + v46;
  v48 = v46 + (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22)) + ((v38 | v42) & v45 | v38 & v42);
  v49 = ((v41 ^ v44) & v47 ^ v41)
      + v39
      + v232[10]
      + 607225278
      + (__ROR4__(v47, 11) ^ __ROR4__(v47, 6) ^ __ROR4__(v47, 25));
  v50 = v38 + v49;
  v51 = v49 + (__ROR4__(v48, 13) ^ __ROR4__(v48, 2) ^ __ROR4__(v48, 22)) + ((v42 | v45) & v48 | v42 & v45);
  v52 = (__ROR4__(v50, 11) ^ __ROR4__(v50, 6) ^ __ROR4__(v50, 25))
      + v41
      + v232[11]
      + 1426881987
      + ((v44 ^ v47) & v50 ^ v44);
  v53 = v42 + v52;
  v54 = ((v45 | v48) & v51 | v45 & v48) + (__ROR4__(v51, 13) ^ __ROR4__(v51, 2) ^ __ROR4__(v51, 22)) + v52;
  v55 = (__ROR4__(v53, 11) ^ __ROR4__(v53, 6) ^ __ROR4__(v53, 25))
      + v44
      + v232[12]
      + 1925078388
      + ((v47 ^ v50) & v53 ^ v47);
  v56 = v45 + v55;
  v57 = ((v48 | v51) & v54 | v48 & v51) + (__ROR4__(v54, 13) ^ __ROR4__(v54, 2) ^ __ROR4__(v54, 22)) + v55;
  v58 = ((v50 ^ (v42 + v52)) & v56 ^ v50)
      + v47
      + v232[13]
      - 2132889090
      + (__ROR4__(v45 + v55, 11) ^ __ROR4__(v56, 6) ^ __ROR4__(v56, 25));
  v59 = v48 + v58;
  v60 = ((v51 | v54) & v57 | v51 & v54) + (__ROR4__(v57, 13) ^ __ROR4__(v57, 2) ^ __ROR4__(v57, 22)) + v58;
  v61 = (__ROR4__(v48 + v58, 11) ^ __ROR4__(v59, 6) ^ __ROR4__(v59, 25))
      + ((v53 ^ v56) & v59 ^ v53)
      + v50
      + v232[14]
      - 1680079193;
  v62 = v51 + v61;
  v63 = ((v54 | v57) & v60 | v54 & v57) + (__ROR4__(v60, 13) ^ __ROR4__(v60, 2) ^ __ROR4__(v60, 22)) + v61;
  v64 = ((v56 ^ v59) & v62 ^ v56)
      + v53
      + v232[15]
      - 1046744716
      + (__ROR4__(v51 + v61, 11) ^ __ROR4__(v51 + v61, 6) ^ __ROR4__(v62, 25));
  v65 = v54 + v64;
  v66 = ((v57 | v60) & v63 | v57 & v60) + (__ROR4__(v63, 13) ^ __ROR4__(v63, 2) ^ __ROR4__(v63, 22)) + v64;
  v67 = (__ROR4__(v54 + v64, 11) ^ __ROR4__(v54 + v64, 6) ^ __ROR4__(v65, 25))
      + ((v59 ^ v62) & v65 ^ v59)
      + v56
      + v232[16]
      - 459576895;
  v68 = v57 + v67;
  v69 = ((v60 | v63) & v66 | v60 & v63) + (__ROR4__(v66, 13) ^ __ROR4__(v66, 2) ^ __ROR4__(v66, 22)) + v67;
  v70 = (__ROR4__(v57 + v67, 11) ^ __ROR4__(v57 + v67, 6) ^ __ROR4__(v68, 25))
      + ((v62 ^ v65) & v68 ^ v62)
      + v59
      + v232[17]
      - 272742522;
  v71 = v60 + v70;
  v72 = ((v63 | v66) & v69 | v63 & v66) + (__ROR4__(v69, 13) ^ __ROR4__(v69, 2) ^ __ROR4__(v69, 22)) + v70;
  v73 = ((v65 ^ v68) & v71 ^ v65)
      + v62
      + v232[18]
      + 264347078
      + (__ROR4__(v60 + v70, 11) ^ __ROR4__(v60 + v70, 6) ^ __ROR4__(v71, 25));
  v74 = v63 + v73;
  v75 = ((v66 | v69) & v72 | v66 & v69) + (__ROR4__(v72, 13) ^ __ROR4__(v72, 2) ^ __ROR4__(v72, 22)) + v73;
  v76 = (__ROR4__(v63 + v73, 11) ^ __ROR4__(v74, 6) ^ __ROR4__(v74, 25))
      + ((v68 ^ v71) & v74 ^ v68)
      + v65
      + v232[19]
      + 604807628;
  v77 = v66 + v76;
  v78 = ((v69 | v72) & v75 | v69 & v72) + (__ROR4__(v75, 13) ^ __ROR4__(v75, 2) ^ __ROR4__(v75, 22)) + v76;
  v79 = (__ROR4__(v66 + v76, 11) ^ __ROR4__(v77, 6) ^ __ROR4__(v77, 25))
      + ((v71 ^ v74) & v77 ^ v71)
      + v68
      + v232[20]
      + 770255983;
  v80 = v69 + v79;
  v81 = ((v72 | v75) & v78 | v72 & v75) + (__ROR4__(v78, 13) ^ __ROR4__(v78, 2) ^ __ROR4__(v78, 22)) + v79;
  v82 = ((v74 ^ v77) & v80 ^ v74)
      + v71
      + v232[21]
      + 1249150122
      + (__ROR4__(v69 + v79, 11) ^ __ROR4__(v69 + v79, 6) ^ __ROR4__(v80, 25));
  v83 = v72 + v82;
  v84 = ((v75 | v78) & v81 | v75 & v78) + (__ROR4__(v81, 13) ^ __ROR4__(v81, 2) ^ __ROR4__(v81, 22)) + v82;
  v85 = (__ROR4__(v72 + v82, 11) ^ __ROR4__(v83, 6) ^ __ROR4__(v83, 25))
      + ((v77 ^ v80) & v83 ^ v77)
      + v74
      + v232[22]
      + 1555081692;
  v86 = v75 + v85;
  v87 = ((v78 | v81) & v84 | v78 & v81) + (__ROR4__(v84, 13) ^ __ROR4__(v84, 2) ^ __ROR4__(v84, 22)) + v85;
  v88 = (__ROR4__(v75 + v85, 11) ^ __ROR4__(v75 + v85, 6) ^ __ROR4__(v86, 25))
      + ((v80 ^ v83) & v86 ^ v80)
      + v77
      + v232[23]
      + 1996064986;
  v89 = v78 + v88;
  v90 = ((v81 | v84) & v87 | v81 & v84) + (__ROR4__(v87, 13) ^ __ROR4__(v87, 2) ^ __ROR4__(v87, 22)) + v88;
  v91 = ((v83 ^ v86) & v89 ^ v83)
      + v80
      + v232[24]
      - 1740746414
      + (__ROR4__(v78 + v88, 11) ^ __ROR4__(v78 + v88, 6) ^ __ROR4__(v89, 25));
  v92 = v81 + v91;
  v93 = ((v84 | v87) & v90 | v84 & v87) + (__ROR4__(v90, 13) ^ __ROR4__(v90, 2) ^ __ROR4__(v90, 22)) + v91;
  v94 = (__ROR4__(v81 + v91, 11) ^ __ROR4__(v81 + v91, 6) ^ __ROR4__(v92, 25))
      + ((v86 ^ v89) & v92 ^ v86)
      + v83
      + v232[25]
      - 1473132947;
  v95 = v84 + v94;
  v96 = ((v87 | v90) & v93 | v87 & v90) + (__ROR4__(v93, 13) ^ __ROR4__(v93, 2) ^ __ROR4__(v93, 22)) + v94;
  v97 = (__ROR4__(v84 + v94, 11) ^ __ROR4__(v84 + v94, 6) ^ __ROR4__(v95, 25))
      + ((v89 ^ v92) & v95 ^ v89)
      + v86
      + v232[26]
      - 1341970488;
  v98 = v87 + v97;
  v99 = ((v90 | v93) & v96 | v90 & v93) + (__ROR4__(v96, 13) ^ __ROR4__(v96, 2) ^ __ROR4__(v96, 22)) + v97;
  v100 = ((v92 ^ v95) & v98 ^ v92)
       + v89
       + v232[27]
       - 1084653625
       + (__ROR4__(v87 + v97, 11) ^ __ROR4__(v87 + v97, 6) ^ __ROR4__(v98, 25));
  v101 = v90 + v100;
  v102 = ((v93 | v96) & v99 | v93 & v96) + (__ROR4__(v99, 13) ^ __ROR4__(v99, 2) ^ __ROR4__(v99, 22)) + v100;
  v103 = (__ROR4__(v90 + v100, 11) ^ __ROR4__(v101, 6) ^ __ROR4__(v101, 25))
       + ((v95 ^ v98) & v101 ^ v95)
       + v92
       + v232[28]
       - 958395405;
  v104 = v93 + v103;
  v105 = ((v96 | v99) & v102 | v96 & v99) + (__ROR4__(v102, 13) ^ __ROR4__(v102, 2) ^ __ROR4__(v102, 22)) + v103;
  v106 = (__ROR4__(v93 + v103, 11) ^ __ROR4__(v104, 6) ^ __ROR4__(v104, 25))
       + ((v98 ^ v101) & v104 ^ v98)
       + v95
       + v232[29]
       - 710438585;
  v107 = v96 + v106;
  v108 = ((v99 | v102) & v105 | v99 & v102) + (__ROR4__(v105, 13) ^ __ROR4__(v105, 2) ^ __ROR4__(v105, 22)) + v106;
  v109 = ((v101 ^ v104) & v107 ^ v101)
       + v98
       + v232[30]
       + 113926993
       + (__ROR4__(v96 + v106, 11) ^ __ROR4__(v96 + v106, 6) ^ __ROR4__(v107, 25));
  v110 = v99 + v109;
  v111 = ((v102 | v105) & v108 | v102 & v105) + (__ROR4__(v108, 13) ^ __ROR4__(v108, 2) ^ __ROR4__(v108, 22)) + v109;
  v112 = (__ROR4__(v99 + v109, 11) ^ __ROR4__(v110, 6) ^ __ROR4__(v110, 25))
       + ((v104 ^ v107) & v110 ^ v104)
       + v101
       + v232[31]
       + 338241895;
  v113 = v102 + v112;
  v114 = ((v105 | v108) & v111 | v105 & v108) + (__ROR4__(v111, 13) ^ __ROR4__(v111, 2) ^ __ROR4__(v111, 22)) + v112;
  v115 = (__ROR4__(v102 + v112, 11) ^ __ROR4__(v102 + v112, 6) ^ __ROR4__(v113, 25))
       + ((v107 ^ v110) & v113 ^ v107)
       + v104
       + v232[32]
       + 666307205;
  v116 = v105 + v115;
  v117 = ((v108 | v111) & v114 | v108 & v111) + (__ROR4__(v114, 13) ^ __ROR4__(v114, 2) ^ __ROR4__(v114, 22)) + v115;
  v118 = ((v110 ^ v113) & v116 ^ v110)
       + v107
       + v232[33]
       + 773529912
       + (__ROR4__(v105 + v115, 11) ^ __ROR4__(v105 + v115, 6) ^ __ROR4__(v116, 25));
  v119 = v108 + v118;
  v120 = ((v111 | v114) & v117 | v111 & v114) + (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + v118;
  v121 = (__ROR4__(v108 + v118, 11) ^ __ROR4__(v108 + v118, 6) ^ __ROR4__(v119, 25))
       + ((v113 ^ v116) & v119 ^ v113)
       + v110
       + v232[34]
       + 1294757372;
  v122 = v111 + v121;
  v123 = ((v114 | v117) & v120 | v114 & v117) + (__ROR4__(v120, 13) ^ __ROR4__(v120, 2) ^ __ROR4__(v120, 22)) + v121;
  v124 = (__ROR4__(v111 + v121, 11) ^ __ROR4__(v111 + v121, 6) ^ __ROR4__(v122, 25))
       + ((v116 ^ v119) & v122 ^ v116)
       + v113
       + v232[35]
       + 1396182291;
  v125 = v114 + v124;
  v126 = ((v117 | v120) & v123 | v117 & v120) + (__ROR4__(v123, 13) ^ __ROR4__(v123, 2) ^ __ROR4__(v123, 22)) + v124;
  v127 = ((v119 ^ v122) & v125 ^ v119)
       + v116
       + v232[36]
       + 1695183700
       + (__ROR4__(v114 + v124, 11) ^ __ROR4__(v114 + v124, 6) ^ __ROR4__(v125, 25));
  v128 = v117 + v127;
  v129 = ((v120 | v123) & v126 | v120 & v123) + (__ROR4__(v126, 13) ^ __ROR4__(v126, 2) ^ __ROR4__(v126, 22)) + v127;
  v130 = (__ROR4__(v117 + v127, 11) ^ __ROR4__(v128, 6) ^ __ROR4__(v128, 25))
       + ((v122 ^ v125) & v128 ^ v122)
       + v119
       + v232[37]
       + 1986661051;
  v131 = v120 + v130;
  v132 = ((v123 | v126) & v129 | v123 & v126) + (__ROR4__(v129, 13) ^ __ROR4__(v129, 2) ^ __ROR4__(v129, 22)) + v130;
  v133 = (__ROR4__(v120 + v130, 11) ^ __ROR4__(v131, 6) ^ __ROR4__(v131, 25))
       + ((v125 ^ v128) & v131 ^ v125)
       + v122
       + v232[38]
       - 2117940946;
  v134 = v123 + v133;
  v135 = ((v126 | v129) & v132 | v126 & v129) + (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + v133;
  v136 = ((v128 ^ v131) & v134 ^ v128)
       + v125
       + v232[39]
       - 1838011259
       + (__ROR4__(v123 + v133, 11) ^ __ROR4__(v123 + v133, 6) ^ __ROR4__(v134, 25));
  v137 = v126 + v136;
  v138 = ((v129 | v132) & v135 | v129 & v132) + (__ROR4__(v135, 13) ^ __ROR4__(v135, 2) ^ __ROR4__(v135, 22)) + v136;
  v139 = (__ROR4__(v126 + v136, 11) ^ __ROR4__(v137, 6) ^ __ROR4__(v137, 25))
       + ((v131 ^ v134) & v137 ^ v131)
       + v128
       + v232[40]
       - 1564481375;
  v140 = v129 + v139;
  v141 = ((v132 | v135) & v138 | v132 & v135) + (__ROR4__(v138, 13) ^ __ROR4__(v138, 2) ^ __ROR4__(v138, 22)) + v139;
  v142 = (__ROR4__(v129 + v139, 11) ^ __ROR4__(v129 + v139, 6) ^ __ROR4__(v140, 25))
       + ((v134 ^ v137) & v140 ^ v134)
       + v131
       + v232[41]
       - 1474664885;
  v143 = v132 + v142;
  v144 = ((v135 | v138) & v141 | v135 & v138) + (__ROR4__(v141, 13) ^ __ROR4__(v141, 2) ^ __ROR4__(v141, 22)) + v142;
  v145 = ((v137 ^ v140) & v143 ^ v137)
       + v134
       + v232[42]
       - 1035236496
       + (__ROR4__(v132 + v142, 11) ^ __ROR4__(v132 + v142, 6) ^ __ROR4__(v143, 25));
  v146 = v135 + v145;
  v147 = ((v138 | v141) & v144 | v138 & v141) + (__ROR4__(v144, 13) ^ __ROR4__(v144, 2) ^ __ROR4__(v144, 22)) + v145;
  v148 = (__ROR4__(v135 + v145, 11) ^ __ROR4__(v135 + v145, 6) ^ __ROR4__(v146, 25))
       + ((v140 ^ v143) & v146 ^ v140)
       + v137
       + v232[43]
       - 949202525;
  v149 = v138 + v148;
  v150 = ((v141 | v144) & v147 | v141 & v144) + (__ROR4__(v147, 13) ^ __ROR4__(v147, 2) ^ __ROR4__(v147, 22)) + v148;
  v151 = (__ROR4__(v138 + v148, 11) ^ __ROR4__(v138 + v148, 6) ^ __ROR4__(v149, 25))
       + ((v143 ^ v146) & v149 ^ v143)
       + v140
       + v232[44]
       - 778901479;
  v152 = v141 + v151;
  v153 = ((v144 | v147) & v150 | v144 & v147) + (__ROR4__(v150, 13) ^ __ROR4__(v150, 2) ^ __ROR4__(v150, 22)) + v151;
  v154 = ((v146 ^ v149) & v152 ^ v146)
       + v143
       + v232[45]
       - 694614492
       + (__ROR4__(v141 + v151, 11) ^ __ROR4__(v141 + v151, 6) ^ __ROR4__(v152, 25));
  v155 = v144 + v154;
  v156 = ((v147 | v150) & v153 | v147 & v150) + (__ROR4__(v153, 13) ^ __ROR4__(v153, 2) ^ __ROR4__(v153, 22)) + v154;
  v157 = (__ROR4__(v144 + v154, 11) ^ __ROR4__(v155, 6) ^ __ROR4__(v155, 25))
       + ((v149 ^ v152) & v155 ^ v149)
       + v146
       + v232[46]
       - 200395387;
  v158 = v147 + v157;
  v159 = ((v150 | v153) & v156 | v150 & v153) + (__ROR4__(v156, 13) ^ __ROR4__(v156, 2) ^ __ROR4__(v156, 22)) + v157;
  v160 = (__ROR4__(v147 + v157, 11) ^ __ROR4__(v158, 6) ^ __ROR4__(v158, 25))
       + ((v152 ^ v155) & v158 ^ v152)
       + v149
       + v232[47]
       + 275423344;
  v161 = v150 + v160;
  v162 = ((v153 | v156) & v159 | v153 & v156) + (__ROR4__(v159, 13) ^ __ROR4__(v159, 2) ^ __ROR4__(v159, 22)) + v160;
  v163 = ((v155 ^ v158) & v161 ^ v155)
       + v152
       + v232[48]
       + 430227734
       + (__ROR4__(v150 + v160, 11) ^ __ROR4__(v150 + v160, 6) ^ __ROR4__(v161, 25));
  v164 = v153 + v163;
  v165 = ((v156 | v159) & v162 | v156 & v159) + (__ROR4__(v162, 13) ^ __ROR4__(v162, 2) ^ __ROR4__(v162, 22)) + v163;
  v166 = (__ROR4__(v153 + v163, 11) ^ __ROR4__(v164, 6) ^ __ROR4__(v164, 25))
       + ((v158 ^ v161) & v164 ^ v158)
       + v155
       + v232[49]
       + 506948616;
  v167 = v156 + v166;
  v168 = ((v159 | v162) & v165 | v159 & v162) + (__ROR4__(v165, 13) ^ __ROR4__(v165, 2) ^ __ROR4__(v165, 22)) + v166;
  v169 = (__ROR4__(v156 + v166, 11) ^ __ROR4__(v156 + v166, 6) ^ __ROR4__(v167, 25))
       + ((v161 ^ v164) & v167 ^ v161)
       + v158
       + v232[50]
       + 659060556;
  v170 = v159 + v169;
  v171 = ((v162 | v165) & v168 | v162 & v165) + (__ROR4__(v168, 13) ^ __ROR4__(v168, 2) ^ __ROR4__(v168, 22)) + v169;
  v172 = ((v164 ^ v167) & v170 ^ v164)
       + v161
       + v232[51]
       + 883997877
       + (__ROR4__(v159 + v169, 11) ^ __ROR4__(v159 + v169, 6) ^ __ROR4__(v170, 25));
  v173 = v162 + v172;
  v174 = ((v165 | v168) & v171 | v165 & v168) + (__ROR4__(v171, 13) ^ __ROR4__(v171, 2) ^ __ROR4__(v171, 22)) + v172;
  v175 = (__ROR4__(v162 + v172, 11) ^ __ROR4__(v162 + v172, 6) ^ __ROR4__(v173, 25))
       + ((v167 ^ v170) & v173 ^ v167)
       + v164
       + v232[52]
       + 958139571;
  v176 = v165 + v175;
  v177 = ((v168 | v171) & v174 | v168 & v171) + (__ROR4__(v174, 13) ^ __ROR4__(v174, 2) ^ __ROR4__(v174, 22)) + v175;
  v178 = (__ROR4__(v165 + v175, 11) ^ __ROR4__(v165 + v175, 6) ^ __ROR4__(v176, 25))
       + ((v170 ^ v173) & v176 ^ v170)
       + v167
       + v232[53]
       + 1322822218;
  v179 = v168 + v178;
  v180 = ((v171 | v174) & v177 | v171 & v174) + (__ROR4__(v177, 13) ^ __ROR4__(v177, 2) ^ __ROR4__(v177, 22)) + v178;
  v181 = ((v173 ^ v176) & v179 ^ v173)
       + v170
       + v232[54]
       + 1537002063
       + (__ROR4__(v168 + v178, 11) ^ __ROR4__(v168 + v178, 6) ^ __ROR4__(v179, 25));
  v182 = v171 + v181;
  v183 = ((v174 | v177) & v180 | v174 & v177) + (__ROR4__(v180, 13) ^ __ROR4__(v180, 2) ^ __ROR4__(v180, 22)) + v181;
  v184 = (__ROR4__(v171 + v181, 11) ^ __ROR4__(v182, 6) ^ __ROR4__(v182, 25))
       + ((v176 ^ v179) & v182 ^ v176)
       + v173
       + v232[55]
       + 1747873779;
  v185 = v174 + v184;
  v186 = ((v177 | v180) & v183 | v177 & v180) + (__ROR4__(v183, 13) ^ __ROR4__(v183, 2) ^ __ROR4__(v183, 22)) + v184;
  v187 = (__ROR4__(v185, 11) ^ __ROR4__(v185, 6) ^ __ROR4__(v185, 25))
       + v176
       + v232[56]
       + 1955562222
       + ((v179 ^ v182) & v185 ^ v179);
  v188 = v177 + v187;
  v189 = ((v180 | v183) & v186 | v180 & v183) + (__ROR4__(v186, 13) ^ __ROR4__(v186, 2) ^ __ROR4__(v186, 22)) + v187;
  v190 = (__ROR4__(v177 + v187, 11) ^ __ROR4__(v188, 6) ^ __ROR4__(v188, 25))
       + ((v182 ^ v185) & v188 ^ v182)
       + v179
       + v232[57]
       + 2024104815;
  v191 = v180 + v190;
  v192 = ((v183 | v186) & v189 | v183 & v186) + (__ROR4__(v189, 13) ^ __ROR4__(v189, 2) ^ __ROR4__(v189, 22)) + v190;
  v193 = (__ROR4__(v180 + v190, 11) ^ __ROR4__(v180 + v190, 6) ^ __ROR4__(v191, 25))
       + ((v185 ^ v188) & v191 ^ v185)
       + v182
       + v232[58]
       - 2067236844;
  v194 = v183 + v193;
  v195 = ((v186 | v189) & v192 | v186 & v189) + (__ROR4__(v192, 13) ^ __ROR4__(v192, 2) ^ __ROR4__(v192, 22)) + v193;
  v196 = v185
       + v232[59]
       - 1933114872
       + ((v188 ^ v191) & v194 ^ v188)
       + (__ROR4__(v183 + v193, 11) ^ __ROR4__(v194, 6) ^ __ROR4__(v194, 25));
  v197 = v232[61];
  v198 = v186 + v196;
  v199 = ((v189 | v192) & v195 | v189 & v192) + (__ROR4__(v195, 13) ^ __ROR4__(v195, 2) ^ __ROR4__(v195, 22)) + v196;
  v200 = (__ROR4__(v198, 11) ^ __ROR4__(v198, 6) ^ __ROR4__(v198, 25))
       + ((v191 ^ v194) & v198 ^ v191)
       + v232[60]
       - 1866530822
       + v188;
  v201 = (__ROR4__(v199, 13) ^ __ROR4__(v199, 2) ^ __ROR4__(v199, 22)) + ((v192 | v195) & v199 | v192 & v195) + v200;
  S[7] = v189 + v200;
  v202 = v191
       + v197
       - 1538233109
       + ((v194 ^ v198) & S[7] ^ v194)
       + (__ROR4__(S[7], 11) ^ __ROR4__(S[7], 6) ^ __ROR4__(S[7], 25));
  v203 = (__ROR4__(v201, 13) ^ __ROR4__(v201, 2) ^ __ROR4__(v201, 22)) + ((v195 | v199) & v201 | v195 & v199) + v202;
  v204 = v232[63];
  v205 = v232[62] - 1090935817;
  S[6] = v192 + v202;
  v206 = (__ROR4__(S[6], 11) ^ __ROR4__(S[6], 6) ^ __ROR4__(S[6], 25))
       + ((v198 ^ (v189 + v200)) & S[6] ^ v198)
       + v194
       + v205;
  v207 = v195 + v206;
  v208 = v206 + (__ROR4__(v203, 13) ^ __ROR4__(v203, 2) ^ __ROR4__(v203, 22)) + ((v199 | v201) & v203 | v199 & v201);
  S[5] = v207;
  v209 = v198
       + v204
       - 965641998
       + ((S[7] ^ (v192 + v202)) & v207 ^ S[7])
       + (__ROR4__(v207, 11) ^ __ROR4__(v207, 6) ^ __ROR4__(v207, 25));
  v210 = (__ROR4__(v208, 13) ^ __ROR4__(v208, 2) ^ __ROR4__(v208, 22)) + ((v201 | v203) & v208 | v201 & v203) + v209;
  v211 = statea - 1;
  S[3] = v201;
  S[4] = v199 + v209;
  v212 = statea + 7;
  S[1] = v208;
  S[2] = v203;
  v213 = &S[1];
  S[0] = v210;
  while ( 1 )
  {
    v215 = v211[1];
    *++v211 = v210 + v215;
    if ( v212 == v211 )
      break;
    v214 = *v213++;
    v210 = v214;
  }
}

//----- (000165BC) --------------------------------------------------------
void __fastcall benchfile_dspwork(work *work, uint32_t nonce)
{
  int v2; // r2
  int v3; // r4
  int v4; // r3
  char buf[1024]; // [sp+8h] [bp-1400h] BYREF
  char tmp42[4096]; // [sp+408h] [bp-1000h] BYREF

  v2 = 4;
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)nonce;
    --v2;
    nonce >>= 8;
    v3 = v4 + (v3 << 8);
  }
  while ( v2 );
  _bin2hex(buf, work->data, 0x80u);
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "BENCHFILE nonce %u=0x%08x for work=%s", v3, v3, buf);
    applog(3, tmp42, 0);
  }
}

//----- (00016640) --------------------------------------------------------
void __fastcall suffix_string(uint64_t val, char *buf, size_t bufsiz, int sigdigits)
{
  __int16 v6; // r3
  double v7; // d8
  int v8; // r1
  double v9; // r0
  char suffix[8]; // [sp+1Ch] [bp-8h] BYREF

  *(_WORD *)suffix = 0;
  if ( val > 0xDE0B6B3A763FFFFLL )
  {
    val /= 0x38D7EA4C68000uLL;
    v6 = 69;
    goto LABEL_3;
  }
  if ( val > 0x38D7EA4C67FFFLL )
  {
    val /= 0xE8D4A51000uLL;
    v6 = 80;
    goto LABEL_3;
  }
  if ( val > 0xE8D4A50FFFLL )
  {
    val /= 0x3B9ACA00uLL;
    v6 = 84;
    goto LABEL_3;
  }
  if ( val > 0x3B9AC9FF )
  {
    val /= 0xF4240uLL;
    v6 = 71;
LABEL_3:
    *(_WORD *)suffix = v6;
    v7 = (double)(int)val / 1000.0;
    if ( !sigdigits )
    {
LABEL_4:
      snprintf(buf, bufsiz, "%.3g%s", v7, suffix);
      return;
    }
    goto LABEL_9;
  }
  if ( val > 0xF423F )
  {
    val /= 0x3E8uLL;
    v6 = 77;
    goto LABEL_3;
  }
  v7 = (double)(int)val;
  if ( val < 0x3E8 )
  {
    if ( !sigdigits )
    {
      snprintf(buf, bufsiz, "%d%s", (_DWORD)val, suffix);
      return;
    }
  }
  else
  {
    strcpy(suffix, "K");
    v7 = v7 / 1000.0;
    if ( !sigdigits )
      goto LABEL_4;
  }
LABEL_9:
  if ( v7 > 0.0 )
  {
    v9 = log10(*(double *)&val);
    floor(v9);
    v8 = (int)(3.0 - v7);
  }
  else
  {
    v8 = 3;
  }
  snprintf(buf, bufsiz, "%*.*f%s", sigdigits + 1, v8, v7, suffix);
}

//----- (00016810) --------------------------------------------------------
char *__fastcall set_logfile_path(const char *arg)
{
  opt_set_charp(arg, &opt_logfile_path);
  return 0;
}

//----- (00016824) --------------------------------------------------------
char *__fastcall set_logwork_asicnum(const char *arg)
{
  opt_set_charp(arg, &opt_logwork_asicnum);
  return 0;
}

//----- (00016834) --------------------------------------------------------
char *__fastcall set_logwork_path(const char *arg)
{
  opt_set_charp(arg, &opt_logwork_path);
  return 0;
}

//----- (00016844) --------------------------------------------------------
char *__fastcall set_logfile_openflag(const char *arg)
{
  opt_set_charp(arg, &opt_logfile_openflag);
  return 0;
}

//----- (00016854) --------------------------------------------------------
char *__fastcall set_version_path(const char *arg)
{
  opt_set_charp(arg, &opt_version_path);
  return 0;
}

//----- (00016864) --------------------------------------------------------
char *__fastcall set_default_config(const char *arg)
{
  opt_set_charp(arg, &default_config);
  return 0;
}

//----- (00016874) --------------------------------------------------------
char *__fastcall set_sharelog(char *arg)
{
  int v2; // r0
  bool v3; // zf
  int v5; // r5
  char *r; // [sp+4h] [bp-1008h] BYREF
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  r = &byte_59398;
  v2 = strtol(arg, &r, 10);
  v3 = v2 == 0;
  if ( v2 >= 0 )
    v3 = *r == 0;
  if ( v3 )
  {
    v5 = v2;
    sharelog_file = fdopen(v2, "a");
    if ( sharelog_file || !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(tmp42, 0x1000u, "Failed to open fd %u for share log", v5);
    goto LABEL_12;
  }
  if ( *arg != 45 || arg[1] )
  {
    sharelog_file = fopen(arg, "a");
    if ( sharelog_file || !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(tmp42, 0x1000u, "Failed to open %s for share log", arg);
LABEL_12:
    applog(3, tmp42, 0);
    return 0;
  }
  sharelog_file = (FILE *)stdout;
  if ( stdout || !use_syslog && !opt_log_output && opt_log_level <= 2 )
    return 0;
  strcpy(tmp42, "Standard output missing for share log");
  applog(3, tmp42, 0);
  return 0;
}
// 59398: using guessed type char byte_59398;
// 6D854: using guessed type int stdout;

//----- (000169DC) --------------------------------------------------------
char *__fastcall json_escape(char *str)
{
  char *v1; // r4
  size_t v2; // r0
  char *v3; // r5
  JE *v4; // r0
  int v5; // r3
  JE *v6; // r1
  char *v7; // r1
  char *v8; // r2
  bool v9; // zf
  char *v10; // r0
  int v11; // t1

  v1 = str;
  v2 = strlen(str);
  v3 = (char *)malloc(2 * v2 + 1);
  v4 = (JE *)malloc(8u);
  v5 = (unsigned __int8)*v1;
  v4->buf = v3;
  v6 = jedata;
  jedata = v4;
  v4->next = v6;
  v7 = v3;
  if ( v5 )
  {
    do
    {
      v8 = v7 + 1;
      v9 = v5 == 34;
      if ( v5 != 34 )
        v9 = v5 == 92;
      v10 = v7 + 1;
      if ( v9 )
      {
        *v7 = 92;
        v7 += 2;
      }
      else
      {
        v8 = v7;
      }
      if ( !v9 )
        v7 = v10;
      *v8 = v5;
      v11 = (unsigned __int8)*++v1;
      v5 = v11;
    }
    while ( v11 );
  }
  *v7 = 0;
  return v3;
}

//----- (00016A34) --------------------------------------------------------
void __fastcall thread_reportout(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 1;
  cgtime(&thr->last);
  thr->cgpu->status = alive::LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00016A58) --------------------------------------------------------
void __fastcall thread_reportin(thr_info *thr)
{
  cgpu_info *cgpu; // r4

  thr->getwork = 0;
  cgtime(&thr->last);
  thr->cgpu->status = alive::LIFE_WELL;
  cgpu = thr->cgpu;
  cgpu->device_last_well = time(0);
}

//----- (00016A7C) --------------------------------------------------------
void __fastcall regen_hash(work *work)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r2
  unsigned int v3; // t1
  unsigned __int8 *hash; // r5
  char *v5; // r0
  char *v6; // r4
  unsigned __int8 hash1[32]; // [sp+0h] [bp-1074h] BYREF
  unsigned __int8 swap[80]; // [sp+20h] [bp-1054h] BYREF
  char tmp42[4100]; // [sp+70h] [bp-1004h] BYREF

  v1 = &work[-1].device_target[35];
  v2 = &hash1[28];
  do
  {
    v3 = *((_DWORD *)v1 + 1);
    v1 += 4;
    *((_DWORD *)v2 + 1) = bswap32(v3);
    v2 += 4;
  }
  while ( v2 != &swap[76] );
  hash = work->hash;
  sha256(swap, 0x50u, hash1);
  sha256(hash1, 0x20u, hash);
  v5 = bin2hex(hash, 0x20u);
  v6 = v5;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "regen:%s", v5);
    applog(5, tmp42, 0);
    free(v6);
  }
  else
  {
    free(v5);
  }
}

//----- (00016B20) --------------------------------------------------------
void *__fastcall submit_work_thread(void *userdata)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  return 0;
}

//----- (00016B30) --------------------------------------------------------
void *__fastcall miner_thread(void *userdata)
{
  cgpu_info *v1; // r8
  device_drv *drv; // r7
  char threadname[16]; // [sp+0h] [bp-1010h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  v1 = (cgpu_info *)*((_DWORD *)userdata + 9);
  drv = v1->drv;
  snprintf(threadname, 0x10u, "%d/Miner", *(_DWORD *)userdata);
  RenameThread(threadname);
  thread_reportout((thr_info *)userdata);
  if ( ((int (__fastcall *)(void *))drv->thread_init)(userdata) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42, "Waiting on sem in miner thread");
      applog(7, tmp42, 0);
    }
    cgsem_wait((cgsem_t *)userdata + 1, "cgminer.c", "miner_thread", 9147);
    v1->last_device_valid_work = time(0);
    drv->hash_work((thr_info *)userdata);
    drv->thread_shutdown((thr_info *)userdata);
    return 0;
  }
  else
  {
    dev_error(v1, dev_reason::REASON_THREAD_FAIL_INIT);
    return 0;
  }
}

//----- (00016C1C) --------------------------------------------------------
void *__fastcall __noreturn killall_thread(void *arg)
{
  pthread_t v1; // r0

  v1 = pthread_self();
  pthread_detach(v1);
  pthread_setcanceltype(1, 0);
  sleep(5u);
  exit(1);
}

//----- (00016C3C) --------------------------------------------------------
void __fastcall calc_diff(work *work, double known)
{
  double v3; // d0
  pool *pool; // r4
  double *p_work_difficulty; // r6
  int v7; // r0
  double v8; // d8
  double min_diff; // d7
  double max_diff; // d7
  double v11; // d9
  unsigned __int64 v12; // r0
  double v13; // d8

  pool = work->pool;
  if ( v3 == 0.0 )
  {
    v11 = 65536.0;
    p_work_difficulty = &work->work_difficulty;
    v12 = *(_QWORD *)&work->target[24];
    if ( !opt_scrypt )
      v11 = 2.69595353e67;
    v13 = (double)*(unsigned __int64 *)work->target
        + (double)v12 * 6.27710174e57
        + (double)*(unsigned __int64 *)&work->target[16] * 3.40282367e38
        + (double)*(unsigned __int64 *)&work->target[8] * 1.84467441e19;
    if ( v13 != 0.0 )
      v11 = v11 / v13;
    *p_work_difficulty = v11;
  }
  else
  {
    p_work_difficulty = &work->work_difficulty;
    work->work_difficulty = v3;
  }
  v7 = target_zero_cal(work->target);
  v8 = (double)v7;
  *p_work_difficulty = (double)v7;
  pool->cgminer_pool_stats.last_diff = (double)v7;
  suffix_string(v7, work->pool->diff, 8u, 0);
  min_diff = pool->cgminer_pool_stats.min_diff;
  if ( v8 == min_diff )
  {
    ++pool->cgminer_pool_stats.min_diff_count;
    goto LABEL_5;
  }
  if ( v8 >= min_diff )
  {
    if ( min_diff != 0.0 )
    {
LABEL_5:
      max_diff = pool->cgminer_pool_stats.max_diff;
      if ( v8 != max_diff )
        goto LABEL_6;
LABEL_12:
      ++pool->cgminer_pool_stats.max_diff_count;
      return;
    }
    pool->cgminer_pool_stats.min_diff = v8;
    pool->cgminer_pool_stats.min_diff_count = 1;
  }
  else
  {
    pool->cgminer_pool_stats.min_diff = v8;
    pool->cgminer_pool_stats.min_diff_count = 1;
  }
  max_diff = pool->cgminer_pool_stats.max_diff;
  if ( v8 == max_diff )
    goto LABEL_12;
LABEL_6:
  if ( v8 > max_diff )
  {
    pool->cgminer_pool_stats.max_diff = v8;
    pool->cgminer_pool_stats.max_diff_count = 1;
  }
}
// 16C52: variable 'v3' is possibly undefined

//----- (00016DB8) --------------------------------------------------------
void __noreturn applog_and_exit(const char *a1, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, a1);
  vsnprintf(exit_buf, 0x200u, a1, varg_r1);
  applog(3, exit_buf, 1);
  exit(1);
}

//----- (00016DE8) --------------------------------------------------------
void __fastcall __noreturn opt_verusage_and_exit(const char *a1)
{
  char *v2; // r0

  printf("%s\nBuilt with bitmain_zcash mining support.\n", packagename);
  v2 = opt_usage(opt_argv0, a1);
  printf("%s", v2);
  fflush((FILE *)stdout);
  exit(0);
}
// 6D854: using guessed type int stdout;

//----- (00016E30) --------------------------------------------------------
// Alternative name is 'enable_pool.isra.2.part.3'
void __fastcall enable_pool(pool *pool)
{
  ++enabled_pools;
  pool->pool_no = 1;
}

//----- (00016E44) --------------------------------------------------------
// Alternative name is 'priority_pool.part.11'
pool *__fastcall priority_pool_0(int choice)
{
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "WTF No pool %d found!", choice);
    applog(3, tmp42, 0);
  }
  return pools[choice];
}

//----- (00016EA8) --------------------------------------------------------
pool *__fastcall priority_pool(int choice)
{
  pool **v1; // r2
  pool *v2; // r1
  int v3; // r3
  pool *v4; // t1

  if ( total_pools <= 0 )
    return priority_pool_0(choice);
  v1 = pools;
  v2 = *pools;
  if ( (*pools)->prio != choice )
  {
    v3 = 0;
    while ( ++v3 != total_pools )
    {
      v4 = v1[1];
      ++v1;
      v2 = v4;
      if ( v4->prio == choice )
        return v2;
    }
    return priority_pool_0(choice);
  }
  return v2;
}

//----- (00016EE8) --------------------------------------------------------
// Alternative name is 'new_nonce.isra.12'
int __fastcall new_nonce(thr_info *thr, __time_t nonce)
{
  int result; // r0
  char tmp42[4096]; // [sp+8h] [bp-1008h] BYREF

  if ( thr[3].last.tv_sec == nonce )
  {
    result = opt_debug;
    if ( opt_debug && (use_syslog || (result = opt_log_output) != 0 || opt_log_level > 6) )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s %d duplicate share detected as HW error",
        *(const char **)(thr->device_thread + 8),
        *(_DWORD *)&thr->primary_thread);
      applog(7, tmp42, 0);
      return 0;
    }
  }
  else
  {
    thr[3].last.tv_sec = nonce;
    return 1;
  }
  return result;
}

//----- (00016F64) --------------------------------------------------------
char *__fastcall set_sched_start(const char *arg)
{
  if ( sscanf(arg, "%d:%d", &schedstart.tm.tm_hour, &schedstart.tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( schedstart.tm.tm_hour > 0x17u || schedstart.tm.tm_min > 0x3Bu )
    return "Invalid time set.";
  schedstart.enable = 1;
  return 0;
}

//----- (00016FB0) --------------------------------------------------------
// Alternative name is 'should_run.part.15'
int should_run()
{
  struct tm *v0; // r0
  _BOOL4 enable; // r4
  _BOOL4 v2; // lr
  __int64 v3; // kr00_8
  int tm_hour; // r4
  _BOOL4 v7; // lr
  _BOOL4 v8; // r1
  _BOOL4 v9; // r7
  _BOOL4 v10; // r2
  time_t tmp_time; // [sp+4h] [bp-10h] BYREF
  timeval tv; // [sp+8h] [bp-Ch] BYREF

  cgtime(&tv);
  tmp_time = tv.tv_sec;
  v0 = localtime(&tmp_time);
  enable = schedstart.enable;
  if ( schedstart.enable )
  {
    v2 = schedstop.enable;
    v3 = *(_QWORD *)&v0->tm_min;
    if ( schedstop.enable )
    {
      if ( schedstop.tm.tm_hour > schedstart.tm.tm_hour
        || (schedstop.tm.tm_min > schedstart.tm.tm_min ? (v8 = schedstop.tm.tm_hour == schedstart.tm.tm_hour) : (v8 = 0),
            v8) )
      {
        if ( schedstop.tm.tm_hour > SHIDWORD(v3)
          || (schedstop.tm.tm_min > (int)v3 ? (v2 = schedstop.tm.tm_hour == HIDWORD(v3)) : (v2 = 0), v2) )
        {
          if ( schedstart.tm.tm_hour <= SHIDWORD(v3) )
          {
            v10 = schedstart.tm.tm_min > (int)v3 && schedstart.tm.tm_hour == HIDWORD(v3);
            return !v10;
          }
          else
          {
            return 0;
          }
        }
      }
      else if ( schedstart.tm.tm_hour > SHIDWORD(v3)
             || (schedstart.tm.tm_min > (int)v3 ? (v9 = schedstart.tm.tm_hour == HIDWORD(v3)) : (v9 = 0), v9) )
      {
        if ( schedstop.tm.tm_hour <= SHIDWORD(v3) )
          return schedstop.tm.tm_min > (int)v3 && schedstop.tm.tm_hour == HIDWORD(v3);
      }
    }
    else if ( schedstart.tm.tm_hour <= SHIDWORD(v3)
           && (schedstart.tm.tm_min <= (int)v3 || schedstart.tm.tm_hour != HIDWORD(v3)) )
    {
      schedstart.enable = schedstop.enable;
      return enable;
    }
    return v2;
  }
  tm_hour = v0->tm_hour;
  if ( tm_hour < schedstop.tm.tm_hour )
    return 1;
  v7 = v0->tm_min < schedstop.tm.tm_min;
  if ( tm_hour != schedstop.tm.tm_hour )
    return 0;
  return v7;
}
// 16FFC: masking with 0x1 was optimized away because r1.4 <= 0x1
// 1706C: masking with 0x1 was optimized away because r1.4 <= 0x1

//----- (000170C8) --------------------------------------------------------
char *__fastcall set_float_100_to_250(const char *arg, float *i)
{
  char *result; // r0

  result = opt_set_floatval(arg, i);
  if ( !result )
  {
    if ( *i >= 100.0 )
    {
      if ( *i > 250.0 )
        return "Value out of range";
    }
    else
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (00017114) --------------------------------------------------------
char *__fastcall set_float_125_to_500(const char *arg, float *i)
{
  char *result; // r0

  result = opt_set_floatval(arg, i);
  if ( !result )
  {
    if ( *i >= 125.0 )
    {
      if ( *i > 500.0 )
        return "Value out of range";
    }
    else
    {
      return "Value out of range";
    }
  }
  return result;
}

//----- (00017160) --------------------------------------------------------
// Alternative name is 'mt_disable.isra.19'
void __fastcall mt_disable(thr_info *mythr, int thr_id, device_drv *drv)
{
  _BOOL4 v6; // r3
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "Thread %d being disabled", thr_id);
    applog(4, tmp42, 0);
  }
  v6 = opt_debug;
  mythr->cgpu->rolling = 0.0;
  if ( v6 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Waiting on sem in miner thread");
    applog(7, tmp42, 0);
  }
  cgsem_wait(&mythr->sem, "cgminer.c", "mt_disable", 8561);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "Thread %d being re-enabled", thr_id);
    applog(4, tmp42, 0);
  }
  ((void (__fastcall *)(thr_info *))drv->drv_id)(mythr);
}

//----- (00017280) --------------------------------------------------------
// Alternative name is 'set_lowprio.part.20'
void set_lowprio_0()
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(tmp42, "Unable to set thread to low priority");
  applog(7, tmp42, 0);
}

//----- (000172B8) --------------------------------------------------------
void set_lowprio()
{
  if ( !nice(10) && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    set_lowprio_0();
}

//----- (000172FC) --------------------------------------------------------
void *__fastcall api_thread(void *userdata)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  RenameThread("API");
  set_lowprio();
  api(api_thr_id);
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (00017338) --------------------------------------------------------
char *__fastcall set_int_42_to_65(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)(*i - 42) > 0x14 )
    return "Value out of range";
  return result;
}

//----- (00017358) --------------------------------------------------------
char *__fastcall set_int_22_to_55(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)(*i - 22) > 0x21 )
    return "Value out of range";
  return result;
}

//----- (00017378) --------------------------------------------------------
char *__fastcall set_int_32_to_63(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)(*i - 32) > 0x1F )
    return "Value out of range";
  return result;
}

//----- (00017398) --------------------------------------------------------
char *__fastcall set_int_0_to_4(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)*i > 4 )
    return "Value out of range";
  return result;
}

//----- (000173B8) --------------------------------------------------------
char *__fastcall set_int_0_to_200(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)*i > 0xC8 )
    return "Value out of range";
  return result;
}

//----- (000173D8) --------------------------------------------------------
char *__fastcall set_int_0_to_255(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)*i > 0xFF )
    return "Value out of range";
  return result;
}

//----- (000173F8) --------------------------------------------------------
char *__fastcall set_int_0_to_100(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)*i > 0x64 )
    return "Value out of range";
  return result;
}

//----- (00017418) --------------------------------------------------------
char *__fastcall set_int_1_to_10(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)(*i - 1) > 9 )
    return "Value out of range";
  return result;
}

//----- (00017438) --------------------------------------------------------
char *__fastcall set_int_0_to_10(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)*i > 0xA )
    return "Value out of range";
  return result;
}

//----- (00017458) --------------------------------------------------------
char *__fastcall set_int_1_to_65535(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)(*i - 1) > 0xFFFE )
    return "Value out of range";
  return result;
}

//----- (0001747C) --------------------------------------------------------
char *__fastcall set_int_0_to_9999(const char *arg, int *i)
{
  char *result; // r0

  result = opt_set_intval(arg, i);
  if ( !result && (unsigned int)*i > 0x270F )
    return "Value out of range";
  return result;
}

//----- (000174A0) --------------------------------------------------------
char *__fastcall set_rotate(const char *arg, char *i)
{
  char *result; // r0

  pool_strategy_0 = pool_strategy::POOL_ROTATE;
  result = opt_set_intval(arg, &opt_rotate_period);
  if ( !result && (unsigned int)opt_rotate_period > 0x270F )
    return "Value out of range";
  return result;
}

//----- (000174D8) --------------------------------------------------------
// Alternative name is 'decay_time.part.34'
void __fastcall decay_time_0(double f, double fadd, double fsecs, double interval)
{
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double *v7; // r4

  v7 = (double *)LODWORD(f);
  exp(f);
  *v7 = (*v7 + v4 / v5 * (1.0 - 1.0 / (v5 / v6))) / (1.0 - 1.0 / (v5 / v6) + 1.0);
}
// 174F4: variable 'v4' is possibly undefined
// 174F4: variable 'v5' is possibly undefined
// 174E4: variable 'v6' is possibly undefined

//----- (0001751C) --------------------------------------------------------
// Alternative name is 'flush_queue.part.38'
void __fastcall flush_queue_0(cgpu_info *cgpu)
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(tmp42, "Discarded queued work item");
  applog(7, tmp42, 0);
}

//----- (00017554) --------------------------------------------------------
// Alternative name is 'submit_tested_work.part.54'
int __fastcall submit_tested_work_0(thr_info *thr, work *work)
{
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  snprintf(
    tmp42,
    0x1000u,
    "%s %s %d: Share above target",
    "submit_tested_work",
    thr->cgpu->drv->name,
    thr->cgpu->device_id);
  applog(7, tmp42, 0);
  return 0;
}

//----- (0001759C) --------------------------------------------------------
int noop_thread_prepare()
{
  return 1;
}

//----- (000175A0) --------------------------------------------------------
int noop_thread_init()
{
  return 1;
}

//----- (000175B0) --------------------------------------------------------
pool *__fastcall select_balanced(pool *cp)
{
  int shares; // r5
  pool *v2; // r4
  pool **v3; // r2
  pool *v4; // r3
  pool *v5; // t1

  shares = cp->shares;
  if ( total_pools > 0 )
  {
    v2 = cp;
    v3 = pools;
    do
    {
      v5 = *v3++;
      v4 = v5;
      if ( !v5->idle
        && v4->enabled == pool_enable::POOL_ENABLED
        && (!v4->has_stratum || v4->stratum_active)
        && v4->shares < shares )
      {
        v2 = v4;
        shares = v4->shares;
      }
    }
    while ( v3 != &pools[total_pools] );
    shares = v2->shares;
  }
  else
  {
    v2 = cp;
  }
  v2->shares = shares + 1;
  return v2;
}

//----- (00017618) --------------------------------------------------------
char *__fastcall set_sched_stop(const char *arg)
{
  if ( sscanf(arg, "%d:%d", &schedstop.tm.tm_hour, &schedstop.tm.tm_min) != 2 )
    return "Invalid time set, should be HH:MM";
  if ( schedstop.tm.tm_hour > 0x17u || schedstop.tm.tm_min > 0x3Bu )
    return "Invalid time set.";
  schedstop.enable = 1;
  return 0;
}

//----- (00017664) --------------------------------------------------------
void __fastcall scrypt_1024_1_1_256_sp(const uint32_t *input, char *scratchpad, uint32_t *ostate)
{
  int *v3; // r6
  int v4; // r1
  int v5; // r2
  int v6; // r3
  int *v7; // r7
  int *v8; // r8
  int *v9; // r4
  int v10; // t1
  __int64 v11; // r2
  unsigned int v12; // r0
  int *v13; // lr
  unsigned int v14; // r1
  unsigned int v15; // r3
  _DWORD *i; // r0
  unsigned int v17; // t1
  int v18; // t1
  int v19; // r7
  uint32_t *v20; // r8
  uint32_t *v21; // r2
  uint32_t *v22; // r1
  unsigned int v23; // t1
  int v24; // r7
  int v25; // r10
  int v26; // r0
  int v27; // r9
  int v28; // r12
  int v29; // r11
  int v30; // r3
  int v31; // lr
  int v32; // r2
  int v33; // r1
  int v34; // r4
  int v35; // r8
  int v36; // r7
  int v37; // r6
  int v38; // r5
  int v39; // r4
  int v40; // r10
  int v41; // r9
  int v42; // r3
  int v43; // r3
  int v44; // r12
  int v45; // r0
  int v46; // r2
  int v47; // r1
  int v48; // r11
  int v49; // r5
  int v50; // r6
  int v51; // r7
  uint32_t v52; // r1
  int v53; // r2
  int v54; // r10
  int v55; // lr
  int v56; // r3
  int v57; // r7
  int v58; // r11
  int v59; // r9
  int v60; // r12
  int v61; // r0
  int v62; // r5
  int v63; // r2
  int v64; // r8
  int v65; // r4
  int v66; // r6
  int v67; // r9
  int v68; // r10
  int v69; // r0
  int v70; // r3
  int v71; // r12
  int v72; // r7
  int v73; // r4
  int v74; // r11
  int v75; // r2
  int v76; // r6
  int v77; // r1
  int v78; // r10
  int v79; // r9
  int v80; // r1
  int v81; // r11
  int v82; // r2
  int v83; // r3
  int v84; // r12
  int v85; // r4
  int v86; // r0
  int v87; // lr
  int v88; // r8
  int v89; // r7
  int v90; // r6
  int v91; // r5
  int v92; // r4
  int v93; // r10
  int v94; // r9
  int v95; // r3
  int v96; // r3
  int v97; // r12
  int v98; // r0
  int v99; // r2
  int v100; // r1
  int v101; // r11
  int v102; // r5
  int v103; // r6
  int v104; // r7
  uint32_t v105; // r6
  int v106; // r2
  int v107; // r7
  int v108; // r10
  int v109; // lr
  int v110; // r3
  int v111; // r7
  int v112; // r11
  int v113; // r9
  int v114; // r12
  int v115; // r0
  int v116; // r5
  int v117; // r2
  int v118; // r8
  int v119; // r4
  int v120; // r6
  int v121; // r9
  int v122; // r10
  int v123; // r0
  int v124; // r3
  int v125; // r12
  int v126; // r7
  int v127; // r4
  int v128; // r11
  int v129; // r2
  int v130; // r6
  int v131; // r1
  __int16 v132; // r4
  uint32_t *v133; // r11
  int v134; // r4
  uint32_t v135; // r2
  int v136; // r0
  int v137; // r1
  int v138; // r3
  uint32_t v139; // r10
  uint32_t v140; // lr
  uint32_t v141; // r4
  uint32_t v142; // r9
  uint32_t v143; // r8
  uint32_t v144; // r12
  uint32_t v145; // r7
  uint32_t v146; // r2
  uint32_t v147; // r3
  uint32_t v148; // r6
  int v149; // lr
  int v150; // r12
  int v151; // r9
  int v152; // r11
  int v153; // r10
  int v154; // r2
  int v155; // r7
  int v156; // r3
  int v157; // r5
  int v158; // r12
  int v159; // r4
  int v160; // r3
  int v161; // r1
  int v162; // r0
  uint32_t v163; // lr
  int v164; // r9
  int v165; // r10
  int v166; // r8
  uint32_t v167; // r12
  int v168; // r3
  int v169; // r4
  uint32_t v170; // r2
  int v171; // r7
  int v172; // r5
  int v173; // lr
  int v174; // r7
  int v175; // r12
  int v176; // r9
  int v177; // r8
  int v178; // r10
  int v179; // r11
  int v180; // r5
  int v181; // r3
  int v182; // lr
  int v183; // r1
  int v184; // r4
  int v185; // r7
  int v186; // r2
  int v187; // r6
  int v188; // r0
  int v189; // r4
  int v190; // r6
  uint32_t *v191; // r1
  uint32_t v192; // r0
  uint32_t v193; // r2
  int v194; // r5
  int v195; // r4
  int v196; // r3
  uint32_t v197; // r10
  uint32_t v198; // r8
  uint32_t v199; // lr
  uint32_t v200; // r9
  uint32_t v201; // r12
  uint32_t v202; // r1
  uint32_t v203; // r11
  uint32_t v204; // r2
  uint32_t v205; // r3
  uint32_t v206; // r6
  int v207; // r8
  int v208; // r9
  int v209; // r4
  int v210; // lr
  int v211; // r11
  int v212; // r10
  int v213; // r5
  int v214; // r3
  int v215; // r7
  int v216; // r1
  int v217; // r5
  int v218; // r3
  int v219; // r0
  int v220; // r4
  uint32_t v221; // r8
  uint32_t v222; // lr
  uint32_t v223; // r2
  uint32_t v224; // r6
  int v225; // r12
  uint32_t v226; // r4
  uint32_t v227; // r5
  int v228; // r9
  int v229; // r10
  uint32_t v230; // r0
  uint32_t v231; // r11
  uint32_t v232; // r3
  uint32_t v233; // r2
  uint32_t v234; // r6
  uint32_t v235; // r7
  int v236; // r8
  int v237; // lr
  int v238; // r5
  int v239; // r0
  int v240; // r9
  int v241; // r10
  int v242; // r12
  int v243; // r6
  int v244; // r7
  int v245; // r2
  int v246; // r11
  int v247; // r5
  int v248; // r4
  bool v249; // zf
  char *v250; // r8
  int *v251; // r6
  int *v252; // r5
  uint32_t v253; // r1
  uint32_t v254; // r2
  uint32_t v255; // r3
  char *v256; // r12
  uint32_t v257; // r0
  int v258; // r1
  int v259; // r2
  int v260; // r3
  int v261; // r0
  int v262; // r1
  int v263; // r2
  int v264; // r3
  int v265; // t1
  int v266; // t1
  int v267; // [sp+0h] [bp-160h]
  int v268; // [sp+0h] [bp-160h]
  int v269; // [sp+0h] [bp-160h]
  int v270; // [sp+0h] [bp-160h]
  int v271; // [sp+0h] [bp-160h]
  int v272; // [sp+0h] [bp-160h]
  int v273; // [sp+0h] [bp-160h]
  int v274; // [sp+0h] [bp-160h]
  uint32_t v275; // [sp+0h] [bp-160h]
  int v276; // [sp+0h] [bp-160h]
  uint32_t v277; // [sp+0h] [bp-160h]
  int v278; // [sp+0h] [bp-160h]
  int v279; // [sp+4h] [bp-15Ch]
  int v280; // [sp+4h] [bp-15Ch]
  int v281; // [sp+4h] [bp-15Ch]
  int v282; // [sp+4h] [bp-15Ch]
  int v283; // [sp+4h] [bp-15Ch]
  int v284; // [sp+4h] [bp-15Ch]
  int v285; // [sp+4h] [bp-15Ch]
  uint32_t v286; // [sp+4h] [bp-15Ch]
  int v287; // [sp+4h] [bp-15Ch]
  uint32_t v288; // [sp+4h] [bp-15Ch]
  int v289; // [sp+4h] [bp-15Ch]
  int v290; // [sp+8h] [bp-158h]
  int v291; // [sp+8h] [bp-158h]
  int v292; // [sp+8h] [bp-158h]
  int v293; // [sp+8h] [bp-158h]
  int v294; // [sp+8h] [bp-158h]
  int v295; // [sp+8h] [bp-158h]
  uint32_t v296; // [sp+8h] [bp-158h]
  int v297; // [sp+8h] [bp-158h]
  uint32_t v298; // [sp+8h] [bp-158h]
  int v299; // [sp+8h] [bp-158h]
  int v300; // [sp+Ch] [bp-154h]
  int v301; // [sp+Ch] [bp-154h]
  int v302; // [sp+Ch] [bp-154h]
  int v303; // [sp+Ch] [bp-154h]
  uint32_t v304; // [sp+Ch] [bp-154h]
  uint32_t v305; // [sp+Ch] [bp-154h]
  uint32_t v306; // [sp+Ch] [bp-154h]
  int v307; // [sp+Ch] [bp-154h]
  int v308; // [sp+10h] [bp-150h]
  int v309; // [sp+10h] [bp-150h]
  int v310; // [sp+10h] [bp-150h]
  int v311; // [sp+10h] [bp-150h]
  int v312; // [sp+10h] [bp-150h]
  int v313; // [sp+10h] [bp-150h]
  uint32_t v314; // [sp+10h] [bp-150h]
  int v315; // [sp+10h] [bp-150h]
  int v316; // [sp+10h] [bp-150h]
  uint32_t v317; // [sp+10h] [bp-150h]
  int v318; // [sp+10h] [bp-150h]
  int v319; // [sp+14h] [bp-14Ch]
  int v320; // [sp+14h] [bp-14Ch]
  int v321; // [sp+14h] [bp-14Ch]
  int v322; // [sp+14h] [bp-14Ch]
  int v323; // [sp+14h] [bp-14Ch]
  uint32_t v324; // [sp+14h] [bp-14Ch]
  uint32_t v325; // [sp+14h] [bp-14Ch]
  int v326; // [sp+14h] [bp-14Ch]
  int v327; // [sp+18h] [bp-148h]
  int v328; // [sp+18h] [bp-148h]
  int v329; // [sp+18h] [bp-148h]
  int v330; // [sp+18h] [bp-148h]
  uint32_t v331; // [sp+18h] [bp-148h]
  int v332; // [sp+18h] [bp-148h]
  int v333; // [sp+18h] [bp-148h]
  int v334; // [sp+18h] [bp-148h]
  int v335; // [sp+1Ch] [bp-144h]
  int v336; // [sp+1Ch] [bp-144h]
  int v337; // [sp+1Ch] [bp-144h]
  int v338; // [sp+1Ch] [bp-144h]
  int v339; // [sp+1Ch] [bp-144h]
  int v340; // [sp+1Ch] [bp-144h]
  int v341; // [sp+1Ch] [bp-144h]
  int v342; // [sp+1Ch] [bp-144h]
  int v343; // [sp+20h] [bp-140h]
  int v344; // [sp+20h] [bp-140h]
  int v345; // [sp+20h] [bp-140h]
  int v346; // [sp+20h] [bp-140h]
  int v347; // [sp+20h] [bp-140h]
  int v348; // [sp+20h] [bp-140h]
  int v349; // [sp+20h] [bp-140h]
  int v350; // [sp+24h] [bp-13Ch]
  int v351; // [sp+24h] [bp-13Ch]
  int v352; // [sp+24h] [bp-13Ch]
  int v353; // [sp+24h] [bp-13Ch]
  int v354; // [sp+24h] [bp-13Ch]
  int v355; // [sp+24h] [bp-13Ch]
  int v356; // [sp+24h] [bp-13Ch]
  int v357; // [sp+24h] [bp-13Ch]
  uint32_t *dest; // [sp+28h] [bp-138h]
  int desta; // [sp+28h] [bp-138h]
  void *destb; // [sp+28h] [bp-138h]
  int destc; // [sp+28h] [bp-138h]
  int destd; // [sp+28h] [bp-138h]
  uint32_t v363; // [sp+2Ch] [bp-134h]
  int v364; // [sp+2Ch] [bp-134h]
  int v365; // [sp+2Ch] [bp-134h]
  uint32_t v366; // [sp+2Ch] [bp-134h]
  int v367; // [sp+2Ch] [bp-134h]
  int v368; // [sp+2Ch] [bp-134h]
  uint32_t v369; // [sp+30h] [bp-130h]
  int v370; // [sp+30h] [bp-130h]
  uint32_t v371; // [sp+30h] [bp-130h]
  int v372; // [sp+30h] [bp-130h]
  uint32_t v373; // [sp+30h] [bp-130h]
  uint32_t v374; // [sp+30h] [bp-130h]
  uint32_t v375; // [sp+34h] [bp-12Ch]
  int v376; // [sp+34h] [bp-12Ch]
  uint32_t v377; // [sp+34h] [bp-12Ch]
  int v378; // [sp+34h] [bp-12Ch]
  uint32_t v379; // [sp+34h] [bp-12Ch]
  uint32_t v380; // [sp+34h] [bp-12Ch]
  uint32_t v381; // [sp+34h] [bp-12Ch]
  uint32_t v382; // [sp+38h] [bp-128h]
  int v383; // [sp+38h] [bp-128h]
  uint32_t v384; // [sp+38h] [bp-128h]
  int v385; // [sp+38h] [bp-128h]
  uint32_t v386; // [sp+38h] [bp-128h]
  uint32_t v387; // [sp+38h] [bp-128h]
  uint32_t v388; // [sp+38h] [bp-128h]
  uint32_t v389; // [sp+3Ch] [bp-124h]
  int v390; // [sp+3Ch] [bp-124h]
  uint32_t v391; // [sp+3Ch] [bp-124h]
  int v392; // [sp+3Ch] [bp-124h]
  uint32_t v393; // [sp+3Ch] [bp-124h]
  uint32_t v394; // [sp+3Ch] [bp-124h]
  uint32_t v395; // [sp+3Ch] [bp-124h]
  uint32_t v396; // [sp+40h] [bp-120h]
  int v397; // [sp+40h] [bp-120h]
  int v398; // [sp+40h] [bp-120h]
  uint32_t v399; // [sp+40h] [bp-120h]
  uint32_t v400; // [sp+40h] [bp-120h]
  uint32_t v401; // [sp+40h] [bp-120h]
  uint32_t v402; // [sp+44h] [bp-11Ch]
  int v403; // [sp+44h] [bp-11Ch]
  int v404; // [sp+44h] [bp-11Ch]
  uint32_t v405; // [sp+44h] [bp-11Ch]
  uint32_t v406; // [sp+44h] [bp-11Ch]
  uint32_t v407; // [sp+48h] [bp-118h]
  int v408; // [sp+48h] [bp-118h]
  int v409; // [sp+48h] [bp-118h]
  uint32_t v410; // [sp+48h] [bp-118h]
  uint32_t v411; // [sp+48h] [bp-118h]
  uint32_t v412; // [sp+4Ch] [bp-114h]
  int v413; // [sp+4Ch] [bp-114h]
  int v414; // [sp+4Ch] [bp-114h]
  uint32_t v415; // [sp+4Ch] [bp-114h]
  uint32_t v416; // [sp+4Ch] [bp-114h]
  uint32_t v417; // [sp+50h] [bp-110h]
  int v418; // [sp+50h] [bp-110h]
  uint32_t v419; // [sp+50h] [bp-110h]
  int v420; // [sp+50h] [bp-110h]
  uint32_t v421; // [sp+50h] [bp-110h]
  uint32_t v422; // [sp+50h] [bp-110h]
  uint32_t v423; // [sp+54h] [bp-10Ch]
  int v424; // [sp+54h] [bp-10Ch]
  uint32_t v425; // [sp+54h] [bp-10Ch]
  int v426; // [sp+54h] [bp-10Ch]
  int v427; // [sp+54h] [bp-10Ch]
  uint32_t v428; // [sp+58h] [bp-108h]
  int v429; // [sp+58h] [bp-108h]
  uint32_t v430; // [sp+58h] [bp-108h]
  int v431; // [sp+58h] [bp-108h]
  int v432; // [sp+58h] [bp-108h]
  uint32_t v433; // [sp+5Ch] [bp-104h]
  int v434; // [sp+5Ch] [bp-104h]
  uint32_t v435; // [sp+5Ch] [bp-104h]
  int v436; // [sp+5Ch] [bp-104h]
  uint32_t v437; // [sp+5Ch] [bp-104h]
  uint32_t v438; // [sp+5Ch] [bp-104h]
  uint32_t v439; // [sp+60h] [bp-100h]
  int v440; // [sp+60h] [bp-100h]
  uint32_t v441; // [sp+60h] [bp-100h]
  int v442; // [sp+60h] [bp-100h]
  uint32_t v443; // [sp+60h] [bp-100h]
  uint32_t v444; // [sp+64h] [bp-FCh]
  int v445; // [sp+64h] [bp-FCh]
  uint32_t v446; // [sp+64h] [bp-FCh]
  int v447; // [sp+64h] [bp-FCh]
  uint32_t v448; // [sp+64h] [bp-FCh]
  uint32_t v449; // [sp+64h] [bp-FCh]
  uint32_t v450; // [sp+64h] [bp-FCh]
  uint32_t v451; // [sp+68h] [bp-F8h]
  int v452; // [sp+68h] [bp-F8h]
  uint32_t v453; // [sp+68h] [bp-F8h]
  int v454; // [sp+68h] [bp-F8h]
  uint32_t v455; // [sp+68h] [bp-F8h]
  uint32_t v456; // [sp+68h] [bp-F8h]
  uint32_t v457; // [sp+6Ch] [bp-F4h]
  int v458; // [sp+6Ch] [bp-F4h]
  uint32_t v459; // [sp+6Ch] [bp-F4h]
  int v460; // [sp+6Ch] [bp-F4h]
  uint32_t v461; // [sp+6Ch] [bp-F4h]
  uint32_t v462; // [sp+6Ch] [bp-F4h]
  uint32_t v463; // [sp+6Ch] [bp-F4h]
  uint32_t v464; // [sp+70h] [bp-F0h]
  int v465; // [sp+70h] [bp-F0h]
  uint32_t v466; // [sp+70h] [bp-F0h]
  int v467; // [sp+70h] [bp-F0h]
  uint32_t v468; // [sp+70h] [bp-F0h]
  uint32_t v469; // [sp+74h] [bp-ECh]
  int v470; // [sp+74h] [bp-ECh]
  uint32_t v471; // [sp+74h] [bp-ECh]
  int v472; // [sp+74h] [bp-ECh]
  uint32_t v473; // [sp+74h] [bp-ECh]
  uint32_t v474; // [sp+74h] [bp-ECh]
  uint32_t v475; // [sp+74h] [bp-ECh]
  uint32_t v476; // [sp+78h] [bp-E8h]
  int v477; // [sp+78h] [bp-E8h]
  uint32_t v478; // [sp+78h] [bp-E8h]
  int v479; // [sp+78h] [bp-E8h]
  uint32_t v480; // [sp+7Ch] [bp-E4h]
  int v481; // [sp+7Ch] [bp-E4h]
  uint32_t v482; // [sp+7Ch] [bp-E4h]
  int v483; // [sp+7Ch] [bp-E4h]
  uint32_t v484; // [sp+7Ch] [bp-E4h]
  uint32_t v485; // [sp+7Ch] [bp-E4h]
  uint32_t v486; // [sp+80h] [bp-E0h]
  int v487; // [sp+80h] [bp-E0h]
  int v488; // [sp+80h] [bp-E0h]
  uint32_t v489; // [sp+84h] [bp-DCh]
  int v490; // [sp+84h] [bp-DCh]
  int v491; // [sp+84h] [bp-DCh]
  uint32_t v492; // [sp+84h] [bp-DCh]
  uint32_t v493; // [sp+84h] [bp-DCh]
  uint32_t v494; // [sp+88h] [bp-D8h]
  int v495; // [sp+88h] [bp-D8h]
  int v496; // [sp+88h] [bp-D8h]
  uint32_t v497; // [sp+8Ch] [bp-D4h]
  int v498; // [sp+8Ch] [bp-D4h]
  int v499; // [sp+8Ch] [bp-D4h]
  int v500; // [sp+8Ch] [bp-D4h]
  uint32_t v501; // [sp+8Ch] [bp-D4h]
  uint32_t v502; // [sp+8Ch] [bp-D4h]
  uint32_t v503; // [sp+90h] [bp-D0h]
  int v504; // [sp+90h] [bp-D0h]
  uint32_t v505; // [sp+94h] [bp-CCh]
  uint32_t v506; // [sp+94h] [bp-CCh]
  int v507; // [sp+94h] [bp-CCh]
  uint32_t v508; // [sp+94h] [bp-CCh]
  uint32_t v509; // [sp+94h] [bp-CCh]
  uint32_t v510; // [sp+98h] [bp-C8h]
  uint32_t v511; // [sp+98h] [bp-C8h]
  int v512; // [sp+98h] [bp-C8h]
  uint32_t v513; // [sp+9Ch] [bp-C4h]
  int v514; // [sp+9Ch] [bp-C4h]
  uint32_t v515; // [sp+9Ch] [bp-C4h]
  uint32_t v516; // [sp+9Ch] [bp-C4h]
  uint32_t v517; // [sp+9Ch] [bp-C4h]
  uint32_t v518; // [sp+A0h] [bp-C0h]
  int v519; // [sp+A0h] [bp-C0h]
  uint32_t v520; // [sp+A0h] [bp-C0h]
  int v521; // [sp+A0h] [bp-C0h]
  uint32_t v522; // [sp+A4h] [bp-BCh]
  uint32_t v523; // [sp+A4h] [bp-BCh]
  uint32_t v524; // [sp+A4h] [bp-BCh]
  uint32_t v525; // [sp+A8h] [bp-B8h]
  int v526; // [sp+A8h] [bp-B8h]
  int v527; // [sp+A8h] [bp-B8h]
  int v528; // [sp+ACh] [bp-B4h]
  int v529; // [sp+ACh] [bp-B4h]
  int v530; // [sp+ACh] [bp-B4h]
  uint32_t v531; // [sp+ACh] [bp-B4h]
  uint32_t v532; // [sp+ACh] [bp-B4h]
  int v533; // [sp+B0h] [bp-B0h]
  int v534; // [sp+B0h] [bp-B0h]
  uint32_t v535; // [sp+B0h] [bp-B0h]
  int v536; // [sp+B4h] [bp-ACh]
  int v537; // [sp+B4h] [bp-ACh]
  uint32_t *v538; // [sp+B4h] [bp-ACh]
  int v539; // [sp+B8h] [bp-A8h]
  int v540; // [sp+B8h] [bp-A8h]
  int v541; // [sp+BCh] [bp-A4h]
  uint32_t v542; // [sp+C0h] [bp-A0h]
  uint32_t v543; // [sp+C4h] [bp-9Ch]
  int v544; // [sp+C8h] [bp-98h]
  uint32_t *V; // [sp+D4h] [bp-8Ch]
  const uint32_t *v547; // [sp+D8h] [bp-88h]
  uint32_t state; // [sp+E0h] [bp-80h] BYREF
  int v550; // [sp+E4h] [bp-7Ch]
  int v551; // [sp+E8h] [bp-78h]
  int v552; // [sp+ECh] [bp-74h]
  int v553; // [sp+F0h] [bp-70h]
  int v554; // [sp+F4h] [bp-6Ch]
  int v555; // [sp+F8h] [bp-68h]
  _DWORD v556[8]; // [sp+FCh] [bp-64h] BYREF
  int v557; // [sp+11Ch] [bp-44h] BYREF
  uint32_t v558; // [sp+120h] [bp-40h] BYREF
  uint32_t v559; // [sp+124h] [bp-3Ch]
  uint32_t v560; // [sp+128h] [bp-38h]
  uint32_t v561; // [sp+12Ch] [bp-34h]
  uint32_t v562; // [sp+130h] [bp-30h]
  uint32_t v563; // [sp+134h] [bp-2Ch]
  uint32_t v564; // [sp+138h] [bp-28h]
  uint32_t v565; // [sp+13Ch] [bp-24h] BYREF
  uint32_t v566[7]; // [sp+140h] [bp-20h] BYREF
  int v567; // [sp+15Ch] [bp-4h] BYREF
  uint32_t block; // [sp+160h] [bp+0h] BYREF
  int v569; // [sp+164h] [bp+4h]
  int v570; // [sp+168h] [bp+8h]
  int v571; // [sp+16Ch] [bp+Ch]
  int v572; // [sp+170h] [bp+10h]
  int v573; // [sp+174h] [bp+14h]
  int v574; // [sp+178h] [bp+18h]
  int v575; // [sp+17Ch] [bp+1Ch]
  _DWORD v576[8]; // [sp+180h] [bp+20h] BYREF
  uint32_t v577; // [sp+1A0h] [bp+40h] BYREF
  int v578; // [sp+1A4h] [bp+44h]
  int v579; // [sp+1A8h] [bp+48h]
  int v580; // [sp+1ACh] [bp+4Ch]
  int v581; // [sp+1B0h] [bp+50h]
  int v582; // [sp+1B4h] [bp+54h]
  int v583; // [sp+1B8h] [bp+58h]
  int v584; // [sp+1BCh] [bp+5Ch] BYREF
  uint32_t v585[4]; // [sp+1C0h] [bp+60h] BYREF
  int v586; // [sp+1D0h] [bp+70h] BYREF
  char v587; // [sp+1FCh] [bp+9Ch] BYREF
  uint32_t v588; // [sp+200h] [bp+A0h] BYREF
  uint32_t v589; // [sp+204h] [bp+A4h]
  uint32_t v590; // [sp+208h] [bp+A8h]
  uint32_t v591; // [sp+20Ch] [bp+ACh]
  uint32_t v592; // [sp+210h] [bp+B0h]
  uint32_t v593; // [sp+214h] [bp+B4h]
  uint32_t v594; // [sp+218h] [bp+B8h]
  int v595; // [sp+21Ch] [bp+BCh]
  uint32_t v596[16]; // [sp+220h] [bp+C0h] BYREF
  uint32_t X[32]; // [sp+260h] [bp+100h] BYREF
  int v598; // [sp+2E0h] [bp+180h] BYREF

  V = (uint32_t *)((unsigned int)(scratchpad + 63) & 0xFFFFFFC0);
  state = 1779033703;
  v550 = -1150833019;
  v547 = input + 16;
  v3 = v556;
  v552 = -1521486534;
  v553 = 1359893119;
  v554 = -1694144372;
  v555 = 528734635;
  v556[0] = 1541459225;
  v551 = 1013904242;
  SHA256_Transform(&state, input, 1);
  v4 = v547[1];
  v5 = v547[2];
  v6 = v547[3];
  block = *v547;
  v569 = v4;
  v570 = v5;
  v571 = v6;
  v7 = &v567;
  v572 = 128;
  v573 = 0;
  v574 = 0;
  v575 = 0;
  memset(v576, 0, 28);
  v576[7] = -2147352576;
  SHA256_Transform(&state, &block, 1);
  v580 = -1521486534;
  v581 = 1359893119;
  v582 = -1694144372;
  v556[1] = state;
  v556[2] = v550;
  v556[3] = v551;
  v556[4] = v552;
  v577 = 1779033703;
  v578 = -1150833019;
  v8 = &v567;
  v583 = 528734635;
  v584 = 1541459225;
  v9 = v556;
  v579 = 1013904242;
  v556[5] = v553;
  v556[6] = v554;
  v556[7] = v555;
  v557 = v556[0];
  do
  {
    v10 = v9[1];
    ++v9;
    v8[1] = v10 ^ 0x36363636;
    ++v8;
  }
  while ( &v557 != v9 );
  memset(v576, 54, sizeof(v576));
  SHA256_Transform(&v577, &block, 0);
  SHA256_Transform(&v577, input, 1);
  v11 = *((_QWORD *)input + 9);
  v12 = input[16];
  v13 = &v586;
  v14 = input[17];
  v585[3] = bswap32(HIDWORD(v11));
  v585[0] = bswap32(v12);
  v585[1] = bswap32(v14);
  v585[2] = bswap32(v11);
  v15 = 0x80000000;
  for ( i = &innerpad_13357; ; ++i )
  {
    v13[1] = v15;
    if ( &v587 == (char *)++v13 )
      break;
    v17 = i[1];
    v15 = bswap32(v17);
  }
  v588 = 1779033703;
  v589 = -1150833019;
  v590 = 1013904242;
  v591 = -1521486534;
  v592 = 1359893119;
  v593 = -1694144372;
  v594 = 528734635;
  v595 = 1541459225;
  do
  {
    v18 = v3[1];
    ++v3;
    v7[1] = v18 ^ 0x5C5C5C5C;
    ++v7;
  }
  while ( v9 != v3 );
  memset(v576, 92, sizeof(v576));
  v19 = 0;
  v20 = X;
  SHA256_Transform(&v588, &block, 0);
  v596[8] = 0x80000000;
  memset(&v596[9], 0, 24);
  v596[15] = 768;
  do
  {
    ++v19;
    v558 = v577;
    v559 = v578;
    v560 = v579;
    v561 = v580;
    v586 = v19;
    v562 = v581;
    v563 = v582;
    v564 = v583;
    v565 = v584;
    SHA256_Transform(&v558, v585, 0);
    v596[0] = v558;
    v596[1] = v559;
    v596[2] = v560;
    v596[3] = v561;
    v596[4] = v562;
    v596[5] = v563;
    v596[6] = v564;
    v596[7] = v565;
    v566[0] = v588;
    v566[1] = v589;
    v566[2] = v590;
    v566[3] = v591;
    v566[4] = v592;
    v566[5] = v593;
    v566[6] = v594;
    v567 = v595;
    SHA256_Transform(v566, v596, 0);
    v21 = &v565;
    v22 = v20;
    do
    {
      v23 = v21[1];
      ++v21;
      *v22++ = bswap32(v23);
    }
    while ( v21 != (uint32_t *)&v567 );
    v20 += 8;
  }
  while ( v19 != 4 );
  v513 = X[0];
  dest = V;
  v363 = X[16];
  v518 = X[1];
  v486 = X[17];
  v522 = X[2];
  v489 = X[18];
  v417 = X[3];
  v494 = X[19];
  v525 = X[4];
  v497 = X[20];
  v423 = X[5];
  v369 = X[21];
  v428 = X[6];
  v375 = X[22];
  v433 = X[7];
  v382 = X[23];
  v439 = X[8];
  v389 = X[24];
  v444 = X[9];
  v503 = X[25];
  v451 = X[10];
  v505 = X[26];
  v457 = X[11];
  v396 = X[27];
  v464 = X[12];
  v402 = X[28];
  v469 = X[13];
  v407 = X[29];
  v476 = X[14];
  v510 = X[30];
  v480 = X[15];
  v412 = X[31];
  do
  {
    memcpy(dest, X, 0x80u);
    v24 = v513 ^ v363;
    v514 = v518 ^ v486;
    v25 = v522 ^ v489;
    v519 = v522 ^ v489;
    v418 = v417 ^ v494;
    v26 = v525 ^ v497;
    v528 = v24;
    v424 = v423 ^ v369;
    v429 = v428 ^ v375;
    v434 = v433 ^ v382;
    v440 = v439 ^ v389;
    v445 = v444 ^ v503;
    v452 = v451 ^ v505;
    v458 = v457 ^ v396;
    v27 = v434;
    v465 = v464 ^ v402;
    v327 = v458;
    v470 = v469 ^ v407;
    v28 = v470;
    v29 = v452;
    v477 = v476 ^ v510;
    v30 = v477;
    v308 = v424;
    v481 = v480 ^ v412;
    v31 = v481;
    v319 = v429;
    v350 = 4;
    v279 = v514;
    v32 = v445;
    v34 = v418;
    v33 = v440;
    v35 = v465;
    v267 = v24;
    do
    {
      v36 = v279;
      v37 = v26 ^ __ROR4__(v267 + v35, 25);
      v38 = v30 ^ __ROR4__(v319 + v29, 25);
      v290 = v34 ^ __ROR4__(v31 + v327, 25);
      v280 = v32 ^ __ROR4__(v279 + v308, 25);
      v39 = v308;
      v300 = v33 ^ __ROR4__(v37 + v267, 23);
      v40 = v25 ^ __ROR4__(v29 + v38, 23);
      v41 = v27 ^ __ROR4__(v31 + v290, 23);
      v42 = v308 + v280;
      v309 = v37;
      v43 = v28 ^ __ROR4__(v42, 23);
      v335 = v38;
      v44 = v35 ^ __ROR4__(v37 + v300, 19);
      v45 = v327 ^ __ROR4__(v290 + v41, 19);
      v46 = v36 ^ __ROR4__(v280 + v43, 19);
      v47 = v319 ^ __ROR4__(v38 + v40, 19);
      v268 = v267 ^ __ROR4__(v300 + v44, 14);
      v48 = v29 ^ __ROR4__(v40 + v47, 14);
      v49 = v280;
      v50 = v39 ^ __ROR4__(v43 + v46, 14);
      v343 = v31 ^ __ROR4__(v41 + v45, 14);
      v35 = v44 ^ __ROR4__(v335 + v343, 25);
      v327 = v45 ^ __ROR4__(v280 + v48, 25);
      v279 = v46 ^ __ROR4__(v290 + v268, 25);
      v319 = v47 ^ __ROR4__(v309 + v50, 25);
      v27 = v41 ^ __ROR4__(v50 + v319, 23);
      v25 = v40 ^ __ROR4__(v279 + v268, 23);
      v28 = v43 ^ __ROR4__(v343 + v35, 23);
      v33 = v300 ^ __ROR4__(v48 + v327, 23);
      v26 = v309 ^ __ROR4__(v319 + v27, 19);
      v32 = v49 ^ __ROR4__(v327 + v33, 19);
      v34 = v290 ^ __ROR4__(v279 + v25, 19);
      v30 = v335 ^ __ROR4__(v35 + v28, 19);
      v51 = v268 ^ __ROR4__(v25 + v34, 14);
      v29 = v48 ^ __ROR4__(v33 + v32, 14);
      v267 = v51;
      v308 = v50 ^ __ROR4__(v27 + v26, 14);
      v31 = v343 ^ __ROR4__(v28 + v30, 14);
      --v350;
    }
    while ( v350 );
    v419 = v418 + v34;
    v544 = v528 + v51;
    v425 = v424 + v308;
    v430 = v429 + v319;
    v435 = v434 + v27;
    v441 = v440 + v33;
    v446 = v445 + v32;
    v453 = v452 + v29;
    v459 = v458 + v327;
    v466 = v465 + v35;
    v471 = v470 + v28;
    v52 = v528 + v51;
    v515 = v514 + v279;
    v523 = (v525 ^ v497) + v26;
    v478 = v477 + v30;
    v520 = v519 + v25;
    v482 = v481 + v31;
    v364 = v363 ^ (v528 + v51);
    v487 = v486 ^ v515;
    v490 = v489 ^ v520;
    v495 = v494 ^ v419;
    v498 = v497 ^ v523;
    v376 = v375 ^ v430;
    v370 = v369 ^ v425;
    v383 = v382 ^ v435;
    v390 = v389 ^ v441;
    v526 = v503 ^ v446;
    v53 = v503 ^ v446;
    v54 = v490;
    v529 = v396 ^ v459;
    v504 = v505 ^ v453;
    v55 = v396 ^ v459;
    v533 = v402 ^ v466;
    v536 = v407 ^ v471;
    v344 = v407 ^ v471;
    v56 = v53;
    v320 = v376;
    v57 = v510 ^ v478;
    v539 = v510 ^ v478;
    v541 = v412 ^ v482;
    v291 = v370;
    v58 = v412 ^ v482;
    v328 = v487;
    v59 = v383;
    v60 = v390;
    v61 = v495;
    v62 = v505 ^ v453;
    v63 = v498;
    v351 = 4;
    X[0] = v52;
    X[13] = v471;
    v64 = v402 ^ v466;
    X[1] = v515;
    v269 = v364;
    X[2] = v520;
    X[3] = v419;
    X[4] = v523;
    X[5] = v425;
    X[6] = v430;
    X[7] = v435;
    X[8] = v441;
    X[9] = v446;
    X[10] = v453;
    X[11] = v459;
    X[12] = v466;
    X[14] = v478;
    X[15] = v482;
    do
    {
      v65 = v291;
      v281 = v63 ^ __ROR4__(v269 + v64, 25);
      v66 = v56 ^ __ROR4__(v291 + v328, 25);
      v292 = v57 ^ __ROR4__(v320 + v62, 25);
      v301 = v61 ^ __ROR4__(v58 + v55, 25);
      v67 = v59 ^ __ROR4__(v301 + v58, 23);
      v336 = v66;
      v310 = v60 ^ __ROR4__(v269 + v281, 23);
      v68 = v54 ^ __ROR4__(v292 + v62, 23);
      v69 = v65;
      v70 = v344 ^ __ROR4__(v65 + v66, 23);
      v71 = v64 ^ __ROR4__(v281 + v310, 19);
      v72 = v55 ^ __ROR4__(v301 + v67, 19);
      v73 = v320 ^ __ROR4__(v292 + v68, 19);
      v74 = v58 ^ __ROR4__(v67 + v72, 14);
      v75 = v328 ^ __ROR4__(v66 + v70, 19);
      v270 = v269 ^ __ROR4__(v310 + v71, 14);
      v76 = v62 ^ __ROR4__(v68 + v73, 14);
      v77 = v69 ^ __ROR4__(v70 + v75, 14);
      v64 = v71 ^ __ROR4__(v292 + v74, 25);
      v55 = v72 ^ __ROR4__(v336 + v76, 25);
      v328 = v75 ^ __ROR4__(v301 + v270, 25);
      v320 = v73 ^ __ROR4__(v281 + v77, 25);
      v59 = v67 ^ __ROR4__(v77 + v320, 23);
      v54 = v68 ^ __ROR4__(v328 + v270, 23);
      v344 = v70 ^ __ROR4__(v74 + v64, 23);
      v60 = v310 ^ __ROR4__(v76 + v55, 23);
      v63 = v281 ^ __ROR4__(v320 + v59, 19);
      v61 = v301 ^ __ROR4__(v328 + v54, 19);
      v56 = v336 ^ __ROR4__(v55 + v60, 19);
      v57 = v292 ^ __ROR4__(v64 + v344, 19);
      v269 = v270 ^ __ROR4__(v54 + v61, 14);
      v291 = v77 ^ __ROR4__(v59 + v63, 14);
      v58 = v74 ^ __ROR4__(v344 + v57, 14);
      v62 = v76 ^ __ROR4__(v60 + v56, 14);
      --v351;
    }
    while ( v351 );
    v542 = v364 + v269;
    v543 = v487 + v328;
    v506 = v490 + v54;
    v511 = v495 + v61;
    v365 = v498 + v63;
    v371 = v370 + v291;
    v377 = v376 + v320;
    v384 = v383 + v59;
    v397 = v526 + v56;
    v391 = v390 + v60;
    v403 = v504 + v62;
    v408 = v529 + v55;
    v413 = v533 + v64;
    X[20] = v498 + v63;
    v488 = v536 + v344;
    X[21] = v371;
    v491 = v539 + v57;
    X[22] = v377;
    v496 = v541 + v58;
    X[23] = v384;
    X[16] = v542;
    X[17] = v543;
    X[25] = v526 + v56;
    X[18] = v506;
    X[19] = v511;
    X[26] = v504 + v62;
    X[24] = v391;
    X[27] = v529 + v55;
    X[28] = v533 + v64;
    X[29] = v536 + v344;
    X[30] = v539 + v57;
    X[31] = v541 + v58;
    memcpy(dest + 32, X, 0x80u);
    v499 = v544 ^ v542;
    v527 = v515 ^ v543;
    v420 = v419 ^ v511;
    v78 = v520 ^ v506;
    v521 = v520 ^ v506;
    v426 = v425 ^ v371;
    v431 = v430 ^ v377;
    v436 = v435 ^ v384;
    v79 = v436;
    v442 = v441 ^ v391;
    v447 = v446 ^ v397;
    v454 = v453 ^ (v504 + v62);
    v460 = v459 ^ v408;
    v321 = v431;
    v467 = v466 ^ (v533 + v64);
    v282 = v515 ^ v543;
    v80 = v442;
    v472 = v471 ^ (v536 + v344);
    v81 = v454;
    v82 = v447;
    v83 = v478 ^ (v539 + v57);
    v479 = v83;
    v84 = v472;
    v85 = v420;
    v86 = v523 ^ v365;
    v87 = v482 ^ v496;
    v311 = v426;
    v329 = v460;
    v88 = v467;
    v483 = v482 ^ v496;
    v352 = 4;
    v271 = v544 ^ v542;
    do
    {
      v89 = v282;
      v90 = v86 ^ __ROR4__(v88 + v271, 25);
      v91 = v83 ^ __ROR4__(v321 + v81, 25);
      v293 = v85 ^ __ROR4__(v87 + v329, 25);
      v283 = v82 ^ __ROR4__(v311 + v282, 25);
      v92 = v311;
      v302 = v80 ^ __ROR4__(v271 + v90, 23);
      v93 = v78 ^ __ROR4__(v91 + v81, 23);
      v94 = v79 ^ __ROR4__(v87 + v293, 23);
      v95 = v311 + v283;
      v312 = v90;
      v96 = v84 ^ __ROR4__(v95, 23);
      v337 = v91;
      v97 = v88 ^ __ROR4__(v90 + v302, 19);
      v98 = v329 ^ __ROR4__(v293 + v94, 19);
      v99 = v89 ^ __ROR4__(v283 + v96, 19);
      v100 = v321 ^ __ROR4__(v91 + v93, 19);
      v272 = v271 ^ __ROR4__(v302 + v97, 14);
      v101 = v81 ^ __ROR4__(v93 + v100, 14);
      v102 = v283;
      v103 = v92 ^ __ROR4__(v96 + v99, 14);
      v345 = v87 ^ __ROR4__(v94 + v98, 14);
      v88 = v97 ^ __ROR4__(v337 + v345, 25);
      v329 = v98 ^ __ROR4__(v283 + v101, 25);
      v282 = v99 ^ __ROR4__(v293 + v272, 25);
      v321 = v100 ^ __ROR4__(v312 + v103, 25);
      v79 = v94 ^ __ROR4__(v103 + v321, 23);
      v78 = v93 ^ __ROR4__(v282 + v272, 23);
      v84 = v96 ^ __ROR4__(v345 + v88, 23);
      v80 = v302 ^ __ROR4__(v101 + v329, 23);
      v86 = v312 ^ __ROR4__(v321 + v79, 19);
      v82 = v102 ^ __ROR4__(v329 + v80, 19);
      v85 = v293 ^ __ROR4__(v282 + v78, 19);
      v83 = v337 ^ __ROR4__(v88 + v84, 19);
      v104 = v272 ^ __ROR4__(v78 + v85, 14);
      v81 = v101 ^ __ROR4__(v80 + v82, 14);
      v271 = v104;
      v311 = v103 ^ __ROR4__(v79 + v86, 14);
      v87 = v345 ^ __ROR4__(v84 + v83, 14);
      --v352;
    }
    while ( v352 );
    v513 = v499 + v104;
    v105 = v521 + v78;
    v417 = v420 + v85;
    v423 = v426 + v311;
    v428 = v431 + v321;
    v433 = v436 + v79;
    v439 = v442 + v80;
    v444 = v447 + v82;
    v451 = v454 + v81;
    v457 = v460 + v329;
    v464 = v467 + v88;
    v469 = v472 + v84;
    v476 = v479 + v83;
    v518 = v527 + v282;
    v525 = (v523 ^ v365) + v86;
    v522 = v105;
    v500 = v542 ^ (v499 + v104);
    v507 = v506 ^ v105;
    v512 = v511 ^ v417;
    v530 = v365 ^ v525;
    v372 = v371 ^ v423;
    v480 = v483 + v87;
    v378 = v377 ^ v428;
    v385 = v384 ^ v433;
    v392 = v391 ^ v439;
    v534 = v397 ^ v444;
    v106 = v397 ^ v444;
    v107 = v403;
    v108 = v507;
    v404 = v408 ^ v457;
    v398 = v107 ^ v451;
    v109 = v408 ^ v457;
    v409 = v413 ^ v464;
    v284 = v413 ^ v464;
    v414 = v488 ^ v469;
    v346 = v488 ^ v469;
    v110 = v106;
    v330 = v378;
    v111 = v491 ^ v476;
    v537 = v491 ^ v476;
    v540 = v496 ^ v480;
    v294 = v372;
    v112 = v496 ^ v480;
    v322 = v543 ^ v518;
    v113 = v385;
    v114 = v392;
    v115 = v512;
    v116 = v398;
    v117 = v365 ^ v525;
    v353 = 4;
    X[0] = v513;
    X[13] = v469;
    v118 = v284;
    X[1] = v518;
    v273 = v542 ^ v513;
    X[2] = v105;
    X[3] = v417;
    X[4] = v525;
    X[5] = v423;
    X[6] = v428;
    X[7] = v433;
    X[8] = v439;
    X[9] = v444;
    X[10] = v451;
    X[11] = v457;
    X[12] = v464;
    X[14] = v476;
    X[15] = v480;
    do
    {
      v119 = v294;
      v285 = v117 ^ __ROR4__(v118 + v273, 25);
      v120 = v110 ^ __ROR4__(v294 + v322, 25);
      v295 = v111 ^ __ROR4__(v116 + v330, 25);
      v303 = v115 ^ __ROR4__(v112 + v109, 25);
      v121 = v113 ^ __ROR4__(v112 + v303, 23);
      v338 = v120;
      v313 = v114 ^ __ROR4__(v285 + v273, 23);
      v122 = v108 ^ __ROR4__(v116 + v295, 23);
      v123 = v119;
      v124 = v346 ^ __ROR4__(v119 + v120, 23);
      v125 = v118 ^ __ROR4__(v285 + v313, 19);
      v126 = v109 ^ __ROR4__(v303 + v121, 19);
      v127 = v330 ^ __ROR4__(v295 + v122, 19);
      v128 = v112 ^ __ROR4__(v121 + v126, 14);
      v129 = v322 ^ __ROR4__(v120 + v124, 19);
      v274 = v273 ^ __ROR4__(v313 + v125, 14);
      v130 = v116 ^ __ROR4__(v122 + v127, 14);
      v131 = v123 ^ __ROR4__(v124 + v129, 14);
      v118 = v125 ^ __ROR4__(v295 + v128, 25);
      v109 = v126 ^ __ROR4__(v338 + v130, 25);
      v322 = v129 ^ __ROR4__(v303 + v274, 25);
      v330 = v127 ^ __ROR4__(v285 + v131, 25);
      v113 = v121 ^ __ROR4__(v131 + v330, 23);
      v108 = v122 ^ __ROR4__(v322 + v274, 23);
      v346 = v124 ^ __ROR4__(v128 + v118, 23);
      v114 = v313 ^ __ROR4__(v130 + v109, 23);
      v117 = v285 ^ __ROR4__(v330 + v113, 19);
      v115 = v303 ^ __ROR4__(v322 + v108, 19);
      v110 = v338 ^ __ROR4__(v109 + v114, 19);
      v111 = v295 ^ __ROR4__(v118 + v346, 19);
      v273 = v274 ^ __ROR4__(v108 + v115, 14);
      v294 = v131 ^ __ROR4__(v113 + v117, 14);
      v112 = v128 ^ __ROR4__(v346 + v111, 14);
      v116 = v130 ^ __ROR4__(v114 + v110, 14);
      --v353;
    }
    while ( v353 );
    v363 = v500 + v273;
    v486 = (v543 ^ v518) + v322;
    v489 = v507 + v108;
    v494 = v512 + v115;
    v497 = v530 + v117;
    v369 = v372 + v294;
    v375 = v378 + v330;
    v382 = v385 + v113;
    v389 = v392 + v114;
    v503 = v534 + v110;
    v505 = v398 + v116;
    v396 = v404 + v109;
    v402 = v409 + v118;
    X[18] = v489;
    X[19] = v512 + v115;
    X[20] = v530 + v117;
    X[23] = v382;
    X[24] = v389;
    X[25] = v534 + v110;
    v407 = v414 + v346;
    X[26] = v505;
    v510 = v537 + v111;
    v412 = v540 + v112;
    dest += 64;
    X[16] = v363;
    X[17] = v486;
    X[21] = v369;
    X[22] = v375;
    X[27] = v396;
    X[28] = v402;
    X[29] = v407;
    X[30] = v537 + v111;
    X[31] = v540 + v112;
  }
  while ( dest != V + 0x8000 );
  v132 = v363;
  v432 = (char *)V - (char *)X;
  v427 = 512;
  do
  {
    v133 = X;
    v134 = v432 + ((v132 & 0x3FF) << 7);
    do
    {
      v135 = v133[1];
      v136 = *(uint32_t *)((char *)v133 + v134 + 4);
      v137 = *(uint32_t *)((char *)v133 + v134);
      v133 += 2;
      v138 = *(v133 - 2);
      *(v133 - 1) = v135 ^ v136;
      *(v133 - 2) = v138 ^ v137;
    }
    while ( &v598 != (int *)v133 );
    desta = 4;
    v373 = X[16] ^ X[0];
    v296 = X[16] ^ X[0];
    v386 = X[17] ^ X[1];
    v139 = X[18] ^ X[2];
    v286 = X[17] ^ X[1];
    v399 = X[18] ^ X[2];
    v140 = X[3] ^ X[19];
    v141 = X[20] ^ X[4];
    v304 = X[5] ^ X[21];
    v461 = X[6] ^ X[22];
    v331 = X[6] ^ X[22];
    v142 = X[7] ^ X[23];
    v473 = X[7] ^ X[23];
    v484 = X[8] ^ X[24];
    v143 = X[8] ^ X[24];
    v144 = X[9] ^ X[25];
    v492 = X[9] ^ X[25];
    v501 = X[10] ^ X[26];
    v314 = X[10] ^ X[26];
    v508 = X[11] ^ X[27];
    v145 = X[12] ^ X[28];
    v275 = X[11] ^ X[27];
    v516 = X[12] ^ X[28];
    v524 = X[13] ^ X[29];
    v146 = X[13] ^ X[29];
    v147 = X[30] ^ X[14];
    v531 = X[30] ^ X[14];
    v538 = v133;
    v148 = X[15] ^ X[31];
    v535 = X[15] ^ X[31];
    do
    {
      v339 = v141 ^ __ROR4__(v296 + v145, 25);
      v354 = v147 ^ __ROR4__(v331 + v314, 25);
      v149 = v140 ^ __ROR4__(v275 + v148, 25);
      v150 = v144 ^ __ROR4__(v286 + v304, 25);
      v151 = v142 ^ __ROR4__(v149 + v148, 23);
      v152 = v143 ^ __ROR4__(v339 + v296, 23);
      v153 = v139 ^ __ROR4__(v354 + v314, 23);
      v154 = v146 ^ __ROR4__(v150 + v304, 23);
      v155 = v145 ^ __ROR4__(v339 + v152, 19);
      v156 = v150 + v154;
      v347 = v150;
      v157 = v296 ^ __ROR4__(v152 + v155, 14);
      v158 = v275 ^ __ROR4__(v149 + v151, 19);
      v159 = v331 ^ __ROR4__(v354 + v153, 19);
      v160 = v286 ^ __ROR4__(v156, 19);
      v323 = v148 ^ __ROR4__(v151 + v158, 14);
      v161 = v314 ^ __ROR4__(v153 + v159, 14);
      v145 = v155 ^ __ROR4__(v354 + v323, 25);
      v162 = v304 ^ __ROR4__(v154 + v160, 14);
      v275 = v158 ^ __ROR4__(v347 + v161, 25);
      v331 = v159 ^ __ROR4__(v339 + v162, 25);
      v142 = v151 ^ __ROR4__(v162 + v331, 23);
      v286 = v160 ^ __ROR4__(v149 + v157, 25);
      v139 = v153 ^ __ROR4__(v157 + v286, 23);
      v146 = v154 ^ __ROR4__(v323 + v145, 23);
      v143 = v152 ^ __ROR4__(v161 + v275, 23);
      v140 = v149 ^ __ROR4__(v286 + v139, 19);
      v141 = v339 ^ __ROR4__(v331 + v142, 19);
      v144 = v347 ^ __ROR4__(v275 + v143, 19);
      v296 = v157 ^ __ROR4__(v139 + v140, 14);
      v147 = v354 ^ __ROR4__(v145 + v146, 19);
      v304 = v162 ^ __ROR4__(v142 + v141, 14);
      v314 = v161 ^ __ROR4__(v143 + v144, 14);
      v148 = v323 ^ __ROR4__(v146 + v147, 14);
      --desta;
    }
    while ( desta );
    X[0] = v373 + v296;
    X[1] = v386 + v286;
    X[2] = v399 + v139;
    v163 = (X[3] ^ X[19]) + v140;
    X[4] = (X[20] ^ X[4]) + v141;
    X[5] = (X[5] ^ X[21]) + v304;
    X[6] = v461 + v331;
    X[7] = v473 + v142;
    X[8] = v484 + v143;
    X[9] = v492 + v144;
    X[10] = v501 + v314;
    X[11] = v508 + v275;
    X[12] = v516 + v145;
    X[13] = v524 + v146;
    X[14] = v531 + v147;
    X[15] = v535 + v148;
    v421 = X[16] ^ (v373 + v296);
    v437 = X[17] ^ (v386 + v286);
    destb = (void *)(X[18] ^ (v399 + v139));
    v366 = X[19] ^ v163;
    v448 = X[22] ^ (v461 + v331);
    v379 = X[23] ^ (v473 + v142);
    v387 = X[24] ^ (v484 + v143);
    v393 = X[25] ^ (v492 + v144);
    v340 = v448;
    v164 = v379;
    v455 = X[26] ^ (v501 + v314);
    v165 = (int)destb;
    v400 = X[27] ^ (v508 + v275);
    v166 = v387;
    v167 = X[19] ^ v163;
    v405 = X[28] ^ (v516 + v145);
    v315 = v455;
    v462 = X[29] ^ (v524 + v146);
    v410 = X[30] ^ (v531 + v147);
    v287 = v400;
    v415 = X[31] ^ (v535 + v148);
    v168 = v393;
    v355 = 4;
    v169 = v415;
    X[3] = v163;
    v297 = v437;
    v305 = X[21] ^ X[5];
    v170 = X[20] ^ X[4];
    v171 = v410;
    v172 = v405;
    v173 = v462;
    v324 = v421;
    do
    {
      v276 = v170 ^ __ROR4__(v172 + v324, 25);
      v174 = v171 ^ __ROR4__(v340 + v315, 25);
      v175 = v167 ^ __ROR4__(v287 + v169, 25);
      v332 = v168 ^ __ROR4__(v297 + v305, 25);
      v176 = v164 ^ __ROR4__(v169 + v175, 23);
      v177 = v166 ^ __ROR4__(v324 + v276, 23);
      v178 = v165 ^ __ROR4__(v315 + v174, 23);
      v179 = v172 ^ __ROR4__(v276 + v177, 19);
      v180 = v174;
      v181 = v173 ^ __ROR4__(v305 + v332, 23);
      v182 = v287 ^ __ROR4__(v175 + v176, 19);
      v183 = v169 ^ __ROR4__(v176 + v182, 14);
      v184 = v315;
      v185 = v340 ^ __ROR4__(v174 + v178, 19);
      v316 = v180;
      v172 = v179 ^ __ROR4__(v180 + v183, 25);
      v186 = v297 ^ __ROR4__(v332 + v181, 19);
      v187 = v324 ^ __ROR4__(v177 + v179, 14);
      v188 = v184 ^ __ROR4__(v178 + v185, 14);
      v189 = v305 ^ __ROR4__(v181 + v186, 14);
      v287 = v182 ^ __ROR4__(v332 + v188, 25);
      v340 = v185 ^ __ROR4__(v276 + v189, 25);
      v164 = v176 ^ __ROR4__(v189 + v340, 23);
      v297 = v186 ^ __ROR4__(v175 + v187, 25);
      v165 = v178 ^ __ROR4__(v187 + v297, 23);
      v166 = v177 ^ __ROR4__(v188 + v287, 23);
      v173 = v181 ^ __ROR4__(v183 + v172, 23);
      v167 = v175 ^ __ROR4__(v297 + v165, 19);
      v170 = v276 ^ __ROR4__(v340 + v164, 19);
      v190 = v187 ^ __ROR4__(v165 + v167, 14);
      v168 = v332 ^ __ROR4__(v287 + v166, 19);
      v324 = v190;
      v171 = v316 ^ __ROR4__(v172 + v173, 19);
      v305 = v189 ^ __ROR4__(v164 + v170, 14);
      v315 = v188 ^ __ROR4__(v166 + v168, 14);
      v169 = v183 ^ __ROR4__(v173 + v171, 14);
      --v355;
    }
    while ( v355 );
    X[17] = v437 + v297;
    X[16] = v421 + v190;
    v191 = X;
    v192 = v432 + (((v421 + v190) & 0x3FF) << 7);
    X[21] = (X[21] ^ X[5]) + v305;
    X[25] = v393 + v168;
    X[26] = v455 + v315;
    X[28] = v405 + v172;
    X[18] = (uint32_t)destb + v165;
    X[19] = v366 + v167;
    X[20] = (X[20] ^ X[4]) + v170;
    X[22] = v448 + v340;
    X[23] = v379 + v164;
    X[24] = v387 + v166;
    X[27] = v400 + v287;
    X[29] = v462 + v173;
    X[30] = v410 + v171;
    X[31] = v415 + v169;
    do
    {
      v193 = v191[1];
      v194 = *(uint32_t *)((char *)v191 + v192 + 4);
      v195 = *(uint32_t *)((char *)v191 + v192);
      v191 += 2;
      v196 = *(v191 - 2);
      *(v191 - 1) = v193 ^ v194;
      *(v191 - 2) = v196 ^ v195;
    }
    while ( v191 != v538 );
    v367 = 4;
    v380 = X[16] ^ X[0];
    v288 = X[16] ^ X[0];
    v394 = X[17] ^ X[1];
    v277 = X[17] ^ X[1];
    v197 = X[2] ^ X[18];
    v406 = X[2] ^ X[18];
    v198 = X[3] ^ X[19];
    v199 = X[4] ^ X[20];
    v449 = X[5] ^ X[21];
    v298 = X[5] ^ X[21];
    v463 = X[6] ^ X[22];
    v200 = X[7] ^ X[23];
    v317 = X[6] ^ X[22];
    v474 = X[7] ^ X[23];
    v201 = X[8] ^ X[24];
    v485 = X[8] ^ X[24];
    v202 = X[25] ^ X[9];
    v493 = X[25] ^ X[9];
    v502 = X[10] ^ X[26];
    v203 = X[11] ^ X[27];
    v306 = X[10] ^ X[26];
    v509 = X[11] ^ X[27];
    v517 = X[12] ^ X[28];
    v204 = X[13] ^ X[29];
    v205 = X[14] ^ X[30];
    v532 = X[14] ^ X[30];
    v206 = X[15] ^ X[31];
    v325 = X[12] ^ X[28];
    do
    {
      v207 = v198 ^ __ROR4__(v203 + v206, 25);
      v333 = v199 ^ __ROR4__(v288 + v325, 25);
      v208 = v200 ^ __ROR4__(v207 + v206, 23);
      v209 = v205 ^ __ROR4__(v317 + v306, 25);
      v210 = v201 ^ __ROR4__(v333 + v288, 23);
      v211 = v203 ^ __ROR4__(v207 + v208, 19);
      v212 = v197 ^ __ROR4__(v209 + v306, 23);
      v213 = v202 ^ __ROR4__(v277 + v298, 25);
      v356 = v204 ^ __ROR4__(v213 + v298, 23);
      v214 = v213 + v356;
      v215 = v325 ^ __ROR4__(v333 + v210, 19);
      v341 = v213;
      v348 = v209;
      v216 = v317 ^ __ROR4__(v209 + v212, 19);
      v217 = v288 ^ __ROR4__(v210 + v215, 14);
      v218 = v277 ^ __ROR4__(v214, 19);
      destc = v206 ^ __ROR4__(v208 + v211, 14);
      v219 = v306 ^ __ROR4__(v212 + v216, 14);
      v325 = v215 ^ __ROR4__(v209 + destc, 25);
      v220 = v298 ^ __ROR4__(v356 + v218, 14);
      v203 = v211 ^ __ROR4__(v341 + v219, 25);
      v201 = v210 ^ __ROR4__(v219 + v203, 23);
      v317 = v216 ^ __ROR4__(v333 + v220, 25);
      v200 = v208 ^ __ROR4__(v220 + v317, 23);
      v277 = v218 ^ __ROR4__(v207 + v217, 25);
      v197 = v212 ^ __ROR4__(v217 + v277, 23);
      v199 = v333 ^ __ROR4__(v317 + v200, 19);
      v204 = v356 ^ __ROR4__(destc + v325, 23);
      v198 = v207 ^ __ROR4__(v277 + v197, 19);
      v202 = v341 ^ __ROR4__(v203 + v201, 19);
      v205 = v348 ^ __ROR4__(v325 + v204, 19);
      v288 = v217 ^ __ROR4__(v197 + v198, 14);
      v298 = v220 ^ __ROR4__(v200 + v199, 14);
      v306 = v219 ^ __ROR4__(v201 + v202, 14);
      v206 = destc ^ __ROR4__(v204 + v205, 14);
      --v367;
    }
    while ( v367 );
    X[0] = v380 + v288;
    X[1] = v394 + v277;
    X[2] = v406 + v197;
    v221 = (X[3] ^ X[19]) + v198;
    v222 = (X[4] ^ X[20]) + v199;
    X[5] = v449 + v298;
    X[6] = v463 + v317;
    X[7] = v474 + v200;
    X[8] = v485 + v201;
    X[9] = v493 + v202;
    X[10] = v502 + v306;
    X[11] = v509 + v203;
    X[12] = v517 + v325;
    X[13] = (X[13] ^ X[29]) + v204;
    X[14] = v532 + v205;
    v223 = v380 + v288;
    v224 = (X[15] ^ X[31]) + v206;
    v381 = X[18] ^ (v406 + v197);
    v374 = X[16] ^ v223;
    v388 = X[19] ^ v221;
    v438 = X[17] ^ (v394 + v277);
    v443 = X[21] ^ (v449 + v298);
    v395 = X[20] ^ v222;
    v401 = X[23] ^ (v474 + v200);
    v450 = X[22] ^ (v463 + v317);
    v456 = X[24] ^ (v485 + v201);
    v225 = v456;
    v226 = v502 + v306;
    v307 = v443;
    v411 = X[26] ^ v226;
    v334 = v450;
    v416 = X[27] ^ (v509 + v203);
    v289 = v438;
    v422 = X[28] ^ (v517 + v325);
    v278 = v416;
    v299 = v422;
    v468 = X[30] ^ (v532 + v205);
    v227 = X[16] ^ v223;
    v228 = v401;
    v229 = v381;
    v475 = X[31] ^ v224;
    v230 = X[19] ^ v221;
    v231 = X[26] ^ v226;
    v232 = X[25] ^ (v493 + v202);
    v233 = X[20] ^ v222;
    v368 = 4;
    X[15] = v224;
    v235 = X[30] ^ X[14];
    v234 = X[29] ^ X[13];
    X[3] = v221;
    X[4] = v222;
    v236 = v227;
    v237 = v475;
    do
    {
      v238 = v235 ^ __ROR4__(v334 + v231, 25);
      v239 = v230 ^ __ROR4__(v278 + v237, 25);
      v342 = v233 ^ __ROR4__(v236 + v299, 25);
      v240 = v228 ^ __ROR4__(v239 + v237, 23);
      v349 = v232 ^ __ROR4__(v289 + v307, 25);
      v241 = v229 ^ __ROR4__(v238 + v231, 23);
      v357 = v238;
      v326 = v234 ^ __ROR4__(v349 + v307, 23);
      v318 = v225 ^ __ROR4__(v342 + v236, 23);
      v242 = v299 ^ __ROR4__(v318 + v342, 19);
      v243 = v334 ^ __ROR4__(v238 + v241, 19);
      v244 = v278 ^ __ROR4__(v239 + v240, 19);
      v245 = v289 ^ __ROR4__(v349 + v326, 19);
      v246 = v231 ^ __ROR4__(v241 + v243, 14);
      v247 = v236 ^ __ROR4__(v318 + v242, 14);
      destd = v237 ^ __ROR4__(v240 + v244, 14);
      v248 = v307 ^ __ROR4__(v326 + v245, 14);
      v278 = v244 ^ __ROR4__(v349 + v246, 25);
      v299 = v242 ^ __ROR4__(v357 + destd, 25);
      v334 = v243 ^ __ROR4__(v342 + v248, 25);
      v228 = v240 ^ __ROR4__(v248 + v334, 23);
      v289 = v245 ^ __ROR4__(v239 + v247, 25);
      v229 = v241 ^ __ROR4__(v247 + v289, 23);
      v225 = v318 ^ __ROR4__(v246 + v278, 23);
      v230 = v239 ^ __ROR4__(v289 + v229, 19);
      v234 = v326 ^ __ROR4__(destd + v299, 23);
      v236 = v247 ^ __ROR4__(v229 + v230, 14);
      v233 = v342 ^ __ROR4__(v334 + v228, 19);
      v232 = v349 ^ __ROR4__(v278 + v225, 19);
      v231 = v246 ^ __ROR4__(v225 + v232, 14);
      v235 = v357 ^ __ROR4__(v299 + v234, 19);
      v307 = v248 ^ __ROR4__(v228 + v233, 14);
      v237 = destd ^ __ROR4__(v234 + v235, 14);
      --v368;
    }
    while ( v368 );
    v132 = v374 + v236;
    X[16] = v374 + v236;
    X[17] = v438 + v289;
    X[18] = v381 + v229;
    X[19] = v388 + v230;
    X[20] = v395 + v233;
    X[21] = v443 + v307;
    X[28] = v422 + v299;
    X[22] = v450 + v334;
    X[23] = v401 + v228;
    X[24] = v456 + v225;
    X[25] = (X[25] ^ (v493 + v202)) + v232;
    X[26] = v411 + v231;
    X[27] = v416 + v278;
    X[29] = (X[29] ^ X[13]) + v234;
    X[30] = v468 + v235;
    v249 = v427 == 1;
    X[31] = v475 + v237;
    --v427;
  }
  while ( !v249 );
  v572 = 1359893119;
  v571 = -1521486534;
  v250 = &v587;
  v251 = &v576[7];
  v573 = -1694144372;
  v574 = 528734635;
  v575 = 1541459225;
  v252 = &v576[7];
  block = 1779033703;
  v569 = -1150833019;
  v570 = 1013904242;
  SHA256_Transform(&block, input, 1);
  v253 = v547[1];
  v254 = v547[2];
  v255 = v547[3];
  v588 = *v547;
  v589 = v253;
  v590 = v254;
  v591 = v255;
  v592 = 128;
  v593 = 0;
  v594 = 0;
  v595 = 0;
  memset(v596, 0, 28);
  v596[7] = -2147352576;
  SHA256_Transform(&block, &v588, 1);
  v256 = &v587;
  v257 = block;
  v258 = v569;
  v259 = v570;
  v260 = v571;
  *ostate = 1779033703;
  ostate[1] = -1150833019;
  v577 = v257;
  v578 = v258;
  v579 = v259;
  v580 = v260;
  v261 = v572;
  v262 = v573;
  v263 = v574;
  v264 = v575;
  ostate[2] = 1013904242;
  ostate[3] = -1521486534;
  ostate[4] = 1359893119;
  ostate[5] = -1694144372;
  ostate[6] = 528734635;
  ostate[7] = 1541459225;
  v581 = v261;
  v582 = v262;
  v583 = v263;
  v584 = v264;
  do
  {
    v265 = v252[1];
    ++v252;
    *((_DWORD *)v256 + 1) = v265 ^ 0x5C5C5C5C;
    v256 += 4;
  }
  while ( &v584 != v252 );
  memset(v596, 92, 32);
  SHA256_Transform(ostate, &v588, 0);
  block = 1779033703;
  v569 = -1150833019;
  v570 = 1013904242;
  v571 = -1521486534;
  v572 = 1359893119;
  v573 = -1694144372;
  v574 = 528734635;
  v575 = 1541459225;
  do
  {
    v266 = v251[1];
    ++v251;
    *((_DWORD *)v250 + 1) = v266 ^ 0x36363636;
    v250 += 4;
  }
  while ( v251 != v252 );
  memset(v596, 54, 32);
  SHA256_Transform(&block, &v588, 0);
  SHA256_Transform(&block, X, 1);
  SHA256_Transform(&block, &X[16], 1);
  SHA256_Transform(&block, &ihash_finalblk_13384, 0);
  v588 = block;
  v589 = v569;
  v590 = v570;
  v591 = v571;
  v592 = v572;
  v593 = v573;
  v594 = v574;
  v595 = v575;
  v596[0] = 0x80000000;
  memset(&v596[1], 0, 24);
  v596[7] = 768;
  SHA256_Transform(ostate, &v588, 0);
}

//----- (0001919C) --------------------------------------------------------
void __fastcall scrypt_regenhash(work *work)
{
  unsigned __int8 *v2; // r1
  uint32_t *v3; // r2
  unsigned int v4; // t1
  unsigned int v5; // r3
  unsigned __int8 *v6; // r0
  unsigned int v7; // t1
  uint32_t *v8; // [sp+4h] [bp-20254h] BYREF
  uint32_t data[20]; // [sp+8h] [bp-20250h] BYREF
  char scratchbuf[131584]; // [sp+58h] [bp-20200h] BYREF

  *(_DWORD *)scratchbuf = 0;
  memset(&scratchbuf[4], 0, (size_t)&loc_201FC);
  v2 = &work[-1].device_target[35];
  v3 = (uint32_t *)&v8;
  do
  {
    v4 = *((_DWORD *)v2 + 1);
    v2 += 4;
    v3[1] = bswap32(v4);
    ++v3;
  }
  while ( v3 != &data[18] );
  v5 = *(_DWORD *)&work->data[76];
  v8 = data;
  data[19] = bswap32(v5);
  scrypt_1024_1_1_256_sp(data, scratchbuf, (uint32_t *)work->hash);
  v6 = &work->target[28];
  do
  {
    v7 = *((_DWORD *)v6 + 1);
    v6 += 4;
    *(_DWORD *)v6 = bswap32(v7);
  }
  while ( v6 != &work->hash[28] );
}

//----- (0001920C) --------------------------------------------------------
void __fastcall rebuild_hash(work *work)
{
  if ( opt_scrypt )
    scrypt_regenhash(work);
  else
    regen_hash(work);
}

//----- (00019220) --------------------------------------------------------
int __fastcall scrypt_test(unsigned __int8 *pdata, const unsigned __int8 *ptarget, uint32_t nonce)
{
  unsigned __int8 *v3; // r0
  unsigned int v4; // r5
  uint32_t *v5; // r1
  unsigned int v6; // t1
  unsigned int v7; // r4
  char scratchpad[131596]; // [sp+8h] [bp-20208h] BYREF
  uint32_t *input; // [sp+20214h] [bp+4h]
  uint32_t ohash[8]; // [sp+20218h] [bp+8h] BYREF
  uint32_t data[20]; // [sp+20238h] [bp+28h] BYREF
  char tmp42[4096]; // [sp+20288h] [bp+78h] BYREF

  v3 = pdata - 4;
  v4 = *((_DWORD *)ptarget + 7);
  v5 = &ohash[7];
  do
  {
    v6 = *((_DWORD *)v3 + 1);
    v3 += 4;
    v5[1] = bswap32(v6);
    ++v5;
  }
  while ( v5 != &data[18] );
  input = data;
  data[19] = bswap32(nonce);
  scrypt_1024_1_1_256_sp(data, scratchpad, ohash);
  v7 = bswap32(ohash[7]);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "htarget %08lx diff1 %08lx hash %08lx", v4, 0xFFFF, v7);
    applog(7, tmp42, 0);
  }
  if ( v7 >= 0x10000 )
    return -1;
  else
    return v4 >= v7;
}

//----- (000192E4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __fastcall scanhash_scrypt(
        thr_info *thr,
        const unsigned __int8 *pmidstate,
        unsigned __int8 *pdata,
        unsigned __int8 *phash1,
        unsigned __int8 *phash,
        const unsigned __int8 *ptarget,
        uint32_t max_nonce,
        uint32_t *last_nonce,
        uint32_t n)
{
  unsigned __int8 *v11; // r1
  uint32_t *v12; // r2
  unsigned int v13; // r5
  unsigned int v15; // t1
  char *v16; // r9
  unsigned int v17; // r10
  bool v18; // r4
  uint32_t data[20]; // [sp+0h] [bp-1050h] BYREF
  uint32_t ostate[1024]; // [sp+50h] [bp-1000h] OVERLAPPED BYREF

  v11 = pdata - 4;
  v12 = &data[-1];
  v13 = *((_DWORD *)ptarget + 7);
  do
  {
    v15 = *((_DWORD *)v11 + 1);
    v11 += 4;
    v12[1] = bswap32(v15);
    ++v12;
  }
  while ( v12 != &data[18] );
  v16 = (char *)malloc(0x20200u);
  if ( v16 )
  {
    while ( 1 )
    {
      *((_DWORD *)pdata + 19) = ++n;
      v17 = bswap32(n);
      data[19] = v17;
      scrypt_1024_1_1_256_sp(data, v16, ostate);
      if ( v13 >= bswap32(ostate[7]) )
        break;
      if ( n >= max_nonce || thr->work_restart )
      {
        v18 = 0;
        *last_nonce = n;
        goto LABEL_8;
      }
    }
    *((_DWORD *)pdata + 19) = v17;
    v18 = 1;
    *last_nonce = n;
LABEL_8:
    free(v16);
  }
  else if ( use_syslog || (v18 = opt_log_output) || opt_log_level > 2 )
  {
    v18 = 0;
    strcpy((char *)ostate, "Failed to malloc scratchbuf in scanhash_scrypt");
    applog(3, (const char *)ostate, 0);
  }
  return v18;
}
// 192E4: variables would overlap: ^50.47 and stkvar "ostate" ^50.32(has user info)

//----- (000193EC) --------------------------------------------------------
void __fastcall get_datestamp(char *f, size_t fsiz, timeval *tv)
{
  struct tm *v5; // r0
  time_t tmp_time; // [sp+1Ch] [bp-4h] BYREF

  tmp_time = tv->tv_sec;
  v5 = localtime(&tmp_time);
  snprintf(
    f,
    fsiz,
    "[%d-%02d-%02d %02d:%02d:%02d]",
    v5->tm_year + 1900,
    v5->tm_mon + 1,
    v5->tm_mday,
    v5->tm_hour,
    v5->tm_min,
    v5->tm_sec);
}

//----- (00019434) --------------------------------------------------------
void adjust_quota_gcd()
{
  unsigned int v0; // r4
  pool **v1; // r7
  pool **v2; // r5
  pool *v3; // t1
  unsigned int quota; // r3
  bool v5; // cf
  pool **v6; // r8
  int v7; // t1
  unsigned int v8; // r6
  unsigned int v9; // r8
  _DWORD *v10; // t1
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( total_pools <= 0 )
  {
    v0 = 1;
  }
  else
  {
    v0 = -1;
    v1 = pools;
    v2 = pools;
    do
    {
      v3 = *v2++;
      quota = v3->quota;
      v5 = 1;
      if ( quota )
        v5 = quota >= v0;
      if ( !v5 )
        v0 = quota;
    }
    while ( &pools[total_pools] != v2 );
    if ( v0 == -1 )
    {
      v0 = 1;
    }
    else
    {
      v6 = pools;
      do
      {
        v7 = (int)*v6++;
        v8 = *(_DWORD *)(v7 + 56);
        if ( v8 && v8 % v0 )
        {
          do
            --v0;
          while ( v8 % v0 );
        }
      }
      while ( v2 != v6 );
    }
    v9 = global_quota_gcd;
    do
    {
      v10 = *v1++;
      v10[16] = v10[16] * v9 / v0;
      v10[15] = v10[14] / v0;
    }
    while ( v2 != v1 );
  }
  global_quota_gcd = v0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Global quota greatest common denominator set to %lu", v0);
    applog(7, tmp42, 0);
  }
}

//----- (0001953C) --------------------------------------------------------
char *__fastcall set_int_range(const char *arg, int *i, int min, int max)
{
  char *result; // r0
  _BOOL4 v8; // r4
  int v9; // r3

  result = opt_set_intval(arg, i);
  if ( !result )
  {
    v8 = *i < min;
    if ( *i > max )
      v9 = v8 | 1;
    else
      v9 = v8;
    if ( v9 )
      return "Value out of range";
  }
  return result;
}

//----- (00019570) --------------------------------------------------------
void __fastcall get_intrange(char *arg, int *val1, int *val2)
{
  if ( sscanf(arg, "%d-%d", val1, val2) == 1 )
    *val2 = *val1;
}

//----- (00019590) --------------------------------------------------------
bool __fastcall detect_stratum(pool *pool, char *url)
{
  _BOOL4 sockaddr; // r5
  char *v6; // r0
  char *sockaddr_url; // r3

  check_extranonce_option(pool, url);
  sockaddr = extract_sockaddr(url, &pool->sockaddr_url, &pool->stratum_port);
  if ( !sockaddr )
    return sockaddr;
  if ( strncasecmp(url, "stratum+tcp://", 0xEu) )
  {
    LOBYTE(sockaddr) = 0;
    return sockaddr;
  }
  v6 = _strdup(url);
  sockaddr_url = pool->sockaddr_url;
  pool->rpc_url = v6;
  pool->has_stratum = 1;
  pool->stratum_url = sockaddr_url;
  return sockaddr;
}

//----- (000195E0) --------------------------------------------------------
char *__fastcall set_temp_cutoff(char *arg)
{
  if ( !arg )
    return "Invalid parameters for set temp cutoff";
  if ( !*arg )
    return "Invalid parameters for set temp cutoff";
  if ( (unsigned int)strtol(arg, 0, 10) > 0xC8 )
    return "Invalid value passed to set temp cutoff";
  temp_cutoff_str = arg;
  return 0;
}

//----- (00019624) --------------------------------------------------------
void __fastcall clean_work(work *work)
{
  free(work->job_id);
  free(work->ntime);
  free(work->coinbase);
  free(work->nonce1);
  j_memset(work, 0, sizeof(work));
}

//----- (00019658) --------------------------------------------------------
void __fastcall copy_work(work *work, const work *base_work, int noffset)
{
  uint32_t id; // r7
  char *job_id; // r0
  char *nonce1; // r0
  char *ntime; // r0
  char *coinbase; // r0
  unsigned __int8 p[4]; // [sp+4h] [bp-8h] BYREF

  id = work->id;
  clean_work(work);
  memcpy(work, base_work, sizeof(work));
  work->id = id;
  job_id = base_work->job_id;
  if ( job_id )
    work->job_id = _strdup(job_id);
  nonce1 = base_work->nonce1;
  if ( nonce1 )
    work->nonce1 = _strdup(nonce1);
  ntime = base_work->ntime;
  if ( ntime )
  {
    if ( noffset )
    {
      *(_DWORD *)&work->data[68] = bswap32(bswap32(*(_DWORD *)&work->data[68]) + noffset);
      hex2bin(p, base_work->ntime, 4u);
      *(_DWORD *)p = bswap32(noffset + bswap32(*(unsigned int *)p));
      work->ntime = bin2hex(p, 4u);
    }
    else
    {
      work->ntime = _strdup(ntime);
    }
  }
  else if ( noffset )
  {
    *(_DWORD *)&work->data[68] = bswap32(noffset + bswap32(*(_DWORD *)&work->data[68]));
  }
  coinbase = base_work->coinbase;
  if ( coinbase )
    work->coinbase = _strdup(coinbase);
}

//----- (000196F8) --------------------------------------------------------
void __fastcall free_work(work *work)
{
  clean_work(work);
  sub_12000(work);
}

//----- (0001970C) --------------------------------------------------------
void __fastcall decay_time(double f, double fadd, double fsecs, double interval)
{
  double v4; // d1

  if ( v4 > 0.0 )
    decay_time_0(f, fadd, fsecs, interval);
}
// 19714: variable 'v4' is possibly undefined

//----- (0001971C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall cgpu_runtime(cgpu_info *cgpu)
{
  cgpu_info *v1; // r4
  double result; // r0
  timeval now; // [sp+0h] [bp-8h] BYREF

  if ( cgpu->dev_start_tv.tv_sec )
  {
    v1 = cgpu;
    cgtime(&now);
    *(double *)&cgpu = tdiff(&now, &v1->dev_start_tv);
  }
  LODWORD(result) = cgpu;
  return result;
}
// 1971C: variables would overlap: r0.4 and r0.8

//----- (0001975C) --------------------------------------------------------
double tsince_restart()
{
  timeval now; // [sp+0h] [bp-Ch] BYREF

  cgtime(&now);
  return tdiff(&now, &restart_tv_start);
}

//----- (00019778) --------------------------------------------------------
double tsince_update()
{
  timeval now; // [sp+0h] [bp-Ch] BYREF

  cgtime(&now);
  return tdiff(&now, &update_tv_start);
}

//----- (00019794) --------------------------------------------------------
void app_restart()
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "Attempting to restart %s", packagename);
    applog(4, tmp42, 0);
  }
  cg_completion_timeout(_kill_work, 0, 5000);
  cgtime(&total_tv_end);
  if ( forkpid > 0 )
  {
    kill(forkpid, 15);
    forkpid = 0;
  }
  execv(*initial_args, initial_args);
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    strcpy(tmp42, "Failed to restart application");
    applog(4, tmp42, 0);
  }
}

//----- (00019878) --------------------------------------------------------
void __fastcall set_work_ntime(work *work, int ntime)
{
  char *v2; // r3

  v2 = work->ntime;
  *(_DWORD *)&work->data[68] = bswap32(ntime);
  if ( v2 )
  {
    free(v2);
    work->ntime = bin2hex(&work->data[68], 4u);
  }
}

//----- (000198A0) --------------------------------------------------------
uint64_t __fastcall share_ndiff(const work *work)
{
  double v2; // d9
  unsigned __int64 v3; // r0
  double v4; // d8

  if ( !work )
    return 0;
  v2 = 2.69595353e67;
  v3 = *(_QWORD *)&work->hash[24];
  if ( opt_scrypt )
    v2 = 1.7668201e72;
  v4 = (double)*(unsigned __int64 *)work->hash
     + (double)v3 * 6.27710174e57
     + (double)*(unsigned __int64 *)&work->hash[16] * 3.40282367e38
     + (double)*(unsigned __int64 *)&work->hash[8] * 1.84467441e19;
  if ( v4 == 0.0 )
    return 0;
  else
    return (unsigned __int64)(v2 / v4);
}

//----- (00019968) --------------------------------------------------------
void __fastcall discard_work(work *work)
{
  pool *pool; // r3
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( work->clone || work->rolls || work->mined )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42, "Discarded cloned or rolled work");
      applog(7, tmp42, 0);
    }
  }
  else
  {
    pool = work->pool;
    if ( pool )
    {
      ++pool->discarded_work;
      --work->pool->quota_used;
      --work->pool->works;
    }
    ++total_discarded;
  }
  clean_work(work);
  sub_12000(work);
}

//----- (00019A28) --------------------------------------------------------
void __fastcall remove_pool(pool *pool)
{
  int v1; // r7
  int v2; // r12
  pool **v3; // r2
  pool **v4; // r6
  int v5; // r1
  int v6; // t1
  int v7; // r3
  bool v8; // cc
  int v9; // r3
  int v10; // r3

  v1 = total_pools;
  v2 = total_pools - 1;
  if ( total_pools > 0 )
  {
    v3 = pools;
    v4 = &pools[total_pools];
    do
    {
      v6 = (int)*v3++;
      v5 = v6;
      v7 = *(_DWORD *)(v6 + 4);
      v8 = v7 <= pool->prio;
      v9 = v7 - 1;
      if ( !v8 )
        *(_DWORD *)(v5 + 4) = v9;
    }
    while ( v3 != v4 );
  }
  if ( pool->pool_no < v2 )
  {
    pools[v2]->pool_no = pool->pool_no;
    pools[pool->pool_no] = pools[v2];
    v1 = total_pools;
  }
  pool->pool_no = v1;
  v10 = total_pools;
  pool->removed = 1;
  total_pools = v10 - 1;
}

//----- (00019A98) --------------------------------------------------------
void __fastcall write_config(FILE *fcfg)
{
  int v2; // r6
  const char *v3; // r10
  char *v4; // r0
  char *v5; // r11
  char *v6; // r0
  char *v7; // r0
  __int16 *v8; // r2
  int quota; // r3
  char *v10; // r0
  char *v11; // r0
  char *v12; // r0
  pool *v13; // r0
  pool *v14; // r4
  const char *v15; // r10
  char *v16; // r0
  char *v17; // r11
  char *rpc_proxy; // r0
  char *v19; // r2
  __int16 *v20; // r3
  char *v21; // r0
  char *v22; // r0
  opt_table *v23; // r4
  char *v24; // r8
  char *v25; // r11
  char *(__fastcall *cb_arg)(const char *, int *); // r2
  bool v27; // zf
  int v28; // r3
  opt_type type; // r1
  char *(__fastcall *cb)(bool *); // r2
  bool v31; // zf
  char **carg; // r3
  char *v33; // r0
  pool_strategy v34; // r1
  JE *next; // r4
  JE v36; // kr00_8
  JE *v37; // r0
  bool v38; // zf
  const char *v39; // [sp+14h] [bp-10h]
  const char *v40; // [sp+14h] [bp-10h]
  int v41; // [sp+18h] [bp-Ch]
  const char *v42; // [sp+18h] [bp-Ch]
  const char *v43; // [sp+1Ch] [bp-8h]

  fwrite("{\n\"pools\" : [", 1u, 0xDu, fcfg);
  if ( total_pools > 0 )
  {
    v2 = 0;
    do
    {
      v13 = priority_pool(v2);
      quota = v13->quota;
      v14 = v13;
      if ( quota == 1 )
      {
        if ( v2 )
          v15 = ",";
        else
          v15 = &byte_59398;
        if ( v13->rpc_proxy )
        {
          v16 = (char *)proxytype(v13->rpc_proxytype);
          v17 = json_escape(v16);
          rpc_proxy = v14->rpc_proxy;
          v19 = &byte_59398;
          v20 = (__int16 *)&byte_59398;
          if ( rpc_proxy )
          {
            v21 = json_escape(rpc_proxy);
            v20 = &word_4F67C;
            v19 = v21;
            if ( !v14->rpc_proxy )
              v20 = (__int16 *)&byte_59398;
          }
        }
        else
        {
          v19 = &byte_59398;
          v17 = &byte_59398;
          v20 = (__int16 *)&byte_59398;
        }
        v40 = (const char *)v20;
        v42 = v19;
        v22 = json_escape(v14->rpc_url);
        fprintf(fcfg, "%s\n\t{\n\t\t\"url\" : \"%s%s%s%s\",", v15, v17, v42, v40, v22);
      }
      else
      {
        if ( v2 )
          v3 = ",";
        else
          v3 = &byte_59398;
        if ( v13->rpc_proxy )
        {
          v4 = (char *)proxytype(v13->rpc_proxytype);
          v5 = json_escape(v4);
          v6 = v14->rpc_proxy;
          if ( v6 )
          {
            v7 = json_escape(v6);
            v8 = &word_4F67C;
            quota = v14->quota;
            v39 = v7;
            if ( !v14->rpc_proxy )
              v8 = (__int16 *)&byte_59398;
          }
          else
          {
            quota = v14->quota;
            v8 = (__int16 *)&byte_59398;
            v39 = &byte_59398;
          }
        }
        else
        {
          v39 = &byte_59398;
          v5 = &byte_59398;
          v8 = (__int16 *)&byte_59398;
        }
        v41 = quota;
        v43 = (const char *)v8;
        v10 = json_escape(v14->rpc_url);
        fprintf(fcfg, "%s\n\t{\n\t\t\"quota\" : \"%s%s%s%d;%s\",", v3, v5, v39, v43, v41, v10);
      }
      ++v2;
      v11 = json_escape(v14->rpc_user);
      fprintf(fcfg, "\n\t\t\"user\" : \"%s\",", v11);
      v12 = json_escape(v14->rpc_pass);
      fprintf(fcfg, "\n\t\t\"pass\" : \"%s\"\n\t}", v12);
    }
    while ( total_pools > v2 );
  }
  fwrite("\n]\n", 1u, 3u, fcfg);
  if ( opt_config_table[0].type != opt_type::OPT_END )
  {
    v23 = &opt_config_table[1];
    while ( 1 )
    {
      v24 = _strdup(v23[-1].names);
      v25 = strtok(v24, (const char *)&word_4F67C);
      if ( v25 )
        break;
LABEL_67:
      ++v23;
      free(v24);
      if ( v23[-1].type == opt_type::OPT_END )
        goto LABEL_68;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v25[1] != 45 || v23[-1].desc == opt_hidden )
          goto LABEL_53;
        type = v23[-1].type;
        if ( (type & 1) != 0 )
        {
          cb = (char *(__fastcall *)(bool *))v23[-1].cb;
          v31 = cb == opt_set_bool;
          if ( cb != opt_set_bool )
            v31 = cb == opt_set_invbool;
          if ( v31 && *(_BYTE *)v23[-1].u.carg == (cb == opt_set_bool) )
          {
            fprintf(fcfg, ",\n\"%s\" : true", v25 + 2);
            goto LABEL_53;
          }
        }
        if ( (type & 2) == 0 )
          goto LABEL_63;
        cb_arg = (char *(__fastcall *)(const char *, int *))v23[-1].cb_arg;
        v27 = cb_arg == set_int_0_to_9999;
        if ( cb_arg != set_int_0_to_9999 )
          v27 = cb_arg == opt_set_intval;
        v28 = v27;
        if ( cb_arg == set_int_1_to_65535 )
          v28 |= 1u;
        if ( cb_arg == set_int_0_to_10 )
          v28 |= 1u;
        if ( cb_arg == set_int_1_to_10 )
          v28 |= 1u;
        if ( cb_arg == set_int_0_to_100 )
          v28 |= 1u;
        if ( cb_arg == set_int_0_to_255 )
          v28 |= 1u;
        if ( cb_arg == set_int_0_to_200 )
          v28 |= 1u;
        if ( cb_arg == set_int_0_to_4 )
          v28 |= 1u;
        if ( cb_arg == set_int_32_to_63 )
          v28 |= 1u;
        if ( cb_arg == set_int_22_to_55 )
          v28 |= 1u;
        if ( cb_arg == set_int_42_to_65 )
          v28 |= 1u;
        if ( !v28 )
          break;
        fprintf(fcfg, ",\n\"%s\" : \"%d\"", v25 + 2, *(_DWORD *)v23[-1].u.carg);
LABEL_53:
        v25 = strtok(0, (const char *)&word_4F67C);
        if ( !v25 )
          goto LABEL_67;
      }
      v38 = (char *)cb_arg == (char *)set_float_100_to_250;
      if ( (char *)cb_arg != (char *)set_float_100_to_250 )
        v38 = (char *)cb_arg == (char *)set_float_125_to_500;
      if ( v38 )
      {
        fprintf(fcfg, ",\n\"%s\" : \"%.1f\"", v25 + 2, *(float *)v23[-1].u.carg);
        goto LABEL_53;
      }
LABEL_63:
      if ( (type & 6) == 0 )
        goto LABEL_53;
      carg = (char **)v23[-1].u.carg;
      if ( carg == &opt_set_null || !*carg )
        goto LABEL_53;
      v33 = json_escape(*carg);
      fprintf(fcfg, ",\n\"%s\" : \"%s\"", v25 + 2, v33);
      v25 = strtok(0, (const char *)&word_4F67C);
      if ( !v25 )
        goto LABEL_67;
    }
  }
LABEL_68:
  v34 = pool_strategy_0;
  if ( pool_strategy_0 == pool_strategy::POOL_BALANCE )
  {
    fwrite(",\n\"balance\" : true", 1u, 0x12u, fcfg);
    v34 = pool_strategy_0;
  }
  if ( v34 == pool_strategy::POOL_LOADBALANCE )
  {
    fwrite(",\n\"load-balance\" : true", 1u, 0x17u, fcfg);
    v34 = pool_strategy_0;
  }
  if ( v34 == pool_strategy::POOL_ROUNDROBIN )
  {
    fwrite(",\n\"round-robin\" : true", 1u, 0x16u, fcfg);
    v34 = pool_strategy_0;
  }
  if ( v34 == pool_strategy::POOL_ROTATE )
    fprintf(fcfg, ",\n\"rotate\" : \"%d\"", opt_rotate_period);
  fwrite("\n}\n", 1u, 3u, fcfg);
  next = jedata;
  jedata = 0;
  if ( next )
  {
    do
    {
      v36 = *next;
      free(next->buf);
      v37 = next;
      next = v36.next;
      free(v37);
    }
    while ( v36.next );
  }
}
// 4F67C: using guessed type __int16 word_4F67C;
// 59398: using guessed type char byte_59398;

//----- (00019EF4) --------------------------------------------------------
void zero_bestshare()
{
  pool **v0; // r3
  pool **v1; // r4
  int v2; // t1

  *(_DWORD *)best_share = 0;
  *(_DWORD *)&best_share[4] = 0;
  best_diff = 0;
  suffix_string(0, best_share, 8u, 0);
  if ( total_pools > 0 )
  {
    v0 = pools;
    v1 = &pools[total_pools];
    do
    {
      v2 = (int)*v0++;
      *(_DWORD *)(v2 + 400) = 0;
      *(_DWORD *)(v2 + 404) = 0;
    }
    while ( v0 != v1 );
  }
}

//----- (00019F58) --------------------------------------------------------
void __fastcall default_save_file(char *filename)
{
  char *v2; // r0

  if ( default_config && *default_config )
  {
    j_strcpy(filename, default_config);
  }
  else
  {
    if ( getenv("HOME") && *getenv("HOME") )
    {
      v2 = getenv("HOME");
      *(_WORD *)stpcpy(filename, v2) = 47;
    }
    else
    {
      *filename = 0;
    }
    strcat(filename, ".cgminer/");
    mkdir(filename, 0x1FFu);
    strcat(filename, "cgminer.conf");
  }
}
// 120CC: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (0001A000) --------------------------------------------------------
void __fastcall set_target(unsigned __int8 *dest_target, double diff)
{
  double v3; // d0
  double v5; // d7
  double v6; // d8
  double v7; // d8
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r1
  int v12; // r2
  int v13; // r3
  char *v14; // r6
  unsigned __int8 target[32]; // [sp+0h] [bp-1020h] BYREF
  char tmp42[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( v3 == 0.0 )
  {
    if ( use_syslog || opt_log_output || (v3 = 1.0, opt_log_level > 2) )
    {
      strcpy(tmp42, "Diff zero passed to set_target");
      applog(3, tmp42, 0);
      v3 = 1.0;
    }
  }
  v5 = 2.69595353e67;
  if ( opt_scrypt )
    v5 = 1.7668201e72;
  *(_QWORD *)&target[24] = (unsigned __int64)(v5 / v3 * 1.59309191e-58);
  v6 = v5 / v3 - (double)*(unsigned __int64 *)&target[24] * 6.27710174e57;
  *(_QWORD *)&target[16] = (unsigned __int64)(v6 * 2.93873588e-39);
  v7 = v6 - (double)*(unsigned __int64 *)&target[16] * 3.40282367e38;
  *(_QWORD *)&target[8] = (unsigned __int64)(v7 * 5.42101086e-20);
  *(_QWORD *)target = (unsigned __int64)(v7 - (double)*(unsigned __int64 *)&target[8] * 1.84467441e19);
  if ( opt_debug )
  {
    v14 = bin2hex(target, 0x20u);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "Generated target %s", v14);
      applog(7, tmp42, 0);
    }
    free(v14);
  }
  v8 = *(_DWORD *)&target[4];
  v9 = *(_DWORD *)&target[8];
  v10 = *(_DWORD *)&target[12];
  *(_DWORD *)dest_target = *(_DWORD *)target;
  *((_DWORD *)dest_target + 1) = v8;
  *((_DWORD *)dest_target + 2) = v9;
  *((_DWORD *)dest_target + 3) = v10;
  v11 = *(_DWORD *)&target[20];
  v12 = *(_DWORD *)&target[24];
  v13 = *(_DWORD *)&target[28];
  *((_DWORD *)dest_target + 4) = *(_DWORD *)&target[16];
  *((_DWORD *)dest_target + 5) = v11;
  *((_DWORD *)dest_target + 6) = v12;
  *((_DWORD *)dest_target + 7) = v13;
}
// 1A014: variable 'v3' is possibly undefined

//----- (0001A1D0) --------------------------------------------------------
int __fastcall add_var_int(uint8_t *msg, int a2, uint64_t var_int)
{
  bool v3; // cf
  uint8_t v4; // r3
  int v6; // r4
  size_t v7; // r2
  uint64_t v8; // [sp+0h] [bp-Ch] BYREF

  v8 = var_int;
  if ( var_int >= 0xFD )
  {
    if ( var_int >= 0x10000 )
    {
      v3 = HIDWORD(var_int) != 0;
      if ( HIDWORD(var_int) == 1 )
        v3 = 1;
      if ( v3 )
      {
        v6 = 9;
        v7 = 8;
      }
      else
      {
        v6 = 5;
        v7 = 4;
      }
      if ( v3 )
        v4 = -1;
      else
        v4 = -2;
      *msg = v4;
    }
    else
    {
      v6 = 3;
      *msg = -3;
      v7 = 2;
    }
  }
  else
  {
    *msg = var_int;
    v6 = 1;
    v7 = 0;
  }
  memcpy(msg + 1, &v8, v7);
  return v6;
}

//----- (0001A228) --------------------------------------------------------
int __fastcall share_work_tdiff(cgpu_info *cgpu)
{
  return last_getwork - cgpu->last_device_valid_work;
}

//----- (0001A23C) --------------------------------------------------------
bool __fastcall test_nonce(work *work, uint32_t nonce)
{
  unsigned int v3; // r3

  *(_DWORD *)&work->data[76] = nonce;
  rebuild_hash(work);
  v3 = 0xFFFF;
  if ( !opt_scrypt )
    v3 = 0;
  return *(_DWORD *)&work->hash[28] <= v3;
}

//----- (0001A268) --------------------------------------------------------
bool __fastcall test_nonce_diff(work *work, uint32_t nonce, double diff)
{
  double v3; // d0
  double v5; // d7

  *(_DWORD *)&work->data[76] = nonce;
  rebuild_hash(work);
  v5 = 4294901760.0;
  if ( opt_scrypt )
    v5 = 2.81470682e14;
  return (unsigned __int64)(v5 / v3) >= *(_QWORD *)&work->hash[24];
}
// 1A294: variable 'v3' is possibly undefined

//----- (0001A2C8) --------------------------------------------------------
void __fastcall _add_queued(cgpu_info *cgpu, work *work)
{
  work *queued_work; // r5
  UT_hash_handle *p_hh; // r1
  __int64 v6; // kr00_8
  int v7; // r5
  unsigned int v8; // r2
  unsigned int v9; // r3
  int v10; // r5
  unsigned int v11; // r2
  unsigned int v12; // r3
  unsigned int v13; // r5
  unsigned int v14; // r3
  UT_hash_bucket *v15; // r5
  unsigned int v16; // r3
  UT_hash_handle *hh_head; // r2
  UT_hash_bucket *v18; // r2
  UT_hash_handle *v19; // r0
  UT_hash_bucket *v20; // r2
  __int64 v21; // r2
  UT_hash_table *v22; // r4
  UT_hash_bucket *v23; // r6
  int v24; // r7
  unsigned int num_items; // r1
  unsigned int v26; // r3
  UT_hash_table *v27; // r2
  unsigned int num_buckets; // r4
  UT_hash_handle *v29; // r5
  UT_hash_handle *hh_next; // r11
  int v31; // r4
  UT_hash_bucket *v32; // r8
  unsigned int v33; // r0
  UT_hash_handle *v34; // r3
  UT_hash_table *v35; // r3
  unsigned int nonideal_items; // r2
  unsigned int v37; // r1
  bool v38; // cc
  unsigned int ineff_expands; // r2
  UT_hash_table *v40; // r3
  work *v41; // r6
  UT_hash_table *tbl; // r0
  UT_hash_table *v43; // r6
  UT_hash_bucket *buckets; // r0
  unsigned int _he_bkt_i; // [sp+4h] [bp-8h]

  ++cgpu->queued_count;
  work->hh.next = 0;
  work->hh.key = &work->id;
  work->hh.keylen = 4;
  queued_work = cgpu->queued_work;
  if ( queued_work )
  {
    p_hh = &work->hh;
    queued_work->hh.tbl->tail->next = work;
    v6 = *(_QWORD *)&cgpu->queued_work->hh.tbl->tail;
    work->hh.prev = (void *)(v6 - HIDWORD(v6));
    cgpu->queued_work->hh.tbl->tail = &work->hh;
  }
  else
  {
    cgpu->queued_work = work;
    work->hh.prev = 0;
    v41 = cgpu->queued_work;
    v41->hh.tbl = (UT_hash_table *)malloc(0x2Cu);
    tbl = cgpu->queued_work->hh.tbl;
    if ( !tbl )
      goto LABEL_33;
    memset(tbl, 0, sizeof(UT_hash_table));
    cgpu->queued_work->hh.tbl->tail = &cgpu->queued_work->hh;
    cgpu->queued_work->hh.tbl->num_buckets = 32;
    cgpu->queued_work->hh.tbl->log2_num_buckets = 5;
    cgpu->queued_work->hh.tbl->hho = 1832;
    v43 = cgpu->queued_work->hh.tbl;
    v43->buckets = (UT_hash_bucket *)malloc(0x180u);
    buckets = cgpu->queued_work->hh.tbl->buckets;
    if ( !buckets )
      goto LABEL_33;
    memset(buckets, 0, 0x180u);
    p_hh = &work->hh;
    cgpu->queued_work->hh.tbl->signature = -1609490463;
  }
  ++cgpu->queued_work->hh.tbl->num_items;
  v7 = (LOBYTE(work->id) + 17973517 + (HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16) + (BYTE1(work->id) << 8))
     ^ 0x7F76D;
  v8 = (-1622558010 - v7) ^ (v7 << 8);
  v9 = (-17973517 - v7 - v8) ^ (v8 >> 13);
  work->hh.tbl = cgpu->queued_work->hh.tbl;
  v10 = (v7 - v8 - v9) ^ (v9 >> 12);
  v11 = (v8 - v9 - v10) ^ (v10 << 16);
  v12 = (v9 - v10 - v11) ^ (v11 >> 5);
  v13 = v10 - v11 - v12;
  v14 = (v12 - (v13 ^ (v12 >> 3)) - ((v11 - v12 - (v13 ^ (v12 >> 3))) ^ ((v13 ^ (v12 >> 3)) << 10)))
      ^ (((v11 - v12 - (v13 ^ (v12 >> 3))) ^ ((v13 ^ (v12 >> 3)) << 10)) >> 15);
  work->hh.hashv = v14;
  v15 = cgpu->queued_work->hh.tbl->buckets;
  v16 = v14 & (cgpu->queued_work->hh.tbl->num_buckets - 1);
  ++v15[v16].count;
  hh_head = cgpu->queued_work->hh.tbl->buckets[v16].hh_head;
  work->hh.hh_prev = 0;
  work->hh.hh_next = hh_head;
  v18 = cgpu->queued_work->hh.tbl->buckets;
  v19 = v18[v16].hh_head;
  v20 = &v18[v16];
  if ( v19 )
  {
    v19->hh_prev = p_hh;
    v20 = &cgpu->queued_work->hh.tbl->buckets[v16];
  }
  v20->hh_head = p_hh;
  v21 = *(_QWORD *)&cgpu->queued_work->hh.tbl->buckets[v16].count;
  if ( (unsigned int)v21 >= 10 * (HIDWORD(v21) + 1) )
  {
    v22 = work->hh.tbl;
    if ( v22->noexpand != 1 )
    {
      v23 = (UT_hash_bucket *)calloc(24 * v22->num_buckets, 1u);
      if ( v23 )
      {
        v24 = 0;
        num_items = v22->num_items;
        v26 = num_items >> (*(_QWORD *)&v22->log2_num_buckets + 1);
        if ( ((2 * v22->num_buckets - 1) & num_items) != 0 )
          ++v26;
        v22->ideal_chain_maxlen = v26;
        work->hh.tbl->nonideal_items = 0;
        v27 = work->hh.tbl;
        num_buckets = v27->num_buckets;
        if ( num_buckets )
        {
          for ( _he_bkt_i = 0; _he_bkt_i < num_buckets; ++_he_bkt_i )
          {
            v29 = v27->buckets[v24].hh_head;
            if ( v29 )
            {
              while ( 1 )
              {
                hh_next = v29->hh_next;
                v31 = (2 * num_buckets - 1) & v29->hashv;
                v32 = &v23[v31];
                v33 = v32->count + 1;
                v32->count = v33;
                if ( v33 > v27->ideal_chain_maxlen )
                {
                  ++v27->nonideal_items;
                  v32->expand_mult = v32->count / work->hh.tbl->ideal_chain_maxlen;
                }
                v29->hh_prev = 0;
                v29->hh_next = v23[v31].hh_head;
                v34 = v23[v31].hh_head;
                if ( v34 )
                  v34->hh_prev = v29;
                v23[v31].hh_head = v29;
                v27 = work->hh.tbl;
                if ( !hh_next )
                  break;
                num_buckets = v27->num_buckets;
                v29 = hh_next;
              }
              num_buckets = v27->num_buckets;
            }
            ++v24;
          }
        }
        free(v27->buckets);
        work->hh.tbl->num_buckets *= 2;
        ++work->hh.tbl->log2_num_buckets;
        work->hh.tbl->buckets = v23;
        v35 = work->hh.tbl;
        nonideal_items = v35->nonideal_items;
        v37 = v35->num_items;
        v38 = nonideal_items > v37 >> 1;
        if ( nonideal_items <= v37 >> 1 )
          ineff_expands = 0;
        else
          ineff_expands = v35->ineff_expands;
        if ( v38 )
          ++ineff_expands;
        v35->ineff_expands = ineff_expands;
        v40 = work->hh.tbl;
        if ( v40->ineff_expands > 1 )
          v40->noexpand = 1;
        return;
      }
LABEL_33:
      exit(-1);
    }
  }
}

//----- (0001A5E8) --------------------------------------------------------
work *__fastcall _find_work_bymidstate(
        work *que,
        char *midstate,
        size_t midstatelen,
        char *data,
        int offset,
        size_t datalen)
{
  work *v6; // r5
  work *next; // r4

  v6 = que;
  if ( que )
  {
    next = (work *)que->hh.next;
    while ( memcmp(v6->midstate, midstate, midstatelen) || memcmp(&v6->data[offset], data, datalen) )
    {
      if ( !next )
        return next;
      v6 = next;
      next = (work *)next->hh.next;
    }
  }
  return v6;
}

//----- (0001A62C) --------------------------------------------------------
work *__fastcall _find_work_byid(work *que, uint32_t id)
{
  void *next; // r3

  if ( que )
  {
    next = que->hh.next;
    if ( id != que->id )
    {
      if ( next )
      {
        que = (work *)*((_DWORD *)next + 460);
        while ( *((_DWORD *)next + 457) != id )
        {
          if ( !que )
            return que;
          next = que;
          que = (work *)que->hh.next;
        }
      }
      return (work *)next;
    }
  }
  return que;
}

//----- (0001A65C) --------------------------------------------------------
void __fastcall _work_completed(cgpu_info *cgpu, work *work)
{
  work *queued_work; // r4
  char *prev; // r2
  UT_hash_table *tbl; // r5
  UT_hash_handle *p_hh; // r4
  ptrdiff_t hho; // r3
  work *next; // r6
  char *v8; // r3
  UT_hash_table *v9; // r2
  unsigned int v10; // r3
  UT_hash_bucket *buckets; // r2
  UT_hash_handle *hh_prev; // r2
  UT_hash_handle *hh_next; // r3

  queued_work = cgpu->queued_work;
  --cgpu->queued_count;
  prev = (char *)work->hh.prev;
  if ( !prev )
  {
    next = (work *)work->hh.next;
    tbl = queued_work->hh.tbl;
    if ( !next )
    {
      free(tbl->buckets);
      free(cgpu->queued_work->hh.tbl);
      cgpu->queued_work = 0;
      return;
    }
    hho = tbl->hho;
    p_hh = &work->hh;
    if ( work != (work *)((char *)tbl->tail - hho) )
      goto LABEL_17;
    goto LABEL_13;
  }
  tbl = queued_work->hh.tbl;
  p_hh = &work->hh;
  hho = tbl->hho;
  if ( work == (work *)((char *)tbl->tail - hho) )
  {
LABEL_13:
    tbl->tail = (UT_hash_handle *)&prev[hho];
    prev = (char *)work->hh.prev;
    if ( prev )
    {
      hho = cgpu->queued_work->hh.tbl->hho;
      goto LABEL_3;
    }
    next = (work *)work->hh.next;
LABEL_17:
    cgpu->queued_work = next;
    goto LABEL_4;
  }
LABEL_3:
  *(_DWORD *)&prev[hho + 8] = work->hh.next;
  next = cgpu->queued_work;
LABEL_4:
  v8 = (char *)work->hh.next;
  v9 = next->hh.tbl;
  if ( v8 )
  {
    *(_DWORD *)&v8[v9->hho + 4] = work->hh.prev;
    v9 = cgpu->queued_work->hh.tbl;
  }
  v10 = (v9->num_buckets - 1) & work->hh.hashv;
  --v9->buckets[v10].count;
  buckets = cgpu->queued_work->hh.tbl->buckets;
  if ( buckets[v10].hh_head == p_hh )
    buckets[v10].hh_head = work->hh.hh_next;
  hh_prev = work->hh.hh_prev;
  hh_next = work->hh.hh_next;
  if ( hh_prev )
  {
    hh_prev->hh_next = hh_next;
    hh_next = work->hh.hh_next;
  }
  if ( hh_next )
    hh_next->hh_prev = work->hh.hh_prev;
  --cgpu->queued_work->hh.tbl->num_items;
}

//----- (0001A75C) --------------------------------------------------------
void __fastcall reinit_device(cgpu_info *cgpu)
{
  if ( cgpu->deven != dev_enable::DEV_DISABLED )
    ((void (*)(void))cgpu->drv->reinit_device)();
}

//----- (0001A76C) --------------------------------------------------------
void __fastcall __noreturn _quit(int a1, int a2)
{
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  if ( !pthread_create(newthread, 0, killall_thread, 0) )
  {
    if ( a2 )
    {
      cgtime(&total_tv_end);
      if ( !opt_realquiet && successful_connect )
        print_summary();
    }
    if ( forkpid > 0 )
    {
      kill(forkpid, 15);
      forkpid = 0;
    }
    pthread_cancel(newthread[0]);
    exit(a1);
  }
  exit(1);
}

//----- (0001A7E8) --------------------------------------------------------
void __noreturn kill_work()
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  cg_completion_timeout(_kill_work, 0, 5000);
  strcpy(tmp42, "Shutdown signal received.");
  applog(3, tmp42, 1);
  _quit(0, 1);
}

//----- (0001A82C) --------------------------------------------------------
void __fastcall __noreturn sighandler(int sig)
{
  sigaction_0(15, &termhandler, 0);
  sigaction_0(2, &inthandler, 0);
  kill_work();
}

//----- (0001A854) --------------------------------------------------------
void __fastcall setup_url(pool *pool, char *arg)
{
  char *proxy; // r5
  char *v4; // r0
  char *v5; // r7
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  proxy = get_proxy(arg, pool);
  if ( !detect_stratum(pool, proxy) )
  {
    opt_set_charp(proxy, &pool->rpc_url);
    if ( strncmp(proxy, "http://", 7u) )
    {
      if ( strncmp(proxy, "https://", 8u) )
      {
        v4 = (char *)malloc(0x100u);
        v5 = v4;
        if ( !v4 )
        {
          strcpy(tmp42, "Failed to malloc httpinput");
          applog(3, tmp42, 1);
          _quit(1, 1);
        }
        strcpy(v4, "stratum+tcp://");
        strncat(v4, proxy, 0xF2u);
        detect_stratum(pool, v5);
      }
    }
  }
}

//----- (0001A910) --------------------------------------------------------
int __fastcall get_statline(char *a1, size_t a2, cgpu_info *cgpu)
{
  double v3; // d0
  double v7; // d8
  uint64_t rolling; // r8
  char v10[16]; // [sp+28h] [bp-1064h] BYREF
  char v11[16]; // [sp+38h] [bp-1054h] BYREF
  char s[64]; // [sp+48h] [bp-1044h] BYREF
  char str[4100]; // [sp+88h] [bp-1004h] BYREF

  cgpu_runtime(cgpu);
  v7 = (double)cgpu->diff1 / v3 * 60.0;
  rolling = (unsigned __int64)cgpu->rolling;
  suffix_string((unsigned __int64)(cgpu->total_mhashes / v3), v10, 0x10u, 4);
  suffix_string(rolling, v11, 0x10u, 4);
  snprintf(a1, a2, "%s%d ", cgpu->drv->name, cgpu->device_id);
  cgpu->drv->get_statline_before(a1, a2, cgpu);
  LODWORD(rolling) = strlen(a1);
  snprintf(
    s,
    0x40u,
    "(%ds):%s (avg):%sh/s | A:%.0f R:%.0f HW:%d WU:%.1f/m",
    opt_log_interval,
    v11,
    v10,
    cgpu->diff_accepted,
    cgpu->diff_rejected,
    cgpu->hw_errors,
    v7);
  if ( strlen(s) + (unsigned int)rolling >= a2 )
  {
    snprintf(str, 0x1000u, "tailsprintf buffer overflow in %s %s line %d", "cgminer.c", "get_statline", 3081);
    applog(3, str, 1);
    _quit(1);
  }
  strcat(a1, s);
  return ((int (__fastcall *)(char *, size_t, cgpu_info *))cgpu->drv->get_statline)(a1, a2, cgpu);
}
// 1A948: variable 'v3' is possibly undefined
// 1A76C: using guessed type void __fastcall __noreturn _quit(_DWORD);

//----- (0001AA64) --------------------------------------------------------
// Alternative name is 'restart_threads.part.56'
void __noreturn restart_threads_0()
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  strcpy(tmp42, "Failed to create restart thread");
  applog(3, tmp42, 1);
  _quit(1, 1);
}

//----- (0001AA94) --------------------------------------------------------
int restart_threads()
{
  void *(*v0)(void *); // r2
  int result; // r0
  pthread_t newthread[2]; // [sp+4h] [bp-8h] BYREF

  cgtime(&restart_tv_start);
  LOWORD(v0) = 2185;
  HIWORD(v0) = (unsigned int)&loc_24020 >> 16;
  result = pthread_create(newthread, 0, v0, 0);
  if ( result )
    restart_threads_0();
  return result;
}

//----- (0001AAC0) --------------------------------------------------------
// Alternative name is 'load_config.part.59'
char *__fastcall load_config_0(const char *arg, void *unused)
{
  json_t *v3; // r0
  size_t v4; // r4
  size_t v5; // r4
  char *v6; // r0
  char *v7; // r7
  json_error_t err; // [sp+Ch] [bp-1100h] BYREF
  char tmp42[4100]; // [sp+108h] [bp-1004h] BYREF

  v3 = json_load_file(arg, 0, &err);
  if ( v3 && v3->type == JSON_OBJECT )
  {
    config_loaded = 1;
    return parse_config(v3, 1);
  }
  else
  {
    v4 = strlen(arg);
    v5 = v4 + strlen(err.text) + 35;
    v6 = (char *)malloc(v5);
    v7 = v6;
    if ( !v6 )
    {
      strcpy(tmp42, "Malloc failure in json error");
      applog(3, tmp42, 1);
      _quit(1, 1);
    }
    snprintf(v6, v5, "JSON decode of file '%s' failed\n %s", arg, err.text);
    return v7;
  }
}

//----- (0001AB5C) --------------------------------------------------------
char *__fastcall load_config(const char *arg, void *unused)
{
  bool v3; // nf

  if ( !cnfbuf )
    cnfbuf = _strdup(arg);
  v3 = include_count - 9 < 0;
  ++include_count;
  if ( v3 ^ __OFSUB__(include_count, 10) | (include_count == 10) )
    return load_config_0(arg, unused);
  else
    return "Too many levels of JSON includes (limit 10) or a loop";
}
// 1AB8C: variable 'unused' is possibly undefined

//----- (0001AB98) --------------------------------------------------------
char *__fastcall parse_config(const json_t *a1, int a2)
{
  opt_table *v3; // r5
  opt_type type; // r3
  const char *names; // r0
  char *v6; // r9
  char *v7; // r4
  json_t *v8; // r0
  const json_t *v9; // r7
  opt_type v10; // r3
  const char *v11; // r3
  json_t *v12; // r0
  const char *v13; // r0
  const char *v15; // r7
  int v16; // r0
  size_t v17; // r4
  json_t *v18; // r0
  int v19; // r0
  const char *v21; // [sp+14h] [bp-1010h]
  char *v22; // [sp+14h] [bp-1010h]
  char *arg; // [sp+18h] [bp-100Ch]
  const char *v24; // [sp+1Ch] [bp-1008h]
  char s[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( a2 && !fileconf_load )
    fileconf_load = 1;
  if ( opt_config_table[0].type == opt_type::OPT_END )
    goto LABEL_29;
  if ( (opt_config_table[0].type & 8) != 0 )
LABEL_51:
    _assert_fail("!(opt->type & OPT_SUBTABLE)", "cgminer.c", 0x7A0u, "parse_config");
  v3 = &opt_config_table[1];
  while ( 1 )
  {
    names = v3[-1].names;
    if ( !names )
    {
      type = v3->type;
      if ( type == opt_type::OPT_END )
        break;
      goto LABEL_8;
    }
    v6 = _strdup(names);
    v7 = strtok(v6, (const char *)&word_4F67C);
    if ( v7 )
    {
      while ( 1 )
      {
        if ( v7[1] != 45 )
          goto LABEL_12;
        v8 = json_object_get(a1, v7 + 2);
        v9 = v8;
        if ( !v8 )
          goto LABEL_12;
        v10 = v3[-1].type;
        if ( (v10 & 6) != 0 )
        {
          if ( v8->type != JSON_STRING )
          {
            if ( v8->type == JSON_ARRAY )
            {
              v22 = v7;
              v17 = 0;
              if ( json_array_size(v8) )
              {
                while ( 1 )
                {
                  v18 = json_array_get(v9, v17);
                  if ( !v18 )
                    goto LABEL_12;
                  if ( v18->type == JSON_STRING )
                  {
                    arg = (char *)json_string_value(v18);
                    v19 = (int)v3[-1].cb_arg(arg, v3[-1].u.arg);
                    v11 = (const char *)v19;
                    if ( v3[-1].type == opt_type::OPT_PROCESSARG )
                    {
                      v24 = (const char *)v19;
                      opt_set_charp(arg, (char **)v3[-1].u.carg);
                      v11 = v24;
                      if ( v24 )
                        goto LABEL_46;
                    }
                    else if ( v19 )
                    {
                      goto LABEL_46;
                    }
                  }
                  else if ( v18->type == JSON_OBJECT )
                  {
                    v11 = (const char *)parse_config();
                    if ( v11 )
                    {
LABEL_46:
                      v7 = v22;
                      goto LABEL_22;
                    }
                  }
                  if ( json_array_size(v9) <= ++v17 )
                    goto LABEL_12;
                }
              }
              goto LABEL_12;
            }
            goto LABEL_18;
          }
          v15 = json_string_value(v8);
          v16 = (int)v3[-1].cb_arg(v15, v3[-1].u.arg);
          v11 = (const char *)v16;
          if ( v3[-1].type != opt_type::OPT_PROCESSARG )
            goto LABEL_21;
          v21 = (const char *)v16;
          opt_set_charp(v15, (char **)v3[-1].u.carg);
          v11 = v21;
          if ( v21 )
          {
LABEL_22:
            if ( !a2 )
              goto LABEL_33;
            goto LABEL_23;
          }
LABEL_12:
          v7 = strtok(0, (const char *)&word_4F67C);
          if ( !v7 )
            break;
        }
        else
        {
LABEL_18:
          if ( (v10 & 1) != 0 && v8->type == JSON_TRUE )
          {
            v11 = v3[-1].cb(v3[-1].u.tlen);
LABEL_21:
            if ( v11 )
              goto LABEL_22;
            goto LABEL_12;
          }
          v11 = "Invalid value";
          if ( !a2 )
          {
LABEL_33:
            snprintf(err_buf_15170, 0xC8u, "Parsing JSON option %s: %s", v7, v11);
            return err_buf_15170;
          }
LABEL_23:
          if ( use_syslog || opt_log_output || opt_log_level > 2 )
          {
            snprintf(s, 0x1000u, "Invalid config option %s: %s", v7, v11);
            applog(3, s, 0);
          }
          fileconf_load = -1;
          v7 = strtok(0, (const char *)&word_4F67C);
          if ( !v7 )
            break;
        }
      }
    }
    free(v6);
    type = v3->type;
    if ( type == opt_type::OPT_END )
      break;
LABEL_8:
    ++v3;
    if ( (type & 8) != 0 )
      goto LABEL_51;
  }
LABEL_29:
  v12 = json_object_get(a1, "include");
  if ( !v12 || v12->type != JSON_STRING )
    return 0;
  v13 = json_string_value(v12);
  return load_config(v13, 0);
}
// 4F67C: using guessed type __int16 word_4F67C;

//----- (0001AE10) --------------------------------------------------------
bool __fastcall benchfile_get_work(work *work)
{
  char *v2; // r4
  bool v3; // r4
  int v4; // r5
  FILE *v6; // r0
  char *v7; // r0
  char **v8; // r11
  int v9; // r9
  char *v10; // r0
  int v11; // r12
  char *v12; // r3
  int length; // lr
  int v14; // r9
  _BOOL4 v15; // r1
  size_t v16; // r0
  size_t v17; // r10
  char *v18; // r9
  char *v19; // r5
  char *v20; // r8
  const char *v21; // r2
  char *v22; // r9
  char *v23; // r5
  char *v24; // r8
  const char *v25; // r2
  int v26; // r0
  unsigned __int8 *v27; // r1
  char **v28; // r2
  unsigned int v29; // t1
  uint32_t v30; // r1
  uint32_t v31; // r2
  uint32_t v32; // r3
  uint32_t v33; // r1
  uint32_t v34; // r2
  uint32_t v35; // r3
  char *nptr; // [sp+14h] [bp-1508h]
  char *commas[5]; // [sp+1Ch] [bp-1500h] BYREF
  unsigned __int8 message[8]; // [sp+30h] [bp-14ECh] BYREF
  int v39; // [sp+6Ch] [bp-14B0h] BYREF
  sha256_ctx ctx; // [sp+70h] [bp-14ACh] BYREF
  char buf[1024]; // [sp+118h] [bp-1404h] BYREF
  char tmp42[4100]; // [sp+518h] [bp-1004h] BYREF

  if ( !benchfile_in )
  {
    if ( !opt_benchfile )
    {
      strcpy(tmp42, "BENCHFILE Invalid benchfile NULL");
      applog(3, tmp42, 1);
      _quit(1, 1);
    }
    v6 = fopen(opt_benchfile, "r");
    benchfile_in = v6;
    if ( v6 )
    {
      benchfile_line = 0;
      if ( fgets(buf, 1024, v6) )
      {
        benchfile_work = 0;
        while ( 1 )
        {
LABEL_3:
          v3 = buf[0] != 35;
          v4 = benchfile_line + 1;
          if ( !buf[0] )
            v3 = 0;
          ++benchfile_line;
          v2 = (char *)(buf[0] != 47 && v3);
          if ( v2 )
            break;
          if ( !fgets(buf, 1024, benchfile_in) )
            goto LABEL_10;
        }
        v7 = buf;
        v8 = commas;
        v9 = 0;
        commas[0] = buf;
        do
        {
          v10 = strchr(v7, 44);
          v11 = v9 + 1;
          v12 = v10;
          v8[1] = v10;
          if ( !v10 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "BENCHFILE Invalid input file line %d - field count is %d but should be %d",
              v4,
              v9 + 1,
              5);
            goto LABEL_32;
          }
          ++v8;
          length = benchfile_data[v9].length;
          v14 = 8 * v9;
          v15 = length != v10 - *(v8 - 1);
          if ( !length )
            v15 = 0;
          if ( v15 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be %d",
              v4,
              v11,
              *(const char **)&_func___16862[v14 + 272],
              v10 - *(v8 - 1),
              length);
            goto LABEL_32;
          }
          v7 = v10 + 1;
          v9 = v11;
          *v12 = 0;
          *v8 = v12 + 1;
        }
        while ( v11 != 4 );
        nptr = commas[4];
        v16 = strlen(commas[4]);
        if ( v16 > 9 )
        {
          sprintf(tmp42, "0000000%c", (unsigned __int8)*commas[0]);
          v17 = strlen(tmp42);
          v18 = &tmp42[v17];
          v19 = commas[2] + 56;
          v20 = commas[2] - 8;
          do
          {
            v21 = v19;
            v19 -= 8;
            sprintf(v18, "%.8s", v21);
            v18 += 8;
          }
          while ( v20 != v19 );
          v22 = &tmp42[v17 + 64];
          v23 = commas[1] + 56;
          v24 = commas[1] - 8;
          do
          {
            v25 = v23;
            v23 -= 8;
            sprintf(v22, "%.8s", v25);
            v22 += 8;
          }
          while ( v24 != v23 );
          v26 = strtol(nptr, 0, 10);
          sprintf(&tmp42[v17 + 128], "%08lx", v26);
          strcpy(&tmp42[v17 + 136], commas[3]);
          memset(work, 0, sizeof(work));
          hex2bin(work->data, tmp42, (int)(v17 + 144) >> 1);
          v27 = &work[-1].device_target[35];
          v28 = &commas[4];
          do
          {
            v29 = *((_DWORD *)v27 + 1);
            v27 += 4;
            v28[1] = (char *)bswap32(v29);
            ++v28;
          }
          while ( &v39 != (int *)v28 );
          sha256_init(&ctx);
          sha256_update(&ctx, message, 0x40u);
          v30 = ctx.h[1];
          v31 = ctx.h[2];
          v32 = ctx.h[3];
          ++benchfile_work;
          *(_DWORD *)work->midstate = ctx.h[0];
          *(_DWORD *)&work->midstate[4] = v30;
          *(_DWORD *)&work->midstate[8] = v31;
          *(_DWORD *)&work->midstate[12] = v32;
          v33 = ctx.h[5];
          v34 = ctx.h[6];
          v35 = ctx.h[7];
          *(_DWORD *)&work->midstate[16] = ctx.h[4];
          *(_DWORD *)&work->midstate[20] = v33;
          *(_DWORD *)&work->midstate[24] = v34;
          *(_DWORD *)&work->midstate[28] = v35;
          return (char)v2;
        }
        snprintf(
          tmp42,
          0x1000u,
          "BENCHFILE Invalid input file line %d field %d (%s) length is %d but should be least %d",
          v4,
          5,
          "NonceTime",
          v16,
          10);
      }
      else
      {
        snprintf(tmp42, 0x1000u, "BENCHFILE Failed to read benchfile '%s'", opt_benchfile);
      }
    }
    else
    {
      snprintf(tmp42, 0x1000u, "BENCHFILE Failed to open benchfile '%s'", opt_benchfile);
    }
LABEL_32:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  v2 = fgets(buf, 1024, benchfile_in);
  if ( v2 )
    goto LABEL_3;
LABEL_10:
  if ( !benchfile_work )
  {
    snprintf(tmp42, 0x1000u, "BENCHFILE No work in benchfile '%s'", opt_benchfile);
    goto LABEL_32;
  }
  fclose(benchfile_in);
  benchfile_in = (FILE *)v2;
  LOBYTE(v2) = benchfile_get_work(work);
  return (char)v2;
}

//----- (0001B188) --------------------------------------------------------
// Alternative name is '_mutex_init.part.39.constprop.66'
void __fastcall __noreturn mutex_init(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1, 1);
}

//----- (0001B1CC) --------------------------------------------------------
// Alternative name is '_mutex_init.constprop.65'
void __fastcall mutex_init_0(pthread_mutex_t *lock, pthread_mutex_t *file, const char *func, const int line)
{
  const char *v6; // r2
  int v7; // r3

  if ( pthread_mutex_init(lock, 0) )
    mutex_init(file, func, v6, v7);
}
// 1B1E0: variable 'v6' is possibly undefined
// 1B1E0: variable 'v7' is possibly undefined

//----- (0001B1E4) --------------------------------------------------------
// Alternative name is '_rwlock_init.part.40.constprop.68'
void __fastcall __noreturn rwlock_init(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1, 1);
}

//----- (0001B228) --------------------------------------------------------
// Alternative name is '_rwlock_init.constprop.67'
void __fastcall rwlock_init_0(pthread_rwlock_t *lock, pthread_rwlock_t *file, const char *func, const int line)
{
  const char *v6; // r2
  int v7; // r3

  if ( pthread_rwlock_init(lock, 0) )
    rwlock_init(file, func, v6, v7);
}
// 1B23C: variable 'v6' is possibly undefined
// 1B23C: variable 'v7' is possibly undefined

//----- (0001B240) --------------------------------------------------------
// Alternative name is '_cglock_init.constprop.64'
int __fastcall cglock_init_constprop_65(int a1, pthread_mutex_t *a2, const char *a3)
{
  const char *v6; // r2
  int v7; // r3
  int result; // r0
  const char *v9; // r2
  int v10; // r3

  if ( pthread_mutex_init((pthread_mutex_t *)a1, 0) )
    mutex_init(a2, a3, v6, v7);
  result = pthread_rwlock_init((pthread_rwlock_t *)(a1 + 24), 0);
  if ( result )
    rwlock_init((pthread_rwlock_t *)a2, a3, v9, v10);
  return result;
}
// 1B262: variable 'v6' is possibly undefined
// 1B262: variable 'v7' is possibly undefined
// 1B26A: variable 'v9' is possibly undefined
// 1B26A: variable 'v10' is possibly undefined

//----- (0001B270) --------------------------------------------------------
// Alternative name is '_wr_lock.part.51.constprop.73'
void __fastcall __noreturn wr_lock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1, 1);
}

//----- (0001B2B4) --------------------------------------------------------
// Alternative name is '_mutex_lock.part.44.constprop.75'
void __fastcall __noreturn mutex_lock(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1, 1);
}

//----- (0001B2F8) --------------------------------------------------------
// Alternative name is '_mutex_unlock_noyield.part.45.constprop.77'
void __fastcall __noreturn mutex_unlock_noyield(
        pthread_mutex_t *lock,
        const char *file,
        const char *func,
        const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1, 1);
}

//----- (0001B33C) --------------------------------------------------------
int __fastcall pool_tset(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  const char *v4; // r2
  int v5; // r3
  pthread_mutex_t *v6; // r0
  int v7; // r4
  const char *v8; // r2
  int v9; // r3

  v2 = (pthread_mutex_t *)(a1 + 220);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 220)) )
    mutex_lock((pthread_mutex_t *)&_func___14516, (const char *)0x304, v4, v5);
  v6 = v2;
  v7 = (unsigned __int8)*a2;
  *a2 = 1;
  if ( pthread_mutex_unlock(v6) )
    mutex_unlock_noyield((pthread_mutex_t *)&_func___14516, (const char *)0x307, v8, v9);
  selective_yield();
  return v7;
}
// 1B370: variable 'v4' is possibly undefined
// 1B370: variable 'v5' is possibly undefined
// 1B37A: variable 'v8' is possibly undefined
// 1B37A: variable 'v9' is possibly undefined

//----- (0001B384) --------------------------------------------------------
int __fastcall pool_tclear(int a1, _BYTE *a2)
{
  pthread_mutex_t *v2; // r4
  const char *v4; // r2
  int v5; // r3
  pthread_mutex_t *v6; // r0
  int v7; // r4
  const char *v8; // r2
  int v9; // r3

  v2 = (pthread_mutex_t *)(a1 + 220);
  if ( pthread_mutex_lock((pthread_mutex_t *)(a1 + 220)) )
    mutex_lock((pthread_mutex_t *)(&_func___14516.__align + 3), (const char *)0x310, v4, v5);
  v6 = v2;
  v7 = (unsigned __int8)*a2;
  *a2 = 0;
  if ( pthread_mutex_unlock(v6) )
    mutex_unlock_noyield((pthread_mutex_t *)(&_func___14516.__align + 3), (const char *)0x313, v8, v9);
  selective_yield();
  return v7;
}
// 1B3B8: variable 'v4' is possibly undefined
// 1B3B8: variable 'v5' is possibly undefined
// 1B3C2: variable 'v8' is possibly undefined
// 1B3C2: variable 'v9' is possibly undefined

//----- (0001B3CC) --------------------------------------------------------
bool __fastcall pool_active(pool *pool, bool pinging)
{
  _BOOL4 v3; // r8
  int v4; // r7
  _BOOL4 v5; // r2
  const char *v6; // r12
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int *v11; // r12
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  int v16; // r0
  int v17; // r1
  int v18; // r2
  int v19; // r3
  int v20; // r1
  int v21; // r2
  int v22; // r3
  char *stratum_url; // r1
  _BOOL4 has_gbt; // r3
  _BOOL4 v26; // r8
  int *v27; // r4
  int v28; // r0
  int v29; // r1
  int v30; // r2
  int v31; // r3
  int *v32; // r4
  int v33; // r0
  int v34; // r1
  int v35; // r2
  int v36; // r3
  int v37; // r4
  timeval tv_getwork; // [sp+8h] [bp-1010h] BYREF
  timeval tv_getwork_reply; // [sp+10h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  v3 = pinging;
  if ( pool->has_gbt )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "Retrieving block template from pool %s", pool->rpc_url);
      goto LABEL_62;
    }
  }
  else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Testing pool %s", pool->rpc_url);
LABEL_62:
    applog(7, tmp42, 0);
  }
  LOBYTE(v4) = pool->has_stratum;
  if ( (_BYTE)v4 )
    goto LABEL_20;
  if ( !curly )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(tmp42, "CURL initialisation failed");
      applog(3, tmp42, 0);
    }
    return v4;
  }
  if ( pool->probed )
    goto LABEL_16;
  if ( !opt_debug )
  {
    pool->probed = v4;
    goto LABEL_16;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
  {
    has_gbt = pool->has_gbt;
    pool->probed = v4;
    if ( !has_gbt )
    {
      if ( !pool->gbt_solo )
      {
        if ( use_syslog )
        {
LABEL_57:
          v6 = "No GBT coinbase + append support found, using getwork protocol";
          goto LABEL_14;
        }
        goto LABEL_55;
      }
LABEL_47:
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        strcpy(tmp42, "GBT coinbase without append found, switching to GBT solo protocol");
        applog(7, tmp42, 0);
      }
      goto LABEL_16;
    }
LABEL_11:
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      v6 = "GBT coinbase + append support found, switching to GBT protocol";
LABEL_14:
      v7 = *(_DWORD *)v6;
      v8 = *((_DWORD *)v6 + 1);
      v9 = *((_DWORD *)v6 + 2);
      v10 = *((_DWORD *)v6 + 3);
      v11 = (int *)(v6 + 16);
      *(_DWORD *)tmp42 = v7;
      *(_DWORD *)&tmp42[4] = v8;
      *(_DWORD *)&tmp42[8] = v9;
      *(_DWORD *)&tmp42[12] = v10;
      v12 = *v11;
      v13 = v11[1];
      v14 = v11[2];
      v15 = v11[3];
      v11 += 4;
      *(_DWORD *)&tmp42[16] = v12;
      *(_DWORD *)&tmp42[20] = v13;
      *(_DWORD *)&tmp42[24] = v14;
      *(_DWORD *)&tmp42[28] = v15;
      v16 = *v11;
      v17 = v11[1];
      v18 = v11[2];
      v19 = v11[3];
      v11 += 4;
      *(_DWORD *)&tmp42[32] = v16;
      *(_DWORD *)&tmp42[36] = v17;
      *(_DWORD *)&tmp42[40] = v18;
      *(_DWORD *)&tmp42[44] = v19;
      v20 = v11[1];
      v21 = v11[2];
      v22 = v11[3];
      *(_DWORD *)&tmp42[48] = *v11;
      *(_DWORD *)&tmp42[52] = v20;
      *(_DWORD *)&tmp42[56] = v21;
      *(_WORD *)&tmp42[60] = v22;
      tmp42[62] = BYTE2(v22);
      applog(7, tmp42, 0);
      goto LABEL_16;
    }
    goto LABEL_16;
  }
  strcpy(tmp42, "Probing for GBT support");
  applog(7, tmp42, 0);
  v5 = pool->has_gbt;
  pool->probed = 0;
  if ( v5 )
  {
    if ( !opt_debug )
      goto LABEL_16;
    goto LABEL_11;
  }
  if ( pool->gbt_solo )
  {
    if ( !opt_debug )
      goto LABEL_16;
    goto LABEL_47;
  }
  if ( !opt_debug )
    goto LABEL_16;
  if ( use_syslog )
    goto LABEL_57;
LABEL_55:
  if ( opt_log_output || opt_log_level > 6 )
    goto LABEL_57;
LABEL_16:
  cgtime(&tv_getwork);
  cgtime(&tv_getwork_reply);
  stratum_url = pool->stratum_url;
  if ( !stratum_url || opt_fix_protocol )
    goto LABEL_18;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Testing pool %d stratum %s", pool->pool_no, pool->stratum_url);
    applog(7, tmp42, 0);
    stratum_url = pool->stratum_url;
  }
  check_extranonce_option(pool, stratum_url);
  if ( extract_sockaddr(pool->stratum_url, &pool->sockaddr_url, &pool->stratum_port) && initiate_stratum(pool) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "Switching pool %d %s to %s", pool->pool_no, pool->rpc_url, pool->stratum_url);
      applog(7, tmp42, 0);
    }
    if ( !pool->rpc_url )
      pool->rpc_url = _strdup(pool->stratum_url);
  }
  else
  {
LABEL_18:
    if ( !initiate_stratum(pool) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "FAILED to retrieve work from pool %u %s", pool->pool_no, pool->rpc_url);
        applog(7, tmp42, 0);
      }
      if ( !v3 && !pool->idle && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        LOBYTE(v4) = 0;
        snprintf(tmp42, 0x1000u, "Pool %u slow/down or URL or credentials invalid", pool->pool_no);
        applog(4, tmp42, 0);
      }
      return v4;
    }
  }
  pool->has_stratum = 1;
LABEL_20:
  v4 = pool_tset((int)pool, &pool->stratum_init);
  if ( v4 )
    return pool->stratum_active;
  if ( initiate_stratum(pool) && (v26 = auth_stratum(pool)) )
  {
    extranonce_subscribe_stratum(pool);
    have_longpoll = 1;
    if ( pthread_create(&pool->stratum_sthread, 0, (void *(*)(void *))stratum_sthread, pool) )
    {
      v27 = (int *)&unk_4FCAC;
LABEL_88:
      v28 = *v27;
      v29 = v27[1];
      v30 = v27[2];
      v31 = v27[3];
      v32 = v27 + 4;
      *(_DWORD *)tmp42 = v28;
      *(_DWORD *)&tmp42[4] = v29;
      *(_DWORD *)&tmp42[8] = v30;
      *(_DWORD *)&tmp42[12] = v31;
      v33 = *v32;
      v34 = v32[1];
      v35 = v32[2];
      v36 = v32[3];
      v37 = v32[4];
      *(_DWORD *)&tmp42[16] = v33;
      *(_DWORD *)&tmp42[20] = v34;
      *(_DWORD *)&tmp42[24] = v35;
      *(_DWORD *)&tmp42[28] = v36;
      tmp42[32] = v37;
      applog(3, tmp42, 1);
      _quit(1, 1);
    }
    LOBYTE(v4) = v26;
    if ( pthread_create(&pool->stratum_rthread, 0, stratum_rthread, pool) )
    {
      v27 = (int *)&unk_4FCD0;
      goto LABEL_88;
    }
  }
  else
  {
    extranonce_subscribe_stratum(pool);
    pool_tclear((int)pool, &pool->stratum_init);
  }
  return v4;
}
// 20978: using guessed type int stratum_sthread();

//----- (0001B904) --------------------------------------------------------
int __fastcall inc_dev_status(int a1, int a2)
{
  const char *v4; // r2
  int v5; // r3
  const char *v6; // r2
  int v7; // r3

  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock((pthread_mutex_t *)&_func___16532, (const char *)0x2081, v4, v5);
  g_max_fan = a1;
  g_max_temp = a2;
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield((pthread_mutex_t *)&_func___16532, (const char *)0x2084, v6, v7);
  return selective_yield();
}
// 1B950: variable 'v4' is possibly undefined
// 1B950: variable 'v5' is possibly undefined
// 1B95A: variable 'v6' is possibly undefined
// 1B95A: variable 'v7' is possibly undefined

//----- (0001B964) --------------------------------------------------------
int wake_gws()
{
  const char *v0; // r2
  int v1; // r3
  const char *v2; // r2
  int v3; // r3

  if ( pthread_mutex_lock(stgd_lock) )
    mutex_lock((pthread_mutex_t *)(&_func___16532.__align + 4), (const char *)0x1454, v0, v1);
  pthread_cond_signal(&gws_cond);
  if ( pthread_mutex_unlock(stgd_lock) )
    mutex_unlock_noyield((pthread_mutex_t *)(&_func___16532.__align + 4), (const char *)0x1456, v2, v3);
  return selective_yield();
}
// 1B9A4: variable 'v0' is possibly undefined
// 1B9A4: variable 'v1' is possibly undefined
// 1B9AE: variable 'v2' is possibly undefined
// 1B9AE: variable 'v3' is possibly undefined

//----- (0001B9B8) --------------------------------------------------------
int __fastcall restart_wait(int a1, unsigned int a2)
{
  unsigned int v4; // r4
  int v5; // r1
  __time_t v6; // r4
  int v7; // r1
  const char *v8; // r2
  int v9; // r3
  int v10; // r4
  const char *v11; // r2
  int v12; // r3
  timeval v14; // [sp+0h] [bp-10h] BYREF
  struct timespec abstime; // [sp+8h] [bp-8h] BYREF

  v4 = a2 / 0x3E8;
  cgtime(&v14);
  v5 = 1000 * a2 - 1000000 * v4;
  v6 = v4 + v14.tv_sec;
  v7 = v5 + v14.tv_usec;
  if ( v7 > 999999 )
  {
    ++v6;
    v7 -= 1000000;
  }
  abstime.tv_sec = v6;
  abstime.tv_nsec = 1000 * v7;
  v10 = pthread_mutex_lock(&restart_lock);
  if ( v10 )
    mutex_lock((pthread_mutex_t *)&_func___15752, (const char *)0x1481, v8, v9);
  if ( !*(_BYTE *)(a1 + 62) )
    v10 = pthread_cond_timedwait(&restart_cond, &restart_lock, &abstime);
  if ( pthread_mutex_unlock(&restart_lock) )
    mutex_unlock_noyield((pthread_mutex_t *)&_func___15752, (const char *)0x1486, v11, v12);
  selective_yield();
  return v10;
}
// 1BA66: variable 'v8' is possibly undefined
// 1BA66: variable 'v9' is possibly undefined
// 1BA70: variable 'v11' is possibly undefined
// 1BA70: variable 'v12' is possibly undefined

//----- (0001BA78) --------------------------------------------------------
// Alternative name is '_rw_unlock.part.36.constprop.79'
void __fastcall __noreturn rw_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1);
}
// 1A76C: using guessed type void __fastcall __noreturn _quit(_DWORD);

//----- (0001BABC) --------------------------------------------------------
uint32_t total_work_inc()
{
  const char *v0; // r2
  int v1; // r3
  const char *v2; // r2
  int v3; // r3
  uint32_t v4; // r4
  const char *v5; // r2
  int v6; // r3
  const char *v7; // r2
  int v8; // r3

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock((pthread_mutex_t *)(&_func___15752.__align + 4), (const char *)0x8E1, v0, v1);
  if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
    wr_lock((pthread_rwlock_t *)(&_func___15752.__align + 4), (const char *)0x8E1, v2, v3);
  v4 = total_work++;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock((pthread_rwlock_t *)(&_func___15752.__align + 4), (const char *)0x8E3, v5, v6);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield((pthread_mutex_t *)(&_func___15752.__align + 4), (const char *)0x8E3, v7, v8);
  selective_yield();
  return v4;
}
// 1BB12: variable 'v0' is possibly undefined
// 1BB12: variable 'v1' is possibly undefined
// 1BB1C: variable 'v2' is possibly undefined
// 1BB1C: variable 'v3' is possibly undefined
// 1BB26: variable 'v5' is possibly undefined
// 1BB26: variable 'v6' is possibly undefined
// 1BB30: variable 'v7' is possibly undefined
// 1BB30: variable 'v8' is possibly undefined

//----- (0001BB3C) --------------------------------------------------------
void __fastcall roll_work(work *work)
{
  _BOOL4 v2; // r5
  unsigned int v3; // r3
  int v4; // r0
  unsigned int v5; // r1
  char *ntime; // r5
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  v2 = opt_debug;
  v3 = bswap32(bswap32(*(_DWORD *)&work->data[68]) + 1);
  v4 = work->rolls + 1;
  v5 = local_work + 1;
  *(_DWORD *)&work->data[68] = v3;
  work->rolls = v4;
  work->nonce = 0;
  local_work = v5;
  if ( v2 && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Successfully rolled work");
    applog(7, tmp42, 0);
  }
  ntime = work->ntime;
  if ( ntime )
  {
    hex2bin((unsigned __int8 *)tmp42, work->ntime, 4u);
    *(_DWORD *)tmp42 = bswap32(bswap32(*(unsigned int *)tmp42) + 1);
    _bin2hex(ntime, (const unsigned __int8 *)tmp42, 4u);
  }
  work->id = total_work_inc();
}

//----- (0001BBF4) --------------------------------------------------------
work *make_work()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  v0 = calloc(1u, 0x7B0u);
  if ( !v0 )
  {
    strcpy(tmp42, "Failed to calloc work in make_work");
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  v1 = v0;
  v0[457] = total_work_inc();
  return (work *)v1;
}

//----- (0001BC4C) --------------------------------------------------------
work *__fastcall copy_work_noffset(work *base_work, int noffset)
{
  work *work; // r4

  work = make_work();
  copy_work(work, base_work, noffset);
  return work;
}

//----- (0001BC64) --------------------------------------------------------
work *__fastcall make_clone(work *work)
{
  work *v2; // r4
  __time_t tv_sec; // r3

  v2 = make_work();
  copy_work(v2, work, 0);
  v2->clone = 1;
  cgtime(&v2->tv_cloned);
  tv_sec = v2->tv_staged.tv_sec;
  v2->longpoll = 0;
  v2->mandatory = 0;
  v2->tv_staged.tv_sec = tv_sec - 1;
  return v2;
}

//----- (0001BC9C) --------------------------------------------------------
int __fastcall add_queued(cgpu_info *a1, work *a2)
{
  pthread_rwlock_t *p_qlock; // r4
  const char *v5; // r2
  int v6; // r3
  const char *v7; // r2
  int v8; // r3

  p_qlock = &a1->qlock;
  if ( pthread_rwlock_wrlock(&a1->qlock) )
    wr_lock((pthread_rwlock_t *)&_func___16717, (const char *)0x2279, v5, v6);
  _add_queued(a1, a2);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock((pthread_rwlock_t *)&_func___16717, (const char *)0x227B, v7, v8);
  return selective_yield();
}
// 1BCD4: variable 'v5' is possibly undefined
// 1BCD4: variable 'v6' is possibly undefined
// 1BCDE: variable 'v7' is possibly undefined
// 1BCDE: variable 'v8' is possibly undefined

//----- (0001BCE8) --------------------------------------------------------
void __fastcall work_completed(cgpu_info *a1, work *a2)
{
  pthread_rwlock_t *p_qlock; // r5
  const char *v5; // r2
  int v6; // r3
  const char *v7; // r2
  int v8; // r3

  p_qlock = &a1->qlock;
  if ( pthread_rwlock_wrlock(&a1->qlock) )
    wr_lock((pthread_rwlock_t *)(&_func___16717.__align + 3), (const char *)0x2309, v5, v6);
  _work_completed(a1, a2);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock((pthread_rwlock_t *)(&_func___16717.__align + 3), (const char *)0x230B, v7, v8);
  selective_yield();
  clean_work(a2);
  sub_12000(a2);
}
// 1BD2C: variable 'v5' is possibly undefined
// 1BD2C: variable 'v6' is possibly undefined
// 1BD36: variable 'v7' is possibly undefined
// 1BD36: variable 'v8' is possibly undefined

//----- (0001BD40) --------------------------------------------------------
work *__fastcall take_queued_work_bymidstate(cgpu_info *a1, char *a2, size_t a3, char *a4, int offset, size_t datalen)
{
  pthread_rwlock_t *p_qlock; // r6
  const char *v11; // r2
  int v12; // r3
  work *work_bymidstate; // r5
  const char *v14; // r2
  int v15; // r3

  p_qlock = &a1->qlock;
  if ( pthread_rwlock_wrlock(&a1->qlock) )
    wr_lock((pthread_rwlock_t *)(&_func___16717.__align + 7), (const char *)0x2316, v11, v12);
  work_bymidstate = _find_work_bymidstate(a1->queued_work, a2, a3, a4, offset, datalen);
  if ( work_bymidstate )
    _work_completed(a1, work_bymidstate);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock((pthread_rwlock_t *)(&_func___16717.__align + 7), (const char *)0x231A, v14, v15);
  selective_yield();
  return work_bymidstate;
}
// 1BD9E: variable 'v11' is possibly undefined
// 1BD9E: variable 'v12' is possibly undefined
// 1BDA8: variable 'v14' is possibly undefined
// 1BDA8: variable 'v15' is possibly undefined

//----- (0001BDB0) --------------------------------------------------------
int __fastcall age_queued_work(pthread_rwlock_t *a1)
{
  const char *v2; // r2
  int v3; // r3
  timeval *readers; // r5
  timeval *i; // r4
  const char *v6; // r2
  int v7; // r3
  timeval v9; // [sp+0h] [bp-8h] BYREF

  cgtime(&v9);
  if ( pthread_rwlock_wrlock(a1 + 10) )
    wr_lock((pthread_rwlock_t *)&_func___16796, (const char *)0x22F6, v2, v3);
  readers = (timeval *)a1[11].__readers;
  if ( readers )
  {
    for ( i = (timeval *)readers[230].tv_sec; ; i = (timeval *)i[230].tv_sec )
    {
      tdiff(&v9, readers + 239);
      if ( !i )
        break;
      readers = i;
    }
  }
  if ( pthread_rwlock_unlock(a1 + 10) )
    rw_unlock((pthread_rwlock_t *)&_func___16796, (const char *)0x2300, v6, v7);
  selective_yield();
  return 0;
}
// 1BE3C: variable 'v2' is possibly undefined
// 1BE3C: variable 'v3' is possibly undefined
// 1BE46: variable 'v6' is possibly undefined
// 1BE46: variable 'v7' is possibly undefined

//----- (0001BE50) --------------------------------------------------------
void __fastcall flush_queue(pthread_rwlock_t *a1)
{
  pthread_rwlock_t *v1; // r5
  pthread_rwlock_t *v3; // r0
  work *writers; // r5
  const char *v5; // r2
  int v6; // r3
  cgpu_info *v7; // r0

  if ( a1 )
  {
    v1 = a1 + 10;
    if ( !pthread_rwlock_trywrlock(a1 + 10) )
    {
      v3 = v1;
      writers = (work *)a1[11].__writers;
      a1[11].__writers = 0;
      if ( pthread_rwlock_unlock(v3) )
        rw_unlock((pthread_rwlock_t *)(&_func___16796.__align + 4), (const char *)0x232C, v5, v6);
      selective_yield();
      if ( writers )
      {
        clean_work(writers);
        free(writers);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          flush_queue_0(v7);
      }
    }
  }
}
// 1BEBC: variable 'v7' is possibly undefined
// 1BED8: variable 'v5' is possibly undefined
// 1BED8: variable 'v6' is possibly undefined

//----- (0001BEE0) --------------------------------------------------------
// Alternative name is '_rd_lock.part.35.constprop.80'
void __fastcall __noreturn rd_lock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
    *v6,
    "cgminer.c",
    (const char *)lock,
    file);
  applog(3, tmp42, 1);
  _quit(1);
}
// 1A76C: using guessed type void __fastcall __noreturn _quit(_DWORD);

//----- (0001BF24) --------------------------------------------------------
work *__fastcall clone_queued_work_byid(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r7
  const char *v5; // r2
  int v6; // r3
  work *readers; // r4
  const work *next; // r5
  const char *v9; // r2
  int v10; // r3

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    rd_lock((pthread_rwlock_t *)(&_func___16796.__align + 7), (const char *)0x22DC, v5, v6);
  readers = (work *)a1[11].__readers;
  if ( readers )
  {
    next = (const work *)readers->hh.next;
    if ( a2 == readers->id )
    {
      next = readers;
    }
    else
    {
      readers = (work *)readers->hh.next;
      if ( !next )
        goto LABEL_9;
      readers = (work *)next->hh.next;
      while ( a2 != next->id )
      {
        if ( !readers )
          goto LABEL_9;
        next = readers;
        readers = (work *)readers->hh.next;
      }
    }
    readers = make_work();
    copy_work(readers, next, 0);
  }
LABEL_9:
  if ( pthread_rwlock_unlock(v2) )
    rw_unlock((pthread_rwlock_t *)(&_func___16796.__align + 7), (const char *)0x22E0, v9, v10);
  selective_yield();
  return readers;
}
// 1BF94: variable 'v5' is possibly undefined
// 1BF94: variable 'v6' is possibly undefined
// 1BF9E: variable 'v9' is possibly undefined
// 1BF9E: variable 'v10' is possibly undefined

//----- (0001BFA8) --------------------------------------------------------
work *__fastcall clone_queued_work_bymidstate(
        cgpu_info *cgpu,
        char *midstate,
        size_t midstatelen,
        char *data,
        int offset,
        size_t datalen)
{
  pthread_rwlock_t *p_qlock; // r4
  const char *v11; // r2
  int v12; // r3
  work *work_bymidstate; // r5
  work *work; // r7
  const char *v15; // r2
  int v16; // r3

  p_qlock = &cgpu->qlock;
  if ( pthread_rwlock_rdlock(&cgpu->qlock) )
    rd_lock((pthread_rwlock_t *)&_func___16758, (const char *)0x22B0, v11, v12);
  work_bymidstate = _find_work_bymidstate(cgpu->queued_work, midstate, midstatelen, data, offset, datalen);
  if ( work_bymidstate )
  {
    work = make_work();
    copy_work(work, work_bymidstate, 0);
  }
  else
  {
    work = 0;
  }
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock((pthread_rwlock_t *)&_func___16758, (const char *)0x22B4, v15, v16);
  selective_yield();
  return work;
}
// 1C00E: variable 'v11' is possibly undefined
// 1C00E: variable 'v12' is possibly undefined
// 1C018: variable 'v15' is possibly undefined
// 1C018: variable 'v16' is possibly undefined

//----- (0001C024) --------------------------------------------------------
unsigned int __fastcall find_queued_work_byid(pthread_rwlock_t *a1, int a2)
{
  pthread_rwlock_t *v2; // r6
  const char *v5; // r2
  int v6; // r3
  unsigned int readers; // r4
  unsigned int v8; // r3
  const char *v9; // r2
  int v10; // r3

  v2 = a1 + 10;
  if ( pthread_rwlock_rdlock(a1 + 10) )
    rd_lock((pthread_rwlock_t *)&_func___16774, (const char *)0x22D1, v5, v6);
  readers = a1[11].__readers;
  if ( readers )
  {
    v8 = *(_DWORD *)(readers + 1840);
    if ( a2 != *(_DWORD *)(readers + 1828) )
    {
      if ( v8 )
      {
        readers = *(_DWORD *)(v8 + 1840);
        while ( a2 != *(_DWORD *)(v8 + 1828) )
        {
          if ( !readers )
            goto LABEL_9;
          v8 = readers;
          readers = *(_DWORD *)(readers + 1840);
        }
      }
      readers = v8;
    }
  }
LABEL_9:
  if ( pthread_rwlock_unlock(v2) )
    rw_unlock((pthread_rwlock_t *)&_func___16774, (const char *)0x22D3, v9, v10);
  selective_yield();
  return readers;
}
// 1C084: variable 'v5' is possibly undefined
// 1C084: variable 'v6' is possibly undefined
// 1C08E: variable 'v9' is possibly undefined
// 1C08E: variable 'v10' is possibly undefined

//----- (0001C098) --------------------------------------------------------
work *__fastcall find_queued_work_bymidstate(int a1, char *a2, size_t a3, char *a4, int offset, size_t datalen)
{
  pthread_rwlock_t *v6; // r4
  const char *v11; // r2
  int v12; // r3
  work *work_bymidstate; // r5
  const char *v14; // r2
  int v15; // r3

  v6 = (pthread_rwlock_t *)(a1 + 320);
  if ( pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 320)) )
    rd_lock((pthread_rwlock_t *)(&_func___16774.__align + 6), (const char *)0x22A5, v11, v12);
  work_bymidstate = _find_work_bymidstate(*(work **)(a1 + 352), a2, a3, a4, offset, datalen);
  if ( pthread_rwlock_unlock(v6) )
    rw_unlock((pthread_rwlock_t *)(&_func___16774.__align + 6), (const char *)0x22A7, v14, v15);
  selective_yield();
  return work_bymidstate;
}
// 1C0EC: variable 'v11' is possibly undefined
// 1C0EC: variable 'v12' is possibly undefined
// 1C0F6: variable 'v14' is possibly undefined
// 1C0F6: variable 'v15' is possibly undefined

//----- (0001C100) --------------------------------------------------------
cgpu_info *__fastcall get_devices(int a1)
{
  const char *v2; // r2
  int v3; // r3
  cgpu_info *v4; // r4
  const char *v5; // r2
  int v6; // r3

  if ( pthread_rwlock_rdlock(&devices_lock) )
    rd_lock((pthread_rwlock_t *)&_func___14460, (const char *)0x278, v2, v3);
  v4 = devices[a1];
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock((pthread_rwlock_t *)&_func___14460, (const char *)0x27A, v5, v6);
  selective_yield();
  return v4;
}
// 1C144: variable 'v2' is possibly undefined
// 1C144: variable 'v3' is possibly undefined
// 1C14E: variable 'v5' is possibly undefined
// 1C14E: variable 'v6' is possibly undefined

//----- (0001C158) --------------------------------------------------------
void zero_stats()
{
  int *v0; // r3
  pool **v1; // r6
  pool **v2; // r7
  int v3; // t1
  int v4; // r5
  cgpu_info *devices; // r4
  const char *v6; // r2
  int v7; // r3
  const char *v8; // r2
  int v9; // r3

  cgtime(&total_tv_start);
  copy_time(&tv_hashmeter, &total_tv_start);
  v0 = (int *)g_local_mhashes_dones;
  total_rolling = 0.0;
  rolling1 = 0.0;
  rolling5 = 0.0;
  rolling15 = 0.0;
  total_mhashes_done = 0.0;
  do
  {
    *(_QWORD *)v0 = 0;
    v0 += 2;
  }
  while ( v0 != &g_local_mhashes_index );
  total_secs = 1.0;
  zero_stats_flag = 1;
  g_local_mhashes_index = 0;
  hw_errors = 0;
  local_work = 0;
  found_blocks = 0;
  last_total_secs = 1.0;
  total_getworks = 0;
  total_accepted = 0;
  total_rejected = 0;
  g_max_fan = 0;
  g_max_temp = 0;
  total_stale = 0;
  total_discarded = 0;
  total_diff1 = 0;
  total_go = 0;
  total_ro = 0;
  total_diff_accepted = 0.0;
  total_diff_rejected = 0.0;
  total_diff_stale = 0.0;
  if ( total_pools > 0 )
  {
    v1 = pools;
    v2 = &pools[total_pools];
    do
    {
      v3 = (int)*v1++;
      *(_DWORD *)(v3 + 148) = 0;
      *(_QWORD *)(v3 + 8) = 0;
      *(_QWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 152) = 0;
      *(_DWORD *)(v3 + 156) = 0;
      *(_DWORD *)(v3 + 160) = 0;
      *(_DWORD *)(v3 + 164) = 0;
      *(_DWORD *)(v3 + 384) = 0;
      *(_QWORD *)(v3 + 40) = 0;
      *(_QWORD *)(v3 + 104) = 0;
      *(_QWORD *)(v3 + 112) = 0;
      *(_QWORD *)(v3 + 120) = 0;
      *(_QWORD *)(v3 + 392) = 0;
    }
    while ( v2 != v1 );
  }
  zero_bestshare();
  if ( total_devices > 0 )
  {
    v4 = 0;
    do
    {
      devices = get_devices(v4);
      copy_time(&devices->dev_start_tv, &total_tv_start);
      v7 = pthread_mutex_lock(&hash_lock);
      if ( v7 )
        mutex_lock((pthread_mutex_t *)(&_func___14460.__align + 3), (const char *)0x16F2, v6, v7);
      devices->accepted = 0;
      devices->total_mhashes = 0.0;
      devices->rejected = 0;
      devices->hw_errors = 0;
      devices->utility = 0.0;
      devices->last_share_pool_time = 0;
      devices->diff_accepted = 0.0;
      devices->diff_rejected = 0.0;
      devices->last_share_diff = 0.0;
      devices->diff1 = 0;
      if ( pthread_mutex_unlock(&hash_lock) )
        mutex_unlock_noyield((pthread_mutex_t *)(&_func___14460.__align + 3), (const char *)0x16FD, v8, v9);
      ++v4;
      selective_yield();
      devices->drv->zero_stats(devices);
    }
    while ( total_devices > v4 );
  }
}
// 1C3A6: variable 'v6' is possibly undefined
// 1C3B0: variable 'v8' is possibly undefined
// 1C3B0: variable 'v9' is possibly undefined

//----- (0001C3CC) --------------------------------------------------------
void print_summary()
{
  int v0; // r4
  int v1; // r2
  int v2; // r6
  int v3; // r11
  double v4; // d10
  double v5; // d8
  double v6; // d7
  int64_t v7; // r6
  int v8; // r8
  pool *v9; // r6
  int solved; // r3
  const char *v11; // r1
  int64_t accepted; // r10
  __int64 v13; // r0
  int v14; // r5
  cgpu_info *devices; // r0
  int v16; // r1
  _BOOL4 v17; // r3
  double v18; // d7
  char v19[256]; // [sp+28h] [bp-1104h] BYREF
  char tmp42[4100]; // [sp+128h] [bp-1004h] BYREF

  v0 = total_tv_end.tv_sec - total_tv_start.tv_sec;
  LOWORD(v1) = -30583;
  if ( total_tv_end.tv_usec - total_tv_start.tv_usec < 0 )
    --v0;
  HIWORD(v1) = -30584;
  v2 = v0 - 60 * (((int)(v0 + ((unsigned __int64)(v0 * (__int64)v1) >> 32)) >> 5) - (v0 >> 31));
  v3 = ((int)(v0 % 3600 + ((unsigned __int64)(v0 % 3600 * (__int64)v1) >> 32)) >> 5) - ((v0 % 3600) >> 31);
  v4 = (double)total_accepted / total_secs * 60.0;
  v5 = (double)total_diff1 / total_secs * 60.0;
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3
    || (strcpy(tmp42, "\nSummary of runtime statistics:\n"), applog(4, tmp42, 0), !use_syslog)
    && !opt_log_output
    && opt_log_level <= 3 )
  {
    if ( total_pools == 1 )
      goto LABEL_156;
LABEL_8:
    if ( use_syslog || opt_log_output )
      goto LABEL_10;
    goto LABEL_137;
  }
  snprintf(tmp42, 0x1000u, "Started at %s", datestamp);
  applog(4, tmp42, 0);
  if ( total_pools != 1 )
    goto LABEL_8;
  if ( use_syslog || opt_log_output )
    goto LABEL_157;
LABEL_156:
  if ( opt_log_level > 3 )
  {
LABEL_157:
    snprintf(tmp42, 0x1000u, "Pool: %s", (*pools)->rpc_url);
    applog(4, tmp42, 0);
    goto LABEL_8;
  }
LABEL_137:
  if ( opt_log_level <= 3 )
  {
    v6 = total_mhashes_done / total_secs;
    goto LABEL_139;
  }
LABEL_10:
  snprintf(tmp42, 0x1000u, "Runtime: %d hrs : %d mins : %d secs", v0 / 3600, v3, v2);
  applog(4, tmp42, 0);
  v6 = total_mhashes_done / total_secs;
  if ( use_syslog || opt_log_output )
  {
LABEL_12:
    snprintf(tmp42, 0x1000u, "Average hashrate: %.1f Mhash/s", v6);
    applog(4, tmp42, 0);
    if ( use_syslog || opt_log_output )
      goto LABEL_14;
    goto LABEL_189;
  }
LABEL_139:
  if ( opt_log_level > 3 )
    goto LABEL_12;
LABEL_189:
  if ( opt_log_level <= 3 )
    goto LABEL_190;
LABEL_14:
  snprintf(tmp42, 0x1000u, "Solved blocks: %d", found_blocks);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output )
  {
LABEL_190:
    if ( opt_log_level <= 3 )
      goto LABEL_158;
  }
  snprintf(tmp42, 0x1000u, "Best share difficulty: %s", best_share);
  applog(4, tmp42, 0);
  if ( use_syslog || opt_log_output )
  {
LABEL_18:
    snprintf(tmp42, 0x1000u, "Share submissions: %lld", total_accepted + total_rejected);
    applog(4, tmp42, 0);
    if ( use_syslog || opt_log_output )
      goto LABEL_20;
    goto LABEL_159;
  }
LABEL_158:
  if ( opt_log_level > 3 )
    goto LABEL_18;
LABEL_159:
  if ( opt_log_level <= 3 )
    goto LABEL_160;
LABEL_20:
  snprintf(tmp42, 0x1000u, "Accepted shares: %lld", total_accepted);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output )
  {
LABEL_160:
    if ( opt_log_level <= 3 )
      goto LABEL_161;
  }
  snprintf(tmp42, 0x1000u, "Rejected shares: %lld", total_rejected);
  applog(4, tmp42, 0);
  if ( use_syslog || opt_log_output )
  {
LABEL_24:
    snprintf(tmp42, 0x1000u, "Accepted difficulty shares: %1.f", total_diff_accepted);
    applog(4, tmp42, 0);
    if ( use_syslog || opt_log_output )
      goto LABEL_26;
    goto LABEL_162;
  }
LABEL_161:
  if ( opt_log_level > 3 )
    goto LABEL_24;
LABEL_162:
  if ( opt_log_level <= 3 )
  {
    v7 = total_accepted;
    if ( total_accepted )
      goto LABEL_164;
    goto LABEL_54;
  }
LABEL_26:
  snprintf(tmp42, 0x1000u, "Rejected difficulty shares: %1.f", total_diff_rejected);
  applog(4, tmp42, 0);
  v7 = total_accepted;
  if ( total_accepted )
  {
    if ( !use_syslog )
      goto LABEL_28;
LABEL_29:
    snprintf(tmp42, 0x1000u, "Reject ratio: %.1f%%", (double)(100 * total_rejected) / (double)(total_rejected + v7));
    applog(4, tmp42, 0);
LABEL_30:
    if ( use_syslog || opt_log_output )
      goto LABEL_32;
    goto LABEL_145;
  }
LABEL_54:
  if ( !total_rejected )
    goto LABEL_30;
  v7 = 0;
  if ( use_syslog )
    goto LABEL_29;
LABEL_28:
  if ( opt_log_output )
    goto LABEL_29;
LABEL_164:
  if ( opt_log_level > 3 )
    goto LABEL_29;
LABEL_145:
  if ( opt_log_level <= 3 )
    goto LABEL_146;
LABEL_32:
  snprintf(tmp42, 0x1000u, "Hardware errors: %d", hw_errors);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_146:
    if ( opt_log_level <= 3 )
      goto LABEL_147;
    goto LABEL_36;
  }
  snprintf(tmp42, 0x1000u, "Utility (accepted shares / min): %.2f/min", v4);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_147:
    if ( opt_log_level <= 3 )
      goto LABEL_148;
    goto LABEL_38;
  }
LABEL_36:
  snprintf(tmp42, 0x1000u, "Work Utility (diff1 shares solved / min): %.2f/min\n", v5);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_148:
    if ( opt_log_level <= 3 )
      goto LABEL_149;
    goto LABEL_40;
  }
LABEL_38:
  snprintf(tmp42, 0x1000u, "Stale submissions discarded due to new blocks: %lld", total_stale);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_149:
    if ( opt_log_level <= 3 )
      goto LABEL_150;
    goto LABEL_42;
  }
LABEL_40:
  snprintf(tmp42, 0x1000u, "Unable to get work from server occasions: %d", total_go);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_150:
    if ( opt_log_level <= 3 )
      goto LABEL_151;
    goto LABEL_44;
  }
LABEL_42:
  snprintf(tmp42, 0x1000u, "Work items generated locally: %d", local_work);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_151:
    if ( opt_log_level <= 3 )
      goto LABEL_152;
    goto LABEL_46;
  }
LABEL_44:
  snprintf(tmp42, 0x1000u, "Submitting work remotely delay occasions: %d", total_ro);
  applog(4, tmp42, 0);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
  {
LABEL_152:
    if ( total_pools <= 1 )
      goto LABEL_141;
    goto LABEL_47;
  }
LABEL_46:
  snprintf(tmp42, 0x1000u, "New blocks detected on network: %d\n", new_blocks);
  applog(4, tmp42, 0);
  if ( total_pools > 1 )
  {
LABEL_47:
    v8 = 0;
    while ( 1 )
    {
      v9 = pools[v8];
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
        break;
      solved = v9->solved;
      if ( solved )
        goto LABEL_52;
LABEL_63:
      if ( !opt_log_output )
      {
LABEL_110:
        if ( opt_log_level <= 3 )
          goto LABEL_111;
      }
LABEL_64:
      snprintf(tmp42, 0x1000u, " Share submissions: %lld", v9->accepted + v9->rejected);
      applog(4, tmp42, 0);
      if ( use_syslog || opt_log_output )
      {
LABEL_66:
        snprintf(tmp42, 0x1000u, " Accepted shares: %lld", v9->accepted);
        applog(4, tmp42, 0);
        if ( use_syslog || opt_log_output )
          goto LABEL_68;
        goto LABEL_112;
      }
LABEL_111:
      if ( opt_log_level > 3 )
        goto LABEL_66;
LABEL_112:
      if ( opt_log_level <= 3 )
        goto LABEL_113;
LABEL_68:
      snprintf(tmp42, 0x1000u, " Rejected shares: %lld", v9->rejected);
      applog(4, tmp42, 0);
      if ( !use_syslog && !opt_log_output )
      {
LABEL_113:
        if ( opt_log_level <= 3 )
          goto LABEL_114;
      }
      snprintf(tmp42, 0x1000u, " Accepted difficulty shares: %1.f", v9->diff_accepted);
      applog(4, tmp42, 0);
      if ( use_syslog || opt_log_output )
      {
LABEL_72:
        snprintf(tmp42, 0x1000u, " Rejected difficulty shares: %1.f", v9->diff_rejected);
        applog(4, tmp42, 0);
        accepted = v9->accepted;
        if ( accepted )
          goto LABEL_75;
        goto LABEL_73;
      }
LABEL_114:
      if ( opt_log_level > 3 )
        goto LABEL_72;
      accepted = v9->accepted;
      if ( accepted )
      {
        if ( opt_log_level <= 3 )
          goto LABEL_117;
        goto LABEL_77;
      }
LABEL_73:
      if ( v9->rejected )
      {
        accepted = 0;
LABEL_75:
        if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
        {
LABEL_117:
          if ( opt_log_level <= 3 )
            goto LABEL_118;
          goto LABEL_80;
        }
LABEL_77:
        HIDWORD(v13) = (unsigned __int64)(3 * v9->rejected) >> 32;
        LODWORD(v13) = 96 * LODWORD(v9->rejected);
        snprintf(
          tmp42,
          0x1000u,
          " Reject ratio: %.1f%%",
          (double)(__int64)(__PAIR64__((unsigned __int64)(96 * v9->rejected) >> 32, 3 * LODWORD(v9->rejected))
                          + v13
                          + v9->rejected)
        / (double)(v9->rejected + accepted));
        applog(4, tmp42, 0);
      }
      if ( !use_syslog && !opt_log_output )
        goto LABEL_117;
LABEL_80:
      snprintf(tmp42, 0x1000u, " Items worked on: %d", v9->works);
      applog(4, tmp42, 0);
      if ( use_syslog || opt_log_output )
      {
LABEL_82:
        snprintf(tmp42, 0x1000u, " Stale submissions discarded due to new blocks: %d", v9->stale_shares);
        applog(4, tmp42, 0);
        if ( use_syslog || opt_log_output )
          goto LABEL_84;
        goto LABEL_119;
      }
LABEL_118:
      if ( opt_log_level > 3 )
        goto LABEL_82;
LABEL_119:
      if ( opt_log_level <= 3 )
        goto LABEL_120;
LABEL_84:
      snprintf(tmp42, 0x1000u, " Unable to get work from server occasions: %d", v9->getfail_occasions);
      applog(4, tmp42, 0);
      if ( !use_syslog && !opt_log_output )
      {
LABEL_120:
        if ( opt_log_level <= 3 )
          goto LABEL_87;
      }
      snprintf(tmp42, 0x1000u, " Submitting work remotely delay occasions: %d\n", v9->remotefail_occasions);
      applog(4, tmp42, 0);
LABEL_87:
      if ( total_pools <= ++v8 )
        goto LABEL_88;
    }
    snprintf(tmp42, 0x1000u, "Pool: %s", v9->rpc_url);
    applog(4, tmp42, 0);
    solved = v9->solved;
    if ( solved )
    {
      if ( !use_syslog && !opt_log_output )
      {
LABEL_52:
        if ( opt_log_level <= 3 )
          goto LABEL_110;
      }
      v11 = "S";
      if ( solved <= 1 )
        v11 = &byte_59398;
      snprintf(tmp42, 0x1000u, "SOLVED %d BLOCK%s!", solved, v11);
      applog(4, tmp42, 0);
    }
    if ( use_syslog )
      goto LABEL_64;
    goto LABEL_63;
  }
LABEL_88:
  if ( use_syslog || opt_log_output )
    goto LABEL_90;
LABEL_141:
  if ( opt_log_level > 3 )
  {
LABEL_90:
    strcpy(tmp42, "Summary of per device statistics:\n");
    applog(4, tmp42, 0);
  }
  if ( total_devices > 0 )
  {
    v14 = 0;
    do
    {
      devices = get_devices(v14++);
      devices->drv->get_statline_before = blank_get_statline_before;
      devices->drv->get_statline = (void (*)(char *, size_t, cgpu_info *))noop_get_statline;
      get_statline(v19, 0xFFu, devices);
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "%s", v19);
        applog(4, tmp42, 0);
      }
    }
    while ( total_devices > v14 );
  }
  v16 = opt_shares;
  v17 = use_syslog;
  if ( opt_shares )
  {
    v18 = total_diff_accepted;
    if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
    {
      if ( (double)opt_shares <= total_diff_accepted )
        goto LABEL_143;
      goto LABEL_103;
    }
    snprintf(tmp42, 0x1000u, "Mined %.0f accepted shares of %d requested\n", total_diff_accepted, opt_shares);
    applog(4, tmp42, 0);
    v18 = total_diff_accepted;
    v16 = opt_shares;
    v17 = use_syslog;
    if ( (double)opt_shares > total_diff_accepted )
    {
      if ( use_syslog )
      {
LABEL_105:
        snprintf(tmp42, 0x1000u, "WARNING - Mined only %.0f shares of %d requested.", v18, v16);
        applog(4, tmp42, 0);
        v17 = use_syslog;
        goto LABEL_106;
      }
LABEL_103:
      if ( !opt_log_output && opt_log_level <= 3 )
      {
LABEL_143:
        if ( opt_log_level <= 3 )
          goto LABEL_109;
        goto LABEL_108;
      }
      goto LABEL_105;
    }
  }
LABEL_106:
  if ( !v17 && !opt_log_output )
    goto LABEL_143;
LABEL_108:
  strcpy(tmp42, " ");
  applog(4, tmp42, 0);
LABEL_109:
  fflush((FILE *)stderr);
  fflush((FILE *)stdout);
}
// 17594: using guessed type int noop_get_statline();
// 59398: using guessed type char byte_59398;
// 6D848: using guessed type int stderr;
// 6D854: using guessed type int stdout;

//----- (0001D290) --------------------------------------------------------
thr_info *__fastcall get_thread(int a1)
{
  const char *v2; // r2
  int v3; // r3
  thr_info *v4; // r4
  const char *v5; // r2
  int v6; // r3

  if ( pthread_rwlock_rdlock(&mining_thr_lock) )
    rd_lock((pthread_rwlock_t *)(&_func___14460.__align + 6), (const char *)0x266, v2, v3);
  v4 = mining_thr[a1];
  if ( pthread_rwlock_unlock(&mining_thr_lock) )
    rw_unlock((pthread_rwlock_t *)(&_func___14460.__align + 6), (const char *)0x268, v5, v6);
  selective_yield();
  return v4;
}
// 1D2D4: variable 'v2' is possibly undefined
// 1D2D4: variable 'v3' is possibly undefined
// 1D2DE: variable 'v5' is possibly undefined
// 1D2DE: variable 'v6' is possibly undefined

//----- (0001D2E8) --------------------------------------------------------
int __fastcall dev_from_id(int thr_id)
{
  return get_thread(thr_id)->cgpu->device_id;
}

//----- (0001D2F4) --------------------------------------------------------
// Alternative name is '__kill_work.part.37'
void _kill_work_0()
{
  int v0; // r4
  int v1; // r0
  thr_info *thread; // r0
  cgpu_info *cgpu; // r3
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( opt_debug )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(tmp42, "Received kill message");
      applog(7, tmp42, 1);
      if ( !opt_debug )
        goto LABEL_8;
      if ( use_syslog )
      {
LABEL_7:
        strcpy(tmp42, "Killing off watchpool thread");
        applog(7, tmp42, 1);
        goto LABEL_8;
      }
    }
    if ( opt_log_output || opt_log_level > 6 )
      goto LABEL_7;
  }
LABEL_8:
  cg_completion_timeout(thr_info_cancel, &control_thr[watchpool_thr_id], 1000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Killing off watchdog thread");
    applog(7, tmp42, 1);
  }
  cg_completion_timeout(thr_info_cancel, &control_thr[watchdog_thr_id], 1000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Shutting down mining threads");
    applog(7, tmp42, 1);
  }
  if ( mining_threads > 0 )
  {
    v0 = 0;
    do
    {
      v1 = v0++;
      thread = get_thread(v1);
      if ( thread )
      {
        cgpu = thread->cgpu;
        if ( cgpu )
          cgpu->shutdown = 1;
      }
    }
    while ( v0 < mining_threads );
  }
  sleep(1u);
  cg_completion_timeout(kill_mining, 0, 3000);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Killing off API thread");
    applog(7, tmp42, 1);
  }
  cg_completion_timeout(thr_info_cancel, &control_thr[api_thr_id], 1000);
}

//----- (0001D558) --------------------------------------------------------
void _kill_work()
{
  if ( successful_connect )
    _kill_work_0();
}

//----- (0001D568) --------------------------------------------------------
void kill_mining()
{
  int i; // r4
  thr_info *thread; // r0
  thr_info *v2; // r5
  pthread_t pth; // r0
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Killing off mining threads");
    applog(7, tmp42, 1);
  }
  if ( mining_threads > 0 )
  {
    for ( i = 0; mining_threads > i; ++i )
    {
      while ( 1 )
      {
        thread = get_thread(i);
        v2 = thread;
        if ( thread )
        {
          if ( thread->pth )
            break;
        }
        thr_info_cancel(thread);
LABEL_8:
        if ( mining_threads <= ++i )
          return;
      }
      thr_info_cancel(thread);
      pth = v2->pth;
      if ( !pth )
        goto LABEL_8;
      pthread_join(pth, 0);
    }
  }
}

//----- (0001D618) --------------------------------------------------------
pool *current_pool()
{
  const char *v0; // r2
  int v1; // r3
  const char *v2; // r2
  int v3; // r3
  const char *v4; // r2
  int v5; // r3
  pool *v6; // r4
  const char *v7; // r2
  int v8; // r3

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock((pthread_mutex_t *)&_func___14527, (const char *)0x31C, v0, v1);
  if ( pthread_rwlock_rdlock(&control_lock.rwlock) )
    rd_lock((pthread_rwlock_t *)&_func___14527, (const char *)0x31C, v2, v3);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield((pthread_mutex_t *)&_func___14527, (const char *)0x31C, v4, v5);
  v6 = currentpool;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock((pthread_rwlock_t *)&_func___14527, (const char *)0x31E, v7, v8);
  selective_yield();
  return v6;
}
// 1D668: variable 'v0' is possibly undefined
// 1D668: variable 'v1' is possibly undefined
// 1D672: variable 'v2' is possibly undefined
// 1D672: variable 'v3' is possibly undefined
// 1D67C: variable 'v4' is possibly undefined
// 1D67C: variable 'v5' is possibly undefined
// 1D686: variable 'v7' is possibly undefined
// 1D686: variable 'v8' is possibly undefined

//----- (0001D694) --------------------------------------------------------
int __fastcall inc_work_stats(int a1, int a2, int a3)
{
  const char *v6; // r2
  int v7; // r3
  int v8; // r1
  __int64 v9; // kr00_8
  int v10; // r4
  const char *v11; // r2
  int v12; // r3
  pool *v14; // r0

  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock((pthread_mutex_t *)(&_func___14527.__align + 4), (const char *)0x20C9, v6, v7);
  v8 = *(_DWORD *)(a1 + 36);
  v9 = *(_QWORD *)(v8 + 192) + a3;
  total_diff1 += a3;
  *(_QWORD *)(v8 + 192) = v9;
  if ( a2 )
  {
    *(_QWORD *)(a2 + 40) += a3;
  }
  else
  {
    v14 = current_pool();
    v14->diff1 += a3;
  }
  v10 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(v10 + 232) = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield((pthread_mutex_t *)(&_func___14527.__align + 4), (const char *)0x20D6, v11, v12);
  return selective_yield();
}
// 1D736: variable 'v6' is possibly undefined
// 1D736: variable 'v7' is possibly undefined
// 1D740: variable 'v11' is possibly undefined
// 1D740: variable 'v12' is possibly undefined

//----- (0001D748) --------------------------------------------------------
int cp_prio()
{
  const char *v0; // r2
  int v1; // r3
  const char *v2; // r2
  int v3; // r3
  const char *v4; // r2
  int v5; // r3
  int prio; // r4
  const char *v7; // r2
  int v8; // r3

  if ( pthread_mutex_lock(&control_lock.mutex) )
    mutex_lock((pthread_mutex_t *)&_func___16209, (const char *)0x1B7C, v0, v1);
  if ( pthread_rwlock_rdlock(&control_lock.rwlock) )
    rd_lock((pthread_rwlock_t *)&_func___16209, (const char *)0x1B7C, v2, v3);
  if ( pthread_mutex_unlock(&control_lock.mutex) )
    mutex_unlock_noyield((pthread_mutex_t *)&_func___16209, (const char *)0x1B7C, v4, v5);
  prio = currentpool->prio;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
    rw_unlock((pthread_rwlock_t *)&_func___16209, (const char *)0x1B7E, v7, v8);
  selective_yield();
  return prio;
}
// 1D79A: variable 'v0' is possibly undefined
// 1D79A: variable 'v1' is possibly undefined
// 1D7A4: variable 'v2' is possibly undefined
// 1D7A4: variable 'v3' is possibly undefined
// 1D7AE: variable 'v4' is possibly undefined
// 1D7AE: variable 'v5' is possibly undefined
// 1D7B8: variable 'v7' is possibly undefined
// 1D7B8: variable 'v8' is possibly undefined

//----- (0001D7C4) --------------------------------------------------------
void __fastcall pool_resus(pool *pool)
{
  pool_strategy v1; // r3
  int prio; // r5
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = pool_strategy_0;
  pool->seq_getfails = 0;
  if ( v1 || (prio = pool->prio, prio >= cp_prio()) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "Pool %d %s alive", pool->pool_no, pool->rpc_url);
      applog(7, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "Pool %d %s alive, testing stability", pool->pool_no, pool->rpc_url);
    applog(4, tmp42, 0);
  }
}

//----- (0001D8A0) --------------------------------------------------------
// Alternative name is 'stratum_resumed.part.47'
void __fastcall stratum_resumed_0(pool *pool)
{
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Stratum connection to pool %d resumed", pool->pool_no);
    applog(7, tmp42, 0);
  }
  pool_resus(pool);
}

//----- (0001D908) --------------------------------------------------------
void __fastcall stratum_resumed(pool *pool)
{
  if ( pool_tclear((int)pool, &pool->idle) )
    stratum_resumed_0(pool);
}

//----- (0001D920) --------------------------------------------------------
bool __fastcall cnx_needed(pool *pool)
{
  int prio; // r4

  if ( pool->enabled != pool_enable::POOL_ENABLED )
    return 0;
  if ( (unsigned int)(pool_strategy_0 - 3) <= 1 || pool->has_stratum && pool->idle )
    return 1;
  if ( pool == current_pool() )
    return 1;
  if ( pool->sshares )
    return 1;
  if ( pool_strategy_0 == pool_strategy::POOL_FAILOVER )
  {
    prio = pool->prio;
    if ( prio < cp_prio() )
      return 1;
  }
  return no_work;
}

//----- (0001D984) --------------------------------------------------------
pool *add_pool()
{
  pool *v0; // r0
  pool *v1; // r4
  int v2; // r3
  pool **v3; // r0
  int v4; // r1
  pool **v5; // r0
  int v6; // r2
  int v8; // r3
  int v9; // r4
  int v10; // r3
  int v11; // r4
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  v0 = (pool *)calloc(0x750u, 1u);
  if ( !v0 )
  {
    strcpy(tmp42, "Failed to malloc pool in add_pool");
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  v1 = v0;
  v2 = total_pools;
  v3 = pools;
  v4 = total_pools + 2;
  v1->pool_no = total_pools;
  v1->prio = v2;
  v5 = (pool **)realloc(v3, 4 * v4);
  v6 = total_pools;
  pools = v5;
  ++total_pools;
  v5[v6] = v1;
  if ( pthread_mutex_init(&v1->pool_lock, 0) )
  {
    v8 = *_errno_location();
    v9 = 748;
    goto LABEL_11;
  }
  if ( pthread_cond_init(&v1->cr_cond, 0) )
  {
    strcpy(tmp42, "Failed to pthread_cond_init in add_pool");
    goto LABEL_12;
  }
  if ( pthread_mutex_init(&v1->data_lock.mutex, 0) )
  {
    v8 = *_errno_location();
    v9 = 751;
    goto LABEL_11;
  }
  if ( pthread_rwlock_init(&v1->data_lock.rwlock, 0) )
  {
    v10 = *_errno_location();
    v11 = 751;
LABEL_18:
    snprintf(
      tmp42,
      0x1000u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      v10,
      "cgminer.c",
      &_func___16209.__size[8],
      v11);
LABEL_12:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  if ( pthread_mutex_init(&v1->stratum_lock, 0) )
  {
    v8 = *_errno_location();
    v9 = 752;
LABEL_11:
    snprintf(
      tmp42,
      0x1000u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      v8,
      "cgminer.c",
      &_func___16209.__size[8],
      v9);
    goto LABEL_12;
  }
  if ( pthread_mutex_init(&v1->gbt_lock.mutex, 0) )
  {
    v8 = *_errno_location();
    v9 = 753;
    goto LABEL_11;
  }
  if ( pthread_rwlock_init(&v1->gbt_lock.rwlock, 0) )
  {
    v10 = *_errno_location();
    v11 = 753;
    goto LABEL_18;
  }
  v1->rpc_proxy = 0;
  v1->rpc_req = "{\"method\": \"getwork\", \"params\": [], \"id\":0}\n";
  v1->curlring.next = &v1->curlring;
  v1->curlring.prev = &v1->curlring;
  v1->tv_idle.tv_sec = -1;
  v1->quota = 1;
  adjust_quota_gcd();
  return v1;
}

//----- (0001DB7C) --------------------------------------------------------
char *__fastcall set_userpass(const char *arg)
{
  int v2; // r3
  int v3; // r6
  char *v4; // r4
  char *v5; // r0
  const char *v6; // r4
  char *v7; // r0

  if ( total_users || total_passes )
    return "Use only user + pass or userpass, but not both";
  v2 = total_userpasses + 1;
  total_userpasses = v2;
  if ( v2 > total_pools )
  {
    add_pool();
    v2 = total_userpasses;
  }
  v3 = (int)*(&pools[v2] + 0x3FFFFFFF);
  v4 = _strdup(arg);
  opt_set_charp(arg, (char **)(v3 + 200));
  v5 = v4;
  v6 = "Failed to find : delimited user info";
  v7 = strtok(v5, ":");
  *(_DWORD *)(v3 + 204) = v7;
  if ( v7 )
  {
    v6 = strtok(0, ":");
    *(_DWORD *)(v3 + 208) = v6;
    if ( v6 )
      return 0;
    *(_DWORD *)(v3 + 208) = calloc(1u, 1u);
  }
  return (char *)v6;
}

//----- (0001DC30) --------------------------------------------------------
char *__fastcall set_user(const char *arg)
{
  int v3; // r3

  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  v3 = total_users + 1;
  total_users = v3;
  if ( v3 > total_pools )
  {
    add_pool();
    v3 = total_users;
  }
  opt_set_charp(arg, &(*(&pools[v3] + 0x3FFFFFFF))->rpc_user);
  return 0;
}

//----- (0001DC90) --------------------------------------------------------
pool *add_url()
{
  int v0; // r3

  v0 = ++total_urls;
  if ( total_urls > total_pools )
  {
    add_pool();
    v0 = total_urls;
  }
  return *(&pools[v0] + 0x3FFFFFFF);
}

//----- (0001DCD0) --------------------------------------------------------
char *__fastcall set_url(char *arg)
{
  pool *v2; // r0

  v2 = add_url();
  setup_url(v2, arg);
  return 0;
}

//----- (0001DCE4) --------------------------------------------------------
char *__fastcall set_quota(char *arg)
{
  char *v2; // r0
  char *v3; // r4
  size_t v4; // r0
  size_t v5; // r6
  size_t v6; // r0
  size_t v7; // r4
  int v9; // r6
  pool *v10; // r0
  char *v11; // r1
  pool *v12; // r4
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = strchr(arg, 59);
  if ( !v2 )
    return "No semicolon separated quota;URL pair found";
  v3 = v2;
  v4 = strlen(arg);
  *v3 = 0;
  v5 = v4;
  v6 = strlen(arg);
  if ( !v6 )
    return "No parameter for quota found";
  v7 = v6 + 1;
  if ( (int)(v5 - (v6 + 1)) <= 0 )
    return "No parameter for URL found";
  v9 = strtol(arg, 0, 10);
  if ( v9 < 0 )
    return "Invalid negative parameter for quota set";
  v10 = add_url();
  v11 = &arg[v7];
  v12 = v10;
  setup_url(v10, v11);
  v12->quota = v9;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Setting pool %d to quota %d", v12->pool_no, v9);
    applog(7, tmp42, 0);
  }
  adjust_quota_gcd();
  return 0;
}

//----- (0001DDC4) --------------------------------------------------------
char *__fastcall set_pass(const char *arg)
{
  int v3; // r3

  if ( total_userpasses )
    return "Use only user + pass or userpass, but not both";
  v3 = total_passes + 1;
  total_passes = v3;
  if ( v3 > total_pools )
  {
    add_pool();
    v3 = total_passes;
  }
  opt_set_charp(arg, &(*(&pools[v3] + 0x3FFFFFFF))->rpc_pass);
  return 0;
}

//----- (0001DE24) --------------------------------------------------------
void __fastcall inc_hw_errors_with_diff(thr_info *thr, int diff)
{
  cgpu_info *cgpu; // r6
  int v5; // r1
  int *v6; // r0
  int *v7; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "%s%d: invalid nonce - HW error", thr->cgpu->drv->name, thr->cgpu->device_id);
    applog(7, tmp42, 0);
  }
  if ( pthread_mutex_lock(&stats_lock) )
  {
    v6 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v6,
      "cgminer.c",
      &_func___16209.__align + 5,
      8309);
    goto LABEL_11;
  }
  cgpu = thr->cgpu;
  v5 = cgpu->hw_errors + diff;
  hw_errors += diff;
  cgpu->hw_errors = v5;
  if ( pthread_mutex_unlock(&stats_lock) )
  {
    v7 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v7,
      "cgminer.c",
      &_func___16209.__align + 5,
      8312);
LABEL_11:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  thr->cgpu->drv->hw_error(thr);
}

//----- (0001DF48) --------------------------------------------------------
void __fastcall inc_hw_errors(thr_info *thr)
{
  cgpu_info *cgpu; // r5
  int v3; // r2
  int *v4; // r0
  int *v5; // r0
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "%s %d: invalid nonce - HW error", thr->cgpu->drv->name, thr->cgpu->device_id);
    applog(7, tmp42, 1);
  }
  if ( pthread_mutex_lock(&stats_lock) )
  {
    v4 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "cgminer.c", "inc_hw_errors", 8296);
    goto LABEL_11;
  }
  cgpu = thr->cgpu;
  v3 = cgpu->hw_errors + 1;
  ++hw_errors;
  cgpu->hw_errors = v3;
  if ( pthread_mutex_unlock(&stats_lock) )
  {
    v5 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v5,
      "cgminer.c",
      "inc_hw_errors",
      8299);
LABEL_11:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  thr->cgpu->drv->hw_error(thr);
}

//----- (0001E068) --------------------------------------------------------
uint64_t __fastcall share_diff(const work *work)
{
  double v2; // d9
  unsigned __int64 v3; // r0
  double v4; // d0
  uint64_t v5; // r6
  int v6; // r5
  pool *pool; // r1
  int *v9; // r0
  int *v10; // r0
  int *v11; // r0
  int *v12; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v2 = 2.69595353e67;
  v3 = *(_QWORD *)&work->hash[24];
  if ( opt_scrypt )
    v2 = 1.7668201e72;
  v4 = (double)*(unsigned __int64 *)work->hash
     + (double)v3 * 6.27710174e57
     + (double)*(unsigned __int64 *)&work->hash[16] * 3.40282367e38
     + (double)*(unsigned __int64 *)&work->hash[8] * 1.84467441e19;
  if ( v4 == 0.0 )
    v4 = 0.0;
  round();
  v5 = (unsigned __int64)(v2 / v4);
  if ( pthread_mutex_lock(&control_lock.mutex) )
  {
    v9 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v9, "cgminer.c", "share_diff", 4986);
    goto LABEL_17;
  }
  if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
  {
    v10 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v10, "cgminer.c", "share_diff", 4986);
    goto LABEL_17;
  }
  if ( best_diff < v5 )
  {
    best_diff = (unsigned __int64)(v2 / v4);
    v6 = 1;
    suffix_string(v5, best_share, 8u, 0);
  }
  else
  {
    v6 = 0;
  }
  pool = work->pool;
  if ( pool->best_diff < v5 )
    pool->best_diff = v5;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
  {
    v11 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v11,
      "cgminer.c",
      "share_diff",
      4995);
    goto LABEL_17;
  }
  if ( pthread_mutex_unlock(&control_lock.mutex) )
  {
    v12 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v12, "cgminer.c", "share_diff", 4995);
LABEL_17:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  if ( v6 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "New best share: %s", best_share);
    applog(7, tmp42, 0);
  }
  return (unsigned __int64)(v2 / v4);
}
// 1231C: using guessed type int round(void);

//----- (0001E2DC) --------------------------------------------------------
void __fastcall update_work_stats(thr_info *thr, work *work)
{
  double v4; // d8
  unsigned __int64 v5; // r0
  double device_diff; // d8
  cgpu_info *cgpu; // r9
  cgpu_info *v8; // r4
  pool *pool; // r5
  _BOOL4 v10; // r6
  unsigned int v11; // r2
  int *v12; // r0
  int *v13; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = current_diff;
  v5 = share_diff(work);
  work->share_diff = v5;
  if ( opt_scrypt )
    v4 = v4 * 65536.0;
  if ( (double)v5 >= v4 )
  {
    pool = work->pool;
    work->block = 1;
    v10 = use_syslog;
    v11 = found_blocks + 1;
    ++pool->solved;
    found_blocks = v11;
    work->mandatory = 1;
    if ( v10 || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "Found block for pool %d!", work->pool->pool_no);
      applog(5, tmp42, 0);
    }
  }
  if ( pthread_mutex_lock(&stats_lock) )
  {
    v12 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v12,
      "cgminer.c",
      "update_work_stats",
      8383);
    goto LABEL_11;
  }
  device_diff = work->device_diff;
  cgpu = thr->cgpu;
  total_diff1 = (__int64)((double)total_diff1 + device_diff);
  cgpu->diff1 = (__int64)((double)cgpu->diff1 + device_diff);
  work->pool->diff1 = (__int64)((double)work->pool->diff1 + work->device_diff);
  v8 = thr->cgpu;
  v8->last_device_valid_work = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
  {
    v13 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v13,
      "cgminer.c",
      "update_work_stats",
      8388);
LABEL_11:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
}

//----- (0001E4C8) --------------------------------------------------------
bool __fastcall submit_nonce_1(thr_info *thr, work *work, uint32_t nonce, int *nofull)
{
  unsigned int v7; // r2
  _BOOL4 v8; // r4
  bool v9; // r3
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( nofull )
    *nofull = 0;
  *(_DWORD *)&work->data[76] = nonce;
  rebuild_hash(work);
  v7 = 0xFFFF;
  if ( !opt_scrypt )
    v7 = 0;
  if ( *(_DWORD *)&work->hash[28] > v7 )
  {
    inc_hw_errors(thr);
    return 0;
  }
  else
  {
    update_work_stats(thr, work);
    v8 = fulltest(work->hash, work->target);
    if ( v8 )
      return v8;
    if ( nofull )
      *nofull = 1;
    v9 = opt_debug;
    if ( opt_debug && (use_syslog || (v9 = opt_log_output) || opt_log_level > 6) )
    {
      strcpy(tmp42, "Share above target");
      applog(7, tmp42, 0);
      return v8;
    }
    return v9;
  }
}

//----- (0001E590) --------------------------------------------------------
void __fastcall clear_pool_work(pool *pool)
{
  work *v2; // r4
  int v3; // r8
  work *next; // r5
  work *hh_next; // r1
  char *prev; // r12
  UT_hash_table *tbl; // lr
  ptrdiff_t hho; // r2
  UT_hash_handle *p_hh; // r10
  char *v10; // r2
  UT_hash_table *v11; // r3
  int v12; // r2
  UT_hash_bucket *buckets; // r3
  UT_hash_handle *hh_head; // r0
  UT_hash_handle *hh_prev; // r2
  UT_hash_handle *v16; // r3
  work *v17; // r9
  int *v18; // r0
  int *v19; // r0
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(stgd_lock) )
  {
    v18 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v18,
      "cgminer.c",
      "clear_pool_work",
      7016);
    goto LABEL_37;
  }
  v2 = staged_work;
  if ( !staged_work )
  {
    if ( !pthread_mutex_unlock(stgd_lock) )
    {
      selective_yield();
      return;
    }
    goto LABEL_38;
  }
  v3 = 0;
  next = (work *)staged_work->hh.next;
  if ( staged_work->pool == pool )
    goto LABEL_6;
LABEL_4:
  if ( next )
  {
    while ( 1 )
    {
      v2 = next;
      next = (work *)next->hh.next;
      if ( v2->pool != pool )
        goto LABEL_4;
LABEL_6:
      hh_next = staged_work;
      prev = (char *)v2->hh.prev;
      tbl = staged_work->hh.tbl;
      if ( prev )
        break;
      v17 = (work *)v2->hh.next;
      if ( v17 )
      {
        hho = tbl->hho;
        p_hh = &v2->hh;
        if ( v2 != (work *)((char *)tbl->tail - hho) )
          goto LABEL_33;
LABEL_31:
        tbl->tail = (UT_hash_handle *)&prev[hho];
        prev = (char *)v2->hh.prev;
        if ( !prev )
        {
          v17 = (work *)v2->hh.next;
LABEL_33:
          v10 = (char *)v17;
          hh_next = v17;
          staged_work = v17;
LABEL_9:
          v11 = hh_next->hh.tbl;
          if ( v10 )
          {
            *(_DWORD *)&v10[v11->hho + 4] = v2->hh.prev;
            v11 = hh_next->hh.tbl;
          }
          v12 = (v11->num_buckets - 1) & v2->hh.hashv;
          --v11->buckets[v12].count;
          buckets = hh_next->hh.tbl->buckets;
          hh_head = buckets[v12].hh_head;
          if ( hh_head == p_hh )
          {
            hh_next = (work *)v2->hh.hh_next;
            buckets[v12].hh_head = (UT_hash_handle *)hh_next;
          }
          hh_prev = v2->hh.hh_prev;
          if ( hh_head == p_hh )
            hh_next = staged_work;
          v16 = v2->hh.hh_next;
          if ( hh_prev )
          {
            hh_prev->hh_next = v16;
            v16 = v2->hh.hh_next;
          }
          if ( v16 )
            v16->hh_prev = v2->hh.hh_prev;
          --hh_next->hh.tbl->num_items;
          goto LABEL_20;
        }
        hho = hh_next->hh.tbl->hho;
LABEL_8:
        *(_DWORD *)&prev[hho + 8] = v2->hh.next;
        v10 = (char *)v2->hh.next;
        goto LABEL_9;
      }
      free(tbl->buckets);
      free(staged_work->hh.tbl);
      staged_work = 0;
LABEL_20:
      ++v3;
      clean_work(v2);
      free(v2);
      if ( !next )
        goto LABEL_21;
    }
    hho = tbl->hho;
    p_hh = &v2->hh;
    if ( v2 == (work *)((char *)tbl->tail - hho) )
      goto LABEL_31;
    goto LABEL_8;
  }
LABEL_21:
  if ( pthread_mutex_unlock(stgd_lock) )
  {
LABEL_38:
    v19 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v19,
      "cgminer.c",
      "clear_pool_work",
      7026);
LABEL_37:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  if ( v3 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Cleared %d work items due to stratum disconnect on pool %d", v3, pool->pool_no);
    applog(7, tmp42, 0);
  }
}

//----- (0001E7F8) --------------------------------------------------------
void __fastcall switch_pools(pool *selected)
{
  int v2; // r6
  pool *v3; // r7
  pool_strategy v4; // r12
  int pool_no; // r10
  int prio; // r11
  int v7; // r0
  pool **v8; // lr
  pool **v9; // r2
  pool **v10; // r0
  int v11; // r1
  int v12; // t1
  int v13; // r3
  pool *v14; // r0
  pool *v15; // r5
  int v16; // r3
  int v17; // r0
  pool **v18; // r1
  int v19; // r3
  int v20; // r4
  int *v21; // r0
  int *v22; // r0
  int v23; // r3
  int v24; // r4
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&control_lock.mutex) )
  {
    v19 = *_errno_location();
    v20 = 5101;
LABEL_51:
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v19, "cgminer.c", "switch_pools", v20);
    goto LABEL_52;
  }
  v2 = pthread_rwlock_wrlock(&control_lock.rwlock);
  if ( v2 )
  {
    v21 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v21,
      "cgminer.c",
      "switch_pools",
      5101);
    goto LABEL_52;
  }
  v3 = currentpool;
  v4 = pool_strategy_0;
  pool_no = currentpool->pool_no;
  if ( selected )
  {
    prio = selected->prio;
    if ( prio )
    {
      v7 = total_pools;
      if ( total_pools > 0 )
      {
        v8 = pools;
        v9 = pools;
        v10 = &pools[total_pools];
        while ( 1 )
        {
          v12 = (int)*v9++;
          v11 = v12;
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 < prio )
            *(_DWORD *)(v11 + 4) = v13 + 1;
          if ( v10 == v9 )
          {
            selected->prio = 0;
            switch ( v4 )
            {
              case pool_strategy::POOL_FAILOVER:
              case pool_strategy::POOL_LOADBALANCE:
              case pool_strategy::POOL_BALANCE:
                goto LABEL_15;
              case pool_strategy::POOL_ROUNDROBIN:
              case pool_strategy::POOL_ROTATE:
                goto LABEL_37;
              default:
                goto LABEL_49;
            }
          }
          prio = selected->prio;
        }
      }
      selected->prio = 0;
      switch ( v4 )
      {
        case pool_strategy::POOL_FAILOVER:
        case pool_strategy::POOL_LOADBALANCE:
        case pool_strategy::POOL_BALANCE:
          goto LABEL_14;
        case pool_strategy::POOL_ROUNDROBIN:
        case pool_strategy::POOL_ROTATE:
          goto LABEL_36;
        default:
          goto LABEL_30;
      }
    }
    switch ( pool_strategy_0 )
    {
      case pool_strategy::POOL_FAILOVER:
      case pool_strategy::POOL_LOADBALANCE:
      case pool_strategy::POOL_BALANCE:
        goto LABEL_13;
      case pool_strategy::POOL_ROUNDROBIN:
      case pool_strategy::POOL_ROTATE:
LABEL_36:
        v8 = pools;
LABEL_37:
        if ( selected->idle )
          goto LABEL_40;
        v15 = v8[selected->pool_no];
        break;
      default:
        goto LABEL_30;
    }
  }
  else
  {
    switch ( pool_strategy_0 )
    {
      case pool_strategy::POOL_FAILOVER:
      case pool_strategy::POOL_LOADBALANCE:
      case pool_strategy::POOL_BALANCE:
LABEL_13:
        v7 = total_pools;
LABEL_14:
        if ( v7 <= 0 )
          goto LABEL_30;
        do
        {
LABEL_15:
          v14 = priority_pool(v2);
          if ( !v14->idle && v14->enabled == pool_enable::POOL_ENABLED )
          {
            v15 = pools[v14->pool_no];
            goto LABEL_18;
          }
          ++v2;
        }
        while ( total_pools > v2 );
        v15 = pools[pool_no];
        break;
      case pool_strategy::POOL_ROUNDROBIN:
      case pool_strategy::POOL_ROTATE:
        v8 = pools;
LABEL_40:
        if ( total_pools <= 1 )
        {
LABEL_49:
          v15 = v8[pool_no];
        }
        else
        {
          v16 = pool_no;
          v17 = 1;
          while ( 1 )
          {
            if ( ++v16 >= total_pools )
            {
              v18 = v8;
              v16 = 0;
            }
            else
            {
              v18 = &v8[v16];
            }
            v15 = *v18;
            if ( !(*v18)->idle && v15->enabled == pool_enable::POOL_ENABLED )
              break;
            if ( ++v17 == total_pools )
              goto LABEL_49;
          }
        }
        break;
      default:
LABEL_30:
        v15 = pools[pool_no];
        break;
    }
  }
LABEL_18:
  currentpool = v15;
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
  {
    v22 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v22,
      "cgminer.c",
      "switch_pools",
      5163);
    goto LABEL_52;
  }
  if ( pthread_mutex_unlock(&control_lock.mutex) )
  {
    v23 = *_errno_location();
    v24 = 5163;
LABEL_56:
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v23, "cgminer.c", "switch_pools", v24);
LABEL_52:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  if ( opt_fail_only )
    pool_tset((int)v15, &v15->lagging);
  if ( v3 != v15 && (unsigned int)(pool_strategy_0 - 3) > 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(tmp42, 0x1000u, "Switching to pool %d %s", v15->pool_no, v15->rpc_url);
      applog(4, tmp42, 0);
    }
    clear_pool_work(v3);
  }
  if ( pthread_mutex_lock(&lp_lock) )
  {
    v19 = *_errno_location();
    v20 = 5178;
    goto LABEL_51;
  }
  pthread_cond_broadcast(&lp_cond);
  if ( pthread_mutex_unlock(&lp_lock) )
  {
    v23 = *_errno_location();
    v24 = 5180;
    goto LABEL_56;
  }
  selective_yield();
}

//----- (0001EB74) --------------------------------------------------------
void __fastcall pool_failed(pool *pool)
{
  if ( !pool_tset((int)pool, &pool->idle) )
  {
    cgtime(&pool->tv_idle);
    if ( pool == current_pool() )
      switch_pools(0);
  }
}

//----- (0001EBA0) --------------------------------------------------------
void __fastcall pool_died(pool *pool)
{
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( !pool_tset((int)pool, &pool->idle) )
  {
    cgtime(&pool->tv_idle);
    if ( pool == current_pool() )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "Pool %d %s not responding!", pool->pool_no, pool->rpc_url);
        applog(4, tmp42, 0);
      }
      switch_pools(0);
    }
    else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "Pool %d %s failed to return work", pool->pool_no, pool->rpc_url);
      applog(7, tmp42, 0);
    }
  }
}

//----- (0001EC8C) --------------------------------------------------------
void *__fastcall test_pool_thread(void *arg)
{
  int v2; // r5
  int v4; // r0
  pthread_t v5; // r0
  int *v6; // r0
  int *v7; // r0
  int *v8; // r0
  int *v9; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( !*((_BYTE *)arg + 139) )
  {
    v5 = pthread_self();
    pthread_detach(v5);
  }
  while ( !pool_active((pool *)arg, 0) )
  {
    pool_died((pool *)arg);
    sleep(5u);
  }
  pool_tset((int)arg, (_BYTE *)arg + 130);
  pool_tclear((int)arg, (_BYTE *)arg + 129);
  if ( pthread_mutex_lock(&control_lock.mutex) )
  {
    v6 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v6,
      "cgminer.c",
      "test_pool_thread",
      10008);
    goto LABEL_16;
  }
  if ( pthread_rwlock_wrlock(&control_lock.rwlock) )
  {
    v7 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v7,
      "cgminer.c",
      "test_pool_thread",
      10008);
    goto LABEL_16;
  }
  v2 = 0;
  if ( !pools_active )
  {
    v4 = *(_DWORD *)arg;
    currentpool = (pool *)arg;
    pools_active = 1;
    v2 = v4;
    if ( v4 )
      v2 = 1;
  }
  if ( pthread_rwlock_unlock(&control_lock.rwlock) )
  {
    v8 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v8,
      "cgminer.c",
      "test_pool_thread",
      10016);
    goto LABEL_16;
  }
  if ( pthread_mutex_unlock(&control_lock.mutex) )
  {
    v9 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v9,
      "cgminer.c",
      "test_pool_thread",
      10016);
LABEL_16:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  if ( v2 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Switching to pool %d %s - first alive pool", *(_DWORD *)arg, *((const char **)arg + 49));
    applog(7, tmp42, 0);
  }
  pool_resus((pool *)arg);
  switch_pools(0);
  *((_BYTE *)arg + 316) = 0;
  return 0;
}

//----- (0001EE6C) --------------------------------------------------------
void *__fastcall __noreturn watchpool_thread(void *userdata)
{
  int v1; // r3
  int v2; // r5
  pool *v3; // r4
  int64_t diff1; // r8
  double v5; // r0
  double utility; // d7
  double v7; // d6
  int prio; // r7
  int v9; // r9
  list_head *next; // r1
  list_head *p_curlring; // r7
  list_head **p_prev; // r12
  int v13; // r8
  int curls; // r0
  int v15; // r2
  __int64 v16; // r2
  char *v17; // r0
  int v18; // r9
  stratum_share *v19; // r7
  pool *v20; // r8
  stratum_share *v21; // r4
  char *prev; // r0
  stratum_share *v23; // r3
  UT_hash_table *tbl; // r12
  ptrdiff_t hho; // r1
  char *v26; // r0
  __int64 v27; // r0
  int v28; // r1
  UT_hash_bucket *buckets; // r0
  UT_hash_handle *hh_prev; // r1
  UT_hash_handle *hh_next; // r1
  int64_t v32; // r2
  int *v33; // r0
  const char *v34; // r4
  int *v35; // r0
  int v36; // r1
  int *v37; // r0
  int intervals; // [sp+10h] [bp-102Ch]
  pthread_mutex_t *mutex; // [sp+14h] [bp-1028h]
  pthread_mutex_t *mutexa; // [sp+14h] [bp-1028h]
  work *ptra; // [sp+1Ch] [bp-1020h]
  stratum_share *ptr; // [sp+1Ch] [bp-1020h]
  stratum_share *v43; // [sp+24h] [bp-1018h]
  timeval now; // [sp+28h] [bp-1014h] BYREF
  timeval tv; // [sp+30h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+38h] [bp-1004h] BYREF

  pthread_setcanceltype(1, 0);
  intervals = 0;
  RenameThread("Watchpool");
  set_lowprio();
  while ( 1 )
  {
    v1 = intervals + 1;
    if ( intervals + 1 >= 21 )
      v1 = 0;
    intervals = v1;
    cgtime(&now);
    if ( total_pools > 0 )
      break;
LABEL_21:
    if ( current_pool()->idle )
      switch_pools(0);
    if ( pool_strategy_0 == pool_strategy::POOL_ROTATE && now.tv_sec - rotate_tv.tv_sec > 60 * opt_rotate_period )
    {
      cgtime(&rotate_tv);
      switch_pools(0);
    }
    cgsleep_ms(30000);
  }
  v2 = 0;
  while ( 1 )
  {
    v3 = pools[v2];
    if ( opt_benchmark || opt_benchfile )
      goto LABEL_10;
    mutex = &v3->pool_lock;
    cgtime(&tv);
    v9 = pthread_mutex_lock(&v3->pool_lock);
    if ( v9 )
    {
      v33 = _errno_location();
      snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v33, "cgminer.c", "reap_curl", 9503);
      goto LABEL_92;
    }
    next = v3->curlring.next;
    p_curlring = &v3->curlring;
    p_prev = &next[-1].prev;
    v13 = (int)&next->next[-1].prev;
    if ( &v3->curlring != next )
    {
      curls = v3->curls;
      if ( curls > 1 )
      {
        while ( 1 )
        {
          if ( tv.tv_sec - (int)p_prev[3] <= 300 )
          {
            v15 = *(_DWORD *)(v13 + 4) - 4;
            if ( p_curlring == (list_head *)(v13 + 4) )
              goto LABEL_40;
          }
          else
          {
            ++v9;
            v3->curls = curls - 1;
            v16 = *(_QWORD *)(p_prev + 1);
            *(_DWORD *)(v16 + 4) = HIDWORD(v16);
            *(_DWORD *)HIDWORD(v16) = v16;
            free(p_prev);
            v15 = *(_DWORD *)(v13 + 4) - 4;
            if ( p_curlring == (list_head *)(v13 + 4) )
            {
LABEL_40:
              if ( pthread_mutex_unlock(mutex) )
                goto LABEL_93;
              selective_yield();
              if ( v9 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                v17 = "s";
                if ( v9 == 1 )
                  v17 = &byte_59398;
                snprintf(tmp42, 0x1000u, "Reaped %d curl%s from pool %d", v9, v17, v3->pool_no);
                applog(7, tmp42, 0);
              }
              goto LABEL_47;
            }
          }
          curls = v3->curls;
          p_prev = (list_head **)v13;
          if ( curls <= 1 )
            goto LABEL_40;
          v13 = v15;
        }
      }
    }
    if ( pthread_mutex_unlock(mutex) )
    {
LABEL_93:
      v34 = "reap_curl";
      v35 = _errno_location();
      v36 = 9517;
      goto LABEL_94;
    }
    selective_yield();
LABEL_47:
    mutexa = (pthread_mutex_t *)time(0);
    v18 = pthread_mutex_lock(&sshare_lock);
    if ( v18 )
    {
      v37 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v37,
        "cgminer.c",
        "prune_stratum_shares",
        9532);
      goto LABEL_92;
    }
    v19 = stratum_shares;
    if ( stratum_shares )
      break;
    if ( pthread_mutex_unlock(&sshare_lock) )
    {
LABEL_96:
      v35 = _errno_location();
      v34 = "prune_stratum_shares";
      v36 = 9543;
LABEL_94:
      snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v35, "cgminer.c", v34, v36);
LABEL_92:
      applog(3, tmp42, 1);
      _quit(1, 1);
    }
    selective_yield();
LABEL_10:
    if ( intervals == 20 )
    {
      diff1 = v3->diff1;
      v5 = (double)(diff1 - v3->last_shares);
      utility = v3->utility;
      v3->last_shares = diff1;
      v7 = (utility + v5 * 0.63) / 1.63;
      v3->utility = v7;
      v3->shares = (int)v7;
    }
    if ( v3->enabled == pool_enable::POOL_DISABLED || v3->testing )
      goto LABEL_7;
    if ( !v3->idle )
    {
LABEL_6:
      if ( pool_strategy_0 == pool_strategy::POOL_FAILOVER )
      {
        prio = v3->prio;
        if ( prio < cp_prio() && now.tv_sec - v3->tv_idle.tv_sec > 300 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(tmp42, 0x1000u, "Pool %d %s stable for 5 mins", v3->pool_no, v3->rpc_url);
            applog(4, tmp42, 0);
          }
          switch_pools(0);
        }
      }
      goto LABEL_7;
    }
    if ( now.tv_sec - v3->tv_idle.tv_sec <= 30 )
    {
LABEL_7:
      if ( total_pools <= ++v2 )
        goto LABEL_21;
    }
    else
    {
      if ( pool_active(v3, 1) && pool_tclear((int)v3, &v3->idle) )
        pool_resus(v3);
      else
        cgtime(&v3->tv_idle);
      if ( !v3->idle )
        goto LABEL_6;
      if ( total_pools <= ++v2 )
        goto LABEL_21;
    }
  }
  v20 = v3;
  v21 = (stratum_share *)stratum_shares->hh.next;
  if ( v20 == stratum_shares->work->pool )
    goto LABEL_52;
LABEL_50:
  if ( !v21 )
  {
LABEL_66:
    v3 = v20;
    if ( pthread_mutex_unlock(&sshare_lock) )
      goto LABEL_96;
    selective_yield();
    if ( v18 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "Lost %d shares due to no stratum share response from pool %d", v18, v20->pool_no);
        applog(4, tmp42, 0);
      }
      v32 = total_stale;
      v20->stale_shares += v18;
      total_stale = v32 + v18;
    }
    goto LABEL_10;
  }
  while ( 1 )
  {
    v19 = v21;
    v21 = (stratum_share *)v21->hh.next;
    if ( v20 != v19->work->pool )
      goto LABEL_50;
LABEL_52:
    if ( (int)mutexa <= v19->sshare_time + 120 )
      goto LABEL_50;
    prev = (char *)v19->hh.prev;
    v23 = stratum_shares;
    tbl = stratum_shares->hh.tbl;
    if ( prev )
      break;
    ptr = (stratum_share *)v19->hh.next;
    if ( ptr )
    {
      hho = tbl->hho;
      if ( v19 != (stratum_share *)((char *)tbl->tail - hho) )
        goto LABEL_78;
LABEL_80:
      tbl->tail = (UT_hash_handle *)&prev[hho];
      prev = (char *)v19->hh.prev;
      if ( prev )
      {
        hho = v23->hh.tbl->hho;
        goto LABEL_55;
      }
      ptr = (stratum_share *)v19->hh.next;
LABEL_78:
      v23 = ptr;
      stratum_shares = ptr;
LABEL_56:
      v26 = (char *)v19->hh.next;
      if ( v26 )
        *(_DWORD *)&v26[v23->hh.tbl->hho + 4] = v19->hh.prev;
      v27 = *(_QWORD *)&v23->hh.tbl->buckets;
      v28 = 3 * ((HIDWORD(v27) - 1) & v19->hh.hashv);
      --*(_DWORD *)(v27 + 4 * v28 + 4);
      buckets = v23->hh.tbl->buckets;
      if ( (stratum_share *)buckets[v28 / 3u].hh_head == v19 )
        buckets[v28 / 3u].hh_head = v19->hh.hh_next;
      hh_prev = v19->hh.hh_prev;
      if ( hh_prev )
        hh_prev->hh_next = v19->hh.hh_next;
      hh_next = v19->hh.hh_next;
      if ( hh_next )
        hh_next->hh_prev = v19->hh.hh_prev;
      --v23->hh.tbl->num_items;
      goto LABEL_65;
    }
    v43 = stratum_shares;
    free(tbl->buckets);
    free(v43->hh.tbl);
    stratum_shares = 0;
LABEL_65:
    ++v18;
    ptra = v19->work;
    clean_work(ptra);
    free(ptra);
    free(v19);
    if ( !v21 )
      goto LABEL_66;
  }
  hho = tbl->hho;
  if ( v19 == (stratum_share *)((char *)tbl->tail - hho) )
    goto LABEL_80;
LABEL_55:
  *(_DWORD *)&prev[hho + 8] = v19->hh.next;
  goto LABEL_56;
}
// 59398: using guessed type char byte_59398;

//----- (0001F420) --------------------------------------------------------
void __fastcall clear_stratum_shares(pool *pool)
{
  stratum_share *v2; // r4
  int v3; // r8
  stratum_share *next; // r5
  double v5; // d8
  char *prev; // r0
  stratum_share *v7; // r7
  UT_hash_table *tbl; // r12
  ptrdiff_t hho; // r2
  char *v10; // r2
  UT_hash_table *v11; // r1
  int v12; // r2
  UT_hash_bucket *buckets; // r1
  UT_hash_handle *hh_next; // r2
  UT_hash_handle *hh_prev; // r3
  work *work; // r7
  double v17; // d6
  double v18; // d8
  int64_t v19; // kr10_8
  unsigned int v20; // r4
  stratum_share *v21; // r1
  int *v22; // r0
  int *v23; // r0
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&sshare_lock) )
  {
    v22 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v22,
      "cgminer.c",
      "clear_stratum_shares",
      6986);
    goto LABEL_36;
  }
  v2 = stratum_shares;
  if ( !stratum_shares )
  {
    if ( !pthread_mutex_unlock(&sshare_lock) )
    {
      selective_yield();
      return;
    }
    goto LABEL_37;
  }
  v3 = 0;
  next = (stratum_share *)stratum_shares->hh.next;
  v5 = 0.0;
  if ( stratum_shares->work->pool == pool )
    goto LABEL_6;
LABEL_4:
  if ( next )
  {
    while ( 1 )
    {
      v2 = next;
      next = (stratum_share *)next->hh.next;
      if ( v2->work->pool != pool )
        goto LABEL_4;
LABEL_6:
      prev = (char *)v2->hh.prev;
      v7 = stratum_shares;
      tbl = stratum_shares->hh.tbl;
      if ( prev )
        break;
      v21 = (stratum_share *)v2->hh.next;
      if ( v21 )
      {
        hho = tbl->hho;
        if ( v2 != (stratum_share *)((char *)tbl->tail - hho) )
          goto LABEL_30;
LABEL_28:
        tbl->tail = (UT_hash_handle *)&prev[hho];
        prev = (char *)v2->hh.prev;
        if ( !prev )
        {
          v21 = (stratum_share *)v2->hh.next;
LABEL_30:
          v10 = (char *)v21;
          v7 = v21;
          stratum_shares = v21;
LABEL_9:
          v11 = v7->hh.tbl;
          if ( v10 )
          {
            *(_DWORD *)&v10[v11->hho + 4] = v2->hh.prev;
            v11 = v7->hh.tbl;
          }
          v12 = (v11->num_buckets - 1) & v2->hh.hashv;
          --v11->buckets[v12].count;
          buckets = v7->hh.tbl->buckets;
          if ( (stratum_share *)buckets[v12].hh_head == v2 )
            buckets[v12].hh_head = v2->hh.hh_next;
          hh_next = v2->hh.hh_next;
          hh_prev = v2->hh.hh_prev;
          if ( hh_prev )
          {
            hh_prev->hh_next = hh_next;
            hh_next = v2->hh.hh_next;
          }
          if ( hh_next )
            hh_next->hh_prev = v2->hh.hh_prev;
          --v7->hh.tbl->num_items;
          goto LABEL_18;
        }
        hho = v7->hh.tbl->hho;
LABEL_8:
        *(_DWORD *)&prev[hho + 8] = v2->hh.next;
        v10 = (char *)v2->hh.next;
        goto LABEL_9;
      }
      free(tbl->buckets);
      free(v7->hh.tbl);
      stratum_shares = 0;
LABEL_18:
      work = v2->work;
      ++v3;
      v5 = v5 + work->work_difficulty;
      clean_work(work);
      free(work);
      v2->work = 0;
      --pool->sshares;
      free(v2);
      if ( !next )
        goto LABEL_19;
    }
    hho = tbl->hho;
    if ( v2 == (stratum_share *)((char *)tbl->tail - hho) )
      goto LABEL_28;
    goto LABEL_8;
  }
LABEL_19:
  if ( pthread_mutex_unlock(&sshare_lock) )
  {
LABEL_37:
    v23 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v23,
      "cgminer.c",
      "clear_stratum_shares",
      6999);
LABEL_36:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  if ( v3 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(tmp42, 0x1000u, "Lost %d shares due to stratum disconnect on pool %d", v3, pool->pool_no);
      applog(4, tmp42, 0);
    }
    v17 = pool->diff_stale + v5;
    v18 = total_diff_stale + v5;
    v19 = total_stale + v3;
    v20 = pool->stale_shares + v3;
    pool->diff_stale = v17;
    total_stale = v19;
    pool->stale_shares = v20;
    total_diff_stale = v18;
  }
}

//----- (0001F6B8) --------------------------------------------------------
work *__fastcall hash_pop(bool blocking)
{
  work *i; // r4
  work *v2; // r2
  UT_hash_table *tbl; // r1
  char *prev; // r3
  ptrdiff_t hho; // r12
  UT_hash_handle *p_hh; // r0
  work *hh_next; // r1
  work *next; // r6
  UT_hash_table *v9; // r2
  int v10; // r3
  UT_hash_bucket *buckets; // r2
  UT_hash_handle *hh_head; // r6
  UT_hash_handle *hh_prev; // r2
  UT_hash_handle *v14; // r3
  int *v16; // r0
  int *v17; // r0
  timespec then; // [sp+10h] [bp-1014h] BYREF
  timeval now; // [sp+18h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  i = (work *)blocking;
  if ( pthread_mutex_lock(stgd_lock) )
  {
    v16 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v16, "cgminer.c", "hash_pop", 7715);
    goto LABEL_64;
  }
  if ( staged_work && staged_work->hh.tbl->num_items )
  {
    if ( !no_work )
    {
LABEL_14:
      v2 = staged_work;
      goto LABEL_15;
    }
LABEL_40:
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy(tmp42, "Work available from pools, resuming.");
      applog(4, tmp42, 0);
    }
    v2 = staged_work;
    no_work = 0;
    if ( !staged_work )
      goto LABEL_44;
LABEL_15:
    tbl = v2->hh.tbl;
    if ( (signed int)tbl->num_items > staged_rollable && !v2->clone && v2->rolltime )
    {
      for ( i = (work *)v2->hh.next; i; i = (work *)i->hh.next )
      {
        if ( i->clone || !i->rolltime )
          goto LABEL_18;
      }
LABEL_44:
      __und(0xFFu);
    }
    i = v2;
LABEL_18:
    prev = (char *)i->hh.prev;
    if ( prev )
    {
      hho = tbl->hho;
      p_hh = &i->hh;
      if ( i != (work *)((char *)tbl->tail - hho) )
      {
LABEL_20:
        hh_next = staged_work;
        *(_DWORD *)&prev[hho + 8] = i->hh.next;
        next = (work *)i->hh.next;
LABEL_21:
        v9 = hh_next->hh.tbl;
        if ( next )
        {
          *(_DWORD *)&next->data[v9->hho + 4] = i->hh.prev;
          v9 = hh_next->hh.tbl;
        }
        v10 = (v9->num_buckets - 1) & i->hh.hashv;
        --v9->buckets[v10].count;
        buckets = hh_next->hh.tbl->buckets;
        hh_head = buckets[v10].hh_head;
        if ( hh_head == p_hh )
        {
          hh_next = (work *)i->hh.hh_next;
          buckets[v10].hh_head = (UT_hash_handle *)hh_next;
        }
        hh_prev = i->hh.hh_prev;
        if ( hh_head == p_hh )
          hh_next = staged_work;
        v14 = i->hh.hh_next;
        if ( hh_prev )
        {
          hh_prev->hh_next = v14;
          v14 = i->hh.hh_next;
        }
        if ( v14 )
          v14->hh_prev = i->hh.hh_prev;
        --hh_next->hh.tbl->num_items;
        goto LABEL_32;
      }
    }
    else
    {
      next = (work *)i->hh.next;
      if ( !next )
      {
        free(tbl->buckets);
        free(staged_work->hh.tbl);
        staged_work = 0;
LABEL_32:
        if ( !i->clone && i->rolltime )
          --staged_rollable;
        pthread_cond_signal(&gws_cond);
        pthread_cond_signal(&getq->cond);
        last_getwork = time(0);
        goto out_unlock;
      }
      hho = tbl->hho;
      p_hh = &i->hh;
      if ( i != (work *)((char *)tbl->tail - hho) )
        goto LABEL_52;
    }
    tbl->tail = (UT_hash_handle *)&prev[hho];
    prev = (char *)i->hh.prev;
    if ( prev )
    {
      hho = v2->hh.tbl->hho;
      goto LABEL_20;
    }
    next = (work *)i->hh.next;
LABEL_52:
    hh_next = next;
    staged_work = next;
    goto LABEL_21;
  }
  if ( work_filled && max_queue < opt_queue )
  {
    ++max_queue;
    work_filled = 0;
  }
  work_emptied = 1;
  if ( i )
  {
    do
    {
      cgtime(&now);
      then.tv_sec = now.tv_sec + 10;
      then.tv_nsec = 1000 * now.tv_usec;
      pthread_cond_signal(&gws_cond);
      if ( pthread_cond_timedwait(&getq->cond, stgd_lock, &then) )
      {
        if ( !no_work )
        {
          no_work = 1;
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            strcpy(tmp42, "Waiting for work to be available from pools.");
            applog(4, tmp42, 0);
          }
        }
      }
    }
    while ( !staged_work || !staged_work->hh.tbl->num_items );
    if ( !no_work )
      goto LABEL_14;
    goto LABEL_40;
  }
out_unlock:
  if ( pthread_mutex_unlock(stgd_lock) )
  {
    v17 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v17, "cgminer.c", "hash_pop", 7782);
LABEL_64:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  return i;
}

//----- (0001FA70) --------------------------------------------------------
void __fastcall sharelog(const char *disposition, const work *work)
{
  int thr_id; // r6
  cgpu_info *cgpu; // r11
  pool *pool; // r10
  char *v6; // r8
  char *v7; // r7
  char *v8; // r9
  signed int v9; // r4
  size_t v10; // r4
  const char *v11; // r4
  int v12; // r0
  int v13; // r1
  int v14; // r2
  int v15; // r3
  _DWORD *v16; // r4
  int v17; // r1
  int *v18; // r0
  int *v19; // r0
  __time_t t; // [sp+24h] [bp-1408h]
  char s[1024]; // [sp+28h] [bp-1404h] BYREF
  char tmp42[4096]; // [sp+428h] [bp-1004h] BYREF

  if ( !sharelog_file )
    return;
  thr_id = work->thr_id;
  cgpu = get_thread(thr_id)->cgpu;
  pool = work->pool;
  t = work->tv_work_found.tv_sec;
  v6 = bin2hex(work->target, 0x20u);
  v7 = bin2hex(work->hash, 0x20u);
  v8 = bin2hex(work->data, 0x80u);
  v9 = snprintf(
         s,
         0x400u,
         "%lu,%s,%s,%s,%s%u,%u,%s,%s\n",
         t,
         disposition,
         v6,
         pool->rpc_url,
         cgpu->drv->name,
         cgpu->device_id,
         thr_id,
         v7,
         v8);
  free(v6);
  free(v7);
  free(v8);
  if ( v9 >= 1024 )
  {
    s[1023] = 0;
    goto LABEL_5;
  }
  if ( v9 >= 0 )
  {
LABEL_5:
    if ( pthread_mutex_lock(&sharelog_lock) )
    {
      v18 = _errno_location();
      snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v18, "cgminer.c", "sharelog", 673);
    }
    else
    {
      v10 = fwrite(s, v9, 1u, sharelog_file);
      fflush(sharelog_file);
      if ( !pthread_mutex_unlock(&sharelog_lock) )
      {
        selective_yield();
        if ( v10 != 1 && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          v11 = "sharelog fwrite error";
LABEL_12:
          v12 = *(_DWORD *)v11;
          v13 = *((_DWORD *)v11 + 1);
          v14 = *((_DWORD *)v11 + 2);
          v15 = *((_DWORD *)v11 + 3);
          v16 = v11 + 16;
          *(_DWORD *)tmp42 = v12;
          *(_DWORD *)&tmp42[4] = v13;
          *(_DWORD *)&tmp42[8] = v14;
          *(_DWORD *)&tmp42[12] = v15;
          v17 = v16[1];
          *(_DWORD *)&tmp42[16] = *v16;
          *(_WORD *)&tmp42[20] = v17;
          applog(3, tmp42, 0);
          return;
        }
        return;
      }
      v19 = _errno_location();
      snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v19, "cgminer.c", "sharelog", 676);
    }
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v11 = "sharelog printf error";
    goto LABEL_12;
  }
}

//----- (0001FC58) --------------------------------------------------------
void __fastcall gen_stratum_work(pool *pool, work *work)
{
  cglock_t *p_data_lock; // r6
  int nonce2; // r3
  int nonce2_high; // r2
  size_t v7; // r0
  int v8; // lr
  int v9; // r12
  int v10; // r0
  double v11; // r2
  int v12; // r8
  int v13; // lr
  int v14; // r12
  unsigned int v15; // r0
  int *v16; // r0
  int *v17; // r0
  int v18; // r3
  int v19; // r4
  int *v20; // r0
  int *v21; // r0
  char *header; // [sp+1Ch] [bp-1008h]
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  p_data_lock = &pool->data_lock;
  if ( pthread_mutex_lock(&pool->data_lock.mutex) )
  {
    v16 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v16,
      "cgminer.c",
      "gen_stratum_work",
      7949);
    goto LABEL_19;
  }
  if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
  {
    v17 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v17,
      "cgminer.c",
      "gen_stratum_work",
      7949);
    goto LABEL_19;
  }
  nonce2 = pool->nonce2;
  nonce2_high = HIDWORD(pool->nonce2);
  LODWORD(pool->nonce2) = nonce2 + 1;
  HIDWORD(pool->nonce2) = __CFADD__(nonce2, 1) + nonce2_high;
  LODWORD(work->nonce2) = nonce2;
  HIDWORD(work->nonce2) = nonce2_high;
  work->nonce2_len = 2;
  if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
  {
    v18 = *_errno_location();
    v19 = 7954;
LABEL_22:
    snprintf(
      tmp42,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      v18,
      "cgminer.c",
      "gen_stratum_work",
      v19);
    goto LABEL_19;
  }
  if ( pthread_rwlock_rdlock(&pool->data_lock.rwlock) )
  {
    v20 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v20,
      "cgminer.c",
      "gen_stratum_work",
      7954);
    goto LABEL_19;
  }
  if ( pthread_mutex_unlock(&p_data_lock->mutex) )
  {
    v21 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v21,
      "cgminer.c",
      "gen_stratum_work",
      7954);
LABEL_19:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  memset(work->equihash_data, 0, sizeof(work->equihash_data));
  memcpy(work->equihash_data, pool->header_bin, 0x80u);
  v7 = strlen(pool->nonce1);
  hex2bin(&work->equihash_data[108], pool->nonce1, v7 >> 1);
  memcpy(&work->equihash_data[128 - work->nonce2_len], &work->nonce2, work->nonce2_len);
  work->equihash_data[140] = -3;
  *(_WORD *)&work->equihash_data[141] = 1344;
  work->sdiff = pool->swork.diff;
  work->job_id = _strdup(pool->swork.job_id);
  work->nonce1 = _strdup(pool->nonce1);
  work->ntime = _strdup(pool->swork.ntime);
  if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
  {
    v18 = *_errno_location();
    v19 = 7975;
    goto LABEL_22;
  }
  selective_yield();
  if ( opt_debug )
  {
    header = bin2hex(work->equihash_data, 0x8Fu);
    if ( opt_debug )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_14;
      snprintf(tmp42, 0x1000u, "[THR%d] Generated stratum header %s", work->thr_id, header);
      applog(7, tmp42, 0);
      if ( opt_debug )
      {
        if ( use_syslog )
        {
LABEL_16:
          snprintf(
            tmp42,
            0x1000u,
            "[THR%d] job_id %s, nonce1 %s, nonce2 %llu, ntime %s",
            work->thr_id,
            work->job_id,
            work->nonce1,
            work->nonce2,
            work->ntime);
          applog(7, tmp42, 0);
          goto LABEL_17;
        }
LABEL_14:
        if ( !opt_log_output && opt_log_level <= 6 )
          goto LABEL_17;
        goto LABEL_16;
      }
    }
LABEL_17:
    free(header);
  }
  v8 = *(_DWORD *)&pool->Target[4];
  v9 = *(_DWORD *)&pool->Target[8];
  v10 = *(_DWORD *)&pool->Target[12];
  LODWORD(v11) = local_work + 1;
  *(_DWORD *)work->target = *(_DWORD *)pool->Target;
  *(_DWORD *)&work->target[4] = v8;
  *(_DWORD *)&work->target[8] = v9;
  *(_DWORD *)&work->target[12] = v10;
  v12 = *(_DWORD *)&pool->Target[16];
  v13 = *(_DWORD *)&pool->Target[20];
  v14 = *(_DWORD *)&pool->Target[24];
  HIDWORD(v11) = total_work;
  *(_DWORD *)&work->target[28] = *(_DWORD *)&pool->Target[28];
  v15 = work_block;
  *(_DWORD *)&work->target[16] = v12;
  *(_DWORD *)&work->target[20] = v13;
  *(_DWORD *)&work->target[24] = v14;
  work->id = HIDWORD(v11)++;
  work->work_block = v15;
  work->getwork_mode = 83;
  work->drv_rolllimit = 60;
  work->pool = pool;
  work->stratum = 1;
  work->longpoll = 0;
  total_work = HIDWORD(v11);
  local_work = LODWORD(v11);
  calc_diff(work, v11);
  cgtime(&work->tv_staged);
}

//----- (0001FFEC) --------------------------------------------------------
bool __fastcall stale_work(work *work, bool share)
{
  bool v2; // r5
  _BOOL4 v4; // r7
  int rolltime; // r8
  pool *pool; // r9
  int v8; // r8
  const char *v9; // r6
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  int *v14; // r6
  int v15; // r0
  int v16; // r1
  int v17; // r2
  int v18; // r3
  int v19; // r1
  int v20; // r2
  const char *v21; // r2
  int v22; // r3
  const char *v23; // r2
  int v24; // r3
  int *v25; // r0
  int *v26; // r0
  timeval now; // [sp+10h] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1004h] BYREF

  v2 = opt_benchmark;
  if ( !opt_benchmark )
  {
    if ( opt_benchfile )
      return v2;
    v4 = share;
    if ( work->work_block != work_block )
    {
      v2 = opt_debug;
      if ( opt_debug )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 6 )
        {
          strcpy(tmp42, "Work stale due to block mismatch");
          applog(7, tmp42, 0);
        }
        return v2;
      }
      return 1;
    }
    rolltime = work->rolltime;
    pool = work->pool;
    if ( rolltime <= opt_scantime )
      rolltime = opt_expiry;
    if ( !share && pool->has_stratum )
    {
      if ( !pool->stratum_active || !pool->stratum_notify )
      {
        v2 = opt_debug;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy(tmp42, "Work stale due to stratum inactive");
          applog(7, tmp42, 0);
          return v2;
        }
        return 1;
      }
      if ( pthread_mutex_lock(&pool->data_lock.mutex) )
        mutex_lock((pthread_mutex_t *)&_func___15639, (const char *)0x1347, v21, v22);
      if ( pthread_rwlock_rdlock(&pool->data_lock.rwlock) )
        rd_lock((pthread_rwlock_t *)&_func___15639, (const char *)0x1347, v23, v24);
      if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
      {
        v26 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v26,
          "cgminer.c",
          &_func___15639,
          4935);
LABEL_56:
        applog(3, tmp42, 1);
        _quit(1, 1);
      }
      if ( strcmp(work->job_id, pool->swork.job_id) )
      {
        if ( !pthread_rwlock_unlock(&pool->data_lock.rwlock) )
        {
          selective_yield();
          v2 = opt_debug;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            v9 = "Work stale due to stratum job_id mismatch";
            goto LABEL_42;
          }
          return 1;
        }
        goto LABEL_55;
      }
      if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
      {
LABEL_55:
        v25 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v25,
          "cgminer.c",
          &_func___15639,
          4938);
        goto LABEL_56;
      }
      selective_yield();
    }
    v8 = rolltime - (int)(pool->cgminer_pool_stats.getwork_wait_rolling * 5.0 + 1.0);
    cgtime(&now);
    if ( v8 < 5 )
      v8 = 5;
    if ( v8 <= now.tv_sec - work->tv_staged.tv_sec )
    {
      v2 = opt_debug;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(tmp42, "Work stale due to expiry");
        applog(7, tmp42, 0);
        return v2;
      }
      return 1;
    }
    if ( !opt_fail_only || v4 || pool == current_pool() || work->mandatory || (unsigned int)(pool_strategy_0 - 3) <= 1 )
      return v2;
    v2 = opt_debug;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      v9 = "Work stale due to fail only pool mismatch";
LABEL_42:
      v10 = *(_DWORD *)v9;
      v11 = *((_DWORD *)v9 + 1);
      v12 = *((_DWORD *)v9 + 2);
      v13 = *((_DWORD *)v9 + 3);
      v14 = (int *)(v9 + 16);
      *(_DWORD *)tmp42 = v10;
      *(_DWORD *)&tmp42[4] = v11;
      *(_DWORD *)&tmp42[8] = v12;
      *(_DWORD *)&tmp42[12] = v13;
      v15 = *v14;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[3];
      v14 += 4;
      *(_DWORD *)&tmp42[16] = v15;
      *(_DWORD *)&tmp42[20] = v16;
      *(_DWORD *)&tmp42[24] = v17;
      *(_DWORD *)&tmp42[28] = v18;
      v19 = v14[1];
      v20 = v14[2];
      *(_DWORD *)&tmp42[32] = *v14;
      *(_DWORD *)&tmp42[36] = v19;
      *(_WORD *)&tmp42[40] = v20;
      applog(7, tmp42, 0);
      return v2;
    }
    return 1;
  }
  return 0;
}
// 202F0: variable 'v21' is possibly undefined
// 202F0: variable 'v22' is possibly undefined
// 202FA: variable 'v23' is possibly undefined
// 202FA: variable 'v24' is possibly undefined

//----- (00020360) --------------------------------------------------------
work *__fastcall get_work(thr_info *thr, const int thr_id)
{
  cgpu_info *cgpu; // r6
  time_t v5; // r5
  work *v6; // r4
  int v7; // r5
  _BOOL4 v8; // r3
  char **v9; // r3
  double *p_device_diff; // r3
  work *result; // r0
  double max_diff; // d7
  device_drv *drv; // r2
  int v14; // r1
  int hidiff; // r2
  int v16; // r2
  int v17; // r1
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  cgpu = thr->cgpu;
  thread_reportout(thr);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Popping work from get queue to get work");
    applog(7, tmp42, 0);
  }
  v5 = time(0);
  do
  {
    while ( 1 )
    {
      v6 = hash_pop(1);
      if ( !stale_work(v6, 0) )
        break;
      discard_work(v6);
      wake_gws();
    }
  }
  while ( !v6 );
  v7 = time(0) - v5;
  v8 = opt_debug;
  if ( v7 <= 0 )
  {
LABEL_16:
    if ( !v8 )
      goto LABEL_20;
    goto LABEL_17;
  }
  if ( !opt_debug )
  {
    cgpu->last_device_valid_work += v7;
    goto LABEL_20;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 6 )
  {
    snprintf(tmp42, 0x1000u, "Get work blocked for %d seconds", v7);
    applog(7, tmp42, 0);
    v8 = opt_debug;
    cgpu->last_device_valid_work += v7;
    goto LABEL_16;
  }
  cgpu->last_device_valid_work += v7;
LABEL_17:
  if ( use_syslog || opt_log_output || opt_log_level > 6 )
  {
    snprintf(tmp42, 0x1000u, "Got work from get queue to get work for thread %d", thr_id);
    applog(7, tmp42, 0);
  }
LABEL_20:
  v9 = &opt_logfile_path;
  v6->thr_id = thr_id;
  if ( !opt_benchmark )
    goto LABEL_21;
  v14 = cgpu->direction + cgpu->lodiff;
  cgpu->lodiff = v14;
  if ( v14 <= 0 )
  {
    cgpu->direction = 1;
LABEL_44:
    memcpy(v6, bench_lodiff_bins[v14], 0xA0u);
    goto LABEL_21;
  }
  if ( v14 <= 15 )
    goto LABEL_44;
  hidiff = cgpu->hidiff;
  cgpu->direction = -1;
  v16 = hidiff + 1;
  if ( v16 > 15 )
  {
    v17 = (int)bench_hidiff_bins;
  }
  else
  {
    v17 = 5 * v16;
    v9 = (char **)bench_hidiff_bins;
  }
  if ( v16 > 15 )
    v9 = 0;
  else
    cgpu->hidiff = v16;
  if ( v16 > 15 )
    cgpu->hidiff = (int)v9;
  else
    v17 = (int)&v9[8 * v17];
  memcpy(v6, (const void *)v17, 0xA0u);
LABEL_21:
  thread_reportin(thr);
  v6->mined = 1;
  p_device_diff = &v6->device_diff;
  result = v6;
  max_diff = cgpu->drv->max_diff;
  if ( max_diff > v6->work_difficulty )
    max_diff = v6->work_difficulty;
  *p_device_diff = max_diff;
  drv = cgpu->drv;
  if ( drv->min_diff > max_diff )
    max_diff = drv->min_diff;
  *p_device_diff = max_diff;
  return result;
}

//----- (00020590) --------------------------------------------------------
work *__fastcall get_queue_work(thr_info *thr, cgpu_info *cgpu, int thr_id)
{
  work *work; // r4

  work = get_work(thr, thr_id);
  add_queued(cgpu, work);
  return work;
}

//----- (000205A8) --------------------------------------------------------
work *__fastcall _get_queued(cgpu_info *cgpu)
{
  work *unqueued_work; // r5
  work *v4; // r0

  unqueued_work = cgpu->unqueued_work;
  if ( unqueued_work )
  {
    if ( stale_work(cgpu->unqueued_work, 0) )
    {
      v4 = unqueued_work;
      unqueued_work = 0;
      discard_work(v4);
      wake_gws();
    }
    else
    {
      _add_queued(cgpu, unqueued_work);
    }
    cgpu->unqueued_work = 0;
  }
  return unqueued_work;
}

//----- (000205DC) --------------------------------------------------------
work *__fastcall get_queued(cgpu_info *a1)
{
  pthread_rwlock_t *p_qlock; // r4
  const char *v3; // r2
  int v4; // r3
  work *queued; // r5
  const char *v6; // r2
  int v7; // r3

  p_qlock = &a1->qlock;
  if ( pthread_rwlock_wrlock(&a1->qlock) )
    wr_lock((pthread_rwlock_t *)(&_func___15639.__align + 3), (const char *)0x2270, v3, v4);
  queued = _get_queued(a1);
  if ( pthread_rwlock_unlock(p_qlock) )
    rw_unlock((pthread_rwlock_t *)(&_func___15639.__align + 3), (const char *)0x2272, v6, v7);
  selective_yield();
  return queued;
}
// 20612: variable 'v3' is possibly undefined
// 20612: variable 'v4' is possibly undefined
// 2061C: variable 'v6' is possibly undefined
// 2061C: variable 'v7' is possibly undefined

//----- (00020624) --------------------------------------------------------
void discard_stale()
{
  work *v0; // r4
  work *next; // r5
  int v2; // r7
  char *prev; // r1
  work *hh_next; // r2
  UT_hash_table *tbl; // lr
  ptrdiff_t hho; // r0
  UT_hash_handle *p_hh; // r12
  char *v8; // r3
  UT_hash_table *v9; // r1
  int v10; // r3
  UT_hash_bucket *buckets; // r0
  UT_hash_handle *hh_head; // r1
  bool v13; // zf
  UT_hash_handle *hh_prev; // r1
  UT_hash_handle *v15; // r3
  work *v16; // r9
  int *v17; // r0
  int *v18; // r0
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(stgd_lock) )
  {
    v17 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v17,
      "cgminer.c",
      "discard_stale",
      5214);
    goto LABEL_39;
  }
  v0 = staged_work;
  if ( !staged_work )
  {
    pthread_cond_signal(&gws_cond);
    if ( !pthread_mutex_unlock(stgd_lock) )
    {
      selective_yield();
      return;
    }
    goto LABEL_40;
  }
  next = (work *)staged_work->hh.next;
  v2 = 0;
  while ( 1 )
  {
    if ( !stale_work(v0, 0) )
      goto LABEL_20;
    prev = (char *)v0->hh.prev;
    hh_next = staged_work;
    tbl = staged_work->hh.tbl;
    if ( prev )
    {
      hho = tbl->hho;
      p_hh = &v0->hh;
      if ( v0 != (work *)((char *)tbl->tail - hho) )
      {
LABEL_7:
        *(_DWORD *)&prev[hho + 8] = v0->hh.next;
        v8 = (char *)v0->hh.next;
LABEL_8:
        v9 = hh_next->hh.tbl;
        if ( v8 )
        {
          *(_DWORD *)&v8[v9->hho + 4] = v0->hh.prev;
          v9 = hh_next->hh.tbl;
        }
        v10 = (v9->num_buckets - 1) & v0->hh.hashv;
        --v9->buckets[v10].count;
        buckets = hh_next->hh.tbl->buckets;
        hh_head = buckets[v10].hh_head;
        v13 = hh_head == p_hh;
        if ( hh_head == p_hh )
        {
          hh_next = (work *)v0->hh.hh_next;
          buckets[v10].hh_head = (UT_hash_handle *)hh_next;
        }
        hh_prev = v0->hh.hh_prev;
        if ( v13 )
          hh_next = staged_work;
        v15 = v0->hh.hh_next;
        if ( hh_prev )
        {
          hh_prev->hh_next = v15;
          v15 = v0->hh.hh_next;
        }
        if ( v15 )
          v15->hh_prev = v0->hh.hh_prev;
        --hh_next->hh.tbl->num_items;
        goto LABEL_19;
      }
LABEL_24:
      tbl->tail = (UT_hash_handle *)&prev[hho];
      prev = (char *)v0->hh.prev;
      if ( prev )
      {
        hho = hh_next->hh.tbl->hho;
        goto LABEL_7;
      }
      v16 = (work *)v0->hh.next;
LABEL_26:
      v8 = (char *)v16;
      hh_next = v16;
      staged_work = v16;
      goto LABEL_8;
    }
    v16 = (work *)v0->hh.next;
    if ( v16 )
    {
      hho = tbl->hho;
      p_hh = &v0->hh;
      if ( v0 != (work *)((char *)tbl->tail - hho) )
        goto LABEL_26;
      goto LABEL_24;
    }
    free(tbl->buckets);
    free(staged_work->hh.tbl);
    staged_work = 0;
LABEL_19:
    ++v2;
    discard_work(v0);
LABEL_20:
    if ( !next )
      break;
    v0 = next;
    next = (work *)next->hh.next;
  }
  pthread_cond_signal(&gws_cond);
  if ( pthread_mutex_unlock(stgd_lock) )
  {
LABEL_40:
    v18 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v18,
      "cgminer.c",
      "discard_stale",
      5225);
LABEL_39:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  selective_yield();
  if ( v2 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Discarded %d stales that didn't match current hash", v2);
    applog(7, tmp42, 0);
  }
}

//----- (00020888) --------------------------------------------------------
int restart_thread()
{
  pool *v0; // r4
  pthread_t v1; // r0
  const char *v2; // r2
  int v3; // r3
  int v4; // r6
  const char *v5; // r2
  int v6; // r3
  int v7; // r4
  thr_info *v8; // r3
  pthread_rwlock_t *cgpu; // r5
  const char *v10; // r2
  int v11; // r3
  const char *v12; // r2
  int v13; // r3

  v0 = current_pool();
  v1 = pthread_self();
  pthread_detach(v1);
  pool_tset((int)v0, &v0->lagging);
  discard_stale();
  if ( pthread_rwlock_rdlock(&mining_thr_lock) )
    rd_lock((pthread_rwlock_t *)&_func___15760, (const char *)0x1496, v2, v3);
  v4 = mining_threads;
  v7 = pthread_rwlock_unlock(&mining_thr_lock);
  if ( v7 )
    rw_unlock((pthread_rwlock_t *)&_func___15760, (const char *)0x1498, v5, v6);
  selective_yield();
  if ( v4 > 0 )
  {
    do
    {
      v8 = mining_thr[v7];
      cgpu = (pthread_rwlock_t *)v8->cgpu;
      if ( cgpu && !cgpu[1].__readers )
      {
        v8->work_restart = 1;
        flush_queue(cgpu);
        (*(void (__fastcall **)(pthread_rwlock_t *))(cgpu->__writers + 76))(cgpu);
      }
      ++v7;
    }
    while ( v4 != v7 );
  }
  if ( pthread_mutex_lock(&restart_lock) )
    mutex_lock((pthread_mutex_t *)&_func___15760, (const char *)0x14A4, v10, v11);
  pthread_cond_broadcast(&restart_cond);
  if ( pthread_mutex_unlock(&restart_lock) )
    mutex_unlock_noyield((pthread_mutex_t *)&_func___15760, (const char *)0x14A6, v12, v13);
  selective_yield();
  return 0;
}
// 20952: variable 'v2' is possibly undefined
// 20952: variable 'v3' is possibly undefined
// 2095C: variable 'v5' is possibly undefined
// 2095C: variable 'v6' is possibly undefined
// 20966: variable 'v10' is possibly undefined
// 20966: variable 'v11' is possibly undefined
// 20970: variable 'v12' is possibly undefined
// 20970: variable 'v13' is possibly undefined

//----- (00020978) --------------------------------------------------------
int __fastcall stratum_sthread(pool *a1)
{
  pthread_t v2; // r0
  thread_q *v3; // r0
  thread_q *v4; // r4
  thread_q *stratum_q; // r0
  void *v6; // r4
  char *v7; // r6
  char *v8; // r8
  char *v9; // r7
  int v10; // r2
  size_t v11; // r0
  time_t v12; // r8
  ssize_t v13; // r0
  stratum_share *v14; // r4
  __int64 v15; // r2
  UT_hash_table *tbl; // r5
  int v17; // r5
  int v18; // r3
  int v19; // r1
  unsigned int v20; // r0
  unsigned int v21; // r3
  int v22; // r1
  unsigned int v23; // r0
  unsigned int v24; // r3
  unsigned int v25; // r1
  unsigned int v26; // r3
  __int64 v27; // kr00_8
  int v28; // r0
  UT_hash_handle *hh_head; // r1
  UT_hash_bucket *buckets; // r2
  UT_hash_handle *v31; // r3
  UT_hash_bucket *v32; // r2
  __int64 v33; // r2
  int v34; // r4
  time_t v35; // r0
  _BOOL4 v36; // r3
  _DWORD *v38; // r7
  unsigned int v39; // r1
  unsigned int v40; // r3
  int v41; // r1
  unsigned int v42; // r4
  unsigned int v43; // r10
  char *v44; // r9
  _DWORD *v45; // r5
  _DWORD *v46; // r6
  int v47; // r4
  char *v48; // r8
  unsigned int v49; // r2
  int v50; // r3
  int v51; // r3
  unsigned int v52; // r2
  unsigned int v53; // r1
  bool v54; // cc
  int v55; // r2
  char *v56; // r5
  char *v57; // r4
  int v58; // r0
  int v59; // r1
  int v60; // r2
  int v61; // r3
  _DWORD *v62; // r5
  char *v63; // r4
  int v64; // r1
  int v65; // r2
  int v66; // r3
  UT_hash_table *v67; // r0
  UT_hash_bucket *v68; // r0
  int v69; // r3
  int v70; // r4
  int v71; // r3
  int v72; // r4
  const char *nonce1; // r1
  int v74; // r3
  int v75; // r3
  int v76; // r3
  int v77; // [sp+18h] [bp-2034h]
  pool *v78; // [sp+30h] [bp-201Ch]
  char s[16]; // [sp+38h] [bp-2014h] BYREF
  char v80[4096]; // [sp+48h] [bp-2004h] BYREF
  char v81[4100]; // [sp+1048h] [bp-1004h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(s, 0x10u, "%d/SStratum", a1->pool_no);
  RenameThread(s);
  v3 = tq_new();
  a1->stratum_q = v3;
  if ( !v3 )
  {
    v56 = " stratum_q in stratum_sthread";
    qmemcpy(v81, "Failed to create", 16);
    v57 = &v81[16];
    goto LABEL_64;
  }
  v4 = v3;
  memset(v80, 0, sizeof(v80));
  if ( !a1->removed )
  {
    stratum_q = v4;
    while ( 1 )
    {
      v6 = tq_pop(stratum_q, 0);
      if ( !v6 )
        break;
      v7 = (char *)calloc(0x34u, 1u);
      if ( !v7 )
      {
        snprintf(v81, 0x1000u, "%s: calloc() failed on sshare.", &_func___15760.__size[16]);
        goto LABEL_38;
      }
      *((_DWORD *)v7 + 11) = time(0);
      *((_DWORD *)v7 + 9) = v6;
      v8 = bin2hex((const unsigned __int8 *)v6 + 332, 0x20u);
      v9 = bin2hex((const unsigned __int8 *)v6 + 364, 0x543u);
      if ( pthread_mutex_lock(&sshare_lock) )
      {
        v69 = *_errno_location();
        v70 = 7288;
        goto LABEL_70;
      }
      v10 = swork_id;
      *((_DWORD *)v7 + 10) = swork_id;
      swork_id = v10 + 1;
      if ( pthread_mutex_unlock(&sshare_lock) )
      {
        v71 = *_errno_location();
        v72 = 7291;
        goto LABEL_72;
      }
      selective_yield();
      v11 = strlen(*((const char **)v6 + 452));
      snprintf(
        v80,
        0x1000u,
        "{\"id\": %d, \"method\": \"mining.submit\", \"params\": [\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"]}",
        *((_DWORD *)v7 + 10),
        a1->rpc_user,
        *((const char **)v6 + 444),
        *((const char **)v6 + 449),
        &v8[v11],
        v9);
      free(v8);
      free(v9);
      while ( 1 )
      {
        v12 = *((_DWORD *)v7 + 11) + 119;
        if ( v12 < time(0) )
          goto LABEL_29;
        v13 = strlen(v80);
        if ( stratum_send(a1, v80, v13) )
        {
          if ( !pthread_mutex_lock(&sshare_lock) )
          {
            v14 = stratum_shares;
            LODWORD(v15) = v7 + 40;
            HIDWORD(v15) = 4;
            *((_DWORD *)v7 + 2) = 0;
            *(_QWORD *)(v7 + 20) = v15;
            if ( v14 )
            {
              v14->hh.tbl->tail->next = v7;
              *((_DWORD *)v7 + 1) = (char *)v14->hh.tbl->tail - v14->hh.tbl->hho;
              v14->hh.tbl->tail = (UT_hash_handle *)v7;
              tbl = v14->hh.tbl;
              goto LABEL_14;
            }
            *((_DWORD *)v7 + 1) = 0;
            stratum_shares = (stratum_share *)v7;
            v67 = (UT_hash_table *)malloc(0x2Cu);
            tbl = v67;
            *(_DWORD *)v7 = v67;
            if ( v67 )
            {
              memset(&v67->num_items, 0, 0x20u);
              tbl->num_buckets = 32;
              tbl->tail = (UT_hash_handle *)v7;
              tbl->hho = 0;
              tbl->log2_num_buckets = 5;
              v68 = (UT_hash_bucket *)calloc(0x180u, 1u);
              tbl->buckets = v68;
              if ( v68 )
              {
                v14 = (stratum_share *)v7;
                tbl->signature = -1609490463;
LABEL_14:
                ++tbl->num_items;
                v17 = (unsigned __int8)v7[41];
                v18 = (unsigned __int8)v7[40]
                    + 17973517
                    + ((unsigned __int8)v7[43] << 24)
                    + ((unsigned __int8)v7[42] << 16);
                *(_DWORD *)v7 = v14->hh.tbl;
                v19 = (v18 + (v17 << 8)) ^ 0x7F76D;
                v20 = (-1622558010 - v19) ^ (v19 << 8);
                v21 = (-17973517 - v19 - v20) ^ (v20 >> 13);
                v22 = (v19 - v20 - v21) ^ (v21 >> 12);
                v23 = (v20 - v21 - v22) ^ (v22 << 16);
                v24 = (v21 - v22 - v23) ^ (v23 >> 5);
                v25 = v22 - v23 - v24;
                v26 = (v24 - (v25 ^ (v24 >> 3)) - ((v23 - v24 - (v25 ^ (v24 >> 3))) ^ ((v25 ^ (v24 >> 3)) << 10)))
                    ^ (((v23 - v24 - (v25 ^ (v24 >> 3))) ^ ((v25 ^ (v24 >> 3)) << 10)) >> 15);
                *((_DWORD *)v7 + 7) = v26;
                v27 = *(_QWORD *)&v14->hh.tbl->buckets;
                v28 = v26 & (HIDWORD(v27) - 1);
                ++*(_DWORD *)(v27 + v28 * 12 + 4);
                hh_head = v14->hh.tbl->buckets[v28].hh_head;
                *((_DWORD *)v7 + 3) = 0;
                *((_DWORD *)v7 + 4) = hh_head;
                buckets = v14->hh.tbl->buckets;
                v31 = buckets[v28].hh_head;
                v32 = &buckets[v28];
                if ( v31 )
                {
                  v31->hh_prev = (UT_hash_handle *)v7;
                  v32 = &v14->hh.tbl->buckets[v28];
                }
                v32->hh_head = (UT_hash_handle *)v7;
                v33 = *(_QWORD *)&v14->hh.tbl->buckets[v28].count;
                if ( (unsigned int)v33 < 10 * (HIDWORD(v33) + 1)
                  || (v34 = *(_DWORD *)v7, *(_DWORD *)(*(_DWORD *)v7 + 36) == 1) )
                {
LABEL_18:
                  ++a1->sshares;
                  if ( !pthread_mutex_unlock(&sshare_lock) )
                  {
                    selective_yield();
                    if ( !pool_tclear((int)a1, &a1->submit_fail) )
                      goto LABEL_24;
                    if ( use_syslog || opt_log_output || opt_log_level > 3 )
                    {
                      snprintf(v81, 0x1000u, "Pool %d communication resumed, submitting work", a1->pool_no);
                      applog(4, v81, 0);
LABEL_24:
                      if ( !opt_debug )
                        goto LABEL_29;
                      if ( !use_syslog && !opt_log_output )
                      {
LABEL_27:
                        if ( opt_log_level <= 6 )
                          goto LABEL_29;
                      }
                      strcpy(v81, "Successfully submitted, adding to stratum_shares db");
                      applog(7, v81, 0);
                      goto LABEL_29;
                    }
                    if ( !opt_debug )
                      goto LABEL_29;
                    goto LABEL_27;
                  }
                  v71 = *_errno_location();
                  v72 = 7309;
LABEL_72:
                  snprintf(
                    v81,
                    0x1000u,
                    "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                    v71,
                    "cgminer.c",
                    &_func___15760.__align + 4,
                    v72);
LABEL_38:
                  applog(3, v81, 1);
                  _quit(1, 1);
                }
                v38 = calloc(24 * *(_DWORD *)(v34 + 4), 1u);
                if ( v38 )
                {
                  v39 = *(_DWORD *)(v34 + 12);
                  v40 = v39 >> (*(_QWORD *)(v34 + 8) + 1);
                  if ( ((2 * *(_DWORD *)(v34 + 4) - 1) & v39) != 0 )
                    ++v40;
                  *(_DWORD *)(v34 + 24) = v40;
                  *(_DWORD *)(*(_DWORD *)v7 + 28) = 0;
                  v41 = *(_DWORD *)v7;
                  v42 = *(_DWORD *)(*(_DWORD *)v7 + 4);
                  if ( v42 )
                  {
                    v78 = a1;
                    v43 = 0;
                    v44 = v7;
                    v77 = 0;
                    do
                    {
                      v45 = *(_DWORD **)(*(_DWORD *)v41 + v77);
                      if ( v45 )
                      {
                        while ( 1 )
                        {
                          v46 = (_DWORD *)v45[4];
                          v47 = 3 * ((2 * v42 - 1) & v45[7]);
                          v48 = (char *)&v38[v47];
                          v49 = *((_DWORD *)v48 + 1) + 1;
                          *((_DWORD *)v48 + 1) = v49;
                          if ( v49 > *(_DWORD *)(v41 + 24) )
                          {
                            ++*(_DWORD *)(v41 + 28);
                            *((_DWORD *)v48 + 2) = *((_DWORD *)v48 + 1) / *(_DWORD *)(*(_DWORD *)v44 + 24);
                          }
                          v45[3] = 0;
                          v45[4] = v38[v47];
                          v50 = v38[v47];
                          if ( v50 )
                            *(_DWORD *)(v50 + 12) = v45;
                          v38[v47] = v45;
                          v41 = *(_DWORD *)v44;
                          if ( !v46 )
                            break;
                          v42 = *(_DWORD *)(v41 + 4);
                          v45 = v46;
                        }
                        v42 = *(_DWORD *)(v41 + 4);
                      }
                      ++v43;
                      v77 += 12;
                    }
                    while ( v43 < v42 );
                    v7 = v44;
                    a1 = v78;
                  }
                  free(*(void **)v41);
                  *(_DWORD *)(*(_DWORD *)v7 + 4) *= 2;
                  ++*(_DWORD *)(*(_DWORD *)v7 + 8);
                  **(_DWORD **)v7 = v38;
                  v51 = *(_DWORD *)v7;
                  v52 = *(_DWORD *)(*(_DWORD *)v7 + 28);
                  v53 = *(_DWORD *)(*(_DWORD *)v7 + 12);
                  v54 = v52 > v53 >> 1;
                  if ( v52 <= v53 >> 1 )
                    v55 = 0;
                  else
                    v55 = *(_DWORD *)(v51 + 32);
                  if ( v54 )
                    ++v55;
                  *(_DWORD *)(v51 + 32) = v55;
                  if ( *(_DWORD *)(*(_DWORD *)v7 + 32) > 1u )
                    *(_DWORD *)(*(_DWORD *)v7 + 36) = 1;
                  goto LABEL_18;
                }
              }
            }
            exit(-1);
          }
          v69 = *_errno_location();
          v70 = 7306;
LABEL_70:
          snprintf(
            v81,
            0x1000u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            v69,
            "cgminer.c",
            &_func___15760.__align + 4,
            v70);
          goto LABEL_38;
        }
        if ( !pool_tset((int)a1, &a1->submit_fail) && cnx_needed(a1) )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(v81, 0x1000u, "Pool %d stratum share submission failure", a1->pool_no);
            applog(4, v81, 0);
          }
          v75 = a1->remotefail_occasions + 1;
          ++total_ro;
          a1->remotefail_occasions = v75;
        }
        if ( opt_lowmem )
          break;
        if ( pthread_mutex_lock(&a1->data_lock.mutex) )
        {
          v69 = *_errno_location();
          v70 = 7330;
          goto LABEL_70;
        }
        if ( pthread_rwlock_rdlock(&a1->data_lock.rwlock) )
        {
          v76 = *_errno_location();
          snprintf(
            v81,
            0x1000u,
            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            v76,
            "cgminer.c",
            &_func___15760.__align + 4,
            7330);
          goto LABEL_38;
        }
        if ( pthread_mutex_unlock(&a1->data_lock.mutex) )
        {
          v71 = *_errno_location();
          v72 = 7330;
          goto LABEL_72;
        }
        nonce1 = a1->nonce1;
        if ( !nonce1 || strcmp(*((const char **)v6 + 452), nonce1) )
        {
          if ( !pthread_rwlock_unlock(&a1->data_lock.rwlock) )
          {
            selective_yield();
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy(v81, "No matching session id for resubmitting stratum share");
              applog(7, v81, 0);
            }
            goto LABEL_29;
          }
LABEL_87:
          v74 = *_errno_location();
          snprintf(
            v81,
            0x1000u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            v74,
            "cgminer.c",
            &_func___15760.__align + 4,
            7332);
          goto LABEL_38;
        }
        if ( pthread_rwlock_unlock(&a1->data_lock.rwlock) )
          goto LABEL_87;
        selective_yield();
        sleep(5u);
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(v81, "Lowmem option prevents resubmitting stratum share");
        applog(7, v81, 0);
      }
LABEL_29:
      v35 = time(0);
      v36 = opt_debug;
      *((_DWORD *)v7 + 12) = v35;
      if ( v36 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          v81,
          0x1000u,
          "Pool %d stratum share submission lag time %d seconds",
          a1->pool_no,
          v35 - *((_DWORD *)v7 + 11));
        applog(7, v81, 0);
      }
      memset(v80, 0, sizeof(v80));
      stratum_q = a1->stratum_q;
      if ( a1->removed )
      {
        v4 = a1->stratum_q;
        goto LABEL_36;
      }
    }
    v56 = "Stratum q returned empty work";
    v57 = v81;
LABEL_64:
    v58 = *(_DWORD *)v56;
    v59 = *((_DWORD *)v56 + 1);
    v60 = *((_DWORD *)v56 + 2);
    v61 = *((_DWORD *)v56 + 3);
    v62 = v56 + 16;
    *(_DWORD *)v57 = v58;
    *((_DWORD *)v57 + 1) = v59;
    *((_DWORD *)v57 + 2) = v60;
    *((_DWORD *)v57 + 3) = v61;
    v63 = v57 + 16;
    v64 = v62[1];
    v65 = v62[2];
    v66 = v62[3];
    *(_DWORD *)v63 = *v62;
    *((_DWORD *)v63 + 1) = v64;
    *((_DWORD *)v63 + 2) = v65;
    *((_WORD *)v63 + 6) = v66;
    applog(3, v81, 1);
    _quit(1, 1);
  }
LABEL_36:
  tq_freeze(v4);
  return 0;
}

//----- (00021200) --------------------------------------------------------
void __fastcall hashmeter(int thr_id, int a2, uint64_t hashes_done)
{
  double v3; // d0
  __time_t tv_sec; // r6
  double v6; // d9
  int v7; // r6
  cgpu_info *cgpu; // r5
  double v9; // r0
  double v10; // r2
  double v11; // r0
  double v12; // r2
  double v13; // r0
  double v14; // r2
  double v15; // r0
  double v16; // r2
  double v17; // d10
  int v18; // r6
  int v19; // r6
  bool v20; // cc
  int v21; // r8
  unsigned __int64 v22; // r0
  int *v23; // r6
  double v24; // d8
  double v25; // r2
  double v26; // r0
  int v27; // r11
  __int64 v28; // r0
  int v29; // r6
  double v30; // d7
  thr_info *thread; // r0
  cgpu_info *v32; // r10
  double v33; // d8
  double v34; // r2
  double v35; // r0
  double v36; // r0
  double v37; // r2
  double v38; // r0
  double v39; // r2
  double v40; // r0
  double v41; // r2
  double v42; // r0
  double v43; // r2
  double v44; // r0
  double v45; // r2
  int *v46; // r0
  int *v47; // r0
  int v48; // r3
  int v49; // r4
  int v50; // r3
  int v51; // r4
  double sigdigits; // [sp+0h] [bp-1064h]
  double sigdigitsb; // [sp+0h] [bp-1064h]
  double sigdigitsc; // [sp+0h] [bp-1064h]
  double sigdigitsd; // [sp+0h] [bp-1064h]
  double sigdigitse; // [sp+0h] [bp-1064h]
  double sigdigitsf; // [sp+0h] [bp-1064h]
  double sigdigitsg; // [sp+0h] [bp-1064h]
  double sigdigitsa; // [sp+0h] [bp-1064h]
  double v60; // [sp+8h] [bp-105Ch]
  double v61; // [sp+8h] [bp-105Ch]
  double v62; // [sp+8h] [bp-105Ch]
  double v63; // [sp+8h] [bp-105Ch]
  double v64; // [sp+8h] [bp-105Ch]
  double v65; // [sp+8h] [bp-105Ch]
  double v66; // [sp+8h] [bp-105Ch]
  double v67; // [sp+8h] [bp-105Ch]
  char displayed_hashes[16]; // [sp+20h] [bp-1044h] BYREF
  char displayed_rolling[16]; // [sp+30h] [bp-1034h] BYREF
  char displayed_r1[16]; // [sp+40h] [bp-1024h] BYREF
  char displayed_r5[16]; // [sp+50h] [bp-1014h] BYREF
  char displayed_r15[4100]; // [sp+60h] [bp-1004h] BYREF

  cgtime(&total_tv_end);
  tdiff(&total_tv_end, &tv_hashmeter);
  tv_sec = total_tv_end.tv_sec;
  v6 = v3;
  if ( opt_log_interval > total_tv_end.tv_sec - hashdisplay_t )
  {
    if ( thr_id < 0 )
      return;
    v27 = 0;
    copy_time(&tv_hashmeter, &total_tv_end);
  }
  else
  {
    hashdisplay_t = total_tv_end.tv_sec;
    copy_time(&tv_hashmeter, &total_tv_end);
    if ( thr_id < 0 )
    {
      v7 = pthread_mutex_lock(&hash_lock);
      if ( !v7 )
      {
        if ( mining_threads > 0 )
        {
          do
          {
            while ( 1 )
            {
              cgpu = get_thread(v7)->cgpu;
              tdiff(&total_tv_end, &cgpu->last_message_tv);
              copy_time(&cgpu->last_message_tv, &total_tv_end);
              if ( v3 > 0.0 )
                break;
              if ( mining_threads <= ++v7 )
                goto LABEL_9;
            }
            HIDWORD(v10) = opt_log_interval;
            LODWORD(v9) = &cgpu->rolling;
            decay_time_0(v9, v10, sigdigits, v60);
            LODWORD(v11) = &cgpu->rolling1;
            decay_time_0(v11, v12, sigdigitsb, v61);
            LODWORD(v13) = &cgpu->rolling5;
            decay_time_0(v13, v14, sigdigitsc, v62);
            LODWORD(v15) = &cgpu->rolling15;
            ++v7;
            v3 = 0.0;
            decay_time_0(v15, v16, sigdigitsd, v63);
          }
          while ( mining_threads > v7 );
        }
LABEL_9:
        if ( pthread_mutex_unlock(&hash_lock) )
        {
          v50 = *_errno_location();
          v51 = 6776;
          goto LABEL_60;
        }
        selective_yield();
        if ( !pthread_mutex_lock(&hash_lock) )
        {
          v17 = (double)hashes_done;
          v18 = g_local_mhashes_index;
          total_mhashes_done = total_mhashes_done + (double)hashes_done;
          goto LABEL_12;
        }
LABEL_53:
        v46 = _errno_location();
        snprintf(
          displayed_r15,
          0x1000u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v46,
          "cgminer.c",
          "hashmeter",
          6779);
        goto LABEL_54;
      }
      v48 = *_errno_location();
      v49 = 6763;
LABEL_57:
      snprintf(
        displayed_r15,
        0x1000u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        v48,
        "cgminer.c",
        "hashmeter",
        v49);
      goto LABEL_54;
    }
    v27 = 1;
  }
  thread = get_thread(thr_id);
  v32 = thread->cgpu;
  copy_time(&thread->last, &total_tv_end);
  v32->device_last_well = tv_sec;
  tdiff(&total_tv_end, &v32->last_message_tv);
  v33 = v3;
  copy_time(&v32->last_message_tv, &total_tv_end);
  if ( pthread_mutex_lock(&hash_lock) )
  {
    v48 = *_errno_location();
    v49 = 6737;
    goto LABEL_57;
  }
  v35 = (double)hashes_done;
  v17 = (double)hashes_done;
  v32->total_mhashes = v32->total_mhashes + (double)hashes_done;
  if ( v3 > 0.0 )
  {
    HIDWORD(v34) = opt_log_interval;
    LODWORD(v35) = &v32->rolling;
    decay_time_0(v35, v34, sigdigits, v60);
    LODWORD(v36) = &v32->rolling1;
    v3 = (double)hashes_done;
    decay_time_0(v36, v37, sigdigitse, v64);
    if ( v33 > 0.0 )
    {
      LODWORD(v38) = &v32->rolling5;
      decay_time_0(v38, v39, sigdigits, v60);
      LODWORD(v40) = &v32->rolling15;
      v3 = (double)hashes_done;
      decay_time_0(v40, v41, sigdigitsf, v65);
    }
  }
  if ( pthread_mutex_unlock(&hash_lock) )
  {
    v50 = *_errno_location();
    v51 = 6743;
    goto LABEL_60;
  }
  selective_yield();
  get_statline(displayed_r15, 0x100u, v32);
  printf("%s          \r", displayed_r15);
  fflush((FILE *)stdout);
  if ( pthread_mutex_lock(&hash_lock) )
    goto LABEL_53;
  v18 = g_local_mhashes_index;
  total_mhashes_done = total_mhashes_done + v17;
  if ( v27 )
  {
LABEL_12:
    v19 = v18 + 1;
    v20 = v19 <= 11;
    v21 = 0;
    if ( v19 <= 11 )
      g_local_mhashes_index = v19;
    v22 = 0;
    v23 = (int *)g_local_mhashes_dones;
    if ( !v20 )
      g_local_mhashes_index = 0;
    do
    {
      v24 = *(double *)v23;
      v23 += 2;
      if ( v24 >= 0.0 )
      {
        ++v21;
        v22 = (unsigned __int64)((double)v22 + v24);
      }
    }
    while ( &g_local_mhashes_index != v23 );
    v25 = v17;
    if ( v21 )
      v25 = (double)(v22 / v21);
    HIDWORD(v26) = opt_log_interval;
    if ( (double)opt_log_interval > 0.0 )
    {
      LODWORD(v26) = &total_rolling;
      decay_time_0(v26, v25, sigdigits, v60);
      if ( v6 <= 0.0 )
        goto LABEL_23;
    }
    else if ( v6 <= 0.0 )
    {
LABEL_23:
      v27 = 1;
      v3 = total_rolling;
      v28 = llround();
      v29 = g_local_mhashes_index;
      v30 = 0.0;
      global_hashrate = 1000000 * v28;
      g_local_mhashes_dones[g_local_mhashes_index] = 0.0;
      goto LABEL_32;
    }
    LODWORD(v26) = &rolling1;
    decay_time_0(v26, v25, sigdigits, v60);
    LODWORD(v42) = &rolling5;
    decay_time_0(v42, v43, sigdigitsg, v66);
    if ( v6 > 0.0 )
    {
      LODWORD(v44) = &rolling15;
      decay_time_0(v44, v45, sigdigitsa, v67);
    }
    goto LABEL_23;
  }
  v29 = g_local_mhashes_index;
  v30 = g_local_mhashes_dones[g_local_mhashes_index];
LABEL_32:
  g_local_mhashes_dones[v29] = v30 + v17;
  tdiff(&total_tv_end, &total_tv_start);
  total_secs = v3;
  if ( v3 - last_total_secs > 86400.0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(displayed_r15, 0x1000u, "cgminer time error total_secs = %f last_total_secs = %f", v3, last_total_secs);
      applog(3, displayed_r15, 0);
    }
    if ( !pthread_mutex_unlock(&hash_lock) )
    {
      selective_yield();
      zero_stats();
      if ( !pthread_mutex_lock(&hash_lock) )
      {
        if ( !v27 )
          goto LABEL_39;
LABEL_43:
        suffix_string((unsigned __int64)(total_mhashes_done / total_secs * 1000000.0), displayed_hashes, 0x10u, 4);
        g_displayed_rolling = total_rolling / 1000.0;
        suffix_string((unsigned __int64)(total_rolling * 1000000.0), displayed_rolling, 0x10u, 4);
        suffix_string((unsigned __int64)(rolling1 * 1000000.0), displayed_r1, 0x10u, 4);
        suffix_string((unsigned __int64)(rolling5 * 1000000.0), displayed_r5, 0x10u, 4);
        suffix_string((unsigned __int64)(rolling15 * 1000000.0), displayed_r15, 0x10u, 4);
        snprintf(
          statusline,
          0x100u,
          "(%ds):%s (1m):%s (5m):%s (15m):%s (avg):%sh/s",
          opt_log_interval,
          displayed_rolling,
          displayed_r1,
          displayed_r5,
          displayed_r15,
          displayed_hashes);
        if ( !pthread_mutex_unlock(&hash_lock) )
        {
          selective_yield();
          printf("%s          \r", statusline);
          fflush((FILE *)stdout);
          return;
        }
        goto LABEL_55;
      }
      v48 = *_errno_location();
      v49 = 6821;
      goto LABEL_57;
    }
    v50 = *_errno_location();
    v51 = 6819;
LABEL_60:
    snprintf(
      displayed_r15,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      v50,
      "cgminer.c",
      "hashmeter",
      v51);
LABEL_54:
    applog(3, displayed_r15, 1);
    _quit(1, 1);
  }
  last_total_secs = v3;
  if ( v27 )
    goto LABEL_43;
LABEL_39:
  if ( pthread_mutex_unlock(&hash_lock) )
  {
LABEL_55:
    v47 = _errno_location();
    snprintf(
      displayed_r15,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v47,
      "cgminer.c",
      "hashmeter",
      6850);
    goto LABEL_54;
  }
  selective_yield();
}
// 2124C: variable 'v3' is possibly undefined
// 212F4: variable 'v9' is possibly undefined
// 212F4: variable 'v10' is possibly undefined
// 212F4: variable 'sigdigits' is possibly undefined
// 212F4: variable 'v60' is possibly undefined
// 21308: variable 'v11' is possibly undefined
// 21308: variable 'v12' is possibly undefined
// 21308: variable 'sigdigitsb' is possibly undefined
// 21308: variable 'v61' is possibly undefined
// 21326: variable 'v13' is possibly undefined
// 21326: variable 'v14' is possibly undefined
// 21326: variable 'sigdigitsc' is possibly undefined
// 21326: variable 'v62' is possibly undefined
// 21346: variable 'v15' is possibly undefined
// 21346: variable 'v16' is possibly undefined
// 21346: variable 'sigdigitsd' is possibly undefined
// 21346: variable 'v63' is possibly undefined
// 217F4: variable 'v34' is possibly undefined
// 21808: variable 'v36' is possibly undefined
// 21808: variable 'v37' is possibly undefined
// 21808: variable 'sigdigitse' is possibly undefined
// 21808: variable 'v64' is possibly undefined
// 21828: variable 'v38' is possibly undefined
// 21828: variable 'v39' is possibly undefined
// 21848: variable 'v40' is possibly undefined
// 21848: variable 'v41' is possibly undefined
// 21848: variable 'sigdigitsf' is possibly undefined
// 21848: variable 'v65' is possibly undefined
// 218CE: variable 'v26' is possibly undefined
// 218CE: variable 'v25' is possibly undefined
// 218E6: variable 'v42' is possibly undefined
// 218E6: variable 'v43' is possibly undefined
// 218E6: variable 'sigdigitsg' is possibly undefined
// 218E6: variable 'v66' is possibly undefined
// 2190A: variable 'v44' is possibly undefined
// 2190A: variable 'v45' is possibly undefined
// 2190A: variable 'sigdigitsa' is possibly undefined
// 2190A: variable 'v67' is possibly undefined
// 12370: using guessed type __int64 llround(void);
// 6D854: using guessed type int stdout;

//----- (00021A4C) --------------------------------------------------------
void __fastcall hash_queued_work(thr_info *mythr)
{
  cgpu_info *cgpu; // r4
  device_drv *drv; // r5
  uint64_t v4; // r6
  bool shutdown; // r3
  __int64 v6; // r2
  bool v7; // zf
  int v8; // r3
  int v9; // r2
  int v10; // r1
  bool v11; // cc
  uint64_t v12; // r2
  int *v13; // r0
  int *v14; // r0
  int thr_id; // [sp+10h] [bp-101Ch]
  work *work; // [sp+14h] [bp-1018h]
  timeval tv_start; // [sp+18h] [bp-1014h] BYREF
  timeval tv_end; // [sp+20h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+28h] [bp-1004h] BYREF

  cgpu = mythr->cgpu;
  tv_start.tv_sec = 0;
  tv_start.tv_usec = 0;
  drv = cgpu->drv;
  v4 = 0;
  thr_id = mythr->id;
  while ( 2 )
  {
    shutdown = cgpu->shutdown;
    if ( shutdown )
      goto LABEL_23;
LABEL_3:
    mythr->work_update = shutdown;
    do
    {
      while ( cgpu->unqueued_work )
      {
LABEL_4:
        if ( ((int (__fastcall *)(cgpu_info *))drv->queue_full)(cgpu) )
          goto LABEL_10;
      }
      work = get_work(mythr, thr_id);
      if ( pthread_rwlock_wrlock(&cgpu->qlock) )
      {
        v13 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v13,
          "cgminer.c",
          "fill_queue",
          8763);
        goto LABEL_28;
      }
      if ( cgpu->unqueued_work )
      {
        if ( !pthread_rwlock_unlock(&cgpu->qlock) )
        {
          selective_yield();
          discard_work(work);
          goto LABEL_4;
        }
LABEL_31:
        v14 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v14,
          "cgminer.c",
          "fill_queue",
          8770);
LABEL_28:
        applog(3, tmp42, 1);
        _quit(1, 1);
      }
      cgpu->unqueued_work = work;
      if ( pthread_rwlock_unlock(&cgpu->qlock) )
        goto LABEL_31;
      selective_yield();
    }
    while ( !((int (__fastcall *)(cgpu_info *))drv->queue_full)(cgpu) );
LABEL_10:
    v6 = drv->scanwork(mythr);
    mythr->work_restart = 0;
    v7 = HIDWORD(v6) == -1;
    if ( HIDWORD(v6) == -1 )
      v7 = (_DWORD)v6 == -1;
    if ( !v7 )
    {
      v4 += v6;
      cgtime(&tv_end);
      v8 = tv_end.tv_usec - tv_start.tv_usec;
      v9 = tv_end.tv_sec - tv_start.tv_sec;
      if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
      {
        --v9;
        v8 += 1000000;
      }
      v10 = v4 | HIDWORD(v4);
      if ( v4 )
      {
        v10 = 200000;
        v11 = v8 <= 200000;
        if ( v8 <= 200000 )
          v11 = v9 <= 0;
        if ( !v11 )
          goto LABEL_19;
      }
      if ( opt_log_interval <= v9 )
      {
LABEL_19:
        v12 = v4;
        v4 = 0;
        hashmeter(thr_id, v10, v12);
        copy_time(&tv_start, &tv_end);
        if ( mythr->pause )
          goto LABEL_26;
      }
      else if ( mythr->pause )
      {
LABEL_26:
        mt_disable(mythr, thr_id, (device_drv *)&drv->thread_enable);
        goto LABEL_21;
      }
      if ( cgpu->deven )
        goto LABEL_26;
LABEL_21:
      if ( !mythr->work_update )
        continue;
      drv->update_work(cgpu);
      shutdown = cgpu->shutdown;
      if ( shutdown )
        goto LABEL_23;
      goto LABEL_3;
    }
    break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "%s %d failure, disabling!", drv->name, cgpu->device_id);
    applog(3, tmp42, 0);
  }
  cgpu->deven = dev_enable::DEV_DISABLED;
  dev_error(cgpu, dev_reason::REASON_THREAD_ZERO_HASH);
LABEL_23:
  cgpu->deven = dev_enable::DEV_DISABLED;
}

//----- (00021C64) --------------------------------------------------------
void __fastcall hash_driver_work(thr_info *mythr)
{
  cgpu_info *cgpu; // r7
  device_drv *drv; // r8
  uint64_t v4; // r4
  bool i; // r9
  __int64 v6; // r2
  bool v7; // zf
  __int64 v8; // r0
  int v9; // r3
  int v10; // r2
  int v11; // r1
  bool v12; // cc
  uint64_t v13; // r2
  int *v14; // r0
  int *v15; // r0
  int thr_id; // [sp+10h] [bp-101Ch]
  timeval tv_start; // [sp+18h] [bp-1014h] BYREF
  timeval tv_end; // [sp+20h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+28h] [bp-1004h] BYREF

  cgpu = mythr->cgpu;
  tv_start.tv_usec = 0;
  drv = cgpu->drv;
  tv_start.tv_sec = 0;
  v4 = 0;
  thr_id = mythr->id;
LABEL_2:
  for ( i = cgpu->shutdown; !i; i = cgpu->shutdown )
  {
    mythr->work_update = i;
    v8 = drv->scanwork(mythr);
    v6 = v8;
    v7 = ++HIDWORD(v8) == 0;
    mythr->work_restart = i;
    if ( !HIDWORD(v8) )
      v7 = (_DWORD)v8 == -1;
    if ( v7 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(tmp42, 0x1000u, "%s %d failure, disabling!", drv->name, cgpu->device_id);
        applog(3, tmp42, 0);
      }
      cgpu->deven = dev_enable::DEV_DISABLED;
      dev_error(cgpu, dev_reason::REASON_THREAD_ZERO_HASH);
      break;
    }
    v4 += v6;
    cgtime(&tv_end);
    v9 = tv_end.tv_usec - tv_start.tv_usec;
    v10 = tv_end.tv_sec - tv_start.tv_sec;
    if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
    {
      --v10;
      v9 += 1000000;
    }
    v11 = v4 | HIDWORD(v4);
    if ( v4 )
    {
      v12 = v10 <= 0;
      if ( v10 <= 0 )
        v12 = v9 <= (int)&loc_30D3E + 2;
      if ( !v12 )
        goto LABEL_12;
    }
    if ( opt_log_interval <= v10 )
    {
LABEL_12:
      v13 = v4;
      v4 = 0;
      hashmeter(thr_id, v11, v13);
      copy_time(&tv_start, &tv_end);
      if ( !mythr->pause )
        goto LABEL_13;
    }
    else if ( !mythr->pause )
    {
LABEL_13:
      if ( cgpu->deven == dev_enable::DEV_ENABLED )
        goto LABEL_14;
    }
    mt_disable(mythr, thr_id, (device_drv *)&drv->thread_enable);
LABEL_14:
    if ( !mythr->work_update )
      goto LABEL_2;
    if ( pthread_mutex_lock(&update_job_lock) )
    {
      v14 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v14,
        "cgminer.c",
        "hash_driver_work",
        9120);
      goto LABEL_29;
    }
    drv->update_work(cgpu);
    if ( pthread_mutex_unlock(&update_job_lock) )
    {
      v15 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v15,
        "cgminer.c",
        "hash_driver_work",
        9122);
LABEL_29:
      applog(3, tmp42, 1);
      _quit(1, 1);
    }
    selective_yield();
  }
  cgpu->deven = dev_enable::DEV_DISABLED;
}

//----- (00021E3C) --------------------------------------------------------
void __fastcall hash_sole_work(thr_info *mythr)
{
  cgpu_info *cgpu; // r10
  int v3; // r3
  int shutdown; // r11
  int v5; // r9
  int v6; // r3
  work *work; // r5
  double *p_work_difficulty; // r6
  double work_difficulty; // d9
  double *p_device_diff; // r4
  double max_diff; // d8
  double v12; // r2
  double working_diff; // d11
  pool *pool; // r6
  __int64 v15; // r6
  bool v16; // zf
  int v17; // r1
  int v18; // r3
  int v19; // r2
  int v20; // r4
  int v21; // r6
  int v22; // r7
  bool v23; // cc
  _BOOL4 v24; // r1
  int device_thread; // r3
  int v26; // r1
  double v27; // d8
  int64_t hashes_done; // [sp+8h] [bp-106Ch]
  device_drv *drv; // [sp+10h] [bp-1064h]
  timeval *dest; // [sp+14h] [bp-1060h]
  timeval *p_getwork_wait_max; // [sp+18h] [bp-105Ch]
  uint32_t max_nonce; // [sp+20h] [bp-1054h]
  int cycle; // [sp+2Ch] [bp-1048h]
  int thr_id; // [sp+30h] [bp-1044h]
  _BOOL4 primary; // [sp+38h] [bp-103Ch]
  int v36; // [sp+3Ch] [bp-1038h]
  int v37; // [sp+40h] [bp-1034h]
  unsigned int mult; // [sp+4Ch] [bp-1028h]
  timeval getwork_start; // [sp+50h] [bp-1024h] BYREF
  timeval tv_start; // [sp+58h] [bp-101Ch] BYREF
  timeval tv_workstart; // [sp+60h] [bp-1014h] BYREF
  timeval tv_lastupdate; // [sp+68h] [bp-100Ch] BYREF
  timespec rgtp; // [sp+70h] [bp-1004h] BYREF

  cgpu = mythr->cgpu;
  thr_id = mythr->id;
  drv = cgpu->drv;
  v3 = opt_log_interval / 5;
  if ( (int)((unsigned __int64)(1717986919LL * opt_log_interval) >> 32) >> 1 == opt_log_interval >> 31 )
    v3 = 1;
  cycle = v3;
  if ( mythr->device_thread )
    primary = mythr->primary_thread;
  else
    primary = 1;
  max_nonce = drv->can_limit_work(mythr);
  cgtime(&getwork_start);
  cgtime(&tv_lastupdate);
  if ( cgpu->shutdown )
    goto LABEL_60;
  shutdown = cgpu->shutdown;
  v5 = shutdown;
  v36 = 1000000 * cycle;
  v6 = (v36 + 1023) & (v36 >> 31);
  if ( 1000000 * cycle >= 0 )
    v6 = 1000000 * cycle;
  hashes_done = 0;
  v37 = v6 >> 10;
  do
  {
    work = get_work(mythr, thr_id);
    mythr->work_restart = 0;
    cgpu->new_work = 1;
    cgtime(&tv_workstart);
    work->nonce = 0;
    cgpu->max_hashes = 0;
    if ( !((int (__fastcall *)(thr_info *, work *))drv->prepare_work)(mythr, work) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf((char *)&rgtp, 0x1000u, "work prepare failed, exiting mining thread %d", thr_id);
        applog(3, (const char *)&rgtp, 0);
      }
      break;
    }
    LODWORD(v12) = drv;
    p_work_difficulty = &work->work_difficulty;
    work_difficulty = work->work_difficulty;
    p_device_diff = &work->device_diff;
    max_diff = drv->max_diff;
    HIDWORD(v12) = opt_scrypt;
    if ( max_diff > work_difficulty )
      max_diff = work->work_difficulty;
    *p_device_diff = max_diff;
    if ( drv->min_diff > max_diff )
      max_diff = drv->min_diff;
    *p_device_diff = max_diff;
    if ( HIDWORD(v12) )
    {
      working_diff = drv->working_diff;
      HIDWORD(v12) = &global_quota_gcd;
      if ( (double)total_diff1 / total_secs * 60.0 > 30.0
        && drv->max_diff > working_diff
        && work_difficulty > working_diff )
      {
        v27 = working_diff + 1.0;
        HIDWORD(v12) = opt_debug;
        drv->working_diff = working_diff + 1.0;
        if ( HIDWORD(v12) )
        {
          if ( use_syslog || opt_log_output || (HIDWORD(v12) = opt_log_level, opt_log_level > 6) )
          {
            snprintf((char *)&rgtp, 0x1000u, "Driver %s working diff changed to %.0f", drv->dname, working_diff + 1.0);
            applog(7, (const char *)&rgtp, 0);
            v27 = drv->working_diff;
          }
        }
        if ( *p_work_difficulty < v27 )
          v27 = *p_work_difficulty;
        *p_device_diff = v27;
      }
      else if ( work_difficulty < working_diff )
      {
        HIDWORD(v12) = drv;
        drv->working_diff = work_difficulty;
      }
      set_target(work->device_target, v12);
    }
    p_getwork_wait_max = &cgpu->cgminer_stats.getwork_wait_max;
    dest = &cgpu->cgminer_stats.getwork_wait_min;
    while ( 1 )
    {
      cgtime(&tv_start);
      subtime(&tv_start, &getwork_start);
      addtime(&getwork_start, &cgpu->cgminer_stats.getwork_wait);
      if ( time_more(&getwork_start, p_getwork_wait_max) )
        copy_time(p_getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, dest) )
        copy_time(dest, &getwork_start);
      ++cgpu->cgminer_stats.getwork_calls;
      pool = work->pool;
      addtime(&getwork_start, &pool->cgminer_stats.getwork_wait);
      if ( time_more(&getwork_start, &pool->cgminer_stats.getwork_wait_max) )
        copy_time(&pool->cgminer_stats.getwork_wait_max, &getwork_start);
      if ( time_less(&getwork_start, &pool->cgminer_stats.getwork_wait_min) )
        copy_time(&pool->cgminer_stats.getwork_wait_min, &getwork_start);
      ++pool->cgminer_stats.getwork_calls;
      cgtime(&work->tv_work_start);
      pthread_setcancelstate(1, 0);
      thread_reportin(mythr);
      v15 = ((__int64 (__fastcall *)(thr_info *, work *, uint32_t, _DWORD))drv->scanhash)(
              mythr,
              work,
              work->nonce + max_nonce,
              0);
      thread_reportout(mythr);
      pthread_setcancelstate(0, 0);
      pthread_testcancel();
      cgtime(&getwork_start);
      v16 = HIDWORD(v15) == -1;
      if ( HIDWORD(v15) == -1 )
        v16 = (_DWORD)v15 == -1;
      if ( v16 )
        break;
      v17 = (unsigned __int64)(hashes_done + v15) >> 32;
      hashes_done += v15;
      if ( cgpu->max_hashes < v15 )
        cgpu->max_hashes = v15;
      v18 = getwork_start.tv_usec - tv_start.tv_usec + (getwork_start.tv_usec - tv_start.tv_usec < 0 ? 0xF4000 : 0);
      v19 = getwork_start.tv_sec - tv_start.tv_sec;
      if ( getwork_start.tv_usec - tv_start.tv_usec < 0 )
      {
        v18 += 576;
        --v19;
      }
      shutdown += v18;
      v5 += v19;
      if ( shutdown > 1000000 )
      {
        ++v5;
        shutdown -= 1000000;
      }
      v20 = getwork_start.tv_sec - tv_workstart.tv_sec;
      if ( getwork_start.tv_usec - tv_workstart.tv_usec < 0 )
        --v20;
      if ( cycle > v5 )
      {
        if ( max_nonce == -1 )
          goto LABEL_54;
        v26 = shutdown + 2047;
        if ( shutdown + 1024 >= 0 )
          v26 = shutdown + 1024;
        mult = (1000000 / (v26 >> 10) + 16) * cycle;
        if ( 0xFFFFFC00 / mult >= max_nonce )
          max_nonce = (max_nonce * mult) >> 10;
        else
          max_nonce = -1;
      }
      else if ( cycle < v5 )
      {
        max_nonce = max_nonce * cycle / v5;
      }
      else if ( shutdown > 100000 )
      {
        max_nonce = (max_nonce << 10) / ((v36 + shutdown) / v37);
      }
      v21 = getwork_start.tv_usec - tv_lastupdate.tv_usec;
      v22 = getwork_start.tv_sec - tv_lastupdate.tv_sec;
      if ( getwork_start.tv_usec - tv_lastupdate.tv_usec < 0 )
      {
        --v22;
        v21 += 1000000;
      }
      if ( hashes_done )
      {
        v23 = v22 <= 0;
        if ( v22 <= 0 )
          v23 = v21 <= 200000;
        if ( !v23 )
          goto LABEL_51;
      }
      if ( opt_log_interval <= v22 )
      {
LABEL_51:
        hashmeter(thr_id, v17, hashes_done);
        hashes_done = 0;
        copy_time(&tv_lastupdate, &getwork_start);
        if ( mythr->work_restart )
          goto LABEL_63;
      }
      else if ( mythr->work_restart )
      {
LABEL_63:
        if ( !primary )
        {
          device_thread = mythr->device_thread;
          rgtp.tv_sec = 0;
          rgtp.tv_nsec = 250000000 * device_thread;
          nanosleep(&rgtp, 0);
        }
        goto LABEL_59;
      }
      if ( mythr->pause || (shutdown = cgpu->deven, (v5 = shutdown) != 0) )
      {
        shutdown = 0;
        v5 = 0;
        mt_disable(mythr, thr_id, (device_drv *)&drv->thread_enable);
      }
LABEL_54:
      v24 = opt_scantime < v20 || cgpu->max_hashes > 0xFFFFFFFDuLL;
      if ( v24 || stale_work(work, 0) )
        goto LABEL_59;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf((char *)&rgtp, 0x1000u, "%s %d failure, disabling!", drv->name, cgpu->device_id);
      applog(3, (const char *)&rgtp, 0);
    }
    cgpu->deven = dev_enable::DEV_DISABLED;
    dev_error(cgpu, dev_reason::REASON_THREAD_ZERO_HASH);
    cgpu->shutdown = 1;
LABEL_59:
    clean_work(work);
    free(work);
  }
  while ( !cgpu->shutdown );
LABEL_60:
  cgpu->deven = dev_enable::DEV_DISABLED;
}
// 21FE2: variable 'v12' is possibly undefined
// 22176: variable 'v17' is possibly undefined

//----- (00022430) --------------------------------------------------------
void *__fastcall __noreturn watchdog_thread(void *userdata)
{
  int v1; // r1
  int v2; // r5
  _BOOL4 v3; // r3
  cgpu_info *devices; // r0
  cgpu_info *v5; // r4
  thr_info *v6; // r6
  alive status; // r1
  int v8; // r3
  _BOOL4 v9; // r3
  thr_info **v10; // r3
  thr_info **v11; // r1
  int v12; // t1
  int v13; // r4
  thr_info *thread; // r0
  cgsem_t *v15; // r5
  _BOOL4 v16; // r3
  int *v17; // r0
  int *v18; // r0
  timeval now; // [sp+30h] [bp-1014h] BYREF
  char dev_str[8]; // [sp+38h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+40h] [bp-1004h] BYREF

  pthread_setcanceltype(1, 0);
  RenameThread("Watchdog");
  set_lowprio();
  cgtime(&rotate_tv);
LABEL_2:
  while ( 1 )
  {
    sleep(2u);
    discard_stale();
    hashmeter(-1, v1, 0);
    cgtime(&now);
    if ( sched_paused )
      goto LABEL_92;
    if ( schedstart.enable || schedstop.enable )
    {
      if ( !should_run() )
      {
        if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
        {
          if ( !schedstart.enable )
            goto LABEL_86;
          goto LABEL_50;
        }
        snprintf(
          tmp42,
          0x1000u,
          "Pausing execution as per stop time %02d:%02d scheduled",
          schedstop.tm.tm_hour,
          schedstop.tm.tm_min);
        applog(4, tmp42, 0);
        if ( !schedstart.enable )
        {
LABEL_86:
          strcpy(tmp42, "Terminating execution as planned");
          applog(3, tmp42, 1);
          _quit(0, 1);
        }
        if ( use_syslog || opt_log_output )
        {
LABEL_60:
          snprintf(
            tmp42,
            0x1000u,
            "Will restart execution as scheduled at %02d:%02d",
            schedstart.tm.tm_hour,
            schedstart.tm.tm_min);
          applog(4, tmp42, 0);
        }
        else
        {
LABEL_50:
          if ( opt_log_level > 3 )
            goto LABEL_60;
        }
        sched_paused = 1;
        if ( pthread_rwlock_rdlock(&mining_thr_lock) )
        {
          v17 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *v17,
            "cgminer.c",
            "watchdog_thread",
            9721);
          goto LABEL_88;
        }
        if ( mining_threads > 0 )
        {
          v10 = mining_thr;
          v11 = &mining_thr[mining_threads];
          do
          {
            v12 = (int)*v10++;
            *(_BYTE *)(v12 + 60) = 1;
          }
          while ( v10 != v11 );
        }
        if ( pthread_rwlock_unlock(&mining_thr_lock) )
        {
          v18 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v18,
            "cgminer.c",
            "watchdog_thread",
            9724);
LABEL_88:
          applog(3, tmp42, 1);
          _quit(1, 1);
        }
        selective_yield();
        goto LABEL_6;
      }
      if ( sched_paused )
      {
LABEL_92:
        if ( !schedstart.enable && !schedstop.enable || should_run() )
          break;
      }
    }
LABEL_6:
    if ( total_devices > 0 )
    {
      v2 = 0;
      while ( 1 )
      {
        devices = get_devices(v2);
        v5 = devices;
        v6 = *devices->thr;
        if ( v6 )
        {
          ((void (*)(void))devices->drv->get_stats)();
          snprintf(dev_str, 8u, "%s %d", v5->drv->name, v5->device_id);
          if ( !v6->getwork && v5->deven != dev_enable::DEV_DISABLED )
          {
            status = v5->status;
            v8 = now.tv_sec - v6->last.tv_sec;
            if ( status == alive::LIFE_WELL )
            {
              if ( v8 <= 120 )
                goto LABEL_20;
              v3 = use_syslog;
              v5->rolling = 0.0;
              v5->status = alive::LIFE_SICK;
              if ( v3 || opt_log_output || opt_log_level > 2 )
              {
                snprintf(tmp42, 0x1000u, "%s: Idle for more than 60 seconds, declaring SICK!", dev_str);
                applog(3, tmp42, 0);
              }
              cgtime(&v6->sick);
              dev_error(v5, dev_reason::REASON_DEV_SICK_IDLE_60);
              if ( !opt_restart )
                goto LABEL_20;
              if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                snprintf(tmp42, 0x1000u, "%s: Attempting to restart", dev_str);
                applog(3, tmp42, 0);
              }
LABEL_18:
              if ( v5->deven != dev_enable::DEV_DISABLED )
                v5->drv->reinit_device(v5);
              goto LABEL_20;
            }
            if ( v8 > 119 )
            {
              if ( status == alive::LIFE_SICK )
              {
                if ( v8 <= 600 )
                {
                  if ( now.tv_sec - v6->sick.tv_sec > 60 )
                  {
                    cgtime(&v6->sick);
                    if ( opt_restart )
                      goto LABEL_18;
                  }
                }
                else
                {
                  v9 = use_syslog;
                  v5->status = alive::LIFE_DEAD;
                  if ( v9 || opt_log_output || opt_log_level > 2 )
                  {
                    snprintf(tmp42, 0x1000u, "%s: Not responded for more than 10 minutes, declaring DEAD!", dev_str);
                    applog(3, tmp42, 0);
                  }
                  cgtime(&v6->sick);
                  dev_error(v5, dev_reason::REASON_DEV_DEAD_IDLE_600);
                }
              }
              else if ( now.tv_sec - v6->sick.tv_sec > 60 && status == alive::LIFE_DEAD )
              {
                cgtime(&v6->sick);
                if ( opt_restart )
                  goto LABEL_18;
              }
            }
            else
            {
              if ( status != alive::LIFE_INIT && (use_syslog || opt_log_output || opt_log_level > 2) )
              {
                snprintf(tmp42, 0x1000u, "%s: Recovered, declaring WELL!", dev_str);
                applog(3, tmp42, 0);
              }
              v5->status = alive::LIFE_WELL;
              v5->device_last_well = time(0);
            }
          }
        }
LABEL_20:
        if ( total_devices <= ++v2 )
          goto LABEL_2;
      }
    }
  }
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "Restarting execution as per start time %02d:%02d scheduled",
      schedstart.tm.tm_hour,
      schedstart.tm.tm_min);
    applog(4, tmp42, 0);
    if ( !schedstop.enable )
      goto LABEL_68;
    if ( use_syslog || opt_log_output )
    {
LABEL_82:
      snprintf(
        tmp42,
        0x1000u,
        "Will pause execution as scheduled at %02d:%02d",
        schedstop.tm.tm_hour,
        schedstop.tm.tm_min);
      applog(4, tmp42, 0);
LABEL_68:
      v13 = 0;
      for ( sched_paused = 0; mining_threads > v13; ++v13 )
      {
        thread = get_thread(v13);
        v15 = (cgsem_t *)thread;
        if ( thread->cgpu->deven != dev_enable::DEV_DISABLED )
        {
          v16 = opt_debug;
          thread->pause = 0;
          if ( v16 && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "Pushing sem post to thread %d", thread->id);
            applog(7, tmp42, 0);
          }
          cgsem_post(v15 + 1, "cgminer.c", "watchdog_thread", 9746);
        }
      }
      goto LABEL_6;
    }
  }
  else if ( !schedstop.enable )
  {
    goto LABEL_68;
  }
  if ( opt_log_level <= 3 )
    goto LABEL_68;
  goto LABEL_82;
}
// 224B0: variable 'v1' is possibly undefined

//----- (00022A04) --------------------------------------------------------
int __fastcall test_work_current(int a1)
{
  int v3; // r1
  int v4; // r4
  int v5; // r3
  int v6; // r2
  int v7; // r0
  int v8; // r4
  _DWORD *v9; // r3
  int v10; // r4
  size_t v11; // r0
  int v12; // r3
  size_t v13; // r6
  unsigned __int8 *v14; // r12
  int v15; // r0
  unsigned int v16; // lr
  unsigned int v17; // r5
  int v18; // r10
  int v19; // r7
  int v20; // r2
  unsigned __int8 *v21; // r9
  int v22; // r3
  unsigned int v23; // r5
  unsigned int v24; // r3
  int v25; // r2
  unsigned int v26; // r1
  unsigned int v27; // r3
  int v28; // r2
  unsigned int v29; // r1
  unsigned int v30; // r3
  size_t v31; // r4
  int *v32; // r0
  char *v33; // r0
  block *v34; // r11
  unsigned int v35; // r3
  block *v36; // r5
  UT_hash_handle *v37; // lr
  int v38; // r7
  UT_hash_handle *v39; // r3
  UT_hash_handle *v40; // r2
  unsigned int v41; // r12
  UT_hash_handle *next; // r6
  ptrdiff_t hho; // r4
  int v44; // r1
  int v45; // r0
  UT_hash_handle *v46; // r4
  bool v47; // zf
  void *v48; // r8
  int v49; // r8
  char *v50; // r6
  bool v51; // zf
  UT_hash_handle *v52; // r9
  int v53; // r2
  UT_hash_table *tbl; // r0
  int v55; // r2
  unsigned int v56; // r3
  unsigned int v57; // r5
  int v58; // r4
  unsigned int v59; // r3
  unsigned int v60; // r5
  int v61; // r4
  UT_hash_handle *hh_head; // r4
  int v63; // r5
  char *v64; // r4
  _BOOL4 v65; // r3
  UT_hash_table *v66; // r4
  int v67; // r7
  unsigned int v68; // r6
  UT_hash_table *v69; // r3
  size_t v70; // r0
  unsigned int v71; // r9
  unsigned __int8 *v72; // r10
  int v73; // r4
  int v74; // r1
  int v75; // r0
  int v76; // r3
  unsigned __int8 *v77; // r8
  int v78; // r12
  unsigned int v79; // r1
  unsigned int v80; // r3
  int v81; // r2
  unsigned int v82; // r3
  unsigned int v83; // r1
  int v84; // r2
  unsigned int v85; // r3
  unsigned int v86; // r1
  unsigned int v87; // r7
  int v88; // r3
  unsigned int v89; // r6
  unsigned int v90; // r7
  int v91; // r3
  unsigned int v92; // r6
  unsigned int v93; // r7
  int v94; // r3
  unsigned int v95; // r3
  int v96; // r3
  UT_hash_handle *v97; // r2
  UT_hash_bucket *v98; // r2
  UT_hash_handle *v99; // r1
  UT_hash_bucket *v100; // r2
  __int64 v101; // r2
  UT_hash_table *v102; // r4
  UT_hash_bucket *v103; // r6
  unsigned int num_items; // r0
  unsigned int v105; // r3
  UT_hash_table *v106; // r3
  unsigned int num_buckets; // r4
  int v108; // r8
  UT_hash_handle *v109; // r5
  UT_hash_handle *v110; // r7
  int v111; // r4
  UT_hash_bucket *v112; // r9
  unsigned int v113; // r1
  UT_hash_handle *v114; // r3
  UT_hash_table *v115; // r3
  unsigned int nonideal_items; // r2
  unsigned int v117; // r1
  bool v118; // cc
  unsigned int ineff_expands; // r2
  UT_hash_table *v120; // r3
  char v121; // r3
  unsigned __int64 v122; // r0
  double v123; // d8
  struct tm *v124; // r0
  int v125; // r7
  char *v126; // r3
  int v127; // t1
  int v128; // r1
  int v129; // r2
  int v130; // r3
  int v131; // r1
  int v132; // r2
  int v133; // r3
  int v134; // r1
  ptrdiff_t v135; // r9
  void *v136; // r6
  char *v137; // r6
  block *v138; // r4
  char *prev; // r0
  UT_hash_table *v140; // r5
  UT_hash_handle *v141; // r2
  ptrdiff_t v142; // r1
  block *v143; // r6
  UT_hash_table *v144; // r0
  int v145; // r1
  UT_hash_bucket *v146; // r0
  UT_hash_handle *hh_next; // r2
  UT_hash_handle *hh_prev; // r3
  UT_hash_table *v149; // r0
  UT_hash_bucket *v150; // r0
  char *v151; // r6
  int v152; // r0
  int v153; // r1
  int v154; // r2
  int v155; // r3
  int v156; // r1
  int v157; // r2
  int v158; // r3
  pool *v159; // r4
  int *v160; // r0
  char *v161; // r3
  char *v162; // r3
  int *v163; // r0
  int *v164; // r0
  int *v165; // r0
  int *v166; // r0
  int *v167; // r0
  int *v168; // r0
  UT_hash_bucket *buckets; // r0
  int v170; // [sp+14h] [bp-1090h]
  _DWORD *v172; // [sp+24h] [bp-1080h]
  UT_hash_handle *p_hh; // [sp+28h] [bp-107Ch]
  unsigned int i; // [sp+28h] [bp-107Ch]
  int block_no; // [sp+2Ch] [bp-1078h]
  int v176; // [sp+3Ch] [bp-1068h] BYREF
  int v177; // [sp+40h] [bp-1064h]
  int v178; // [sp+44h] [bp-1060h]
  int v179; // [sp+48h] [bp-105Ch]
  int v180; // [sp+4Ch] [bp-1058h]
  int v181; // [sp+50h] [bp-1054h]
  int v182; // [sp+54h] [bp-1050h]
  int v183; // [sp+58h] [bp-104Ch]
  char s[12]; // [sp+5Ch] [bp-1048h] BYREF
  char v185; // [sp+68h] [bp-103Ch] BYREF
  time_t str[1025]; // [sp+A0h] [bp-1004h] BYREF

  v170 = *(unsigned __int8 *)(a1 + 1770);
  if ( *(_BYTE *)(a1 + 1770) )
    return v170;
  v3 = *(_DWORD *)(a1 + 32);
  v177 = *(_DWORD *)(a1 + 28);
  v4 = *(_DWORD *)(a1 + 12);
  v180 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 20);
  v181 = v4;
  v7 = *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 4);
  v182 = v5;
  v9 = *(_DWORD **)(a1 + 1748);
  v176 = v3;
  v178 = v7;
  v179 = v6;
  v183 = v8;
  v172 = v9;
  _bin2hex(s, (const unsigned __int8 *)&v176, 0x20u);
  if ( pthread_rwlock_rdlock(&blk_lock) )
  {
    v160 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v160,
      "cgminer.c",
      "block_exists",
      5347);
    goto LABEL_12;
  }
  if ( blocks )
  {
    LOWORD(v10) = -16657;
    v11 = strlen(s);
    v12 = -1640531527;
    v13 = v11;
    if ( v11 <= 0xB )
    {
      HIWORD(v10) = -275;
      v15 = -1640531527;
      v16 = v13;
      v21 = (unsigned __int8 *)s;
    }
    else
    {
      v14 = (unsigned __int8 *)&v185;
      v15 = -1640531527;
      HIWORD(v10) = -275;
      v16 = v13;
      v17 = -1640531527;
      do
      {
        v18 = *(v14 - 6);
        v16 -= 12;
        v19 = *(v14 - 7);
        v20 = *(v14 - 10);
        v21 = v14;
        v22 = *(v14 - 2);
        v14 += 12;
        v23 = v17 + (v18 << 16) + (v19 << 8) + *(v14 - 20) + (*(v14 - 17) << 24);
        v24 = *(v14 - 16) + (v22 << 16) + (*(v14 - 15) << 8) + (*(v14 - 13) << 24) + v10;
        v25 = ((v20 << 16) + (*(v14 - 23) << 8) + *(v14 - 24) + (*(v14 - 21) << 24) - v23 - v24 + v15) ^ (v24 >> 13);
        v26 = (v23 - v24 - v25) ^ (v25 << 8);
        v27 = (v24 - v25 - v26) ^ (v26 >> 13);
        v28 = (v25 - v26 - v27) ^ (v27 >> 12);
        v29 = (v26 - v27 - v28) ^ (v28 << 16);
        v30 = (v27 - v28 - v29) ^ (v29 >> 5);
        v15 = (v28 - v29 - v30) ^ (v30 >> 3);
        v17 = (v29 - v30 - v15) ^ (v15 << 10);
        v10 = (v30 - v15 - v17) ^ (v17 >> 15);
      }
      while ( v16 > 0xB );
      v12 = (v29 - v30 - v15) ^ (v15 << 10);
    }
    v31 = v10 + v13;
    switch ( v16 )
    {
      case 1u:
        goto LABEL_58;
      case 2u:
        goto LABEL_57;
      case 3u:
        goto LABEL_56;
      case 4u:
        goto LABEL_55;
      case 5u:
        goto LABEL_54;
      case 6u:
        goto LABEL_53;
      case 7u:
        goto LABEL_52;
      case 8u:
        goto LABEL_51;
      case 9u:
        goto LABEL_50;
      case 0xAu:
        goto LABEL_49;
      case 0xBu:
        v31 += v21[10] << 24;
LABEL_49:
        v31 += v21[9] << 16;
LABEL_50:
        v31 += v21[8] << 8;
LABEL_51:
        v12 += v21[7] << 24;
LABEL_52:
        v12 += v21[6] << 16;
LABEL_53:
        v12 += v21[5] << 8;
LABEL_54:
        v12 += v21[4];
LABEL_55:
        v15 += v21[3] << 24;
LABEL_56:
        v15 += v21[2] << 16;
LABEL_57:
        v15 += v21[1] << 8;
LABEL_58:
        v15 += *v21;
        break;
      default:
        break;
    }
    v53 = v15 - v12;
    tbl = blocks->hh.tbl;
    v55 = (v53 - v31) ^ (v31 >> 13);
    v56 = (v12 - v31 - v55) ^ (v55 << 8);
    v57 = (v31 - v55 - v56) ^ (v56 >> 13);
    v58 = (v55 - v56 - v57) ^ (v57 >> 12);
    v59 = (v56 - v57 - v58) ^ (v58 << 16);
    v60 = (v57 - v58 - v59) ^ (v59 >> 5);
    v61 = (v58 - v59 - v60) ^ (v60 >> 3);
    hh_head = tbl->buckets[(tbl->num_buckets - 1)
                         & ((v60 - v61 - ((v59 - v60 - v61) ^ (v61 << 10)))
                          ^ (((v59 - v60 - v61) ^ (v61 << 10)) >> 15))].hh_head;
    if ( hh_head )
    {
      v63 = -tbl->hho;
      while ( 1 )
      {
        v64 = (char *)hh_head + v63;
        if ( !v64 )
          goto LABEL_10;
        if ( v13 == *((_DWORD *)v64 + 23) && !memcmp(*((const void **)v64 + 22), s, v13) )
          break;
        hh_head = (UT_hash_handle *)*((_DWORD *)v64 + 21);
        if ( !hh_head )
          goto LABEL_10;
      }
      if ( !pthread_rwlock_unlock(&blk_lock) )
      {
        selective_yield();
        if ( !memcmp(v172 + 142, &v176, 0x20u) )
        {
          v65 = 1;
        }
        else
        {
          v152 = memcmp(&v176, current_block, 0x20u);
          v65 = opt_debug;
          if ( !v152 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf((char *)str, 0x1000u, "Pool %d now up to date", *v172);
              applog(7, (const char *)str, 0);
            }
            v170 = 1;
            v153 = v177;
            v154 = v178;
            v155 = v179;
            v172[142] = v176;
            v172[143] = v153;
            v172[144] = v154;
            v172[145] = v155;
            v156 = v181;
            v157 = v182;
            v158 = v183;
            v172[146] = v180;
            v172[147] = v156;
            v172[148] = v157;
            v172[149] = v158;
            goto LABEL_69;
          }
          if ( opt_debug )
          {
            if ( use_syslog || opt_log_output || opt_log_level > 6 )
            {
              snprintf((char *)str, 0x1000u, "Stale data from pool %d", *v172);
              applog(7, (const char *)str, 0);
            }
            else
            {
              v170 = opt_log_output;
            }
LABEL_69:
            if ( *(_BYTE *)(a1 + 1768) )
            {
              v118 = (unsigned int)(pool_strategy_0 - 3) > 1;
              *(_DWORD *)(a1 + 1824) = ++work_block;
              if ( !v118 || (v159 = *(pool **)(a1 + 1748), v159 == current_pool()) )
              {
                if ( *(_BYTE *)(a1 + 1772) )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf((char *)str, 0x1000u, "Stratum from pool %d requested work restart", *v172);
                    applog(7, (const char *)str, 0);
                  }
                }
                else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v161 = &byte_59398;
                  if ( *(_BYTE *)(a1 + 1812) )
                    v161 = "GBT ";
                  snprintf(
                    (char *)str,
                    0x1000u,
                    "%sLONGPOLL from pool %d requested work restart",
                    v161,
                    **(_DWORD **)(a1 + 1748));
                  applog(7, (const char *)str, 0);
                }
                restart_threads();
              }
            }
            goto out;
          }
        }
        v170 = v65;
        goto LABEL_69;
      }
      goto LABEL_11;
    }
  }
LABEL_10:
  if ( pthread_rwlock_unlock(&blk_lock) )
  {
LABEL_11:
    v32 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v32,
      "cgminer.c",
      "block_exists",
      5349);
    goto LABEL_12;
  }
  selective_yield();
  v33 = (char *)calloc(0x68u, 1u);
  v34 = (block *)v33;
  if ( !v33 )
  {
    strcpy((char *)str, "test_work_current OOM");
    applog(3, (const char *)str, 1);
    _quit(1, 1);
  }
  strcpy(v33, s);
  v35 = new_blocks;
  v34->block_no = new_blocks;
  new_blocks = v35 + 1;
  block_no = pthread_rwlock_wrlock(&blk_lock);
  if ( block_no )
  {
    v163 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v163,
      "cgminer.c",
      "test_work_current",
      5414);
    goto LABEL_12;
  }
  v36 = blocks;
  if ( !blocks )
  {
    v34->hh.key = v34;
    v34->hh.next = 0;
    v34->hh.keylen = strlen(v34->hash);
    goto LABEL_184;
  }
  if ( blocks->hh.tbl->num_items <= 6 )
  {
    v34->hh.key = v34;
    v34->hh.next = 0;
    v34->hh.keylen = strlen(v34->hash);
LABEL_81:
    p_hh = &v34->hh;
    v36->hh.tbl->tail->next = v34;
    v34->hh.prev = (char *)v36->hh.tbl->tail - v36->hh.tbl->hho;
    v36->hh.tbl->tail = &v34->hh;
    v66 = v36->hh.tbl;
    goto LABEL_82;
  }
  v37 = &blocks->hh;
  v38 = 1;
  while ( 2 )
  {
    v39 = v37;
    v37 = 0;
    v40 = 0;
    v41 = 0;
    do
    {
      ++v41;
      if ( v38 )
      {
        next = (UT_hash_handle *)v39->next;
        if ( next && (hho = v36->hh.tbl->hho, (next = (UT_hash_handle *)((char *)next + hho)) != 0) )
        {
          v44 = 1;
          do
          {
            if ( v44 == v38 )
            {
              v45 = v44;
              goto LABEL_27;
            }
            next = (UT_hash_handle *)next->next;
            ++v44;
            if ( !next )
              break;
            next = (UT_hash_handle *)((char *)next + hho);
          }
          while ( next );
          v45 = v38;
        }
        else
        {
          v45 = v38;
          v44 = 1;
        }
      }
      else
      {
        next = v39;
        v45 = 0;
        v44 = 0;
      }
LABEL_27:
      v46 = v39;
      v39 = next;
      while ( v44 )
      {
        v51 = v39 == 0;
        if ( v39 )
          v51 = v45 == 0;
        if ( v51 )
        {
          if ( !v46 )
            goto LABEL_161;
          v52 = (UT_hash_handle *)v46->next;
          if ( v52 )
            v52 = (UT_hash_handle *)((char *)v52 + v36->hh.tbl->hho);
        }
        else
        {
          v135 = v36->hh.tbl->hho;
          if ( (char *)*(void **)((char *)&v46[3].prev - v135) - (char *)*(void **)((char *)&v39[3].prev - v135) > 0 )
          {
            v136 = v39->next;
            v49 = (int)v136 + v135;
            if ( !v136 )
            {
              v49 = 0;
              --v45;
              if ( !v40 )
                goto LABEL_156;
              goto LABEL_35;
            }
LABEL_34:
            --v45;
            if ( !v40 )
            {
LABEL_156:
              v40 = v39;
              v39 = (UT_hash_handle *)v49;
              goto LABEL_157;
            }
LABEL_35:
            v40->next = (char *)v39 - v36->hh.tbl->hho;
            if ( v39 )
            {
LABEL_36:
              v50 = (char *)v40 - v36->hh.tbl->hho;
              v40 = v39;
              v39 = (UT_hash_handle *)v49;
              goto LABEL_37;
            }
            v40 = 0;
            v39 = (UT_hash_handle *)v49;
            continue;
          }
          if ( !v46 )
          {
LABEL_161:
            v52 = v46;
            goto LABEL_45;
          }
          v137 = (char *)v46->next;
          v52 = (UT_hash_handle *)&v137[v135];
          if ( !v137 )
            v52 = 0;
        }
LABEL_45:
        --v44;
        if ( v40 )
        {
          if ( v46 )
          {
            v49 = (int)v39;
            v39 = v46;
            v151 = (char *)v46 - v36->hh.tbl->hho;
            v46 = v52;
            v40->next = v151;
            goto LABEL_36;
          }
          v40->next = 0;
          v40 = 0;
          v46 = v52;
          continue;
        }
        v40 = v46;
        v46 = v52;
LABEL_157:
        v37 = v40;
        v50 = 0;
        if ( !v40 )
          continue;
LABEL_37:
        v40->prev = v50;
      }
      v47 = v45 == 0;
      if ( v45 )
        v47 = v39 == 0;
      if ( !v47 )
      {
        v48 = v39->next;
        if ( v48 )
          v49 = (int)v48 + v36->hh.tbl->hho;
        else
          v49 = v44;
        goto LABEL_34;
      }
    }
    while ( v39 );
    if ( v40 )
      v40->next = 0;
    if ( v41 > 1 )
    {
      v38 *= 2;
      if ( !v37 )
      {
        v40 = 0;
        break;
      }
      continue;
    }
    break;
  }
  v36->hh.tbl->tail = v40;
  v138 = (block *)((char *)v37 - v36->hh.tbl->hho);
  prev = (char *)v138->hh.prev;
  blocks = v138;
  block_no = v138->block_no;
  if ( !prev )
  {
    v143 = (block *)v138->hh.next;
    v140 = v138->hh.tbl;
    if ( !v143 )
    {
      buckets = v140->buckets;
      v36 = 0;
      free(buckets);
      free(v138->hh.tbl);
      blocks = 0;
      goto LABEL_183;
    }
    v142 = v140->hho;
    v141 = &v138->hh;
    if ( v138 == (block *)((char *)v140->tail - v142) )
      goto LABEL_238;
LABEL_242:
    v36 = v143;
    blocks = v143;
    goto LABEL_174;
  }
  v140 = v138->hh.tbl;
  v141 = &v138->hh;
  v142 = v140->hho;
  if ( v138 != (block *)((char *)v140->tail - v142) )
    goto LABEL_173;
LABEL_238:
  v140->tail = (UT_hash_handle *)&prev[v142];
  prev = (char *)v138->hh.prev;
  if ( !prev )
  {
    v143 = (block *)v138->hh.next;
    goto LABEL_242;
  }
  v142 = v138->hh.tbl->hho;
LABEL_173:
  v36 = v138;
  *(_DWORD *)&prev[v142 + 8] = v138->hh.next;
  v143 = (block *)v138->hh.next;
LABEL_174:
  v144 = v36->hh.tbl;
  if ( v143 )
  {
    *(_DWORD *)&v143->hash[v144->hho + 4] = v138->hh.prev;
    v144 = v36->hh.tbl;
  }
  v145 = (v144->num_buckets - 1) & v138->hh.hashv;
  --v144->buckets[v145].count;
  v146 = v36->hh.tbl->buckets;
  if ( v146[v145].hh_head == v141 )
    v146[v145].hh_head = v138->hh.hh_next;
  hh_next = v138->hh.hh_next;
  hh_prev = v138->hh.hh_prev;
  if ( hh_prev )
  {
    hh_prev->hh_next = hh_next;
    hh_next = v138->hh.hh_next;
  }
  if ( hh_next )
    hh_next->hh_prev = v138->hh.hh_prev;
  --v36->hh.tbl->num_items;
LABEL_183:
  free(v138);
  v34->hh.key = v34;
  v34->hh.next = 0;
  v34->hh.keylen = strlen(v34->hash);
  if ( v36 )
    goto LABEL_81;
LABEL_184:
  v34->hh.prev = 0;
  blocks = v34;
  v149 = (UT_hash_table *)malloc(0x2Cu);
  v66 = v149;
  v34->hh.tbl = v149;
  if ( !v149 )
    goto LABEL_256;
  memset(&v149->num_items, 0, 0x20u);
  p_hh = &v34->hh;
  v66->tail = &v34->hh;
  v66->num_buckets = 32;
  v66->log2_num_buckets = 5;
  v66->hho = 68;
  v150 = (UT_hash_bucket *)calloc(0x180u, 1u);
  v66->buckets = v150;
  if ( !v150 )
    goto LABEL_256;
  v36 = v34;
  v66->signature = -1609490463;
LABEL_82:
  v67 = -17973521;
  v68 = -1640531527;
  ++v66->num_items;
  v69 = v36->hh.tbl;
  v34->hh.hashv = -17973521;
  v34->hh.tbl = v69;
  v70 = strlen(v34->hash);
  v71 = v70;
  if ( v70 <= 0xB )
  {
    v73 = -1640531527;
    v77 = (unsigned __int8 *)v34;
  }
  else
  {
    v72 = (unsigned __int8 *)&v34->hash[12];
    v73 = -1640531527;
    do
    {
      v74 = *(v72 - 2);
      v71 -= 12;
      v75 = *(v72 - 3);
      v76 = *(v72 - 6);
      v77 = v72;
      v78 = *(v72 - 7);
      v72 += 12;
      v79 = (v74 << 16) + (v75 << 8) + *(v72 - 16) + (*(v72 - 13) << 24) + v67;
      v80 = (v76 << 16) + (v78 << 8) + *(v72 - 20) + (*(v72 - 17) << 24) + v68;
      v81 = ((*(v72 - 22) << 16) + (*(v72 - 23) << 8) + *(v72 - 24) + (*(v72 - 21) << 24) - v79 - v80 + v73)
          ^ (v79 >> 13);
      v82 = (v80 - v79 - v81) ^ (v81 << 8);
      v83 = (v79 - v81 - v82) ^ (v82 >> 13);
      v84 = (v81 - v82 - v83) ^ (v83 >> 12);
      v85 = (v82 - v83 - v84) ^ (v84 << 16);
      v86 = (v83 - v84 - v85) ^ (v85 >> 5);
      v73 = (v84 - v85 - v86) ^ (v86 >> 3);
      v68 = (v85 - v86 - v73) ^ (v73 << 10);
      v67 = (v86 - v73 - v68) ^ (v68 >> 15);
      v34->hh.hashv = v67;
    }
    while ( v71 > 0xB );
    v70 = strlen(v34->hash);
  }
  v87 = v67 + v70;
  v34->hh.hashv = v87;
  switch ( v71 )
  {
    case 1u:
      goto LABEL_97;
    case 2u:
      goto LABEL_96;
    case 3u:
      goto LABEL_95;
    case 4u:
      goto LABEL_94;
    case 5u:
      goto LABEL_93;
    case 6u:
      goto LABEL_92;
    case 7u:
      goto LABEL_91;
    case 8u:
      goto LABEL_90;
    case 9u:
      goto LABEL_89;
    case 0xAu:
      goto LABEL_88;
    case 0xBu:
      v87 += v77[10] << 24;
      v34->hh.hashv = v87;
LABEL_88:
      v87 += v77[9] << 16;
      v34->hh.hashv = v87;
LABEL_89:
      v87 += v77[8] << 8;
      v34->hh.hashv = v87;
LABEL_90:
      v68 += v77[7] << 24;
LABEL_91:
      v68 += v77[6] << 16;
LABEL_92:
      v68 += v77[5] << 8;
LABEL_93:
      v68 += v77[4];
LABEL_94:
      v73 += v77[3] << 24;
LABEL_95:
      v73 += v77[2] << 16;
LABEL_96:
      v73 += v77[1] << 8;
LABEL_97:
      v73 += *v77;
      break;
    default:
      break;
  }
  v88 = (v73 - v68 - v87) ^ (v87 >> 13);
  v89 = (v68 - v87 - v88) ^ (v88 << 8);
  v90 = (v87 - v88 - v89) ^ (v89 >> 13);
  v91 = (v88 - v89 - v90) ^ (v90 >> 12);
  v92 = (v89 - v90 - v91) ^ (v91 << 16);
  v93 = (v90 - v91 - v92) ^ (v92 >> 5);
  v94 = (v91 - v92 - v93) ^ (v93 >> 3);
  v95 = (v93 - v94 - ((v92 - v93 - v94) ^ (v94 << 10))) ^ (((v92 - v93 - v94) ^ (v94 << 10)) >> 15);
  v34->hh.hashv = v95;
  v96 = v95 & (v36->hh.tbl->num_buckets - 1);
  ++v36->hh.tbl->buckets[v96].count;
  v97 = v36->hh.tbl->buckets[v96].hh_head;
  v34->hh.hh_prev = 0;
  v34->hh.hh_next = v97;
  v98 = v36->hh.tbl->buckets;
  v99 = v98[v96].hh_head;
  v100 = &v98[v96];
  if ( v99 )
  {
    v99->hh_prev = p_hh;
    v100 = &v36->hh.tbl->buckets[v96];
  }
  v100->hh_head = p_hh;
  v101 = *(_QWORD *)&v36->hh.tbl->buckets[v96].count;
  if ( (unsigned int)v101 >= 10 * (HIDWORD(v101) + 1) )
  {
    v102 = v34->hh.tbl;
    if ( v102->noexpand != 1 )
    {
      v103 = (UT_hash_bucket *)calloc(24 * v102->num_buckets, 1u);
      if ( v103 )
      {
        num_items = v102->num_items;
        v105 = num_items >> (*(_QWORD *)&v102->log2_num_buckets + 1);
        if ( ((2 * v102->num_buckets - 1) & num_items) != 0 )
          ++v105;
        v102->ideal_chain_maxlen = v105;
        v34->hh.tbl->nonideal_items = 0;
        v106 = v34->hh.tbl;
        num_buckets = v106->num_buckets;
        if ( num_buckets )
        {
          v108 = 0;
          for ( i = 0; i < num_buckets; ++i )
          {
            v109 = v106->buckets[v108].hh_head;
            if ( v109 )
            {
              while ( 1 )
              {
                v110 = v109->hh_next;
                v111 = (2 * num_buckets - 1) & v109->hashv;
                v112 = &v103[v111];
                v113 = v112->count + 1;
                v112->count = v113;
                if ( v113 > v106->ideal_chain_maxlen )
                {
                  ++v106->nonideal_items;
                  v112->expand_mult = v112->count / v34->hh.tbl->ideal_chain_maxlen;
                }
                v109->hh_prev = 0;
                v109->hh_next = v103[v111].hh_head;
                v114 = v103[v111].hh_head;
                if ( v114 )
                  v114->hh_prev = v109;
                v103[v111].hh_head = v109;
                v106 = v34->hh.tbl;
                if ( !v110 )
                  break;
                num_buckets = v106->num_buckets;
                v109 = v110;
              }
              num_buckets = v106->num_buckets;
            }
            ++v108;
          }
        }
        free(v106->buckets);
        v34->hh.tbl->num_buckets *= 2;
        ++v34->hh.tbl->log2_num_buckets;
        v34->hh.tbl->buckets = v103;
        v115 = v34->hh.tbl;
        nonideal_items = v115->nonideal_items;
        v117 = v115->num_items;
        v118 = nonideal_items > v117 >> 1;
        if ( nonideal_items <= v117 >> 1 )
          ineff_expands = 0;
        else
          ineff_expands = v115->ineff_expands;
        if ( v118 )
          ++ineff_expands;
        v115->ineff_expands = ineff_expands;
        v120 = v34->hh.tbl;
        if ( v120->ineff_expands > 1 )
          v120->noexpand = 1;
        goto LABEL_124;
      }
LABEL_256:
      exit(-1);
    }
  }
LABEL_124:
  v121 = 8 * (29 - *(_BYTE *)(a1 + 72));
  LODWORD(v122) = 0xFFFF << v121;
  HIDWORD(v122) = (0xFFFF << (v121 - 32)) | (0xFFFFu >> (32 - v121));
  v123 = (double)v122 / (double)(bswap32(*(_DWORD *)(a1 + 72)) & 0xFFFFFF);
  if ( v123 != current_diff )
  {
    suffix_string((unsigned __int64)v123, block_diff, 8u, 0);
    current_diff = v123;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf((char *)str, 0x1000u, "Network diff set to %s", block_diff);
      applog(7, (const char *)str, 0);
    }
  }
  if ( pthread_rwlock_unlock(&blk_lock) )
  {
    v164 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v164,
      "cgminer.c",
      "test_work_current",
      5430);
    goto LABEL_12;
  }
  selective_yield();
  if ( block_no && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)str, 0x1000u, "Deleted block %d from database", block_no);
    applog(7, (const char *)str, 0);
  }
  if ( pthread_mutex_lock(&ch_lock.mutex) )
  {
    v165 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v165,
      "cgminer.c",
      "set_curblock",
      5324);
    goto LABEL_12;
  }
  if ( pthread_rwlock_wrlock(&ch_lock.rwlock) )
  {
    v167 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v167,
      "cgminer.c",
      "set_curblock",
      5324);
    goto LABEL_12;
  }
  cgtime(&block_timeval);
  strcpy(current_hash, s);
  str[0] = block_timeval.tv_sec;
  *(_DWORD *)current_block = v176;
  *(_DWORD *)&current_block[4] = v177;
  *(_DWORD *)&current_block[8] = v178;
  *(_DWORD *)&current_block[12] = v179;
  *(_DWORD *)&current_block[16] = v180;
  *(_DWORD *)&current_block[20] = v181;
  *(_DWORD *)&current_block[24] = v182;
  *(_DWORD *)&current_block[28] = v183;
  v124 = localtime(str);
  snprintf(blocktime, 0x20u, "[%02d:%02d:%02d]", v124->tm_hour, v124->tm_min, v124->tm_sec);
  if ( pthread_rwlock_unlock(&ch_lock.rwlock) )
  {
    v166 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v166,
      "cgminer.c",
      "set_curblock",
      5329);
    goto LABEL_12;
  }
  v125 = pthread_mutex_unlock(&ch_lock.mutex);
  if ( v125 )
  {
    v168 = _errno_location();
    snprintf(
      (char *)str,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v168,
      "cgminer.c",
      "set_curblock",
      5329);
LABEL_12:
    applog(3, (const char *)str, 1);
    _quit(1, 1);
  }
  selective_yield();
  v126 = current_hash;
  do
  {
    v127 = (unsigned __int8)*v126++;
    if ( v127 != 48 )
      break;
    ++v125;
  }
  while ( v125 != 57 );
  strncpy(prev_block, &current_hash[v125], 8u);
  prev_block[8] = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf((char *)str, 0x1000u, "New block: %s... diff %s", current_hash, block_diff);
    applog(7, (const char *)str, 0);
  }
  v128 = v177;
  v129 = v178;
  v130 = v179;
  v47 = new_blocks == 1;
  v172[142] = v176;
  v172[143] = v128;
  v172[144] = v129;
  v172[145] = v130;
  v131 = v181;
  v132 = v182;
  v133 = v183;
  v172[146] = v180;
  v172[147] = v131;
  v172[148] = v132;
  v172[149] = v133;
  if ( !v47 )
  {
    v134 = *(unsigned __int8 *)(a1 + 1768);
    *(_DWORD *)(a1 + 1824) = ++work_block;
    if ( v134 )
    {
      if ( *(_BYTE *)(a1 + 1772) )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf((char *)str, 0x1000u, "Stratum from pool %d detected new block", *v172);
          applog(7, (const char *)str, 0);
        }
      }
      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        v162 = &byte_59398;
        if ( *(_BYTE *)(a1 + 1812) )
          v162 = "GBT ";
        snprintf((char *)str, 0x1000u, "%sLONGPOLL from pool %d detected new block", v162, **(_DWORD **)(a1 + 1748));
        applog(7, (const char *)str, 0);
      }
    }
    else if ( have_longpoll )
    {
      if ( !*((_BYTE *)v172 + 924) && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy((char *)str, "New block detected on network before pool notification");
        applog(7, (const char *)str, 0);
      }
    }
    else if ( !*((_BYTE *)v172 + 924) && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy((char *)str, "New block detected on network");
      applog(7, (const char *)str, 0);
    }
    restart_threads();
    v170 = 1;
  }
out:
  *(_BYTE *)(a1 + 1768) = 0;
  return v170;
}
// 59398: using guessed type char byte_59398;

//----- (00023B90) --------------------------------------------------------
void __fastcall stage_work(work *work)
{
  pthread_mutex_t *v2; // r0
  thread_q *v3; // r10
  work *v4; // r5
  UT_hash_handle *p_hh; // r4
  UT_hash_table *tbl; // r7
  int v7; // r7
  unsigned int v8; // r1
  unsigned int v9; // r3
  int v10; // r0
  unsigned int v11; // r1
  unsigned int v12; // r3
  unsigned int v13; // r0
  unsigned int v14; // r3
  __int64 v15; // r0
  unsigned int v16; // r3
  UT_hash_bucket *buckets; // r2
  UT_hash_handle *hh_head; // r1
  UT_hash_bucket *v19; // r2
  work *v20; // r5
  __int64 v21; // r2
  UT_hash_table *v22; // r4
  UT_hash_bucket *v23; // r7
  unsigned int num_items; // r0
  unsigned int v25; // r3
  UT_hash_table *v26; // r0
  unsigned int num_buckets; // r4
  int v28; // r11
  UT_hash_handle *v29; // r5
  UT_hash_handle *hh_next; // r8
  int v31; // r4
  UT_hash_bucket *v32; // r10
  unsigned int v33; // r2
  UT_hash_handle *v34; // r3
  UT_hash_table *v35; // r3
  unsigned int nonideal_items; // r2
  unsigned int v37; // r1
  bool v38; // cc
  unsigned int ineff_expands; // r2
  UT_hash_table *v40; // r3
  UT_hash_handle *v41; // r12
  int v42; // r7
  UT_hash_handle *v43; // r3
  UT_hash_handle *v44; // r2
  unsigned int v45; // lr
  UT_hash_handle *next; // r6
  ptrdiff_t hho; // r4
  int v48; // r1
  int v49; // r0
  UT_hash_handle *v50; // r4
  bool v51; // zf
  void *v52; // r9
  int v53; // r9
  char *v54; // r6
  bool v55; // zf
  UT_hash_handle *v56; // r11
  ptrdiff_t v57; // r11
  void *v58; // r6
  char *v59; // r6
  char *v60; // r6
  UT_hash_table *v61; // r0
  UT_hash_bucket *v62; // r0
  int *v63; // r0
  int *v64; // r0
  unsigned int i; // [sp+14h] [bp-1010h]
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Pushing work from pool %d to hash queue", work->pool->pool_no);
    applog(7, tmp42, 0);
  }
  work->work_block = work_block;
  test_work_current((int)work);
  v2 = stgd_lock;
  ++work->pool->works;
  if ( pthread_mutex_lock(v2) )
  {
    v64 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v64, "cgminer.c", "hash_push", 5533);
LABEL_102:
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  if ( !work->clone && work->rolltime )
    ++staged_rollable;
  v3 = getq;
  if ( getq->frozen )
    goto LABEL_90;
  v4 = staged_work;
  work->hh.next = (void *)getq->frozen;
  work->hh.key = &work->id;
  work->hh.keylen = 4;
  if ( v4 )
  {
    p_hh = &work->hh;
    v4->hh.tbl->tail->next = work;
    work->hh.prev = (char *)v4->hh.tbl->tail - v4->hh.tbl->hho;
    v4->hh.tbl->tail = &work->hh;
    tbl = v4->hh.tbl;
  }
  else
  {
    work->hh.prev = 0;
    staged_work = work;
    v61 = (UT_hash_table *)malloc(0x2Cu);
    tbl = v61;
    work->hh.tbl = v61;
    if ( !v61 )
      goto LABEL_104;
    memset(&v61->num_items, 0, 0x20u);
    p_hh = &work->hh;
    tbl->num_buckets = 32;
    tbl->tail = &work->hh;
    tbl->log2_num_buckets = 5;
    tbl->hho = 1832;
    v62 = (UT_hash_bucket *)calloc(0x180u, 1u);
    tbl->buckets = v62;
    if ( !v62 )
      goto LABEL_104;
    v4 = work;
    tbl->signature = -1609490463;
  }
  ++tbl->num_items;
  v7 = LOBYTE(work->id) + 17973517 + (HIBYTE(work->id) << 24) + (BYTE2(work->id) << 16) + (BYTE1(work->id) << 8);
  v8 = (-1622558010 - (v7 ^ 0x7F76D)) ^ ((v7 ^ 0x7F76D) << 8);
  work->hh.tbl = v4->hh.tbl;
  v9 = (-17973517 - (v7 ^ 0x7F76D) - v8) ^ (v8 >> 13);
  v10 = ((v7 ^ 0x7F76D) - v8 - v9) ^ (v9 >> 12);
  v11 = (v8 - v9 - v10) ^ (v10 << 16);
  v12 = (v9 - v10 - v11) ^ (v11 >> 5);
  v13 = v10 - v11 - v12;
  v14 = (v12 - (v13 ^ (v12 >> 3)) - ((v11 - v12 - (v13 ^ (v12 >> 3))) ^ ((v13 ^ (v12 >> 3)) << 10)))
      ^ (((v11 - v12 - (v13 ^ (v12 >> 3))) ^ ((v13 ^ (v12 >> 3)) << 10)) >> 15);
  work->hh.hashv = v14;
  v15 = *(_QWORD *)&v4->hh.tbl->buckets;
  v16 = v14 & (HIDWORD(v15) - 1);
  ++*(_DWORD *)(v15 + v16 * 12 + 4);
  HIDWORD(v15) = v4->hh.tbl->buckets[v16].hh_head;
  work->hh.hh_prev = 0;
  work->hh.hh_next = (UT_hash_handle *)HIDWORD(v15);
  buckets = v4->hh.tbl->buckets;
  hh_head = buckets[v16].hh_head;
  v19 = &buckets[v16];
  if ( hh_head )
  {
    hh_head->hh_prev = p_hh;
    v19 = &v4->hh.tbl->buckets[v16];
  }
  v19->hh_head = p_hh;
  v20 = staged_work;
  v21 = *(_QWORD *)&staged_work->hh.tbl->buckets[v16].count;
  if ( (unsigned int)v21 >= 10 * (HIDWORD(v21) + 1) )
  {
    v22 = work->hh.tbl;
    if ( v22->noexpand != 1 )
    {
      v23 = (UT_hash_bucket *)calloc(24 * v22->num_buckets, 1u);
      if ( v23 )
      {
        num_items = v22->num_items;
        v25 = num_items >> (*(_QWORD *)&v22->log2_num_buckets + 1);
        if ( ((2 * v22->num_buckets - 1) & num_items) != 0 )
          ++v25;
        v22->ideal_chain_maxlen = v25;
        work->hh.tbl->nonideal_items = 0;
        v26 = work->hh.tbl;
        num_buckets = v26->num_buckets;
        if ( num_buckets )
        {
          v28 = 0;
          for ( i = 0; i < num_buckets; ++i )
          {
            v29 = v26->buckets[v28].hh_head;
            if ( v29 )
            {
              while ( 1 )
              {
                hh_next = v29->hh_next;
                v31 = (2 * num_buckets - 1) & v29->hashv;
                v32 = &v23[v31];
                v33 = v32->count + 1;
                v32->count = v33;
                if ( v33 > v26->ideal_chain_maxlen )
                {
                  ++v26->nonideal_items;
                  v32->expand_mult = v32->count / work->hh.tbl->ideal_chain_maxlen;
                }
                v29->hh_prev = 0;
                v29->hh_next = v23[v31].hh_head;
                v34 = v23[v31].hh_head;
                if ( v34 )
                  v34->hh_prev = v29;
                v23[v31].hh_head = v29;
                v26 = work->hh.tbl;
                if ( !hh_next )
                  break;
                num_buckets = v26->num_buckets;
                v29 = hh_next;
              }
              num_buckets = v26->num_buckets;
            }
            ++v28;
          }
        }
        free(v26->buckets);
        work->hh.tbl->num_buckets *= 2;
        ++work->hh.tbl->log2_num_buckets;
        work->hh.tbl->buckets = v23;
        v35 = work->hh.tbl;
        v20 = staged_work;
        nonideal_items = v35->nonideal_items;
        v37 = v35->num_items;
        v38 = nonideal_items > v37 >> 1;
        if ( nonideal_items <= v37 >> 1 )
          ineff_expands = 0;
        else
          ineff_expands = v35->ineff_expands;
        if ( v38 )
          ++ineff_expands;
        v35->ineff_expands = ineff_expands;
        v40 = work->hh.tbl;
        if ( v40->ineff_expands > 1 )
          v40->noexpand = 1;
        v3 = getq;
        if ( !v20 )
          goto LABEL_90;
        goto LABEL_40;
      }
LABEL_104:
      exit(-1);
    }
  }
  v3 = getq;
LABEL_40:
  v41 = &v20->hh;
  v42 = 1;
  while ( 2 )
  {
    v43 = v41;
    v41 = 0;
    v44 = 0;
    v45 = 0;
    do
    {
      ++v45;
      if ( v42 )
      {
        next = (UT_hash_handle *)v43->next;
        if ( next && (hho = v20->hh.tbl->hho, (next = (UT_hash_handle *)((char *)next + hho)) != 0) )
        {
          v48 = 1;
          do
          {
            if ( v48 == v42 )
            {
              v49 = v48;
              goto LABEL_50;
            }
            next = (UT_hash_handle *)next->next;
            ++v48;
            if ( !next )
              break;
            next = (UT_hash_handle *)((char *)next + hho);
          }
          while ( next );
          v49 = v42;
        }
        else
        {
          v49 = v42;
          v48 = 1;
        }
      }
      else
      {
        next = v43;
        v49 = 0;
        v48 = 0;
      }
LABEL_50:
      v50 = v43;
      v43 = next;
      while ( v48 )
      {
        v55 = v43 == 0;
        if ( v43 )
          v55 = v49 == 0;
        if ( v55 )
        {
          if ( v50 )
          {
            v56 = (UT_hash_handle *)v50->next;
            if ( v56 )
              v56 = (UT_hash_handle *)((char *)v56 + v20->hh.tbl->hho);
LABEL_68:
            --v48;
            if ( v44 )
              goto LABEL_69;
            goto LABEL_79;
          }
        }
        else
        {
          v57 = v20->hh.tbl->hho;
          if ( (signed int)(*(unsigned int *)((char *)&v50[54].keylen - v57)
                          - *(unsigned int *)((char *)&v43[54].keylen - v57)) > 0 )
          {
            v58 = v43->next;
            v53 = (int)v58 + v57;
            if ( v58 )
              goto LABEL_57;
            v53 = 0;
            --v49;
            if ( !v44 )
            {
LABEL_74:
              v44 = v43;
              v43 = (UT_hash_handle *)v53;
              goto LABEL_75;
            }
LABEL_58:
            v44->next = (char *)v43 - v20->hh.tbl->hho;
            if ( v43 )
              goto LABEL_59;
            v44 = 0;
            v43 = (UT_hash_handle *)v53;
            continue;
          }
          if ( v50 )
          {
            v59 = (char *)v50->next;
            v56 = (UT_hash_handle *)&v59[v57];
            if ( !v59 )
              v56 = 0;
            goto LABEL_68;
          }
        }
        v56 = v50;
        --v48;
        if ( v44 )
        {
LABEL_69:
          if ( v50 )
          {
            v53 = (int)v43;
            v43 = v50;
            v60 = (char *)v50 - v20->hh.tbl->hho;
            v50 = v56;
            v44->next = v60;
LABEL_59:
            v54 = (char *)v44 - v20->hh.tbl->hho;
            v44 = v43;
            v43 = (UT_hash_handle *)v53;
            goto LABEL_60;
          }
          v44->next = 0;
          v44 = 0;
          v50 = v56;
          continue;
        }
LABEL_79:
        v44 = v50;
        v50 = v56;
LABEL_75:
        v41 = v44;
        v54 = 0;
        if ( !v44 )
          continue;
LABEL_60:
        v44->prev = v54;
      }
      v51 = v49 == 0;
      if ( v49 )
        v51 = v43 == 0;
      if ( !v51 )
      {
        v52 = v43->next;
        if ( v52 )
          v53 = (int)v52 + v20->hh.tbl->hho;
        else
          v53 = v48;
LABEL_57:
        --v49;
        if ( !v44 )
          goto LABEL_74;
        goto LABEL_58;
      }
    }
    while ( v43 );
    if ( v44 )
      v44->next = 0;
    if ( v45 > 1 )
    {
      v42 *= 2;
      if ( !v41 )
      {
        v44 = 0;
        break;
      }
      continue;
    }
    break;
  }
  v20->hh.tbl->tail = v44;
  staged_work = (work *)((char *)v41 - v20->hh.tbl->hho);
LABEL_90:
  pthread_cond_broadcast(&v3->cond);
  if ( pthread_mutex_unlock(stgd_lock) )
  {
    v63 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v63, "cgminer.c", "hash_push", 5544);
    goto LABEL_102;
  }
  selective_yield();
}

//----- (00024128) --------------------------------------------------------
void __fastcall submit_work_async(work *work)
{
  pool *pool; // r5
  cgpu_info *cgpu; // r6
  int64_t v4; // kr08_8
  double v5; // d6
  double work_difficulty; // d5
  double v7; // d7
  _BOOL4 v8; // r2
  _BOOL4 v9; // r2
  _BOOL4 stratum; // r3
  double diff_stale; // d6
  double v12; // d7
  double v13; // d5
  int v14; // r3
  int v15; // r4
  int v16; // r3
  int v17; // r4
  pthread_t submit_thread; // [sp+14h] [bp-1008h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( !*(_DWORD *)&work->data[76] )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy(tmp42, "Get A Error Data To Push!DROP!\r\n");
      applog(4, tmp42, 0);
    }
    return;
  }
  pool = work->pool;
  cgtime(&work->tv_work_found);
  if ( opt_benchmark )
  {
    cgpu = get_thread(work->thr_id)->cgpu;
    if ( !pthread_mutex_lock(&stats_lock) )
    {
      v4 = total_accepted;
      ++cgpu->accepted;
      total_accepted = v4 + 1;
      v5 = total_diff_accepted;
      ++pool->accepted;
      cgpu->diff_accepted = cgpu->diff_accepted + work->work_difficulty;
      work_difficulty = work->work_difficulty;
      v7 = pool->diff_accepted + work_difficulty;
      total_diff_accepted = v5 + work_difficulty;
      pool->diff_accepted = v7;
      if ( !pthread_mutex_unlock(&stats_lock) )
      {
        selective_yield();
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "Accepted %s %d benchmark share nonce %08x",
            cgpu->drv->name,
            cgpu->device_id,
            *(_DWORD *)&work->data[76]);
          applog(7, tmp42, 0);
        }
        return;
      }
      v16 = *_errno_location();
      v17 = 8243;
      goto LABEL_65;
    }
    v14 = *_errno_location();
    v15 = 8236;
LABEL_62:
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      v14,
      "cgminer.c",
      "submit_work_async",
      v15);
    goto LABEL_63;
  }
  if ( !stale_work(work, 1) )
  {
    v8 = opt_debug;
    goto LABEL_17;
  }
  if ( !opt_submit_stale )
  {
    if ( !pool->submit_old )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "Pool %d stale share detected, discarding", pool->pool_no);
        applog(7, tmp42, 0);
      }
      sharelog("discard", work);
      if ( pthread_mutex_lock(&stats_lock) )
      {
        v14 = *_errno_location();
        v15 = 8261;
        goto LABEL_62;
      }
      diff_stale = pool->diff_stale;
      v12 = total_diff_stale;
      ++pool->stale_shares;
      v13 = work->work_difficulty;
      ++total_stale;
      pool->diff_stale = diff_stale + v13;
      total_diff_stale = v12 + v13;
      if ( pthread_mutex_unlock(&stats_lock) )
      {
        v16 = *_errno_location();
        v17 = 8266;
LABEL_65:
        snprintf(
          tmp42,
          0x1000u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          v16,
          "cgminer.c",
          "submit_work_async",
          v17);
LABEL_63:
        applog(3, tmp42, 1);
        _quit(1, 1);
      }
      selective_yield();
LABEL_37:
      clean_work(work);
      sub_12000(work);
      return;
    }
    if ( opt_debug )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_26;
      snprintf(tmp42, 0x1000u, "Pool %d stale share detected, submitting as pool requested", pool->pool_no);
      goto LABEL_50;
    }
LABEL_51:
    stratum = work->stratum;
    work->stale = 1;
    if ( stratum )
      goto LABEL_31;
    goto LABEL_43;
  }
  if ( !opt_debug )
    goto LABEL_51;
  if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
  {
LABEL_26:
    v9 = work->stratum;
    work->stale = 1;
    if ( v9 )
    {
LABEL_27:
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        snprintf(tmp42, 0x1000u, "Pushing pool %d work to stratum queue", pool->pool_no);
        applog(7, tmp42, 0);
      }
      goto LABEL_31;
    }
LABEL_39:
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(tmp42, "Pushing submit work to work thread");
      applog(7, tmp42, 0);
    }
    goto LABEL_43;
  }
  snprintf(tmp42, 0x1000u, "Pool %d stale share detected, submitting as user requested", pool->pool_no);
LABEL_50:
  applog(7, tmp42, 0);
  v8 = opt_debug;
  work->stale = 1;
LABEL_17:
  if ( work->stratum )
  {
    if ( v8 )
      goto LABEL_27;
LABEL_31:
    if ( tq_push(pool->stratum_q, work) )
      return;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42, "Discarding work from removed pool");
      applog(7, tmp42, 0);
    }
    goto LABEL_37;
  }
  if ( v8 )
    goto LABEL_39;
LABEL_43:
  if ( pthread_create(&submit_thread, 0, submit_work_thread, work) )
  {
    strcpy(tmp42, "Failed to create submit_work_thread");
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
}

//----- (00024644) --------------------------------------------------------
bool __fastcall submit_tested_work(thr_info *thr, work *work)
{
  _BOOL4 v4; // r0
  work *v5; // r1
  bool v6; // r4
  work *v8; // r6

  update_work_stats(thr, work);
  v4 = fulltest(work->hash, work->target);
  if ( v4 )
  {
    v6 = v4;
    v8 = make_work();
    copy_work(v8, work, 0);
    submit_work_async(v8);
  }
  else
  {
    v6 = opt_debug;
    if ( opt_debug )
    {
      if ( use_syslog )
        return submit_tested_work_0(thr, v5);
      v6 = opt_log_output;
      if ( opt_log_output || opt_log_level > 6 )
        return submit_tested_work_0(thr, v5);
    }
  }
  return v6;
}
// 24694: variable 'v5' is possibly undefined

//----- (000246B4) --------------------------------------------------------
bool __fastcall submit_nonce(thr_info *thr, work *work, uint32_t nonce)
{
  int v6; // r0
  bool v7; // r4
  unsigned int v8; // r3

  v6 = new_nonce((thr_info *)thr->cgpu, nonce);
  if ( !v6 )
    goto LABEL_5;
  v7 = v6;
  *(_DWORD *)&work->data[76] = nonce;
  rebuild_hash(work);
  v8 = 0xFFFF;
  if ( !opt_scrypt )
    v8 = 0;
  if ( *(_DWORD *)&work->hash[28] <= v8 )
  {
    submit_tested_work(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
    {
      v7 = opt_benchfile_display;
      benchfile_dspwork(work, nonce);
    }
  }
  else
  {
LABEL_5:
    v7 = 0;
    inc_hw_errors(thr);
  }
  return v7;
}

//----- (0002472C) --------------------------------------------------------
void __fastcall submit_nonce_2(work *work)
{
  work *v2; // r4

  v2 = make_work();
  copy_work(v2, work, 0);
  submit_work_async(v2);
}

//----- (00024748) --------------------------------------------------------
bool __fastcall submit_nonce_direct(thr_info *thr, work *work, uint32_t nonce)
{
  work *v4; // r5

  *(_DWORD *)&work->data[76] = nonce;
  v4 = make_work();
  copy_work(v4, work, 0);
  submit_work_async(v4);
  return 1;
}

//----- (00024768) --------------------------------------------------------
bool __fastcall submit_noffset_nonce(thr_info *thr, work *work_in, uint32_t nonce, int noffset)
{
  work *work; // r4
  unsigned int v9; // r3
  _BOOL4 v10; // r5
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  work = make_work();
  copy_work(work, work_in, noffset);
  *(_DWORD *)&work->data[76] = nonce;
  rebuild_hash(work);
  v9 = 0xFFFF;
  if ( !opt_scrypt )
    v9 = 0;
  if ( *(_DWORD *)&work->hash[28] > v9 )
  {
    clean_work(work);
    free(work);
    inc_hw_errors(thr);
    return 0;
  }
  else
  {
    update_work_stats(thr, work);
    if ( opt_benchfile && opt_benchfile_display )
      benchfile_dspwork(work, nonce);
    v10 = fulltest(work->hash, work->target);
    if ( v10 )
    {
      submit_work_async(work);
      return v10;
    }
    clean_work(work);
    free(work);
    LOBYTE(v10) = opt_debug;
    if ( opt_debug )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return v10;
      snprintf(tmp42, 0x1000u, "%s %d: Share above target", thr->cgpu->drv->name, thr->cgpu->device_id);
      applog(7, tmp42, 0);
      return v10;
    }
    else
    {
      return 1;
    }
  }
}

//----- (0002489C) --------------------------------------------------------
void *__fastcall stratum_rthread(void *userdata)
{
  pthread_t v2; // r0
  pool *v3; // r0
  fd_set *v4; // r3
  int v5; // r3
  int v6; // r2
  bool v7; // nf
  int v8; // r2
  int v9; // r1
  __fd_mask v10; // r4
  int v11; // r0
  char *v12; // r4
  int v14; // r0
  unsigned int v15; // r2
  int v16; // r4
  json_t *v17; // r0
  json_t *v18; // r0
  int v19; // r6
  stratum_share *v20; // r5
  UT_hash_table *tbl; // r0
  unsigned int v22; // r1
  unsigned int v23; // r3
  unsigned int v24; // r6
  int v25; // r1
  unsigned int v26; // r2
  unsigned int v27; // r3
  int v28; // r1
  UT_hash_handle *hh_head; // r6
  ptrdiff_t hho; // r12
  char *v31; // r6
  unsigned __int8 *v32; // r2
  int v33; // r7
  unsigned __int8 *v34; // r2
  int v35; // r1
  stratum_share *v36; // r7
  UT_hash_table *v37; // r2
  int v38; // r3
  UT_hash_bucket *buckets; // r2
  __int64 v40; // r2
  int v41; // r7
  time_t v42; // r12
  char *v43; // r3
  unsigned int v45; // r8
  double work_difficulty; // d0
  const char *v47; // r1
  pool *pool; // r8
  double v49; // d5
  unsigned int v50; // kr04_4
  int v51; // r1
  unsigned int rejected_high; // r1
  unsigned int rejected; // kr0C_4
  double v54; // d5
  double v55; // d7
  const char *v56; // r7
  size_t v57; // r3
  const char *v58; // r1
  char *v59; // r7
  int seq_rejects; // r5
  work *v61; // r5
  size_t v62; // r3
  size_t v63; // r3
  work *work; // r5
  char *v65; // r6
  size_t refcount; // r3
  size_t v67; // r3
  const pthread_mutex_t *v68; // r5
  int v69; // r3
  int v70; // r4
  int *v71; // r0
  const pthread_mutex_t *v72; // r5
  int v73; // r3
  int v74; // r4
  int *v75; // r0
  double v76; // d8
  int64_t v77; // kr20_8
  double v78; // d6
  double v79; // d7
  __int64 v80; // kr28_8
  char *v81; // r0
  int64_t v82; // kr30_8
  double v83; // d5
  double v84; // d7
  int pool_no; // r2
  time_t v86; // r0
  _BOOL4 v87; // r3
  const char *v88; // r2
  int v89; // r3
  double v90; // d6
  unsigned int v91; // r2
  double v92; // d7
  unsigned int v93; // kr18_4
  const char *v94; // r2
  int v95; // r3
  int *v96; // r0
  int v97; // r1
  int *v98; // r0
  int *v99; // r0
  int v100; // r4
  const char *v101; // r2
  json_t *v102; // r0
  const char *v103; // r0
  int *v104; // r0
  json_t *json; // [sp+18h] [bp-1264h]
  work *v106; // [sp+20h] [bp-125Ch]
  cgpu_info *cgpu; // [sp+28h] [bp-1254h]
  json_t *n; // [sp+34h] [bp-1248h]
  size_t na; // [sp+34h] [bp-1248h]
  const json_t *v110; // [sp+38h] [bp-1244h]
  double *p_work_difficulty; // [sp+44h] [bp-1238h]
  int v112; // [sp+48h] [bp-1234h]
  timeval timeout; // [sp+4Ch] [bp-1230h] BYREF
  char threadname[16]; // [sp+54h] [bp-1228h] BYREF
  char v115[20]; // [sp+64h] [bp-1218h] BYREF
  char v116[2]; // [sp+78h] [bp-1204h] BYREF
  __int16 v117; // [sp+7Ah] [bp-1202h] BYREF
  char buf[7]; // [sp+98h] [bp-11E4h] BYREF
  char dest[29]; // [sp+9Fh] [bp-11DDh] BYREF
  char v120[60]; // [sp+BCh] [bp-11C0h] BYREF
  char v121; // [sp+F8h] [bp-1184h] BYREF
  fd_set rd; // [sp+FCh] [bp-1180h] BYREF
  json_error_t error; // [sp+17Ch] [bp-1100h] BYREF
  char tmp42[4096]; // [sp+278h] [bp-1004h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  snprintf(threadname, 0x10u, "%d/RStratum", *(_DWORD *)userdata);
  RenameThread(threadname);
  do
  {
LABEL_2:
    v3 = (pool *)userdata;
    if ( *((_BYTE *)userdata + 137) )
    {
LABEL_17:
      suspend_stratum(v3);
      return 0;
    }
    while ( 1 )
    {
      if ( !sock_full(v3) && !cnx_needed((pool *)userdata) )
      {
        suspend_stratum((pool *)userdata);
        clear_stratum_shares((pool *)userdata);
        clear_pool_work((pool *)userdata);
        if ( cnx_needed((pool *)userdata) )
          goto LABEL_33;
        while ( !*((_DWORD *)userdata + 33) || userdata != current_pool() && (unsigned int)(pool_strategy_0 - 3) > 1 )
        {
          if ( pthread_mutex_lock(&lp_lock) )
          {
            v68 = (const pthread_mutex_t *)"wait_lpcurrent";
            v69 = *_errno_location();
            v70 = 9248;
            goto LABEL_155;
          }
          pthread_cond_wait(&lp_cond, &lp_lock);
          if ( pthread_mutex_unlock(&lp_lock) )
          {
            v72 = (const pthread_mutex_t *)"wait_lpcurrent";
            v73 = *_errno_location();
            v74 = 9250;
            goto LABEL_159;
          }
          selective_yield();
          if ( cnx_needed((pool *)userdata) )
            break;
        }
LABEL_33:
        while ( !restart_stratum((pool *)userdata) )
        {
          if ( *((_BYTE *)userdata + 137) )
            return 0;
          if ( enabled_pools <= 1 )
            v14 = 3000;
          else
            v14 = 30000;
          cgsleep_ms(v14);
        }
      }
      v4 = (fd_set *)&v121;
      do
      {
        v4->fds_bits[1] = 0;
        v4 = (fd_set *)((char *)v4 + 4);
      }
      while ( &rd.fds_bits[31] != (__fd_mask *)v4 );
      v5 = *((_DWORD *)userdata + 153);
      timeout.tv_usec = 0;
      v6 = (v5 + 31) & (v5 >> 31);
      if ( v5 >= 0 )
        v6 = v5;
      v7 = -v5 < 0;
      v8 = v6 >> 5;
      v9 = -v5 & 0x1F;
      LOBYTE(v5) = v5 & 0x1F;
      v10 = rd.fds_bits[v8];
      if ( !v7 )
        v5 = -v9;
      timeout.tv_sec = 90;
      rd.fds_bits[v8] = (1 << v5) | v10;
      if ( !sock_full((pool *)userdata) )
      {
        v11 = select(*((_DWORD *)userdata + 153) + 1, &rd, 0, 0, &timeout);
        if ( v11 <= 0 )
          break;
      }
      v12 = recv_line((pool *)userdata);
      if ( !v12 )
        goto LABEL_35;
      stratum_resumed((pool *)userdata);
      if ( parse_method((pool *)userdata, v12) )
        goto LABEL_14;
      v17 = json_loads(v12, 0, &error);
      json = v17;
      if ( v17 )
      {
        n = json_object_get(v17, "result");
        v110 = json_object_get(json, "error");
        v18 = json_object_get(json, "id");
        if ( !v18 || v18->type == JSON_NULL )
        {
          if ( v110 )
          {
            v65 = json_dumps(v110, 3u);
          }
          else
          {
            v81 = (char *)malloc(0x11u);
            v65 = v81;
            if ( v81 )
              strcpy(v81, "(unknown reason)");
          }
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "JSON-RPC non method decode failed: %s", v65);
            applog(7, tmp42, 0);
          }
          free(v65);
          refcount = json->refcount;
          if ( refcount != -1 )
            goto LABEL_147;
        }
        else
        {
          v19 = json_integer_value(v18);
          v112 = v19;
          if ( pthread_mutex_lock(&sshare_lock) )
          {
            v68 = &_func___16149;
            v69 = *_errno_location();
            v70 = 6921;
LABEL_155:
            snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", v69, "cgminer.c", v68, v70);
            goto LABEL_156;
          }
          v20 = stratum_shares;
          if ( stratum_shares )
          {
            tbl = stratum_shares->hh.tbl;
            v22 = (unsigned int)&nonce_fifo.nonce_buffer[37].Nonce[368]
                ^ ((v19 & 0xFF000000) + (unsigned __int8)v19 + 17973517 + (v19 & 0xFF0000) + (v19 & 0xFF00));
            v23 = (-1622558010 - v22) ^ (v22 << 8);
            v24 = (-17973517 - v22 - v23) ^ (v23 >> 13);
            v25 = (v22 - v23 - v24) ^ (v24 >> 12);
            v26 = (v23 - v24 - v25) ^ (v25 << 16);
            v27 = (v24 - v25 - v26) ^ (v26 >> 5);
            v28 = (v25 - v26 - v27) ^ (v27 >> 3);
            hh_head = stratum_shares->hh.tbl->buckets[((v27 - v28 - ((v26 - v27 - v28) ^ (v28 << 10)))
                                                     ^ (((v26 - v27 - v28) ^ (v28 << 10)) >> 15))
                                                    & (stratum_shares->hh.tbl->num_buckets - 1)].hh_head;
            if ( hh_head )
            {
              hho = tbl->hho;
              while ( 1 )
              {
                v31 = (char *)hh_head - hho;
                if ( !v31 )
                  goto LABEL_163;
                if ( *((_DWORD *)v31 + 6) == 4 )
                {
                  v32 = (unsigned __int8 *)*((_DWORD *)v31 + 5);
                  if ( *v32 == (unsigned __int8)v112 )
                  {
                    v33 = v32[1];
                    v34 = v32 + 1;
                    if ( v33 == BYTE1(v112) && __PAIR64__(v34[2], v34[1]) == __PAIR64__(HIBYTE(v112), BYTE2(v112)) )
                      break;
                  }
                }
                hh_head = (UT_hash_handle *)*((_DWORD *)v31 + 4);
                if ( !hh_head )
                  goto LABEL_163;
              }
              v35 = *((_DWORD *)v31 + 1);
              if ( v35 )
              {
                if ( v31 != (char *)tbl->tail - hho )
                  goto LABEL_67;
LABEL_189:
                tbl->tail = (UT_hash_handle *)(v35 + hho);
                v35 = *((_DWORD *)v31 + 1);
                if ( v35 )
                {
                  hho = v20->hh.tbl->hho;
LABEL_67:
                  *(_DWORD *)(v35 + hho + 8) = *((_DWORD *)v31 + 2);
                  v36 = (stratum_share *)*((_DWORD *)v31 + 2);
LABEL_68:
                  v37 = v20->hh.tbl;
                  if ( v36 )
                  {
                    *(void **)((char *)&v36->hh.prev + v37->hho) = (void *)*((_DWORD *)v31 + 1);
                    v37 = v20->hh.tbl;
                  }
                  v38 = (v37->num_buckets - 1) & *((_DWORD *)v31 + 7);
                  --v37->buckets[v38].count;
                  buckets = v20->hh.tbl->buckets;
                  if ( (char *)buckets[v38].hh_head == v31 )
                    buckets[v38].hh_head = (UT_hash_handle *)*((_DWORD *)v31 + 4);
                  v40 = *(_QWORD *)(v31 + 12);
                  if ( (_DWORD)v40 )
                  {
                    *(_DWORD *)(v40 + 16) = HIDWORD(v40);
                    HIDWORD(v40) = *((_DWORD *)v31 + 4);
                  }
                  if ( HIDWORD(v40) )
                    *(_DWORD *)(HIDWORD(v40) + 12) = *((_DWORD *)v31 + 3);
                  --v20->hh.tbl->num_items;
LABEL_77:
                  --*((_DWORD *)userdata + 189);
                  v41 = pthread_mutex_unlock(&sshare_lock);
                  if ( v41 )
                    goto LABEL_228;
                  selective_yield();
                  v106 = (work *)*((_DWORD *)v31 + 9);
                  v42 = time(0);
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(
                      tmp42,
                      0x1000u,
                      "Pool %d stratum share result lag time %d seconds",
                      v106->pool->pool_no,
                      v42 - *((_DWORD *)v31 + 12));
                    applog(7, tmp42, 0);
                  }
                  v43 = tmp42;
                  *(_DWORD *)tmp42 = bswap32(*(_DWORD *)&v106->hash[28]);
                  *(_DWORD *)&tmp42[4] = bswap32(*(_DWORD *)&v106->hash[24]);
                  *(_DWORD *)&tmp42[8] = bswap32(*(_DWORD *)&v106->hash[20]);
                  *(_DWORD *)&tmp42[12] = bswap32(*(_DWORD *)&v106->hash[16]);
                  *(_DWORD *)&tmp42[16] = bswap32(*(_DWORD *)&v106->hash[12]);
                  *(_DWORD *)&tmp42[20] = bswap32(*(_DWORD *)&v106->hash[8]);
                  *(_DWORD *)&tmp42[24] = bswap32(*(_DWORD *)&v106->hash[4]);
                  *(_DWORD *)&tmp42[28] = bswap32(*(_DWORD *)v106->hash);
                  do
                  {
                    if ( *v43++ )
                      break;
                    ++v41;
                  }
                  while ( v41 != 29 );
                  v45 = bswap32(*(_DWORD *)&tmp42[v41]);
                  work_difficulty = v106->work_difficulty;
                  p_work_difficulty = &v106->work_difficulty;
                  round();
                  suffix_string(v106->share_diff, buf, 0x10u, 0);
                  v47 = " BLOCK!";
                  if ( !v106->block )
                    v47 = &byte_59398;
                  snprintf(v120, 0x40u, "%08lx Diff %s/%llu%s", v45, buf, (unsigned __int64)work_difficulty, v47);
                  pool = v106->pool;
                  cgpu = get_thread(v106->thr_id)->cgpu;
                  if ( n && (n->type == JSON_TRUE || v106->gbt && n->type == JSON_NULL) )
                  {
                    if ( pthread_mutex_lock(&stats_lock) )
                    {
                      v98 = _errno_location();
                      snprintf(
                        tmp42,
                        0x1000u,
                        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                        *v98,
                        "cgminer.c",
                        "share_result",
                        3481);
                      goto LABEL_156;
                    }
                    v82 = total_accepted + 1;
                    ++cgpu->accepted;
                    total_accepted = v82;
                    ++pool->accepted;
                    v83 = total_diff_accepted;
                    cgpu->diff_accepted = cgpu->diff_accepted + *p_work_difficulty;
                    v84 = pool->diff_accepted + *p_work_difficulty;
                    total_diff_accepted = v83 + *p_work_difficulty;
                    pool->diff_accepted = v84;
                    if ( pthread_mutex_unlock(&stats_lock) )
                    {
                      v96 = _errno_location();
                      v97 = 3488;
                      goto LABEL_239;
                    }
                    selective_yield();
                    pool_no = pool->pool_no;
                    pool->seq_rejects = 0;
                    cgpu->last_share_pool = pool_no;
                    v86 = time(0);
                    cgpu->last_share_pool_time = v86;
                    v87 = opt_debug;
                    cgpu->last_share_diff = *p_work_difficulty;
                    pool->last_share_time = v86;
                    pool->last_share_diff = *p_work_difficulty;
                    if ( v87 && (use_syslog || opt_log_output || opt_log_level > 6) )
                    {
                      strcpy(tmp42, "PROOF OF WORK RESULT: true (yay!!!)");
                      applog(7, tmp42, 0);
                    }
                    if ( !opt_quiet && !opt_realquiet )
                    {
                      if ( total_pools <= 1 )
                      {
                        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          snprintf(
                            tmp42,
                            0x1000u,
                            "Accepted %s %s %d %s%s",
                            v120,
                            cgpu->drv->name,
                            cgpu->device_id,
                            &byte_59398,
                            &byte_59398);
                          applog(7, tmp42, 0);
                        }
                      }
                      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                      {
                        snprintf(
                          tmp42,
                          0x1000u,
                          "Accepted %s %s %d pool %d %s%s",
                          v120,
                          cgpu->drv->name,
                          cgpu->device_id,
                          v106->pool->pool_no,
                          &byte_59398,
                          &byte_59398);
                        applog(7, tmp42, 0);
                      }
                    }
                    sharelog("accept", v106);
                    if ( opt_shares && (double)opt_shares <= total_diff_accepted )
                    {
                      if ( use_syslog || opt_log_output || opt_log_level > 3 )
                      {
                        snprintf(
                          tmp42,
                          0x1000u,
                          "Successfully mined %d accepted shares as requested and exiting.",
                          opt_shares);
                        applog(4, tmp42, 0);
                      }
                      kill_work();
                    }
                    if ( pool->enabled == pool_enable::POOL_REJECTING )
                    {
                      if ( use_syslog || opt_log_output || opt_log_level > 3 )
                      {
                        snprintf(tmp42, 0x1000u, "Rejecting pool %d now accepting shares, re-enabling!", pool->pool_no);
                        applog(4, tmp42, 0);
                      }
                      if ( pool->enabled != pool_enable::POOL_ENABLED )
                        enable_pool((pool *)&pool->enabled);
                      switch_pools(0);
                    }
                    if ( v106->block )
                      restart_threads();
                  }
                  else
                  {
                    if ( pthread_mutex_lock(&stats_lock) )
                    {
                      v104 = _errno_location();
                      snprintf(
                        tmp42,
                        0x1000u,
                        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
                        *v104,
                        "cgminer.c",
                        "share_result",
                        3531);
                      goto LABEL_156;
                    }
                    v49 = total_diff_rejected;
                    v50 = total_rejected;
                    v51 = cgpu->rejected + 1;
                    LODWORD(total_rejected) = total_rejected + 1;
                    cgpu->rejected = v51;
                    rejected_high = HIDWORD(pool->rejected);
                    rejected = pool->rejected;
                    HIDWORD(total_rejected) = (__PAIR64__(HIDWORD(total_rejected), v50) + 1) >> 32;
                    pool->rejected = __PAIR64__(rejected_high, rejected) + 1;
                    cgpu->diff_rejected = cgpu->diff_rejected + *p_work_difficulty;
                    v54 = v49 + *p_work_difficulty;
                    v55 = pool->diff_rejected + *p_work_difficulty;
                    ++pool->seq_rejects;
                    total_diff_rejected = v54;
                    pool->diff_rejected = v55;
                    if ( pthread_mutex_unlock(&stats_lock) )
                    {
                      v96 = _errno_location();
                      v97 = 3539;
LABEL_239:
                      snprintf(
                        tmp42,
                        0x1000u,
                        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                        *v96,
                        "cgminer.c",
                        "share_result",
                        v97);
                      goto LABEL_156;
                    }
                    selective_yield();
                    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                    {
                      strcpy(tmp42, "PROOF OF WORK RESULT: false (booooo)");
                      applog(7, tmp42, 0);
                    }
                    if ( !opt_quiet && !opt_realquiet )
                    {
                      strcpy(buf, "reject");
                      memset(dest, opt_realquiet, sizeof(dest));
                      v116[0] = opt_realquiet;
                      if ( total_pools > 1 )
                        snprintf(v115, 0x14u, "pool %d", v106->pool->pool_no);
                      else
                        v115[0] = opt_realquiet;
                      if ( !v106->gbt )
                        n = json_object_get(json, "reject-reason");
                      if ( n )
                      {
                        v56 = json_string_value(n);
                        v57 = strlen(v56);
                        if ( v57 >= 0x1C )
                          v57 = 28;
                        *(_WORD *)v116 = 10272;
                        na = v57;
                        memcpy(&v117, v56, v57);
                        v58 = v56;
                        v59 = &v116[na];
                        v59[2] = 41;
                        v59[3] = 0;
                        memcpy(dest, v58, na);
                        buf[6] = 58;
                        buf[na + 7] = 0;
                      }
                      else if ( v110 && v106->stratum )
                      {
                        if ( v110->type == JSON_ARRAY )
                        {
                          v102 = json_array_get(v110, 1u);
                          if ( !v102 || v102->type != JSON_STRING )
                            goto LABEL_105;
                        }
                        else
                        {
                          if ( v110->type != JSON_STRING )
                            goto LABEL_105;
                          v102 = (json_t *)v110;
                        }
                        v103 = json_string_value(v102);
                        snprintf(v116, 0x1Fu, " (%s)", v103);
                      }
LABEL_105:
                      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                      {
                        snprintf(
                          tmp42,
                          0x1000u,
                          "Rejected %s %s %d %s%s %s%s",
                          v120,
                          cgpu->drv->name,
                          cgpu->device_id,
                          v115,
                          v116,
                          &byte_59398,
                          &byte_59398);
                        applog(7, tmp42, 0);
                      }
                      sharelog(buf, v106);
                    }
                    seq_rejects = pool->seq_rejects;
                    if ( seq_rejects > 10
                      && !v106->stale
                      && opt_disable_pool
                      && enabled_pools > 1
                      && (double)seq_rejects > (double)total_accepted / total_secs * 60.0 * 3.0 )
                    {
                      if ( use_syslog || opt_log_output || opt_log_level > 3 )
                      {
                        snprintf(
                          tmp42,
                          0x1000u,
                          "Pool %d rejected %d sequential shares, disabling!",
                          pool->pool_no,
                          pool->seq_rejects);
                        applog(4, tmp42, 0);
                      }
                      if ( pool->enabled == pool_enable::POOL_ENABLED )
                        --enabled_pools;
                      pool->enabled = pool_enable::POOL_REJECTING;
                      if ( pool == current_pool() )
                        switch_pools(0);
                      pool->seq_rejects = 0;
                    }
                  }
                  v61 = (work *)*((_DWORD *)v31 + 9);
                  clean_work(v61);
                  free(v61);
                  free(v31);
                  v62 = json->refcount;
                  if ( v62 != -1 )
                  {
                    v63 = v62 - 1;
                    json->refcount = v63;
                    if ( !v63 )
                      json_delete(json);
                  }
LABEL_14:
                  if ( *((_BYTE *)userdata + 696) )
                  {
                    work = make_work();
                    *((_BYTE *)userdata + 696) = 0;
                    gen_stratum_work((pool *)userdata, work);
                    work->longpoll = 1;
                    test_work_current((int)work);
                    clean_work(work);
                    free(work);
                  }
                  goto LABEL_16;
                }
                v36 = (stratum_share *)*((_DWORD *)v31 + 2);
              }
              else
              {
                v36 = (stratum_share *)*((_DWORD *)v31 + 2);
                if ( !v36 )
                {
                  free(stratum_shares->hh.tbl->buckets);
                  free(v20->hh.tbl);
                  stratum_shares = 0;
                  goto LABEL_77;
                }
                if ( v31 == (char *)tbl->tail - hho )
                  goto LABEL_189;
              }
              v20 = v36;
              stratum_shares = v36;
              goto LABEL_68;
            }
          }
LABEL_163:
          if ( pthread_mutex_unlock(&sshare_lock) )
          {
LABEL_228:
            v72 = &_func___16149;
            v73 = *_errno_location();
            v74 = 6928;
LABEL_159:
            snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", v73, "cgminer.c", v72, v74);
            goto LABEL_156;
          }
          selective_yield();
          if ( !n )
          {
            refcount = json->refcount;
            if ( refcount == -1 )
              goto LABEL_149;
LABEL_147:
            v67 = refcount - 1;
            json->refcount = v67;
            if ( !v67 )
              json_delete(json);
            goto LABEL_149;
          }
          if ( pthread_mutex_lock((pthread_mutex_t *)((char *)userdata + 244)) )
          {
            v99 = _errno_location();
            v101 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
            v100 = 6938;
LABEL_249:
            snprintf(tmp42, 0x1000u, v101, *v99, "cgminer.c", &_func___16149, v100);
LABEL_156:
            applog(3, tmp42, 1);
            _quit(1, 1);
          }
          if ( pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)userdata + 268)) )
          {
            v99 = _errno_location();
            v101 = "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d";
            v100 = 6938;
            goto LABEL_249;
          }
          if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)userdata + 244)) )
          {
            v99 = _errno_location();
            v100 = 6938;
            goto LABEL_248;
          }
          v76 = *((double *)userdata + 230);
          if ( pthread_rwlock_unlock((pthread_rwlock_t *)((char *)userdata + 268)) )
          {
            v99 = _errno_location();
            v101 = "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d";
            v100 = 6940;
            goto LABEL_249;
          }
          selective_yield();
          if ( n->type == JSON_TRUE )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(tmp42, 0x1000u, "Accepted untracked stratum share from pool %d", *(_DWORD *)userdata);
              applog(7, tmp42, 0);
            }
            if ( pthread_mutex_lock(&stats_lock) )
              mutex_lock((pthread_mutex_t *)&_func___16149, (const char *)0x1B24, v88, v89);
            v90 = *((double *)userdata + 13) + v76;
            ++total_accepted;
            v91 = *((_DWORD *)userdata + 3);
            v92 = total_diff_accepted + v76;
            v93 = *((_DWORD *)userdata + 2);
            *((double *)userdata + 13) = v90;
            *((_QWORD *)userdata + 1) = __PAIR64__(v91, v93) + 1;
            total_diff_accepted = v92;
            if ( pthread_mutex_unlock(&stats_lock) )
              mutex_unlock_noyield((pthread_mutex_t *)&_func___16149, (const char *)0x1B29, v94, v95);
          }
          else
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(tmp42, 0x1000u, "Rejected untracked stratum share from pool %d", *(_DWORD *)userdata);
              applog(7, tmp42, 0);
            }
            if ( pthread_mutex_lock(&stats_lock) )
            {
              v99 = _errno_location();
              v101 = "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d";
              v100 = 6959;
              goto LABEL_249;
            }
            v77 = total_rejected + 1;
            v78 = *((double *)userdata + 14) + v76;
            v79 = total_diff_rejected + v76;
            v80 = *((_QWORD *)userdata + 2) + 1LL;
            LODWORD(total_rejected) = total_rejected + 1;
            *((_QWORD *)userdata + 2) = v80;
            *((double *)userdata + 14) = v78;
            HIDWORD(total_rejected) = HIDWORD(v77);
            total_diff_rejected = v79;
            if ( pthread_mutex_unlock(&stats_lock) )
            {
              v99 = _errno_location();
              v100 = 6964;
LABEL_248:
              v101 = "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d";
              goto LABEL_249;
            }
          }
          selective_yield();
          refcount = json->refcount;
          if ( refcount != -1 )
            goto LABEL_147;
        }
      }
      else
      {
        if ( !opt_debug )
          goto LABEL_16;
        if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
          goto LABEL_151;
        snprintf(tmp42, 0x1000u, "JSON decode failed(%d): %s", error.line, error.text);
        applog(7, tmp42, 0);
      }
LABEL_149:
      if ( opt_debug )
      {
        if ( !use_syslog )
        {
LABEL_151:
          if ( !opt_log_output && opt_log_level <= 6 )
            goto LABEL_16;
        }
        snprintf(tmp42, 0x1000u, "Unknown stratum msg: %s", v12);
        applog(7, tmp42, 0);
      }
LABEL_16:
      free(v12);
      v3 = (pool *)userdata;
      if ( *((_BYTE *)userdata + 137) )
        goto LABEL_17;
    }
    if ( opt_debug )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        snprintf(tmp42, 0x1000u, "Stratum select failed on pool %d with value %d", *(_DWORD *)userdata, v11);
        applog(7, tmp42, 0);
LABEL_35:
        if ( opt_debug )
        {
          if ( !use_syslog )
            goto LABEL_37;
LABEL_38:
          snprintf(tmp42, 0x1000u, "Stratum connection to pool %d interrupted", *(_DWORD *)userdata);
          applog(7, tmp42, 0);
        }
      }
      else
      {
LABEL_37:
        if ( opt_log_output || opt_log_level > 6 )
          goto LABEL_38;
      }
    }
    v15 = total_go;
    ++*((_DWORD *)userdata + 40);
    total_go = v15 + 1;
    if ( pthread_mutex_lock((pthread_mutex_t *)((char *)userdata + 244)) )
    {
      v68 = (const pthread_mutex_t *)"supports_resume";
      v69 = *_errno_location();
      v70 = 7101;
      goto LABEL_155;
    }
    if ( pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)userdata + 268)) )
    {
      v71 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v71,
        "cgminer.c",
        "supports_resume",
        7101);
      goto LABEL_156;
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)((char *)userdata + 244)) )
    {
      v72 = (const pthread_mutex_t *)"supports_resume";
      v73 = *_errno_location();
      v74 = 7101;
      goto LABEL_159;
    }
    v16 = *((_DWORD *)userdata + 165);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)((char *)userdata + 268)) )
    {
      v75 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v75,
        "cgminer.c",
        "supports_resume",
        7103);
      goto LABEL_156;
    }
    selective_yield();
    if ( !v16 || opt_lowmem )
      clear_stratum_shares((pool *)userdata);
    clear_pool_work((pool *)userdata);
    if ( userdata == current_pool() )
      restart_threads();
  }
  while ( restart_stratum((pool *)userdata) );
  while ( !*((_BYTE *)userdata + 137) )
  {
    cgsleep_ms(30000);
    if ( restart_stratum((pool *)userdata) )
      goto LABEL_2;
  }
  return 0;
}
// 259A6: variable 'v94' is possibly undefined
// 259A6: variable 'v95' is possibly undefined
// 25A3E: variable 'v88' is possibly undefined
// 25A3E: variable 'v89' is possibly undefined
// 1231C: using guessed type int round(void);
// 59398: using guessed type char byte_59398;

//----- (00025C88) --------------------------------------------------------
void __fastcall __noreturn quit(int status)
{
  _quit(status, 1);
}

//----- (00025C90) --------------------------------------------------------
bool __fastcall add_pool_details(pool *pool, bool live, char *url, char *user, char *pass)
{
  _BOOL4 v6; // r6
  char *proxy; // r0
  size_t v9; // r5
  size_t v10; // r5
  char *v11; // r0
  pool_enable enabled; // r1
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  v6 = live;
  proxy = get_proxy(url, pool);
  pool->rpc_user = user;
  pool->rpc_url = proxy;
  pool->rpc_pass = pass;
  v9 = strlen(user);
  v10 = v9 + strlen(pass) + 2;
  v11 = (char *)malloc(v10);
  pool->rpc_userpass = v11;
  if ( !v11 )
  {
    strcpy(tmp42, "Failed to malloc userpass");
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  snprintf(v11, v10, "%s:%s", user, pass);
  enabled = pool->enabled;
  pool->testing = 1;
  pool->idle = 1;
  pool->blocking = !v6;
  if ( enabled != pool_enable::POOL_ENABLED )
    enable_pool((pool *)&pool->enabled);
  pthread_create(&pool->test_thread, 0, test_pool_thread, pool);
  if ( !v6 )
  {
    pthread_join(pool->test_thread, 0);
    LOBYTE(v6) = pools_active;
  }
  return v6;
}

//----- (00025D70) --------------------------------------------------------
void __fastcall fill_device_drv(device_drv *drv)
{
  if ( drv->drv_detect )
  {
    if ( drv->reinit_device )
      goto LABEL_3;
  }
  else
  {
    drv->drv_detect = noop_detect;
    if ( drv->reinit_device )
    {
LABEL_3:
      if ( drv->get_statline_before )
        goto LABEL_4;
      goto LABEL_23;
    }
  }
  drv->reinit_device = noop_reinit_device;
  if ( drv->get_statline_before )
  {
LABEL_4:
    if ( drv->get_statline )
      goto LABEL_5;
    goto LABEL_24;
  }
LABEL_23:
  drv->get_statline_before = blank_get_statline_before;
  if ( drv->get_statline )
  {
LABEL_5:
    if ( drv->get_stats )
      goto LABEL_6;
    goto LABEL_25;
  }
LABEL_24:
  drv->get_statline = (void (*)(char *, size_t, cgpu_info *))noop_get_statline;
  if ( drv->get_stats )
  {
LABEL_6:
    if ( drv->thread_prepare )
      goto LABEL_7;
    goto LABEL_26;
  }
LABEL_25:
  drv->get_stats = noop_get_stats;
  if ( drv->thread_prepare )
  {
LABEL_7:
    if ( drv->can_limit_work )
      goto LABEL_8;
    goto LABEL_27;
  }
LABEL_26:
  drv->thread_prepare = (bool (*)(thr_info *))noop_thread_prepare;
  if ( drv->can_limit_work )
  {
LABEL_8:
    if ( drv->thread_init )
      goto LABEL_9;
    goto LABEL_28;
  }
LABEL_27:
  drv->can_limit_work = noop_can_limit_work;
  if ( drv->thread_init )
  {
LABEL_9:
    if ( drv->prepare_work )
      goto LABEL_10;
    goto LABEL_29;
  }
LABEL_28:
  drv->thread_init = (bool (*)(thr_info *))noop_thread_init;
  if ( drv->prepare_work )
  {
LABEL_10:
    if ( drv->hw_error )
      goto LABEL_11;
    goto LABEL_30;
  }
LABEL_29:
  drv->prepare_work = noop_prepare_work;
  if ( drv->hw_error )
  {
LABEL_11:
    if ( drv->thread_shutdown )
      goto LABEL_12;
    goto LABEL_31;
  }
LABEL_30:
  drv->hw_error = (void (*)(thr_info *))noop_hw_error;
  if ( drv->thread_shutdown )
  {
LABEL_12:
    if ( drv->thread_enable )
      goto LABEL_13;
    goto LABEL_32;
  }
LABEL_31:
  drv->thread_shutdown = (void (*)(thr_info *))noop_thread_shutdown;
  if ( drv->thread_enable )
  {
LABEL_13:
    if ( drv->hash_work )
      goto LABEL_14;
    goto LABEL_33;
  }
LABEL_32:
  drv->thread_enable = (void (*)(thr_info *))noop_thread_enable;
  if ( drv->hash_work )
  {
LABEL_14:
    if ( drv->flush_work )
      goto LABEL_15;
    goto LABEL_34;
  }
LABEL_33:
  drv->hash_work = hash_sole_work;
  if ( drv->flush_work )
  {
LABEL_15:
    if ( drv->update_work )
      goto LABEL_16;
    goto LABEL_35;
  }
LABEL_34:
  drv->flush_work = noop_reinit_device;
  if ( drv->update_work )
  {
LABEL_16:
    if ( drv->queue_full )
      goto LABEL_17;
LABEL_36:
    drv->queue_full = noop_get_stats;
    if ( drv->zero_stats )
      goto LABEL_18;
    goto LABEL_37;
  }
LABEL_35:
  drv->update_work = noop_reinit_device;
  if ( !drv->queue_full )
    goto LABEL_36;
LABEL_17:
  if ( drv->zero_stats )
    goto LABEL_18;
LABEL_37:
  drv->zero_stats = noop_reinit_device;
LABEL_18:
  if ( drv->max_diff == 0.0 )
    drv->max_diff = 1.0;
}
// 17594: using guessed type int noop_get_statline();
// 175A4: using guessed type int noop_hw_error();
// 175A8: using guessed type int noop_thread_shutdown();
// 175AC: using guessed type int noop_thread_enable();

//----- (00025F10) --------------------------------------------------------
void __fastcall null_device_drv(device_drv *drv)
{
  drv->get_api_stats = noop_get_api_stats;
  drv->drv_detect = noop_detect;
  drv->get_statline_before = blank_get_statline_before;
  drv->get_statline = (void (*)(char *, size_t, cgpu_info *))noop_get_statline;
  drv->set_device = 0;
  drv->thread_prepare = (bool (*)(thr_info *))noop_thread_prepare;
  drv->can_limit_work = noop_can_limit_work;
  drv->thread_init = (bool (*)(thr_info *))noop_thread_init;
  drv->prepare_work = noop_prepare_work;
  drv->hash_work = (void (*)(thr_info *))noop_hash_work;
  drv->hw_error = (void (*)(thr_info *))noop_hw_error;
  drv->thread_shutdown = (void (*)(thr_info *))noop_thread_shutdown;
  drv->thread_enable = (void (*)(thr_info *))noop_thread_enable;
  drv->max_diff = 1.0;
  drv->min_diff = 1.0;
  drv->reinit_device = noop_reinit_device;
  drv->identify_device = noop_reinit_device;
  drv->zero_stats = noop_reinit_device;
  drv->flush_work = noop_reinit_device;
  drv->update_work = noop_reinit_device;
  drv->get_stats = noop_get_stats;
  drv->queue_full = noop_get_stats;
}
// 17594: using guessed type int noop_get_statline();
// 17598: using guessed type int noop_hash_work();
// 175A4: using guessed type int noop_hw_error();
// 175A8: using guessed type int noop_thread_shutdown();
// 175AC: using guessed type int noop_thread_enable();

//----- (00025FC0) --------------------------------------------------------
int __fastcall enable_device(pthread_rwlock_t *a1)
{
  const char *v2; // r2
  int v3; // r3
  cgpu_info **v4; // r1
  int v5; // r3
  const char *v6; // r2
  int v7; // r3
  int result; // r0
  const char *v9; // r2
  int v10; // r3

  a1[1].__readers = 0;
  if ( pthread_rwlock_wrlock(&devices_lock) )
    wr_lock((pthread_rwlock_t *)&_func___17121, (const char *)0x2894, v2, v3);
  v4 = devices;
  v5 = cgminer_id_count;
  a1->__readers = cgminer_id_count;
  v4[v5] = (cgpu_info *)a1;
  cgminer_id_count = v5 + 1;
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock((pthread_rwlock_t *)&_func___17121, (const char *)0x2896, v6, v7);
  selective_yield();
  if ( hotplug_mode )
    new_threads += a1[4].__pad4;
  else
    mining_threads += a1[4].__pad4;
  result = pthread_rwlock_init(a1 + 10, 0);
  if ( result )
    rwlock_init((pthread_rwlock_t *)&_func___17121, (const char *)0x289D, v9, v10);
  a1[11].__readers = 0;
  return result;
}
// 2605A: variable 'v2' is possibly undefined
// 2605A: variable 'v3' is possibly undefined
// 26064: variable 'v6' is possibly undefined
// 26064: variable 'v7' is possibly undefined
// 2606E: variable 'v9' is possibly undefined
// 2606E: variable 'v10' is possibly undefined

//----- (00026078) --------------------------------------------------------
int __fastcall add_cgpu(cgpu_info *a1)
{
  int v1; // r6
  const char *name; // r4
  size_t v3; // r5
  int v4; // r3
  int v5; // r7
  int v6; // r0
  unsigned __int8 *v7; // lr
  unsigned int v8; // r1
  int v9; // r12
  int v10; // r4
  int v11; // r2
  int v12; // r3
  unsigned int v13; // r1
  unsigned int v14; // r2
  int v15; // r3
  unsigned int v16; // r1
  unsigned int v17; // r2
  int v18; // r3
  unsigned int v19; // r1
  unsigned int v20; // r2
  size_t v21; // r7
  _DWORD *v22; // r1
  int v23; // r0
  unsigned int v24; // r4
  unsigned int v25; // r7
  int v26; // r3
  unsigned int v27; // r0
  unsigned int v28; // r7
  int v29; // r3
  int v30; // r4
  int v31; // r7
  int v32; // r4
  int v33; // r4
  int v34; // r3
  const char *v35; // r2
  int v36; // r3
  const char *v37; // r2
  int v38; // r3
  const char *v39; // r2
  int v40; // r3
  const char *v41; // r2
  int v42; // r3
  int v43; // r3
  char *v45; // r0
  unsigned __int8 *v46; // r3
  _DWORD *v47; // r7
  char *v48; // r4
  __int64 v49; // r2
  _DWORD *v50; // r4
  int v51; // r8
  unsigned int v52; // r5
  int v53; // r3
  size_t v54; // r0
  unsigned int v55; // r10
  unsigned __int8 *v56; // r11
  int v57; // r4
  int v58; // r0
  int v59; // r8
  int v60; // r1
  int v61; // r3
  unsigned __int8 *v62; // r9
  int v63; // r12
  unsigned int v64; // r8
  unsigned int v65; // r3
  int v66; // r2
  unsigned int v67; // r3
  unsigned int v68; // r8
  int v69; // r2
  unsigned int v70; // r3
  unsigned int v71; // r8
  size_t v72; // r0
  int v73; // r3
  unsigned int v74; // r1
  unsigned int v75; // r0
  int v76; // r3
  unsigned int v77; // r1
  unsigned int v78; // r0
  unsigned int v79; // r3
  unsigned int v80; // r3
  __int64 v81; // r0
  int v82; // r3
  int v83; // r2
  int v84; // r1
  _DWORD *v85; // r2
  __int64 v86; // r2
  int v87; // r4
  _DWORD *v88; // r6
  unsigned int v89; // r1
  unsigned int v90; // r3
  int v91; // r1
  unsigned int v92; // r4
  int v93; // r9
  _DWORD *v94; // r5
  _DWORD *v95; // r8
  int v96; // r4
  char *v97; // r11
  unsigned int v98; // r2
  int v99; // r3
  _DWORD *v100; // r3
  unsigned int v101; // r2
  unsigned int v102; // r1
  bool v103; // cc
  int v104; // r2
  int v105; // r3
  int v106; // r3
  _DWORD *v107; // r0
  void *v108; // r0
  unsigned __int8 *v109; // r9
  unsigned int v110; // r8
  unsigned __int8 *s2; // [sp+Ch] [bp-8h]
  void *s2a; // [sp+Ch] [bp-8h]
  char *s2b; // [sp+Ch] [bp-8h]

  v1 = devids_17132;
  s2 = (unsigned __int8 *)a1->drv->name;
  if ( devids_17132 )
  {
    name = a1->drv->name;
    v3 = strlen(name);
    v4 = -1640531527;
    v5 = -17973521;
    v6 = -1640531527;
    if ( v3 > 0xB )
    {
      v7 = (unsigned __int8 *)(name + 12);
      v110 = v3;
      v8 = -1640531527;
      do
      {
        v9 = *(v7 - 6);
        v110 -= 12;
        v10 = *(v7 - 7);
        v11 = *(v7 - 2);
        v109 = v7;
        v12 = *(v7 - 10);
        v7 += 12;
        v13 = v8 + (v9 << 16) + (v10 << 8) + *(v7 - 20) + (*(v7 - 17) << 24);
        v14 = (v11 << 16) + (*(v7 - 15) << 8) + *(v7 - 16) + (*(v7 - 13) << 24) + v5;
        v15 = ((v12 << 16) + (*(v7 - 23) << 8) + *(v7 - 24) + (*(v7 - 21) << 24) - v13 - v14 + v6) ^ (v14 >> 13);
        v16 = (v13 - v14 - v15) ^ (v15 << 8);
        v17 = (v14 - v15 - v16) ^ (v16 >> 13);
        v18 = (v15 - v16 - v17) ^ (v17 >> 12);
        v19 = (v16 - v17 - v18) ^ (v18 << 16);
        v20 = (v17 - v18 - v19) ^ (v19 >> 5);
        v6 = (v18 - v19 - v20) ^ (v20 >> 3);
        v8 = (v19 - v20 - v6) ^ (v6 << 10);
        v5 = (v20 - v6 - v8) ^ (v8 >> 15);
      }
      while ( v110 > 0xB );
      v4 = v8;
    }
    else
    {
      v109 = s2;
      v110 = v3;
    }
    v21 = v5 + v3;
    switch ( v110 )
    {
      case 1u:
        goto LABEL_18;
      case 2u:
        goto LABEL_17;
      case 3u:
        goto LABEL_16;
      case 4u:
        goto LABEL_15;
      case 5u:
        goto LABEL_14;
      case 6u:
        goto LABEL_13;
      case 7u:
        goto LABEL_12;
      case 8u:
        goto LABEL_11;
      case 9u:
        goto LABEL_10;
      case 0xAu:
        goto LABEL_9;
      case 0xBu:
        v21 += v109[10] << 24;
LABEL_9:
        v21 += v109[9] << 16;
LABEL_10:
        v21 += v109[8] << 8;
LABEL_11:
        v4 += v109[7] << 24;
LABEL_12:
        v4 += v109[6] << 16;
LABEL_13:
        v4 += v109[5] << 8;
LABEL_14:
        v4 += v109[4];
LABEL_15:
        v6 += v109[3] << 24;
LABEL_16:
        v6 += v109[2] << 16;
LABEL_17:
        v6 += v109[1] << 8;
LABEL_18:
        v6 += *v109;
        break;
      default:
        break;
    }
    v22 = *(_DWORD **)(devids_17132 + 8);
    v23 = (v6 - v4 - v21) ^ (v21 >> 13);
    v24 = (v4 - v21 - v23) ^ (v23 << 8);
    v25 = (v21 - v23 - v24) ^ (v24 >> 13);
    v26 = (v23 - v24 - v25) ^ (v25 >> 12);
    v27 = (v24 - v25 - v26) ^ (v26 << 16);
    v28 = (v25 - v26 - v27) ^ (v27 >> 5);
    v29 = (v26 - v27 - v28) ^ (v28 >> 3);
    v30 = *(_DWORD *)(*v22
                    + 12
                    * (((v28 - v29 - ((v27 - v28 - v29) ^ (v29 << 10)))
                      ^ (((v27 - v28 - v29) ^ (v29 << 10)) >> 15))
                     & (v22[1] - 1)));
    if ( v30 )
    {
      v31 = -v22[5];
      v32 = v30 - v22[5];
      if ( v32 )
      {
        while ( *(_DWORD *)(v32 + 32) != v3 || memcmp(*(const void **)(v32 + 28), s2, v3) )
        {
          v33 = *(_DWORD *)(v32 + 24);
          if ( v33 )
          {
            v32 = v33 + v31;
            if ( v32 )
              continue;
          }
          goto LABEL_36;
        }
        v34 = *(_DWORD *)(v32 + 4) + 1;
        *(_DWORD *)(v32 + 4) = v34;
        a1->device_id = v34;
LABEL_27:
        if ( !pthread_rwlock_wrlock(&devices_lock) )
          goto LABEL_28;
LABEL_81:
        wr_lock((pthread_rwlock_t *)(&_func___17121.__align + 4), (const char *)0x28CC, v35, v36);
      }
    }
LABEL_36:
    v45 = (char *)malloc(0x28u);
    v46 = s2;
    v47 = v45;
    v48 = v45 + 8;
    s2a = v45 + 8;
    v49 = *(unsigned int *)v46;
    *((_DWORD *)v45 + 7) = v45;
    *((_DWORD *)v45 + 4) = 0;
    *(_QWORD *)v45 = v49;
    a1->device_id = HIDWORD(v49);
    *((_DWORD *)v45 + 8) = strlen(v45);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) + 8) = v47;
    v47[3] = *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) - *(_DWORD *)(*(_DWORD *)(v1 + 8) + 20);
    *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) = v48;
    v50 = *(_DWORD **)(v1 + 8);
  }
  else
  {
    v47 = malloc(0x28u);
    v106 = *(_DWORD *)s2;
    a1->device_id = 0;
    v47[4] = 0;
    *v47 = v106;
    v47[1] = 0;
    v47[7] = v47;
    v47[8] = strlen((const char *)v47);
    v47[3] = 0;
    devids_17132 = (int)v47;
    v107 = malloc(0x2Cu);
    v50 = v107;
    v47[2] = v107;
    if ( !v107 )
      goto LABEL_89;
    memset(v107 + 3, 0, 0x20u);
    s2a = v47 + 2;
    v50[4] = v47 + 2;
    v50[1] = 32;
    v50[2] = 5;
    v50[5] = 8;
    v108 = calloc(0x180u, 1u);
    *v50 = v108;
    if ( !v108 )
      goto LABEL_89;
    v1 = (int)v47;
    v50[10] = -1609490463;
  }
  v51 = -17973521;
  v52 = -1640531527;
  ++v50[3];
  v53 = *(_DWORD *)(v1 + 8);
  v47[9] = -17973521;
  v47[2] = v53;
  v54 = strlen((const char *)v47);
  v55 = v54;
  if ( v54 <= 0xB )
  {
    v57 = -1640531527;
    v62 = (unsigned __int8 *)v47;
  }
  else
  {
    v56 = (unsigned __int8 *)(v47 + 3);
    v57 = -1640531527;
    v58 = -17973521;
    do
    {
      v59 = *(v56 - 2);
      v55 -= 12;
      v60 = *(v56 - 3);
      v61 = *(v56 - 6);
      v62 = v56;
      v63 = *(v56 - 7);
      v56 += 12;
      v64 = (v59 << 16) + (v60 << 8) + *(v56 - 16) + (*(v56 - 13) << 24) + v58;
      v65 = (v61 << 16) + (v63 << 8) + *(v56 - 20) + (*(v56 - 17) << 24) + v52;
      v66 = ((*(v56 - 22) << 16) + (*(v56 - 23) << 8) + *(v56 - 24) + (*(v56 - 21) << 24) - v64 - v65 + v57)
          ^ (v64 >> 13);
      v67 = (v65 - v64 - v66) ^ (v66 << 8);
      v68 = (v64 - v66 - v67) ^ (v67 >> 13);
      v69 = (v66 - v67 - v68) ^ (v68 >> 12);
      v70 = (v67 - v68 - v69) ^ (v69 << 16);
      v71 = (v68 - v69 - v70) ^ (v70 >> 5);
      v57 = (v69 - v70 - v71) ^ (v71 >> 3);
      v52 = (v70 - v71 - v57) ^ (v57 << 10);
      v58 = (v71 - v57 - v52) ^ (v52 >> 15);
      v47[9] = v58;
    }
    while ( v55 > 0xB );
    v51 = (v71 - v57 - v52) ^ (v52 >> 15);
    v54 = strlen((const char *)v47);
  }
  v72 = v54 + v51;
  v47[9] = v72;
  switch ( v55 )
  {
    case 1u:
      goto LABEL_53;
    case 2u:
      goto LABEL_52;
    case 3u:
      goto LABEL_51;
    case 4u:
      goto LABEL_50;
    case 5u:
      goto LABEL_49;
    case 6u:
      goto LABEL_48;
    case 7u:
      goto LABEL_47;
    case 8u:
      goto LABEL_46;
    case 9u:
      goto LABEL_45;
    case 0xAu:
      goto LABEL_44;
    case 0xBu:
      v72 += v62[10] << 24;
      v47[9] = v72;
LABEL_44:
      v72 += v62[9] << 16;
      v47[9] = v72;
LABEL_45:
      v72 += v62[8] << 8;
      v47[9] = v72;
LABEL_46:
      v52 += v62[7] << 24;
LABEL_47:
      v52 += v62[6] << 16;
LABEL_48:
      v52 += v62[5] << 8;
LABEL_49:
      v52 += v62[4];
LABEL_50:
      v57 += v62[3] << 24;
LABEL_51:
      v57 += v62[2] << 16;
LABEL_52:
      v57 += v62[1] << 8;
LABEL_53:
      v57 += *v62;
      break;
    default:
      break;
  }
  v73 = (v57 - v52 - v72) ^ (v72 >> 13);
  v74 = (v52 - v72 - v73) ^ (v73 << 8);
  v75 = (v72 - v73 - v74) ^ (v74 >> 13);
  v76 = (v73 - v74 - v75) ^ (v75 >> 12);
  v77 = (v74 - v75 - v76) ^ (v76 << 16);
  v78 = (v75 - v76 - v77) ^ (v77 >> 5);
  v79 = v76 - v77 - v78;
  v80 = (v78 - (v79 ^ (v78 >> 3)) - ((v77 - v78 - (v79 ^ (v78 >> 3))) ^ ((v79 ^ (v78 >> 3)) << 10)))
      ^ (((v77 - v78 - (v79 ^ (v78 >> 3))) ^ ((v79 ^ (v78 >> 3)) << 10)) >> 15);
  v47[9] = v80;
  v81 = *(_QWORD *)*(_DWORD *)(v1 + 8);
  v82 = 12 * (v80 & (HIDWORD(v81) - 1));
  ++*(_DWORD *)(v81 + v82 + 4);
  HIDWORD(v81) = *(_DWORD *)(**(_DWORD **)(v1 + 8) + v82);
  v47[5] = 0;
  v47[6] = HIDWORD(v81);
  v83 = **(_DWORD **)(v1 + 8);
  v84 = *(_DWORD *)(v83 + v82);
  v85 = (_DWORD *)(v83 + v82);
  if ( v84 )
  {
    *(_DWORD *)(v84 + 12) = s2a;
    v85 = (_DWORD *)(**(_DWORD **)(v1 + 8) + v82);
  }
  *v85 = s2a;
  v86 = *(_QWORD *)(**(_DWORD **)(v1 + 8) + v82 + 4);
  if ( (unsigned int)v86 < 10 * (HIDWORD(v86) + 1) )
    goto LABEL_27;
  v87 = v47[2];
  if ( *(_DWORD *)(v87 + 36) == 1 )
    goto LABEL_27;
  v88 = calloc(24 * *(_DWORD *)(v87 + 4), 1u);
  if ( !v88 )
LABEL_89:
    exit(-1);
  v89 = *(_DWORD *)(v87 + 12);
  v90 = v89 >> (*(_QWORD *)(v87 + 8) + 1);
  if ( ((2 * *(_DWORD *)(v87 + 4) - 1) & v89) != 0 )
    ++v90;
  *(_DWORD *)(v87 + 24) = v90;
  *(_DWORD *)(v47[2] + 28) = 0;
  v91 = v47[2];
  v92 = *(_DWORD *)(v91 + 4);
  if ( v92 )
  {
    v93 = 0;
    for ( s2b = 0; (unsigned int)s2b < v92; ++s2b )
    {
      v94 = *(_DWORD **)(*(_DWORD *)v91 + v93);
      if ( v94 )
      {
        while ( 1 )
        {
          v95 = (_DWORD *)v94[4];
          v96 = 3 * ((2 * v92 - 1) & v94[7]);
          v97 = (char *)&v88[v96];
          v98 = *((_DWORD *)v97 + 1) + 1;
          *((_DWORD *)v97 + 1) = v98;
          if ( v98 > *(_DWORD *)(v91 + 24) )
          {
            ++*(_DWORD *)(v91 + 28);
            *((_DWORD *)v97 + 2) = *((_DWORD *)v97 + 1) / *(_DWORD *)(v47[2] + 24);
          }
          v94[3] = 0;
          v94[4] = v88[v96];
          v99 = v88[v96];
          if ( v99 )
            *(_DWORD *)(v99 + 12) = v94;
          v88[v96] = v94;
          v91 = v47[2];
          if ( !v95 )
            break;
          v92 = *(_DWORD *)(v91 + 4);
          v94 = v95;
        }
        v92 = *(_DWORD *)(v91 + 4);
      }
      v93 += 12;
    }
  }
  free(*(void **)v91);
  *(_DWORD *)(v47[2] + 4) *= 2;
  ++*(_DWORD *)(v47[2] + 8);
  *(_DWORD *)v47[2] = v88;
  v100 = (_DWORD *)v47[2];
  v101 = v100[7];
  v102 = v100[3];
  v103 = v101 > v102 >> 1;
  if ( v101 <= v102 >> 1 )
    v104 = 0;
  else
    v104 = v100[8];
  if ( v103 )
    ++v104;
  v100[8] = v104;
  v105 = v47[2];
  if ( *(_DWORD *)(v105 + 32) > 1u )
    *(_DWORD *)(v105 + 36) = 1;
  if ( pthread_rwlock_wrlock(&devices_lock) )
    goto LABEL_81;
LABEL_28:
  devices = (cgpu_info **)realloc(devices, 4 * (total_devices + new_devices + 2));
  if ( pthread_rwlock_unlock(&devices_lock) )
    rw_unlock((pthread_rwlock_t *)(&_func___17121.__align + 4), (const char *)0x28CE, v37, v38);
  selective_yield();
  if ( pthread_mutex_lock(&stats_lock) )
    mutex_lock((pthread_mutex_t *)(&_func___17121.__align + 4), (const char *)0x28D0, v39, v40);
  a1->last_device_valid_work = time(0);
  if ( pthread_mutex_unlock(&stats_lock) )
    mutex_unlock_noyield((pthread_mutex_t *)(&_func___17121.__align + 4), (const char *)0x28D2, v41, v42);
  selective_yield();
  if ( hotplug_mode )
  {
    v43 = new_devices + total_devices;
    ++new_devices;
  }
  else
  {
    v43 = total_devices++;
  }
  devices[v43] = a1;
  if ( total_devices - zombie_devs > most_devices )
    most_devices = total_devices - zombie_devs;
  return 1;
}
// 2670C: variable 'v35' is possibly undefined
// 2670C: variable 'v36' is possibly undefined
// 26794: variable 'v37' is possibly undefined
// 26794: variable 'v38' is possibly undefined
// 2679E: variable 'v39' is possibly undefined
// 2679E: variable 'v40' is possibly undefined
// 267A8: variable 'v41' is possibly undefined
// 267A8: variable 'v42' is possibly undefined
// 6F39C: using guessed type int devids_17132;

//----- (000267B8) --------------------------------------------------------
device_drv *__fastcall copy_drv(device_drv *drv)
{
  device_drv *v2; // r0
  device_drv *v3; // r4
  const char *v5; // r1
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = (device_drv *)malloc(0x80u);
  if ( !v2 )
  {
    v5 = "original";
    if ( drv->copy )
      v5 = "copy";
    snprintf(tmp42, 0x1000u, "Failed to allocate device_drv copy of %s (%s)", drv->name, v5);
    applog(3, tmp42, 1);
    _quit(1, 1);
  }
  v3 = v2;
  memcpy(v2, drv, sizeof(device_drv));
  v3->copy = 1;
  return v3;
}

//----- (00026828) --------------------------------------------------------
int no_yield()
{
  return 0;
}

//----- (0002682C) --------------------------------------------------------
send_ret __fastcall _stratum_send(pool *pool, char *s, ssize_t len)
{
  int v5; // r4
  size_t v6; // r0
  int sock; // r3
  int v8; // r9
  int v9; // r7
  int v10; // r7
  _BYTE *v11; // r7
  int v12; // r9
  int v13; // r8
  fd_set *p_tv_usec; // r3
  ssize_t v16; // r6
  ssize_t v17; // r0
  __int64 v18; // r2
  int bytes_sent; // r1
  int bytes_sent_high; // r5
  uint64_t v21; // kr08_8
  bool v22; // cf
  uint64_t v23; // r4
  unsigned int net_bytes_sent; // r1
  uint64_t v25; // kr10_8
  ssize_t lena; // [sp+8h] [bp-9Ch]
  ssize_t ssent; // [sp+Ch] [bp-98h]
  timeval timeout; // [sp+18h] [bp-8Ch] BYREF
  fd_set wd; // [sp+20h] [bp-84h] BYREF
  _BYTE v31[4]; // [sp+A0h] [bp-4h] BYREF

  v5 = len + 1;
  v6 = strlen(s);
  sock = pool->sock;
  lena = v5;
  *(_WORD *)&s[v6] = 10;
  if ( v5 <= 0 )
  {
    v18 = 0;
LABEL_17:
    bytes_sent = pool->cgminer_pool_stats.bytes_sent;
    bytes_sent_high = HIDWORD(pool->cgminer_pool_stats.bytes_sent);
    v21 = pool->cgminer_pool_stats.times_sent + 1;
    ++LODWORD(pool->cgminer_pool_stats.times_sent);
    v22 = __CFADD__(bytes_sent, (_DWORD)v18);
    LODWORD(v23) = bytes_sent + v18;
    net_bytes_sent = pool->cgminer_pool_stats.net_bytes_sent;
    HIDWORD(pool->cgminer_pool_stats.times_sent) = HIDWORD(v21);
    HIDWORD(v23) = bytes_sent_high + v22 + HIDWORD(v18);
    v25 = __PAIR64__(HIDWORD(pool->cgminer_pool_stats.net_bytes_sent), net_bytes_sent) + v18;
    pool->cgminer_pool_stats.bytes_sent = v23;
    pool->cgminer_pool_stats.net_bytes_sent = v25;
    return send_ret::SEND_OK;
  }
  else
  {
    LOBYTE(v8) = sock & 0x1F;
    v9 = (sock + 31) & (sock >> 31);
    if ( sock >= 0 )
      v9 = sock;
    v10 = v9 >> 5;
    if ( sock <= 0 )
      v8 = -(-sock & 0x1F);
    v11 = &v31[4 * v10];
    v12 = 1 << v8;
    v13 = sock + 1;
    ssent = 0;
    do
    {
      while ( 1 )
      {
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        while ( 1 )
        {
          p_tv_usec = (fd_set *)&timeout.tv_usec;
          do
          {
            p_tv_usec->fds_bits[1] = 0;
            p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
          }
          while ( p_tv_usec != (fd_set *)&wd.fds_bits[31] );
          *((_DWORD *)v11 - 32) |= v12;
          if ( select(v13, 0, &wd, 0, &timeout) > 0 )
            break;
          if ( *_errno_location() != 4 )
            return send_ret::SEND_SELECTFAIL;
        }
        v16 = ssent;
        v17 = send(pool->sock, &s[ssent], lena, 0x4000);
        if ( v17 < 0 )
          break;
        ssent += v17;
        lena -= v17;
        if ( lena <= 0 )
        {
          HIDWORD(v18) = ssent >> 31;
          LODWORD(v18) = v16 + v17;
          goto LABEL_17;
        }
      }
    }
    while ( *_errno_location() == 11 );
    return send_ret::SEND_SENDFAIL;
  }
}

//----- (00026958) --------------------------------------------------------
bool __fastcall http_negotiate(pool *pool, int sockd, bool http0)
{
  char *sockaddr_url; // r0
  size_t v6; // r0
  ssize_t v7; // r0
  _BOOL4 v8; // r3
  int v9; // r7
  int v10; // r3
  bool v11; // r4
  char buf[1024]; // [sp+10h] [bp-1400h] BYREF
  char tmp42[4096]; // [sp+410h] [bp-1000h] BYREF

  sockaddr_url = pool->sockaddr_url;
  if ( http0 )
    snprintf(buf, 0x400u, "CONNECT %s:%s HTTP/1.0\r\n\r\n", sockaddr_url, pool->stratum_port);
  else
    snprintf(
      buf,
      0x400u,
      "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\n\r\n",
      sockaddr_url,
      pool->stratum_port,
      sockaddr_url,
      pool->stratum_port);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Sending proxy %s:%s - %s", pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);
    applog(7, tmp42, 0);
  }
  v6 = strlen(buf);
  send(sockd, buf, v6, 0);
  v7 = recv(sockd, buf, 0xCu, 0);
  if ( v7 > 0 )
  {
    v8 = opt_debug;
    buf[v7] = 0;
    if ( v8 && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        tmp42,
        0x1000u,
        "Received from proxy %s:%s - %s",
        pool->sockaddr_proxy_url,
        pool->sockaddr_proxy_port,
        buf);
      applog(7, tmp42, 0);
    }
    v9 = strcmp(buf, "HTTP/1.1 200");
    if ( v9 )
    {
      v9 = strcmp(buf, "HTTP/1.0 200");
      if ( v9 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(
            tmp42,
            0x1000u,
            "HTTP Error from proxy %s:%s - %s",
            pool->sockaddr_proxy_url,
            pool->sockaddr_proxy_port,
            buf);
          applog(4, tmp42, 0);
          return 0;
        }
        return 0;
      }
    }
    do
    {
      if ( recv(sockd, tmp42, 1u, 0) == -1 )
      {
        buf[v9] = -1;
        goto LABEL_31;
      }
      v10 = (unsigned __int8)tmp42[0];
      buf[v9++] = tmp42[0];
      if ( v10 == 255 )
        goto LABEL_31;
    }
    while ( v9 != 4 );
    if ( !strncmp(buf, "\r\n\r\n", 4u) )
    {
LABEL_20:
      v11 = opt_debug;
      if ( !opt_debug )
        return 1;
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        snprintf(
          tmp42,
          0x1000u,
          "Success negotiating with %s:%s HTTP proxy",
          pool->sockaddr_proxy_url,
          pool->sockaddr_proxy_port);
        applog(7, tmp42, 0);
      }
      return v11;
    }
    while ( 1 )
    {
      buf[0] = buf[1];
      buf[1] = buf[2];
      buf[2] = buf[3];
      if ( recv(sockd, tmp42, 1u, 0) == -1 )
        break;
      buf[3] = tmp42[0];
      if ( (unsigned __int8)tmp42[0] == 255 )
        goto LABEL_31;
      if ( !strncmp(buf, "\r\n\r\n", 4u) )
        goto LABEL_20;
    }
    buf[3] = -1;
LABEL_31:
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      v11 = 0;
      snprintf(
        tmp42,
        0x1000u,
        "Couldn't read HTTP byte from proxy %s:%s",
        pool->sockaddr_proxy_url,
        pool->sockaddr_proxy_port);
      applog(4, tmp42, 0);
      return v11;
    }
    return 0;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
    return 0;
  snprintf(
    tmp42,
    0x1000u,
    "Couldn't read from proxy %s:%s after sending CONNECT",
    pool->sockaddr_proxy_url,
    pool->sockaddr_proxy_port);
  applog(4, tmp42, 0);
  return 0;
}

//----- (00026CBC) --------------------------------------------------------
void __fastcall _suspend_stratum(pool *pool)
{
  char *sockbuf; // r3
  int sock; // r0

  sockbuf = pool->sockbuf;
  if ( sockbuf )
    *sockbuf = 0;
  sock = pool->sock;
  pool->stratum_notify = 0;
  pool->stratum_active = 0;
  if ( sock )
    close(sock);
  pool->sock = 0;
}

//----- (00026CE8) --------------------------------------------------------
void __fastcall block_socket(int fd)
{
  unsigned int v2; // r2

  v2 = fcntl(fd, 3, 0) & 0xFFFFF7FF;
  j_fcntl(fd, 4, v2);
}

//----- (00026D04) --------------------------------------------------------
bool __fastcall socks4_negotiate(pool *pool, int sockd, bool socks4a)
{
  _BOOL4 v5; // r8
  char *stratum_port; // r0
  __int16 v7; // kr00_2
  unsigned int v8; // r6
  char *sockaddr_url; // r0
  char *v11; // r8
  size_t v12; // r0
  size_t v13; // r6
  int v14; // r4
  unsigned int v15; // r6
  addrinfo *servinfo; // [sp+8h] [bp-1228h] BYREF
  addrinfo servinfobase; // [sp+Ch] [bp-1224h] BYREF
  char buf[515]; // [sp+2Ch] [bp-1204h] BYREF
  char tmp42[4096]; // [sp+230h] [bp-1000h] BYREF

  v5 = socks4a;
  stratum_port = pool->stratum_port;
  *(_WORD *)buf = 260;
  v7 = strtol(stratum_port, 0, 10);
  buf[2] = HIBYTE(v7);
  buf[3] = v7;
  strcpy(&buf[8], "CGMINER");
  v8 = bswap32(inet_addr(pool->sockaddr_url));
  if ( v8 != -1 )
    goto LABEL_2;
  servinfo = &servinfobase;
  memset(tmp42, 0, 0x20u);
  sockaddr_url = pool->sockaddr_url;
  *(_DWORD *)&tmp42[4] = 2;
  if ( !getaddrinfo(sockaddr_url, 0, (const struct addrinfo *)tmp42, &servinfo) )
  {
    v15 = *(_DWORD *)&servinfo->ai_addr->sa_data[2];
    freeaddrinfo(servinfo);
    v8 = bswap32(v15);
    if ( v8 != -1 )
    {
LABEL_2:
      buf[7] = v8;
      buf[4] = HIBYTE(v8);
      buf[5] = BYTE2(v8);
      buf[6] = BYTE1(v8);
      send(sockd, buf, 0x10u, 0);
      goto LABEL_3;
    }
LABEL_22:
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(tmp42, 0x1000u, "Invalid IP address specified for socks4 proxy: %s", pool->sockaddr_url);
      goto LABEL_9;
    }
    return 0;
  }
  if ( !v5 )
    goto LABEL_22;
  v11 = pool->sockaddr_url;
  *(_DWORD *)&buf[4] = 0x1000000;
  v12 = strlen(v11);
  if ( v12 >= 0xFF )
    v12 = 255;
  v13 = v12;
  memcpy(&buf[16], v11, v12);
  buf[v13 + 16] = 0;
  send(sockd, buf, v13 + 17, 0);
LABEL_3:
  if ( recv(sockd, tmp42, 1u, 0) == -1 || tmp42[0] || recv(sockd, tmp42, 1u, 0) == -1 || tmp42[0] != 90 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "Bad response from %s:%s SOCKS4 server",
        pool->sockaddr_proxy_url,
        pool->sockaddr_proxy_port);
LABEL_9:
      applog(4, tmp42, 0);
      return 0;
    }
    return 0;
  }
  v14 = 6;
  do
  {
    recv(sockd, tmp42, 1u, 0);
    --v14;
  }
  while ( v14 );
  return 1;
}

//----- (00026EDC) --------------------------------------------------------
// Alternative name is 'socket_full.isra.2'
bool __fastcall socket_full(int pool, int wait)
{
  __time_t v2; // r1
  fd_set *p_tv_usec; // r3
  signed int v4; // r4
  _BYTE *v5; // r4
  int v6; // r3
  timeval timeout; // [sp+8h] [bp-8Ch] BYREF
  fd_set rd; // [sp+10h] [bp-84h] BYREF
  _BYTE v10[4]; // [sp+90h] [bp-4h] BYREF

  v2 = wait & ~(wait >> 31);
  p_tv_usec = (fd_set *)&timeout.tv_usec;
  do
  {
    p_tv_usec->fds_bits[1] = 0;
    p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
  }
  while ( &rd.fds_bits[31] != (__fd_mask *)p_tv_usec );
  timeout.tv_sec = v2;
  v4 = (pool + 31) & (pool >> 31);
  if ( pool >= 0 )
    v4 = pool;
  timeout.tv_usec = 0;
  v5 = &v10[4 * (v4 >> 5)];
  LOBYTE(v6) = pool & 0x1F;
  if ( pool <= 0 )
    v6 = -(-pool & 0x1F);
  *((_DWORD *)v5 - 32) |= 1 << v6;
  return select(pool + 1, &rd, 0, 0, &timeout) > 0;
}

//----- (00026F44) --------------------------------------------------------
char *__fastcall _json_array_string(json_t *val, unsigned int entry)
{
  json_t *v4; // r0

  if ( !val )
    return 0;
  if ( val->type == JSON_ARRAY && json_array_size(val) >= entry )
  {
    v4 = json_array_get(val, entry);
    if ( v4 )
    {
      if ( v4->type == JSON_STRING )
        return (char *)json_string_value(v4);
    }
  }
  return 0;
}

//----- (00026F7C) --------------------------------------------------------
char *__fastcall json_array_string(json_t *val, unsigned int entry)
{
  char *result; // r0

  result = _json_array_string(val, entry);
  if ( result )
    return j___strdup(result);
  return result;
}

//----- (00026F90) --------------------------------------------------------
// Alternative name is '_cgsem_post.part.8'
void __fastcall __noreturn cgsem_post_0(cgsem_t *cgsem, const char *file, const char *func, const int line)
{
  int *v8; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v8 = _errno_location();
  snprintf(tmp42, 0x1000u, "Failed to sem_post errno=%d cgsem=0x%p in %s %s():%d", *v8, cgsem, file, func, line);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (00026FD8) --------------------------------------------------------
// Alternative name is '_mutex_unlock_noyield.constprop.14'
void __fastcall mutex_unlock_noyield_0(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_mutex_unlock(lock) )
  {
    v6 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "util.c", file, func);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00027030) --------------------------------------------------------
// Alternative name is '_mutex_lock.part.1.constprop.15'
void __fastcall __noreturn mutex_lock_0(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "util.c", (const char *)lock, file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0002707C) --------------------------------------------------------
void __fastcall clear_sock(pool *pool)
{
  pthread_mutex_t *p_stratum_lock; // r5
  const char *v3; // r2
  int v4; // r3
  int v5; // r3
  int sock; // r0
  char *sockbuf; // r3

  p_stratum_lock = &pool->stratum_lock;
  if ( pthread_mutex_lock(&pool->stratum_lock) )
    mutex_lock_0((pthread_mutex_t *)"clear_sock", (const char *)0x7A3, v3, v4);
  do
  {
    v5 = 0;
    sock = pool->sock;
  }
  while ( sock && recv(sock, pool->sockbuf, 0x1FFCu, 0) > 0 );
  mutex_unlock_noyield_0(p_stratum_lock, "clear_sock", (const char *)0x7AC, v5);
  selective_yield();
  sockbuf = pool->sockbuf;
  if ( sockbuf )
    *sockbuf = 0;
}
// 270E0: variable 'v3' is possibly undefined
// 270E0: variable 'v4' is possibly undefined
// 270B8: variable 'v5' is possibly undefined

//----- (000270E8) --------------------------------------------------------
void __fastcall tq_freezethaw(thread_q *tq, bool frozen)
{
  pthread_mutex_t *p_mutex; // r5
  const char *v5; // r2
  int v6; // r3
  int v7; // r3

  p_mutex = &tq->mutex;
  if ( pthread_mutex_lock(&tq->mutex) )
    mutex_lock_0((pthread_mutex_t *)&_func___11739, (const char *)0x4D4, v5, v6);
  tq->frozen = frozen;
  pthread_cond_signal(&tq->cond);
  mutex_unlock_noyield_0(p_mutex, (const char *)&_func___11739, (const char *)0x4D7, v7);
  selective_yield();
}
// 2710C: variable 'v7' is possibly undefined
// 27126: variable 'v5' is possibly undefined
// 27126: variable 'v6' is possibly undefined

//----- (00027130) --------------------------------------------------------
const char *__fastcall proxytype(proxytypes_t a1)
{
  unsigned int *p_nusers; // r3
  const char *v2; // r2

  if ( !a1 )
    return "http:";
  p_nusers = &_func___11739.__data.__nusers;
  v2 = "http0:";
  while ( 1 )
  {
    p_nusers += 2;
    if ( p_nusers[1] == a1 )
      break;
    v2 = (const char *)p_nusers[2];
    if ( !v2 )
      return "invalid";
  }
  return v2;
}

//----- (00027164) --------------------------------------------------------
void __fastcall _bin2hex(char *s, const unsigned __int8 *p, size_t len)
{
  const unsigned __int8 *v3; // r6
  const unsigned __int8 *v4; // r1
  char *v5; // r4
  unsigned int v6; // t1

  if ( (int)len <= 0 )
  {
    *s = 0;
  }
  else
  {
    v3 = &p[len - 1];
    v4 = p - 1;
    v5 = s + 2;
    do
    {
      v6 = *++v4;
      v5 += 2;
      *(v5 - 4) = _func___12024[(v6 >> 4) + 84];
      *(v5 - 3) = _func___12024[(*v4 & 0xF) + 84];
    }
    while ( v4 != v3 );
    s[2 * len] = 0;
  }
}

//----- (000271B4) --------------------------------------------------------
char *__fastcall bin2hex(const unsigned __int8 *p, size_t len)
{
  size_t v2; // r5
  size_t v5; // r3
  char *v6; // r0
  char *v7; // r6
  char *v8; // r5
  const unsigned __int8 *v9; // r0
  char *v10; // r2
  unsigned int v11; // t1
  char v12; // r3
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  v2 = 2 * len;
  v5 = (2 * len + 1) & 3;
  if ( (int)(2 * len + 1) <= 0 )
    v5 = -(-(2 * len + 1) & 3);
  v6 = (char *)calloc(v2 + 1 + 4 - v5, 1u);
  v7 = v6;
  if ( !v6 )
  {
    snprintf(tmp42, 0x1000u, "Failed to calloc in %s %s():%d", "util.c", "bin2hex", 920);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( (int)len > 0 )
  {
    v9 = p - 1;
    v10 = v7 + 2;
    do
    {
      v11 = *++v9;
      v10 += 2;
      v12 = _func___12024[(v11 >> 4) + 84];
      *(v10 - 3) = _func___12024[(v11 & 0xF) + 84];
      *(v10 - 4) = v12;
    }
    while ( v9 != &p[len - 1] );
    v8 = &v7[v2];
  }
  else
  {
    v8 = v6;
  }
  *v8 = 0;
  return v7;
}

//----- (00027270) --------------------------------------------------------
bool __fastcall hex2bin(unsigned __int8 *p, const char *hexstr, size_t len)
{
  unsigned int v4; // r3
  unsigned int v5; // r4
  _BOOL4 v6; // r0
  const char *v7; // r1
  const char *v8; // r4
  int v9; // r3
  char tmp42[4096]; // [sp+0h] [bp-1018h] BYREF

  if ( !*hexstr )
  {
    if ( !len )
    {
      LOBYTE(v6) = 1;
      return v6;
    }
    goto LABEL_23;
  }
  if ( !len )
  {
LABEL_23:
    LOBYTE(v6) = 0;
    return v6;
  }
  if ( hexstr[1] )
  {
    v4 = *(_DWORD *)&_func___12024[4 * *((unsigned __int8 *)hexstr + 1) + 108];
    v5 = *(_DWORD *)&_func___12024[4 * *(unsigned __int8 *)hexstr + 108];
    v6 = (v4 >> 31) | (v5 >> 31);
    if ( v6 )
    {
LABEL_11:
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        strcpy(tmp42, "hex2bin scan failed");
        applog(3, tmp42, 0);
        LOBYTE(v6) = 0;
        return v6;
      }
    }
    else
    {
      v7 = hexstr + 4;
      while ( 1 )
      {
        --len;
        *p++ = v4 | (16 * v5);
        v8 = &_func___12024[4 * *((unsigned __int8 *)v7 - 2)];
        if ( !*(v7 - 2) )
          break;
        if ( !len )
          return v6;
        v9 = *((unsigned __int8 *)v7 - 1);
        v7 += 2;
        if ( !v9 )
          goto LABEL_16;
        v5 = *((_DWORD *)v8 + 27);
        v4 = *(_DWORD *)&_func___12024[4 * v9 + 108];
        if ( ((v5 | v4) & 0x80000000) != 0 )
          goto LABEL_11;
      }
      if ( !len )
      {
        LOBYTE(v6) = 1;
        return v6;
      }
    }
  }
  else
  {
LABEL_16:
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(tmp42, "hex2bin str truncated");
      applog(3, tmp42, 0);
    }
  }
  LOBYTE(v6) = 0;
  return v6;
}

//----- (00027394) --------------------------------------------------------
bool __fastcall parse_extranonce_equihash(pool *pool, json_t *val, int type)
{
  char *v4; // r0
  char *v5; // r5
  size_t v6; // r3
  unsigned __int8 *nonce1bin; // r0
  size_t n1_len; // r6
  unsigned __int8 *v9; // r0
  size_t v10; // r3
  int *v11; // r0
  int *v12; // r0
  int *v13; // r0
  int *v14; // r0
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  v4 = json_array_string(val, type);
  v5 = v4;
  if ( v4 )
  {
    if ( pthread_mutex_lock(&pool->data_lock.mutex) )
    {
      v11 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
        *v11,
        "util.c",
        "parse_extranonce_equihash",
        2522);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
    {
      v12 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
        *v12,
        "util.c",
        "parse_extranonce_equihash",
        2522);
      applog(3, tmp42, 1);
      quit(1);
    }
    free(pool->nonce1);
    pool->nonce1 = v5;
    v6 = strlen(v5) >> 1;
    nonce1bin = pool->nonce1bin;
    pool->n1_len = v6;
    free(nonce1bin);
    n1_len = pool->n1_len;
    v9 = (unsigned __int8 *)calloc(n1_len, 1u);
    pool->nonce1bin = v9;
    if ( !v9 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s: Failed to calloc pool->nonce1bin in %s %s():%d",
        "parse_extranonce_equihash",
        "util.c",
        "parse_extranonce_equihash",
        2530);
      applog(3, tmp42, 1);
      quit(1);
    }
    hex2bin(v9, pool->nonce1, n1_len);
    v10 = pool->n1_len;
    pool->nonce2 = 0;
    pool->n2size = 64 - v10;
    if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
    {
      v13 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v13,
        "util.c",
        "parse_extranonce_equihash",
        2536);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
    {
      v14 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v14,
        "util.c",
        "parse_extranonce_equihash",
        2536);
      applog(3, tmp42, 1);
      quit(1);
    }
    selective_yield();
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      snprintf(tmp42, 0x1000u, "Pool %d extranonce set to %s", pool->pool_no, v5);
      applog(6, tmp42, 0);
      LOBYTE(v4) = 1;
    }
    else
    {
      LOBYTE(v4) = 1;
    }
  }
  return (char)v4;
}

//----- (000275E8) --------------------------------------------------------
void __fastcall b58tobin(unsigned __int8 *b58bin, const char *b58)
{
  uint32_t v2; // r4
  size_t v5; // r0
  unsigned __int8 v6; // r1
  const char *v7; // lr
  const char *v8; // r12
  int v9; // t1
  uint32_t *v10; // r2
  unsigned int v11; // r0
  __int64 v12; // r0
  unsigned __int8 *v13; // r3
  uint32_t *v14; // r2
  unsigned __int8 *v15; // r7
  unsigned int v16; // t1
  int v17; // [sp+0h] [bp-20h] BYREF
  uint32_t bin32[7]; // [sp+4h] [bp-1Ch] BYREF

  v2 = 0;
  memset(bin32, 0, sizeof(bin32));
  v5 = strlen(b58);
  v6 = v5;
  if ( v5 )
  {
    v7 = b58 - 1;
    v8 = &b58[v5 - 1];
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)++v7;
      v10 = &bin32[6];
      v11 = *(_DWORD *)&_func___12024[4 * v9 + 1160];
      while ( 1 )
      {
        v12 = 58LL * v2 + v11;
        *v10-- = v12;
        v11 = HIDWORD(v12);
        if ( &v17 == (int *)v10 )
          break;
        v2 = *v10;
      }
      if ( v8 == v7 )
        break;
      v2 = bin32[6];
    }
    v6 = bin32[0];
    v5 = bswap32(bin32[1]);
  }
  v13 = b58bin + 1;
  v14 = &bin32[1];
  *b58bin = v6;
  v15 = b58bin + 25;
  while ( 1 )
  {
    *(_DWORD *)v13 = v5;
    v13 += 4;
    if ( v13 == v15 )
      break;
    v16 = v14[1];
    ++v14;
    v5 = bswap32(v16);
  }
}

//----- (00027670) --------------------------------------------------------
void __fastcall address_to_pubkeyhash(unsigned __int8 *pkh, const char *addr)
{
  int v3; // t1
  int v4; // r7
  int v5; // r6
  int v6; // r1
  unsigned __int8 b58bin[28]; // [sp+4h] [bp-20h] BYREF

  memset(b58bin, 0, 25);
  b58tobin(b58bin, addr);
  pkh[2] = 20;
  v3 = *(_DWORD *)&b58bin[1];
  *pkh = 118;
  pkh[1] = -87;
  *(_DWORD *)(pkh + 3) = v3;
  v4 = *(_DWORD *)&b58bin[9];
  v5 = *(_DWORD *)&b58bin[13];
  *(_DWORD *)(pkh + 7) = *(_DWORD *)&b58bin[5];
  v6 = *(_DWORD *)&b58bin[17];
  *(_DWORD *)(pkh + 11) = v4;
  *(_DWORD *)(pkh + 15) = v5;
  *(_DWORD *)(pkh + 19) = v6;
  pkh[23] = -120;
  pkh[24] = -84;
}

//----- (000276C8) --------------------------------------------------------
int __fastcall ser_number(unsigned __int8 *s, int32_t val)
{
  unsigned __int8 v3; // r2
  int result; // r0

  if ( val > 127 )
  {
    if ( val >= 16512 )
    {
      if ( val <= 2113663 )
        result = 4;
      else
        result = 5;
      if ( val <= 2113663 )
        v3 = 3;
      else
        v3 = 4;
    }
    else
    {
      result = 3;
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
    result = 2;
  }
  *(_DWORD *)(s + 1) = val;
  *s = v3;
  return result;
}

//----- (000276FC) --------------------------------------------------------
unsigned __int8 *__fastcall ser_string(char *s, int *slen)
{
  size_t v4; // r4
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r5
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  v4 = strlen(s);
  v5 = (unsigned __int8 *)malloc(v4 + 9);
  v6 = v5;
  if ( !v5 )
  {
    strcpy(tmp42, "Failed to malloc ret in ser_string");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( v4 <= 0xFC )
  {
    *v5 = v4;
    memcpy(v5 + 1, s, v4);
    *slen = v4 + 1;
    return v6;
  }
  else
  {
    if ( v4 < 0x10000 )
    {
      *v5 = -3;
      *(_WORD *)(v5 + 1) = __rev16(v4);
      memcpy(v5 + 3, s, v4);
      *slen = v4 + 3;
    }
    else
    {
      *v5 = -2;
      *(_DWORD *)(v5 + 1) = bswap32(v4);
      memcpy(v5 + 5, s, v4);
      *slen = v4 + 5;
    }
    return v6;
  }
}

//----- (000277C0) --------------------------------------------------------
bool __fastcall fulltest(const unsigned __int8 *hash, const unsigned __int8 *target)
{
  const unsigned __int8 *v2; // r3
  const unsigned __int8 *v3; // r2
  unsigned int v4; // r5
  unsigned int v5; // t1
  unsigned int v6; // t1
  bool v7; // cf
  _BOOL4 v8; // r5
  __int64 v10; // kr00_8
  unsigned int v11; // r6
  unsigned int v12; // r2
  __int64 v13; // kr08_8
  __int64 v14; // r6
  unsigned int v15; // r2
  unsigned int v16; // r3
  unsigned int v17; // r2
  unsigned int v18; // r3
  unsigned int v19; // r12
  __int64 v20; // kr10_8
  char *v21; // r7
  char *v22; // r0
  char *v23; // r6
  const char *v24; // r3
  unsigned __int8 hash_swap[32]; // [sp+8h] [bp-1044h] BYREF
  unsigned __int8 target_swap[32]; // [sp+28h] [bp-1024h] BYREF
  char tmp42[4100]; // [sp+48h] [bp-1004h] BYREF

  v2 = hash + 32;
  v3 = target + 32;
  while ( 1 )
  {
    v5 = *((_DWORD *)v2 - 1);
    v2 -= 4;
    v4 = v5;
    v6 = *((_DWORD *)v3 - 1);
    v3 -= 4;
    v7 = v4 >= v6;
    if ( v4 > v6 )
      break;
    if ( !v7 || hash == v2 )
    {
      v8 = 1;
      goto LABEL_7;
    }
  }
  v8 = 0;
LABEL_7:
  if ( !opt_debug )
    return v8;
  v10 = *((_QWORD *)hash + 3);
  v11 = *((_DWORD *)hash + 5);
  *(_DWORD *)hash_swap = bswap32(HIDWORD(v10));
  v12 = *((_DWORD *)hash + 4);
  *(_DWORD *)&hash_swap[4] = bswap32(v10);
  *(_DWORD *)&hash_swap[8] = bswap32(v11);
  v13 = *((_QWORD *)hash + 1);
  *(_DWORD *)&hash_swap[12] = bswap32(v12);
  v14 = *(_QWORD *)hash;
  v15 = *((_DWORD *)target + 7);
  *(_DWORD *)&hash_swap[20] = bswap32(v13);
  v16 = *((_DWORD *)target + 6);
  *(_DWORD *)&hash_swap[24] = bswap32(HIDWORD(v14));
  *(_DWORD *)&hash_swap[28] = bswap32(v14);
  LODWORD(v14) = *((_DWORD *)target + 5);
  HIDWORD(v14) = bswap32(v16);
  *(_DWORD *)target_swap = bswap32(v15);
  v17 = *((_DWORD *)target + 3);
  v18 = bswap32(v14);
  LODWORD(v14) = *((_DWORD *)target + 4);
  *(_DWORD *)&hash_swap[16] = bswap32(HIDWORD(v13));
  *(_DWORD *)&target_swap[4] = HIDWORD(v14);
  v19 = bswap32(v14);
  *(_DWORD *)&target_swap[8] = v18;
  LODWORD(v14) = *((_DWORD *)target + 2);
  v20 = *(_QWORD *)target;
  *(_DWORD *)&target_swap[12] = v19;
  *(_DWORD *)&target_swap[16] = bswap32(v17);
  *(_DWORD *)&target_swap[24] = bswap32(HIDWORD(v20));
  *(_DWORD *)&target_swap[28] = bswap32(v20);
  *(_DWORD *)&target_swap[20] = bswap32(v14);
  v21 = bin2hex(hash_swap, 0x20u);
  v22 = bin2hex(target_swap, 0x20u);
  v23 = v22;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v24 = "YES (hash <= target)";
    if ( !v8 )
      v24 = "no (false positive; hash > target)";
    snprintf(tmp42, 0x1000u, " Proof: %s\nTarget: %s\nTrgVal? %s", v21, v22, v24);
    applog(7, tmp42, 0);
  }
  free(v21);
  free(v23);
  return v8;
}

//----- (000278F8) --------------------------------------------------------
thread_q *tq_new()
{
  char *v0; // r0
  char *v1; // r4

  v0 = (char *)calloc(1u, 0x58u);
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = v0;
    *((_DWORD *)v0 + 1) = v0;
    pthread_mutex_init((pthread_mutex_t *)(v0 + 12), 0);
    pthread_cond_init((pthread_cond_t *)(v1 + 40), 0);
  }
  return (thread_q *)v1;
}

//----- (00027920) --------------------------------------------------------
void __fastcall tq_free(thread_q *tq)
{
  list_head *next; // r2
  bool v3; // zf
  list_head **p_prev; // r0
  list_head **i; // r5
  list_head *v6; // r3

  if ( tq )
  {
    next = tq->q.next->next;
    v3 = tq == (thread_q *)tq->q.next;
    p_prev = &tq->q.next[-1].prev;
    for ( i = &next[-1].prev; !v3; i = &next[-1].prev )
    {
      v6 = p_prev[2];
      next->prev = v6;
      v6->next = next;
      free(p_prev);
      p_prev = i;
      next = i[1];
      v3 = i + 1 == (list_head **)tq;
    }
    pthread_cond_destroy(&tq->cond);
    pthread_mutex_destroy(&tq->mutex);
    sub_12000(tq);
  }
}

//----- (0002796C) --------------------------------------------------------
void __fastcall tq_freeze(thread_q *tq)
{
  tq_freezethaw(tq, 1);
}

//----- (00027974) --------------------------------------------------------
void __fastcall tq_thaw(thread_q *tq)
{
  tq_freezethaw(tq, 0);
}

//----- (0002797C) --------------------------------------------------------
bool __fastcall tq_push(thread_q *tq, void *data)
{
  _DWORD *v4; // r0
  _DWORD *v5; // r4
  list_head *v6; // r6
  const char *v7; // r2
  int v8; // r3
  list_head *prev; // r3
  char v10; // r7
  int v11; // r3

  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( v4 )
  {
    *v4 = data;
    v6 = (list_head *)(v4 + 1);
    v4[1] = v4 + 1;
    v4[2] = v4 + 1;
    if ( pthread_mutex_lock(&tq->mutex) )
      mutex_lock_0((pthread_mutex_t *)&_func___11752, (const char *)0x4F0, v7, v8);
    if ( tq->frozen )
    {
      v10 = 0;
      free(v5);
    }
    else
    {
      prev = tq->q.prev;
      v10 = 1;
      v5[1] = tq;
      tq->q.prev = v6;
      v5[2] = prev;
      prev->next = v6;
    }
    pthread_cond_signal(&tq->cond);
    mutex_unlock_noyield_0(&tq->mutex, (const char *)&_func___11752, (const char *)0x4FB, v11);
    selective_yield();
    LOBYTE(v4) = v10;
  }
  return (char)v4;
}
// 279C6: variable 'v11' is possibly undefined
// 279F4: variable 'v7' is possibly undefined
// 279F4: variable 'v8' is possibly undefined

//----- (00027A00) --------------------------------------------------------
void *__fastcall tq_pop(thread_q *tq, const timespec *abstime)
{
  pthread_mutex_t *p_mutex; // r6
  const char *v5; // r2
  int v6; // r3
  list_head *next; // r4
  list_head *prev; // r2
  list_head *v9; // r1
  list_head *v10; // r5
  list_head *v11; // r3
  pthread_cond_t *p_cond; // r0
  int v14; // r0

  p_mutex = &tq->mutex;
  if ( pthread_mutex_lock(&tq->mutex) )
    mutex_lock_0((pthread_mutex_t *)(&_func___11752.__align + 2), (const char *)0x506, v5, v6);
  next = tq->q.next;
  if ( tq == (thread_q *)tq->q.next )
  {
    p_cond = &tq->cond;
    if ( abstime )
      v14 = pthread_cond_timedwait(p_cond, p_mutex, abstime);
    else
      v14 = pthread_cond_wait(p_cond, p_mutex);
    if ( v14 )
    {
      v10 = 0;
      goto out_0;
    }
    v11 = tq->q.next;
    if ( next == tq->q.next )
    {
      v10 = 0;
      goto out_0;
    }
    next = tq->q.next;
  }
  prev = next->prev;
  v9 = next->next;
  v10 = next[-1].prev;
  v9->prev = prev;
  prev->next = v9;
  next->next = 0;
  next->prev = 0;
  free(&next[-1].prev);
out_0:
  mutex_unlock_noyield_0(p_mutex, &_func___11752.__size[8], (const char *)0x519, (const int)v11);
  selective_yield();
  return v10;
}
// 27A38: variable 'v11' is possibly undefined
// 27A74: variable 'v5' is possibly undefined
// 27A74: variable 'v6' is possibly undefined

//----- (00027A88) --------------------------------------------------------
void __fastcall thr_info_join(thr_info *thr)
{
  pthread_t pth; // r0
  cgsem_t *p_sem; // r0

  if ( thr )
  {
    pth = thr->pth;
    if ( pth )
    {
      pthread_join(pth, 0);
      p_sem = &thr->sem;
      thr->pth = 0;
    }
    else
    {
      p_sem = &thr->sem;
    }
    j_sem_destroy(p_sem);
  }
}

//----- (00027AB8) --------------------------------------------------------
void __fastcall thr_info_cancel(thr_info *thr)
{
  pthread_t pth; // r0
  cgsem_t *p_sem; // r0

  if ( thr )
  {
    pth = thr->pth;
    if ( pth )
    {
      pthread_cancel(pth);
      p_sem = &thr->sem;
      thr->pth = 0;
    }
    else
    {
      p_sem = &thr->sem;
    }
    j_sem_destroy(p_sem);
  }
}

//----- (00027AE4) --------------------------------------------------------
void __fastcall subtime(timeval *a, timeval *b)
{
  timeval v2; // kr00_8
  __time_t v3; // r2
  __suseconds_t v4; // r3
  timeval v5; // r2

  v2 = *b;
  v3 = a->tv_sec - b->tv_sec;
  b->tv_sec = v3;
  v4 = a->tv_usec - v2.tv_usec;
  b->tv_usec = v4;
  if ( v4 < 0 )
  {
    v5.tv_sec = v3 - 1;
    v5.tv_usec = v4 + 1000000;
    *b = v5;
  }
}

//----- (00027B10) --------------------------------------------------------
void __fastcall addtime(timeval *a, timeval *b)
{
  __suseconds_t tv_usec; // r5
  __time_t v3; // r2
  __suseconds_t v4; // r3
  timeval v5; // r2

  tv_usec = b->tv_usec;
  v3 = a->tv_sec + b->tv_sec;
  b->tv_sec = v3;
  v4 = a->tv_usec + tv_usec;
  b->tv_usec = v4;
  if ( v4 > 999999 )
  {
    v5.tv_usec = v4 - 1000000;
    v5.tv_sec = v3 + 1;
    *b = v5;
  }
}

//----- (00027B44) --------------------------------------------------------
bool __fastcall time_more(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec > b->tv_usec;
  else
    return a->tv_sec > b->tv_sec;
}

//----- (00027B64) --------------------------------------------------------
bool __fastcall time_less(timeval *a, timeval *b)
{
  if ( a->tv_sec == b->tv_sec )
    return a->tv_usec < b->tv_usec;
  else
    return a->tv_sec < b->tv_sec;
}

//----- (00027B84) --------------------------------------------------------
void __fastcall copy_time(timeval *dest, const timeval *src)
{
  __suseconds_t tv_usec; // r3

  tv_usec = src->tv_usec;
  dest->tv_sec = src->tv_sec;
  dest->tv_usec = tv_usec;
}

//----- (00027B90) --------------------------------------------------------
void __fastcall timespec_to_val(timeval *val, const timespec *spec)
{
  val->tv_sec = spec->tv_sec;
  val->tv_usec = spec->tv_nsec / 1000;
}

//----- (00027BB0) --------------------------------------------------------
void __fastcall timeval_to_spec(timespec *spec, const timeval *val)
{
  spec->tv_sec = val->tv_sec;
  spec->tv_nsec = 1000 * val->tv_usec;
}

//----- (00027BC4) --------------------------------------------------------
void __fastcall us_to_timeval(timeval *val, int a2, int64_t us)
{
  lldiv_t tvdiv; // [sp+8h] [bp-10h] BYREF

  lldiv(&tvdiv, a2, us, HIDWORD(us), 1000000, 0);
  *val = (timeval)__PAIR64__(tvdiv.rem, tvdiv.quot);
}
// 12570: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027BEC) --------------------------------------------------------
void __fastcall us_to_timespec(timespec *spec, int a2, int64_t us)
{
  timespec v4; // r2
  lldiv_t tvdiv; // [sp+8h] [bp-10h] BYREF

  lldiv(&tvdiv, a2, us, HIDWORD(us), 1000000, 0);
  v4.tv_sec = tvdiv.quot;
  v4.tv_nsec = 1000 * LODWORD(tvdiv.rem);
  *spec = v4;
}
// 12570: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027C1C) --------------------------------------------------------
void __fastcall ms_to_timespec(timespec *spec, int a2, int64_t ms)
{
  timespec v4; // r2
  lldiv_t tvdiv; // [sp+8h] [bp-10h] BYREF

  lldiv(&tvdiv, a2, ms, HIDWORD(ms), 1000, 0);
  v4.tv_sec = tvdiv.quot;
  v4.tv_nsec = 1000000 * LODWORD(tvdiv.rem);
  *spec = v4;
}
// 12570: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027C4C) --------------------------------------------------------
void __fastcall ms_to_timeval(timeval *val, int a2, int64_t ms)
{
  timeval v4; // r2
  lldiv_t tvdiv; // [sp+8h] [bp-10h] BYREF

  lldiv(&tvdiv, a2, ms, HIDWORD(ms), 1000, 0);
  v4.tv_sec = tvdiv.quot;
  v4.tv_usec = 1000 * LODWORD(tvdiv.rem);
  *val = v4;
}
// 12570: using guessed type int __fastcall lldiv(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027C78) --------------------------------------------------------
void __fastcall timeraddspec(timespec *a, const timespec *b)
{
  __syscall_slong_t tv_nsec; // r3
  __int64 v3; // r2
  __time_t v4; // r5
  __syscall_slong_t v5; // r1

  tv_nsec = a->tv_nsec;
  LODWORD(v3) = a->tv_sec + b->tv_sec;
  a->tv_sec = v3;
  HIDWORD(v3) = tv_nsec + b->tv_nsec;
  a->tv_nsec = HIDWORD(v3);
  if ( SHIDWORD(v3) <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        HIDWORD(v3) += 1000000000;
        LODWORD(v3) = v3 - 1;
      }
      while ( v3 < 0 );
      *a = (timespec)v3;
    }
  }
  else
  {
    v4 = v3 + 1;
    v5 = HIDWORD(v3) - 1000000000;
    if ( HIDWORD(v3) - 1000000000 > 999999999 )
    {
      v4 = v3 + 2;
      v5 = HIDWORD(v3) - 2000000000;
    }
    a->tv_sec = v4;
    a->tv_nsec = v5;
  }
}

//----- (00027CD4) --------------------------------------------------------
char *__fastcall Strcasestr(char *haystack, const char *needle)
{
  bool v2; // zf
  signed int v5; // r10
  signed int v6; // r9
  _BOOL4 v7; // r4
  const __int32_t **v8; // r0
  signed int v9; // r3
  const __int32_t *v10; // r12
  char *v11; // r0
  char *v12; // r2
  int v13; // t1
  const char *v14; // r2
  char *v15; // r0
  signed int v16; // r3
  int v17; // t1
  char *v18; // r0
  char v20[32]; // [sp+0h] [bp-20h] BYREF

  v2 = needle == 0;
  if ( needle )
    v2 = haystack == 0;
  if ( v2 )
    return 0;
  v5 = strlen(haystack);
  v6 = strlen(needle);
  if ( v5 )
    v7 = v6 == 0;
  else
    v7 = 1;
  if ( v7 )
    return 0;
  v8 = _ctype_tolower_loc();
  v9 = 0;
  v10 = *v8;
  v11 = &v20[-1];
  v12 = haystack - 1;
  do
  {
    v13 = (unsigned __int8)*++v12;
    ++v9;
    *++v11 = v10[v13];
  }
  while ( v9 < v5 );
  v14 = needle - 1;
  v15 = &v20[-1];
  v16 = 0;
  do
  {
    v17 = *(unsigned __int8 *)++v14;
    ++v16;
    *++v15 = v10[v17];
  }
  while ( v16 < v6 );
  v18 = strstr(v20, v20);
  if ( !v18 )
    return 0;
  else
    return &haystack[v18 - v20];
}

//----- (00027D7C) --------------------------------------------------------
char *__fastcall Strsep(char **stringp, const char *delim)
{
  char *v3; // r4
  char *v4; // r0

  v3 = *stringp;
  if ( *stringp && (v4 = strpbrk(*stringp, delim)) != 0 )
  {
    *v4 = 0;
    *stringp = v4 + 1;
    return v3;
  }
  else
  {
    *stringp = 0;
    return v3;
  }
}

//----- (00027DA0) --------------------------------------------------------
void __fastcall cgtime(timeval *tv)
{
  j_gettimeofday(tv, 0);
}

//----- (00027DA8) --------------------------------------------------------
int __fastcall cgtimer_to_ms(cgtimer_t *cgt)
{
  return cgt->tv_nsec / 1000000 + 1000 * cgt->tv_sec;
}

//----- (00027DCC) --------------------------------------------------------
void __fastcall cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)
{
  __time_t v3; // r3
  __syscall_slong_t tv_nsec; // r1
  __syscall_slong_t v5; // r0

  v3 = a->tv_sec - b->tv_sec;
  res->tv_sec = v3;
  tv_nsec = b->tv_nsec;
  v5 = a->tv_nsec - tv_nsec;
  if ( v5 >= 0 )
  {
    res->tv_nsec = v5;
  }
  else
  {
    tv_nsec = 1000000000;
    --v3;
  }
  if ( v5 < 0 )
  {
    res->tv_sec = v3;
    res->tv_nsec = tv_nsec + v5;
  }
}

//----- (00027DFC) --------------------------------------------------------
void __fastcall cgtimer_time(cgtimer_t *ts_start)
{
  j_clock_gettime(1, ts_start);
}

//----- (00027E04) --------------------------------------------------------
void __fastcall cgsleep_ms_r(cgtimer_t *ts_start, int ms)
{
  __syscall_slong_t v3; // r3
  __time_t v4; // r2
  __time_t v5; // r4
  __syscall_slong_t v6; // r1
  timespec ts_end; // [sp+0h] [bp-Ch] BYREF

  ms_to_timespec(&ts_end, ms, ms);
  v3 = ts_end.tv_nsec + ts_start->tv_nsec;
  v4 = ts_end.tv_sec + ts_start->tv_sec;
  ts_end.tv_sec = v4;
  ts_end.tv_nsec = v3;
  if ( v3 <= 999999999 )
  {
    if ( v3 < 0 )
    {
      do
      {
        v3 += 1000000000;
        --v4;
      }
      while ( v3 < 0 );
      ts_end.tv_sec = v4;
      ts_end.tv_nsec = v3;
    }
  }
  else
  {
    v5 = v4 + 1;
    v6 = v3 - 1000000000;
    if ( v3 - 1000000000 > 999999999 )
    {
      v5 = v4 + 2;
      v6 = v3 - 2000000000;
    }
    ts_end.tv_sec = v5;
    ts_end.tv_nsec = v6;
  }
  while ( clock_nanosleep(1, 1, &ts_end, 0) == 4 )
    ;
}

//----- (00027E80) --------------------------------------------------------
void __fastcall cgsleep_us_r(cgtimer_t *ts_start, int a2, int64_t us)
{
  __syscall_slong_t v4; // r3
  __time_t v5; // r2
  __time_t v6; // r4
  __syscall_slong_t v7; // r1
  timespec ts_end; // [sp+0h] [bp-Ch] BYREF

  us_to_timespec(&ts_end, a2, us);
  v4 = ts_end.tv_nsec + ts_start->tv_nsec;
  v5 = ts_end.tv_sec + ts_start->tv_sec;
  ts_end.tv_sec = v5;
  ts_end.tv_nsec = v4;
  if ( v4 <= 999999999 )
  {
    if ( v4 < 0 )
    {
      do
      {
        v4 += 1000000000;
        --v5;
      }
      while ( v4 < 0 );
      ts_end.tv_sec = v5;
      ts_end.tv_nsec = v4;
    }
  }
  else
  {
    v6 = v5 + 1;
    v7 = v4 - 1000000000;
    if ( v4 - 1000000000 > 999999999 )
    {
      v6 = v5 + 2;
      v7 = v4 - 2000000000;
    }
    ts_end.tv_sec = v6;
    ts_end.tv_nsec = v7;
  }
  while ( clock_nanosleep(1, 1, &ts_end, 0) == 4 )
    ;
}

//----- (00027EF8) --------------------------------------------------------
void __fastcall cgsleep_ms(int ms)
{
  cgtimer_t ts_start; // [sp+0h] [bp-8h] BYREF

  clock_gettime(1, &ts_start);
  cgsleep_ms_r(&ts_start, ms);
}

//----- (00027F14) --------------------------------------------------------
void __fastcall cgsleep_us(int64_t us)
{
  int v2; // r1
  cgtimer_t ts_start; // [sp+0h] [bp-Ch] BYREF

  clock_gettime(1, &ts_start);
  cgsleep_us_r(&ts_start, v2, us);
}
// 27F2A: variable 'v2' is possibly undefined

//----- (00027F34) --------------------------------------------------------
double __fastcall us_tdiff(timeval *end, timeval *start)
{
  double result; // r0

  if ( end->tv_sec - start->tv_sec <= 60 )
  {
    end = (timeval *)1000000;
    start = (timeval *)start->tv_usec;
  }
  LODWORD(result) = end;
  HIDWORD(result) = start;
  return result;
}

//----- (00027F68) --------------------------------------------------------
int __fastcall ms_tdiff(timeval *end, timeval *start)
{
  int v2; // r2

  v2 = end->tv_sec - start->tv_sec;
  if ( v2 > 3600 )
    return 3600000;
  else
    return (end->tv_usec - start->tv_usec) / 1000 + 1000 * v2;
}

//----- (00027FA4) --------------------------------------------------------
double __fastcall tdiff(timeval *end, timeval *start)
{
  double result; // r0

  HIDWORD(result) = start->tv_sec;
  LODWORD(result) = end;
  return result;
}

//----- (00027FE0) --------------------------------------------------------
void __fastcall check_extranonce_option(pool *pool, char *url)
{
  char *v3; // r0
  char *v4; // r4
  char extra_op[16]; // [sp+0h] [bp-1010h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  v3 = strchr(url, 35);
  if ( v3 )
  {
    if ( !pool->extranonce_subscribe )
    {
      v4 = v3;
      strcpy(extra_op, v3);
      *v4 = 0;
      if ( !strcmp(extra_op, "#xnsub") )
      {
        pool->extranonce_subscribe = 1;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42, 0x1000u, "Pool %d extranonce subscribing enabled.", pool->pool_no);
          applog(7, tmp42, 0);
        }
      }
    }
  }
}

//----- (00028080) --------------------------------------------------------
bool __fastcall extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)
{
  char *v4; // r4
  char *v6; // r0
  char *v7; // r6
  char *v8; // r0
  char v9; // r5
  int v10; // r5
  char *v11; // r6
  size_t v12; // r0
  int v13; // r3
  int v14; // r7
  char *v16; // r0
  char port[8]; // [sp+8h] [bp-10Ch] BYREF
  char url_address[260]; // [sp+10h] [bp-104h] BYREF

  v4 = url;
  *sockaddr_url = url;
  v6 = strstr(url, "//");
  if ( v6 )
    v4 = v6 + 2;
  v7 = strchr(v4, 91);
  v8 = strchr(v4, 93);
  v9 = (char)v8;
  if ( v8 )
    v9 = 1;
  if ( !v7 )
    v9 = 0;
  if ( v7 < v8 )
    v10 = v9 & 1;
  else
    v10 = 0;
  if ( !v10 )
    v8 = v4;
  v11 = strchr(v8, 58);
  v12 = strlen(v4);
  if ( v11 )
  {
    v13 = v11 - v4;
    v14 = ~(v11 - v4) + v12;
    if ( v14 <= 0 )
      return 0;
    ++v11;
  }
  else
  {
    v13 = v12;
    v14 = 0;
  }
  if ( v13 <= 0 )
    return 0;
  if ( v10 )
  {
    v13 -= 2;
    ++v4;
  }
  snprintf(url_address, 0xFEu, "%.*s", v13, v4);
  if ( v14 )
  {
    snprintf(port, 6u, "%.*s", v14, v11);
    v16 = strchr(port, 47);
    if ( v16 )
      *v16 = 0;
  }
  else
  {
    strcpy(port, "80");
  }
  *sockaddr_port = _strdup(port);
  *sockaddr_url = _strdup(url_address);
  return 1;
}

//----- (0002817C) --------------------------------------------------------
char *__fastcall get_proxy(char *url, pool *pool)
{
  const char *v2; // r4
  int v4; // r5
  size_t v5; // r6
  char *v7; // r0
  char *v8; // r8
  char *v9; // r0
  const char *v10; // r1
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v2 = "http:";
  v4 = 0;
  v5 = 5;
  pool->rpc_proxy = 0;
  while ( strncmp(url, v2, v5) )
  {
    ++v4;
    v2 = (const char *)*(&_func___11739.__data.__nusers + 2 * v4);
    if ( !v2 )
      return url;
    v5 = strlen(v2);
  }
  v7 = strchr(url, 124);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    v9 = (char *)malloc(v7 - url + 1 - v5);
    pool->rpc_proxy = v9;
    if ( !v9 )
    {
      snprintf(tmp42, 0x1000u, "Failed to malloc rpc_proxy in %s %s():%d", "util.c", &_func___11752.__size[16], 881);
      applog(3, tmp42, 1);
      quit(1);
    }
    v10 = &url[v5];
    url = v8 + 1;
    strcpy(v9, v10);
    extract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);
    pool->rpc_proxytype = *(_DWORD *)&_func___12024[8 * v4 + 32];
  }
  return url;
}

//----- (0002825C) --------------------------------------------------------
bool __fastcall sock_full(pool *pool)
{
  char *sockbuf; // r3

  sockbuf = pool->sockbuf;
  return *sockbuf || socket_full(pool->sock, (unsigned __int8)*sockbuf);
}

//----- (00028270) --------------------------------------------------------
void __fastcall recalloc(void **ptr, size_t old, size_t a3, const char *file, const char *func, const int line)
{
  void *v10; // r0
  char tmp42[4120]; // [sp+8h] [bp-1018h] BYREF

  if ( a3 != old )
  {
    v10 = realloc(*ptr, a3);
    *ptr = v10;
    if ( !v10 )
    {
      snprintf(tmp42, 0x1000u, "Failed to realloc in %s %s():%d", file, func, line);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( a3 > old )
      memset((char *)*ptr + old, 0, a3 - old);
  }
}

//----- (000282EC) --------------------------------------------------------
void __fastcall suspend_stratum(pool *pool)
{
  int *v2; // r0
  int *v3; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Closing socket for stratum pool %d", pool->pool_no);
    applog(7, tmp42, 0);
  }
  if ( pthread_mutex_lock(&pool->stratum_lock) )
  {
    v2 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v2, "util.c", "suspend_stratum", 3354);
    applog(3, tmp42, 1);
    quit(1);
  }
  _suspend_stratum(pool);
  if ( pthread_mutex_unlock(&pool->stratum_lock) )
  {
    v3 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v3,
      "util.c",
      "suspend_stratum",
      3356);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
}

//----- (00028408) --------------------------------------------------------
bool __fastcall stratum_send(pool *pool, char *s, ssize_t len)
{
  pthread_mutex_t *p_stratum_lock; // r6
  int *v7; // r0
  int *v8; // r0
  send_ret v9; // r4
  bool result; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( opt_protocol && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    p_stratum_lock = &pool->stratum_lock;
    snprintf(tmp42, 0x1000u, "SEND: %s", s);
    applog(7, tmp42, 0);
    if ( pthread_mutex_lock(&pool->stratum_lock) )
    {
LABEL_11:
      v8 = _errno_location();
      snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v8, "util.c", "stratum_send", 1893);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  else
  {
    p_stratum_lock = &pool->stratum_lock;
    if ( pthread_mutex_lock(&pool->stratum_lock) )
      goto LABEL_11;
  }
  if ( !pool->stratum_active )
  {
    if ( pthread_mutex_unlock(p_stratum_lock) )
      goto LABEL_6;
    selective_yield();
    goto LABEL_24;
  }
  v9 = _stratum_send(pool, s, len);
  if ( pthread_mutex_unlock(p_stratum_lock) )
  {
LABEL_6:
    v7 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v7, "util.c", "stratum_send", 1896);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  if ( v9 == send_ret::SEND_SENDFAIL )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42, "Failed to send in stratum_send");
      applog(7, tmp42, 0);
      suspend_stratum(pool);
      return 0;
    }
    goto LABEL_21;
  }
  if ( v9 != send_ret::SEND_INACTIVE )
  {
    if ( v9 != send_ret::SEND_SELECTFAIL )
      return v9 == send_ret::SEND_OK;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "Write select failed on pool %d sock", pool->pool_no);
      applog(7, tmp42, 0);
    }
LABEL_21:
    suspend_stratum(pool);
    return 0;
  }
LABEL_24:
  result = opt_debug;
  if ( opt_debug && (use_syslog || (result = opt_log_output) || opt_log_level > 6) )
  {
    strcpy(tmp42, "Stratum send failed due to no pool stratum_active");
    applog(7, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (000286A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
char *__fastcall recv_line(pool *pool)
{
  char *sockbuf; // r6
  signed int v3; // r7
  char *v4; // r0
  char *v5; // r5
  size_t v6; // r0
  size_t v7; // r8
  unsigned int bytes_received; // r2
  _BOOL4 v9; // r7
  uint64_t v10; // kr08_8
  unsigned int bytes_received_high; // r6
  unsigned int net_bytes_received; // r3
  unsigned int v13; // kr00_4
  unsigned int net_bytes_received_high; // r3
  ssize_t v16; // r6
  int v17; // r5
  char *v18; // r9
  size_t v19; // r6
  size_t v20; // r8
  size_t v21; // r0
  size_t v22; // r6
  char *v23; // r0
  timeval rstart; // [sp+8h] [bp-3014h] BYREF
  timeval now; // [sp+10h] [bp-300Ch] BYREF
  char tmp42[4096]; // [sp+18h] [bp-3004h] BYREF
  char tmp42_0[8196]; // [sp+1018h] [bp-2004h] OVERLAPPED BYREF

  sockbuf = pool->sockbuf;
  if ( !strchr(sockbuf, 10) )
  {
    gettimeofday(&rstart, 0);
    if ( !socket_full(pool->sock, 60) )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(tmp42_0, "Timed out waiting for data on socket_full");
        applog(7, tmp42_0, 0);
      }
      goto LABEL_30;
    }
    while ( 1 )
    {
      memset(tmp42_0, 0, 0x2000u);
      v16 = recv(pool->sock, tmp42_0, 0x1FFCu, 0);
      if ( !v16 )
        break;
      gettimeofday(&now, 0);
      v17 = (int)((double)(now.tv_usec - rstart.tv_usec) / 1000000.0 + (double)(now.tv_sec - rstart.tv_sec));
      if ( v16 < 0 )
      {
        if ( *_errno_location() != 11 || !socket_full(pool->sock, 60 - v17) )
        {
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy(tmp42, "Failed to recv sock in recv_line");
            applog(7, tmp42, 0);
          }
          goto LABEL_36;
        }
      }
      else
      {
        v18 = pool->sockbuf;
        v19 = strlen(tmp42_0);
        v20 = strlen(v18);
        v21 = v19 + v20 + 1;
        if ( v21 >= pool->sockbuf_size )
        {
          v22 = (v21 & 0xFFFFE000) + 0x2000;
          v23 = (char *)realloc(v18, v22);
          pool->sockbuf = v23;
          if ( !v23 )
          {
            snprintf(tmp42, 0x1000u, "Failed to realloc pool sockbuf in %s %s():%d", "util.c", "recalloc_sock", 1997);
            applog(3, tmp42, 1);
            quit(1);
          }
          memset(&v23[v20], 0, v22 - v20);
          v18 = pool->sockbuf;
          pool->sockbuf_size = v22;
        }
        strcat(v18, tmp42_0);
      }
      sockbuf = pool->sockbuf;
      if ( v17 > 59 || strchr(pool->sockbuf, 10) )
        goto LABEL_2;
    }
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42, "Socket closed waiting in recv_line");
      applog(7, tmp42, 0);
    }
LABEL_36:
    suspend_stratum(pool);
    sockbuf = pool->sockbuf;
  }
LABEL_2:
  v3 = strlen(sockbuf);
  v4 = strtok(sockbuf, (const char *)&word_58FE4);
  if ( !v4 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42_0, "Failed to parse a \\n terminated string in recv_line");
      applog(7, tmp42_0, 0);
    }
LABEL_30:
    v5 = 0;
    clear_sock(pool);
    return v5;
  }
  v5 = _strdup(v4);
  v6 = strlen(v5);
  v7 = v6;
  if ( (int)(v6 + 1) < v3 )
    memmove(pool->sockbuf, &pool->sockbuf[v6 + 1], v3 - v6 + 1);
  else
    *pool->sockbuf = 0;
  bytes_received = pool->cgminer_pool_stats.bytes_received;
  v9 = opt_protocol;
  v10 = pool->cgminer_pool_stats.times_received + 1;
  bytes_received_high = HIDWORD(pool->cgminer_pool_stats.bytes_received);
  HIDWORD(pool->cgminer_pool_stats.times_received) = HIDWORD(v10);
  net_bytes_received = pool->cgminer_pool_stats.net_bytes_received;
  LODWORD(pool->cgminer_pool_stats.times_received) = v10;
  v13 = net_bytes_received;
  net_bytes_received_high = HIDWORD(pool->cgminer_pool_stats.net_bytes_received);
  pool->cgminer_pool_stats.bytes_received = __PAIR64__(bytes_received_high, bytes_received) + v7;
  pool->cgminer_pool_stats.net_bytes_received = __PAIR64__(net_bytes_received_high, v13) + v7;
  if ( v9 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42_0, 0x1000u, "RECVD: %s", v5);
    applog(7, tmp42_0, 0);
  }
  return v5;
}
// 286A0: variables would overlap: ^1018.8192 and stkvar "tmp42_0" ^1018.4096(has user info)
// 58FE4: using guessed type __int16 word_58FE4;

//----- (00028AB8) --------------------------------------------------------
bool __fastcall initiate_stratum(pool *pool)
{
  pool *v1; // r10
  int sock; // r0
  char *rpc_proxy; // r3
  int v4; // r0
  _BOOL4 v5; // r4
  struct addrinfo *v6; // r5
  int v7; // r0
  int *v8; // r10
  int v9; // r0
  int v10; // r9
  char *v11; // r6
  int v12; // r0
  int v13; // r1
  int v14; // r2
  __int16 v15; // r3
  int v16; // r3
  int v17; // r7
  int v18; // r7
  int v19; // r6
  fd_set *v20; // r3
  int v21; // r0
  char *v22; // r0
  char *v23; // r3
  int v24; // r0
  int *v25; // r4
  const char *sessionid; // r3
  int v27; // r2
  int v28; // r6
  ssize_t v29; // r0
  bool v30; // r6
  _BOOL4 v32; // r2
  bool extranonce_subscribe; // r7
  int v34; // r2
  ssize_t v35; // r0
  char *v36; // r0
  size_t v37; // r3
  size_t v38; // r3
  int v39; // r2
  const char *v40; // r0
  const char *v41; // r3
  int *v42; // r0
  int *v43; // r0
  const char *v44; // r6
  size_t v45; // r0
  size_t v46; // r5
  __int16 v47; // r0
  char *v48; // r1
  char *v49; // r0
  char *v50; // r6
  json_t *v51; // r6
  json_t *v52; // r0
  char *v53; // r4
  size_t refcount; // r3
  size_t v55; // r3
  char *v56; // r0
  int *v57; // r0
  int *v58; // r0
  int *v59; // r0
  int *v60; // r0
  int v61; // r5
  int v62; // r6
  int v63; // r5
  _BOOL4 v65; // r0
  char *v66; // r0
  int v67; // r5
  struct addrinfo *v68; // [sp+10h] [bp-3364h]
  const char *stratum_port; // [sp+18h] [bp-335Ch]
  const char *sockaddr_url; // [sp+1Ch] [bp-3358h]
  pthread_mutex_t *mutex; // [sp+20h] [bp-3354h]
  json_t *val; // [sp+28h] [bp-334Ch]
  int noresume; // [sp+2Ch] [bp-3348h]
  pool *v74; // [sp+34h] [bp-3340h]
  struct addrinfo *pai; // [sp+3Ch] [bp-3338h] BYREF
  socklen_t optlen; // [sp+40h] [bp-3334h] BYREF
  int optval; // [sp+44h] [bp-3330h] BYREF
  struct timeval timeout; // [sp+48h] [bp-332Ch] BYREF
  struct addrinfo req; // [sp+50h] [bp-3324h] BYREF
  json_error_t err; // [sp+70h] [bp-3304h] BYREF
  fd_set writefds; // [sp+16Ch] [bp-3208h] BYREF
  char tmp42[4096]; // [sp+370h] [bp-3004h] BYREF
  char s[8196]; // [sp+1370h] [bp-2004h] BYREF

  v1 = pool;
  val = 0;
  mutex = &pool->stratum_lock;
  noresume = 0;
LABEL_2:
  if ( pthread_mutex_lock(mutex) )
  {
    v43 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v43,
      "util.c",
      "setup_stratum_socket",
      3167);
    applog(3, tmp42, 1);
    quit(1);
  }
  sock = v1->sock;
  v1->stratum_active = 0;
  if ( sock )
    close(sock);
  v1->sock = 0;
  if ( pthread_mutex_unlock(mutex) )
  {
    v42 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v42,
      "util.c",
      "setup_stratum_socket",
      3172);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  memset(&req, 0, sizeof(req));
  rpc_proxy = v1->rpc_proxy;
  req.ai_socktype = 1;
  if ( rpc_proxy )
    goto LABEL_7;
  v22 = opt_socks_proxy;
  if ( !opt_socks_proxy )
  {
    sockaddr_url = v1->sockaddr_url;
    goto LABEL_73;
  }
  v1->rpc_proxy = opt_socks_proxy;
  extract_sockaddr(v22, &v1->sockaddr_proxy_url, &v1->sockaddr_proxy_port);
  v23 = v1->rpc_proxy;
  v1->rpc_proxytype = 3;
  sockaddr_url = v1->sockaddr_url;
  if ( !v23 )
  {
LABEL_73:
    stratum_port = v1->stratum_port;
    v4 = getaddrinfo(sockaddr_url, stratum_port, &req, &pai);
    goto LABEL_8;
  }
LABEL_7:
  sockaddr_url = v1->sockaddr_proxy_url;
  stratum_port = v1->sockaddr_proxy_port;
  v4 = getaddrinfo(sockaddr_url, stratum_port, &req, &pai);
LABEL_8:
  if ( v4 )
  {
    if ( !v1->probed )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "Failed to resolve (?wrong URL) %s:%s", sockaddr_url, stratum_port);
        applog(4, tmp42, 0);
      }
      v1->probed = 1;
      goto LABEL_15;
    }
    if ( !opt_debug )
      goto LABEL_93;
    if ( use_syslog || (v5 = opt_log_output) || opt_log_level > 6 )
    {
      snprintf(tmp42, 0x1000u, "Failed to getaddrinfo for %s:%s", sockaddr_url, stratum_port);
      applog(7, tmp42, 0);
      goto LABEL_15;
    }
    goto LABEL_17;
  }
  if ( !pai )
    goto LABEL_40;
  v6 = pai;
  v74 = v1;
  do
  {
    while ( 1 )
    {
      v9 = socket(v6->ai_family, v6->ai_socktype, v6->ai_protocol);
      v10 = v9;
      if ( v9 == -1 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          v11 = tmp42;
          v12 = *(_DWORD *)"Failed socket";
          v13 = *(_DWORD *)"ed socket";
          v14 = *(_DWORD *)"ocket";
          v15 = *(_WORD *)"t";
          goto LABEL_38;
        }
        goto LABEL_31;
      }
      v7 = fcntl(v9, 3, 0);
      fcntl(v10, 4, v7 | 0x800);
      if ( connect(v10, v6->ai_addr, v6->ai_addrlen) != -1 )
      {
        v1 = v74;
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          strcpy(tmp42, "Succeeded immediate connect");
          applog(4, tmp42, 0);
        }
LABEL_69:
        block_socket(v10);
        freeaddrinfo(pai);
        if ( v1->rpc_proxy )
        {
          switch ( v1->rpc_proxytype )
          {
            case 0:
              if ( !http_negotiate(v1, v10, 0) )
                goto LABEL_15;
              break;
            case 1:
              if ( !http_negotiate(v1, v10, 1) )
                goto LABEL_15;
              break;
            case 2:
              if ( !socks4_negotiate(v1, v10, 0) )
                goto LABEL_15;
              break;
            case 3:
            case 5:
              LOWORD(writefds.fds_bits[0]) = 261;
              BYTE2(writefds.fds_bits[0]) = 0;
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  tmp42,
                  0x1000u,
                  "Attempting to negotiate with %s:%s SOCKS5 proxy",
                  v1->sockaddr_proxy_url,
                  v1->sockaddr_proxy_port);
                applog(7, tmp42, 0);
              }
              send(v10, &writefds, 3u, 0);
              if ( recv(v10, tmp42, 1u, 0) == -1
                || tmp42[0] != 5
                || recv(v10, tmp42, 1u, 0) == -1
                || BYTE2(writefds.fds_bits[0]) != (unsigned __int8)tmp42[0] )
              {
                if ( use_syslog || opt_log_output || opt_log_level > 3 )
                  goto LABEL_159;
LABEL_193:
                v5 = 0;
                if ( !opt_debug )
                  goto LABEL_93;
                if ( !opt_log_output )
                {
LABEL_195:
                  if ( opt_log_level > 6 )
                    goto LABEL_19;
LABEL_20:
                  if ( !v5 )
                    goto LABEL_93;
LABEL_92:
                  suspend_stratum(v1);
                  goto LABEL_93;
                }
LABEL_19:
                strcpy(tmp42, "Initiate stratum failed");
                applog(7, tmp42, 0);
                goto LABEL_20;
              }
              v44 = v1->sockaddr_url;
              writefds.fds_bits[0] = 50331909;
              v45 = strlen(v44);
              if ( v45 >= 0xFF )
                v45 = 255;
              v46 = v45;
              LOBYTE(writefds.fds_bits[1]) = v45;
              memcpy((char *)&writefds.fds_bits[1] + 1, v44, v45);
              v47 = strtol(v1->stratum_port, 0, 10);
              v48 = (char *)&writefds + v46;
              v48[6] = v47;
              v48[5] = HIBYTE(v47);
              send(v10, &writefds, v46 + 7, 0);
              if ( recv(v10, tmp42, 1u, 0) == -1
                || tmp42[0] != 5
                || recv(v10, tmp42, 1u, 0) == -1
                || (v61 = (unsigned __int8)tmp42[0], tmp42[0])
                || (recv(v10, tmp42, 1u, 0), recv(v10, tmp42, 1u, v61) == -1) )
              {
LABEL_152:
                if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
                  goto LABEL_15;
LABEL_159:
                snprintf(
                  tmp42,
                  0x1000u,
                  "Bad response from %s:%s SOCKS5 server",
                  v1->sockaddr_proxy_url,
                  v1->sockaddr_proxy_port);
                applog(4, tmp42, 0);
                goto LABEL_15;
              }
              if ( tmp42[0] == 1 )
              {
                v67 = 4;
                do
                {
                  recv(v10, tmp42, 1u, 0);
                  --v67;
                }
                while ( v67 );
              }
              else
              {
                if ( tmp42[0] != 3 )
                  goto LABEL_152;
                v62 = 0;
                if ( recv(v10, tmp42, 1u, 0) == -1 )
                  v63 = -1;
                else
                  v63 = (unsigned __int8)tmp42[0];
                while ( v62++ < v63 )
                  recv(v10, tmp42, 1u, 0);
              }
              recv(v10, tmp42, 1u, 0);
              recv(v10, tmp42, 1u, 0);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  tmp42,
                  0x1000u,
                  "Success negotiating with %s:%s SOCKS5 proxy",
                  v1->sockaddr_proxy_url,
                  v1->sockaddr_proxy_port);
                applog(7, tmp42, 0);
              }
              break;
            case 4:
              if ( socks4_negotiate(v1, v10, 1) )
                break;
              goto LABEL_15;
            default:
              if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
                goto LABEL_193;
              snprintf(
                tmp42,
                0x1000u,
                "Unsupported proxy type for %s:%s",
                v1->sockaddr_proxy_url,
                v1->sockaddr_proxy_port);
              applog(4, tmp42, 0);
              goto LABEL_15;
          }
        }
        if ( !v1->sockbuf )
        {
          v56 = (char *)calloc(0x2000u, 1u);
          v1->sockbuf = v56;
          if ( !v56 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "Failed to calloc pool sockbuf in %s %s():%d",
              "util.c",
              "setup_stratum_socket",
              3311);
            applog(3, tmp42, 1);
            quit(1);
          }
          v1->sockbuf_size = 0x2000;
        }
        v1->sock = v10;
        *(_DWORD *)tmp42 = 30;
        writefds.fds_bits[0] = 45;
        timeout.tv_sec = 1;
        v24 = fcntl(v10, 3, 0);
        fcntl(v10, 4, v24 | 0x800);
        setsockopt(v10, 1, 9, &timeout, 4u);
        if ( !opt_delaynet )
          fcntl(v10, 2, 1);
        setsockopt(v10, 6, 1, &timeout, 4u);
        setsockopt(v10, 6, 6, &timeout, 4u);
        LOWORD(v25) = (unsigned __int16)&swork_id;
        setsockopt(v10, 6, 4, &writefds, 4u);
        setsockopt(v10, 6, 5, tmp42, 4u);
        if ( noresume )
        {
          HIWORD(v25) = (unsigned int)&swork_id >> 16;
          clear_sock(v1);
          v39 = (*v25)++;
          sprintf(s, "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": []}", v39);
        }
        else
        {
          HIWORD(v25) = (unsigned int)&swork_id >> 16;
          sessionid = v1->sessionid;
          v27 = *v25;
          v28 = *v25 + 1;
          if ( sessionid )
          {
            *v25 = v28;
            sprintf(
              s,
              "{\"id\": %d, \"method\": \"mining.subscribe\", \"params\": [\"cgminer/4.9.0\", \"%s\"]}",
              v27,
              sessionid);
          }
          else
          {
            v40 = v1->stratum_port;
            v41 = v1->sockaddr_url;
            *v25 = v28;
            sprintf(
              s,
              "{\"id\":%d, \"method\":\"mining.subscribe\", \"params\":[\"cgminer/4.9.0\", null, \"%s\", \"%s\"]}",
              v27,
              v41,
              v40);
          }
        }
        v29 = strlen(s);
        if ( _stratum_send(v1, s, v29) )
        {
          v5 = opt_debug;
          if ( !opt_debug )
            goto LABEL_92;
          if ( use_syslog || opt_log_output || opt_log_level > 6 )
          {
            strcpy(tmp42, "Failed to send s in initiate_stratum");
            applog(7, tmp42, 0);
            goto LABEL_117;
          }
          goto LABEL_17;
        }
        if ( !socket_full(v1->sock, 60) )
        {
          v5 = opt_debug;
          if ( !opt_debug )
            goto LABEL_92;
          if ( use_syslog || opt_log_output || opt_log_level > 6 )
          {
            strcpy(tmp42, "Timed out waiting for response in initiate_stratum");
            applog(7, tmp42, 0);
LABEL_117:
            v5 = opt_debug;
            if ( opt_debug )
              goto LABEL_17;
            goto LABEL_92;
          }
LABEL_17:
          if ( !use_syslog && !opt_log_output )
            goto LABEL_195;
          goto LABEL_19;
        }
        v49 = recv_line(v1);
        v50 = v49;
        if ( !v49 )
          goto LABEL_117;
        val = json_loads(v49, 0, &err);
        free(v50);
        if ( !val )
        {
          noresume ^= 1u;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "JSON decode failed(%d): %s", err.line, err.text);
            applog(7, tmp42, 0);
          }
          goto LABEL_173;
        }
        v51 = json_object_get(val, "result");
        v52 = json_object_get(val, "error");
        if ( !v51 || v51->type == JSON_NULL )
        {
          if ( !v52 )
          {
            v66 = (char *)malloc(0x11u);
            v53 = v66;
            if ( v66 )
              strcpy(v66, "(unknown reason)");
            goto LABEL_167;
          }
        }
        else if ( !v52 || v52->type == JSON_NULL )
        {
          v65 = parse_extranonce_equihash(v1, v51, 1);
          if ( v65 )
          {
            v30 = v65;
            if ( !v1->stratum_url )
              v1->stratum_url = v1->sockaddr_url;
            v32 = opt_protocol;
            v1->stratum_active = 1;
            v1->sdiff = 1.0;
            if ( v32 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                tmp42,
                0x1000u,
                "Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d",
                v1->pool_no,
                v1->nonce1,
                v1->n2size);
              applog(7, tmp42, 0);
            }
            extranonce_subscribe = v1->extranonce_subscribe;
            if ( extranonce_subscribe )
            {
              v34 = (*v25)++;
              sprintf(s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v34);
              v35 = strlen(s);
              stratum_send(v1, s, v35);
              v36 = recv_line(v1);
              if ( v36 )
              {
                free(v36);
                v30 = extranonce_subscribe;
              }
              else if ( use_syslog || opt_log_output || opt_log_level > 2 )
              {
                v30 = extranonce_subscribe;
                strcpy(tmp42, "recv mining.extranonce.subscribe failed\n");
                applog(3, tmp42, 0);
              }
              else
              {
                v30 = extranonce_subscribe;
              }
            }
            goto LABEL_111;
          }
          noresume ^= 1u;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "%s: Failed to get parse extranonce.", "initiate_stratum");
            applog(7, tmp42, 0);
          }
          goto LABEL_173;
        }
        v53 = json_dumps(v52, 3u);
LABEL_167:
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42, 0x1000u, "JSON-RPC decode failed: %s", v53);
          applog(7, tmp42, 0);
        }
        noresume ^= 1u;
        free(v53);
LABEL_173:
        if ( !noresume )
          goto LABEL_117;
        if ( pthread_mutex_lock(&v1->data_lock.mutex) )
        {
          v60 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
            *v60,
            "util.c",
            "initiate_stratum",
            3608);
          applog(3, tmp42, 1);
          quit(1);
        }
        if ( pthread_rwlock_wrlock(&v1->data_lock.rwlock) )
        {
          v59 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *v59,
            "util.c",
            "initiate_stratum",
            3608);
          applog(3, tmp42, 1);
          quit(1);
        }
        free(v1->sessionid);
        free(v1->nonce1);
        v1->nonce1 = 0;
        v1->sessionid = 0;
        if ( pthread_rwlock_unlock(&v1->data_lock.rwlock) )
        {
          v58 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v58,
            "util.c",
            "initiate_stratum",
            3612);
          applog(3, tmp42, 1);
          quit(1);
        }
        if ( pthread_mutex_unlock(&v1->data_lock.mutex) )
        {
          v57 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v57,
            "util.c",
            "initiate_stratum",
            3612);
          applog(3, tmp42, 1);
          quit(1);
        }
        selective_yield();
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy(tmp42, "Failed to resume stratum, trying afresh");
          applog(7, tmp42, 0);
        }
        if ( val )
        {
          refcount = val->refcount;
          if ( refcount != -1 )
          {
            v55 = refcount - 1;
            val->refcount = v55;
            if ( !v55 )
              json_delete(val);
          }
        }
        goto LABEL_2;
      }
      timeout.tv_usec = 0;
      timeout.tv_sec = 1;
      v8 = _errno_location();
      if ( *v8 != 115 )
      {
        close(v10);
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          strcpy(tmp42, "Failed sock connect");
          applog(7, tmp42, 0);
        }
        goto LABEL_31;
      }
      LOBYTE(v16) = v10 & 0x1F;
      v17 = (v10 + 31) & (v10 >> 31);
      if ( v10 >= 0 )
        v17 = v10;
      v18 = v17 >> 5;
      if ( v10 <= 0 )
        v16 = -(-v10 & 0x1F);
      v68 = v6;
      v19 = 1 << v16;
      while ( 1 )
      {
        v6 = v68;
        v20 = (fd_set *)&err.text[156];
        do
        {
          v20->fds_bits[1] = 0;
          v20 = (fd_set *)((char *)v20 + 4);
        }
        while ( &writefds.fds_bits[31] != (__fd_mask *)v20 );
        writefds.fds_bits[v18] |= v19;
        v21 = select(v10 + 1, 0, &writefds, 0, &timeout);
        if ( v21 > 0 )
          break;
        if ( !v21 || *v8 != 4 )
          goto LABEL_54;
      }
      if ( (v19 & writefds.fds_bits[v18]) != 0 )
      {
        optlen = 4;
        if ( !getsockopt(v10, 1, 4, &optval, &optlen) && !optval )
        {
          v1 = v74;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            strcpy(tmp42, "Succeeded delayed connect");
            applog(7, tmp42, 0);
          }
          goto LABEL_69;
        }
      }
LABEL_54:
      close(v10);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        break;
LABEL_31:
      v6 = v6->ai_next;
      if ( !v6 )
        goto LABEL_39;
    }
    qmemcpy(tmp42, "Select timeout/f", 16);
    v11 = &tmp42[16];
    v12 = *(_DWORD *)"ailed connect";
    v13 = *(_DWORD *)"d connect";
    v14 = *(_DWORD *)"nnect";
    v15 = *(_WORD *)"t";
LABEL_38:
    *(_DWORD *)v11 = v12;
    *((_DWORD *)v11 + 1) = v13;
    *((_DWORD *)v11 + 2) = v14;
    *((_WORD *)v11 + 6) = v15;
    applog(7, tmp42, 0);
    v6 = v6->ai_next;
  }
  while ( v6 );
LABEL_39:
  v1 = v74;
LABEL_40:
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Failed to connect to stratum on %s:%s", sockaddr_url, stratum_port);
    applog(7, tmp42, 0);
  }
  freeaddrinfo(pai);
LABEL_15:
  if ( opt_debug )
  {
    v5 = 0;
    goto LABEL_17;
  }
LABEL_93:
  v30 = 0;
  if ( !val )
    return 0;
LABEL_111:
  v37 = val->refcount;
  if ( v37 == -1 )
    return v30;
  v38 = v37 - 1;
  val->refcount = v38;
  if ( v38 )
    return v30;
  json_delete(val);
  return v30;
}

//----- (00029B7C) --------------------------------------------------------
bool __fastcall restart_stratum(pool *pool)
{
  _BOOL4 v3; // r5

  if ( pool->stratum_active )
    suspend_stratum(pool);
  if ( initiate_stratum(pool)
    && (!pool->extranonce_subscribe || subscribe_extranonce(pool))
    && (v3 = auth_stratum(pool)) )
  {
    stratum_resumed(pool);
    return v3;
  }
  else
  {
    pool_died(pool);
    return 0;
  }
}

//----- (00029BC4) --------------------------------------------------------
// Alternative name is 'parse_method.part.6'
bool __fastcall parse_method_0(pool *pool, char *s)
{
  double v2; // d0
  json_t *v4; // r0
  json_t *v5; // r5
  json_t *v6; // r7
  json_t *v7; // r8
  json_t *v8; // r4
  const char *v9; // r0
  const char *v10; // r8
  int v11; // r7
  json_t *v12; // r0
  int v13; // r0
  ssize_t v14; // r0
  json_t *v15; // r0
  size_t refcount; // r3
  size_t v17; // r3
  void *v19; // r0
  json_t *v20; // r0
  const char *v21; // r2
  int v22; // r3
  double sdiff; // d9
  char *v24; // r9
  char *v25; // r8
  char *v26; // r11
  char *v27; // r10
  _BOOL4 v28; // r4
  bool v29; // zf
  bool v30; // zf
  _BOOL4 v31; // r3
  json_t *v32; // r0
  const char *v33; // r8
  char *sockaddr_url; // r10
  char *v35; // r9
  char *v36; // r0
  json_t *v37; // r0
  int v38; // r0
  json_t *v39; // r0
  const char *stratum_port; // r0
  const char *v41; // r2
  int v42; // r3
  char *v43; // r3
  char *v44; // r0
  char *v45; // r0
  char *v46; // r8
  const char *v47; // r2
  int v48; // r3
  __int64 v49; // kr00_8
  __time_t tv_sec; // r1
  struct timeval v51; // kr08_8
  struct timeval v52; // kr10_8
  json_t *v53; // r0
  const char *v54; // r0
  double next_diff; // d7
  size_t v56; // r4
  size_t v57; // r0
  size_t v58; // r4
  size_t v59; // r0
  _BOOL4 v60; // r3
  int header_len; // r4
  int64_t v62; // kr18_8
  struct timezone *v63; // r9
  struct timezone *v64; // r1
  char *v65; // r9
  int *v66; // r0
  int *v67; // r0
  int *v68; // r0
  const char *v69; // r3
  int *v70; // r0
  int *v71; // r0
  int *v72; // r0
  int *v73; // r0
  int *v74; // r0
  int *v75; // r0
  int *v76; // r0
  int *v77; // r0
  int *v78; // r0
  int *v79; // r0
  char *v80; // [sp+18h] [bp-222Ch]
  char *ptr; // [sp+1Ch] [bp-2228h]
  char *v82; // [sp+20h] [bp-2224h]
  char *hexstr; // [sp+24h] [bp-2220h]
  int hexstra; // [sp+24h] [bp-2220h]
  cglock_t *mutex; // [sp+30h] [bp-2214h]
  pthread_rwlock_t *rwlock; // [sp+34h] [bp-2210h]
  char *v87; // [sp+3Ch] [bp-2208h] BYREF
  char *sockaddr_port; // [sp+40h] [bp-2204h] BYREF
  json_error_t err; // [sp+44h] [bp-2200h] BYREF
  struct timeval p[32]; // [sp+140h] [bp-2104h] BYREF
  char tmp42[8196]; // [sp+240h] [bp-2004h] BYREF

  v4 = json_loads(s, 0, &err);
  if ( v4 )
  {
    v5 = v4;
    v6 = json_object_get(v4, "method");
    if ( !v6 )
      goto LABEL_22;
    v7 = json_object_get(v5, "error");
    v8 = json_object_get(v5, "params");
    if ( v7 && v7->type != JSON_NULL )
    {
      v8 = (json_t *)json_dumps(v7, 3u);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "JSON-RPC method decode failed: %s", (const char *)v8);
        applog(7, tmp42, 0);
      }
      v19 = v8;
      LOBYTE(v8) = 0;
      free(v19);
      goto LABEL_23;
    }
    v9 = json_string_value(v6);
    v10 = v9;
    if ( !v9 )
      goto LABEL_22;
    v11 = strncasecmp(v9, "mining.notify", 0xDu);
    if ( v11 )
    {
      if ( !strncasecmp(v10, "mining.set_extranonce", 0x15u) )
      {
        LOBYTE(v8) = parse_extranonce_equihash(pool, v8, 0);
        goto LABEL_23;
      }
      if ( !strncasecmp(v10, "mining.set_difficulty", 0x15u) )
      {
        v20 = json_array_get(v8, 0);
        json_number_value(v20);
        if ( v2 == 0.0 )
          goto LABEL_22;
        if ( pthread_mutex_lock(&pool->data_lock.mutex) )
          mutex_lock_0((pthread_mutex_t *)&_func___12181, (const char *)0x9B3, v21, v22);
        if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
        {
          v68 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
            *v68,
            "util.c",
            (const char *)&_func___12181,
            2483);
          applog(3, tmp42, 1);
          quit(1);
        }
        sdiff = pool->sdiff;
        pool->sdiff = v2;
        if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
        {
          v67 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v67,
            "util.c",
            (const char *)&_func___12181,
            2486);
          applog(3, tmp42, 1);
          quit(1);
        }
        if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
        {
          v66 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v66,
            "util.c",
            (const char *)&_func___12181,
            2486);
          applog(3, tmp42, 1);
          quit(1);
        }
        selective_yield();
        if ( v2 == sdiff )
        {
          LOBYTE(v8) = opt_debug;
          if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "Pool %d difficulty set to %f", pool->pool_no, v2);
            goto LABEL_50;
          }
        }
        else
        {
          LOBYTE(v8) = opt_debug;
          if ( v2 == (double)(int)v2 )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(tmp42, 0x1000u, "Pool %d difficulty changed to %d", pool->pool_no, (int)v2);
LABEL_50:
              applog(7, tmp42, 0);
              goto LABEL_23;
            }
          }
          else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "Pool %d difficulty changed to %.1f", pool->pool_no, v2);
            goto LABEL_50;
          }
        }
LABEL_121:
        LOBYTE(v8) = 1;
        goto LABEL_23;
      }
      if ( strncasecmp(v10, "client.reconnect", 0x10u) )
      {
        if ( !strncasecmp(v10, "client.get_version", 0x12u) )
        {
          v15 = json_object_get(v5, "id");
          if ( !v15 )
            goto LABEL_21;
          v37 = json_object_get(v5, "id");
          v38 = json_integer_value(v37);
          sprintf(tmp42, "{\"id\": %d, \"result\": \"cgminer/4.9.0\", \"error\": null}", v38);
LABEL_20:
          v14 = strlen(tmp42);
          LOBYTE(v15) = stratum_send(pool, tmp42, v14);
LABEL_21:
          LOBYTE(v8) = (_BYTE)v15;
LABEL_23:
          refcount = v5->refcount;
          if ( refcount != -1 )
          {
            v17 = refcount - 1;
            v5->refcount = v17;
            if ( !v17 )
              json_delete(v5);
          }
          return (char)v8;
        }
        if ( strncasecmp(v10, "client.show_message", 0x13u) )
        {
          if ( !strncasecmp(v10, "mining.ping", 0xBu) )
          {
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(tmp42, 0x1000u, "Pool %d ping", pool->pool_no);
              applog(7, tmp42, 0);
            }
            if ( json_object_get(v5, "id") )
            {
              v12 = json_object_get(v5, "id");
              v13 = json_integer_value(v12);
              sprintf(tmp42, "{\"id\": %d, \"result\": \"pong\", \"error\": null}", v13);
              goto LABEL_20;
            }
          }
          else if ( !strncasecmp(v10, "mining.set_target", 0x11u) )
          {
            v46 = json_array_string(v8, 0);
            if ( v46 )
            {
              hex2bin((unsigned __int8 *)p, v46, 0x20u);
              if ( pthread_mutex_lock(&pool->data_lock.mutex) )
                mutex_lock_0((pthread_mutex_t *)&_func___12266, (const char *)0xA9A, v47, v48);
              if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
              {
                v77 = _errno_location();
                snprintf(
                  tmp42,
                  0x1000u,
                  "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                  *v77,
                  "util.c",
                  (const char *)&_func___12266,
                  2714);
                applog(3, tmp42, 1);
                quit(1);
              }
              v49 = *(_QWORD *)&p[2].tv_usec;
              *(_DWORD *)pool->Target = bswap32(p[3].tv_usec);
              tv_sec = p[2].tv_sec;
              *(_DWORD *)&pool->Target[4] = bswap32(HIDWORD(v49));
              *(_DWORD *)&pool->Target[8] = bswap32(v49);
              v51 = p[1];
              *(_DWORD *)&pool->Target[12] = bswap32(tv_sec);
              v52 = p[0];
              *(_DWORD *)&pool->Target[16] = bswap32(v51.tv_usec);
              *(_DWORD *)&pool->Target[20] = bswap32(v51.tv_sec);
              *(_DWORD *)&pool->Target[24] = bswap32(v52.tv_usec);
              *(_DWORD *)&pool->Target[28] = bswap32(v52.tv_sec);
              if ( pthread_rwlock_unlock(&pool->data_lock.rwlock) )
              {
                v76 = _errno_location();
                snprintf(
                  tmp42,
                  0x1000u,
                  "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                  *v76,
                  "util.c",
                  (const char *)&_func___12266,
                  2717);
                applog(3, tmp42, 1);
                quit(1);
              }
              if ( pthread_mutex_unlock(&pool->data_lock.mutex) )
              {
                v75 = _errno_location();
                snprintf(
                  tmp42,
                  0x1000u,
                  "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
                  *v75,
                  "util.c",
                  (const char *)&_func___12266,
                  2717);
                applog(3, tmp42, 1);
                quit(1);
              }
              LOBYTE(v8) = 1;
              selective_yield();
              free(v46);
              goto LABEL_23;
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              LOBYTE(v8) = 0;
              strcpy(tmp42, "parse_target: Missing an array value.");
              applog(7, tmp42, 0);
              goto LABEL_23;
            }
          }
LABEL_22:
          LOBYTE(v8) = 0;
          goto LABEL_23;
        }
        if ( !v8 )
          goto LABEL_22;
        if ( v8->type != JSON_ARRAY )
          goto LABEL_22;
        v53 = json_array_get(v8, 0);
        v54 = json_string_value(v53);
        if ( !v54 )
          goto LABEL_22;
        LOBYTE(v8) = opt_debug;
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42, 0x1000u, "Pool %d message: %s", pool->pool_no, v54);
          goto LABEL_50;
        }
        goto LABEL_121;
      }
      memset(p, 0, 0xFFu);
      v32 = json_array_get(v8, 0);
      v33 = json_string_value(v32);
      if ( v33 )
      {
        sockaddr_url = pool->sockaddr_url;
        v35 = strchr(sockaddr_url, 46);
        if ( !v35 )
        {
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
            goto LABEL_22;
          snprintf(tmp42, 0x1000u, "Denied stratum reconnect request for pool without domain '%s'", sockaddr_url);
          goto LABEL_92;
        }
        v36 = strchr(v33, 46);
        if ( !v36 )
        {
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
            goto LABEL_22;
          snprintf(tmp42, 0x1000u, "Denied stratum reconnect request to url without domain '%s'", v33);
          goto LABEL_92;
        }
        if ( strcmp(v35, v36) )
        {
          if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
            goto LABEL_22;
          snprintf(tmp42, 0x1000u, "Denied stratum reconnect request to non-matching domain url '%s'", sockaddr_url);
LABEL_92:
          LOBYTE(v8) = 0;
          applog(3, tmp42, 0);
          goto LABEL_23;
        }
      }
      else
      {
        v33 = pool->sockaddr_url;
      }
      v39 = json_array_get(v8, 1u);
      stratum_port = json_string_value(v39);
      if ( !stratum_port )
        stratum_port = pool->stratum_port;
      snprintf((char *)p, 0xFEu, "%s:%s", v33, stratum_port);
      if ( extract_sockaddr((char *)p, &v87, &sockaddr_port) )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(tmp42, 0x1000u, "Stratum reconnect requested from pool %d to %s", pool->pool_no, (const char *)p);
          applog(4, tmp42, 0);
        }
        clear_pool_work(pool);
        if ( pthread_mutex_lock(&pool->stratum_lock) )
          mutex_lock_0((pthread_mutex_t *)(&_func___12181.__align + 3), (const char *)0xA51, v41, v42);
        _suspend_stratum(pool);
        v43 = v87;
        v44 = pool->sockaddr_url;
        pool->stratum_url = v87;
        pool->sockaddr_url = v43;
        free(v44);
        v45 = pool->stratum_port;
        pool->stratum_port = sockaddr_port;
        free(v45);
        if ( pthread_mutex_unlock(&pool->stratum_lock) )
        {
          v72 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v72,
            "util.c",
            &_func___12181.__size[12],
            2650);
          applog(3, tmp42, 1);
          quit(1);
        }
        selective_yield();
        LOBYTE(v8) = restart_stratum(pool);
        goto LABEL_23;
      }
      goto LABEL_22;
    }
    v24 = json_array_string(v8, 0);
    ptr = json_array_string(v8, 1u);
    v25 = json_array_string(v8, 2u);
    v26 = json_array_string(v8, 3u);
    v27 = json_array_string(v8, 4u);
    v80 = json_array_string(v8, 5u);
    v82 = json_array_string(v8, 6u);
    if ( json_array_get(v8, 7u) )
    {
      v28 = json_array_get(v8, 7u)->type == JSON_TRUE;
      v11 = v28;
    }
    else
    {
      LOBYTE(v28) = 0;
    }
    v29 = v25 == 0;
    if ( v25 )
      v29 = v24 == 0;
    if ( v29 )
    {
      if ( !v24 )
      {
LABEL_58:
        if ( v25 )
          free(v25);
        if ( v27 )
          free(v27);
        if ( v26 )
          free(v26);
        if ( ptr )
          free(ptr);
        if ( v82 )
          free(v82);
        if ( v80 )
          free(v80);
        if ( hexstr )
          free(hexstr);
        LOBYTE(v8) = 0;
        pool->stratum_notify = 0;
        goto LABEL_23;
      }
    }
    else
    {
      v30 = v27 == 0;
      if ( v27 )
        v30 = v26 == 0;
      if ( v30 )
        goto LABEL_82;
      v31 = v82 == 0;
      if ( !ptr )
        v31 = 1;
      if ( !v80 )
        v31 = 1;
      if ( v31 )
        goto LABEL_82;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(tmp42, "Valid Notify\n");
        applog(7, tmp42, 0);
      }
      mutex = &pool->data_lock;
      if ( pthread_mutex_lock(&pool->data_lock.mutex) )
      {
        v74 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
          *v74,
          "util.c",
          "parse_notify_equihash",
          2142);
        applog(3, tmp42, 1);
        quit(1);
      }
      rwlock = &pool->data_lock.rwlock;
      if ( pthread_rwlock_wrlock(&pool->data_lock.rwlock) )
      {
        v73 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
          *v73,
          "util.c",
          "parse_notify_equihash",
          2142);
        applog(3, tmp42, 1);
        quit(1);
      }
      free(pool->swork.job_id);
      free(pool->swork.prev_hash);
      free(pool->swork.bbversion);
      free(pool->swork.nbit);
      free(pool->swork.ntime);
      pool->swork.job_id = v24;
      pool->swork.prev_hash = v25;
      pool->swork.clean = v28;
      pool->swork.bbversion = ptr;
      pool->swork.nbit = v82;
      pool->swork.ntime = v80;
      next_diff = pool->next_diff;
      if ( next_diff > 0.0 )
        pool->swork.diff = next_diff;
      if ( v11 )
        pool->nonce2 = 0;
      v56 = strlen(ptr);
      v57 = strlen(v25);
      pool->merkle_offset = v56 + v57;
      hexstra = (int)(v56 + v57) / 2;
      v58 = strlen(v80);
      v59 = strlen(v82);
      pool->merkle_offset = hexstra;
      v60 = opt_debug;
      header_len = 2 * ((v59 >> 1) + (v58 >> 1) + 84 + hexstra) + 1;
      pool->swork.header_len = header_len;
      if ( v60 && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "%s: pool->swork.header_len = %d", "parse_notify_equihash", header_len);
        applog(7, tmp42, 0);
        header_len = pool->swork.header_len;
      }
      if ( header_len << 30 )
      {
        header_len = (header_len & 0xFFFFFFFC) + 4;
        pool->swork.header_len = header_len;
      }
      hexstr = (char *)malloc(header_len);
      if ( !hexstr )
      {
        snprintf(
          tmp42,
          0x1000u,
          "%s: Failed to malloc header. in %s %s():%d",
          "parse_notify_equihash",
          "util.c",
          "parse_notify_equihash",
          2188);
        applog(3, tmp42, 1);
        quit(1);
      }
      snprintf(
        hexstr,
        header_len,
        "%s%s%s%s%s%s%s",
        pool->swork.bbversion,
        pool->swork.prev_hash,
        v26,
        v27,
        pool->swork.ntime,
        pool->swork.nbit,
        "0000000000000000000000000000000000000000");
      v8 = (json_t *)hex2bin(pool->header_bin, hexstr, 0x80u);
      if ( v8 )
      {
        v62 = total_getworks;
        ++pool->getwork_requested;
        total_getworks = v62 + 1;
        if ( pthread_rwlock_unlock(rwlock) )
        {
          v71 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v71,
            "util.c",
            "parse_notify_equihash",
            2214);
          applog(3, tmp42, 1);
          quit(1);
        }
        if ( pthread_mutex_unlock(&mutex->mutex) )
        {
          v70 = _errno_location();
          snprintf(
            tmp42,
            0x1000u,
            "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v70,
            "util.c",
            "parse_notify_equihash",
            2214);
          applog(3, tmp42, 1);
          quit(1);
        }
        selective_yield();
        if ( pool == current_pool() )
          opt_work_update = 1;
        if ( !opt_protocol )
          goto LABEL_163;
        if ( opt_debug )
        {
          if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
            goto LABEL_152;
          snprintf(tmp42, 0x1000u, "job_id: %s", v24);
          applog(7, tmp42, 0);
          if ( !opt_debug )
          {
LABEL_220:
            if ( !opt_debug )
              goto LABEL_163;
            if ( use_syslog )
            {
LABEL_211:
              snprintf(tmp42, 0x1000u, "nbit: %s", v82);
              applog(7, tmp42, 0);
LABEL_212:
              if ( !opt_debug )
                goto LABEL_163;
              if ( use_syslog )
              {
LABEL_200:
                snprintf(tmp42, 0x1000u, "ntime: %s", v80);
                applog(7, tmp42, 0);
LABEL_201:
                if ( !opt_debug )
                  goto LABEL_163;
                if ( use_syslog )
                {
LABEL_203:
                  v69 = "yes";
                  if ( !v11 )
                    v69 = (const char *)&dword_54574;
                  snprintf(tmp42, 0x1000u, "clean: %s", v69);
                  applog(7, tmp42, 0);
                  goto LABEL_163;
                }
LABEL_216:
                if ( !opt_log_output && opt_log_level <= 6 )
                  goto LABEL_163;
                goto LABEL_203;
              }
LABEL_214:
              if ( !opt_log_output && opt_log_level <= 6 )
                goto LABEL_216;
              goto LABEL_200;
            }
LABEL_209:
            if ( !opt_log_output && opt_log_level <= 6 )
              goto LABEL_214;
            goto LABEL_211;
          }
          if ( !use_syslog )
          {
LABEL_152:
            if ( !opt_log_output && opt_log_level <= 6 )
              goto LABEL_156;
          }
          snprintf(tmp42, 0x1000u, "version: %s", ptr);
          applog(7, tmp42, 0);
          if ( !opt_debug )
            goto LABEL_212;
          if ( !use_syslog )
          {
LABEL_156:
            if ( !opt_log_output && opt_log_level <= 6 )
              goto LABEL_160;
          }
          snprintf(tmp42, 0x1000u, "prev_hash: %s", v25);
          applog(7, tmp42, 0);
          if ( !opt_debug )
            goto LABEL_201;
          if ( !use_syslog )
          {
LABEL_160:
            if ( !opt_log_output && opt_log_level <= 6 )
              goto LABEL_207;
          }
          snprintf(tmp42, 0x1000u, "merkle: %s", v26);
          applog(7, tmp42, 0);
        }
        if ( !opt_debug )
        {
LABEL_163:
          v63 = (struct timezone *)(unsigned __int8)set_os_time_12121;
          if ( !set_os_time_12121 )
          {
            hex2bin((unsigned __int8 *)&sockaddr_port, v80, 4u);
            v64 = v63;
            v65 = sockaddr_port;
            gettimeofday(p, v64);
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(tmp42, 0x1000u, "stime.tv_sec %lu, block_ntime %lu\n", p[0].tv_sec, v65);
              applog(5, tmp42, 0);
            }
            if ( (unsigned int)v65 > p[0].tv_sec + 3600 )
            {
              p[0].tv_sec = (__time_t)v65;
              settimeofday(p, 0);
            }
            set_os_time_12121 = 1;
          }
          free(hexstr);
          pool->stratum_notify = 1;
          goto LABEL_23;
        }
        if ( use_syslog )
        {
LABEL_219:
          snprintf(tmp42, 0x1000u, "reserved: %s", v27);
          applog(7, tmp42, 0);
          goto LABEL_220;
        }
LABEL_207:
        if ( !opt_log_output && opt_log_level <= 6 )
          goto LABEL_209;
        goto LABEL_219;
      }
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "%s: Failed to convert header to header_bin, got %s", "parse_notify_equihash", hexstr);
        applog(4, tmp42, 0);
      }
      if ( pthread_rwlock_unlock(rwlock) )
      {
        v79 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v79,
          "util.c",
          "parse_notify_equihash",
          2205);
        applog(3, tmp42, 1);
        quit(1);
      }
      if ( pthread_mutex_unlock(&mutex->mutex) )
      {
        v78 = _errno_location();
        snprintf(
          tmp42,
          0x1000u,
          "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
          *v78,
          "util.c",
          "parse_notify_equihash",
          2205);
        applog(3, tmp42, 1);
        quit(1);
      }
      selective_yield();
      pool_failed(pool);
    }
LABEL_82:
    free(v24);
    goto LABEL_58;
  }
  LOBYTE(v8) = opt_debug;
  if ( opt_debug && (use_syslog || (LOBYTE(v8) = opt_log_output) != 0 || opt_log_level > 6) )
  {
    LOBYTE(v8) = 0;
    snprintf(tmp42, 0x1000u, "JSON decode failed(%d): %s", err.line, err.text);
    applog(7, tmp42, 0);
  }
  return (char)v8;
}
// 2A68C: conditional instruction was optimized away because %hexstr.4!=0
// 29E68: variable 'v2' is possibly undefined
// 29FF8: variable 'hexstr' is possibly undefined
// 2A8CE: variable 'v21' is possibly undefined
// 2A8CE: variable 'v22' is possibly undefined
// 2AC96: variable 'v41' is possibly undefined
// 2AC96: variable 'v42' is possibly undefined
// 2AD3A: variable 'v47' is possibly undefined
// 2AD3A: variable 'v48' is possibly undefined
// 54574: using guessed type int dword_54574;
// 6F91D: using guessed type char set_os_time_12121;

//----- (0002AE94) --------------------------------------------------------
bool __fastcall parse_method(pool *pool, char *s)
{
  return s && parse_method_0(pool, s);
}

//----- (0002AEA0) --------------------------------------------------------
bool __fastcall auth_stratum(pool *pool)
{
  char *rpc_user; // r3
  int v3; // r2
  ssize_t v4; // r0
  _BOOL4 v5; // r8
  _BOOL4 v6; // r6
  char *v7; // r0
  char *v8; // r4
  json_t *v10; // r9
  json_t *v11; // r4
  json_t *v12; // r0
  char *v13; // r4
  size_t refcount; // r3
  size_t v15; // r3
  char *v16; // r0
  int v17; // r3
  int v18; // r2
  ssize_t v19; // r0
  int v20; // r2
  ssize_t v21; // r0
  char *rpc_pass; // [sp+0h] [bp-310Ch]
  json_error_t err; // [sp+Ch] [bp-3100h] BYREF
  char tmp42[4096]; // [sp+108h] [bp-3004h] BYREF
  char s[8196]; // [sp+1108h] [bp-2004h] BYREF

  rpc_user = pool->rpc_user;
  v3 = swork_id;
  rpc_pass = pool->rpc_pass;
  ++swork_id;
  sprintf(s, "{\"id\": %d, \"method\": \"mining.authorize\", \"params\": [\"%s\", \"%s\"]}", v3, rpc_user, rpc_pass);
  v4 = strlen(s);
  v5 = stratum_send(pool, s, v4);
  if ( v5 )
  {
    while ( 1 )
    {
      v7 = recv_line(pool);
      v8 = v7;
      if ( !v7 )
        goto LABEL_6;
      v6 = parse_method_0(pool, v7);
      if ( !v6 )
        break;
      free(v8);
    }
    v10 = json_loads(v8, 0, &err);
    free(v8);
    v11 = json_object_get(v10, "result");
    v12 = json_object_get(v10, "error");
    if ( !v11 || v11->type == JSON_FALSE )
    {
      if ( !v12 )
      {
        v16 = (char *)malloc(0x11u);
        v13 = v16;
        if ( v16 )
          strcpy(v16, "(unknown reason)");
        goto LABEL_13;
      }
    }
    else if ( !v12 || v12->type == JSON_NULL )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "Stratum authorisation success for pool %d", pool->pool_no);
        applog(7, tmp42, 0);
      }
      v17 = opt_suggest_diff;
      successful_connect = 1;
      pool->probed = 1;
      if ( v17 )
      {
        v20 = swork_id++;
        sprintf(s, "{\"id\": %d, \"method\": \"mining.suggest_difficulty\", \"params\": [%d]}", v20, v17);
        v21 = strlen(s);
        stratum_send(pool, s, v21);
      }
      LOBYTE(v6) = v5;
      if ( opt_multi_version )
      {
        v18 = swork_id++;
        sprintf(s, "{\"id\": %d, \"method\": \"mining.multi_version\", \"params\": [%d]}", v18, opt_multi_version);
        v19 = strlen(s);
        stratum_send(pool, s, v19);
      }
      goto out_0;
    }
    v13 = json_dumps(v12, 3u);
LABEL_13:
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "pool %d JSON stratum auth failed: %s", pool->pool_no, v13);
      applog(7, tmp42, 0);
    }
    free(v13);
    suspend_stratum(pool);
out_0:
    if ( v10 )
    {
      refcount = v10->refcount;
      if ( refcount != -1 )
      {
        v15 = refcount - 1;
        v10->refcount = v15;
        if ( !v15 )
          json_delete(v10);
      }
    }
    return v6;
  }
LABEL_6:
  LOBYTE(v6) = 0;
  return v6;
}

//----- (0002B0FC) --------------------------------------------------------
bool __fastcall subscribe_extranonce(pool *pool)
{
  int v2; // r2
  ssize_t v3; // r0
  _BOOL4 v4; // r7
  char *v5; // r0
  char *v6; // r4
  _BOOL4 v7; // r6
  json_t *v8; // r8
  json_t *v9; // r7
  json_t *v10; // r0
  const json_t *v11; // r4
  const char *v12; // r7
  char *v13; // r4
  size_t refcount; // r3
  size_t v15; // r3
  char *v16; // r0
  json_error_t err; // [sp+Ch] [bp-30FCh] BYREF
  char tmp42[4096]; // [sp+108h] [bp-3000h] BYREF
  char s[8192]; // [sp+1108h] [bp-2000h] BYREF

  v2 = swork_id++;
  sprintf(s, "{\"id\": %d, \"method\": \"mining.extranonce.subscribe\", \"params\": []}", v2);
  v3 = strlen(s);
  v4 = stratum_send(pool, s, v3);
  if ( v4 )
  {
    while ( 1 )
    {
      v7 = socket_full(pool->sock, 2);
      if ( !v7 )
      {
        if ( opt_debug )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 6 )
          {
            LOBYTE(v4) = opt_debug;
            strcpy(tmp42, "Timed out waiting for response extranonce.subscribe");
            applog(7, tmp42, 0);
          }
          else
          {
            LOBYTE(v4) = opt_debug;
          }
        }
        goto LABEL_11;
      }
      v5 = recv_line(pool);
      v6 = v5;
      if ( !v5 )
        return (char)v5;
      if ( !parse_method_0(pool, v5) )
        break;
      free(v6);
    }
    v8 = json_loads(v6, 0, &err);
    free(v6);
    v9 = json_object_get(v8, "result");
    v10 = json_object_get(v8, "error");
    v11 = v10;
    if ( !v9 || v9->type == JSON_FALSE )
    {
      if ( !v10 )
      {
        v16 = (char *)malloc(0x11u);
        v13 = v16;
        if ( v16 )
          strcpy(v16, "(unknown reason)");
        goto LABEL_32;
      }
    }
    else if ( !v10 || v10->type == JSON_NULL )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        LOBYTE(v4) = v7;
        snprintf(tmp42, 0x1000u, "Stratum extranonce subscribe for pool %d", pool->pool_no);
        applog(6, tmp42, 0);
        goto LABEL_25;
      }
LABEL_44:
      LOBYTE(v4) = v7;
      goto LABEL_25;
    }
    v12 = _json_array_string(v10, 1u);
    if ( !v12 && (v12 = json_string_value(v11)) == 0
      || strcmp(v12, "Method 'subscribe' not found for service 'mining.extranonce'")
      && strcmp(v12, "Unrecognized request provided") )
    {
      v13 = json_dumps(v11, 3u);
LABEL_32:
      if ( use_syslog || opt_log_output || opt_log_level > 5 )
      {
        snprintf(tmp42, 0x1000u, "Pool %d JSON extranonce subscribe failed: %s", pool->pool_no, v13);
        applog(6, tmp42, 0);
      }
      LOBYTE(v4) = 0;
      free(v13);
      goto LABEL_25;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 5 )
    {
      LOBYTE(v4) = v7;
      snprintf(tmp42, 0x1000u, "Cannot subscribe to mining.extranonce for pool %d", pool->pool_no);
      applog(6, tmp42, 0);
LABEL_25:
      if ( v8 )
      {
        refcount = v8->refcount;
        if ( refcount != -1 )
        {
          v15 = refcount - 1;
          v8->refcount = v15;
          if ( !v15 )
            json_delete(v8);
        }
      }
      goto LABEL_11;
    }
    goto LABEL_44;
  }
LABEL_11:
  LOBYTE(v5) = v4;
  return (char)v5;
}

//----- (0002B3B0) --------------------------------------------------------
void __fastcall dev_error(cgpu_info *dev, dev_reason reason)
{
  dev->device_last_not_well = time(0);
  dev->device_not_well_reason = reason;
  switch ( reason )
  {
    case dev_reason::REASON_THREAD_FAIL_INIT:
      ++dev->thread_fail_init_count;
      break;
    case dev_reason::REASON_THREAD_ZERO_HASH:
      ++dev->thread_zero_hash_count;
      break;
    case dev_reason::REASON_THREAD_FAIL_QUEUE:
      ++dev->thread_fail_queue_count;
      break;
    case dev_reason::REASON_DEV_SICK_IDLE_60:
      ++dev->dev_sick_idle_60_count;
      break;
    case dev_reason::REASON_DEV_DEAD_IDLE_600:
      ++dev->dev_dead_idle_600_count;
      break;
    case dev_reason::REASON_DEV_NOSTART:
      ++dev->dev_nostart_count;
      break;
    case dev_reason::REASON_DEV_OVER_HEAT:
      ++dev->dev_over_heat_count;
      break;
    case dev_reason::REASON_DEV_THERMAL_CUTOFF:
      ++dev->dev_thermal_cutoff_count;
      break;
    case dev_reason::REASON_DEV_COMMS_ERROR:
      ++dev->dev_comms_error_count;
      break;
    case dev_reason::REASON_DEV_THROTTLE:
      ++dev->dev_throttle_count;
      break;
    default:
      return;
  }
}

//----- (0002B44C) --------------------------------------------------------
void *__fastcall realloc_strcat(char *ptr, char *s)
{
  char *v4; // r4
  size_t v5; // r0
  size_t v6; // r4
  char *v7; // r0
  size_t v8; // r0
  char *v9; // r0
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = ptr;
  v5 = strlen(s);
  if ( !v5 )
    return v4;
  v6 = v5;
  v7 = ptr;
  if ( ptr )
    v7 = (char *)strlen(ptr);
  v8 = (size_t)&v7[v6 + 1];
  if ( v8 << 30 )
    v8 = (v8 & 0xFFFFFFFC) + 4;
  v9 = (char *)malloc(v8);
  v4 = v9;
  if ( !v9 )
  {
    snprintf(tmp42, 0x1000u, "Failed to malloc in %s %s():%d", "util.c", &_func___12266.__size[16], 3705);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( ptr )
  {
    sprintf(v9, "%s%s", ptr, s);
    free(ptr);
    return v4;
  }
  strcpy(v9, s);
  return v4;
}

//----- (0002B4F8) --------------------------------------------------------
void *__fastcall str_text(char *ptr)
{
  size_t v2; // r0
  void *v3; // r0
  void *v4; // r7
  char *v5; // r5
  char *i; // r4
  int v7; // r2
  int v8; // t1
  char *v10; // r3
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( !ptr )
  {
    v10 = (char *)malloc(7u);
    if ( !v10 )
    {
      snprintf(tmp42, 0x1000u, "Failed to malloc null in %s %s():%d", "util.c", "str_text", 3730);
      applog(3, tmp42, 1);
      quit(1);
    }
    strcpy(v10, "(null)");
  }
  v2 = strlen(ptr);
  v3 = malloc(4 * v2 + 5);
  v4 = v3;
  if ( !v3 )
  {
    snprintf(tmp42, 0x1000u, "Failed to malloc txt in %s %s():%d", "util.c", "str_text", 3737);
    applog(3, tmp42, 1);
    quit(1);
  }
  v5 = ptr - 1;
  for ( i = (char *)v3; ; i += 4 )
  {
    while ( 1 )
    {
      v8 = (unsigned __int8)*++v5;
      v7 = v8;
      if ( (unsigned int)(v8 - 32) > 0x5E )
        break;
      *i++ = v7;
    }
    sprintf(i, "0x%02x", v7);
    if ( !*v5 )
      break;
  }
  i[4] = 0;
  return v4;
}

//----- (0002B5E4) --------------------------------------------------------
void __fastcall RenameThread(const char *name)
{
  char buf[20]; // [sp+8h] [bp-14h] BYREF

  snprintf(buf, 0x10u, "cg@%s", name);
  prctl(15, buf, 0);
}

//----- (0002B610) --------------------------------------------------------
void __fastcall cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)
{
  int v7; // r0
  int v8; // r4
  int *v9; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v7 = sem_init(cgsem, 0, 0);
  if ( v7 )
  {
    v8 = v7;
    v9 = _errno_location();
    snprintf(tmp42, 0x1000u, "Failed to sem_init ret=%d errno=%d in %s %s():%d", v8, *v9, file, func, line);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0002B664) --------------------------------------------------------
int __fastcall thr_info_create(thr_info *thr, pthread_attr_t *attr, void *(*start)(void *), void *arg)
{
  cgsem_init(&thr->sem, "util.c", "thr_info_create", 1312);
  return j_pthread_create(&thr->pth, attr, start, arg);
}

//----- (0002B69C) --------------------------------------------------------
void __fastcall cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)
{
  if ( sem_post(cgsem) )
    cgsem_post_0(cgsem, file, func, line);
}

//----- (0002B6C4) --------------------------------------------------------
void *__fastcall completion_thread(void *arg)
{
  pthread_setcanceltype(1, 0);
  (*((void (__fastcall **)(_DWORD))arg + 4))(*((_DWORD *)arg + 5));
  cgsem_post((cgsem_t *)arg, "util.c", "completion_thread", 3963);
  return 0;
}

//----- (0002B6F4) --------------------------------------------------------
void __fastcall cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)
{
  int v8; // r3
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  while ( sem_wait(cgsem) )
  {
    v8 = *_errno_location();
    if ( v8 != 4 )
    {
      snprintf(tmp42, 0x1000u, "Failed to sem_wait errno=%d cgsem=0x%p in %s %s():%d", v8, cgsem, file, func, line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
}

//----- (0002B74C) --------------------------------------------------------
int __fastcall cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)
{
  int v8; // r5
  __time_t tv_sec; // r10
  __syscall_slong_t v10; // r3
  __time_t v11; // r2
  bool v12; // cc
  __syscall_slong_t v13; // r1
  __time_t v14; // r0
  int result; // r0
  timespec abs_timeout; // [sp+18h] [bp-1014h] BYREF
  timeval tv_now; // [sp+20h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+28h] [bp-1004h] BYREF

  gettimeofday(&tv_now, 0);
  v8 = 1000 * tv_now.tv_usec;
  tv_sec = tv_now.tv_sec;
  ms_to_timespec(&abs_timeout, tv_now.tv_usec, ms);
  while ( 1 )
  {
    v10 = abs_timeout.tv_nsec + v8;
    v11 = abs_timeout.tv_sec + tv_sec;
    v12 = abs_timeout.tv_nsec + v8 <= 999999999;
    abs_timeout.tv_sec += tv_sec;
    abs_timeout.tv_nsec += v8;
    if ( v12 )
    {
      if ( v10 < 0 )
      {
        do
        {
          v10 += 1000000000;
          --v11;
        }
        while ( v10 < 0 );
        abs_timeout.tv_sec = v11;
        abs_timeout.tv_nsec = v10;
      }
    }
    else
    {
      v13 = v10 - 1000000000;
      v14 = v11 + 1;
      if ( v10 - 1000000000 > 999999999 )
      {
        v13 = v10 - 2000000000;
        v14 = v11 + 2;
      }
      abs_timeout.tv_sec = v14;
      abs_timeout.tv_nsec = v13;
    }
    result = sem_timedwait(cgsem, &abs_timeout);
    if ( !result )
      break;
    result = *_errno_location();
    if ( result == 110 )
      break;
    if ( result != 4 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "Failed to sem_timedwait errno=%d cgsem=0x%p in %s %s():%d",
        result,
        cgsem,
        file,
        func,
        line);
      applog(3, tmp42, 1);
      quit(1);
    }
  }
  return result;
}

//----- (0002B830) --------------------------------------------------------
void __fastcall cgsem_reset(cgsem_t *cgsem)
{
  int v2; // r0

  do
  {
    while ( 1 )
    {
      v2 = sem_trywait(cgsem);
      if ( v2 < 0 )
        break;
      if ( v2 )
        return;
    }
  }
  while ( *_errno_location() == 4 );
}

//----- (0002B854) --------------------------------------------------------
bool __fastcall cg_completion_timeout(void *fn, void *fnarg, int timeout)
{
  cgsem_t *v6; // r0
  cgsem_t *v7; // r5
  int v8; // r4
  pthread_t pthread[2]; // [sp+Ch] [bp-8h] BYREF

  v6 = (cgsem_t *)malloc(0x18u);
  v7 = v6;
  if ( v6 )
  {
    cgsem_init(v6, "util.c", "cg_completion_timeout", 3977);
    v7[1].__align = (int)fn;
    *(&v7[1].__align + 1) = (int)fnarg;
    pthread_create(pthread, 0, completion_thread, v7);
    v8 = cgsem_mswait(v7, timeout, "util.c", "cg_completion_timeout", 3983);
    if ( v8 )
    {
      pthread_cancel(pthread[0]);
    }
    else
    {
      pthread_join(pthread[0], 0);
      free(v7);
    }
    LOBYTE(v6) = v8 == 0;
  }
  return (char)v6;
}

//----- (0002B8D0) --------------------------------------------------------
void __fastcall cg_memcpy(
        void *dest,
        const void *src,
        unsigned int n,
        const char *file,
        const char *func,
        const int line)
{
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( (int)(n - 1) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(tmp42, 0x1000u, "ERR: Asked to memcpy %u bytes from %s %s():%d", n, file, func, line);
      applog(3, tmp42, 0);
    }
  }
  else
  {
    sub_12058(dest, src, n);
  }
}

//----- (0002B950) --------------------------------------------------------
int __fastcall cg_timeval_subtract(timeval *result, timeval *x, timeval *y)
{
  __time_t v3; // r4
  __suseconds_t v4; // r3

  if ( x->tv_sec > y->tv_sec || x->tv_sec == y->tv_sec && x->tv_usec > y->tv_usec )
    return -1;
  v3 = y->tv_sec - x->tv_sec;
  result->tv_sec = v3;
  v4 = y->tv_usec - x->tv_usec;
  result->tv_usec = v4;
  if ( v4 < 0 )
  {
    result->tv_sec = v3 - 1;
    result->tv_usec = v4 + 1000000;
  }
  return 0;
}

//----- (0002B994) --------------------------------------------------------
void __fastcall rev(unsigned __int8 *s, size_t l)
{
  size_t v2; // r3
  unsigned __int8 *v3; // r4
  unsigned __int8 *v4; // r0
  unsigned __int8 v5; // r5
  unsigned __int8 v6; // t1
  unsigned __int8 v7; // t1

  if ( l != 1 )
  {
    v2 = 0;
    v3 = s - 1;
    v4 = &s[l];
    do
    {
      ++v2;
      v6 = *++v3;
      v5 = v6;
      v7 = *--v4;
      *v3 = v7;
      *v4 = v5;
    }
    while ( v2 < ~v2 + l );
  }
}

//----- (0002B9BC) --------------------------------------------------------
int __fastcall check_asicnum(int asic_num, unsigned __int8 nonce)
{
  unsigned int v2; // r1
  unsigned int v3; // r1
  int v4; // r1
  unsigned int v5; // r1
  unsigned int v6; // r1

  switch ( asic_num )
  {
    case 1:
      return asic_num;
    case 2:
      if ( (nonce & 0x80) != 0x80 )
        asic_num = 1;
      break;
    case 4:
      v4 = nonce & 0xC0;
      if ( v4 == 128 )
        goto LABEL_30;
      if ( v4 != 192 )
      {
        if ( v4 == 64 )
          asic_num = 2;
        else
          asic_num = 1;
      }
      break;
    case 8:
      v5 = nonce & 0xE0;
      if ( v5 == 128 )
        goto LABEL_51;
      if ( v5 <= 0x80 )
      {
        if ( v5 == 64 )
          goto LABEL_30;
        if ( v5 == 96 )
          goto LABEL_50;
        if ( v5 != 32 )
          goto LABEL_9;
        goto LABEL_26;
      }
      if ( v5 == 192 )
        goto LABEL_49;
      if ( v5 != 224 )
      {
        if ( v5 != 160 )
          goto LABEL_9;
        goto LABEL_40;
      }
      break;
    case 16:
      v2 = nonce & 0xF0;
      if ( v2 == 128 )
      {
        asic_num = 9;
      }
      else if ( v2 > 0x80 )
      {
        if ( v2 == 192 )
        {
          asic_num = 13;
        }
        else if ( v2 <= 0xC0 )
        {
          switch ( v2 )
          {
            case 0xA0u:
              asic_num = 11;
              break;
            case 0xB0u:
              asic_num = 12;
              break;
            case 0x90u:
              asic_num = 10;
              break;
            default:
              goto LABEL_9;
          }
        }
        else if ( v2 == 224 )
        {
          asic_num = 15;
        }
        else if ( v2 != 240 )
        {
          if ( v2 != 208 )
            goto LABEL_9;
          asic_num = 14;
        }
      }
      else if ( v2 == 64 )
      {
LABEL_51:
        asic_num = 5;
      }
      else if ( v2 > 0x40 )
      {
        switch ( v2 )
        {
          case '`':
LABEL_49:
            asic_num = 7;
            break;
          case 'p':
            asic_num = 8;
            break;
          case 'P':
LABEL_40:
            asic_num = 6;
            break;
          default:
            goto LABEL_9;
        }
      }
      else
      {
        switch ( v2 )
        {
          case 0x20u:
LABEL_30:
            asic_num = 3;
            break;
          case 0x30u:
LABEL_50:
            asic_num = 4;
            break;
          case 0x10u:
LABEL_26:
            asic_num = 2;
            break;
          default:
            goto LABEL_9;
        }
      }
      break;
    case 32:
      v6 = (unsigned __int8)((nonce & 0xF8) - 8);
      if ( v6 > 0xF0 )
        goto LABEL_9;
      asic_num = _func___12024[v6 + 1928];
      break;
    case 64:
      v3 = (unsigned __int8)((nonce & 0xFC) - 4);
      if ( v3 > 0xF8 )
LABEL_9:
        asic_num = 1;
      else
        asic_num = _func___12024[v3 + 2172];
      break;
    default:
      asic_num = 0;
      break;
  }
  return asic_num;
}

//----- (0002BB0C) --------------------------------------------------------
// Alternative name is 'cg_logwork.part.9'
// local variable allocation has failed, the output may be wrong!
void __fastcall cg_logwork_0(work *work, unsigned __int8 *nonce_bin, bool ok)
{
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v8; // r1
  int v9; // r2
  int v10; // r3
  unsigned __int8 *v11; // r7
  unsigned __int8 *v12; // r5
  int v13; // r1
  int v14; // r2
  int v15; // r1
  int v16; // r3
  int v17; // r2
  int v18; // r1
  int v19; // r2
  int v20; // r3
  unsigned __int8 v21; // r3
  unsigned __int8 v22; // t1
  unsigned __int8 v23; // t1
  unsigned __int8 *v24; // r2
  unsigned __int8 *v25; // r3
  unsigned __int8 v26; // t1
  unsigned __int8 v27; // r0
  unsigned __int8 *v28; // r3
  _BYTE *v29; // r2
  char v30; // r1
  char v31; // t1
  unsigned __int8 v32; // t1
  unsigned __int8 *v33; // r3
  char *v34; // r2
  char v35; // r1
  char v36; // t1
  unsigned __int8 v37; // t1
  char *v38; // r5
  char *v39; // r7
  char *v40; // r8
  char *v41; // r11
  char *v42; // r9
  uint32_t id; // r3
  size_t v44; // r0
  int v45; // r4
  size_t v46; // r0
  uint64_t v47; // r2
  int i; // r4
  size_t v49; // r0
  size_t v50; // r0
  size_t v51; // r0
  size_t v52; // r0
  char *sznonce5; // [sp+24h] [bp-14C8h]
  _BOOL4 v54; // [sp+28h] [bp-14C4h]
  uint64_t v55; // [sp+2Ch] [bp-14C0h]
  bool *v56; // [sp+34h] [bp-14B8h] BYREF
  unsigned __int8 midstate_tmp[32]; // [sp+38h] [bp-14B4h] BYREF
  unsigned __int8 data_tmp[32]; // [sp+58h] [bp-1494h] BYREF
  unsigned __int8 hash_tmp[32]; // [sp+78h] [bp-1474h] BYREF
  _BYTE nonce[80]; // [sp+98h] [bp-1454h] OVERLAPPED BYREF
  char szmsg[1024]; // [sp+E8h] [bp-1404h] BYREF
  char tmp42[4100]; // [sp+4E8h] [bp-1004h] BYREF

  v54 = ok;
  memset(szmsg, 0, sizeof(szmsg));
  memset(&data_tmp[12], 0, 20);
  memset(nonce, 0, sizeof(nonce));
  v5 = *(_DWORD *)&work->midstate[4];
  v6 = *(_DWORD *)&work->midstate[8];
  v7 = *(_DWORD *)&work->midstate[12];
  *(_DWORD *)midstate_tmp = *(_DWORD *)work->midstate;
  *(_DWORD *)&midstate_tmp[4] = v5;
  *(_DWORD *)&midstate_tmp[8] = v6;
  *(_DWORD *)&midstate_tmp[12] = v7;
  v8 = *(_DWORD *)&work->midstate[20];
  v9 = *(_DWORD *)&work->midstate[24];
  v10 = *(_DWORD *)&work->midstate[28];
  *(_DWORD *)&midstate_tmp[16] = *(_DWORD *)&work->midstate[16];
  *(_DWORD *)&midstate_tmp[20] = v8;
  *(_DWORD *)&midstate_tmp[24] = v9;
  *(_DWORD *)&midstate_tmp[28] = v10;
  v11 = data_tmp;
  v12 = (unsigned __int8 *)&v56 + 3;
  v13 = *(_DWORD *)&work->data[68];
  v14 = *(_DWORD *)&work->data[72];
  *(_DWORD *)data_tmp = *(_DWORD *)&work->data[64];
  *(_DWORD *)&data_tmp[4] = v13;
  *(_DWORD *)&data_tmp[8] = v14;
  v15 = *(_DWORD *)&work->hash[4];
  v16 = *(_DWORD *)&work->hash[12];
  v17 = *(_DWORD *)&work->hash[8];
  *(_DWORD *)hash_tmp = *(_DWORD *)work->hash;
  *(_DWORD *)&hash_tmp[4] = v15;
  *(_DWORD *)&hash_tmp[8] = v17;
  *(_DWORD *)&hash_tmp[12] = v16;
  v18 = *(_DWORD *)&work->hash[20];
  v19 = *(_DWORD *)&work->hash[24];
  v20 = *(_DWORD *)&work->hash[28];
  *(_DWORD *)&hash_tmp[16] = *(_DWORD *)&work->hash[16];
  *(_DWORD *)&hash_tmp[20] = v18;
  *(_DWORD *)&hash_tmp[24] = v19;
  *(_DWORD *)&hash_tmp[28] = v20;
  do
  {
    v22 = *++v12;
    v21 = v22;
    v23 = *--v11;
    *v12 = v23;
    *v11 = v21;
  }
  while ( &midstate_tmp[15] != v12 );
  v24 = data_tmp;
  v25 = &data_tmp[12];
  do
  {
    v26 = *--v25;
    v27 = *v24;
    *v24++ = v26;
    *v25 = v27;
  }
  while ( &data_tmp[6] != v25 );
  v28 = &data_tmp[31];
  v29 = nonce;
  do
  {
    v31 = *++v28;
    v30 = v31;
    v32 = *--v29;
    *v28 = v32;
    *v29 = v30;
  }
  while ( &hash_tmp[15] != v28 );
  if ( opt_scrypt )
  {
    memcpy(nonce, work, sizeof(nonce));
    v33 = &hash_tmp[31];
    v34 = szmsg;
    do
    {
      v36 = *++v33;
      v35 = v36;
      v37 = *--v34;
      *v33 = v37;
      *v34 = v35;
    }
    while ( &nonce[39] != v33 );
    *(_DWORD *)nonce = bswap32(16 * bswap32(*(unsigned int *)nonce));
    v38 = bin2hex(nonce, 0x50u);
  }
  else
  {
    v38 = bin2hex(work->data, 0x80u);
  }
  v39 = bin2hex(midstate_tmp, 0x20u);
  v40 = bin2hex(data_tmp, 0xCu);
  v41 = bin2hex(nonce_bin, 4u);
  sznonce5 = bin2hex(nonce_bin, 5u);
  v42 = bin2hex(hash_tmp, 0x20u);
  v55 = share_ndiff(work);
  if ( !strcmp(opt_logwork_path, "screen") )
  {
    if ( v54 )
    {
      sprintf(szmsg, "work %s nonce %s", v38, v41);
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(tmp42, 0x1000u, szmsg);
        applog(3, tmp42, 0);
      }
      v51 = strlen(szmsg);
      fwrite(szmsg, v51, 1u, g_logwork_file);
      fwrite(&word_58FE4, 1u, 1u, g_logwork_file);
      fflush(g_logwork_file);
    }
  }
  else
  {
    v56 = &use_syslog;
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(tmp42, 0x1000u, szmsg);
      applog(3, tmp42, 0);
    }
    if ( g_logwork_file )
    {
      id = work->id;
      if ( v54 )
      {
        sprintf(
          szmsg,
          "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
          "o",
          id,
          v38,
          v39,
          v40,
          sznonce5,
          v42,
          v55);
        v44 = strlen(szmsg);
        fwrite(szmsg, v44, 1u, g_logwork_file);
        fwrite(&word_58FE4, 1u, 1u, g_logwork_file);
        fflush(g_logwork_file);
        if ( g_logwork_asicnum == 1 )
        {
          sprintf(szmsg, "midstate %s data %s nonce %s hash %s", v39, v40, v41, v42);
          v52 = strlen(szmsg);
          fwrite(szmsg, v52, 1u, g_logwork_files[0]);
          fwrite(&word_58FE4, 1u, 1u, g_logwork_files[0]);
          fflush(g_logwork_files[0]);
        }
        else if ( ((g_logwork_asicnum - 32) & 0xFFFFFFDF) == 0 )
        {
          sprintf(szmsg, "midstate %s data %s nonce %s hash %s", v39, v40, v41, v42);
          v45 = check_asicnum(g_logwork_asicnum, *nonce_bin);
          v46 = strlen(szmsg);
          fwrite(szmsg, v46, 1u, g_logwork_files[v45]);
          fwrite(&word_58FE4, 1u, 1u, g_logwork_files[v45]);
          fflush(g_logwork_files[v45]);
        }
        if ( opt_logwork_diff )
        {
          v47 = v55;
          for ( i = 0; i != 64; ++i )
          {
            v47 >>= 1;
            if ( !v47 )
              break;
          }
          if ( opt_debug && (*v56 || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "work diff %lld diffnum %d", v55, i);
            applog(7, tmp42, 0);
          }
          sprintf(szmsg, "midstate %s data %s nonce %s hash %s", v39, v40, v41, v42);
          v49 = strlen(szmsg);
          fwrite(szmsg, v49, 1u, g_logwork_diffs[i]);
          fwrite(&word_58FE4, 1u, 1u, g_logwork_diffs[i]);
          fflush(g_logwork_diffs[i]);
        }
      }
      else
      {
        sprintf(
          szmsg,
          "%s %08x work %s midstate %s data %s nonce %s hash %s diff %lld",
          "x",
          id,
          v38,
          v39,
          v40,
          sznonce5,
          v42,
          v55);
        v50 = strlen(szmsg);
        fwrite(szmsg, v50, 1u, g_logwork_file);
        fwrite(&word_58FE4, 1u, 1u, g_logwork_file);
        fflush(g_logwork_file);
      }
    }
  }
  if ( v38 )
    free(v38);
  if ( v39 )
    free(v39);
  if ( v40 )
    free(v40);
  if ( v41 )
    free(v41);
  if ( sznonce5 )
    free(sznonce5);
  if ( v42 )
    free(v42);
}
// 2BB0C: variables would overlap: ^98.80 and stkvar "nonce" ^98.4(has user info)
// 58FE4: using guessed type __int16 word_58FE4;

//----- (0002C020) --------------------------------------------------------
void __fastcall cg_logwork(work *work, unsigned __int8 *nonce_bin, bool ok)
{
  if ( opt_logwork_path )
    cg_logwork_0(work, nonce_bin, ok);
}

//----- (0002C030) --------------------------------------------------------
void __fastcall cg_logwork_uint32(work *work, uint32_t nonce, bool ok)
{
  unsigned __int8 nonce_bin[8]; // [sp+0h] [bp-8h] BYREF

  if ( opt_logwork_path )
  {
    *(_DWORD *)nonce_bin = nonce;
    nonce_bin[4] = 0;
    cg_logwork_0(work, nonce_bin, ok);
  }
}

//----- (0002C058) --------------------------------------------------------
void __fastcall sha256_transf(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int block_nb)
{
  unsigned __int8 *v3; // r0
  uint32_t *v4; // r5
  uint32_t *v5; // r4
  int v6; // r3
  int v7; // r6
  int v8; // r1
  int v9; // t1
  uint32_t v10; // r5
  uint32_t *v11; // r3
  uint32_t v12; // t1
  sha256_ctx *v13; // r0
  sha256_ctx **v14; // r3
  uint32_t *v15; // r2
  sha256_ctx *v16; // t1
  int v17; // r12
  uint32_t v18; // r3
  uint32_t v19; // r6
  uint32_t v20; // r10
  uint32_t v21; // r9
  uint32_t v22; // r7
  uint32_t v23; // r8
  uint32_t v24; // r11
  uint32_t v25; // lr
  uint32_t v26; // r2
  uint32_t v27; // r4
  uint32_t v28; // r3
  uint32_t v29; // r5
  uint32_t v30; // r1
  uint32_t *v31; // r3
  sha256_ctx **v32; // r1
  sha256_ctx *v33; // t1
  bool v34; // zf
  const unsigned __int8 *sub_block; // [sp+4h] [bp-164h]
  uint32_t *v36; // [sp+8h] [bp-160h]
  const unsigned __int8 *v37; // [sp+14h] [bp-154h]
  uint32_t *h; // [sp+18h] [bp-150h]
  sha256_ctx *v39; // [sp+1Ch] [bp-14Ch] BYREF
  uint32_t wv[8]; // [sp+20h] [bp-148h] BYREF
  uint32_t w[64]; // [sp+40h] [bp-128h] BYREF

  if ( (int)block_nb > 0 )
  {
    h = ctx->h;
    sub_block = message;
    v37 = &message[64 * block_nb];
    v39 = ctx + 1;
    do
    {
      v3 = (unsigned __int8 *)sub_block;
      v4 = &wv[7];
      v5 = w;
      do
      {
        v6 = v3[1];
        v7 = v3[2];
        v8 = v3[3];
        v9 = *v3;
        v3 += 4;
        v4[1] = (v6 << 16) | (v7 << 8) | v8 | (v9 << 24);
        ++v4;
      }
      while ( &w[15] != v4 );
      do
      {
        v10 = v5[14];
        v11 = v5;
        v12 = v5[1];
        ++v5;
        v5[15] = (__ROR4__(v10, 19) ^ __ROR4__(v10, 17) ^ (v10 >> 10))
               + v11[9]
               + *v11
               + (__ROR4__(v12, 18) ^ __ROR4__(v12, 7) ^ (v12 >> 3));
      }
      while ( &w[48] != v5 );
      v13 = v39;
      v14 = &v39;
      v15 = h;
      do
      {
        v16 = (sha256_ctx *)*v15++;
        v14[1] = v16;
        ++v14;
      }
      while ( v13 != (sha256_ctx *)v15 );
      v36 = v15;
      v17 = 0;
      v18 = wv[7];
      v19 = wv[4];
      v20 = wv[5];
      v21 = wv[6];
      v22 = wv[0];
      v23 = wv[1];
      v25 = wv[2];
      v24 = wv[3];
      while ( 1 )
      {
        v26 = (v21 & ~v19 ^ v20 & v19) + (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25)) + w[v17];
        v27 = sha256_k[v17++];
        v28 = v18 + v26 + v27;
        v29 = v24 + v28;
        v30 = (__ROR4__(v22, 13) ^ __ROR4__(v22, 2) ^ __ROR4__(v22, 22)) + ((v25 ^ v23) & v22 ^ v25 & v23) + v28;
        v24 = v25;
        v18 = v21;
        if ( v17 == 64 )
          break;
        v25 = v23;
        v21 = v20;
        v23 = v22;
        v20 = v19;
        v22 = v30;
        v19 = v29;
      }
      wv[0] = v30;
      wv[1] = v22;
      v31 = h;
      v32 = &v39;
      wv[7] = v21;
      wv[4] = v29;
      wv[5] = v19;
      wv[6] = v20;
      wv[2] = v23;
      wv[3] = v25;
      do
      {
        v33 = v32[1];
        ++v32;
        *v31++ += (uint32_t)v33;
      }
      while ( v36 != v31 );
      v34 = v37 == sub_block + 64;
      sub_block += 64;
    }
    while ( !v34 );
  }
}

//----- (0002C1B0) --------------------------------------------------------
void __fastcall sha256_init(sha256_ctx *ctx)
{
  uint32_t *v1; // r2
  sha256_ctx *h; // r3
  unsigned int v3; // t1

  v1 = &sha256_k[63];
  h = (sha256_ctx *)ctx->h;
  do
  {
    v3 = v1[1];
    ++v1;
    h->tot_len = v3;
    h = (sha256_ctx *)((char *)h + 4);
  }
  while ( h != &ctx[1] );
  ctx->tot_len = 0;
  ctx->len = 0;
}

//----- (0002C1D8) --------------------------------------------------------
void __fastcall sha256_update(sha256_ctx *ctx, const unsigned __int8 *message, unsigned int len)
{
  unsigned int v4; // r0
  size_t v7; // r6
  unsigned __int8 *v8; // r0
  unsigned int v9; // r3
  unsigned int v10; // r5
  const unsigned __int8 *v11; // r6
  unsigned int tot_len; // r3

  v4 = ctx->len;
  v7 = 64 - v4;
  v8 = &ctx->block[v4];
  if ( v7 >= len )
    v7 = len;
  memcpy(v8, message, v7);
  v9 = ctx->len + len;
  if ( v9 > 0x3F )
  {
    v10 = len - v7;
    v11 = &message[v7];
    sha256_transf(ctx, ctx->block, 1u);
    sha256_transf(ctx, v11, v10 >> 6);
    memcpy(ctx->block, &v11[v10 & 0xFFFFFFC0], v10 & 0x3F);
    tot_len = ctx->tot_len;
    ctx->len = v10 & 0x3F;
    ctx->tot_len = tot_len + (((v10 >> 6) + 1) << 6);
  }
  else
  {
    ctx->len = v9;
  }
}

//----- (0002C248) --------------------------------------------------------
void __fastcall sha256_final(sha256_ctx *ctx, unsigned __int8 *digest)
{
  unsigned int len; // r3
  unsigned __int8 *block; // r6
  bool v6; // cf
  int v7; // r2
  unsigned int v8; // r7
  size_t v9; // r2
  unsigned __int8 *v10; // r0
  int v11; // r3
  int v12; // r8
  int v13; // r9
  int v14; // r10
  unsigned int v15; // r11
  int v16; // r7
  uint32_t *h; // r3
  sha256_ctx *v18; // r5
  int v19; // t1
  int v20; // [sp+4h] [bp-8h]

  len = ctx->len;
  block = ctx->block;
  v6 = (len & 0x3F) >= 0x38;
  if ( (len & 0x3F) >= 0x38 )
    v7 = 128;
  else
    v7 = 64;
  v8 = ctx->tot_len + len;
  v9 = v7 - len;
  v10 = &block[len];
  if ( (len & 0x3F) >= 0x38 )
    v11 = 124;
  else
    v11 = 60;
  if ( v6 )
    v12 = 125;
  else
    v12 = 61;
  if ( v6 )
    v13 = 126;
  else
    v13 = 62;
  if ( v6 )
    v14 = 127;
  else
    v14 = 63;
  if ( v6 )
    v15 = 2;
  else
    v15 = 1;
  v20 = v11;
  memset(v10, 0, v9);
  v16 = 8 * v8;
  ctx->block[ctx->len] = 0x80;
  block[v14] = v16;
  block[v13] = BYTE1(v16);
  block[v12] = BYTE2(v16);
  block[v20] = HIBYTE(v16);
  sha256_transf(ctx, block, v15);
  h = ctx->h;
  v18 = ctx + 1;
  do
  {
    digest[3] = *h;
    v19 = *h++;
    digest[2] = BYTE1(v19);
    digest[1] = *((_WORD *)h - 1);
    *digest = *((_BYTE *)h - 1);
    digest += 4;
  }
  while ( v18 != (sha256_ctx *)h );
}

//----- (0002C2FC) --------------------------------------------------------
void __fastcall sha256(const unsigned __int8 *message, unsigned int len, unsigned __int8 *digest)
{
  uint32_t *v3; // r3
  uint32_t *h; // r2
  uint32_t v6; // t1
  sha256_ctx ctx; // [sp+0h] [bp-A8h] BYREF

  v3 = &sha256_k[63];
  h = ctx.h;
  do
  {
    v6 = v3[1];
    ++v3;
    *h++ = v6;
  }
  while ( v3 != &sha256_h0[7] );
  ctx.tot_len = 0;
  ctx.len = 0;
  sha256_update(&ctx, message, len);
  sha256_final(&ctx, digest);
}

//----- (0002C340) --------------------------------------------------------
api_data *__fastcall api_add_data_full(api_data *root, char *name, api_data_type type, void *data, bool copy_data)
{
  api_data *v9; // r4
  char *v10; // r0
  api_data *prev; // r3
  api_data *v12; // r9
  api_data *result; // r0
  _DWORD *v14; // r0
  int v15; // r3
  _WORD *v16; // r0
  __int16 v17; // r3
  _QWORD *v18; // r0
  __int64 v19; // r2
  size_t v20; // r5
  void *v21; // r0
  _BYTE *v22; // r0
  char v23; // r3
  _BYTE *v24; // r0
  char v25; // r3
  _DWORD *v26; // r0
  int v27; // r1
  _DWORD *v28; // r2
  int v29; // r0
  _DWORD *v30; // r0
  int v31; // r3

  v9 = (api_data *)malloc(0x18u);
  v10 = _strdup(name);
  v9->type = type;
  v9->name = v10;
  if ( root )
  {
    prev = root->prev;
    v12 = root;
    v9->next = root;
    root->prev = v9;
    v9->prev = prev;
    prev->next = v9;
  }
  else
  {
    v9->prev = v9;
    v12 = v9;
    v9->next = v9;
  }
  v9->data_was_malloc = copy_data;
  if ( !data )
  {
    v9->data_was_malloc = 0;
    data = "(null)";
    v9->type = api_data_type::API_CONST;
LABEL_7:
    v9->data = data;
    return v12;
  }
  if ( !copy_data )
    goto LABEL_7;
  switch ( type )
  {
    case api_data_type::API_UINT8:
      v24 = malloc(4u);
      v25 = *(_BYTE *)data;
      v9->data = v24;
      *v24 = v25;
      return v12;
    case api_data_type::API_INT16:
    case api_data_type::API_UINT16:
      v16 = malloc(4u);
      v17 = *(_WORD *)data;
      v9->data = v16;
      *v16 = v17;
      return v12;
    case api_data_type::API_INT:
    case api_data_type::API_UINT:
    case api_data_type::API_UINT32:
    case api_data_type::API_HEX32:
    case api_data_type::API_TIME:
      v14 = malloc(4u);
      v15 = *(_DWORD *)data;
      v9->data = v14;
      *v14 = v15;
      result = v12;
      break;
    case api_data_type::API_UINT64:
    case api_data_type::API_INT64:
    case api_data_type::API_DOUBLE:
    case api_data_type::API_ELAPSED:
    case api_data_type::API_MHS:
    case api_data_type::API_MHTOTAL:
    case api_data_type::API_UTILITY:
    case api_data_type::API_FREQ:
    case api_data_type::API_HS:
    case api_data_type::API_DIFF:
    case api_data_type::API_PERCENT:
      v18 = malloc(8u);
      v19 = *(_QWORD *)data;
      v9->data = v18;
      *v18 = v19;
      return v12;
    case api_data_type::API_BOOL:
      v22 = malloc(1u);
      v23 = *(_BYTE *)data;
      v9->data = v22;
      *v22 = v23;
      return v12;
    case api_data_type::API_TIMEVAL:
      v26 = malloc(8u);
      v27 = *((_DWORD *)data + 1);
      v28 = v26;
      v29 = *(_DWORD *)data;
      v9->data = v28;
      *v28 = v29;
      v28[1] = v27;
      return v12;
    case api_data_type::API_TEMP:
    case api_data_type::API_VOLTS:
    case api_data_type::API_AVG:
      v30 = malloc(4u);
      v31 = *(_DWORD *)data;
      v9->data = v30;
      *v30 = v31;
      return v12;
    default:
      v20 = strlen((const char *)data) + 1;
      v21 = malloc(v20);
      v9->data = v21;
      memcpy(v21, data, v20);
      return v12;
  }
  return result;
}

//----- (0002C458) --------------------------------------------------------
bool __fastcall io_add(io_data *io_data, char *buf)
{
  size_t v4; // r7
  char *ptr; // r0
  char *cur; // r2
  int v7; // r8
  size_t v8; // r3
  size_t v9; // r5
  char *v10; // r0

  v4 = strlen(buf);
  cur = io_data->cur;
  ptr = io_data->ptr;
  v7 = cur - ptr;
  v8 = cur - ptr + 12 + v4;
  if ( io_data->siz < v8 )
  {
    v9 = io_data->siz + 0x20000;
    if ( v8 > v9 )
      v9 = ((unsigned int)vcvts_n_f32_u32(v8, 0x10u) + 2) << 16;
    v10 = (char *)realloc(ptr, v9);
    cur = &v10[v7];
    io_data->siz = v9;
    io_data->ptr = v10;
    io_data->cur = &v10[v7];
  }
  memcpy(cur, buf, v4 + 1);
  io_data->cur += v4;
  return 1;
}

//----- (0002C4C0) --------------------------------------------------------
void __fastcall doquit(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *ptr; // r4
  char *v6; // r1

  ptr = io_data->ptr;
  if ( isjson )
  {
    LOWORD(v6) = 20132;
    io_data->cur = ptr;
    HIWORD(v6) = (unsigned int)&freq_pll[66].fildiv2 >> 16;
  }
  else
  {
    LOWORD(v6) = 20148;
    io_data->cur = ptr;
    HIWORD(v6) = (unsigned int)&freq_pll[67].fildiv2 >> 16;
  }
  *ptr = 0;
  io_data->close = 0;
  io_add(io_data, v6);
  bye = 1;
  do_a_quit = 1;
}

//----- (0002C500) --------------------------------------------------------
void __fastcall dorestart(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *ptr; // r4
  char *v6; // r1

  ptr = io_data->ptr;
  if ( isjson )
  {
    LOWORD(v6) = 20152;
    io_data->cur = ptr;
    HIWORD(v6) = (unsigned int)&freq_pll[67].vilpll >> 16;
  }
  else
  {
    LOWORD(v6) = 20172;
    io_data->cur = ptr;
    HIWORD(v6) = (unsigned int)&freq_pll[69] >> 16;
  }
  *ptr = 0;
  io_data->close = 0;
  io_add(io_data, v6);
  bye = 1;
  do_a_restart = 1;
}

//----- (0002C540) --------------------------------------------------------
char *__fastcall escape_string(char *str, bool isjson)
{
  unsigned int v2; // r4
  char *v3; // r5
  _BOOL4 v4; // r7
  char *v5; // r2
  unsigned int v6; // r3
  int v7; // r6
  unsigned int v8; // t1
  unsigned int v9; // t1
  size_t v10; // r6
  char *v11; // r3
  char *v12; // r2
  char *v13; // r1
  unsigned int v14; // t1
  char *v15; // r2
  char *v16; // r1
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  v2 = (unsigned __int8)*str;
  v3 = str;
  if ( *str )
  {
    v4 = isjson;
    v5 = str;
    v6 = (unsigned __int8)*str;
    v7 = 0;
    while ( 1 )
    {
      if ( v6 == 61 )
        goto LABEL_11;
      if ( v6 <= 0x3D )
      {
        if ( v6 != 34 )
        {
          if ( v6 != 44 )
            goto LABEL_6;
          if ( isjson )
            goto LABEL_12;
LABEL_5:
          ++v7;
          goto LABEL_6;
        }
        if ( isjson )
          goto LABEL_5;
LABEL_6:
        v8 = (unsigned __int8)*++v5;
        v6 = v8;
        if ( !v8 )
          goto LABEL_13;
      }
      else
      {
        if ( v6 == 92 )
          goto LABEL_5;
        if ( v6 != 124 )
          goto LABEL_6;
LABEL_11:
        if ( !isjson )
          goto LABEL_5;
LABEL_12:
        v9 = (unsigned __int8)*++v5;
        v6 = v9;
        if ( !v9 )
        {
LABEL_13:
          if ( !v7 )
            return str;
          v10 = v7 + 1 + strlen(str);
          str = (char *)malloc(v10);
          if ( !str )
          {
            snprintf(tmp42, 0x1000u, "Failed to malloc escape buf %d in %s %s():%d", v10, "api.c", "escape_string", 840);
            applog(3, tmp42, 1);
            quit(1);
          }
          v11 = str;
          if ( !v2 )
          {
LABEL_27:
            *v11 = v2;
            return str;
          }
          while ( 2 )
          {
            if ( v2 != 61 )
            {
              if ( v2 > 0x3D )
              {
                if ( v2 == 92 )
                {
                  *v11 = 92;
                  v11[1] = 92;
                  v11 += 2;
                  goto LABEL_26;
                }
                if ( v2 != 124 )
                  goto LABEL_35;
              }
              else
              {
                if ( v2 == 34 )
                {
                  v12 = v11 + 1;
                  if ( v4 )
                  {
                    v13 = v11++;
                    *v13 = 92;
                    v12 = v13 + 2;
                  }
                  *v11 = 34;
                  v11 = v12;
                  goto LABEL_26;
                }
                if ( v2 != 44 )
                {
LABEL_35:
                  *v11++ = v2;
                  goto LABEL_26;
                }
              }
            }
            v15 = v11 + 1;
            if ( !v4 )
            {
              v16 = v11++;
              *v16 = 92;
              v15 = v16 + 2;
            }
            *v11 = v2;
            v11 = v15;
LABEL_26:
            v14 = (unsigned __int8)*++v3;
            v2 = v14;
            if ( !v14 )
              goto LABEL_27;
            continue;
          }
        }
      }
    }
  }
  return str;
}

//----- (0002C660) --------------------------------------------------------
void __fastcall head_join(io_data *io_data, char *cmdptr, bool isjson, bool *firstjoin)
{
  char *v6; // r0
  char *v7; // r1
  char *v8; // r5
  char *v9; // r1

  if ( *firstjoin )
  {
    if ( !isjson )
    {
      *firstjoin = 0;
LABEL_4:
      v6 = escape_string(cmdptr, isjson);
      LOWORD(v7) = 20240;
      v8 = v6;
      HIWORD(v7) = (unsigned int)&freq_pll[73] >> 16;
      io_add(io_data, v7);
      io_add(io_data, v8);
      io_add(io_data, (char *)&word_4F67C);
      goto LABEL_5;
    }
    io_add(io_data, "{");
    *firstjoin = 0;
    v8 = escape_string(cmdptr, 1);
  }
  else
  {
    if ( !isjson )
      goto LABEL_4;
    io_add(io_data, ",");
    v8 = escape_string(cmdptr, 1);
  }
  io_add(io_data, "\"");
  io_add(io_data, v8);
  LOWORD(v9) = 21868;
  HIWORD(v9) = (unsigned int)"n_acn%d" >> 16;
  io_add(io_data, v9);
LABEL_5:
  if ( cmdptr != v8 )
    sub_12000(v8);
}
// 4F67C: using guessed type __int16 word_4F67C;

//----- (0002C714) --------------------------------------------------------
bool __fastcall check_connect(sockaddr_storage *cli, char **connectaddr, char *group)
{
  char *v6; // r0
  int v7; // lr
  char *v8; // r12
  in6_addr *p_client_ip; // r0
  char *v10; // r2
  char *v11; // r1
  int v12; // r3
  int v13; // t1
  int v14; // r5
  int v15; // t1
  int v16; // t1
  bool v18; // r4
  in6_addr client_ip; // [sp+10h] [bp-34h] BYREF
  char tmp[36]; // [sp+20h] [bp-24h] BYREF

  v6 = (char *)malloc(0x2Eu);
  *connectaddr = v6;
  getnameinfo((const struct sockaddr *)cli, 0x80u, v6, 0x2Eu, 0, 0, 1u);
  if ( cli->ss_family == 2 )
  {
    sprintf(tmp, "::ffff:%s", *connectaddr);
    inet_pton(10, tmp, &client_ip);
  }
  else
  {
    inet_pton(10, *connectaddr, &client_ip);
  }
  *group = (*_ctype_toupper_loc())[82];
  if ( opt_api_allow )
  {
    if ( ips > 0 )
    {
      v7 = 0;
      v8 = (char *)&ipaccess->ip.__u6_addr8[15];
      while ( 2 )
      {
        p_client_ip = &client_ip;
        v10 = v8 - 16;
        v11 = v8;
        while ( 1 )
        {
          v13 = p_client_ip->__u6_addr8[0];
          p_client_ip = (in6_addr *)((char *)p_client_ip + 1);
          v12 = v13;
          v15 = (unsigned __int8)*++v11;
          v14 = v15;
          v16 = (unsigned __int8)*++v10;
          if ( v16 != (v12 & v14) )
            break;
          if ( v10 == v8 )
          {
            v18 = 1;
            *group = v8[17];
            return v18;
          }
        }
        ++v7;
        v8 += 36;
        if ( v7 != ips )
          continue;
        break;
      }
    }
    return 0;
  }
  else
  {
    v18 = opt_api_network;
    if ( !opt_api_network )
    {
      if ( !strcmp(*connectaddr, "127.0.0.1") )
      {
        return 1;
      }
      else if ( !client_ip.__u6_addr32[0] && __PAIR64__(client_ip.__u6_addr32[1], 0) == client_ip.__u6_addr32[2] )
      {
        return client_ip.__u6_addr32[3] == 0x1000000;
      }
    }
    return v18;
  }
}

//----- (0002C830) --------------------------------------------------------
void mcast()
{
  addrinfo *v0; // r4
  addrinfo *i; // r3
  int v2; // r0
  int *v3; // r0
  char *v4; // r0
  time_t v5; // r6
  int *v6; // r0
  char *v7; // r5
  int ai_family; // r3
  sockaddr *ai_addr; // r3
  in_addr_t v10; // t1
  in_addr_t v11; // r1
  int v12; // r2
  int v13; // r3
  const char *v14; // r11
  size_t v15; // r0
  size_t v16; // r4
  int v17; // r7
  ssize_t v18; // r4
  _BOOL4 v19; // r11
  const char *v20; // r1
  socklen_t v21; // r1
  const char *v22; // r4
  int v23; // r0
  int *v24; // r0
  char *v25; // r0
  addrinfo *v26; // r3
  addrinfo *v27; // r4
  int v28; // r0
  size_t v29; // r0
  ssize_t v30; // r4
  int *v31; // r0
  char *v32; // r0
  int *v33; // r0
  char *v34; // r0
  int mcast_sock; // [sp+10h] [bp-1914h]
  size_t expect_code_len; // [sp+1Ch] [bp-1908h]
  char *expect_code; // [sp+24h] [bp-1900h]
  int fd; // [sp+28h] [bp-18FCh]
  addrinfo *client; // [sp+2Ch] [bp-18F8h]
  char group; // [sp+4Bh] [bp-18D9h] BYREF
  socklen_t came_from_siz; // [sp+4Ch] [bp-18D8h] BYREF
  char *connectaddr; // [sp+50h] [bp-18D4h] BYREF
  addrinfo *res; // [sp+54h] [bp-18D0h] BYREF
  int optval; // [sp+58h] [bp-18CCh] BYREF
  char expect[12]; // [sp+5Ch] [bp-18C8h] BYREF
  char port_s[12]; // [sp+68h] [bp-18BCh] BYREF
  char came_from_port[12]; // [sp+74h] [bp-18B0h] BYREF
  addrinfo hints; // [sp+80h] [bp-18A4h] BYREF
  sockaddr_storage came_from; // [sp+A0h] [bp-1884h] BYREF
  char buf[1024]; // [sp+120h] [bp-1804h] BYREF
  ip_mreq grp; // [sp+520h] [bp-1404h] BYREF
  int v52; // [sp+528h] [bp-13FCh]
  int v53; // [sp+52Ch] [bp-13F8h]
  int v54; // [sp+530h] [bp-13F4h]
  char tmp42[4100]; // [sp+920h] [bp-1004h] BYREF

  strcpy(expect, "cgminer-");
  sprintf(port_s, "%d", opt_api_mcast_port);
  memset(&hints, 0, sizeof(hints));
  if ( getaddrinfo(opt_api_mcast_addr, port_s, &hints, &res) )
  {
    strcpy(tmp42, "Invalid API Multicast Address");
    applog(3, tmp42, 1);
    quit(1);
  }
  v0 = res;
  if ( !res )
  {
LABEL_17:
    freeaddrinfo(res);
    strcpy(tmp42, "API mcast could not open socket");
    applog(3, tmp42, 1);
    quit(1);
  }
  for ( i = res; ; i = res )
  {
    v2 = socket(i->ai_family, 2, 0);
    if ( v2 > 0 )
    {
      mcast_sock = v2;
      goto LABEL_9;
    }
    v0 = v0->ai_next;
    if ( !v0 )
      break;
  }
  mcast_sock = v2;
  if ( v2 == -1 )
    goto LABEL_17;
LABEL_9:
  optval = 1;
  if ( setsockopt(mcast_sock, 1, 2, &optval, 4u) < 0 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      goto die;
    v3 = _errno_location();
    v4 = strerror(*v3);
    snprintf(
      tmp42,
      0x1000u,
      "API mcast setsockopt SO_REUSEADDR failed (%s)%s",
      v4,
      " - API multicast listener will not be available");
    goto LABEL_14;
  }
  v5 = time(0);
  while ( 1 )
  {
    if ( bind(mcast_sock, v0->ai_addr, v0->ai_addrlen) >= 0 )
    {
      ai_family = v0->ai_family;
      if ( ai_family == 2 )
      {
        grp.imr_multiaddr.s_addr = 0;
        grp.imr_interface.s_addr = 0;
        grp.imr_multiaddr.s_addr = *(_DWORD *)&v0->ai_addr->sa_data[2];
        if ( setsockopt(mcast_sock, 0, 35, &grp, 8u) >= 0 )
        {
LABEL_25:
          freeaddrinfo(res);
          v14 = opt_api_mcast_code;
          v15 = strlen(opt_api_mcast_code);
          v16 = v15 + 10;
          expect_code_len = v15 + 9;
          expect_code = (char *)malloc(v15 + 10);
          if ( !expect_code )
          {
            strcpy(tmp42, "Failed to malloc mcast expect_code");
            applog(3, tmp42, 1);
            quit(1);
          }
          fd = -1;
          v17 = 0;
          snprintf(expect_code, v16, "%s%s-", expect, v14);
          while ( 1 )
          {
            do
            {
              while ( 1 )
              {
                cgsleep_ms(1000);
                came_from_siz = 128;
                ++v17;
                v18 = recvfrom(mcast_sock, buf, 0x3FFu, 0, (struct sockaddr *)&came_from, &came_from_siz);
                if ( v18 >= 0 )
                  break;
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  v24 = _errno_location();
                  v25 = strerror(*v24);
                  snprintf(tmp42, 0x1000u, "API mcast failed count=%d (%s) (%d)", v17, v25, mcast_sock);
                  applog(7, tmp42, 0);
                }
              }
              v19 = check_connect(&came_from, &connectaddr, &group);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                v20 = "Ignored";
                if ( v19 )
                  v20 = "Accepted";
                snprintf(tmp42, 0x1000u, "API mcast from %s - %s", connectaddr, v20);
                applog(7, tmp42, 0);
              }
            }
            while ( !v19 );
            v21 = came_from_siz;
            buf[v18] = 0;
            if ( v18 )
            {
              if ( buf[v18 - 1] == 10 )
                buf[--v18] = 0;
              getnameinfo((const struct sockaddr *)&came_from, v21, 0, 0, came_from_port, 0xAu, 1u);
              if ( opt_debug )
              {
LABEL_58:
                if ( use_syslog || opt_log_output || opt_log_level > 6 )
                {
                  snprintf(
                    tmp42,
                    0x1000u,
                    "API mcast request rep=%d (%s) from [%s]:%s",
                    v18,
                    buf,
                    connectaddr,
                    came_from_port);
                  applog(7, tmp42, 0);
                }
                if ( expect_code_len < v18 && !memcmp(buf, expect_code, expect_code_len) )
                  goto LABEL_42;
                if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  strcpy(tmp42, "API mcast request was no good");
                  applog(7, tmp42, 0);
                }
              }
              else if ( expect_code_len < v18 && !memcmp(buf, expect_code, expect_code_len) )
              {
LABEL_42:
                v22 = &buf[expect_code_len];
                v23 = strtol(&buf[expect_code_len], 0, 10);
                if ( (unsigned int)(v23 - 1) <= 0xFFFE )
                {
                  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                  {
                    snprintf(tmp42, 0x1000u, "API mcast request OK port %s=%d", v22, v23);
                    applog(7, tmp42, 0);
                  }
                  if ( getaddrinfo(connectaddr, v22, &hints, &res) )
                  {
                    if ( use_syslog || opt_log_output || opt_log_level > 2 )
                    {
                      snprintf(tmp42, 0x1000u, "Invalid client address %s", connectaddr);
                      goto LABEL_79;
                    }
                  }
                  else
                  {
                    v26 = res;
                    client = res;
                    v27 = res;
                    if ( res )
                    {
                      while ( 1 )
                      {
                        v28 = socket(v26->ai_family, 2, 0);
                        if ( mcast_sock > 0 )
                          break;
                        v27 = v27->ai_next;
                        if ( !v27 )
                          break;
                        v26 = res;
                      }
                      fd = v28;
                      client = v27;
                    }
                    if ( fd == -1 )
                    {
                      freeaddrinfo(res);
                      if ( use_syslog || opt_log_output || opt_log_level > 2 )
                      {
                        snprintf(tmp42, 0x1000u, "API mcast could not open socket to client %s", connectaddr);
LABEL_79:
                        applog(3, tmp42, 0);
                      }
                    }
                    else
                    {
                      snprintf((char *)&grp, 0x400u, "cgm-FTW-%d-%s", opt_api_port, opt_api_mcast_des);
                      v29 = strlen((const char *)&grp);
                      v30 = sendto(fd, &grp, v29 + 1, 0, client->ai_addr, client->ai_addrlen);
                      freeaddrinfo(res);
                      if ( v30 < 0 )
                      {
                        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                        {
                          v31 = _errno_location();
                          v32 = strerror(*v31);
                          snprintf(tmp42, 0x1000u, "API mcast send reply failed (%s) (%d)", v32, fd);
                          applog(7, tmp42, 0);
                        }
                      }
                      else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                      {
                        snprintf(tmp42, 0x1000u, "API mcast send reply (%s) succeeded (%d) (%d)", &grp, v30, fd);
                        applog(7, tmp42, 0);
                      }
                      close(fd);
                    }
                  }
                }
                else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(tmp42, 0x1000u, "API mcast request ignored - invalid port (%s)", v22);
                  applog(7, tmp42, 0);
                }
              }
            }
            else
            {
              getnameinfo((const struct sockaddr *)&came_from, v21, 0, 0, came_from_port, 0xAu, 1u);
              if ( opt_debug )
                goto LABEL_58;
            }
          }
        }
      }
      else
      {
        if ( ai_family != 10 )
          goto LABEL_25;
        ai_addr = v0->ai_addr;
        v10 = *(_DWORD *)&ai_addr->sa_data[6];
        ai_addr = (sockaddr *)((char *)ai_addr + 8);
        v11 = *(_DWORD *)&ai_addr->sa_data[2];
        v12 = *(_DWORD *)&ai_addr->sa_data[6];
        v13 = *(_DWORD *)&ai_addr->sa_data[10];
        grp.imr_multiaddr.s_addr = v10;
        grp.imr_interface.s_addr = v11;
        v52 = v12;
        v53 = v13;
        v54 = 0;
        if ( setsockopt(mcast_sock, 41, 20, &grp, 0x14u) >= 0 )
          goto LABEL_25;
      }
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        goto die;
      v33 = _errno_location();
      v34 = strerror(*v33);
      snprintf(tmp42, 0x1000u, "API mcast join failed (%s)%s", v34, " - API multicast listener will not be available");
LABEL_14:
      applog(3, tmp42, 0);
      goto die;
    }
    v6 = _errno_location();
    v7 = strerror(*v6);
    if ( time(0) - v5 > 61 )
      break;
    cgsleep_ms(30000);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "API mcast bind to port %d failed (%s)%s",
      opt_api_mcast_port,
      v7,
      " - API multicast listener will not be available");
    applog(3, tmp42, 0);
  }
die:
  close(mcast_sock);
}

//----- (0002CF94) --------------------------------------------------------
void *__fastcall mcast_thread(void *userdata)
{
  pthread_t v2; // r0

  v2 = pthread_self();
  pthread_detach(v2);
  pthread_setcanceltype(1, 0);
  RenameThread("APIMcast");
  mcast();
  *((_DWORD *)userdata + 3) = 0;
  return 0;
}

//----- (0002CFC0) --------------------------------------------------------
void __fastcall tail_join(io_data *io_data, bool isjson)
{
  _BOOL4 v3; // r5
  char *v4; // r1

  v3 = isjson;
  if ( !io_data->close )
  {
    if ( !isjson )
      return;
LABEL_5:
    LOWORD(v4) = 20988;
    HIWORD(v4) = (unsigned int)"set_baud" >> 16;
    io_add(io_data, v4);
    j_io_add(io_data, (char *)&word_59A90);
    return;
  }
  io_add(io_data, (char *)&word_59A90);
  io_data->close = 0;
  if ( v3 )
    goto LABEL_5;
}
// 59A90: using guessed type __int16 word_59A90;

//----- (0002D004) --------------------------------------------------------
// Alternative name is 'add_item_buf.isra.2'
void __fastcall add_item_buf(K_ITEM *item, const char *str)
{
  const char *name; // r6
  size_t v5; // r0
  int v6; // r7
  size_t v7; // r4
  unsigned int v8; // r1
  size_t v9; // r10
  char *v10; // r6
  int v11; // r11
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  name = item->name;
  v5 = strlen(str);
  v6 = *((_DWORD *)name + 1);
  v7 = v5;
  v8 = *((_DWORD *)name + 2);
  v9 = v5 + 1;
  v10 = *(char **)name;
  if ( v6 + 1 + v5 > v8 )
  {
    v11 = v5 + 4097 - (v9 & 0xFFF);
    v10 = (char *)realloc(v10, v8 + v11);
    *(_DWORD *)item->name = v10;
    if ( !v10 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "OOM buf siz=%d tot=%d ext=%d in %s %s():%d",
        v7,
        *((_DWORD *)item->name + 2),
        v11,
        "api.c",
        "add_item_buf",
        1179);
      applog(3, tmp42, 1);
      quit(1);
    }
    *((_DWORD *)item->name + 2) += v11;
  }
  memcpy(&v10[v6], str, v9);
  *((_DWORD *)item->name + 1) += v7;
}

//----- (0002D0B8) --------------------------------------------------------
// Alternative name is 'send_result.isra.6'
void __fastcall send_result(io_data *io_data, int c, int isjson, int a4)
{
  const char *v7; // r11
  size_t v8; // r0
  size_t v9; // r2
  const char *v10; // r3
  signed int v11; // r5
  int v12; // r6
  int v13; // r3
  int v14; // r10
  _BOOL4 v15; // r3
  fd_set *p_tv_usec; // r3
  int v17; // r0
  ssize_t v18; // r0
  ssize_t v19; // r7
  int v20; // r0
  char *v21; // r0
  int count; // [sp+Ch] [bp-10A0h]
  int v23; // [sp+10h] [bp-109Ch]
  int tosend; // [sp+14h] [bp-1098h]
  timeval timeout; // [sp+20h] [bp-108Ch] BYREF
  fd_set wd; // [sp+28h] [bp-1084h] BYREF
  char tmp42[4100]; // [sp+A8h] [bp-1004h] BYREF

  v7 = (const char *)io_data;
  v8 = strlen((const char *)io_data);
  v9 = v8;
  if ( c )
  {
    v9 = v8 + 1;
    *(_WORD *)&v7[v8] = 93;
  }
  if ( a4 )
  {
    strcpy((char *)&v7[v9], ",\"id\":1}");
    v9 = strlen(v7);
  }
  tosend = v9 + 1;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v10 = &byte_59398;
    if ( v9 > 0xA )
      v10 = "...";
    snprintf(tmp42, 0x1000u, "API: send reply: (%d) '%.10s%s'", tosend, v7, v10);
    applog(7, tmp42, 0);
  }
  v11 = tosend;
  v12 = (isjson + 31) & (isjson >> 31);
  if ( isjson >= 0 )
    v12 = isjson;
  LOBYTE(v13) = isjson & 0x1F;
  if ( isjson <= 0 )
    v13 = -(-isjson & 0x1F);
  v14 = 0;
  count = 0;
  v23 = 1 << v13;
  while ( 1 )
  {
    v15 = count <= 4;
    if ( v11 <= 0 )
      v15 = 0;
    if ( !v15 )
      break;
    p_tv_usec = (fd_set *)&timeout.tv_usec;
    timeout.tv_sec = 0;
    timeout.tv_usec = 50000;
    do
    {
      p_tv_usec->fds_bits[1] = 0;
      p_tv_usec = (fd_set *)((char *)p_tv_usec + 4);
    }
    while ( &wd.fds_bits[31] != (__fd_mask *)p_tv_usec );
    wd.fds_bits[v12 >> 5] |= v23;
    v17 = select(isjson + 1, 0, &wd, 0, &timeout);
    if ( v17 <= 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "API: send select failed (%d)", v17);
        applog(4, tmp42, 0);
      }
      return;
    }
    v18 = send(isjson, v7, v11, 0);
    v19 = v18;
    ++v14;
    if ( v18 < 0 )
    {
      v20 = *_errno_location();
      if ( v20 != 11 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          v21 = strerror(v20);
          snprintf(tmp42, 0x1000u, "API: send (%d:%d) failed: %s", tosend, tosend - v11, v21);
          applog(4, tmp42, 0);
        }
        return;
      }
LABEL_29:
      ++count;
    }
    else if ( v14 == 1 )
    {
      if ( v11 != v18 )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42, 0x1000u, "API: sent %d of %d first go", v18, v11);
          applog(7, tmp42, 0);
        }
        goto LABEL_28;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "API: sent all of %d first go", v11);
        applog(7, tmp42, 0);
      }
LABEL_49:
      v11 -= v19;
      v7 += v19;
    }
    else if ( v11 == v18 )
    {
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        goto LABEL_49;
      snprintf(tmp42, 0x1000u, "API: sent all of remaining %d (sendc=%d)", v11, v14);
      v11 -= v19;
      applog(7, tmp42, 0);
      v7 += v19;
    }
    else
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "API: sent %d of remaining %d (sendc=%d)", v18, v11, v14);
        applog(7, tmp42, 0);
      }
LABEL_28:
      v11 -= v19;
      v7 += v19;
      if ( !v19 )
        goto LABEL_29;
    }
  }
}
// 59398: using guessed type char byte_59398;
// 59A90: using guessed type __int16 word_59A90;

//----- (0002D43C) --------------------------------------------------------
// Alternative name is 'copyadvanceafter.constprop.20'
void __fastcall copyadvanceafter(unsigned __int8 **ch, char **param, char **buf)
{
  _BYTE *v3; // r2
  int v4; // r3
  char *v5; // r2
  bool v6; // zf
  _BYTE *v7; // r3
  char *v8; // r3

  v3 = *ch;
  v4 = **ch;
  if ( **ch )
  {
    while ( v4 != 44 )
    {
      v6 = v4 == 92;
      v7 = v3;
      if ( v6 && v3[1] )
        v7 = v3 + 1;
      *ch = v7 + 1;
      v5 = (*param)++;
      *v5 = *v7;
      v3 = *ch;
      v4 = **ch;
      if ( !**ch )
        goto LABEL_10;
    }
    *ch = v3 + 1;
  }
LABEL_10:
  v8 = (*param)++;
  *v8 = 0;
}

//----- (0002D484) --------------------------------------------------------
bool __fastcall pooldetails(char *param, char **url, char **user, char **pass)
{
  size_t v7; // r0
  char *v8; // r0
  char **v9; // r2
  char *v10; // r4
  char **v11; // r2
  char **v12; // r2
  unsigned __int8 *v14[2]; // [sp+4h] [bp-100Ch] BYREF
  char *buf; // [sp+Ch] [bp-1004h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  v14[0] = (unsigned __int8 *)param;
  v7 = strlen(param);
  v8 = (char *)malloc(v7 + 1);
  v10 = v8;
  buf = v8;
  if ( !v8 )
  {
    strcpy(tmp42, "Failed to malloc pooldetails buf");
    applog(3, tmp42, 1);
    quit(1);
  }
  *url = v8;
  copyadvanceafter(v14, &buf, v9);
  if ( *v14[0] && (*user = buf, copyadvanceafter(v14, &buf, v11), *v14[0]) )
  {
    *pass = buf;
    copyadvanceafter(v14, &buf, v12);
    return 1;
  }
  else
  {
    free(v10);
    return 0;
  }
}
// 2D4AE: variable 'v9' is possibly undefined
// 2D4C0: variable 'v11' is possibly undefined
// 2D4E6: variable 'v12' is possibly undefined

//----- (0002D528) --------------------------------------------------------
// Alternative name is '_rd_lock.constprop.25'
void __fastcall rd_lock_0(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_rwlock_rdlock(lock) )
  {
    v6 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "api.c", file, func);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (0002D580) --------------------------------------------------------
// Alternative name is '_mutex_lock.part.3.constprop.27'
void __fastcall __noreturn mutex_lock_1(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v6, "api.c", (const char *)lock, file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0002D5CC) --------------------------------------------------------
// Alternative name is '_rw_unlock.part.4.constprop.30'
void __fastcall __noreturn rw_unlock_0(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(tmp42, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "api.c", (const char *)lock, file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0002D618) --------------------------------------------------------
// Alternative name is '_mutex_unlock_noyield.part.5.constprop.32'
void __fastcall __noreturn mutex_unlock_noyield_1(
        pthread_mutex_t *lock,
        const char *file,
        const char *func,
        const int line)
{
  int *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v6 = _errno_location();
  snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v6, "api.c", (const char *)lock, file);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0002D664) --------------------------------------------------------
void __fastcall tidyup(void *arg)
{
  const char *v2; // r2
  int v3; // r3
  int v4; // r0
  io_list *v5; // r6
  io_list *v6; // r4
  io_list *next; // r5
  io_list *v8; // r0
  const char *v9; // r2
  int v10; // r3

  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___12372, (const char *)0x120C, v2, v3);
  v4 = *(_DWORD *)arg;
  bye = 1;
  if ( v4 != -1 )
  {
    shutdown(v4, 2);
    close(*(_DWORD *)arg);
    *(_DWORD *)arg = -1;
  }
  if ( ipaccess )
  {
    free(ipaccess);
    ipaccess = 0;
  }
  v5 = io_head;
  if ( io_head )
  {
    v6 = io_head;
    do
    {
      next = v6->next;
      free(v6->io_data->ptr);
      free(v6->io_data);
      v8 = v6;
      v6 = next;
      free(v8);
    }
    while ( v5 != next );
    io_head = 0;
  }
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___12372, (const char *)0x1221, v9, v10);
  selective_yield();
}
// 2D6E8: variable 'v2' is possibly undefined
// 2D6E8: variable 'v3' is possibly undefined
// 2D6F4: variable 'v9' is possibly undefined
// 2D6F4: variable 'v10' is possibly undefined

//----- (0002D704) --------------------------------------------------------
void *__fastcall __noreturn quit_thread(void *userdata)
{
  int *v1; // r0
  int *v2; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( !pthread_mutex_lock(&quit_restart_lock) )
  {
    if ( !pthread_mutex_unlock(&quit_restart_lock) )
    {
      selective_yield();
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        strcpy(tmp42, "API: killing cgminer");
        applog(7, tmp42, 0);
      }
      kill_work();
    }
    v2 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v2,
      "api.c",
      &_func___12372.__size[8],
      4938);
    applog(3, tmp42, 1);
    quit(1);
  }
  v1 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
    *v1,
    "api.c",
    &_func___12372.__size[8],
    4937);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0002D81C) --------------------------------------------------------
void *__fastcall restart_thread_0(void *userdata)
{
  int *v2; // r0
  int *v3; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_mutex_lock(&quit_restart_lock) )
  {
    v2 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v2,
      "api.c",
      &_func___12372.__size[20],
      4951);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&quit_restart_lock) )
  {
    v3 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v3,
      "api.c",
      &_func___12372.__size[20],
      4952);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "API: restarting cgminer");
    applog(7, tmp42, 0);
  }
  app_restart();
  return 0;
}

//----- (0002D934) --------------------------------------------------------
api_data *__fastcall print_data(io_data *io_data, api_data *root, bool isjson, bool precom)
{
  _BOOL4 v5; // r7
  _BOOL4 v6; // r6
  cglock_t *lock; // r5
  K_ITEM *v8; // r11
  cglock_t *v9; // r5
  K_ITEM *p_data; // r5
  api_data_type type; // r3
  api_data *next; // r3
  api_data *prev; // r2
  api_data *v14; // r0
  cglock_t *v15; // r4
  cglock_t *v16; // r4
  char *v18; // r3
  char *v19; // r6
  char *v20; // r3
  const char *data; // r1
  K_ITEM *v22; // r0
  int *v23; // r0
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  int *v27; // r0
  int *v28; // r0
  int *v29; // r0
  int *v30; // r0
  char *original; // [sp+24h] [bp-1048h]
  char *originala; // [sp+24h] [bp-1048h]
  char buf[64]; // [sp+28h] [bp-1044h] BYREF
  char tmp42[4100]; // [sp+68h] [bp-1004h] BYREF

  v5 = isjson;
  v6 = precom;
  lock = strbufs->lock;
  if ( pthread_mutex_lock(&lock->mutex) )
  {
    v27 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v27, "api.c", "print_data", 1196);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_rwlock_wrlock(&lock->rwlock) )
  {
    v28 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v28, "api.c", "print_data", 1196);
    applog(3, tmp42, 1);
    quit(1);
  }
  v8 = k_unlink_head(strbufs, "api.c", "print_data", 1197);
  v9 = strbufs->lock;
  if ( pthread_rwlock_unlock(&v9->rwlock) )
  {
    v29 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v29, "api.c", "print_data", 1198);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&v9->mutex) )
  {
    v30 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v30, "api.c", "print_data", 1198);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  p_data = (K_ITEM *)&v8->data;
  *((_DWORD *)v8->data + 1) = 0;
  if ( v6 )
    add_item_buf(p_data, ",");
  if ( v5 )
  {
    add_item_buf(p_data, "{");
    if ( !root )
      goto LABEL_26;
  }
  else if ( !root )
  {
    goto LABEL_19;
  }
  if ( v5 )
  {
LABEL_16:
    add_item_buf(p_data, "\"");
    add_item_buf(p_data, root->name);
    add_item_buf(p_data, "\"");
    add_item_buf(p_data, ":");
    type = root->type;
    switch ( root->type )
    {
      case api_data_type::API_ESCAPE:
        originala = (char *)root->data;
        v19 = escape_string(originala, 1);
        add_item_buf(p_data, "\"");
        add_item_buf(p_data, v19);
        add_item_buf(p_data, "\"");
        v20 = originala;
        goto LABEL_56;
      case api_data_type::API_STRING:
      case api_data_type::API_CONST:
        add_item_buf(p_data, "\"");
        data = (const char *)root->data;
        v22 = (K_ITEM *)&v8->data;
        goto LABEL_60;
      case api_data_type::API_UINT8:
        goto LABEL_29;
      case api_data_type::API_INT16:
        goto LABEL_28;
      case api_data_type::API_UINT16:
        goto LABEL_27;
      case api_data_type::API_INT:
        goto LABEL_46;
      case api_data_type::API_UINT:
      case api_data_type::API_UINT32:
        goto LABEL_11;
      case api_data_type::API_HEX32:
        add_item_buf(p_data, "\"");
        snprintf(buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
        data = buf;
        v22 = (K_ITEM *)&v8->data;
        goto LABEL_60;
      case api_data_type::API_UINT64:
        goto LABEL_44;
      case api_data_type::API_INT64:
        goto LABEL_43;
      case api_data_type::API_DOUBLE:
        goto LABEL_42;
      case api_data_type::API_ELAPSED:
        goto LABEL_41;
      case api_data_type::API_BOOL:
        goto LABEL_38;
      case api_data_type::API_TIMEVAL:
        goto LABEL_37;
      case api_data_type::API_TIME:
        goto LABEL_36;
      case api_data_type::API_MHS:
      case api_data_type::API_UTILITY:
      case api_data_type::API_FREQ:
        goto LABEL_35;
      case api_data_type::API_MHTOTAL:
        goto LABEL_34;
      case api_data_type::API_TEMP:
        goto LABEL_33;
      case api_data_type::API_VOLTS:
      case api_data_type::API_AVG:
        goto LABEL_32;
      case api_data_type::API_HS:
        goto LABEL_31;
      case api_data_type::API_DIFF:
        goto LABEL_30;
      case api_data_type::API_PERCENT:
        goto LABEL_45;
      default:
        goto LABEL_49;
    }
  }
  while ( 1 )
  {
    add_item_buf(p_data, root->name);
    add_item_buf(p_data, "=");
    type = root->type;
    switch ( root->type )
    {
      case api_data_type::API_ESCAPE:
        original = (char *)root->data;
        v19 = escape_string(original, 0);
        add_item_buf(p_data, v19);
        v20 = original;
LABEL_56:
        if ( v20 != v19 )
          free(v19);
        break;
      case api_data_type::API_STRING:
      case api_data_type::API_CONST:
        add_item_buf(p_data, (const char *)root->data);
        break;
      case api_data_type::API_UINT8:
LABEL_29:
        snprintf(buf, 0x40u, "%u", *(unsigned __int8 *)root->data);
        goto LABEL_12;
      case api_data_type::API_INT16:
LABEL_28:
        snprintf(buf, 0x40u, "%d", *(__int16 *)root->data);
        goto LABEL_12;
      case api_data_type::API_UINT16:
LABEL_27:
        snprintf(buf, 0x40u, "%u", *(unsigned __int16 *)root->data);
        goto LABEL_12;
      case api_data_type::API_INT:
LABEL_46:
        snprintf(buf, 0x40u, "%d", *(_DWORD *)root->data);
        goto LABEL_12;
      case api_data_type::API_UINT:
      case api_data_type::API_UINT32:
LABEL_11:
        snprintf(buf, 0x40u, "%u", *(_DWORD *)root->data);
        goto LABEL_12;
      case api_data_type::API_HEX32:
        snprintf(buf, 0x40u, "0x%08x", *(_DWORD *)root->data);
        add_item_buf(p_data, buf);
        break;
      case api_data_type::API_UINT64:
LABEL_44:
        snprintf(buf, 0x40u, "%llu", *(_QWORD *)root->data);
        goto LABEL_12;
      case api_data_type::API_INT64:
LABEL_43:
        snprintf(buf, 0x40u, "%lld", *(_QWORD *)root->data);
        goto LABEL_12;
      case api_data_type::API_DOUBLE:
LABEL_42:
        snprintf(buf, 0x40u, "%f", *(double *)root->data);
        goto LABEL_12;
      case api_data_type::API_ELAPSED:
LABEL_41:
        snprintf(buf, 0x40u, "%.0f", *(double *)root->data);
        goto LABEL_12;
      case api_data_type::API_BOOL:
LABEL_38:
        v18 = "false";
        if ( *(_BYTE *)root->data )
          v18 = "true";
        snprintf(buf, 0x40u, "%s", v18);
        goto LABEL_12;
      case api_data_type::API_TIMEVAL:
LABEL_37:
        snprintf(buf, 0x40u, "%ld.%06ld", *(_DWORD *)root->data, *((_DWORD *)root->data + 1));
        goto LABEL_12;
      case api_data_type::API_TIME:
LABEL_36:
        snprintf(buf, 0x40u, "%lu", *(_DWORD *)root->data);
        goto LABEL_12;
      case api_data_type::API_MHS:
      case api_data_type::API_UTILITY:
      case api_data_type::API_FREQ:
LABEL_35:
        snprintf(buf, 0x40u, "%.2f", *(double *)root->data);
        goto LABEL_12;
      case api_data_type::API_MHTOTAL:
LABEL_34:
        snprintf(buf, 0x40u, "%.4f", *(double *)root->data);
        goto LABEL_12;
      case api_data_type::API_TEMP:
LABEL_33:
        snprintf(buf, 0x40u, "%.2f", *(float *)root->data);
        goto LABEL_12;
      case api_data_type::API_VOLTS:
      case api_data_type::API_AVG:
LABEL_32:
        snprintf(buf, 0x40u, "%.3f", *(float *)root->data);
        goto LABEL_12;
      case api_data_type::API_HS:
LABEL_31:
        snprintf(buf, 0x40u, "%.15f", *(double *)root->data);
        goto LABEL_12;
      case api_data_type::API_DIFF:
LABEL_30:
        snprintf(buf, 0x40u, "%.8f", *(double *)root->data);
        goto LABEL_12;
      case api_data_type::API_PERCENT:
LABEL_45:
        snprintf(buf, 0x40u, "%.4f", *(double *)root->data * 100.0);
LABEL_12:
        add_item_buf(p_data, buf);
        break;
      default:
LABEL_49:
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(tmp42, 0x1000u, "API: unknown2 data type %d ignored", type);
          applog(3, tmp42, 0);
        }
        if ( v5 )
        {
          add_item_buf(p_data, "\"");
          data = "Unknown";
          v22 = (K_ITEM *)&v8->data;
LABEL_60:
          add_item_buf(v22, data);
          add_item_buf(p_data, "\"");
        }
        else
        {
          add_item_buf(p_data, "Unknown");
        }
        break;
    }
    free(root->name);
    if ( !root->data_was_malloc )
    {
      next = root->next;
      if ( next == root )
        break;
      goto LABEL_15;
    }
    free(root->data);
    next = root->next;
    if ( next == root )
      break;
LABEL_15:
    prev = root->prev;
    v14 = root;
    root = next;
    next->prev = prev;
    prev->next = next;
    free(v14);
    add_item_buf(p_data, ",");
    if ( v5 )
      goto LABEL_16;
  }
  free(root);
  if ( !v5 )
  {
LABEL_19:
    add_item_buf(p_data, (const char *)&word_4F67C);
    goto LABEL_20;
  }
LABEL_26:
  add_item_buf(p_data, "}");
LABEL_20:
  io_add(io_data, *(char **)v8->data);
  v15 = strbufs->lock;
  if ( pthread_mutex_lock(&v15->mutex) )
  {
    v23 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v23, "api.c", "print_data", 1368);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_rwlock_wrlock(&v15->rwlock) )
  {
    v24 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v24, "api.c", "print_data", 1368);
    applog(3, tmp42, 1);
    quit(1);
  }
  k_add_head(strbufs, v8, "api.c", "print_data", 1369);
  v16 = strbufs->lock;
  if ( pthread_rwlock_unlock(&v16->rwlock) )
  {
    v25 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d", *v25, "api.c", "print_data", 1370);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&v16->mutex) )
  {
    v26 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d", *v26, "api.c", "print_data", 1370);
    applog(3, tmp42, 1);
    quit(1);
  }
  selective_yield();
  return 0;
}
// 2DE4C: conditional instruction was optimized away because r7.4!=0
// 2DE5C: conditional instruction was optimized away because r7.4!=0
// 4F67C: using guessed type __int16 word_4F67C;

//----- (0002E18C) --------------------------------------------------------
void __fastcall message(io_data *io_data, int messageid, int paramid, char *param2, bool isjson)
{
  code_severity v8; // r1
  CODES *v9; // r3
  int v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r7
  char *v14; // r1
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  __int64 v18; // kr00_8
  api_data *v19; // r0
  api_data *v20; // r0
  char *v21; // r2
  int messageida; // [sp+Ch] [bp-200Ch] BYREF
  char severity[4]; // [sp+10h] [bp-2008h] BYREF
  int id; // [sp+14h] [bp-2004h] BYREF
  char buf[8192]; // [sp+18h] [bp-2000h] BYREF

  messageida = messageid;
  if ( isjson )
    io_add(io_data, "{\"STATUS\":[");
  v8 = codes[0].severity;
  if ( codes[0].severity == code_severity::SEVERITY_FAIL )
  {
LABEL_9:
    v11 = api_add_data_full(0, "STATUS", api_data_type::API_STRING, "F", 0);
    v12 = api_add_data_full(v11, "When", api_data_type::API_TIME, &when, 0);
    id = -1;
    v13 = api_add_data_full(v12, "Code", api_data_type::API_INT, &id, 0);
    sprintf(buf, "%d", messageida);
    LOWORD(v14) = (unsigned __int16)"Msg";
    v15 = v13;
    goto LABEL_10;
  }
  if ( codes[0].code != messageida )
  {
    v9 = codes;
    v10 = 0;
    while ( 1 )
    {
      v8 = v9[1].severity;
      ++v10;
      ++v9;
      if ( v8 == code_severity::SEVERITY_FAIL )
        goto LABEL_9;
      if ( v9->code == messageida )
        goto LABEL_13;
    }
  }
  v10 = 0;
LABEL_13:
  switch ( v8 )
  {
    case code_severity::SEVERITY_INFO:
      severity[0] = 73;
      break;
    case code_severity::SEVERITY_SUCC:
      severity[0] = 83;
      break;
    case code_severity::SEVERITY_WARN:
      severity[0] = 87;
      break;
    default:
      severity[0] = 69;
      break;
  }
  severity[1] = 0;
  v18 = *(_QWORD *)&codes[v10].params;
  switch ( (int)v18 )
  {
    case 0:
    case 1:
    case 2:
    case 14:
      sprintf(buf, (const char *)HIDWORD(v18), paramid);
      break;
    case 5:
      sprintf(buf, (const char *)HIDWORD(v18), total_pools);
      break;
    case 6:
      sprintf(buf, (const char *)HIDWORD(v18), paramid, total_pools - 1);
      break;
    case 7:
      sprintf(buf, (const char *)HIDWORD(v18));
      break;
    case 8:
      sprintf(buf, (const char *)HIDWORD(v18), "command");
      break;
    case 9:
      sprintf(buf, (const char *)HIDWORD(v18), paramid, pools[paramid]->rpc_url);
      break;
    case 10:
      sprintf(buf, (const char *)HIDWORD(v18), param2);
      break;
    case 11:
      sprintf(buf, (const char *)HIDWORD(v18), paramid, param2);
      break;
    case 12:
      v21 = "false";
      if ( paramid )
        v21 = "true";
      sprintf(buf, (const char *)HIDWORD(v18), v21, "true");
      break;
    case 13:
      sprintf(buf, (const char *)HIDWORD(v18), param2, paramid);
      break;
    default:
      strcpy(buf, (const char *)HIDWORD(v18));
      break;
  }
  v19 = api_add_data_full(0, "STATUS", api_data_type::API_STRING, severity, 0);
  v20 = api_add_data_full(v19, "When", api_data_type::API_TIME, &when, 0);
  v15 = api_add_data_full(v20, "Code", api_data_type::API_INT, &messageida, 0);
  LOWORD(v14) = 21536;
LABEL_10:
  HIWORD(v14) = (unsigned int)"Msg" >> 16;
  v16 = api_add_data_full(v15, v14, api_data_type::API_ESCAPE, buf, 0);
  v17 = api_add_data_full(v16, "Description", api_data_type::API_ESCAPE, opt_api_description, 0);
  print_data(io_data, v17, isjson, 0);
  if ( isjson )
    io_add(io_data, (char *)&word_59A90);
}
// 59A90: using guessed type __int16 word_59A90;

//----- (0002E3E0) --------------------------------------------------------
void __fastcall privileged(io_data *io_data, int c, char *param, bool isjson, char group)
{
  message(io_data, 46, 0, 0, isjson);
}

//----- (0002E3EC) --------------------------------------------------------
void __fastcall dosave(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *v7; // r4
  FILE *v8; // r0
  FILE *v9; // r6
  char *v10; // r6
  char *v11; // r8
  char filename[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( !param || (v7 = param, !*param) )
  {
    v7 = filename;
    default_save_file(filename);
  }
  v8 = fopen(v7, "w");
  v9 = v8;
  if ( v8 )
  {
    write_config(v8);
    fclose(v9);
    v10 = escape_string(v7, isjson);
    message(io_data, 44, 0, v10, isjson);
    if ( v7 != v10 )
      free(v10);
  }
  else
  {
    v11 = escape_string(v7, isjson);
    message(io_data, 43, 0, v11, isjson);
    if ( v7 != v11 )
      free(v11);
  }
}

//----- (0002E480) --------------------------------------------------------
void __fastcall lockstats(io_data *io_data, int c, char *param, bool isjson, char group)
{
  message(io_data, 124, 0, 0, isjson);
}

//----- (0002E48C) --------------------------------------------------------
void __fastcall dohotplug(io_data *io_data, int c, char *param, bool isjson, char group)
{
  message(io_data, 102, 0, 0, isjson);
}

//----- (0002E498) --------------------------------------------------------
void __fastcall dozero(io_data *io_data, int c, char *param, bool isjson, char group)
{
  io_data *v6; // r5
  char *v8; // r0
  char *v9; // r7
  int v10; // r8
  int v11; // r9
  int v12; // r10
  int v13; // r4
  bool v14; // zf
  char *v15; // r3
  int v16; // r1
  bool groupa; // [sp+20h] [bp+20h]

  if ( !param || !*param )
  {
    v15 = 0;
    groupa = isjson;
    v16 = 94;
    goto LABEL_20;
  }
  v6 = io_data;
  v8 = strchr(param, 44);
  v9 = v8;
  if ( !v8 || (*v8 = 0, v8 == (char *)-1) || (v10 = (unsigned __int8)v8[1], !v8[1]) )
  {
    v15 = 0;
    groupa = isjson;
    io_data = v6;
    v16 = 75;
    goto LABEL_20;
  }
  if ( !strcasecmp(param, "all") )
  {
    v11 = 0;
    v12 = 1;
  }
  else
  {
    if ( strcasecmp(param, "bestshare") )
    {
      groupa = isjson;
      v15 = param;
      io_data = v6;
      v16 = 95;
      goto LABEL_20;
    }
    v12 = 0;
    v11 = 1;
  }
  v13 = LOBYTE((*_ctype_tolower_loc())[v10]);
  v14 = v13 == 116;
  if ( v13 != 116 )
    v14 = v13 == 102;
  v9[1] = v13;
  if ( !v14 )
  {
    v15 = 0;
    groupa = isjson;
    io_data = v6;
    v16 = 76;
    goto LABEL_20;
  }
  if ( v13 == 116 )
  {
    print_summary();
    if ( !v12 )
      goto LABEL_14;
    goto LABEL_26;
  }
  if ( v12 )
LABEL_26:
    zero_stats();
LABEL_14:
  if ( v11 )
    zero_bestshare();
  v15 = "BestShare";
  if ( v12 )
    v15 = "All";
  groupa = isjson;
  io_data = v6;
  if ( v13 == 116 )
    v16 = 96;
  else
    v16 = 97;
LABEL_20:
  message(io_data, v16, 0, v15, groupa);
}

//----- (0002E5B0) --------------------------------------------------------
void __fastcall usbstats(io_data *io_data, int c, char *param, bool isjson, char group)
{
  message(io_data, 88, 0, 0, isjson);
}

//----- (0002E5BC) --------------------------------------------------------
void __fastcall setconfig(io_data *io_data, int c, char *param, bool isjson, char group)
{
  io_data *v6; // r5
  char *v8; // r0
  unsigned int v9; // r0
  int v10; // r7
  char *v11; // r3
  int v12; // r2
  int v13; // r1
  bool groupa; // [sp+18h] [bp+18h]

  if ( param && *param )
  {
    v6 = io_data;
    v8 = strchr(param, 44);
    if ( v8 )
    {
      *v8 = 0;
      v9 = strtol(v8 + 1, 0, 10);
      v10 = v9;
      if ( v9 > 0x270F )
      {
        groupa = isjson;
        v11 = param;
        v12 = v9;
        v13 = 84;
        io_data = v6;
      }
      else
      {
        if ( !strcasecmp(param, "queue") )
        {
          opt_queue = v10;
        }
        else if ( !strcasecmp(param, "scantime") )
        {
          opt_scantime = v10;
        }
        else
        {
          if ( strcasecmp(param, "expiry") )
          {
            groupa = isjson;
            v11 = param;
            v12 = 0;
            io_data = v6;
            v13 = 83;
            goto LABEL_9;
          }
          opt_expiry = v10;
        }
        groupa = isjson;
        v11 = param;
        v12 = v10;
        io_data = v6;
        v13 = 82;
      }
    }
    else
    {
      groupa = isjson;
      v11 = param;
      v12 = 0;
      v13 = 86;
      io_data = v6;
    }
  }
  else
  {
    v11 = 0;
    groupa = isjson;
    v12 = 0;
    v13 = 85;
  }
LABEL_9:
  message(io_data, v13, v12, v11, groupa);
}

//----- (0002E690) --------------------------------------------------------
void __fastcall failoveronly(io_data *io_data, int c, char *param, bool isjson, char group)
{
  int v6; // r6
  io_data *v8; // r5
  int v9; // r2
  bool v10; // zf
  int v11; // r3
  _BOOL4 v12; // r2
  int v13; // r1
  bool groupa; // [sp+18h] [bp+18h]

  if ( param && *param )
  {
    v8 = io_data;
    v6 = (unsigned __int8)*param;
    v9 = LOBYTE((*_ctype_tolower_loc())[v6]);
    v10 = v9 == 116;
    if ( v9 != 116 )
      v10 = v9 == 102;
    *param = v9;
    v11 = !v10;
    if ( v10 )
    {
      groupa = isjson;
      io_data = v8;
      v12 = v9 == 116;
      opt_fail_only = v12;
      v13 = 77;
    }
    else
    {
      v11 = 0;
      groupa = isjson;
      io_data = v8;
      v12 = 0;
      v13 = 76;
    }
  }
  else
  {
    v11 = 0;
    groupa = isjson;
    v12 = 0;
    v13 = 75;
  }
  message(io_data, v13, v12, (char *)v11, groupa);
}

//----- (0002E6FC) --------------------------------------------------------
void __fastcall removepool(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *v6; // r3
  io_data *v7; // r6
  int v8; // r2
  int v9; // r1
  bool v10; // r5
  int v11; // r0
  int v12; // r7
  pool *v13; // r4
  char *v14; // r8
  bool groupa; // [sp+20h] [bp+18h]

  v6 = (char *)total_pools;
  if ( !total_pools )
  {
    groupa = isjson;
    v8 = 0;
    v9 = 8;
    goto LABEL_5;
  }
  v7 = io_data;
  if ( !param || !*param )
  {
    v6 = 0;
    groupa = isjson;
    v8 = 0;
    v9 = 25;
LABEL_5:
    message(io_data, v9, v8, v6, groupa);
    return;
  }
  v10 = isjson;
  v11 = strtol(param, 0, 10);
  v12 = v11;
  if ( v11 < 0 || v11 >= total_pools )
  {
    groupa = v10;
    v8 = v11;
    io_data = v7;
    v6 = 0;
    v9 = 26;
    goto LABEL_5;
  }
  if ( total_pools <= 1 )
  {
    groupa = v10;
    v8 = v11;
    io_data = v7;
    v6 = 0;
    v9 = 66;
    goto LABEL_5;
  }
  v13 = pools[v11];
  if ( v13 == current_pool() )
    switch_pools(0);
  if ( v13 == current_pool() )
  {
    groupa = v10;
    v8 = v12;
    io_data = v7;
    v6 = 0;
    v9 = 67;
    goto LABEL_5;
  }
  v13->enabled = pool_enable::POOL_DISABLED;
  v14 = escape_string(v13->rpc_url, v10);
  if ( v14 == v13->rpc_url )
  {
    remove_pool(v13);
    groupa = v10;
    v6 = v14;
    v8 = v12;
    io_data = v7;
    v9 = 68;
    goto LABEL_5;
  }
  remove_pool(v13);
  message(v7, 68, v12, v14, v10);
  sub_12000(v14);
}

//----- (0002E7F0) --------------------------------------------------------
void __fastcall disablepool(io_data *io_data, int c, char *param, bool isjson, char group)
{
  io_data *v5; // r6
  int v6; // r2
  int v7; // r1
  int v9; // r0
  int v10; // r7
  pool *v11; // r4
  bool groupa; // [sp+18h] [bp+18h]

  if ( total_pools )
  {
    v5 = io_data;
    if ( param && *param )
    {
      v9 = strtol(param, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= total_pools )
      {
        groupa = isjson;
        v6 = v9;
        io_data = v5;
        v7 = 26;
      }
      else
      {
        v11 = pools[v9];
        if ( v11->enabled )
        {
          if ( enabled_pools <= 1 )
          {
            groupa = isjson;
            v6 = v9;
            io_data = v5;
            v7 = 51;
          }
          else
          {
            v11->enabled = pool_enable::POOL_DISABLED;
            if ( v11 == current_pool() )
              switch_pools(0);
            groupa = isjson;
            v6 = v10;
            io_data = v5;
            v7 = 48;
          }
        }
        else
        {
          groupa = isjson;
          v6 = v9;
          io_data = v5;
          v7 = 50;
        }
      }
    }
    else
    {
      groupa = isjson;
      v6 = 0;
      v7 = 25;
    }
  }
  else
  {
    groupa = isjson;
    v6 = 0;
    v7 = 8;
  }
  message(io_data, v7, v6, 0, groupa);
}

//----- (0002E8B8) --------------------------------------------------------
void __fastcall enablepool(io_data *io_data, int c, char *param, bool isjson, char group)
{
  io_data *v5; // r6
  int v6; // r2
  int v7; // r1
  int v9; // r0
  int v10; // r7
  pool *v11; // r4
  int prio; // r8
  bool groupa; // [sp+18h] [bp+18h]

  if ( total_pools )
  {
    v5 = io_data;
    if ( param && *param )
    {
      v9 = strtol(param, 0, 10);
      v10 = v9;
      if ( v9 < 0 || v9 >= total_pools )
      {
        groupa = isjson;
        v6 = v9;
        io_data = v5;
        v7 = 26;
      }
      else
      {
        v11 = pools[v9];
        if ( v11->enabled == pool_enable::POOL_ENABLED )
        {
          groupa = isjson;
          v6 = v9;
          io_data = v5;
          v7 = 49;
        }
        else
        {
          prio = v11->prio;
          v11->enabled = pool_enable::POOL_ENABLED;
          if ( prio < current_pool()->prio )
            switch_pools(v11);
          groupa = isjson;
          v6 = v10;
          io_data = v5;
          v7 = 47;
        }
      }
    }
    else
    {
      groupa = isjson;
      v6 = 0;
      v7 = 25;
    }
  }
  else
  {
    groupa = isjson;
    v6 = 0;
    v7 = 8;
  }
  message(io_data, v7, v6, 0, groupa);
}

//----- (0002E968) --------------------------------------------------------
void __fastcall poolquota(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *rpc_url; // r3
  io_data *v7; // r7
  char *v9; // r8
  int v10; // r0
  int v11; // r2
  int v12; // r1
  pool *v13; // r5
  int v14; // r0
  int v15; // r4
  bool groupa; // [sp+20h] [bp+20h]

  rpc_url = (char *)total_pools;
  if ( total_pools )
  {
    v7 = io_data;
    if ( param && *param )
    {
      v9 = strchr(param, 44);
      if ( v9 )
      {
        *v9 = 0;
        v10 = strtol(param, 0, 10);
        if ( v10 >= 0 && v10 < total_pools )
        {
          v13 = pools[v10];
          v14 = strtol(v9 + 1, 0, 10);
          v15 = v14;
          if ( v14 < 0 )
          {
            rpc_url = v13->rpc_url;
            v11 = v14;
            groupa = isjson;
            io_data = v7;
            v12 = 121;
          }
          else
          {
            v13->quota = v14;
            adjust_quota_gcd();
            rpc_url = v13->rpc_url;
            v11 = v15;
            groupa = isjson;
            io_data = v7;
            v12 = 122;
          }
        }
        else
        {
          groupa = isjson;
          v11 = v10;
          io_data = v7;
          rpc_url = 0;
          v12 = 26;
        }
      }
      else
      {
        groupa = isjson;
        rpc_url = param;
        v11 = 0;
        v12 = 86;
        io_data = v7;
      }
    }
    else
    {
      rpc_url = 0;
      groupa = isjson;
      v11 = 0;
      v12 = 25;
    }
  }
  else
  {
    groupa = isjson;
    v11 = 0;
    v12 = 8;
  }
  message(io_data, v12, v11, rpc_url, groupa);
}

//----- (0002EA3C) --------------------------------------------------------
void __fastcall poolpriority(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *v6; // r2
  char *v7; // r3
  int v8; // r6
  char *v9; // r10
  char *v10; // r0
  char *v11; // r4
  const char *v12; // r0
  int v13; // r0
  int v14; // r12
  int v15; // r1
  pool **v16; // r4
  char *v17; // r2
  int v18; // r0
  int v20; // lr
  char *v21; // r2
  int v22; // r3
  pool *v24; // r0
  char v25; // [sp+7h] [bp-1h] BYREF
  io_data *v26; // [sp+8h] [bp+0h] BYREF
  bool v27[8]; // [sp+Ch] [bp+4h]

  *(_DWORD *)v27 = isjson;
  v26 = io_data;
  if ( !total_pools )
  {
    message(io_data, 8, 0, 0, v27[0]);
    goto LABEL_29;
  }
  if ( !param || !*param )
  {
    message(v26, 25, 0, 0, v27[0]);
    goto LABEL_29;
  }
  if ( total_pools > 0 )
  {
    v6 = &v25;
    v7 = (char *)&v26 + total_pools - 1;
    do
      *++v6 = 0;
    while ( v6 != v7 );
  }
  v8 = 0;
  v9 = param;
  while ( 1 )
  {
    v10 = strchr(v9, 44);
    v11 = v10;
    if ( v10 )
    {
      v11 = v10 + 1;
      *v10 = 0;
    }
    v12 = v9;
    v9 = v11;
    v13 = strtol(v12, 0, 10);
    v14 = v8 + 1;
    if ( v13 < 0 )
      break;
    v15 = total_pools;
    if ( total_pools <= v13 )
      break;
    if ( v27[v13 - 4] )
    {
      message(v26, 74, v13, 0, v27[0]);
LABEL_29:
      __asm { POP.W           {R4-R11,PC} }
    }
    *(_DWORD *)&v27[4 * v13 - 4] = v8++;
    v27[v13 - 4] = 1;
    if ( !v11 || !*v11 )
    {
      v16 = pools;
      v17 = &v25;
      v18 = 0;
      do
      {
        if ( *++v17 )
          v16[v18]->prio = *(_DWORD *)&v27[4 * v18 - 4];
        ++v18;
      }
      while ( v17 != &v25 + v15 );
      v20 = 0;
      while ( 1 )
      {
        v21 = &v25;
        v22 = 0;
        while ( 1 )
        {
          if ( !*++v21 )
          {
            v24 = v16[v22];
            if ( v24->prio == v20 )
              break;
          }
          if ( v15 == ++v22 )
            goto LABEL_24;
        }
        v24->prio = v14++;
        v27[v22 - 4] = 1;
LABEL_24:
        if ( v15 == ++v20 )
        {
          if ( current_pool()->prio )
            switch_pools(0);
          message(v26, 73, 0, 0, v27[0]);
          __asm { POP.W           {R4-R11,PC} }
        }
      }
    }
  }
  message(v26, 26, v13, 0, v27[0]);
  goto LABEL_29;
}

//----- (0002EBCC) --------------------------------------------------------
void __fastcall addpool(io_data *io_data, int c, char *param, bool isjson, char group)
{
  char *v8; // r8
  pool *v9; // r7
  char *v10; // r4
  char *url; // [sp+Ch] [bp-Ch] BYREF
  char *user; // [sp+10h] [bp-8h] BYREF
  char *pass; // [sp+14h] [bp-4h] BYREF

  if ( param && *param )
  {
    if ( pooldetails(param, &url, &user, &pass) )
    {
      v9 = add_pool();
      detect_stratum(v9, url);
      add_pool_details(v9, 1, url, user, pass);
      v10 = escape_string(url, isjson);
      message(io_data, 55, v9->pool_no, v10, isjson);
      if ( url != v10 )
        free(v10);
    }
    else
    {
      v8 = escape_string(param, isjson);
      message(io_data, 53, 0, v8, isjson);
      if ( param != v8 )
        free(v8);
    }
  }
  else
  {
    message(io_data, 52, 0, 0, isjson);
  }
}

//----- (0002EC68) --------------------------------------------------------
void __fastcall switchpool(io_data *io_data, int c, char *param, bool isjson, char group)
{
  io_data *v5; // r6
  int v6; // r2
  int v7; // r1
  int v9; // r7
  const char *v10; // r2
  int v11; // r3
  const char *v12; // r2
  int v13; // r3
  const char *v14; // r2
  int v15; // r3
  pool *v16; // r4
  const char *v17; // r2
  int v18; // r3
  bool groupa; // [sp+18h] [bp+18h]

  if ( total_pools )
  {
    v5 = io_data;
    if ( param && *param )
    {
      v9 = strtol(param, 0, 10);
      if ( pthread_mutex_lock(&control_lock.mutex) )
        mutex_lock_1((pthread_mutex_t *)&_func___11933, (const char *)0xB5B, v10, v11);
      rd_lock_0(&control_lock.rwlock, (const char *)&_func___11933, (const char *)0xB5B, v11);
      if ( pthread_mutex_unlock(&control_lock.mutex) )
        mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11933, (const char *)0xB5B, v12, v13);
      if ( v9 >= 0 && v9 < total_pools )
      {
        v16 = pools[v9];
        v16->enabled = pool_enable::POOL_ENABLED;
        if ( pthread_rwlock_unlock(&control_lock.rwlock) )
          rw_unlock_0((pthread_rwlock_t *)&_func___11933, (const char *)0xB65, v17, v18);
        selective_yield();
        switch_pools(v16);
        groupa = isjson;
        v6 = v9;
        io_data = v5;
        v7 = 27;
      }
      else
      {
        if ( pthread_rwlock_unlock(&control_lock.rwlock) )
          rw_unlock_0((pthread_rwlock_t *)&_func___11933, (const char *)0xB5E, v14, v15);
        selective_yield();
        groupa = isjson;
        v6 = v9;
        io_data = v5;
        v7 = 26;
      }
    }
    else
    {
      groupa = isjson;
      v6 = 0;
      v7 = 25;
    }
  }
  else
  {
    groupa = isjson;
    v6 = 0;
    v7 = 8;
  }
  message(io_data, v7, v6, 0, groupa);
}
// 2ECBC: variable 'v11' is possibly undefined
// 2ED56: variable 'v12' is possibly undefined
// 2ED56: variable 'v13' is possibly undefined
// 2ED62: variable 'v10' is possibly undefined
// 2ED6E: variable 'v14' is possibly undefined
// 2ED6E: variable 'v15' is possibly undefined
// 2ED7A: variable 'v17' is possibly undefined
// 2ED7A: variable 'v18' is possibly undefined

//----- (0002ED88) --------------------------------------------------------
void __fastcall devstatus(io_data *io_data, int c, char *param, bool isjson, char group)
{
  message(io_data, 10, 0, 0, isjson);
}

//----- (0002ED94) --------------------------------------------------------
void __fastcall edevstatus(io_data *a1, int a2, int a3, bool a4)
{
  message(a1, 10, 0, 0, a4);
}

//----- (0002EDA0) --------------------------------------------------------
void __fastcall asccount(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r5
  char *v7; // r1
  _BOOL4 v8; // r0
  char *v9; // r1
  _BOOL4 v10; // r5
  api_data *v11; // r0
  char *v12; // r1
  char *v13; // r1
  api_data *v14; // r0
  int count; // [sp+Ch] [bp-4h] BYREF

  v5 = isjson;
  count = 0;
  message(io_data, 104, 0, 0, isjson);
  if ( v5 )
  {
    LOWORD(v7) = 21612;
    HIWORD(v7) = (unsigned int)"reset_all_hash_board_high" >> 16;
    v8 = io_add(io_data, v7);
    LOWORD(v9) = 21896;
    v10 = v8;
    HIWORD(v9) = (unsigned int)"%d" >> 16;
    v11 = api_add_data_full(0, v9, api_data_type::API_INT, &count, 0);
    print_data(io_data, v11, 1, 0);
    if ( v10 )
      io_data->close = 1;
  }
  else
  {
    LOWORD(v12) = 21624;
    HIWORD(v12) = (unsigned int)"sh_board_high" >> 16;
    io_add(io_data, v12);
    LOWORD(v13) = 21896;
    HIWORD(v13) = (unsigned int)"%d" >> 16;
    v14 = api_add_data_full(0, v13, api_data_type::API_INT, &count, 0);
    print_data(io_data, v14, 0, 0);
  }
}

//----- (0002EE28) --------------------------------------------------------
void __fastcall debugstate(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v6; // r4
  int v8; // r2
  _BOOL4 v9; // r3
  _BOOL4 v10; // r6
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  api_data *v22; // r0
  api_data *v23; // r0
  api_data *v24; // r1
  _BOOL4 v25; // r3
  _BOOL4 v26; // r3

  v6 = isjson;
  if ( param )
  {
    v8 = LOBYTE((*_ctype_tolower_loc())[(unsigned __int8)*param]);
    *param = v8;
    switch ( v8 )
    {
      case 'd':
        v9 = !opt_debug;
        opt_debug = v9;
        opt_log_output = v9;
        if ( v9 )
          goto LABEL_4;
        break;
      case 'n':
        opt_log_output = 0;
        opt_debug = 0;
        opt_quiet = 0;
        opt_protocol = 0;
        want_per_device_stats = 0;
        opt_worktime = 0;
        break;
      case 'p':
        want_per_device_stats ^= 1u;
        opt_log_output = want_per_device_stats;
        break;
      case 'q':
        opt_quiet ^= 1u;
        break;
      case 'r':
        v25 = !opt_protocol;
        opt_protocol ^= 1u;
        if ( v25 )
          goto LABEL_4;
        break;
      case 's':
        opt_realquiet = 1;
        break;
      case 'v':
        v26 = !opt_log_output;
        opt_log_output ^= 1u;
        if ( v26 )
LABEL_4:
          opt_quiet = 0;
        break;
      case 'w':
        opt_worktime ^= 1u;
        break;
      default:
        break;
    }
  }
  message(io_data, 79, 0, 0, v6);
  if ( v6 )
  {
    v10 = io_add(io_data, ",\"DEBUG\":[");
    v11 = api_add_data_full(0, "Silent", api_data_type::API_BOOL, &opt_realquiet, 0);
    v12 = api_add_data_full(v11, "Quiet", api_data_type::API_BOOL, &opt_quiet, 0);
    v13 = api_add_data_full(v12, "Verbose", api_data_type::API_BOOL, &opt_log_output, 0);
    v14 = api_add_data_full(v13, "Debug", api_data_type::API_BOOL, &opt_debug, 0);
    v15 = api_add_data_full(v14, "RPCProto", api_data_type::API_BOOL, &opt_protocol, 0);
    v16 = api_add_data_full(v15, "PerDevice", api_data_type::API_BOOL, &want_per_device_stats, 0);
    v17 = api_add_data_full(v16, "WorkTime", api_data_type::API_BOOL, &opt_worktime, 0);
    print_data(io_data, v17, 1, 0);
    if ( v10 )
      io_data->close = 1;
  }
  else
  {
    io_add(io_data, "DEBUG,");
    v18 = api_add_data_full(0, "Silent", api_data_type::API_BOOL, &opt_realquiet, 0);
    v19 = api_add_data_full(v18, "Quiet", api_data_type::API_BOOL, &opt_quiet, 0);
    v20 = api_add_data_full(v19, "Verbose", api_data_type::API_BOOL, &opt_log_output, 0);
    v21 = api_add_data_full(v20, "Debug", api_data_type::API_BOOL, &opt_debug, 0);
    v22 = api_add_data_full(v21, "RPCProto", api_data_type::API_BOOL, &opt_protocol, 0);
    v23 = api_add_data_full(v22, "PerDevice", api_data_type::API_BOOL, &want_per_device_stats, 0);
    v24 = api_add_data_full(v23, "WorkTime", api_data_type::API_BOOL, &opt_worktime, 0);
    print_data(io_data, v24, 0, 0);
  }
}

//----- (0002F10C) --------------------------------------------------------
void __fastcall checkcommand(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r6
  char *name; // r3
  CMDS *v9; // r4
  char *v10; // t1
  const __int32_t **v11; // r0
  __int32_t v12; // r3
  _BOOL4 v13; // r5
  api_data *v14; // r0
  char *v15; // r3
  api_data *v16; // r0
  _BOOL4 v17; // r0
  char *v18; // r3
  _BOOL4 v19; // r0
  _BOOL4 v20; // r0
  char cmdbuf[100]; // [sp+Ch] [bp-64h] BYREF

  v5 = isjson;
  if ( param && *param )
  {
    name = cmds[0].name;
    if ( cmds[0].name )
    {
      v9 = cmds;
      while ( strcmp(name, param) )
      {
        v10 = v9[1].name;
        ++v9;
        name = v10;
        if ( !v10 )
        {
          message(io_data, 72, 0, 0, v5);
          if ( !v5 )
            goto LABEL_20;
          goto LABEL_17;
        }
      }
      sprintf(cmdbuf, "|%s|", param);
      v11 = _ctype_toupper_loc();
      v12 = (*v11)[(unsigned __int8)group];
      if ( v12 == (*v11)[87] || strstr(apigroups[v12 - (*v11)[65]].commands, cmdbuf) )
      {
        message(io_data, 72, 0, 0, v5);
        if ( v5 )
          v13 = io_add(io_data, ",\"CHECK\":[");
        else
          v13 = io_add(io_data, "CHECK,");
        v14 = api_add_data_full(0, "Exists", api_data_type::API_CONST, "Y", 0);
        v15 = "Y";
        goto LABEL_12;
      }
      message(io_data, 72, 0, 0, v5);
      if ( v5 )
        v20 = io_add(io_data, ",\"CHECK\":[");
      else
        v20 = io_add(io_data, "CHECK,");
      v18 = "Y";
      v13 = v20;
    }
    else
    {
      message(io_data, 72, 0, 0, v5);
      if ( v5 )
      {
LABEL_17:
        v17 = io_add(io_data, ",\"CHECK\":[");
        v18 = "N";
        v13 = v17;
      }
      else
      {
LABEL_20:
        v19 = io_add(io_data, "CHECK,");
        v18 = "N";
        v13 = v19;
      }
    }
    v14 = api_add_data_full(0, "Exists", api_data_type::API_CONST, v18, 0);
    v15 = "N";
LABEL_12:
    v16 = api_add_data_full(v14, "Access", api_data_type::API_CONST, v15, 0);
    print_data(io_data, v16, v5, 0);
    if ( v5 && v13 )
      io_data->close = 1;
  }
  else
  {
    message(io_data, 71, 0, 0, isjson);
  }
}

//----- (0002F2D4) --------------------------------------------------------
void __fastcall devdetails(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r6
  _BOOL4 v7; // r10
  api_data *v8; // r11
  int v9; // r0
  cgpu_info *devices; // r5
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  char *kname; // r3
  api_data *v16; // r0
  char *name; // r3
  api_data *v18; // r0
  char *device_path; // r3
  api_data *v20; // r0
  bool v21; // r3
  int i; // [sp+Ch] [bp-8h] BYREF

  v5 = isjson;
  if ( !total_devices )
  {
    message(io_data, 10, 0, 0, isjson);
    return;
  }
  message(io_data, 69, 0, 0, isjson);
  if ( !v5 )
  {
    i = 0;
    if ( total_devices <= 0 )
      return;
    v7 = 0;
    goto LABEL_6;
  }
  v7 = io_add(io_data, ",\"DEVDETAILS\":[");
  i = 0;
  if ( total_devices > 0 )
  {
LABEL_6:
    v8 = 0;
    v9 = 0;
    do
    {
      devices = get_devices(v9);
      v11 = api_add_data_full(v8, "DEVDETAILS", api_data_type::API_INT, &i, 0);
      v12 = api_add_data_full(v11, "Name", api_data_type::API_STRING, devices->drv->name, 0);
      v13 = api_add_data_full(v12, "ID", api_data_type::API_INT, &devices->device_id, 0);
      v14 = api_add_data_full(v13, "Driver", api_data_type::API_STRING, devices->drv->dname, 0);
      kname = (char *)devices->kname;
      if ( !kname )
        kname = &byte_59398;
      v16 = api_add_data_full(v14, "Kernel", api_data_type::API_CONST, kname, 0);
      name = devices->name;
      if ( !name )
        name = &byte_59398;
      v18 = api_add_data_full(v16, "Model", api_data_type::API_CONST, name, 0);
      device_path = devices->device_path;
      if ( !device_path )
        device_path = &byte_59398;
      v20 = api_add_data_full(v18, "Device Path", api_data_type::API_CONST, device_path, 0);
      v21 = v5;
      if ( v5 )
        v21 = i > 0;
      v8 = print_data(io_data, v20, v5, v21);
      v9 = ++i;
    }
    while ( i < total_devices );
  }
  if ( v7 )
    io_data->close = 1;
}
// 59398: using guessed type char byte_59398;

//----- (0002F42C) --------------------------------------------------------
void __fastcall pgacount(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r5
  char *v7; // r1
  _BOOL4 v8; // r0
  char *v9; // r1
  _BOOL4 v10; // r5
  api_data *v11; // r0
  char *v12; // r1
  char *v13; // r1
  api_data *v14; // r0
  int count; // [sp+Ch] [bp-4h] BYREF

  v5 = isjson;
  count = 0;
  message(io_data, 59, 0, 0, isjson);
  if ( v5 )
  {
    LOWORD(v7) = 21840;
    HIWORD(v7) = (unsigned int)"r_count" >> 16;
    v8 = io_add(io_data, v7);
    LOWORD(v9) = 21896;
    v10 = v8;
    HIWORD(v9) = (unsigned int)"%d" >> 16;
    v11 = api_add_data_full(0, v9, api_data_type::API_INT, &count, 0);
    print_data(io_data, v11, 1, 0);
    if ( v10 )
      io_data->close = 1;
  }
  else
  {
    LOWORD(v12) = 21852;
    HIWORD(v12) = (unsigned int)"num" >> 16;
    io_add(io_data, v12);
    LOWORD(v13) = 21896;
    HIWORD(v13) = (unsigned int)"%d" >> 16;
    v14 = api_add_data_full(0, v13, api_data_type::API_INT, &count, 0);
    print_data(io_data, v14, 0, 0);
  }
}

//----- (0002F4B4) --------------------------------------------------------
void __fastcall minerconfig(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r5
  char *v7; // r1
  _BOOL4 v8; // r7
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  int asccount; // [sp+8h] [bp-Ch] BYREF
  int pgacount; // [sp+Ch] [bp-8h] BYREF

  v5 = isjson;
  asccount = 0;
  pgacount = 0;
  message(io_data, 33, 0, 0, isjson);
  v7 = ",\"CONFIG\":[";
  if ( !v5 )
    v7 = "CONFIG,";
  v8 = io_add(io_data, v7);
  v9 = api_add_data_full(0, "ASC Count", api_data_type::API_INT, &asccount, 0);
  v10 = api_add_data_full(v9, "PGA Count", api_data_type::API_INT, &pgacount, 0);
  v11 = api_add_data_full(v10, "Pool Count", api_data_type::API_INT, &total_pools, 0);
  v12 = api_add_data_full(v11, "Strategy", api_data_type::API_CONST, (void *)strategies_0[pool_strategy_0].s, 0);
  v13 = api_add_data_full(v12, "Log Interval", api_data_type::API_INT, &opt_log_interval, 0);
  v14 = api_add_data_full(v13, "Device Code", api_data_type::API_CONST, &byte_59398, 0);
  v15 = api_add_data_full(v14, "OS", api_data_type::API_CONST, "Linux", 0);
  v16 = api_add_data_full(v15, "Failover-Only", api_data_type::API_BOOL, &opt_fail_only, 0);
  v17 = api_add_data_full(v16, "ScanTime", api_data_type::API_INT, &opt_scantime, 0);
  v18 = api_add_data_full(v17, "Queue", api_data_type::API_INT, &opt_queue, 0);
  v19 = api_add_data_full(v18, "Expiry", api_data_type::API_INT, &opt_expiry, 0);
  v20 = api_add_data_full(v19, "Hotplug", api_data_type::API_CONST, "None", 0);
  print_data(io_data, v20, v5, 0);
  if ( v5 && v8 )
    io_data->close = 1;
}
// 59398: using guessed type char byte_59398;

//----- (0002F62C) --------------------------------------------------------
void __fastcall apiversion(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r4
  char *v7; // r1
  _BOOL4 v8; // r0
  void *v9; // r3
  char *v10; // r1
  _BOOL4 v11; // r6
  api_data *v12; // r0
  void *v13; // r3
  api_data *v14; // r0
  char *v15; // r1
  api_data *v16; // r0
  char *v17; // r1
  api_data *v18; // r0
  char *v19; // r1
  api_data *v20; // r0
  char *v21; // r1
  void *v22; // r3
  char *v23; // r1
  api_data *v24; // r0
  void *v25; // r3
  api_data *v26; // r0
  char *v27; // r1
  api_data *v28; // r0
  char *v29; // r1
  api_data *v30; // r0
  char *v31; // r1
  api_data *v32; // r1

  v5 = isjson;
  message(io_data, 22, 0, 0, isjson);
  if ( v5 )
  {
    LOWORD(v7) = 22028;
    HIWORD(v7) = (unsigned int)"lloc cgpu_info data" >> 16;
    v8 = io_add(io_data, v7);
    LOWORD(v9) = 12812;
    LOWORD(v10) = 22044;
    v11 = v8;
    HIWORD(v9) = (unsigned int)"ata" >> 16;
    HIWORD(v10) = (unsigned int)"cgpu(cgpu)" >> 16;
    v12 = api_add_data_full(0, v10, api_data_type::API_STRING, v9, 0);
    LOWORD(v13) = 22052;
    HIWORD(v13) = (unsigned int)"u)" >> 16;
    v14 = api_add_data_full(v12, "API", api_data_type::API_CONST, v13, 0);
    LOWORD(v15) = 22056;
    HIWORD(v15) = (unsigned int)"etect new device" >> 16;
    v16 = api_add_data_full(v14, v15, api_data_type::API_STRING, g_miner_version, 0);
    LOWORD(v17) = 22064;
    HIWORD(v17) = (unsigned int)"w device" >> 16;
    v18 = api_add_data_full(v16, v17, api_data_type::API_STRING, g_miner_compiletime, 0);
    LOWORD(v19) = 22076;
    HIWORD(v19) = (unsigned int)"%s: i2c always busy, break\n" >> 16;
    v20 = api_add_data_full(v18, v19, api_data_type::API_STRING, g_miner_type, 0);
    print_data(io_data, v20, 1, 0);
    if ( v11 )
      io_data->close = 1;
  }
  else
  {
    LOWORD(v21) = 22084;
    HIWORD(v21) = (unsigned int)"always busy, break\n" >> 16;
    io_add(io_data, v21);
    LOWORD(v22) = 12812;
    LOWORD(v23) = 22044;
    HIWORD(v22) = (unsigned int)"ata" >> 16;
    HIWORD(v23) = (unsigned int)"cgpu(cgpu)" >> 16;
    v24 = api_add_data_full(0, v23, api_data_type::API_STRING, v22, 0);
    LOWORD(v25) = 22052;
    HIWORD(v25) = (unsigned int)"u)" >> 16;
    v26 = api_add_data_full(v24, "API", api_data_type::API_CONST, v25, 0);
    LOWORD(v27) = 22056;
    HIWORD(v27) = (unsigned int)"etect new device" >> 16;
    v28 = api_add_data_full(v26, v27, api_data_type::API_STRING, g_miner_version, 0);
    LOWORD(v29) = 22064;
    HIWORD(v29) = (unsigned int)"w device" >> 16;
    v30 = api_add_data_full(v28, v29, api_data_type::API_STRING, g_miner_compiletime, 0);
    LOWORD(v31) = 22076;
    HIWORD(v31) = (unsigned int)"%s: i2c always busy, break\n" >> 16;
    v32 = api_add_data_full(v30, v31, api_data_type::API_STRING, g_miner_type, 0);
    print_data(io_data, v32, 0, 0);
  }
}

//----- (0002F780) --------------------------------------------------------
void __fastcall lcddisplay(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v6; // r5
  _BOOL4 v7; // r8
  pool *v8; // r6
  api_data *v9; // r0
  api_data *v10; // r0
  api_data *v11; // r9
  api_data *v12; // r9
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r1
  api_data *v16; // r0
  double ghs; // [sp+8h] [bp-ACh] BYREF
  char szindex[32]; // [sp+10h] [bp-A4h] BYREF
  char szfan[32]; // [sp+30h] [bp-84h] BYREF
  char sztemp[32]; // [sp+50h] [bp-64h] BYREF
  char szpool[32]; // [sp+70h] [bp-44h] BYREF
  char szuser[36]; // [sp+90h] [bp-24h] BYREF

  v6 = isjson;
  memset(szindex, 0, sizeof(szindex));
  v7 = v6;
  memset(szfan, 0, sizeof(szfan));
  memset(sztemp, 0, sizeof(sztemp));
  memset(szpool, 0, sizeof(szpool));
  memset(szuser, 0, 0x20u);
  v8 = current_pool();
  message(io_data, 7, 0, 0, v6);
  if ( v6 )
    v7 = io_add(io_data, ",\"POOLS\":[");
  strcpy(szindex, "0");
  ghs = total_mhashes_done / 1000.0 / total_secs;
  v9 = api_add_data_full(0, "LCD", api_data_type::API_STRING, szindex, 0);
  v10 = api_add_data_full(v9, "GHS5s", api_data_type::API_MHS, &g_displayed_rolling, 0);
  v11 = api_add_data_full(v10, "GHSavg", api_data_type::API_MHS, &ghs, 0);
  sprintf(szfan, "%d", g_max_fan);
  v12 = api_add_data_full(v11, "fan", api_data_type::API_STRING, szfan, 0);
  sprintf(sztemp, "%d", g_max_temp);
  v13 = api_add_data_full(v12, "temp", api_data_type::API_STRING, sztemp, 0);
  if ( v8 )
  {
    v14 = api_add_data_full(v13, "pool", api_data_type::API_STRING, v8->rpc_url, 0);
    v15 = api_add_data_full(v14, "user", api_data_type::API_STRING, v8->rpc_user, 0);
  }
  else
  {
    strcpy(szpool, "no");
    strcpy(szuser, "no");
    v16 = api_add_data_full(v13, "pool", api_data_type::API_STRING, szpool, 0);
    v15 = api_add_data_full(v16, "user", api_data_type::API_STRING, szuser, 0);
  }
  print_data(io_data, v15, v6, v6);
  if ( v7 )
    io_data->close = 1;
}
// 54574: using guessed type int dword_54574;

//----- (0002F950) --------------------------------------------------------
// Alternative name is 'itemstats.isra.17'
int __fastcall itemstats(
        io_data *io_data,
        int i,
        char *id,
        cgminer_stats *stats,
        api_data *pool_stats,
        api_data *extra,
        cgpu_info *cgpu,
        bool isjson)
{
  api_data *v11; // r0
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r1
  __time_t prev; // r3
  char v22; // r3
  int ia; // [sp+Ch] [bp-Ch] BYREF
  double ghs; // [sp+10h] [bp-8h] BYREF

  ia = i;
  ghs = total_mhashes_done / total_secs;
  v11 = api_add_data_full(0, "STATS", api_data_type::API_INT, &ia, 0);
  v12 = api_add_data_full(v11, "ID", api_data_type::API_STRING, id, 0);
  v13 = api_add_data_full(v12, "Elapsed", api_data_type::API_ELAPSED, &total_secs, 0);
  v14 = api_add_data_full(v13, "Calls", api_data_type::API_UINT32, stats, 0);
  v15 = api_add_data_full(v14, "Wait", api_data_type::API_TIMEVAL, &stats->getwork_wait, 0);
  v16 = api_add_data_full(v15, "Max", api_data_type::API_TIMEVAL, &stats->getwork_wait_max, 0);
  v17 = api_add_data_full(v16, "Min", api_data_type::API_TIMEVAL, &stats->getwork_wait_min, 0);
  v18 = api_add_data_full(v17, "GHS 5s", api_data_type::API_STRING, displayed_hash_rate, 0);
  v19 = api_add_data_full(v18, "GHS av", api_data_type::API_MHS, &ghs, 0);
  v20 = v19;
  if ( pool_stats )
  {
    if ( v19 )
    {
      prev = (__time_t)pool_stats->prev;
      pool_stats->prev = v19->prev;
      v19->prev->next = pool_stats;
      *(_DWORD *)(prev + 20) = v19;
      v19->prev = (api_data *)prev;
    }
    else
    {
      v20 = pool_stats;
    }
  }
  v22 = (char)extra;
  if ( (_BYTE)extra )
    v22 = ia > 0;
  print_data(io_data, v20, (bool)extra, v22);
  return ia + 1;
}

//----- (0002FA70) --------------------------------------------------------
void __fastcall minerestats(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r9
  int v7; // r4
  int v8; // r8
  cgpu_info *devices; // r0
  cgpu_info *v10; // r5
  device_drv *drv; // r3
  int (*pool_stats)(void); // r6
  int v13; // r0
  cgpu_info *v14; // [sp+8h] [bp-24h]
  _BOOL4 io_open; // [sp+Ch] [bp-20h]
  char id[24]; // [sp+14h] [bp-18h] BYREF

  v5 = isjson;
  message(io_data, 70, 0, 0, isjson);
  if ( !v5 )
  {
    if ( total_devices <= 0 )
      return;
    io_open = 0;
    goto LABEL_5;
  }
  io_open = io_add(io_data, ",\"STATS\":[");
  if ( total_devices > 0 )
  {
LABEL_5:
    v7 = 0;
    v8 = 0;
    do
    {
      devices = get_devices(v7);
      v10 = devices;
      if ( devices )
      {
        drv = devices->drv;
        if ( drv )
        {
          pool_stats = (int (*)(void))drv->get_api_stats;
          if ( pool_stats )
          {
            v13 = pool_stats();
            drv = v10->drv;
            pool_stats = (int (*)(void))v13;
          }
          sprintf(id, "%s%d", drv->name, v10->device_id);
          v8 = itemstats(io_data, v8, id, &v10->cgminer_stats, (api_data *)pool_stats, (api_data *)v5, v14, io_open);
        }
      }
      ++v7;
    }
    while ( total_devices > v7 );
  }
  if ( io_open )
    io_data->close = 1;
}
// 2FAE2: variable 'v14' is possibly undefined
// 2FAE2: variable 'io_open' is possibly undefined

//----- (0002FB20) --------------------------------------------------------
void __fastcall minerstats(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r7
  api_data *v7; // r0
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  int v11; // r4
  int v12; // r9
  cgpu_info *devices; // r0
  cgpu_info *v14; // r5
  device_drv *drv; // r3
  int (*get_api_stats)(void); // r6
  int v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  cgpu_info *v22; // [sp+8h] [bp-24h]
  _BOOL4 io_open; // [sp+Ch] [bp-20h]
  char id[24]; // [sp+14h] [bp-18h] BYREF

  v5 = isjson;
  message(io_data, 70, 0, 0, isjson);
  if ( !v5 )
  {
    v7 = api_add_data_full(0, "CGMiner", api_data_type::API_STRING, &unk_5320C, 0);
    v8 = api_add_data_full(v7, "Miner", api_data_type::API_STRING, g_miner_version, 0);
    v9 = api_add_data_full(v8, "CompileTime", api_data_type::API_STRING, g_miner_compiletime, 0);
    v10 = api_add_data_full(v9, "Type", api_data_type::API_STRING, g_miner_type, 0);
    print_data(io_data, v10, 0, 0);
    if ( total_devices <= 0 )
      return;
    io_open = 0;
    goto LABEL_5;
  }
  io_open = io_add(io_data, ",\"STATS\":[");
  v18 = api_add_data_full(0, "CGMiner", api_data_type::API_STRING, &unk_5320C, 0);
  v19 = api_add_data_full(v18, "Miner", api_data_type::API_STRING, g_miner_version, 0);
  v20 = api_add_data_full(v19, "CompileTime", api_data_type::API_STRING, g_miner_compiletime, 0);
  v21 = api_add_data_full(v20, "Type", api_data_type::API_STRING, g_miner_type, 0);
  print_data(io_data, v21, 1, 0);
  if ( total_devices > 0 )
  {
LABEL_5:
    v11 = 0;
    v12 = 0;
    do
    {
      devices = get_devices(v11);
      v14 = devices;
      if ( devices )
      {
        drv = devices->drv;
        if ( drv )
        {
          get_api_stats = (int (*)(void))drv->get_api_stats;
          if ( get_api_stats )
          {
            v17 = get_api_stats();
            drv = v14->drv;
            get_api_stats = (int (*)(void))v17;
          }
          sprintf(id, "%s%d", drv->name, v14->device_id);
          v12 = itemstats(
                  io_data,
                  v12,
                  id,
                  &v14->cgminer_stats,
                  (api_data *)get_api_stats,
                  (api_data *)v5,
                  v22,
                  io_open);
        }
      }
      ++v11;
    }
    while ( total_devices > v11 );
  }
  if ( io_open )
    io_data->close = 1;
}
// 2FBFA: variable 'v22' is possibly undefined
// 2FBFA: variable 'io_open' is possibly undefined

//----- (0002FCAC) --------------------------------------------------------
void __fastcall minecoin(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r4
  char *v7; // r1
  _BOOL4 v8; // r8
  api_data *v9; // r7
  const char *v10; // r2
  int v11; // r3
  const char *v12; // r2
  int v13; // r3
  api_data *v14; // r0
  api_data *v15; // r9
  const char *v16; // r2
  int v17; // r3
  api_data *v18; // r0
  api_data *v19; // r0

  v5 = isjson;
  message(io_data, 78, 0, 0, isjson);
  v7 = ",\"COIN\":[";
  if ( !v5 )
    v7 = "COIN,";
  v8 = io_add(io_data, v7);
  v9 = api_add_data_full(0, "Hash Method", api_data_type::API_CONST, "sha256", 0);
  if ( pthread_mutex_lock(&ch_lock.mutex) )
    mutex_lock_1((pthread_mutex_t *)(&_func___11933.__align + 3), (const char *)0xE72, v10, v11);
  rd_lock_0(&ch_lock.rwlock, &_func___11933.__size[12], (const char *)0xE72, v11);
  if ( pthread_mutex_unlock(&ch_lock.mutex) )
    mutex_unlock_noyield_1((pthread_mutex_t *)(&_func___11933.__align + 3), (const char *)0xE72, v12, v13);
  v14 = api_add_data_full(v9, "Current Block Time", api_data_type::API_TIMEVAL, &block_timeval, 1);
  v15 = api_add_data_full(v14, "Current Block Hash", api_data_type::API_STRING, current_hash, 1);
  if ( pthread_rwlock_unlock(&ch_lock.rwlock) )
    rw_unlock_0((pthread_rwlock_t *)(&_func___11933.__align + 3), (const char *)0xE75, v16, v17);
  selective_yield();
  v18 = api_add_data_full(v15, "LP", api_data_type::API_BOOL, &have_longpoll, 0);
  v19 = api_add_data_full(v18, "Network Difficulty", api_data_type::API_DIFF, &current_diff, 1);
  print_data(io_data, v19, v5, 0);
  if ( v5 && v8 )
    io_data->close = 1;
}
// 2FD14: variable 'v11' is possibly undefined
// 2FDCA: variable 'v10' is possibly undefined
// 2FDD6: variable 'v12' is possibly undefined
// 2FDD6: variable 'v13' is possibly undefined
// 2FDE2: variable 'v16' is possibly undefined
// 2FDE2: variable 'v17' is possibly undefined

//----- (0002FDF0) --------------------------------------------------------
void __fastcall summary(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r9
  char *v7; // r1
  const char *v8; // r2
  int v9; // r3
  double v10; // d7
  double v11; // d9
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  api_data *v22; // r0
  api_data *v23; // r0
  api_data *v24; // r0
  api_data *v25; // r0
  api_data *v26; // r0
  api_data *v27; // r0
  api_data *v28; // r0
  api_data *v29; // r0
  api_data *v30; // r0
  api_data *v31; // r0
  api_data *v32; // r0
  int64_t v33; // r10
  double v34; // d7
  api_data *v35; // r4
  double v36; // d7
  api_data *v37; // r0
  double v38; // d7
  double v39; // d5
  api_data *v40; // r0
  double v41; // d7
  double v42; // d5
  api_data *v43; // r0
  api_data *v44; // r4
  const char *v45; // r2
  int v46; // r3
  time_t v47; // r0
  int v48; // r4
  int v49; // r0
  int v50; // r10
  int v51; // r10
  int v52; // r4
  time_t v53; // r0
  double v54; // d5
  int v55; // r0
  int v56; // r3
  _BOOL4 io_open; // [sp+8h] [bp-44h]
  double utility; // [sp+10h] [bp-3Ch] BYREF
  double ghs; // [sp+18h] [bp-34h] BYREF
  double work_utility; // [sp+20h] [bp-2Ch] BYREF
  double hwp; // [sp+28h] [bp-24h] BYREF
  double rejp; // [sp+30h] [bp-1Ch] BYREF
  double prejp; // [sp+38h] [bp-14h] BYREF
  double stalep; // [sp+40h] [bp-Ch] BYREF

  v5 = isjson;
  message(io_data, 11, 0, 0, isjson);
  v7 = "SUMMARY,";
  if ( v5 )
    v7 = ",\"SUMMARY\":[";
  io_open = io_add(io_data, v7);
  if ( pthread_mutex_lock(&hash_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___11888, (const char *)0xAE9, v8, v9);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  v10 = (double)total_accepted;
  if ( total_secs == 0.0 )
  {
    v11 = 1.0;
  }
  else
  {
    v10 = (double)total_accepted / total_secs;
    v11 = total_secs;
  }
  utility = v10 * 60.0;
  ghs = total_mhashes_done / total_secs;
  work_utility = (double)(__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale) / v11 * 60.0;
  if ( certification_firmware )
  {
    v47 = time(0);
    srand(v47);
    if ( *cert_devname == 122 && cert_devname[1] == 57 && !cert_devname[2] )
    {
      v48 = 14 * rt_chain_num;
    }
    else
    {
      v52 = 4;
      v51 = 14;
      if ( strcmp(cert_devname, "z9-mini") )
      {
LABEL_31:
        v53 = time(0);
        srand(v53);
        v54 = (double)(rand() % 99) / 100.0;
        rt_hashrate_total = (double)v51 + v54;
        utility = (double)v52 + v54;
        ghs = (double)v51 + v54;
        v55 = rand();
        v56 = v55 & 3;
        if ( v55 <= 0 )
          v56 = -(-v55 & 3);
        work_utility = (double)(v56 + 100) + 0.27;
        sprintf(displayed_hash_rate, "%f", (double)v51 + v54 + 0.79);
        goto LABEL_7;
      }
      v48 = 3 * rt_chain_num + 1;
    }
    v49 = rand();
    v50 = v49 & 1;
    if ( v49 < 0 )
      v50 = -v50;
    v51 = v50 + v48;
    v52 = v51 % 5;
    goto LABEL_31;
  }
LABEL_7:
  v12 = api_add_data_full(0, "Elapsed", api_data_type::API_ELAPSED, &total_secs, 1);
  v13 = api_add_data_full(v12, "GHS 5s", api_data_type::API_STRING, displayed_hash_rate, 0);
  v14 = api_add_data_full(v13, "GHS av", api_data_type::API_MHS, &ghs, 0);
  v15 = api_add_data_full(v14, "Found Blocks", api_data_type::API_UINT, &found_blocks, 1);
  v16 = api_add_data_full(v15, "Getworks", api_data_type::API_INT64, &total_getworks, 1);
  v17 = api_add_data_full(v16, "Accepted", api_data_type::API_INT64, &total_accepted, 1);
  v18 = api_add_data_full(v17, "Rejected", api_data_type::API_INT64, &total_rejected, 1);
  v19 = api_add_data_full(v18, "Hardware Errors", api_data_type::API_INT, &hw_errors, 1);
  v20 = api_add_data_full(v19, "Utility", api_data_type::API_UTILITY, &utility, 0);
  v21 = api_add_data_full(v20, "Discarded", api_data_type::API_INT64, &total_discarded, 1);
  v22 = api_add_data_full(v21, "Stale", api_data_type::API_INT64, &total_stale, 1);
  v23 = api_add_data_full(v22, "Get Failures", api_data_type::API_UINT, &total_go, 1);
  v24 = api_add_data_full(v23, "Local Work", api_data_type::API_UINT, &local_work, 1);
  v25 = api_add_data_full(v24, "Remote Failures", api_data_type::API_UINT, &total_ro, 1);
  v26 = api_add_data_full(v25, "Network Blocks", api_data_type::API_UINT, &new_blocks, 1);
  v27 = api_add_data_full(v26, "Total MH", api_data_type::API_MHTOTAL, &total_mhashes_done, 1);
  v28 = api_add_data_full(v27, "Work Utility", api_data_type::API_UTILITY, &work_utility, 0);
  v29 = api_add_data_full(v28, "Difficulty Accepted", api_data_type::API_DIFF, &total_diff_accepted, 1);
  v30 = api_add_data_full(v29, "Difficulty Rejected", api_data_type::API_DIFF, &total_diff_rejected, 1);
  v31 = api_add_data_full(v30, "Difficulty Stale", api_data_type::API_DIFF, &total_diff_stale, 1);
  v32 = api_add_data_full(v31, "Best Share", api_data_type::API_UINT64, &best_diff, 1);
  v33 = total_diff1 + hw_errors;
  if ( v33 )
    v34 = (double)hw_errors / (double)v33;
  else
    v34 = 0.0;
  hwp = v34;
  v35 = api_add_data_full(v32, "Device Hardware%", api_data_type::API_PERCENT, &hwp, 0);
  if ( total_diff1 )
    v36 = total_diff_rejected / (double)total_diff1;
  else
    v36 = 0.0;
  rejp = v36;
  v37 = api_add_data_full(v35, "Device Rejected%", api_data_type::API_PERCENT, &rejp, 0);
  v38 = total_diff_rejected + total_diff_accepted + total_diff_stale;
  if ( v38 == 0.0 )
    v39 = 0.0;
  else
    v39 = total_diff_rejected / v38;
  prejp = v39;
  v40 = api_add_data_full(v37, "Pool Rejected%", api_data_type::API_PERCENT, &prejp, 0);
  v41 = total_diff_accepted + total_diff_rejected + total_diff_stale;
  if ( v41 == 0.0 )
    v42 = 0.0;
  else
    v42 = total_diff_stale / v41;
  stalep = v42;
  v43 = api_add_data_full(v40, "Pool Stale%", api_data_type::API_PERCENT, &stalep, 0);
  v44 = api_add_data_full(v43, "Last getwork", api_data_type::API_TIME, &last_getwork, 0);
  if ( pthread_mutex_unlock(&hash_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___11888, (const char *)0xB2E, v45, v46);
  selective_yield();
  print_data(io_data, v44, v5, 0);
  if ( v5 && io_open )
    io_data->close = 1;
}
// 303F4: variable 'v45' is possibly undefined
// 303F4: variable 'v46' is possibly undefined
// 30400: variable 'v8' is possibly undefined
// 30400: variable 'v9' is possibly undefined

//----- (0003040C) --------------------------------------------------------
void __fastcall poolstatus(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v6; // r9
  int v7; // r3
  api_data *v8; // r0
  api_data *v9; // r0
  api_data *v10; // r0
  double diff_rejected; // d5
  double v12; // d7
  double v13; // d6
  api_data *v14; // r0
  double diff_stale; // d5
  double v16; // d7
  double v17; // d6
  api_data *v18; // r0
  bool v19; // r3
  pool *v20; // r4
  pool_enable enabled; // r6
  char *v22; // r5
  time_t v23; // r0
  unsigned int v24; // lr
  api_data *v25; // r0
  api_data *v26; // r0
  api_data *v27; // r0
  api_data *v28; // r0
  api_data *v29; // r0
  api_data *v30; // r0
  api_data *v31; // r0
  api_data *v32; // r0
  api_data *v33; // r0
  api_data *v34; // r0
  api_data *v35; // r0
  api_data *v36; // r0
  api_data *v37; // r0
  api_data *v38; // r0
  api_data *v39; // r0
  api_data *v40; // r0
  api_data *v41; // r0
  api_data *v42; // r6
  char *v43; // r0
  api_data *v44; // r0
  api_data *v45; // r0
  api_data *v46; // r0
  api_data *v47; // r0
  api_data *v48; // r0
  api_data *v49; // r0
  api_data *v50; // r0
  api_data *v51; // r0
  api_data *v52; // r0
  char *v53; // r6
  api_data *root; // [sp+Ch] [bp-130h]
  _BOOL4 v56; // [sp+1Ch] [bp-120h]
  int i; // [sp+24h] [bp-118h] BYREF
  double rejp; // [sp+28h] [bp-114h] BYREF
  double stalep; // [sp+30h] [bp-10Ch] BYREF
  char lasttime[260]; // [sp+38h] [bp-104h] BYREF

  v6 = isjson;
  memset(lasttime, 0, 0x100u);
  if ( !total_pools )
  {
    message(io_data, 8, 0, 0, v6);
    return;
  }
  message(io_data, 7, 0, 0, v6);
  if ( !v6 )
  {
    i = 0;
    if ( total_pools <= 0 )
      return;
    v56 = 0;
    goto LABEL_6;
  }
  v56 = io_add(io_data, ",\"POOLS\":[");
  i = 0;
  if ( total_pools > 0 )
  {
LABEL_6:
    root = 0;
    v7 = 0;
    do
    {
      v20 = pools[v7];
      if ( !v20->removed )
      {
        enabled = v20->enabled;
        if ( enabled == pool_enable::POOL_ENABLED )
        {
          if ( v20->idle )
            v53 = "Dead";
          else
            v53 = "Alive";
        }
        else if ( enabled )
        {
          if ( enabled == pool_enable::POOL_REJECTING )
            v53 = "Rejecting";
          else
            v53 = "Unknown";
        }
        else
        {
          v53 = "Disabled";
        }
        v22 = "Y";
        if ( !v20->hdr_path )
          v22 = "N";
        if ( v20->last_share_time > 0 )
        {
          v23 = time(0);
          v24 = (v23 - v20->last_share_time) & ~((v23 - v20->last_share_time) >> 31);
          sprintf(lasttime, "%d:%02d:%02d", v24 / 0xE10, v24 % 0xE10 / 0x3C, v24 % 0xE10 % 0x3C);
        }
        else
        {
          strcpy(lasttime, "0");
        }
        v25 = api_add_data_full(root, "POOL", api_data_type::API_INT, &i, 0);
        v26 = api_add_data_full(v25, "URL", api_data_type::API_ESCAPE, v20->rpc_url, 0);
        v27 = api_add_data_full(v26, "Status", api_data_type::API_STRING, v53, 0);
        v28 = api_add_data_full(v27, "Priority", api_data_type::API_INT, &v20->prio, 0);
        v29 = api_add_data_full(v28, "Quota", api_data_type::API_INT, &v20->quota, 0);
        v30 = api_add_data_full(v29, "Long Poll", api_data_type::API_STRING, v22, 0);
        v31 = api_add_data_full(v30, "Getworks", api_data_type::API_UINT, &v20->getwork_requested, 0);
        v32 = api_add_data_full(v31, "Accepted", api_data_type::API_INT64, &v20->accepted, 0);
        v33 = api_add_data_full(v32, "Rejected", api_data_type::API_INT64, &v20->rejected, 0);
        v34 = api_add_data_full(v33, "Discarded", api_data_type::API_UINT, &v20->discarded_work, 0);
        v35 = api_add_data_full(v34, "Stale", api_data_type::API_UINT, &v20->stale_shares, 0);
        v36 = api_add_data_full(v35, "Get Failures", api_data_type::API_UINT, &v20->getfail_occasions, 0);
        v37 = api_add_data_full(v36, "Remote Failures", api_data_type::API_UINT, &v20->remotefail_occasions, 0);
        v38 = api_add_data_full(v37, "User", api_data_type::API_ESCAPE, v20->rpc_user, 0);
        v39 = api_add_data_full(v38, "Last Share Time", api_data_type::API_STRING, lasttime, 0);
        v40 = api_add_data_full(v39, "Diff", api_data_type::API_STRING, v20->diff, 0);
        v41 = api_add_data_full(v40, "Diff1 Shares", api_data_type::API_INT64, &v20->diff1, 0);
        v42 = v41;
        if ( v20->rpc_proxy )
        {
          v43 = (char *)proxytype(v20->rpc_proxytype);
          v44 = api_add_data_full(v42, "Proxy Type", api_data_type::API_CONST, v43, 0);
          v45 = api_add_data_full(v44, "Proxy", api_data_type::API_ESCAPE, v20->rpc_proxy, 0);
        }
        else
        {
          v52 = api_add_data_full(v41, "Proxy Type", api_data_type::API_CONST, &byte_59398, 0);
          v45 = api_add_data_full(v52, "Proxy", api_data_type::API_CONST, &byte_59398, 0);
        }
        v46 = api_add_data_full(v45, "Difficulty Accepted", api_data_type::API_DIFF, &v20->diff_accepted, 0);
        v47 = api_add_data_full(v46, "Difficulty Rejected", api_data_type::API_DIFF, &v20->diff_rejected, 0);
        v48 = api_add_data_full(v47, "Difficulty Stale", api_data_type::API_DIFF, &v20->diff_stale, 0);
        v49 = api_add_data_full(v48, "Last Share Difficulty", api_data_type::API_DIFF, &v20->last_share_diff, 0);
        v50 = api_add_data_full(v49, "Has Stratum", api_data_type::API_BOOL, &v20->has_stratum, 0);
        v51 = api_add_data_full(v50, "Stratum Active", api_data_type::API_BOOL, &v20->stratum_active, 0);
        if ( v20->stratum_active )
          v8 = api_add_data_full(v51, "Stratum URL", api_data_type::API_ESCAPE, v20->stratum_url, 0);
        else
          v8 = api_add_data_full(v51, "Stratum URL", api_data_type::API_CONST, &byte_59398, v20->stratum_active);
        v9 = api_add_data_full(v8, "Has GBT", api_data_type::API_BOOL, &v20->has_gbt, 0);
        v10 = api_add_data_full(v9, "Best Share", api_data_type::API_UINT64, &v20->best_diff, 1);
        diff_rejected = v20->diff_rejected;
        v12 = diff_rejected + v20->diff_accepted + v20->diff_stale;
        if ( v12 == 0.0 )
          v13 = 0.0;
        else
          v13 = diff_rejected / v12;
        rejp = v13;
        v14 = api_add_data_full(v10, "Pool Rejected%", api_data_type::API_PERCENT, &rejp, 0);
        diff_stale = v20->diff_stale;
        v16 = v20->diff_accepted + v20->diff_rejected + diff_stale;
        if ( v16 == 0.0 )
          v17 = 0.0;
        else
          v17 = diff_stale / v16;
        stalep = v17;
        v18 = api_add_data_full(v14, "Pool Stale%", api_data_type::API_PERCENT, &stalep, 0);
        v19 = v6 && i > 0;
        root = print_data(io_data, v18, v6, v19);
      }
      v7 = ++i;
    }
    while ( i < total_pools );
  }
  if ( v56 )
    io_data->close = 1;
}
// 59398: using guessed type char byte_59398;

//----- (00030914) --------------------------------------------------------
api_data *__fastcall api_add_escape(api_data *root, char *name, char *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_ESCAPE, data, copy_data);
}

//----- (00030928) --------------------------------------------------------
api_data *__fastcall api_add_string(api_data *root, char *name, char *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_STRING, data, copy_data);
}

//----- (0003093C) --------------------------------------------------------
api_data *__fastcall api_add_const(api_data *root, char *name, const char *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_CONST, (void *)data, copy_data);
}

//----- (00030950) --------------------------------------------------------
api_data *__fastcall api_add_uint8(api_data *root, char *name, uint8_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_UINT8, data, copy_data);
}

//----- (00030964) --------------------------------------------------------
api_data *__fastcall api_add_int16(api_data *root, char *name, int16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_INT16, data, copy_data);
}

//----- (00030978) --------------------------------------------------------
api_data *__fastcall api_add_uint16(api_data *root, char *name, uint16_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_UINT16, data, copy_data);
}

//----- (0003098C) --------------------------------------------------------
api_data *__fastcall api_add_int(api_data *root, char *name, int *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_INT, data, copy_data);
}

//----- (000309A0) --------------------------------------------------------
api_data *__fastcall api_add_uint(api_data *root, char *name, unsigned int *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_UINT, data, copy_data);
}

//----- (000309B4) --------------------------------------------------------
api_data *__fastcall api_add_uint32(api_data *root, char *name, uint32_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_UINT32, data, copy_data);
}

//----- (000309C8) --------------------------------------------------------
api_data *__fastcall api_add_hex32(api_data *root, char *name, uint32_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_HEX32, data, copy_data);
}

//----- (000309DC) --------------------------------------------------------
api_data *__fastcall api_add_uint64(api_data *root, char *name, uint64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_UINT64, data, copy_data);
}

//----- (000309F0) --------------------------------------------------------
api_data *__fastcall api_add_int64(api_data *root, char *name, int64_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_INT64, data, copy_data);
}

//----- (00030A04) --------------------------------------------------------
api_data *__fastcall api_add_double(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_DOUBLE, data, copy_data);
}

//----- (00030A18) --------------------------------------------------------
api_data *__fastcall api_add_elapsed(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_ELAPSED, data, copy_data);
}

//----- (00030A2C) --------------------------------------------------------
api_data *__fastcall api_add_bool(api_data *root, char *name, bool *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_BOOL, data, copy_data);
}

//----- (00030A40) --------------------------------------------------------
api_data *__fastcall api_add_timeval(api_data *root, char *name, timeval *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_TIMEVAL, data, copy_data);
}

//----- (00030A54) --------------------------------------------------------
api_data *__fastcall api_add_time(api_data *root, char *name, time_t *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_TIME, data, copy_data);
}

//----- (00030A68) --------------------------------------------------------
api_data *__fastcall api_add_mhs(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_MHS, data, copy_data);
}

//----- (00030A7C) --------------------------------------------------------
api_data *__fastcall api_add_mhtotal(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_MHTOTAL, data, copy_data);
}

//----- (00030A90) --------------------------------------------------------
api_data *__fastcall api_add_temp(api_data *root, char *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_TEMP, data, copy_data);
}

//----- (00030AA4) --------------------------------------------------------
api_data *__fastcall api_add_utility(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_UTILITY, data, copy_data);
}

//----- (00030AB8) --------------------------------------------------------
api_data *__fastcall api_add_freq(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_FREQ, data, copy_data);
}

//----- (00030ACC) --------------------------------------------------------
api_data *__fastcall api_add_volts(api_data *root, char *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_VOLTS, data, copy_data);
}

//----- (00030AE0) --------------------------------------------------------
api_data *__fastcall api_add_hs(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_HS, data, copy_data);
}

//----- (00030AF4) --------------------------------------------------------
api_data *__fastcall api_add_diff(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_DIFF, data, copy_data);
}

//----- (00030B08) --------------------------------------------------------
api_data *__fastcall api_add_percent(api_data *root, char *name, double *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_PERCENT, data, copy_data);
}

//----- (00030B1C) --------------------------------------------------------
api_data *__fastcall api_add_avg(api_data *root, char *name, float *data, bool copy_data)
{
  return api_add_data_full(root, name, api_data_type::API_AVG, data, copy_data);
}

//----- (00030B30) --------------------------------------------------------
void __fastcall notifystatus(io_data *io_data, int device, cgpu_info *cgpu, bool isjson, char group)
{
  time_t device_last_not_well; // r2
  int v7; // r7
  _BOOL4 v9; // r6
  dev_reason device_not_well_reason; // r2
  __int16 v11; // r3^2
  api_data *v12; // r0
  api_data *v13; // r0
  api_data *v14; // r0
  api_data *v15; // r0
  api_data *v16; // r0
  api_data *v17; // r0
  api_data *v18; // r0
  api_data *v19; // r0
  api_data *v20; // r0
  api_data *v21; // r0
  api_data *v22; // r0
  api_data *v23; // r0
  api_data *v24; // r0
  api_data *v25; // r0
  api_data *v26; // r0
  api_data *v27; // r0
  bool v28; // r3
  int devicea; // [sp+Ch] [bp-4h] BYREF

  device_last_not_well = cgpu->device_last_not_well;
  v7 = (int)"None";
  v9 = isjson;
  devicea = device;
  if ( device_last_not_well )
  {
    device_not_well_reason = cgpu->device_not_well_reason;
    if ( (unsigned int)device_not_well_reason > dev_reason::REASON_DEV_COMMS_ERROR )
      v7 = 22944;
    else
      *(_DWORD *)&isjson = 19980;
    if ( (unsigned int)device_not_well_reason > dev_reason::REASON_DEV_COMMS_ERROR )
      HIWORD(v7) = 5;
    else
      v11 = 5;
    if ( (unsigned int)device_not_well_reason <= dev_reason::REASON_DEV_COMMS_ERROR )
      v7 = *(_DWORD *)(isjson + 4 * device_not_well_reason + 112);
  }
  v12 = api_add_data_full(0, "NOTIFY", api_data_type::API_INT, &devicea, 0);
  v13 = api_add_data_full(v12, "Name", api_data_type::API_STRING, cgpu->drv->name, 0);
  v14 = api_add_data_full(v13, "ID", api_data_type::API_INT, &cgpu->device_id, 0);
  v15 = api_add_data_full(v14, "Last Well", api_data_type::API_TIME, &cgpu->device_last_well, 0);
  v16 = api_add_data_full(v15, "Last Not Well", api_data_type::API_TIME, &cgpu->device_last_not_well, 0);
  v17 = api_add_data_full(v16, "Reason Not Well", api_data_type::API_STRING, (void *)v7, 0);
  v18 = api_add_data_full(v17, "*Thread Fail Init", api_data_type::API_INT, &cgpu->thread_fail_init_count, 0);
  v19 = api_add_data_full(v18, "*Thread Zero Hash", api_data_type::API_INT, &cgpu->thread_zero_hash_count, 0);
  v20 = api_add_data_full(v19, "*Thread Fail Queue", api_data_type::API_INT, &cgpu->thread_fail_queue_count, 0);
  v21 = api_add_data_full(v20, "*Dev Sick Idle 60s", api_data_type::API_INT, &cgpu->dev_sick_idle_60_count, 0);
  v22 = api_add_data_full(v21, "*Dev Dead Idle 600s", api_data_type::API_INT, &cgpu->dev_dead_idle_600_count, 0);
  v23 = api_add_data_full(v22, "*Dev Nostart", api_data_type::API_INT, &cgpu->dev_nostart_count, 0);
  v24 = api_add_data_full(v23, "*Dev Over Heat", api_data_type::API_INT, &cgpu->dev_over_heat_count, 0);
  v25 = api_add_data_full(v24, "*Dev Thermal Cutoff", api_data_type::API_INT, &cgpu->dev_thermal_cutoff_count, 0);
  v26 = api_add_data_full(v25, "*Dev Comms Error", api_data_type::API_INT, &cgpu->dev_comms_error_count, 0);
  v27 = api_add_data_full(v26, "*Dev Throttle", api_data_type::API_INT, &cgpu->dev_throttle_count, 0);
  v28 = v9;
  if ( v9 )
    v28 = devicea > 0;
  print_data(io_data, v27, v9, v28);
}

//----- (00030CCC) --------------------------------------------------------
void __fastcall notify(io_data *io_data, int c, char *param, bool isjson, char group)
{
  _BOOL4 v5; // r6
  _BOOL4 v7; // r9
  int v8; // r4
  cgpu_info *devices; // r0
  int v10; // r1

  if ( !total_devices )
  {
    message(io_data, 10, 0, 0, isjson);
    return;
  }
  v5 = isjson;
  message(io_data, 60, 0, 0, isjson);
  if ( !v5 )
  {
    if ( total_devices <= 0 )
      return;
    v7 = 0;
    goto LABEL_6;
  }
  v7 = io_add(io_data, ",\"NOTIFY\":[");
  if ( total_devices > 0 )
  {
LABEL_6:
    v8 = 0;
    do
    {
      devices = get_devices(v8);
      v10 = v8++;
      notifystatus(io_data, v10, devices, v5, group);
    }
    while ( total_devices > v8 );
  }
  if ( v7 )
    io_data->close = 1;
}

//----- (00030D58) --------------------------------------------------------
void mcast_init()
{
  thr_info *v0; // r0
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  v0 = (thr_info *)calloc(1u, 0x40u);
  if ( !v0 )
  {
    strcpy(tmp42, "Failed to calloc mcast thr");
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( thr_info_create(v0, 0, mcast_thread, v0) )
  {
    strcpy(tmp42, "API mcast thread create failed");
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00030DE0) --------------------------------------------------------
void __fastcall api(int api_thr_id)
{
  double v1; // d0
  _BOOL4 v2; // r3
  io_data *v3; // r5
  char *v4; // r0
  char *v5; // r7
  io_list *v6; // r0
  io_list *v7; // r2
  const char *v8; // r4
  size_t v9; // r0
  unsigned __int8 *v10; // r5
  char *v11; // r0
  char *v12; // r0
  const __int32_t **v13; // r9
  const __int32_t *v14; // r2
  __int32_t v15; // r1
  unsigned __int8 *v16; // r4
  int v17; // r8
  char *v18; // r0
  char *v19; // r7
  char *name; // r5
  CMDS *v21; // r10
  int v22; // r6
  char *v23; // t1
  size_t v24; // r0
  int v25; // r5
  char *v26; // r0
  const __int32_t **v27; // r0
  char *v28; // r5
  const __int32_t **v29; // r11
  CMDS *v30; // r4
  char *v31; // r7
  char *v32; // t1
  size_t v33; // r0
  char *v34; // t1
  char *v35; // r0
  size_t v36; // r0
  __int32_t v37; // r3
  int v38; // r4
  char *v39; // r0
  const char *v40; // r5
  size_t v41; // r0
  char *v42; // r0
  char *v43; // r9
  char *v44; // r2
  size_t v45; // r0
  int v46; // r3
  int v47; // t1
  int v48; // r6
  const char *v49; // r5
  int v50; // r3
  int v51; // t1
  bool v52; // zf
  char *v53; // r0
  char *v54; // r8
  const unsigned __int16 **v55; // r0
  int v56; // r2
  const __int32_t *v57; // r3
  char v58; // r1
  IPACCESS *v59; // r4
  int v60; // r10
  char *v61; // r0
  int v62; // r10
  int v63; // r0
  const char *v64; // r5
  size_t v65; // r0
  CMDS *v66; // r4
  char *v67; // r8
  char *v68; // t1
  const char *v69; // r7
  char *v70; // r0
  uint8_t *v71; // r1
  IPACCESS *v72; // r3
  IPACCESS *v73; // r3
  int v74; // r2
  bool v75; // cf
  int v76; // r12
  IPACCESS *v77; // r3
  uint8_t *v78; // r0
  uint8_t *v79; // r3
  uint8_t *v80; // r4
  char v81; // r2
  char v82; // t1
  char v83; // t1
  IPACCESS *v84; // r3
  __int32_t v85; // r0
  addrinfo *v86; // r4
  addrinfo *i; // r3
  int v88; // r0
  int *v89; // r0
  char *v90; // r0
  time_t v91; // r8
  int *v92; // r0
  int v93; // r7
  _BOOL4 v94; // r4
  _BOOL4 v95; // r0
  int v96; // r9
  const char *v97; // r1
  ssize_t v98; // r0
  size_t v99; // r5
  _BOOL4 v100; // r3
  const char *v101; // r8
  time_t v102; // r0
  char *ptr; // r3
  int v104; // r3
  char *v105; // r0
  size_t v106; // r0
  char *v107; // r6
  char *v108; // r0
  int v109; // r3
  char *v110; // r1
  CMDS *v111; // r5
  int v112; // r4
  char *v113; // t1
  size_t v114; // r0
  char **v115; // r3
  int v116; // r5
  __int32_t v117; // r2
  int v118; // r3
  int *v119; // r0
  char *v120; // r0
  int *v121; // r0
  char *v122; // r0
  int *v123; // r0
  int *v124; // r0
  char *v125; // r0
  const char *v126; // r3
  const char *v127; // r2
  int v128; // r3
  const char *v129; // r2
  int v130; // r3
  json_t *v131; // r0
  size_t refcount; // r3
  size_t v133; // r3
  int *v134; // r0
  char *v135; // r0
  json_t *v136; // r0
  const char *v137; // r2
  int v138; // r3
  const char *v139; // r2
  int v140; // r3
  json_t *v141; // r0
  json_type type; // r3
  int v143; // r0
  int v144; // [sp+14h] [bp-26468h]
  unsigned __int8 *v145; // [sp+18h] [bp-26464h]
  int *apisock; // [sp+20h] [bp-2645Ch]
  char *v147; // [sp+24h] [bp-26458h]
  json_t *json_config; // [sp+2Ch] [bp-26450h]
  __int16 v149; // [sp+38h] [bp-26444h]
  int c; // [sp+40h] [bp-2643Ch]
  char *dest; // [sp+44h] [bp-26438h]
  int protocol; // [sp+48h] [bp-26434h]
  char *param; // [sp+54h] [bp-26428h]
  io_data *io_data; // [sp+58h] [bp-26424h]
  char *cmdsbuf; // [sp+60h] [bp-2641Ch]
  char group; // [sp+7Eh] [bp-263FEh] BYREF
  bool firstjoin; // [sp+7Fh] [bp-263FDh] BYREF
  char *connectaddr; // [sp+80h] [bp-263FCh] BYREF
  socklen_t clisiz; // [sp+84h] [bp-263F8h] BYREF
  addrinfo *res; // [sp+88h] [bp-263F4h] BYREF
  int optval; // [sp+8Ch] [bp-263F0h] BYREF
  char port_s[12]; // [sp+90h] [bp-263ECh] BYREF
  char cp[32]; // [sp+9Ch] [bp-263E0h] BYREF
  addrinfo hints; // [sp+BCh] [bp-263C0h] BYREF
  thr_info bye_thr; // [sp+DCh] [bp-263A0h] BYREF
  char cmdbuf[100]; // [sp+11Ch] [bp-26360h] BYREF
  char s[100]; // [sp+180h] [bp-262FCh] BYREF
  sockaddr_storage cli; // [sp+1E4h] [bp-26298h] BYREF
  json_error_t json_err; // [sp+264h] [bp-26218h] BYREF
  __pthread_unwind_buf_t __cancel_buf; // [sp+360h] [bp-2611Ch] BYREF
  char tmp42[4096]; // [sp+478h] [bp-26004h] BYREF
  char tmp42_0[4096]; // [sp+1478h] [bp-25004h] BYREF
  char tmp42_1[4096]; // [sp+2478h] [bp-24004h] BYREF
  char tmp42_2[4096]; // [sp+3478h] [bp-23004h] BYREF
  char tmp42_3[4096]; // [sp+4478h] [bp-22004h] BYREF
  char tmp42_4[4096]; // [sp+5478h] [bp-21004h] BYREF
  char tmp42_5[4096]; // [sp+6478h] [bp-20004h] BYREF
  char tmp42_6[4096]; // [sp+7478h] [bp-1F004h] BYREF
  char tmp42_7[4096]; // [sp+8478h] [bp-1E004h] BYREF
  char tmp42_8[4096]; // [sp+9478h] [bp-1D004h] BYREF
  char tmp42_9[4096]; // [sp+A478h] [bp-1C004h] BYREF
  char tmp42_10[4096]; // [sp+B478h] [bp-1B004h] BYREF
  char tmp42_11[4096]; // [sp+C478h] [bp-1A004h] BYREF
  char tmp42_12[4096]; // [sp+D478h] [bp-19004h] BYREF
  char tmp42_13[4096]; // [sp+E478h] [bp-18004h] BYREF
  char tmp42_14[4096]; // [sp+F478h] [bp-17004h] BYREF
  char tmp42_15[4096]; // [sp+10478h] [bp-16004h] BYREF
  char tmp42_16[4096]; // [sp+11478h] [bp-15004h] BYREF
  char tmp42_17[4096]; // [sp+12478h] [bp-14004h] BYREF
  char tmp42_18[4096]; // [sp+13478h] [bp-13004h] BYREF
  char v191[3976]; // [sp+14478h] [bp-12004h] BYREF
  char v192[3976]; // [sp+15478h] [bp-11004h] BYREF
  char v193[3976]; // [sp+16478h] [bp-10004h] BYREF
  char v194[3976]; // [sp+17478h] [bp-F004h] BYREF
  char v195[3976]; // [sp+18478h] [bp-E004h] BYREF
  char v196[3976]; // [sp+19478h] [bp-D004h] BYREF
  char v197[3976]; // [sp+1A478h] [bp-C004h] BYREF
  char v198[3976]; // [sp+1B478h] [bp-B004h] BYREF
  char v199[3976]; // [sp+1C478h] [bp-A004h] BYREF
  char v200[3976]; // [sp+1D478h] [bp-9004h] BYREF
  char v201[3976]; // [sp+1E478h] [bp-8004h] BYREF
  char v202[3976]; // [sp+1F478h] [bp-7004h] BYREF
  char buf[8192]; // [sp+20478h] [bp-6004h] BYREF
  char param_buf[8192]; // [sp+22478h] [bp-4004h] BYREF
  _WORD v205[4098]; // [sp+24478h] [bp-2004h] BYREF

  json_config = 0;
  v149 = opt_api_port;
  apisock = (int *)malloc(4u);
  v2 = opt_api_listen;
  *apisock = -1;
  if ( !v2 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "API not running%s", " - API will not be available");
      applog(7, tmp42, 0);
    }
    goto LABEL_6;
  }
  io_data = (io_data *)malloc(0x10u);
  v3 = io_data;
  v4 = (char *)malloc(0x10000u);
  v5 = 0;
  io_data->close = 0;
  *v4 = 0;
  io_data->ptr = v4;
  io_data->cur = v4;
  io_data->sock = 1;
  io_data->siz = 0x10000;
  v6 = (io_list *)malloc(0xCu);
  v6->io_data = io_data;
  v7 = io_head;
  if ( io_head )
  {
    v6->next = io_head;
    v6->prev = v7->prev;
    v7->prev = v6;
    v6->prev->next = v6;
  }
  else
  {
    v6->prev = v6;
    v6->next = v6;
    io_head = v6;
  }
  if ( pthread_mutex_init(&quit_restart_lock, 0) )
  {
    v123 = _errno_location();
    snprintf(
      v191,
      0x1000u,
      "Failed to pthread_mutex_init errno=%d in %s %s():%d",
      *v123,
      "api.c",
      (const char *)&_func___12699,
      5297);
    applog(3, v191, 1);
    quit(1);
  }
  if ( _sigsetjmp((struct __jmp_buf_tag *)&__cancel_buf, 0) )
  {
    tidyup(apisock);
    _pthread_unwind_next(&__cancel_buf);
LABEL_253:
    freeaddrinfo(res);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(tmp42_5, 0x1000u, "API bind to port %d failed (%s)%s", v3, v5, " - API will not be available");
      applog(3, tmp42_5, 0);
    }
    goto LABEL_6;
  }
  _pthread_register_cancel(&__cancel_buf);
  v8 = opt_api_groups;
  if ( opt_api_groups )
  {
    v9 = strlen(opt_api_groups) + 1;
  }
  else
  {
    v8 = &byte_59398;
    v9 = 1;
  }
  dest = (char *)malloc(v9);
  if ( !dest )
  {
    strcpy(v192, "Failed to malloc ipgroups buf");
    applog(3, v192, 1);
    quit(1);
  }
  v10 = (unsigned __int8 *)dest;
  strcpy(dest, v8);
  if ( *dest )
  {
    do
    {
      v11 = strchr((const char *)v10, 44);
      if ( v11 )
      {
        v145 = (unsigned __int8 *)(v11 + 1);
        *v11 = 0;
      }
      else
      {
        v145 = 0;
      }
      if ( v10[1] != 58 )
      {
        v12 = strchr((const char *)v10, 58);
        if ( v12 )
          *v12 = 0;
        snprintf(v193, 0x1000u, "API invalid group name '%s'", v10);
        applog(3, v193, 1);
        quit(1);
      }
      v13 = _ctype_toupper_loc();
      v14 = *v13;
      v144 = LOBYTE((*v13)[*v10]);
      v15 = (*v13)[v144];
      if ( v15 < (*v13)[65] || v15 > v14[90] )
      {
        snprintf(v194, 0x1000u, "API invalid group name '%c'");
        applog(3, v194, 1);
        quit(1);
      }
      if ( v144 == v14[87] )
      {
        snprintf(v195, 0x1000u, "API group name can't be '%c'", v144);
        applog(3, v195, 1);
        quit(1);
      }
      if ( v144 == v14[82] )
      {
        snprintf(v196, 0x1000u, "API group name can't be '%c'", v144);
        applog(3, v196, 1);
        quit(1);
      }
      if ( apigroups[v14[v144] - v14[65]].commands )
      {
        snprintf(v197, 0x1000u, "API duplicate group name '%c'", *v10);
        applog(3, v197, 1);
        quit(1);
      }
      v16 = v10 + 2;
      v205[0] = 124;
      if ( v10 != (unsigned __int8 *)-2 && v10[2] )
      {
        v17 = 0;
        v147 = (char *)v205 + 1;
        do
        {
          v18 = strchr((const char *)v16, 58);
          v19 = v18;
          if ( v18 )
          {
            v19 = v18 + 1;
            *v18 = 0;
          }
          if ( *v16 != 42 || v16[1] )
          {
            name = cmds[0].name;
            v21 = cmds;
            v22 = 0;
            if ( !cmds[0].name )
            {
LABEL_92:
              snprintf(v198, 0x1000u, "API unknown command '%s' in group '%c'", v16, v144);
              applog(3, v198, 1);
              quit(1);
            }
            while ( strcasecmp((const char *)v16, name) )
            {
              v23 = v21[1].name;
              ++v21;
              name = v23;
              ++v22;
              if ( !v23 )
                goto LABEL_92;
            }
            sprintf(s, "|%s|", name);
            if ( !strstr((const char *)v205, s) )
            {
              v64 = (const char *)*((_DWORD *)&codes[67].severity + 3 * v22);
              strcpy(v147, v64);
              v65 = strlen(v64);
              v147[v65 + 1] = 0;
              v147[v65] = 124;
              v147 += v65 + 1;
            }
          }
          else
          {
            v17 = 1;
          }
          if ( !v19 )
            break;
          v16 = (unsigned __int8 *)v19;
        }
        while ( *v19 );
        if ( v17 && cmds[0].name )
        {
          v66 = cmds;
          v67 = v147;
          do
          {
            if ( !v66->iswritemode )
            {
              sprintf(s, "|%s|");
              if ( !strstr((const char *)v205, s) )
              {
                v69 = v66->name;
                strcpy(v67, v66->name);
                v70 = &v67[strlen(v69)];
                v67 = v70 + 1;
                v70[1] = 0;
                *v70 = 124;
              }
            }
            v68 = v66[1].name;
            ++v66;
          }
          while ( v68 );
        }
      }
      v24 = strlen((const char *)v205);
      v25 = (*v13)[v144] - (*v13)[65];
      v26 = (char *)malloc(v24 + 1);
      apigroups[v25].commands = v26;
      if ( !v26 )
      {
        strcpy(v199, "Failed to malloc group commands buf");
        applog(3, v199, 1);
        quit(1);
      }
      strcpy(v26, (const char *)v205);
      if ( !v145 )
        break;
      v10 = v145;
    }
    while ( *v145 );
  }
  v27 = _ctype_toupper_loc();
  v28 = cmds[0].name;
  v29 = v27;
  v205[0] = 124;
  if ( cmds[0].name )
  {
    v30 = cmds;
    v31 = (char *)v205 + 1;
    do
    {
      while ( v30->iswritemode )
      {
        v32 = v30[1].name;
        ++v30;
        v28 = v32;
        if ( !v32 )
          goto LABEL_51;
      }
      strcpy(v31, v28);
      v33 = strlen(v28);
      v34 = v30[1].name;
      ++v30;
      v28 = v34;
      v35 = &v31[v33];
      v31 = v35 + 1;
      *v35 = 124;
      v35[1] = 0;
    }
    while ( v34 );
  }
LABEL_51:
  v36 = strlen((const char *)v205) + 1;
  v37 = (*v29)[82];
  if ( (unsigned int)(v37 + 128) < 0x180 )
    v37 = (*v29)[v37];
  v38 = v37 - (*v29)[65];
  v39 = (char *)malloc(v36);
  apigroups[v38].commands = v39;
  if ( !v39 )
  {
    strcpy(v200, "Failed to malloc noprivgroup commands buf");
    applog(3, v200, 1);
    quit(1);
  }
  strcpy(v39, (const char *)v205);
  free(dest);
  v40 = opt_api_allow;
  if ( opt_api_allow )
  {
    v41 = strlen(opt_api_allow);
    v42 = (char *)malloc(v41 + 1);
    v43 = v42;
    if ( !v42 )
    {
      strcpy(v201, "Failed to malloc ipaccess buf");
      applog(3, v201, 1);
      quit(1);
    }
    strcpy(v42, v40);
    v44 = v43 - 1;
    v45 = 1;
    while ( 1 )
    {
      v47 = (unsigned __int8)*++v44;
      v46 = v47;
      if ( !v47 )
        break;
      if ( v46 == 44 )
        ++v45;
    }
    ipaccess = (IPACCESS *)calloc(v45, 0x24u);
    if ( !ipaccess )
    {
      strcpy(v202, "Failed to calloc ipaccess");
      applog(3, v202, 1);
      quit(1);
    }
    v48 = 0;
    v49 = v43;
    ips = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        v50 = *(unsigned __int8 *)v49;
        if ( !*v49 )
        {
LABEL_85:
          free(v43);
          if ( v48 )
            goto LABEL_86;
          if ( use_syslog || opt_log_output || opt_log_level > 3 )
          {
            snprintf(tmp42_0, 0x1000u, "API not running (no valid IPs specified)%s", " - API will not be available");
            applog(4, tmp42_0, 0);
          }
LABEL_6:
          free(apisock);
          return;
        }
        while ( 1 )
        {
          v52 = v50 == 9;
          if ( v50 != 9 )
            v52 = v50 == 32;
          if ( !v52 )
            break;
          v51 = *(unsigned __int8 *)++v49;
          v50 = v51;
        }
        if ( v50 != 44 )
          break;
        ++v49;
LABEL_84:
        if ( !v49 )
          goto LABEL_85;
      }
      v53 = strchr(v49, 44);
      v54 = v53;
      if ( v53 )
      {
        v54 = v53 + 1;
        *v53 = 0;
      }
      v55 = _ctype_b_loc();
      v56 = *(unsigned __int8 *)v49;
      v57 = *v29;
      v58 = *((_BYTE *)*v29 + 328);
      if ( ((*v55)[v56] & 0x400) != 0 && v49[1] == 58 )
      {
        v85 = v57[v56];
        if ( v85 == v57[87] || apigroups[v85 - v57[65]].commands )
          v58 = v57[v56];
        v49 += 2;
      }
      v59 = &ipaccess[v48];
      v59->group = v58;
      v60 = *(unsigned __int8 *)v49;
      if ( v60 == 48 )
      {
        if ( v49[1] == 47 && v49[2] == 48 && !v49[3] )
        {
          v71 = &v59->ip.__u6_addr8[15];
          v72 = (IPACCESS *)((char *)v59 - 1);
          do
          {
            v72->ip.__u6_addr8[1] = 0;
            v72 = (IPACCESS *)((char *)v72 + 1);
            *++v71 = 0;
          }
          while ( v72 != (IPACCESS *)((char *)&v59->ip.__u6_addr32[3] + 3) );
          goto LABEL_107;
        }
        v61 = strchr(v49, 47);
        if ( v61 )
          goto LABEL_78;
      }
      else
      {
        v61 = strchr(v49, 47);
        if ( v61 )
          goto LABEL_76;
      }
      v73 = (IPACCESS *)((char *)&v59->ip.__u6_addr32[3] + 3);
      do
      {
        v73->ip.__u6_addr8[1] = -1;
        v73 = (IPACCESS *)((char *)v73 + 1);
      }
      while ( (IPACCESS *)((char *)&v59->mask.__u6_addr32[3] + 3) != v73 );
      v60 = *(unsigned __int8 *)v49;
      v61 = (char *)&v49[strlen(v49)];
LABEL_76:
      if ( v60 == 91 && *(v61 - 1) == 93 )
      {
        v62 = 1;
        *v49++ = 0;
        *(v61 - 1) = 0;
        goto LABEL_79;
      }
LABEL_78:
      v62 = 0;
LABEL_79:
      if ( *v61 )
      {
        *v61 = 0;
        v63 = strtol(v61 + 1, 0, 10);
        if ( v63 <= 0 )
          goto LABEL_83;
        if ( v62 )
        {
          if ( v63 > 128 )
            goto LABEL_83;
        }
        else
        {
          v63 += 96;
          if ( v63 > 128 )
          {
LABEL_83:
            v49 = v54;
            goto LABEL_84;
          }
        }
        v84 = (IPACCESS *)((char *)&v59->ip.__u6_addr32[3] + 3);
        v74 = 0;
        do
        {
          v84->ip.__u6_addr8[1] = 0;
          v84 = (IPACCESS *)((char *)v84 + 1);
        }
        while ( (IPACCESS *)((char *)&v59->mask.__u6_addr32[3] + 3) != v84 );
        while ( 1 )
        {
          v75 = v63-- != 0;
          v76 = 7;
          if ( !v75 )
            break;
          while ( 1 )
          {
            v59->mask.__u6_addr8[v74] |= 1 << v76;
            if ( !v76 )
              break;
            v75 = v63-- != 0;
            --v76;
            if ( !v75 )
              goto LABEL_118;
          }
          ++v74;
        }
      }
LABEL_118:
      v77 = (IPACCESS *)((char *)v59 - 1);
      do
      {
        v77->ip.__u6_addr8[1] = 0;
        v77 = (IPACCESS *)((char *)v77 + 1);
      }
      while ( (IPACCESS *)((char *)&v59->ip.__u6_addr32[3] + 3) != v77 );
      if ( v62 )
      {
        if ( inet_pton(10, v49, v59) != 1 )
          goto LABEL_83;
      }
      else
      {
        sprintf(cp, "::ffff:%s", v49);
        v48 = ips;
        v59 = &ipaccess[ips];
        if ( inet_pton(10, cp, v59) != 1 )
        {
          v49 = v54;
          goto LABEL_84;
        }
      }
      v78 = &v59->ip.__u6_addr8[15];
      v79 = (uint8_t *)(&v59[-1].group + 3);
      v80 = &v59->ip.__u6_addr8[15];
      do
      {
        v82 = *++v79;
        v81 = v82;
        v83 = *++v78;
        *v79 = v81 & v83;
      }
      while ( v79 != v80 );
LABEL_107:
      v49 = v54;
      ips = ++v48;
      if ( !v54 )
        goto LABEL_85;
    }
  }
LABEL_86:
  v3 = (io_data *)v149;
  cgsleep_ms(1000 * opt_log_interval);
  sprintf(port_s, "%d", v149);
  hints.ai_flags = 1;
  memset(&hints.ai_family, 0, 28);
  protocol = getaddrinfo(opt_api_host, port_s, &hints, &res);
  if ( protocol )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(tmp42_1, 0x1000u, "API failed to resolve %s", opt_api_host);
      applog(3, tmp42_1, 0);
    }
    goto LABEL_6;
  }
  v86 = res;
  if ( res )
  {
    for ( i = res; ; i = res )
    {
      v88 = socket(i->ai_family, 1, protocol);
      *apisock = v88;
      if ( v88 > 0 )
        break;
      v86 = v86->ai_next;
      if ( !v86 )
        goto LABEL_223;
    }
  }
  else
  {
    v88 = *apisock;
LABEL_223:
    if ( v88 == -1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        v119 = _errno_location();
        v120 = strerror(*v119);
        snprintf(tmp42_2, 0x1000u, "API initialisation failed (%s)%s", v120, " - API will not be available");
        applog(3, tmp42_2, 0);
      }
      freeaddrinfo(res);
      free(apisock);
      return;
    }
    v86 = 0;
  }
  optval = 1;
  if ( setsockopt(v88, 1, 2, &optval, 4u) < 0 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    v89 = _errno_location();
    v90 = strerror(*v89);
    snprintf(tmp42_3, 0x1000u, "API setsockopt SO_REUSEADDR failed (ignored): %s", v90);
    applog(7, tmp42_3, 0);
  }
  v91 = time(0);
  while ( bind(*apisock, v86->ai_addr, v86->ai_addrlen) < 0 )
  {
    v92 = _errno_location();
    v5 = strerror(*v92);
    if ( time(0) - v91 > 61 )
      goto LABEL_253;
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(tmp42_4, 0x1000u, "API bind to port %d failed - trying again in 30sec", v149);
      applog(4, tmp42_4, 0);
    }
    cgsleep_ms(30000);
  }
  freeaddrinfo(res);
  if ( listen(*apisock, 100) < 0 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      v134 = _errno_location();
      v135 = strerror(*v134);
      snprintf(tmp42_6, 0x1000u, "API3 initialisation failed (%s)%s", v135, " - API will not be available");
      applog(3, tmp42_6, 0);
    }
    close(*apisock);
    free(apisock);
    return;
  }
  if ( opt_api_allow )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(tmp42_7, 0x1000u, "API running in IP access mode on port %d (%d)", v149, *apisock);
      applog(4, tmp42_7, 0);
    }
  }
  else if ( opt_api_network )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      snprintf(tmp42_8, 0x1000u, "API running in UNRESTRICTED read access mode on port %d (%d)", v149, *apisock);
      applog(4, tmp42_8, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42_9, 0x1000u, "API running in local read access mode on port %d (%d)", v149, *apisock);
    applog(4, tmp42_9, 0);
  }
  if ( opt_api_mcast )
    mcast_init();
  v93 = 0;
  strbufs = k_new_list("StrBufs", 0xCu, 2, 0, 0, "api.c", (const char *)&_func___12699, 5409);
  while ( 1 )
  {
    v94 = bye;
    if ( bye )
      goto die;
    clisiz = 128;
    c = accept(*apisock, (struct sockaddr *)&cli, &clisiz);
    if ( c < 0 )
      break;
    v95 = check_connect(&cli, &connectaddr, &group);
    v96 = v95;
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      v97 = "Accepted";
      if ( !v95 )
        v97 = "Ignored";
      snprintf(tmp42_11, 0x1000u, "API: connection from %s - %s", connectaddr, v97);
      applog(7, tmp42_11, 0);
    }
    if ( v96 )
    {
      v98 = recv(c, buf, 0x1FFFu, 0);
      v99 = v98;
      v100 = opt_debug;
      if ( v98 >= 0 )
      {
        buf[v98] = 0;
        if ( v100 && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42_13, 0x1000u, "API: recv command: (%d) '%s'", v98, buf);
          applog(7, tmp42_13, 0);
        }
        v101 = buf;
        v102 = time(0);
        ptr = io_data->ptr;
        io_data->cur = ptr;
        when = v102;
        *ptr = 0;
        v104 = (unsigned __int8)buf[0];
        io_data->close = 0;
        if ( v104 == 123 )
        {
          v131 = json_loadb(buf, v99, 0, &json_err);
          json_config = v131;
          if ( v131 && v131->type == JSON_OBJECT )
          {
            v136 = json_object_get(v131, "command");
            if ( v136 )
            {
              if ( v136->type == JSON_STRING )
              {
                v101 = json_string_value(v136);
                v141 = json_object_get(json_config, "parameter");
                if ( v141 )
                {
                  type = v141->type;
                  if ( v141->type == JSON_STRING )
                  {
                    param = (char *)json_string_value(v141);
                  }
                  else if ( type == JSON_INTEGER )
                  {
                    v143 = json_integer_value(v141);
                    param = param_buf;
                    sprintf(param_buf, "%d", v143);
                  }
                  else if ( type == JSON_REAL )
                  {
                    json_real_value(v141);
                    param = param_buf;
                    sprintf(param_buf, "%f", v1);
                  }
                  else
                  {
                    param = 0;
                  }
                }
                else
                {
                  param = 0;
                }
                goto LABEL_191;
              }
              message(io_data, 14, 0, 0, 1);
            }
            else
            {
              message(io_data, 24, 0, 0, 1);
            }
          }
          else
          {
            message(io_data, 23, 0, 0, 1);
          }
          send_result((io_data *)io_data->ptr, io_data->close, c, 1);
LABEL_283:
          if ( v93 )
            send_result((io_data *)io_data->ptr, io_data->close, c, v96);
LABEL_215:
          if ( json_config )
            v118 = v96 & 1;
          else
            v118 = 0;
          if ( v118 )
          {
            if ( json_config->type == JSON_OBJECT )
            {
              refcount = json_config->refcount;
              if ( refcount != -1 )
              {
                v133 = refcount - 1;
                json_config->refcount = v133;
                if ( !v133 )
                  json_delete(json_config);
              }
            }
          }
          goto LABEL_220;
        }
        v105 = strchr(buf, 124);
        if ( v105 )
        {
          v96 = v94;
          *v105 = 0;
          param = v105 + 1;
        }
        else
        {
          param = 0;
          v96 = v94;
        }
LABEL_191:
        cmdsbuf = strchr(v101, 43);
        if ( cmdsbuf )
        {
          v93 = 1;
          firstjoin = 1;
          v106 = strlen(v101);
          cmdsbuf = (char *)malloc(v106 + 3);
          if ( !cmdsbuf )
          {
            snprintf(tmp42_14, 0x1000u, "OOM cmdsbuf in %s %s():%d", "api.c", (const char *)&_func___12699, 5520);
            applog(3, tmp42_14, 1);
            quit(1);
          }
          param = 0;
          *(_WORD *)cmdsbuf = 124;
        }
        else
        {
          v93 = v94;
          firstjoin = 0;
        }
        v107 = (char *)v101;
        if ( !v93 )
        {
          v110 = cmds[0].name;
          if ( cmds[0].name )
            goto LABEL_204;
          goto LABEL_237;
        }
        while ( 2 )
        {
          v108 = strchr(v107, 43);
          v101 = v108;
          if ( v108 )
          {
            v101 = v108 + 1;
            *v108 = 0;
          }
          if ( !*v107 )
          {
LABEL_198:
            if ( v101 )
              v109 = v93 & 1;
            else
              v109 = 0;
            v107 = (char *)v101;
            if ( !v109 )
              goto LABEL_283;
            continue;
          }
          break;
        }
        v110 = cmds[0].name;
        if ( cmds[0].name )
        {
LABEL_204:
          v111 = cmds;
          v112 = 0;
          while ( strcmp(v107, v110) )
          {
            v113 = v111[1].name;
            ++v111;
            v110 = v113;
            ++v112;
            if ( !v113 )
            {
              if ( !v93 )
                goto LABEL_237;
              goto LABEL_236;
            }
          }
          sprintf(cmdbuf, "|%s|", v107);
          if ( v93 )
          {
            if ( strstr(cmdsbuf, cmdbuf) )
              goto LABEL_198;
            v114 = strlen(cmdsbuf);
            *(_WORD *)stpcpy(&cmdsbuf[v114], v107) = 124;
            head_join(io_data, v107, v96, &firstjoin);
            v115 = (char **)codes + 3 * v112;
            if ( !*((_BYTE *)v115 + 1081) )
            {
              message(io_data, 45, *((unsigned __int8 *)v115 + 1081), v115[268], v96);
              tail_join(io_data, v96);
              goto inochi;
            }
          }
          v116 = (unsigned __int8)group;
          v117 = (*v29)[(unsigned __int8)group];
          if ( v117 == (*v29)[87] || strstr(apigroups[v117 - (*v29)[65]].commands, cmdbuf) )
          {
            (*((void (__fastcall **)(io_data *, int, char *, int, int))&codes[67].code + 3 * v112))(
              io_data,
              c,
              param,
              v96,
              v116);
          }
          else
          {
            message(io_data, 45, 0, *((char **)&codes[67].severity + 3 * v112), v96);
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(
                tmp42_15,
                0x1000u,
                "API: access denied to '%s' for '%s' command",
                connectaddr,
                *((const char **)&codes[67].severity + 3 * v112));
              applog(7, tmp42_15, 0);
            }
          }
          if ( (unsigned __int8)v93 == 1 )
            goto LABEL_238;
        }
        else
        {
LABEL_236:
          head_join(io_data, v107, v96, &firstjoin);
LABEL_237:
          message(io_data, 14, 0, 0, v96);
          if ( v93 )
          {
LABEL_238:
            tail_join(io_data, v96);
inochi:
            if ( !v93 )
              goto LABEL_215;
            goto LABEL_198;
          }
        }
        send_result((io_data *)io_data->ptr, io_data->close, c, v96);
        goto inochi;
      }
      buf[0] = 0;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        v121 = _errno_location();
        v122 = strerror(*v121);
        snprintf(tmp42_12, 0x1000u, "API: recv failed: %s", v122);
        applog(7, tmp42_12, 0);
      }
    }
LABEL_220:
    close(c);
  }
  if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    v124 = _errno_location();
    v125 = strerror(*v124);
    snprintf(tmp42_10, 0x1000u, "API failed (%s)%s (%d)", v125, " - API will not be available", *apisock);
    applog(3, tmp42_10, 0);
  }
die:
  _pthread_unregister_cancel(&__cancel_buf);
  tidyup(apisock);
  free(apisock);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    if ( do_a_quit )
    {
      v126 = "QUIT";
    }
    else if ( do_a_restart )
    {
      v126 = "RESTART";
    }
    else
    {
      v126 = "UNKNOWN!";
      if ( bye )
        v126 = &_func___12699.__size[20];
    }
    snprintf(tmp42_16, 0x1000u, "API: terminating due to: %s", v126);
    applog(7, tmp42_16, 0);
  }
  if ( pthread_mutex_lock(&quit_restart_lock) )
    mutex_lock_1((pthread_mutex_t *)&_func___12699, (const char *)0x15F3, v127, v128);
  if ( do_a_restart )
  {
    if ( thr_info_create(&bye_thr, 0, restart_thread_0, &bye_thr) )
    {
      if ( !pthread_mutex_unlock(&quit_restart_lock) )
      {
        selective_yield();
        strcpy(tmp42_17, "API failed to initiate a restart - aborting");
        applog(3, tmp42_17, 1);
        quit(1);
      }
      mutex_unlock_noyield_1((pthread_mutex_t *)&_func___12699, (const char *)0x15F9, v139, v140);
    }
  }
  else
  {
    if ( !do_a_quit )
      goto LABEL_277;
    if ( thr_info_create(&bye_thr, (pthread_attr_t *)do_a_restart, quit_thread, &bye_thr) )
    {
      if ( pthread_mutex_unlock(&quit_restart_lock) )
        mutex_unlock_noyield_1((pthread_mutex_t *)&_func___12699, (const char *)0x1602, v137, v138);
      selective_yield();
      strcpy(tmp42_18, "API failed to initiate a clean quit - aborting");
      applog(3, tmp42_18, 1);
      quit(1);
    }
  }
  pthread_detach(bye_thr.pth);
LABEL_277:
  if ( pthread_mutex_unlock(&quit_restart_lock) )
    mutex_unlock_noyield_1((pthread_mutex_t *)&_func___12699, (const char *)0x1608, v129, v130);
  selective_yield();
}
// 31AC2: conditional instruction was optimized away because r7.4 is in (1..FF)
// 322D0: variable 'v137' is possibly undefined
// 322D0: variable 'v138' is possibly undefined
// 32386: variable 'v127' is possibly undefined
// 32386: variable 'v128' is possibly undefined
// 32392: variable 'v139' is possibly undefined
// 32392: variable 'v140' is possibly undefined
// 323E4: variable 'v1' is possibly undefined
// 32426: variable 'v129' is possibly undefined
// 32426: variable 'v130' is possibly undefined
// 120CC: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);
// 4F67C: using guessed type __int16 word_4F67C;
// 59398: using guessed type char byte_59398;

//----- (00032430) --------------------------------------------------------
void __fastcall applog(int prio, const char *str, bool force)
{
  _BOOL4 v5; // r8
  struct tm *v6; // r0
  int v7; // r0
  FILE *v8; // r7
  size_t v9; // r0
  size_t v10; // r0
  time_t tmp_time; // [sp+1Ch] [bp-50h] BYREF
  timeval tv; // [sp+20h] [bp-4Ch] BYREF
  char datetime[64]; // [sp+28h] [bp-44h] BYREF

  if ( use_syslog )
  {
    syslog(prio | 0x80, "%s", str);
    return;
  }
  v5 = force;
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  cgtime(&tv);
  tmp_time = tv.tv_sec;
  v6 = localtime(&tmp_time);
  snprintf(
    datetime,
    0x40u,
    " [%d-%02d-%02d %02d:%02d:%02d] ",
    v6->tm_year + 1900,
    v6->tm_mon + 1,
    v6->tm_mday,
    v6->tm_hour,
    v6->tm_min,
    v6->tm_sec);
  v7 = fileno((FILE *)stderr);
  if ( isatty(v7) )
  {
    if ( g_logfile_enable )
    {
LABEL_4:
      v8 = g_log_file;
      if ( g_log_file || (v8 = fopen(g_logfile_path, g_logfile_openflag), (g_log_file = v8) != 0) )
      {
        v9 = strlen(datetime);
        fwrite(datetime, v9, 1u, v8);
        v10 = strlen(str);
        fwrite(str, v10, 1u, g_log_file);
        fwrite(&word_58FE4, 1u, 1u, g_log_file);
        fflush(g_log_file);
      }
    }
  }
  else
  {
    fprintf((FILE *)stderr, "%s%s\n", datetime, str);
    fflush((FILE *)stderr);
    if ( g_logfile_enable )
      goto LABEL_4;
  }
  if ( prio == 3 || !opt_quiet )
    my_log_curses((pthread_mutex_t *)datetime, str, (const char *)v5, opt_quiet);
}
// 58FE4: using guessed type __int16 word_58FE4;
// 6D848: using guessed type int stderr;

//----- (00032574) --------------------------------------------------------
// Alternative name is '_mutex_unlock_noyield.constprop.3'
void __fastcall mutex_unlock_noyield_2(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v5; // r0
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( pthread_mutex_unlock(&console_lock) )
  {
    v5 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v5,
      "logging.c",
      "my_log_curses",
      lock);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (000325DC) --------------------------------------------------------
// Alternative name is '_mutex_lock.constprop.4'
void __fastcall mutex_lock_2(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v4; // r0
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( pthread_mutex_lock(&console_lock) )
  {
    v4 = _errno_location();
    snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v4, "logging.c", "my_log_curses", 47);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00032644) --------------------------------------------------------
// Alternative name is 'my_log_curses.part.2'
void __fastcall my_log_curses(pthread_mutex_t *prio, const char *datetime, const char *str, bool force)
{
  pthread_mutex_t *v4; // r5
  const char *v6; // r1
  const char *v7; // r2
  int v8; // r3
  const char *v9; // r1
  const char *v10; // r2
  int v11; // r3

  v4 = prio;
  if ( str )
  {
    pthread_mutex_trylock(&console_lock);
    mutex_unlock_noyield_2((pthread_mutex_t *)0x26, v9, v10, v11);
    prio = (pthread_mutex_t *)selective_yield();
  }
  mutex_lock_2(prio, datetime, str, force);
  printf("%s%s%s", (const char *)v4, datetime, "                    \n");
  mutex_unlock_noyield_2((pthread_mutex_t *)0x31, v6, v7, v8);
  selective_yield();
}
// 32694: variable 'v9' is possibly undefined
// 32694: variable 'v10' is possibly undefined
// 32694: variable 'v11' is possibly undefined
// 32654: variable 'datetime' is possibly undefined
// 32654: variable 'str' is possibly undefined
// 32654: variable 'force' is possibly undefined
// 32672: variable 'v6' is possibly undefined
// 32672: variable 'v7' is possibly undefined
// 32672: variable 'v8' is possibly undefined

//----- (000326A0) --------------------------------------------------------
void __fastcall simplelog(int prio, const char *str, bool force)
{
  _BOOL4 v5; // r7
  int v6; // r0
  bool v8; // [sp+0h] [bp-4h]

  if ( use_syslog )
  {
    j_syslog(prio | 0x80, "%s", str);
  }
  else
  {
    v5 = force;
    v6 = fileno((FILE *)stderr);
    if ( !isatty(v6) )
    {
      fprintf((FILE *)stderr, "%s\n", str);
      fflush((FILE *)stderr);
    }
    if ( prio == 3 || !opt_quiet )
      my_log_curses((pthread_mutex_t *)&byte_59398, str, (const char *)v5, v8);
  }
}
// 326EE: variable 'v8' is possibly undefined
// 59398: using guessed type char byte_59398;
// 6D848: using guessed type int stderr;

//----- (00032720) --------------------------------------------------------
void __fastcall k_alloc_items(K_LIST *list, const char *file, const char *func, const int line)
{
  int limit; // r3
  int total; // r2
  int allocate; // r6
  void **item_memory; // r0
  __int64 v9; // kr00_8
  void **v10; // r0
  k_item *v11; // r5
  int v12; // r3
  const char *name; // r1
  __int64 v14; // r2
  _BOOL4 do_tail; // r2
  int v16; // r6
  k_item *v17; // r3
  k_item *v18; // r6
  void **data_memory; // r0
  int v20; // r1
  void **v21; // r0
  void *v22; // r0
  char tmp42[4096]; // [sp+20h] [bp-1000h] BYREF

  if ( list->is_store )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s store can't %s() - from %s %s() line %d in %s %s():%d",
      list->name,
      "k_alloc_items",
      file,
      func,
      line,
      "klist.c",
      "k_alloc_items",
      19);
    applog(3, tmp42, 1);
    quit(1);
  }
  limit = list->limit;
  if ( limit <= 0 )
  {
    allocate = list->allocate;
  }
  else
  {
    total = list->total;
    if ( limit <= total )
      return;
    allocate = list->allocate;
    if ( limit < total + allocate )
      allocate = limit - total;
  }
  v9 = *(_QWORD *)&list->item_mem_count;
  item_memory = list->item_memory;
  list->item_mem_count = v9 + 1;
  v10 = (void **)realloc(item_memory, 4 * (v9 + 1));
  list->item_memory = v10;
  if ( !v10 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s item_memory failed to realloc count=%d in %s %s():%d",
      list->name,
      list->item_mem_count,
      "klist.c",
      "k_alloc_items",
      33);
    applog(3, tmp42, 1);
    quit(1);
  }
  v11 = (k_item *)calloc(allocate, 0x10u);
  if ( !v11 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s failed to calloc %d new items - total was %d, limit was %d in %s %s():%d",
      list->name,
      allocate,
      list->total,
      list->limit,
      "klist.c",
      "k_alloc_items",
      38);
    applog(3, tmp42, 1);
    quit(1);
  }
  DWORD1073741823(list->item_memory[list->item_mem_count]) = v11;
  v12 = list->total;
  name = list->name;
  list->count = allocate;
  list->count_up = allocate;
  list->total = v12 + allocate;
  v11->name = name;
  v11->prev = 0;
  v11->next = v11 + 1;
  if ( allocate > 2 )
  {
    HIDWORD(v14) = v11 + 2;
    do
    {
      LODWORD(v14) = HIDWORD(v14) - 32;
      *(_DWORD *)(HIDWORD(v14) - 16) = name;
      *(_QWORD *)(HIDWORD(v14) - 12) = v14;
      HIDWORD(v14) += 16;
    }
    while ( (k_item *)HIDWORD(v14) != &v11[allocate] );
  }
  do_tail = list->do_tail;
  v16 = allocate + 0xFFFFFFF;
  list->head = v11;
  v11[v16].name = name;
  v17 = &v11[v16 - 1];
  v18 = &v11[v16];
  v18->prev = v17;
  v18->next = 0;
  if ( do_tail )
    list->tail = v18;
  do
  {
    data_memory = list->data_memory;
    v20 = list->data_mem_count + 1;
    list->data_mem_count = v20;
    v21 = (void **)realloc(data_memory, 4 * v20);
    list->data_memory = v21;
    if ( !v21 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "List %s data_memory failed to realloc count=%d in %s %s():%d",
        list->name,
        list->data_mem_count,
        "klist.c",
        "k_alloc_items",
        69);
      applog(3, tmp42, 1);
      quit(1);
    }
    v22 = calloc(1u, list->siz);
    v11->data = v22;
    if ( !v22 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "List %s failed to calloc item data in %s %s():%d",
        list->name,
        "klist.c",
        "k_alloc_items",
        73);
      applog(3, tmp42, 1);
      quit(1);
    }
    DWORD1073741823(list->data_memory[list->data_mem_count]) = v22;
    v11 = v11->next;
  }
  while ( v11 );
}

//----- (0003296C) --------------------------------------------------------
K_LIST *__fastcall k_new_store(K_LIST *list)
{
  K_LIST *result; // r0
  const char *name; // r3
  cglock_t *lock; // r6
  bool do_tail; // r1
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  result = (K_LIST *)calloc(1u, 0x40u);
  name = list->name;
  if ( !result )
  {
    snprintf(tmp42, 0x1000u, "Failed to calloc store for %s in %s %s():%d", name, "klist.c", "k_new_store", 85);
    applog(3, tmp42, 1);
    quit(1);
  }
  lock = list->lock;
  do_tail = list->do_tail;
  result->name = name;
  result->lock = lock;
  result->do_tail = do_tail;
  result->is_store = 1;
  return result;
}

//----- (000329DC) --------------------------------------------------------
K_LIST *__fastcall k_new_list(
        const char *name,
        size_t siz,
        int allocate,
        int limit,
        bool do_tail,
        const char *file,
        const char *func,
        const int line)
{
  K_LIST *v12; // r0
  K_LIST *v13; // r4
  pthread_mutex_t *v14; // r0
  pthread_mutex_t *v15; // r5
  int *v17; // r0
  int *v18; // r0
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( allocate <= 0 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "Invalid new list %s with allocate %d must be > 0 in %s %s():%d",
      name,
      allocate,
      "klist.c",
      "_k_new_list",
      100);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( limit < 0 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "Invalid new list %s with limit %d must be >= 0 in %s %s():%d",
      name,
      limit,
      "klist.c",
      "_k_new_list",
      103);
    applog(3, tmp42, 1);
    quit(1);
  }
  v12 = (K_LIST *)calloc(1u, 0x40u);
  v13 = v12;
  if ( !v12 )
  {
    snprintf(tmp42, 0x1000u, "Failed to calloc list %s in %s %s():%d", name, "klist.c", "_k_new_list", 107);
    applog(3, tmp42, 1);
    quit(1);
  }
  v12->is_store = 0;
  v14 = (pthread_mutex_t *)calloc(1u, 0x38u);
  v15 = v14;
  v13->lock = (cglock_t *)v14;
  if ( !v14 )
  {
    snprintf(tmp42, 0x1000u, "Failed to calloc lock for list %s in %s %s():%d", name, "klist.c", "_k_new_list", 113);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_init(v14, 0) )
  {
    v17 = _errno_location();
    snprintf(tmp42, 0x1000u, "Failed to pthread_mutex_init errno=%d in %s %s():%d", *v17, "klist.c", "_k_new_list", 115);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( pthread_rwlock_init((pthread_rwlock_t *)&v15[1], 0) )
  {
    v18 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v18,
      "klist.c",
      "_k_new_list",
      115);
    applog(3, tmp42, 1);
    quit(1);
  }
  v13->name = name;
  v13->siz = siz;
  v13->allocate = allocate;
  v13->limit = limit;
  v13->do_tail = do_tail;
  k_alloc_items(v13, file, func, line);
  return v13;
}

//----- (00032C14) --------------------------------------------------------
K_ITEM *__fastcall k_unlink_head(K_LIST *list, const char *file, const char *func, const int line)
{
  k_item *head; // r4
  k_item *next; // r3

  head = list->head;
  if ( !head )
  {
    if ( list->is_store )
      return 0;
    k_alloc_items(list, file, func, line);
    head = list->head;
    if ( !head )
      return 0;
  }
  next = head->next;
  list->head = next;
  if ( next )
  {
    next->prev = 0;
  }
  else if ( list->do_tail )
  {
    list->tail = 0;
  }
  head->prev = 0;
  head->next = 0;
  --list->count;
  return head;
}

//----- (00032C58) --------------------------------------------------------
K_ITEM *__fastcall k_unlink_head_zero(K_LIST *list, const char *file, const char *func, const int line)
{
  K_ITEM *v5; // r0
  K_ITEM *v6; // r4

  v5 = k_unlink_head(list, file, func, line);
  v6 = v5;
  if ( v5 )
    memset(v5->data, 0, list->siz);
  return v6;
}

//----- (00032C74) --------------------------------------------------------
K_ITEM *__fastcall k_unlink_tail(K_LIST *list, const char *file, const char *func, const int line)
{
  K_ITEM *result; // r0
  k_item *prev; // r3
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( !list->do_tail )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_unlink_tail",
      file,
      func,
      line,
      "klist.c",
      "_k_unlink_tail",
      181);
    applog(3, tmp42, 1);
    quit(1);
  }
  result = list->tail;
  if ( result )
  {
    prev = result->prev;
    list->tail = prev;
    if ( prev )
      prev->next = 0;
    else
      list->head = 0;
    result->prev = 0;
    result->next = 0;
    --list->count;
  }
  return result;
}

//----- (00032CF0) --------------------------------------------------------
void __fastcall k_add_head(K_LIST *list, K_ITEM *item, const char *file, const char *func, const int line)
{
  k_item *head; // r3
  _BOOL4 do_tail; // r3
  __int64 v7; // r2
  char tmp42[4096]; // [sp+20h] [bp-1004h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_add_head",
      item->name,
      file,
      func,
      line,
      "klist.c",
      "_k_add_head",
      205);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = 0;
  item->next = list->head;
  head = list->head;
  if ( head )
    head->prev = item;
  do_tail = list->do_tail;
  list->head = item;
  if ( do_tail && !list->tail )
    list->tail = item;
  v7 = *(_QWORD *)&list->count;
  LODWORD(v7) = v7 + 1;
  ++HIDWORD(v7);
  *(_QWORD *)&list->count = v7;
}

//----- (00032D8C) --------------------------------------------------------
void __fastcall k_add_tail(K_LIST *list, K_ITEM *item, const char *file, const char *func, const int line)
{
  const char *name; // r1
  k_item *tail; // r3
  k_item *head; // r3
  __int64 v9; // r2
  char tmp42[4096]; // [sp+20h] [bp-1004h] BYREF

  name = item->name;
  if ( name != list->name )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_add_tail",
      name,
      file,
      func,
      line,
      "klist.c",
      "_k_add_tail",
      236);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !list->do_tail )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_add_tail",
      file,
      func,
      line,
      "klist.c",
      "_k_add_tail",
      241);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = list->tail;
  item->next = 0;
  tail = list->tail;
  if ( tail )
    tail->next = item;
  head = list->head;
  list->tail = item;
  if ( !head )
    list->head = item;
  v9 = *(_QWORD *)&list->count;
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)&list->count = v9;
}

//----- (00032E74) --------------------------------------------------------
void __fastcall k_insert_before(
        K_LIST *list,
        K_ITEM *item,
        K_ITEM *before,
        const char *file,
        const char *func,
        const int line)
{
  const char *name; // r1
  k_item *prev; // r3
  __int64 v9; // r2
  char tmp42[4096]; // [sp+20h] [bp-1004h] BYREF

  name = item->name;
  if ( name != list->name )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_insert_before",
      name,
      file,
      func,
      line,
      "klist.c",
      "_k_insert_before",
      262);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !before )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s() (%s) can't before a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_before",
      list->name,
      file,
      func,
      line,
      "klist.c",
      "_k_insert_before",
      267);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->next = before;
  item->prev = before->prev;
  prev = before->prev;
  if ( prev )
    prev->next = item;
  else
    list->head = item;
  before->prev = item;
  v9 = *(_QWORD *)&list->count;
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)&list->count = v9;
}

//----- (00032F68) --------------------------------------------------------
void __fastcall k_insert_after(
        K_LIST *list,
        K_ITEM *item,
        K_ITEM *after,
        const char *file,
        const char *func,
        const int line)
{
  const char *name; // r1
  k_item *next; // r3
  __int64 v9; // r2
  char tmp42[4096]; // [sp+20h] [bp-1004h] BYREF

  name = item->name;
  if ( name != list->name )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_insert_after",
      name,
      file,
      func,
      line,
      "klist.c",
      "_k_insert_after",
      286);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !after )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s() (%s) can't after a null item - from %s %s() line %d in %s %s():%d",
      "_k_insert_after",
      list->name,
      file,
      func,
      line,
      "klist.c",
      "_k_insert_after",
      291);
    applog(3, tmp42, 1);
    quit(1);
  }
  item->prev = after;
  item->next = after->next;
  next = after->next;
  if ( next )
  {
    next->prev = item;
  }
  else if ( list->do_tail )
  {
    list->tail = item;
  }
  after->next = item;
  v9 = *(_QWORD *)&list->count;
  LODWORD(v9) = v9 + 1;
  ++HIDWORD(v9);
  *(_QWORD *)&list->count = v9;
}

//----- (00033064) --------------------------------------------------------
void __fastcall k_unlink_item(K_LIST *list, K_ITEM *item, const char *file, const char *func, const int line)
{
  __int64 v5; // r2
  char tmp42[4096]; // [sp+20h] [bp-1004h] BYREF

  if ( item->name != list->name )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() a %s item - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_unlink_item",
      item->name,
      file,
      func,
      line,
      "klist.c",
      "_k_unlink_item",
      312);
    applog(3, tmp42, 1);
    quit(1);
  }
  v5 = *(_QWORD *)&item->prev;
  if ( (_DWORD)v5 )
  {
    *(_DWORD *)(v5 + 8) = HIDWORD(v5);
    HIDWORD(v5) = item->next;
  }
  if ( HIDWORD(v5) )
    *(_DWORD *)(HIDWORD(v5) + 4) = item->prev;
  if ( list->head == item )
    list->head = item->next;
  if ( list->do_tail && list->tail == item )
    list->tail = item->prev;
  item->prev = 0;
  item->next = 0;
  --list->count;
}

//----- (0003310C) --------------------------------------------------------
void __fastcall k_list_transfer_to_head(K_LIST *from, K_LIST *to, const char *file, const char *func, const int line)
{
  const char *name; // r0
  const char *v8; // r1
  k_item *head; // r2
  k_item *tail; // r3
  int count; // r1
  char tmp42[4096]; // [sp+20h] [bp-1000h] BYREF

  name = from->name;
  v8 = to->name;
  if ( name != v8 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      name,
      "_k_list_transfer_to_head",
      v8,
      file,
      func,
      line,
      "klist.c",
      "_k_list_transfer_to_head",
      338);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !from->do_tail )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      from->name,
      "_k_list_transfer_to_head",
      file,
      func,
      line,
      "klist.c",
      "_k_list_transfer_to_head",
      343);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( from->head )
  {
    head = to->head;
    tail = from->tail;
    if ( head )
    {
      head->prev = tail;
      head = to->head;
    }
    else
    {
      to->tail = tail;
    }
    from->tail->next = head;
    to->head = from->head;
    from->tail = 0;
    count = from->count;
    from->head = 0;
    to->count += count;
    from->count = 0;
    to->count_up += from->count_up;
    from->count_up = 0;
  }
}

//----- (00033208) --------------------------------------------------------
void __fastcall k_list_transfer_to_tail(K_LIST *from, K_LIST *to, const char *file, const char *func, const int line)
{
  const char *name; // r0
  const char *v8; // r1
  k_item *head; // r3
  k_item *tail; // r2
  int count; // r1
  char tmp42[4096]; // [sp+20h] [bp-1000h] BYREF

  name = from->name;
  v8 = to->name;
  if ( name != v8 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() to a %s list - from %s %s() line %d in %s %s():%d",
      name,
      "_k_list_transfer_to_tail",
      v8,
      file,
      func,
      line,
      "klist.c",
      "_k_list_transfer_to_tail",
      368);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( !from->do_tail )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() - do_tail is false - from %s %s() line %d in %s %s():%d",
      from->name,
      "_k_list_transfer_to_tail",
      file,
      func,
      line,
      "klist.c",
      "_k_list_transfer_to_tail",
      373);
    applog(3, tmp42, 1);
    quit(1);
  }
  head = from->head;
  if ( head )
  {
    tail = to->tail;
    if ( tail )
    {
      tail->next = head;
      tail = to->tail;
    }
    else
    {
      to->head = head;
    }
    from->head->prev = tail;
    to->tail = from->tail;
    from->tail = 0;
    count = from->count;
    from->head = 0;
    to->count += count;
    from->count = 0;
    to->count_up += from->count_up;
    from->count_up = 0;
  }
}

//----- (00033304) --------------------------------------------------------
K_LIST *__fastcall k_free_list(K_LIST *list, const char *file, const char *func, const int line)
{
  int v5; // r5
  void *v6; // r0
  int v7; // r5
  void *v8; // r0
  cglock_t *lock; // r5
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( list->is_store )
  {
    snprintf(
      tmp42,
      0x1000u,
      "List %s can't %s() a store - from %s %s() line %d in %s %s():%d",
      list->name,
      "_k_free_list",
      file,
      func,
      line,
      "klist.c",
      "_k_free_list",
      400);
    applog(3, tmp42, 1);
    quit(1);
  }
  if ( list->item_mem_count > 0 )
  {
    v5 = 0;
    do
    {
      v6 = list->item_memory[v5++];
      free(v6);
    }
    while ( list->item_mem_count > v5 );
  }
  free(list->item_memory);
  if ( list->data_mem_count > 0 )
  {
    v7 = 0;
    do
    {
      v8 = list->data_memory[v7++];
      free(v8);
    }
    while ( list->data_mem_count > v7 );
  }
  free(list->data_memory);
  lock = list->lock;
  pthread_rwlock_destroy(&lock->rwlock);
  pthread_mutex_destroy(&lock->mutex);
  free(list->lock);
  free(list);
  return 0;
}

//----- (000333C0) --------------------------------------------------------
K_LIST *__fastcall k_free_store(K_LIST *store, const char *file, const char *func, const int line)
{
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( !store->is_store )
  {
    snprintf(
      tmp42,
      0x1000u,
      "Store %s can't %s() the list - from %s %s() line %d in %s %s():%d",
      store->name,
      "_k_free_store",
      file,
      func,
      line,
      "klist.c",
      "_k_free_store",
      424);
    applog(3, tmp42, 1);
    quit(1);
  }
  free(store);
  return 0;
}

//----- (00033424) --------------------------------------------------------
void __fastcall dupalloc(cgpu_info *cgpu, int timelimit)
{
  _DWORD *v4; // r4
  K_LIST *v5; // r0
  K_LIST *v6; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v4 = calloc(1u, 0x20u);
  if ( !v4 )
  {
    snprintf(tmp42, 0x1000u, "Failed to calloc dupdata in %s %s():%d", "noncedup.c", "dupalloc", 36);
    applog(3, tmp42, 1);
    quit(1);
  }
  *v4 = timelimit;
  v5 = k_new_list("Nonces", 0x10u, 1024, 0, 1, "noncedup.c", "dupalloc", 39);
  v4[1] = v5;
  v6 = k_new_store(v5);
  cgpu->dup_data = v4;
  v4[2] = v6;
}

//----- (000334B4) --------------------------------------------------------
void __fastcall dupcounters(cgpu_info *cgpu, uint64_t *checked, uint64_t *dups)
{
  _QWORD *dup_data; // r3

  dup_data = cgpu->dup_data;
  if ( dup_data )
  {
    *checked = dup_data[2];
    *dups = dup_data[3];
  }
  else
  {
    *checked = 0;
    *dups = 0;
  }
}

//----- (000334E4) --------------------------------------------------------
bool __fastcall isdupnonce(cgpu_info *cgpu, work *work, uint32_t nonce)
{
  double v3; // d0
  void *dup_data; // r4
  _BOOL4 v5; // r6
  int v8; // r1
  int v9; // r5
  int v10; // r5
  _BOOL4 v11; // r7
  _DWORD *v12; // r3
  int i; // r3
  K_ITEM *v14; // r0
  int v15; // r5
  K_ITEM *v17; // r5
  _DWORD *data; // lr
  __time_t tv_sec; // r0
  int *v20; // r0
  int *v21; // r0
  int *v22; // r0
  int *v23; // r0
  timeval now; // [sp+18h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  dup_data = cgpu->dup_data;
  LOBYTE(v5) = (_BYTE)dup_data;
  if ( dup_data )
  {
    cgtime(&now);
    v8 = *((_DWORD *)dup_data + 1);
    ++*((_QWORD *)dup_data + 2);
    v9 = *(_DWORD *)(v8 + 8);
    if ( pthread_mutex_lock((pthread_mutex_t *)v9) )
    {
      v20 = _errno_location();
      snprintf(tmp42, 0x1000u, "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d", *v20, "noncedup.c", "isdupnonce", 70);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_rwlock_wrlock((pthread_rwlock_t *)(v9 + 24)) )
    {
      v21 = _errno_location();
      snprintf(tmp42, 0x1000u, "WTF WRLOCK ERROR ON LOCK! errno=%d in %s %s():%d", *v21, "noncedup.c", "isdupnonce", 70);
      applog(3, tmp42, 1);
      quit(1);
    }
    v10 = *(_DWORD *)(*((_DWORD *)dup_data + 2) + 16);
    v11 = 1;
    while ( 1 )
    {
      v5 = v10 && v11;
      if ( !v5 )
        break;
      while ( 1 )
      {
        v12 = *(_DWORD **)(v10 + 12);
        v11 = v5;
        if ( *v12 == work->id && v12[1] == nonce )
          break;
        v10 = *(_DWORD *)(v10 + 4);
        if ( !v10 )
          v5 = 0;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( !use_syslog )
      {
        v11 = opt_log_output;
        if ( !opt_log_output && opt_log_level <= 3 )
          continue;
      }
      v11 = 0;
      snprintf(tmp42, 0x1000u, "%s%d: Duplicate nonce %08x", cgpu->drv->name, cgpu->device_id, nonce);
      applog(4, tmp42, 0);
    }
LABEL_13:
    if ( v11 )
    {
      v17 = k_unlink_head(*((K_LIST **)dup_data + 1), "noncedup.c", "isdupnonce", 81);
      *(_DWORD *)v17->data = work->id;
      *((_DWORD *)v17->data + 1) = nonce;
      data = v17->data;
      tv_sec = now.tv_sec;
      data[3] = now.tv_usec;
      data[2] = tv_sec;
      k_add_head(*((K_LIST **)dup_data + 2), v17, "noncedup.c", "isdupnonce", 85);
    }
    for ( i = *(_DWORD *)(*((_DWORD *)dup_data + 2) + 16); i; i = *(_DWORD *)(*((_DWORD *)dup_data + 2) + 16) )
    {
      tdiff((timeval *)(*(_DWORD *)(i + 12) + 8), &now);
      if ( v3 <= (double)*(int *)dup_data )
        break;
      v14 = k_unlink_tail(*((K_LIST **)dup_data + 2), "noncedup.c", "isdupnonce", 89);
      k_add_head(*((K_LIST **)dup_data + 1), v14, "noncedup.c", "isdupnonce", 90);
    }
    v15 = *(_DWORD *)(*((_DWORD *)dup_data + 1) + 8);
    if ( pthread_rwlock_unlock((pthread_rwlock_t *)(v15 + 24)) )
    {
      v23 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v23,
        "noncedup.c",
        "isdupnonce",
        93);
      applog(3, tmp42, 1);
      quit(1);
    }
    if ( pthread_mutex_unlock((pthread_mutex_t *)v15) )
    {
      v22 = _errno_location();
      snprintf(
        tmp42,
        0x1000u,
        "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
        *v22,
        "noncedup.c",
        "isdupnonce",
        93);
      applog(3, tmp42, 1);
      quit(1);
    }
    selective_yield();
    if ( !v11 )
    {
      LOBYTE(v5) = 1;
      ++*((_QWORD *)dup_data + 3);
    }
  }
  return v5;
}
// 33572: masking with 0x1 was optimized away because r6.4 <= 0x1
// 335D2: variable 'v3' is possibly undefined

//----- (000337B0) --------------------------------------------------------
unsigned __int16 __fastcall crc16(const unsigned __int8 *buffer, int len)
{
  const unsigned __int8 *v2; // r1
  unsigned int v3; // r3
  int v4; // t1

  if ( len <= 0 )
    return 0;
  v2 = &buffer[len];
  v3 = 0;
  do
  {
    v4 = *buffer++;
    v3 = LOWORD(crc16_table[v4 ^ (v3 >> 8)]) ^ (unsigned __int16)((_WORD)v3 << 8);
  }
  while ( buffer != v2 );
  return v3;
}

//----- (000337EC) --------------------------------------------------------
void reset_all_hash_board_low()
{
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s %d", "reset_all_hash_board_low", 4392);
    applog(5, tmp42, 0);
  }
  axi_fpga_addr[13] = 0xFFFF;
}

//----- (00033860) --------------------------------------------------------
void __fastcall bitmain_ZCASH_update(cgpu_info *bitmain)
{
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "Updated Work!");
    applog(7, tmp42, 0);
  }
  new_block[0] = 1;
  new_block[1] = 1;
  new_block[2] = 1;
  new_block[3] = 1;
}

//----- (000338CC) --------------------------------------------------------
int64_t __fastcall bitmain_ZCASH_scanhash(thr_info *thr)
{
  pthread_t send_id; // [sp+4h] [bp-4h] BYREF

  h = 0;
  pthread_create(&send_id, 0, bitmain_scanhash, thr);
  pthread_join(send_id, 0);
  return h;
}

//----- (00033904) --------------------------------------------------------
api_data *__fastcall bitmain_api_stats(cgpu_info *cgpu)
{
  uint32_t *v1; // r5
  api_data *v2; // r0
  api_data *v3; // r0
  int v4; // r4
  api_data *v5; // r6
  api_data *v6; // r0
  api_data *v7; // r5
  int i; // r4
  int v9; // r4
  api_data *v10; // r0
  api_data *v11; // r4
  int64_t v12; // r0
  int32x2_t v13; // d8
  double v14; // d7
  api_data *v15; // r0
  int v16; // r5
  api_data *v17; // r4
  char *v18; // r6
  int v19; // r5
  api_data *v20; // r0
  int j; // r5
  int k; // r6
  int v23; // r2
  char *v24; // r6
  int v25; // r5
  api_data *result; // r0
  double rateideal; // [sp+10h] [bp-101Ch] BYREF
  char chain_freq[16]; // [sp+18h] [bp-1014h] BYREF
  char chain_rate[4100]; // [sp+28h] [bp-1004h] BYREF

  rateideal = 320000.0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(chain_rate, 0x1000u, "rateideal = %f\n", rateideal);
    applog(5, chain_rate, 0);
  }
  v1 = (_DWORD *)(&dev + 489);
  v2 = api_add_mhs(0, "total_rateideal", &rateideal, 0);
  v3 = api_add_uint8(v2, "miner_count", &dev.chain_num, 0);
  v4 = 0;
  v5 = api_add_uint8(v3, "fan_num", &dev.fan_num, 0);
  do
  {
    sprintf(chain_rate, "fan%d", ++v4);
    v6 = api_add_uint32(v5, chain_rate, v1++, 0);
    v5 = v6;
  }
  while ( v4 != 6 );
  v7 = api_add_uint8(v6, "temp_num", &dev.chain_num, 0);
  for ( i = 0; i != 4; v7 = api_add_int16(v7, chain_rate, &dev.pfd[5].events + 2 * i, 0) )
    sprintf(chain_rate, "temp%d", ++i);
  v9 = 0;
  do
  {
    sprintf(chain_rate, "temp2_%d", ++v9);
    v10 = api_add_int16(v7, chain_rate, (int16_t *)&dev.max_local_temp[v9 + 3], 0);
    v7 = v10;
  }
  while ( v9 != 4 );
  v11 = api_add_uint32(v10, "temp_max", (uint32_t *)&dev.temp_top1, 0);
  total_diff1 = (__int64)(total_diff_accepted + total_diff_rejected + total_diff_stale);
  v12 = total_diff1 + hw_errors;
  if ( v12 )
  {
    v13.n64_u32[0] = hw_errors;
    v13.n64_u32[1] = hw_errors;
    v14 = vcvt_n_f64_s32(v13, 8u) / (double)v12;
  }
  else
  {
    v14 = 0.0;
  }
  hwp = v14;
  v15 = api_add_percent(v11, "Device Hardware%", &hwp, 1);
  v16 = 0;
  v17 = api_add_int(v15, "no_matching_work", &hw_errors, 1);
  do
  {
    sprintf(chain_rate, "chain_acn%d", ++v16);
    v17 = api_add_uint8(v17, chain_rate, (uint8_t *)&dev.temp[3] + v16 + 3, 0);
  }
  while ( v16 != 4 );
  v18 = (_BYTE *)(&dev + 355);
  v19 = 0;
  do
  {
    sprintf(chain_rate, "chain_acs%d", ++v19);
    v20 = api_add_string(v17, chain_rate, v18, 0);
    v18 += 19;
    v17 = v20;
  }
  while ( v19 != 4 );
  for ( j = 0; j != 4; v17 = api_add_uint32(v17, chain_rate, (uint32_t *)&dev.whether_read_out_temp[j + 3][3], 0) )
    sprintf(chain_rate, "chain_hw%d", ++j);
  for ( k = 0; k != 4; v17 = api_add_uint16(v17, chain_freq, (uint16_t *)&dev.frequency_t[2 * k + 8], 0) )
  {
    memset(chain_freq, 0, sizeof(chain_freq));
    memset(chain_rate, 0, 16);
    sprintf(chain_freq, "frequency%d", k + 1);
    v23 = dev.freq[k++];
    sprintf(chain_rate, "%u", v23);
  }
  v24 = displayed_rate;
  v25 = 0;
  do
  {
    sprintf(chain_rate, "chain_rate%d", ++v25);
    if ( certification_firmware )
      sprintf(v24, "%2.2f", rt_hashrate_total / (double)rt_chain_num);
    result = api_add_string(v17, chain_rate, v24, 0);
    v24 += 16;
    v17 = result;
  }
  while ( v25 != 4 );
  return result;
}

//----- (00033C90) --------------------------------------------------------
void __fastcall bitmain_ZCASH_reinit_device(cgpu_info *bitmain)
{
  if ( !status_error )
    j_system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
}

//----- (00033CAC) --------------------------------------------------------
void bitmain_ZCASH_detect()
{
  cgpu_info *v0; // r0
  cgpu_info *v1; // r4
  void *v2; // r0
  char v3[4100]; // [sp+0h] [bp-1004h] BYREF

  v0 = (cgpu_info *)calloc(1u, 0x188u);
  if ( !v0 )
    _assert_fail("cgpu", "driver-btm-zcash.c", 0x1D65u, "bitmain_ZCASH_detect");
  v1 = v0;
  v0->drv = &bitmainZCASH_drv;
  v0->deven = dev_enable::DEV_ENABLED;
  v0->threads = 1;
  v2 = calloc(0x4B4u, 1u);
  v1->device_data = v2;
  if ( !v2 )
  {
    strcpy(v3, "Failed to calloc cgpu_info data");
    applog(3, v3, 1);
    quit(1);
  }
  if ( !add_cgpu(v1) )
    _assert_fail("add_cgpu(cgpu)", "driver-btm-zcash.c", 0x1D6Du, "bitmain_ZCASH_detect");
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(v3, 0x1000u, "%s detect new device", "bitmain_ZCASH_detect");
    applog(7, v3, 0);
  }
}

//----- (00033DB0) --------------------------------------------------------
void *__fastcall __noreturn check_fan_thr(void *arg)
{
  int v1; // r6
  int v2; // r10
  int v3; // r3
  uint32_t v4; // r1
  char *v5; // r3
  uint8_t fan_num; // r0
  uint32_t fan_speed_low1; // r3
  uint32_t fan_exist_map; // r2
  uint8_t v9; // r12
  bool v10; // cf
  unsigned int v11; // [sp+4h] [bp-4h]

  while ( 1 )
  {
    v1 = 2;
    dev.fan_speed_top1 = 0;
    dev.fan_speed_low1 = 0;
    while ( 1 )
    {
      v2 = 6;
      do
      {
        v11 = axi_fpga_addr[1];
        if ( v11 == -1 )
          goto LABEL_10;
        v3 = (v11 >> 8) & 7;
        v4 = 120 * (unsigned __int8)v11;
        dev.fan_speed_value[v3] = v4;
        if ( !(_BYTE)v11 )
        {
          v5 = (char *)&dev + v3;
          if ( v5[459] == 1 )
          {
            fan_num = dev.fan_num;
            v5[459] = 0;
            dev.fan_exist_map = 0;
            dev.fan_num = fan_num - 1;
          }
          fan_speed_low1 = dev.fan_speed_low1;
LABEL_8:
          if ( fan_speed_low1 )
            goto LABEL_10;
          goto LABEL_9;
        }
        if ( !dev.fan_exist[v3] )
        {
          fan_exist_map = dev.fan_exist_map;
          v9 = dev.fan_num;
          dev.fan_exist[v3] = 1;
          dev.fan_exist_map = fan_exist_map | (1 << v3);
          dev.fan_num = v9 + 1;
        }
        fan_speed_low1 = dev.fan_speed_low1;
        if ( v4 > dev.fan_speed_top1 )
          dev.fan_speed_top1 = 120 * (unsigned __int8)v11;
        v10 = 1;
        if ( v4 )
          v10 = v4 >= dev.fan_speed_low1;
        if ( v10 )
          goto LABEL_8;
LABEL_9:
        dev.fan_speed_low1 = 120 * (unsigned __int8)v11;
LABEL_10:
        cgsleep_ms(50);
        --v2;
      }
      while ( v2 );
      if ( v1 == 1 )
        break;
      v1 = 1;
    }
    sleep(1u);
  }
}

//----- (00033E90) --------------------------------------------------------
void __noreturn get_hash_rate()
{
  double *v0; // r5
  int v1; // r4
  double v2; // d8
  int v3; // r7
  int v4; // s24
  int v5; // r6
  uint64_t *v6; // r11
  double v7; // r0
  double v8; // d7
  double *v9; // r3
  double v10; // d6
  int v11; // r6
  int v12; // r3
  double v13; // d6
  timeval old_h; // [sp+0h] [bp-164h] BYREF
  timeval new_h; // [sp+8h] [bp-15Ch] BYREF
  int index[4]; // [sp+10h] [bp-154h] BYREF
  double each_chain_h[4][10]; // [sp+20h] [bp-144h] BYREF

  memset(each_chain_h, 0, sizeof(each_chain_h));
  memset(index, 0, sizeof(index));
  cgtime(&old_h);
  cgtime(&new_h);
  while ( 1 )
  {
    v0 = each_chain_h_avg;
    cgtime(&new_h);
    v1 = 0;
    v2 = 0.0;
    v3 = new_h.tv_usec - old_h.tv_usec + (new_h.tv_usec - old_h.tv_usec < 0 ? 0xF4000 : 0);
    v4 = new_h.tv_sec - old_h.tv_sec;
    if ( new_h.tv_usec - old_h.tv_usec < 0 )
    {
      v3 += 576;
      v4 = new_h.tv_sec - old_h.tv_sec - 1;
    }
    do
    {
      if ( dev.chain_exist[v1] )
      {
        v5 = index[v1];
        v6 = &h_each_chain[v1];
        v7 = (double)(0xFFFF * *v6);
        v8 = 0.0;
        *v6 = 0;
        v9 = each_chain_h[v1];
        each_chain_h[v1][v5] = v7 / ((double)(v3 + 1) / 1000000.0 + (double)v4);
        do
        {
          v10 = *v9++;
          v8 = v8 + v10;
        }
        while ( v9 != each_chain_h[v1 + 1] );
        *v0 = v8;
        v11 = v5 + 1;
        sprintf(&displayed_rate[16 * v1], "%.2f", v8 / 1000.0 / 10.0);
        v13 = *v0;
        if ( v11 <= 9 )
          index[v1] = v11;
        else
          v12 = 0;
        if ( v11 > 9 )
          index[v1] = v12;
        v2 = v2 + v13 / 10.0;
      }
      ++v1;
      ++v0;
    }
    while ( v1 != 4 );
    sprintf(displayed_hash_rate, "%.2f", v2);
    geach_chain_h_all = v2;
    copy_time(&old_h, &new_h);
    sleep(5u);
  }
}
// 33FF2: variable 'v12' is possibly undefined

//----- (00034020) --------------------------------------------------------
// Alternative name is 'i2c_write.part.1'
void __fastcall i2c_write_0(unsigned int config_data)
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  snprintf(tmp42, 0x1000u, "%s: i2c always busy, break\n", "i2c_write");
  applog(5, tmp42, 0);
}

//----- (00034054) --------------------------------------------------------
// Alternative name is 'i2c_read.part.2'
int __fastcall i2c_read_0(unsigned int config_data)
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  snprintf(tmp42, 0x1000u, "%s: i2c always busy, break\n", "i2c_read");
  applog(5, tmp42, 0);
  return 255;
}

//----- (0003408C) --------------------------------------------------------
// Alternative name is 'bm1740_makeup_work.part.6'
int __fastcall bm1740_makeup_work_0(uint8_t *str, int len)
{
  unsigned int v3; // r2
  uint8_t *v4; // r1
  int v5; // t1

  v3 = 0xFFFF;
  str[2] = str[2] & 0x1F | 0x20;
  *(_WORD *)str = -21931;
  v4 = str + 2;
  do
  {
    v5 = *v4++;
    v3 = (unsigned __int16)(*(_WORD *)&_FUNCTION___15596[2 * (v5 ^ (v3 >> 8)) + 100] ^ ((_WORD)v3 << 8));
  }
  while ( v4 != str + 144 );
  *((_WORD *)str + 72) = ((_WORD)v3 << 8) | (v3 >> 8);
  return 146;
}

//----- (000340E0) --------------------------------------------------------
// Alternative name is 'calculate_asic_number.part.9'
int __fastcall calculate_asic_number_0(unsigned int actual_asic_number)
{
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  snprintf(tmp42, 0x1000u, "actual_asic_number = %d, but it is error\n", actual_asic_number);
  applog(7, tmp42, 0);
  return -1;
}

//----- (00034114) --------------------------------------------------------
// Alternative name is '_rwlock_init.constprop.25'
void __fastcall rwlock_init_1(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
{
  int *v4; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( pthread_rwlock_init(lock, 0) )
  {
    v4 = _errno_location();
    snprintf(
      tmp42,
      0x1000u,
      "Failed to pthread_rwlock_init errno=%d in %s %s():%d",
      *v4,
      "driver-btm-zcash.c",
      "bitmain_ZCASH_prepare",
      7544);
    applog(3, tmp42, 1);
    quit(1);
  }
}

//----- (00034174) --------------------------------------------------------
void *__fastcall bitmain_scanhash(void *arg)
{
  bitmain_ZCASH_info *v1; // r4
  uint32_t nonce_num; // r11
  work *v3; // r6
  uint32_t v4; // r7
  int work_id; // r8
  unsigned int chain_id; // r4
  int v7; // r9
  uint32_t v8; // r3
  work *v9; // r0
  uint8_t *v10; // r3
  unsigned __int8 *hash; // r2
  unsigned int v12; // r0
  unsigned int v13; // t1
  unsigned int v14; // t1
  bool v15; // cc
  int valid; // r0
  int v17; // r0
  char *v19; // r8
  work *v20; // r0
  unsigned int v21; // r8
  int *v22; // r0
  char *v23; // r9
  int *v24; // r0
  int *v25; // r0
  int *v26; // r0
  bitmain_ZCASH_info *info; // [sp+14h] [bp-1718h]
  unsigned int chip_addr; // [sp+18h] [bp-1714h]
  int nonce_id; // [sp+1Ch] [bp-1710h]
  cgpu_info *bitmain_ZCASH; // [sp+24h] [bp-1708h]
  pthread_rwlock_t *rwlock; // [sp+2Ch] [bp-1700h]
  uint8_t nonce_bin[4]; // [sp+34h] [bp-16F8h] BYREF
  timeval current; // [sp+38h] [bp-16F4h] BYREF
  uint8_t s[32]; // [sp+40h] [bp-16ECh] BYREF
  uint8_t v36[32]; // [sp+60h] [bp-16CCh] BYREF
  blake2b_state digest[1]; // [sp+80h] [bp-16ACh] BYREF
  uint8_t nonce[1344]; // [sp+1E8h] [bp-1544h] BYREF
  uint8_t tmp42[4100]; // [sp+728h] [bp-1004h] BYREF

  v1 = *(bitmain_ZCASH_info **)(*((_DWORD *)arg + 9) + 20);
  bitmain_ZCASH = (cgpu_info *)*((_DWORD *)arg + 9);
  info = v1;
  memset(nonce, 0, sizeof(nonce));
  cgtime(&current);
  h = 0;
  pthread_mutex_lock(&nonce_mutex);
  nonce_num = nonce_fifo.nonce_num;
  pthread_mutex_unlock(&nonce_mutex);
  if ( pthread_mutex_lock(&v1->update_lock.mutex) )
  {
    v25 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON LOCK! errno=%d in %s %s():%d",
      *v25,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6344);
    applog(3, (const char *)tmp42, 1);
    quit(1);
  }
  rwlock = &v1->update_lock.rwlock;
  if ( pthread_rwlock_rdlock(&v1->update_lock.rwlock) )
  {
    v26 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x1000u,
      "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
      *v26,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6344);
    applog(3, (const char *)tmp42, 1);
    quit(1);
  }
  if ( pthread_mutex_unlock(&v1->update_lock.mutex) )
  {
    v24 = _errno_location();
    snprintf(
      (char *)tmp42,
      0x1000u,
      "WTF MUTEX ERROR ON UNLOCK! errno=%d in %s %s():%d",
      *v24,
      "driver-btm-zcash.c",
      "bitmain_scanhash",
      6344);
    applog(3, (const char *)tmp42, 1);
    quit(1);
  }
  if ( !nonce_num )
    goto LABEL_24;
  v3 = 0;
  v4 = nonce_num;
  while ( 1 )
  {
    pthread_mutex_lock(&nonce_mutex);
    --v4;
    --nonce_fifo.nonce_num;
    work_id = nonce_fifo.nonce_buffer[nonce_fifo.p_rd].work_id;
    nonce_id = nonce_fifo.nonce_buffer[nonce_fifo.p_rd].nonce_id;
    chain_id = nonce_fifo.nonce_buffer[nonce_fifo.p_rd].chain_id;
    chip_addr = nonce_fifo.nonce_buffer[nonce_fifo.p_rd].chip_addr;
    memcpy(nonce, &nonce_fifo.nonce_buffer[nonce_fifo.p_rd], sizeof(nonce));
    v7 = *(_DWORD *)nonce_fifo.nonce_buffer[nonce_fifo.p_rd].chip_nonce;
    v8 = nonce_fifo.p_rd > 0x62 ? 0 : nonce_fifo.p_rd + 1;
    nonce_fifo.p_rd = v8;
    pthread_mutex_unlock(&nonce_mutex);
    if ( chain_id > 4 )
      break;
    pthread_mutex_lock(&work_queue_mutex);
    v9 = info->work_queue[work_id];
    if ( v9 )
      v3 = copy_work_noffset(v9, 0);
    pthread_mutex_unlock(&work_queue_mutex);
    if ( v3 )
    {
      *(_DWORD *)&v3->equihash_data[136] = v7;
      memcpy(&v3->equihash_data[143], nonce, 0x540u);
      digestInit(digest, 200, 9);
      blake2b_update(digest, v3->equihash_data, 0x8Cu);
      memset(s, 0, sizeof(s));
      memset(v36, 0, sizeof(v36));
      memcpy(tmp42, v3->equihash_data, 0x5CFu);
      Sha256_Onestep(tmp42, 0x5CFu, s);
      Sha256_Onestep(s, 0x20u, v36);
      v10 = (uint8_t *)digest;
      hash = v3->hash;
      while ( 1 )
      {
        v13 = *--v10;
        v12 = v13;
        v14 = *--hash;
        v15 = v12 > v14;
        if ( v12 < v14 )
        {
LABEL_17:
          valid = IsValidSolution(digest, nonce);
          if ( valid )
            goto LABEL_32;
          submit_nonce_direct((thr_info *)arg, v3, 1u);
          goto LABEL_19;
        }
        if ( v15 )
          break;
        if ( v36 == v10 )
          goto LABEL_17;
      }
      valid = IsValidSolution(digest, nonce);
      if ( valid )
      {
LABEL_32:
        if ( valid == 2 )
        {
          v19 = (char *)&dev.chain_asic_nonce[chain_id + 3][(unsigned __int8)(chip_addr / dev.addrInterval) + 2] + 1;
          ++*(_DWORD *)(v19 + 3);
        }
        if ( zero_stats_flag )
        {
          zero_stats_flag = 0;
          dev.chain_hw[0] = 0;
          dev.chain_hw[1] = 0;
          dev.chain_hw[2] = 0;
          dev.chain_hw[3] = 0;
        }
LABEL_36:
        cg_logwork(v3, nonce_bin, 1);
        v20 = v3;
        v3 = 0;
        free_work(v20);
        if ( !v4 )
        {
LABEL_24:
          if ( !pthread_rwlock_unlock(rwlock) )
            goto LABEL_25;
LABEL_51:
          v22 = _errno_location();
          snprintf(
            (char *)tmp42,
            0x1000u,
            "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
            *v22,
            "driver-btm-zcash.c",
            "bitmain_scanhash",
            6453);
          applog(3, (const char *)tmp42, 1);
          quit(1);
        }
        continue;
      }
LABEL_19:
      v17 = dev.chain_exist[chain_id];
      ++h;
      ++*(_QWORD *)&(&axi_fpga_addr)[2 * chain_id + 20];
      if ( !v17 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf((char *)tmp42, 0x1000u, "ChainID Cause Error! ChainID:[%d]", chain_id);
          applog(3, (const char *)tmp42, 0);
        }
        goto LABEL_23;
      }
      v21 = (unsigned __int8)(chip_addr / dev.addrInterval);
      if ( v21 <= 2 )
      {
        update_work_stats((thr_info *)arg, v3);
        v23 = (char *)&dev.chain_hw[3 * chain_id + 3 + v21] + 1;
        ++*(_DWORD *)(v23 + 3);
        goto LABEL_36;
      }
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf((char *)tmp42, 0x1000u, "Which Nonce Cause Err![%d] %08x", v21, nonce_id);
        applog(7, (const char *)tmp42, 0);
        if ( !v4 )
          goto LABEL_24;
        continue;
      }
LABEL_23:
      if ( !v4 )
        goto LABEL_24;
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        goto LABEL_23;
      snprintf(
        (char *)tmp42,
        0x1000u,
        "%s %d: work %02x not find error",
        bitmain_ZCASH->drv->name,
        bitmain_ZCASH->device_id,
        work_id);
      applog(3, (const char *)tmp42, 0);
      if ( !v4 )
        goto LABEL_24;
    }
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    goto LABEL_24;
  snprintf((char *)tmp42, 0x1000u, "Error:scanhash chainid=%u\n", chain_id);
  applog(5, (const char *)tmp42, 0);
  if ( pthread_rwlock_unlock(rwlock) )
    goto LABEL_51;
LABEL_25:
  selective_yield();
  h *= 0xFFFFLL;
  return 0;
}

//----- (000346CC) --------------------------------------------------------
// Alternative name is '_mutex_init.part.0.constprop.31'
void __fastcall __noreturn mutex_init_1(pthread_mutex_t *lock, const char *file, const char *func, const int line)
{
  int *v5; // r0
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v5 = _errno_location();
  snprintf(
    tmp42,
    0x1000u,
    "Failed to pthread_mutex_init errno=%d in %s %s():%d",
    *v5,
    "driver-btm-zcash.c",
    "bitmain_ZCASH_prepare",
    lock);
  applog(3, tmp42, 1);
  quit(1);
}

//----- (0003471C) --------------------------------------------------------
int bitmain_axi_init()
{
  int fd; // r0
  unsigned int *v1; // r1
  int v2; // r0
  unsigned int *v3; // r1

  fd = open("/dev/axi_fpga_dev", 2);
  fpga_fd = fd;
  if ( fd < 0 )
  {
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fd);
    return -1;
  }
  else
  {
    v1 = (unsigned int *)mmap(0, 0x1200u, 3, 1, fd, 0);
    axi_fpga_addr = v1;
    if ( v1 )
    {
      printf("mmap axi_fpga_addr = 0x%x\n", v1);
      printf("axi_fpga_addr data = 0x%x\n", *(unsigned __int16 *)axi_fpga_addr);
      v2 = open("/dev/fpga_mem", 2);
      fd_fpga_mem = v2;
      if ( v2 < 0 )
      {
        printf("/dev/fpga_mem open failed. fd_fpga_mem = %d\n", v2);
        return -1;
      }
      else
      {
        v3 = (unsigned int *)mmap(0, 0x1000000u, 3, 1, v2, 0);
        fpga_mem_addr = v3;
        if ( v3 )
        {
          printf("mmap fpga_mem_addr = 0x%x\n", v3);
          return 0;
        }
        else
        {
          printf("mmap fpga_mem_addr failed. fpga_mem_addr = 0x%x\n", 0);
          return -1;
        }
      }
    }
    else
    {
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", 0);
      return -1;
    }
  }
}

//----- (00034810) --------------------------------------------------------
int bitmain_axi_close()
{
  printf("\n\n--- %s\n", "bitmain_axi_close");
  if ( munmap(axi_fpga_addr, 0x1200u) < 0 )
    puts("munmap failed!");
  if ( munmap(fpga_mem_addr, 0x1000000u) < 0 )
    puts("munmap failed!");
  close(fpga_fd);
  return j_close(fd_fpga_mem);
}

//----- (00034888) --------------------------------------------------------
void __fastcall print_bin(uint8_t *cmd, size_t len)
{
  char *v2; // r0
  char *v3; // r4
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  v2 = bin2hex(cmd, len);
  v3 = v2;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s", v2);
    applog(5, tmp42, 0);
    free(v3);
  }
  else
  {
    free(v2);
  }
}

//----- (000348F0) --------------------------------------------------------
unsigned int __fastcall read_axi_fpga(unsigned int address)
{
  return axi_fpga_addr[address];
}

//----- (00034910) --------------------------------------------------------
void __fastcall write_axi_fpga(unsigned int address, unsigned int data)
{
  axi_fpga_addr[address] = data;
}

//----- (00034920) --------------------------------------------------------
void check_fpga_version()
{
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  *axi_fpga_addr |= 0x60000000u;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "FPGA version: %04X", (unsigned __int16)*axi_fpga_addr);
    applog(5, tmp42, 0);
  }
}

//----- (000349A4) --------------------------------------------------------
void init_fpga()
{
  printf("\n--- %s\n", "init_fpga");
  axi_fpga_addr[32] = -2139062257;
  do
    cgsleep_us(10000);
  while ( (axi_fpga_addr[32] & 0x80000000) != 0 );
  check_fpga_version();
  cgsleep_us((unsigned int)&loc_1869E + 2);
}
// 349D8: conditional instruction was optimized away because r3.4==8080800F

//----- (00034A10) --------------------------------------------------------
unsigned __int8 __fastcall asic_baud_to_fpga_baud(unsigned __int8 asic_baud)
{
  if ( asic_baud > 1u && asic_baud != 26 )
  {
    printf("%s: Don't support ASIC baud = %d, error!!!\n", "asic_baud_to_fpga_baud", asic_baud);
    return 53;
  }
  return asic_baud;
}

//----- (00034A38) --------------------------------------------------------
void __fastcall set_fpga_baud(unsigned __int8 asic_baud)
{
  unsigned __int8 v1; // r0

  v1 = asic_baud_to_fpga_baud(asic_baud);
  axi_fpga_addr[15] = v1 & 0x3F | ((v1 & 0x3F) << 8) | ((v1 & 0x3F) << 16) & 0xC0FFFFFF | ((v1 & 0x3F) << 24);
}

//----- (00034A64) --------------------------------------------------------
unsigned int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 which_uart)
{
  unsigned int result; // r0

  switch ( which_uart )
  {
    case 0u:
      result = HIWORD(axi_fpga_addr[124]) & 0x3FF;
      break;
    case 1u:
      result = axi_fpga_addr[124] & 0x3FF;
      break;
    case 2u:
      result = HIWORD(axi_fpga_addr[125]) & 0x3FF;
      break;
    case 3u:
      result = axi_fpga_addr[125] & 0x3FF;
      break;
    case 4u:
      result = HIWORD(axi_fpga_addr[126]) & 0x3FF;
      break;
    case 5u:
      result = axi_fpga_addr[126] & 0x3FF;
      break;
    case 6u:
      result = HIWORD(axi_fpga_addr[127]) & 0x3FF;
      break;
    case 7u:
      result = axi_fpga_addr[127] & 0x3FF;
      break;
    case 8u:
      result = HIWORD(axi_fpga_addr[128]) & 0x3FF;
      break;
    case 9u:
      result = axi_fpga_addr[128] & 0x3FF;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", which_uart);
      result = 0;
      break;
  }
  return result;
}

//----- (00034BC4) --------------------------------------------------------
unsigned int __fastcall read_uart_data_in_fpga(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int length)
{
  int v3; // r0
  int v4; // r9
  unsigned int v5; // r8
  unsigned __int8 *v6; // r3
  unsigned int v7; // r0
  unsigned int result; // r0
  unsigned int v9; // r2
  unsigned __int8 *v10; // r4
  unsigned int v11; // [sp+4h] [bp-8h]

  switch ( which_uart )
  {
    case 0u:
      v3 = 132;
      v4 = 133;
      goto LABEL_3;
    case 1u:
      v3 = 134;
      v4 = 135;
      goto LABEL_3;
    case 2u:
      v3 = 136;
      v4 = 137;
      goto LABEL_3;
    case 3u:
      v3 = 138;
      v4 = 139;
      goto LABEL_3;
    case 4u:
      v3 = 140;
      v4 = 141;
      goto LABEL_3;
    case 5u:
      v3 = 142;
      v4 = 143;
      goto LABEL_3;
    case 6u:
      v3 = 144;
      v4 = 145;
      goto LABEL_3;
    case 7u:
      v3 = 146;
      v4 = 147;
      goto LABEL_3;
    case 8u:
      v3 = 148;
      v4 = 149;
      goto LABEL_3;
    case 9u:
      v3 = 150;
      v4 = 151;
LABEL_3:
      v5 = length >> 2;
      axi_fpga_addr[v3] = length & 0x3FF | 0x80000000;
      if ( length >> 2 )
      {
        v6 = buf;
        do
        {
          v6 += 4;
          v7 = axi_fpga_addr[v4];
          *(v6 - 1) = v7;
          *(v6 - 4) = HIBYTE(v7);
          *(v6 - 3) = BYTE2(v7);
          *(v6 - 2) = BYTE1(v7);
        }
        while ( v6 != &buf[4 * v5] );
      }
      result = length & 0xFFFFFFFC;
      v9 = length & 3;
      if ( v9 )
      {
        v10 = &buf[4 * v5];
        v11 = axi_fpga_addr[v4];
        if ( v9 == 2 )
        {
          buf[4 * v5] = HIBYTE(v11);
          v10[1] = BYTE2(v11);
          result += 2;
        }
        else if ( v9 == 3 )
        {
          result += 3;
          buf[4 * v5] = HIBYTE(v11);
          v10[1] = BYTE2(v11);
          v10[2] = BYTE1(v11);
        }
        else
        {
          buf[4 * v5] = HIBYTE(v11);
          ++result;
        }
      }
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "read_uart_data_in_fpga", length);
      result = 0;
      break;
  }
  return result;
}

//----- (00034D04) --------------------------------------------------------
unsigned int __fastcall clear_uart_send_fifo(unsigned __int8 which_chain)
{
  int v1; // r5
  int v2; // r10
  char v3; // r9
  int v4; // r4
  unsigned int v5; // r8
  unsigned int v6; // r8
  pthread_mutex_t *mutex; // [sp+4h] [bp-10h]

  v1 = which_chain;
  printf("--- %s\n", "clear_uart_send_fifo");
  mutex = &uart_send_mutex[v1];
  pthread_mutex_lock(mutex);
  switch ( v1 )
  {
    case 0:
      v2 = 96;
      v3 = 24;
      goto LABEL_3;
    case 1:
      v2 = 96;
      v3 = 16;
      goto LABEL_3;
    case 2:
      v2 = 96;
      v3 = 8;
      goto LABEL_3;
    case 3:
      v2 = 96;
      v3 = 0;
      goto LABEL_3;
    case 4:
      v2 = 97;
      v3 = 24;
      goto LABEL_3;
    case 5:
      v2 = 97;
      v3 = 16;
      goto LABEL_3;
    case 6:
      v2 = 97;
      v3 = 8;
      goto LABEL_3;
    case 7:
      v2 = 97;
      v3 = 0;
      goto LABEL_3;
    case 8:
      v2 = 98;
      v3 = 24;
      goto LABEL_3;
    case 9:
      v2 = 98;
      v3 = 16;
LABEL_3:
      v4 = 21;
      break;
    default:
      printf("%s: The uart%d is not supported!!!\n", "clear_uart_send_fifo", v1);
      v6 = 1;
      pthread_mutex_unlock(mutex);
      return v6;
  }
  while ( 1 )
  {
    v5 = (unsigned __int8)(axi_fpga_addr[v2] >> v3);
    if ( v5 == 255 )
      break;
    printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_send_fifo", v1);
    usleep(0xBB8u);
    if ( !--v4 )
    {
      printf("%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_send_fifo", v1);
      pthread_mutex_unlock(mutex);
      return v5;
    }
  }
  v6 = 0;
  pthread_mutex_unlock(mutex);
  return v6;
}

//----- (00034E40) --------------------------------------------------------
unsigned int __fastcall clear_uart_rx_fifo(unsigned __int8 which_chain)
{
  int v1; // r5
  pthread_mutex_t *v2; // r4
  size_t v3; // r0
  unsigned int v4; // r6
  unsigned __int8 *v5; // r0
  unsigned __int8 *v6; // r7
  unsigned int uart_data_in_fpga; // r3

  v1 = which_chain;
  v2 = &uart_receive_mutex[which_chain];
  pthread_mutex_lock(v2);
  v3 = check_how_many_uart_data_in_fpga(v1);
  v4 = v3;
  if ( v3 )
  {
    v5 = (unsigned __int8 *)malloc(v3);
    v6 = v5;
    if ( !v5 )
    {
LABEL_5:
      usleep((__useconds_t)&nonce_fifo.nonce_buffer[20].chip_addr);
      pthread_mutex_unlock(v2);
      return 1;
    }
    uart_data_in_fpga = read_uart_data_in_fpga(v1, v5, v4);
    if ( v4 != uart_data_in_fpga )
    {
      printf("%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n", "clear_uart_rx_fifo", v1, v4, uart_data_in_fpga);
      free(v6);
      goto LABEL_5;
    }
    v4 = 1;
    free(v6);
    usleep((__useconds_t)&nonce_fifo.nonce_buffer[20].chip_addr);
  }
  pthread_mutex_unlock(v2);
  return v4;
}

//----- (00034ED4) --------------------------------------------------------
unsigned int __fastcall uart_send(unsigned __int8 which_uart, volatile unsigned __int8 *buf, unsigned int length)
{
  int v3; // r9
  int v5; // r10
  char v6; // r8
  int v7; // r11
  unsigned int *v8; // r4
  int v9; // r7
  unsigned int v10; // r7
  unsigned __int8 *v11; // r2
  int v12; // r3
  unsigned int v13; // r2
  int v14; // r3
  int v15; // r7
  unsigned int v16; // r1
  int v18; // [sp+0h] [bp-1224h]
  pthread_mutex_t *mutex; // [sp+8h] [bp-121Ch]
  int v20; // [sp+Ch] [bp-1218h]
  unsigned int chain_send_buffer_addr; // [sp+14h] [bp-1210h]
  unsigned __int8 send_buf[512]; // [sp+20h] [bp-1204h] BYREF
  char tmp42[4100]; // [sp+220h] [bp-1004h] BYREF

  v3 = which_uart;
  memset(send_buf, 0, sizeof(send_buf));
  mutex = &uart_send_mutex[v3];
  pthread_mutex_lock(mutex);
  switch ( v3 )
  {
    case 0:
      v5 = 96;
      chain_send_buffer_addr = 101;
      v6 = 24;
      v20 = 100;
      goto LABEL_3;
    case 1:
      v5 = 96;
      v6 = 16;
      chain_send_buffer_addr = 103;
      v20 = 102;
      goto LABEL_3;
    case 2:
      v5 = 96;
      chain_send_buffer_addr = 105;
      v6 = 8;
      v20 = 104;
      goto LABEL_3;
    case 3:
      v5 = 96;
      chain_send_buffer_addr = 107;
      v6 = 0;
      v20 = 106;
      goto LABEL_3;
    case 4:
      v5 = 97;
      chain_send_buffer_addr = 109;
      v6 = 24;
      v20 = 108;
      goto LABEL_3;
    case 5:
      v5 = 97;
      chain_send_buffer_addr = 111;
      v6 = 16;
      v20 = 110;
      goto LABEL_3;
    case 6:
      v5 = 97;
      chain_send_buffer_addr = 113;
      v6 = 8;
      v20 = 112;
      goto LABEL_3;
    case 7:
      v5 = 97;
      chain_send_buffer_addr = 115;
      v6 = 0;
      v20 = 114;
      goto LABEL_3;
    case 8:
      v5 = 98;
      chain_send_buffer_addr = 117;
      v6 = 24;
      v20 = 116;
      goto LABEL_3;
    case 9:
      v5 = 98;
      chain_send_buffer_addr = 119;
      v6 = 16;
      v20 = 118;
LABEL_3:
      v7 = 21;
      break;
    default:
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
        return 0;
      snprintf(tmp42, 0x1000u, "%s: The uart%d is not supported!!!\n", "uart_send", v18);
      goto LABEL_33;
  }
  while ( 1 )
  {
    v8 = axi_fpga_addr;
    if ( length <= (unsigned __int8)(axi_fpga_addr[v5] >> v6) )
      break;
    usleep(0xBB8u);
    if ( !--v7 )
    {
      pthread_mutex_unlock(mutex);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "%s: uart%d always dose not has enough send fifo space, break\n", "uart_send", v3);
LABEL_33:
        applog(5, tmp42, 0);
      }
      return 0;
    }
  }
  if ( (axi_fpga_addr[v20] & 0x80000000) != 0 )
  {
    v9 = 21;
    while ( 1 )
    {
      usleep(0xBB8u);
      v8 = axi_fpga_addr;
      if ( (axi_fpga_addr[v20] & 0x80000000) == 0 )
        break;
      if ( !--v9 )
      {
        pthread_mutex_unlock(mutex);
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(tmp42, 0x1000u, "%s: uart%d always busy, break\n", "uart_send", v3);
          goto LABEL_33;
        }
        return 0;
      }
    }
  }
  memcpy(send_buf, (const void *)buf, length);
  v10 = length >> 2;
  if ( length >> 2 )
  {
    v11 = send_buf;
    do
    {
      v12 = v11[1];
      v11 += 4;
      v8[chain_send_buffer_addr] = (v12 << 16) | (*(v11 - 4) << 24) | *(v11 - 1) | (*(v11 - 2) << 8);
      v8 = axi_fpga_addr;
    }
    while ( &send_buf[4 * v10] != v11 );
  }
  v13 = length & 3;
  if ( (length & 3) != 0 )
  {
    v14 = send_buf[4 * v10];
    v15 = 4 * v10;
    v16 = v14 << 24;
    if ( v13 == 2 )
    {
      v16 |= send_buf[v15 + 1] << 16;
    }
    else if ( v13 == 3 )
    {
      v16 |= (send_buf[v15 + 2] << 8) | (send_buf[v15 + 1] << 16);
    }
    v8[chain_send_buffer_addr] = v16;
    v8 = axi_fpga_addr;
  }
  v8[v20] = length | 0x80000000;
  pthread_mutex_unlock(mutex);
  return length;
}
// 351A8: variable 'v18' is possibly undefined

//----- (000351C4) --------------------------------------------------------
void *__fastcall ZCASH_fill_work(void *usrdata)
{
  pthread_t v2; // r0
  int v3; // r5
  int v4; // r6
  char *v5; // r3
  int v6; // r3
  int v7; // r2
  work *work; // r0
  work *v10; // r7
  int v11; // r1
  work *v12; // r0
  char *v13; // [sp+Ch] [bp-10B8h]
  thr_info *thr; // [sp+10h] [bp-10B4h]
  bitmain_ZCASH_info *info; // [sp+14h] [bp-10B0h]
  timeval send_start; // [sp+1Ch] [bp-10A8h] BYREF
  timeval last_send; // [sp+24h] [bp-10A0h] BYREF
  bm1740_work workdata; // [sp+2Ch] [bp-1098h] BYREF
  char tmp42[4100]; // [sp+C0h] [bp-1004h] BYREF

  v2 = pthread_self();
  pthread_detach(v2);
  v3 = *((unsigned __int8 *)usrdata + 4);
  info = *(bitmain_ZCASH_info **)usrdata;
  thr = *(thr_info **)(*(_DWORD *)usrdata + 630);
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "Start To Fill Work!ChainIndex:[%d]", v3);
    applog(7, tmp42, 0);
  }
  v4 = 0;
  cgtime(&send_start);
  cgtime(&last_send);
LABEL_6:
  while ( 1 )
  {
    v5 = (char *)&axi_fpga_addr + v3;
    if ( *((_BYTE *)&axi_fpga_addr + v3 + 668) )
      return 0;
    while ( 1 )
    {
      if ( !v5[652] || stop || certification_firmware )
      {
        cgsleep_ms(10);
        goto LABEL_6;
      }
      cgtime(&send_start);
      v6 = send_start.tv_usec - last_send.tv_usec;
      v7 = send_start.tv_sec - last_send.tv_sec;
      if ( send_start.tv_usec - last_send.tv_usec < 0 )
      {
        --v7;
        v6 += 1000000;
      }
      if ( *((_BYTE *)&axi_fpga_addr + v3 + 4) || v6 + 1000000 * v7 >= dev.timeout )
        break;
      cgsleep_us(500);
      v5 = (char *)&axi_fpga_addr + v3;
      if ( *((_BYTE *)&axi_fpga_addr + v3 + 668) )
        return 0;
    }
    cgtime(&last_send);
    while ( 1 )
    {
      work = get_work(thr, thr->id);
      if ( work )
        break;
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(tmp42, 0x1000u, "Work Error![%d]", v4);
        applog(3, tmp42, 0);
      }
    }
    *((_BYTE *)&axi_fpga_addr + v3 + 4) = 0;
    v10 = work;
    v4 = work->id & 0x7F;
    v13 = &info->update_lock.mutex.__size[4 * v4];
    memset(&workdata, 0, sizeof(workdata));
    *((_BYTE *)&workdata + 2) = 32;
    workdata.workid = v4;
    memcpy(workdata.work, v10->equihash_data, sizeof(workdata.work));
    bm1740_makeup_work_0(&workdata.header_55, v11);
    pthread_mutex_lock(&work_queue_mutex);
    v12 = *(work **)(v13 + 118);
    if ( v12 )
    {
      free_work(v12);
      *(_DWORD *)(v13 + 118) = 0;
    }
    *(_DWORD *)(v13 + 118) = copy_work_noffset(v10, 0);
    pthread_mutex_unlock(&work_queue_mutex);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "ChainID[%d] Wirte Work. workid=%d, jobid=%s", v3, v4, v10->job_id);
      applog(7, tmp42, 0);
    }
    uart_send(v3, &workdata.header_55, 0x92u);
    gBegin_get_nonce = 1;
    cgtime(&tv_send_job);
    cgsleep_us(500);
    free_work(v10);
  }
}
// 3533A: variable 'v11' is possibly undefined

//----- (00035434) --------------------------------------------------------
unsigned int __fastcall uart_receive(unsigned __int8 which_uart, unsigned __int8 *buf, unsigned int buf_length)
{
  pthread_mutex_t *v6; // r4
  unsigned int v7; // r0
  unsigned int v9; // r6
  unsigned int uart_data_in_fpga; // r6

  v6 = &uart_receive_mutex[which_uart];
  pthread_mutex_lock(v6);
  v7 = check_how_many_uart_data_in_fpga(which_uart);
  if ( v7 >= buf_length )
  {
    uart_data_in_fpga = read_uart_data_in_fpga(which_uart, buf, buf_length);
    pthread_mutex_unlock(v6);
    return uart_data_in_fpga;
  }
  else if ( v7 )
  {
    v9 = read_uart_data_in_fpga(which_uart, buf, v7);
    pthread_mutex_unlock(v6);
    return v9;
  }
  else
  {
    pthread_mutex_unlock(v6);
    return 0;
  }
}

//----- (0003549C) --------------------------------------------------------
void __fastcall i2c_write(unsigned int config_data)
{
  int v2; // r4
  unsigned int v3; // r0

  v2 = 22;
  do
  {
    if ( (axi_fpga_addr[12] & 0x80000000) != 0 )
    {
      axi_fpga_addr[12] = config_data;
      return;
    }
    v3 = usleep(0x1388u);
    --v2;
  }
  while ( v2 );
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
    i2c_write_0(v3);
}

//----- (00035504) --------------------------------------------------------
unsigned __int8 __fastcall i2c_read(unsigned int config_data)
{
  int v1; // r4

  v1 = 22;
  i2c_write(config_data | 0x2000000);
  do
  {
    usleep(0x1388u);
    if ( (axi_fpga_addr[12] & 0x80000000) != 0 )
      return axi_fpga_addr[12];
    --v1;
  }
  while ( v1 );
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
    return i2c_read_0(axi_fpga_addr[12]);
  else
    return -1;
}

//----- (00035578) --------------------------------------------------------
void __fastcall write_pic(unsigned __int8 data)
{
  i2c_write(data | (i2c_slave_addr << 16) | 0xA00000);
}

//----- (00035590) --------------------------------------------------------
int read_pic()
{
  return i2c_read((i2c_slave_addr << 16) | 0xA00000);
}

//----- (000355A8) --------------------------------------------------------
int __fastcall write_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t *data, int len)
{
  int v4; // r1
  int v5; // r6
  int v6; // r0
  uint8_t v7; // r4
  uint8_t *v8; // r1
  unsigned int v9; // r2
  __int16 v10; // t1
  unsigned int v11; // r1
  unsigned __int8 v12; // r4
  int v13; // r6
  int v14; // r3
  uint8_t *v15; // r4
  uint8_t read_back_data[16]; // [sp+10h] [bp-1024h] BYREF
  uint8_t send_data[16]; // [sp+20h] [bp-1014h] BYREF
  char tmp42[4100]; // [sp+30h] [bp-1004h] BYREF

  send_data[5] = reg;
  v4 = 0;
  v5 = len + 6;
  *(_WORD *)send_data = -21931;
  send_data[4] = 2 * i2c_dev_addr;
  send_data[3] = 50;
  send_data[2] = len + 6;
  *(_DWORD *)read_back_data = 255;
  memset(&read_back_data[4], 0, 12);
  memset(&send_data[6], 0, 10);
  if ( len > 0 )
  {
    v6 = 0;
    do
    {
      v7 = data[v4];
      v4 = (unsigned __int8)(v4 + 1);
      send_data[v6 + 6] = v7;
      v6 = v4;
    }
    while ( v4 < len );
  }
  if ( len < -3 )
  {
    LOBYTE(v9) = 0;
    LOBYTE(v11) = 0;
  }
  else
  {
    v8 = &send_data[1];
    LOWORD(v9) = 0;
    do
    {
      v10 = *++v8;
      v9 = (unsigned __int16)(v9 + v10);
    }
    while ( &send_data[len + 5] != v8 );
    v11 = v9 >> 8;
  }
  send_data[v5] = v11;
  v12 = 0;
  send_data[len + 7] = v9;
  pthread_mutex_lock(&i2c_mutex);
  v13 = (unsigned __int8)v5 + 1;
  v14 = 0;
  do
  {
    ++v12;
    i2c_write(send_data[v14] | (i2c_slave_addr << 16) | 0xA00000);
    v14 = v12;
  }
  while ( v12 <= v13 );
  v15 = read_back_data;
  usleep((__useconds_t)&loc_30D3E + 2);
  memset(read_back_data, 0, sizeof(read_back_data));
  do
    *v15++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( &read_back_data[5] != v15 );
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] == 50 && read_back_data[2] == 1 )
    return 0;
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return -1;
  snprintf(
    tmp42,
    0x1000u,
    "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n\n",
    "write_dc_dc",
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3]);
  applog(5, tmp42, 0);
  return -1;
}

//----- (00035728) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall read_dc_dc(uint8_t i2c_dev_addr, uint8_t reg, uint8_t *value, int len)
{
  int v4; // r10
  char v5; // r4
  __int16 v7; // r0
  __int16 v9; // r3
  int *v10; // r4
  int i; // r3
  int v12; // t1
  int v13; // r4
  int v15; // r3
  int v16; // r2
  int v17; // [sp+14h] [bp-101Ch] BYREF
  char v18; // [sp+18h] [bp-1018h]
  uint8_t rega; // [sp+19h] [bp-1017h]
  char v20; // [sp+1Ah] [bp-1016h]
  char v21; // [sp+1Bh] [bp-1015h]
  char v22; // [sp+1Ch] [bp-1014h] BYREF
  uint8_t read_back_data[16]; // [sp+20h] [bp-1010h] BYREF
  char tmp42[4096]; // [sp+30h] [bp-1000h] BYREF

  v5 = len;
  v7 = (unsigned __int8)(2 * i2c_dev_addr) | 1;
  rega = reg;
  v9 = v7 + 57 + reg + (unsigned __int8)len;
  v18 = v7;
  v22 = v9;
  v20 = v5;
  v21 = HIBYTE(v9);
  v10 = &v17;
  v17 = 839363157;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v12 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( v10 == (int *)&v22 )
      break;
    v12 = *((unsigned __int8 *)v10 + 1);
    v10 = (int *)((char *)v10 + 1);
  }
  v13 = 0;
  cgsleep_ms(200);
  *(_DWORD *)&read_back_data[4] = 0;
  if ( len + 4 >= 0 )
    v4 = 0;
  *(_DWORD *)read_back_data = 0;
  *(_DWORD *)&read_back_data[8] = 0;
  *(_DWORD *)&read_back_data[12] = 0;
  if ( len + 4 < 0 )
  {
    pthread_mutex_unlock(&i2c_mutex);
LABEL_9:
    if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
      return -1;
    snprintf(
      tmp42,
      0x1000u,
      "--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x, read_back_data[3] = 0x%02x\n",
      "read_dc_dc",
      read_back_data[0],
      v13,
      read_back_data[2],
      read_back_data[3]);
    applog(5, tmp42, 0);
    return -1;
  }
  do
  {
    v13 = (unsigned __int8)(v13 + 1);
    read_back_data[v4] = i2c_read((i2c_slave_addr << 16) | 0xA00000);
    v4 = v13;
  }
  while ( v13 <= len + 4 );
  v13 = read_back_data[1];
  pthread_mutex_unlock(&i2c_mutex);
  if ( v13 != 50 || read_back_data[2] != 1 )
    goto LABEL_9;
  if ( len > 0 )
  {
    v15 = 0;
    v16 = 0;
    do
    {
      value[v15] = read_back_data[v16 + 3];
      v15 = (unsigned __int8)(v15 + 1);
      v16 = v15;
    }
    while ( v15 < len );
  }
  return 0;
}
// 35728: variables would overlap: r1.1 and r1.2

//----- (0003588C) --------------------------------------------------------
unsigned __int8 __fastcall CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  char v2; // r9
  unsigned __int8 v3; // r6
  int v5; // r2
  int v6; // r0
  int v7; // lr
  int v8; // r7
  int v9; // r12
  unsigned int v10; // r5
  unsigned int v11; // r3
  unsigned __int8 v12; // r3
  int v13; // r4

  if ( len )
  {
    v2 = 1;
    v3 = 0;
    LOBYTE(v5) = 0;
    v6 = 1;
    v7 = 1;
    v8 = 1;
    v9 = 1;
    v10 = 128;
    while ( 1 )
    {
      v5 = (unsigned __int8)(v5 + 1);
      ++v3;
      v11 = *ptr & v10;
      v10 >>= 1;
      if ( v11 )
        v12 = v2 ^ 1;
      else
        v12 = v2;
      if ( v5 == 8 )
      {
        ++ptr;
        LOBYTE(v5) = 0;
        v10 = 128;
      }
      v13 = (unsigned __int8)(v12 ^ v8);
      v2 = v6;
      if ( (unsigned int)v3 >= len )
        break;
      v6 = v7;
      v8 = v9;
      v7 = v13;
      v9 = v12;
    }
    if ( v6 )
      LOBYTE(v6) = 16;
    if ( v7 )
      LOBYTE(v6) = v6 | 8;
    if ( v12 != v8 )
      LOBYTE(v6) = v6 | 4;
    if ( v9 )
    {
      LOBYTE(v6) = v6 | 2;
      if ( !v12 )
        return v6;
      goto LABEL_18;
    }
    if ( v12 )
LABEL_18:
      LOBYTE(v6) = v6 | 1;
  }
  else
  {
    LOBYTE(v6) = 31;
  }
  return v6;
}

//----- (00035938) --------------------------------------------------------
// Alternative name is 'bm1740_makeup_get_status_cmd.part.3'
// local variable allocation has failed, the output may be wrong!
int __fastcall bm1740_makeup_get_status_cmd(
        uint8_t *str,
        uint32_t str_len,
        uint8_t all,
        uint8_t chip_addr,
        uint8_t regaddr)
{
  unsigned __int8 v6; // r0
  int v7; // r1
  int v9; // [sp+0h] [bp-Ch] BYREF
  int chip_addra; // [sp+4h] [bp-8h] OVERLAPPED

  *(_WORD *)((char *)&chip_addra + 1) = __PAIR16__(BYTE2(chip_addra), chip_addr) & 0x1FFF;
  LOBYTE(chip_addra) = all;
  LOWORD(v9) = -21931;
  BYTE2(v9) = (16 * (str_len & 1)) | 0x42;
  HIBYTE(v9) = 5;
  v6 = CRC5((unsigned __int8 *)&v9 + 2, 0x20u);
  BYTE2(chip_addra) = BYTE2(chip_addra) & 0xE0 | v6 & 0x1F;
  v7 = chip_addra;
  *(_DWORD *)str = v9;
  *((_WORD *)str + 2) = v7;
  str[6] = BYTE2(v7);
  return 7;
}
// 35938: variables would overlap: ^4.4 and stkvar "chip_addr" ^4.1(has user info),stkvar "regaddr" ^5.1(has user info)

//----- (000359A4) --------------------------------------------------------
// Alternative name is 'bm1740_makeup_get_status_cmd.constprop.20'
int __fastcall bm1740_makeup_get_status_cmd_0(
        uint8_t *str,
        uint32_t str_len,
        uint8_t all,
        uint8_t chip_addr,
        uint8_t regaddr)
{
  return bm1740_makeup_get_status_cmd(str, 1u, 0, str_len, regaddr);
}

//----- (000359AC) --------------------------------------------------------
// Alternative name is 'bm1740_makeup_chain_inactive_cmd.constprop.19'
int __fastcall bm1740_makeup_chain_inactive_cmd(uint8_t *str, uint32_t str_len)
{
  unsigned __int8 v3; // r0
  char v4; // r2
  uint8_t v5; // r2
  chain_inactive_cmd_t chain_inactive_cmd; // [sp+0h] [bp-8h] BYREF

  *(_WORD *)&chain_inactive_cmd.reserve1 = 0;
  *((_BYTE *)&chain_inactive_cmd + 4) = 0;
  *(_WORD *)&chain_inactive_cmd = 1363;
  v3 = CRC5((unsigned __int8 *)&chain_inactive_cmd, 0x20u);
  v4 = *((_BYTE *)&chain_inactive_cmd + 4);
  *(_WORD *)str = -21931;
  v5 = v4 & 0xE0 | v3 & 0x1F;
  *(_DWORD *)(str + 2) = chain_inactive_cmd;
  str[6] = v5;
  return 7;
}

//----- (000359EC) --------------------------------------------------------
// Alternative name is 'bm1740_makeup_set_config_cmd.constprop.21'
// local variable allocation has failed, the output may be wrong!
int __fastcall bm1740_makeup_set_config_cmd(
        uint8_t *str,
        uint32_t str_len,
        uint8_t all,
        uint8_t chip_addr,
        uint32_t regaddr,
        uint32_t regdata)
{
  unsigned __int8 v7; // r0
  int v8; // r1
  int v9; // r2
  int v11; // [sp+4h] [bp-10h] BYREF
  __int64 chip_addra; // [sp+8h] [bp-Ch] OVERLAPPED

  LOBYTE(chip_addra) = all;
  BYTE1(chip_addra) = chip_addr;
  BYTE2(v11) = (16 * (str_len & 1)) | 0x41;
  *(_DWORD *)((char *)&chip_addra + 2) = bswap32(regaddr);
  BYTE6(chip_addra) &= 0x1Fu;
  LOWORD(v11) = -21931;
  HIBYTE(v11) = 9;
  v7 = CRC5((unsigned __int8 *)&v11 + 2, 0x40u);
  BYTE6(chip_addra) = BYTE6(chip_addra) & 0xE0 | v7 & 0x1F;
  v9 = HIDWORD(chip_addra);
  v8 = chip_addra;
  *(_DWORD *)str = v11;
  *((_DWORD *)str + 1) = v8;
  *((_WORD *)str + 4) = v9;
  str[10] = BYTE2(v9);
  return 11;
}
// 359EC: variables would overlap: ^8.8 and stkvar "chip_addr" ^8.1(has user info),stkvar "regaddr" ^9.1(has user info)

//----- (00035A68) --------------------------------------------------------
// Alternative name is 'bm1740_makeup_set_address_cmd.constprop.22'
int __fastcall bm1740_makeup_set_address_cmd(uint8_t *str, uint32_t str_len, uint8_t chip_addr)
{
  unsigned __int8 v4; // r0
  char v5; // r2
  uint8_t v6; // r2
  int v8; // [sp+0h] [bp-Ch] BYREF
  char v9; // [sp+4h] [bp-8h]

  HIWORD(v8) = (unsigned __int8)str_len;
  v9 = 0;
  LOWORD(v8) = 1344;
  v4 = CRC5((unsigned __int8 *)&v8, 0x20u);
  v5 = v9;
  *(_WORD *)str = -21931;
  v6 = v5 & 0xE0 | v4 & 0x1F;
  *(_DWORD *)(str + 2) = v8;
  str[6] = v6;
  return 7;
}

//----- (00035AB8) --------------------------------------------------------
unsigned __int16 __fastcall CRC16(unsigned __int8 *buffer, int len)
{
  unsigned __int8 *v2; // r1
  unsigned int v3; // r2
  int v4; // t1

  if ( !len )
    return -1;
  v2 = &buffer[len];
  v3 = 0xFFFF;
  do
  {
    v4 = *buffer++;
    LOWORD(v3) = *(_WORD *)&_FUNCTION___15596[2 * (v4 ^ (v3 >> 8)) + 100] ^ ((_WORD)v3 << 8);
  }
  while ( buffer != v2 );
  return v3;
}

//----- (00035AF4) --------------------------------------------------------
uint16_t __fastcall crc_itu_t(uint16_t crc, const uint8_t *buffer, int len)
{
  const uint8_t *v3; // r2
  int v4; // t1

  if ( len )
  {
    v3 = &buffer[len];
    do
    {
      v4 = *buffer++;
      crc = *(_WORD *)&_FUNCTION___15596[2 * (v4 ^ HIBYTE(crc)) + 100] ^ (crc << 8);
    }
    while ( buffer != v3 );
  }
  return crc;
}

//----- (00035B24) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __fastcall set_PIC16F1704_flash_pointer_new(unsigned __int8 flash_addr_h, unsigned __int8 flash_addr_l)
{
  char *v2; // r4
  int i; // r3
  int v4; // t1
  int v5; // r4
  int v6; // r7
  bool v7; // zf
  int result; // r0
  int v9; // [sp+10h] [bp-100Ch] BYREF
  unsigned __int8 flash_addr_ha; // [sp+14h] [bp-1008h]
  unsigned __int8 v11; // [sp+15h] [bp-1007h]
  char v12; // [sp+16h] [bp-1006h]
  char v13; // [sp+17h] [bp-1005h]
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  flash_addr_ha = flash_addr_h;
  v13 = flash_addr_l + 7 + flash_addr_h;
  v12 = (unsigned __int16)(flash_addr_l + 7 + flash_addr_h) >> 8;
  v11 = flash_addr_l;
  v9 = 17214037;
  v2 = (char *)&v9 + 1;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( tmp42 == v2 )
      break;
    v4 = (unsigned __int8)*v2++;
  }
  usleep(0x186A0u);
  v5 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v6 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  v7 = v6 == 1;
  if ( v6 == 1 )
    v7 = v5 == 1;
  if ( v7 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "set_PIC16F1704_flash_pointer_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_flash_pointer_new",
      i2c_slave_addr,
      v5,
      v6);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}
// 35B24: variables would overlap: r0.1 and r0.2
// 35B24: variables would overlap: r1.1 and r1.2

//----- (00035C5C) --------------------------------------------------------
int __fastcall send_data_to_PIC16F1704_new(unsigned __int8 *buf)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r0
  unsigned __int8 *v3; // r2
  __int16 v4; // r3
  __int16 v5; // t1
  unsigned __int8 *v6; // r2
  unsigned __int8 v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // t1
  __int64 v10; // r4
  int result; // r0
  char v12; // [sp+Fh] [bp-1019h] BYREF
  unsigned __int8 send_data[22]; // [sp+10h] [bp-1018h] BYREF
  char tmp42[4096]; // [sp+28h] [bp-1000h] BYREF

  v1 = buf - 1;
  v2 = buf + 15;
  v3 = v1;
  v4 = 22;
  memset(&send_data[4], 0, 16);
  do
  {
    v5 = *++v3;
    v4 += v5;
  }
  while ( v2 != v3 );
  v6 = &send_data[4];
  *(_DWORD *)send_data = 34908757;
  do
  {
    v7 = *++v1;
    *v6++ = v7;
  }
  while ( &send_data[20] != v6 );
  send_data[20] = HIBYTE(v4);
  v8 = (unsigned __int8 *)&v12;
  send_data[21] = v4;
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v9 = *++v8;
    i2c_write(v9 | (i2c_slave_addr << 16) | 0xA00000);
  }
  while ( &send_data[21] != v8 );
  usleep(0x186A0u);
  LODWORD(v10) = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  HIDWORD(v10) = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  if ( v10 == 0x100000002LL )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "send_data_to_PIC16F1704_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "send_data_to_PIC16F1704_new",
      i2c_slave_addr,
      (_DWORD)v10,
      HIDWORD(v10));
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00035DBC) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_pointer_new(unsigned __int8 *flash_addr_h, unsigned __int8 *flash_addr_l)
{
  unsigned __int8 *v4; // r4
  int i; // r3
  int v6; // t1
  unsigned __int8 *v7; // r4
  int result; // r0
  int v9; // r1
  unsigned int v10; // r3
  unsigned __int8 read_back_data[6]; // [sp+20h] [bp-1010h] BYREF
  char v12; // [sp+26h] [bp-100Ah] BYREF
  unsigned __int8 send_data[6]; // [sp+28h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+30h] [bp-1000h] BYREF

  send_data[4] = 0;
  send_data[5] = 12;
  *(_DWORD *)read_back_data = 255;
  *(_WORD *)&read_back_data[4] = 0;
  v4 = send_data;
  *(_DWORD *)send_data = 134523477;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v6 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v4 )
      break;
    v6 = *++v4;
  }
  v7 = read_back_data;
  usleep((__useconds_t)&loc_1869E + 2);
  do
    *v7++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( &v12 != (char *)v7 );
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[1] != 8 || read_back_data[0] != 6 )
  {
    if ( !use_syslog )
    {
      result = opt_log_output;
      if ( !opt_log_output && opt_log_level <= 2 )
        return result;
    }
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3"
      "] = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
      "\n",
      "read_PIC16F1704_flash_pointer_new",
      i2c_slave_addr,
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5]);
    goto LABEL_11;
  }
  v9 = read_back_data[3];
  v10 = read_back_data[2] + read_back_data[3] + 14;
  if ( read_back_data[4] != v10 >> 8 || read_back_data[5] != (unsigned __int8)v10 )
  {
    if ( !use_syslog )
    {
      result = opt_log_output;
      if ( !opt_log_output && opt_log_level <= 2 )
        return result;
    }
    snprintf(
      tmp42,
      0x1000u,
      "%s failed!!! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%"
      "x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
      "\n",
      "read_PIC16F1704_flash_pointer_new",
      6,
      8,
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5]);
LABEL_11:
    applog(3, tmp42, 0);
    return 0;
  }
  *flash_addr_h = read_back_data[2];
  *flash_addr_l = v9;
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return 1;
  snprintf(
    tmp42,
    0x1000u,
    "%s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x",
    "read_PIC16F1704_flash_pointer_new",
    *flash_addr_h,
    v9);
  applog(5, tmp42, 0);
  return 1;
}

//----- (00035FA0) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_data_new(unsigned __int8 *buf)
{
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r6
  int result; // r0
  unsigned __int8 v8; // r1
  unsigned __int8 *v9; // r7
  unsigned __int8 *j; // r2
  unsigned __int8 v11; // t1
  unsigned __int8 send_data[6]; // [sp+54h] [bp-1020h] BYREF
  char v13; // [sp+5Bh] [bp-1019h] BYREF
  unsigned __int8 read_back_data[20]; // [sp+5Ch] [bp-1018h] BYREF
  char tmp42[4100]; // [sp+70h] [bp-1004h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  v2 = send_data;
  memset(&read_back_data[4], 0, 16);
  *(_DWORD *)send_data = 50637397;
  send_data[5] = 7;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( v2 == &send_data[5] )
      break;
    v4 = *++v2;
  }
  v5 = (unsigned __int8 *)&v13;
  usleep((__useconds_t)&loc_493DE + 2);
  do
    *++v5 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( v5 != &read_back_data[19] );
  pthread_mutex_unlock(&i2c_mutex);
  v6 = read_back_data[1];
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\tre"
      "ad_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_bac"
      "k_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x, \t\tread_back_da"
      "ta[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x, \t\tread_back_data"
      "[16] = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
      "read_PIC16F1704_flash_data_new",
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4],
      read_back_data[5],
      read_back_data[6],
      read_back_data[7],
      read_back_data[8],
      read_back_data[9],
      read_back_data[10],
      read_back_data[11],
      read_back_data[12],
      read_back_data[13],
      read_back_data[14],
      read_back_data[15],
      read_back_data[16],
      read_back_data[17],
      read_back_data[18],
      read_back_data[19]);
    applog(5, tmp42, 0);
    usleep(0x186A0u);
    if ( v6 != 3 )
      goto LABEL_9;
  }
  else
  {
    usleep(0x186A0u);
    if ( v6 != 3 )
      goto LABEL_9;
  }
  if ( read_back_data[0] != 20 )
  {
LABEL_9:
    if ( !use_syslog )
    {
      result = opt_log_output;
      if ( !opt_log_output && opt_log_level <= 2 )
        return result;
    }
    snprintf(tmp42, 0x1000u, "%s chain %d failed!", "read_PIC16F1704_flash_data_new", i2c_slave_addr);
    goto LABEL_13;
  }
  v8 = read_back_data[2];
  if ( read_back_data[18] != (unsigned __int16)(read_back_data[17]
                                              + read_back_data[16]
                                              + read_back_data[15]
                                              + read_back_data[14]
                                              + read_back_data[13]
                                              + read_back_data[12]
                                              + read_back_data[11]
                                              + read_back_data[10]
                                              + read_back_data[9]
                                              + read_back_data[8]
                                              + read_back_data[7]
                                              + read_back_data[6]
                                              + read_back_data[3]
                                              + read_back_data[2]
                                              + 23
                                              + read_back_data[4]
                                              + read_back_data[5]) >> 8
    || read_back_data[19] != (unsigned __int8)(read_back_data[17]
                                             + read_back_data[16]
                                             + read_back_data[15]
                                             + read_back_data[14]
                                             + read_back_data[13]
                                             + read_back_data[12]
                                             + read_back_data[11]
                                             + read_back_data[10]
                                             + read_back_data[9]
                                             + read_back_data[8]
                                             + read_back_data[7]
                                             + read_back_data[6]
                                             + read_back_data[3]
                                             + read_back_data[2]
                                             + 23
                                             + read_back_data[4]
                                             + read_back_data[5]) )
  {
    if ( !use_syslog )
    {
      result = opt_log_output;
      if ( !opt_log_output && opt_log_level <= 2 )
        return result;
    }
    snprintf(
      tmp42,
      0x1000u,
      "%s failed! crc = 0x%04x\n\n",
      "read_PIC16F1704_flash_data_new",
      (unsigned __int16)(read_back_data[17]
                       + read_back_data[16]
                       + read_back_data[15]
                       + read_back_data[14]
                       + read_back_data[13]
                       + read_back_data[12]
                       + read_back_data[11]
                       + read_back_data[10]
                       + read_back_data[9]
                       + read_back_data[8]
                       + read_back_data[7]
                       + read_back_data[6]
                       + read_back_data[3]
                       + read_back_data[2]
                       + 23
                       + read_back_data[4]
                       + read_back_data[5]));
LABEL_13:
    applog(3, tmp42, 0);
    return 0;
  }
  v9 = buf - 1;
  for ( j = &read_back_data[3]; ; ++j )
  {
    *++v9 = v8;
    if ( &read_back_data[18] == j )
      break;
    v11 = *j;
    v8 = v11;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return 1;
  snprintf(tmp42, 0x1000u, "%s ok", "read_PIC16F1704_flash_data_new");
  applog(5, tmp42, 0);
  return 1;
}

//----- (00036280) --------------------------------------------------------
bool erase_PIC16F1704_flash_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  int v3; // r4
  int v4; // r6
  bool v5; // zf
  _BOOL4 result; // r0
  unsigned __int8 send_data[6]; // [sp+10h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)send_data = 67414613;
  send_data[4] = 0;
  send_data[5] = 8;
  v0 = send_data;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v0 )
      break;
    v2 = *++v0;
  }
  usleep(0x186A0u);
  v3 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  v5 = v4 == 1;
  if ( v4 == 1 )
    v5 = v3 == 4;
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "erase_PIC16F1704_flash_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "erase_PIC16F1704_flash_new",
      i2c_slave_addr,
      v3,
      v4);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (000363B8) --------------------------------------------------------
bool write_data_into_PIC16F1704_flash_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  int v3; // r4
  int v4; // r6
  bool v5; // zf
  _BOOL4 result; // r0
  unsigned __int8 send_data[6]; // [sp+10h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)send_data = 84191829;
  send_data[4] = 0;
  send_data[5] = 9;
  v0 = send_data;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v0 )
      break;
    v2 = *++v0;
  }
  usleep(0x30D40u);
  v3 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  v5 = v4 == 1;
  if ( v4 == 1 )
    v5 = v3 == 5;
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok\n\n", "write_data_into_PIC16F1704_flash_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_data_into_PIC16F1704_flash_new",
      i2c_slave_addr,
      v3,
      v4);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (000364F0) --------------------------------------------------------
bool jump_from_loader_to_app_PIC16F1704_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  int v3; // r4
  int v4; // r6
  bool v5; // zf
  _BOOL4 result; // r0
  unsigned __int8 send_data[6]; // [sp+10h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)send_data = 100969045;
  send_data[4] = 0;
  send_data[5] = 10;
  v0 = send_data;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v0 )
      break;
    v2 = *++v0;
  }
  usleep(0x186A0u);
  v3 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x493E0u);
  v5 = v4 == 1;
  if ( v4 == 1 )
    v5 = v3 == 6;
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "jump_from_loader_to_app_PIC16F1704_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "jump_from_loader_to_app_PIC16F1704_new",
      i2c_slave_addr,
      v3,
      v4);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00036628) --------------------------------------------------------
bool reset_PIC16F1704_pic_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  int v3; // r4
  int v4; // r6
  bool v5; // zf
  _BOOL4 result; // r0
  unsigned __int8 send_data[6]; // [sp+10h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)send_data = 117746261;
  send_data[4] = 0;
  send_data[5] = 11;
  v0 = send_data;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v0 )
      break;
    v2 = *++v0;
  }
  usleep(0x186A0u);
  v3 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0xF4240u);
  v5 = v4 == 1;
  if ( v4 == 1 )
    v5 = v3 == 7;
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "reset_PIC16F1704_pic_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "reset_PIC16F1704_pic_new",
      i2c_slave_addr,
      v3,
      v4);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00036760) --------------------------------------------------------
int __fastcall PIC16F1704_i2c_forward_send(uint8_t dev_addr, int rw_flag, uint8_t reg_addr, int len, uint8_t *data)
{
  uint8_t v7; // r4
  int v8; // r4
  __int16 v9; // r3
  int v10; // r6
  int v11; // r2
  uint8_t *v12; // r1
  int v13; // r5
  __int16 v14; // t1
  uint8_t *v15; // r10
  int v16; // r6
  int v17; // r3
  int v18; // r4
  int v19; // t1
  uint8_t *v20; // r7
  int v21; // r6
  int v22; // r0
  _BOOL4 v23; // r5
  int v24; // r3
  uint8_t *v25; // r2
  __int16 v26; // t1
  int v28; // [sp+Ch] [bp-1050h]
  int v30; // [sp+18h] [bp-1044h]
  int v31; // [sp+1Ch] [bp-1040h]
  uint8_t recv_data[12]; // [sp+2Ch] [bp-1030h] BYREF
  uint8_t send_data[32]; // [sp+38h] [bp-1024h] BYREF
  char tmp42[4100]; // [sp+58h] [bp-1004h] BYREF

  v7 = rw_flag | (2 * dev_addr);
  memset(&send_data[2], 0, 0x1Eu);
  send_data[5] = reg_addr;
  send_data[4] = v7;
  *(_WORD *)send_data = -21931;
  send_data[3] = 38;
  memset(recv_data, 0, sizeof(recv_data));
  if ( rw_flag )
  {
    v8 = 8;
    v9 = 7;
    v10 = 5;
    v31 = 7;
    send_data[6] = len;
    send_data[2] = 7;
LABEL_3:
    v11 = 0;
    v12 = &send_data[2];
    LOWORD(v13) = 0;
    while ( 1 )
    {
      ++v11;
      v13 = (unsigned __int16)(v13 + v9);
      if ( v10 <= v11 )
        break;
      v14 = *++v12;
      v9 = v14;
    }
    send_data[v31] = BYTE1(v13);
    send_data[v8] = v13;
    pthread_mutex_lock(&i2c_mutex);
    if ( v8 < 0 )
      goto LABEL_13;
    goto LABEL_7;
  }
  v10 = len + 4;
  memcpy(&send_data[6], data, len);
  v9 = (unsigned __int8)(len + 6);
  v8 = len + 7;
  v31 = len + 6;
  send_data[2] = len + 6;
  if ( len + 4 > 0 )
    goto LABEL_3;
  send_data[len + 6] = rw_flag;
  send_data[v8] = rw_flag;
  pthread_mutex_lock(&i2c_mutex);
  if ( v8 < 0 )
  {
    usleep(0x30D40u);
    goto LABEL_30;
  }
  v13 = rw_flag;
LABEL_7:
  v15 = send_data;
  v16 = 0;
  v28 = v8 + 1;
  do
  {
    v17 = v16++;
    v19 = *v15++;
    v18 = v19;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "write pic i2c[%d] %02x\n", v17, v18);
      applog(5, tmp42, 0);
    }
    i2c_write(v18 | (i2c_slave_addr << 16) | 0xA00000);
  }
  while ( v16 != v28 );
LABEL_13:
  usleep(0x30D40u);
  if ( rw_flag != 1 )
  {
LABEL_30:
    pthread_mutex_unlock(&i2c_mutex);
    return 0;
  }
  if ( len >= -4 )
  {
    v20 = recv_data;
    v21 = 0;
    v30 = v13;
    do
    {
      v22 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
      v23 = use_syslog;
      v24 = v21++;
      *v20++ = v22;
      if ( v23 || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "read pic i2c[%d] %02x\n", v24, v22);
        applog(5, tmp42, 0);
      }
    }
    while ( v21 != len + 5 );
    v13 = v30;
  }
  if ( len >= -2 )
  {
    v25 = recv_data;
    do
    {
      v26 = *v25++;
      v13 = (unsigned __int16)(v13 + v26);
    }
    while ( v25 != &recv_data[len + 3] );
  }
  if ( *(unsigned __int16 *)&recv_data[len + 3] == v13 )
  {
    if ( recv_data[0] == v31 && recv_data[1] == 38 && recv_data[2] == 1 )
    {
      memcpy(data, &recv_data[3], len);
      goto LABEL_30;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "pic read failed %d %d %d\n", *data, data[1], data[2]);
      applog(5, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "crc failed 0x%x\n", v13);
    applog(5, tmp42, 0);
  }
  pthread_mutex_unlock(&i2c_mutex);
  return -1;
}

//----- (00036A70) --------------------------------------------------------
int __fastcall ISL_get_voltage(uint8_t i2c_dev_addr, uint16_t *voltage)
{
  uint8_t vol[8]; // [sp+4h] [bp-8h] BYREF

  *(_WORD *)vol = 0;
  read_dc_dc(i2c_dev_addr, 0x21u, vol, 2);
  *voltage = vol[0] | (vol[1] << 8);
  return 0;
}

//----- (00036A9C) --------------------------------------------------------
void __fastcall every_asic_get_isl_voltage(int which_chain)
{
  uint8_t *v1; // r6
  unsigned __int16 *v3; // r5
  int i; // r4
  uint8_t v5; // t1
  _BOOL4 v6; // r7
  int v7; // r12
  unsigned __int16 vol; // [sp+16h] [bp-1006h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  v1 = isl_dev_addr;
  v3 = &isl_vol[which_chain - 1][2];
  for ( i = 0; i != 3; ++i )
  {
    v5 = *v1++;
    vol = 0;
    ISL_get_voltage(v5, &vol);
    v6 = use_syslog;
    v7 = vol;
    v3[1] = vol;
    ++v3;
    if ( v6 || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "chain %d asic = %d vol=%u\n", which_chain, i, v7);
      applog(5, tmp42, 0);
    }
  }
}

//----- (00036B3C) --------------------------------------------------------
void every_chain_get_isl_voltage()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1

  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      every_asic_get_isl_voltage(i);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00036B7C) --------------------------------------------------------
int __fastcall ISL_set_i2c_data(uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len)
{
  uint8_t *chain_exist; // r5
  int v5; // r4
  int v6; // t1
  unsigned __int8 *v7; // r9
  int v8; // r6
  uint8_t v9; // t1
  int result; // r0
  uint8_t reg[4]; // [sp+20h] [bp-1014h]
  char tmp42[4100]; // [sp+30h] [bp-1004h] BYREF

  chain_exist = dev.chain_exist;
  v5 = 0;
  *(_DWORD *)reg = i2c_reg_addr;
  do
  {
    v6 = *chain_exist++;
    if ( v6 == 1 )
    {
      v7 = isl_dev_addr;
      v8 = 0;
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = v5;
      do
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            tmp42,
            0x1000u,
            "chain%d asic%d, set data slave:%02x addr:%02x %02x %02x, len=%d\n",
            v5,
            v8,
            *v7,
            *(_DWORD *)reg,
            *i2c_reg_data,
            i2c_reg_data[1],
            len);
          applog(5, tmp42, 0);
        }
        v9 = *v7++;
        write_dc_dc(v9, reg[0], i2c_reg_data, len);
        ++v8;
        cgsleep_ms(200);
      }
      while ( v8 != 3 );
      *(_DWORD *)&i2c_reg_addr = pthread_mutex_unlock(&iic_mutex);
    }
    ++v5;
  }
  while ( v5 != 4 );
  LOBYTE(result) = i2c_reg_addr;
  return result;
}

//----- (00036C64) --------------------------------------------------------
int __fastcall ISL_get_i2c_data(uint8_t i2c_reg_addr, uint8_t *i2c_reg_data, int len)
{
  uint8_t *chain_exist; // r5
  int v5; // r4
  int v6; // t1
  int v7; // r6
  int result; // r0
  uint8_t reg[4]; // [sp+1Ch] [bp-1018h]
  char tmp42[4100]; // [sp+30h] [bp-1004h] BYREF

  chain_exist = dev.chain_exist;
  v5 = 0;
  *(_DWORD *)reg = i2c_reg_addr;
  do
  {
    v6 = *chain_exist++;
    if ( v6 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      v7 = 0;
      i2c_slave_addr = v5;
      do
      {
        read_dc_dc(isl_dev_addr[v7], reg[0], i2c_reg_data, len);
        if ( len == 1 )
        {
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "chain%d asic%d, slave:%02x, addr:%02x %02x\n",
              v5,
              v7,
              isl_dev_addr[v7],
              *(_DWORD *)reg,
              *i2c_reg_data);
            applog(5, tmp42, 0);
          }
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(
            tmp42,
            0x1000u,
            "chain%d asic%d, slave:%02x, addr:%02x %02x %02x\n",
            v5,
            v7,
            isl_dev_addr[v7],
            *(_DWORD *)reg,
            *i2c_reg_data,
            i2c_reg_data[1]);
          applog(5, tmp42, 0);
        }
        ++v7;
        cgsleep_ms(200);
      }
      while ( v7 != 3 );
      *(_DWORD *)&i2c_reg_addr = pthread_mutex_unlock(&iic_mutex);
    }
    ++v5;
  }
  while ( v5 != 4 );
  LOBYTE(result) = i2c_reg_addr;
  return result;
}

//----- (00036D90) --------------------------------------------------------
int __fastcall XDPED_update_asics_vol(uint32_t vol)
{
  char reg_data[4]; // [sp+Ch] [bp-1008h] BYREF
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  *(_DWORD *)reg_data = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "xdped set voltage to %d\n", vol);
    applog(5, tmp42, 0);
  }
  reg_data[0] = 32;
  ISL_set_i2c_data(0, (uint8_t *)reg_data, 1);
  sleep(1u);
  reg_data[1] = 64;
  reg_data[0] = (unsigned int)(((double)vol / 1000.0 - 0.25) / 0.005 + 1.0);
  return ISL_set_i2c_data(0x13u, (uint8_t *)reg_data, 2);
}

//----- (00036E60) --------------------------------------------------------
uint16_t __fastcall ISL_set_voltage_dynamic(uint8_t i2c_dev_addr, uint16_t vol)
{
  int v3; // r5
  uint16_t v4; // r6
  int v6; // [sp+8h] [bp-101Ch]
  uint8_t v7; // [sp+Ch] [bp-1018h]
  int v8; // [sp+10h] [bp-1014h]
  int v9; // [sp+14h] [bp-1010h]
  uint8_t which_page; // [sp+1Bh] [bp-1009h] BYREF
  uint8_t cmd[2]; // [sp+1Ch] [bp-1008h] BYREF
  uint16_t r_voltage; // [sp+1Eh] [bp-1006h] BYREF
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  if ( (unsigned int)(vol - 700) > 0x64 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      v3 = 700;
      snprintf(tmp42, 0x1000u, "illegal voltage [%d, %d], set default voltage %d\n", 700, 800, 700);
      applog(5, tmp42, 0);
      LOBYTE(v8) = 2;
      v9 = 704;
      v7 = -68;
    }
    else
    {
      LOBYTE(v8) = 2;
      v9 = 704;
      v7 = -68;
      v3 = 700;
    }
  }
  else
  {
    v3 = vol;
    v7 = vol;
    v8 = HIBYTE(vol);
    v9 = vol + 4;
  }
  r_voltage = 0;
  LOBYTE(v6) = 4;
  while ( 1 )
  {
    which_page = -1;
    write_dc_dc(i2c_dev_addr, 0, &which_page, 1);
    cgsleep_ms(100);
    cmd[0] = v7;
    cmd[1] = v8;
    write_dc_dc(i2c_dev_addr, 0x21u, cmd, 2);
    cgsleep_ms(200);
    ISL_get_voltage(i2c_dev_addr, &r_voltage);
    v4 = r_voltage;
    if ( r_voltage <= v9 && r_voltage >= v3 - 4 )
      break;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "set vol %d, get vol %d, set again!\n", v3, r_voltage);
      applog(5, tmp42, 0);
    }
    cgsleep_ms(200);
    v6 = (unsigned __int8)(v6 - 1);
    if ( !v6 )
      return r_voltage;
  }
  return v4;
}

//----- (00036FE0) --------------------------------------------------------
uint16_t __fastcall ISL_set_voltage(uint8_t i2c_dev_addr, uint16_t voltage)
{
  uint16_t v2; // r3
  int v6; // r4
  uint8_t which_page; // [sp+9h] [bp-1007h] BYREF
  uint8_t config; // [sp+Ah] [bp-1006h] BYREF
  uint8_t oper; // [sp+Bh] [bp-1005h] BYREF
  uint8_t cmd[4]; // [sp+Ch] [bp-1004h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( (unsigned int)(voltage - 700) <= 0x64 )
  {
    which_page = -1;
    write_dc_dc(i2c_dev_addr, 0, &which_page, 1);
    config = 26;
    write_dc_dc(i2c_dev_addr, 2u, &config, 1);
    cgsleep_ms(100);
    oper = 64;
    LOBYTE(v6) = 5;
    write_dc_dc(i2c_dev_addr, 1u, &oper, 1);
    cgsleep_ms(100);
    *(_WORD *)cmd = voltage;
    write_dc_dc(i2c_dev_addr, 0x21u, cmd, 2);
    cgsleep_ms(100);
    oper = 0x80;
    write_dc_dc(i2c_dev_addr, 1u, &oper, 1);
    cgsleep_ms(100);
    *(_WORD *)tmp42 = 0;
    cgsleep_ms(200);
    ISL_get_voltage(i2c_dev_addr, (uint16_t *)tmp42);
    while ( 1 )
    {
      v2 = *(_WORD *)tmp42;
      if ( *(_WORD *)tmp42 )
        break;
      cgsleep_ms(200);
      ISL_get_voltage(i2c_dev_addr, (uint16_t *)tmp42);
      v6 = (unsigned __int8)(v6 - 1);
      if ( !v6 )
        return *(_WORD *)tmp42;
    }
  }
  else if ( use_syslog || (v2 = opt_log_output) != 0 || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "illegal voltage [%d, %d]\n", 700, 800);
    applog(5, tmp42, 0);
    return 0;
  }
  return v2;
}

//----- (0003710C) --------------------------------------------------------
void __fastcall every_asic_set_isl_voltage(int which_chain)
{
  uint8_t *v1; // r6
  int v3; // r4
  uint8_t v4; // t1
  int v5; // r7
  uint16_t v6; // r1
  int v7; // lr
  unsigned __int16 *v8; // [sp+18h] [bp-100Ch]
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  v1 = isl_dev_addr;
  v3 = 0;
  v8 = &isl_vol[which_chain - 1][2];
  do
  {
    v4 = *v1++;
    v5 = v8[1];
    v6 = v8[1];
    ++v8;
    v7 = ISL_set_voltage_dynamic(v4, v6);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "chain%d asic%d addr %02x, %s set vol %d, get vol %d",
        which_chain,
        v3,
        *(v1 - 1),
        "every_asic_set_isl_voltage",
        v5,
        v7);
      applog(5, tmp42, 0);
    }
    ++v3;
    cgsleep_ms(200);
  }
  while ( v3 != 3 );
}

//----- (000371CC) --------------------------------------------------------
void every_chain_set_isl_voltage()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1

  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      every_asic_set_isl_voltage(i);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00037210) --------------------------------------------------------
void __fastcall update_asic_vol(int which_chain, int which_asic, int vol)
{
  uint8_t v6; // r0
  unsigned __int16 g_vol; // [sp+6h] [bp-2h] BYREF

  pthread_mutex_lock(&iic_mutex);
  v6 = *((_BYTE *)&bitmainZCASH_drv + which_asic + 128);
  g_vol = 0;
  i2c_slave_addr = which_chain;
  ISL_get_voltage(v6, &g_vol);
  if ( g_vol > vol + 5 || g_vol < vol - 5 )
  {
    ISL_set_voltage_dynamic(*((_BYTE *)&bitmainZCASH_drv + which_asic + 128), vol);
    cgsleep_ms(200);
  }
  pthread_mutex_unlock(&iic_mutex);
}

//----- (0003727C) --------------------------------------------------------
void __fastcall update_asics_vol(int vol)
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v4; // t1
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "isl set voltage to %d\n", vol);
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
    {
      update_asic_vol(i, 0, vol);
      update_asic_vol(i, 1, vol);
      update_asic_vol(i, 2, vol);
    }
  }
}

//----- (0003730C) --------------------------------------------------------
void __fastcall update_asics_voltage(int vol)
{
  char reg_data[4]; // [sp+4h] [bp-4h] BYREF

  *(_DWORD *)reg_data = 0;
  ISL_get_i2c_data(0, (uint8_t *)reg_data, 1);
  if ( (unsigned __int8)(reg_data[0] - 2) > 0xFCu )
    update_asics_vol(vol);
  else
    XDPED_update_asics_vol(vol);
  sleep(1u);
}

//----- (0003734C) --------------------------------------------------------
void __fastcall init_vol_table(unsigned __int16 vol)
{
  pthread_mutex_t *v1; // r3

  v1 = (pthread_mutex_t *)isl_vol;
  do
  {
    LOWORD(v1->__data.__lock) = vol;
    v1 = (pthread_mutex_t *)((char *)v1 + 6);
    *((_WORD *)&v1[-1].__align + 10) = vol;
    *((_WORD *)&v1[-1].__align + 11) = vol;
  }
  while ( v1 != &iic_mutex );
}

//----- (00037368) --------------------------------------------------------
void dump_vol_table()
{
  unsigned __int16 *v0; // r6
  int i; // r5
  int j; // r4
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v0 = isl_vol[0];
  for ( i = 0; i != 4; ++i )
  {
    for ( j = 0; j != 3; ++j )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "chain %d asic %d vol %d\n", i, j, v0[j]);
        applog(5, tmp42, 0);
      }
    }
    v0 += 3;
  }
}

//----- (000373E8) --------------------------------------------------------
int __fastcall set_PIC16F1704_voltage_new(unsigned __int8 voltage)
{
  int v1; // r7
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  int v5; // r4
  int v6; // r6
  bool v7; // zf
  int result; // r0
  unsigned __int8 send_data[7]; // [sp+10h] [bp-100Ch] BYREF
  char v10; // [sp+17h] [bp-1005h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  v1 = voltage;
  send_data[6] = voltage + 21;
  *(_DWORD *)send_data = 268806741;
  send_data[5] = (unsigned __int16)(voltage + 21) >> 8;
  send_data[4] = voltage;
  pthread_mutex_lock(&i2c_mutex);
  v2 = &send_data[1];
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &v10 == (char *)v2 )
      break;
    v4 = *v2++;
  }
  usleep(0x30D40u);
  v5 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v6 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  v7 = v6 == 1;
  if ( v6 == 1 )
    v7 = v5 == 16;
  if ( v7 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok, voltage = 0x%02x", "set_PIC16F1704_voltage_new", v1);
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_voltage_new",
      i2c_slave_addr,
      v5,
      v6);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (0003752C) --------------------------------------------------------
int __fastcall write_hash_ID_PIC16F1704_new(unsigned __int8 *buf)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r0
  unsigned __int8 *v3; // r2
  __int16 v4; // r3
  __int16 v5; // t1
  unsigned __int8 *v6; // r0
  unsigned __int8 v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // t1
  int v10; // r4
  int v11; // r6
  bool v12; // zf
  int result; // r0
  char v14; // [sp+13h] [bp-1015h] BYREF
  unsigned __int8 send_data[18]; // [sp+14h] [bp-1014h] BYREF
  char tmp42[4096]; // [sp+28h] [bp-1000h] BYREF

  v1 = buf - 1;
  v2 = buf + 11;
  v3 = v1;
  v4 = 34;
  memset(&send_data[4], 0, 12);
  do
  {
    v5 = *++v3;
    v4 += v5;
  }
  while ( v2 != v3 );
  v6 = &send_data[3];
  *(_DWORD *)send_data = 303082069;
  do
  {
    v7 = *++v1;
    *++v6 = v7;
  }
  while ( v1 != v3 );
  send_data[16] = HIBYTE(v4);
  v8 = (unsigned __int8 *)&v14;
  send_data[17] = v4;
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v9 = *++v8;
    i2c_write(v9 | (i2c_slave_addr << 16) | 0xA00000);
  }
  while ( &send_data[17] != v8 );
  usleep(0x30D40u);
  v10 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v11 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  v12 = v11 == 1;
  if ( v11 == 1 )
    v12 = v10 == 18;
  if ( v12 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "write_hash_ID_PIC16F1704_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_hash_ID_PIC16F1704_new",
      i2c_slave_addr,
      v10,
      v11);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00037690) --------------------------------------------------------
int __fastcall read_hash_id_PIC16F1704_new(unsigned __int8 *buf)
{
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r6
  int v7; // r8
  unsigned __int8 v9; // r2
  unsigned __int8 *v10; // r3
  unsigned __int8 *v11; // r1
  unsigned __int8 *v12; // r7
  unsigned __int8 v13; // t1
  unsigned __int8 send_data[6]; // [sp+40h] [bp-1018h] BYREF
  char v15; // [sp+47h] [bp-1011h] BYREF
  unsigned __int8 read_back_data[16]; // [sp+48h] [bp-1010h] BYREF
  char tmp42[4096]; // [sp+58h] [bp-1000h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  v2 = send_data;
  memset(&read_back_data[4], 0, 12);
  *(_DWORD *)send_data = 319072853;
  send_data[5] = 23;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v2 )
      break;
    v4 = *++v2;
  }
  v5 = (unsigned __int8 *)&v15;
  usleep((__useconds_t)&loc_30D3E + 2);
  do
    *++v5 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( v5 != &read_back_data[15] );
  pthread_mutex_unlock(&i2c_mutex);
  v6 = read_back_data[1];
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
  {
    if ( read_back_data[1] != 19 )
    {
LABEL_11:
      if ( opt_log_level <= 2 )
        return 0;
      goto LABEL_12;
    }
    if ( read_back_data[0] == 16 )
      goto LABEL_18;
LABEL_10:
    if ( !opt_log_output )
      goto LABEL_11;
LABEL_12:
    snprintf(tmp42, 0x1000u, aSChainDFailed_0, "read_hash_id_PIC16F1704_new", i2c_slave_addr);
LABEL_13:
    applog(3, tmp42, 0);
    return 0;
  }
  v7 = read_back_data[0];
  snprintf(
    tmp42,
    0x1000u,
    "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,\t\tread_"
    "back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,\t\tread_back_data"
    "[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,\t\tread_back_data[12] = "
    "0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
    "read_hash_id_PIC16F1704_new",
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5],
    read_back_data[6],
    read_back_data[7],
    read_back_data[8],
    read_back_data[9],
    read_back_data[10],
    read_back_data[11],
    read_back_data[12],
    read_back_data[13],
    read_back_data[14],
    read_back_data[15]);
  applog(5, tmp42, 0);
  if ( v6 != 19 || v7 != 16 )
  {
    if ( use_syslog )
      goto LABEL_12;
    goto LABEL_10;
  }
LABEL_18:
  v9 = read_back_data[2];
  if ( read_back_data[14] != (unsigned __int16)(read_back_data[13]
                                              + read_back_data[12]
                                              + read_back_data[11]
                                              + read_back_data[10]
                                              + read_back_data[9]
                                              + read_back_data[8]
                                              + read_back_data[7]
                                              + read_back_data[6]
                                              + read_back_data[3]
                                              + read_back_data[2]
                                              + 35
                                              + read_back_data[4]
                                              + read_back_data[5]) >> 8
    || read_back_data[15] != (unsigned __int8)(read_back_data[13]
                                             + read_back_data[12]
                                             + read_back_data[11]
                                             + read_back_data[10]
                                             + read_back_data[9]
                                             + read_back_data[8]
                                             + read_back_data[7]
                                             + read_back_data[6]
                                             + read_back_data[3]
                                             + read_back_data[2]
                                             + 35
                                             + read_back_data[4]
                                             + read_back_data[5]) )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(
      tmp42,
      0x1000u,
      "%s failed! crc = 0x%04x",
      "read_hash_id_PIC16F1704_new",
      (unsigned __int16)(read_back_data[13]
                       + read_back_data[12]
                       + read_back_data[11]
                       + read_back_data[10]
                       + read_back_data[9]
                       + read_back_data[8]
                       + read_back_data[7]
                       + read_back_data[6]
                       + read_back_data[3]
                       + read_back_data[2]
                       + 35
                       + read_back_data[4]
                       + read_back_data[5]));
    goto LABEL_13;
  }
  v10 = buf - 1;
  v11 = &read_back_data[2];
  v12 = buf + 11;
  while ( 1 )
  {
    *++v10 = v9;
    if ( v12 == v10 )
      break;
    v13 = *++v11;
    v9 = v13;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return 1;
  snprintf(tmp42, 0x1000u, "%s ok", "read_hash_id_PIC16F1704_new");
  applog(5, tmp42, 0);
  return 1;
}

//----- (00037934) --------------------------------------------------------
bool enable_PIC16F1704_dc_dc_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  int v3; // r4
  int v4; // r6
  bool v5; // zf
  _BOOL4 result; // r0
  unsigned __int8 send_data[7]; // [sp+10h] [bp-1008h] BYREF
  char v8; // [sp+17h] [bp-1001h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  send_data[5] = 0;
  *(_DWORD *)send_data = 352692821;
  send_data[4] = 1;
  send_data[6] = 27;
  v0 = &send_data[1];
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &v8 == (char *)v0 )
      break;
    v2 = *v0++;
  }
  usleep(0x186A0u);
  v3 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  v5 = v4 == 1;
  if ( v4 == 1 )
    v5 = v3 == 21;
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "enable_PIC16F1704_dc_dc_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "enable_PIC16F1704_dc_dc_new",
      i2c_slave_addr,
      v3,
      v4);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00037A68) --------------------------------------------------------
bool disable_PIC16F1704_dc_dc_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  int v3; // r4
  int v4; // r6
  bool v5; // zf
  _BOOL4 result; // r0
  unsigned __int8 send_data[7]; // [sp+10h] [bp-1008h] BYREF
  char v8; // [sp+17h] [bp-1001h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)send_data = 352692821;
  *(_WORD *)&send_data[4] = 0;
  v0 = &send_data[1];
  send_data[6] = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &v8 == (char *)v0 )
      break;
    v2 = *v0++;
  }
  usleep(0x186A0u);
  v3 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  v5 = v4 == 1;
  if ( v4 == 1 )
    v5 = v3 == 21;
  if ( v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "disable_PIC16F1704_dc_dc_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chain %d failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "disable_PIC16F1704_dc_dc_new",
      i2c_slave_addr,
      v3,
      v4);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00037B98) --------------------------------------------------------
int heart_beat_PIC16F1704_new()
{
  unsigned __int8 *v0; // r4
  int i; // r3
  int v2; // t1
  unsigned __int8 *v3; // r4
  int v4; // r6
  int result; // r0
  unsigned __int8 read_back_data[6]; // [sp+18h] [bp-1010h] BYREF
  char v7; // [sp+1Eh] [bp-100Ah] BYREF
  unsigned __int8 send_data[6]; // [sp+20h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+28h] [bp-1000h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  *(_WORD *)&read_back_data[4] = 0;
  v0 = send_data;
  *(_DWORD *)send_data = 369404501;
  send_data[5] = 26;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v2 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v0 )
      break;
    v2 = *++v0;
  }
  v3 = read_back_data;
  usleep((__useconds_t)&loc_1869E + 2);
  do
    *v3++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( &v7 != (char *)v3 );
  pthread_mutex_unlock(&i2c_mutex);
  v4 = read_back_data[1];
  if ( read_back_data[1] == 22 && (result = read_back_data[2], read_back_data[2] == 1) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "heart_beat_PIC16F1704_new");
      applog(7, tmp42, 0);
      return 1;
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "%s chain %d failed!", "heart_beat_PIC16F1704_new", i2c_slave_addr);
    applog(3, tmp42, 0);
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
        "heart_beat_PIC16F1704_new",
        read_back_data[0],
        v4,
        read_back_data[2],
        read_back_data[3],
        read_back_data[4],
        read_back_data[5]);
      applog(3, tmp42, 0);
      return 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

//----- (00037D5C) --------------------------------------------------------
void *__fastcall __noreturn pic_heart_beat_func_new(void *arg)
{
  uint8_t *chain_exist; // r5
  int v2; // r4
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "pic_heart_beat_func_new");
    applog(5, tmp42, 0);
  }
  while ( 1 )
  {
    chain_exist = dev.chain_exist;
    v2 = 0;
    sleep(0xAu);
    do
    {
      if ( *chain_exist++ )
      {
        if ( send_heart )
        {
          pthread_mutex_lock(&iic_mutex);
          i2c_slave_addr = v2;
          heart_beat_PIC16F1704_new();
          cgsleep_ms(100);
          pthread_mutex_unlock(&iic_mutex);
        }
      }
      ++v2;
    }
    while ( v2 != 4 );
  }
}

//----- (00037DFC) --------------------------------------------------------
int __fastcall get_PIC16F1704_software_version_new(unsigned __int8 *version)
{
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r7
  unsigned __int16 v7; // r3
  unsigned __int8 read_back_data[5]; // [sp+18h] [bp-Dh] BYREF
  _BYTE v10[3]; // [sp+1Dh] [bp-8h] BYREF
  unsigned __int8 send_data[6]; // [sp+20h] [bp-5h] BYREF
  char tmp42[4100]; // [sp+28h] [bp+3h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  v2 = send_data;
  read_back_data[4] = 0;
  *(_DWORD *)send_data = 386181717;
  send_data[5] = 27;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v2 )
      break;
    v4 = *++v2;
  }
  v5 = read_back_data;
  usleep(0x61A80u);
  do
    *v5++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( v10 != v5 );
  pthread_mutex_unlock(&i2c_mutex);
  v6 = read_back_data[1];
  if ( opt_debug )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 6 )
    {
      if ( read_back_data[1] != 23 )
        goto LABEL_26;
      if ( read_back_data[0] == 5 )
        goto LABEL_12;
LABEL_20:
      if ( opt_log_output )
      {
LABEL_21:
        snprintf(tmp42, 0x1000u, "%s chain %d failed!", "get_PIC16F1704_software_version_new", i2c_slave_addr);
        applog(3, tmp42, 0);
        if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
          return 0;
        snprintf(
          tmp42,
          0x1000u,
          "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, re"
          "ad_back_data[4] = 0x%x",
          "get_PIC16F1704_software_version_new",
          read_back_data[0],
          v6,
          read_back_data[2],
          read_back_data[3],
          read_back_data[4]);
LABEL_24:
        applog(3, tmp42, 0);
        return 0;
      }
LABEL_26:
      if ( opt_log_level <= 2 )
        return 0;
      goto LABEL_21;
    }
    snprintf(
      tmp42,
      0x1000u,
      "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_b"
      "ack_data[4] = 0x%x",
      "get_PIC16F1704_software_version_new",
      read_back_data[0],
      read_back_data[1],
      read_back_data[2],
      read_back_data[3],
      read_back_data[4]);
    applog(7, tmp42, 0);
  }
  if ( v6 != 23 || read_back_data[0] != 5 )
  {
    if ( use_syslog )
      goto LABEL_21;
    goto LABEL_20;
  }
LABEL_12:
  v7 = read_back_data[2] + 28;
  if ( read_back_data[3] != HIBYTE(v7) || read_back_data[4] != (unsigned __int8)v7 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(tmp42, 0x1000u, "%s failed! crc = 0x%04x", "get_PIC16F1704_software_version_new", v7);
    goto LABEL_24;
  }
  *version = read_back_data[2];
  return 1;
}

//----- (0003803C) --------------------------------------------------------
void every_chain_get_pic_version()
{
  uint8_t *chain_exist; // r5
  int v1; // r4
  int v2; // t1
  int PIC16F1704_software_version_new; // r9
  unsigned __int8 version[4]; // [sp+Ch] [bp-1008h] BYREF
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  chain_exist = dev.chain_exist;
  v1 = 0;
  *(_DWORD *)version = 0;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = v1;
      PIC16F1704_software_version_new = get_PIC16F1704_software_version_new(&version[v1]);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
      if ( PIC16F1704_software_version_new == 1 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(tmp42, 0x1000u, "chain%d pic version %02x\n", v1, version[v1]);
          applog(5, tmp42, 0);
        }
      }
      else if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "chain%d pic version read failed\n", v1);
        applog(5, tmp42, 0);
      }
    }
    ++v1;
  }
  while ( v1 != 4 );
}

//----- (0003812C) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage_new(unsigned __int8 *voltage)
{
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r7
  int v7; // r8
  int v9; // r0
  unsigned __int16 v10; // r3
  unsigned __int8 read_back_data[5]; // [sp+18h] [bp-Dh] BYREF
  _BYTE v12[3]; // [sp+1Dh] [bp-8h] BYREF
  unsigned __int8 send_data[6]; // [sp+20h] [bp-5h] BYREF
  char tmp42[4096]; // [sp+28h] [bp+3h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  v2 = send_data;
  read_back_data[4] = 0;
  *(_DWORD *)send_data = 402958933;
  send_data[5] = 28;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v2 )
      break;
    v4 = *++v2;
  }
  v5 = read_back_data;
  usleep((__useconds_t)&loc_30D3E + 2);
  do
    *v5++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( v12 != v5 );
  pthread_mutex_unlock(&i2c_mutex);
  v6 = read_back_data[1];
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
  {
    if ( read_back_data[1] != 24 )
    {
LABEL_11:
      if ( opt_log_level <= 2 )
        return 0;
      goto LABEL_12;
    }
    if ( read_back_data[0] == 5 )
      goto LABEL_18;
LABEL_10:
    if ( !opt_log_output )
      goto LABEL_11;
LABEL_12:
    snprintf(tmp42, 0x1000u, "%s chain %d failed!", "get_PIC16F1704_voltage_new", i2c_slave_addr);
LABEL_13:
    applog(3, tmp42, 0);
    return 0;
  }
  v7 = read_back_data[0];
  snprintf(
    tmp42,
    0x1000u,
    "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read_bac"
    "k_data[4] = 0x%x\n",
    "get_PIC16F1704_voltage_new",
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4]);
  applog(5, tmp42, 0);
  if ( v6 != 24 || v7 != 5 )
  {
    if ( use_syslog )
      goto LABEL_12;
    goto LABEL_10;
  }
LABEL_18:
  v9 = read_back_data[2];
  v10 = read_back_data[2] + 29;
  if ( read_back_data[3] != HIBYTE(v10) || read_back_data[4] != (unsigned __int8)v10 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(tmp42, 0x1000u, "%s failed! crc = 0x%04x", "get_PIC16F1704_voltage_new", v10);
    goto LABEL_13;
  }
  *voltage = read_back_data[2];
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return 1;
  snprintf(tmp42, 0x1000u, "%s ok, voltage = 0x%02x", "get_PIC16F1704_voltage_new", v9);
  applog(5, tmp42, 0);
  return 1;
}

//----- (00038324) --------------------------------------------------------
int __fastcall write_temperature_offset_PIC16F1704_new(unsigned __int8 *buf)
{
  unsigned __int8 *v1; // r1
  unsigned __int8 *v2; // r0
  unsigned __int8 *v3; // r2
  __int16 v4; // r3
  __int16 v5; // t1
  unsigned __int8 *v6; // r0
  unsigned __int8 v7; // t1
  unsigned __int8 *v8; // r4
  int v9; // t1
  __int64 v10; // r4
  int result; // r0
  char v12; // [sp+7h] [bp-1011h] BYREF
  unsigned __int8 send_data[14]; // [sp+8h] [bp-1010h] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  v1 = buf - 1;
  v2 = buf + 7;
  v3 = v1;
  v4 = 46;
  *(_DWORD *)&send_data[4] = 0;
  *(_DWORD *)&send_data[8] = 0;
  do
  {
    v5 = *++v3;
    v4 += v5;
  }
  while ( v2 != v3 );
  v6 = &send_data[4];
  *(_DWORD *)send_data = 571255381;
  do
  {
    v7 = *++v1;
    *v6++ = v7;
  }
  while ( v1 != v3 );
  send_data[12] = HIBYTE(v4);
  v8 = (unsigned __int8 *)&v12;
  send_data[13] = v4;
  pthread_mutex_lock(&i2c_mutex);
  do
  {
    v9 = *++v8;
    i2c_write(v9 | (i2c_slave_addr << 16) | 0xA00000);
  }
  while ( &send_data[13] != v8 );
  usleep(0x30D40u);
  LODWORD(v10) = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  HIDWORD(v10) = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  if ( v10 == 0x100000022LL )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s ok", "write_temperature_offset_PIC16F1704_new");
      applog(5, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x",
      "write_temperature_offset_PIC16F1704_new",
      (_DWORD)v10,
      HIDWORD(v10));
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00038480) --------------------------------------------------------
int __fastcall read_temperature_offset_PIC16F1704_new(unsigned __int8 *buf)
{
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r6
  int v7; // r8
  unsigned __int8 v9; // r6
  unsigned int v10; // r3
  unsigned __int8 *v11; // r3
  unsigned __int8 *v12; // r2
  unsigned __int8 *v13; // r7
  unsigned __int8 v14; // t1
  unsigned __int8 send_data[6]; // [sp+34h] [bp-1014h] BYREF
  unsigned __int8 read_back_data[12]; // [sp+3Ch] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+48h] [bp-1000h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  *(_DWORD *)&read_back_data[4] = 0;
  v2 = send_data;
  *(_DWORD *)&read_back_data[8] = 0;
  *(_DWORD *)send_data = 587508309;
  send_data[5] = 39;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( v2 == &send_data[5] )
      break;
    v4 = *++v2;
  }
  v5 = read_back_data;
  usleep((__useconds_t)&loc_30D3E + 2);
  do
    *v5++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( tmp42 != (char *)v5 );
  pthread_mutex_unlock(&i2c_mutex);
  v6 = read_back_data[1];
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
  {
    if ( read_back_data[1] != 35 )
    {
LABEL_11:
      if ( opt_log_level <= 2 )
        return 0;
      goto LABEL_12;
    }
    if ( read_back_data[0] == 12 )
      goto LABEL_18;
LABEL_10:
    if ( !opt_log_output )
      goto LABEL_11;
LABEL_12:
    snprintf(tmp42, 0x1000u, "%s failed!", "read_temperature_offset_PIC16F1704_new");
LABEL_13:
    applog(3, tmp42, 0);
    return 0;
  }
  v7 = read_back_data[0];
  snprintf(
    tmp42,
    0x1000u,
    "%s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, \t\tread"
    "_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_back_da"
    "ta[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
    "read_temperature_offset_PIC16F1704_new",
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5],
    read_back_data[6],
    read_back_data[7],
    read_back_data[8],
    read_back_data[9],
    read_back_data[10],
    read_back_data[11]);
  applog(5, tmp42, 0);
  if ( v6 != 35 || v7 != 12 )
  {
    if ( use_syslog )
      goto LABEL_12;
    goto LABEL_10;
  }
LABEL_18:
  v9 = read_back_data[2];
  v10 = read_back_data[9]
      + read_back_data[8]
      + read_back_data[7]
      + read_back_data[6]
      + read_back_data[3]
      + read_back_data[2]
      + 47
      + read_back_data[4]
      + read_back_data[5];
  if ( read_back_data[10] != v10 >> 8 || read_back_data[11] != (unsigned __int8)v10 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(
      tmp42,
      0x1000u,
      "%s failed! crc = 0x%04x",
      "read_temperature_offset_PIC16F1704_new",
      read_back_data[9]
    + read_back_data[8]
    + read_back_data[7]
    + read_back_data[6]
    + read_back_data[3]
    + read_back_data[2]
    + 47
    + read_back_data[4]
    + read_back_data[5]);
    goto LABEL_13;
  }
  v11 = buf - 1;
  v12 = &read_back_data[3];
  v13 = buf + 7;
  while ( 1 )
  {
    *++v11 = v9;
    if ( v13 == v11 )
      break;
    v14 = *v12++;
    v9 = v14;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return 1;
  snprintf(tmp42, 0x1000u, "%s ok", "read_temperature_offset_PIC16F1704_new");
  applog(5, tmp42, 0);
  return 1;
}

//----- (000386E4) --------------------------------------------------------
bool erase_PIC16F1704_app_flash_new()
{
  int v0; // r4
  _BOOL4 result; // r0
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  set_PIC16F1704_flash_pointer_new(6u, 0);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash_new", 76);
    applog(5, tmp42, 0);
  }
  v0 = 76;
  do
  {
    result = erase_PIC16F1704_flash_new();
    --v0;
  }
  while ( v0 );
  return result;
}

//----- (00038754) --------------------------------------------------------
int PIC1704_update_pic_app_program_new()
{
  int v0; // r4
  FILE *v1; // r0
  FILE *v2; // r5
  unsigned __int8 *v3; // r4
  __int16 v4; // r0
  unsigned __int8 *v6; // r3
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int j; // r4
  unsigned int i; // [sp+Ch] [bp-23A8h]
  char data_read[8]; // [sp+10h] [bp-23A4h] BYREF
  unsigned __int8 buf[16]; // [sp+18h] [bp-239Ch] BYREF
  char tmp42[4096]; // [sp+28h] [bp-238Ch] BYREF
  unsigned __int8 program_data[5000]; // [sp+1028h] [bp-138Ch] BYREF

  memset(program_data, 0, sizeof(program_data));
  memset(data_read, 0, 5);
  memset(buf, 0, sizeof(buf));
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "PIC1704_update_pic_app_program_new");
    v0 = (int)&tmp42[34];
    applog(5, tmp42, 0);
  }
  v1 = fopen("/sbin/pic.txt", "r");
  v2 = v1;
  if ( !v1 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return v0;
    snprintf(tmp42, 0x1000u, "%s: open pic16f1704_app_new.txt failed\n", "PIC1704_update_pic_app_program_new");
    goto LABEL_18;
  }
  fseek(v1, 0, 0);
  memset(program_data, 0, sizeof(program_data));
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s: pic_flash_length = %d\n", "PIC1704_update_pic_app_program_new", 2432);
    applog(5, tmp42, 0);
  }
  v3 = program_data;
  do
  {
    v3 += 2;
    fgets(data_read, 1023, v2);
    v4 = strtoul(data_read, 0, 16);
    *(v3 - 1) = v4;
    *(v3 - 2) = HIBYTE(v4);
  }
  while ( v3 != &program_data[4864] );
  fclose(v2);
  v0 = reset_PIC16F1704_pic_new();
  if ( !v0 )
    goto LABEL_11;
  if ( erase_PIC16F1704_app_flash_new() )
  {
    v0 = set_PIC16F1704_flash_pointer_new(6u, 0);
    if ( !v0 )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        return 0;
      snprintf(tmp42, 0x1000u, "%s: set flash pointer error!\n\n", "PIC1704_update_pic_app_program_new");
LABEL_18:
      applog(3, tmp42, 0);
      return v0;
    }
    for ( i = 0; i != 304; ++i )
    {
      v6 = &program_data[16 * i];
      v7 = *(_DWORD *)v6;
      v8 = *((_DWORD *)v6 + 1);
      v9 = *((_DWORD *)v6 + 2);
      v10 = *((_DWORD *)v6 + 3);
      *(_DWORD *)buf = v7;
      *(_DWORD *)&buf[4] = v8;
      *(_DWORD *)&buf[8] = v9;
      *(_DWORD *)&buf[12] = v10;
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "send pic program time: %d", i);
        applog(5, tmp42, 0);
      }
      for ( j = 0; j != 16; ++j )
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42, 0x1000u, "buf[%d] = 0x%02x", j, buf[j]);
          applog(7, tmp42, 0);
        }
      }
      send_data_to_PIC16F1704_new(buf);
      write_data_into_PIC16F1704_flash_new();
    }
    v0 = reset_PIC16F1704_pic_new();
    if ( v0 )
      return 1;
LABEL_11:
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(tmp42, 0x1000u, "%s: reset pic error!\n\n", "PIC1704_update_pic_app_program_new");
    goto LABEL_18;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
    return 0;
  snprintf(tmp42, 0x1000u, aSEraseFlashErr, "PIC1704_update_pic_app_program_new");
  applog(3, tmp42, 0);
  return 0;
}
// 388DA: variable 'v0' is possibly undefined

//----- (00038A90) --------------------------------------------------------
void every_chain_reset_PIC16F1704_pic_new()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "chain%d %s", i, "every_chain_reset_PIC16F1704_pic_new");
        applog(5, tmp42, 0);
      }
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      reset_PIC16F1704_pic_new();
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  cgsleep_ms(500);
}

//----- (00038B44) --------------------------------------------------------
void every_chain_jump_from_loader_to_app_PIC16F1704_new()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "chain%d %s", i, "every_chain_jump_from_loader_to_app_PIC16F1704_new");
        applog(5, tmp42, 0);
      }
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      jump_from_loader_to_app_PIC16F1704_new();
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  cgsleep_ms(500);
}

//----- (00038BF8) --------------------------------------------------------
void every_chain_disable_PIC16F1704_dc_dc_new()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "every_chain_disable_PIC16F1704_dc_dc_new");
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      disable_PIC16F1704_dc_dc_new();
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  cgsleep_ms(500);
}

//----- (00038C9C) --------------------------------------------------------
void __fastcall bitmain_ZCASH_shutdown(thr_info *thr)
{
  every_chain_disable_PIC16F1704_dc_dc_new();
  reset_all_hash_board_low();
  cgsleep_ms(100);
  thr_info_cancel(check_miner_status_id);
  thr_info_cancel(check_fan_id);
  thr_info_cancel(read_hash_rate);
  thr_info_cancel(read_temp_id);
}

//----- (00038CE8) --------------------------------------------------------
void every_chain_enable_PIC16F1704_dc_dc_new()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "every_chain_enable_PIC16F1704_dc_dc_new");
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      enable_PIC16F1704_dc_dc_new();
      cgsleep_ms(200);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
}

//----- (00038D84) --------------------------------------------------------
int send_heart_beat_to_every_chain()
{
  int v0; // r6
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  pic_heart_beat = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(pic_heart_beat, 0, (void *(*)(void *))pic_heart_beat_func_new, pic_heart_beat) )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(tmp42, 0x1000u, "%s: create thread error for pic_heart_beat_func", "send_heart_beat_to_every_chain");
      applog(3, tmp42, 0);
    }
    return -3;
  }
  else
  {
    pthread_detach(pic_heart_beat->pth);
    return v0;
  }
}
// 38E06: variable 'v0' is possibly undefined

//----- (00038E14) --------------------------------------------------------
void check_whether_need_update_pic_program()
{
  int v0; // r6
  unsigned __int8 *v1; // r8
  int v2; // r5
  int PIC16F1704_software_version_new; // r4
  unsigned int v4; // r3
  bool v5; // zf
  int v6; // r4
  unsigned int v7; // r2
  bool v8; // r3
  uint8_t *chain_exist; // [sp+8h] [bp-100Ch]
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "check_whether_need_update_pic_program");
    applog(5, tmp42, 0);
  }
  v0 = 0;
  chain_exist = dev.chain_exist;
  v1 = pic_version;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = v0;
      reset_PIC16F1704_pic_new();
      cgsleep_ms(100);
      jump_from_loader_to_app_PIC16F1704_new();
      cgsleep_ms(100);
      PIC16F1704_software_version_new = get_PIC16F1704_software_version_new(&pic_version[v0]);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
      v4 = *v1;
      v5 = v4 == 128;
      if ( v4 <= 0x80 )
        v5 = PIC16F1704_software_version_new == 1;
      if ( v5 )
      {
        do
        {
          pthread_mutex_lock(&iic_mutex);
          i2c_slave_addr = v0;
          PIC1704_update_pic_app_program_new();
          cgsleep_ms(100);
          jump_from_loader_to_app_PIC16F1704_new();
          cgsleep_ms(200);
          v6 = get_PIC16F1704_software_version_new(&pic_version[v0]);
          pthread_mutex_unlock(&iic_mutex);
          cgsleep_ms(100);
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "%s: Chain%d pic update for %d times",
              "check_whether_need_update_pic_program",
              v0,
              v2);
            applog(5, tmp42, 0);
          }
          v7 = (unsigned __int8)v2;
          v8 = *v1 != 129 || v6 == 0;
          ++v2;
        }
        while ( v7 <= 2 && v8 );
      }
    }
    ++v0;
    ++v1;
  }
  while ( v0 != 4 );
}

//----- (00038FA4) --------------------------------------------------------
int __fastcall save_freq_PIC16F1704_new(unsigned __int16 freq)
{
  char *v1; // r4
  int i; // r3
  int v3; // t1
  int v4; // r4
  int v5; // r6
  bool v6; // zf
  int result; // r0
  unsigned __int8 send_data[8]; // [sp+8h] [bp-1008h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  send_data[4] = HIBYTE(freq);
  send_data[7] = freq + HIBYTE(freq) + 42;
  *(_DWORD *)send_data = 604416597;
  v1 = (char *)&send_data[1];
  send_data[5] = freq;
  send_data[6] = (unsigned __int16)((unsigned __int8)freq + HIBYTE(freq) + 42) >> 8;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v3 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( tmp42 == v1 )
      break;
    v3 = (unsigned __int8)*v1++;
  }
  usleep(0x493E0u);
  v4 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  v5 = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  pthread_mutex_unlock(&i2c_mutex);
  usleep(0x30D40u);
  v6 = v5 == 1;
  if ( v5 == 1 )
    v6 = v4 == 36;
  if ( v6 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "\n--- %s ok\n\n", "save_freq_PIC16F1704_new");
      applog(7, tmp42, 0);
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "save_freq_PIC16F1704_new",
      v4,
      v5);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (000390FC) --------------------------------------------------------
int __fastcall get_PIC16F1704_freq_new(unsigned __int16 *freq)
{
  unsigned __int8 *v2; // r4
  int i; // r3
  int v4; // t1
  unsigned __int8 *v5; // r4
  int v6; // r5
  int v7; // r7
  unsigned int v9; // r3
  int v10; // r1
  unsigned __int8 read_back_data[6]; // [sp+18h] [bp-Dh] BYREF
  __int16 v12; // [sp+1Eh] [bp-7h] BYREF
  unsigned __int8 send_data[6]; // [sp+20h] [bp-5h] BYREF
  char tmp42[4100]; // [sp+28h] [bp+3h] BYREF

  *(_DWORD *)read_back_data = 255;
  send_data[4] = 0;
  v2 = send_data;
  *(_WORD *)&read_back_data[4] = 0;
  *(_DWORD *)send_data = 621062741;
  send_data[5] = 41;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v4 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( &send_data[5] == v2 )
      break;
    v4 = *++v2;
  }
  v5 = read_back_data;
  usleep((__useconds_t)&loc_493DE + 2);
  do
    *v5++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( &v12 != (__int16 *)v5 );
  pthread_mutex_unlock(&i2c_mutex);
  usleep((__useconds_t)&loc_30D3E + 2);
  v6 = read_back_data[1];
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
  {
    if ( read_back_data[1] != 37 )
    {
LABEL_11:
      if ( opt_log_level <= 2 )
        return 0;
      goto LABEL_12;
    }
    if ( read_back_data[0] == 6 )
      goto LABEL_18;
LABEL_10:
    if ( !opt_log_output )
      goto LABEL_11;
LABEL_12:
    snprintf(tmp42, 0x1000u, "\n--- %s failed!\n\n", "get_PIC16F1704_freq_new");
LABEL_13:
    applog(3, tmp42, 0);
    return 0;
  }
  v7 = read_back_data[0];
  snprintf(
    tmp42,
    0x1000u,
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
    "get_PIC16F1704_freq_new",
    read_back_data[0],
    read_back_data[1],
    read_back_data[2],
    read_back_data[3],
    read_back_data[4],
    read_back_data[5]);
  applog(5, tmp42, 0);
  if ( v6 != 37 || v7 != 6 )
  {
    if ( use_syslog )
      goto LABEL_12;
    goto LABEL_10;
  }
LABEL_18:
  v9 = read_back_data[2] + read_back_data[3] + 43;
  if ( read_back_data[4] != v9 >> 8 || read_back_data[5] != (unsigned __int8)v9 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return 0;
    snprintf(
      tmp42,
      0x1000u,
      "\n--- %s failed! crc = 0x%04x\n\n",
      "get_PIC16F1704_freq_new",
      read_back_data[2] + read_back_data[3] + 43);
    goto LABEL_13;
  }
  v10 = read_back_data[3] | (read_back_data[2] << 8);
  *freq = _byteswap_ushort(*(unsigned __int16 *)&read_back_data[2]);
  if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
    return 1;
  snprintf(tmp42, 0x1000u, "\n--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq_new", v10);
  applog(5, tmp42, 0);
  return 1;
}

//----- (00039304) --------------------------------------------------------
int __fastcall write_data_to_PIC16F1704_flash(unsigned __int8 *buf, unsigned int offset, int buf_len)
{
  int v3; // r3
  __int16 v5; // r4
  __int16 v6; // r2
  size_t v7; // r2
  int v8; // r7
  unsigned __int8 *v9; // r5
  unsigned __int8 v10; // r4
  int v11; // r3
  unsigned __int8 *v12; // r4
  int result; // r0
  unsigned __int8 read_back_data[5]; // [sp+14h] [bp-1020h] BYREF
  char v15; // [sp+19h] [bp-101Bh] BYREF
  unsigned __int8 send_data[17]; // [sp+1Ch] [bp-1018h] BYREF
  char tmp42[4100]; // [sp+30h] [bp-1004h] BYREF

  v3 = 0;
  *(_DWORD *)&send_data[6] = 0;
  *(_DWORD *)read_back_data = 255;
  *(_DWORD *)&send_data[10] = 0;
  v5 = 2 * buf_len + 57;
  read_back_data[4] = 0;
  for ( *(_DWORD *)&send_data[13] = 0; v3 < buf_len; v5 += v6 )
  {
    v6 = buf[v3];
    v3 = (unsigned __int8)(v3 + 1);
  }
  send_data[4] = offset;
  send_data[2] = buf_len + 6;
  v7 = buf_len;
  send_data[5] = buf_len;
  v8 = buf_len + 8;
  send_data[3] = 51;
  v9 = &send_data[buf_len];
  *(_WORD *)send_data = -21931;
  memcpy(&send_data[6], buf, v7);
  v9[7] = v5;
  v9[6] = HIBYTE(v5);
  pthread_mutex_lock(&i2c_mutex);
  if ( v8 > 0 )
  {
    v10 = 0;
    v11 = 0;
    do
    {
      ++v10;
      i2c_write(send_data[v11] | (i2c_slave_addr << 16) | 0xA00000);
      v11 = v10;
    }
    while ( v10 < v8 );
  }
  v12 = read_back_data;
  usleep((__useconds_t)&loc_30D3E + 2);
  do
    *v12++ = i2c_read((i2c_slave_addr << 16) | 0xA00000);
  while ( &v15 != (char *)v12 );
  pthread_mutex_unlock(&i2c_mutex);
  if ( read_back_data[0] == 5 && read_back_data[1] == 51 && (result = read_back_data[2], read_back_data[2] == 1) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "\n--- %s ok\n\n", "write_data_to_PIC16F1704_flash");
      applog(7, tmp42, 0);
      return 1;
    }
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x, read_back_data[2] = 0x%02x\n\n",
      "write_data_to_PIC16F1704_flash",
      read_back_data[0],
      read_back_data[1],
      read_back_data[2]);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (000394B8) --------------------------------------------------------
int __fastcall read_data_from_PIC16F1704_flash(unsigned __int8 *buf, unsigned __int8 offset, unsigned __int8 read_len)
{
  size_t v4; // r7
  unsigned __int8 *v6; // r4
  int i; // r3
  int v8; // t1
  signed int v9; // r4
  signed int v10; // r9
  signed int v11; // r10
  int v12; // r4
  int result; // r0
  __int16 v14; // r3
  signed int v15; // r2
  unsigned int v16; // r1
  unsigned __int8 send_data[8]; // [sp+8h] [bp-1030h] BYREF
  unsigned __int8 read_back_data[40]; // [sp+10h] [bp-1028h] BYREF
  char tmp42[4096]; // [sp+38h] [bp-1000h] BYREF

  v4 = read_len;
  memset(read_back_data, 0, sizeof(read_back_data));
  send_data[4] = offset;
  send_data[6] = (unsigned __int16)(v4 + 58) >> 8;
  v6 = &send_data[1];
  *(_DWORD *)send_data = 872852053;
  send_data[5] = v4;
  send_data[7] = v4 + 58;
  read_back_data[0] = -1;
  pthread_mutex_lock(&i2c_mutex);
  for ( i = 85; ; i = v8 )
  {
    i2c_write(i | 0xA00000 | (i2c_slave_addr << 16));
    if ( read_back_data == v6 )
      break;
    v8 = *v6++;
  }
  LOBYTE(v9) = 0;
  v10 = 0;
  v11 = v4 + 4;
  usleep((__useconds_t)&loc_30D3E + 2);
  do
  {
    v9 = (unsigned __int8)(v9 + 1);
    read_back_data[v10] = i2c_read((i2c_slave_addr << 16) | 0xA00000);
    v10 = v9;
  }
  while ( v9 <= v11 );
  v12 = read_back_data[1];
  pthread_mutex_unlock(&i2c_mutex);
  if ( v12 != 52 )
    return 0;
  v14 = read_back_data[0];
  if ( read_back_data[0] != v4 + 5 || read_back_data[2] != 1 )
    return 0;
  LOBYTE(v15) = 0;
  LOWORD(v16) = 0;
  while ( 1 )
  {
    v15 = (unsigned __int8)(v15 + 1);
    v16 = (unsigned __int16)(v14 + v16);
    if ( (int)(v4 + 2) < v15 )
      break;
    v14 = read_back_data[v15];
  }
  if ( read_back_data[v4 + 3] == v16 >> 8 && read_back_data[v11] == (unsigned __int8)v16 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "\n--- %s ok\n\n", "read_data_from_PIC16F1704_flash");
      applog(7, tmp42, 0);
    }
    memcpy(buf, &read_back_data[3], v4);
    return 1;
  }
  else if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "\n--- %s failed! crc = 0x%04x\n\n", "read_data_from_PIC16F1704_flash", v16);
    applog(3, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (0003965C) --------------------------------------------------------
void __fastcall every_chain_set_voltage_PIC16F1704_new(unsigned __int16 voltage)
{
  double v1; // d7
  uint8_t *chain_exist; // r5
  int i; // r4
  int v4; // t1
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  v1 = 1609.92742 - (double)voltage * 182.739369 / 100.0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "set voltage = %.6f  real:%u mv\n", v1, voltage);
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      set_PIC16F1704_voltage_new((unsigned int)v1);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  cgsleep_ms(500);
}

//----- (0003974C) --------------------------------------------------------
void __fastcall every_chain_get_voltage_PIC16F1704_new(unsigned __int16 voltage)
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v3; // t1
  uint8_t pic_voltage1; // [sp+Fh] [bp-1001h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v3 = *chain_exist++;
    if ( v3 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      get_PIC16F1704_voltage_new(&pic_voltage1);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "Chain %u voltage %u", i, pic_voltage1);
        applog(5, tmp42, 0);
      }
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  cgsleep_ms(500);
}

//----- (0003980C) --------------------------------------------------------
void __fastcall every_chain_save_freq_PIC16F1704_new(unsigned __int16 freq)
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v4; // t1
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s %u", "set freq:", freq);
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      save_freq_PIC16F1704_new(freq);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  cgsleep_ms(500);
}

//----- (000398B8) --------------------------------------------------------
void every_chain_get_PIC16F1704_freq_new()
{
  uint8_t *chain_exist; // r5
  int i; // r4
  int v2; // t1
  int v3; // [sp+4h] [bp-1010h]
  unsigned __int16 freq_read_back[4]; // [sp+8h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  memset(freq_read_back, 0, sizeof(freq_read_back));
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "every_chain_get_PIC16F1704_freq_new");
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      get_PIC16F1704_freq_new(&freq_read_back[i]);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(
          tmp42,
          0x1000u,
          "chain%d pic freq = 0x%08x\n",
          i,
          freq_read_back[i],
          v3,
          *(_DWORD *)freq_read_back,
          *(_DWORD *)&freq_read_back[2]);
        applog(5, tmp42, 0);
      }
    }
  }
  cgsleep_ms(500);
}
// 39994: variable 'v3' is possibly undefined

//----- (000399C4) --------------------------------------------------------
void pic_test_new()
{
  int v0; // r4
  unsigned __int8 version; // [sp+6h] [bp-2Ah] BYREF
  unsigned __int8 voltage; // [sp+7h] [bp-29h] BYREF
  unsigned __int8 temp_offset_send[8]; // [sp+8h] [bp-28h] BYREF
  unsigned __int8 temp_offset_receive[8]; // [sp+10h] [bp-20h] BYREF
  unsigned __int8 hash_id_send[12]; // [sp+18h] [bp-18h] BYREF
  unsigned __int8 hash_id_receive[12]; // [sp+24h] [bp-Ch] BYREF

  *(_DWORD *)temp_offset_send = 387323156;
  version = 0;
  *(_DWORD *)hash_id_send = 218893066;
  *(_DWORD *)&hash_id_send[4] = 286265102;
  *(_DWORD *)&hash_id_send[8] = 353637138;
  voltage = 0;
  memset(hash_id_receive, 0, sizeof(hash_id_receive));
  memset(temp_offset_receive, 0, sizeof(temp_offset_receive));
  *(_DWORD *)&temp_offset_send[4] = 454695192;
  v0 = 0;
  reset_PIC16F1704_pic_new();
  PIC1704_update_pic_app_program_new();
  jump_from_loader_to_app_PIC16F1704_new();
  get_PIC16F1704_software_version_new(&version);
  write_hash_ID_PIC16F1704_new(hash_id_send);
  read_hash_id_PIC16F1704_new(hash_id_receive);
  write_temperature_offset_PIC16F1704_new(temp_offset_send);
  read_temperature_offset_PIC16F1704_new(temp_offset_receive);
  set_PIC16F1704_voltage_new(0x78u);
  get_PIC16F1704_voltage_new(&voltage);
  enable_PIC16F1704_dc_dc_new();
  enable_PIC16F1704_dc_dc_new();
  heart_beat_PIC16F1704_new();
  usleep(0x1E8480u);
  heart_beat_PIC16F1704_new();
  usleep(0x1E8480u);
  heart_beat_PIC16F1704_new();
  usleep(0x1E8480u);
  do
  {
    printf("i = %d\n", v0++);
    usleep(0x1E8480u);
  }
  while ( v0 != 35 );
  heart_beat_PIC16F1704_new();
  usleep(0x1E8480u);
  heart_beat_PIC16F1704_new();
  usleep(0x1E8480u);
  heart_beat_PIC16F1704_new();
  usleep(0x1E8480u);
}

//----- (00039AC8) --------------------------------------------------------
unsigned __int8 __fastcall bit_read(unsigned __int8 *y, int x)
{
  int v2; // r3
  int v3; // r3
  bool v4; // cf
  int v5; // r1
  int v6; // r3
  int v7; // r1
  int v8; // r3
  int v9; // r1
  int v10; // r3
  int v11; // r1
  int v12; // r3
  int v13; // r1
  int v14; // r3
  int v15; // r1
  int v16; // r3
  int v17; // r1
  int v18; // r3
  int v19; // r1

  v2 = x & 7;
  if ( x <= 0 )
    v2 = -(-x & 7);
  switch ( v2 )
  {
    case 0:
      v6 = x + 7;
      v4 = x < 0;
      v7 = x & ~(x >> 31);
      if ( v4 )
        v7 = v6;
      LOBYTE(y) = y[v7 >> 3] & 1;
      break;
    case 1:
      v8 = x + 7;
      v4 = x < 0;
      v9 = x & ~(x >> 31);
      if ( v4 )
        v9 = v8;
      y = (unsigned __int8 *)((y[v9 >> 3] >> 1) & 1);
      break;
    case 2:
      v10 = x + 7;
      v4 = x < 0;
      v11 = x & ~(x >> 31);
      if ( v4 )
        v11 = v10;
      y = (unsigned __int8 *)((y[v11 >> 3] >> 2) & 1);
      break;
    case 3:
      v12 = x + 7;
      v4 = x < 0;
      v13 = x & ~(x >> 31);
      if ( v4 )
        v13 = v12;
      y = (unsigned __int8 *)((y[v13 >> 3] >> 3) & 1);
      break;
    case 4:
      v14 = x + 7;
      v4 = x < 0;
      v15 = x & ~(x >> 31);
      if ( v4 )
        v15 = v14;
      y = (unsigned __int8 *)((y[v15 >> 3] >> 4) & 1);
      break;
    case 5:
      v16 = x + 7;
      v4 = x < 0;
      v17 = x & ~(x >> 31);
      if ( v4 )
        v17 = v16;
      y = (unsigned __int8 *)((y[v17 >> 3] >> 5) & 1);
      break;
    case 6:
      v18 = x + 7;
      v4 = x < 0;
      v19 = x & ~(x >> 31);
      if ( v4 )
        v19 = v18;
      y = (unsigned __int8 *)((y[v19 >> 3] >> 6) & 1);
      break;
    case 7:
      v3 = x + 7;
      v4 = x < 0;
      v5 = x & ~(x >> 31);
      if ( v4 )
        v5 = v3;
      y = (unsigned __int8 *)(y[v5 >> 3] >> 7);
      break;
    default:
      LOBYTE(y) = 0;
      break;
  }
  return (unsigned __int8)y;
}

//----- (00039B88) --------------------------------------------------------
int __fastcall bm1740_makeup_work(uint8_t *str, int len)
{
  int result; // r0
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( len == 146 )
    return bm1740_makeup_work_0(str, 146);
  if ( use_syslog || (result = opt_log_output) != 0 || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "%s len error\n", "bm1740_makeup_work");
    applog(4, tmp42, 0);
    return 0;
  }
  return result;
}

//----- (00039BF8) --------------------------------------------------------
void __fastcall chain_inactive(const int which_chain)
{
  uint32_t v1; // r1
  unsigned __int8 v2; // r4
  unsigned int v3; // r0
  uint8_t cmd_buf[8]; // [sp+0h] [bp-8h] BYREF

  v2 = which_chain;
  memset(cmd_buf, 0, 7);
  v3 = bm1740_makeup_chain_inactive_cmd(cmd_buf, v1);
  uart_send(v2, cmd_buf, v3);
}
// 39C08: variable 'v1' is possibly undefined

//----- (00039C1C) --------------------------------------------------------
void __fastcall set_address(const int which_chain, unsigned __int8 chip_addr)
{
  uint8_t v2; // r2
  unsigned __int8 v3; // r4
  unsigned int v4; // r0
  uint8_t cmd_buf[8]; // [sp+0h] [bp-8h] BYREF

  v3 = which_chain;
  memset(cmd_buf, 0, 7);
  v4 = bm1740_makeup_set_address_cmd(cmd_buf, chip_addr, v2);
  uart_send(v3, cmd_buf, v4);
}
// 39C2C: variable 'v2' is possibly undefined

//----- (00039C40) --------------------------------------------------------
void __fastcall software_set_address_chain(unsigned int which_chain)
{
  int v2; // r4
  unsigned __int8 v3; // r1
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s chainID%d asics %d addrInterval %d",
      "software_set_address_chain",
      which_chain,
      dev.chain_asic_num[which_chain],
      dev.addrInterval);
    applog(5, tmp42, 0);
  }
  v2 = 0;
  chain_inactive(which_chain);
  cgsleep_ms(50);
  do
  {
    v3 = dev.addrInterval * v2++;
    set_address(which_chain, v3);
    cgsleep_ms(50);
  }
  while ( v2 != 3 );
}

//----- (00039CE8) --------------------------------------------------------
void software_set_address()
{
  unsigned int v0; // r4
  uint8_t *chain_exist; // r5
  int v2; // t1

  v0 = 0;
  chain_exist = dev.chain_exist;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
      software_set_address_chain(v0);
    ++v0;
  }
  while ( v0 != 4 );
  cgsleep_ms(10);
}

//----- (00039D14) --------------------------------------------------------
void __fastcall set_core_timeout_chain(unsigned __int8 which_chain, unsigned int timeout)
{
  uint32_t regdata; // [sp+4h] [bp-1018h]
  uint8_t cmd[11]; // [sp+Ch] [bp-1010h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  *(_DWORD *)&cmd[7] = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "chainid%d %s: core timeout = %08x", which_chain, "set_core_timeout_chain", timeout);
    applog(7, tmp42, 0);
  }
  default_core_timeout_reg = timeout;
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x28u, timeout, regdata);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(1);
}
// 39D88: variable 'regdata' is possibly undefined

//----- (00039DB8) --------------------------------------------------------
void __fastcall set_nonce_shift_chain(unsigned __int8 which_chain, int shift)
{
  uint32_t regaddr; // r5
  uint32_t shifta; // [sp+4h] [bp-1014h]
  uint8_t cmd[11]; // [sp+Ch] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  *(_DWORD *)&cmd[7] = 0;
  regaddr = (unsigned __int8)shift << 27;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "chainid%d %s: nonce shift = %08x", which_chain, "set_nonce_shift_chain", shift);
    applog(7, tmp42, 0);
  }
  default_nonce_shift_reg = regaddr;
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x50u, regaddr, shifta);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(10);
}
// 39E36: variable 'shifta' is possibly undefined

//----- (00039E68) --------------------------------------------------------
void __fastcall set_core_timeout(uint32_t timeout)
{
  uint8_t *chain_exist; // r5
  int v3; // r4
  int v4; // t1

  chain_exist = dev.chain_exist;
  LOBYTE(v3) = 0;
  do
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
      set_core_timeout_chain(v3, timeout);
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
  cgsleep_ms(10);
}

//----- (00039E98) --------------------------------------------------------
void __fastcall set_nonce_shift(int shift)
{
  uint8_t *chain_exist; // r5
  int v3; // r4
  int v4; // t1

  chain_exist = dev.chain_exist;
  LOBYTE(v3) = 0;
  do
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
      set_nonce_shift_chain(v3, shift);
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
  cgsleep_ms(10);
}

//----- (00039EC8) --------------------------------------------------------
void __fastcall set_io_drive_strength_chain(unsigned __int8 which_chain)
{
  uint32_t regaddr; // r4
  uint32_t regdata; // [sp+4h] [bp-1018h]
  uint8_t cmd[11]; // [sp+Ch] [bp-1010h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  regaddr = default_io_drive_strength_reg & 0xFFFF0FFF | 0x3000;
  default_io_drive_strength_reg = regaddr;
  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  *(_DWORD *)&cmd[7] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "chainid%d %s: IO drive = %08x", which_chain, "set_io_drive_strength_chain", regaddr);
    applog(5, tmp42, 0);
  }
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x30u, regaddr, regdata);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(1);
}
// 39F38: variable 'regdata' is possibly undefined

//----- (00039F68) --------------------------------------------------------
void set_io_drive_strength()
{
  int v0; // r4
  uint8_t *chain_exist; // r5
  int v2; // t1

  LOBYTE(v0) = 0;
  chain_exist = dev.chain_exist;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
      set_io_drive_strength_chain(v0);
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
  cgsleep_ms(10);
}

//----- (00039F94) --------------------------------------------------------
void __fastcall set_analog_mux_control_chain(unsigned __int8 which_chain, uint32_t value)
{
  uint32_t regaddr; // r4
  uint32_t regdata; // [sp+4h] [bp-1018h]
  uint8_t cmd[11]; // [sp+Ch] [bp-1010h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  *(_DWORD *)&cmd[7] = 0;
  regaddr = value & 7;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "chainid%d %s: analog mux = %08x", which_chain, "set_analog_mux_control_chain", regaddr);
    applog(5, tmp42, 0);
  }
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x40u, regaddr, regdata);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(1);
}
// 39FF4: variable 'regdata' is possibly undefined

//----- (0003A024) --------------------------------------------------------
void __fastcall set_analog_mux_control(uint32_t value)
{
  uint8_t *chain_exist; // r5
  int v3; // r4
  int v4; // t1

  chain_exist = dev.chain_exist;
  LOBYTE(v3) = 0;
  do
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
      set_analog_mux_control_chain(v3, value);
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
  cgsleep_ms(10);
}

//----- (0003A054) --------------------------------------------------------
void __fastcall set_frequency_chain(unsigned __int8 which_chain, unsigned int frequency)
{
  int v2; // r5
  freq_pll_str *v4; // r1
  int v5; // r2
  int v6; // r3
  unsigned int freq; // t1
  uint32_t regaddr; // r6
  uint32_t v9; // [sp+4h] [bp-1014h]
  uint8_t cmd[11]; // [sp+Ch] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  v2 = which_chain;
  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  *(_DWORD *)&cmd[7] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "chainid%d %s freq=%d", which_chain, "set_frequency_chain", frequency);
    applog(5, tmp42, 0);
  }
  v4 = freq_pll;
  v5 = 100;
  v6 = 0;
  while ( 1 )
  {
    if ( frequency == v5 )
    {
      regaddr = *(_DWORD *)&_FUNCTION___15596[16 * v6 + 2016];
      goto LABEL_9;
    }
    if ( ++v6 == 119 )
      break;
    freq = v4[1].freq;
    ++v4;
    v5 = freq;
  }
  regaddr = 4194881;
LABEL_9:
  default_pll_reg = regaddr;
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0xCu, regaddr, v9);
  uart_send(v2, cmd, 0xBu);
  dev.freq[v2] = frequency;
  cgsleep_ms(50);
}
// 3A0E6: variable 'v9' is possibly undefined

//----- (0003A134) --------------------------------------------------------
void __fastcall set_freq_asic(unsigned __int8 which_chain, unsigned __int8 which_asic, unsigned int frequency)
{
  freq_pll_str *v6; // r1
  int v7; // r2
  int v8; // r3
  unsigned int freq; // t1
  uint32_t regaddr; // r3
  uint32_t v11; // [sp+4h] [bp-1020h]
  uint8_t cmd[11]; // [sp+14h] [bp-1010h] BYREF
  char tmp42[4100]; // [sp+20h] [bp-1004h] BYREF

  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  *(_DWORD *)&cmd[7] = 0;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "%s %d %d freq=%d\n", "set_freq_asic", which_chain, which_asic, frequency);
    applog(7, tmp42, 0);
  }
  v6 = freq_pll;
  v7 = 100;
  v8 = 0;
  while ( 1 )
  {
    if ( frequency == v7 )
    {
      regaddr = *(_DWORD *)&_FUNCTION___15596[16 * v8 + 2016];
      goto LABEL_10;
    }
    if ( ++v8 == 119 )
      break;
    freq = v6[1].freq;
    ++v6;
    v7 = freq;
  }
  regaddr = 4194881;
LABEL_10:
  bm1740_makeup_set_config_cmd(cmd, 0, dev.addrInterval * which_asic, 0xCu, regaddr, v11);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(100);
}
// 3A1D6: variable 'v11' is possibly undefined

//----- (0003A214) --------------------------------------------------------
void __noreturn turbo_mode_monitor()
{
  uint8_t *chain_exist; // r7
  int v1; // r2
  int v2; // t1
  char *v3; // r0
  int v4; // r1
  char *v5; // r5
  __int64 v6; // kr00_8
  int v7; // r5
  _BYTE *v8; // r1
  uint8_t *v9; // r9
  unsigned int v10; // r4
  int v11; // t1
  unsigned int *v12; // r5
  int v13; // r8
  unsigned __int8 v14; // r6
  uint32_t *v15; // r11
  int v16; // r3
  int *v17; // r7
  uint32_t v18; // r12
  freq_pll_str *v19; // r0
  int v20; // r2
  unsigned int v21; // r0
  freq_pll_str *v22; // r12
  int freq; // lr
  int v24; // r3
  unsigned int v25; // r2
  int v26; // t1
  unsigned int v27; // r2
  int v28; // r1
  uint8_t *v29; // r5
  int v30; // t1
  int v31; // r3
  int *v32; // r3
  int v33; // r4
  uint8_t *v34; // r10
  int v35; // t1
  int v36; // r8
  uint32_t *v37; // r6
  int *v38; // r5
  _BOOL4 v39; // r3
  int v40; // r7
  uint32_t v41; // r0
  uint32_t v42; // r2
  freq_pll_str *v43; // r2
  int v44; // r1
  int v45; // r3
  unsigned int v46; // r3
  pthread_cond_t *cond; // [sp+20h] [bp-10B4h]
  unsigned int v48; // [sp+30h] [bp-10A4h]
  int lower_times[4][3]; // [sp+40h] [bp-1094h] BYREF
  _BYTE s[48]; // [sp+70h] [bp-1064h] BYREF
  _DWORD v51[12]; // [sp+A0h] [bp-1034h] BYREF
  char tmp42[4100]; // [sp+D0h] [bp-1004h] BYREF

  memset(lower_times, 0, sizeof(lower_times));
  memset(s, 0, sizeof(s));
  chain_exist = dev.chain_exist;
  memset(v51, 0, sizeof(v51));
  v1 = 0;
  do
  {
    while ( 1 )
    {
      v2 = *chain_exist++;
      if ( v2 == 1 )
        break;
      if ( ++v1 == 4 )
        goto LABEL_5;
    }
    v3 = (char *)&dev + 2 * v1;
    v4 = 3 * v1;
    v51[3 * v1] = 775;
    v5 = (char *)&g_scan_freq_info + 12 * v1++;
    v6 = *(_QWORD *)(v5 + 244);
    v7 = *((_DWORD *)v5 + 63);
    v8 = &v51[v4];
    *((_DWORD *)v8 + 1) = 775;
    *((_DWORD *)v8 + 2) = 775;
    *(_WORD *)(v3 + 593) = (__int16)(v6 + WORD2(v6) + v7) / 3;
  }
  while ( v1 != 4 );
LABEL_5:
  while ( !start_send[0] )
LABEL_11:
    cgsleep_ms(500);
  while ( 1 )
  {
    v9 = dev.chain_exist;
    v10 = 0;
    cond = 0;
    do
    {
      v11 = *v9++;
      if ( v11 == 1 )
      {
        v12 = &v51[v10 / 4];
        v13 = 0;
        v14 = ~(unsigned int)dev.chain_exist + (_BYTE)v9;
        v15 = g_scan_freq_info.each_asic_freq[v10 / 0xC];
        v17 = lower_times[v10 / 0xC + 4];
        v16 = *v17;
        if ( !*v17 )
        {
LABEL_13:
          v18 = *v15;
          if ( *v15 <= 0x306 || v18 == 775 )
          {
            v27 = *v15;
            *v12 = v18;
            set_freq_asic(v14, v13, v27);
          }
          else
          {
            v19 = freq_pll;
            v20 = 1;
            while ( 1 )
            {
              ++v20;
              ++v19;
              if ( v20 == 119 )
                break;
              if ( v19[1].freq == v18 )
              {
                v21 = *v12;
                if ( *v12 == 100 )
                  goto LABEL_24;
                goto LABEL_19;
              }
            }
            v21 = *v12;
            if ( *v12 == 100 )
              goto LABEL_33;
            v20 = -1;
LABEL_19:
            v22 = freq_pll;
            freq = 125;
            v16 = 1;
            while ( 1 )
            {
              ++v22;
              if ( freq == v21 )
              {
                v20 -= v16;
                goto LABEL_24;
              }
              if ( ++v16 == 119 )
                break;
              freq = v22[1].freq;
            }
            ++v20;
            v16 = -1;
LABEL_24:
            if ( v20 <= 1 )
LABEL_33:
              v24 = v16 + 1;
            else
              v24 = v16 + 2;
            v25 = *(_DWORD *)&_FUNCTION___15596[16 * v24 + 2004];
            *v12 = v25;
            v48 = v25;
            set_freq_asic(v14, v13, v25);
            if ( v48 != *v15 )
              goto LABEL_28;
          }
          *v17 = 1;
          goto LABEL_28;
        }
        while ( 1 )
        {
          cond = (pthread_cond_t *)((char *)cond + 1);
LABEL_28:
          ++v13;
          ++v12;
          ++v15;
          if ( v13 == 3 )
            break;
          v26 = v17[1];
          ++v17;
          v16 = v26;
          if ( !v26 )
            goto LABEL_13;
        }
      }
      v10 += 12;
    }
    while ( v10 != 48 );
    if ( 3 * dev.chain_num <= (int)cond )
      break;
    sleep(3u);
    if ( !start_send[0] )
      goto LABEL_11;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "All asics arrive target freq\n");
    applog(5, tmp42, 0);
  }
  v28 = 0;
  v29 = dev.chain_exist;
  do
  {
    while ( 1 )
    {
      v30 = *v29++;
      if ( v30 == 1 )
        break;
      if ( ++v28 == 4 )
        goto LABEL_42;
    }
    v31 = 3 * v28++;
    v32 = &g_scan_freq_info.scan_freq_store_pos + v31;
    v32[1] = 0;
    v32[25] = 0;
    v32[49] = 815;
    v32[37] = 775;
    v32[2] = 0;
    v32[26] = 0;
    v32[50] = 815;
    v32[38] = 775;
    v32[3] = 0;
    v32[27] = 0;
    v32[51] = 815;
    v32[39] = 775;
  }
  while ( v28 != 4 );
  while ( 1 )
  {
    do
    {
LABEL_42:
      sleep(1u);
      pthread_mutex_lock(&each_chain_err_asic_mutex);
      pthread_cond_wait(&each_chain_err_asic_cond, &each_chain_err_asic_mutex);
      pthread_mutex_unlock(&each_chain_err_asic_mutex);
      v33 = status_error;
    }
    while ( status_error );
    v34 = &dev.chain_exist[1];
    if ( dev.chain_exist[0] == 1 )
    {
LABEL_46:
      v36 = 0;
      v37 = g_scan_freq_info.each_asic_invalid_nonce_each_2min[v33];
      v38 = lower_times[v33];
      if ( v37[24] != 1 )
      {
        *v38 = 0;
        goto LABEL_49;
      }
LABEL_52:
      v39 = use_syslog;
      v40 = *v38 + 1;
      *v38 = v40;
      if ( v39 || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "low freq[%d-%d]: cur freq %d, lower times %d\n", v33, v36, v37[60], v40);
        applog(5, tmp42, 0);
      }
      if ( v40 > 3 )
      {
        v41 = v37[60];
        v42 = v37[36];
        if ( v41 > v42 )
        {
          *v38 = 0;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "low freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
              v33,
              v36,
              v41,
              v42,
              v37[48],
              *v37,
              v37[24]);
            applog(5, tmp42, 0);
            v41 = v37[60];
          }
          if ( v41 == 100 )
          {
LABEL_74:
            v46 = 0;
          }
          else
          {
            v43 = freq_pll;
            v44 = 125;
            v45 = 1;
            while ( 1 )
            {
              ++v43;
              if ( v41 == v44 )
                break;
              if ( ++v45 == 119 )
                goto LABEL_74;
              v44 = v43[1].freq;
            }
            v46 = *(_DWORD *)&_FUNCTION___15596[16 * v45 + 1988];
          }
          v37[60] = v46;
          set_freq_asic(v33, v36, v46);
        }
      }
LABEL_49:
      while ( 1 )
      {
        ++v36;
        ++v37;
        ++v38;
        if ( v36 == 3 )
          break;
        if ( v37[24] == 1 )
          goto LABEL_52;
        *v38 = 0;
      }
    }
    while ( ++v33 != 4 )
    {
      v35 = *v34++;
      if ( v35 == 1 )
        goto LABEL_46;
    }
  }
}

//----- (0003A66C) --------------------------------------------------------
void __fastcall set_frequency(unsigned int frequency)
{
  uint8_t *chain_exist; // r5
  int v3; // r4
  int v4; // t1

  chain_exist = dev.chain_exist;
  LOBYTE(v3) = 0;
  do
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
      set_frequency_chain(v3, frequency);
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
  cgsleep_ms(10);
}

//----- (0003A69C) --------------------------------------------------------
void __fastcall set_baud_chain(unsigned __int8 which_chain, unsigned int bt8d)
{
  uint32_t v3; // [sp+4h] [bp-14h]
  uint8_t cmd[12]; // [sp+Ch] [bp-Ch] BYREF

  memset(cmd, 0, 11);
  default_misc_reg = default_misc_reg & 0xFFFFE0FF | ((bt8d & 0x1F) << 8) | 4;
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x1Cu, default_misc_reg, v3);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(1);
}
// 3A6CE: variable 'v3' is possibly undefined

//----- (0003A6E8) --------------------------------------------------------
void __fastcall set_baud(unsigned int bt8d)
{
  unsigned __int8 v1; // r7
  uint8_t *chain_exist; // r5
  int v4; // r4
  int v5; // t1
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v1 = bt8d;
  dev.baud = bt8d;
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(tmp42, 0x1000u, "%s: bt8d = %d", "set_baud", bt8d);
    applog(7, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  LOBYTE(v4) = 0;
  do
  {
    v5 = *chain_exist++;
    if ( v5 == 1 )
      set_baud_chain(v4, bt8d);
    v4 = (unsigned __int8)(v4 + 1);
  }
  while ( v4 != 4 );
  sleep(1u);
  set_fpga_baud(v1);
  cgsleep_ms(10);
}

//----- (0003A794) --------------------------------------------------------
void __fastcall set_ticket_mask_chain(unsigned __int8 which_chain, uint32_t ticket_mask)
{
  unsigned __int8 v3; // r6
  uint32_t v4; // [sp+4h] [bp-1014h]
  uint8_t cmd[11]; // [sp+Ch] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  v3 = ticket_mask;
  *(_DWORD *)&cmd[7] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s chainID%d ticket_mask = 0x%08x", "set_ticket_mask_chain", which_chain, ticket_mask);
    applog(5, tmp42, 0);
  }
  default_ticket_mask_reg = v3;
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x14u, v3, v4);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(1);
}
// 3A804: variable 'v4' is possibly undefined

//----- (0003A834) --------------------------------------------------------
void __fastcall set_ticket_mask(unsigned int ticket_mask)
{
  uint8_t *chain_exist; // r5
  int v3; // r4
  int v4; // t1

  chain_exist = dev.chain_exist;
  LOBYTE(v3) = 0;
  do
  {
    v4 = *chain_exist++;
    if ( v4 == 1 )
      set_ticket_mask_chain(v3, ticket_mask);
    v3 = (unsigned __int8)(v3 + 1);
  }
  while ( v3 != 4 );
}

//----- (0003A85C) --------------------------------------------------------
void __fastcall set_txn_data_chain(unsigned __int8 which_chain, int txn_shalow, int txn_zero)
{
  char v4; // r8
  char v5; // r7
  uint32_t regdata; // [sp+4h] [bp-101Ch]
  uint8_t cmd[11]; // [sp+14h] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+20h] [bp-1000h] BYREF

  v4 = txn_shalow;
  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  v5 = txn_zero;
  *(_DWORD *)&cmd[7] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "chainID%d %s txndata %d txnzero %d",
      which_chain,
      "set_txn_data_chain",
      txn_shalow,
      txn_zero);
    applog(5, tmp42, 0);
  }
  default_txn_data = (2 * (v4 & 1)) | v5 & 1;
  bm1740_makeup_set_config_cmd(cmd, 1u, 0, 0x58u, default_txn_data, regdata);
  uart_send(which_chain, cmd, 0xBu);
  cgsleep_ms(1);
}
// 3A8DA: variable 'regdata' is possibly undefined

//----- (0003A90C) --------------------------------------------------------
void __fastcall set_txn_data(int txn_shalow, int txn_zero)
{
  uint8_t *chain_exist; // r5
  int v5; // r4
  int v6; // t1

  chain_exist = dev.chain_exist;
  LOBYTE(v5) = 0;
  do
  {
    v6 = *chain_exist++;
    if ( v6 == 1 )
      set_txn_data_chain(v5, txn_shalow, txn_zero);
    v5 = (unsigned __int8)(v5 + 1);
  }
  while ( v5 != 4 );
}

//----- (0003A938) --------------------------------------------------------
int __fastcall is_nonce_or_reg_value(unsigned __int8 data)
{
  return data >> 7;
}

//----- (0003A93C) --------------------------------------------------------
void init_asic_display_status()
{
  int v0; // r8
  uint8_t *chain_exist; // r11
  int v3; // r6
  int v4; // r6
  int v5; // r10
  unsigned int v6; // r5
  int v7; // r4
  char *v8; // r3
  unsigned int v9; // r3
  char *v10; // r3
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v0 = 0;
  chain_exist = dev.chain_exist;
  do
  {
    if ( *chain_exist++ )
    {
      v3 = chain_exist[520];
      if ( chain_exist[520] )
      {
        v4 = 0;
        v5 = v0;
        v6 = 0;
        do
        {
          v7 = v4 + v6;
          if ( !(v6 << 29) )
          {
            if ( v7 > 19 && (use_syslog || opt_log_output || opt_log_level > 2) )
            {
              snprintf(tmp42, 0x1000u, "offset[%d] ERR", v4 + v6);
              applog(3, tmp42, 0);
            }
            v4 = (unsigned __int8)(v4 + 1);
            v8 = (char *)&dev + v5 * 19 + v7;
            v7 = v6 + v4;
            v8[355] = 32;
          }
          if ( v7 > 19 && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf(tmp42, 0x1000u, "offset[%d] ERR", v7);
            applog(3, tmp42, 0);
          }
          dev.chain_asic_status_string[v5][v7] = 111;
          v9 = 3 * v0 + v6;
          v6 = (unsigned __int8)(v6 + 1);
          v10 = (char *)&dev.chain_hw[v9 + 3] + 1;
          v10[3] = 0;
          v10[4] = 0;
          v10[5] = 0;
          v10[6] = 0;
        }
        while ( chain_exist[520] > v6 );
        v3 = v4 + v6;
        if ( v3 > 19 && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(tmp42, 0x1000u, "offset[%d] ERR", v3);
          applog(3, tmp42, 0);
        }
      }
      dev.chain_asic_status_string[v0][v3] = 0;
    }
    ++v0;
  }
  while ( v0 != 4 );
}

//----- (0003AACC) --------------------------------------------------------
speed_t __fastcall tiospeed_t(int baud)
{
  if ( baud == 115200 )
    return 4098;
  if ( baud <= 115200 )
  {
    if ( baud != 19200 )
    {
      if ( baud <= 19200 )
      {
        if ( baud == 9600 )
          return 13;
      }
      else
      {
        if ( baud == 38400 )
          return 15;
        if ( baud == 57600 )
          return 4097;
      }
      return 0;
    }
    return 14;
  }
  else
  {
    if ( baud != 921600 )
    {
      if ( baud > 921600 )
      {
        if ( baud == 1500000 )
          return 4106;
        if ( baud == 3000000 )
          return 4109;
      }
      else
      {
        if ( baud == 230400 )
          return 4099;
        if ( baud == 460800 )
          return 4100;
      }
      return 0;
    }
    return 4103;
  }
}

//----- (0003AB54) --------------------------------------------------------
void __fastcall tty_init_chain(uint8_t which_chain, bitmain_ZCASH_info *info)
{
  int v2; // r4
  _BOOL4 v3; // r3
  int v5; // r8
  int v6; // r6
  bitmian_ZCASH_info_with_index info_with_index; // [sp+8h] [bp-1028h] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1020h] BYREF

  if ( dev.chain_exist[which_chain] )
  {
    v2 = which_chain;
    v3 = use_syslog;
    dev_info_0[which_chain].chainid = which_chain;
    if ( v3 || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s chainid = %d", "tty_init_chain", which_chain);
      applog(5, tmp42, 0);
    }
    v5 = (__int16)v2 << 6;
    *((_BYTE *)&axi_fpga_addr + v2 + 776) = 1;
    if ( thr_info_create((thr_info *)((char *)info->uart_rx_t + v5), 0, get_asic_response, &dev_info_0[(__int16)v2]) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 2 )
      {
        snprintf(tmp42, 0x1000u, "create rx read thread for chain %d failed", v2);
        goto LABEL_9;
      }
    }
    else if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(tmp42, 0x1000u, "create rx read thread for chain %d ok", v2);
LABEL_9:
      applog(3, tmp42, 0);
    }
    cgsleep_ms(50);
    info_with_index.info = info;
    info_with_index.chain_index = v2;
    v6 = thr_info_create((thr_info *)((char *)info->uart_tx_t + v5), 0, ZCASH_fill_work, &info_with_index);
    cgsleep_ms(200);
    if ( v6 )
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        goto LABEL_22;
      snprintf(tmp42, 0x1000u, "create tx read thread for chain %d failed", v2);
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
        goto LABEL_22;
      snprintf(tmp42, 0x1000u, "create tx read thread for chain %d ok", v2);
    }
    applog(3, tmp42, 0);
    if ( use_syslog || opt_log_output )
    {
LABEL_16:
      strcpy(tmp42, "open device over");
      applog(5, tmp42, 0);
LABEL_17:
      cgsleep_ms(10);
      return;
    }
LABEL_22:
    if ( opt_log_level <= 4 )
      goto LABEL_17;
    goto LABEL_16;
  }
}

//----- (0003AD60) --------------------------------------------------------
void __fastcall tty_init(bitmain_ZCASH_info *info)
{
  int i; // r4
  uint8_t v3; // r0
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "tty_init");
    applog(5, tmp42, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    v3 = i;
    tty_init_chain(v3, info);
  }
  cgsleep_ms(10);
}

//----- (0003ADCC) --------------------------------------------------------
int __fastcall ZCASH_write(int fd, volatile uint8_t *buf, size_t bufLen)
{
  return uart_send(fd, buf, bufLen);
}

//----- (0003ADD4) --------------------------------------------------------
int __fastcall ZCASH_read(int uart_fd, unsigned __int8 *buf, size_t MAX_READ_BYTES)
{
  return uart_receive(uart_fd, buf, MAX_READ_BYTES);
}

//----- (0003ADDC) --------------------------------------------------------
void check_chain()
{
  int v0; // r4
  int v1; // r10
  char *v2; // lr
  bool *v3; // [sp+0h] [bp-1014h]
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "check_chain");
    applog(5, tmp42, 0);
  }
  v0 = 0;
  dev.chain_num = 0;
  v1 = axi_fpga_addr[2];
  v3 = &opt_log_output;
  do
  {
    v2 = (char *)&dev + v0;
    if ( ((v1 >> v0) & 1) != 0 )
    {
      v2[8] = 1;
      ++dev.chain_num;
      if ( use_syslog || *v3 || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "Chain %d existed!", v0, v3);
        applog(5, tmp42, 0);
      }
    }
    else
    {
      v2[8] = 0;
    }
    ++v0;
  }
  while ( v0 != 4 );
}
// 3AEA0: variable 'v3' is possibly undefined

//----- (0003AEE0) --------------------------------------------------------
void __fastcall set_led(bool stop)
{
  char cmd[100]; // [sp+4h] [bp-64h] BYREF

  blink_15605 ^= 1u;
  if ( stop )
  {
    sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", 0, 942);
    system(cmd);
    sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)blink_15605, 941);
  }
  else
  {
    sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", 0, 941);
    system(cmd);
    sprintf(cmd, "echo %d > /sys/class/gpio/gpio%d/value", (unsigned __int8)blink_15605, 942);
  }
  system(cmd);
}
// 6D7F0: using guessed type char blink_15605;

//----- (0003AF6C) --------------------------------------------------------
void *__fastcall __noreturn check_miner_status(void *arg)
{
  unsigned int **v1; // r11
  int v2; // r3
  int32_t temp_top1; // r3
  int v4; // r1
  int v5; // r3
  int v6; // r2
  int v7; // r3
  _BOOL4 v8; // lr
  int fan_num; // r7
  _BOOL4 v10; // r8
  unsigned int v11; // r6
  int v12; // r2
  int v13; // r0
  unsigned int v14; // r6
  int v15; // r3
  int v16; // r1
  unsigned int v17; // r2
  int v18; // r6
  _BOOL4 v19; // r1
  int v20; // r0
  uint32_t fan_exist_map; // r0
  int v22; // r1
  int v23; // r2
  int v24; // r4
  unsigned int *v25; // r4
  uint8_t *v26; // r5
  int v27; // t1
  char *v28; // r4
  uint32_t *v29; // r6
  uint32_t v30; // r3
  uint32_t *v31; // r5
  uint32_t v32; // r0
  uint32_t v33; // r1
  uint32_t v34; // r2
  uint32_t *v35; // r6
  uint32_t *v36; // r4
  uint32_t v37; // r3
  uint32_t *v38; // r5
  uint32_t v39; // r0
  uint32_t v40; // r1
  uint32_t v41; // r2
  int v42; // r5
  uint8_t *chain_exist; // r7
  unsigned int v44; // r8
  unsigned int v46; // r9
  uint8_t *v47; // r11
  unsigned int v49; // r5
  unsigned int v50; // r7
  unsigned int v51; // r5
  uint32_t *v52; // r8
  char *v53; // r3
  unsigned int v54; // r4
  unsigned int v55; // r2
  _BOOL4 v56; // r1
  int v57; // r3
  char *v58; // r3
  unsigned int v59; // lr
  unsigned int v60; // r4
  uint32_t v61; // r12
  unsigned int asic_num; // [sp+2Ch] [bp-1058h]
  unsigned int asic_numa; // [sp+2Ch] [bp-1058h]
  unsigned int ox_num; // [sp+38h] [bp-104Ch]
  unsigned int **v65; // [sp+44h] [bp-1040h]
  int v66; // [sp+50h] [bp-1034h]
  timeval tv_start; // [sp+58h] [bp-102Ch] BYREF
  timeval tv_end; // [sp+60h] [bp-1024h] BYREF
  timeval tv_send; // [sp+68h] [bp-101Ch] BYREF
  unsigned int each_chain_error_asic[4]; // [sp+70h] [bp-1014h] BYREF
  char tmp42[4100]; // [sp+80h] [bp-1004h] BYREF

  v1 = &axi_fpga_addr;
  tv_start.tv_usec = 0;
  tv_start.tv_sec = 0;
  cgtime(&tv_end);
  cgtime(&tv_send);
  copy_time(&tv_start, &tv_end);
  copy_time(&tv_send_job, &tv_send);
  memset(each_chain_error_asic, 0, sizeof(each_chain_error_asic));
  while ( 1 )
  {
    while ( 1 )
    {
      cgtime(&tv_end);
      cgtime(&tv_send);
      v2 = tv_end.tv_sec - tv_start.tv_sec;
      if ( tv_end.tv_usec - tv_start.tv_usec < 0 )
        --v2;
      if ( v2 <= 11999 )
        break;
      copy_time(&tv_start, &tv_end);
      cgsleep_ms(3000);
    }
    if ( v2 <= 120 )
      goto LABEL_6;
    v28 = (_BYTE *)(&dev + 307);
    v29 = g_scan_freq_info.each_asic_invalid_nonce_each_2min[0];
    memset(each_chain_error_asic, 0, sizeof(each_chain_error_asic));
    do
    {
      v30 = *((_DWORD *)v28 + 3);
      v31 = v29;
      v32 = *(_DWORD *)v28;
      v28 += 16;
      v33 = *((_DWORD *)v28 - 3);
      v29 += 4;
      v34 = *((_DWORD *)v28 - 2);
      *v31 = v32;
      v31[1] = v33;
      v31[2] = v34;
      v31[3] = v30;
    }
    while ( v28 != dev.chain_asic_status_string[0] );
    v35 = g_scan_freq_info.each_asic_valid_nonce_each_2min[0];
    v36 = (_DWORD *)(&dev + 259);
    do
    {
      v37 = v36[3];
      v38 = v35;
      v39 = *v36;
      v36 += 4;
      v40 = *(v36 - 3);
      v35 += 4;
      v41 = *(v36 - 2);
      *v38 = v39;
      v38[1] = v40;
      v38[2] = v41;
      v38[3] = v37;
    }
    while ( v36 != dev.chain_asic_invalid_nonce[0] );
    v42 = 0;
    chain_exist = dev.chain_exist;
    v44 = 0;
    asic_num = 0;
    do
    {
      if ( *chain_exist++ )
      {
        v59 = chain_exist[520];
        asic_num += v59;
        if ( chain_exist[520] )
        {
          v60 = 0;
          do
          {
            v61 = dev.chain_asic_nonce[v42][v60];
            v44 += v61;
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              snprintf(tmp42, 0x1000u, "%s: chain %d asic %d asic_nonce_num %d", "check_miner_status", v42, v60, v61);
              applog(7, tmp42, 0);
              v59 = chain_exist[520];
            }
            ++v60;
          }
          while ( v59 > v60 );
        }
      }
      ++v42;
    }
    while ( v42 != 4 );
    if ( asic_num )
    {
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "%s: avg_num %d asic_num %d", "check_miner_status", v44, asic_num);
        applog(7, tmp42, 0);
      }
      ox_num = (v44 / asic_num) >> 3;
    }
    else
    {
      ox_num = 1;
    }
    v65 = v1;
    v46 = 0;
    v47 = dev.chain_exist;
    do
    {
      if ( !*v47++ )
        goto LABEL_120;
      v49 = v47[520];
      if ( !v47[520] )
      {
        v66 = 4 * v46;
        goto LABEL_150;
      }
      v66 = 4 * v46;
      v50 = 0;
      v51 = 0;
      asic_numa = v46;
      v52 = g_scan_freq_info.each_asic_ox_status[v46];
      do
      {
        if ( !v51 )
        {
          if ( v50 > 0x13 && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf(tmp42, 0x1000u, aAsicNumErrD, v50);
            applog(3, tmp42, 0);
          }
          v53 = (char *)&dev + asic_numa * 19 + v50++;
          v53[355] = 32;
        }
        v54 = v50 + v51;
        if ( ox_num < dev.chain_asic_nonce[v46][v51] )
        {
          *v52 = 0;
LABEL_151:
          if ( v54 > 0x13 && (use_syslog || opt_log_output || opt_log_level > 2) )
          {
            snprintf(tmp42, 0x1000u, aAsicNumErrD, v50 + v51);
            applog(3, tmp42, 0);
          }
          dev.chain_asic_status_string[asic_numa][v54] = 111;
          goto LABEL_144;
        }
        *v52 = 1;
        if ( *((_BYTE *)v65 + 24) )
          goto LABEL_151;
        if ( v54 > 0x13 && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(tmp42, 0x1000u, aAsicNumErrD, v50 + v51);
          applog(3, tmp42, 0);
        }
        v55 = each_chain_error_asic[v46];
        v56 = opt_debug;
        dev.chain_asic_status_string[asic_numa][v54] = 120;
        each_chain_error_asic[v46] = v55 + 1;
        if ( v56 && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "x chain%d asic%d nonce_num=%d avg_num=%d\n",
            v46,
            v51,
            dev.chain_asic_nonce[v46][v51],
            ox_num);
          applog(7, tmp42, 0);
        }
LABEL_144:
        ++v52;
        v57 = 3 * v46 + v51++;
        v58 = (char *)&dev.chain_hw[v57 + 3] + 1;
        v58[3] = 0;
        v58[4] = 0;
        v58[5] = 0;
        v58[6] = 0;
      }
      while ( v47[520] > v51 );
      v49 = v51 + v50;
      if ( v49 > 0x13 && (use_syslog || opt_log_output || opt_log_level > 2) )
      {
        snprintf(tmp42, 0x1000u, aAsicNumErrD, v49);
        applog(3, tmp42, 0);
      }
LABEL_150:
      dev.chain_asic_status_string[0][4 * (v66 + v46) - v46 + v49] = 0;
LABEL_120:
      ++v46;
    }
    while ( v46 != 4 );
    v1 = v65;
    pthread_mutex_lock(&each_chain_err_asic_mutex);
    pthread_cond_signal(&each_chain_err_asic_cond);
    pthread_mutex_unlock(&each_chain_err_asic_mutex);
    memset(dev.chain_asic_invalid_nonce, 0, sizeof(dev.chain_asic_invalid_nonce));
    memset(dev.chain_asic_nonce, 0, sizeof(dev.chain_asic_nonce));
    copy_time(&tv_start, &tv_end);
LABEL_6:
    temp_top1 = dev.temp_top1;
    if ( dev.temp_top1 > 80 || dev.temp_chip_top > 110 )
    {
      v16 = *((unsigned __int8 *)v1 + 44);
      v17 = (unsigned __int8)(*((_BYTE *)v1 + 780) + 1);
      *((_BYTE *)v1 + 780) = v17;
      if ( v17 <= 2 )
      {
        if ( !v16 && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "Temperature pcb:%d/chip:%d is higher than %d/%d'C for %d time, PWM is %d",
            temp_top1,
            dev.temp_chip_top,
            80,
            110,
            v17,
            dev.pwm_percent);
          applog(3, tmp42, 0);
        }
      }
      else
      {
        *((_BYTE *)v1 + 781) = 1;
        if ( !v16 && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "%s: the temperature pcb:%d/chip:%d is too high, close PIC and need reboot!!!",
            "check_miner_status",
            temp_top1,
            dev.temp_chip_top);
          applog(3, tmp42, 0);
        }
      }
    }
    else
    {
      *((_BYTE *)v1 + 780) = 0;
      *((_BYTE *)v1 + 781) = 0;
    }
    v4 = tv_send.tv_sec - (_DWORD)v1[165];
    if ( tv_send.tv_usec - (int)v1[166] < 0 )
      --v4;
    if ( v4 > 120 )
    {
      v5 = *((unsigned __int8 *)v1 + 44);
      *((_BYTE *)v1 + 782) = 1;
      if ( !v5 && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(
          tmp42,
          0x1000u,
          "%s: We have lost internet for %d seconds, so don't send work to hashboard anymore",
          "check_miner_status",
          v4);
        applog(7, tmp42, 0);
      }
    }
    else
    {
      *((_BYTE *)v1 + 782) = 0;
    }
    if ( (dev.fan_exist_map & 1) != 0 )
    {
      v6 = 0;
      v7 = 1;
      if ( (dev.fan_exist_map & 2) == 0 )
      {
LABEL_25:
        v8 = 1;
        goto LABEL_27;
      }
LABEL_171:
      fan_num = dev.fan_num;
      if ( dev.fan_num <= 1u )
      {
        v8 = 1;
        v10 = 1;
        v18 = 1;
        goto LABEL_66;
      }
      v10 = 1;
      goto LABEL_47;
    }
    v6 = 1;
    do
    {
      v7 = v6 + 1;
      if ( ((1 << v6) & dev.fan_exist_map) != 0 )
      {
        if ( v6 != 31 )
        {
          if ( ((1 << v7) & dev.fan_exist_map) == 0 )
            goto LABEL_25;
          goto LABEL_171;
        }
        fan_num = dev.fan_num;
        if ( dev.fan_num <= 1u )
        {
          v8 = 1;
          v7 = -1;
          v18 = 1;
          v10 = 0;
          goto LABEL_66;
        }
        v7 = -1;
        v10 = 0;
LABEL_47:
        v14 = dev.fan_speed_value[v6];
        if ( v14 < 6000 * (unsigned int)dev.fan_pwm / 0x82 )
        {
          v8 = 1;
          v18 = 2;
          goto LABEL_66;
        }
        v8 = dev.pwm_percent == 100;
        if ( v14 >= 0x12C0 )
          v8 = 0;
        if ( v8 )
        {
LABEL_191:
          v18 = 4;
          goto LABEL_66;
        }
        v8 = 1;
LABEL_30:
        if ( v10 )
        {
          v11 = dev.fan_speed_value[v7];
          if ( v11 < 4300 * (unsigned int)dev.fan_pwm / 0x82 )
          {
            v18 = 3;
            goto LABEL_66;
          }
          v10 = dev.pwm_percent == 100;
          if ( v11 >= 0xD70 )
            v10 = 0;
          if ( v10 )
            goto LABEL_191;
        }
        v1[196] = 0;
LABEL_36:
        *((_BYTE *)v1 + 788) = 0;
        goto LABEL_37;
      }
      ++v6;
    }
    while ( v7 != 32 );
    v8 = 0;
    v6 = -1;
    v7 = 0;
    do
    {
LABEL_27:
      if ( ++v7 == 32 )
      {
        fan_num = dev.fan_num;
        v7 = -1;
        v10 = 0;
        if ( dev.fan_num <= 1u )
          goto LABEL_65;
LABEL_29:
        if ( v8 )
          goto LABEL_47;
        goto LABEL_30;
      }
    }
    while ( ((1 << v7) & dev.fan_exist_map) == 0 );
    fan_num = dev.fan_num;
    v10 = 1;
    if ( dev.fan_num > 1u )
      goto LABEL_29;
LABEL_65:
    v18 = 1;
LABEL_66:
    v19 = opt_debug;
    v20 = (int)v1[196] + 1;
    v1[196] = (unsigned int *)v20;
    if ( v19 && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        tmp42,
        0x1000u,
        "ret:%d [%d:%d]fan_error_num:%d fan_num %d fan_pwm %d fan1_speed_value %d fan2_speed_value %d",
        v18,
        v8,
        v10,
        v20,
        fan_num,
        dev.fan_pwm,
        dev.fan_speed_value[v6],
        dev.fan_speed_value[v7]);
      applog(7, tmp42, 0);
      v20 = (int)v1[196];
    }
    if ( v20 <= 20 )
      goto LABEL_36;
    fan_exist_map = dev.fan_exist_map;
    v22 = 1;
    *((_BYTE *)v1 + 788) = 1;
    if ( (fan_exist_map & 1) != 0 )
    {
      v23 = 1;
      v24 = fan_exist_map & 2;
      v22 = 0;
      goto LABEL_79;
    }
    while ( 1 )
    {
      v23 = v22 + 1;
      if ( ((1 << v22) & fan_exist_map) != 0 )
        break;
      ++v22;
      if ( v23 == 32 )
      {
        v23 = 0;
        v22 = -1;
        goto LABEL_82;
      }
    }
    if ( v22 == 31 )
    {
LABEL_83:
      v23 = -1;
    }
    else
    {
      v24 = (1 << v23) & fan_exist_map;
LABEL_79:
      if ( !v24 )
      {
LABEL_82:
        while ( ++v23 != 32 )
        {
          if ( ((1 << v23) & fan_exist_map) != 0 )
            goto LABEL_84;
        }
        goto LABEL_83;
      }
    }
LABEL_84:
    switch ( v18 )
    {
      case 3:
        if ( !*((_BYTE *)v1 + 44) && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "Fan Err! Disable PIC! Fan2 speed is too low %d pwm %d ",
            dev.fan_speed_value[v23],
            dev.pwm_percent);
LABEL_180:
          applog(3, tmp42, 0);
        }
        break;
      case 4:
        if ( !*((_BYTE *)v1 + 44) && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "Fan Err! Disable PIC! Fan1:%d Fan2:%d pwm %d",
            dev.fan_speed_value[v22],
            dev.fan_speed_value[v23],
            dev.pwm_percent);
          applog(3, tmp42, 0);
        }
        break;
      case 2:
        if ( !*((_BYTE *)v1 + 44) && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(
            tmp42,
            0x1000u,
            "Fan Err! Disable PIC! Fan1 speed is too low %d pwm %d ",
            dev.fan_speed_value[v22],
            dev.pwm_percent);
          goto LABEL_180;
        }
        break;
      default:
        if ( !*((_BYTE *)v1 + 44) && (use_syslog || opt_log_output || opt_log_level > 2) )
        {
          snprintf(tmp42, 0x1000u, "Fan Err! Disable PIC! Fan num is %d", dev.fan_num);
          applog(3, tmp42, 0);
        }
        break;
    }
LABEL_37:
    v12 = *((unsigned __int8 *)v1 + 789);
    if ( *((_BYTE *)v1 + 24) )
    {
      *((_BYTE *)v1 + 782) = 0;
      if ( !v12 )
        goto LABEL_39;
LABEL_54:
      v15 = *((unsigned __int8 *)v1 + 790);
      *((_BYTE *)v1 + 656) = 1;
      if ( !v15 )
      {
        if ( !*((_BYTE *)v1 + 781) && !*((_BYTE *)v1 + 788) )
        {
LABEL_57:
          LOBYTE(v13) = *((_BYTE *)v1 + 656);
          goto LABEL_44;
        }
LABEL_98:
        *((_BYTE *)v1 + 44) = 1;
        v25 = 0;
        *((_BYTE *)v1 + 790) = 1;
        v26 = &dev.chain_exist[1];
        if ( dev.chain_exist[0] == 1 )
          goto LABEL_101;
        while ( 1 )
        {
          do
          {
            v25 = (unsigned int *)((char *)v25 + 1);
            if ( v25 == (unsigned int *)4 )
              goto LABEL_57;
            v27 = *v26++;
          }
          while ( v27 != 1 );
LABEL_101:
          pthread_mutex_lock(&iic_mutex);
          v1[168] = v25;
          disable_PIC16F1704_dc_dc_new();
          cgsleep_ms(100);
          pthread_mutex_unlock(&iic_mutex);
        }
      }
LABEL_43:
      LOBYTE(v13) = 1;
      goto LABEL_44;
    }
    if ( *((_BYTE *)v1 + 789) || *((_BYTE *)v1 + 782) )
      goto LABEL_54;
LABEL_39:
    v13 = *((unsigned __int8 *)v1 + 790);
    if ( *((_BYTE *)v1 + 781) || *((_BYTE *)v1 + 788) )
    {
      *((_BYTE *)v1 + 656) = 1;
      if ( !v13 )
        goto LABEL_98;
      goto LABEL_43;
    }
    if ( *((_BYTE *)v1 + 791) )
    {
      *((_BYTE *)v1 + 656) = 1;
      if ( !v13 )
        goto LABEL_57;
      goto LABEL_43;
    }
    *((_BYTE *)v1 + 656) = 0;
    *((_BYTE *)v1 + 44) = 0;
    if ( v13 )
    {
      *((_BYTE *)v1 + 656) = 1;
      *((_BYTE *)v1 + 44) = 1;
    }
LABEL_44:
    set_led(v13);
    cgsleep_ms(1000);
  }
}

//----- (0003B9A4) --------------------------------------------------------
int __fastcall get_fan_speed(unsigned __int8 *fan_id, unsigned int *fan_speed)
{
  int v2; // r3

  v2 = axi_fpga_addr[1];
  *fan_speed = (unsigned __int8)v2;
  *fan_id = BYTE1(v2) & 7;
  return v2;
}

//----- (0003B9D4) --------------------------------------------------------
void fan_power_on()
{
  system("echo 1 > /sys/class/gpio/gpio954/value");
  j_system("echo 1 > /sys/class/gpio/gpio955/value");
}

//----- (0003B9F4) --------------------------------------------------------
void check_fan_speed()
{
  int v0; // r10
  int v1; // r3
  uint32_t v2; // r1
  char *v3; // r3
  uint8_t fan_num; // r0
  uint32_t fan_speed_low1; // r3
  uint32_t fan_exist_map; // r2
  uint8_t v7; // r12
  bool v8; // cf
  unsigned int v9; // [sp+Ch] [bp-1004h]
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  dev.fan_speed_top1 = 0;
  dev.fan_speed_low1 = 0;
  while ( 2 )
  {
    v0 = 6;
    do
    {
      v9 = axi_fpga_addr[1];
      if ( v9 == -1 )
        goto LABEL_10;
      v1 = (v9 >> 8) & 7;
      v2 = 120 * (unsigned __int8)v9;
      dev.fan_speed_value[v1] = v2;
      if ( !(_BYTE)v9 )
      {
        v3 = (char *)&dev + v1;
        if ( v3[459] == 1 )
        {
          fan_num = dev.fan_num;
          v3[459] = 0;
          dev.fan_exist_map = 0;
          dev.fan_num = fan_num - 1;
        }
        fan_speed_low1 = dev.fan_speed_low1;
LABEL_8:
        if ( fan_speed_low1 )
          goto LABEL_10;
        goto LABEL_9;
      }
      if ( !dev.fan_exist[v1] )
      {
        fan_exist_map = dev.fan_exist_map;
        v7 = dev.fan_num;
        dev.fan_exist[v1] = 1;
        dev.fan_exist_map = fan_exist_map | (1 << v1);
        dev.fan_num = v7 + 1;
      }
      fan_speed_low1 = dev.fan_speed_low1;
      if ( v2 > dev.fan_speed_top1 )
        dev.fan_speed_top1 = 120 * (unsigned __int8)v9;
      v8 = 1;
      if ( v2 )
        v8 = v2 >= dev.fan_speed_low1;
      if ( v8 )
        goto LABEL_8;
LABEL_9:
      dev.fan_speed_low1 = 120 * (unsigned __int8)v9;
LABEL_10:
      cgsleep_ms(50);
      --v0;
    }
    while ( v0 );
    if ( dev.fan_num <= 1u )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "No %d Fan find, check again", 2);
        applog(5, tmp42, 0);
      }
      cgsleep_ms(1000);
      continue;
    }
    break;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "fan-num %d fan-map %d\n", dev.fan_num, dev.fan_exist_map);
    applog(5, tmp42, 0);
  }
}

//----- (0003BB5C) --------------------------------------------------------
void __fastcall set_PWM(unsigned __int8 pwm_percent)
{
  int v1; // r0
  uint8_t v2; // r1
  unsigned int *v3; // r2

  if ( (int)pwm_percent <= 39 )
  {
    *(_DWORD *)&pwm_percent = 40;
  }
  else if ( (int)pwm_percent > 100 )
  {
    v1 = 6553600;
    v2 = 100;
    goto LABEL_7;
  }
  if ( gMinerStatus_Not_read_all_sensor )
  {
    v1 = 6553600;
    v2 = 100;
  }
  else
  {
    v2 = pwm_percent;
    v1 = (100 - pwm_percent) | (pwm_percent << 16);
  }
LABEL_7:
  v3 = axi_fpga_addr;
  dev.pwm_percent = v2;
  axi_fpga_addr[33] = v1;
  v3[40] = v1;
}

//----- (0003BBB0) --------------------------------------------------------
float __fastcall adjust_pwm_bm1744_4chips(int temp)
{
  return temp;
}

//----- (0003BC58) --------------------------------------------------------
void set_PWM_according_to_temperature()
{
  float v0; // s0
  int fan_pwm; // r3
  int v2; // r2
  unsigned int *v3; // r1
  int v4; // r6
  unsigned int *v5; // r2
  unsigned int v6; // r3
  uint8_t v7; // r0
  unsigned int *v8; // r2
  int v9; // r1
  int v10; // r0
  int v11; // r2
  uint8_t v12; // r0
  unsigned int *v13; // r3
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  temp_highest = dev.temp_top1;
  if ( !dev.fan_eft || (fan_pwm = dev.fan_pwm, dev.fan_pwm > 0x64u) )
  {
    v4 = dev.temp_top1 > 62 || dev.temp_top1 == 0;
    if ( v4 )
    {
      v8 = axi_fpga_addr;
      dev.pwm_percent = 100;
      axi_fpga_addr[33] = 6553600;
      v8[40] = 6553600;
      dev.fan_pwm = 100;
      return;
    }
    if ( dev.temp_top1 <= 35 )
    {
      v5 = axi_fpga_addr;
      v6 = 2621500;
      if ( gMinerStatus_Not_read_all_sensor )
      {
        v6 = 6553600;
        v7 = 100;
      }
      else
      {
        v7 = 40;
      }
      dev.pwm_percent = v7;
      axi_fpga_addr[33] = v6;
      v5[40] = v6;
      dev.fan_pwm = 40;
      return;
    }
    if ( (unsigned int)(dev.temp_top1 - last_temperature + 1) <= 2 )
      return;
    adjust_pwm_bm1744_4chips(dev.temp_top1);
    v10 = (int)v0;
    if ( (int)v0 < 0 )
    {
      dev.fan_pwm = 0;
      if ( !opt_debug )
        goto LABEL_33;
      v10 = 0;
    }
    else
    {
      dev.fan_pwm = (int)v0;
      v4 = (unsigned __int8)v10;
      if ( !opt_debug )
        goto LABEL_20;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      snprintf(tmp42, 0x1000u, "%s: Set PWM percent : %d", "set_PWM_according_to_temperature", v10);
      applog(7, tmp42, 0);
      v9 = temp_highest;
    }
LABEL_20:
    if ( v4 > 39 )
    {
      if ( v4 > 100 )
        goto LABEL_22;
      goto LABEL_34;
    }
LABEL_33:
    v4 = 40;
LABEL_34:
    if ( !gMinerStatus_Not_read_all_sensor )
    {
      v12 = v4;
      v11 = (100 - v4) | (v4 << 16);
      goto LABEL_23;
    }
LABEL_22:
    v11 = 6553600;
    v12 = 100;
LABEL_23:
    v13 = axi_fpga_addr;
    dev.pwm_percent = v12;
    last_temperature = v9;
    axi_fpga_addr[33] = v11;
    v13[40] = v11;
    return;
  }
  if ( gMinerStatus_Not_read_all_sensor )
  {
    v2 = 6553600;
    LOBYTE(fan_pwm) = 100;
  }
  else
  {
    if ( dev.fan_pwm < 0x28u )
      fan_pwm = 40;
    v2 = (100 - fan_pwm) | (fan_pwm << 16);
  }
  v3 = axi_fpga_addr;
  dev.pwm_percent = fan_pwm;
  axi_fpga_addr[33] = v2;
  v3[40] = v2;
}
// 3BD32: variable 'v0' is possibly undefined
// 3BD56: variable 'v9' is possibly undefined

//----- (0003BDE8) --------------------------------------------------------
void __fastcall enable_read_temperature_from_asic_chain(unsigned int which_chain)
{
  int v1; // r1
  uint32_t regaddr; // r4
  unsigned __int8 v3; // r6
  unsigned __int8 *v4; // r5
  uint8_t v5; // t1
  uint32_t v6; // [sp+4h] [bp-1018h]
  uint8_t cmd[11]; // [sp+Ch] [bp-1010h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  v1 = dev.chain_exist[which_chain];
  *(_DWORD *)&cmd[4] = 0;
  regaddr = default_misc_reg | 0x4060;
  *(_DWORD *)&cmd[7] = 0;
  default_misc_reg |= 0x4060u;
  *(_DWORD *)cmd = 0;
  if ( v1 == 1 )
  {
    v3 = which_chain;
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s: reg_value=0x%08x chainid %u",
        "enable_read_temperature_from_asic_chain",
        regaddr,
        which_chain);
      applog(5, tmp42, 0);
    }
    v4 = TempChipAddr;
    do
    {
      v5 = *v4++;
      bm1740_makeup_set_config_cmd(cmd, 0, v5, 0x1Cu, regaddr, v6);
      uart_send(v3, cmd, 0xBu);
      cgsleep_ms(50);
    }
    while ( v4 != &TempChipAddr[3] );
  }
}
// 3BE78: variable 'v6' is possibly undefined

//----- (0003BEB0) --------------------------------------------------------
void enable_read_temperature_from_asic()
{
  enable_read_temperature_from_asic_chain(0);
  enable_read_temperature_from_asic_chain(1u);
  enable_read_temperature_from_asic_chain(2u);
  enable_read_temperature_from_asic_chain(3u);
}

//----- (0003BED0) --------------------------------------------------------
void __fastcall select_core_to_check_temperature_chain(unsigned int which_chain, uint32_t analog_mux_reg_value)
{
  uint32_t regaddr; // r6
  unsigned __int8 *v4; // r4
  uint8_t v5; // t1
  uint32_t v6; // [sp+4h] [bp-1018h]
  uint8_t cmd[11]; // [sp+Ch] [bp-1010h] BYREF
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  *(_DWORD *)cmd = 0;
  *(_DWORD *)&cmd[4] = 0;
  regaddr = analog_mux_reg_value & 0xFFFFFFF8;
  *(_DWORD *)&cmd[7] = 0;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s: analog_mux_reg_value = %08x",
      "select_core_to_check_temperature_chain",
      analog_mux_reg_value);
    applog(5, tmp42, 0);
  }
  if ( dev.chain_exist[which_chain] == 1 )
  {
    v4 = TempChipAddr;
    do
    {
      v5 = *v4++;
      bm1740_makeup_set_config_cmd(cmd, 0, v5, 0x40u, regaddr, v6);
      uart_send(which_chain, cmd, 0xBu);
      cgsleep_ms(2);
    }
    while ( v4 != &TempChipAddr[3] );
  }
}
// 3BF5C: variable 'v6' is possibly undefined

//----- (0003BF84) --------------------------------------------------------
void __fastcall select_core_to_check_temperature(uint32_t analog_mux_reg_value)
{
  unsigned int i; // r4
  unsigned int v3; // r0
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s: analog_mux_reg_value = %08x",
      "select_core_to_check_temperature",
      analog_mux_reg_value);
    applog(5, tmp42, 0);
  }
  for ( i = 0; i != 4; ++i )
  {
    v3 = i;
    select_core_to_check_temperature_chain(v3, analog_mux_reg_value);
  }
}

//----- (0003BFF4) --------------------------------------------------------
void __fastcall write_i2c_reg(
        unsigned __int8 which_chain,
        unsigned __int8 which_sensor,
        uint8_t i2c_dev_addr,
        uint8_t i2c_reg_addr,
        uint8_t i2c_reg_data)
{
  uint8_t v6; // r1
  uint32_t v7; // [sp+4h] [bp-18h]
  uint8_t cmd_buf[11]; // [sp+Ch] [bp-10h] BYREF

  v6 = *((_BYTE *)&axi_fpga_addr + which_sensor + 800);
  *(_DWORD *)cmd_buf = 0;
  *(_DWORD *)&cmd_buf[4] = 0;
  *(_DWORD *)&cmd_buf[7] = 0;
  bm1740_makeup_set_config_cmd(
    cmd_buf,
    0,
    v6,
    0x20u,
    default_i2c_reg & 0xFE010000
  | 0x1000000
  | ((i2c_dev_addr & 0x7F) << 17)
  | (i2c_reg_addr << 8)
  | i2c_reg_data
  | 0x10000,
    v7);
  uart_send(which_chain, cmd_buf, 0xBu);
  cgsleep_ms(50);
}
// 3C040: variable 'v7' is possibly undefined

//----- (0003C058) --------------------------------------------------------
void enable_sensor_extend_mode()
{
  int v0; // r4
  uint8_t *chain_exist; // r6
  int v2; // t1
  int i; // r5
  unsigned __int8 v4; // r1

  LOBYTE(v0) = 0;
  chain_exist = dev.chain_exist;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      for ( i = 0; i != 3; ++i )
      {
        v4 = i;
        write_i2c_reg(v0, v4, 0x4Cu, 9u, 4u);
      }
    }
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
}

//----- (0003C094) --------------------------------------------------------
void __fastcall reset_chain(bitmain_ZCASH_info *info, uint8_t chain)
{
  int v3; // r5
  char *v4; // r3
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  v3 = chain;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "%s chainid %d", "reset_chain", chain);
    applog(4, tmp42, 0);
  }
  pthread_mutex_lock(&iic_mutex);
  i2c_slave_addr = v3;
  disable_PIC16F1704_dc_dc_new();
  pthread_mutex_unlock(&iic_mutex);
  v4 = (char *)&axi_fpga_addr + v3;
  v4[652] = 0;
  v4[776] = 0;
  v4[668] = 1;
  thr_info_join(&info->uart_tx_t[v3]);
  thr_info_join(&info->uart_rx_t[v3]);
  send_heart = 0;
  pthread_mutex_lock(&iic_mutex);
  i2c_slave_addr = v3;
  reset_PIC16F1704_pic_new();
  cgsleep_ms(1000);
  jump_from_loader_to_app_PIC16F1704_new();
  cgsleep_ms(1000);
  pthread_mutex_unlock(&iic_mutex);
  send_heart = 1;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s %d", "reset_hash_board_low", v3);
    applog(5, tmp42, 0);
  }
  axi_fpga_addr[13] = 1 << v3;
  cgsleep_ms(100);
  pthread_mutex_lock(&iic_mutex);
  i2c_slave_addr = v3;
  enable_PIC16F1704_dc_dc_new();
  pthread_mutex_unlock(&iic_mutex);
  sleep(1u);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s %d", "reset_hash_board_high", v3);
    applog(5, tmp42, 0);
  }
  axi_fpga_addr[13] = 0;
  *((_BYTE *)&axi_fpga_addr + v3 + 668) = 0;
  tty_init_chain(v3, info);
  set_fpga_baud(0x1Au);
  cgsleep_ms(100);
  set_baud_chain(v3, 0);
  cgsleep_ms(1000);
  set_fpga_baud(0);
  cgsleep_ms(100);
}

//----- (0003C27C) --------------------------------------------------------
int __fastcall calculate_asic_number(unsigned int actual_asic_number)
{
  if ( actual_asic_number != 1 && actual_asic_number != 2 )
  {
    if ( actual_asic_number - 3 <= 1 )
    {
      return 4;
    }
    else if ( actual_asic_number - 5 <= 3 )
    {
      return 8;
    }
    else if ( actual_asic_number - 9 <= 7 )
    {
      return 16;
    }
    else if ( actual_asic_number - 17 <= 0xF )
    {
      return 32;
    }
    else if ( actual_asic_number - 33 <= 0x1F )
    {
      return 64;
    }
    else if ( actual_asic_number - 65 <= 0x3F )
    {
      return 128;
    }
    else if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      return calculate_asic_number_0(actual_asic_number);
    }
    else
    {
      return -1;
    }
  }
  return actual_asic_number;
}

//----- (0003C304) --------------------------------------------------------
void calculate_address_interval()
{
  int v0; // r0
  uint8_t addrInterval; // r2
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  v0 = 256 / calculate_asic_number(3u);
  dev.addrInterval = v0;
  if ( use_syslog || opt_log_output || (addrInterval = v0, opt_log_level > 4) )
  {
    snprintf(tmp42, 0x1000u, "%s:addrInterval = %d", "calculate_address_interval", (unsigned __int8)v0);
    applog(5, tmp42, 0);
    addrInterval = dev.addrInterval;
  }
  TempChipAddr[1] = addrInterval;
  TempChipAddr[2] = 2 * addrInterval;
  TempChipAddr[0] = 0;
}

//----- (0003C39C) --------------------------------------------------------
int create_bitmain_scan_freq_pthread()
{
  int v0; // r5
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  auto_freq_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(auto_freq_id, 0, (void *(*)(void *))scan_freq_handle, 0) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_scan_freq_pthread");
      applog(7, tmp42, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(auto_freq_id->pth);
    cgsleep_ms(500);
    return v0;
  }
}
// 3C428: variable 'v0' is possibly undefined

//----- (0003C448) --------------------------------------------------------
int create_bitmain_turbo_mode_monitor_pthread()
{
  int v0; // r5
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  auto_freq_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(auto_freq_id, 0, (void *(*)(void *))turbo_mode_monitor, 0) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_turbo_mode_monitor_pthread");
      applog(7, tmp42, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(auto_freq_id->pth);
    cgsleep_ms(500);
    return v0;
  }
}
// 3C4D4: variable 'v0' is possibly undefined

//----- (0003C4F4) --------------------------------------------------------
int __fastcall every_chain_read_pic_freq_data(unsigned __int8 (*freq_table)[9])
{
  uint8_t *chain_exist; // r5
  int data_from_PIC16F1704_flash; // r6
  int v4; // r4
  int v5; // t1
  int v7; // r1
  unsigned __int8 *v8; // r12
  unsigned __int8 v9; // r3
  unsigned __int8 buf[9]; // [sp+4h] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+10h] [bp-1000h] BYREF

  chain_exist = dev.chain_exist;
  data_from_PIC16F1704_flash = 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = *chain_exist++;
    if ( v5 == 1 )
      break;
LABEL_3:
    if ( ++v4 == 4 )
      return data_from_PIC16F1704_flash;
  }
  memset(buf, 0, sizeof(buf));
  pthread_mutex_lock(&iic_mutex);
  i2c_slave_addr = v4;
  data_from_PIC16F1704_flash = read_data_from_PIC16F1704_flash(buf, 0, 9u);
  cgsleep_ms(100);
  pthread_mutex_unlock(&iic_mutex);
  if ( data_from_PIC16F1704_flash )
  {
    if ( data_from_PIC16F1704_flash > 0 )
    {
      xxtea_decode((uint32_t *)&buf[1], 2, sec_key[v4]);
      v7 = *(_DWORD *)&buf[4];
      v8 = &(*freq_table)[9 * v4];
      v9 = buf[8];
      *(_DWORD *)v8 = *(_DWORD *)buf;
      *((_DWORD *)v8 + 1) = v7;
      v8[8] = v9;
    }
    goto LABEL_3;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "chain%d pic not support flash data storage, adopt file mode\n", v4);
    applog(5, tmp42, 0);
  }
  return data_from_PIC16F1704_flash;
}

//----- (0003C5DC) --------------------------------------------------------
int __fastcall every_chain_write_freq_to_pic(unsigned __int8 (*freq_table)[9])
{
  uint8_t *chain_exist; // r5
  int v3; // r9
  int i; // r4
  int v5; // t1

  chain_exist = dev.chain_exist;
  v3 = 1;
  for ( i = 0; i != 4; ++i )
  {
    v5 = *chain_exist++;
    if ( v5 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = i;
      v3 = write_data_to_PIC16F1704_flash(&(*freq_table)[9 * i], 0, 9);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
  }
  return v3;
}

//----- (0003C638) --------------------------------------------------------
int clear_every_chain_freq_to_pic()
{
  uint8_t *chain_exist; // r5
  int v1; // r7
  int v2; // r4
  int v3; // t1
  unsigned __int8 freq_table[4][9]; // [sp+4h] [bp-24h] BYREF

  chain_exist = dev.chain_exist;
  v1 = 1;
  v2 = 0;
  memset(freq_table, 0, sizeof(freq_table));
  do
  {
    v3 = *chain_exist++;
    if ( v3 == 1 )
    {
      pthread_mutex_lock(&iic_mutex);
      i2c_slave_addr = v2;
      v1 = write_data_to_PIC16F1704_flash(freq_table[v2], 0, 9);
      cgsleep_ms(100);
      pthread_mutex_unlock(&iic_mutex);
    }
    ++v2;
  }
  while ( v2 != 4 );
  return v1;
}

//----- (0003C6A0) --------------------------------------------------------
void scan_freq_init_freq()
{
  uint8_t *chain_exist; // r6
  int v1; // r1
  uint8_t *v2; // r3
  int v3; // t1
  int i; // r4
  int v5; // t1
  int *v6; // r5
  int v7; // r0
  int v8; // r1
  int v9; // r2
  int v10; // r3
  int v11; // r5
  const char *v12; // r5
  int v13; // r0
  int v14; // r1
  int v15; // r2
  int v16; // r3
  int *v17; // r5
  int v18; // r0
  int v19; // r1
  int v20; // r2
  int v21; // r3
  int v22; // r1
  int v23; // r2
  int v24; // r3
  int v25; // r12
  uint32_t *v26; // r5
  unsigned __int8 *v27; // r9
  int v28; // t1
  int v29; // r8
  uint32_t v30; // r6
  int v31; // r4
  FILE *v32; // r8
  uint8_t *v33; // r7
  int v34; // t1
  int v35; // r5
  _DWORD *v36; // r6
  uint8_t *v37; // [sp+1Ch] [bp-1030h]
  unsigned __int8 freq_table[4][9]; // [sp+24h] [bp-1028h] BYREF
  char tmp42[4096]; // [sp+48h] [bp-1004h] BYREF

  memset(freq_table, 0, 12);
  every_chain_get_pic_version();
  g_scan_freq_info.scan_freq_store_pos = every_chain_read_pic_freq_data(freq_table);
  if ( g_scan_freq_info.scan_freq_store_pos > 0 )
  {
    chain_exist = dev.chain_exist;
    v1 = 0;
    v2 = dev.chain_exist;
    while ( 1 )
    {
      v3 = *v2++;
      if ( v3 == 1 && freq_table[v1][0] != 78 )
        break;
      if ( ++v1 == 4 )
      {
        for ( i = 0; i != 4; ++i )
        {
          v5 = *chain_exist++;
          if ( v5 == 1 )
          {
            v37 = chain_exist;
            v25 = 0;
            v26 = g_scan_freq_info.each_asic_freq[i];
            v27 = &freq_table[i][1];
            do
            {
              v28 = *v27++;
              v29 = v25 + 1;
              v30 = *(_DWORD *)&_FUNCTION___15596[16 * v28 + 2004];
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf(tmp42, 0x1000u, "pic read chain%d asic%d freq %d\n", i, v25, v30);
                applog(5, tmp42, 0);
              }
              v25 = v29;
              if ( v30 - 775 > 0x32 )
                *v26 = 800;
              ++v26;
              if ( v30 - 775 <= 0x32 )
                *(v26 - 1) = v30;
            }
            while ( v29 != 3 );
            chain_exist = v37;
          }
        }
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          v6 = (int *)&unk_59E9C;
          goto LABEL_11;
        }
        goto LABEL_12;
      }
    }
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      v12 = "1 Goto scan mode and find the best frequency\n";
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v31 = access("/config/chips_freq.config", 0);
  if ( !v31 )
  {
    v32 = fopen("/config/chips_freq.config", "r");
    if ( v32 )
    {
      v33 = dev.chain_exist;
      do
      {
        v34 = *v33++;
        if ( v34 == 1 )
        {
          v35 = 0;
          v36 = (uint32_t *)((char *)g_scan_freq_info.each_asic_freq[0] + v31);
          do
          {
            *(_DWORD *)tmp42 = 0;
            fscanf(v32, "%d", tmp42);
            if ( (unsigned int)(*(_DWORD *)tmp42 - 775) <= 0x32 )
            {
              if ( *(_DWORD *)tmp42 == 775 )
                *v36 = 775;
              else
                *v36 = *(_DWORD *)tmp42;
            }
            else
            {
              *v36 = 800;
            }
            ++v35;
            ++v36;
          }
          while ( v35 != 3 );
        }
        v31 += 12;
      }
      while ( v31 != 48 );
      fclose(v32);
    }
    else
    {
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
      {
LABEL_45:
        if ( opt_log_level <= 4 )
        {
LABEL_12:
          create_bitmain_turbo_mode_monitor_pthread();
          return;
        }
LABEL_46:
        v6 = (int *)&unk_59F0C;
LABEL_11:
        v7 = *v6;
        v8 = v6[1];
        v9 = v6[2];
        v10 = v6[3];
        v11 = v6[4];
        *(_DWORD *)tmp42 = v7;
        *(_DWORD *)&tmp42[4] = v8;
        *(_DWORD *)&tmp42[8] = v9;
        *(_DWORD *)&tmp42[12] = v10;
        *(_WORD *)&tmp42[16] = v11;
        tmp42[18] = BYTE2(v11);
        applog(5, tmp42, 0);
        goto LABEL_12;
      }
      snprintf(tmp42, 0x1000u, "open %s failed\n", "/config/chips_freq.config");
      applog(5, tmp42, 0);
    }
    if ( use_syslog || opt_log_output )
      goto LABEL_46;
    goto LABEL_45;
  }
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    v12 = "2 Goto scan mode and find the best frequency\n";
LABEL_17:
    v13 = *(_DWORD *)v12;
    v14 = *((_DWORD *)v12 + 1);
    v15 = *((_DWORD *)v12 + 2);
    v16 = *((_DWORD *)v12 + 3);
    v17 = (int *)(v12 + 16);
    *(_DWORD *)tmp42 = v13;
    *(_DWORD *)&tmp42[4] = v14;
    *(_DWORD *)&tmp42[8] = v15;
    *(_DWORD *)&tmp42[12] = v16;
    v18 = *v17;
    v19 = v17[1];
    v20 = v17[2];
    v21 = v17[3];
    v17 += 4;
    *(_DWORD *)&tmp42[16] = v18;
    *(_DWORD *)&tmp42[20] = v19;
    *(_DWORD *)&tmp42[24] = v20;
    *(_DWORD *)&tmp42[28] = v21;
    v22 = v17[1];
    v23 = v17[2];
    v24 = v17[3];
    *(_DWORD *)&tmp42[32] = *v17;
    *(_DWORD *)&tmp42[36] = v22;
    *(_DWORD *)&tmp42[40] = v23;
    *(_WORD *)&tmp42[44] = v24;
    applog(5, tmp42, 0);
  }
LABEL_18:
  create_bitmain_scan_freq_pthread();
}

//----- (0003C9BC) --------------------------------------------------------
int scan_freq_save_freq()
{
  uint8_t *chain_exist; // r7
  int v1; // r4
  int v2; // t1
  int v4; // r6
  uint32_t *v5; // r5
  unsigned __int8 *v6; // r8
  int v7; // r0
  int v8; // t1
  freq_pll_str *v9; // r2
  int freq; // r1
  int v11; // r3
  int v12; // t1
  FILE *v13; // r8
  uint8_t *v14; // r6
  int i; // r5
  int v16; // t1
  uint32_t *v17; // r9
  int v18; // r7
  uint32_t v19; // t1
  unsigned __int8 buf[4][9]; // [sp+1Ch] [bp-1028h] BYREF
  char tmp42[4100]; // [sp+40h] [bp-1004h] BYREF

  if ( g_scan_freq_info.scan_freq_store_pos > 0 )
  {
    chain_exist = dev.chain_exist;
    v1 = 0;
    memset(buf, 0, sizeof(buf));
    while ( 1 )
    {
      v2 = *chain_exist++;
      if ( v2 != 1 )
        goto LABEL_4;
      v4 = 0;
      v5 = g_scan_freq_info.each_asic_freq[v1];
      v6 = buf[v1];
      *v6 = 78;
      do
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(tmp42, 0x1000u, "pic write chain%d asic%d freq %d\n", v1, v4, *v5);
          applog(5, tmp42, 0);
          v12 = *v5++;
          v7 = v12;
          if ( v12 == 100 )
          {
LABEL_18:
            LOBYTE(v11) = 0;
            goto LABEL_15;
          }
        }
        else
        {
          v8 = *v5++;
          v7 = v8;
          if ( v8 == 100 )
            goto LABEL_18;
        }
        v9 = freq_pll;
        freq = 125;
        v11 = 1;
        while ( 1 )
        {
          ++v9;
          if ( v7 == freq )
            break;
          if ( ++v11 == 119 )
          {
            LOBYTE(v11) = -1;
            break;
          }
          freq = v9[1].freq;
        }
LABEL_15:
        ++v4;
        *++v6 = v11;
      }
      while ( v4 != 3 );
      xxtea_encode((uint32_t *)&buf[v1][1], 2, sec_key[v1]);
LABEL_4:
      if ( ++v1 == 4 )
      {
        every_chain_write_freq_to_pic(buf);
        return 0;
      }
    }
  }
  v13 = fopen("/config/chips_freq.config", "w+");
  if ( v13 )
  {
    v14 = dev.chain_exist;
    for ( i = 0; i != 4; ++i )
    {
      v16 = *v14++;
      if ( v16 == 1 )
      {
        v17 = &g_scan_freq_info.each_asic_max_freq[i + 3][2];
        v18 = 3;
        do
        {
          v19 = v17[1];
          ++v17;
          fprintf(v13, "%d ", v19);
          --v18;
        }
        while ( v18 );
      }
    }
    fclose(v13);
    return 0;
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s open %s failed\n", "scan_freq_save_freq", "/config/chips_freq.config");
    applog(5, tmp42, 0);
    return -1;
  }
  else
  {
    return -1;
  }
}

//----- (0003CB9C) --------------------------------------------------------
void __noreturn scan_freq_handle()
{
  scan_freq_status *v0; // r2
  uint8_t *chain_exist; // r4
  int v2; // t1
  scan_freq_status *v3; // r3
  int v4; // r0
  int v5; // r9
  int v6; // r5
  uint8_t *v7; // r8
  int v8; // t1
  scan_freq_status *v9; // r4
  int v10; // r10
  int v11; // r7
  int v12; // r5
  int v13; // r3
  int v14; // r6
  uint32_t *v15; // r4
  int v16; // r12
  uint32_t v17; // r1
  uint32_t v18; // r0
  freq_pll_str *v19; // r2
  int freq; // r7
  int v21; // r3
  freq_pll_str *v22; // r1
  int v23; // r7
  int v24; // r2
  int v25; // r2
  int v26; // r0
  int v27; // r2
  unsigned int v28; // r2
  _BOOL4 v29; // r3
  const char *v30; // r3
  uint32_t v31; // r7
  freq_pll_str *v32; // r3
  int v33; // r0
  int v34; // r2
  int v35; // r2
  uint32_t v36; // lr
  freq_pll_str *v37; // r1
  int v38; // r0
  int v39; // r3
  uint32_t v40; // r12
  uint8_t *v41; // [sp+24h] [bp-1040h]
  uint32_t v42; // [sp+38h] [bp-102Ch]
  char tmp42[4100]; // [sp+60h] [bp-1004h] BYREF

  set_frequency(0x320u);
  v0 = &g_scan_freq_info;
  chain_exist = dev.chain_exist;
  while ( 1 )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      v3 = v0;
      v4 = 3;
      do
      {
        --v4;
        v3->each_asic_invalid_nonce_each_2min[0][0] = 0;
        v3 = (scan_freq_status *)((char *)v3 + 4);
        v3->each_asic_valid_nonce_each_2min[3][2] = 0;
        v3->each_asic_max_freq[3][2] = 800;
        v3->each_asic_min_freq[3][2] = 815;
        v3->each_asic_ox_status[3][2] = 775;
        v3->each_asic_freq[3][2] = 0;
      }
      while ( v4 );
      v0 = (scan_freq_status *)((char *)v0 + 12);
      if ( v0 == (scan_freq_status *)&g_scan_freq_info.each_asic_invalid_nonce_each_2min[3][2] )
      {
LABEL_7:
        v5 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            do
            {
              ++v5;
              sleep(1u);
              pthread_mutex_lock(&each_chain_err_asic_mutex);
              pthread_cond_wait(&each_chain_err_asic_cond, &each_chain_err_asic_mutex);
              pthread_mutex_unlock(&each_chain_err_asic_mutex);
              v6 = status_error;
            }
            while ( status_error );
            if ( v5 != 1 )
              break;
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              strcpy(tmp42, "ignore first 2 minutes\n");
              applog(5, tmp42, 0);
            }
          }
          v7 = dev.chain_exist;
          do
          {
            v8 = *v7++;
            if ( v8 == 1 )
            {
              v14 = 0;
              v15 = g_scan_freq_info.each_asic_invalid_nonce_each_2min[v6];
              v16 = v15[24];
              v17 = v15[60];
              if ( v16 )
                goto LABEL_48;
LABEL_24:
              if ( *v15 <= 0x19 )
              {
                v18 = v15[48];
                if ( v18 != v17 )
                {
                  v15[36] = v17;
                  if ( v17 == 100 )
                  {
                    if ( v18 != 100 )
                    {
                      v21 = v16;
                      goto LABEL_32;
                    }
                    v25 = v16;
                    v21 = v16;
                  }
                  else
                  {
                    v19 = freq_pll;
                    freq = 125;
                    v21 = 1;
                    while ( 1 )
                    {
                      ++v19;
                      if ( v17 == freq )
                      {
                        if ( v18 != 100 )
                          goto LABEL_32;
                        v24 = 0;
                        goto LABEL_36;
                      }
                      if ( ++v21 == 119 )
                        break;
                      freq = v19[1].freq;
                    }
                    v21 = -1;
                    if ( v18 == 100 )
                    {
LABEL_70:
                      v27 = v21 + 1;
                      v26 = 1;
LABEL_38:
                      v28 = *(_DWORD *)&_FUNCTION___15596[16 * v27 + 2004];
                      v29 = opt_debug;
                      v15[60] = v28;
                      if ( v29 && (use_syslog || opt_log_output || opt_log_level > 6) )
                      {
                        v30 = "down";
                        if ( v26 == 1 )
                          v30 = "up";
                        snprintf(
                          tmp42,
                          0x1000u,
                          "%s freq[%d-%d]: cur freq %d, [%d, %d], invalid nonce %d, ox status %d\n",
                          v30,
                          v6,
                          v14,
                          v28,
                          v15[36],
                          v15[48],
                          *v15,
                          v16);
                        applog(7, tmp42, 0);
                        v28 = v15[60];
                      }
                      set_freq_asic(v6, v14, v28);
                      goto LABEL_46;
                    }
LABEL_32:
                    v22 = freq_pll;
                    v23 = 125;
                    v24 = 1;
                    while ( 1 )
                    {
                      ++v22;
                      if ( v18 == v23 )
                        goto LABEL_36;
                      if ( ++v24 == 119 )
                        break;
                      v23 = v22[1].freq;
                    }
                    v24 = -1;
LABEL_36:
                    v25 = v24 - v21;
                    if ( v25 == 1 )
                      goto LABEL_70;
                  }
                  v26 = 1;
                  v27 = v21 + v25 / 2;
                  goto LABEL_38;
                }
                goto LABEL_85;
              }
              while ( 1 )
              {
LABEL_48:
                v31 = v15[36];
                if ( v17 != v31 )
                {
                  if ( v17 == 100 )
                  {
                    if ( v31 != 100 )
                    {
                      v35 = -1;
                      v36 = 0;
                      goto LABEL_55;
                    }
                    v39 = 0;
                    v35 = -1;
                    v36 = 0;
                    goto LABEL_62;
                  }
                  v32 = freq_pll;
                  v33 = 125;
                  v34 = 1;
                  while ( 1 )
                  {
                    ++v32;
                    if ( v17 == v33 )
                    {
                      v35 = v34 - 1;
                      v36 = *(_DWORD *)&_FUNCTION___15596[16 * v35 + 2004];
                      if ( v31 == 100 )
                      {
                        v39 = 0;
                      }
                      else
                      {
LABEL_55:
                        v37 = freq_pll;
                        v38 = 125;
                        v39 = 1;
                        while ( 1 )
                        {
                          ++v37;
                          if ( v38 == v31 )
                          {
                            v35 -= v39;
                            goto LABEL_60;
                          }
                          if ( ++v39 == 119 )
                            break;
                          v38 = v37[1].freq;
                        }
                        ++v35;
                        v39 = -1;
                      }
LABEL_60:
                      if ( v35 != 1 )
                        goto LABEL_62;
                      v27 = v39 + 1;
                      goto LABEL_63;
                    }
                    if ( ++v34 == 119 )
                      break;
                    v33 = v32[1].freq;
                  }
                  if ( v31 != 100 )
                  {
                    v35 = -2;
                    v36 = 0;
                    goto LABEL_55;
                  }
                  v39 = 0;
                  v35 = -2;
                  v36 = 0;
LABEL_62:
                  v27 = v39 + v35 / 2;
LABEL_63:
                  v26 = -1;
                  v15[48] = v36;
                  goto LABEL_38;
                }
LABEL_85:
                v15[72] = 1;
LABEL_46:
                ++v14;
                ++v15;
                if ( v14 == 3 )
                  break;
                v16 = v15[24];
                v17 = v15[60];
                if ( !v16 )
                  goto LABEL_24;
              }
            }
            ++v6;
          }
          while ( v6 != 4 );
          v9 = &g_scan_freq_info;
          v10 = 0;
          v11 = 0;
          v12 = 0;
          v41 = dev.chain_exist;
          do
          {
            v13 = *v41++;
            if ( v13 == 1 )
            {
              v40 = v9->each_asic_freq[0][2];
              v42 = v9->each_asic_freq[0][1];
              v10 += v9->each_asic_freq[0][0] + v42 + v40;
              v11 += v9->is_asic_scan_freq_done[0][0]
                   + v9->is_asic_scan_freq_done[0][1]
                   + v9->is_asic_scan_freq_done[0][2];
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(tmp42, 0x1000u, "chain%d %d %d %d\n", v12, v9->each_asic_freq[0][0], v42, v40);
                applog(7, tmp42, 0);
              }
            }
            ++v12;
            v9 = (scan_freq_status *)((char *)v9 + 12);
          }
          while ( v12 != 4 );
          if ( 3 * dev.chain_num == v11 )
          {
            scan_freq_save_freq();
            if ( use_syslog || opt_log_output || opt_log_level > 4 )
            {
              snprintf(tmp42, 0x1000u, "scan freq done, avg freq %d max %d, reboot cgminer\n", v10 / v11, 815);
              applog(5, tmp42, 0);
            }
            system("/etc/init.d/cgminer.sh restart > /dev/null 2>&1 &");
          }
        }
      }
    }
    else
    {
      v0 = (scan_freq_status *)((char *)v0 + 12);
      if ( v0 == (scan_freq_status *)&g_scan_freq_info.each_asic_invalid_nonce_each_2min[3][2] )
        goto LABEL_7;
    }
  }
}

//----- (0003CFFC) --------------------------------------------------------
void __fastcall set_miner_name(char *name)
{
  FILE *v2; // r4
  FILE *v3; // r4
  char rbuf1[128]; // [sp+0h] [bp-1084h] BYREF
  char tmp42[4100]; // [sp+80h] [bp-1004h] BYREF

  v2 = fopen("/usr/bin/compile_time", "r");
  memset(rbuf1, 0, sizeof(rbuf1));
  fgets(rbuf1, 128, v2);
  fclose(v2);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "rbuf1 %s\n", rbuf1);
    applog(5, tmp42, 0);
  }
  v3 = fopen("/usr/bin/compile_time", "w");
  fputs(rbuf1, v3);
  fprintf(v3, "Antminer %s\n", name);
  fclose(v3);
}

//----- (0003D0B8) --------------------------------------------------------
void *__fastcall bitmain_ZCASH_reinit_chain(void *usrdata)
{
  pthread_t v2; // r0
  unsigned int v3; // r4
  void *result; // r0
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s Begin\n", "bitmain_ZCASH_reinit_chain");
    applog(5, tmp42, 0);
  }
  v2 = pthread_self();
  pthread_detach(v2);
  pthread_mutex_lock(&reinit_mutex);
  v3 = *((unsigned __int8 *)usrdata + 4);
  reset_chain(*(bitmain_ZCASH_info **)usrdata, *((_BYTE *)usrdata + 4));
  software_set_address_chain(v3);
  cgsleep_ms(100);
  set_frequency_chain(v3, dev.freq[v3]);
  cgsleep_ms(100);
  set_core_timeout_chain(v3, (unsigned int)&loc_13880);
  cgsleep_ms(100);
  set_ticket_mask_chain(v3, default_ticket_mask_reg);
  cgsleep_ms(100);
  enable_read_temperature_from_asic_chain(v3);
  *((_BYTE *)&axi_fpga_addr + v3 + 652) = 1;
  sleep(1u);
  result = (void *)pthread_mutex_unlock(&reinit_mutex);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s Done\n", "bitmain_ZCASH_reinit_chain");
    applog(5, tmp42, 0);
  }
  return result;
}

//----- (0003D1F0) --------------------------------------------------------
void __fastcall suffix_string_ZCASH(uint64_t val, char *buf, size_t bufsiz, int sigdigits, bool display)
{
  double v7; // d9
  double v8; // d8
  int v9; // r3
  int v10; // s16
  double v11; // r0
  char suffix[8]; // [sp+1Ch] [bp-8h] BYREF

  *(_WORD *)suffix = 0;
  if ( val <= 0x3B9AC9FF )
  {
    if ( val <= 0xF423F )
    {
      v7 = (double)(int)val;
      if ( val < 0x3E8 )
      {
        if ( !sigdigits )
        {
          snprintf(buf, bufsiz, "%d%s", (_DWORD)val, suffix);
          return;
        }
      }
      else
      {
        strcpy(suffix, "K");
        v7 = v7 / 1000.0;
        if ( !sigdigits )
          goto LABEL_3;
      }
    }
    else
    {
      val /= 0x3E8uLL;
      strcpy(suffix, "M");
      v7 = (double)(int)val / 1000.0;
      if ( !sigdigits )
        goto LABEL_3;
    }
  }
  else
  {
    *(double *)&val = (double)(val / 0xF4240);
    strcpy(suffix, "G");
    v7 = *(double *)&val / 1000.0;
    if ( !sigdigits )
    {
LABEL_3:
      snprintf(buf, bufsiz, "%.3g%s", v7, suffix);
      return;
    }
  }
  v8 = (double)(sigdigits - 1);
  if ( v7 > 0.0 )
  {
    v11 = log10(*(double *)&val);
    floor(v11);
    v9 = sigdigits + 1;
    v10 = (int)(v8 - v7);
    if ( !display )
      goto LABEL_10;
  }
  else
  {
    v9 = sigdigits + 1;
    v10 = (int)v8;
    if ( !display )
    {
LABEL_10:
      snprintf(buf, bufsiz, "%*.*f", v9, v10, v7);
      return;
    }
  }
  snprintf(buf, bufsiz, "%*.*f%s", v9, v10, v7, suffix);
}

//----- (0003D378) --------------------------------------------------------
void calculate_hash_rate()
{
  uint64_t *v0; // r9
  uint8_t *chain_exist; // r11
  int v2; // r4
  int v4; // r5
  _BOOL4 v5; // r7
  int v6; // r6
  unsigned int v7; // r5
  unsigned int v8; // r3
  char *v9; // r2
  unsigned int v10; // r6
  int i; // r5
  unsigned int v12; // r3
  uint64_t tmp_rate; // [sp+10h] [bp-102Ch]
  uint64_t tmp_ratea; // [sp+10h] [bp-102Ch]
  uint64_t tmp_rt_rate_all_chain_low4; // [sp+1Ch] [bp-1020h]
  char tmp42[4100]; // [sp+38h] [bp-1004h] BYREF

  v0 = rate;
  chain_exist = dev.chain_exist;
  v2 = 0;
  tmp_rt_rate_all_chain_low4 = 0;
  do
  {
    while ( 1 )
    {
      if ( *chain_exist++ )
      {
        if ( g_HASH_RATE_reg_value_num[v2] )
        {
          if ( g_HASH_RATE_reg_value_num[v2] <= 2u )
          {
            for ( i = 0; i != 3; ++i )
            {
              if ( !g_HASH_RATE_reg_value_from_which_asic[v2][0]
                && !status_error
                && opt_debug
                && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  tmp42,
                  0x1000u,
                  "%s: Chain%d ASIC%d didn't send back HASH_RATE register value",
                  "calculate_hash_rate",
                  v2,
                  i);
                applog(7, tmp42, 0);
              }
            }
            v12 = (unsigned __int8)(rate_error[v2] + 1);
            rate_error[v2] = v12;
            if ( v12 > 3 || status_error )
            {
              *v0 = 0;
              suffix_string_ZCASH(0, &displayed_rate[16 * v2], 0x10u, 6, 1);
            }
          }
          else
          {
            v4 = is_rt;
            v5 = opt_debug;
            if ( is_rt )
            {
              v6 = 0;
              tmp_rate = 0;
              do
              {
                v7 = g_HASH_RATE_reg_value[v2][v6] & 0x7FFFFFFF;
                tmp_rate += v7;
                if ( v5 && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(
                    tmp42,
                    0x1000u,
                    "%s: RT g_HASH_RATE_reg_value[%d][%d] = 0x%08x",
                    "calculate_hash_rate",
                    v2,
                    v6,
                    v7);
                  applog(7, tmp42, 0);
                  v5 = opt_debug;
                }
                ++v6;
              }
              while ( v6 != 3 );
              if ( v5 && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  tmp42,
                  0x1000u,
                  "%s: chain%d RT hash rate is %0.2fGHz/s",
                  "calculate_hash_rate",
                  v2,
                  (double)tmp_rate / 1000000.0);
                applog(7, tmp42, 0);
              }
              *v0 = 1000000 * tmp_rate;
              rate_error[v2] = 0;
              suffix_string_ZCASH(1000000 * tmp_rate, &displayed_rate[16 * v2], 0x10u, 6, 0);
            }
            else
            {
              tmp_ratea = 0;
              do
              {
                v10 = g_HASH_RATE_reg_value[v2][v4] & 0x7FFFFFFF;
                tmp_ratea += v10;
                if ( v5 && (use_syslog || opt_log_output || opt_log_level > 6) )
                {
                  snprintf(
                    tmp42,
                    0x1000u,
                    "%s: avg g_HASH_RATE_reg_value[%d][%d] = 0x%08x",
                    "calculate_hash_rate",
                    v2,
                    v4,
                    v10);
                  applog(7, tmp42, 0);
                  v5 = opt_debug;
                }
                ++v4;
              }
              while ( v4 != 3 );
              if ( v5 && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                snprintf(
                  tmp42,
                  0x1000u,
                  "%s: chain%d avg hash rate is %0.2fGHz/s",
                  "calculate_hash_rate",
                  v2,
                  (double)tmp_ratea / 1000000.0);
                applog(7, tmp42, 0);
              }
              rate_error[v2] = 0;
            }
          }
          tmp_rt_rate_all_chain_low4 += *v0;
          goto LABEL_19;
        }
        v8 = (unsigned __int8)(rate_error[v2] + 1);
        rate_error[v2] = v8;
        if ( v8 > 3 || status_error )
          break;
      }
LABEL_19:
      ++v2;
      ++v0;
      if ( v2 == 4 )
        goto LABEL_20;
    }
    v9 = &displayed_rate[16 * v2++];
    *v0 = 0;
    suffix_string_ZCASH(0, v9, 0x10u, 6, 1);
    ++v0;
  }
  while ( v2 != 4 );
LABEL_20:
  suffix_string_ZCASH(tmp_rt_rate_all_chain_low4, displayed_hash_rate, 0x10u, 6, 0);
}

//----- (0003D7C8) --------------------------------------------------------
void clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  reg_fifo.p_wr = 0;
  reg_fifo.p_rd = 0;
  reg_fifo.reg_value_num = 0;
  j_pthread_mutex_unlock(&reg_mutex);
}

//----- (0003D7F0) --------------------------------------------------------
void __fastcall check_asic_reg(unsigned __int8 which_chain, unsigned __int8 chip_addr, unsigned __int8 reg, bool mode)
{
  uint32_t v4; // r5
  int v5; // r11
  int v6; // r10
  unsigned int status_cmd; // r0
  int i; // r4
  uint32_t reg_value_num; // r7
  int v10; // r4
  uint32_t p_rd; // r3
  char *v12; // r2
  int v13; // r0
  int v14; // r2
  unsigned int v15; // r3
  unsigned int v16; // r1
  unsigned __int8 *v17; // r12
  bool *v18; // r0
  int v19; // r1
  int v20; // t1
  uint8_t regaddr; // [sp+0h] [bp-1044h]
  uint8_t all[4]; // [sp+10h] [bp-1034h]
  int v23; // [sp+18h] [bp-102Ch]
  int16_t v24; // [sp+2Ch] [bp-1018h]
  uint8_t cmd_buf[8]; // [sp+38h] [bp-100Ch] BYREF
  char tmp42[4100]; // [sp+40h] [bp-1004h] BYREF

  v4 = mode;
  v5 = which_chain;
  memset(cmd_buf, 0, 7);
  v6 = reg;
  *(_DWORD *)all = chip_addr;
  clear_register_value_buf();
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s: check chain J%d mode %d chipaddr %02x regaddr %02x",
      "check_asic_reg",
      v5,
      v4,
      *(_DWORD *)all,
      v6);
    applog(7, tmp42, 0);
  }
  status_cmd = bm1740_makeup_get_status_cmd(cmd_buf, v4, all[0], v6, regaddr);
  uart_send(v5, cmd_buf, status_cmd);
  if ( !v6 && *((_BYTE *)&axi_fpga_addr + v5 + 3456) )
    dev.chain_asic_num[v5] = 0;
  for ( i = 0; i != 3; ++i )
  {
LABEL_9:
    usleep(0x493E0u);
    pthread_mutex_lock(&reg_mutex);
    reg_value_num = reg_fifo.reg_value_num;
    pthread_mutex_unlock(&reg_mutex);
    if ( reg_value_num )
    {
      v10 = 0;
      while ( 1 )
      {
        while ( 1 )
        {
          pthread_mutex_lock(&reg_mutex);
          p_rd = reg_fifo.p_rd;
          v12 = (char *)&reg_fifo + 7 * reg_fifo.p_rd;
          v13 = (unsigned __int8)v12[18];
          if ( v13 == v5 )
            break;
          ++reg_fifo.p_rd;
          if ( p_rd == 99 )
            reg_fifo.p_rd = 0;
          --reg_fifo.reg_value_num;
          if ( use_syslog || opt_log_output || opt_log_level > 4 )
          {
            snprintf(
              tmp42,
              0x1000u,
              "%s: the return data is from chain%d, but it should be from chain%d chipaddr=0x%02x reg=0x%02x\n",
              "check_asic_reg",
              v13,
              v5,
              *(_DWORD *)all,
              v6);
            applog(5, tmp42, 0);
          }
          ++v10;
          pthread_mutex_unlock(&reg_mutex);
          if ( reg_value_num == v10 )
          {
LABEL_25:
            i = 0;
            goto LABEL_9;
          }
        }
        v14 = (unsigned __int8)v12[17];
        v15 = bswap32(*(_DWORD *)reg_fifo.reg_buffer[reg_fifo.p_rd].reg_data);
        if ( v6 )
        {
          switch ( v6 )
          {
            case 12:
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf(tmp42, 0x1000u, "%s: the asic freq is 0x%08x", "check_asic_reg", v15);
LABEL_31:
                applog(5, tmp42, 0);
              }
              break;
            case 20:
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf(tmp42, 0x1000u, "%s: the asic tm is 0x%08x", "check_asic_reg", v15);
                goto LABEL_31;
              }
              break;
            case 28:
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf(tmp42, 0x1000u, "%s: the asic misc is 0x%08x", "check_asic_reg", v15);
                goto LABEL_31;
              }
              break;
            case 32:
              if ( (v15 & 0xC0000000) == 0 )
              {
                v17 = TempChipAddr;
                v18 = g_chip_temp_return[(__int16)v5][0];
                v24 = (unsigned __int8)v15 - 64;
                v23 = v15 & 0xFF00;
                v19 = 4 * (__int16)v5;
                do
                {
                  v20 = *v17++;
                  if ( v14 == v20 )
                  {
                    if ( (v15 & 0xFF00) != 0 )
                    {
                      switch ( v23 )
                      {
                        case 256:
                          v18[1] = 1;
                          dev.chain_asic_temp[0][v19 - v5][1] = v24;
                          break;
                        case 4352:
                          send_back_gTempOffsetValue[v19] = v15;
                          v18[2] = 1;
                          break;
                        case 65024:
                          sensor_id[v19] = v15;
                          v18[3] = 1;
                          break;
                      }
                    }
                    else
                    {
                      *v18 = 1;
                      dev.chain_asic_temp[0][v19 - v5][0] = v24;
                    }
                  }
                  ++v19;
                  v18 += 4;
                }
                while ( v19 != 4 * (__int16)v5 + 3 );
              }
              break;
            case 84:
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf(tmp42, 0x1000u, "%s: the start nonce offset is 0x%08x", "check_asic_reg", v15);
                goto LABEL_31;
              }
              break;
            default:
              if ( v6 == 48 && (use_syslog || opt_log_output || opt_log_level > 4) )
              {
                snprintf(tmp42, 0x1000u, "%s: the asic IO strength is 0x%08x", "check_asic_reg", v15);
                goto LABEL_31;
              }
              break;
          }
        }
        else if ( *((_BYTE *)&axi_fpga_addr + v5 + 3456) )
        {
          ++dev.chain_asic_num[v5];
        }
        else if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          snprintf(tmp42, 0x1000u, "%s: the asic address is 0x%08x", "check_asic_reg", v15);
          goto LABEL_31;
        }
        ++v10;
        ++reg_fifo.p_rd;
        --reg_fifo.reg_value_num;
        if ( reg_fifo.p_rd == 100 )
          reg_fifo.p_rd = 0;
        pthread_mutex_unlock(&reg_mutex);
        if ( reg_value_num == v10 )
          goto LABEL_25;
      }
    }
    usleep((__useconds_t)&loc_1869E + 2);
  }
  if ( !v6 )
  {
    v16 = dev.chain_asic_num[v5];
    if ( dev.max_asic_num_in_one_chain < v16 )
      dev.max_asic_num_in_one_chain = dev.chain_asic_num[v5];
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(tmp42, 0x1000u, "%s: chain J%d has %d ASIC", "check_asic_reg", v5, v16);
      applog(5, tmp42, 0);
    }
  }
  clear_register_value_buf();
}
// 3D86A: variable 'regaddr' is possibly undefined

//----- (0003DCB8) --------------------------------------------------------
void check_every_chain_asic_pll()
{
  uint8_t *chain_exist; // r5
  int v1; // r4
  int v2; // t1
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "check_every_chain_asic_pll");
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  LOBYTE(v1) = 0;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      check_asic_reg(v1, 0, 0xCu, 1);
      cgsleep_ms(100);
    }
    v1 = (unsigned __int8)(v1 + 1);
  }
  while ( v1 != 4 );
}

//----- (0003DD40) --------------------------------------------------------
void __fastcall check_chain_asic_number(unsigned __int8 which_chain, bool whether_update_asic_num)
{
  if ( dev.chain_exist[which_chain] )
  {
    *((_BYTE *)&axi_fpga_addr + which_chain + 3456) = whether_update_asic_num;
    check_asic_reg(which_chain, 0, 0, 1);
  }
}

//----- (0003DD70) --------------------------------------------------------
void __fastcall check_every_chain_asic_number(bool whether_update_asic_num)
{
  uint8_t *chain_exist; // r5
  int i; // r4
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "check_every_chain_asic_number");
    applog(5, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    if ( *chain_exist++ )
    {
      update_asic_num[i] = whether_update_asic_num;
      check_asic_reg(i, 0, 0, 1);
    }
    cgsleep_ms(100);
  }
}

//----- (0003DDFC) --------------------------------------------------------
void __fastcall get_reg_value(uint8_t regaddr)
{
  uint8_t v1; // r2
  uint8_t v2; // r3
  uint8_t *chain_exist; // r5
  uint32_t v4; // r7
  int v5; // r4
  int v6; // t1
  uint8_t cmd[12]; // [sp+0h] [bp-Ch] BYREF

  v2 = 0;
  chain_exist = dev.chain_exist;
  v4 = regaddr;
  LOBYTE(v5) = 0;
  memset(cmd, 0, 7);
  do
  {
    v6 = *chain_exist++;
    if ( v6 == 1 )
    {
      bm1740_makeup_get_status_cmd_0(cmd, v4, v1, v2, cmd[0]);
      uart_send(v5, cmd, 7u);
      cgsleep_ms(200);
      check_asic_reg(v5, 0, v4, 1);
    }
    v5 = (unsigned __int8)(v5 + 1);
  }
  while ( v5 != 4 );
}
// 3DE26: variable 'v1' is possibly undefined
// 3DE26: variable 'v2' is possibly undefined

//----- (0003DE4C) --------------------------------------------------------
void __fastcall read_i2c_reg(
        unsigned __int8 which_chain,
        unsigned __int8 which_sensor,
        uint8_t i2c_dev_addr,
        uint8_t i2c_reg_addr)
{
  unsigned int v4; // r9
  int v5; // r6
  int v6; // r7
  int v8; // r8
  int v9; // r4
  char *v10; // r8
  int v11; // r3
  uint32_t v12; // [sp+4h] [bp-1014h]
  uint8_t cmd_buf[11]; // [sp+Ch] [bp-100Ch] BYREF
  char tmp42[4096]; // [sp+18h] [bp-1000h] BYREF

  v4 = i2c_reg_addr;
  v5 = which_chain;
  *(_DWORD *)cmd_buf = 0;
  *(_DWORD *)&cmd_buf[4] = 0;
  v6 = which_sensor;
  *(_DWORD *)&cmd_buf[7] = 0;
  cgsleep_ms(50);
  if ( v4 < 2 )
  {
    v8 = v4;
  }
  else if ( v4 == 17 )
  {
    v8 = 2;
  }
  else
  {
    if ( v4 != 254 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 3 )
      {
        snprintf(tmp42, 0x1000u, "%s unknow reg_type %d\n", "read_i2c_reg", v4);
        applog(4, tmp42, 0);
      }
      return;
    }
    v8 = 3;
  }
  bm1740_makeup_set_config_cmd(
    cmd_buf,
    0,
    *((_BYTE *)&axi_fpga_addr + v6 + 800),
    0x20u,
    default_i2c_reg & 0xFE000000
  | 0x1000000
  | ((i2c_dev_addr & 0x7F) << 17)
  | (unsigned __int16)((unsigned __int8)v4 << 8),
    v12);
  uart_send(v5, cmd_buf, 0xBu);
  cgsleep_ms(200);
  v9 = 0;
  v10 = (char *)&(&(&axi_fpga_addr)[3 * v5])[v6] + v8;
  v10[3460] = 0;
  do
  {
    ++v9;
    cgsleep_ms(50);
    check_asic_reg(v5, *((_BYTE *)&axi_fpga_addr + v6 + 800), 0x20u, 0);
    if ( v9 == 3 )
      v11 = 0;
    else
      v11 = ((unsigned __int8)v10[3460] ^ 1) & 1;
  }
  while ( v11 );
}
// 3DF10: variable 'v12' is possibly undefined

//----- (0003DF84) --------------------------------------------------------
void __fastcall set_temperature_offset_value_chain_sensor(unsigned __int8 which_chain, unsigned __int8 which_sensor)
{
  int v2; // r5
  int v3; // r7
  char *v4; // r4
  int v5; // r1
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v2 = which_chain;
  v3 = which_sensor;
  if ( use_syslog || opt_log_output || opt_log_level > 3 )
  {
    snprintf(tmp42, 0x1000u, "Chain %d %s", which_chain, "set_temperature_offset_value_chain_sensor");
    applog(4, tmp42, 0);
  }
  v4 = (char *)&(&axi_fpga_addr)[v2] + v3;
  write_i2c_reg(v2, v3, 0x4Cu, 0x11u, v4[3540]);
  cgsleep_ms(50);
  read_i2c_reg(v2, v3, 0x4Cu, 0x11u);
  v5 = v4[3540];
  if ( v4[3508] == v5 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s: Chain%d Sensor%d temp offset : %02d, ",
        "set_temperature_offset_value_chain_sensor",
        v2,
        v3,
        v4[3508]);
      applog(5, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(
      tmp42,
      0x1000u,
      "%s: Chain%d Sensor%d temp offset value set error. It should be %02d, but read back is %02d\n",
      "set_temperature_offset_value_chain_sensor",
      v2,
      v3,
      v5,
      v4[3508]);
    applog(3, tmp42, 0);
  }
}

//----- (0003E0B8) --------------------------------------------------------
void __fastcall calibration_sensor_offset_chain(unsigned __int8 which_chain)
{
  int v1; // r6
  char *v2; // r5
  char *v3; // r8
  int v4; // r4
  int v5; // r3
  int v6; // r12
  char v7; // r2
  int v8; // r3
  unsigned __int8 v9[4]; // [sp+Ch] [bp-1008h]
  char tmp42[4100]; // [sp+10h] [bp-1004h] BYREF

  v1 = which_chain;
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%d %s", which_chain, "calibration_sensor_offset_chain");
    applog(5, tmp42, 0);
  }
  v2 = (char *)&dev + 24 * (__int16)v1;
  v3 = &gTempOffsetValue[4 * (__int16)v1];
  *(_DWORD *)v9 = 0;
  do
  {
    LOBYTE(v4) = 11;
    do
    {
      read_i2c_reg(v1, v9[0], 0x4Cu, 1u);
      read_i2c_reg(v1, v9[0], 0x4Cu, 0);
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        snprintf(tmp42, 0x1000u, "chain:%d local:%d remote:%d", v1, *((__int16 *)v2 + 64), *((__int16 *)v2 + 65));
        applog(5, tmp42, 0);
      }
      v5 = *((__int16 *)v2 + 64);
      v6 = *((__int16 *)v2 + 65);
      v7 = *v3 + v5;
      v8 = v5 - v6;
      *v3 = v7 - v6;
      if ( v8 < 0 )
        v8 = -v8;
      if ( v8 <= 2 )
        break;
      set_temperature_offset_value_chain_sensor(v1, v9[0]);
      v4 = (unsigned __int8)(v4 - 1);
    }
    while ( v4 );
    ++v3;
    v2 += 8;
    ++*(_DWORD *)v9;
  }
  while ( *(_DWORD *)v9 != 3 );
}

//----- (0003E200) --------------------------------------------------------
void calibration_sensor_offset()
{
  int v0; // r4
  uint8_t *chain_exist; // r5
  int v2; // t1

  LOBYTE(v0) = 0;
  chain_exist = dev.chain_exist;
  do
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      calibration_sensor_offset_chain(v0);
      cgsleep_ms(200);
    }
    v0 = (unsigned __int8)(v0 + 1);
  }
  while ( v0 != 4 );
}

//----- (0003E22C) --------------------------------------------------------
void check_sensor_ID()
{
  uint8_t *chain_exist; // r11
  int i; // r4
  int v2; // t1
  int v3; // r5
  char *v4; // r8
  int v5; // r12
  int v6; // t1
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "check_sensor_ID");
    applog(7, tmp42, 0);
  }
  chain_exist = dev.chain_exist;
  for ( i = 0; i != 4; ++i )
  {
    v2 = *chain_exist++;
    if ( v2 == 1 )
    {
      v3 = 0;
      v4 = &sensor_id[4 * i];
      do
      {
        read_i2c_reg(i, v3, 0x4Cu, 0xFEu);
        v6 = *v4++;
        v5 = v6;
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(tmp42, 0x1000u, "%s: Chain%d Sensor%d Manufacturer ID = 0x%02x", "check_sensor_ID", i, v3, v5);
          applog(3, tmp42, 0);
        }
        ++v3;
      }
      while ( v3 != 3 );
    }
  }
}

//----- (0003E32C) --------------------------------------------------------
void __noreturn read_temp_func()
{
  all_parameters *v0; // r11
  uint8_t *chain_exist; // r5
  int v2; // r4
  int v3; // t1
  __int16 *v4; // r5
  int v5; // r4
  _BOOL4 v6; // r9
  int v7; // r7
  unsigned int *v8; // r3
  int v9; // r6
  _BOOL4 v10; // r11
  bool *v11; // r8
  bool *v12; // r2
  __int16 *v13; // r9
  int v14; // r12
  int v15; // r12
  int v16; // r2
  int v17; // r3
  int v18; // r1
  uint32_t *v19; // r6
  _BOOL4 v20; // r0
  int i; // r7
  unsigned __int8 v22; // r8
  unsigned __int8 v23; // r1
  int tmpTemp; // [sp+14h] [bp-1028h]
  all_parameters *v25; // [sp+18h] [bp-1024h]
  char tmp42[4100]; // [sp+38h] [bp-1004h] BYREF

  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "read_temp_func");
    applog(7, tmp42, 0);
  }
  v0 = &dev;
  while ( 1 )
  {
    while ( 1 )
    {
      chain_exist = dev.chain_exist;
      v2 = 0;
      sleep(1u);
      do
      {
        v3 = *chain_exist++;
        if ( v3 == 1 && start_send[v2] )
        {
          for ( i = 0; i != 3; ++i )
          {
            v22 = i;
            v23 = i;
            read_i2c_reg(v2, v23, 0x4Cu, 1u);
            read_i2c_reg(v2, v22, 0x4Cu, 0);
          }
        }
        ++v2;
        cgsleep_ms(200);
      }
      while ( v2 != 4 );
      v4 = (__int16 *)&dev;
      v5 = 0;
      v6 = 0;
      v7 = -256;
      tmpTemp = -256;
      do
      {
        if ( v0->chain_exist[v5] == 1 && start_send[v5] )
        {
          v25 = v0;
          v9 = 0;
          v10 = v6;
          v11 = g_chip_temp_return[v5][0];
          do
          {
            if ( v11[4 * v9] )
            {
              v10 = v11[4 * v9];
            }
            else
            {
              v12 = &v11[4 * v9];
              if ( v12[1] )
                v10 = v12[1];
            }
            v13 = &v4[4 * v9];
            v14 = v13[64];
            if ( v14 > tmpTemp )
            {
              if ( v14 > 80 && !status_error && (use_syslog || opt_log_output || opt_log_level > 2) )
              {
                tmpTemp = v13[64];
                snprintf(
                  tmp42,
                  0x1000u,
                  "%s: Chain%d sensor%d local temp is %d `C, higher than MAX_TEMP",
                  "read_temp_func",
                  v5,
                  v9,
                  tmpTemp);
                applog(3, tmp42, 0);
              }
              else
              {
                tmpTemp = v13[64];
              }
            }
            v15 = v13[65];
            if ( v15 > v7 )
            {
              if ( v15 > 110 && !status_error && (use_syslog || opt_log_output || opt_log_level > 2) )
              {
                v7 = v13[65];
                snprintf(
                  tmp42,
                  0x1000u,
                  "%s: Chain%d sensor%d remote temp is %d `C, higher than MAX_CHIP_TEMP",
                  "read_temp_func",
                  v5,
                  v9,
                  v15);
                applog(3, tmp42, 0);
              }
              else
              {
                v7 = v13[65];
              }
            }
            ++v9;
          }
          while ( v9 != 3 );
          v16 = v4[68];
          v6 = v10;
          v17 = v4[69];
          v0 = v25;
          if ( v16 < v4[64] )
            v16 = v4[64];
          v18 = v4[72];
          if ( v16 < -256 )
            v16 = -256;
          if ( v17 < v4[65] )
            v17 = v4[65];
          v19 = &v25->pwm_value + v5;
          if ( v17 < -256 )
            v17 = -256;
          if ( v18 < v16 )
            v18 = v16;
          v20 = opt_debug;
          if ( v17 < v4[73] )
            v17 = v4[73];
          *(uint32_t *)((char *)v19 + 653) = v18;
          *(uint32_t *)((char *)v19 + 669) = v17;
          if ( v20 && (use_syslog || opt_log_output || opt_log_level > 6) )
          {
            snprintf(tmp42, 0x1000u, "chain%d, max local temp :%d, max remote temp: %d", v5, v18, v17);
            applog(7, tmp42, 0);
          }
        }
        ++v5;
        v4 += 12;
      }
      while ( v5 != 4 );
      v0->temp_chip_top = v7;
      v0->temp_top1 = tmpTemp;
      if ( !v6 )
        break;
      gMinerStatus_Not_read_all_sensor = 0;
      if ( stop )
        goto LABEL_17;
LABEL_63:
      set_PWM_according_to_temperature();
    }
    gMinerStatus_Not_read_all_sensor = 1;
    if ( !status_error && opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s: can't read all sensor's temperature, close PIC and need reboot!!!",
        "read_temp_func");
      applog(7, tmp42, 0);
    }
    if ( !stop )
      goto LABEL_63;
LABEL_17:
    v8 = axi_fpga_addr;
    v0->pwm_percent = 100;
    v8[33] = 6553600;
    v8[40] = 6553600;
  }
}

//----- (0003E6B0) --------------------------------------------------------
void __fastcall recheck_asic_num(bitmain_ZCASH_info *info, uint8_t chain)
{
  int v2; // r5
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  v2 = chain;
  pthread_mutex_lock(&reinit_mutex);
  reset_chain(info, v2);
  pthread_mutex_unlock(&reinit_mutex);
  clear_register_value_buf();
  cgsleep_ms(100);
  if ( dev.chain_exist[v2] )
  {
    *((_BYTE *)&axi_fpga_addr + v2 + 3456) = 1;
    check_asic_reg(v2, 0, 0, 1);
  }
  cgsleep_ms(200);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "%s DONE!", "recheck_asic_num");
    applog(5, tmp42, 0);
  }
}

//----- (0003E764) --------------------------------------------------------
void clear_nonce_fifo()
{
  pthread_mutex_lock(&nonce_mutex);
  nonce_fifo.p_wr = 0;
  nonce_fifo.p_rd = 0;
  nonce_fifo.nonce_num = 0;
  clear_uart_rx_fifo(0);
  clear_uart_rx_fifo(1u);
  clear_uart_rx_fifo(2u);
  clear_uart_rx_fifo(3u);
  j_pthread_mutex_unlock(&nonce_mutex);
}

//----- (0003E7A4) --------------------------------------------------------
int __fastcall target_zero_cal(uint8_t *target)
{
  unsigned __int8 *v2; // r6
  uint8_t *v3; // r0
  uint8_t *v4; // r3
  uint8_t v5; // t1
  int v6; // r5
  int v7; // r4
  int v8; // r1
  char v10; // [sp+0h] [bp-25h] BYREF
  uint8_t tmphash[32]; // [sp+1h] [bp-24h] BYREF
  char v12; // [sp+21h] [bp-4h] BYREF

  memset(tmphash, 0, sizeof(tmphash));
  v2 = tmphash;
  v3 = target + 32;
  v4 = (uint8_t *)&v10;
  do
  {
    v5 = *--v3;
    *++v4 = v5;
  }
  while ( v4 != &tmphash[31] );
  v6 = 0;
LABEL_4:
  v7 = 7;
  while ( 1 )
  {
    v8 = v7--;
    if ( bit_read(v2, v8) )
      return v6;
    ++v6;
    if ( v7 == -1 )
    {
      if ( ++v2 != (unsigned __int8 *)&v12 )
        goto LABEL_4;
      return v6;
    }
  }
}

//----- (0003E7F4) --------------------------------------------------------
bool __fastcall target_match(unsigned __int8 *result_value, unsigned __int8 *target)
{
  unsigned __int8 *v2; // r1
  unsigned __int8 *v3; // r3
  unsigned int v4; // r4
  unsigned int v5; // t1
  unsigned int v6; // t1
  bool v7; // cc

  v2 = target + 32;
  v3 = result_value + 32;
  while ( 1 )
  {
    v5 = *--v3;
    v4 = v5;
    v6 = *--v2;
    v7 = v4 > v6;
    if ( v4 < v6 )
      return 1;
    if ( v7 )
      break;
    if ( v3 == result_value )
      return 1;
  }
  return 0;
}

//----- (0003E820) --------------------------------------------------------
int create_bitmain_check_fan_pthread()
{
  int v0; // r5
  char tmp42[4100]; // [sp+0h] [bp-1004h] BYREF

  check_fan_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(check_fan_id, 0, (void *(*)(void *))check_fan_thr, 0) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_check_fan_pthread");
      applog(7, tmp42, 0);
    }
    return -8;
  }
  else
  {
    pthread_detach(check_fan_id->pth);
    cgsleep_ms(500);
    return v0;
  }
}
// 3E8AC: variable 'v0' is possibly undefined

//----- (0003E8CC) --------------------------------------------------------
int __fastcall create_bitmain_check_miner_status_pthread(bitmain_ZCASH_info *info)
{
  int v1; // r6
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  check_miner_status_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(check_miner_status_id, 0, (void *(*)(void *))check_miner_status, info) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "%s: create thread for check miner_status", "create_bitmain_check_miner_status_pthread");
      applog(7, tmp42, 0);
    }
    return -5;
  }
  else
  {
    pthread_detach(check_miner_status_id->pth);
    cgsleep_ms(500);
    return v1;
  }
}
// 3E956: variable 'v1' is possibly undefined

//----- (0003E974) --------------------------------------------------------
int create_bitmain_get_hash_rate_pthread()
{
  int v0; // r6
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  read_hash_rate = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_hash_rate, 0, (void *(*)(void *))get_hash_rate, read_hash_rate) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s: create thread for get hashrate from asic failed",
        "create_bitmain_get_hash_rate_pthread");
      applog(7, tmp42, 0);
    }
    return -6;
  }
  else
  {
    pthread_detach(read_hash_rate->pth);
    cgsleep_ms(500);
    return v0;
  }
}
// 3E9FC: variable 'v0' is possibly undefined

//----- (0003EA18) --------------------------------------------------------
unsigned __int8 __fastcall read_temperature_through_fpga_iic_register(unsigned __int8 which_chain)
{
  unsigned int v1; // r4
  unsigned __int8 v2; // r6

  v1 = (which_chain << 16) | 0x1900000;
  pthread_mutex_lock(&i2c_mutex);
  v2 = i2c_read(v1);
  i2c_read(v1);
  cgsleep_ms(100);
  pthread_mutex_unlock(&i2c_mutex);
  return v2;
}

//----- (0003EA4C) --------------------------------------------------------
int create_bitmain_read_temp_pthread()
{
  int v0; // r6
  char tmp42[4096]; // [sp+0h] [bp-1000h] BYREF

  read_temp_id = (thr_info *)calloc(1u, 0x40u);
  if ( thr_info_create(read_temp_id, 0, (void *(*)(void *))read_temp_func, read_temp_id) )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(tmp42, 0x1000u, "%s: create thread for read temp", "create_bitmain_read_temp_pthread");
      applog(7, tmp42, 0);
    }
    return -7;
  }
  else
  {
    pthread_detach(read_temp_id->pth);
    cgsleep_ms(500);
    return v0;
  }
}
// 3EAD4: variable 'v0' is possibly undefined

//----- (0003EAF0) --------------------------------------------------------
int __fastcall bitmain_ZCASH_init(bitmain_ZCASH_info *info)
{
  pool **v2; // r3
  int v3; // r12
  pool **v4; // r0
  int v5; // r1
  int v6; // t1
  _BYTE *v7; // r2
  _BYTE *v8; // r2
  int v9; // r3
  int v10; // r3
  uint8_t v11; // r1
  unsigned int *v12; // r2
  int hash_rate_pthread; // r9
  init_config *p_config_parameter; // r0
  unsigned int v16; // r3
  int i; // r2
  int version; // t1
  int v19; // r2
  int v20; // r3
  char *v21; // r3
  int v22; // r9
  uint8_t *chain_exist; // r10
  int v24; // t1
  uint8_t *v25; // r11
  int v26; // r9
  uint32_t v27; // r10
  int v28; // t1
  unsigned int fan_pwm_percent; // r6
  _BOOL4 v30; // r1
  int v31; // r3
  unsigned int *v32; // r2
  bool v33; // zf
  int v34; // r11
  int v35; // r3
  _BOOL4 v36; // r2
  char v37; // [sp+20h] [bp-104Ch]
  init_config config; // [sp+28h] [bp-1044h]
  init_config config_parameter; // [sp+48h] [bp-1024h] BYREF
  unsigned __int8 tmp42[455][9]; // [sp+68h] [bp-1004h] BYREF

  config = info->ZCASH_config;
  set_miner_name("Z15j");
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy((char *)tmp42, "z15j init...\n");
    applog(5, (const char *)tmp42, 0);
  }
  start_http_thread();
  while ( 1 )
  {
    if ( total_pools > 0 )
    {
      v2 = pools;
      v3 = 0;
      v4 = &pools[total_pools];
      do
      {
        while ( 1 )
        {
          v6 = (int)*v2++;
          v5 = v6;
          v7 = *(_BYTE **)(v6 + 196);
          if ( !v7 )
            break;
          if ( !*v7 )
            break;
          v8 = *(_BYTE **)(v5 + 204);
          if ( !v8 || !*v8 )
            break;
          ++v3;
          if ( v4 == v2 )
            goto LABEL_12;
        }
      }
      while ( v4 != v2 );
      if ( v3 )
        break;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 3 )
    {
      strcpy((char *)tmp42, "No valid pools, please configure them first!!!");
      applog(4, (const char *)tmp42, 0);
    }
    sleep(5u);
  }
LABEL_12:
  bitmain_axi_init();
  init_fpga();
  set_fpga_baud(0x1Au);
  config_parameter = config;
  dev.addrInterval = 1;
  strcpy(g_miner_version, "9.0.0.5");
  system("echo 1 > /sys/class/gpio/gpio954/value");
  system("echo 1 > /sys/class/gpio/gpio955/value");
  v9 = (unsigned __int8)opt_bitmain_fan_pwm;
  if ( (unsigned __int8)opt_bitmain_fan_pwm <= 0x27u )
  {
    v9 = 40;
  }
  else if ( (unsigned __int8)opt_bitmain_fan_pwm > 0x64u )
  {
    v10 = 6553600;
    v11 = 100;
    goto LABEL_18;
  }
  if ( gMinerStatus_Not_read_all_sensor )
  {
    v10 = 6553600;
    v11 = 100;
  }
  else
  {
    v11 = v9;
    v10 = (100 - v9) | (v9 << 16);
  }
LABEL_18:
  v12 = axi_fpga_addr;
  dev.pwm_percent = v11;
  axi_fpga_addr[33] = v10;
  v12[40] = v10;
  check_fan_speed();
  if ( config_parameter.token_type != 81 )
  {
    if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
      return -1;
    snprintf(
      (char *)tmp42,
      0x1000u,
      "%s: config_parameter.token_type != 0x%x, it is 0x%x",
      "bitmain_ZCASH_init",
      81,
      config_parameter.token_type);
    hash_rate_pthread = -1;
    applog(3, (const char *)tmp42, 0);
    return hash_rate_pthread;
  }
  p_config_parameter = &config_parameter;
  v16 = 255;
  for ( i = 81; ; i = version )
  {
    v16 = (unsigned __int16)(*(_WORD *)&_FUNCTION___15596[2 * (i ^ (v16 >> 8)) + 100] ^ ((_WORD)v16 << 8));
    if ( p_config_parameter == (init_config *)&config_parameter.reg_address )
      break;
    version = p_config_parameter->version;
    p_config_parameter = (init_config *)((char *)p_config_parameter + 1);
  }
  if ( config_parameter.crc == v16 )
  {
    v19 = 0;
    do
    {
      v20 = v19 + 28;
      ++v19;
      v21 = &info->update_lock.mutex.__size[4 * v20];
      *((_WORD *)v21 + 3) = 0;
      *((_WORD *)v21 + 4) = 0;
    }
    while ( v19 != 128 );
    check_chain();
    if ( certification_firmware )
    {
      config_parameter.fan_pwm_percent = 50;
      *((_BYTE *)&config_parameter + 8) |= 2u;
      rt_chain_num = dev.chain_num;
    }
    every_chain_reset_PIC16F1704_pic_new();
    every_chain_jump_from_loader_to_app_PIC16F1704_new();
    sleep(1u);
    hash_rate_pthread = send_heart_beat_to_every_chain();
    if ( hash_rate_pthread == -3 )
      return hash_rate_pthread;
    if ( !access("/tmp/delete_freq", 0) )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy((char *)tmp42, "delete freq data and scan freq again\n");
        applog(5, (const char *)tmp42, 0);
      }
      memset(tmp42, 0, 0x24u);
      every_chain_write_freq_to_pic(tmp42);
      system("rm /tmp/delete_freq");
      sleep(3u);
      exit(1);
    }
    v37 = *((_BYTE *)&config_parameter + 8);
    if ( (*((_BYTE *)&config_parameter + 8) & 8) == 0 )
      goto LABEL_51;
    v33 = config_parameter.frequency == 0;
    if ( config_parameter.frequency )
      v33 = config_parameter.frequency == 800;
    if ( v33 )
LABEL_51:
      dev.frequency = 800;
    else
      dev.frequency = config_parameter.frequency;
    reset_all_hash_board_low();
    cgsleep_ms(100);
    every_chain_disable_PIC16F1704_dc_dc_new();
    cgsleep_ms(200);
    cgsleep_ms(200);
    every_chain_enable_PIC16F1704_dc_dc_new();
    cgsleep_ms(100);
    if ( use_syslog || opt_log_output || opt_log_level > 4 )
    {
      snprintf((char *)tmp42, 0x1000u, "%s %d", "reset_all_hash_board_high", 4398);
      applog(5, (const char *)tmp42, 0);
    }
    v22 = 0;
    axi_fpga_addr[13] = 0;
    cgsleep_ms(100);
    tty_init(info);
    sleep(3u);
    set_baud(config_parameter.baud);
    cgsleep_ms(100);
    calculate_address_interval();
    dev.corenum = 1;
    clear_register_value_buf();
    cgsleep_ms(100);
    sleep(2u);
    chain_exist = dev.chain_exist;
    check_every_chain_asic_number(1);
    cgsleep_ms(300);
    do
    {
      v24 = *chain_exist++;
      if ( v24 == 1 )
      {
        v34 = 3;
        need_recheck[v22] = 1;
        while ( 1 )
        {
          v35 = chain_exist[520];
          if ( v35 == 3 )
            break;
          v36 = use_syslog;
          need_recheck[v22] = 1;
          if ( !v36 && !opt_log_output && opt_log_level <= 4
            || (snprintf(
                  (char *)tmp42,
                  0x1000u,
                  "recheck: chainid %d exist %d asicnum %d realnum %d",
                  v22,
                  *(chain_exist - 1),
                  v35,
                  3),
                applog(5, (const char *)tmp42, 0),
                need_recheck[v22]) )
          {
            recheck_asic_num(info, v22);
            if ( --v34 )
              continue;
          }
          goto LABEL_58;
        }
        need_recheck[v22] = 0;
      }
LABEL_58:
      ++v22;
    }
    while ( v22 != 4 );
    v25 = dev.chain_exist;
    LOBYTE(v26) = 0;
    scan_freq_init_freq();
    v27 = default_ticket_mask_reg;
    do
    {
      v28 = *v25++;
      if ( v28 == 1 )
        set_ticket_mask_chain(v26, v27);
      v26 = (unsigned __int8)(v26 + 1);
    }
    while ( v26 != 4 );
    cgsleep_ms(100);
    software_set_address();
    cgsleep_ms(100);
    set_core_timeout(opt_bitmain_core_timeout);
    cgsleep_ms(100);
    set_nonce_shift(0);
    cgsleep_ms(100);
    enable_read_temperature_from_asic_chain(0);
    enable_read_temperature_from_asic_chain(1u);
    enable_read_temperature_from_asic_chain(2u);
    enable_read_temperature_from_asic_chain(3u);
    enable_sensor_extend_mode();
    set_analog_mux_control(0);
    if ( (v37 & 4) != 0 )
    {
      dev.timeout = 100000000;
      if ( !use_syslog && !opt_log_output && opt_log_level <= 4 )
      {
        fan_pwm_percent = config_parameter.fan_pwm_percent;
        dev.fan_eft = (*((_BYTE *)&config_parameter + 8) & 2) != 0;
        v30 = (*((_BYTE *)&config_parameter + 8) & 2) != 0;
        dev.fan_pwm = config_parameter.fan_pwm_percent;
        goto LABEL_68;
      }
      snprintf((char *)tmp42, 0x1000u, "dev.timeout = %d us", 100000000);
      applog(5, (const char *)tmp42, 0);
    }
    fan_pwm_percent = config_parameter.fan_pwm_percent;
    dev.fan_eft = (*((_BYTE *)&config_parameter + 8) & 2) != 0;
    v30 = (*((_BYTE *)&config_parameter + 8) & 2) != 0;
    dev.fan_pwm = config_parameter.fan_pwm_percent;
    if ( use_syslog )
    {
LABEL_70:
      snprintf((char *)tmp42, 0x1000u, "%s: fan_eft : %d  fan_pwm : %d", "bitmain_ZCASH_init", v30, fan_pwm_percent);
      applog(5, (const char *)tmp42, 0);
LABEL_71:
      if ( (v37 & 2) != 0 && fan_pwm_percent <= 0x64 )
      {
        if ( gMinerStatus_Not_read_all_sensor )
        {
          v31 = 6553600;
          LOBYTE(fan_pwm_percent) = 100;
        }
        else
        {
          if ( fan_pwm_percent < 0x28 )
            fan_pwm_percent = 40;
          v31 = (100 - fan_pwm_percent) | (fan_pwm_percent << 16);
        }
        v32 = axi_fpga_addr;
        dev.pwm_percent = fan_pwm_percent;
        axi_fpga_addr[33] = v31;
        v32[40] = v31;
      }
      else
      {
        set_PWM_according_to_temperature();
      }
      hash_rate_pthread = create_bitmain_check_fan_pthread();
      if ( hash_rate_pthread != -8 )
      {
        sleep(1u);
        create_bitmain_read_temp_pthread();
        if ( hash_rate_pthread != -7 )
        {
          hash_rate_pthread = create_bitmain_check_miner_status_pthread(info);
          if ( hash_rate_pthread != -5 )
          {
            hash_rate_pthread = create_bitmain_get_hash_rate_pthread();
            if ( hash_rate_pthread != -6 )
            {
              init_asic_display_status();
              start_send[0] = 1;
              start_send[1] = 1;
              start_send[2] = 1;
              start_send[3] = 1;
              if ( use_syslog || opt_log_output || opt_log_level > 4 )
              {
                snprintf((char *)tmp42, 0x1000u, "%s done", "bitmain_ZCASH_init");
                hash_rate_pthread = 0;
                applog(5, (const char *)tmp42, 0);
              }
              else
              {
                return opt_log_output;
              }
            }
          }
        }
      }
      return hash_rate_pthread;
    }
LABEL_68:
    if ( !opt_log_output && opt_log_level <= 4 )
      goto LABEL_71;
    goto LABEL_70;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 2 )
    return -2;
  snprintf(
    (char *)tmp42,
    0x1000u,
    "%s: config_parameter.crc = 0x%x, but we calculate it as 0x%x",
    "bitmain_ZCASH_init",
    config_parameter.crc,
    v16);
  applog(3, (const char *)tmp42, 0);
  return -2;
}

//----- (0003F2C0) --------------------------------------------------------
bool __fastcall bitmain_ZCASH_prepare(thr_info *thr)
{
  char *device_data; // r5
  const char *v2; // r1
  const char *v3; // r2
  int v4; // r3
  const char *v5; // r1
  const char *v6; // r2
  int v7; // r3
  init_config *p_ZCASH_config; // r2
  __int16 v9; // r3
  unsigned int v10; // r4
  int version; // t1
  uint32_t baud; // r1
  int v13; // r2
  int v14; // r3
  int v15; // r1
  uint32_t reg_data; // r2
  int v17; // r3
  init_config ZCASH_config; // [sp+0h] [bp-24h] BYREF

  device_data = (char *)thr->cgpu->device_data;
  *(_DWORD *)(device_data + 630) = thr;
  if ( pthread_mutex_init((pthread_mutex_t *)(device_data + 1146), 0) )
    mutex_init_1((pthread_mutex_t *)0x1D77, v2, v3, v4);
  if ( pthread_mutex_init((pthread_mutex_t *)device_data, 0) )
    mutex_init_1((pthread_mutex_t *)0x1D78, v5, v6, v7);
  rwlock_init_1((pthread_rwlock_t *)(device_data + 24), v5, v6, v7);
  memset(&ZCASH_config, 0, sizeof(ZCASH_config));
  ZCASH_config.frequency = opt_bitmain_ZCASH_freq;
  ZCASH_config.token_type = 81;
  ZCASH_config.length = 24;
  *((_BYTE *)&ZCASH_config + 9) = 7;
  *(_WORD *)&ZCASH_config.chain_num = 774;
  ZCASH_config.temperature = 80;
  *(_WORD *)ZCASH_config.voltage = 9479;
  *(_WORD *)&ZCASH_config.chain_check_time_integer = 2570;
  *((_BYTE *)&ZCASH_config + 8) = (2 * opt_bitmain_fan_ctrl) | 0xFD;
  p_ZCASH_config = &ZCASH_config;
  ZCASH_config.fan_pwm_percent = opt_bitmain_fan_pwm;
  v9 = 19156;
  LOWORD(v10) = 255;
  ZCASH_config.chip_address = 4;
  while ( 1 )
  {
    v10 = (unsigned __int16)(v9 ^ ((_WORD)v10 << 8));
    if ( p_ZCASH_config == (init_config *)&ZCASH_config.reg_address )
      break;
    version = p_ZCASH_config->version;
    p_ZCASH_config = (init_config *)((char *)p_ZCASH_config + 1);
    v9 = *(_WORD *)&_FUNCTION___15596[2 * (version ^ (v10 >> 8)) + 100];
  }
  ZCASH_config.crc = v10;
  baud = ZCASH_config.baud;
  v13 = *((_DWORD *)&ZCASH_config + 2);
  v14 = *(_DWORD *)&ZCASH_config.chain_num;
  *(_DWORD *)(device_data + 1170) = *(_DWORD *)&ZCASH_config.token_type;
  *(_DWORD *)(device_data + 1174) = baud;
  *(_DWORD *)(device_data + 1178) = v13;
  *(_DWORD *)(device_data + 1182) = v14;
  v15 = *(_DWORD *)&ZCASH_config.chain_check_time_integer;
  reg_data = ZCASH_config.reg_data;
  v17 = *(_DWORD *)&ZCASH_config.chip_address;
  *(_DWORD *)(device_data + 1186) = *(_DWORD *)&ZCASH_config.frequency;
  *(_DWORD *)(device_data + 1190) = v15;
  *(_DWORD *)(device_data + 1194) = reg_data;
  *(_DWORD *)(device_data + 1198) = v17;
  bitmain_ZCASH_init((bitmain_ZCASH_info *)device_data);
  return 1;
}
// 3F2EA: variable 'v5' is possibly undefined
// 3F2EA: variable 'v6' is possibly undefined
// 3F2EA: variable 'v7' is possibly undefined
// 3F3CC: variable 'v2' is possibly undefined
// 3F3CC: variable 'v3' is possibly undefined
// 3F3CC: variable 'v4' is possibly undefined

//----- (0003F3E8) --------------------------------------------------------
int __fastcall nonce_handle(
        nonce_rb_format (*g_nonce)[1],
        uint8_t (*g_nonce_list)[1][16][91],
        uint8_t *str,
        int len,
        uint32_t chainid)
{
  unsigned __int8 v6; // r0
  int v7; // r4
  int v8; // r8
  uint8_t *v10; // r6
  int v11; // r7
  unsigned __int8 *v12; // r0
  int v13; // r12
  unsigned __int8 *v14; // r1
  unsigned int v15; // r2
  int v16; // t1
  uint32_t v17; // r3
  uint8_t *v18; // r0
  uint8_t *v19; // r1
  int v20; // r3
  uint8_t v21; // r2
  uint8_t *v22; // r2
  int v23; // r7
  uint8_t *v24; // r1
  int v25; // r7
  int v26; // r3
  int v27; // r7
  char *v28; // r7
  nonce_rb_format *v29; // r4
  nonce_rb_format *v30; // r5
  nonce_rb_format *v31; // r0
  uint32_t p_wr; // r3
  char *v33; // r2
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  v6 = str[3] / dev.addrInterval;
  v7 = v6;
  if ( v6 <= 2u )
  {
    v10 = (*g_nonce_list)[v6][0];
    v11 = str[2] & 0xF;
    memcpy(&v10[91 * v11], str + 2, 0x5Bu);
    if ( v11 != 15 )
      return 1;
    v12 = v10 + 89;
    v13 = 0;
    while ( 1 )
    {
      v14 = v12 - 89;
      v15 = 0xFFFF;
      do
      {
        v16 = *v14++;
        v15 = (unsigned __int16)(*(_WORD *)&_FUNCTION___15596[2 * (v16 ^ (v15 >> 8)) + 100] ^ ((_WORD)v15 << 8));
      }
      while ( v14 != v12 );
      if ( __PAIR64__((unsigned __int8)((unsigned __int16)(((_WORD)v15 << 8) | (v15 >> 8)) >> 8), BYTE1(v15)) != __PAIR64__(v14[1], *v14) )
        break;
      ++v13;
      v12 = v14 + 91;
      v8 = 0;
      if ( v13 == 16 )
      {
        v18 = v10;
        v19 = v10;
        v20 = 0;
        while ( 1 )
        {
          v21 = *v19;
          v19 += 91;
          if ( (v21 & 0xF) != v20 )
            break;
          if ( ++v20 == 16 )
          {
            v22 = v10;
            while ( 1 )
            {
              v23 = v22[92];
              v22 += 91;
              if ( v23 != v10[1] )
                break;
              if ( v10 + 1365 == v22 )
              {
                v24 = v10;
                while ( 1 )
                {
                  v25 = v24[93];
                  v24 += 91;
                  if ( v25 != v10[2] )
                    break;
                  if ( v22 == v24 )
                  {
                    v26 = v10[3];
                    while ( 1 )
                    {
                      v27 = v18[94];
                      v18 += 91;
                      if ( v27 != v26 )
                        break;
                      if ( v24 == v18 )
                      {
                        v28 = (char *)(v10 + 4);
                        v29 = &(*g_nonce)[v7];
                        v30 = v29;
                        do
                        {
                          v31 = v30;
                          v30 = (nonce_rb_format *)((char *)v30 + 85);
                          memcpy(v31, v28, 0x55u);
                          v28 += 91;
                        }
                        while ( v30 != (nonce_rb_format *)&v29->Nonce[1275] );
                        memcpy(v30, v10 + 1369, 0x45u);
                        *(_DWORD *)v29->chip_nonce = *(_DWORD *)(v10 + 1450);
                        v29->chip_addr = v10[1366];
                        v29->work_id = v10[1367];
                        v29->nonce_id = v10[1368];
                        v29->diff0 = v10[1441];
                        *(_DWORD *)v29->sha256 = *(_DWORD *)(v10 + 1442);
                        pthread_mutex_lock(&nonce_mutex);
                        p_wr = nonce_fifo.p_wr;
                        v33 = (char *)&nonce_fifo + 1357 * nonce_fifo.p_wr;
                        v33[1368] = chainid;
                        v33[1356] = v29->chip_addr;
                        v33[1357] = v29->work_id & 0x7F;
                        v33[1358] = v29->nonce_id;
                        v33[1359] = v29->diff0;
                        *(_DWORD *)nonce_fifo.nonce_buffer[p_wr].sha256 = *(_DWORD *)v29->sha256;
                        *(_DWORD *)nonce_fifo.nonce_buffer[p_wr].chip_nonce = *(_DWORD *)v29->chip_nonce;
                        memcpy(&nonce_fifo.nonce_buffer[p_wr], v29, 0x540u);
                        if ( nonce_fifo.p_wr > 0x62 )
                          nonce_fifo.p_wr = 0;
                        else
                          ++nonce_fifo.p_wr;
                        if ( nonce_fifo.nonce_num > 0x63 )
                        {
                          nonce_fifo.nonce_num = 100;
                          if ( use_syslog || opt_log_output || opt_log_level > 3 )
                          {
                            snprintf(tmp42, 0x1000u, "%s: nonce fifo full!!!", "nonce_handle");
                            applog(4, tmp42, 0);
                          }
                        }
                        else
                        {
                          ++nonce_fifo.nonce_num;
                        }
                        pthread_mutex_unlock(&nonce_mutex);
                        return v8;
                      }
                    }
                    if ( use_syslog || opt_log_output || opt_log_level > 2 )
                    {
                      snprintf(tmp42, 0x1000u, "nonceID is different %02x != %02x chipid=%d\n", v26, v27, v7);
                      goto LABEL_17;
                    }
                    goto LABEL_19;
                  }
                }
                if ( use_syslog || opt_log_output || opt_log_level > 2 )
                {
                  snprintf(tmp42, 0x1000u, "workID is different %02x != %02x\n");
                  goto LABEL_17;
                }
                goto LABEL_19;
              }
            }
            if ( use_syslog || opt_log_output || opt_log_level > 2 )
            {
              snprintf(tmp42, 0x1000u, "chip_addr is different %02x != %02x\n");
              goto LABEL_17;
            }
            goto LABEL_19;
          }
        }
        if ( use_syslog || opt_log_output || opt_log_level > 2 )
        {
          snprintf(tmp42, 0x1000u, "nonce is not continous i=%d\n", v20);
          goto LABEL_17;
        }
        goto LABEL_19;
      }
    }
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      snprintf(
        tmp42,
        0x1000u,
        "%s CRC error. cal-crc=%x, chip-crc=%02x%02x\n",
        "bm1740_verify_nonce_integrality",
        (unsigned __int16)((_WORD)v15 << 8) | (unsigned __int16)(v15 >> 8),
        v10[91 * v13 + 89],
        v10[91 * v13 + 90]);
LABEL_17:
      applog(3, tmp42, 0);
      if ( use_syslog )
        goto LABEL_20;
    }
    if ( opt_log_output )
      goto LABEL_20;
LABEL_19:
    if ( opt_log_level <= 3 )
      return -1;
LABEL_20:
    v17 = total_error_16509;
    v8 = -1;
    ++total_error_16509;
    snprintf(tmp42, 0x1000u, "receive a error nonce. total = %u", v17);
    applog(4, tmp42, 0);
    return v8;
  }
  if ( !use_syslog && !opt_log_output && opt_log_level <= 3 )
    return -1;
  snprintf(tmp42, 0x1000u, "%s chipid %d is not exist", "nonce_handle", v6);
  applog(4, tmp42, 0);
  return -1;
}

//----- (0003F848) --------------------------------------------------------
void __fastcall pm_handle(uint8_t *str, int len, uint8_t chainid)
{
  int v4; // r5
  int v5; // r0
  char tmp42[4100]; // [sp+18h] [bp-1004h] BYREF

  v4 = chainid;
  v5 = CRC5(str + 2, 8 * len - 21);
  if ( (str[8] & 0x1F) == v5 )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      snprintf(
        tmp42,
        0x1000u,
        "chain[%d] asic[%d] %02x %02x %02x %02x\n",
        v4,
        (unsigned __int8)(str[7] / dev.addrInterval),
        str[3],
        str[4],
        str[5],
        str[6]);
      applog(7, tmp42, 0);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "%s chain%d CRC error crc = %02x\n", "pm_handle", v4, v5);
    applog(3, tmp42, 0);
  }
}

//----- (0003F940) --------------------------------------------------------
void __fastcall reg_handle(uint8_t *str, int len, uint32_t chainid)
{
  char v4; // r6
  int v5; // r0
  uint32_t p_wr; // r1
  bool v7; // cc
  uint32_t v8; // r3
  char *v9; // r3
  uint8_t v10; // r2
  char tmp42[4096]; // [sp+8h] [bp-1000h] BYREF

  v4 = chainid;
  v5 = CRC5(str + 2, 0x33u);
  if ( (str[8] & 0x1F) == v5 )
  {
    if ( reg_fifo.reg_value_num > 0x63 || reg_fifo.p_wr > 0x63 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy(tmp42, "Will Clean!");
        applog(5, tmp42, 0);
      }
      clear_register_value_buf();
    }
    else
    {
      pthread_mutex_lock(&reg_mutex);
      p_wr = reg_fifo.p_wr;
      v7 = reg_fifo.p_wr > 0x62;
      v8 = reg_fifo.p_wr;
      *(_DWORD *)reg_fifo.reg_buffer[v8].reg_data = *(_DWORD *)(str + 3);
      v9 = (char *)&reg_fifo + v8 * 7;
      v9[17] = str[7];
      v10 = str[2];
      v9[18] = v4;
      v9[12] = v10;
      if ( v7 )
      {
        reg_fifo.p_wr = 0;
      }
      else
      {
        if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
        {
          snprintf(tmp42, 0x1000u, "%s: p_wr = %d reg_value_num = %d", "reg_handle", p_wr, reg_fifo.reg_value_num);
          applog(7, tmp42, 0);
        }
        ++reg_fifo.p_wr;
      }
      if ( reg_fifo.reg_value_num > 0x63 )
      {
        reg_fifo.reg_value_num = 100;
        if ( use_syslog || opt_log_output || opt_log_level > 3 )
        {
          snprintf(tmp42, 0x1000u, "%s: reg fifo full!!!", "reg_handle");
          applog(4, tmp42, 0);
        }
      }
      else
      {
        ++reg_fifo.reg_value_num;
      }
      pthread_mutex_unlock(&reg_mutex);
    }
  }
  else if ( use_syslog || opt_log_output || opt_log_level > 2 )
  {
    snprintf(tmp42, 0x1000u, "%s CRC error crc = %02x\n", "reg_handle", v5);
    applog(3, tmp42, 0);
  }
}

//----- (0003FB00) --------------------------------------------------------
void *__fastcall get_asic_response(void *arg)
{
  int v1; // r7
  uint32_t v3; // r9
  pthread_t v4; // r0
  int v5; // r8
  int v6; // r4
  signed int v7; // r0
  uint8_t *v8; // r3
  char v9; // t1
  unsigned __int8 *v10; // r2
  int v11; // r3
  char v12; // r1
  unsigned __int8 *v13; // r3
  char v14; // r2
  unsigned __int8 *v15; // r3
  char v16; // r2
  unsigned __int8 *v17; // r3
  char v18; // r2
  unsigned __int8 header[3]; // [sp+14h] [bp-149D0h] BYREF
  char v21; // [sp+17h] [bp-149CDh] BYREF
  uint8_t tmp[96]; // [sp+18h] [bp-149CCh] BYREF
  uint8_t receive_buf[1488]; // [sp+78h] [bp-1496Ch] BYREF
  nonce_rb_format g_nonce[3][1]; // [sp+648h] [bp-1439Ch] BYREF
  uint8_t g_nonce_list[3][1][16][91]; // [sp+1630h] [bp-133B4h] BYREF
  char tmp42[74404]; // [sp+2740h] [bp-122A4h] BYREF

  memset(receive_buf, 0, sizeof(receive_buf));
  v3 = *(_DWORD *)arg;
  v4 = pthread_self();
  pthread_detach(v4);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "Start A New Asic Response.Chain Id:[%d]", v3);
    applog(5, tmp42, 0);
    if ( !opt_debug )
      goto LABEL_5;
    if ( use_syslog || opt_log_output )
    {
LABEL_30:
      snprintf(tmp42, 0x1000u, "%s %d", "get_asic_response", v3);
      applog(7, tmp42, 0);
      goto LABEL_5;
    }
LABEL_53:
    if ( opt_log_level <= 6 )
      goto LABEL_5;
    goto LABEL_30;
  }
  if ( opt_debug )
    goto LABEL_53;
LABEL_5:
  v5 = 0;
  memset(tmp42, 0, (size_t)&loc_122A0);
  memset(tmp, 0, 0x5Du);
  v6 = 0;
LABEL_6:
  while ( *((_BYTE *)&axi_fpga_addr + v3 + 776) )
  {
    cgsleep_us(500);
    v7 = uart_receive(v3, receive_buf, 0x5D0u);
    if ( v7 > 0 )
    {
      v8 = receive_buf;
      do
      {
        v9 = *v8++;
        tmp42[v5++] = v9;
        if ( v5 > (int)&loc_1229C + 3 )
          v5 = 0;
      }
      while ( &receive_buf[v7] != v8 );
    }
    if ( v5 != v6 )
    {
      if ( v5 > v6 )
        v1 = v5 - v6;
      else
        v8 = (uint8_t *)&loc_122A0;
      if ( v5 <= v6 )
        v1 = (int)&v8[v5 - v6];
      while ( v1 > 2 )
      {
        v10 = header;
        v11 = v6;
        memset(header, 0, sizeof(header));
        do
        {
          v12 = tmp42[v11++];
          if ( v11 > (int)&loc_1229C + 3 )
            v11 = 0;
          *v10++ = v12;
        }
        while ( &v21 != (char *)v10 );
        if ( header[0] == 170 && header[1] == 85 )
        {
          if ( (header[2] & 0xF0) == 0xE0 )
          {
            if ( v1 <= 92 )
              goto LABEL_6;
            v17 = (unsigned __int8 *)&v21;
            do
            {
              v18 = tmp42[v6++];
              if ( v6 > (int)&loc_1229C + 3 )
                v6 = 0;
              *++v17 = v18;
            }
            while ( &tmp[92] != v17 );
            v1 -= 93;
            nonce_handle(g_nonce, g_nonce_list, tmp, 93, v3);
          }
          else if ( header[2] == 204 )
          {
            if ( v1 <= 8 )
              goto LABEL_6;
            v15 = (unsigned __int8 *)&v21;
            do
            {
              v16 = tmp42[v6++];
              if ( v6 > (int)&loc_1229C + 3 )
                v6 = 0;
              *++v15 = v16;
            }
            while ( v15 != &tmp[8] );
            v1 -= 9;
            pm_handle(tmp, 9, v3);
          }
          else
          {
            if ( v1 <= 8 )
              goto LABEL_6;
            v13 = (unsigned __int8 *)&v21;
            do
            {
              v14 = tmp42[v6++];
              if ( v6 > (int)&loc_1229C + 3 )
                v6 = 0;
              *++v13 = v14;
            }
            while ( &tmp[8] != v13 );
            v1 -= 9;
            reg_handle(tmp, 9, v3);
          }
        }
        else
        {
          ++v6;
          --v1;
          if ( v6 > (int)&loc_1229C + 3 )
            v6 = 0;
        }
      }
    }
  }
  return 0;
}
// 3FBEE: variable 'v8' is possibly undefined
// 3FBF4: variable 'v1' is possibly undefined

//----- (0003FD5C) --------------------------------------------------------
void __fastcall sha2_starts(sha2_context *ctx)
{
  ctx->state[0] = 1779033703;
  ctx->state[1] = -1150833019;
  ctx->state[2] = 1013904242;
  ctx->state[3] = -1521486534;
  ctx->state[4] = 1359893119;
  ctx->state[5] = -1694144372;
  ctx->state[6] = 528734635;
  ctx->state[7] = 1541459225;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
}

//----- (0003FDB8) --------------------------------------------------------
void __fastcall sha2_process(sha2_context *ctx, const unsigned __int8 *data)
{
  uint32_t v3; // r1
  uint32_t v4; // r3
  uint32_t v5; // r12
  unsigned int v6; // r4
  int v7; // r3
  uint32_t v8; // r0
  uint32_t v9; // r7
  int v10; // r3
  uint32_t v11; // r2
  uint32_t v12; // r6
  int v13; // r5
  int v14; // r12
  uint32_t v15; // r3
  int v16; // r10
  int v17; // r12
  int v18; // r12
  uint32_t v19; // r0
  int v20; // r12
  int v21; // r8
  uint32_t v22; // r2
  int v23; // r7
  int v24; // r9
  uint32_t v25; // r3
  int v26; // r11
  int v27; // r9
  uint32_t v28; // r11
  uint32_t v29; // r10
  uint32_t v30; // r11
  int v31; // r4
  int v32; // r12
  int v33; // lr
  int v34; // r4
  int v35; // r7
  int v36; // r5
  int v37; // r4
  int v38; // r2
  int v39; // r9
  int v40; // r10
  int v41; // r6
  uint32_t v42; // r11
  int v43; // r12
  int v44; // lr
  int v45; // r0
  int v46; // r7
  int v47; // r5
  int v48; // r12
  int v49; // r9
  int v50; // r2
  uint32_t v51; // r10
  int v52; // r11
  int v53; // r9
  uint32_t v54; // r3
  int v55; // r1
  int v56; // r6
  uint32_t v57; // r4
  int v58; // r5
  int v59; // r12
  uint32_t v60; // r0
  int v61; // r2
  uint32_t v62; // r1
  uint32_t v63; // r7
  int v64; // r9
  int v65; // r2
  int v66; // r6
  uint32_t v67; // r4
  int v68; // r3
  int v69; // r6
  int v70; // r8
  uint32_t v71; // r1
  uint32_t v72; // r9
  int v73; // lr
  int v74; // r2
  uint32_t v75; // lr
  int v76; // r12
  int v77; // r3
  int v78; // r12
  uint32_t v79; // r6
  uint32_t v80; // r0
  int v81; // r12
  int v82; // r12
  uint32_t v83; // r9
  uint32_t v84; // r1
  int v85; // r7
  uint32_t v86; // lr
  int v87; // r5
  uint32_t v88; // r3
  int v89; // r5
  uint32_t v90; // r0
  uint32_t v91; // r6
  int v92; // r5
  uint32_t v93; // r9
  int v94; // r1
  uint32_t v95; // r5
  int v96; // r8
  int v97; // r11
  int v98; // r12
  uint32_t v99; // r3
  int v100; // r10
  int v101; // r1
  uint32_t v102; // r6
  int v103; // r8
  int v104; // r1
  uint32_t v105; // r12
  int v106; // r2
  int v107; // r7
  int v108; // r0
  int v109; // r4
  int v110; // r5
  int v111; // lr
  int v112; // r3
  int v113; // r9
  int v114; // r1
  int v115; // r7
  int v116; // r10
  uint32_t v117; // r9
  int v118; // r7
  int v119; // r4
  uint32_t v120; // r2
  int v121; // r8
  uint32_t v122; // r0
  int v123; // lr
  int v124; // r11
  int v125; // r1
  int v126; // r8
  int v127; // r1
  uint32_t v128; // r8
  int v129; // r10
  uint32_t v130; // r5
  int v131; // r7
  int v132; // r9
  uint32_t v133; // r2
  int v134; // r7
  uint32_t v135; // r0
  int v136; // r4
  int v137; // lr
  int v138; // r11
  int v139; // r3
  int v140; // lr
  int v141; // r10
  int v142; // r5
  int v143; // lr
  int v144; // r9
  int v145; // r8
  unsigned int v146; // r2
  int v147; // r12
  int v148; // r7
  int v149; // r0
  int v150; // r3
  int v151; // r0
  int v152; // r11
  int v153; // r5
  int v154; // r11
  int v155; // r10
  int v156; // r8
  int v157; // r10
  int v158; // r9
  int v159; // r4
  int v160; // r9
  int v161; // r4
  int v162; // lr
  int v163; // r11
  int v164; // r3
  unsigned int v165; // r1
  int v166; // r5
  uint32_t v167; // r3
  int v168; // r12
  unsigned int v169; // lr
  int v170; // r6
  uint32_t v171; // r3
  int v172; // r9
  uint32_t v173; // r6
  unsigned int v174; // r10
  int v175; // r1
  uint32_t v176; // r5
  unsigned int v177; // lr
  int v178; // r12
  uint32_t v179; // r2
  int v180; // r1
  unsigned int v181; // r10
  int v182; // r9
  int v183; // r0
  int v184; // r12
  uint32_t v185; // r6
  int v186; // r7
  unsigned int v187; // r4
  unsigned int *A; // [sp+4h] [bp-80h]
  uint32_t Aa; // [sp+4h] [bp-80h]
  uint32_t Ab; // [sp+4h] [bp-80h]
  uint32_t Ac; // [sp+4h] [bp-80h]
  uint32_t Ad; // [sp+4h] [bp-80h]
  uint32_t Ae; // [sp+4h] [bp-80h]
  uint32_t Af; // [sp+4h] [bp-80h]
  uint32_t Ag; // [sp+4h] [bp-80h]
  uint32_t C; // [sp+8h] [bp-7Ch]
  uint32_t Ca; // [sp+8h] [bp-7Ch]
  uint32_t Cb; // [sp+8h] [bp-7Ch]
  uint32_t Cc; // [sp+8h] [bp-7Ch]
  uint32_t Cd; // [sp+8h] [bp-7Ch]
  uint32_t v201; // [sp+Ch] [bp-78h]
  unsigned int v202; // [sp+Ch] [bp-78h]
  unsigned int v203; // [sp+Ch] [bp-78h]
  int v204; // [sp+Ch] [bp-78h]
  uint32_t v205; // [sp+Ch] [bp-78h]
  unsigned int v206; // [sp+10h] [bp-74h]
  unsigned int v207; // [sp+10h] [bp-74h]
  unsigned int v208; // [sp+10h] [bp-74h]
  unsigned int v209; // [sp+10h] [bp-74h]
  uint32_t H; // [sp+14h] [bp-70h]
  uint32_t Ha; // [sp+14h] [bp-70h]
  uint32_t Hb; // [sp+14h] [bp-70h]
  uint32_t Hc; // [sp+14h] [bp-70h]
  uint32_t Hd; // [sp+14h] [bp-70h]
  uint32_t He; // [sp+14h] [bp-70h]
  uint32_t Hf; // [sp+14h] [bp-70h]
  uint32_t Hg; // [sp+14h] [bp-70h]
  uint32_t D; // [sp+18h] [bp-6Ch]
  uint32_t Da; // [sp+18h] [bp-6Ch]
  uint32_t Db; // [sp+18h] [bp-6Ch]
  unsigned int v221; // [sp+1Ch] [bp-68h]
  unsigned int v222; // [sp+1Ch] [bp-68h]
  unsigned int v223; // [sp+1Ch] [bp-68h]
  int v224; // [sp+1Ch] [bp-68h]
  int v225; // [sp+1Ch] [bp-68h]
  unsigned int v226; // [sp+20h] [bp-64h]
  unsigned int v227; // [sp+20h] [bp-64h]
  unsigned int v228; // [sp+20h] [bp-64h]
  uint32_t v229; // [sp+20h] [bp-64h]
  unsigned int v230; // [sp+24h] [bp-60h]
  unsigned int v231; // [sp+24h] [bp-60h]
  unsigned int v232; // [sp+24h] [bp-60h]
  int v233; // [sp+24h] [bp-60h]
  unsigned int v234; // [sp+28h] [bp-5Ch]
  unsigned int v235; // [sp+28h] [bp-5Ch]
  unsigned int v236; // [sp+28h] [bp-5Ch]
  unsigned int v237; // [sp+28h] [bp-5Ch]
  unsigned int v238; // [sp+2Ch] [bp-58h]
  unsigned int v239; // [sp+2Ch] [bp-58h]
  unsigned int v240; // [sp+2Ch] [bp-58h]
  unsigned int v241; // [sp+2Ch] [bp-58h]
  uint32_t F; // [sp+30h] [bp-54h]
  uint32_t Fa; // [sp+30h] [bp-54h]
  unsigned int v244; // [sp+34h] [bp-50h]
  unsigned int v245; // [sp+34h] [bp-50h]
  unsigned int v246; // [sp+34h] [bp-50h]
  int v247; // [sp+34h] [bp-50h]
  unsigned int v248; // [sp+38h] [bp-4Ch]
  unsigned int v249; // [sp+38h] [bp-4Ch]
  unsigned int v250; // [sp+38h] [bp-4Ch]
  unsigned int v251; // [sp+38h] [bp-4Ch]
  unsigned int v252; // [sp+3Ch] [bp-48h]
  unsigned int v253; // [sp+3Ch] [bp-48h]
  unsigned int v254; // [sp+3Ch] [bp-48h]
  int v255; // [sp+3Ch] [bp-48h]
  unsigned int v256; // [sp+3Ch] [bp-48h]
  uint32_t B; // [sp+40h] [bp-44h]
  uint32_t Ba; // [sp+40h] [bp-44h]
  uint32_t Bb; // [sp+40h] [bp-44h]
  unsigned int v260; // [sp+44h] [bp-40h]
  unsigned int v261; // [sp+44h] [bp-40h]
  unsigned int v262; // [sp+44h] [bp-40h]
  unsigned int v263; // [sp+48h] [bp-3Ch]
  unsigned int v264; // [sp+48h] [bp-3Ch]
  unsigned int v265; // [sp+48h] [bp-3Ch]
  unsigned int v266; // [sp+4Ch] [bp-38h]
  unsigned int v267; // [sp+4Ch] [bp-38h]
  unsigned int v268; // [sp+4Ch] [bp-38h]
  unsigned int v269; // [sp+50h] [bp-34h]
  unsigned int v270; // [sp+50h] [bp-34h]
  int v271; // [sp+54h] [bp-30h]
  unsigned int v272; // [sp+54h] [bp-30h]
  unsigned int v273; // [sp+58h] [bp-2Ch]
  uint32_t v274; // [sp+5Ch] [bp-28h]
  uint32_t v275; // [sp+60h] [bp-24h]
  uint32_t v276; // [sp+64h] [bp-20h]
  uint32_t v277; // [sp+68h] [bp-1Ch]
  uint32_t v278; // [sp+6Ch] [bp-18h]
  uint32_t v279; // [sp+70h] [bp-14h]
  uint32_t v280; // [sp+74h] [bp-10h]
  uint32_t v281; // [sp+78h] [bp-Ch]

  v3 = ctx->state[4];
  v277 = ctx->state[6];
  v275 = ctx->state[1];
  v280 = ctx->state[7];
  v278 = ctx->state[2];
  v276 = ctx->state[5];
  v279 = ctx->state[3];
  D = bswap32(*(_DWORD *)data);
  v4 = ((v276 ^ v277) & v3 ^ v277) + (__ROR4__(v3, 11) ^ __ROR4__(v3, 6) ^ __ROR4__(v3, 25)) + v280 + 1116352408 + D;
  v274 = ctx->state[0];
  v5 = v279 + v4;
  C = (v274 & v275 | (v274 | v275) & v278) + (__ROR4__(v274, 13) ^ __ROR4__(v274, 2) ^ __ROR4__(v274, 22)) + v4;
  v6 = bswap32(*((_DWORD *)data + 1));
  A = (unsigned int *)data;
  v281 = v3;
  v7 = ((v276 ^ v3) & (v279 + v4) ^ v276)
     + v277
     + 1899447441
     + v6
     + (__ROR4__(v279 + v4, 11) ^ __ROR4__(v279 + v4, 6) ^ __ROR4__(v279 + v4, 25));
  v8 = ((C | v274) & v275 | v274 & C) + (__ROR4__(C, 13) ^ __ROR4__(C, 2) ^ __ROR4__(C, 22)) + v7;
  v9 = v278 + v7;
  H = bswap32(*((_DWORD *)data + 2));
  v10 = ((v3 ^ v5) & (v278 + v7) ^ v3)
      + v276
      - 1245643825
      + H
      + (__ROR4__(v278 + v7, 11) ^ __ROR4__(v278 + v7, 6) ^ __ROR4__(v278 + v7, 25));
  v11 = ((C | v8) & v274 | C & v8) + (__ROR4__(v8, 13) ^ __ROR4__(v8, 2) ^ __ROR4__(v8, 22)) + v10;
  v12 = v275 + v10;
  v226 = bswap32(*((_DWORD *)data + 3));
  v13 = ((v5 ^ v9) & v12 ^ v5) + v3 - 373957723 + v226 + (__ROR4__(v12, 11) ^ __ROR4__(v12, 6) ^ __ROR4__(v12, 25));
  v201 = (__ROR4__(v11, 13) ^ __ROR4__(v11, 2) ^ __ROR4__(v11, 22)) + ((v8 | v11) & C | v8 & v11) + v13;
  v221 = v6;
  v271 = __ROR4__(v6, 18) ^ __ROR4__(v6, 7) ^ (v6 >> 3);
  v248 = *((_DWORD *)data + 8);
  v230 = bswap32(*((_DWORD *)data + 4));
  v206 = *((_DWORD *)data + 9);
  v14 = v5
      + v230
      + 961987163
      + ((v9 ^ (v275 + v10)) & (v274 + v13) ^ v9)
      + (__ROR4__(v274 + v13, 11) ^ __ROR4__(v274 + v13, 6) ^ __ROR4__(v274 + v13, 25));
  v15 = C + v14;
  v16 = (__ROR4__(v201, 13) ^ __ROR4__(v201, 2) ^ __ROR4__(v201, 22)) + ((v11 | v201) & v8 | v11 & v201) + v14;
  v252 = *((_DWORD *)data + 10);
  v17 = __ROR4__(C + v14, 11);
  Ca = v15;
  v234 = bswap32(*((_DWORD *)data + 5));
  v18 = (v17 ^ __ROR4__(v15, 6) ^ __ROR4__(v15, 25)) + v9 + v234 + 1508970993 + ((v12 ^ (v274 + v13)) & v15 ^ v12);
  v19 = v8 + v18;
  v20 = v18 + ((v201 | v16) & v11 | v201 & v16) + (__ROR4__(v16, 13) ^ __ROR4__(v16, 2) ^ __ROR4__(v16, 22));
  v238 = bswap32(*((_DWORD *)data + 6));
  v21 = (__ROR4__(v19, 11) ^ __ROR4__(v19, 6) ^ __ROR4__(v19, 25))
      + v12
      + v238
      - 1841331548
      + (((v274 + v13) ^ v15) & v19 ^ (v274 + v13));
  v22 = v11 + v21;
  v23 = (__ROR4__(v20, 13) ^ __ROR4__(v20, 2) ^ __ROR4__(v20, 22)) + ((v16 | v20) & v201 | v16 & v20) + v21;
  v244 = bswap32(A[7]);
  v24 = (__ROR4__(v22, 11) ^ __ROR4__(v22, 6) ^ __ROR4__(v22, 25))
      + v274
      + v13
      + v244
      - 1424204075
      + ((v15 ^ v19) & v22 ^ v15);
  v266 = bswap32(v248);
  v25 = v201 + v24;
  v263 = bswap32(A[12]);
  v249 = bswap32(v206);
  v207 = bswap32(A[13]);
  v253 = bswap32(v252);
  v26 = __ROR4__(v201 + v24, 11) ^ __ROR4__(v201 + v24, 6) ^ __ROR4__(v201 + v24, 25);
  v27 = v24 + (__ROR4__(v23, 13) ^ __ROR4__(v23, 2) ^ __ROR4__(v23, 22)) + ((v20 | v23) & v16 | v20 & v23);
  v260 = bswap32(A[11]);
  v28 = v26 + Ca + v266 - 670586216 + ((v19 ^ v22) & v25 ^ v19);
  v29 = v16 + v28;
  v30 = v28 + (__ROR4__(v27, 13) ^ __ROR4__(v27, 2) ^ __ROR4__(v27, 22)) + ((v23 | v27) & v20 | v23 & v27);
  v31 = (__ROR4__(v29, 11) ^ __ROR4__(v29, 6) ^ __ROR4__(v29, 25)) + v19 + v249 + 310598401 + ((v22 ^ v25) & v29 ^ v22);
  v32 = v20 + v31;
  Cb = bswap32(A[14]);
  v33 = (__ROR4__(v30, 13) ^ __ROR4__(v30, 2) ^ __ROR4__(v30, 22)) + ((v27 | v30) & v23 | v27 & v30) + v31;
  v202 = bswap32(A[15]);
  v34 = (__ROR4__(v32, 11) ^ __ROR4__(v32, 6) ^ __ROR4__(v32, 25)) + v22 + v253 + 607225278 + ((v25 ^ v29) & v32 ^ v25);
  v35 = v23 + v34;
  v36 = (v30 & v33 | (v30 | v33) & v27) + (__ROR4__(v33, 13) ^ __ROR4__(v33, 2) ^ __ROR4__(v33, 22)) + v34;
  v37 = (__ROR4__(v35, 11) ^ __ROR4__(v35, 6) ^ __ROR4__(v35, 25)) + v25 + v260 + 1426881987 + ((v29 ^ v32) & v35 ^ v29);
  v38 = (v33 & v36 | (v33 | v36) & v30) + (__ROR4__(v36, 13) ^ __ROR4__(v36, 2) ^ __ROR4__(v36, 22)) + v37;
  v39 = v27 + v37;
  v40 = v29 + v263 + 1925078388 + ((v32 ^ v35) & v39 ^ v32) + (__ROR4__(v39, 11) ^ __ROR4__(v39, 6) ^ __ROR4__(v39, 25));
  v41 = ((v36 | v38) & v33 | v36 & v38) + (__ROR4__(v38, 13) ^ __ROR4__(v38, 2) ^ __ROR4__(v38, 22)) + v40;
  v42 = v30 + v40;
  v43 = v32 + v207 - 2132889090 + ((v35 ^ v39) & v42 ^ v35) + (__ROR4__(v42, 11) ^ __ROR4__(v42, 6) ^ __ROR4__(v42, 25));
  v44 = v33 + v43;
  v45 = ((v38 | v41) & v36 | v38 & v41) + (__ROR4__(v41, 13) ^ __ROR4__(v41, 2) ^ __ROR4__(v41, 22)) + v43;
  v46 = v35 + Cb - 1680079193 + ((v39 ^ v42) & v44 ^ v39) + (__ROR4__(v44, 11) ^ __ROR4__(v44, 6) ^ __ROR4__(v44, 25));
  v47 = v36 + v46;
  v48 = ((v41 | v45) & v38 | v41 & v45) + (__ROR4__(v45, 13) ^ __ROR4__(v45, 2) ^ __ROR4__(v45, 22)) + v46;
  v49 = v39 + v202 - 1046744716 + ((v42 ^ v44) & v47 ^ v42) + (__ROR4__(v47, 11) ^ __ROR4__(v47, 6) ^ __ROR4__(v47, 25));
  v50 = v38 + v49;
  v51 = (__ROR4__(Cb, 19) ^ __ROR4__(Cb, 17) ^ (Cb >> 10)) + D + v249 + v271;
  Aa = (v45 & v48 | (v45 | v48) & v41) + (__ROR4__(v48, 13) ^ __ROR4__(v48, 2) ^ __ROR4__(v48, 22)) + v49;
  v52 = v42 + v51 - 459576895 + ((v44 ^ v47) & v50 ^ v44) + (__ROR4__(v50, 11) ^ __ROR4__(v50, 6) ^ __ROR4__(v50, 25));
  v53 = v41 + v52;
  Da = (__ROR4__(H, 18) ^ __ROR4__(H, 7) ^ (H >> 3))
     + (__ROR4__(v202, 19) ^ __ROR4__(v202, 17) ^ (v202 >> 10))
     + v221
     + v253;
  v54 = H;
  Ha = ((v48 | Aa) & v45 | v48 & Aa) + (__ROR4__(Aa, 13) ^ __ROR4__(Aa, 2) ^ __ROR4__(Aa, 22)) + v52;
  v55 = ((v47 ^ v50) & v53 ^ v47)
      + v44
      + Da
      - 272742522
      + (__ROR4__(v41 + v52, 11) ^ __ROR4__(v53, 6) ^ __ROR4__(v53, 25));
  v56 = v45 + v55;
  v57 = ((Aa | Ha) & v48 | Aa & Ha) + (__ROR4__(Ha, 13) ^ __ROR4__(Ha, 2) ^ __ROR4__(Ha, 22)) + v55;
  v222 = (__ROR4__(v226, 18) ^ __ROR4__(v226, 7) ^ (v226 >> 3))
       + v54
       + v260
       + (__ROR4__(v51, 19) ^ __ROR4__(v51, 17) ^ (v51 >> 10));
  v58 = ((v50 ^ v53) & v56 ^ v50)
      + v222
      + 264347078
      + v47
      + (__ROR4__(v45 + v55, 11) ^ __ROR4__(v45 + v55, 6) ^ __ROR4__(v56, 25));
  v59 = v48 + v58;
  v60 = (__ROR4__(v57, 13) ^ __ROR4__(v57, 2) ^ __ROR4__(v57, 22)) + (Aa & (Ha | v57) | Ha & v57) + v58;
  v227 = v226
       + v263
       + (__ROR4__(v230, 18) ^ __ROR4__(v230, 7) ^ (v230 >> 3))
       + (__ROR4__(Da, 19) ^ __ROR4__(Da, 17) ^ (Da >> 10));
  v61 = ((v53 ^ v56) & v59 ^ v53) + v227 + 604807628 + v50 + (__ROR4__(v59, 11) ^ __ROR4__(v59, 6) ^ __ROR4__(v59, 25));
  v62 = ((v57 | v60) & Ha | v57 & v60) + (__ROR4__(v60, 13) ^ __ROR4__(v60, 2) ^ __ROR4__(v60, 22)) + v61;
  v63 = Aa + v61;
  v231 = (__ROR4__(v222, 19) ^ __ROR4__(v222, 17) ^ (v222 >> 10))
       + (__ROR4__(v234, 18) ^ __ROR4__(v234, 7) ^ (v234 >> 3))
       + v230
       + v207;
  v64 = v53
      + v231
      + 770255983
      + ((v56 ^ v59) & v63 ^ v56)
      + (__ROR4__(v63, 11) ^ __ROR4__(v63, 6) ^ __ROR4__(Aa + v61, 25));
  v65 = ((v60 | v62) & v57 | v60 & v62) + (__ROR4__(v62, 13) ^ __ROR4__(v62, 2) ^ __ROR4__(v62, 22)) + v64;
  Hb = Ha + v64;
  v235 = (__ROR4__(v238, 18) ^ __ROR4__(v238, 7) ^ (v238 >> 3))
       + v234
       + Cb
       + (__ROR4__(v227, 19) ^ __ROR4__(v227, 17) ^ (v227 >> 10));
  v66 = ((v59 ^ v63) & Hb ^ v59) + v235 + 1249150122 + v56 + (__ROR4__(Hb, 11) ^ __ROR4__(Hb, 6) ^ __ROR4__(Hb, 25));
  v67 = v57 + v66;
  v68 = ((v62 | v65) & v60 | v62 & v65) + (__ROR4__(v65, 13) ^ __ROR4__(v65, 2) ^ __ROR4__(v65, 22)) + v66;
  v239 = (__ROR4__(v244, 18) ^ __ROR4__(v244, 7) ^ (v244 >> 3))
       + v238
       + v202
       + (__ROR4__(v231, 19) ^ __ROR4__(v231, 17) ^ (v231 >> 10));
  v69 = (__ROR4__(v67, 11) ^ __ROR4__(v67, 6) ^ __ROR4__(v67, 25)) + v59 + v239 + 1555081692 + ((v63 ^ Hb) & v67 ^ v63);
  Ab = v60 + v69;
  B = v69 + (__ROR4__(v68, 13) ^ __ROR4__(v68, 2) ^ __ROR4__(v68, 22)) + ((v65 | v68) & v62 | v65 & v68);
  F = (__ROR4__(v266, 18) ^ __ROR4__(v266, 7) ^ (v266 >> 3))
    + v244
    + v51
    + (__ROR4__(v235, 19) ^ __ROR4__(v235, 17) ^ (v235 >> 10));
  v70 = (__ROR4__(Ab, 11) ^ __ROR4__(Ab, 6) ^ __ROR4__(Ab, 25)) + v63 + F + 1996064986 + ((Hb ^ v67) & Ab ^ Hb);
  v71 = v62 + v70;
  v72 = (__ROR4__(B, 13) ^ __ROR4__(B, 2) ^ __ROR4__(B, 22)) + ((v68 | B) & v65 | v68 & B) + v70;
  v245 = (__ROR4__(v249, 18) ^ __ROR4__(v249, 7) ^ (v249 >> 3))
       + v266
       + Da
       + (__ROR4__(v239, 19) ^ __ROR4__(v239, 17) ^ (v239 >> 10));
  v73 = (__ROR4__(v71, 11) ^ __ROR4__(v71, 6) ^ __ROR4__(v71, 25))
      + Hb
      + v245
      - 1740746414
      + (((v60 + v69) ^ v67) & v71 ^ v67);
  v74 = v65 + v73;
  v75 = v73 + (__ROR4__(v72, 13) ^ __ROR4__(v72, 2) ^ __ROR4__(v72, 22)) + ((B | v72) & v68 | B & v72);
  v250 = (__ROR4__(v253, 18) ^ __ROR4__(v253, 7) ^ (v253 >> 3))
       + v249
       + v222
       + (__ROR4__(F, 19) ^ __ROR4__(F, 17) ^ (F >> 10));
  v76 = (__ROR4__(v74, 11) ^ __ROR4__(v74, 6) ^ __ROR4__(v74, 25)) + v67 + v250 - 1473132947 + ((Ab ^ v71) & v74 ^ Ab);
  v77 = v68 + v76;
  Hc = (__ROR4__(v75, 13) ^ __ROR4__(v75, 2) ^ __ROR4__(v75, 22)) + ((v72 | v75) & B | v72 & v75) + v76;
  v254 = (__ROR4__(v245, 19) ^ __ROR4__(v245, 17) ^ (v245 >> 10))
       + (__ROR4__(v260, 18) ^ __ROR4__(v260, 7) ^ (v260 >> 3))
       + v253
       + v227;
  v78 = (__ROR4__(v77, 11) ^ __ROR4__(v77, 6) ^ __ROR4__(v77, 25))
      + v60
      + v69
      + v254
      - 1341970488
      + ((v71 ^ v74) & v77 ^ v71);
  v79 = B + v78;
  v80 = (__ROR4__(Hc, 13) ^ __ROR4__(Hc, 2) ^ __ROR4__(Hc, 22)) + ((v75 | Hc) & v72 | v75 & Hc) + v78;
  v81 = __ROR4__(B + v78, 11) ^ __ROR4__(B + v78, 6);
  Ba = (__ROR4__(v250, 19) ^ __ROR4__(v250, 17) ^ (v250 >> 10))
     + (__ROR4__(v263, 18) ^ __ROR4__(v263, 7) ^ (v263 >> 3))
     + v260
     + v231;
  v82 = (v81 ^ __ROR4__(v79, 25)) + v71 + Ba - 1084653625 + ((v74 ^ v77) & v79 ^ v74);
  v83 = v72 + v82;
  v84 = (__ROR4__(v80, 13) ^ __ROR4__(v80, 2) ^ __ROR4__(v80, 22)) + ((Hc | v80) & v75 | Hc & v80) + v82;
  v261 = (__ROR4__(v207, 18) ^ __ROR4__(v207, 7) ^ (v207 >> 3))
       + v263
       + v235
       + (__ROR4__(v254, 19) ^ __ROR4__(v254, 17) ^ (v254 >> 10));
  v85 = (__ROR4__(v83, 11) ^ __ROR4__(v83, 6) ^ __ROR4__(v83, 25)) + v74 + v261 - 958395405 + ((v77 ^ v79) & v83 ^ v77);
  v86 = v75 + v85;
  Ac = v85 + (__ROR4__(v84, 13) ^ __ROR4__(v84, 2) ^ __ROR4__(v84, 22)) + ((v80 | v84) & Hc | v80 & v84);
  v208 = (__ROR4__(Ba, 19) ^ __ROR4__(Ba, 17) ^ (Ba >> 10))
       + (__ROR4__(Cb, 18) ^ __ROR4__(Cb, 7) ^ (Cb >> 3))
       + v207
       + v239;
  v87 = (__ROR4__(v86, 11) ^ __ROR4__(v86, 6) ^ __ROR4__(v86, 25)) + v77 + v208 - 710438585 + ((v79 ^ v83) & v86 ^ v79);
  Hd = Hc + v87;
  v88 = (__ROR4__(Ac, 13) ^ __ROR4__(Ac, 2) ^ __ROR4__(Ac, 22)) + ((v84 | Ac) & v80 | v84 & Ac) + v87;
  v264 = (__ROR4__(v202, 18) ^ __ROR4__(v202, 7) ^ (v202 >> 3))
       + Cb
       + F
       + (__ROR4__(v261, 19) ^ __ROR4__(v261, 17) ^ (v261 >> 10));
  v89 = (__ROR4__(Hd, 11) ^ __ROR4__(Hd, 6) ^ __ROR4__(Hd, 25)) + v79 + v264 + 113926993 + ((v83 ^ v86) & Hd ^ v83);
  v90 = v80 + v89;
  v91 = v89 + (__ROR4__(v88, 13) ^ __ROR4__(v88, 2) ^ __ROR4__(v88, 22)) + ((Ac | v88) & v84 | Ac & v88);
  v267 = (__ROR4__(v208, 19) ^ __ROR4__(v208, 17) ^ (v208 >> 10))
       + (__ROR4__(v51, 18) ^ __ROR4__(v51, 7) ^ (v51 >> 3))
       + v202
       + v245;
  v92 = (__ROR4__(v90, 11) ^ __ROR4__(v90, 6) ^ __ROR4__(v90, 25)) + v83 + v267 + 338241895 + ((v86 ^ Hd) & v90 ^ v86);
  v93 = v84 + v92;
  v94 = __ROR4__(v84 + v92, 11);
  v95 = v92 + (__ROR4__(v91, 13) ^ __ROR4__(v91, 2) ^ __ROR4__(v91, 22)) + ((v88 | v91) & Ac | v88 & v91);
  v269 = (__ROR4__(Da, 18) ^ __ROR4__(Da, 7) ^ (Da >> 3))
       + v51
       + v250
       + (__ROR4__(v264, 19) ^ __ROR4__(v264, 17) ^ (v264 >> 10));
  v96 = (v94 ^ __ROR4__(v93, 6) ^ __ROR4__(v93, 25)) + v86 + v269 + 666307205 + ((Hd ^ v90) & v93 ^ Hd);
  v97 = (__ROR4__(v95, 13) ^ __ROR4__(v95, 2) ^ __ROR4__(v95, 22)) + ((v91 | v95) & v88 | v91 & v95) + v96;
  Ad = Ac + v96;
  v272 = (__ROR4__(v222, 18) ^ __ROR4__(v222, 7) ^ (v222 >> 3))
       + Da
       + v254
       + (__ROR4__(v267, 19) ^ __ROR4__(v267, 17) ^ (v267 >> 10));
  v98 = (__ROR4__(Ad, 11) ^ __ROR4__(Ad, 6) ^ __ROR4__(Ad, 25)) + Hd + v272 + 773529912 + ((v90 ^ v93) & Ad ^ v90);
  v99 = v88 + v98;
  v100 = (__ROR4__(v97, 13) ^ __ROR4__(v97, 2) ^ __ROR4__(v97, 22)) + ((v95 | v97) & v91 | v95 & v97) + v98;
  v223 = (__ROR4__(v227, 18) ^ __ROR4__(v227, 7) ^ (v227 >> 3))
       + v222
       + Ba
       + (__ROR4__(v269, 19) ^ __ROR4__(v269, 17) ^ (v269 >> 10));
  v101 = (__ROR4__(v99, 11) ^ __ROR4__(v99, 6) ^ __ROR4__(v99, 25)) + v90 + v223 + 1294757372 + ((v93 ^ Ad) & v99 ^ v93);
  v102 = v91 + v101;
  v103 = (__ROR4__(v100, 13) ^ __ROR4__(v100, 2) ^ __ROR4__(v100, 22)) + ((v97 | v100) & v95 | v97 & v100) + v101;
  v228 = (__ROR4__(v231, 18) ^ __ROR4__(v231, 7) ^ (v231 >> 3))
       + v227
       + v261
       + (__ROR4__(v272, 19) ^ __ROR4__(v272, 17) ^ (v272 >> 10));
  v104 = v228
       + 1396182291
       + v93
       + ((Ad ^ v99) & v102 ^ Ad)
       + (__ROR4__(v102, 11) ^ __ROR4__(v102, 6) ^ __ROR4__(v102, 25));
  v105 = v95 + v104;
  v106 = ((v100 | v103) & v97 | v100 & v103) + (__ROR4__(v103, 13) ^ __ROR4__(v103, 2) ^ __ROR4__(v103, 22)) + v104;
  v232 = (__ROR4__(v235, 18) ^ __ROR4__(v235, 7) ^ (v235 >> 3))
       + v231
       + v208
       + (__ROR4__(v223, 19) ^ __ROR4__(v223, 17) ^ (v223 >> 10));
  v107 = Ad
       + v232
       + 1695183700
       + ((v102 ^ v99) & v105 ^ v99)
       + (__ROR4__(v95 + v104, 11) ^ __ROR4__(v95 + v104, 6) ^ __ROR4__(v105, 25));
  v108 = v97 + v107;
  v109 = ((v103 | v106) & v100 | v103 & v106) + (__ROR4__(v106, 13) ^ __ROR4__(v106, 2) ^ __ROR4__(v106, 22)) + v107;
  v203 = (__ROR4__(v228, 19) ^ __ROR4__(v228, 17) ^ (v228 >> 10))
       + (__ROR4__(v239, 18) ^ __ROR4__(v239, 7) ^ (v239 >> 3))
       + v235
       + v264;
  v110 = (__ROR4__(v97 + v107, 11) ^ __ROR4__(v108, 6) ^ __ROR4__(v108, 25))
       + v99
       + v203
       + 1986661051
       + ((v102 ^ (v95 + v104)) & v108 ^ v102);
  v111 = v100 + v110;
  v112 = ((v106 | v109) & v103 | v106 & v109) + (__ROR4__(v109, 13) ^ __ROR4__(v109, 2) ^ __ROR4__(v109, 22)) + v110;
  v236 = (__ROR4__(F, 18) ^ __ROR4__(F, 7) ^ (F >> 3))
       + v239
       + v267
       + (__ROR4__(v232, 19) ^ __ROR4__(v232, 17) ^ (v232 >> 10));
  v113 = (__ROR4__(v100 + v110, 11) ^ __ROR4__(v111, 6) ^ __ROR4__(v111, 25))
       + v102
       + v236
       - 2117940946
       + ((v105 ^ (v97 + v107)) & v111 ^ v105);
  v114 = v103 + v113;
  Ae = ((v109 | v112) & v106 | v109 & v112) + (__ROR4__(v112, 13) ^ __ROR4__(v112, 2) ^ __ROR4__(v112, 22)) + v113;
  He = (__ROR4__(v245, 18) ^ __ROR4__(v245, 7) ^ (v245 >> 3))
     + F
     + v269
     + (__ROR4__(v203, 19) ^ __ROR4__(v203, 17) ^ (v203 >> 10));
  v115 = (__ROR4__(v103 + v113, 11) ^ __ROR4__(v103 + v113, 6) ^ __ROR4__(v114, 25))
       + He
       - 1838011259
       + v105
       + ((v108 ^ (v100 + v110)) & v114 ^ v108);
  v116 = v106 + v115;
  v117 = ((v112 | Ae) & v109 | v112 & Ae) + (__ROR4__(Ae, 13) ^ __ROR4__(Ae, 2) ^ __ROR4__(Ae, 22)) + v115;
  v240 = (__ROR4__(v250, 18) ^ __ROR4__(v250, 7) ^ (v250 >> 3))
       + v245
       + v272
       + (__ROR4__(v236, 19) ^ __ROR4__(v236, 17) ^ (v236 >> 10));
  v118 = (__ROR4__(v106 + v115, 11) ^ __ROR4__(v106 + v115, 6) ^ __ROR4__(v106 + v115, 25))
       + ((v111 ^ v114) & (v106 + v115) ^ v111)
       + v240
       - 1564481375
       + v108;
  v119 = v109 + v118;
  v120 = ((Ae | v117) & v112 | Ae & v117) + (__ROR4__(v117, 13) ^ __ROR4__(v117, 2) ^ __ROR4__(v117, 22)) + v118;
  v273 = (__ROR4__(He, 19) ^ __ROR4__(He, 17) ^ (He >> 10))
       + (__ROR4__(v254, 18) ^ __ROR4__(v254, 7) ^ (v254 >> 3))
       + v250
       + v223;
  v121 = (__ROR4__(v119, 11) ^ __ROR4__(v119, 6) ^ __ROR4__(v119, 25))
       + v111
       + v273
       - 1474664885
       + ((v114 ^ v116) & v119 ^ v114);
  Cc = v112 + v121;
  v122 = (Ae & (v117 | v120) | v117 & v120) + (__ROR4__(v120, 13) ^ __ROR4__(v120, 2) ^ __ROR4__(v120, 22)) + v121;
  Fa = (__ROR4__(v240, 19) ^ __ROR4__(v240, 17) ^ (v240 >> 10))
     + (__ROR4__(Ba, 18) ^ __ROR4__(Ba, 7) ^ (Ba >> 3))
     + v254
     + v228;
  v123 = (__ROR4__(v112 + v121, 11) ^ __ROR4__(v112 + v121, 6) ^ __ROR4__(v112 + v121, 25))
       + ((v116 ^ v119) & (v112 + v121) ^ v116)
       + Fa
       - 1035236496
       + v114;
  v124 = ((v120 | v122) & v117 | v120 & v122) + (__ROR4__(v122, 13) ^ __ROR4__(v122, 2) ^ __ROR4__(v122, 22)) + v123;
  v246 = (__ROR4__(v261, 18) ^ __ROR4__(v261, 7) ^ (v261 >> 3))
       + Ba
       + v232
       + (__ROR4__(v273, 19) ^ __ROR4__(v273, 17) ^ (v273 >> 10));
  v125 = (v119 ^ (v112 + v121)) & (Ae + v123);
  v126 = __ROR4__(Ae + v123, 11);
  Af = Ae + v123;
  v127 = (v125 ^ v119) + v246 - 949202525 + v116 + (v126 ^ __ROR4__(Af, 6) ^ __ROR4__(Af, 25));
  v128 = v117 + v127;
  v129 = ((v122 | v124) & v120 | v122 & v124) + (__ROR4__(v124, 13) ^ __ROR4__(v124, 2) ^ __ROR4__(v124, 22)) + v127;
  Db = (__ROR4__(Fa, 19) ^ __ROR4__(Fa, 17) ^ (Fa >> 10))
     + (__ROR4__(v208, 18) ^ __ROR4__(v208, 7) ^ (v208 >> 3))
     + v261
     + v203;
  v130 = Cc;
  v131 = (__ROR4__(v117 + v127, 11) ^ __ROR4__(v128, 6) ^ __ROR4__(v128, 25))
       + v119
       + Db
       - 778901479
       + ((Cc ^ Af) & v128 ^ Cc);
  v132 = ((v124 | v129) & v122 | v124 & v129) + (__ROR4__(v129, 13) ^ __ROR4__(v129, 2) ^ __ROR4__(v129, 22)) + v131;
  v133 = v120 + v131;
  Cd = (__ROR4__(v264, 18) ^ __ROR4__(v264, 7) ^ (v264 >> 3))
     + v208
     + v236
     + (__ROR4__(v246, 19) ^ __ROR4__(v246, 17) ^ (v246 >> 10));
  v134 = (__ROR4__(v133, 11) ^ __ROR4__(v133, 6) ^ __ROR4__(v133, 25))
       + ((Af ^ v128) & v133 ^ Af)
       + Cd
       - 694614492
       + v130;
  v135 = v122 + v134;
  v136 = ((v129 | v132) & v124 | v129 & v132) + (__ROR4__(v132, 13) ^ __ROR4__(v132, 2) ^ __ROR4__(v132, 22)) + v134;
  v209 = (__ROR4__(v267, 18) ^ __ROR4__(v267, 7) ^ (v267 >> 3))
       + v264
       + He
       + (__ROR4__(Db, 19) ^ __ROR4__(Db, 17) ^ (Db >> 10));
  v137 = (__ROR4__(v135, 11) ^ __ROR4__(v135, 6) ^ __ROR4__(v135, 25))
       + ((v128 ^ v133) & v135 ^ v128)
       + Af
       + v209
       - 200395387;
  v138 = v124 + v137;
  v139 = ((v132 | v136) & v129 | v132 & v136) + (__ROR4__(v136, 13) ^ __ROR4__(v136, 2) ^ __ROR4__(v136, 22)) + v137;
  v251 = (__ROR4__(v269, 18) ^ __ROR4__(v269, 7) ^ (v269 >> 3))
       + v267
       + v240
       + (__ROR4__(Cd, 19) ^ __ROR4__(Cd, 17) ^ (Cd >> 10));
  v140 = (__ROR4__(v138, 11) ^ __ROR4__(v138, 6) ^ __ROR4__(v138, 25))
       + ((v133 ^ v135) & v138 ^ v133)
       + v251
       + 275423344
       + v128;
  v141 = v129 + v140;
  v142 = ((v136 | v139) & v132 | v136 & v139) + (__ROR4__(v139, 13) ^ __ROR4__(v139, 2) ^ __ROR4__(v139, 22)) + v140;
  Bb = (__ROR4__(v209, 19) ^ __ROR4__(v209, 17) ^ (v209 >> 10))
     + (__ROR4__(v272, 18) ^ __ROR4__(v272, 7) ^ (v272 >> 3))
     + v269
     + v273;
  v143 = (__ROR4__(v141, 11) ^ __ROR4__(v141, 6) ^ __ROR4__(v141, 25))
       + ((v135 ^ v138) & v141 ^ v135)
       + Bb
       + 430227734
       + v133;
  v144 = v132 + v143;
  v145 = ((v139 | v142) & v136 | v139 & v142) + (__ROR4__(v142, 13) ^ __ROR4__(v142, 2) ^ __ROR4__(v142, 22)) + v143;
  v146 = (__ROR4__(v251, 19) ^ __ROR4__(v251, 17) ^ (v251 >> 10))
       + (__ROR4__(v223, 18) ^ __ROR4__(v223, 7) ^ (v223 >> 3))
       + v272
       + Fa;
  v147 = (__ROR4__(v144, 11) ^ __ROR4__(v144, 6) ^ __ROR4__(v144, 25))
       + ((v138 ^ v141) & v144 ^ v138)
       + v146
       + 506948616
       + v135;
  v148 = (v139 & (v142 | v145) | v142 & v145) + (__ROR4__(v145, 13) ^ __ROR4__(v145, 2) ^ __ROR4__(v145, 22)) + v147;
  v255 = v136 + v147;
  v262 = (__ROR4__(Bb, 19) ^ __ROR4__(Bb, 17) ^ (Bb >> 10))
       + (__ROR4__(v228, 18) ^ __ROR4__(v228, 7) ^ (v228 >> 3))
       + v223
       + v246;
  v149 = (__ROR4__(v136 + v147, 11) ^ __ROR4__(v136 + v147, 6) ^ __ROR4__(v255, 25))
       + ((v141 ^ v144) & v255 ^ v141)
       + v138
       + v262
       + 659060556;
  v150 = v139 + v149;
  v151 = v149 + ((v145 | v148) & v142 | v145 & v148) + (__ROR4__(v148, 13) ^ __ROR4__(v148, 2) ^ __ROR4__(v148, 22));
  v265 = (__ROR4__(v146, 19) ^ __ROR4__(v146, 17) ^ (v146 >> 10))
       + v228
       + (__ROR4__(v232, 18) ^ __ROR4__(v232, 7) ^ (v232 >> 3))
       + Db;
  v152 = (__ROR4__(v150, 11) ^ __ROR4__(v150, 6) ^ __ROR4__(v150, 25))
       + ((v144 ^ (v136 + v147)) & v150 ^ v144)
       + v141
       + v265
       + 883997877;
  v153 = v142 + v152;
  v268 = (__ROR4__(v203, 18) ^ __ROR4__(v203, 7) ^ (v203 >> 3))
       + v232
       + Cd
       + (__ROR4__(v262, 19) ^ __ROR4__(v262, 17) ^ (v262 >> 10));
  v154 = v152 + (__ROR4__(v151, 13) ^ __ROR4__(v151, 2) ^ __ROR4__(v151, 22)) + ((v148 | v151) & v145 | v148 & v151);
  v155 = (__ROR4__(v153, 11) ^ __ROR4__(v153, 6) ^ __ROR4__(v153, 25))
       + ((v255 ^ v150) & v153 ^ v255)
       + v144
       + v268
       + 958139571;
  v156 = v145 + v155;
  v270 = (__ROR4__(v236, 18) ^ __ROR4__(v236, 7) ^ (v236 >> 3))
       + v203
       + v209
       + (__ROR4__(v265, 19) ^ __ROR4__(v265, 17) ^ (v265 >> 10));
  v157 = v155 + (__ROR4__(v154, 13) ^ __ROR4__(v154, 2) ^ __ROR4__(v154, 22)) + ((v151 | v154) & v148 | v151 & v154);
  v158 = (__ROR4__(v156, 11) ^ __ROR4__(v156, 6) ^ __ROR4__(v156, 25))
       + ((v150 ^ v153) & v156 ^ v150)
       + v136
       + v147
       + v270
       + 1322822218;
  v224 = v148 + v158;
  v159 = __ROR4__(v148 + v158, 11);
  v160 = v158 + (__ROR4__(v157, 13) ^ __ROR4__(v157, 2) ^ __ROR4__(v157, 22)) + ((v154 | v157) & v151 | v154 & v157);
  v237 = (__ROR4__(He, 18) ^ __ROR4__(He, 7) ^ (He >> 3))
       + v236
       + v251
       + (__ROR4__(v268, 19) ^ __ROR4__(v268, 17) ^ (v268 >> 10));
  v161 = (v159 ^ __ROR4__(v224, 6) ^ __ROR4__(v224, 25)) + ((v153 ^ v156) & v224 ^ v153) + v237 + 1537002063 + v150;
  v204 = v151 + v161;
  v256 = (__ROR4__(v240, 18) ^ __ROR4__(v240, 7) ^ (v240 >> 3))
       + He
       + Bb
       + (__ROR4__(v270, 19) ^ __ROR4__(v270, 17) ^ (v270 >> 10));
  Hf = v161 + (__ROR4__(v160, 13) ^ __ROR4__(v160, 2) ^ __ROR4__(v160, 22)) + ((v157 | v160) & v154 | v157 & v160);
  v162 = (__ROR4__(v204, 11) ^ __ROR4__(v204, 6) ^ __ROR4__(v204, 25))
       + ((v156 ^ v224) & v204 ^ v156)
       + v153
       + v256
       + 1747873779;
  v163 = v154 + v162;
  v241 = (__ROR4__(v273, 18) ^ __ROR4__(v273, 7) ^ (v273 >> 3))
       + v240
       + v146
       + (__ROR4__(v237, 19) ^ __ROR4__(v237, 17) ^ (v237 >> 10));
  v229 = (__ROR4__(Hf, 13) ^ __ROR4__(Hf, 2) ^ __ROR4__(Hf, 22)) + (v160 & Hf | (v160 | Hf) & v157) + v162;
  v164 = (__ROR4__(v163, 11) ^ __ROR4__(v163, 6) ^ __ROR4__(v163, 25))
       + ((v224 ^ (v151 + v161)) & v163 ^ v224)
       + v156
       + v241
       + 1955562222;
  Ag = ((Hf | v229) & v160 | Hf & v229) + (__ROR4__(v229, 13) ^ __ROR4__(v229, 2) ^ __ROR4__(v229, 22)) + v164;
  v233 = v157 + v164;
  v165 = v262
       + (__ROR4__(Fa, 18) ^ __ROR4__(Fa, 7) ^ (Fa >> 3))
       + v273
       + (__ROR4__(v256, 19) ^ __ROR4__(v256, 17) ^ (v256 >> 10));
  v166 = ((v204 ^ v163) & (v157 + v164) ^ v204)
       + v165
       + 2024104815
       + v224
       + (__ROR4__(v157 + v164, 11) ^ __ROR4__(v157 + v164, 6) ^ __ROR4__(v157 + v164, 25));
  v167 = ((v229 | Ag) & Hf | v229 & Ag) + (__ROR4__(Ag, 13) ^ __ROR4__(Ag, 2) ^ __ROR4__(Ag, 22)) + v166;
  v168 = __ROR4__(v167, 13) ^ __ROR4__(v167, 2) ^ __ROR4__(v167, 22);
  v169 = (__ROR4__(v246, 18) ^ __ROR4__(v246, 7) ^ (v246 >> 3))
       + Fa
       + v265
       + (__ROR4__(v241, 19) ^ __ROR4__(v241, 17) ^ (v241 >> 10));
  v205 = v167;
  v170 = v151
       + v161
       + v169
       - 2067236844
       + ((v163 ^ v233) & (v160 + v166) ^ v163)
       + (__ROR4__(v160 + v166, 11) ^ __ROR4__(v160 + v166, 6) ^ __ROR4__(v160 + v166, 25));
  v225 = v160 + v166;
  v171 = Hf + v170;
  v172 = __ROR4__(Hf + v170, 11) ^ __ROR4__(Hf + v170, 6);
  v173 = v170 + ((Ag | v205) & v229 | Ag & v205) + v168;
  v174 = (__ROR4__(Db, 18) ^ __ROR4__(Db, 7) ^ (Db >> 3))
       + v246
       + v268
       + (__ROR4__(v165, 19) ^ __ROR4__(v165, 17) ^ (v165 >> 10));
  v175 = ((v233 ^ v225) & v171 ^ v233) + v174 - 1933114872 + v163 + (v172 ^ __ROR4__(v171, 25));
  v176 = (v205 & v173 | (v205 | v173) & Ag) + (__ROR4__(v173, 13) ^ __ROR4__(v173, 2) ^ __ROR4__(v173, 22)) + v175;
  v247 = __ROR4__(v174, 19) ^ __ROR4__(v174, 17) ^ (v174 >> 10);
  v177 = (__ROR4__(v169, 19) ^ __ROR4__(v169, 17) ^ (v169 >> 10))
       + (__ROR4__(Cd, 18) ^ __ROR4__(Cd, 7) ^ (Cd >> 3))
       + Db
       + v270;
  Hg = v229 + v175;
  v178 = v177
       - 1866530822
       + v233
       + ((v171 ^ v225) & (v229 + v175) ^ v225)
       + (__ROR4__(v229 + v175, 11) ^ __ROR4__(v229 + v175, 6) ^ __ROR4__(v229 + v175, 25));
  v179 = Ag + v178;
  v180 = ((v173 | v176) & v205 | v173 & v176) + (__ROR4__(v176, 13) ^ __ROR4__(v176, 2) ^ __ROR4__(v176, 22)) + v178;
  v181 = (__ROR4__(v209, 18) ^ __ROR4__(v209, 7) ^ (v209 >> 3)) + Cd + v237;
  v182 = (__ROR4__(Ag + v178, 11) ^ __ROR4__(Ag + v178, 6) ^ __ROR4__(Ag + v178, 25))
       + ((v171 ^ Hg) & (Ag + v178) ^ v171)
       + v181
       + v247
       - 1538233109
       + v225;
  v183 = ((v176 | v180) & v173 | v176 & v180) + (__ROR4__(v180, 13) ^ __ROR4__(v180, 2) ^ __ROR4__(v180, 22)) + v182;
  v184 = ((Hg ^ (Ag + v178)) & (v205 + v182) ^ Hg)
       + v209
       - 1090935817
       + (__ROR4__(v251, 18) ^ __ROR4__(v251, 7) ^ (v251 >> 3))
       + v256
       + (__ROR4__(v177, 19) ^ __ROR4__(v177, 17) ^ (v177 >> 10))
       + v171
       + (__ROR4__(v205 + v182, 11) ^ __ROR4__(v205 + v182, 6) ^ __ROR4__(v205 + v182, 25));
  v185 = v173 + v184;
  v186 = ((v180 | v183) & v176 | v180 & v183) + (__ROR4__(v183, 13) ^ __ROR4__(v183, 2) ^ __ROR4__(v183, 22)) + v184;
  v187 = v251
       - 965641998
       + (__ROR4__(Bb, 18) ^ __ROR4__(Bb, 7) ^ (Bb >> 3))
       + v241
       + (__ROR4__(v181 + v247, 19) ^ __ROR4__(v181 + v247, 17) ^ ((v181 + v247) >> 10))
       + Hg
       + ((v179 ^ (v205 + v182)) & v185 ^ v179)
       + (__ROR4__(v185, 11) ^ __ROR4__(v185, 6) ^ __ROR4__(v185, 25));
  ctx->state[7] = v179 + v280;
  ctx->state[3] = v180 + v279;
  ctx->state[6] = v205 + v182 + v277;
  ctx->state[1] = v186 + v275;
  ctx->state[2] = v183 + v278;
  ctx->state[5] = v185 + v276;
  ctx->state[0] = ((v183 | v186) & v180 | v183 & v186)
                + (__ROR4__(v186, 13) ^ __ROR4__(v186, 2) ^ __ROR4__(v186, 22))
                + v274
                + v187;
  ctx->state[4] = v187 + v176 + v281;
}

//----- (00041AD8) --------------------------------------------------------
// Alternative name is 'sha2_update.part.0'
void __fastcall sha2_update_0(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  signed int v3; // r5
  uint32_t v4; // r3
  const unsigned __int8 *v6; // r4
  bool v7; // cf
  uint32_t v8; // r2
  uint32_t v9; // r8
  signed int v10; // r7
  _BOOL4 v11; // r3
  unsigned int v12; // r5
  const unsigned __int8 *v13; // r7
  const unsigned __int8 *v14; // r1
  unsigned __int8 *buffer; // r9

  v3 = ilen;
  v4 = ctx->total[0];
  v6 = input;
  v7 = __CFADD__(ctx->total[0], ilen);
  v8 = ctx->total[0] + ilen;
  v9 = ctx->total[0] & 0x3F;
  if ( v7 )
    v4 = ctx->total[1];
  v10 = 64 - v9;
  ctx->total[0] = v8;
  if ( v7 )
    ctx->total[1] = v4 + 1;
  v11 = v10 <= v3;
  if ( !v9 )
    v11 = 0;
  if ( v11 )
  {
    buffer = ctx->buffer;
    v3 -= v10;
    memcpy(&ctx->buffer[v9], input, 64 - v9);
    v6 += v10;
    v9 = 0;
    sha2_process(ctx, buffer);
  }
  if ( v3 > 63 )
  {
    v12 = v3 - 64;
    v13 = &v6[64 * (v12 >> 6) + 64];
    do
    {
      v14 = v6;
      v6 += 64;
      sha2_process(ctx, v14);
    }
    while ( v6 != v13 );
    v3 = v12 - (v12 >> 6 << 6);
  }
  if ( v3 > 0 )
    sub_12058(&ctx->buffer[v9], v6, v3);
}

//----- (00041B6C) --------------------------------------------------------
void __fastcall sha2_update(sha2_context *ctx, const unsigned __int8 *input, int ilen)
{
  if ( ilen > 0 )
    sha2_update_0(ctx, input, ilen);
}

//----- (00041B74) --------------------------------------------------------
void __fastcall sha2_finish(sha2_context *ctx, unsigned __int8 *output)
{
  uint32_t v4; // r2
  int v5; // r1
  uint32_t v6; // r3
  uint32_t v7; // r0
  uint32_t v8; // r3
  int v9; // r2
  unsigned __int8 msglen[8]; // [sp+0h] [bp-8h] BYREF

  v4 = ctx->total[0] & 0x3F;
  v5 = *(_QWORD *)ctx->total >> 29;
  v6 = 8 * ctx->total[0];
  msglen[7] = 8 * LOBYTE(ctx->total[0]);
  msglen[4] = HIBYTE(v6);
  msglen[3] = v5;
  msglen[1] = BYTE2(v5);
  v7 = HIWORD(v6);
  v8 = v6 >> 8;
  msglen[2] = BYTE1(v5);
  msglen[5] = v7;
  if ( v4 > 0x37 )
    v9 = 120 - v4;
  else
    v9 = 56 - v4;
  msglen[6] = v8;
  msglen[0] = HIBYTE(v5);
  sha2_update_0(ctx, sha2_padding, v9);
  sha2_update_0(ctx, msglen, 8);
  *output = HIBYTE(ctx->state[0]);
  output[1] = HIWORD(ctx->state[0]);
  output[2] = BYTE1(ctx->state[0]);
  output[3] = ctx->state[0];
  output[4] = HIBYTE(ctx->state[1]);
  output[5] = HIWORD(ctx->state[1]);
  output[6] = BYTE1(ctx->state[1]);
  output[7] = ctx->state[1];
  output[8] = HIBYTE(ctx->state[2]);
  output[9] = HIWORD(ctx->state[2]);
  output[10] = BYTE1(ctx->state[2]);
  output[11] = ctx->state[2];
  output[12] = HIBYTE(ctx->state[3]);
  output[13] = HIWORD(ctx->state[3]);
  output[14] = BYTE1(ctx->state[3]);
  output[15] = ctx->state[3];
  output[16] = HIBYTE(ctx->state[4]);
  output[17] = HIWORD(ctx->state[4]);
  output[18] = BYTE1(ctx->state[4]);
  output[19] = ctx->state[4];
  output[20] = HIBYTE(ctx->state[5]);
  output[21] = HIWORD(ctx->state[5]);
  output[22] = BYTE1(ctx->state[5]);
  output[23] = ctx->state[5];
  output[24] = HIBYTE(ctx->state[6]);
  output[25] = HIWORD(ctx->state[6]);
  output[26] = BYTE1(ctx->state[6]);
  output[27] = ctx->state[6];
  output[28] = HIBYTE(ctx->state[7]);
  output[29] = HIWORD(ctx->state[7]);
  output[30] = BYTE1(ctx->state[7]);
  output[31] = ctx->state[7];
}

//----- (00041C78) --------------------------------------------------------
void __fastcall sha2(const unsigned __int8 *input, int ilen, unsigned __int8 *output)
{
  sha2_context ctx; // [sp+0h] [bp-E8h] BYREF

  ctx.state[0] = 1779033703;
  ctx.state[3] = -1521486534;
  ctx.state[4] = 1359893119;
  ctx.state[2] = 1013904242;
  ctx.state[6] = 528734635;
  ctx.state[7] = 1541459225;
  ctx.state[5] = -1694144372;
  ctx.state[1] = -1150833019;
  ctx.total[0] = 0;
  ctx.total[1] = 0;
  if ( ilen > 0 )
    sha2_update_0(&ctx, input, ilen);
  sha2_finish(&ctx, output);
}

//----- (00041CF0) --------------------------------------------------------
int __fastcall compareSR(const void *p1, const void *p2)
{
  return j_memcmp(p1, p2, compare_size);
}

//----- (00041D00) --------------------------------------------------------
void __fastcall generateHash(blake2b_state *S, const uint32_t g, uint8_t *hash, const size_t hashLen)
{
  uint8_t v5; // r5
  uint32_t le_g; // [sp+4h] [bp-170h] BYREF
  blake2b_state digest; // [sp+8h] [bp-16Ch] BYREF

  le_g = g;
  v5 = hashLen;
  memcpy(&digest, S, sizeof(digest));
  blake2b_update(&digest, (const uint8_t *)&le_g, 4u);
  blake2b_final(&digest, hash, v5);
}

//----- (00041D30) --------------------------------------------------------
void __fastcall expandArray(
        const unsigned __int8 *in,
        const size_t in_len,
        unsigned __int8 *out,
        const size_t out_len,
        const size_t bit_len,
        const size_t byte_pad)
{
  size_t v7; // r8
  const unsigned __int8 *v8; // r0
  int v9; // lr
  unsigned int v10; // r6
  size_t v11; // r5
  int v12; // t1
  unsigned __int8 *v13; // r3
  size_t v14; // r1
  unsigned __int8 *v15; // r4
  unsigned int v16; // r3
  unsigned int v17; // r2
  const unsigned __int8 *v18; // [sp+4h] [bp-18h]

  if ( bit_len <= 7 )
    _assert_fail("bit_len >= 8", "sort-verify.c", 0x40u, "expandArray");
  if ( bit_len + 7 > 0x20 )
    _assert_fail("8 * sizeof(uint32_t) >= 7 + bit_len", "sort-verify.c", 0x41u, "expandArray");
  v7 = byte_pad + ((bit_len + 7) >> 3);
  if ( v7 * 8 * in_len / bit_len != out_len )
    _assert_fail("out_len == 8 * out_width * in_len / bit_len", "sort-verify.c", 0x44u, "expandArray");
  if ( in_len )
  {
    v8 = in - 1;
    v18 = &in[in_len - 1];
    v9 = 0;
    v10 = 0;
    v11 = 0;
    do
    {
      while ( 1 )
      {
        v12 = *++v8;
        v11 += 8;
        v10 = v12 | (v10 << 8);
        if ( bit_len <= v11 )
          break;
        if ( v8 == v18 )
          return;
      }
      v11 -= bit_len;
      if ( byte_pad )
      {
        v13 = &out[v9];
        do
          *v13++ = 0;
        while ( &out[byte_pad + v9] != v13 );
      }
      if ( byte_pad < v7 )
      {
        v14 = v11 + 8 * (((bit_len + 7) >> 3) + 0x1FFFFFFF);
        v15 = &out[byte_pad + v9];
        do
        {
          v16 = v10 >> v14;
          v17 = (unsigned int)((1 << bit_len) - 1) >> (v14 - v11);
          v14 -= 8;
          *v15++ = v16 & v17;
        }
        while ( &out[v7 + v9] != v15 );
      }
      v9 += v7;
    }
    while ( v8 != v18 );
  }
}

//----- (00041E64) --------------------------------------------------------
void __fastcall sort_pair(uint32_t *a, uint32_t len)
{
  uint32_t *v2; // r2
  uint32_t v3; // r3
  uint32_t *v4; // r7
  uint32_t *v5; // r6
  uint32_t v6; // r5
  uint32_t v7; // t1
  uint32_t v8; // r4
  uint32_t v9; // t1
  bool v10; // cf
  uint32_t *v11; // r0
  uint32_t *v12; // r2

  v2 = &a[len];
  if ( len )
  {
    v3 = 0;
    v4 = a - 1;
    v5 = v2 - 1;
    while ( 1 )
    {
      v7 = v4[1];
      ++v4;
      v6 = v7;
      v9 = v5[1];
      ++v5;
      v8 = v9;
      v10 = v6 >= v9;
      if ( v6 > v9 )
        break;
      ++v3;
      if ( !v10 || len == v3 )
        return;
    }
    v11 = &a[v3];
    v12 = &v2[v3];
    while ( 1 )
    {
      ++v3;
      *v11++ = v8;
      *v12++ = v6;
      if ( len <= v3 )
        break;
      v8 = *v12;
      v6 = *v11;
    }
  }
}

//----- (00041EAC) --------------------------------------------------------
int __fastcall sortValidator(void *data, const unsigned __int8 *soln)
{
  int v2; // r4
  int v3; // r11
  int v4; // r6
  int v6; // r1
  int v7; // r3
  bool v8; // cf
  int v9; // r1
  uint32_t *v10; // r4
  int v11; // r0
  uint32_t v12; // r1
  uint32_t v13; // t1
  int v14; // r3
  int v15; // r4
  int v17; // r4
  uint32_t *v18; // r10
  int v19; // r3
  int v20; // r6
  uint8_t *v21; // r9
  unsigned int v22; // t1
  signed int v23; // r0
  int v24; // r5
  int v25; // r0
  int v26; // r5
  uint8_t *v27; // r2
  uint8_t *i; // r1
  char v29; // t1
  uint8_t *j; // r3
  int v31; // t1
  size_t v32; // r10
  uint8_t *v33; // r8
  int v34; // r9
  uint8_t *v35; // r5
  uint8_t *v36; // r11
  int v37; // r7
  int v38; // lr
  uint8_t *v39; // r0
  uint8_t *v40; // r4
  uint8_t *v41; // r12
  char v42; // r3
  char v43; // t1
  char v44; // t1
  int v45; // r4
  uint8_t *v46; // r0
  int v47; // r4
  uint8_t *v48; // r1
  uint8_t *v49; // r3
  uint8_t *v50; // r2
  uint32_t *v51; // r8
  unsigned int v52; // t1
  int k; // r10
  uint32_t *v54; // r7
  int v55; // r6
  uint32_t *v56; // r7
  uint8_t *v57; // r5
  signed int v58; // t1
  int v59; // r4
  int v60; // r0
  int v61; // r4
  unsigned int v62; // r4
  const unsigned __int8 *v63; // r0
  char *v64; // r0
  uint8_t *v65; // r9
  size_t v66; // r8
  int v67; // r7
  size_t v68; // r3
  int v69; // r11
  uint8_t *v70; // r10
  uint8_t *v71; // r5
  int v72; // lr
  uint8_t *v73; // r0
  uint8_t *v74; // r4
  uint8_t *v75; // r12
  char v76; // r3
  char v77; // t1
  char v78; // t1
  int v79; // r4
  uint8_t *v80; // r0
  size_t v81; // r4
  uint8_t *v82; // r1
  uint8_t *v83; // r3
  int v84; // r4
  uint8_t *v85; // r6
  unsigned int v86; // r2
  unsigned int v87; // r3
  char *v88; // r0
  uint8_t *v89; // r7
  int v90; // r1
  char *v91; // r0
  char *v92; // r0
  int v93; // r1
  int v94; // r2
  int v95; // r3
  int v96; // r1
  int v97; // r2
  int v98; // r3
  uint8_t *v99; // r3
  int v100; // t1
  size_t x_size_0; // [sp+8h] [bp-5E0h]
  uint32_t x_size_0a; // [sp+8h] [bp-5E0h]
  blake2b_state *digest; // [sp+Ch] [bp-5DCh]
  size_t digesta; // [sp+Ch] [bp-5DCh]
  size_t in_len; // [sp+10h] [bp-5D8h]
  int v106; // [sp+14h] [bp-5D4h]
  int v107; // [sp+14h] [bp-5D4h]
  size_t hashLen; // [sp+18h] [bp-5D0h]
  uint8_t *x; // [sp+1Ch] [bp-5CCh]
  uint8_t *xc; // [sp+20h] [bp-5C8h]
  int v111; // [sp+28h] [bp-5C0h]
  int v112; // [sp+28h] [bp-5C0h]
  size_t x_size; // [sp+2Ch] [bp-5BCh]
  size_t v114; // [sp+30h] [bp-5B8h]
  int v115; // [sp+34h] [bp-5B4h]
  int n; // [sp+44h] [bp-5A4h]
  uint8_t vHash[30]; // [sp+48h] [bp-5A0h] BYREF
  char v118; // [sp+66h] [bp-582h] BYREF
  uint8_t tmp_hash[30]; // [sp+68h] [bp-580h] BYREF
  unsigned __int8 hash[31]; // [sp+88h] [bp-560h] BYREF
  char v121; // [sp+A7h] [bp-541h] BYREF
  uint8_t tmpHash_0[1340]; // [sp+A8h] [bp-540h] BYREF
  char v123; // [sp+5E4h] [bp-4h] BYREF
  char v124; // [sp+5E7h] [bp-1h] BYREF
  uint32_t indices[512]; // [sp+5E8h] [bp+0h] BYREF
  uint8_t tmpHash[2040]; // [sp+DE8h] [bp+800h] BYREF
  int v127; // [sp+15E4h] [bp+FFCh] BYREF

  v2 = *((_DWORD *)data + 1);
  v3 = *(_DWORD *)data;
  v4 = v2 + 1;
  digest = (blake2b_state *)*((_DWORD *)data + 2);
  x_size_0 = *(_DWORD *)data / (v2 + 1);
  v6 = (v3 / (v2 + 1) + 1) << v2;
  v7 = v6 + 7;
  v8 = v6 < 0;
  v9 = v6 & ~(v6 >> 31);
  if ( v8 )
    v9 = v7;
  compare_size = 3;
  expandArray(soln, v9 >> 3, (unsigned __int8 *)indices, 0x800u, v3 / (v2 + 1) + 1, 1u);
  v10 = indices;
  memset(vHash, 0, sizeof(vHash));
  x = (uint8_t *)malloc(0x4400u);
  xc = (uint8_t *)malloc(0x4400u);
  memset(tmp_hash, 0, sizeof(tmp_hash));
  v11 = 0;
  while ( ++v11 != 512 )
  {
    v12 = *v10;
    v13 = v10[1];
    ++v10;
    if ( v12 == v13 )
    {
LABEL_9:
      v15 = 1;
      goto failed;
    }
    v14 = v11;
    while ( ++v14 != 512 )
    {
      if ( v12 == indices[v14] )
        goto LABEL_9;
    }
  }
  v17 = 0;
  v18 = (uint32_t *)&v123;
  v19 = x_size_0 + 14;
  if ( (int)(x_size_0 + 7) >= 0 )
    v19 = x_size_0 + 7;
  v20 = v4 * (v19 >> 3);
  v21 = x;
  v106 = 512 / v3;
  in_len = v3 / 8;
  v111 = v20 + 4;
  hashLen = 512 / v3 * v3 / 8;
  do
  {
    v22 = v18[1];
    ++v18;
    v23 = bswap32(v22);
    v24 = v3 * (v23 % v106);
    generateHash(digest, v23 / v106, tmpHash, hashLen);
    v25 = v24 + 7;
    v8 = v24 < 0;
    v26 = v24 & ~(v24 >> 31);
    if ( v8 )
      v26 = v25;
    expandArray(&tmpHash[v26 >> 3], in_len, tmpHash_0, v20, x_size_0, 0);
    if ( v20 )
    {
      v27 = tmpHash_0;
      for ( i = vHash; ; LOBYTE(v17) = *i )
      {
        v29 = *v27++;
        *i++ = v17 ^ v29;
        if ( v27 == &tmpHash_0[v20] )
          break;
      }
      v17 = vHash[0];
    }
    memcpy(v21, tmpHash_0, v20);
    *(_DWORD *)&v21[v20] = *v18;
    v21 += v111;
  }
  while ( v18 != &indices[511] );
  for ( j = vHash; ; ++j )
  {
    if ( v17 )
    {
      v15 = 2;
      goto failed;
    }
    if ( j == &vHash[29] )
      break;
    v31 = j[1];
    v17 = v31;
  }
  v32 = 4;
  memset(vHash, 0, sizeof(vHash));
  v33 = xc;
  n = v3;
  v115 = 9;
  x_size = 512;
  while ( 1 )
  {
    qsort(x, x_size, v20 + v32, compareSR);
    v34 = 2 * (v20 + v32);
    v35 = &x[v20 + v32 + v20];
    v36 = &x[v20];
    v37 = 0;
    x_size = ((x_size - 1) >> 1) + 1;
    do
    {
      v38 = 2 * v37;
      if ( v20 )
      {
        v39 = &v35[-v20];
        v40 = tmp_hash;
        v41 = &v36[~v20];
        do
        {
          v43 = *v39++;
          v42 = v43;
          v44 = *++v41;
          *v40++ = v42 ^ v44;
        }
        while ( v35 != v39 );
      }
      ++v37;
      v45 = (v20 + v32 + v32) * (v38 >> 1);
      v46 = &v33[v45];
      v47 = v45 + v20;
      memcpy(v46, tmp_hash, v20);
      v48 = v36;
      v36 += v34;
      memcpy(&v33[v47], v48, v32);
      memcpy(&v33[v47 + v32], v35, v32);
      v35 += v34;
    }
    while ( v37 != x_size );
    v32 *= 2;
    compare_size += 3;
    if ( !--v115 )
      break;
    v49 = x;
    x = v33;
    v33 = v49;
  }
  xc = v33;
  v50 = &v33[v20 - 4];
  v51 = &indices[511];
  do
  {
    v52 = *((_DWORD *)v50 + 1);
    v50 += 4;
    v51[1] = bswap32(v52);
    ++v51;
  }
  while ( &v127 != (int *)v51 );
  v114 = v20;
  for ( k = 0; k != 9; ++k )
  {
    v54 = (uint32_t *)tmpHash;
    v55 = 0;
    do
    {
      v55 += 2 << k;
      sort_pair(v54, 1 << k);
      v54 += 2 << k;
    }
    while ( v55 < 512 );
  }
  v56 = &indices[511];
  v57 = xc;
  do
  {
    v58 = v56[1];
    ++v56;
    v59 = n * (v58 % v106);
    generateHash(digest, v58 / v106, tmpHash_0, hashLen);
    v60 = v59 + 7;
    v8 = v59 < 0;
    v61 = v59 & ~(v59 >> 31);
    if ( v8 )
      v61 = v60;
    expandArray(&tmpHash_0[v61 >> 3], in_len, hash, v114, x_size_0, 0);
    v62 = bswap32(*v56);
    memcpy(v57, hash, v114);
    *(_DWORD *)&v57[v114] = v62;
    v63 = v57;
    v57 += v111;
    v64 = bin2hex(v63, 0x22u);
    free(v64);
  }
  while ( v56 != v51 );
  v65 = x;
  v66 = 4;
  x_size_0a = 512;
  v107 = compare_size + 3;
  v112 = compare_size + 30;
  while ( 1 )
  {
    v67 = 0;
    v68 = v114 + 2 * v66;
    v69 = 2 * (v68 - v66);
    v70 = &xc[v114];
    v71 = &xc[v114 + v68 - v66];
    digesta = v68;
    x_size_0a = ((x_size_0a - 1) >> 1) + 1;
    do
    {
      v72 = 2 * v67;
      if ( v114 )
      {
        v73 = &v71[-v114];
        v74 = tmp_hash;
        v75 = &v70[~v114];
        do
        {
          v77 = *v73++;
          v76 = v77;
          v78 = *++v75;
          *v74++ = v76 ^ v78;
        }
        while ( v71 != v73 );
      }
      ++v67;
      v79 = digesta * (v72 >> 1);
      v80 = &v65[v79];
      v81 = v79 + v114;
      memcpy(v80, tmp_hash, v114);
      v82 = v70;
      v70 += v69;
      memcpy(&v65[v81], v82, v66);
      memcpy(&v65[v81 + v66], v71, v66);
      v71 += v69;
    }
    while ( x_size_0a != v67 );
    v66 *= 2;
    compare_size = v107;
    v107 += 3;
    if ( v112 == v107 )
      break;
    v83 = xc;
    xc = v65;
    v65 = v83;
  }
  v84 = 0;
  v85 = &v65[v114];
  v86 = 0;
  v87 = 0;
  v88 = &v121;
  x = v65;
  do
  {
    if ( v87 <= 7 )
    {
      v89 = &v85[v84];
      v87 += 21;
      v90 = v85[v84 + 3];
      v84 += 4;
      v86 = v90 | (v86 << 21) | (v89[2] << 8) | ((v89[1] & 0x1F) << 16);
    }
    v87 -= 8;
    *++v88 = v86 >> v87;
  }
  while ( &v124 != v88 );
  v91 = bin2hex(tmpHash_0, 0x540u);
  free(v91);
  v92 = bin2hex(v65, digesta);
  free(v92);
  v93 = *((_DWORD *)v65 + 1);
  v94 = *((_DWORD *)v65 + 2);
  v95 = *((_DWORD *)v65 + 3);
  *(_DWORD *)vHash = *(_DWORD *)v65;
  *(_DWORD *)&vHash[4] = v93;
  *(_DWORD *)&vHash[8] = v94;
  *(_DWORD *)&vHash[12] = v95;
  v96 = *((_DWORD *)v65 + 5);
  v97 = *((_DWORD *)v65 + 6);
  v98 = *((_DWORD *)v65 + 7);
  *(_DWORD *)&vHash[16] = *((_DWORD *)v65 + 4);
  *(_DWORD *)&vHash[20] = v96;
  *(_DWORD *)&vHash[24] = v97;
  *(_WORD *)&vHash[28] = v98;
  v99 = vHash;
  while ( 1 )
  {
    v100 = *v99++;
    v15 = v100;
    if ( v100 )
      break;
    if ( &v118 == (char *)v99 )
      goto failed;
  }
  v15 = 3;
failed:
  free(x);
  free(xc);
  return v15;
}

//----- (0004236C) --------------------------------------------------------
bool __fastcall HasCollision(const uint8_t *a, const uint8_t *b, int l)
{
  const uint8_t *v3; // r2
  int v4; // r4
  int v5; // t1
  int v6; // t1

  if ( l <= 0 )
    return 1;
  if ( *a != *b )
    return 0;
  v3 = &a[l - 1];
  while ( a != v3 )
  {
    v5 = *++a;
    v4 = v5;
    v6 = *++b;
    if ( v4 != v6 )
      return 0;
  }
  return 1;
}

//----- (000423A4) --------------------------------------------------------
bool __fastcall IndicesBefore(const uint8_t *a, const uint8_t *b, size_t hashLen, uint32_t indicesLen)
{
  return (unsigned int)memcmp(&a[hashLen], &b[hashLen], indicesLen) >> 31;
}

//----- (000423B8) --------------------------------------------------------
bool __fastcall DistinctIndices(const uint8_t *a, const uint8_t *b, size_t hashLen, uint32_t indicesLen)
{
  const uint8_t *v4; // r0
  const uint8_t *v5; // r1
  unsigned __int8 *v6; // r6
  uint32_t i; // r4
  int v8; // r2
  unsigned __int8 *v9; // r5

  if ( !indicesLen )
    return 1;
  v4 = &a[hashLen];
  v5 = &b[hashLen];
  v6 = (unsigned __int8 *)v4;
  do
  {
    for ( i = 0; i < indicesLen; i += 4 )
    {
      v8 = v5[i];
      v9 = (unsigned __int8 *)&v5[i];
      if ( *v6 == v8 && v6[1] == v9[1] && v6[2] == v9[2] && v6[3] == v9[3] )
        return 0;
    }
    v6 += 4;
  }
  while ( v6 - v4 < indicesLen );
  return 1;
}

//----- (00042410) --------------------------------------------------------
bool __fastcall IsZero(const uint8_t *a, size_t len)
{
  const uint8_t *v2; // r1

  if ( !len )
    return 1;
  if ( !*a )
  {
    v2 = &a[len - 1];
    while ( a != v2 )
    {
      if ( *++a )
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (00042430) --------------------------------------------------------
int __fastcall IsValidSolution(blake2b_state *base_state, unsigned __int8 *soln)
{
  uint32_t *v4; // r5
  char *v5; // r11
  uint32_t *v6; // r4
  unsigned int v7; // t1
  int v8; // r6
  bool v9; // nf
  int v10; // r6
  uint32_t v11; // r6
  uint32_t v12; // r1
  uint32_t v13; // r2
  uint32_t v14; // r3
  uint32_t v15; // r0
  uint32_t v16; // r1
  uint32_t v17; // r2
  const unsigned __int8 *v18; // r0
  char *v19; // r0
  size_t v20; // r8
  size_t v21; // r9
  int v22; // r10
  const uint8_t *v23; // r5
  const uint8_t *v24; // r6
  const uint8_t *v25; // r2
  const uint8_t *v26; // r3
  int v27; // r0
  int v28; // t1
  int v29; // t1
  const uint8_t *v30; // r7
  const uint8_t *v31; // r12
  uint8_t *v32; // r0
  char v33; // r3
  char v34; // t1
  char v35; // t1
  int v36; // r4
  char *v37; // r0
  size_t v38; // r4
  uint8_t *v39; // r3
  int v41; // r4
  eh_index i; // [sp+Ch] [bp-880h]
  const uint8_t *src; // [sp+10h] [bp-87Ch]
  size_t n; // [sp+14h] [bp-878h]
  unsigned int v46; // [sp+1Ch] [bp-870h]
  int v47; // [sp+20h] [bp-86Ch]
  uint8_t *x; // [sp+24h] [bp-868h]
  size_t v49; // [sp+28h] [bp-864h]
  uint8_t hash[30]; // [sp+34h] [bp-858h] BYREF
  uint8_t vhash[48]; // [sp+54h] [bp-838h] BYREF
  char v52; // [sp+84h] [bp-808h] BYREF
  uint32_t indices[512]; // [sp+88h] [bp-804h] BYREF

  x = (uint8_t *)malloc(0x4400u);
  v4 = (uint32_t *)(x + 30);
  v5 = (char *)malloc(0x4400u);
  memset(indices, 0, sizeof(indices));
  v6 = (uint32_t *)&v52;
  expandArray(soln, 0x540u, (unsigned __int8 *)indices, 0x800u, 0x15u, 1u);
  do
  {
    v7 = v6[1];
    ++v6;
    v8 = bswap32(v7);
    generateHash(base_state, v8 / 2, vhash, 0x32u);
    v9 = v8 < 0;
    v10 = v8 & 1;
    if ( v9 )
      v10 = -v10;
    expandArray(&vhash[25 * v10], 0x19u, hash, 0x1Eu, 0x14u, 0);
    v11 = *v6;
    v12 = *(_DWORD *)&hash[4];
    v13 = *(_DWORD *)&hash[8];
    v14 = *(_DWORD *)&hash[12];
    *(uint32_t *)((char *)v4 - 30) = *(_DWORD *)hash;
    *(uint32_t *)((char *)v4 - 26) = v12;
    *(uint32_t *)((char *)v4 - 22) = v13;
    v15 = *(_DWORD *)&hash[16];
    v16 = *(_DWORD *)&hash[20];
    v17 = *(_DWORD *)&hash[24];
    *(uint32_t *)((char *)v4 - 18) = v14;
    LOWORD(v14) = *(_WORD *)&hash[28];
    *(uint32_t *)((char *)v4 - 14) = v15;
    v18 = (const unsigned __int8 *)v4 - 30;
    *(uint32_t *)((char *)v4 - 10) = v16;
    *((_WORD *)v4 - 1) = v14;
    *(uint32_t *)((char *)v4 - 6) = v17;
    *v4 = v11;
    v4 = (uint32_t *)((char *)v4 + 34);
    v19 = bin2hex(v18, 0x22u);
    free(v19);
  }
  while ( v6 != &indices[511] );
  v20 = 30;
  v21 = 4;
  v22 = 512;
  n = 27;
  while ( 1 )
  {
    v46 = v22;
    if ( v22 )
      break;
    v21 *= 2;
    v49 = n;
LABEL_17:
    v20 -= 3;
    memcpy(x, v5, 0x4400u);
    n -= 3;
    memset(v5, 0, 0x4400u);
    if ( v20 == 3 )
    {
      if ( *x )
      {
LABEL_27:
        v41 = 2;
      }
      else
      {
        v39 = x;
        while ( &x[v49 - 1] != v39 )
        {
          if ( *++v39 )
            goto LABEL_27;
        }
        v41 = 0;
      }
      goto quit;
    }
  }
  v23 = x;
  v47 = 2 * (v20 + v21);
  v24 = &x[v20 + v21];
  v22 = 0;
  v49 = n;
  while ( 1 )
  {
    v25 = v24;
    i = 2 * v22;
    v26 = v23;
    do
    {
      v28 = *v26++;
      v27 = v28;
      v29 = *v25++;
      if ( v27 != v29 )
      {
        v41 = 2;
        puts("Invalid solution: invalid collision length between StepRows");
        goto quit;
      }
    }
    while ( v23 + 3 != v26 );
    src = &v23[v20];
    if ( memcmp(&v24[v20], &v23[v20], v21) < 0 )
    {
      v41 = 2;
      puts("Invalid solution: Index tree incorrectly ordered");
      goto quit;
    }
    if ( !DistinctIndices(v23, v24, v20, v21) )
      break;
    v30 = v24;
    memset(vhash, 0, 0x1Eu);
    v31 = v23 - 1;
    v32 = vhash;
    do
    {
      v34 = *v30++;
      v33 = v34;
      v35 = *++v31;
      *v32++ = v33 ^ v35;
    }
    while ( v30 != &v24[v20] );
    ++v22;
    v36 = (n + 2 * v21) * (i >> 1);
    v23 += v47;
    v24 += v47;
    v37 = &v5[v36];
    v38 = v36 + n;
    memcpy(v37, &vhash[3], n);
    memcpy(&v5[v38], src, v21);
    memcpy(&v5[v38 + v21], v30, v21);
    if ( v46 <= i + 2 )
    {
      v21 *= 2;
      goto LABEL_17;
    }
  }
  v41 = 1;
  puts("Invalid solution: duplicate indices");
quit:
  free(x);
  free(v5);
  return v41;
}

//----- (00042698) --------------------------------------------------------
void __fastcall digestInit(blake2b_state *S, const int n, const int k)
{
  int v6; // r3
  int v7; // r2
  bool v8; // cf
  int v9; // r3
  blake2b_param P[1]; // [sp+0h] [bp-44h] BYREF

  memset(P, 0, 0x30u);
  *(_WORD *)&P[0].fanout = 257;
  v6 = n * (512 / n);
  *(_DWORD *)&P[0].personal[8] = n;
  v7 = v6 + 7;
  *(_DWORD *)&P[0].personal[12] = k;
  v8 = v6 < 0;
  v9 = v6 & ~(v6 >> 31);
  if ( v8 )
    v9 = v7;
  qmemcpy(P[0].personal, "ZcashPoW", 8);
  P[0].digest_length = v9 >> 3;
  blake2b_init_param(S, P);
}

//----- (000426F8) --------------------------------------------------------
int __fastcall blake2b_compress(blake2b_state *S, const uint8_t *block)
{
  uint64_t *v2; // r3
  uint64_t *v3; // r2
  int v4; // r4
  blake2b_state *v5; // r1
  uint64_t v6; // t1
  uint64_t v7; // kr08_8
  int v8; // r10
  int v9; // r8
  int v10; // r5
  unsigned int v11; // r4
  unsigned int v12; // r8
  uint64_t v13; // kr268_8
  unsigned int v14; // r5
  unsigned int v15; // r2
  int v16; // r3
  int v17; // r1
  __int64 v18; // r10
  unsigned int v19; // r5
  unsigned int v20; // r3
  int v21; // lr
  unsigned int v22; // r3
  unsigned int v23; // r1
  int v24; // r2
  unsigned int v25; // r9
  unsigned int v26; // r3
  unsigned int v27; // lr
  uint64_t v28; // kr2A0_8
  int v29; // r2
  int v30; // r3
  int v31; // r4
  int v32; // r5
  unsigned int v33; // r6
  unsigned int v34; // r12
  unsigned int v35; // r2
  unsigned int v36; // r4
  int v37; // r0
  unsigned int v38; // r7
  int v39; // lr
  __int64 v40; // r2
  __int64 v41; // r4
  int v42; // r7
  int v43; // r12
  unsigned int v44; // lr
  int v45; // r4
  int v46; // r0
  int v47; // r8
  unsigned int v48; // kr34_4
  unsigned int v49; // r1
  unsigned int v50; // r7
  signed __int64 v51; // r8
  unsigned int v52; // r12
  unsigned int v53; // r0
  unsigned int v54; // r4
  int v55; // r1
  unsigned int v56; // lr
  unsigned int v57; // r6
  unsigned __int64 v58; // kr2C8_8
  unsigned int v59; // lr
  unsigned __int64 v60; // kr298_8
  unsigned int v61; // r0
  unsigned int v62; // r0
  unsigned __int64 v63; // kr2E0_8
  unsigned int v64; // lr
  unsigned int v65; // r6
  unsigned int v66; // r12
  unsigned int v67; // r7
  unsigned int v68; // r1
  unsigned int v69; // r7
  unsigned int v70; // r6
  __int64 v71; // kr2F8_8
  unsigned int v72; // r12
  int v73; // r6
  unsigned __int64 v74; // kr300_8
  unsigned int v75; // lr
  unsigned int v76; // r0
  unsigned __int64 v77; // kr2A8_8
  unsigned int v78; // r6
  unsigned int v79; // lr
  unsigned int v80; // r6
  uint64_t v81; // kr308_8
  unsigned __int64 v82; // kr310_8
  unsigned int v83; // r6
  unsigned int v84; // r7
  int v85; // r12
  int v86; // r1
  __int64 v87; // r6
  __int64 v88; // kr330_8
  unsigned int v89; // r12
  int v90; // r12
  uint64_t v91; // kr2B0_8
  unsigned int v92; // r1
  int v93; // lr
  unsigned __int64 v94; // kr2B8_8
  uint64_t v95; // kr340_8
  bool v96; // cf
  int v97; // r1
  int v98; // r0
  unsigned int v99; // r1
  int v100; // r0
  unsigned int v101; // lr
  unsigned int v102; // r12
  unsigned int v103; // r12
  uint64_t v104; // kr350_8
  uint64_t v105; // kr368_8
  int v106; // r0
  int v107; // lr
  unsigned __int64 v108; // kr370_8
  unsigned int v109; // r0
  int v110; // r1
  unsigned int v111; // lr
  unsigned __int64 v112; // kr380_8
  int v113; // r0
  uint64_t v114; // kr388_8
  int v115; // lr
  unsigned int v116; // r0
  int v117; // r12
  __int64 v118; // r0
  unsigned int v119; // r12
  unsigned int v120; // lr
  int v121; // r12
  unsigned int v122; // lr
  int v123; // lr
  uint64_t v124; // kr3A0_8
  uint64_t v125; // kr2C0_8
  int v126; // lr
  uint64_t v127; // kr3C0_8
  unsigned int v128; // lr
  int v129; // r12
  int v130; // lr
  uint64_t v131; // kr2D0_8
  unsigned int v132; // r12
  unsigned __int64 v133; // kr3D8_8
  unsigned int v134; // lr
  int v135; // lr
  int v136; // r12
  uint64_t v137; // kr3E0_8
  unsigned int v138; // lr
  unsigned int v139; // r12
  int v140; // r12
  int v141; // lr
  uint64_t v142; // kr3F8_8
  unsigned int v143; // r12
  unsigned int v144; // lr
  unsigned int v145; // r12
  int v146; // r12
  signed __int64 v147; // r10
  unsigned int v148; // r12
  unsigned __int64 v149; // kr418_8
  int v150; // lr
  unsigned int v151; // lr
  unsigned __int64 v152; // kr428_8
  unsigned int v153; // lr
  uint64_t v154; // r2
  int v155; // r12
  unsigned __int64 v156; // kr2D8_8
  unsigned int v157; // r12
  unsigned int v158; // lr
  int v159; // r12
  uint64_t v160; // kr438_8
  uint64_t v161; // kr440_8
  unsigned int v162; // lr
  int v163; // lr
  unsigned __int64 v164; // kr460_8
  unsigned int v165; // lr
  int v166; // r12
  int v167; // lr
  uint64_t v168; // kr2E8_8
  unsigned int v169; // r12
  unsigned int v170; // lr
  int v171; // lr
  int v172; // r12
  uint64_t v173; // kr488_8
  unsigned int v174; // lr
  unsigned int v175; // r12
  int v176; // r12
  int v177; // lr
  __int64 v178; // kr498_8
  uint64_t v179; // kr2F0_8
  unsigned int v180; // r12
  unsigned int v181; // r12
  int v182; // r12
  uint64_t v183; // kr4B8_8
  __int64 v184; // r10
  unsigned int v185; // r12
  uint64_t v186; // kr4C0_8
  unsigned int v187; // lr
  unsigned __int64 v188; // kr4E8_8
  unsigned int v189; // lr
  unsigned int v190; // lr
  int v191; // r12
  unsigned __int64 v192; // r0
  unsigned int v193; // r12
  uint64_t v194; // kr4F8_8
  unsigned int v195; // lr
  int v196; // r12
  uint64_t v197; // kr500_8
  unsigned int v198; // lr
  int v199; // lr
  uint64_t v200; // kr520_8
  unsigned int v201; // lr
  int v202; // r12
  int v203; // lr
  uint64_t v204; // kr530_8
  unsigned int v205; // r12
  unsigned int v206; // lr
  int v207; // lr
  int v208; // r12
  uint64_t v209; // kr540_8
  unsigned int v210; // lr
  unsigned int v211; // r12
  int v212; // r12
  int v213; // lr
  int v214; // lr
  int v215; // r12
  unsigned int v216; // lr
  uint64_t v217; // kr558_8
  unsigned int v218; // r12
  int v219; // r12
  uint64_t v220; // kr318_8
  unsigned __int64 v221; // kr570_8
  unsigned int v222; // r12
  uint64_t v223; // kr320_8
  int v224; // lr
  unsigned __int64 v225; // kr5A8_8
  unsigned int v226; // lr
  int v227; // lr
  unsigned int v228; // r12
  unsigned int v229; // r12
  unsigned int v230; // lr
  int v231; // r12
  uint64_t v232; // kr5C8_8
  int v233; // lr
  unsigned int v234; // lr
  uint64_t v235; // kr5D0_8
  unsigned __int64 v236; // kr5E8_8
  unsigned int v237; // lr
  int v238; // lr
  unsigned int v239; // lr
  int v240; // r12
  int v241; // lr
  uint64_t v242; // kr608_8
  unsigned int v243; // r12
  unsigned __int64 v244; // kr610_8
  unsigned int v245; // lr
  int v246; // lr
  int v247; // r12
  unsigned int v248; // lr
  unsigned int v249; // r12
  int v250; // r12
  int v251; // lr
  uint64_t v252; // kr620_8
  uint64_t v253; // kr638_8
  int v254; // r12
  int v255; // lr
  unsigned int v256; // lr
  uint64_t v257; // kr640_8
  unsigned int v258; // r12
  int v259; // r12
  signed __int64 v260; // r10
  unsigned int v261; // r12
  int v262; // lr
  unsigned __int64 v263; // kr668_8
  unsigned __int64 v264; // kr678_8
  unsigned int v265; // lr
  uint64_t v266; // kr680_8
  int v267; // lr
  unsigned int v268; // r12
  unsigned int v269; // r12
  unsigned int v270; // lr
  uint64_t v271; // kr690_8
  int v272; // r12
  unsigned int v273; // kr120_4
  unsigned int v274; // lr
  uint64_t v275; // kr698_8
  unsigned int v276; // lr
  unsigned int v277; // lr
  uint64_t v278; // kr6C0_8
  unsigned int v279; // lr
  int v280; // r12
  int v281; // lr
  uint64_t v282; // kr6D0_8
  unsigned __int64 v283; // kr6D8_8
  unsigned int v284; // r12
  unsigned int v285; // lr
  int v286; // lr
  int v287; // r12
  uint64_t v288; // kr6E0_8
  unsigned int v289; // lr
  unsigned int v290; // r12
  int v291; // r12
  int v292; // lr
  uint64_t v293; // kr328_8
  uint64_t v294; // kr700_8
  int v295; // r12
  int v296; // lr
  uint64_t v297; // kr708_8
  unsigned int v298; // lr
  unsigned int v299; // r12
  int v300; // r12
  signed __int64 v301; // r10
  unsigned int v302; // r12
  uint64_t v303; // kr728_8
  int v304; // lr
  unsigned __int64 v305; // kr730_8
  unsigned int v306; // lr
  unsigned __int64 v307; // kr740_8
  unsigned int v308; // lr
  uint64_t v309; // kr748_8
  int v310; // r12
  unsigned int v311; // r12
  uint64_t v312; // kr758_8
  unsigned int v313; // lr
  int v314; // r12
  int v315; // lr
  uint64_t v316; // kr760_8
  uint64_t v317; // kr768_8
  unsigned int v318; // lr
  unsigned __int64 v319; // kr780_8
  unsigned int v320; // lr
  int v321; // lr
  __int64 v322; // kr788_8
  uint64_t v323; // kr790_8
  unsigned int v324; // lr
  int v325; // r12
  int v326; // lr
  uint64_t v327; // kr7A0_8
  unsigned int v328; // r12
  unsigned __int64 v329; // kr7A8_8
  unsigned int v330; // lr
  int v331; // lr
  int v332; // r12
  uint64_t v333; // kr7B0_8
  unsigned int v334; // lr
  unsigned int v335; // r12
  int v336; // r12
  int v337; // lr
  unsigned int v338; // r12
  int v339; // lr
  unsigned int v340; // lr
  uint64_t v341; // kr7C8_8
  unsigned int v342; // r12
  int v343; // r12
  signed __int64 v344; // r10
  uint64_t v345; // r2
  unsigned int v346; // r12
  uint64_t v347; // kr338_8
  unsigned __int64 v348; // kr7F8_8
  int v349; // lr
  unsigned int v350; // lr
  unsigned int v351; // lr
  int v352; // r12
  uint64_t v353; // kr348_8
  unsigned int v354; // r12
  unsigned int v355; // lr
  uint64_t v356; // kr818_8
  int v357; // r12
  uint64_t v358; // kr820_8
  unsigned int v359; // lr
  unsigned int v360; // lr
  int v361; // lr
  unsigned int v362; // lr
  int v363; // r12
  int v364; // lr
  uint64_t v365; // kr850_8
  __int64 v366; // r10
  unsigned int v367; // kr194_4
  unsigned int v368; // r12
  unsigned int v369; // lr
  int v370; // lr
  int v371; // r12
  uint64_t v372; // kr860_8
  unsigned int v373; // lr
  unsigned int v374; // r12
  int v375; // r12
  int v376; // lr
  int v377; // r12
  unsigned int v378; // lr
  uint64_t v379; // kr878_8
  unsigned int v380; // r12
  int v381; // r12
  signed __int64 v382; // r10
  unsigned __int64 v383; // r2
  unsigned int v384; // r12
  int v385; // lr
  unsigned __int64 v386; // kr8A0_8
  unsigned int v387; // lr
  unsigned int v388; // lr
  uint64_t v389; // kr358_8
  unsigned int v390; // r12
  unsigned int v391; // r12
  unsigned int v392; // lr
  int v393; // r12
  unsigned __int64 v394; // kr360_8
  uint64_t v395; // kr8D8_8
  uint64_t v396; // kr8E0_8
  int v397; // lr
  unsigned int v398; // lr
  int v399; // lr
  uint64_t v400; // kr900_8
  unsigned int v401; // lr
  int v402; // r12
  int v403; // lr
  uint64_t v404; // kr378_8
  unsigned int v405; // lr
  unsigned int v406; // r12
  int v407; // lr
  int v408; // r12
  uint64_t v409; // kr920_8
  unsigned int v410; // lr
  unsigned int v411; // r12
  int v412; // r12
  int v413; // lr
  uint64_t v414; // kr928_8
  unsigned int v415; // kr68_4
  uint64_t v416; // kr930_8
  unsigned __int64 v417; // kr390_8
  uint64_t v418; // kr398_8
  int v419; // r12
  int v420; // lr
  unsigned int v421; // lr
  unsigned __int64 v422; // kr1D0_8
  uint64_t v423; // kr940_8
  unsigned int v424; // r12
  int v425; // r12
  signed __int64 v426; // r10
  unsigned int v427; // r12
  uint64_t v428; // kr960_8
  int v429; // lr
  unsigned __int64 v430; // kr968_8
  uint64_t v431; // kr970_8
  unsigned __int64 v432; // kr978_8
  unsigned int v433; // lr
  int v434; // lr
  unsigned int v435; // r12
  unsigned int v436; // r12
  unsigned int v437; // lr
  int v438; // r12
  uint64_t v439; // kr990_8
  unsigned int v440; // lr
  int v441; // lr
  unsigned __int64 v442; // kr9B0_8
  uint64_t v443; // kr9B8_8
  unsigned int v444; // lr
  int v445; // r12
  int v446; // lr
  uint64_t v447; // kr9C8_8
  unsigned int v448; // r12
  unsigned int v449; // lr
  int v450; // lr
  int v451; // r12
  uint64_t v452; // kr9D8_8
  unsigned int v453; // lr
  unsigned int v454; // r12
  int v455; // r12
  int v456; // lr
  unsigned int v457; // krC8_4
  uint64_t v458; // kr9F0_8
  unsigned int v459; // r12
  int v460; // lr
  unsigned int v461; // lr
  uint64_t v462; // kr9F8_8
  unsigned int v463; // r12
  int v464; // r12
  signed __int64 v465; // r10
  __int64 v466; // r2
  unsigned int v467; // r12
  unsigned __int64 v468; // krA10_8
  int v469; // lr
  unsigned __int64 v470; // krA20_8
  unsigned int v471; // lr
  unsigned int v472; // lr
  int v473; // r12
  unsigned int v474; // r12
  int v475; // lr
  int v476; // r12
  uint64_t v477; // krA78_8
  unsigned int v478; // lr
  int v479; // r12
  unsigned int v480; // lr
  uint64_t v481; // krA98_8
  unsigned int v482; // lr
  __int64 v483; // krAA0_8
  unsigned int v484; // r12
  uint64_t v485; // krAA8_8
  signed __int64 v486; // krAB0_8
  uint64_t v487; // kr3A8_8
  unsigned int v488; // lr
  int v489; // lr
  unsigned int v490; // r12
  unsigned int v491; // lr
  unsigned __int64 v492; // krAD0_8
  unsigned int v493; // r12
  uint64_t v494; // krAD8_8
  uint64_t v495; // krAE8_8
  int v496; // kr25C_4
  unsigned int v497; // r12
  uint64_t v498; // krAF8_8
  signed __int64 v499; // r8
  unsigned int v500; // r12
  unsigned int v501; // lr
  unsigned __int64 v502; // krB00_8
  uint64_t v503; // krB08_8
  unsigned int v504; // lr
  unsigned int v505; // lr
  uint64_t v506; // krB10_8
  unsigned int v507; // r12
  unsigned int v508; // r12
  uint64_t v509; // r0
  unsigned __int64 v510; // krB20_8
  int v511; // lr
  uint64_t v512; // krB38_8
  unsigned int v513; // lr
  uint64_t v514; // krB40_8
  uint64_t v515; // krB50_8
  unsigned int v516; // r12
  size_t *v517; // r2
  uint64_t *v518; // r5
  uint64_t v519; // r6
  uint64_t v520; // t1
  size_t v521; // t1
  size_t v522; // r0
  unsigned int v524; // [sp+4h] [bp-210h]
  unsigned int v525; // [sp+14h] [bp-200h]
  int v526; // [sp+14h] [bp-200h]
  int v527; // [sp+20h] [bp-1F4h]
  unsigned __int64 v528; // [sp+2Ch] [bp-1E8h]
  uint64_t v529; // [sp+34h] [bp-1E0h]
  unsigned int v530; // [sp+3Ch] [bp-1D8h]
  int v531; // [sp+3Ch] [bp-1D8h]
  unsigned int v532; // [sp+44h] [bp-1D0h]
  _BYTE v533[12]; // [sp+48h] [bp-1CCh]
  unsigned int v534; // [sp+50h] [bp-1C4h]
  unsigned int v535; // [sp+54h] [bp-1C0h]
  int v536; // [sp+54h] [bp-1C0h]
  int v537; // [sp+58h] [bp-1BCh]
  int v538; // [sp+58h] [bp-1BCh]
  unsigned int v539; // [sp+58h] [bp-1BCh]
  int v540; // [sp+5Ch] [bp-1B8h]
  int v541; // [sp+5Ch] [bp-1B8h]
  unsigned int v542; // [sp+5Ch] [bp-1B8h]
  int v543; // [sp+60h] [bp-1B4h]
  int v544; // [sp+60h] [bp-1B4h]
  unsigned int v545; // [sp+70h] [bp-1A4h]
  unsigned int v546; // [sp+78h] [bp-19Ch]
  int v547; // [sp+7Ch] [bp-198h]
  unsigned int v548; // [sp+88h] [bp-18Ch]
  unsigned int v549; // [sp+88h] [bp-18Ch]
  unsigned int v550; // [sp+88h] [bp-18Ch]
  int v551; // [sp+88h] [bp-18Ch]
  int v552; // [sp+88h] [bp-18Ch]
  unsigned int v553; // [sp+88h] [bp-18Ch]
  unsigned int v554; // [sp+88h] [bp-18Ch]
  unsigned int v555; // [sp+88h] [bp-18Ch]
  unsigned int v556; // [sp+88h] [bp-18Ch]
  int v557; // [sp+88h] [bp-18Ch]
  unsigned int v558; // [sp+88h] [bp-18Ch]
  unsigned int v559; // [sp+88h] [bp-18Ch]
  unsigned int v560; // [sp+88h] [bp-18Ch]
  int v561; // [sp+88h] [bp-18Ch]
  unsigned int v562; // [sp+88h] [bp-18Ch]
  unsigned int v563; // [sp+88h] [bp-18Ch]
  unsigned int v564; // [sp+88h] [bp-18Ch]
  int v565; // [sp+88h] [bp-18Ch]
  unsigned int v566; // [sp+88h] [bp-18Ch]
  unsigned int v567; // [sp+88h] [bp-18Ch]
  __int64 v568; // [sp+8Ch] [bp-188h]
  unsigned __int64 v569; // [sp+94h] [bp-180h]
  _BYTE v570[12]; // [sp+9Ch] [bp-178h]
  unsigned int v571; // [sp+A4h] [bp-170h]
  int v572; // [sp+A4h] [bp-170h]
  int v573; // [sp+A4h] [bp-170h]
  unsigned int v574; // [sp+A4h] [bp-170h]
  __int64 v575; // [sp+A8h] [bp-16Ch]
  _BYTE v576[20]; // [sp+B0h] [bp-164h]
  unsigned int v577; // [sp+B0h] [bp-164h]
  unsigned int v578; // [sp+B0h] [bp-164h]
  unsigned int v579; // [sp+B0h] [bp-164h]
  unsigned int v580; // [sp+B0h] [bp-164h]
  int v581; // [sp+B4h] [bp-160h]
  int v582; // [sp+C0h] [bp-154h]
  int v583; // [sp+C0h] [bp-154h]
  int v584; // [sp+C0h] [bp-154h]
  __int64 v585; // [sp+C4h] [bp-150h]
  uint64_t v586; // [sp+C4h] [bp-150h]
  __int64 v587; // [sp+C4h] [bp-150h]
  blake2b_state *v588; // [sp+CCh] [bp-148h]
  size_t *p_buflen; // [sp+D4h] [bp-140h]
  unsigned __int64 v590; // [sp+D8h] [bp-13Ch]
  _BYTE v591[24]; // [sp+D8h] [bp-13Ch]
  uint64_t v592; // [sp+D8h] [bp-13Ch]
  uint64_t v593; // [sp+D8h] [bp-13Ch]
  uint64_t v594; // [sp+D8h] [bp-13Ch]
  uint64_t v595; // [sp+D8h] [bp-13Ch]
  uint64_t v596; // [sp+D8h] [bp-13Ch]
  unsigned int v597; // [sp+E0h] [bp-134h]
  unsigned int v598; // [sp+E4h] [bp-130h]
  unsigned int v599; // [sp+E8h] [bp-12Ch]
  unsigned int v600; // [sp+E8h] [bp-12Ch]
  int v601; // [sp+ECh] [bp-128h]
  unsigned int v602; // [sp+ECh] [bp-128h]
  int v603; // [sp+ECh] [bp-128h]
  int v604; // [sp+ECh] [bp-128h]
  unsigned int v605; // [sp+ECh] [bp-128h]
  int v606; // [sp+F0h] [bp-124h]
  unsigned int v607; // [sp+F0h] [bp-124h]
  int v608; // [sp+F0h] [bp-124h]
  unsigned int v609; // [sp+F0h] [bp-124h]
  unsigned int v610; // [sp+F0h] [bp-124h]
  unsigned __int64 v611; // [sp+F0h] [bp-124h]
  _BYTE v612[20]; // [sp+F0h] [bp-124h]
  unsigned int v613; // [sp+F4h] [bp-120h]
  int v614; // [sp+F4h] [bp-120h]
  unsigned int v615; // [sp+F4h] [bp-120h]
  unsigned int v616; // [sp+F4h] [bp-120h]
  unsigned int v617; // [sp+F4h] [bp-120h]
  int v618; // [sp+F4h] [bp-120h]
  int v619; // [sp+F8h] [bp-11Ch]
  int v620; // [sp+F8h] [bp-11Ch]
  unsigned int v621; // [sp+F8h] [bp-11Ch]
  int v622; // [sp+F8h] [bp-11Ch]
  unsigned int v623; // [sp+F8h] [bp-11Ch]
  unsigned int v624; // [sp+F8h] [bp-11Ch]
  unsigned int v625; // [sp+FCh] [bp-118h]
  int v626; // [sp+FCh] [bp-118h]
  int v627; // [sp+FCh] [bp-118h]
  int v628; // [sp+FCh] [bp-118h]
  unsigned int v629; // [sp+FCh] [bp-118h]
  int v630; // [sp+FCh] [bp-118h]
  int v631; // [sp+FCh] [bp-118h]
  int v632; // [sp+100h] [bp-114h]
  int v633; // [sp+100h] [bp-114h]
  int v634; // [sp+100h] [bp-114h]
  unsigned int v635; // [sp+100h] [bp-114h]
  unsigned int v636; // [sp+100h] [bp-114h]
  int v637; // [sp+100h] [bp-114h]
  int v638; // [sp+100h] [bp-114h]
  int v639; // [sp+100h] [bp-114h]
  unsigned int v640; // [sp+100h] [bp-114h]
  int v641; // [sp+100h] [bp-114h]
  unsigned int v642; // [sp+100h] [bp-114h]
  __int64 v643; // [sp+104h] [bp-110h] BYREF
  int v644; // [sp+10Ch] [bp-108h]
  uint64_t m[16]; // [sp+110h] [bp-104h] BYREF
  uint64_t v[16]; // [sp+190h] [bp-84h] BYREF

  v2 = (uint64_t *)((char *)&v643 + 4);
  v3 = &m[15];
  do
  {
    block += 8;
    v4 = *((_DWORD *)block - 1);
    *((_DWORD *)v2++ + 2) = *((_DWORD *)block - 2);
    *((_DWORD *)v2 + 1) = v4;
  }
  while ( &m[15] != v2 );
  v5 = (blake2b_state *)((char *)S - 8);
  p_buflen = &S[-1].buflen;
  do
  {
    v6 = v5->h[1];
    v5 = (blake2b_state *)((char *)v5 + 8);
    v3[1] = v6;
    ++v3;
  }
  while ( &S->h[7] != (uint64_t *)v5 );
  v7 = v[4] + v[0] + m[0];
  v588 = v5;
  v8 = HIDWORD(v7) ^ 0x510E527F ^ HIDWORD(S->t[0]);
  v9 = v7 ^ 0xADE682D1 ^ LODWORD(S->t[0]);
  v10 = __CFADD__(v8, -205731576) + v9 + 1779033703;
  LODWORD(v585) = ((LODWORD(v[4]) ^ (unsigned int)(v8 - 205731576)) >> 24) | ((HIDWORD(v[4]) ^ v10) << 8);
  HIDWORD(v585) = ((HIDWORD(v[4]) ^ (unsigned int)v10) >> 24) | ((LODWORD(v[4]) ^ (v8 - 205731576)) << 8);
  v11 = LODWORD(v[4]) + LODWORD(v[0]) + LODWORD(m[0]) + LODWORD(m[1]) + v585;
  v529 = v7 + m[1] + v585;
  v12 = HIDWORD(v529) ^ v9;
  v534 = ((v8 ^ v11) >> 16) | (v12 << 16);
  v543 = HIWORD(v12) | ((v8 ^ v11) << 16);
  v590 = __PAIR64__(v10, v8 - 205731576) + __PAIR64__(v543, v534);
  v13 = v[5] + v[1] + m[2];
  v14 = HIDWORD(v13) ^ 0x9B05688C ^ HIDWORD(S->t[1]);
  v15 = v14 - 2067093701;
  v16 = v13 ^ 0x2B3E6C1F ^ LODWORD(S->t[1]);
  v17 = __CFADD__(v14, -2067093701) + v16 - 1150833019;
  LODWORD(v18) = ((LODWORD(v[5]) ^ (v14 - 2067093701)) >> 24) | ((HIDWORD(v[5]) ^ v17) << 8);
  HIDWORD(v18) = ((HIDWORD(v[5]) ^ (unsigned int)v17) >> 24) | ((LODWORD(v[5]) ^ (v14 - 2067093701)) << 8);
  *(_QWORD *)v533 = v13 + m[3] + v18;
  v19 = v14 ^ (LODWORD(v[5]) + LODWORD(v[1]) + LODWORD(m[2]) + LODWORD(m[3]) + v18);
  v20 = v16 ^ *(_DWORD *)&v533[4];
  v537 = HIWORD(v19) | (v20 << 16);
  v540 = HIWORD(v20) | (v19 << 16);
  LODWORD(v568) = v15 + v537;
  HIDWORD(v568) = v15 + v537;
  v21 = ((v[6] + v[2] + m[4]) >> 32) ^ 0x1F83D9AB ^ HIDWORD(S->f[0]);
  v22 = (LODWORD(v[6]) + LODWORD(v[2]) + LODWORD(m[4])) ^ 0xFB41BD6B ^ LODWORD(S->f[0]);
  v23 = v21 - 23791573;
  v24 = __CFADD__(v21, -23791573) + v22 + 1013904242;
  v25 = ((LODWORD(v[6]) ^ (unsigned int)(v21 - 23791573)) >> 24) | ((HIDWORD(v[6]) ^ v24) << 8);
  v532 = ((HIDWORD(v[6]) ^ (unsigned int)v24) >> 24) | ((LODWORD(v[6]) ^ (v21 - 23791573)) << 8);
  v535 = LODWORD(v[6]) + LODWORD(v[2]) + LODWORD(m[4]) + LODWORD(m[5]) + v25;
  v26 = v22 ^ ((v[6] + v[2] + m[4] + m[5] + __PAIR64__(v532, v25)) >> 32);
  v597 = (v[6] + v[2] + m[4] + m[5] + __PAIR64__(v532, v25)) >> 32;
  v27 = v535 ^ v21;
  v582 = HIWORD(v26) | (v27 << 16);
  v632 = HIWORD(v27) | (v26 << 16);
  v530 = (__PAIR64__(v24, v23) + __PAIR64__(v582, v632)) >> 32;
  v28 = v[7] + v[3] + m[6];
  v29 = HIDWORD(v28) ^ 0x5BE0CD19 ^ HIDWORD(S->f[1]);
  v30 = v29 + 1595750129;
  v31 = v28 ^ 0x137E2179 ^ LODWORD(S->f[1]);
  v32 = __CFADD__(v29, 1595750129) + v31 - 1521486534;
  v33 = ((LODWORD(v[7]) ^ (unsigned int)(v29 + 1595750129)) >> 24) | ((HIDWORD(v[7]) ^ v32) << 8);
  v34 = v568 ^ v18;
  LODWORD(v18) = ((HIDWORD(v[7]) ^ (unsigned int)v32) >> 24) | ((LODWORD(v[7]) ^ (v29 + 1595750129)) << 8);
  v35 = v29 ^ (LODWORD(v[7]) + LODWORD(v[3]) + LODWORD(m[6]) + LODWORD(m[7]) + v33);
  v548 = (v28 + m[7] + __PAIR64__(v18, v33)) >> 32;
  v36 = v31 ^ v548;
  v598 = LODWORD(v[7]) + LODWORD(v[3]) + LODWORD(m[6]) + LODWORD(m[7]) + v33;
  v37 = HIWORD(v36) | (v35 << 16);
  v38 = HIDWORD(v568) ^ HIDWORD(v18);
  HIDWORD(v18) = HIWORD(v35) | (v36 << 16);
  v39 = 2 * v38;
  LODWORD(v40) = m[8];
  HIDWORD(v41) = v32 + __CFADD__(v30, HIDWORD(v18)) + v37;
  v547 = v30 + HIDWORD(v18);
  v42 = (2 * v34) | (v38 >> 31);
  HIDWORD(v40) = HIDWORD(v529);
  v43 = v39 | (v34 >> 31);
  LODWORD(v18) = HIDWORD(v41) ^ v18;
  v44 = (__PAIR64__(HIDWORD(m[8]), v529) + v40 + __PAIR64__(v43, v42)) >> 32;
  LODWORD(v40) = v529 + LODWORD(m[8]) + v42;
  v45 = HIDWORD(v18) ^ v40;
  v46 = v44 ^ v37;
  v48 = v23 + v632;
  v47 = v23 + v632 + v46;
  v49 = (v23 + v632) ^ v25;
  v50 = v47 ^ v42;
  v51 = __PAIR64__(v530, v48) + __PAIR64__(HIDWORD(v18) ^ (unsigned int)v40, v46);
  v52 = ((__PAIR64__(v530, v48) + __PAIR64__(HIDWORD(v18) ^ (unsigned int)v40, v46)) >> 32) ^ v43;
  *(_DWORD *)&v576[8] = HIBYTE(v50) | (v52 << 8);
  HIDWORD(v40) = HIDWORD(m[9]);
  *(_DWORD *)&v576[12] = HIBYTE(v52) | (v50 << 8);
  v569 = v40 + __PAIR64__(v44, m[9]) + *(_QWORD *)&v576[8];
  LODWORD(v40) = (2 * v49) | ((v530 ^ v532) >> 31);
  v53 = v46 ^ v569;
  v54 = v45 ^ HIDWORD(v569);
  v581 = HIWORD(v54) | (v53 << 16);
  v55 = (2 * (v530 ^ v532)) | (v49 >> 31);
  *(_QWORD *)v570 = v51 + __PAIR64__(v581, HIWORD(v53) | (v54 << 16));
  LODWORD(v643) = HIWORD(v53) | (v54 << 16);
  LODWORD(v41) = (*(_QWORD *)v533 + m[10] + __PAIR64__(v55, v40)) >> 32;
  v56 = *(_DWORD *)v533 + LODWORD(m[10]) + v40;
  LODWORD(v51) = v56 ^ v534;
  v57 = v33 ^ v547;
  LODWORD(v40) = v40 ^ (v547 + (v41 ^ v543));
  v58 = __PAIR64__(v56 ^ v534, v547) + (v41 ^ (unsigned int)v543);
  v577 = (((unsigned int)v55 ^ HIDWORD(v58)) >> 24) | ((_DWORD)v40 << 8);
  HIDWORD(v18) = (2 * v57) | ((unsigned int)v18 >> 31);
  v613 = BYTE3(v40) | ((v55 ^ HIDWORD(v58)) << 8);
  v60 = __PAIR64__(v41, v56) + m[11] + __PAIR64__(v577, v613);
  v59 = HIDWORD(v60);
  v571 = v60;
  HIDWORD(v51) = (2 * v18) | (v57 >> 31);
  LODWORD(v51) = v59 ^ v51;
  v61 = v41 ^ v543 ^ v571;
  v599 = v59;
  v601 = HIWORD(v61) | ((_DWORD)v51 << 16);
  v62 = WORD1(v51) | (v61 << 16);
  v575 = v58 + __PAIR64__(v62, v601);
  v625 = v62;
  v63 = __PAIR64__(v597, v535) + m[12] + __PAIR64__(HIDWORD(v51), HIDWORD(v18));
  v541 = v540 ^ HIDWORD(v63);
  LODWORD(v40) = (v590 + v541) ^ HIDWORD(v18);
  v64 = ((v590 + __PAIR64__((unsigned int)v63 ^ v537, v541)) >> 32) ^ HIDWORD(v51);
  HIDWORD(v51) = BYTE3(v40) | (v64 << 8);
  HIDWORD(v18) = HIBYTE(v64) | ((_DWORD)v40 << 8);
  v65 = (2 * (v590 ^ v585)) | ((unsigned int)(HIDWORD(v590) ^ HIDWORD(v585)) >> 31);
  HIDWORD(v41) = v541 ^ (v63 + LODWORD(m[13]) + HIDWORD(v51));
  v66 = (__int64)(v590 ^ v585) >> 31;
  v67 = v63 ^ v537 ^ ((v63 + m[13] + __PAIR64__(HIDWORD(v18), HIDWORD(v51))) >> 32);
  v586 = v63 + m[13] + __PAIR64__(HIDWORD(v18), HIDWORD(v51));
  LODWORD(v40) = HIWORD(HIDWORD(v41)) | (v67 << 16);
  v68 = v590 + v541 + v40;
  v606 = v40;
  HIDWORD(v40) = HIWORD(v67) | (HIDWORD(v41) << 16);
  LODWORD(v41) = (v590 + __PAIR64__((unsigned int)v63 ^ v537, v541) + v40) >> 32;
  HIDWORD(v18) ^= v41;
  v619 = HIDWORD(v40);
  LODWORD(v18) = (v598 + LODWORD(m[14]) + v65) ^ v632;
  LODWORD(v51) = (__PAIR64__(v548, v598) + m[14] + __PAIR64__(v66, v65)) >> 32;
  v69 = v598 + LODWORD(m[14]) + v65;
  v549 = *(_DWORD *)v570 ^ *(_DWORD *)&v576[8];
  v70 = v65 ^ (v568 + (v51 ^ v582));
  *(_DWORD *)&v576[8] = *(_DWORD *)&v570[4] ^ *(_DWORD *)&v576[12];
  v71 = v568 + __PAIR64__(v18, (unsigned int)v51 ^ v582);
  v72 = ((v568 + __PAIR64__(v18, (unsigned int)v51 ^ v582)) >> 32) ^ v66;
  LODWORD(v568) = HIBYTE(v70) | (v72 << 8);
  v73 = HIBYTE(v72) | (v70 << 8);
  HIDWORD(v568) = (v58 + v601) ^ v613;
  v74 = __PAIR64__(v51, v69) + m[15] + __PAIR64__(v73, v568);
  v75 = v74 ^ v51 ^ v582;
  LODWORD(v18) = HIDWORD(v74) ^ v18;
  HIDWORD(v40) = WORD1(v18);
  LODWORD(v18) = HIWORD(v75) | ((_DWORD)v18 << 16);
  v77 = v71 + __PAIR64__(HIDWORD(v40) | (v75 << 16), v18);
  v76 = HIDWORD(v77);
  LODWORD(v40) = v77;
  v578 = HIDWORD(v575) ^ v577;
  *(_DWORD *)&v576[12] = v68 ^ HIDWORD(v51);
  v614 = HIDWORD(v40) | (v75 << 16);
  v78 = v73 ^ ((v71 + __PAIR64__(v614, v18)) >> 32);
  v79 = (2 * ((v71 + v18) ^ v568)) | (v78 >> 31);
  v80 = (2 * v78) | (((unsigned int)v40 ^ (unsigned int)v568) >> 31);
  v81 = v569 + m[14] + __PAIR64__(v80, v79);
  v82 = __PAIR64__(v41, v68) + __PAIR64__((unsigned int)v81 ^ v601, HIDWORD(v81) ^ v625);
  LODWORD(v41) = (__PAIR64__(v41, v68) + __PAIR64__((unsigned int)v81 ^ v601, HIDWORD(v81) ^ v625)) >> 32;
  HIDWORD(v41) = v80 ^ v41;
  v83 = (((unsigned int)v82 ^ v79) >> 24) | ((v80 ^ (unsigned int)v41) << 8);
  HIDWORD(v41) = HIBYTE(HIDWORD(v41)) | (((unsigned int)v82 ^ v79) << 8);
  v84 = HIDWORD(v81) ^ v625 ^ (LODWORD(m[10]) + v81 + v83);
  *(_QWORD *)&v591[8] = m[10] + v81 + __PAIR64__(HIDWORD(v41), v83);
  LODWORD(v51) = *(_DWORD *)&v591[12] ^ v81 ^ v601;
  LODWORD(v569) = HIWORD(v84) | ((_DWORD)v51 << 16);
  HIDWORD(v569) = WORD1(v51) | (v84 << 16);
  v85 = (2 * v549) | (*(_DWORD *)&v576[8] >> 31);
  HIDWORD(v40) = (2 * *(_DWORD *)&v576[8]) | (v549 >> 31);
  v550 = (__PAIR64__(v41, v82) + v569) >> 32;
  v602 = v82 + v569;
  *(_DWORD *)&v576[8] = (v82 + v569) ^ v83;
  LODWORD(v41) = (m[4] + __PAIR64__(v599, v571) + __PAIR64__(HIDWORD(v40), v85)) >> 32;
  v86 = LODWORD(m[4]) + v571 + v85;
  HIDWORD(v87) = v86 ^ v606;
  LODWORD(v87) = v619 ^ v41;
  v583 = v550 ^ HIDWORD(v41);
  v88 = __PAIR64__(v76, v40) + v87;
  v89 = (v40 + (v619 ^ v41)) ^ v85;
  HIDWORD(v51) = HIDWORD(v40) ^ ((__PAIR64__(v76, v40) + v87) >> 32);
  HIDWORD(v40) = HIBYTE(v89) | (HIDWORD(v51) << 8);
  v90 = HIBYTE(HIDWORD(v51)) | (v89 << 8);
  v91 = m[8] + __PAIR64__(v41, v86) + __PAIR64__(v90, HIDWORD(v40));
  v607 = HIDWORD(v91);
  v600 = v91;
  v92 = v619 ^ v41 ^ (LODWORD(m[8]) + v86 + HIDWORD(v40));
  HIDWORD(v87) ^= v607;
  HIDWORD(v41) = HIWORD(v92) | (HIDWORD(v87) << 16);
  v572 = HIWORD(HIDWORD(v87)) | (v92 << 16);
  v620 = HIDWORD(v41);
  v94 = v88 + __PAIR64__(v572, HIDWORD(v41));
  v93 = HIDWORD(v94);
  HIDWORD(v41) = v94;
  LODWORD(v41) = (2 * HIDWORD(v568)) | (v578 >> 31);
  v95 = v586;
  LODWORD(v87) = (2 * v578) | (HIDWORD(v568) >> 31);
  LODWORD(v568) = v93;
  v96 = __CFADD__(m[9], (_DWORD)v586);
  v97 = LODWORD(m[9]) + v586;
  v579 = HIDWORD(v41) ^ HIDWORD(v40);
  LODWORD(v586) = HIDWORD(v41);
  v98 = HIDWORD(v95) + v96 + HIDWORD(m[9]);
  v96 = __CFADD__(v97, (_DWORD)v41);
  v99 = v97 + v41;
  v100 = v98 + v96 + (_DWORD)v87;
  v101 = v93 ^ v90;
  LODWORD(v41) = v41 ^ (*(_DWORD *)v570 + (v100 ^ v614));
  HIDWORD(v568) = *(_DWORD *)v570 + (v100 ^ v614);
  HIDWORD(v41) = (*(_QWORD *)v570 + __PAIR64__(v99 ^ (unsigned int)v18, v100 ^ (unsigned int)v614)) >> 32;
  LODWORD(v87) = v87 ^ HIDWORD(v41);
  HIDWORD(v51) = BYTE3(v41) | ((_DWORD)v87 << 8);
  v102 = BYTE3(v87) | ((_DWORD)v41 << 8);
  HIDWORD(v40) = v100 ^ v614 ^ (LODWORD(m[15]) + v99 + HIDWORD(v51));
  HIDWORD(v87) = v99 ^ v18 ^ ((m[15] + __PAIR64__(v100, v99) + __PAIR64__(v102, HIDWORD(v51))) >> 32);
  v615 = (m[15] + __PAIR64__(v100, v99) + __PAIR64__(v102, HIDWORD(v51))) >> 32;
  HIDWORD(v586) = LODWORD(m[15]) + v99 + HIDWORD(v51);
  LODWORD(v40) = HIWORD(HIDWORD(v40)) | (HIDWORD(v87) << 16);
  HIDWORD(v87) = HIWORD(HIDWORD(v87)) | (HIDWORD(v40) << 16);
  v626 = v40;
  LODWORD(v51) = (2 * HIDWORD(v18)) | (*(_DWORD *)&v576[12] >> 31);
  v96 = __CFADD__(HIDWORD(v568), (_DWORD)v40);
  LODWORD(v40) = HIDWORD(v568) + v40;
  HIDWORD(v41) += v96 + HIDWORD(v87);
  v633 = HIDWORD(v87);
  LODWORD(v87) = (2 * *(_DWORD *)&v576[12]) | (HIDWORD(v18) >> 31);
  *(_DWORD *)v570 = v40 ^ HIDWORD(v51);
  v103 = HIDWORD(v41) ^ v102;
  HIDWORD(v18) = (LODWORD(m[13]) + v74 + v87) ^ v643;
  v104 = m[13] + v74 + __PAIR64__(v51, v87);
  HIDWORD(v568) = v575 + (HIDWORD(v104) ^ v581);
  LODWORD(v87) = v87 ^ HIDWORD(v568);
  LODWORD(v41) = (v575 + __PAIR64__(HIDWORD(v18), HIDWORD(v104) ^ (unsigned int)v581)) >> 32;
  LODWORD(v51) = v41 ^ v51;
  HIDWORD(v87) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  LODWORD(v87) = HIDWORD(v87) | ((_DWORD)v87 << 8);
  HIDWORD(v51) = (LODWORD(m[6]) + v104 + v51) ^ HIDWORD(v104) ^ v581;
  v105 = m[6] + v104 + __PAIR64__(v87, v51);
  HIDWORD(v18) ^= HIDWORD(v105);
  v106 = HIWORD(HIDWORD(v18));
  HIDWORD(v18) = HIWORD(HIDWORD(v51)) | (HIDWORD(v18) << 16);
  HIDWORD(v51) = v106 | (HIDWORD(v51) << 16);
  LODWORD(v18) = 2 * v101;
  v107 = (2 * v579) | (v101 >> 31);
  v108 = __PAIR64__(v41, HIDWORD(v568)) + __PAIR64__(HIDWORD(v51), HIDWORD(v18));
  LODWORD(v41) = (__PAIR64__(v41, HIDWORD(v568)) + __PAIR64__(HIDWORD(v51), HIDWORD(v18))) >> 32;
  LODWORD(v18) = v18 | (v579 >> 31);
  LODWORD(v575) = v87 ^ v41;
  v109 = (m[1] + *(_QWORD *)&v591[8] + __PAIR64__(v18, v107)) >> 32;
  v110 = LODWORD(m[1]) + *(_DWORD *)&v591[8] + v107;
  HIDWORD(v18) ^= v110;
  HIDWORD(v51) ^= v109;
  *(_DWORD *)&v570[4] = v108 ^ v51;
  v111 = (v40 + HIDWORD(v51)) ^ v107;
  v112 = __PAIR64__(HIDWORD(v41), v40) + __PAIR64__(HIDWORD(v18), HIDWORD(v51));
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v40) + __PAIR64__(HIDWORD(v18), HIDWORD(v51))) >> 32;
  v114 = m[12] + __PAIR64__(v109, v110);
  v113 = (m[12] + __PAIR64__(v109, v110)) >> 32;
  LODWORD(v18) = HIDWORD(v41) ^ v18;
  LODWORD(v40) = BYTE3(v18);
  LODWORD(v18) = HIBYTE(v111) | ((_DWORD)v18 << 8);
  v115 = v40 | (v111 << 8);
  HIDWORD(v51) ^= v114 + (_DWORD)v18;
  LODWORD(v590) = v114 + v18;
  HIDWORD(v18) ^= v115 + __CFADD__((_DWORD)v114, (_DWORD)v18) + v113;
  HIDWORD(v590) = v115 + __CFADD__((_DWORD)v114, (_DWORD)v18) + v113;
  v116 = *(_DWORD *)v570;
  LODWORD(v643) = HIWORD(HIDWORD(v51)) | (HIDWORD(v18) << 16);
  *(_DWORD *)v570 = HIWORD(HIDWORD(v18)) | (HIDWORD(v51) << 16);
  LODWORD(v40) = (2 * v103) | (v116 >> 31);
  HIDWORD(v568) = *(_DWORD *)v570 + __CFADD__((_DWORD)v112, (_DWORD)v643) + HIDWORD(v41);
  v117 = (2 * v116) | (v103 >> 31);
  HIDWORD(v575) = (v112 + v643) ^ v18;
  LODWORD(v87) = m[2];
  HIDWORD(v87) = (m[0] + __PAIR64__(v607, v600) + __PAIR64__(v40, v117)) >> 32;
  LODWORD(v118) = LODWORD(m[0]) + v600 + v117;
  LODWORD(v51) = HIDWORD(v87) ^ HIDWORD(v569);
  HIDWORD(v40) = v108 + (HIDWORD(v87) ^ HIDWORD(v569));
  v119 = HIDWORD(v40) ^ v117;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v108, HIDWORD(v87) ^ HIDWORD(v569)) + (v118 ^ v569);
  LODWORD(v40) = v40 ^ v41;
  HIDWORD(v569) = HIDWORD(v568) ^ v115;
  v120 = BYTE3(v40);
  LODWORD(v40) = HIBYTE(v119) | ((_DWORD)v40 << 8);
  HIDWORD(v118) = HIDWORD(m[2]);
  v121 = v120 | (v119 << 8);
  v122 = (v87 + v118 + __PAIR64__(v121, v40)) >> 32;
  HIDWORD(v118) = LODWORD(m[2]) + v118 + v40;
  LODWORD(v51) = HIDWORD(v118) ^ v51;
  HIDWORD(v41) = v118 ^ v569 ^ v122;
  *(_QWORD *)&v591[12] = __PAIR64__(v122, HIDWORD(v118));
  HIDWORD(v118) = HIWORD(HIDWORD(v41));
  HIDWORD(v87) = WORD1(v51) | (HIDWORD(v41) << 16);
  HIDWORD(v41) = *(_DWORD *)&v570[4];
  LODWORD(v569) = HIDWORD(v118) | ((_DWORD)v51 << 16);
  LODWORD(v118) = 2 * *(_DWORD *)&v570[4];
  *(_DWORD *)&v570[4] = HIDWORD(v87);
  LODWORD(v87) = v118 | ((unsigned int)v575 >> 31);
  v123 = v569 + __CFADD__(HIDWORD(v40), HIDWORD(v87)) + (_DWORD)v41;
  LODWORD(v41) = HIDWORD(v586);
  LODWORD(v51) = (2 * v575) | (HIDWORD(v41) >> 31);
  HIDWORD(v586) = HIDWORD(v40) + HIDWORD(v87);
  LODWORD(v575) = (HIDWORD(v40) + HIDWORD(v87)) ^ v40;
  v608 = v123;
  v124 = m[11] + __PAIR64__(v615, v41) + __PAIR64__(v51, v87);
  v580 = v123 ^ v121;
  LODWORD(v87) = v87 ^ (v602 + (HIDWORD(v124) ^ v572));
  HIDWORD(v87) = (__PAIR64__(v550, v602) + __PAIR64__((unsigned int)v124 ^ v620, HIDWORD(v124) ^ (unsigned int)v572)) >> 32;
  LODWORD(v40) = v602 + (HIDWORD(v124) ^ v572);
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v40) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v40) |= (_DWORD)v87 << 8;
  v125 = m[7] + v124 + __PAIR64__(HIDWORD(v40), v51);
  v616 = HIDWORD(v125);
  v603 = v125;
  HIDWORD(v51) = (HIDWORD(v40) + __CFADD__(LODWORD(m[7]) + v124, (_DWORD)v51) + ((m[7] + v124) >> 32)) ^ v124 ^ v620;
  HIDWORD(v41) = v583;
  HIDWORD(v118) = (((LODWORD(m[7]) + (_DWORD)v124 + (_DWORD)v51) ^ HIDWORD(v124) ^ (unsigned int)v572) >> 16)
                | (HIDWORD(v51) << 16);
  LODWORD(v118) = HIWORD(HIDWORD(v51)) | (((LODWORD(m[7]) + (_DWORD)v124 + (_DWORD)v51) ^ HIDWORD(v124) ^ v572) << 16);
  v96 = __CFADD__((_DWORD)v40, HIDWORD(v118));
  LODWORD(v40) = v40 + HIDWORD(v118);
  HIDWORD(v87) += v96 + (_DWORD)v118;
  HIDWORD(v51) = 2 * v583;
  v584 = v118;
  v126 = (2 * *(_DWORD *)&v576[8]) | (HIDWORD(v41) >> 31);
  HIDWORD(v51) |= *(_DWORD *)&v576[8] >> 31;
  v573 = HIDWORD(v118);
  *(_DWORD *)&v576[4] = v40 ^ v51;
  *(_DWORD *)&v576[8] = HIDWORD(v87) ^ HIDWORD(v40);
  HIDWORD(v18) = (LODWORD(m[5]) + v105 + v126) ^ v626;
  v127 = m[5] + v105 + __PAIR64__(HIDWORD(v51), v126);
  LODWORD(v18) = HIDWORD(v127) ^ v633;
  v128 = (v586 + (HIDWORD(v127) ^ v633)) ^ v126;
  LODWORD(v87) = (__PAIR64__(v568, v586) + v18) >> 32;
  HIDWORD(v40) = v586 + (HIDWORD(v127) ^ v633);
  HIDWORD(v51) ^= v87;
  v129 = HIBYTE(v128) | (HIDWORD(v51) << 8);
  v130 = HIBYTE(HIDWORD(v51)) | (v128 << 8);
  v131 = m[3] + v127 + __PAIR64__(v130, v129);
  v621 = HIDWORD(v131);
  LODWORD(v118) = v131;
  LODWORD(v18) = v118 ^ HIDWORD(v127) ^ v633;
  HIDWORD(v18) ^= v130 + __CFADD__(LODWORD(m[3]) + v127, v129) + ((m[3] + v127) >> 32);
  LODWORD(v586) = LODWORD(m[3]) + v127 + v129;
  LODWORD(v118) = HIWORD(HIDWORD(v18));
  HIDWORD(v18) = v18 >> 16;
  LODWORD(v18) = v118 | ((_DWORD)v18 << 16);
  v132 = (HIDWORD(v40) + HIDWORD(v18)) ^ v129;
  v133 = __PAIR64__(v87, HIDWORD(v40)) + __PAIR64__(v18, HIDWORD(v18));
  LODWORD(v87) = (__PAIR64__(v87, HIDWORD(v40)) + __PAIR64__(v18, HIDWORD(v18))) >> 32;
  v134 = v87 ^ v130;
  HIDWORD(v51) = 2 * v134;
  v135 = (2 * v132) | (v134 >> 31);
  v136 = HIDWORD(v51) | (v132 >> 31);
  v137 = m[11] + v590 + __PAIR64__(v136, v135);
  v96 = __CFADD__((_DWORD)v40, v569 ^ HIDWORD(v137));
  LODWORD(v40) = v40 + (v569 ^ HIDWORD(v137));
  v138 = v40 ^ v135;
  v551 = v40;
  HIDWORD(v87) += v96 + (*(_DWORD *)&v570[4] ^ v137);
  v139 = HIDWORD(v87) ^ v136;
  HIDWORD(v51) = HIBYTE(v139);
  v140 = HIBYTE(v138) | (v139 << 8);
  v141 = HIDWORD(v51) | (v138 << 8);
  HIDWORD(v118) = v569 ^ HIDWORD(v137) ^ (LODWORD(m[8]) + v137 + v140);
  HIDWORD(v41) = *(_DWORD *)&v570[4] ^ v137 ^ ((m[8] + v137 + __PAIR64__(v141, v140)) >> 32);
  v592 = m[8] + v137 + __PAIR64__(v141, v140);
  *(_DWORD *)&v570[4] = HIWORD(HIDWORD(v41)) | (HIDWORD(v118) << 16);
  v627 = HIWORD(HIDWORD(v118)) | (HIDWORD(v41) << 16);
  LODWORD(v41) = (2 * HIDWORD(v575)) | (HIDWORD(v569) >> 31);
  HIDWORD(v118) = (2 * HIDWORD(v569)) | (HIDWORD(v575) >> 31);
  HIDWORD(v41) = v40 + v627;
  LODWORD(v40) = *(_DWORD *)&v591[12];
  v552 = *(_DWORD *)&v570[4] + __CFADD__(v551, v627) + HIDWORD(v87);
  *(_DWORD *)&v591[12] = HIDWORD(v41);
  *(_DWORD *)&v576[12] = HIDWORD(v41) ^ v140;
  LODWORD(v118) = LODWORD(m[12]) + v40;
  HIDWORD(v87) = (v118 + __PAIR64__((m[12] + __PAIR64__(*(unsigned int *)&v591[16], v40)) >> 32, v41)) >> 32;
  LODWORD(v118) = LODWORD(m[12]) + v40 + v41;
  HIDWORD(v51) = HIDWORD(v87) ^ v584;
  HIDWORD(v40) = v133 + (HIDWORD(v87) ^ v584);
  LODWORD(v87) = v87 + __CFADD__((_DWORD)v133, HIDWORD(v87) ^ v584) + (v118 ^ v573);
  LODWORD(v41) = v41 ^ HIDWORD(v40);
  HIDWORD(v118) ^= v87;
  LODWORD(v51) = HIBYTE(HIDWORD(v118));
  *(_DWORD *)&v576[16] = v552 ^ v141;
  v142 = m[0] + __PAIR64__(HIDWORD(v87), v118);
  HIDWORD(v87) = (m[0] + __PAIR64__(HIDWORD(v87), v118)) >> 32;
  HIDWORD(v118) = BYTE3(v41) | (HIDWORD(v118) << 8);
  LODWORD(v41) = v51 | ((_DWORD)v41 << 8);
  HIDWORD(v41) = v118 ^ v573 ^ (v41 + __CFADD__((_DWORD)v142, HIDWORD(v118)) + HIDWORD(v87));
  LODWORD(v568) = v41 + __CFADD__((_DWORD)v142, HIDWORD(v118)) + HIDWORD(v87);
  *(_DWORD *)&v591[16] = v142 + HIDWORD(v118);
  v574 = ((HIDWORD(v51) ^ (unsigned int)(v142 + HIDWORD(v118))) >> 16) | (HIDWORD(v41) << 16);
  v634 = HIWORD(HIDWORD(v41)) | ((HIDWORD(v51) ^ ((_DWORD)v142 + HIDWORD(v118))) << 16);
  v143 = (2 * v575) | (v580 >> 31);
  HIDWORD(v87) = (2 * v580) | ((unsigned int)v575 >> 31);
  LODWORD(v40) = v603;
  LODWORD(v569) = HIDWORD(v40) + v574;
  v604 = v634 + __CFADD__(HIDWORD(v40), v574) + (_DWORD)v87;
  HIDWORD(v569) = (HIDWORD(v40) + v574) ^ HIDWORD(v118);
  v144 = v604 ^ v41;
  LODWORD(v118) = (m[5] + __PAIR64__(v616, v40) + __PAIR64__(HIDWORD(v87), v143)) >> 32;
  HIDWORD(v40) = LODWORD(m[5]) + v40 + v143;
  HIDWORD(v18) ^= HIDWORD(v40);
  LODWORD(v18) = v118 ^ v18;
  v145 = (v112 + v643 + v18) ^ v143;
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v568), (int)v112 + (int)v643) + v18) >> 32;
  LODWORD(v40) = v112 + v643 + v18;
  HIDWORD(v87) ^= HIDWORD(v41);
  HIDWORD(v118) = HIBYTE(HIDWORD(v87));
  HIDWORD(v87) = HIBYTE(v145) | (HIDWORD(v87) << 8);
  v146 = HIDWORD(v118) | (v145 << 8);
  v147 = (m[2] + __PAIR64__(v118, HIDWORD(v40)) + __PAIR64__(v146, HIDWORD(v87))) ^ v18;
  v617 = (m[2] + __PAIR64__(v118, HIDWORD(v40)) + __PAIR64__(v146, HIDWORD(v87))) >> 32;
  *(_DWORD *)&v591[8] = LODWORD(m[2]) + HIDWORD(v40) + HIDWORD(v87);
  LODWORD(v118) = v147 >> 16;
  v96 = __CFADD__((_DWORD)v40, (_DWORD)v118);
  LODWORD(v40) = v40 + v118;
  LODWORD(v575) = HIWORD(HIDWORD(v147)) | ((_DWORD)v147 << 16);
  HIDWORD(v41) += v96 + (_DWORD)v575;
  HIDWORD(v643) = v118;
  v148 = HIDWORD(v41) ^ v146;
  HIDWORD(v575) = v40 ^ HIDWORD(v87);
  LODWORD(v118) = (m[15] + __PAIR64__(v621, v586) + ((2LL * *(_QWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31))) >> 32;
  HIDWORD(v40) = LODWORD(m[15]) + v586 + ((2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31));
  HIDWORD(v568) = HIDWORD(v586) + (v118 ^ *(_DWORD *)v570);
  LODWORD(v87) = ((2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31)) ^ HIDWORD(v568);
  LODWORD(v41) = (HIDWORD(v40) ^ v643) + __CFADD__(HIDWORD(v586), v118 ^ *(_DWORD *)v570) + v608;
  LODWORD(v51) = v41 ^ (*(__int64 *)&v576[4] >> 31);
  HIDWORD(v87) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  LODWORD(v87) = HIDWORD(v87) | ((_DWORD)v87 << 8);
  HIDWORD(v51) = (LODWORD(m[13]) + HIDWORD(v40) + v51) ^ v118 ^ *(_DWORD *)v570;
  HIDWORD(v147) = ((m[13]
                  + m[15]
                  + __PAIR64__(v621, v586)
                  + ((2LL * *(_QWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31))
                  + __PAIR64__(v87, v51)) >> 32)
                ^ HIDWORD(v40)
                ^ v643;
  HIDWORD(v586) = LODWORD(m[13]) + HIDWORD(v40) + v51;
  v609 = (m[13]
        + m[15]
        + __PAIR64__(v621, v586)
        + ((2LL * *(_QWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31))
        + __PAIR64__(v87, v51)) >> 32;
  LODWORD(v118) = HIWORD(HIDWORD(v147));
  HIDWORD(v147) = HIWORD(HIDWORD(v51)) | (HIDWORD(v147) << 16);
  HIDWORD(v51) = v118 | (HIDWORD(v51) << 16);
  LODWORD(v147) = (2 * v144) | (HIDWORD(v569) >> 31);
  v149 = __PAIR64__(v41, HIDWORD(v568)) + __PAIR64__(HIDWORD(v51), HIDWORD(v147));
  v150 = (2 * HIDWORD(v569)) | (v144 >> 31);
  *(_DWORD *)&v576[8] = HIDWORD(v568) + HIDWORD(v147);
  LODWORD(v87) = v87 ^ ((__PAIR64__(v41, HIDWORD(v568)) + __PAIR64__(HIDWORD(v51), HIDWORD(v147))) >> 32);
  *(_DWORD *)v570 = (HIDWORD(v568) + HIDWORD(v147)) ^ v51;
  HIDWORD(v568) = LODWORD(m[10]) + v592 + v150;
  LODWORD(v118) = (m[10] + v592 + __PAIR64__(v147, v150)) >> 32;
  HIDWORD(v51) ^= v118;
  HIDWORD(v147) ^= HIDWORD(v568);
  v151 = (v40 + HIDWORD(v51)) ^ v150;
  v152 = __PAIR64__(HIDWORD(v41), v40) + __PAIR64__(HIDWORD(v147), HIDWORD(v51));
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v40) + __PAIR64__(HIDWORD(v147), HIDWORD(v51))) >> 32;
  LODWORD(v147) = HIDWORD(v41) ^ v147;
  LODWORD(v40) = BYTE3(v147);
  LODWORD(v147) = HIBYTE(v151) | ((_DWORD)v147 << 8);
  v153 = v40 | (v151 << 8);
  v154 = m[14] + __PAIR64__(v118, HIDWORD(v568)) + __PAIR64__(v153, v147);
  HIDWORD(v51) ^= v154;
  HIDWORD(v147) ^= HIDWORD(v154);
  v593 = v154;
  HIDWORD(v154) = HIDWORD(v575);
  LODWORD(v643) = HIWORD(HIDWORD(v51)) | (HIDWORD(v147) << 16);
  HIDWORD(v575) = HIWORD(HIDWORD(v147)) | (HIDWORD(v51) << 16);
  LODWORD(v154) = (2 * v148) | (HIDWORD(v154) >> 31);
  v155 = (2 * HIDWORD(v154)) | (v148 >> 31);
  HIDWORD(v569) = HIDWORD(v575) + __CFADD__((_DWORD)v152, (_DWORD)v643) + HIDWORD(v41);
  *(_DWORD *)v576 = (v152 + v643) ^ v147;
  HIDWORD(v87) = (m[3] + __PAIR64__(v568, *(unsigned int *)&v591[16]) + __PAIR64__(v154, v155)) >> 32;
  LODWORD(v118) = LODWORD(m[3]) + *(_DWORD *)&v591[16] + v155;
  *(_DWORD *)&v576[4] = HIDWORD(v569) ^ v153;
  v156 = __PAIR64__(HIDWORD(v149), *(unsigned int *)&v576[8])
       + __PAIR64__((unsigned int)v118 ^ v627, HIDWORD(v87) ^ *(_DWORD *)&v570[4]);
  LODWORD(v41) = HIDWORD(v156);
  HIDWORD(v154) = v156;
  v157 = (*(_DWORD *)&v576[8] + (HIDWORD(v87) ^ *(_DWORD *)&v570[4])) ^ v155;
  LODWORD(v154) = v154
                ^ ((__PAIR64__(HIDWORD(v149), *(unsigned int *)&v576[8])
                  + __PAIR64__((unsigned int)v118 ^ v627, HIDWORD(v87) ^ *(_DWORD *)&v570[4])) >> 32);
  v158 = BYTE3(v154);
  LODWORD(v154) = HIBYTE(v157) | ((_DWORD)v154 << 8);
  v159 = v158 | (v157 << 8);
  v160 = m[6] + __PAIR64__(HIDWORD(v87), v118) + __PAIR64__(v159, v154);
  LODWORD(v51) = v160 ^ HIDWORD(v87) ^ *(_DWORD *)&v570[4];
  HIDWORD(v41) = v118 ^ v627 ^ HIDWORD(v160);
  HIDWORD(v118) = HIWORD(HIDWORD(v41));
  HIDWORD(v41) = WORD1(v51) | (HIDWORD(v41) << 16);
  LODWORD(v118) = *(_DWORD *)v570;
  HIDWORD(v118) |= (_DWORD)v51 << 16;
  LODWORD(v51) = 2 * v87;
  LODWORD(v568) = HIDWORD(v154) + HIDWORD(v41);
  LODWORD(v87) = (2 * *(_DWORD *)v570) | ((unsigned int)v87 >> 31);
  *(_DWORD *)v570 = HIDWORD(v118) + __CFADD__(HIDWORD(v154), HIDWORD(v41)) + (_DWORD)v41;
  LODWORD(v51) = v51 | ((unsigned int)v118 >> 31);
  *(_DWORD *)&v576[8] = (HIDWORD(v154) + HIDWORD(v41)) ^ v154;
  v161 = m[7] + __PAIR64__(v617, *(unsigned int *)&v591[8]) + __PAIR64__(v51, v87);
  LODWORD(v586) = *(_DWORD *)v570 ^ v159;
  HIDWORD(v87) = (__PAIR64__(v552, *(unsigned int *)&v591[12])
                + __PAIR64__((unsigned int)v161 ^ v574, HIDWORD(v161) ^ (unsigned int)v634)) >> 32;
  LODWORD(v154) = *(_DWORD *)&v591[12] + (HIDWORD(v161) ^ v634);
  LODWORD(v87) = v87 ^ v154;
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v147) = BYTE3(v51);
  HIDWORD(v51) = (m[1] + v161) >> 32;
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v154) = HIDWORD(v147) | ((_DWORD)v87 << 8);
  LODWORD(v118) = HIDWORD(v161) ^ v634 ^ (LODWORD(m[1]) + v161 + v51);
  v162 = ((__PAIR64__(HIDWORD(v154), LODWORD(m[1]) + (int)v161) + v51) >> 32) ^ v161 ^ v574;
  *(_DWORD *)&v570[4] = WORD1(v118) | (v162 << 16);
  *(_DWORD *)&v570[8] = HIWORD(v162) | ((_DWORD)v118 << 16);
  *(_QWORD *)&v591[8] = __PAIR64__(HIDWORD(v154), LODWORD(m[1]) + (int)v161) + v51;
  HIDWORD(v51) = *(__int64 *)&v576[12] >> 31;
  v163 = (2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)&v576[16] >> 31);
  v164 = __PAIR64__(HIDWORD(v87), v154) + *(_QWORD *)&v570[4];
  HIDWORD(v87) = (__PAIR64__(HIDWORD(v87), v154) + *(_QWORD *)&v570[4]) >> 32;
  *(_DWORD *)&v576[12] = v164 ^ v51;
  LODWORD(v87) = (m[9] + __PAIR64__(v609, HIDWORD(v586)) + __PAIR64__(HIDWORD(v51), v163)) >> 32;
  LODWORD(v118) = LODWORD(m[9]) + HIDWORD(v586) + v163;
  HIDWORD(v147) = v118 ^ HIDWORD(v643);
  LODWORD(v147) = v87 ^ v575;
  *(_DWORD *)&v576[16] = HIDWORD(v87) ^ HIDWORD(v154);
  v165 = (v569 + (v87 ^ v575)) ^ v163;
  HIDWORD(v154) = v569 + (v87 ^ v575);
  HIDWORD(v51) ^= (__PAIR64__(v604, v569) + v147) >> 32;
  v553 = (__PAIR64__(v604, v569) + v147) >> 32;
  v166 = HIBYTE(v165) | (HIDWORD(v51) << 8);
  v167 = HIBYTE(HIDWORD(v51)) | (v165 << 8);
  LODWORD(v147) = (LODWORD(m[4]) + v118 + v166) ^ v87 ^ v575;
  HIDWORD(v147) = v87 ^ v118 ^ HIDWORD(v643);
  v168 = m[4] + __PAIR64__(v87, v118) + __PAIR64__(v167, v166);
  LODWORD(v87) = HIDWORD(v168);
  HIDWORD(v586) = v168;
  LODWORD(v118) = HIWORD(HIDWORD(v147));
  v605 = v87;
  HIDWORD(v147) = v147 >> 16;
  LODWORD(v147) = v118 | ((_DWORD)v147 << 16);
  v169 = (HIDWORD(v154) + HIDWORD(v147)) ^ v166;
  LODWORD(v87) = (__PAIR64__(v553, HIDWORD(v154)) + __PAIR64__(v147, HIDWORD(v147))) >> 32;
  HIDWORD(v154) += HIDWORD(v147);
  v170 = v87 ^ v167;
  HIDWORD(v51) = 2 * v170;
  v171 = (2 * v169) | (v170 >> 31);
  v172 = HIDWORD(v51) | (v169 >> 31);
  v173 = m[7] + v593 + __PAIR64__(v172, v171);
  HIDWORD(v41) ^= v173;
  HIDWORD(v118) ^= HIDWORD(v173);
  LODWORD(v154) = v164 + HIDWORD(v118);
  v174 = (v164 + HIDWORD(v118)) ^ v171;
  LODWORD(v569) = HIDWORD(v87) + __CFADD__((_DWORD)v164, HIDWORD(v118)) + HIDWORD(v41);
  v175 = v569 ^ v172;
  HIDWORD(v51) = HIBYTE(v175);
  v176 = HIBYTE(v174) | (v175 << 8);
  v177 = HIDWORD(v51) | (v174 << 8);
  HIDWORD(v118) ^= LODWORD(m[9]) + v173 + v176;
  HIDWORD(v41) ^= (m[9] + v173 + __PAIR64__(v177, v176)) >> 32;
  v594 = m[9] + v173 + __PAIR64__(v177, v176);
  HIDWORD(v87) = HIWORD(HIDWORD(v118)) | (HIDWORD(v41) << 16);
  LODWORD(v575) = HIWORD(HIDWORD(v41)) | (HIDWORD(v118) << 16);
  v554 = v154 + HIDWORD(v87);
  v618 = HIDWORD(v87);
  LODWORD(v41) = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[4] >> 31);
  HIDWORD(v118) = *(__int64 *)v576 >> 31;
  LODWORD(v569) = v575 + __CFADD__((_DWORD)v154, HIDWORD(v87)) + (_DWORD)v569;
  *(_DWORD *)v576 = (v154 + HIDWORD(v87)) ^ v176;
  LODWORD(v118) = LODWORD(m[3]) + v160;
  v178 = v118 + __PAIR64__((m[3] + v160) >> 32, v41);
  v96 = __CFADD__(HIDWORD(v154), ((v118 + __PAIR64__((m[3] + v160) >> 32, v41)) >> 32) ^ *(_DWORD *)&v570[8]);
  HIDWORD(v154) += ((v118 + __PAIR64__((m[3] + v160) >> 32, v41)) >> 32) ^ *(_DWORD *)&v570[8];
  LODWORD(v87) = v87 + v96 + ((LODWORD(m[3]) + v160 + v41) ^ *(_DWORD *)&v570[4]);
  LODWORD(v41) = v41 ^ HIDWORD(v154);
  HIDWORD(v118) ^= v87;
  LODWORD(v51) = HIBYTE(HIDWORD(v118));
  *(_DWORD *)&v576[4] = v569 ^ v177;
  HIDWORD(v118) = BYTE3(v41) | (HIDWORD(v118) << 8);
  LODWORD(v41) = v51 | ((_DWORD)v41 << 8);
  v179 = m[1] + v178 + __PAIR64__(v41, HIDWORD(v118));
  v610 = HIDWORD(v179);
  LODWORD(v118) = v179;
  LODWORD(v154) = HIDWORD(v178) ^ *(_DWORD *)&v570[8] ^ v118;
  HIDWORD(v41) = v178
               ^ *(_DWORD *)&v570[4]
               ^ (v41 + __CFADD__(LODWORD(m[1]) + v178, HIDWORD(v118)) + ((m[1] + v178) >> 32));
  *(_DWORD *)&v591[16] = LODWORD(m[1]) + v178 + HIDWORD(v118);
  *(_DWORD *)&v570[8] = WORD1(v154) | (HIDWORD(v41) << 16);
  v622 = HIWORD(HIDWORD(v41)) | ((_DWORD)v154 << 16);
  v180 = (2 * *(_DWORD *)&v576[8]) | ((unsigned int)v586 >> 31);
  LODWORD(v118) = (2 * v586) | (*(_DWORD *)&v576[8] >> 31);
  HIDWORD(v87) = (HIDWORD(v154) + *(_DWORD *)&v570[8]) ^ HIDWORD(v118);
  *(_DWORD *)&v570[4] = v622 + __CFADD__(HIDWORD(v154), *(_DWORD *)&v570[8]) + (_DWORD)v87;
  LODWORD(v586) = HIDWORD(v154) + *(_DWORD *)&v570[8];
  HIDWORD(v51) = (m[13] + *(_QWORD *)&v591[8] + __PAIR64__(v118, v180)) >> 32;
  HIDWORD(v154) = LODWORD(m[13]) + *(_DWORD *)&v591[8] + v180;
  HIDWORD(v147) ^= HIDWORD(v154);
  LODWORD(v147) = HIDWORD(v51) ^ v147;
  v181 = (v152 + v643 + v147) ^ v180;
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v569), (int)v152 + (int)v643) + v147) >> 32;
  LODWORD(v154) = v152 + v643 + v147;
  LODWORD(v118) = v118 ^ HIDWORD(v41);
  HIDWORD(v118) = BYTE3(v118);
  LODWORD(v118) = HIBYTE(v181) | ((_DWORD)v118 << 8);
  v182 = HIDWORD(v118) | (v181 << 8);
  v183 = m[12] + __PAIR64__(HIDWORD(v51), HIDWORD(v154)) + __PAIR64__(v182, v118);
  v184 = v183 ^ v147;
  HIDWORD(v568) = v184 >> 16;
  HIDWORD(v569) = HIWORD(HIDWORD(v184)) | ((_DWORD)v184 << 16);
  v96 = __CFADD__((_DWORD)v154, HIDWORD(v568));
  LODWORD(v154) = v154 + HIDWORD(v568);
  HIDWORD(v41) += v96 + HIDWORD(v569);
  v185 = HIDWORD(v41) ^ v182;
  *(_DWORD *)&v576[8] = v154 ^ v118;
  v186 = m[11] + __PAIR64__(v605, HIDWORD(v586)) + ((2LL * *(_QWORD *)&v576[12]) | (*(_DWORD *)&v576[16] >> 31));
  LODWORD(v87) = ((2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)&v576[16] >> 31)) ^ (v568 + (HIDWORD(v186) ^ HIDWORD(v575)));
  LODWORD(v51) = ((__PAIR64__(*(unsigned int *)v570, v568)
                 + __PAIR64__((unsigned int)v186 ^ (unsigned int)v643, HIDWORD(v186) ^ HIDWORD(v575))) >> 32)
               ^ (*(__int64 *)&v576[12] >> 31);
  LODWORD(v118) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  LODWORD(v87) = v118 | ((_DWORD)v87 << 8);
  HIDWORD(v51) = (LODWORD(m[14])
                + LODWORD(m[11])
                + HIDWORD(v586)
                + ((2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)&v576[16] >> 31))
                + v51)
               ^ HIDWORD(v186)
               ^ HIDWORD(v575);
  *(_DWORD *)&v576[16] = LODWORD(m[14])
                       + LODWORD(m[11])
                       + HIDWORD(v586)
                       + ((2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)&v576[16] >> 31))
                       + v51;
  HIDWORD(v184) = ((m[14] + v186 + __PAIR64__(v87, v51)) >> 32) ^ v186 ^ v643;
  HIDWORD(v586) = (m[14] + v186 + __PAIR64__(v87, v51)) >> 32;
  LODWORD(v118) = HIWORD(HIDWORD(v184));
  HIDWORD(v184) = HIWORD(HIDWORD(v51)) | (HIDWORD(v184) << 16);
  HIDWORD(v51) = v118 | (HIDWORD(v51) << 16);
  v187 = (2 * HIDWORD(v87)) | ((*(_DWORD *)&v570[4] ^ (unsigned int)v41) >> 31);
  LODWORD(v184) = (2 * (*(_DWORD *)&v570[4] ^ v41)) | (HIDWORD(v87) >> 31);
  LODWORD(v41) = (__PAIR64__(*(unsigned int *)v570, v568)
                + __PAIR64__((unsigned int)v186 ^ (unsigned int)v643, HIDWORD(v186) ^ HIDWORD(v575))
                + __PAIR64__(HIDWORD(v51), HIDWORD(v184))) >> 32;
  LODWORD(v568) = v568 + (HIDWORD(v186) ^ HIDWORD(v575)) + HIDWORD(v184);
  LODWORD(v87) = v87 ^ v41;
  HIDWORD(v575) = v568 ^ v51;
  LODWORD(v118) = (m[2] + v594 + __PAIR64__(v184, v187)) >> 32;
  HIDWORD(v184) ^= LODWORD(m[2]) + v594 + v187;
  HIDWORD(v51) ^= v118;
  HIDWORD(v154) = LODWORD(m[2]) + v594 + v187;
  v188 = __PAIR64__(HIDWORD(v41), v154) + __PAIR64__(HIDWORD(v184), HIDWORD(v51));
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v154) + __PAIR64__(HIDWORD(v184), HIDWORD(v51))) >> 32;
  v189 = v188 ^ v187;
  LODWORD(v184) = HIDWORD(v41) ^ v184;
  LODWORD(v154) = BYTE3(v184);
  LODWORD(v184) = HIBYTE(v189) | ((_DWORD)v184 << 8);
  v190 = v154 | (v189 << 8);
  HIDWORD(v51) ^= LODWORD(m[6]) + HIDWORD(v154) + v184;
  HIDWORD(v184) ^= (m[6] + __PAIR64__(v118, HIDWORD(v154)) + __PAIR64__(v190, v184)) >> 32;
  v595 = m[6] + __PAIR64__(v118, HIDWORD(v154)) + __PAIR64__(v190, v184);
  *(_DWORD *)v570 = HIWORD(HIDWORD(v51)) | (HIDWORD(v184) << 16);
  LODWORD(v154) = 2 * v185;
  v191 = (2 * *(_DWORD *)&v576[8]) | (v185 >> 31);
  LODWORD(v154) = v154 | (*(_DWORD *)&v576[8] >> 31);
  v192 = __PAIR64__(v610, *(unsigned int *)&v591[16]);
  v628 = HIWORD(HIDWORD(v184)) | (HIDWORD(v51) << 16);
  HIDWORD(v154) = v628 + __CFADD__((_DWORD)v188, *(_DWORD *)v570) + HIDWORD(v41);
  *(_QWORD *)&v591[16] = __PAIR64__(HIDWORD(v154), (int)v188 + *(_DWORD *)v570);
  HIDWORD(v87) = (m[5] + v192) >> 32;
  LODWORD(v192) = LODWORD(m[5]) + v192;
  v96 = __CFADD__((_DWORD)v192, v191);
  LODWORD(v192) = v192 + v191;
  *(_DWORD *)&v576[8] = (v188 + *(_DWORD *)v570) ^ v184;
  HIDWORD(v87) += v96 + (_DWORD)v154;
  LODWORD(v184) = v192 ^ v618;
  LODWORD(v51) = HIDWORD(v87) ^ v575;
  LODWORD(v575) = HIDWORD(v154) ^ v190;
  HIDWORD(v154) = v568 + v51;
  v193 = (v568 + v51) ^ v191;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v568, (_DWORD)v51) + (v192 ^ v618);
  v194 = m[10] + __PAIR64__(HIDWORD(v87), v192);
  LODWORD(v154) = v154 ^ v41;
  v195 = BYTE3(v154);
  LODWORD(v154) = HIBYTE(v193) | ((_DWORD)v154 << 8);
  v196 = v195 | (v193 << 8);
  LODWORD(v51) = (LODWORD(m[10]) + v192 + v154) ^ v51;
  HIDWORD(v87) = v196
               + __CFADD__(LODWORD(m[10]) + v192, (_DWORD)v154)
               + ((m[10] + __PAIR64__(HIDWORD(v87), v192)) >> 32);
  v611 = __PAIR64__(HIDWORD(v87), (int)v194 + (int)v154);
  HIDWORD(v41) = WORD1(v51) | (((unsigned int)v184 ^ HIDWORD(v87)) << 16);
  HIDWORD(v192) = (((unsigned int)v184 ^ HIDWORD(v87)) >> 16) | ((_DWORD)v51 << 16);
  LODWORD(v51) = (2 * v87) | (HIDWORD(v575) >> 31);
  LODWORD(v87) = (2 * HIDWORD(v575)) | ((unsigned int)v87 >> 31);
  LODWORD(v568) = HIDWORD(v192) + __CFADD__(HIDWORD(v154), HIDWORD(v41)) + (_DWORD)v41;
  HIDWORD(v575) = (HIDWORD(v154) + HIDWORD(v41)) ^ v154;
  v197 = m[4] + v183 + __PAIR64__(v51, v87);
  *(_DWORD *)&v591[8] = HIDWORD(v154) + HIDWORD(v41);
  *(_DWORD *)&v576[12] = v568 ^ v196;
  HIDWORD(v87) = (__PAIR64__(v569, v554)
                + __PAIR64__((unsigned int)v197 ^ *(_DWORD *)&v570[8], HIDWORD(v197) ^ (unsigned int)v622)) >> 32;
  LODWORD(v154) = v554 + (HIDWORD(v197) ^ v622);
  LODWORD(v87) = v87 ^ v154;
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v184) = BYTE3(v51);
  HIDWORD(v51) = (m[0] + v197) >> 32;
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v154) = HIDWORD(v184) | ((_DWORD)v87 << 8);
  *(_DWORD *)&v591[12] = LODWORD(m[0]) + v197 + v51;
  LODWORD(v184) = HIDWORD(v197) ^ v622 ^ *(_DWORD *)&v591[12];
  v198 = ((__PAIR64__(HIDWORD(v154), LODWORD(m[0]) + (int)v197) + v51) >> 32) ^ v197 ^ *(_DWORD *)&v570[8];
  v623 = (__PAIR64__(HIDWORD(v154), LODWORD(m[0]) + (int)v197) + v51) >> 32;
  LODWORD(v569) = WORD1(v184) | (v198 << 16);
  *(_DWORD *)&v570[8] = HIWORD(v198) | ((_DWORD)v184 << 16);
  HIDWORD(v51) = *(__int64 *)v576 >> 31;
  v199 = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[4] >> 31);
  v96 = __CFADD__((_DWORD)v154, (_DWORD)v569);
  LODWORD(v154) = v154 + v569;
  HIDWORD(v87) += v96 + *(_DWORD *)&v570[8];
  *(_DWORD *)v576 = v154 ^ v51;
  *(_DWORD *)&v576[4] = HIDWORD(v87) ^ HIDWORD(v154);
  v200 = m[15] + __PAIR64__(HIDWORD(v586), *(unsigned int *)&v576[16]) + __PAIR64__(HIDWORD(v51), v199);
  HIDWORD(v184) = v200 ^ HIDWORD(v568);
  LODWORD(v184) = HIDWORD(v200) ^ HIDWORD(v569);
  v201 = (v586 + (HIDWORD(v200) ^ HIDWORD(v569))) ^ v199;
  HIDWORD(v154) = v586 + (HIDWORD(v200) ^ HIDWORD(v569));
  v555 = (__PAIR64__(*(unsigned int *)&v570[4], v586) + v184) >> 32;
  HIDWORD(v51) ^= v555;
  v202 = HIBYTE(v201) | (HIDWORD(v51) << 8);
  v203 = HIBYTE(HIDWORD(v51)) | (v201 << 8);
  v204 = m[8] + v200 + __PAIR64__(v203, v202);
  LODWORD(v184) = v204 ^ HIDWORD(v200) ^ HIDWORD(v569);
  HIDWORD(v184) = HIDWORD(v204) ^ v200 ^ HIDWORD(v568);
  LODWORD(v192) = HIWORD(HIDWORD(v184));
  HIDWORD(v184) = v184 >> 16;
  LODWORD(v184) = v192 | ((_DWORD)v184 << 16);
  v205 = (HIDWORD(v154) + HIDWORD(v184)) ^ v202;
  LODWORD(v192) = (__PAIR64__(v555, HIDWORD(v154)) + __PAIR64__(v184, HIDWORD(v184))) >> 32;
  HIDWORD(v154) += HIDWORD(v184);
  v206 = v192 ^ v203;
  *(_DWORD *)&v570[4] = v192;
  HIDWORD(v51) = 2 * v206;
  v207 = (2 * v205) | (v206 >> 31);
  v208 = HIDWORD(v51) | (v205 >> 31);
  v209 = m[9] + v595 + __PAIR64__(v208, v207);
  HIDWORD(v41) ^= v209;
  HIDWORD(v192) ^= HIDWORD(v209);
  v96 = __CFADD__((_DWORD)v154, HIDWORD(v192));
  LODWORD(v154) = v154 + HIDWORD(v192);
  HIDWORD(v87) += v96 + HIDWORD(v41);
  v210 = v154 ^ v207;
  v211 = HIDWORD(v87) ^ v208;
  HIDWORD(v51) = HIBYTE(v211);
  v212 = HIBYTE(v210) | (v211 << 8);
  v213 = HIDWORD(v51) | (v210 << 8);
  HIDWORD(v192) ^= LODWORD(m[0]) + v209 + v212;
  HIDWORD(v41) ^= (m[0] + v209 + __PAIR64__(v213, v212)) >> 32;
  v596 = m[0] + v209 + __PAIR64__(v213, v212);
  HIDWORD(v569) = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  LODWORD(v51) = HIWORD(HIDWORD(v41)) | (HIDWORD(v192) << 16);
  LODWORD(v41) = (2 * *(_DWORD *)&v576[8]) | ((unsigned int)v575 >> 31);
  HIDWORD(v192) = (2 * v575) | (*(_DWORD *)&v576[8] >> 31);
  v635 = v51;
  v556 = v154 + HIDWORD(v569);
  HIDWORD(v568) = v51 + __CFADD__((_DWORD)v154, HIDWORD(v569)) + HIDWORD(v87);
  *(_DWORD *)&v576[8] = (v154 + HIDWORD(v569)) ^ v212;
  LODWORD(v192) = LODWORD(m[5]) + v611;
  HIDWORD(v87) = (v192 + __PAIR64__((m[5] + v611) >> 32, v41)) >> 32;
  LODWORD(v192) = LODWORD(m[5]) + v611 + v41;
  v96 = __CFADD__(HIDWORD(v154), HIDWORD(v87) ^ *(_DWORD *)&v570[8]);
  HIDWORD(v154) += HIDWORD(v87) ^ *(_DWORD *)&v570[8];
  LODWORD(v87) = *(_DWORD *)&v570[4] + v96 + (v192 ^ v569);
  LODWORD(v41) = v41 ^ HIDWORD(v154);
  HIDWORD(v192) ^= v87;
  LODWORD(v51) = HIBYTE(HIDWORD(v192));
  *(_DWORD *)&v576[16] = HIDWORD(v568) ^ v213;
  HIDWORD(v192) = BYTE3(v41) | (HIDWORD(v192) << 8);
  LODWORD(v41) = v51 | ((_DWORD)v41 << 8);
  *(_QWORD *)v612 = m[7] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v41, HIDWORD(v192));
  LODWORD(v154) = HIDWORD(v87) ^ *(_DWORD *)&v570[8] ^ *(_DWORD *)v612;
  HIDWORD(v41) = v192 ^ v569 ^ *(_DWORD *)&v612[4];
  *(_DWORD *)&v570[4] = WORD1(v154) | (HIDWORD(v41) << 16);
  *(_DWORD *)&v570[8] = HIWORD(HIDWORD(v41)) | ((_DWORD)v154 << 16);
  v96 = __CFADD__(HIDWORD(v154), *(_DWORD *)&v570[4]);
  v214 = HIDWORD(v154) + *(_DWORD *)&v570[4];
  v215 = (2 * HIDWORD(v575)) | (*(_DWORD *)&v576[12] >> 31);
  HIDWORD(v154) = (2 * *(_DWORD *)&v576[12]) | (HIDWORD(v575) >> 31);
  LODWORD(v569) = v214;
  LODWORD(v154) = *(_DWORD *)&v591[12];
  *(_DWORD *)&v591[12] = *(_DWORD *)&v570[8] + v96 + (_DWORD)v87;
  v216 = *(_DWORD *)&v591[12] ^ v41;
  HIDWORD(v87) = v569 ^ HIDWORD(v192);
  v217 = m[2] + __PAIR64__(v623, v154) + __PAIR64__(HIDWORD(v154), v215);
  LODWORD(v184) = HIDWORD(v217) ^ v184;
  HIDWORD(v184) ^= v217;
  HIDWORD(v41) = (unsigned __int64)(*(_QWORD *)&v591[16] + v184) >> 32;
  LODWORD(v154) = *(_DWORD *)&v591[16] + v184;
  v218 = (*(_DWORD *)&v591[16] + v184) ^ v215;
  HIDWORD(v154) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v218) | (HIDWORD(v154) << 8);
  v219 = HIBYTE(HIDWORD(v154)) | (v218 << 8);
  v220 = m[4] + v217 + __PAIR64__(v219, v41);
  *(_DWORD *)&v591[20] = HIDWORD(v220);
  LODWORD(v192) = v220;
  LODWORD(v184) = v192 ^ v184;
  HIDWORD(v184) ^= v219 + __CFADD__(LODWORD(m[4]) + v217, (_DWORD)v41) + ((m[4] + v217) >> 32);
  *(_DWORD *)&v591[16] = LODWORD(m[4]) + v217 + v41;
  LODWORD(v575) = v184 >> 16;
  HIDWORD(v575) = HIWORD(HIDWORD(v184)) | ((_DWORD)v184 << 16);
  LODWORD(v87) = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[4] >> 31);
  LODWORD(v51) = *(__int64 *)v576 >> 31;
  v221 = __PAIR64__(HIDWORD(v41), v154) + v575;
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v154) + v575) >> 32;
  *(_DWORD *)v576 = v221 ^ v41;
  v222 = HIDWORD(v41) ^ v219;
  LODWORD(v192) = (m[10] + v204 + __PAIR64__(v51, v87)) >> 32;
  HIDWORD(v192) = LODWORD(m[10]) + v204 + v87;
  HIDWORD(v184) = HIDWORD(v192) ^ *(_DWORD *)v570;
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[8] + (v192 ^ v628));
  HIDWORD(v154) = *(_DWORD *)&v591[8] + (v192 ^ v628);
  LODWORD(v51) = ((__PAIR64__(v568, *(unsigned int *)&v591[8])
                 + __PAIR64__(HIDWORD(v192) ^ *(_DWORD *)v570, (unsigned int)v192 ^ v628)) >> 32)
               ^ v51;
  *(_DWORD *)v570 = (__PAIR64__(v568, *(unsigned int *)&v591[8])
                   + __PAIR64__(HIDWORD(v192) ^ *(_DWORD *)v570, (unsigned int)v192 ^ v628)) >> 32;
  LODWORD(v41) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  LODWORD(v87) = v41 | ((_DWORD)v87 << 8);
  HIDWORD(v51) = (LODWORD(m[15]) + HIDWORD(v192) + v51) ^ v192 ^ v628;
  v223 = m[15] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v87, v51);
  HIDWORD(v192) = HIDWORD(v223);
  *(_DWORD *)&v591[8] = v223;
  HIDWORD(v184) ^= HIDWORD(v192);
  v624 = HIDWORD(v192);
  LODWORD(v192) = HIWORD(HIDWORD(v184));
  LODWORD(v184) = (2 * v216) | (HIDWORD(v87) >> 31);
  HIDWORD(v184) = HIWORD(HIDWORD(v51)) | (HIDWORD(v184) << 16);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  v224 = (2 * HIDWORD(v87)) | (v216 >> 31);
  LODWORD(v41) = (__PAIR64__(*(unsigned int *)v570, HIDWORD(v154)) + __PAIR64__(HIDWORD(v51), HIDWORD(v184))) >> 32;
  HIDWORD(v154) += HIDWORD(v184);
  LODWORD(v87) = v87 ^ v41;
  *(_DWORD *)&v576[4] = HIDWORD(v154) ^ v51;
  LODWORD(v192) = (m[14] + v596 + __PAIR64__(v184, v224)) >> 32;
  HIDWORD(v192) = LODWORD(m[14]) + v596 + v224;
  HIDWORD(v184) ^= HIDWORD(v192);
  HIDWORD(v51) ^= v192;
  v225 = __PAIR64__(HIDWORD(v41), v221) + __PAIR64__(HIDWORD(v184), HIDWORD(v51));
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v221) + __PAIR64__(HIDWORD(v184), HIDWORD(v51))) >> 32;
  v226 = v225 ^ v224;
  LODWORD(v184) = HIDWORD(v41) ^ v184;
  LODWORD(v154) = BYTE3(v184);
  LODWORD(v184) = HIBYTE(v226) | ((_DWORD)v184 << 8);
  HIDWORD(v51) ^= LODWORD(m[1]) + HIDWORD(v192) + v184;
  LODWORD(v596) = LODWORD(m[1]) + HIDWORD(v192) + v184;
  v227 = v154 | (v226 << 8);
  LODWORD(v192) = v227
                + __CFADD__(LODWORD(m[1]) + HIDWORD(v192), (_DWORD)v184)
                + ((m[1] + __PAIR64__(v192, HIDWORD(v192))) >> 32);
  HIDWORD(v184) ^= v192;
  HIDWORD(v596) = v192;
  *(_DWORD *)v570 = HIWORD(HIDWORD(v51)) | (HIDWORD(v184) << 16);
  LODWORD(v192) = *(_DWORD *)v576;
  *(_DWORD *)v576 = HIWORD(HIDWORD(v184)) | (HIDWORD(v51) << 16);
  LODWORD(v154) = (2 * v222) | ((unsigned int)v192 >> 31);
  v228 = (2 * v192) | (v222 >> 31);
  LODWORD(v568) = *(_DWORD *)v576 + __CFADD__((_DWORD)v225, *(_DWORD *)v570) + HIDWORD(v41);
  *(_DWORD *)&v576[12] = (v225 + *(_DWORD *)v570) ^ v184;
  HIDWORD(v87) = (m[11] + *(_QWORD *)v612 + __PAIR64__(v154, v228)) >> 32;
  LODWORD(v192) = LODWORD(m[11]) + *(_DWORD *)v612 + v228;
  v229 = (HIDWORD(v154) + (HIDWORD(v87) ^ v635)) ^ v228;
  LODWORD(v184) = (__PAIR64__(v41, HIDWORD(v154)) + __PAIR64__((unsigned int)v192 ^ HIDWORD(v569), HIDWORD(v87) ^ v635)) >> 32;
  HIDWORD(v154) += HIDWORD(v87) ^ v635;
  LODWORD(v154) = v154 ^ v184;
  LODWORD(v586) = v568 ^ v227;
  v230 = BYTE3(v154);
  LODWORD(v154) = HIBYTE(v229) | ((_DWORD)v154 << 8);
  v231 = v230 | (v229 << 8);
  v232 = m[12] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v231, v154);
  LODWORD(v51) = v232 ^ HIDWORD(v87) ^ v635;
  HIDWORD(v41) = v192 ^ HIDWORD(v569) ^ HIDWORD(v232);
  HIDWORD(v192) = HIWORD(HIDWORD(v41));
  HIDWORD(v41) = WORD1(v51) | (HIDWORD(v41) << 16);
  HIDWORD(v192) |= (_DWORD)v51 << 16;
  v96 = __CFADD__(HIDWORD(v154), HIDWORD(v41));
  v233 = HIDWORD(v154) + HIDWORD(v41);
  HIDWORD(v154) = *(_DWORD *)&v591[16];
  LODWORD(v51) = (2 * v87) | (*(_DWORD *)&v576[4] >> 31);
  LODWORD(v87) = (2 * *(_DWORD *)&v576[4]) | ((unsigned int)v87 >> 31);
  *(_DWORD *)&v591[16] = v233;
  HIDWORD(v569) = HIDWORD(v192) + v96 + (_DWORD)v184;
  *(_DWORD *)&v576[4] = v233 ^ v154;
  v234 = (LODWORD(m[6]) + HIDWORD(v154) + v87) ^ *(_DWORD *)&v570[4];
  v235 = m[6] + __PAIR64__(*(unsigned int *)&v591[20], HIDWORD(v154)) + __PAIR64__(v51, v87);
  HIDWORD(v586) = HIDWORD(v569) ^ v231;
  LODWORD(v87) = v87 ^ (v556 + (HIDWORD(v235) ^ *(_DWORD *)&v570[8]));
  HIDWORD(v184) = (__PAIR64__(HIDWORD(v568), v556) + __PAIR64__(v234, HIDWORD(v235) ^ *(_DWORD *)&v570[8])) >> 32;
  LODWORD(v51) = HIDWORD(v184) ^ v51;
  HIDWORD(v87) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v51) = (m[8] + v235) >> 32;
  HIDWORD(v154) = HIDWORD(v87) | ((_DWORD)v87 << 8);
  LODWORD(v41) = HIDWORD(v235) ^ *(_DWORD *)&v570[8] ^ (LODWORD(m[8]) + v235 + v51);
  v236 = __PAIR64__(HIDWORD(v154), LODWORD(m[8]) + (int)v235) + v51;
  v237 = ((__PAIR64__(HIDWORD(v154), LODWORD(m[8]) + (int)v235) + v51) >> 32) ^ v234;
  v636 = (__PAIR64__(HIDWORD(v154), LODWORD(m[8]) + (int)v235) + v51) >> 32;
  *(_DWORD *)&v570[4] = WORD1(v41) | (v237 << 16);
  LODWORD(v643) = HIWORD(v237) | ((_DWORD)v41 << 16);
  v238 = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)&v576[16] >> 31);
  LODWORD(v154) = v556 + (HIDWORD(v235) ^ *(_DWORD *)&v570[8]) + *(_DWORD *)&v570[4];
  v557 = (__PAIR64__(HIDWORD(v184), v556 + (HIDWORD(v235) ^ *(_DWORD *)&v570[8]))
        + __PAIR64__(v643, *(unsigned int *)&v570[4])) >> 32;
  HIDWORD(v51) = (2 * *(_DWORD *)&v576[16]) | (*(_DWORD *)&v576[8] >> 31);
  *(_DWORD *)&v576[8] = v154 ^ v51;
  LODWORD(v41) = (m[3] + __PAIR64__(v624, *(unsigned int *)&v591[8]) + __PAIR64__(HIDWORD(v51), v238)) >> 32;
  HIDWORD(v568) = LODWORD(m[3]) + *(_DWORD *)&v591[8] + v238;
  HIDWORD(v184) = HIDWORD(v568) ^ v575;
  *(_DWORD *)&v576[16] = v557 ^ HIDWORD(v154);
  LODWORD(v184) = v41 ^ HIDWORD(v575);
  v239 = (v569 + (v41 ^ HIDWORD(v575))) ^ v238;
  LODWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[12], v569) + v184) >> 32;
  HIDWORD(v154) = v569 + (v41 ^ HIDWORD(v575));
  HIDWORD(v51) ^= v87;
  v240 = HIBYTE(v239) | (HIDWORD(v51) << 8);
  v241 = HIBYTE(HIDWORD(v51)) | (v239 << 8);
  v242 = m[13] + __PAIR64__(v41, HIDWORD(v568)) + __PAIR64__(v241, v240);
  LODWORD(v184) = v242 ^ v41 ^ HIDWORD(v575);
  HIDWORD(v184) = HIDWORD(v242) ^ HIDWORD(v568) ^ v575;
  LODWORD(v192) = HIWORD(HIDWORD(v184));
  HIDWORD(v184) = v184 >> 16;
  LODWORD(v184) = v192 | ((_DWORD)v184 << 16);
  v243 = (HIDWORD(v154) + HIDWORD(v184)) ^ v240;
  v244 = __PAIR64__(v87, HIDWORD(v154)) + __PAIR64__(v184, HIDWORD(v184));
  LODWORD(v87) = (__PAIR64__(v87, HIDWORD(v154)) + __PAIR64__(v184, HIDWORD(v184))) >> 32;
  v245 = v87 ^ v241;
  HIDWORD(v51) = 2 * v245;
  v246 = (2 * v243) | (v245 >> 31);
  v247 = HIDWORD(v51) | (v243 >> 31);
  HIDWORD(v41) ^= LODWORD(m[2]) + v596 + v246;
  LODWORD(v41) = (m[2] + v596 + __PAIR64__(v247, v246)) >> 32;
  v96 = __CFADD__((_DWORD)v154, HIDWORD(v192) ^ v41);
  LODWORD(v154) = v154 + (HIDWORD(v192) ^ v41);
  LODWORD(v192) = LODWORD(m[2]) + v596 + v246;
  v248 = v154 ^ v246;
  v249 = (v557 + v96 + HIDWORD(v41)) ^ v247;
  HIDWORD(v51) = HIBYTE(v249);
  v250 = HIBYTE(v248) | (v249 << 8);
  v251 = HIDWORD(v51) | (v248 << 8);
  v252 = m[12] + __PAIR64__(v41, v192) + __PAIR64__(v251, v250);
  HIDWORD(v41) ^= HIDWORD(v252);
  HIDWORD(v192) ^= v41 ^ (unsigned int)v252;
  *(_DWORD *)&v570[8] = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  LODWORD(v575) = HIWORD(HIDWORD(v41)) | (HIDWORD(v192) << 16);
  LODWORD(v41) = (2 * *(_DWORD *)&v576[12]) | ((unsigned int)v586 >> 31);
  HIDWORD(v192) = (2 * v586) | (*(_DWORD *)&v576[12] >> 31);
  v558 = v154 + *(_DWORD *)&v570[8];
  HIDWORD(v568) = v154 + *(_DWORD *)&v570[8];
  *(_DWORD *)&v576[12] = (v154 + *(_DWORD *)&v570[8]) ^ v250;
  LODWORD(v192) = LODWORD(m[6]) + v232;
  HIDWORD(v87) = (v192 + __PAIR64__((m[6] + v232) >> 32, v41)) >> 32;
  LODWORD(v192) = LODWORD(m[6]) + v232 + v41;
  LODWORD(v586) = (v154 + *(_DWORD *)&v570[8]) ^ v251;
  HIDWORD(v154) = v244 + (v643 ^ HIDWORD(v87));
  LODWORD(v87) = v87 + __CFADD__((_DWORD)v244, v643 ^ HIDWORD(v87)) + (v192 ^ *(_DWORD *)&v570[4]);
  LODWORD(v41) = v41 ^ HIDWORD(v154);
  HIDWORD(v51) = HIDWORD(v192) ^ v87;
  HIDWORD(v192) = BYTE3(v41) | ((HIDWORD(v192) ^ (unsigned int)v87) << 8);
  LODWORD(v41) = HIBYTE(HIDWORD(v51)) | ((_DWORD)v41 << 8);
  v253 = m[10] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v41, HIDWORD(v192));
  HIDWORD(v41) = v192 ^ *(_DWORD *)&v570[4] ^ HIDWORD(v253);
  *(_DWORD *)&v570[4] = (((unsigned int)v643 ^ HIDWORD(v87) ^ (unsigned int)v253) >> 16) | (HIDWORD(v41) << 16);
  LODWORD(v643) = HIWORD(HIDWORD(v41)) | (((unsigned int)v643 ^ HIDWORD(v87) ^ (unsigned int)v253) << 16);
  v254 = (2 * *(_DWORD *)&v576[4]) | (HIDWORD(v586) >> 31);
  v96 = __CFADD__(HIDWORD(v154), *(_DWORD *)&v570[4]);
  v255 = HIDWORD(v154) + *(_DWORD *)&v570[4];
  HIDWORD(v154) = (2 * HIDWORD(v586)) | (*(_DWORD *)&v576[4] >> 31);
  HIDWORD(v586) = v255;
  v256 = (v643 + v96 + (_DWORD)v87) ^ v41;
  *(_DWORD *)&v591[20] = v643 + v96 + (_DWORD)v87;
  HIDWORD(v87) = HIDWORD(v586) ^ HIDWORD(v192);
  v257 = m[0] + __PAIR64__(v636, v236) + __PAIR64__(HIDWORD(v154), v254);
  HIDWORD(v184) ^= v257;
  LODWORD(v184) = HIDWORD(v257) ^ v184;
  v258 = (v225 + *(_DWORD *)v570 + v184) ^ v254;
  HIDWORD(v41) = (__PAIR64__(v568, (int)v225 + *(_DWORD *)v570) + v184) >> 32;
  LODWORD(v154) = v225 + *(_DWORD *)v570 + v184;
  HIDWORD(v154) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v258) | (HIDWORD(v154) << 8);
  v259 = HIBYTE(HIDWORD(v154)) | (v258 << 8);
  v260 = (m[11] + v257 + __PAIR64__(v259, v41)) ^ v184;
  v629 = (m[11] + v257 + __PAIR64__(v259, v41)) >> 32;
  *(_DWORD *)v612 = LODWORD(m[11]) + v257 + v41;
  HIDWORD(v575) = v260 >> 16;
  *(_DWORD *)&v576[4] = HIWORD(HIDWORD(v260)) | ((_DWORD)v260 << 16);
  LODWORD(v51) = (2 * *(_DWORD *)&v576[16]) | (*(_DWORD *)&v576[8] >> 31);
  v96 = __CFADD__((_DWORD)v154, HIDWORD(v575));
  LODWORD(v154) = v154 + HIDWORD(v575);
  HIDWORD(v41) += v96 + *(_DWORD *)&v576[4];
  LODWORD(v87) = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)&v576[16] >> 31);
  LODWORD(v569) = v154 ^ v41;
  v261 = HIDWORD(v41) ^ v259;
  LODWORD(v192) = (m[8] + v242 + __PAIR64__(v51, v87)) >> 32;
  HIDWORD(v192) = LODWORD(m[8]) + v242 + v87;
  HIDWORD(v260) = HIDWORD(v192) ^ *(_DWORD *)v570;
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[16] + (v192 ^ *(_DWORD *)v576));
  *(_DWORD *)v570 = *(_DWORD *)&v591[16] + (v192 ^ *(_DWORD *)v576);
  LODWORD(v41) = (__PAIR64__(HIDWORD(v569), *(unsigned int *)&v591[16])
                + __PAIR64__(HIDWORD(v260), (unsigned int)v192 ^ *(_DWORD *)v576)) >> 32;
  LODWORD(v51) = v41 ^ v51;
  HIDWORD(v154) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v51) = (LODWORD(m[3]) + HIDWORD(v192) + v51) ^ v192 ^ *(_DWORD *)v576;
  *(_DWORD *)&v576[16] = LODWORD(m[3]) + HIDWORD(v192) + v51;
  LODWORD(v87) = HIDWORD(v154) | ((_DWORD)v87 << 8);
  LODWORD(v192) = v87
                + __CFADD__(LODWORD(m[3]) + HIDWORD(v192), (_DWORD)v51)
                + ((m[3] + __PAIR64__(v192, HIDWORD(v192))) >> 32);
  HIDWORD(v260) ^= v192;
  *(_DWORD *)&v591[8] = v192;
  LODWORD(v192) = HIWORD(HIDWORD(v260));
  HIDWORD(v260) = HIWORD(HIDWORD(v51)) | (HIDWORD(v260) << 16);
  LODWORD(v260) = (2 * v256) | (HIDWORD(v87) >> 31);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  v262 = (2 * HIDWORD(v87)) | (v256 >> 31);
  v263 = __PAIR64__(v41, *(unsigned int *)v570) + __PAIR64__(HIDWORD(v51), HIDWORD(v260));
  LODWORD(v41) = (__PAIR64__(v41, *(unsigned int *)v570) + __PAIR64__(HIDWORD(v51), HIDWORD(v260))) >> 32;
  HIDWORD(v569) = v263 ^ v51;
  LODWORD(v87) = v87 ^ v41;
  LODWORD(v192) = (m[4] + v252 + __PAIR64__(v260, v262)) >> 32;
  HIDWORD(v192) = LODWORD(m[4]) + v252 + v262;
  HIDWORD(v260) ^= HIDWORD(v192);
  HIDWORD(v51) ^= v192;
  v264 = __PAIR64__(HIDWORD(v41), v154) + __PAIR64__(HIDWORD(v260), HIDWORD(v51));
  LODWORD(v154) = (__PAIR64__(HIDWORD(v41), v154) + __PAIR64__(HIDWORD(v260), HIDWORD(v51))) >> 32;
  v265 = v264 ^ v262;
  LODWORD(v260) = v154 ^ v260;
  *(_DWORD *)v570 = v154;
  v266 = m[13] + __PAIR64__(v192, HIDWORD(v192));
  LODWORD(v192) = (m[13] + __PAIR64__(v192, HIDWORD(v192))) >> 32;
  LODWORD(v154) = BYTE3(v260);
  LODWORD(v260) = HIBYTE(v265) | ((_DWORD)v260 << 8);
  v267 = v154 | (v265 << 8);
  HIDWORD(v51) ^= v266 + (_DWORD)v260;
  LODWORD(v596) = v266 + v260;
  HIDWORD(v260) ^= v267 + __CFADD__((_DWORD)v266, (_DWORD)v260) + (_DWORD)v192;
  HIDWORD(v596) = v267 + __CFADD__((_DWORD)v266, (_DWORD)v260) + (_DWORD)v192;
  LODWORD(v154) = 2 * v261;
  v637 = HIWORD(HIDWORD(v51)) | (HIDWORD(v260) << 16);
  *(_DWORD *)v576 = HIWORD(HIDWORD(v260)) | (HIDWORD(v51) << 16);
  v268 = (2 * v569) | (v261 >> 31);
  LODWORD(v154) = v154 | ((unsigned int)v569 >> 31);
  LODWORD(v569) = *(_DWORD *)v576 + __CFADD__((_DWORD)v264, v637) + *(_DWORD *)v570;
  *(_DWORD *)v570 = (((m[7] + v253) >> 32) + v637) ^ v260;
  HIDWORD(v87) = (m[7] + v253 + __PAIR64__(v154, v268)) >> 32;
  LODWORD(v192) = LODWORD(m[7]) + v253 + v268;
  LODWORD(v51) = HIDWORD(v87) ^ v575;
  HIDWORD(v154) = v263 + (HIDWORD(v87) ^ v575);
  v269 = HIDWORD(v154) ^ v268;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v263, HIDWORD(v87) ^ v575) + (v192 ^ *(_DWORD *)&v570[8]);
  LODWORD(v154) = v154 ^ v41;
  LODWORD(v575) = v569 ^ v267;
  v270 = BYTE3(v154);
  v271 = m[5] + __PAIR64__(HIDWORD(v87), v192);
  HIDWORD(v87) = (m[5] + __PAIR64__(HIDWORD(v87), v192)) >> 32;
  LODWORD(v154) = HIBYTE(v269) | ((_DWORD)v154 << 8);
  v272 = v270 | (v269 << 8);
  LODWORD(v51) = (v271 + v154) ^ v51;
  *(_DWORD *)&v591[12] = v271 + v154;
  HIDWORD(v41) = v192 ^ *(_DWORD *)&v570[8] ^ (v272 + __CFADD__((_DWORD)v271, (_DWORD)v154) + HIDWORD(v87));
  *(_DWORD *)&v591[16] = v272 + __CFADD__((_DWORD)v271, (_DWORD)v154) + HIDWORD(v87);
  HIDWORD(v192) = HIWORD(HIDWORD(v41));
  HIDWORD(v41) = WORD1(v51) | (HIDWORD(v41) << 16);
  v96 = __CFADD__(HIDWORD(v154), HIDWORD(v41));
  HIDWORD(v192) |= (_DWORD)v51 << 16;
  *(_DWORD *)&v570[8] = HIDWORD(v41);
  HIDWORD(v41) += HIDWORD(v154);
  HIDWORD(v87) = 2 * HIDWORD(v569);
  LODWORD(v51) = (2 * v87) | (HIDWORD(v569) >> 31);
  HIDWORD(v569) = HIDWORD(v192) + v96 + (_DWORD)v41;
  LODWORD(v87) = HIDWORD(v87) | ((unsigned int)v87 >> 31);
  *(_DWORD *)&v576[8] = HIDWORD(v41) ^ v154;
  v273 = *(_DWORD *)v612;
  *(_DWORD *)v612 = HIDWORD(v41);
  v274 = (LODWORD(m[15]) + v273 + v87) ^ *(_DWORD *)&v570[4];
  v275 = m[15] + __PAIR64__(v629, v273) + __PAIR64__(v51, v87);
  HIDWORD(v260) = v87 ^ (v558 + (HIDWORD(v275) ^ v643));
  *(_DWORD *)&v570[4] = HIDWORD(v569) ^ v272;
  HIDWORD(v87) = (__PAIR64__(HIDWORD(v568), v558) + __PAIR64__(v274, HIDWORD(v275) ^ (unsigned int)v643)) >> 32;
  LODWORD(v154) = v558 + (HIDWORD(v275) ^ v643);
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v154) = BYTE3(v51);
  LODWORD(v51) = HIBYTE(HIDWORD(v260)) | ((_DWORD)v51 << 8);
  HIDWORD(v51) = (m[14] + v275) >> 32;
  HIDWORD(v154) |= HIDWORD(v260) << 8;
  LODWORD(v41) = HIDWORD(v275) ^ v643 ^ (LODWORD(m[14]) + v275 + v51);
  v276 = ((__PAIR64__(HIDWORD(v154), LODWORD(m[14]) + (int)v275) + v51) >> 32) ^ v274;
  v559 = WORD1(v41) | (v276 << 16);
  *(_QWORD *)&v612[4] = __PAIR64__(HIDWORD(v154), LODWORD(m[14]) + (int)v275) + v51;
  HIDWORD(v51) = (2 * v586) | (*(_DWORD *)&v576[12] >> 31);
  v630 = HIWORD(v276) | ((_DWORD)v41 << 16);
  v277 = (2 * *(_DWORD *)&v576[12]) | ((unsigned int)v586 >> 31);
  LODWORD(v87) = (__PAIR64__(HIDWORD(v87), v154) + __PAIR64__(v630, v559)) >> 32;
  LODWORD(v154) = v154 + v559;
  *(_DWORD *)&v576[12] = v154 ^ v51;
  HIDWORD(v568) = v87;
  HIDWORD(v260) = (LODWORD(m[1]) + *(_DWORD *)&v576[16] + v277) ^ HIDWORD(v575);
  v278 = m[1] + __PAIR64__(*(unsigned int *)&v591[8], *(unsigned int *)&v576[16]) + __PAIR64__(HIDWORD(v51), v277);
  HIDWORD(v575) = v87 ^ HIDWORD(v154);
  LODWORD(v260) = HIDWORD(v278) ^ *(_DWORD *)&v576[4];
  v279 = (HIDWORD(v586) + (HIDWORD(v278) ^ *(_DWORD *)&v576[4])) ^ v277;
  LODWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[20], HIDWORD(v586)) + v260) >> 32;
  HIDWORD(v51) ^= v87;
  v280 = HIBYTE(v279) | (HIDWORD(v51) << 8);
  v281 = HIBYTE(HIDWORD(v51)) | (v279 << 8);
  v282 = m[9] + v278 + __PAIR64__(v281, v280);
  LODWORD(v260) = v282 ^ HIDWORD(v278) ^ *(_DWORD *)&v576[4];
  HIDWORD(v260) ^= HIDWORD(v282);
  LODWORD(v192) = HIWORD(HIDWORD(v260));
  HIDWORD(v260) = v260 >> 16;
  LODWORD(v260) = v192 | ((_DWORD)v260 << 16);
  v283 = __PAIR64__(v87, HIDWORD(v586) + (HIDWORD(v278) ^ *(_DWORD *)&v576[4])) + __PAIR64__(v260, HIDWORD(v260));
  LODWORD(v87) = (__PAIR64__(v87, HIDWORD(v586) + (HIDWORD(v278) ^ *(_DWORD *)&v576[4]))
                + __PAIR64__(v260, HIDWORD(v260))) >> 32;
  v284 = v283 ^ v280;
  v285 = v87 ^ v281;
  HIDWORD(v51) = 2 * v285;
  v286 = (2 * v284) | (v285 >> 31);
  v287 = HIDWORD(v51) | (v284 >> 31);
  v288 = m[12] + v596 + __PAIR64__(v287, v286);
  HIDWORD(v192) ^= HIDWORD(v288);
  v96 = __CFADD__((_DWORD)v154, HIDWORD(v192));
  LODWORD(v154) = v154 + HIDWORD(v192);
  v289 = v154 ^ v286;
  *(_DWORD *)&v576[4] = HIDWORD(v568) + v96 + (*(_DWORD *)&v570[8] ^ v288);
  v290 = *(_DWORD *)&v576[4] ^ v287;
  HIDWORD(v51) = HIBYTE(v290);
  v291 = HIBYTE(v289) | (v290 << 8);
  v292 = HIDWORD(v51) | (v289 << 8);
  v293 = m[5] + v288 + __PAIR64__(v292, v291);
  HIDWORD(v87) = HIDWORD(v293);
  LODWORD(v192) = v293;
  HIDWORD(v192) ^= v192;
  HIDWORD(v41) = *(_DWORD *)&v570[8] ^ v288 ^ HIDWORD(v87);
  *(_QWORD *)v591 = __PAIR64__(HIDWORD(v87), v192);
  HIDWORD(v87) = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  *(_DWORD *)&v570[8] = HIWORD(HIDWORD(v41)) | (HIDWORD(v192) << 16);
  HIDWORD(v568) = v154 + HIDWORD(v87);
  LODWORD(v643) = HIDWORD(v87);
  LODWORD(v41) = (2 * *(_DWORD *)v570) | ((unsigned int)v575 >> 31);
  HIDWORD(v192) = (2 * v575) | (*(_DWORD *)v570 >> 31);
  *(_DWORD *)v570 = *(_DWORD *)&v570[8] + __CFADD__((_DWORD)v154, HIDWORD(v87)) + *(_DWORD *)&v576[4];
  *(_DWORD *)&v576[4] = (v154 + HIDWORD(v87)) ^ v291;
  LODWORD(v192) = LODWORD(m[1]) + *(_DWORD *)&v591[12];
  HIDWORD(v87) = (v192 + __PAIR64__((m[1] + *(_QWORD *)&v591[12]) >> 32, v41)) >> 32;
  LODWORD(v192) = LODWORD(m[1]) + *(_DWORD *)&v591[12] + v41;
  *(_DWORD *)&v576[16] = *(_DWORD *)v570 ^ v292;
  HIDWORD(v154) = v283 + (v630 ^ HIDWORD(v87));
  LODWORD(v87) = v87 + __CFADD__((_DWORD)v283, v630 ^ HIDWORD(v87)) + (v192 ^ v559);
  HIDWORD(v51) = v41 ^ HIDWORD(v154);
  LODWORD(v41) = HIDWORD(v192) ^ v87;
  HIDWORD(v192) = HIBYTE(HIDWORD(v51)) | ((HIDWORD(v192) ^ (unsigned int)v87) << 8);
  LODWORD(v41) = BYTE3(v41) | (HIDWORD(v51) << 8);
  v294 = m[15] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v41, HIDWORD(v192));
  HIDWORD(v41) = v192 ^ v559 ^ HIDWORD(v294);
  LODWORD(v154) = v630 ^ HIDWORD(v87) ^ v294;
  LODWORD(v575) = WORD1(v154) | (HIDWORD(v41) << 16);
  v631 = HIWORD(HIDWORD(v41)) | ((_DWORD)v154 << 16);
  v295 = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)&v570[4] >> 31);
  v96 = __CFADD__(HIDWORD(v154), (_DWORD)v575);
  v296 = HIDWORD(v154) + v575;
  HIDWORD(v154) = (2 * *(_DWORD *)&v570[4]) | (*(_DWORD *)&v576[8] >> 31);
  *(_DWORD *)&v570[4] = v296;
  *(_DWORD *)&v591[16] = v631 + v96 + (_DWORD)v87;
  HIDWORD(v87) = v296 ^ HIDWORD(v192);
  v297 = m[14] + *(_QWORD *)&v612[4] + __PAIR64__(HIDWORD(v154), v295);
  HIDWORD(v260) ^= v297;
  LODWORD(v260) = HIDWORD(v297) ^ v260;
  v298 = *(_DWORD *)&v591[16] ^ v41;
  v299 = (v264 + v637 + v260) ^ v295;
  HIDWORD(v41) = (__PAIR64__(v569, (int)v264 + v637) + v260) >> 32;
  LODWORD(v154) = v264 + v637 + v260;
  HIDWORD(v154) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v299) | (HIDWORD(v154) << 8);
  v300 = HIBYTE(HIDWORD(v154)) | (v299 << 8);
  v301 = (m[13] + v297 + __PAIR64__(v300, v41)) ^ v260;
  *(_DWORD *)&v591[20] = LODWORD(m[13]) + v297 + v41;
  *(_DWORD *)&v612[4] = (m[13] + v297 + __PAIR64__(v300, v41)) >> 32;
  LODWORD(v568) = v301 >> 16;
  LODWORD(v569) = HIWORD(HIDWORD(v301)) | ((_DWORD)v301 << 16);
  LODWORD(v87) = (2 * *(_DWORD *)&v576[12]) | (HIDWORD(v575) >> 31);
  LODWORD(v51) = (2 * HIDWORD(v575)) | (*(_DWORD *)&v576[12] >> 31);
  v96 = __CFADD__((_DWORD)v154, (_DWORD)v568);
  LODWORD(v154) = v154 + v568;
  HIDWORD(v41) += v96 + (_DWORD)v569;
  v302 = HIDWORD(v41) ^ v300;
  HIDWORD(v575) = v154 ^ v41;
  LODWORD(v192) = (m[4] + v282 + __PAIR64__(v51, v87)) >> 32;
  HIDWORD(v192) = LODWORD(m[4]) + v282 + v87;
  v560 = v87 ^ (*(_DWORD *)v612 + (v192 ^ *(_DWORD *)v576));
  LODWORD(v41) = (__PAIR64__(HIDWORD(v569), *(unsigned int *)v612)
                + __PAIR64__(HIDWORD(v192) ^ (unsigned int)v637, (unsigned int)v192 ^ *(_DWORD *)v576)) >> 32;
  HIDWORD(v154) = *(_DWORD *)v612 + (v192 ^ *(_DWORD *)v576);
  LODWORD(v51) = v41 ^ v51;
  HIDWORD(v569) = BYTE3(v51);
  LODWORD(v51) = HIBYTE(v560) | ((_DWORD)v51 << 8);
  v303 = m[10] + __PAIR64__(v192, HIDWORD(v192));
  LODWORD(v87) = HIDWORD(v569) | (v560 << 8);
  HIDWORD(v51) = (LODWORD(m[10]) + HIDWORD(v192) + v51) ^ v192 ^ *(_DWORD *)v576;
  LODWORD(v192) = v87
                + __CFADD__(LODWORD(m[10]) + HIDWORD(v192), (_DWORD)v51)
                + ((m[10] + __PAIR64__(v192, HIDWORD(v192))) >> 32);
  v587 = __PAIR64__(v192, (int)v303 + (int)v51);
  HIDWORD(v301) = v192 ^ HIDWORD(v192) ^ v637;
  LODWORD(v192) = HIWORD(HIDWORD(v301));
  HIDWORD(v301) = HIWORD(HIDWORD(v51)) | (HIDWORD(v301) << 16);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  LODWORD(v301) = 2 * v298;
  v304 = (2 * HIDWORD(v87)) | (v298 >> 31);
  LODWORD(v301) = v301 | (HIDWORD(v87) >> 31);
  v305 = __PAIR64__(v41, HIDWORD(v154)) + __PAIR64__(HIDWORD(v51), HIDWORD(v301));
  LODWORD(v41) = (__PAIR64__(v41, HIDWORD(v154)) + __PAIR64__(HIDWORD(v51), HIDWORD(v301))) >> 32;
  *(_DWORD *)v576 = v305 ^ v51;
  LODWORD(v192) = (m[0] + *(_QWORD *)v591 + __PAIR64__(v301, v304)) >> 32;
  HIDWORD(v192) = LODWORD(m[0]) + *(_DWORD *)v591 + v304;
  *(_DWORD *)&v576[8] = v87 ^ v41;
  HIDWORD(v51) ^= v192;
  HIDWORD(v301) ^= HIDWORD(v192);
  v306 = (v154 + HIDWORD(v51)) ^ v304;
  v307 = __PAIR64__(HIDWORD(v41), v154) + __PAIR64__(HIDWORD(v301), HIDWORD(v51));
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v154) + __PAIR64__(HIDWORD(v301), HIDWORD(v51))) >> 32;
  LODWORD(v301) = HIDWORD(v41) ^ v301;
  LODWORD(v154) = BYTE3(v301);
  LODWORD(v301) = HIBYTE(v306) | ((_DWORD)v301 << 8);
  v308 = v154 | (v306 << 8);
  v309 = m[7] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v308, v301);
  HIDWORD(v51) ^= v309;
  HIDWORD(v301) ^= HIDWORD(v309);
  v638 = HIWORD(HIDWORD(v51)) | (HIDWORD(v301) << 16);
  HIDWORD(v569) = HIWORD(HIDWORD(v301)) | (HIDWORD(v51) << 16);
  LODWORD(v154) = (2 * v302) | (HIDWORD(v575) >> 31);
  v310 = (2 * HIDWORD(v575)) | (v302 >> 31);
  v561 = HIDWORD(v569) + __CFADD__((_DWORD)v307, v638) + HIDWORD(v41);
  HIDWORD(v575) = (v307 + v638) ^ v301;
  HIDWORD(v87) = (m[6] + v294 + __PAIR64__(v154, v310)) >> 32;
  LODWORD(v192) = LODWORD(m[6]) + v294 + v310;
  LODWORD(v51) = HIDWORD(v87) ^ *(_DWORD *)&v570[8];
  HIDWORD(v154) = v305 + (HIDWORD(v87) ^ *(_DWORD *)&v570[8]);
  v311 = HIDWORD(v154) ^ v310;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v305, HIDWORD(v87) ^ *(_DWORD *)&v570[8]) + (v192 ^ v643);
  LODWORD(v154) = v154 ^ v41;
  v312 = m[3] + __PAIR64__(HIDWORD(v87), v192);
  HIDWORD(v87) = (m[3] + __PAIR64__(HIDWORD(v87), v192)) >> 32;
  *(_DWORD *)&v576[12] = v561 ^ v308;
  v313 = BYTE3(v154);
  LODWORD(v154) = HIBYTE(v311) | ((_DWORD)v154 << 8);
  v314 = v313 | (v311 << 8);
  LODWORD(v51) = (v312 + v154) ^ v51;
  HIDWORD(v41) = v192 ^ v643 ^ (v314 + __CFADD__((_DWORD)v312, (_DWORD)v154) + HIDWORD(v87));
  *(_DWORD *)&v591[12] = v312 + v154;
  *(_DWORD *)v612 = v314 + __CFADD__((_DWORD)v312, (_DWORD)v154) + HIDWORD(v87);
  HIDWORD(v192) = HIWORD(HIDWORD(v41));
  HIDWORD(v41) = WORD1(v51) | (HIDWORD(v41) << 16);
  *(_DWORD *)&v570[8] = HIDWORD(v192) | ((_DWORD)v51 << 16);
  LODWORD(v51) = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)v576 >> 31);
  LODWORD(v87) = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[8] >> 31);
  HIDWORD(v87) = HIDWORD(v154) + HIDWORD(v41);
  v315 = *(_DWORD *)&v570[8] + __CFADD__(HIDWORD(v154), HIDWORD(v41)) + (_DWORD)v41;
  HIDWORD(v154) = *(_DWORD *)&v591[20];
  *(_DWORD *)&v591[20] = HIDWORD(v87);
  *(_DWORD *)v576 = HIDWORD(v87) ^ v154;
  LODWORD(v41) = *(_DWORD *)&v612[4];
  *(_DWORD *)&v612[4] = v315;
  v316 = m[9] + __PAIR64__(v41, HIDWORD(v154));
  LODWORD(v41) = v575;
  v317 = v316 + __PAIR64__(v51, v87);
  LODWORD(v575) = v315 ^ v314;
  v318 = (v316 + v87) ^ v41;
  LODWORD(v41) = ((v316 + __PAIR64__(v51, v87)) >> 32) ^ v631;
  HIDWORD(v87) = (__PAIR64__(*(unsigned int *)v570, HIDWORD(v568)) + __PAIR64__(v318, v41)) >> 32;
  HIDWORD(v301) = HIDWORD(v568) + v41;
  LODWORD(v87) = v87 ^ (HIDWORD(v568) + v41);
  LODWORD(v51) = ((__PAIR64__(*(unsigned int *)v570, HIDWORD(v568))
                 + __PAIR64__(v318, HIDWORD(v317) ^ (unsigned int)v631)) >> 32)
               ^ v51;
  LODWORD(v154) = BYTE3(v51);
  HIDWORD(v51) = (m[2] + v317) >> 32;
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v154) = v154 | ((_DWORD)v87 << 8);
  LODWORD(v41) = v41 ^ (LODWORD(m[2]) + v317 + v51);
  v319 = __PAIR64__(HIDWORD(v154), LODWORD(m[2]) + (int)v317) + v51;
  v320 = ((__PAIR64__(HIDWORD(v154), LODWORD(m[2]) + (int)v317) + v51) >> 32) ^ v318;
  HIDWORD(v643) = HIWORD(v320) | ((_DWORD)v41 << 16);
  LODWORD(v643) = WORD1(v41) | (v320 << 16);
  HIDWORD(v51) = (2 * *(_DWORD *)&v576[16]) | (*(_DWORD *)&v576[4] >> 31);
  v321 = (2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v576[16] >> 31);
  v322 = __PAIR64__(HIDWORD(v87), HIDWORD(v301)) + v643;
  HIDWORD(v87) = (__PAIR64__(HIDWORD(v87), HIDWORD(v301)) + v643) >> 32;
  *(_DWORD *)&v576[4] = v322 ^ v51;
  *(_DWORD *)&v576[8] = HIDWORD(v87) ^ HIDWORD(v154);
  v323 = m[8] + v587 + __PAIR64__(HIDWORD(v51), v321);
  HIDWORD(v301) = v323 ^ v568;
  LODWORD(v301) = HIDWORD(v323) ^ v569;
  v324 = (*(_DWORD *)&v570[4] + (HIDWORD(v323) ^ v569)) ^ v321;
  LODWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[16], *(unsigned int *)&v570[4]) + v301) >> 32;
  HIDWORD(v154) = *(_DWORD *)&v570[4] + (HIDWORD(v323) ^ v569);
  HIDWORD(v51) ^= v87;
  v325 = HIBYTE(v324) | (HIDWORD(v51) << 8);
  v326 = HIBYTE(HIDWORD(v51)) | (v324 << 8);
  v327 = m[11] + v323 + __PAIR64__(v326, v325);
  LODWORD(v301) = v327 ^ HIDWORD(v323) ^ v569;
  HIDWORD(v301) = HIDWORD(v327) ^ v323 ^ v568;
  LODWORD(v192) = HIWORD(HIDWORD(v301));
  HIDWORD(v301) = v301 >> 16;
  LODWORD(v301) = v192 | ((_DWORD)v301 << 16);
  v328 = (HIDWORD(v154) + HIDWORD(v301)) ^ v325;
  v329 = __PAIR64__(v87, HIDWORD(v154)) + __PAIR64__(v301, HIDWORD(v301));
  LODWORD(v87) = (__PAIR64__(v87, HIDWORD(v154)) + __PAIR64__(v301, HIDWORD(v301))) >> 32;
  v330 = v87 ^ v326;
  HIDWORD(v51) = 2 * v330;
  v331 = (2 * v328) | (v330 >> 31);
  v332 = HIDWORD(v51) | (v328 >> 31);
  v333 = m[13] + v309 + __PAIR64__(v332, v331);
  HIDWORD(v41) ^= v333;
  LODWORD(v568) = v322 + (*(_DWORD *)&v570[8] ^ HIDWORD(v333));
  v334 = v568 ^ v331;
  HIDWORD(v87) += __CFADD__((_DWORD)v322, *(_DWORD *)&v570[8] ^ HIDWORD(v333)) + HIDWORD(v41);
  v335 = HIDWORD(v87) ^ v332;
  HIDWORD(v51) = HIBYTE(v335);
  v336 = HIBYTE(v334) | (v335 << 8);
  v337 = HIDWORD(v51) | (v334 << 8);
  HIDWORD(v192) = *(_DWORD *)&v570[8] ^ HIDWORD(v333) ^ (LODWORD(m[11]) + v333 + v336);
  HIDWORD(v41) ^= (m[11] + v333 + __PAIR64__(v337, v336)) >> 32;
  *(_DWORD *)v591 = (m[11] + v333 + __PAIR64__(v337, v336)) >> 32;
  HIDWORD(v587) = LODWORD(m[11]) + v333 + v336;
  v644 = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  *(_DWORD *)v570 = HIWORD(HIDWORD(v41)) | (HIDWORD(v192) << 16);
  LODWORD(v41) = (2 * HIDWORD(v575)) | (*(_DWORD *)&v576[12] >> 31);
  HIDWORD(v192) = (2 * *(_DWORD *)&v576[12]) | (HIDWORD(v575) >> 31);
  v96 = __CFADD__((_DWORD)v568, v644);
  LODWORD(v568) = v568 + v644;
  HIDWORD(v568) = *(_DWORD *)v570 + v96 + HIDWORD(v87);
  HIDWORD(v575) = v568 ^ v336;
  LODWORD(v192) = LODWORD(m[7]) + *(_DWORD *)&v591[12];
  HIDWORD(v87) = (v192 + __PAIR64__((m[7] + __PAIR64__(*(unsigned int *)v612, *(unsigned int *)&v591[12])) >> 32, v41)) >> 32;
  LODWORD(v192) = LODWORD(m[7]) + *(_DWORD *)&v591[12] + v41;
  *(_DWORD *)&v576[12] = HIDWORD(v568) ^ v337;
  HIDWORD(v154) = v329 + (HIDWORD(v643) ^ HIDWORD(v87));
  LODWORD(v87) = v87 + __CFADD__((_DWORD)v329, HIDWORD(v643) ^ HIDWORD(v87)) + (v192 ^ v643);
  LODWORD(v41) = v41 ^ HIDWORD(v154);
  HIDWORD(v51) = HIDWORD(v192) ^ v87;
  HIDWORD(v192) = BYTE3(v41) | ((HIDWORD(v192) ^ (unsigned int)v87) << 8);
  LODWORD(v41) = HIBYTE(HIDWORD(v51)) | ((_DWORD)v41 << 8);
  LODWORD(v154) = HIDWORD(v643) ^ HIDWORD(v87) ^ (LODWORD(m[14]) + v192 + HIDWORD(v192));
  *(_DWORD *)&v591[4] = LODWORD(m[14]) + v192 + HIDWORD(v192);
  *(_DWORD *)&v591[12] = (m[14] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v41, HIDWORD(v192))) >> 32;
  HIDWORD(v41) = v192 ^ v643 ^ *(_DWORD *)&v591[12];
  *(_DWORD *)&v570[4] = WORD1(v154) | (HIDWORD(v41) << 16);
  LODWORD(v643) = HIWORD(HIDWORD(v41)) | ((_DWORD)v154 << 16);
  v338 = (2 * *(_DWORD *)v576) | ((unsigned int)v575 >> 31);
  v96 = __CFADD__(HIDWORD(v154), *(_DWORD *)&v570[4]);
  v339 = HIDWORD(v154) + *(_DWORD *)&v570[4];
  HIDWORD(v154) = (2 * v575) | (*(_DWORD *)v576 >> 31);
  LODWORD(v569) = v339;
  LODWORD(v154) = v643 + v96 + (_DWORD)v87;
  LODWORD(v87) = v339;
  v340 = v154 ^ v41;
  *(_DWORD *)&v591[16] = v154;
  HIDWORD(v87) = v87 ^ HIDWORD(v192);
  v341 = m[12] + v319 + __PAIR64__(HIDWORD(v154), v338);
  LODWORD(v301) = HIDWORD(v341) ^ v301;
  HIDWORD(v301) ^= v341;
  v342 = (v307 + v638 + v301) ^ v338;
  HIDWORD(v41) = (__PAIR64__(v561, (int)v307 + v638) + v301) >> 32;
  LODWORD(v154) = v307 + v638 + v301;
  HIDWORD(v154) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v342) | (HIDWORD(v154) << 8);
  v343 = HIBYTE(HIDWORD(v154)) | (v342 << 8);
  v344 = (m[1] + v341 + __PAIR64__(v343, v41)) ^ v301;
  *(_DWORD *)&v591[8] = LODWORD(m[1]) + v341 + v41;
  *(_DWORD *)v612 = (m[1] + v341 + __PAIR64__(v343, v41)) >> 32;
  *(_DWORD *)&v570[8] = v344 >> 16;
  LODWORD(v87) = (2 * (v322 ^ v51)) | (*(_DWORD *)&v576[8] >> 31);
  LODWORD(v575) = HIWORD(HIDWORD(v344)) | ((_DWORD)v344 << 16);
  HIDWORD(v154) = v575;
  v345 = v154 + __PAIR64__(HIDWORD(v41), *(unsigned int *)&v570[8]);
  v346 = HIDWORD(v345) ^ v343;
  *(_DWORD *)v576 = v345 ^ v41;
  HIDWORD(v344) = (LODWORD(m[3]) + v327 + v87) ^ v638;
  HIDWORD(v41) = HIDWORD(v569);
  LODWORD(v192) = (m[3] + v327 + ((2LL * *(_QWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31))) >> 32;
  HIDWORD(v192) = LODWORD(m[3]) + v327 + v87;
  HIDWORD(v569) = HIDWORD(v345);
  HIDWORD(v51) = v192 ^ HIDWORD(v41);
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[20] + (v192 ^ HIDWORD(v41)));
  LODWORD(v41) = (__PAIR64__(*(unsigned int *)&v612[4], *(unsigned int *)&v591[20])
                + __PAIR64__(HIDWORD(v344), (unsigned int)v192 ^ HIDWORD(v41))) >> 32;
  HIDWORD(v345) = *(_DWORD *)&v591[20] + (v192 ^ HIDWORD(v41));
  LODWORD(v51) = v41 ^ (*(__int64 *)&v576[4] >> 31);
  HIDWORD(v41) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  LODWORD(v87) = HIDWORD(v41) | ((_DWORD)v87 << 8);
  HIDWORD(v51) ^= LODWORD(m[9]) + HIDWORD(v192) + v51;
  v347 = m[9] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v87, v51);
  HIDWORD(v192) = HIDWORD(v347);
  LODWORD(v587) = v347;
  HIDWORD(v344) ^= HIDWORD(v192);
  *(_DWORD *)&v591[20] = HIDWORD(v192);
  LODWORD(v192) = HIWORD(HIDWORD(v344));
  LODWORD(v344) = (2 * v340) | (HIDWORD(v87) >> 31);
  HIDWORD(v344) = HIWORD(HIDWORD(v51)) | (HIDWORD(v344) << 16);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  v348 = __PAIR64__(v41, HIDWORD(v345)) + __PAIR64__(HIDWORD(v51), HIDWORD(v344));
  LODWORD(v41) = (__PAIR64__(v41, HIDWORD(v345)) + __PAIR64__(HIDWORD(v51), HIDWORD(v344))) >> 32;
  v349 = (2 * HIDWORD(v87)) | (v340 >> 31);
  *(_DWORD *)&v576[8] = v87 ^ v41;
  LODWORD(v192) = (m[5] + __PAIR64__(*(unsigned int *)v591, HIDWORD(v587)) + __PAIR64__(v344, v349)) >> 32;
  HIDWORD(v192) = LODWORD(m[5]) + HIDWORD(v587) + v349;
  HIDWORD(v344) ^= HIDWORD(v192);
  HIDWORD(v51) ^= v192;
  *(_DWORD *)&v576[4] = v348 ^ v51;
  v350 = (v345 + HIDWORD(v51)) ^ v349;
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v569), v345) + __PAIR64__(HIDWORD(v344), HIDWORD(v51))) >> 32;
  HIDWORD(v87) = v345 + HIDWORD(v51);
  LODWORD(v344) = HIDWORD(v41) ^ v344;
  LODWORD(v345) = BYTE3(v344);
  LODWORD(v344) = HIBYTE(v350) | ((_DWORD)v344 << 8);
  v351 = v345 | (v350 << 8);
  HIDWORD(v51) ^= LODWORD(m[0]) + HIDWORD(v192) + v344;
  HIDWORD(v344) ^= (m[0] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v351, v344)) >> 32;
  HIDWORD(v587) = LODWORD(m[0]) + HIDWORD(v192) + v344;
  *(_DWORD *)v591 = (m[0] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v351, v344)) >> 32;
  v639 = HIWORD(HIDWORD(v51)) | (HIDWORD(v344) << 16);
  HIDWORD(v569) = HIWORD(HIDWORD(v344)) | (HIDWORD(v51) << 16);
  LODWORD(v87) = HIDWORD(v87) + v639;
  LODWORD(v345) = (2 * v346) | (*(_DWORD *)v576 >> 31);
  v352 = (2 * *(_DWORD *)v576) | (v346 >> 31);
  LODWORD(v51) = HIDWORD(v569) + __CFADD__(HIDWORD(v87), v639) + HIDWORD(v41);
  HIDWORD(v87) = *(_DWORD *)&v591[4];
  v562 = v51;
  *(_DWORD *)&v591[4] = v87;
  *(_DWORD *)v576 = v87 ^ v344;
  v353 = m[15] + __PAIR64__(*(unsigned int *)&v591[12], HIDWORD(v87)) + __PAIR64__(v345, v352);
  HIDWORD(v87) = HIDWORD(v353);
  LODWORD(v192) = v353;
  LODWORD(v51) = HIDWORD(v87) ^ *(_DWORD *)v570;
  HIDWORD(v345) = v348 + (HIDWORD(v87) ^ *(_DWORD *)v570);
  v354 = HIDWORD(v345) ^ v352;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v348, HIDWORD(v87) ^ *(_DWORD *)v570) + (v192 ^ v644);
  LODWORD(v345) = v345 ^ v41;
  *(_DWORD *)&v576[16] = v562 ^ v351;
  v355 = BYTE3(v345);
  LODWORD(v345) = HIBYTE(v354) | ((_DWORD)v345 << 8);
  v356 = m[4] + __PAIR64__(HIDWORD(v87), v192);
  HIDWORD(v87) = (m[4] + __PAIR64__(HIDWORD(v87), v192)) >> 32;
  v357 = v355 | (v354 << 8);
  LODWORD(v51) = (v356 + v345) ^ v51;
  HIDWORD(v41) = v192 ^ v644 ^ (v357 + __CFADD__((_DWORD)v356, (_DWORD)v345) + HIDWORD(v87));
  *(_DWORD *)&v612[4] = v357 + __CFADD__((_DWORD)v356, (_DWORD)v345) + HIDWORD(v87);
  *(_DWORD *)&v591[12] = v356 + v345;
  HIDWORD(v192) = HIWORD(HIDWORD(v41)) | ((_DWORD)v51 << 16);
  HIDWORD(v41) = WORD1(v51) | (HIDWORD(v41) << 16);
  LODWORD(v51) = *(__int64 *)&v576[4] >> 31;
  LODWORD(v192) = *(_DWORD *)&v591[8];
  LODWORD(v87) = (2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v576[8] >> 31);
  *(_DWORD *)&v591[8] = HIDWORD(v345) + HIDWORD(v41);
  *(_DWORD *)&v576[4] = (HIDWORD(v345) + HIDWORD(v41)) ^ v345;
  v358 = m[8] + __PAIR64__(*(unsigned int *)v612, v192) + __PAIR64__(v51, v87);
  v359 = v358 ^ *(_DWORD *)&v570[4];
  *(_DWORD *)v612 = HIDWORD(v192) + __CFADD__(HIDWORD(v345), HIDWORD(v41)) + (_DWORD)v41;
  *(_DWORD *)&v570[4] = *(_DWORD *)v612 ^ v357;
  LODWORD(v87) = v87 ^ (v568 + (HIDWORD(v358) ^ v643));
  HIDWORD(v87) = (v568 + __PAIR64__(v359, HIDWORD(v358) ^ (unsigned int)v643)) >> 32;
  HIDWORD(v344) = v568 + (HIDWORD(v358) ^ v643);
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v51) = (m[6] + v358) >> 32;
  HIDWORD(v345) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v345) |= (_DWORD)v87 << 8;
  LODWORD(v41) = HIDWORD(v358) ^ v643 ^ (LODWORD(m[6]) + v358 + v51);
  v360 = ((__PAIR64__(HIDWORD(v345), LODWORD(m[6]) + (int)v358) + v51) >> 32) ^ v359;
  LODWORD(v87) = HIDWORD(v575);
  LODWORD(v345) = HIWORD(v360) | ((_DWORD)v41 << 16);
  *(_DWORD *)&v576[8] = WORD1(v41) | (v360 << 16);
  *(_QWORD *)&v612[8] = __PAIR64__(HIDWORD(v345), LODWORD(m[6]) + (int)v358) + v51;
  v361 = (2 * HIDWORD(v575)) | (*(_DWORD *)&v576[12] >> 31);
  LODWORD(v568) = HIDWORD(v344) + *(_DWORD *)&v576[8];
  LODWORD(v643) = v345;
  HIDWORD(v87) += __CFADD__(HIDWORD(v344), *(_DWORD *)&v576[8]) + (_DWORD)v345;
  HIDWORD(v575) = (HIDWORD(v344) + *(_DWORD *)&v576[8]) ^ v51;
  HIDWORD(v51) = (2 * *(_DWORD *)&v576[12]) | ((unsigned int)v87 >> 31);
  LODWORD(v41) = (m[2] + __PAIR64__(*(unsigned int *)&v591[20], v587) + __PAIR64__(HIDWORD(v51), v361)) >> 32;
  LODWORD(v345) = LODWORD(m[2]) + v587 + v361;
  HIDWORD(v344) = v345 ^ *(_DWORD *)&v570[8];
  LODWORD(v344) = v41 ^ v575;
  LODWORD(v575) = HIDWORD(v87) ^ HIDWORD(v345);
  LODWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[16], v569) + v344) >> 32;
  HIDWORD(v345) = v569 + v344;
  v362 = (v569 + v344) ^ v361;
  HIDWORD(v51) ^= v87;
  v363 = HIBYTE(v362) | (HIDWORD(v51) << 8);
  v364 = HIBYTE(HIDWORD(v51)) | (v362 << 8);
  v365 = m[10] + __PAIR64__(v41, v345) + __PAIR64__(v364, v363);
  v366 = v365 ^ v344;
  LODWORD(v192) = HIWORD(HIDWORD(v366));
  HIDWORD(v366) = v366 >> 16;
  LODWORD(v366) = v192 | ((_DWORD)v366 << 16);
  v367 = HIDWORD(v345);
  HIDWORD(v345) += HIDWORD(v366);
  v368 = HIDWORD(v345) ^ v363;
  HIDWORD(v568) = HIDWORD(v345);
  LODWORD(v87) = (__PAIR64__(v87, v367) + __PAIR64__(v366, HIDWORD(v366))) >> 32;
  v369 = v87 ^ v364;
  HIDWORD(v51) = 2 * v369;
  v370 = (2 * v368) | (v369 >> 31);
  v371 = HIDWORD(v51) | (v368 >> 31);
  v372 = m[6] + __PAIR64__(*(unsigned int *)v591, HIDWORD(v587)) + __PAIR64__(v371, v370);
  HIDWORD(v41) ^= v372;
  LODWORD(v345) = v568 + (HIDWORD(v192) ^ HIDWORD(v372));
  HIDWORD(v87) += __CFADD__((_DWORD)v568, HIDWORD(v192) ^ HIDWORD(v372)) + HIDWORD(v41);
  v373 = v345 ^ v370;
  v374 = HIDWORD(v87) ^ v371;
  HIDWORD(v51) = HIBYTE(v374);
  v375 = HIBYTE(v373) | (v374 << 8);
  v376 = HIDWORD(v51) | (v373 << 8);
  HIDWORD(v192) ^= HIDWORD(v372) ^ (LODWORD(m[15]) + v372 + v375);
  HIDWORD(v41) ^= (m[15] + v372 + __PAIR64__(v376, v375)) >> 32;
  *(_DWORD *)v591 = (m[15] + v372 + __PAIR64__(v376, v375)) >> 32;
  HIDWORD(v587) = LODWORD(m[15]) + v372 + v375;
  LODWORD(v569) = HIWORD(HIDWORD(v41)) | (HIDWORD(v192) << 16);
  HIDWORD(v643) = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  LODWORD(v41) = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[16] >> 31);
  HIDWORD(v192) = (2 * *(_DWORD *)&v576[16]) | (*(_DWORD *)v576 >> 31);
  HIDWORD(v345) = *(_DWORD *)&v591[12];
  LODWORD(v568) = v569 + __CFADD__((_DWORD)v345, HIDWORD(v643)) + HIDWORD(v87);
  *(_DWORD *)&v591[12] = v345 + HIDWORD(v643);
  *(_DWORD *)v576 = (v345 + HIDWORD(v643)) ^ v375;
  LODWORD(v192) = LODWORD(m[14]) + HIDWORD(v345);
  HIDWORD(v87) = (v192 + __PAIR64__((m[14] + __PAIR64__(*(unsigned int *)&v612[4], HIDWORD(v345))) >> 32, v41)) >> 32;
  LODWORD(v192) = LODWORD(m[14]) + HIDWORD(v345) + v41;
  HIDWORD(v41) = v192 ^ *(_DWORD *)&v576[8];
  *(_DWORD *)&v576[8] = v568 ^ v376;
  HIDWORD(v51) = HIDWORD(v568) + (HIDWORD(v87) ^ v643);
  LODWORD(v41) = v41 ^ HIDWORD(v51);
  LODWORD(v87) = v87 + __CFADD__(HIDWORD(v568), HIDWORD(v87) ^ v643) + HIDWORD(v41);
  HIDWORD(v192) ^= v87;
  LODWORD(v51) = HIBYTE(HIDWORD(v192));
  HIDWORD(v192) = BYTE3(v41) | (HIDWORD(v192) << 8);
  LODWORD(v41) = v51 | ((_DWORD)v41 << 8);
  LODWORD(v345) = HIDWORD(v87) ^ v643 ^ (LODWORD(m[9]) + v192 + HIDWORD(v192));
  HIDWORD(v41) ^= (m[9] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v41, HIDWORD(v192))) >> 32;
  *(_DWORD *)&v591[16] = (m[9] + __PAIR64__(HIDWORD(v87), v192) + __PAIR64__(v41, HIDWORD(v192))) >> 32;
  *(_DWORD *)&v576[16] = LODWORD(m[9]) + v192 + HIDWORD(v192);
  HIDWORD(v87) = WORD1(v345) | (HIDWORD(v41) << 16);
  *(_DWORD *)v570 = HIWORD(HIDWORD(v41)) | ((_DWORD)v345 << 16);
  v96 = __CFADD__(HIDWORD(v51), HIDWORD(v87));
  LODWORD(v643) = HIDWORD(v87);
  HIDWORD(v568) = HIDWORD(v51) + HIDWORD(v87);
  v377 = (2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v570[4] >> 31);
  HIDWORD(v345) = (2 * *(_DWORD *)&v570[4]) | (*(_DWORD *)&v576[4] >> 31);
  HIDWORD(v87) = (HIDWORD(v51) + HIDWORD(v87)) ^ HIDWORD(v192);
  LODWORD(v87) = *(_DWORD *)v570 + v96 + (_DWORD)v87;
  v378 = v87 ^ v41;
  *(_DWORD *)&v591[20] = v87;
  v379 = m[11] + *(_QWORD *)&v612[8] + __PAIR64__(HIDWORD(v345), v377);
  HIDWORD(v366) ^= v379;
  LODWORD(v366) = HIDWORD(v379) ^ v366;
  v380 = (*(_DWORD *)&v591[4] + v366) ^ v377;
  HIDWORD(v41) = (__PAIR64__(v562, *(unsigned int *)&v591[4]) + v366) >> 32;
  LODWORD(v345) = *(_DWORD *)&v591[4] + v366;
  HIDWORD(v345) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v380) | (HIDWORD(v345) << 8);
  v381 = HIBYTE(HIDWORD(v345)) | (v380 << 8);
  v382 = (m[3] + v379 + __PAIR64__(v381, v41)) ^ v366;
  *(_DWORD *)&v591[4] = LODWORD(m[3]) + v379 + v41;
  *(_DWORD *)&v612[4] = (m[3] + v379 + __PAIR64__(v381, v41)) >> 32;
  *(_DWORD *)&v570[4] = v382 >> 16;
  *(_DWORD *)&v570[8] = HIWORD(HIDWORD(v382)) | ((_DWORD)v382 << 16);
  LODWORD(v87) = v575 >> 31;
  LODWORD(v51) = (2 * v575) | (HIDWORD(v575) >> 31);
  v383 = __PAIR64__(HIDWORD(v41), v345) + *(_QWORD *)&v570[4];
  v563 = HIDWORD(v383);
  LODWORD(v575) = v383 ^ v41;
  HIDWORD(v382) = (LODWORD(m[0]) + v365 + v87) ^ v639;
  LODWORD(v192) = (m[0] + v365 + __PAIR64__(v51, v87)) >> 32;
  HIDWORD(v192) = LODWORD(m[0]) + v365 + v87;
  v384 = HIDWORD(v383) ^ v381;
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[8] + (v192 ^ HIDWORD(v569)));
  LODWORD(v41) = (__PAIR64__(*(unsigned int *)v612, *(unsigned int *)&v591[8])
                + __PAIR64__(HIDWORD(v382), (unsigned int)v192 ^ HIDWORD(v569))) >> 32;
  HIDWORD(v383) = *(_DWORD *)&v591[8] + (v192 ^ HIDWORD(v569));
  LODWORD(v51) = v41 ^ v51;
  HIDWORD(v41) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v51) = (LODWORD(m[8]) + HIDWORD(v192) + v51) ^ v192 ^ HIDWORD(v569);
  LODWORD(v587) = LODWORD(m[8]) + HIDWORD(v192) + v51;
  LODWORD(v87) = HIDWORD(v41) | ((_DWORD)v87 << 8);
  LODWORD(v192) = v87
                + __CFADD__(LODWORD(m[8]) + HIDWORD(v192), (_DWORD)v51)
                + ((m[8] + __PAIR64__(v192, HIDWORD(v192))) >> 32);
  HIDWORD(v382) ^= v192;
  *(_DWORD *)&v591[8] = v192;
  LODWORD(v192) = HIWORD(HIDWORD(v382));
  HIDWORD(v382) = HIWORD(HIDWORD(v51)) | (HIDWORD(v382) << 16);
  LODWORD(v382) = (2 * v378) | (HIDWORD(v87) >> 31);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  v385 = (2 * HIDWORD(v87)) | (v378 >> 31);
  v386 = __PAIR64__(v41, HIDWORD(v383)) + __PAIR64__(HIDWORD(v51), HIDWORD(v382));
  LODWORD(v41) = (__PAIR64__(v41, HIDWORD(v383)) + __PAIR64__(HIDWORD(v51), HIDWORD(v382))) >> 32;
  HIDWORD(v575) = v386 ^ v51;
  LODWORD(v87) = v87 ^ v41;
  LODWORD(v192) = (m[12] + __PAIR64__(*(unsigned int *)v591, HIDWORD(v587)) + __PAIR64__(v382, v385)) >> 32;
  HIDWORD(v192) = LODWORD(m[12]) + HIDWORD(v587) + v385;
  HIDWORD(v382) ^= HIDWORD(v192);
  HIDWORD(v51) ^= v192;
  v387 = (v383 + HIDWORD(v51)) ^ v385;
  HIDWORD(v41) = (__PAIR64__(v563, v383) + __PAIR64__(HIDWORD(v382), HIDWORD(v51))) >> 32;
  HIDWORD(v87) = v383 + HIDWORD(v51);
  LODWORD(v382) = HIDWORD(v41) ^ v382;
  LODWORD(v383) = BYTE3(v382);
  LODWORD(v382) = HIBYTE(v387) | ((_DWORD)v382 << 8);
  v388 = v383 | (v387 << 8);
  HIDWORD(v51) ^= LODWORD(m[2]) + HIDWORD(v192) + v382;
  v389 = m[2] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v388, v382);
  HIDWORD(v192) = HIDWORD(v389);
  HIDWORD(v587) = v389;
  HIDWORD(v382) ^= HIDWORD(v192);
  *(_DWORD *)v591 = HIDWORD(v192);
  HIDWORD(v569) = HIWORD(HIDWORD(v51)) | (HIDWORD(v382) << 16);
  LODWORD(v192) = v575;
  LODWORD(v575) = HIWORD(HIDWORD(v382)) | (HIDWORD(v51) << 16);
  LODWORD(v383) = (2 * v384) | ((unsigned int)v192 >> 31);
  v390 = (2 * v192) | (v384 >> 31);
  v96 = __CFADD__(HIDWORD(v87), HIDWORD(v569));
  *(_DWORD *)v612 = HIDWORD(v87) + HIDWORD(v569);
  *(_DWORD *)&v576[4] = (HIDWORD(v87) + HIDWORD(v569)) ^ v382;
  HIDWORD(v87) = (m[13] + __PAIR64__(*(unsigned int *)&v591[16], *(unsigned int *)&v576[16]) + __PAIR64__(v383, v390)) >> 32;
  LODWORD(v192) = LODWORD(m[13]) + *(_DWORD *)&v576[16] + v390;
  v564 = v575 + v96 + HIDWORD(v41);
  HIDWORD(v383) = v386 + (HIDWORD(v87) ^ v569);
  v391 = HIDWORD(v383) ^ v390;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v386, HIDWORD(v87) ^ v569) + (v192 ^ HIDWORD(v643));
  LODWORD(v383) = v383 ^ v41;
  *(_DWORD *)&v576[12] = v564 ^ v388;
  v392 = BYTE3(v383);
  LODWORD(v383) = HIBYTE(v391) | ((_DWORD)v383 << 8);
  HIDWORD(v192) = HIDWORD(m[7]);
  v393 = v392 | (v391 << 8);
  LODWORD(v51) = (LODWORD(m[7]) + v192 + v383) ^ HIDWORD(v87) ^ v569;
  v394 = __PAIR64__(HIDWORD(v87), m[7]) + v192 + __PAIR64__(v393, v383);
  *(_DWORD *)&v612[8] = HIDWORD(v394);
  *(_DWORD *)&v591[16] = v394;
  HIDWORD(v192) = (((unsigned int)v192 ^ HIDWORD(v643) ^ *(_DWORD *)&v612[8]) >> 16) | ((_DWORD)v51 << 16);
  v640 = WORD1(v51) | (((unsigned int)v192 ^ HIDWORD(v643) ^ *(_DWORD *)&v612[8]) << 16);
  LODWORD(v51) = (2 * v87) | (HIDWORD(v575) >> 31);
  LODWORD(v87) = (2 * HIDWORD(v575)) | ((unsigned int)v87 >> 31);
  LODWORD(v192) = *(_DWORD *)&v591[4];
  *(_DWORD *)&v591[4] = HIDWORD(v383) + v640;
  HIDWORD(v575) = (HIDWORD(v383) + v640) ^ v383;
  v395 = m[1] + __PAIR64__(*(unsigned int *)&v612[4], v192);
  *(_DWORD *)&v612[4] = HIDWORD(v192) + __CFADD__(HIDWORD(v383), v640) + (_DWORD)v41;
  v396 = v395 + __PAIR64__(v51, v87);
  *(_DWORD *)&v576[16] = *(_DWORD *)&v612[4] ^ v393;
  v397 = (v395 + v87) ^ v643;
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[12] + (((v395 + __PAIR64__(v51, v87)) >> 32) ^ *(_DWORD *)v570));
  HIDWORD(v87) = (__PAIR64__(v568, *(unsigned int *)&v591[12])
                + __PAIR64__((unsigned int)v396 ^ (unsigned int)v643, HIDWORD(v396) ^ *(_DWORD *)v570)) >> 32;
  LODWORD(v383) = *(_DWORD *)&v591[12] + (HIDWORD(v396) ^ *(_DWORD *)v570);
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v51) = (m[4] + v396) >> 32;
  HIDWORD(v383) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v383) |= (_DWORD)v87 << 8;
  LODWORD(v41) = HIDWORD(v396) ^ *(_DWORD *)v570 ^ (LODWORD(m[4]) + v396 + v51);
  v398 = ((__PAIR64__(HIDWORD(v383), LODWORD(m[4]) + (int)v396) + v51) >> 32) ^ v397;
  *(_DWORD *)&v612[12] = (__PAIR64__(HIDWORD(v383), LODWORD(m[4]) + (int)v396) + v51) >> 32;
  LODWORD(v569) = WORD1(v41) | (v398 << 16);
  *(_DWORD *)&v591[12] = LODWORD(m[4]) + v396 + v51;
  LODWORD(v643) = HIWORD(v398) | ((_DWORD)v41 << 16);
  v399 = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[8] >> 31);
  HIDWORD(v51) = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)v576 >> 31);
  v96 = __CFADD__((_DWORD)v383, (_DWORD)v569);
  LODWORD(v383) = v383 + v569;
  HIDWORD(v87) += v96 + (_DWORD)v643;
  *(_DWORD *)v576 = v383 ^ v51;
  HIDWORD(v382) = (LODWORD(m[10]) + v587 + v399) ^ *(_DWORD *)&v570[4];
  v400 = m[10] + __PAIR64__(*(unsigned int *)&v591[8], v587) + __PAIR64__(HIDWORD(v51), v399);
  *(_DWORD *)&v576[8] = HIDWORD(v87) ^ HIDWORD(v383);
  LODWORD(v382) = HIDWORD(v400) ^ *(_DWORD *)&v570[8];
  v401 = (HIDWORD(v568) + (HIDWORD(v400) ^ *(_DWORD *)&v570[8])) ^ v399;
  LODWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[20], HIDWORD(v568)) + v382) >> 32;
  HIDWORD(v51) ^= v87;
  v402 = HIBYTE(v401) | (HIDWORD(v51) << 8);
  v403 = HIBYTE(HIDWORD(v51)) | (v401 << 8);
  v404 = m[5] + v400 + __PAIR64__(v403, v402);
  *(_DWORD *)&v591[8] = HIDWORD(v404);
  LODWORD(v192) = v404;
  LODWORD(v382) = v192 ^ HIDWORD(v400) ^ *(_DWORD *)&v570[8];
  HIDWORD(v382) ^= v403 + __CFADD__(LODWORD(m[5]) + v400, v402) + ((m[5] + v400) >> 32);
  LODWORD(v587) = LODWORD(m[5]) + v400 + v402;
  LODWORD(v192) = HIWORD(HIDWORD(v382));
  HIDWORD(v382) = v382 >> 16;
  LODWORD(v382) = v192 | ((_DWORD)v382 << 16);
  v405 = ((__PAIR64__(v87, HIDWORD(v568) + (HIDWORD(v400) ^ *(_DWORD *)&v570[8])) + __PAIR64__(v382, HIDWORD(v382))) >> 32)
       ^ v403;
  v406 = (HIDWORD(v568) + (HIDWORD(v400) ^ *(_DWORD *)&v570[8]) + HIDWORD(v382)) ^ v402;
  HIDWORD(v51) = 2 * v405;
  v407 = (2 * v406) | (v405 >> 31);
  v408 = HIDWORD(v51) | (v406 >> 31);
  v409 = m[10] + __PAIR64__(*(unsigned int *)v591, HIDWORD(v587)) + __PAIR64__(v408, v407);
  HIDWORD(v192) ^= HIDWORD(v409);
  v96 = __CFADD__((_DWORD)v383, HIDWORD(v192));
  LODWORD(v383) = v383 + HIDWORD(v192);
  v410 = v383 ^ v407;
  HIDWORD(v87) += v96 + (v640 ^ v409);
  v411 = HIDWORD(v87) ^ v408;
  HIDWORD(v51) = HIBYTE(v411);
  v412 = HIBYTE(v410) | (v411 << 8);
  v413 = HIDWORD(v51) | (v410 << 8);
  v414 = m[2] + v409 + __PAIR64__(v413, v412);
  HIDWORD(v192) ^= v414;
  HIDWORD(v41) = v640 ^ v409 ^ HIDWORD(v414);
  HIDWORD(v587) = LODWORD(m[2]) + v409 + v412;
  LODWORD(v192) = HIWORD(HIDWORD(v41));
  HIDWORD(v41) = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  *(_DWORD *)v570 = v192 | (HIDWORD(v192) << 16);
  v96 = __CFADD__((_DWORD)v383, HIDWORD(v41));
  v641 = HIDWORD(v41);
  HIDWORD(v41) += v383;
  LODWORD(v41) = (2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v576[12] >> 31);
  HIDWORD(v192) = (2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)&v576[4] >> 31);
  v415 = *(_DWORD *)&v591[16];
  LODWORD(v568) = *(_DWORD *)v570 + v96 + HIDWORD(v87);
  LODWORD(v51) = HIDWORD(v41) ^ v412;
  *(_DWORD *)&v591[16] = HIDWORD(v41);
  HIDWORD(v41) = (LODWORD(m[8]) + v415 + v41) ^ v569;
  v416 = m[8] + __PAIR64__(*(unsigned int *)&v612[8], v415) + __PAIR64__(HIDWORD(v192), v41);
  *(_DWORD *)&v576[4] = v51;
  v417 = __PAIR64__(v87, HIDWORD(v568) + (HIDWORD(v400) ^ *(_DWORD *)&v570[8]))
       + __PAIR64__(v382, HIDWORD(v382))
       + __PAIR64__(HIDWORD(v41), HIDWORD(v416) ^ (unsigned int)v643);
  LODWORD(v87) = HIDWORD(v417);
  HIDWORD(v383) = v417;
  *(_DWORD *)&v576[12] = v568 ^ v413;
  LODWORD(v41) = v41 ^ HIDWORD(v383);
  HIDWORD(v192) ^= v87;
  LODWORD(v51) = HIBYTE(HIDWORD(v192));
  HIDWORD(v192) = BYTE3(v41) | (HIDWORD(v192) << 8);
  LODWORD(v41) = v51 | ((_DWORD)v41 << 8);
  LODWORD(v383) = HIDWORD(v416) ^ v643 ^ (LODWORD(m[4]) + v416 + HIDWORD(v192));
  HIDWORD(v41) ^= (_DWORD)v41 + __CFADD__(LODWORD(m[4]) + v416, HIDWORD(v192)) + ((m[4] + v416) >> 32);
  v418 = m[4] + v416 + __PAIR64__(v41, HIDWORD(v192));
  *(_DWORD *)&v612[8] = HIDWORD(v418);
  *(_DWORD *)&v591[20] = v418;
  *(_DWORD *)&v570[4] = WORD1(v383) | (HIDWORD(v41) << 16);
  LODWORD(v643) = HIWORD(HIDWORD(v41)) | ((_DWORD)v383 << 16);
  v419 = (2 * HIDWORD(v575)) | (*(_DWORD *)&v576[16] >> 31);
  v96 = __CFADD__(HIDWORD(v383), *(_DWORD *)&v570[4]);
  v420 = HIDWORD(v383) + *(_DWORD *)&v570[4];
  HIDWORD(v383) = (2 * *(_DWORD *)&v576[16]) | (HIDWORD(v575) >> 31);
  HIDWORD(v568) = v420;
  v421 = (v643 + v96 + (_DWORD)v87) ^ v41;
  v422 = __PAIR64__(*(unsigned int *)v612, *(unsigned int *)&v591[12]);
  HIDWORD(v87) = HIDWORD(v568) ^ HIDWORD(v192);
  *(_DWORD *)&v591[12] = v643 + v96 + (_DWORD)v87;
  v423 = m[7] + __PAIR64__(*(unsigned int *)&v612[12], v422) + __PAIR64__(HIDWORD(v383), v419);
  HIDWORD(v382) ^= v423;
  LODWORD(v382) = HIDWORD(v423) ^ v382;
  v424 = (*(_DWORD *)v612 + v382) ^ v419;
  HIDWORD(v41) = (__PAIR64__(v564, *(unsigned int *)v612) + v382) >> 32;
  LODWORD(v383) = *(_DWORD *)v612 + v382;
  HIDWORD(v383) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v424) | (HIDWORD(v383) << 8);
  v425 = HIBYTE(HIDWORD(v383)) | (v424 << 8);
  v426 = (m[6] + v423 + __PAIR64__(v425, v41)) ^ v382;
  *(_DWORD *)v612 = LODWORD(m[6]) + v423 + v41;
  *(_DWORD *)&v570[8] = v426 >> 16;
  *(_DWORD *)&v612[12] = (m[6] + v423 + __PAIR64__(v425, v41)) >> 32;
  HIDWORD(v575) = HIWORD(HIDWORD(v426)) | ((_DWORD)v426 << 16);
  LODWORD(v87) = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[8] >> 31);
  LODWORD(v51) = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)v576 >> 31);
  *(_DWORD *)v576 = v383 + *(_DWORD *)&v570[8];
  HIDWORD(v41) += __CFADD__((_DWORD)v383, *(_DWORD *)&v570[8]) + HIDWORD(v575);
  v427 = HIDWORD(v41) ^ v425;
  LODWORD(v569) = (v383 + *(_DWORD *)&v570[8]) ^ v41;
  HIDWORD(v426) = (LODWORD(m[1]) + v587 + v87) ^ HIDWORD(v569);
  LODWORD(v192) = (m[1] + __PAIR64__(*(unsigned int *)&v591[8], v587) + __PAIR64__(v51, v87)) >> 32;
  HIDWORD(v192) = LODWORD(m[1]) + v587 + v87;
  HIDWORD(v51) = v192 ^ v575;
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[4] + (v192 ^ v575));
  LODWORD(v41) = (__PAIR64__(*(unsigned int *)&v612[4], *(unsigned int *)&v591[4])
                + __PAIR64__(HIDWORD(v426), (unsigned int)v192 ^ (unsigned int)v575)) >> 32;
  HIDWORD(v383) = *(_DWORD *)&v591[4] + (v192 ^ v575);
  LODWORD(v51) = v41 ^ v51;
  LODWORD(v383) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  v428 = m[5] + __PAIR64__(v192, HIDWORD(v192));
  LODWORD(v192) = (m[5] + __PAIR64__(v192, HIDWORD(v192))) >> 32;
  HIDWORD(v51) ^= v428 + (_DWORD)v51;
  *(_DWORD *)&v591[4] = v428 + v51;
  LODWORD(v87) = v383 | ((_DWORD)v87 << 8);
  HIDWORD(v426) ^= v87 + __CFADD__((_DWORD)v428, (_DWORD)v51) + (_DWORD)v192;
  *(_DWORD *)&v591[8] = v87 + __CFADD__((_DWORD)v428, (_DWORD)v51) + (_DWORD)v192;
  LODWORD(v192) = HIWORD(HIDWORD(v426));
  HIDWORD(v426) = HIWORD(HIDWORD(v51)) | (HIDWORD(v426) << 16);
  LODWORD(v426) = (2 * v421) | (HIDWORD(v87) >> 31);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  v429 = (2 * HIDWORD(v87)) | (v421 >> 31);
  v430 = __PAIR64__(v41, HIDWORD(v383)) + __PAIR64__(HIDWORD(v51), HIDWORD(v426));
  LODWORD(v41) = (__PAIR64__(v41, HIDWORD(v383)) + __PAIR64__(HIDWORD(v51), HIDWORD(v426))) >> 32;
  HIDWORD(v569) = (HIDWORD(v383) + HIDWORD(v426)) ^ v51;
  LODWORD(v87) = v87 ^ v41;
  v431 = m[15] + __PAIR64__(HIDWORD(v414), HIDWORD(v587)) + __PAIR64__(v426, v429);
  HIDWORD(v426) ^= v431;
  HIDWORD(v51) ^= HIDWORD(v431);
  v432 = __PAIR64__(HIDWORD(v41), *(unsigned int *)v576) + __PAIR64__(HIDWORD(v426), HIDWORD(v51));
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), *(unsigned int *)v576) + __PAIR64__(HIDWORD(v426), HIDWORD(v51))) >> 32;
  v433 = v432 ^ v429;
  LODWORD(v426) = HIDWORD(v41) ^ v426;
  HIDWORD(v192) = BYTE3(v426);
  LODWORD(v426) = HIBYTE(v433) | ((_DWORD)v426 << 8);
  LODWORD(v192) = (m[11] + v431) >> 32;
  HIDWORD(v51) ^= LODWORD(m[11]) + v431 + (_DWORD)v426;
  *(_DWORD *)v591 = LODWORD(m[11]) + v431 + v426;
  v434 = HIDWORD(v192) | (v433 << 8);
  HIDWORD(v426) ^= v434 + __CFADD__(LODWORD(m[11]) + v431, (_DWORD)v426) + (_DWORD)v192;
  *(_DWORD *)&v612[4] = v434 + __CFADD__(LODWORD(m[11]) + v431, (_DWORD)v426) + (_DWORD)v192;
  LODWORD(v575) = HIWORD(HIDWORD(v51)) | (HIDWORD(v426) << 16);
  LODWORD(v383) = 2 * v427;
  v435 = (2 * v569) | (v427 >> 31);
  *(_DWORD *)v576 = HIWORD(HIDWORD(v426)) | (HIDWORD(v51) << 16);
  LODWORD(v383) = v383 | ((unsigned int)v569 >> 31);
  LODWORD(v569) = *(_DWORD *)v576 + __CFADD__((_DWORD)v432, (_DWORD)v575) + HIDWORD(v41);
  *(_DWORD *)&v576[8] = (v432 + v575) ^ v426;
  HIDWORD(v87) = (m[9] + __PAIR64__(*(unsigned int *)&v612[8], *(unsigned int *)&v591[20]) + __PAIR64__(v383, v435)) >> 32;
  LODWORD(v426) = LODWORD(m[9]) + *(_DWORD *)&v591[20] + v435;
  HIDWORD(v383) = v430 + (HIDWORD(v87) ^ *(_DWORD *)v570);
  v436 = HIDWORD(v383) ^ v435;
  LODWORD(v41) = v41 + __CFADD__((_DWORD)v430, HIDWORD(v87) ^ *(_DWORD *)v570) + (v426 ^ v641);
  LODWORD(v383) = v383 ^ v41;
  *(_DWORD *)&v576[16] = v569 ^ v434;
  v437 = BYTE3(v383);
  LODWORD(v383) = HIBYTE(v436) | ((_DWORD)v383 << 8);
  v438 = v437 | (v436 << 8);
  LODWORD(v51) = (LODWORD(m[14]) + v426 + v383) ^ HIDWORD(v87) ^ *(_DWORD *)v570;
  HIDWORD(v41) = v426 ^ v641 ^ ((m[14] + __PAIR64__(HIDWORD(v87), v426) + __PAIR64__(v438, v383)) >> 32);
  *(_DWORD *)&v612[8] = (m[14] + __PAIR64__(HIDWORD(v87), v426) + __PAIR64__(v438, v383)) >> 32;
  *(_DWORD *)&v591[20] = LODWORD(m[14]) + v426 + v383;
  HIDWORD(v192) = HIWORD(HIDWORD(v41));
  HIDWORD(v41) = WORD1(v51) | (HIDWORD(v41) << 16);
  HIDWORD(v192) |= (_DWORD)v51 << 16;
  LODWORD(v51) = (2 * v87) | (HIDWORD(v569) >> 31);
  LODWORD(v87) = (2 * HIDWORD(v569)) | ((unsigned int)v87 >> 31);
  HIDWORD(v569) = HIDWORD(v192) + __CFADD__(HIDWORD(v383), HIDWORD(v41)) + (_DWORD)v41;
  LODWORD(v41) = *(_DWORD *)v612;
  *(_DWORD *)v612 = HIDWORD(v383) + HIDWORD(v41);
  LODWORD(v587) = (HIDWORD(v383) + HIDWORD(v41)) ^ v383;
  v439 = m[3] + __PAIR64__(*(unsigned int *)&v612[12], v41) + __PAIR64__(v51, v87);
  HIDWORD(v587) = HIDWORD(v569) ^ v438;
  LODWORD(v87) = v87 ^ (*(_DWORD *)&v591[16] + (HIDWORD(v439) ^ v643));
  HIDWORD(v87) = (__PAIR64__(v568, *(unsigned int *)&v591[16])
                + __PAIR64__((unsigned int)v439 ^ *(_DWORD *)&v570[4], HIDWORD(v439) ^ (unsigned int)v643)) >> 32;
  LODWORD(v383) = *(_DWORD *)&v591[16] + (HIDWORD(v439) ^ v643);
  LODWORD(v51) = HIDWORD(v87) ^ v51;
  HIDWORD(v51) = (m[12] + v439) >> 32;
  HIDWORD(v383) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  *(_DWORD *)&v591[16] = LODWORD(m[12]) + v439 + v51;
  LODWORD(v426) = HIDWORD(v439) ^ v643 ^ *(_DWORD *)&v591[16];
  HIDWORD(v383) |= (_DWORD)v87 << 8;
  v440 = ((__PAIR64__(HIDWORD(v383), LODWORD(m[12]) + (int)v439) + v51) >> 32) ^ v439 ^ *(_DWORD *)&v570[4];
  *(_DWORD *)&v612[12] = (__PAIR64__(HIDWORD(v383), LODWORD(m[12]) + (int)v439) + v51) >> 32;
  *(_DWORD *)v570 = WORD1(v426) | (v440 << 16);
  *(_DWORD *)&v570[4] = HIWORD(v440) | ((_DWORD)v426 << 16);
  HIDWORD(v51) = (2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)&v576[4] >> 31);
  v441 = (2 * *(_DWORD *)&v576[4]) | (*(_DWORD *)&v576[12] >> 31);
  v442 = __PAIR64__(HIDWORD(v87), v383) + *(_QWORD *)v570;
  HIDWORD(v87) = (__PAIR64__(HIDWORD(v87), v383) + *(_QWORD *)v570) >> 32;
  *(_DWORD *)&v576[4] = v442 ^ v51;
  v443 = m[13] + *(_QWORD *)&v591[4] + __PAIR64__(HIDWORD(v51), v441);
  HIDWORD(v426) = v443 ^ *(_DWORD *)&v570[8];
  *(_DWORD *)&v576[12] = HIDWORD(v87) ^ HIDWORD(v383);
  LODWORD(v426) = HIDWORD(v443) ^ HIDWORD(v575);
  v444 = (HIDWORD(v568) + (HIDWORD(v443) ^ HIDWORD(v575))) ^ v441;
  LODWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[12], HIDWORD(v568)) + v426) >> 32;
  HIDWORD(v51) ^= v87;
  v445 = HIBYTE(v444) | (HIDWORD(v51) << 8);
  v446 = HIBYTE(HIDWORD(v51)) | (v444 << 8);
  v447 = m[0] + v443 + __PAIR64__(v446, v445);
  LODWORD(v426) = v447 ^ HIDWORD(v443) ^ HIDWORD(v575);
  HIDWORD(v426) = HIDWORD(v447) ^ v443 ^ *(_DWORD *)&v570[8];
  LODWORD(v192) = HIWORD(HIDWORD(v426));
  HIDWORD(v426) = v426 >> 16;
  LODWORD(v426) = v192 | ((_DWORD)v426 << 16);
  HIDWORD(v383) = HIDWORD(v568) + (HIDWORD(v443) ^ HIDWORD(v575)) + HIDWORD(v426);
  v448 = HIDWORD(v383) ^ v445;
  LODWORD(v87) = (__PAIR64__(v87, HIDWORD(v568) + (HIDWORD(v443) ^ HIDWORD(v575))) + __PAIR64__(v426, HIDWORD(v426))) >> 32;
  v449 = v87 ^ v446;
  HIDWORD(v51) = 2 * v449;
  v450 = (2 * v448) | (v449 >> 31);
  v451 = HIDWORD(v51) | (v448 >> 31);
  v452 = m[0] + __PAIR64__(*(unsigned int *)&v612[4], *(unsigned int *)v591) + __PAIR64__(v451, v450);
  HIDWORD(v41) ^= v452;
  HIDWORD(v192) ^= HIDWORD(v452);
  LODWORD(v383) = v442 + HIDWORD(v192);
  v453 = (v442 + HIDWORD(v192)) ^ v450;
  HIDWORD(v87) += __CFADD__((_DWORD)v442, HIDWORD(v192)) + HIDWORD(v41);
  v454 = HIDWORD(v87) ^ v451;
  HIDWORD(v51) = HIBYTE(v454);
  v455 = HIBYTE(v453) | (v454 << 8);
  v456 = HIDWORD(v51) | (v453 << 8);
  HIDWORD(v192) ^= LODWORD(m[1]) + v452 + v455;
  *(_DWORD *)v591 = LODWORD(m[1]) + v452 + v455;
  HIDWORD(v41) ^= (m[1] + v452 + __PAIR64__(v456, v455)) >> 32;
  *(_DWORD *)&v591[12] = (m[1] + v452 + __PAIR64__(v456, v455)) >> 32;
  *(_DWORD *)&v570[8] = HIWORD(HIDWORD(v192)) | (HIDWORD(v41) << 16);
  LODWORD(v51) = HIWORD(HIDWORD(v41)) | (HIDWORD(v192) << 16);
  LODWORD(v41) = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)&v576[16] >> 31);
  HIDWORD(v192) = (2 * *(_DWORD *)&v576[16]) | (*(_DWORD *)&v576[8] >> 31);
  v642 = v51;
  LODWORD(v568) = v383 + *(_DWORD *)&v570[8];
  v457 = *(_DWORD *)&v591[20];
  *(_DWORD *)&v591[20] = v51 + __CFADD__((_DWORD)v383, *(_DWORD *)&v570[8]) + HIDWORD(v87);
  *(_DWORD *)&v576[16] = *(_DWORD *)&v591[20] ^ v456;
  *(_DWORD *)&v576[8] = (v383 + *(_DWORD *)&v570[8]) ^ v455;
  LODWORD(v192) = LODWORD(m[2]) + v457;
  HIDWORD(v87) = (v192 + __PAIR64__((m[2] + __PAIR64__(*(unsigned int *)&v612[8], v457)) >> 32, v41)) >> 32;
  LODWORD(v192) = LODWORD(m[2]) + v457 + v41;
  LODWORD(v383) = *(_DWORD *)&v570[4] ^ HIDWORD(v87);
  HIDWORD(v383) += *(_DWORD *)&v570[4] ^ HIDWORD(v87);
  LODWORD(v87) = v87
               + __CFADD__(
                   HIDWORD(v568) + (HIDWORD(v443) ^ HIDWORD(v575)) + HIDWORD(v426),
                   *(_DWORD *)&v570[4] ^ HIDWORD(v87))
               + (v192 ^ *(_DWORD *)v570);
  HIDWORD(v192) ^= v87;
  v458 = m[3] + __PAIR64__(HIDWORD(v87), v192);
  HIDWORD(v87) = (m[3] + __PAIR64__(HIDWORD(v87), v192)) >> 32;
  LODWORD(v51) = HIBYTE(HIDWORD(v192));
  HIDWORD(v192) = (((unsigned int)v41 ^ HIDWORD(v383)) >> 24) | (HIDWORD(v192) << 8);
  LODWORD(v41) = v51 | (((unsigned int)v41 ^ HIDWORD(v383)) << 8);
  LODWORD(v383) = v383 ^ (v458 + HIDWORD(v192));
  HIDWORD(v41) = v192 ^ *(_DWORD *)v570 ^ (v41 + __CFADD__((_DWORD)v458, HIDWORD(v192)) + HIDWORD(v87));
  HIDWORD(v568) = v41 + __CFADD__((_DWORD)v458, HIDWORD(v192)) + HIDWORD(v87);
  *(_DWORD *)&v612[4] = v458 + HIDWORD(v192);
  *(_DWORD *)&v570[4] = WORD1(v383) | (HIDWORD(v41) << 16);
  *(_DWORD *)&v612[8] = HIWORD(HIDWORD(v41)) | ((_DWORD)v383 << 16);
  v459 = (2 * v587) | (HIDWORD(v587) >> 31);
  v96 = __CFADD__(HIDWORD(v383), *(_DWORD *)&v570[4]);
  v460 = HIDWORD(v383) + *(_DWORD *)&v570[4];
  HIDWORD(v383) = v587 >> 31;
  *(_DWORD *)v570 = v460;
  v461 = (*(_DWORD *)&v612[8] + v96 + (_DWORD)v87) ^ v41;
  LODWORD(v587) = *(_DWORD *)&v612[8] + v96 + (_DWORD)v87;
  HIDWORD(v87) = *(_DWORD *)v570 ^ HIDWORD(v192);
  v462 = m[4] + __PAIR64__(*(unsigned int *)&v612[12], *(unsigned int *)&v591[16]) + __PAIR64__(HIDWORD(v383), v459);
  HIDWORD(v426) ^= v462;
  LODWORD(v426) = HIDWORD(v462) ^ v426;
  v463 = (v432 + v575 + v426) ^ v459;
  HIDWORD(v41) = (__PAIR64__(v569, (int)v432 + (int)v575) + v426) >> 32;
  LODWORD(v383) = v432 + v575 + v426;
  HIDWORD(v383) ^= HIDWORD(v41);
  LODWORD(v41) = HIBYTE(v463) | (HIDWORD(v383) << 8);
  v464 = HIBYTE(HIDWORD(v383)) | (v463 << 8);
  v465 = (m[5] + v462 + __PAIR64__(v464, v41)) ^ v426;
  *(_DWORD *)&v591[16] = (m[5] + v462 + __PAIR64__(v464, v41)) >> 32;
  HIDWORD(v587) = LODWORD(m[5]) + v462 + v41;
  HIDWORD(v192) = *(_DWORD *)&v576[4];
  HIDWORD(v575) = v465 >> 16;
  *(_DWORD *)&v576[4] = HIWORD(HIDWORD(v465)) | ((_DWORD)v465 << 16);
  LODWORD(v192) = HIDWORD(v575);
  LODWORD(v87) = (2 * HIDWORD(v192)) | (*(_DWORD *)&v576[12] >> 31);
  LODWORD(v51) = (2 * *(_DWORD *)&v576[12]) | (HIDWORD(v192) >> 31);
  HIDWORD(v192) = *(_DWORD *)&v576[4];
  HIDWORD(v51) = (v383 + HIDWORD(v575)) ^ v41;
  v466 = __PAIR64__(HIDWORD(v41), v383) + v192;
  v467 = HIDWORD(v466) ^ v464;
  v565 = HIDWORD(v51);
  LODWORD(v192) = (m[6] + v447 + __PAIR64__(v51, v87)) >> 32;
  HIDWORD(v192) = LODWORD(m[6]) + v447 + v87;
  LODWORD(v87) = v87 ^ (*(_DWORD *)v612 + (v192 ^ *(_DWORD *)v576));
  v468 = __PAIR64__(HIDWORD(v569), *(unsigned int *)v612)
       + __PAIR64__(HIDWORD(v192) ^ (unsigned int)v575, (unsigned int)v192 ^ *(_DWORD *)v576);
  LODWORD(v41) = (__PAIR64__(HIDWORD(v569), *(unsigned int *)v612)
                + __PAIR64__(HIDWORD(v192) ^ (unsigned int)v575, (unsigned int)v192 ^ *(_DWORD *)v576)) >> 32;
  LODWORD(v51) = v41 ^ v51;
  HIDWORD(v41) = BYTE3(v51);
  LODWORD(v51) = BYTE3(v87) | ((_DWORD)v51 << 8);
  HIDWORD(v51) = (LODWORD(m[7]) + HIDWORD(v192) + v51) ^ v192 ^ *(_DWORD *)v576;
  *(_DWORD *)&v591[4] = LODWORD(m[7]) + HIDWORD(v192) + v51;
  LODWORD(v87) = HIDWORD(v41) | ((_DWORD)v87 << 8);
  LODWORD(v192) = v87
                + __CFADD__(LODWORD(m[7]) + HIDWORD(v192), (_DWORD)v51)
                + ((m[7] + __PAIR64__(v192, HIDWORD(v192))) >> 32);
  HIDWORD(v465) = v192 ^ HIDWORD(v192) ^ v575;
  *(_DWORD *)&v591[8] = v192;
  LODWORD(v192) = HIWORD(HIDWORD(v465));
  HIDWORD(v465) = HIWORD(HIDWORD(v51)) | (HIDWORD(v465) << 16);
  LODWORD(v465) = (2 * v461) | (HIDWORD(v87) >> 31);
  HIDWORD(v51) = v192 | (HIDWORD(v51) << 16);
  v469 = (2 * HIDWORD(v87)) | (v461 >> 31);
  v470 = __PAIR64__(v41, v468) + __PAIR64__(HIDWORD(v51), HIDWORD(v465));
  LODWORD(v41) = (__PAIR64__(v41, v468) + __PAIR64__(HIDWORD(v51), HIDWORD(v465))) >> 32;
  *(_DWORD *)v576 = v470 ^ v51;
  LODWORD(v87) = v87 ^ v41;
  LODWORD(v192) = (m[8] + __PAIR64__(*(unsigned int *)&v591[12], *(unsigned int *)v591) + __PAIR64__(v465, v469)) >> 32;
  HIDWORD(v192) = LODWORD(m[8]) + *(_DWORD *)v591 + v469;
  HIDWORD(v465) ^= HIDWORD(v192);
  HIDWORD(v51) ^= v192;
  v471 = (v466 + HIDWORD(v51)) ^ v469;
  HIDWORD(v41) = (v466 + __PAIR64__(HIDWORD(v465), HIDWORD(v51))) >> 32;
  HIDWORD(v87) = v466 + HIDWORD(v51);
  LODWORD(v465) = HIDWORD(v41) ^ v465;
  LODWORD(v466) = BYTE3(v465);
  LODWORD(v465) = HIBYTE(v471) | ((_DWORD)v465 << 8);
  v472 = v466 | (v471 << 8);
  HIDWORD(v51) ^= LODWORD(m[9]) + HIDWORD(v192) + v465;
  *(_DWORD *)v591 = LODWORD(m[9]) + HIDWORD(v192) + v465;
  HIDWORD(v465) ^= (m[9] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v472, v465)) >> 32;
  *(_DWORD *)&v591[12] = (m[9] + __PAIR64__(v192, HIDWORD(v192)) + __PAIR64__(v472, v465)) >> 32;
  HIDWORD(v569) = HIWORD(HIDWORD(v51)) | (HIDWORD(v465) << 16);
  LODWORD(v575) = HIWORD(HIDWORD(v465)) | (HIDWORD(v51) << 16);
  HIDWORD(v192) = 2 * v467;
  LODWORD(v569) = HIDWORD(v87) + HIDWORD(v569);
  v473 = (2 * v565) | (v467 >> 31);
  LODWORD(v466) = v565;
  v566 = v575 + __CFADD__(HIDWORD(v87), HIDWORD(v569)) + HIDWORD(v41);
  HIDWORD(v192) |= (unsigned int)v466 >> 31;
  HIDWORD(v465) = (HIDWORD(v87) + HIDWORD(v569)) ^ v465;
  LODWORD(v192) = LODWORD(m[10]) + *(_DWORD *)&v612[4];
  HIDWORD(v41) = (v192 + __PAIR64__((m[10] + __PAIR64__(HIDWORD(v568), *(unsigned int *)&v612[4])) >> 32, v473)) >> 32;
  LODWORD(v466) = LODWORD(m[10]) + *(_DWORD *)&v612[4] + v473;
  LODWORD(v51) = v466 ^ *(_DWORD *)&v570[8];
  LODWORD(v465) = (__PAIR64__(v41, v470) + __PAIR64__((unsigned int)v466 ^ *(_DWORD *)&v570[8], HIDWORD(v41) ^ v642)) >> 32;
  HIDWORD(v466) = v470 + (HIDWORD(v41) ^ v642);
  v474 = HIDWORD(v466) ^ v473;
  HIDWORD(v192) ^= v465;
  HIDWORD(v87) = HIBYTE(v474) | (HIDWORD(v192) << 8);
  *(_DWORD *)&v570[8] = v566 ^ v472;
  v475 = HIBYTE(HIDWORD(v192));
  HIDWORD(v192) = HIDWORD(v587);
  v476 = v475 | (v474 << 8);
  LODWORD(v192) = HIDWORD(v41) ^ v642 ^ (LODWORD(m[11]) + v466 + HIDWORD(v87));
  *(_QWORD *)v612 = m[11] + __PAIR64__(HIDWORD(v41), v466) + __PAIR64__(v476, HIDWORD(v87));
  LODWORD(v51) = *(_DWORD *)&v612[4] ^ v51;
  HIDWORD(v51) = (2 * v87) | (*(_DWORD *)v576 >> 31);
  *(_DWORD *)&v612[12] = WORD1(v192) | ((_DWORD)v51 << 16);
  *(_DWORD *)&v612[16] = WORD1(v51) | ((_DWORD)v192 << 16);
  LODWORD(v87) = (2 * *(_DWORD *)v576) | ((unsigned int)v87 >> 31);
  HIDWORD(v568) = (__PAIR64__(v465, HIDWORD(v466)) + *(_QWORD *)&v612[12]) >> 32;
  HIDWORD(v587) = HIDWORD(v466) + *(_DWORD *)&v612[12];
  LODWORD(v466) = (m[12] + __PAIR64__(*(unsigned int *)&v591[16], HIDWORD(v192)) + __PAIR64__(HIDWORD(v51), v87)) >> 32;
  LODWORD(v465) = LODWORD(m[12]) + HIDWORD(v192) + v87;
  HIDWORD(v41) = v465 ^ *(_DWORD *)&v570[4];
  *(_DWORD *)v576 = (HIDWORD(v466) + *(_DWORD *)&v612[12]) ^ HIDWORD(v87);
  LODWORD(v41) = *(_DWORD *)&v612[8] ^ v466;
  *(_DWORD *)&v576[12] = HIDWORD(v568) ^ v476;
  LODWORD(v87) = v87 ^ (v568 + (*(_DWORD *)&v612[8] ^ v466));
  HIDWORD(v87) = (__PAIR64__(*(unsigned int *)&v591[20], v568) + v41) >> 32;
  LODWORD(v192) = v568 + (*(_DWORD *)&v612[8] ^ v466);
  HIDWORD(v192) = HIDWORD(v87) ^ HIDWORD(v51);
  HIDWORD(v51) = BYTE3(v87) | ((HIDWORD(v87) ^ HIDWORD(v51)) << 8);
  LODWORD(v51) = HIBYTE(HIDWORD(v192)) | ((_DWORD)v87 << 8);
  v477 = m[13] + __PAIR64__(v466, v465) + __PAIR64__(v51, HIDWORD(v51));
  HIDWORD(v466) = v477 ^ *(_DWORD *)&v612[8] ^ v466;
  HIDWORD(v41) = v465 ^ *(_DWORD *)&v570[4] ^ HIDWORD(v477);
  *(_DWORD *)&v570[4] = HIWORD(HIDWORD(v466)) | (HIDWORD(v41) << 16);
  *(_DWORD *)&v612[8] = HIWORD(HIDWORD(v41)) | (HIDWORD(v466) << 16);
  HIDWORD(v192) = (2 * *(_DWORD *)&v576[16]) | (*(_DWORD *)&v576[8] >> 31);
  HIDWORD(v466) = (__PAIR64__(HIDWORD(v87), v192) + __PAIR64__(*(unsigned int *)&v612[8], *(unsigned int *)&v570[4])) >> 32;
  LODWORD(v192) = v192 + *(_DWORD *)&v570[4];
  HIDWORD(v51) ^= v192;
  LODWORD(v41) = (2 * *(_DWORD *)&v576[8]) | (*(_DWORD *)&v576[16] >> 31);
  LODWORD(v568) = HIDWORD(v466);
  LODWORD(v87) = LODWORD(m[14]) + *(_DWORD *)&v591[4] + v41;
  v478 = (m[14] + *(_QWORD *)&v591[4] + __PAIR64__(HIDWORD(v192), v41)) >> 32;
  LODWORD(v465) = v87 ^ HIDWORD(v575);
  v479 = v478 ^ *(_DWORD *)&v576[4];
  LODWORD(v51) = HIDWORD(v466) ^ v51;
  LODWORD(v41) = v41 ^ (*(_DWORD *)v570 + (v478 ^ *(_DWORD *)&v576[4]));
  HIDWORD(v41) = (__PAIR64__(v587, *(unsigned int *)v570)
                + __PAIR64__((unsigned int)v87 ^ HIDWORD(v575), v478 ^ *(_DWORD *)&v576[4])) >> 32;
  LODWORD(v466) = *(_DWORD *)v570 + (v478 ^ *(_DWORD *)&v576[4]);
  HIDWORD(v192) ^= HIDWORD(v41);
  v481 = m[15] + __PAIR64__(v478, v87);
  v480 = (m[15] + __PAIR64__(v478, v87)) >> 32;
  LODWORD(v87) = v481;
  HIDWORD(v466) = BYTE3(v41) | (HIDWORD(v192) << 8);
  HIDWORD(v87) = HIBYTE(HIDWORD(v192)) | ((_DWORD)v41 << 8);
  v483 = v87 + __PAIR64__(v480, HIDWORD(v466));
  v482 = (v87 + __PAIR64__(v480, HIDWORD(v466))) >> 32;
  v484 = v483 ^ v479;
  *(_QWORD *)&v576[4] = __PAIR64__(v482, v483);
  LODWORD(v465) = v482 ^ v465;
  HIDWORD(v192) = HIWORD(v484) | ((_DWORD)v465 << 16);
  v96 = __CFADD__((_DWORD)v466, HIDWORD(v192));
  LODWORD(v466) = v466 + HIDWORD(v192);
  LODWORD(v587) = HIDWORD(v192);
  HIDWORD(v41) += v96 + (WORD1(v465) | (v484 << 16));
  *(_DWORD *)&v591[4] = WORD1(v465) | (v484 << 16);
  *(_DWORD *)&v576[16] = (2 * HIDWORD(v465)) | (*(_DWORD *)&v570[8] >> 31);
  HIDWORD(v87) ^= HIDWORD(v41);
  LODWORD(v465) = 2 * HIDWORD(v87);
  HIDWORD(v87) = (2 * (HIDWORD(v466) ^ v466)) | (HIDWORD(v87) >> 31);
  LODWORD(v41) = (2 * *(_DWORD *)&v570[8]) | (HIDWORD(v465) >> 31);
  v538 = (2 * *(_DWORD *)&v576[12]) | (*(_DWORD *)v576 >> 31);
  v485 = m[14]
       + __PAIR64__(*(unsigned int *)&v591[12], *(unsigned int *)v591)
       + __PAIR64__((unsigned int)v465 | ((HIDWORD(v466) ^ (unsigned int)v466) >> 31), HIDWORD(v87));
  *(_DWORD *)&v576[12] = (2 * *(_DWORD *)v576) | (*(_DWORD *)&v576[12] >> 31);
  HIDWORD(v465) = 2 * v51;
  LODWORD(v51) = v51 >> 31;
  HIDWORD(v51) = HIDWORD(v465) | (HIDWORD(v51) >> 31);
  HIDWORD(v465) = HIDWORD(v87) ^ (v192 + (HIDWORD(v485) ^ *(_DWORD *)&v612[16]));
  v486 = v51;
  *(_DWORD *)v576 = v192 + (HIDWORD(v485) ^ *(_DWORD *)&v612[16]);
  LODWORD(v87) = (__PAIR64__(v568, v192)
                + __PAIR64__((unsigned int)v485 ^ *(_DWORD *)&v612[12], HIDWORD(v485) ^ *(_DWORD *)&v612[16])) >> 32;
  HIDWORD(v466) = (v465 | ((HIDWORD(v466) ^ (unsigned int)v466) >> 31)) ^ v87;
  HIDWORD(v192) = HIBYTE(HIDWORD(v465)) | (HIDWORD(v466) << 8);
  HIDWORD(v87) = HIBYTE(HIDWORD(v466)) | (HIDWORD(v465) << 8);
  v487 = m[10] + v485 + __PAIR64__(HIDWORD(v87), HIDWORD(v192));
  LODWORD(v568) = HIDWORD(v487);
  LODWORD(v192) = v487;
  v488 = v192 ^ HIDWORD(v485) ^ *(_DWORD *)&v612[16];
  LODWORD(v51) = (HIDWORD(v87) + __CFADD__(LODWORD(m[10]) + v485, HIDWORD(v192)) + ((m[10] + v485) >> 32))
               ^ v485
               ^ *(_DWORD *)&v612[12];
  v546 = LODWORD(m[10]) + v485 + HIDWORD(v192);
  HIDWORD(v575) = HIWORD(v488) | ((_DWORD)v51 << 16);
  HIDWORD(v466) = WORD1(v51) | (v488 << 16);
  v96 = __CFADD__(*(_DWORD *)v576, HIDWORD(v575));
  v489 = *(_DWORD *)v576 + HIDWORD(v575);
  *(_DWORD *)v576 = HIDWORD(v466);
  v531 = v489;
  v536 = HIDWORD(v466) + v96 + (_DWORD)v87;
  LODWORD(v51) = (LODWORD(m[4]) + *(_DWORD *)v612 + *(_DWORD *)&v576[16]) ^ *(_DWORD *)&v570[4];
  v490 = (m[4] + *(_QWORD *)v612 + __PAIR64__(v41, *(unsigned int *)&v576[16])) >> 32;
  HIDWORD(v465) = v490 ^ *(_DWORD *)&v612[8];
  v491 = (v466 + (v490 ^ *(_DWORD *)&v612[8])) ^ *(_DWORD *)&v576[16];
  v492 = __PAIR64__(HIDWORD(v41), v466) + __PAIR64__(v51, v490 ^ *(_DWORD *)&v612[8]);
  HIDWORD(v41) = (__PAIR64__(HIDWORD(v41), v466) + __PAIR64__(v51, v490 ^ *(_DWORD *)&v612[8])) >> 32;
  LODWORD(v41) = v41 ^ HIDWORD(v41);
  LODWORD(v87) = BYTE3(v41);
  LODWORD(v41) = HIBYTE(v491) | ((_DWORD)v41 << 8);
  LODWORD(v87) = v87 | (v491 << 8);
  HIDWORD(v87) ^= v536;
  v494 = m[8] + __PAIR64__(v490, LODWORD(m[4]) + *(_DWORD *)v612 + *(_DWORD *)&v576[16]);
  v493 = (m[8] + __PAIR64__(v490, LODWORD(m[4]) + *(_DWORD *)v612 + *(_DWORD *)&v576[16])) >> 32;
  HIDWORD(v465) ^= v494 + (_DWORD)v41;
  *(_DWORD *)&v576[16] = (2 * (v531 ^ HIDWORD(v192))) | (HIDWORD(v87) >> 31);
  LODWORD(v51) = ((__PAIR64__(v493, v494) + __PAIR64__(v87, v41)) >> 32) ^ v51;
  *(_DWORD *)&v570[4] = (__PAIR64__(v493, v494) + __PAIR64__(v87, v41)) >> 32;
  v545 = v494 + v41;
  *(_DWORD *)v591 = (2 * HIDWORD(v87)) | (((unsigned int)v531 ^ HIDWORD(v192)) >> 31);
  *(_DWORD *)&v591[8] = HIWORD(HIDWORD(v465)) | ((_DWORD)v51 << 16);
  v528 = __PAIR64__(HIDWORD(v41), v492) + __PAIR64__(WORD1(v51) | (HIDWORD(v465) << 16), *(unsigned int *)&v591[8]);
  *(_DWORD *)&v591[12] = WORD1(v51) | (HIDWORD(v465) << 16);
  LODWORD(v41) = v41 ^ (v492 + *(_DWORD *)&v591[8]);
  v495 = m[9] + v477 + __PAIR64__(v538, *(unsigned int *)&v576[12]);
  HIDWORD(v465) = (v569 + (HIDWORD(v495) ^ *(_DWORD *)&v591[4])) ^ *(_DWORD *)&v576[12];
  HIDWORD(v51) = HIBYTE(HIDWORD(v465))
               | ((((__PAIR64__(v566, v569)
                   + __PAIR64__((unsigned int)v495 ^ (unsigned int)v587, HIDWORD(v495) ^ *(_DWORD *)&v591[4])) >> 32)
                 ^ (unsigned int)v538) << 8);
  HIDWORD(v87) = ((((__PAIR64__(v566, v569)
                   + __PAIR64__((unsigned int)v495 ^ (unsigned int)v587, HIDWORD(v495) ^ *(_DWORD *)&v591[4])) >> 32)
                 ^ (unsigned int)v538) >> 24)
               | (HIDWORD(v465) << 8);
  v496 = LODWORD(m[15]) + LODWORD(m[9]) + v477 + *(_DWORD *)&v576[12];
  v497 = (v496 + HIDWORD(v51)) ^ HIDWORD(v495) ^ *(_DWORD *)&v591[4];
  v542 = (2 * v41) | ((HIDWORD(v528) ^ (unsigned int)v87) >> 31);
  LODWORD(v465) = ((m[15] + v495 + __PAIR64__(HIDWORD(v87), HIDWORD(v51))) >> 32) ^ v495 ^ v587;
  v539 = (m[15] + v495 + __PAIR64__(HIDWORD(v87), HIDWORD(v51))) >> 32;
  LODWORD(v529) = (2 * (HIDWORD(v528) ^ v87)) | ((unsigned int)v41 >> 31);
  HIDWORD(v529) = v496 + HIDWORD(v51);
  v544 = HIWORD(v497) | ((_DWORD)v465 << 16);
  HIDWORD(v41) = (__PAIR64__(v566, v569)
                + __PAIR64__((unsigned int)v495 ^ (unsigned int)v587, HIDWORD(v495) ^ *(_DWORD *)&v591[4])
                + __PAIR64__(WORD1(v465) | (v497 << 16), v544)) >> 32;
  HIDWORD(v192) = v569 + (HIDWORD(v495) ^ *(_DWORD *)&v591[4]) + v544;
  v567 = WORD1(v465) | (v497 << 16);
  HIDWORD(v87) ^= HIDWORD(v41);
  v498 = m[13] + *(_QWORD *)&v576[4] + v486;
  v525 = HIDWORD(v192) ^ HIDWORD(v51);
  v499 = (__PAIR64__(HIDWORD(v568), HIDWORD(v587))
        + __PAIR64__((unsigned int)v498 ^ HIDWORD(v569), HIDWORD(v498) ^ (unsigned int)v575))
       ^ v486;
  HIDWORD(v465) = v499 >> 24;
  LODWORD(v465) = HIBYTE(HIDWORD(v499)) | ((_DWORD)v499 << 8);
  v500 = (LODWORD(m[6]) + LODWORD(m[13]) + *(_DWORD *)&v576[4] + v486 + HIDWORD(v465)) ^ HIDWORD(v498) ^ v575;
  *(_QWORD *)&v533[4] = m[6] + v498 + __PAIR64__(v465, HIDWORD(v465));
  v527 = (2 * v525) | (HIDWORD(v87) >> 31);
  v501 = *(_DWORD *)&v533[8] ^ v498 ^ HIDWORD(v569);
  LODWORD(v87) = HIWORD(v500) | (v501 << 16);
  v502 = __PAIR64__(HIDWORD(v568), HIDWORD(v587))
       + __PAIR64__((unsigned int)v498 ^ HIDWORD(v569), HIDWORD(v498) ^ (unsigned int)v575)
       + __PAIR64__(HIWORD(v501) | (v500 << 16), v87);
  HIDWORD(v499) = HIWORD(v501) | (v500 << 16);
  HIDWORD(v465) ^= v502;
  v526 = (2 * HIDWORD(v87)) | (v525 >> 31);
  LODWORD(v465) = HIDWORD(v502) ^ v465;
  v503 = m[1] + __PAIR64__(v568, v546) + __PAIR64__(v529, v542);
  v96 = __CFADD__(HIDWORD(v192), HIDWORD(v503) ^ HIDWORD(v499));
  HIDWORD(v192) += HIDWORD(v503) ^ HIDWORD(v499);
  HIDWORD(v41) += v96 + (v87 ^ (LODWORD(m[1]) + v546 + v542));
  HIDWORD(v87) = ((HIDWORD(v192) ^ v542) >> 24) | ((HIDWORD(v41) ^ (unsigned int)v529) << 8);
  v504 = ((HIDWORD(v41) ^ (unsigned int)v529) >> 24) | ((HIDWORD(v192) ^ v542) << 8);
  LODWORD(v529) = (2 * v465) | (HIDWORD(v465) >> 31);
  v[0] = m[12] + v503 + __PAIR64__(v504, HIDWORD(v87));
  LODWORD(v466) = HIDWORD(v503) ^ HIDWORD(v499) ^ LODWORD(v[0]);
  HIDWORD(v466) = v87 ^ (LODWORD(m[1]) + v546 + v542) ^ HIDWORD(v[0]);
  LODWORD(v87) = v466 >> 16;
  v96 = __CFADD__(HIDWORD(v192), (_DWORD)v87);
  HIDWORD(v192) += v87;
  LODWORD(v[15]) = v87;
  HIDWORD(v[15]) = HIWORD(HIDWORD(v466)) | ((_DWORD)v466 << 16);
  HIDWORD(v41) += v96 + HIDWORD(v[15]);
  HIDWORD(v87) ^= HIDWORD(v192);
  v505 = HIDWORD(v41) ^ v504;
  v[10] = __PAIR64__(HIDWORD(v41), HIDWORD(v192));
  v506 = m[0] + __PAIR64__(*(unsigned int *)&v570[4], v545) + __PAIR64__(v526, v527);
  HIDWORD(v499) = v506 ^ HIDWORD(v575);
  LODWORD(v499) = HIDWORD(v506) ^ *(_DWORD *)v576;
  LODWORD(v41) = (v502 + v499) >> 32;
  v524 = v502 + (HIDWORD(v506) ^ *(_DWORD *)v576);
  LODWORD(v87) = ((v524 ^ v527) >> 24) | (((unsigned int)v41 ^ v526) << 8);
  v507 = (((unsigned int)v41 ^ v526) >> 24) | ((v524 ^ v527) << 8);
  LODWORD(v[5]) = (2 * HIDWORD(v87)) | (v505 >> 31);
  LODWORD(v499) = (LODWORD(m[2]) + LODWORD(m[0]) + v545 + v527 + v87) ^ HIDWORD(v506) ^ *(_DWORD *)v576;
  v[1] = m[2] + v506 + __PAIR64__(v507, v87);
  HIDWORD(v499) = HIDWORD(v[1]) ^ v506 ^ HIDWORD(v575);
  LODWORD(v[12]) = v499 >> 16;
  HIDWORD(v[12]) = HIWORD(HIDWORD(v499)) | ((_DWORD)v499 << 16);
  HIDWORD(v[5]) = (2 * v505) | (HIDWORD(v87) >> 31);
  LODWORD(v87) = v87 ^ (v524 + LODWORD(v[12]));
  v508 = v41 ^ v507;
  v509 = m[11] + __PAIR64__(v539, HIDWORD(v529)) + __PAIR64__(v529, v465 >> 31);
  HIDWORD(v499) = v509 ^ *(_DWORD *)&v591[8];
  LODWORD(v499) = HIDWORD(v509) ^ *(_DWORD *)&v591[12];
  v510 = __PAIR64__(v536, v531) + v499;
  LODWORD(v465) = (v531 + (HIDWORD(v509) ^ *(_DWORD *)&v591[12])) ^ (v465 >> 31);
  HIDWORD(v465) = ((__PAIR64__(v536, v531) + v499) >> 32) ^ v529;
  HIDWORD(v87) = v465 >> 24;
  v511 = HIBYTE(HIDWORD(v465)) | ((_DWORD)v465 << 8);
  LODWORD(v499) = (LODWORD(m[7]) + v509 + HIDWORD(v87)) ^ HIDWORD(v509) ^ *(_DWORD *)&v591[12];
  HIDWORD(v499) = ((m[7] + v509 + __PAIR64__(v511, HIDWORD(v87))) >> 32) ^ v509 ^ *(_DWORD *)&v591[8];
  LODWORD(v[13]) = v499 >> 16;
  v[11] = __PAIR64__(v41, v524) + v[12];
  HIDWORD(v[13]) = HIWORD(HIDWORD(v499)) | ((_DWORD)v499 << 16);
  v512 = v510 + v[13];
  HIDWORD(v[6]) = (2 * v508) | ((unsigned int)v87 >> 31);
  LODWORD(v[6]) = (2 * v87) | (v508 >> 31);
  HIDWORD(v[2]) = (m[7] + v509 + __PAIR64__(v511, HIDWORD(v87))) >> 32;
  v513 = ((v510 + v[13]) >> 32) ^ v511;
  v514 = m[5] + *(_QWORD *)&v533[4] + __PAIR64__(*(unsigned int *)v591, *(unsigned int *)&v576[16]);
  v[8] = v510 + v[13];
  LODWORD(v465) = (v528 + (HIDWORD(v514) ^ v567)) ^ *(_DWORD *)&v576[16];
  LODWORD(v87) = ((((v528 + __PAIR64__((unsigned int)v514 ^ v544, HIDWORD(v514) ^ v567)) >> 32) ^ *(_DWORD *)v591) >> 24)
               | ((_DWORD)v465 << 8);
  LODWORD(v41) = BYTE3(v465)
               | ((((v528 + __PAIR64__((unsigned int)v514 ^ v544, HIDWORD(v514) ^ v567)) >> 32) ^ *(_DWORD *)v591) << 8);
  v515 = m[3] + v514 + __PAIR64__(v87, v41);
  v516 = v515 ^ HIDWORD(v514) ^ v567;
  HIDWORD(v499) = HIDWORD(v515) ^ v514 ^ v544;
  LODWORD(v[2]) = LODWORD(m[7]) + v509 + HIDWORD(v87);
  v[3] = v515;
  LODWORD(v[7]) = (2 * (HIDWORD(v87) ^ (v510 + LODWORD(v[13])))) | (v513 >> 31);
  v517 = p_buflen;
  HIDWORD(v[7]) = (2 * v513) | ((HIDWORD(v87) ^ (unsigned int)(v510 + LODWORD(v[13]))) >> 31);
  HIDWORD(v[14]) = HIWORD(HIDWORD(v499)) | (v516 << 16);
  LODWORD(v[14]) = HIWORD(v516) | (HIDWORD(v499) << 16);
  LODWORD(v41) = v41 ^ (v528 + (HIDWORD(v514) ^ v567) + LODWORD(v[14]));
  LODWORD(v87) = ((v528 + __PAIR64__((unsigned int)v514 ^ v544, HIDWORD(v514) ^ v567) + v[14]) >> 32) ^ v87;
  v[9] = v528 + __PAIR64__((unsigned int)v514 ^ v544, HIDWORD(v514) ^ v567) + v[14];
  v518 = &v[1];
  LODWORD(v[4]) = (2 * v41) | ((unsigned int)v87 >> 31);
  HIDWORD(v[4]) = (2 * v87) | ((unsigned int)v41 >> 31);
  v519 = v[0];
  while ( 1 )
  {
    v521 = v517[2];
    v517 += 2;
    v522 = v517[1];
    *v517 = v512 ^ v519 ^ v521;
    v517[1] = v522 ^ HIDWORD(v512) ^ HIDWORD(v519);
    if ( v588 == (blake2b_state *)v517 )
      break;
    v520 = *v518++;
    v519 = v520;
    v512 = v518[7];
  }
  return 0;
}

//----- (00046784) --------------------------------------------------------
int __fastcall blake2b_init_param(blake2b_state *S, const blake2b_param *P)
{
  blake2b_state *v4; // r3
  const uint64_t *v5; // r1
  __int64 v6; // r6
  blake2b_state *v7; // r2
  __int64 v8; // t1
  const blake2b_param *v9; // r1
  int v10; // t1
  int v11; // r5
  int v12; // r0

  memset(S, 0, sizeof(blake2b_state));
  v4 = (blake2b_state *)((char *)S - 8);
  v5 = &blake2b_IV[1];
  v6 = 0x6A09E667F3BCC908LL;
  v7 = (blake2b_state *)((char *)S - 8);
  while ( 1 )
  {
    v7->h[1] = v6;
    v7 = (blake2b_state *)((char *)v7 + 8);
    if ( v7 == (blake2b_state *)&S->h[7] )
      break;
    v8 = *v5++;
    v6 = v8;
  }
  v9 = P;
  do
  {
    v10 = v4->h[1];
    v4 = (blake2b_state *)((char *)v4 + 8);
    v9 = (const blake2b_param *)((char *)v9 + 8);
    v11 = *(_DWORD *)&v9[-1].personal[12];
    v12 = HIDWORD(v4->h[0]);
    LODWORD(v4->h[0]) = v10 ^ *(_DWORD *)&v9[-1].personal[8];
    HIDWORD(v4->h[0]) = v12 ^ v11;
  }
  while ( v4 != v7 );
  return 0;
}

//----- (000467EC) --------------------------------------------------------
int __fastcall blake2b_init(blake2b_state *S, const uint8_t outlen)
{
  blake2b_param P[1]; // [sp+0h] [bp-48h] BYREF

  if ( (unsigned int)(outlen - 1) > 0x3F )
    return -1;
  P[0].digest_length = outlen;
  P[0].key_length = 0;
  P[0].leaf_length = 0;
  P[0].node_offset = 0;
  P[0].node_depth = 0;
  P[0].inner_length = 0;
  *(_DWORD *)P[0].reserved = 0;
  *(_DWORD *)P[0].salt = 0;
  *(_DWORD *)P[0].personal = 0;
  *(_DWORD *)&P[0].reserved[4] = 0;
  *(_DWORD *)&P[0].reserved[8] = 0;
  *(_WORD *)&P[0].reserved[12] = 0;
  *(_DWORD *)&P[0].salt[4] = 0;
  *(_DWORD *)&P[0].salt[8] = 0;
  *(_DWORD *)&P[0].salt[12] = 0;
  *(_DWORD *)&P[0].personal[4] = 0;
  *(_DWORD *)&P[0].personal[8] = 0;
  *(_DWORD *)&P[0].personal[12] = 0;
  P[0].fanout = 1;
  P[0].depth = 1;
  return blake2b_init_param(S, P);
}

//----- (00046874) --------------------------------------------------------
int __fastcall blake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen)
{
  uint64_t v3; // r10
  size_t buflen; // r0
  bool v7; // cf
  uint8_t *buf; // r7
  size_t v9; // r5
  size_t v10; // r8
  const uint8_t *v11; // r1
  bool v12; // cf
  uint64_t v14; // [sp+0h] [bp-1Ch]
  uint64_t v15; // [sp+8h] [bp-14h]

  v3 = inlen;
  if ( inlen )
  {
    buflen = S->buflen;
    v7 = HIDWORD(inlen) == 0;
    buf = S->buf;
    v9 = 256 - buflen;
    if ( !HIDWORD(inlen) )
      v7 = v9 >= (unsigned int)inlen;
    v10 = 256 - buflen;
    if ( !v7 )
    {
      do
      {
        v11 = in;
        in += v9;
        memcpy(&buf[buflen], v11, v9);
        v15 = S->t[1];
        v14 = S->t[0] + 128;
        S->t[0] = v14;
        S->buflen += v9;
        S->t[1] = v15 + (v14 < 0x80);
        blake2b_compress(S, S->buf);
        memcpy(S->buf, &S->buf[128], 0x80u);
        v3 -= v10;
        v12 = HIDWORD(v3) == 0;
        buflen = S->buflen - 128;
        v9 = 384 - S->buflen;
        S->buflen = buflen;
        if ( !HIDWORD(v3) )
          v12 = v9 >= (unsigned int)v3;
        v10 = v9;
      }
      while ( !v12 );
    }
    memcpy(&buf[buflen], in, v3);
    S->buflen += v3;
  }
  return 0;
}

//----- (00046958) --------------------------------------------------------
int __fastcall blake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key, const uint8_t keylen)
{
  size_t v5; // r5
  blake2b_param P[1]; // [sp+0h] [bp-C4h] BYREF
  uint8_t block[132]; // [sp+40h] [bp-84h] BYREF

  if ( (unsigned int)(outlen - 1) > 0x3F )
    return -1;
  if ( (unsigned int)(keylen - 1) > 0x3F || key == 0 )
    return -1;
  v5 = keylen;
  P[0].digest_length = outlen;
  P[0].key_length = keylen;
  P[0].leaf_length = 0;
  P[0].node_offset = 0;
  *(_WORD *)&P[0].node_depth = 0;
  *(_DWORD *)P[0].reserved = 0;
  *(_DWORD *)P[0].salt = 0;
  *(_DWORD *)P[0].personal = 0;
  *(_WORD *)&P[0].fanout = 257;
  *(_DWORD *)&P[0].reserved[4] = 0;
  *(_DWORD *)&P[0].reserved[8] = 0;
  *(_WORD *)&P[0].reserved[12] = 0;
  *(_DWORD *)&P[0].salt[4] = 0;
  *(_DWORD *)&P[0].salt[8] = 0;
  *(_DWORD *)&P[0].salt[12] = 0;
  *(_DWORD *)&P[0].personal[4] = 0;
  *(_DWORD *)&P[0].personal[8] = 0;
  *(_DWORD *)&P[0].personal[12] = 0;
  if ( blake2b_init_param(S, P) < 0 )
    return -1;
  memset(block, 0, 0x80u);
  memcpy(block, key, v5);
  blake2b_update(S, block, 0x80u);
  memset_v_6360(block, 0, 0x80u);
  return 0;
}
// 6D81C: using guessed type void *(*memset_v_6360)(void *s, int c, size_t n);

//----- (00046A14) --------------------------------------------------------
int __fastcall blake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen)
{
  size_t v4; // r9
  _BOOL4 v6; // r3
  size_t buflen; // r12
  uint64_t v8; // r6
  uint64_t v9; // r0
  _BOOL4 v10; // r3
  int last_node; // lr
  size_t *p_buflen; // r0
  uint8_t *v13; // r3
  uint64_t *v14; // r4
  size_t v15; // t1
  size_t v16; // r2
  bool v18; // cf
  int v19; // r3
  size_t v20; // r2
  uint64_t v21; // [sp+0h] [bp-4Ch]
  uint8_t buffer[64]; // [sp+8h] [bp-44h] BYREF

  v4 = outlen;
  memset(buffer, 0, sizeof(buffer));
  v6 = out == 0;
  if ( v4 - 1 > 0x3F )
    v6 = 1;
  if ( v6 || S->f[0] )
    return -1;
  buflen = S->buflen;
  v8 = S->t[0];
  v21 = S->t[1];
  if ( buflen > 0x80 )
  {
    v18 = 1;
    if ( !((v8 + 128) >> 32) )
      v18 = (unsigned int)v8 < 0xFFFFFF80;
    S->t[0] = v8 + 128;
    v19 = !v18;
    S->t[1] = v21 + (unsigned int)v19;
    blake2b_compress(S, S->buf);
    v20 = S->buflen - 128;
    S->buflen = v20;
    memcpy(S->buf, &S->buf[128], v20);
    buflen = S->buflen;
    v8 = S->t[0];
    v21 = S->t[1];
  }
  v9 = v8 + buflen;
  v10 = __CFADD__(HIDWORD(v8), HIDWORD(v9));
  last_node = S->last_node;
  S->t[0] = v9;
  S->t[1] = v21 + v10;
  if ( last_node )
    S->f[1] = -1;
  S->f[0] = -1;
  memset(&S->buf[buflen], 0, 256 - buflen);
  blake2b_compress(S, S->buf);
  p_buflen = &S[-1].buflen;
  v13 = buffer;
  v14 = &S->h[7];
  do
  {
    v15 = p_buflen[2];
    p_buflen += 2;
    v13 += 8;
    v16 = p_buflen[1];
    *(v13 - 8) = v15;
    *(v13 - 4) = v16;
    *(v13 - 7) = BYTE1(v15);
    *(v13 - 3) = BYTE1(v16);
    *(v13 - 2) = BYTE2(v16);
    *(v13 - 1) = HIBYTE(v16);
    *((_WORD *)v13 - 3) = HIWORD(v15);
  }
  while ( v14 != (uint64_t *)p_buflen );
  memcpy(out, buffer, v4);
  return 0;
}

//----- (00046B84) --------------------------------------------------------
int __fastcall blake2b(
        uint8_t *out,
        const void *in,
        const void *key,
        const uint8_t outlen,
        const uint64_t inlen,
        uint8_t keylen)
{
  _BOOL4 v6; // r4
  int v7; // r4
  bool v8; // cc
  blake2b_state S[1]; // [sp+0h] [bp-16Ch] BYREF

  v6 = inlen != 0;
  if ( in )
    v6 = 0;
  if ( !out )
    v6 = 1;
  if ( v6 )
    return -1;
  v7 = keylen;
  if ( keylen )
    v7 = 1;
  if ( key )
    v7 = 0;
  if ( v7 )
    return -1;
  v8 = keylen > 0x40u;
  if ( keylen <= 0x40u )
    v8 = (unsigned int)(outlen - 1) > 0x3F;
  if ( v8 )
    return -1;
  if ( keylen )
  {
    if ( blake2b_init_key(S, outlen, key, keylen) >= 0 )
      goto LABEL_16;
    return -1;
  }
  if ( blake2b_init(S, outlen) < 0 )
    return -1;
LABEL_16:
  blake2b_update(S, (const uint8_t *)in, inlen);
  blake2b_final(S, out, outlen);
  return 0;
}

//----- (00046C14) --------------------------------------------------------
void __fastcall Sha256_WriteByteBlock(CSha256 *p)
{
  uint32_t *v1; // r6
  unsigned __int8 *v2; // r5
  int v3; // r3
  CSha256 *v4; // r2
  _DWORD *v5; // r3
  uint32_t v6; // t1
  int v7; // r1
  int v8; // r10
  const uint32_t *v9; // r11
  const uint32_t *v10; // r9
  int v11; // lr
  int i; // r5
  int v13; // t1
  int v14; // r2
  int v15; // r7
  int v16; // r3
  int v17; // r1
  unsigned int v18; // r7
  unsigned int v19; // r10
  int v20; // r7
  int v21; // r1
  _DWORD *v22; // r2
  _DWORD *v23; // r3
  _DWORD *v24; // r6
  int v25; // r1
  _DWORD *v26; // r12
  _DWORD *v27; // r7
  int v28; // r5
  int v29; // t1
  _DWORD *v30; // r2
  CSha256 *v31; // r11
  uint32_t v32; // r3
  uint32_t v33; // t1
  int v34; // t1
  int v35; // [sp+34h] [bp-6Ch]
  CSha256 *v36; // [sp+38h] [bp-68h]
  _DWORD v37[8]; // [sp+40h] [bp-60h] BYREF
  char v38; // [sp+60h] [bp-40h] BYREF
  uint32_t data32[16]; // [sp+64h] [bp-3Ch] BYREF
  _DWORD v40[17]; // [sp+A4h] [bp+4h] BYREF

  v1 = (uint32_t *)&v38;
  v2 = (unsigned __int8 *)p;
  do
  {
    v3 = v2[41];
    v2 += 4;
    v1[1] = (v3 << 16) + (v2[36] << 24) + v2[39] + (v2[38] << 8);
    ++v1;
  }
  while ( &data32[15] != v1 );
  v4 = (CSha256 *)((char *)p - 4);
  v5 = v37;
  do
  {
    v6 = v4->state[1];
    v4 = (CSha256 *)((char *)v4 + 4);
    v5[1] = v6;
    ++v5;
  }
  while ( &p->state[7] != (uint32_t *)v4 );
  v7 = 1116352408;
  v37[0] = (char *)p - 4;
  v8 = 0;
  v9 = K;
  v36 = v4;
  while ( 1 )
  {
    v10 = v9;
    v11 = 0;
    v35 = v8;
    for ( i = v7; ; i = v13 )
    {
      v14 = v37[((4 - (_BYTE)v11) & 7) + 1];
      v15 = v37[((6 - (_BYTE)v11) & 7) + 1];
      v16 = __ROR4__(v14, 11) ^ __ROR4__(v14, 6) ^ __ROR4__(v14, 25);
      v17 = (v37[((5 - (_BYTE)v11) & 7) + 1] ^ v15) & v14 ^ v15;
      if ( v35 )
      {
        v18 = v40[((_BYTE)v11 - 2) & 0xF];
        v19 = v40[((_BYTE)v11 - 15) & 0xF];
        v20 = v40[((_BYTE)v11 - 7) & 0xF]
            + v40[v11]
            + (__ROR4__(v18, 19) ^ __ROR4__(v18, 17) ^ (v18 >> 10))
            + (__ROR4__(v19, 18) ^ __ROR4__(v19, 7) ^ (v19 >> 3));
      }
      else
      {
        v20 = data32[v11];
      }
      v40[v11] = v20;
      v21 = v17 + v16;
      v22 = &v40[((7 - (_BYTE)v11) & 7) + 16];
      v23 = &v40[((3 - (_BYTE)v11) & 7) + 16];
      v24 = &v40[(-v11 & 7) + 16];
      v25 = v21 + *(v22 - 40) + v20 + i;
      *(v22 - 40) = v25;
      v26 = &v40[((1 - (_BYTE)v11) & 7) + 16];
      v27 = &v40[((2 - (_BYTE)v11++) & 7) + 16];
      *(v23 - 40) += v25;
      v28 = *(v24 - 40);
      *(v22 - 40) += ((v28 | *(v26 - 40)) & *(v27 - 40) | *(v26 - 40) & v28)
                   + (__ROR4__(v28, 13) ^ __ROR4__(v28, 2) ^ __ROR4__(v28, 22));
      if ( v11 == 16 )
        break;
      v13 = v10[1];
      ++v10;
    }
    v8 = v35 + 16;
    if ( v35 == 48 )
      break;
    v29 = v9[16];
    v9 += 16;
    v7 = v29;
  }
  v30 = v37;
  v31 = (CSha256 *)v37[0];
  do
  {
    v33 = v31->state[1];
    v31 = (CSha256 *)((char *)v31 + 4);
    v32 = v33;
    v34 = v30[1];
    ++v30;
    v31->state[0] = v32 + v34;
  }
  while ( v36 != v31 );
}

//----- (00046E0C) --------------------------------------------------------
void __fastcall Sha256_Init(CSha256 *p)
{
  p->state[0] = 1779033703;
  p->state[1] = -1150833019;
  p->state[2] = 1013904242;
  p->state[3] = -1521486534;
  p->state[4] = 1359893119;
  p->count = 0;
  p->state[5] = -1694144372;
  p->state[6] = 528734635;
  p->state[7] = 1541459225;
}

//----- (00046E6C) --------------------------------------------------------
void __fastcall Sha256_Update(CSha256 *p, const uint8_t *data, size_t size)
{
  unsigned int count_high; // r5
  unsigned int count; // r0
  const uint8_t *v6; // r6
  int v7; // r3
  const uint8_t *v8; // r8
  char v9; // t1
  char *v10; // r1

  count_high = HIDWORD(p->count);
  count = p->count;
  if ( size )
  {
    v6 = data;
    v7 = count & 0x3F;
    v8 = &data[size];
    while ( 1 )
    {
      v9 = *v6++;
      v10 = (char *)p + v7++;
      v10[40] = v9;
      p->count = __PAIR64__(count_high, count) + 1;
      if ( v7 == 64 )
      {
        Sha256_WriteByteBlock(p);
        v7 = 0;
        if ( v6 == v8 )
          return;
      }
      else if ( v6 == v8 )
      {
        return;
      }
      count_high = HIDWORD(p->count);
      count = p->count;
    }
  }
}

//----- (00046EBC) --------------------------------------------------------
void __fastcall Sha256_Final(CSha256 *p, uint8_t *digest)
{
  uint8_t v2; // r10
  unsigned int count; // r3
  char v6; // r7
  unsigned int v7; // r9
  int v8; // r4
  int v9; // r4
  int v10; // r6
  CSha256 *v11; // r2
  int v12; // r3
  uint8_t *v13; // r3
  uint8_t *v14; // r2
  uint8_t *v15; // r8
  int v16; // t1

  count = p->count;
  v6 = (count & 0x3F) + 1;
  v7 = 8 * count;
  v8 = 8 * HIDWORD(p->count);
  p->buffer[count & 0x3F] = 0x80;
  if ( (count & 0x3F) != 0x37 )
    v2 = 0;
  v9 = v8 | (count >> 29);
  if ( (count & 0x3F) != 0x37 )
  {
    do
    {
      while ( 1 )
      {
        v10 = v6 & 0x3F;
        v6 = v10 + 1;
        if ( v10 )
          break;
        Sha256_WriteByteBlock(p);
        p->buffer[0] = 0;
      }
      p->buffer[v10] = v2;
    }
    while ( v10 != 55 );
  }
  v11 = (CSha256 *)&p->buffer[56];
  do
  {
    v12 = (v9 << 8) | HIBYTE(v7);
    LOBYTE(v11->state[0]) = HIBYTE(v9);
    v11 = (CSha256 *)((char *)v11 + 1);
    v7 <<= 8;
    v9 = v12;
  }
  while ( v11 != &p[1] );
  Sha256_WriteByteBlock(p);
  v13 = digest + 4;
  v14 = &p[-1].buffer[60];
  v15 = digest + 36;
  do
  {
    v16 = *((_DWORD *)v14 + 1);
    v14 += 4;
    v13 += 4;
    *(v13 - 8) = HIBYTE(v16);
    *(v13 - 7) = *((_WORD *)v14 + 1);
    *(v13 - 6) = BYTE1(*(_DWORD *)v14);
    *(v13 - 5) = *(_DWORD *)v14;
  }
  while ( v13 != v15 );
  p->state[0] = 1779033703;
  p->state[1] = -1150833019;
  p->state[2] = 1013904242;
  p->state[3] = -1521486534;
  p->state[4] = 1359893119;
  p->state[5] = -1694144372;
  p->state[6] = 528734635;
  p->state[7] = 1541459225;
  p->count = 0;
}
// 46EFA: variable 'v2' is possibly undefined

//----- (00046FBC) --------------------------------------------------------
void __fastcall Sha256_Onestep(const uint8_t *data, size_t size, uint8_t *digest)
{
  CSha256 p; // [sp+0h] [bp-68h] BYREF

  p.state[0] = 1779033703;
  p.state[1] = -1150833019;
  p.state[2] = 1013904242;
  p.state[3] = -1521486534;
  p.state[4] = 1359893119;
  p.state[6] = 528734635;
  p.state[7] = 1541459225;
  p.state[5] = -1694144372;
  p.count = 0;
  Sha256_Update(&p, data, size);
  Sha256_Final(&p, digest);
}

//----- (00047034) --------------------------------------------------------
void *__fastcall statusServiceThread(void *param)
{
  char *v2; // r8
  int v3; // r6
  ssize_t v4; // r0
  char v5; // r3
  char *v6; // r4
  char *v7; // r1
  const char *v9; // r5
  int v10; // r0
  int v11; // r1
  int v12; // r2
  int v13; // r3
  _DWORD *v14; // r5
  int v15; // r1
  int v16; // r2
  int v17; // r3
  int v18; // r7
  int v19; // r8
  int v20; // r8
  int v21; // r8
  int v22; // r8
  int v23; // r8
  int v24; // r0
  size_t v25; // r0
  unsigned int v26; // r8
  ssize_t v27; // r0
  ssize_t v28; // r11
  signed int len; // [sp+Ch] [bp-7030h]
  char sendbuf[4]; // [sp+10h] [bp-702Ch] BYREF
  int recvlen; // [sp+14h] [bp-7028h] BYREF
  char endofrequest[8]; // [sp+18h] [bp-7024h] BYREF
  timeval timeout; // [sp+20h] [bp-701Ch] BYREF
  sockaddr_in from; // [sp+28h] [bp-7014h] BYREF
  char buf[4096]; // [sp+38h] [bp-7004h] BYREF
  char tmp42_0[4096]; // [sp+1038h] [bp-6004h] BYREF
  char recvbuf[10240]; // [sp+2038h] [bp-5004h] BYREF
  char tmp42[4096]; // [sp+4838h] [bp-2804h] BYREF

  timeout.tv_sec = 3;
  timeout.tv_usec = 0;
  memset(buf, 0, sizeof(buf));
  strcpy(sendbuf, "\r\n");
  v2 = recvbuf;
  recvlen = 0;
  strcpy(endofrequest, "\r\n\r\n");
  v3 = 0;
  memset(recvbuf, 0, sizeof(recvbuf));
  do
  {
    if ( ExitServer )
      goto LABEL_7;
    v4 = recvfrom((int)param, v2, 10239 - v3, 0, (struct sockaddr *)&from, (socklen_t *)&recvlen);
    v3 += v4;
    if ( v4 <= 0 )
    {
      close((int)param);
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return 0;
      strcpy(tmp42, ":statusServiceThread recvfrom<=0");
      applog(7, tmp42, 0);
      return 0;
    }
    v2 = &recvbuf[v3];
    if ( v3 > 10238 )
    {
      close((int)param);
      if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
        return 0;
      strcpy(tmp42, "BUFSIZE is too small!");
      applog(7, tmp42, 0);
      return 0;
    }
  }
  while ( !strstr(recvbuf, endofrequest) );
  if ( opt_debug )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(tmp42, "find http request end flag!");
      applog(7, tmp42, 0);
LABEL_7:
      if ( opt_debug )
      {
        if ( !use_syslog )
          goto LABEL_9;
LABEL_11:
        snprintf(tmp42, 0x1000u, "get http=%s", recvbuf);
        applog(7, tmp42, 0);
      }
    }
    else
    {
LABEL_9:
      if ( opt_log_output || opt_log_level > 6 )
        goto LABEL_11;
    }
  }
  if ( recvbuf[0] != 71 || recvbuf[1] != 69 || recvbuf[2] != 84 || recvbuf[3] != 32 )
  {
    close((int)param);
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      qmemcpy(tmp42, "statusServiceThread not support http command", 44);
      v5 = aStatusservicet[44];
      v6 = &tmp42[44];
      v7 = tmp42;
      goto LABEL_19;
    }
    return 0;
  }
  if ( strstr(&recvbuf[4], "/rate") )
  {
    if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
    {
      strcpy(tmp42, "cmd : get rate");
      applog(7, tmp42, 0);
    }
    if ( freq_scan_status == 1 )
    {
      snprintf(buf, 0x1000u, "%d", &bench_hidiffs[900]);
    }
    else if ( freq_scan_status == 2 )
    {
      snprintf(buf, 0x1000u, "%s:%s", "searchfailed", "search_failed_info");
    }
    else
    {
      strcpy(buf, "searching");
    }
    goto LABEL_46;
  }
  if ( !strstr(&recvbuf[4], "/productName") )
  {
    close((int)param);
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return 0;
    strcpy(tmp42, "statusServiceThread exit for Error cmd!");
    applog(7, tmp42, 0);
    return 0;
  }
  if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
  {
    strcpy(tmp42, "cmd : get miner type");
    applog(7, tmp42, 0);
  }
  snprintf(buf, 0x1000u, g_miner_type);
LABEL_46:
  if ( setsockopt((int)param, 1, 21, &timeout, 8u) )
  {
    close((int)param);
    if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
      return 0;
    v9 = "setsockopt SO_SNDTIMEO failed";
    goto LABEL_52;
  }
  v18 = setsockopt((int)param, 1, 20, &timeout, 8u);
  if ( !v18 )
  {
    len = strlen(buf);
    v19 = sprintf(tmp42, "HTTP/1.0  200  OK%s", sendbuf);
    v20 = v19 + sprintf(&tmp42[v19], "Server: SearchFreqServer%s", sendbuf);
    v21 = v20 + sprintf(&tmp42[v20], "Cache-Control: no-cache%s", sendbuf);
    v22 = v21 + sprintf(&tmp42[v21], "Pragma: no-cache%s", sendbuf);
    v23 = v22 + sprintf(&tmp42[v22], "Content-Type: text/plain%s", sendbuf);
    v24 = sprintf(&tmp42[v23], "Content-Length: %d%s", len, sendbuf);
    sprintf(&tmp42[v24 + v23], "Connection: Keep-Alive%s", endofrequest);
    if ( !opt_debug )
    {
      if ( ExitServer )
        goto LABEL_87;
      goto LABEL_74;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(tmp42_0, "send http response...\n");
      applog(7, tmp42_0, 0);
      if ( !ExitServer )
      {
LABEL_74:
        v25 = strlen(tmp42);
        v26 = 0;
        do
        {
          v27 = send((int)param, &tmp42[v26], v25 - v26, 0);
          if ( v27 == -1 )
          {
            if ( *_errno_location() != 11 )
            {
LABEL_81:
              close((int)param);
              if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
              {
                qmemcpy(tmp42_0, "statusServiceThread send http response error", 44);
                v5 = aStatusservicet_1[44];
                v6 = &tmp42_0[44];
                v7 = tmp42_0;
LABEL_19:
                *v6 = v5;
                applog(7, v7, 0);
              }
              return 0;
            }
            if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
            {
              strcpy(tmp42_0, "statusServiceThread send http timeout, try again...");
              applog(7, tmp42_0, 0);
            }
            usleep((__useconds_t)&loc_1869E + 2);
          }
          else
          {
            if ( v27 <= 0 )
              goto LABEL_81;
            v26 += v27;
          }
          v25 = strlen(tmp42);
        }
        while ( v25 > v26 && !ExitServer );
      }
      if ( !opt_debug )
        goto LABEL_87;
    }
    else if ( !ExitServer )
    {
      goto LABEL_74;
    }
    if ( use_syslog || opt_log_output || opt_log_level > 6 )
    {
      strcpy(tmp42_0, "send http data...");
      applog(7, tmp42_0, 0);
    }
    while ( 1 )
    {
LABEL_87:
      v28 = send((int)param, &buf[v18], len - v18, 0);
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42_0, 0x1000u, "send http data ret=%d", v28);
        applog(7, tmp42_0, 0);
      }
      if ( v28 <= 0 )
        break;
      v18 += v28;
      if ( len <= v18 || ExitServer )
        goto LABEL_95;
    }
    if ( opt_debug )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 6 )
      {
        strcpy(tmp42_0, "statusServiceThread send http data error");
        applog(7, tmp42_0, 0);
LABEL_95:
        if ( !opt_debug )
          goto LABEL_100;
        if ( use_syslog )
          goto LABEL_99;
      }
      if ( opt_log_output || opt_log_level > 6 )
      {
LABEL_99:
        strcpy(tmp42_0, "one client disconnected!");
        applog(7, tmp42_0, 0);
      }
    }
LABEL_100:
    close((int)param);
    return (void *)v18;
  }
  close((int)param);
  if ( !opt_debug || !use_syslog && !opt_log_output && opt_log_level <= 6 )
    return 0;
  v9 = "setsockopt SO_RCVTIMEO failed";
LABEL_52:
  v10 = *(_DWORD *)v9;
  v11 = *((_DWORD *)v9 + 1);
  v12 = *((_DWORD *)v9 + 2);
  v13 = *((_DWORD *)v9 + 3);
  v14 = v9 + 16;
  *(_DWORD *)tmp42 = v10;
  *(_DWORD *)&tmp42[4] = v11;
  *(_DWORD *)&tmp42[8] = v12;
  *(_DWORD *)&tmp42[12] = v13;
  v15 = v14[1];
  v16 = v14[2];
  v17 = v14[3];
  *(_DWORD *)&tmp42[16] = *v14;
  *(_DWORD *)&tmp42[20] = v15;
  *(_DWORD *)&tmp42[24] = v16;
  *(_WORD *)&tmp42[28] = v17;
  applog(7, tmp42, 0);
  return 0;
}

//----- (000479BC) --------------------------------------------------------
void *__fastcall httpListenThread(void *param)
{
  int v1; // r0
  int v2; // r0
  void *v3; // r4
  int addr_len; // [sp+10h] [bp-102Ch] BYREF
  int v6; // [sp+14h] [bp-1028h] BYREF
  sockaddr_in service; // [sp+18h] [bp-1024h] BYREF
  sockaddr_in client_addr; // [sp+28h] [bp-1014h] BYREF
  char tmp42[4100]; // [sp+38h] [bp-1004h] BYREF

  sleep(0x1Eu);
  do
  {
    v1 = socket(2, 1, 6);
    listen_sockfd = v1;
    if ( v1 < 0 )
    {
      if ( use_syslog || opt_log_output || opt_log_level > 4 )
      {
        strcpy(tmp42, "socket creating failed, try again after 10s...");
        applog(5, tmp42, 0);
      }
      sleep(0xAu);
    }
    else
    {
      v6 = 1;
      if ( setsockopt(v1, 1, 2, &v6, 4u) < 0 && (use_syslog || opt_log_output || opt_log_level > 3) )
      {
        strcpy(tmp42, "*******************setsockopt(SO_REUSEADDR) failed");
        applog(4, tmp42, 0);
      }
      memset(&service.sin_addr, 0, 12);
      *(_DWORD *)&service.sin_family = -1407778814;
      if ( bind(listen_sockfd, (const struct sockaddr *)&service, 0x10u) < 0 )
      {
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy(tmp42, "http port bind failed! try again after 10s...");
          applog(5, tmp42, 0);
        }
      }
      else
      {
        if ( listen(listen_sockfd, 100) >= 0 )
          break;
        if ( use_syslog || opt_log_output || opt_log_level > 4 )
        {
          strcpy(tmp42, "http listen failed! try again after 10s...");
          applog(5, tmp42, 0);
        }
      }
      close(listen_sockfd);
      listen_sockfd = -1;
      sleep(0xAu);
    }
  }
  while ( !ExitServer );
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    strcpy(tmp42, "start listen on 6060 ...");
    applog(5, tmp42, 0);
  }
  if ( !ExitServer )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        usleep(0x2710u);
        addr_len = 16;
        v2 = accept(listen_sockfd, (struct sockaddr *)&client_addr, (socklen_t *)&addr_len);
        v3 = (void *)v2;
        if ( v2 != -1 )
          break;
        if ( ExitServer )
          goto LABEL_20;
      }
      if ( ExitServer )
        break;
      if ( opt_debug && (use_syslog || opt_log_output || opt_log_level > 6) )
      {
        snprintf(tmp42, 0x1000u, "one client connected sock=%d", v2);
        applog(7, tmp42, 0);
      }
      statusServiceThread(v3);
      if ( ExitServer )
        goto LABEL_20;
    }
    close(v2);
  }
LABEL_20:
  close(listen_sockfd);
  listen_sockfd = -1;
  return 0;
}

//----- (00047CA4) --------------------------------------------------------
void start_http_thread()
{
  int v0; // r0
  pthread_t tid_ctrl; // [sp+0h] [bp-102Ch] BYREF
  pthread_attr_t tattr_ctrl; // [sp+4h] [bp-1028h] BYREF
  char tmp42[4100]; // [sp+28h] [bp-1004h] BYREF

  pthread_attr_init(&tattr_ctrl);
  pthread_attr_setstacksize(&tattr_ctrl, 0x200000u);
  v0 = pthread_create(&tid_ctrl, &tattr_ctrl, httpListenThread, 0);
  if ( use_syslog || opt_log_output || opt_log_level > 4 )
  {
    snprintf(tmp42, 0x1000u, "httpListenThread start ret=%d", v0);
    applog(5, tmp42, 0);
  }
}

//----- (00047D28) --------------------------------------------------------
void __fastcall xxtea_encode(uint32_t *v, int n, const uint32_t *key)
{
  uint32_t *v3; // r9
  unsigned int v4; // r4
  int v5; // r10
  unsigned int v6; // lr
  uint32_t *v7; // r6
  int v8; // r5
  unsigned int v9; // r12
  uint32_t v10; // r3
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( n <= 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(tmp42, "XXTEA encode failes, N <= 1 found.\n");
      applog(3, tmp42, 0);
    }
  }
  else
  {
    v3 = &v[n - 1];
    v4 = *v3;
    v5 = n - 1;
    v6 = 0;
    do
    {
      v7 = v;
      v8 = 0;
      v6 -= 1640531527;
      v9 = v6 >> 2;
      do
      {
        v10 = key[((unsigned __int8)v9 ^ (unsigned __int8)v8++) & 3];
        v4 = *v7 + (((v10 ^ v4) + (v6 ^ v7[1])) ^ (((4 * v7[1]) ^ (v4 >> 5)) + ((16 * v4) ^ (v7[1] >> 3))));
        *v7++ = v4;
      }
      while ( v8 != v5 );
      v4 = (((v4 ^ key[((unsigned __int8)v9 ^ (unsigned __int8)v5) & 3]) + (v6 ^ *v))
          ^ (((4 * *v) ^ (v4 >> 5)) + ((16 * v4) ^ (*v >> 3))))
         + *v3;
      *v3 = v4;
    }
    while ( v6 != -1253254570 - 1640531527 * (52 / n) );
  }
}

//----- (00047E4C) --------------------------------------------------------
void __fastcall xxtea_decode(uint32_t *v, int n, const uint32_t *key)
{
  unsigned int v4; // r2
  unsigned int v5; // r3
  int v6; // r10
  int v7; // r6
  unsigned int v8; // r12
  uint32_t *v9; // r7
  unsigned int v10; // t1
  uint32_t v11; // r11
  int v12; // r6
  char tmp42[4100]; // [sp+8h] [bp-1004h] BYREF

  if ( n <= 1 )
  {
    if ( use_syslog || opt_log_output || opt_log_level > 2 )
    {
      strcpy(tmp42, "XXTEA decode failes, N <= 1 found.\n");
      applog(3, tmp42, 0);
    }
  }
  else
  {
    v4 = -1640531527 * (52 / n + 6);
    v5 = *v;
    v6 = v4 + 1640531527 * (52 / n) + 1253254570;
    do
    {
      v7 = n - 1;
      v8 = v4 >> 2;
      v9 = &v[n - 1];
      do
      {
        v10 = *--v9;
        v11 = key[((unsigned __int8)v8 ^ (unsigned __int8)v7--) & 3];
        v5 = v9[1] - (((v10 ^ v11) + (v4 ^ v5)) ^ (((4 * v5) ^ (v10 >> 5)) + ((16 * v10) ^ (v5 >> 3))));
        v9[1] = v5;
      }
      while ( v7 );
      v12 = v5 ^ v4;
      v4 += 1640531527;
      v5 = *v - ((((16 * v[n - 1]) ^ (v5 >> 3)) + ((4 * v5) ^ (v[n - 1] >> 5))) ^ ((v[n - 1] ^ key[v8 & 3]) + v12));
      *v = v5;
    }
    while ( v4 != v6 );
  }
}

//----- (00047F78) --------------------------------------------------------
int __fastcall object_key_compare_serials(const void *key1, const void *key2)
{
  if ( *(_DWORD *)key1 < *(_DWORD *)key2 )
    return -1;
  else
    return *(_DWORD *)key1 != *(_DWORD *)key2;
}

//----- (00047F90) --------------------------------------------------------
int __fastcall dump_to_strbuffer(const char *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (00047F9C) --------------------------------------------------------
int __fastcall dump_to_file(const char *buffer, size_t size, void *data)
{
  int result; // r0

  result = fwrite(buffer, size, 1u, (FILE *)data) - 1;
  if ( result )
    return -1;
  return result;
}

//----- (00047FB4) --------------------------------------------------------
int __fastcall object_key_compare_keys(const void *key1, const void *key2)
{
  return sub_11F78(*((const char **)key1 + 1), *((const char **)key2 + 1));
}

//----- (00047FBC) --------------------------------------------------------
int __fastcall dump_indent(size_t flags, int depth, int space, json_dump_callback_t dump, void *data)
{
  size_t v5; // r9
  int v8; // r4

  v5 = flags & 0x1F;
  if ( (flags & 0x1F) != 0 )
  {
    v8 = dump((const char *)&word_58FE4, 1, data);
    if ( !v8 )
    {
      if ( depth <= 0 )
        return 0;
      while ( 1 )
      {
        ++v8;
        if ( dump("                                ", v5, data) )
          break;
        if ( depth == v8 )
          return 0;
      }
    }
    return -1;
  }
  if ( !space || (flags & 0x20) != 0 )
    return 0;
  return dump(" ", 1, data);
}
// 58FE4: using guessed type __int16 word_58FE4;

//----- (0004802C) --------------------------------------------------------
int __fastcall dump_string(const char *str, json_dump_callback_t dump, void *data, size_t flags)
{
  const char *v7; // r11
  const char *v9; // r5
  bool v10; // zf
  int v11; // r1
  char *v12; // r0
  size_t v13; // r1
  int v14; // r3
  unsigned int v15; // r2
  int32_t codepoint; // [sp+Ch] [bp-18h] BYREF
  char seq[20]; // [sp+10h] [bp-14h] BYREF

  if ( ((int (__fastcall *)(char *, int))dump)("\"", 1) )
    return -1;
  v7 = str;
  while ( *v7 )
  {
    v9 = utf8_iterate(v7, &codepoint);
    if ( !v9 )
      return -1;
    v10 = codepoint == 34;
    if ( codepoint != 34 )
      v10 = codepoint == 92;
    v11 = v10;
    if ( codepoint <= 31 )
      v11 |= 1u;
    if ( v11 || ((codepoint == 47) & (flags >> 10)) != 0 || ((codepoint > 127) & (flags >> 6)) != 0 )
    {
      if ( v7 != str && dump(str, v7 - str, data) )
        return -1;
      if ( v7 == v9 )
        return dump("\"", 1, data);
      if ( codepoint == 12 )
      {
        v13 = 2;
        v12 = "\\f";
        goto LABEL_26;
      }
      if ( codepoint <= 12 )
      {
        switch ( codepoint )
        {
          case 9:
            v12 = "\\t";
            v13 = 2;
            goto LABEL_26;
          case 10:
            v12 = "\\n";
            v13 = 2;
            goto LABEL_26;
          case 8:
            v12 = "\\b";
            v13 = 2;
            goto LABEL_26;
        }
        goto LABEL_31;
      }
      if ( codepoint == 34 )
      {
        v12 = "\\\"";
        v13 = 2;
        goto LABEL_26;
      }
      if ( codepoint > 34 )
      {
        if ( codepoint == 47 )
        {
          v12 = "\\/";
          v13 = 2;
          goto LABEL_26;
        }
        if ( codepoint == 92 )
        {
          v12 = "\\\\";
          v13 = 2;
          goto LABEL_26;
        }
LABEL_31:
        if ( codepoint < 0x10000 )
          goto LABEL_32;
        v14 = (codepoint - 0x10000) & 0x3FF | 0xDC00;
        v15 = ((unsigned int)(codepoint - 0x10000) >> 10) & 0x3FF | 0xD800;
        codepoint -= 0x10000;
        sprintf(seq, "\\u%04x\\u%04x", v15, v14);
        v12 = seq;
        v13 = 12;
        goto LABEL_26;
      }
      if ( codepoint != 13 )
      {
LABEL_32:
        sprintf(seq, "\\u%04x", codepoint);
        v12 = seq;
        v13 = 6;
        goto LABEL_26;
      }
      v12 = "\\r";
      v13 = 2;
LABEL_26:
      if ( dump(v12, v13, data) )
        return -1;
      str = v9;
      v7 = v9;
    }
    else
    {
      v7 = v9;
    }
  }
  if ( v7 == str || !dump(str, v7 - str, data) )
    return dump("\"", 1, data);
  return -1;
}
// 48128: conditional instruction was optimized away because %codepoint.4 is in (E..21)

//----- (000481CC) --------------------------------------------------------
int __fastcall do_dump(int a1, size_t a2, size_t a3, int (*a4)(const char *, size_t, void *), void *data)
{
  int v6; // r4
  char *v10; // r11
  int v11; // r8
  void *v12; // r7
  signed int v13; // r7
  const char *v14; // r0
  json_int_t v15; // r0
  int v16; // r0
  double v17; // r2
  int v18; // r1
  const char **v19; // r0
  const char **v20; // r9
  void *v21; // r6
  unsigned int i; // r11
  unsigned int v23; // r2
  char *v24; // r11
  const char **v25; // r7
  int (*v26)(const void *, const void *); // r3
  unsigned int v27; // r9
  int v28; // r8
  const char *v29; // r4
  json_t *v30; // r10
  json_t *v31; // r10
  void *v32; // r4
  const char *v33; // r0
  json_t *v34; // r0
  int v35; // r9
  signed int v36; // r8
  json_t *v37; // r0
  size_t json; // [sp+Ch] [bp-ACh]
  json_t *jsona; // [sp+Ch] [bp-ACh]
  size_t nmemb; // [sp+10h] [bp-A8h]
  size_t nmemba; // [sp+10h] [bp-A8h]
  char *v42; // [sp+14h] [bp-A4h]
  int v43; // [sp+14h] [bp-A4h]
  int depth; // [sp+18h] [bp-A0h]
  int deptha; // [sp+18h] [bp-A0h]
  unsigned int v46; // [sp+1Ch] [bp-9Ch]
  size_t v47; // [sp+20h] [bp-98h]
  const char **base; // [sp+24h] [bp-94h]
  char s[140]; // [sp+2Ch] [bp-8Ch] BYREF

  if ( !a1 )
    return -1;
  v6 = a1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      v10 = ":";
      if ( (a2 & 0x20) != 0 )
        v11 = 1;
      else
        v11 = 2;
      if ( (a2 & 0x20) == 0 )
        v10 = ": ";
      if ( *(_DWORD *)(a1 + 32) )
        goto object_error;
      *(_DWORD *)(a1 + 32) = 1;
      v12 = json_object_iter((json_t *)a1);
      if ( a4("{", 1, data) )
        goto object_error;
      if ( !v12 )
        goto LABEL_12;
      deptha = a3 + 1;
      if ( dump_indent(a2, a3 + 1, 0, a4, data) )
        goto object_error;
      if ( (a2 & 0x180) != 0 )
      {
        json = json_object_size((const json_t *)v6);
        v19 = (const char **)jsonp_malloc(8 * json);
        base = v19;
        if ( v19 )
        {
          v42 = v10;
          v47 = a2;
          v20 = v19 + 1;
          v21 = v12;
          for ( i = 0; ; ++i )
          {
            *(v20 - 1) = (const char *)hashtable_iter_serial(v21);
            *v20 = json_object_iter_key(v21);
            v20 += 2;
            v21 = json_object_iter_next((json_t *)v6, v21);
            if ( !v21 )
              break;
          }
          v23 = i + 1;
          nmemb = i + 1;
          v46 = i;
          v24 = v42;
          if ( json != v23 )
            _assert_fail("i == size", "dump.c", 0x141u, "do_dump");
          v25 = base;
          v26 = object_key_compare_serials;
          v27 = 0;
          if ( (v47 & 0x80) != 0 )
            v26 = object_key_compare_keys;
          qsort(base, nmemb, 8u, v26);
          v43 = v11;
          jsona = (json_t *)v6;
          v28 = a3 + 1;
          depth = a3;
          while ( 1 )
          {
            v29 = v25[1];
            v30 = json_object_get(jsona, v29);
            if ( !v30 )
              _assert_fail("value", "dump.c", 0x151u, "do_dump");
            dump_string(v29, a4, data, v47);
            if ( a4(v24, v43, data) || do_dump((int)v30, v47, v28, (int)a4, data) )
              break;
            if ( v27 < v46 )
            {
              if ( a4(",", 1, data) || dump_indent(v47, v28, 1, a4, data) )
                break;
            }
            else if ( dump_indent(v47, depth, 0, a4, data) )
            {
              break;
            }
            ++v27;
            v25 += 2;
            if ( v27 == nmemb )
            {
              v6 = (int)jsona;
              jsonp_free(base);
LABEL_12:
              *(_DWORD *)(v6 + 32) = 0;
              return a4("}", 1, data);
            }
          }
          v6 = (int)jsona;
          jsonp_free(base);
        }
      }
      else
      {
        nmemba = a3;
        v31 = (json_t *)v6;
        while ( 1 )
        {
          v32 = json_object_iter_next(v31, v12);
          v33 = json_object_iter_key(v12);
          dump_string(v33, a4, data, a2);
          if ( a4(v10, v11, data) || (v34 = json_object_iter_value(v12), do_dump((int)v34, a2, deptha, (int)a4, data)) )
          {
LABEL_49:
            v6 = (int)v31;
            goto object_error;
          }
          if ( !v32 )
            break;
          if ( !a4(",", 1, data) )
          {
            v12 = v32;
            if ( !dump_indent(a2, deptha, 1, a4, data) )
              continue;
          }
          goto LABEL_49;
        }
        v6 = (int)v31;
        if ( !dump_indent(a2, nmemba, 0, a4, data) )
          goto LABEL_12;
      }
object_error:
      *(_DWORD *)(v6 + 32) = 0;
      return -1;
    case 1:
      if ( *(_DWORD *)(a1 + 20) )
        goto array_error;
      *(_DWORD *)(a1 + 20) = 1;
      v13 = json_array_size((const json_t *)a1);
      if ( a4("[", 1, data) )
        goto array_error;
      if ( !v13 )
        goto LABEL_16;
      v35 = a3 + 1;
      v36 = dump_indent(a2, a3 + 1, 0, a4, data);
      if ( v36 )
        goto array_error;
      if ( v13 <= 0 )
        goto LABEL_16;
      break;
    case 2:
      v14 = json_string_value((const json_t *)a1);
      return dump_string(v14, a4, data, a2);
    case 3:
      v15 = json_integer_value((const json_t *)a1);
      v16 = snprintf(s, 0x64u, "%lld", v15);
      return a4(s, v16, data);
    case 4:
      json_real_value((const json_t *)a1);
      v18 = jsonp_dtostr(s, 0x64u, v17);
      if ( v18 < 0 )
        return -1;
      return a4(s, v18, data);
    case 5:
      return a4("true", 4, data);
    case 6:
      return a4("false", 5, data);
    case 7:
      return a4("null", 4, data);
    default:
      return -1;
  }
  while ( 1 )
  {
    v37 = json_array_get((const json_t *)v6, v36);
    if ( do_dump((int)v37, a2, v35, (int)a4, data) )
      break;
    if ( v13 - 1 <= v36 )
    {
      if ( dump_indent(a2, a3, 0, a4, data) )
        break;
    }
    else if ( a4(",", 1, data) || dump_indent(a2, v35, 1, a4, data) )
    {
      break;
    }
    if ( v13 == ++v36 )
    {
LABEL_16:
      *(_DWORD *)(v6 + 20) = 0;
      return a4((const char *)&word_59A90, 1, data);
    }
  }
array_error:
  *(_DWORD *)(v6 + 20) = 0;
  return -1;
}
// 482F0: variable 'v17' is possibly undefined
// 59A90: using guessed type __int16 word_59A90;

//----- (00048630) --------------------------------------------------------
int __fastcall json_dump_callback(const json_t *json, json_dump_callback_t callback, void *data, size_t flags)
{
  if ( (flags & 0x200) != 0 || json && json->type <= (unsigned int)JSON_ARRAY )
    return do_dump((int)json, (unsigned __int16)flags, 0, callback, data);
  else
    return -1;
}

//----- (00048658) --------------------------------------------------------
char *__fastcall json_dumps(const json_t *json, size_t flags)
{
  char *v4; // r4
  const char *v6; // r0
  strbuffer_t strbuff; // [sp+4h] [bp-Ch] BYREF

  v4 = 0;
  if ( !strbuffer_init(&strbuff) )
  {
    v4 = 0;
    if ( !json_dump_callback(json, dump_to_strbuffer, &strbuff, flags) )
    {
      v6 = strbuffer_value(&strbuff);
      v4 = jsonp_strdup(v6);
    }
    strbuffer_close(&strbuff);
  }
  return v4;
}

//----- (0004869C) --------------------------------------------------------
int __fastcall json_dumpf(const json_t *json, FILE *output, size_t flags)
{
  return json_dump_callback(json, dump_to_file, output, flags);
}

//----- (000486AC) --------------------------------------------------------
int __fastcall json_dump_file(const json_t *json, const char *path, size_t flags)
{
  const char *v4; // r1
  FILE *v7; // r0
  FILE *v8; // r4
  json_dump_callback_t v9; // r1
  int v10; // r5

  LOWORD(v4) = 21556;
  HIWORD(v4) = (unsigned int)"create_bitmain_read_temp_pthread" >> 16;
  v7 = fopen(path, v4);
  if ( !v7 )
    return -1;
  v8 = v7;
  LOWORD(v9) = 32669;
  HIWORD(v9) = (unsigned int)&bench_hidiffs[3513] >> 16;
  v10 = json_dump_callback(json, v9, v7, flags);
  fclose(v8);
  return v10;
}

//----- (000486EC) --------------------------------------------------------
pair_t *__fastcall hashtable_find_pair(hashtable_t *hashtable, bucket_t *bucket, const char *key, size_t hash)
{
  hashtable_list *first; // r4

  first = bucket->first;
  if ( bucket->first == &hashtable->list && first == bucket->last )
    return 0;
  while ( first[-1].next != (hashtable_list *)hash || strcmp((const char *)&first[2], key) )
  {
    if ( bucket->last == first )
      return 0;
    first = first->next;
  }
  return (pair_t *)&first[-1].next;
}

//----- (00048734) --------------------------------------------------------
void __fastcall hashtable_do_clear(hashtable_t *hashtable)
{
  hashtable_list *p_list; // r6
  hashtable_t *next; // r4
  json_t *num_buckets; // r0
  hashtable_list **p_next; // r5
  size_t refcount; // r3
  bool v6; // zf
  size_t v7; // r3

  p_list = &hashtable->list;
  next = (hashtable_t *)hashtable->list.next;
  if ( next != (hashtable_t *)&hashtable->list )
  {
    do
    {
      num_buckets = (json_t *)next->num_buckets;
      p_next = &next[-1].list.next;
      next = (hashtable_t *)next->buckets;
      if ( num_buckets )
      {
        refcount = num_buckets->refcount;
        v6 = refcount == -1;
        v7 = refcount - 1;
        if ( !v6 )
        {
          num_buckets->refcount = v7;
          if ( !v7 )
            json_delete(num_buckets);
        }
      }
      jsonp_free(p_next);
    }
    while ( next != (hashtable_t *)p_list );
  }
}

//----- (00048768) --------------------------------------------------------
int __fastcall hashtable_init(hashtable_t *hashtable)
{
  hashtable_bucket *v2; // r0
  size_t num_buckets; // r1
  hashtable_list *p_list; // r3
  size_t v5; // r2
  hashtable_bucket *v6; // r2

  hashtable->size = 0;
  hashtable->num_buckets = 0;
  v2 = (hashtable_bucket *)jsonp_malloc(0x28u);
  hashtable->buckets = v2;
  if ( !v2 )
    return -1;
  num_buckets = hashtable->num_buckets;
  p_list = &hashtable->list;
  hashtable->list.next = &hashtable->list;
  v5 = primes[num_buckets];
  hashtable->list.prev = &hashtable->list;
  if ( v5 )
  {
    v6 = &v2[v5];
    do
    {
      v2->last = p_list;
      v2->first = p_list;
      ++v2;
    }
    while ( v2 != v6 );
  }
  return 0;
}

//----- (000487AC) --------------------------------------------------------
void __fastcall hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear(hashtable);
  jsonp_free(hashtable->buckets);
}

//----- (000487C0) --------------------------------------------------------
int __fastcall hashtable_set(hashtable_t *hashtable, const char *key, size_t serial, json_t *value)
{
  size_t v6; // r1
  hashtable_bucket *buckets; // r10
  int v9; // r3
  size_t v10; // r4
  const char *v11; // r2
  size_t v12; // r0
  int v13; // t1
  bucket_t *v14; // r10
  pair_t *pair; // r0
  pair_t *v16; // r6
  json_t *v17; // r0
  size_t refcount; // r3
  size_t v19; // r3
  size_t v21; // r0
  _DWORD *v22; // r0
  _DWORD *v23; // r6
  char *v24; // r0
  hashtable_t *first; // r2
  hashtable_list *v26; // r3
  size_t v27; // r3
  size_t v28; // r11
  hashtable_bucket *v29; // r0
  hashtable_list *p_list; // r9
  hashtable_bucket *v31; // r0
  hashtable_bucket *v32; // r2
  hashtable_list *next; // r4
  int v34; // r1
  hashtable_list v35; // r2
  hashtable_bucket *v36; // r1
  hashtable_list *v37; // r0
  size_t num_buckets; // [sp+4h] [bp-8h]

  v6 = primes[hashtable->num_buckets];
  buckets = hashtable->buckets;
  if ( hashtable->size >= v6 )
  {
    jsonp_free(hashtable->buckets);
    v27 = hashtable->num_buckets + 1;
    v28 = primes[v27];
    hashtable->num_buckets = v27;
    v29 = (hashtable_bucket *)jsonp_malloc(8 * v28);
    buckets = v29;
    hashtable->buckets = v29;
    if ( !v29 )
      return -1;
    p_list = &hashtable->list;
    v6 = primes[hashtable->num_buckets];
    num_buckets = hashtable->num_buckets;
    if ( v6 )
    {
      v31 = &v29[v6];
      v32 = buckets;
      do
      {
        v32->last = p_list;
        v32->first = p_list;
        ++v32;
      }
      while ( v31 != v32 );
    }
    next = hashtable->list.next;
    hashtable->list.prev = p_list;
    hashtable->list.next = p_list;
    if ( next != p_list )
    {
      do
      {
        while ( 1 )
        {
          v34 = (unsigned int)next[-1].next % v28;
          v35.next = buckets[v34].first;
          v36 = &buckets[v34];
          v37 = next->next;
          if ( v35.next == p_list && p_list == v36->last )
            break;
          v35.prev = v35.next->prev;
          *next = v35;
          v35.next->prev->next = next;
          v35.next->prev = next;
          v36->first = next;
          next = v37;
          if ( v37 == p_list )
            goto LABEL_25;
        }
        next->prev = hashtable->list.prev;
        next->next = p_list;
        hashtable->list.prev->next = next;
        hashtable->list.prev = next;
        v36->first = next;
        v36->last = next;
        next = v37;
      }
      while ( v37 != p_list );
LABEL_25:
      buckets = hashtable->buckets;
      v6 = primes[num_buckets];
    }
  }
  v9 = *(unsigned __int8 *)key;
  v10 = 5381;
  if ( *key )
  {
    v11 = key;
    v10 = 5381;
    do
    {
      v12 = v9 + 32 * v10;
      v13 = *(unsigned __int8 *)++v11;
      v9 = v13;
      v10 += v12;
    }
    while ( v13 );
  }
  v14 = &buckets[v10 % v6];
  pair = hashtable_find_pair(hashtable, v14, key, v10);
  v16 = pair;
  if ( pair )
  {
    v17 = pair->value;
    if ( v17 )
    {
      refcount = v17->refcount;
      if ( refcount != -1 )
      {
        v19 = refcount - 1;
        v17->refcount = v19;
        if ( !v19 )
          json_delete(v17);
      }
    }
    v16->value = value;
    return 0;
  }
  v21 = strlen(key);
  v22 = jsonp_malloc(v21 + 21);
  v23 = v22;
  if ( !v22 )
    return -1;
  *v22 = v10;
  v24 = (char *)(v22 + 5);
  *((_DWORD *)v24 - 1) = serial;
  strcpy(v24, key);
  first = (hashtable_t *)v14->first;
  v26 = (hashtable_list *)(v23 + 1);
  v23[2] = v23 + 1;
  v23[3] = value;
  v23[1] = v23 + 1;
  if ( first == (hashtable_t *)&hashtable->list && first == (hashtable_t *)v14->last )
  {
    v23[1] = hashtable->list.prev;
    v23[2] = first;
    hashtable->list.prev->next = v26;
    hashtable->list.prev = v26;
    v14->first = v26;
    v14->last = v26;
  }
  else
  {
    v23[1] = first->size;
    v23[2] = first;
    *(_DWORD *)(first->size + 4) = v26;
    first->size = (size_t)v26;
    v14->first = v26;
  }
  ++hashtable->size;
  return 0;
}

//----- (00048958) --------------------------------------------------------
void *__fastcall hashtable_get(hashtable_t *hashtable, const char *key)
{
  const char *v2; // r6
  int v3; // r3
  size_t v5; // r4
  size_t v6; // r0
  int v7; // t1
  void *result; // r0

  v2 = key;
  v3 = *(unsigned __int8 *)key;
  v5 = 5381;
  if ( *key )
  {
    v5 = 5381;
    do
    {
      v6 = v3 + 32 * v5;
      v7 = *(unsigned __int8 *)++key;
      v3 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  result = hashtable_find_pair(hashtable, &hashtable->buckets[v5 % primes[hashtable->num_buckets]], v2, v5);
  if ( result )
    return (void *)*((_DWORD *)result + 3);
  return result;
}

//----- (000489A4) --------------------------------------------------------
int __fastcall hashtable_del(hashtable_t *hashtable, const char *key)
{
  const char *v2; // r6
  int v3; // r3
  size_t v5; // r4
  size_t v6; // r0
  int v7; // t1
  hashtable_bucket *buckets; // r7
  const char *v9; // r2
  size_t v10; // r8
  bucket_t *v11; // r6
  pair_t *pair; // r0
  pair_t *v13; // r4
  hashtable_list *p_list; // r2
  hashtable_list list; // kr00_8
  hashtable_list *last; // r12
  json_t *value; // r0
  size_t refcount; // r3
  size_t v19; // r3
  bool v21; // zf

  v2 = key;
  v3 = *(unsigned __int8 *)key;
  v5 = 5381;
  if ( *key )
  {
    v5 = 5381;
    do
    {
      v6 = v3 + 32 * v5;
      v7 = *(unsigned __int8 *)++key;
      v3 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  buckets = hashtable->buckets;
  v9 = v2;
  v10 = v5 % primes[hashtable->num_buckets];
  v11 = &buckets[v10];
  pair = hashtable_find_pair(hashtable, v11, v9, v5);
  v13 = pair;
  if ( !pair )
    return -1;
  p_list = &pair->list;
  list = pair->list;
  last = v11->last;
  if ( &pair->list == buckets[v10].first )
  {
    v21 = p_list == last;
    if ( p_list == last )
      p_list = &hashtable->list;
    else
      buckets[v10].first = list.next;
    if ( v21 )
    {
      v11->last = p_list;
      buckets[v10].first = p_list;
    }
  }
  else if ( p_list == last )
  {
    v11->last = list.prev;
  }
  value = pair->value;
  list.prev->next = list.next;
  v13->list.next->prev = list.prev;
  if ( value )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v19 = refcount - 1;
      value->refcount = v19;
      if ( !v19 )
        json_delete(value);
    }
  }
  jsonp_free(v13);
  --hashtable->size;
  return 0;
}

//----- (00048A54) --------------------------------------------------------
void __fastcall hashtable_clear(hashtable_t *hashtable)
{
  hashtable_list *p_list; // r2
  size_t v3; // r1
  hashtable_bucket *buckets; // r3
  hashtable_bucket *v5; // r1

  hashtable_do_clear(hashtable);
  p_list = &hashtable->list;
  v3 = primes[hashtable->num_buckets];
  if ( v3 )
  {
    buckets = hashtable->buckets;
    v5 = &buckets[v3];
    do
    {
      buckets->last = p_list;
      buckets->first = p_list;
      ++buckets;
    }
    while ( v5 != buckets );
  }
  hashtable->list.prev = p_list;
  hashtable->list.next = p_list;
  hashtable->size = 0;
}

//----- (00048A8C) --------------------------------------------------------
void *__fastcall hashtable_iter(hashtable_t *hashtable)
{
  if ( hashtable->list.next == &hashtable->list )
    return 0;
  else
    return hashtable->list.next;
}

//----- (00048A9C) --------------------------------------------------------
void *__fastcall hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
  const char *v2; // r6
  int v3; // r3
  size_t v5; // r4
  size_t v6; // r0
  int v7; // t1
  void *result; // r0

  v2 = key;
  v3 = *(unsigned __int8 *)key;
  v5 = 5381;
  if ( *key )
  {
    v5 = 5381;
    do
    {
      v6 = v3 + 32 * v5;
      v7 = *(unsigned __int8 *)++key;
      v3 = v7;
      v5 += v6;
    }
    while ( v7 );
  }
  result = hashtable_find_pair(hashtable, &hashtable->buckets[v5 % primes[hashtable->num_buckets]], v2, v5);
  if ( result )
    return (char *)result + 4;
  return result;
}

//----- (00048AE8) --------------------------------------------------------
void *__fastcall hashtable_iter_next(hashtable_t *hashtable, void *iter)
{
  if ( *((hashtable_t **)iter + 1) == (hashtable_t *)&hashtable->list )
    return 0;
  else
    return (void *)*((_DWORD *)iter + 1);
}

//----- (00048AF8) --------------------------------------------------------
void *__fastcall hashtable_iter_key(void *iter)
{
  return (char *)iter + 16;
}

//----- (00048AFC) --------------------------------------------------------
size_t __fastcall hashtable_iter_serial(void *iter)
{
  return *((_DWORD *)iter + 3);
}

//----- (00048B00) --------------------------------------------------------
void *__fastcall hashtable_iter_value(void *iter)
{
  return (void *)*((_DWORD *)iter + 2);
}

//----- (00048B04) --------------------------------------------------------
void __fastcall hashtable_iter_set(void *iter, json_t *value)
{
  json_t *v3; // r0
  size_t refcount; // r3
  size_t v5; // r3

  v3 = (json_t *)*((_DWORD *)iter + 2);
  if ( !v3 || (refcount = v3->refcount, refcount == -1) || (v5 = refcount - 1, (v3->refcount = v5) != 0) )
  {
    *((_DWORD *)iter + 2) = value;
  }
  else
  {
    json_delete(v3);
    *((_DWORD *)iter + 2) = value;
  }
}

//----- (00048B30) --------------------------------------------------------
int __fastcall string_get(void *data)
{
  int v1; // r2
  int v2; // r3

  v1 = *((_DWORD *)data + 1);
  v2 = *(unsigned __int8 *)(*(_DWORD *)data + v1);
  if ( !*(_BYTE *)(*(_DWORD *)data + v1) )
    return -1;
  *((_DWORD *)data + 1) = v1 + 1;
  return v2;
}

//----- (00048B48) --------------------------------------------------------
int __fastcall buffer_get(void *data)
{
  __int64 v1; // r2

  v1 = *(_QWORD *)((char *)data + 4);
  if ( HIDWORD(v1) >= (unsigned int)v1 )
    return -1;
  LODWORD(v1) = HIDWORD(v1) + 1;
  HIDWORD(v1) = *(unsigned __int8 *)(*(_DWORD *)data + HIDWORD(v1));
  *((_DWORD *)data + 2) = v1;
  return HIDWORD(v1);
}

//----- (00048B64) --------------------------------------------------------
int __fastcall callback_get(void *data)
{
  unsigned int v1; // r3
  int (__fastcall *v3)(void *, int, _DWORD); // r3
  int v4; // r0
  int result; // r0

  v1 = *((_DWORD *)data + 257);
  if ( v1 < *((_DWORD *)data + 256) )
    goto LABEL_4;
  v3 = (int (__fastcall *)(void *, int, _DWORD))*((_DWORD *)data + 258);
  *((_DWORD *)data + 257) = 0;
  v4 = v3(data, 1024, *((_DWORD *)data + 259));
  *((_DWORD *)data + 256) = v4;
  if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
  {
    v1 = *((_DWORD *)data + 257);
LABEL_4:
    result = *((unsigned __int8 *)data + v1);
    *((_DWORD *)data + 257) = v1 + 1;
    return result;
  }
  return -1;
}

//----- (00048BA8) --------------------------------------------------------
void error_set(json_error_t *error, const lex_t *lex, const char *a3, ...)
{
  const char *v5; // r0
  __int64 v6; // kr00_8
  size_t position; // r9
  char *v8; // r3
  char msg_text[160]; // [sp+1Ch] [bp-168h] BYREF
  char msg_with_context[192]; // [sp+BCh] [bp-C8h] BYREF
  va_list va; // [sp+180h] [bp-4h] BYREF

  va_start(va, a3);
  if ( error )
  {
    vsnprintf(msg_text, 0xA0u, a3, va);
    msg_text[159] = 0;
    if ( lex )
    {
      v5 = strbuffer_value(&lex->saved_text);
      v6 = *(_QWORD *)&lex->stream.line;
      position = lex->stream.position;
      if ( v5 && *v5 )
      {
        if ( lex->saved_text.length <= 0x14 )
        {
          snprintf(msg_with_context, 0xA0u, "%s near '%s'", msg_text, v5);
          v8 = msg_with_context;
          msg_with_context[159] = 0;
          goto LABEL_8;
        }
      }
      else if ( lex->stream.state != -2 )
      {
        snprintf(msg_with_context, 0xA0u, "%s near end of file", msg_text);
        v8 = msg_with_context;
        msg_with_context[159] = 0;
        goto LABEL_8;
      }
      v8 = msg_text;
    }
    else
    {
      v8 = msg_text;
      position = 0;
      v6 = -1;
    }
LABEL_8:
    jsonp_error_set(error, v6, SHIDWORD(v6), position, "%s", v8);
  }
}

//----- (00048C5C) --------------------------------------------------------
void __fastcall lex_close(lex_t *lex)
{
  if ( lex->token == 256 )
  {
    jsonp_free(lex->value.string);
    strbuffer_close(&lex->saved_text);
  }
  else
  {
    strbuffer_close(&lex->saved_text);
  }
}

//----- (00048C88) --------------------------------------------------------
int32_t __fastcall decode_unicode_escape(const char *str)
{
  const char *v1; // r3
  int32_t result; // r0
  const char *v3; // r5
  int v4; // r2
  int v5; // t1
  int v6; // r0
  int v7; // r1

  if ( *str != 117 )
    _assert_fail("str[0] == 'u'", "load.c", 0x120u, "decode_unicode_escape");
  v1 = str;
  result = 0;
  v3 = v1 + 4;
  do
  {
    v5 = *(unsigned __int8 *)++v1;
    v4 = v5;
    v6 = 16 * result;
    v7 = v5 - 48;
    if ( (unsigned __int8)(v5 - 48) > 9u )
    {
      if ( (unsigned int)(v4 - 97) > 0x19 )
      {
        if ( (unsigned int)(v4 - 65) > 0x19 )
          _assert_fail((const char *)&word_53210, "load.c", 0x12Cu, "decode_unicode_escape");
        result = v6 + v4 - 55;
      }
      else
      {
        result = v6 + v4 - 87;
      }
    }
    else
    {
      result = v6 + v7;
    }
  }
  while ( v1 != v3 );
  return result;
}
// 53210: using guessed type __int16 word_53210;

//----- (00048D0C) --------------------------------------------------------
_DWORD *__fastcall stream_unget(_DWORD *result, int a2)
{
  _DWORD *v2; // r4
  int v4; // r2
  int v5; // r3
  int v6; // r3

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    --result[9];
    if ( a2 == 10 )
    {
      v4 = result[8];
      --result[6];
      result[7] = v4;
    }
    else
    {
      result = (_DWORD *)utf8_check_first(a2);
      if ( result )
        --v2[7];
    }
    v5 = v2[4];
    if ( !v5 )
      _assert_fail("stream->buffer_pos > 0", "load.c", 0xE0u, "stream_unget");
    v6 = v5 - 1;
    v2[4] = v6;
    if ( *((unsigned __int8 *)v2 + v6 + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (00048D88) --------------------------------------------------------
int __fastcall stream_get_part_3(const lex_t *a1, json_error_t *a2)
{
  size_t buffer_pos; // r3
  const lex_t *v4; // r2
  size_t v5; // r6
  int v7; // r0
  int v8; // r5
  int v9; // r1
  int line; // r3
  int column; // r2
  int v13; // r0
  int v14; // r8
  char *v15; // r6
  char *v16; // r9
  size_t v17; // r3
  int v18; // r3

  buffer_pos = a1->stream.buffer_pos;
  v4 = (const lex_t *)((char *)a1 + buffer_pos);
  v5 = (unsigned __int8)a1->stream.buffer[buffer_pos];
  if ( a1->stream.buffer[buffer_pos] )
  {
    v9 = buffer_pos + 1;
  }
  else
  {
    v7 = a1->stream.get(a1->stream.data);
    v8 = v7;
    if ( v7 == -1 )
    {
      a1->stream.state = -1;
      return v8;
    }
    a1->stream.buffer_pos = v5;
    a1->stream.buffer[0] = v7;
    if ( (unsigned int)(v7 - 128) <= 0x7F )
    {
      v13 = utf8_check_first(v7);
      v14 = v13;
      if ( !v13 )
        goto LABEL_20;
      if ( v13 <= 1 )
        _assert_fail("count >= 2", "load.c", 0xAFu, "stream_get");
      v15 = &a1->stream.buffer[1];
      v16 = &a1->stream.buffer[v13];
      do
        *v15++ = a1->stream.get(a1->stream.data);
      while ( v16 != v15 );
      if ( !utf8_check_full(a1->stream.buffer, v14, 0) )
      {
LABEL_20:
        v18 = v8;
        a1->stream.state = -2;
        v8 = -2;
        error_set(a2, a1, "unable to decode byte 0x%x", v18);
        return v8;
      }
      a1->stream.buffer[v14] = 0;
      v17 = a1->stream.buffer_pos;
      v9 = v17 + 1;
      v4 = (const lex_t *)((char *)a1 + v17);
    }
    else
    {
      v9 = 1;
      v4 = a1;
      a1->stream.buffer[1] = v5;
    }
  }
  a1->stream.buffer_pos = v9;
  v8 = (unsigned __int8)v4->stream.buffer[0];
  ++a1->stream.position;
  if ( v8 != 10 )
  {
    if ( utf8_check_first(v8) )
      ++a1->stream.column;
    return v8;
  }
  line = a1->stream.line;
  column = a1->stream.column;
  a1->stream.column = 0;
  a1->stream.line = line + 1;
  a1->stream.last_column = column;
  return 10;
}

//----- (00048E78) --------------------------------------------------------
int __fastcall lex_get_save(lex_t *lex, json_error_t *error)
{
  int state; // r4

  state = lex->stream.state;
  if ( !state )
    state = stream_get_part_3(lex, error);
  if ( (unsigned int)(state + 2) > 1 )
    strbuffer_append_byte(&lex->saved_text, state);
  return state;
}

//----- (00048E9C) --------------------------------------------------------
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2)
{
  _DWORD *v2; // r5

  if ( (unsigned int)(a2 + 2) > 1 )
  {
    v2 = result;
    stream_unget(result, a2);
    result = (_DWORD *)strbuffer_pop((strbuffer_t *)(v2 + 10));
    if ( result != (_DWORD *)a2 )
      _assert_fail("c == d", "load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}

//----- (00048ED8) --------------------------------------------------------
int __fastcall lex_scan(lex_t *lex, json_error_t *error)
{
  strbuffer_t *p_saved_text; // r7
  unsigned int state; // r4
  bool v6; // cc
  int v7; // r3
  int v8; // r4
  bool v9; // zf
  _BOOL4 v10; // r2
  bool v11; // cc
  char i; // r1
  size_t v13; // r3
  size_t v14; // r2
  int v16; // r0
  const char *v17; // r4
  int v18; // r0
  bool v19; // zf
  int part_3; // r1
  json_int_t v21; // r2
  json_error_t *v22; // r1
  lex_t *v23; // r0
  unsigned int v24; // r4
  int v25; // r0
  bool v26; // zf
  unsigned int v27; // r3
  const char *v28; // r4
  int *v29; // r7
  json_int_t v30; // r0
  char *v31; // r4
  const char *j; // r7
  int v33; // r3
  unsigned int v34; // r3
  const char *v35; // r2
  int v36; // r8
  unsigned int v37; // r3
  unsigned int v38; // r4
  bool v39; // cc
  int save; // r0
  int v41; // r1
  int32_t v42; // r0
  const char *v43; // r11
  int32_t v44; // r3
  int32_t v45; // r0
  const char *v46; // r2
  int32_t v47; // [sp+8h] [bp-1Ch]
  int v48; // [sp+Ch] [bp-18h]
  char buffer[4]; // [sp+14h] [bp-10h] BYREF
  json_int_t out; // [sp+18h] [bp-Ch] BYREF

  p_saved_text = &lex->saved_text;
  strbuffer_clear(&lex->saved_text);
  if ( lex->token == 256 )
  {
    jsonp_free(lex->value.string);
    lex->value.string = 0;
  }
  do
  {
    state = lex->stream.state;
    if ( !state )
      state = stream_get_part_3(lex, error);
    v6 = state > 0x20;
    if ( state != 32 )
      v6 = state - 9 > 1;
    v7 = !v6;
  }
  while ( !v6 || state == 13 );
  if ( state == -1 )
  {
    lex->token = v7;
    return v7;
  }
  if ( state == -2 )
    goto LABEL_31;
  strbuffer_append_byte(p_saved_text, state);
  if ( (((state & 0xFFFFFFDF) - 91) & 0xFFFFFFFD) == 0 )
    goto LABEL_34;
  v9 = state == 44;
  if ( state != 44 )
    v9 = state == 58;
  v10 = v9;
  if ( v9 )
    goto LABEL_34;
  if ( state != 34 )
  {
    v11 = state > 0x2D;
    if ( state != 45 )
      v11 = state - 48 > 9;
    if ( !v11 )
    {
      lex->token = -1;
      if ( state == 45 )
      {
        save = lex_get_save(lex, error);
        v41 = save;
        if ( save != 48 )
        {
          if ( (unsigned int)(save - 48) > 9 )
          {
LABEL_110:
            lex_unget_unsave(lex, v41);
            return lex->token;
          }
          goto LABEL_42;
        }
      }
      else if ( state != 48 )
      {
        do
LABEL_42:
          v18 = lex_get_save(lex, error);
        while ( (unsigned int)(v18 - 48) <= 9 );
        goto LABEL_43;
      }
      v18 = lex_get_save(lex, error);
      if ( (unsigned int)(v18 - 48) <= 9 )
      {
LABEL_112:
        v41 = v18;
        goto LABEL_110;
      }
LABEL_43:
      v19 = v18 == 46;
      if ( v18 != 46 )
        v19 = v18 == 69;
      if ( v19 )
      {
        if ( v18 == 46 )
        {
          part_3 = lex->stream.state;
          if ( !part_3 )
            part_3 = stream_get_part_3(lex, error);
          if ( (unsigned int)(part_3 - 48) > 9 )
          {
            stream_unget(lex, part_3);
            return lex->token;
          }
          strbuffer_append_byte(p_saved_text, part_3);
          do
            v18 = lex_get_save(lex, error);
          while ( (unsigned int)(v18 - 48) <= 9 );
        }
        if ( (v18 & 0xFFFFFFDF) != 0x45 )
          goto LABEL_54;
      }
      else if ( v18 != 101 )
      {
        lex_unget_unsave(lex, v18);
        v28 = strbuffer_value(p_saved_text);
        v29 = _errno_location();
        *v29 = 0;
        v30 = strtoll(v28, (char **)&out, 10);
        if ( *v29 == 34 )
        {
          if ( v30 >= 0 )
            LOWORD(v46) = -19712;
          else
            LOWORD(v46) = -19740;
          HIWORD(v46) = 5;
          error_set(error, lex, v46, HIDWORD(v30));
          return lex->token;
        }
        else
        {
          if ( (const char *)out != &v28[lex->saved_text.length] )
            _assert_fail("end == saved_text + lex->saved_text.length", "load.c", 0x206u, "lex_scan_number");
          v8 = 257;
          lex->value.integer = v30;
          lex->token = 257;
        }
        return v8;
      }
      v18 = lex_get_save(lex, error);
      if ( ((v18 - 43) & 0xFFFFFFFD) == 0 )
        v18 = lex_get_save(lex, error);
      if ( (unsigned int)(v18 - 48) <= 9 )
      {
        do
          v18 = lex_get_save(lex, error);
        while ( (unsigned int)(v18 - 48) <= 9 );
LABEL_54:
        lex_unget_unsave(lex, v18);
        if ( jsonp_strtod(p_saved_text, (double *)&out) )
        {
          error_set(error, lex, "real number overflow");
          return lex->token;
        }
        else
        {
          v21 = out;
          v8 = 258;
          lex->token = 258;
          lex->value.integer = v21;
        }
        return v8;
      }
      goto LABEL_112;
    }
    if ( (state & 0xFFFFFFDF) - 65 > 0x19 )
    {
      for ( i = lex->stream.buffer[lex->stream.buffer_pos]; i; i = lex->stream.buffer[v13] )
      {
        strbuffer_append_byte(p_saved_text, i);
        v13 = lex->stream.buffer_pos + 1;
        v14 = lex->stream.position + 1;
        lex->stream.buffer_pos = v13;
        lex->stream.position = v14;
      }
      goto LABEL_31;
    }
    do
      v16 = lex_get_save(lex, error);
    while ( (v16 & 0xFFFFFFDF) - 65 <= 0x19 );
    lex_unget_unsave(lex, v16);
    v17 = strbuffer_value(p_saved_text);
    if ( !strcmp(v17, "true") )
    {
      v8 = 259;
      lex->token = 259;
      return v8;
    }
    if ( strcmp(v17, "false") )
    {
      if ( !strcmp(v17, "null") )
      {
        v8 = 261;
        lex->token = 261;
        return v8;
      }
LABEL_31:
      v8 = -1;
      lex->token = -1;
      return v8;
    }
    state = 260;
LABEL_34:
    lex->token = state;
    return state;
  }
  lex->token = -1;
  lex->value.string = (char *)v10;
LABEL_57:
  v22 = error;
  v23 = lex;
  while ( 1 )
  {
    v24 = lex_get_save(v23, v22);
LABEL_59:
    if ( v24 == 34 )
    {
      v31 = (char *)jsonp_malloc(lex->saved_text.length + 1);
      lex->value.string = v31;
      if ( !v31 )
        goto LABEL_72;
      for ( j = strbuffer_value(p_saved_text) + 1; ; j += 2 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v33 = *(unsigned __int8 *)j;
            if ( v33 == 34 )
            {
              *v31 = 0;
              v8 = 256;
              lex->token = 256;
              return v8;
            }
            if ( v33 == 92 )
              break;
            *v31 = v33;
            ++j;
            ++v31;
          }
          v34 = *((unsigned __int8 *)j + 1);
          if ( v34 != 117 )
            break;
          v42 = decode_unicode_escape(j + 1);
          v43 = j + 6;
          v44 = v42;
          v48 = v42 - 55296;
          if ( (unsigned int)(v42 - 55296) >= 0x400 )
          {
            if ( (unsigned int)(v42 - 56320) < 0x400 )
              goto LABEL_143;
            if ( !v42 )
            {
              error_set(error, lex, "\\u0000 is not allowed", 0);
              goto LABEL_72;
            }
          }
          else
          {
            if ( j[6] != 92 || j[7] != 117 )
            {
LABEL_143:
              error_set(error, lex, "invalid Unicode '\\u%04X'", v42);
              goto LABEL_72;
            }
            v47 = v42;
            v45 = decode_unicode_escape(j + 7);
            v43 = j + 12;
            if ( (unsigned int)(v45 - 56320) >= 0x400 )
            {
              error_set(error, lex, "invalid Unicode '\\u%04X\\u%04X'", v47, v45);
              goto LABEL_72;
            }
            v44 = v45 - 56320 + (v48 << 10) + 0x10000;
          }
          if ( utf8_encode(v44, buffer, (int *)&out) )
            _assert_fail((const char *)&word_53210, "load.c", 0x1AEu, "lex_scan_string");
          j = v43;
          memcpy(v31, buffer, out);
          v31 += out;
        }
        if ( v34 == 98 )
        {
          *v31 = 8;
        }
        else
        {
          if ( v34 <= 0x62 )
          {
            if ( v34 != 47 && v34 != 92 && v34 != 34 )
LABEL_121:
              _assert_fail((const char *)&word_53210, "load.c", 0x1BCu, "lex_scan_string");
            goto LABEL_116;
          }
          if ( v34 == 110 )
          {
            *v31 = 10;
          }
          else
          {
            if ( v34 <= 0x6E )
            {
              if ( v34 != 102 )
                goto LABEL_121;
              LOBYTE(v34) = 12;
LABEL_116:
              *v31 = v34;
              goto LABEL_96;
            }
            if ( v34 == 114 )
            {
              *v31 = 13;
            }
            else
            {
              if ( v34 != 116 )
                goto LABEL_121;
              *v31 = 9;
            }
          }
        }
LABEL_96:
        ++v31;
      }
    }
    if ( v24 == -2 )
      goto LABEL_72;
    if ( v24 == -1 )
    {
      error_set(error, lex, "premature end of input", 0);
      goto LABEL_72;
    }
    if ( v24 <= 0x1F )
      break;
    v22 = error;
    v23 = lex;
    if ( v24 == 92 )
    {
      v25 = lex_get_save(lex, error);
      if ( v25 == 117 )
      {
        v36 = 4;
        v24 = lex_get_save(lex, error);
        while ( 1 )
        {
          v37 = v24 & 0xFFFFFFDF;
          v38 = v24 - 48;
          v27 = v37 - 65;
          v39 = v27 > 5;
          if ( v27 > 5 )
            v39 = v38 > 9;
          if ( v39 )
            break;
          --v36;
          v24 = lex_get_save(lex, error);
          if ( !v36 )
            goto LABEL_59;
        }
LABEL_71:
        error_set(error, lex, "invalid escape", v27);
        goto LABEL_72;
      }
      v26 = v25 == 92;
      if ( v25 != 92 )
        v26 = (v25 & 0xFFFFFFBF) == 34;
      if ( !v26 && v25 != 47 && (v25 & 0xFFFFFFF7) != 0x66 )
      {
        v27 = (v25 - 114) & 0xFFFFFFFD;
        if ( v27 )
          goto LABEL_71;
      }
      goto LABEL_57;
    }
  }
  lex_unget_unsave(lex, v24);
  if ( v24 == 10 )
    LOWORD(v35) = -19884;
  else
    LOWORD(v35) = -19864;
  HIWORD(v35) = 5;
  error_set(error, lex, v35, v24);
LABEL_72:
  jsonp_free(lex->value.string);
  return lex->token;
}
// 53210: using guessed type __int16 word_53210;

//----- (0004942C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t *__fastcall parse_value(lex_t *lex, size_t flags, json_error_t *error)
{
  lex_t *v3; // r4
  int token; // r3
  size_t v5; // r1
  size_t v6; // r9
  json_t *v8; // r6
  int v10; // r3
  char *string; // r8
  json_t *v12; // r0
  json_t *v13; // r7
  size_t v14; // r3
  size_t v15; // r3
  size_t v16; // r3
  int v17; // r3
  int v18; // r3
  int appended; // r0
  size_t refcount; // r3
  bool v21; // zf
  size_t v22; // r3
  int v23; // r3
  json_t *v24; // r0
  size_t v25; // r3
  size_t v26; // r3
  json_t *v27; // r0
  char v28; // r1
  double v29; // r0
  size_t v30; // r3
  double value; // [sp+0h] [bp-Ch] BYREF

  v3 = lex;
  token = lex->token;
  lex = (lex_t *)257;
  v6 = v5;
  if ( token == 257 )
  {
    if ( (v28 & 8) == 0 )
      return json_integer(v3->value.integer);
    LODWORD(v29) = jsonp_strtod(&v3->saved_text, &value);
    if ( !LODWORD(v29) )
      return json_real(v29);
    error_set(error, v3, "real number overflow");
    return 0;
  }
  if ( token < 258 )
  {
    if ( token == 91 )
    {
      v8 = json_array();
      if ( v8 )
      {
        lex_scan(v3, error);
        v18 = v3->token;
        if ( v18 == 93 )
          return v8;
        if ( v18 )
        {
          while ( 1 )
          {
            v24 = parse_value(v3, v6, error);
            v13 = v24;
            if ( !v24 )
              break;
            if ( v24->refcount != -1 )
              ++v24->refcount;
            appended = json_array_append_new(v8, v24);
            refcount = v13->refcount;
            if ( appended )
            {
              if ( refcount != -1 )
              {
LABEL_62:
                v30 = refcount - 1;
                v13->refcount = v30;
                if ( !v30 )
                  json_delete(v13);
              }
              goto LABEL_51;
            }
            v21 = refcount == -1;
            v22 = refcount - 1;
            if ( !v21 )
            {
              v13->refcount = v22;
              if ( !v22 )
                json_delete(v13);
            }
            lex_scan(v3, error);
            v23 = v3->token;
            if ( v23 != 44 )
            {
              if ( v23 == 93 )
                return v8;
              goto LABEL_60;
            }
            lex_scan(v3, error);
            if ( !v3->token )
              goto LABEL_60;
          }
        }
        else
        {
LABEL_60:
          error_set(error, v3, "']' expected");
        }
        goto LABEL_51;
      }
    }
    else if ( token <= 91 )
    {
      if ( token != -1 )
        goto LABEL_37;
      error_set(error, v3, "invalid token");
    }
    else
    {
      if ( token != 123 )
      {
        if ( token == 256 )
          return json_string_nocheck(v3->value.string);
        goto LABEL_37;
      }
      v8 = (json_t *)json_object();
      if ( v8 )
      {
        lex_scan(v3, error);
        v10 = v3->token;
        if ( v10 == 125 )
          return v8;
        if ( v10 != 256 )
        {
LABEL_64:
          error_set(error, v3, "string or '}' expected");
          goto LABEL_51;
        }
        string = v3->value.string;
        v3->value.string = 0;
        if ( string )
        {
          while ( 1 )
          {
            if ( (v6 & 1) != 0 && json_object_get(v8, string) )
            {
              jsonp_free(string);
              error_set(error, v3, "duplicate object key");
              goto LABEL_51;
            }
            lex_scan(v3, error);
            if ( v3->token != 58 )
            {
              jsonp_free(string);
              error_set(error, v3, "':' expected");
              goto LABEL_51;
            }
            lex_scan(v3, error);
            v12 = parse_value(v3, v6, error);
            v13 = v12;
            if ( !v12 )
            {
              jsonp_free(string);
              goto LABEL_51;
            }
            v14 = v12->refcount;
            if ( v14 != -1 )
              v12->refcount = v14 + 1;
            if ( json_object_set_new_nocheck(v8, string, v12) )
            {
              jsonp_free(string);
              refcount = v13->refcount;
              if ( refcount != -1 )
                goto LABEL_62;
              goto LABEL_51;
            }
            v15 = v13->refcount;
            if ( v15 != -1 )
            {
              v16 = v15 - 1;
              v13->refcount = v16;
              if ( !v16 )
                json_delete(v13);
            }
            jsonp_free(string);
            lex_scan(v3, error);
            v17 = v3->token;
            if ( v17 != 44 )
              break;
            lex_scan(v3, error);
            if ( v3->token != 256 )
              goto LABEL_64;
            string = v3->value.string;
            v3->value.string = 0;
            if ( !string )
              return 0;
          }
          if ( v17 == 125 )
            return v8;
          error_set(error, v3, "'}' expected");
LABEL_51:
          v25 = v8->refcount;
          if ( v25 != -1 )
          {
            v26 = v25 - 1;
            v8->refcount = v26;
            if ( !v26 )
            {
              v27 = v8;
              v8 = 0;
              json_delete(v27);
              return v8;
            }
          }
        }
      }
    }
    return 0;
  }
  if ( token == 259 )
    return json_true();
  if ( token <= 258 )
    return json_real(*(double *)&lex);
  if ( token == 260 )
    return json_false();
  if ( token == 261 )
    return json_null();
LABEL_37:
  error_set(error, v3, "unexpected token");
  return 0;
}
// 4942C: variables would overlap: r0.4 and r0.8
// 4942C: too many cbuild loops

//----- (00049748) --------------------------------------------------------
// Alternative name is 'parse_json.constprop.6'
json_t *__fastcall parse_json(lex_t *lex, size_t flags, json_error_t *error)
{
  json_t *v6; // r6
  size_t refcount; // r3
  size_t v9; // r3
  json_t *v10; // r0

  lex_scan(lex, error);
  v6 = (json_t *)(flags & 4);
  if ( (flags & 4) == 0 && (lex->token & 0xFFFFFFDF) != 0x5B )
  {
    error_set(error, lex, "'[' or '{' expected");
    return v6;
  }
  v6 = parse_value(lex, flags, error);
  if ( !v6 )
    return 0;
  if ( (flags & 2) == 0 )
  {
    lex_scan(lex, error);
    if ( lex->token )
    {
      error_set(error, lex, "end of file expected");
      refcount = v6->refcount;
      if ( refcount != -1 )
      {
        v9 = refcount - 1;
        v6->refcount = v9;
        if ( !v9 )
        {
          v10 = v6;
          v6 = 0;
          json_delete(v10);
          return v6;
        }
      }
      return 0;
    }
  }
  if ( error )
    error->position = lex->stream.position;
  return v6;
}

//----- (000497CC) --------------------------------------------------------
json_t *__fastcall json_loads(const char *string, size_t flags, json_error_t *error)
{
  json_t *v6; // r4
  string_data_t stream_data; // [sp+0h] [bp-4Ch] BYREF
  lex_t lex; // [sp+8h] [bp-44h] BYREF

  jsonp_error_init(error, "<string>");
  if ( string )
  {
    v6 = 0;
    stream_data.data = string;
    lex.stream.get = string_get;
    stream_data.pos = 0;
    lex.stream.buffer[0] = 0;
    lex.stream.buffer_pos = 0;
    lex.stream.state = 0;
    lex.stream.column = 0;
    lex.stream.position = 0;
    lex.stream.data = &stream_data;
    lex.stream.line = 1;
    if ( !strbuffer_init(&lex.saved_text) )
    {
      lex.token = -1;
      v6 = parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
  return v6;
}

//----- (00049844) --------------------------------------------------------
json_t *__fastcall json_loadb(const char *buffer, size_t buflen, size_t flags, json_error_t *error)
{
  json_t *v8; // r4
  buffer_data_t stream_data; // [sp+4h] [bp-4Ch] BYREF
  lex_t lex; // [sp+10h] [bp-40h] BYREF

  jsonp_error_init(error, "<buffer>");
  if ( buffer )
  {
    v8 = 0;
    stream_data.data = buffer;
    stream_data.len = buflen;
    lex.stream.get = buffer_get;
    stream_data.pos = 0;
    lex.stream.buffer[0] = 0;
    lex.stream.buffer_pos = 0;
    lex.stream.state = 0;
    lex.stream.column = 0;
    lex.stream.position = 0;
    lex.stream.data = &stream_data;
    lex.stream.line = 1;
    if ( !strbuffer_init(&lex.saved_text) )
    {
      lex.token = -1;
      v8 = parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
  return v8;
}

//----- (000498C4) --------------------------------------------------------
json_t *__fastcall json_loadf(FILE *input, size_t flags, json_error_t *error)
{
  const char *v6; // r1
  json_t *v7; // r4
  lex_t lex; // [sp+0h] [bp-40h] BYREF

  if ( (FILE *)stdin == input )
    v6 = "<stdin>";
  else
    v6 = "<stream>";
  jsonp_error_init(error, v6);
  if ( input )
  {
    v7 = 0;
    lex.stream.data = input;
    lex.stream.get = (get_func)fgetc;
    lex.stream.buffer[0] = 0;
    lex.stream.buffer_pos = 0;
    lex.stream.state = 0;
    lex.stream.column = 0;
    lex.stream.position = 0;
    lex.stream.line = 1;
    if ( !strbuffer_init(&lex.saved_text) )
    {
      lex.token = -1;
      v7 = parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
  return v7;
}
// 6D850: using guessed type int stdin;

//----- (00049954) --------------------------------------------------------
json_t *__fastcall json_load_file(const char *path, size_t flags, json_error_t *error)
{
  FILE *v6; // r0
  FILE *v7; // r7
  json_t *v8; // r6
  int *v10; // r0
  char *v11; // r0

  jsonp_error_init(error, path);
  if ( path )
  {
    v6 = fopen(path, "rb");
    v7 = v6;
    if ( v6 )
    {
      v8 = json_loadf(v6, flags, error);
      fclose(v7);
    }
    else
    {
      v10 = _errno_location();
      v8 = 0;
      v11 = strerror(*v10);
      error_set(error, 0, "unable to open %s: %s", path, v11);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
  return v8;
}

//----- (000499C8) --------------------------------------------------------
json_t *__fastcall json_load_callback(json_load_callback_t callback, void *arg, size_t flags, json_error_t *error)
{
  lex_t lex; // [sp+0h] [bp-454h] BYREF
  callback_data_t stream_data; // [sp+40h] [bp-414h] BYREF

  memset(&stream_data, 0, sizeof(stream_data));
  stream_data.arg = arg;
  stream_data.callback = callback;
  jsonp_error_init(error, "<callback>");
  if ( callback )
  {
    callback = 0;
    lex.stream.get = callback_get;
    lex.stream.line = 1;
    lex.stream.data = &stream_data;
    lex.stream.buffer[0] = 0;
    lex.stream.buffer_pos = 0;
    lex.stream.state = 0;
    lex.stream.column = 0;
    lex.stream.position = 0;
    if ( !strbuffer_init(&lex.saved_text) )
    {
      lex.token = -1;
      callback = (json_load_callback_t)parse_json(&lex, flags, error);
      lex_close(&lex);
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
  }
  return (json_t *)callback;
}

//----- (00049A54) --------------------------------------------------------
void *__fastcall jsonp_malloc(size_t size)
{
  if ( size )
    return do_malloc(size);
  return (void *)size;
}

//----- (00049A64) --------------------------------------------------------
void __fastcall jsonp_free(void *ptr)
{
  if ( ptr )
    do_free(ptr);
}

//----- (00049A74) --------------------------------------------------------
char *__fastcall jsonp_strdup(const char *str)
{
  size_t v2; // r4
  char *v3; // r0
  char *v4; // r5

  v2 = strlen(str) + 1;
  v3 = (char *)do_malloc(v2);
  v4 = v3;
  if ( v3 )
    memcpy(v3, str, v2);
  return v4;
}

//----- (00049A9C) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn)
{
  *(_QWORD *)&do_malloc = *(_QWORD *)&malloc_fn;
}
// 49A9C: variables would overlap: r0.4 and r0.8

//----- (00049AAC) --------------------------------------------------------
int __fastcall strbuffer_init(strbuffer_t *strbuff)
{
  char *v2; // r0

  strbuff->length = 0;
  strbuff->size = 16;
  v2 = (char *)jsonp_malloc(0x10u);
  strbuff->value = v2;
  if ( !v2 )
    return -1;
  *v2 = 0;
  return 0;
}

//----- (00049ACC) --------------------------------------------------------
void __fastcall strbuffer_close(strbuffer_t *strbuff)
{
  char *value; // r0

  value = strbuff->value;
  if ( value )
    jsonp_free(value);
  strbuff->length = 0;
  strbuff->size = 0;
  strbuff->value = 0;
}

//----- (00049AE4) --------------------------------------------------------
void __fastcall strbuffer_clear(strbuffer_t *strbuff)
{
  char *value; // r2

  value = strbuff->value;
  strbuff->length = 0;
  *value = 0;
}

//----- (00049AF0) --------------------------------------------------------
const char *__fastcall strbuffer_value(const strbuffer_t *strbuff)
{
  return strbuff->value;
}

//----- (00049AF4) --------------------------------------------------------
char *__fastcall strbuffer_steal_value(strbuffer_t *strbuff)
{
  char *result; // r0

  result = strbuff->value;
  strbuff->value = 0;
  return result;
}

//----- (00049B00) --------------------------------------------------------
int __fastcall strbuffer_append_bytes(strbuffer_t *strbuff, const char *data, size_t size)
{
  size_t v4; // r3
  size_t length; // r0
  char *value; // r8
  unsigned int v9; // r3
  size_t v10; // r6
  char *v11; // r0
  char *v12; // r2
  size_t v14; // r5

  v4 = strbuff->size;
  length = strbuff->length;
  if ( v4 - length > size )
  {
    value = strbuff->value;
LABEL_9:
    memcpy(&value[length], data, size);
    v12 = strbuff->value;
    v14 = size + strbuff->length;
    strbuff->length = v14;
    v12[v14] = 0;
    return 0;
  }
  if ( !((size == -1) | (v4 >> 31)) && -2 - size >= length )
  {
    v9 = 2 * v4;
    v10 = size + 1 + length;
    if ( v10 < v9 )
      v10 = v9;
    v11 = (char *)jsonp_malloc(v10);
    value = v11;
    if ( v11 )
    {
      memcpy(v11, strbuff->value, strbuff->length);
      jsonp_free(strbuff->value);
      length = strbuff->length;
      strbuff->value = value;
      strbuff->size = v10;
      goto LABEL_9;
    }
  }
  return -1;
}

//----- (00049B88) --------------------------------------------------------
int __fastcall strbuffer_append(strbuffer_t *strbuff, const char *string)
{
  size_t v4; // r0

  v4 = strlen(string);
  return strbuffer_append_bytes(strbuff, string, v4);
}

//----- (00049BA4) --------------------------------------------------------
int __fastcall strbuffer_append_byte(strbuffer_t *strbuff, char byte)
{
  char v3; // [sp+7h] [bp-5h] BYREF

  v3 = byte;
  return strbuffer_append_bytes(strbuff, &v3, 1u);
}

//----- (00049BBC) --------------------------------------------------------
char __fastcall strbuffer_pop(strbuffer_t *strbuff)
{
  size_t length; // r3
  char *value; // r2
  size_t v3; // r3
  char result; // r0

  length = strbuff->length;
  if ( !length )
    return 0;
  value = strbuff->value;
  v3 = length - 1;
  strbuff->length = v3;
  result = value[v3];
  value[v3] = 0;
  return result;
}

//----- (00049BD4) --------------------------------------------------------
int __fastcall jsonp_strtod(strbuffer_t *strbuffer, double *out)
{
  double v2; // d0
  struct lconv *v5; // r0
  char *value; // r5
  int v7; // r6
  char *v8; // r0
  int *v9; // r6
  int result; // r0
  char *end; // [sp+4h] [bp-8h] BYREF

  v5 = localeconv();
  value = strbuffer->value;
  v7 = *(unsigned __int8 *)v5->decimal_point;
  if ( v7 != 46 )
  {
    v8 = strchr(strbuffer->value, 46);
    if ( v8 )
    {
      *v8 = v7;
      value = strbuffer->value;
    }
  }
  v9 = _errno_location();
  *v9 = 0;
  strtod(value, &end);
  if ( end != &strbuffer->value[strbuffer->length] )
    _assert_fail("end == strbuffer->value + strbuffer->length", "strconv.c", 0x46u, "jsonp_strtod");
  result = *v9 == 34 && v2 != 0.0;
  if ( result )
    return -1;
  *out = v2;
  return result;
}
// 49C2C: variable 'v2' is possibly undefined

//----- (00049C60) --------------------------------------------------------
int __fastcall jsonp_dtostr(char *buffer, size_t size, double value)
{
  double v3; // d0
  unsigned int v6; // r0
  unsigned int v7; // r6
  int v8; // r1
  char *v9; // r0
  char *v10; // r5
  char *v11; // r0
  unsigned __int8 *v12; // r4
  int v13; // r3
  _BYTE *v14; // r5
  int v15; // t1
  size_t v16; // r2
  char *v18; // r3

  v6 = snprintf(buffer, size, "%.17g", v3);
  if ( size > v6 )
  {
    v7 = v6;
    v8 = *(unsigned __int8 *)localeconv()->decimal_point;
    if ( v8 != 46 )
    {
      v9 = strchr(buffer, v8);
      if ( v9 )
        *v9 = 46;
    }
    v10 = strchr(buffer, 46);
    v11 = strchr(buffer, 101);
    if ( v10 )
    {
      if ( !v11 )
        return v7;
      goto LABEL_7;
    }
    if ( v11 )
    {
LABEL_7:
      v12 = (unsigned __int8 *)(v11 + 2);
      v13 = (unsigned __int8)v11[2];
      if ( v11[1] != 45 )
      {
        v14 = v11 + 1;
        if ( v13 != 48 )
        {
LABEL_10:
          if ( v12 != v14 )
          {
            v16 = v7 - (v12 - (unsigned __int8 *)buffer);
            v7 -= v12 - v14;
            memmove(v14, v12, v16);
          }
          return v7;
        }
        do
LABEL_9:
          v15 = *++v12;
        while ( v15 == 48 );
        goto LABEL_10;
      }
      if ( v13 == 48 )
      {
        v14 = v11 + 2;
        goto LABEL_9;
      }
      return v7;
    }
    if ( v7 + 3 < size )
    {
      v18 = &buffer[v7];
      buffer[v7] = 46;
      v7 += 2;
      v18[1] = 48;
      buffer[v7] = 0;
      v11 = strchr(buffer, 101);
      if ( !v11 )
        return v7;
      goto LABEL_7;
    }
  }
  return -1;
}
// 49C74: variable 'v3' is possibly undefined

//----- (00049D18) --------------------------------------------------------
int __fastcall utf8_encode(int32_t codepoint, char *buffer, int *size)
{
  char v3; // r3
  char v5; // r3
  unsigned int v6; // r4
  char v7; // r3

  if ( codepoint < 0 )
    return -1;
  if ( codepoint <= 127 )
  {
    *buffer = codepoint;
    *size = 1;
    return 0;
  }
  else if ( codepoint < 2048 )
  {
    v5 = (codepoint & 0x3F) + 0x80;
    *buffer = (codepoint >> 6) - 64;
    buffer[1] = v5;
    *size = 2;
    return 0;
  }
  else if ( codepoint < 0x10000 )
  {
    v6 = ((unsigned int)codepoint >> 6) & 0x3F;
    v7 = (codepoint & 0x3F) + 0x80;
    *buffer = (codepoint >> 12) - 32;
    buffer[1] = v6 + 0x80;
    buffer[2] = v7;
    *size = 3;
    return 0;
  }
  else if ( codepoint >= 1114112 )
  {
    return -1;
  }
  else
  {
    v3 = (codepoint & 0x3F) + 0x80;
    *buffer = (codepoint >> 18) - 16;
    buffer[1] = (((unsigned int)codepoint >> 12) & 0x3F) + 0x80;
    buffer[2] = (((unsigned int)codepoint >> 6) & 0x3F) + 0x80;
    buffer[3] = v3;
    *size = 4;
    return 0;
  }
}

//----- (00049DB4) --------------------------------------------------------
int __fastcall utf8_check_first(char byte)
{
  if ( (byte & 0x80) == 0 )
    return 1;
  if ( (byte ^ 0x80u) <= 0x41 )
    return 0;
  if ( (unsigned __int8)(byte + 62) <= 0x1Du )
    return 2;
  if ( (unsigned __int8)(byte + 32) <= 0xFu )
    return 3;
  if ( (unsigned __int8)(byte + 16) <= 4u )
    return 4;
  return 0;
}

//----- (00049DF4) --------------------------------------------------------
int __fastcall utf8_check_full(const char *buffer, int size, int32_t *codepoint)
{
  char v3; // r5
  int32_t v4; // r5
  int result; // r0
  int v6; // r3
  const char *v7; // r0
  int v8; // r4
  int v9; // t1
  bool v10; // zf
  _BOOL4 v11; // r3
  _BOOL4 v12; // r1

  v3 = *buffer;
  switch ( size )
  {
    case 2:
      v4 = v3 & 0x1F;
      break;
    case 3:
      v4 = v3 & 0xF;
      break;
    case 4:
      v4 = v3 & 7;
      break;
    default:
      return 0;
  }
  v6 = *((unsigned __int8 *)buffer + 1);
  if ( (v6 ^ 0x80u) > 0x3F )
    return 0;
  v7 = buffer + 1;
  v8 = 1;
  while ( 1 )
  {
    ++v8;
    v4 = (v6 & 0x3F) + (v4 << 6);
    if ( size <= v8 )
      break;
    v9 = *(unsigned __int8 *)++v7;
    LOBYTE(v6) = v9;
    if ( (v9 ^ 0x80u) > 0x3F )
      return 0;
  }
  if ( v4 >= 1114112 || (unsigned int)(v4 - 55296) < 0x800 )
    return 0;
  v10 = v4 == 127;
  if ( v4 <= 127 )
    v10 = size == 2;
  result = v10;
  if ( v10 )
    return 0;
  v11 = size == 3;
  if ( v4 >= 2048 )
    v11 = 0;
  if ( !v11 )
  {
    v12 = size == 4;
    if ( v4 >= 0x10000 )
      v12 = 0;
    if ( !v12 )
    {
      result = 1;
      if ( codepoint )
      {
        *codepoint = v4;
        return 1;
      }
      return result;
    }
    return 0;
  }
  return result;
}

//----- (00049EA4) --------------------------------------------------------
const char *__fastcall utf8_iterate(const char *buffer, int32_t *codepoint)
{
  const char *v2; // r4
  int v4; // r0
  int32_t v5; // r2
  int v6; // r6
  int32_t value; // [sp+4h] [bp-4h] BYREF

  if ( !*buffer )
    return buffer;
  v2 = buffer;
  v4 = utf8_check_first(*buffer);
  v6 = v4;
  if ( v4 <= 0 )
    return 0;
  if ( v4 != 1 )
  {
    if ( utf8_check_full(v2, v4, &value) )
      goto LABEL_6;
    return 0;
  }
  value = v5;
LABEL_6:
  if ( codepoint )
    *codepoint = value;
  return &v2[v6];
}
// 49EBE: variable 'v5' is possibly undefined

//----- (00049EE4) --------------------------------------------------------
int __fastcall utf8_check_string(const char *string, int length)
{
  int v3; // r8
  int v4; // r4
  int v5; // r0
  int v6; // r5

  if ( length == -1 )
    v3 = strlen(string);
  else
    v3 = length;
  if ( v3 <= 0 )
    return 1;
  v4 = 0;
  while ( 1 )
  {
    v5 = utf8_check_first(string[v4]);
    v6 = v5;
    if ( !v5 )
      break;
    if ( v5 > 1 )
    {
      if ( v5 + v4 > v3 || !utf8_check_full(&string[v4], v5, 0) )
        return 0;
      v4 += v6 - 1;
    }
    if ( v3 <= ++v4 )
      return 1;
  }
  return 0;
}

//----- (00049F40) --------------------------------------------------------
json_t *__fastcall json_integer_copy(const json_t *integer)
{
  json_t v1; // r4
  json_t *result; // r0

  if ( integer && integer->type == JSON_INTEGER )
    v1 = integer[1];
  else
    v1 = 0;
  result = (json_t *)jsonp_malloc(0x10u);
  if ( result )
  {
    result[1] = v1;
    *result = (json_t)0x100000003LL;
  }
  return result;
}

//----- (00049F6C) --------------------------------------------------------
json_t **__fastcall json_array_grow(json_array_t *array, size_t amount, int copy)
{
  __int64 v3; // kr00_8
  json_t **table; // r6
  size_t v6; // r5
  json_t **v9; // r0

  v3 = *(_QWORD *)&array->size;
  table = array->table;
  if ( HIDWORD(v3) + amount <= (unsigned int)v3 )
    return table;
  v6 = v3 + amount;
  if ( (unsigned int)v3 + amount < 2 * (int)v3 )
    v6 = 2 * v3;
  v9 = (json_t **)jsonp_malloc(4 * v6);
  if ( !v9 )
    return 0;
  array->size = v6;
  array->table = v9;
  if ( !copy )
    return table;
  memcpy(v9, table, 4 * array->entries);
  jsonp_free(table);
  return array->table;
}

//----- (00049FB8) --------------------------------------------------------
// Alternative name is 'json_equal.part.2'
int __fastcall json_equal_0(json_t *json1, json_t *json2)
{
  json_type type; // r3
  hashtable_t *v6; // r9
  void *v7; // r0
  const char *v8; // r6
  json_t *v9; // r1
  void *v10; // r0
  json_t *v11; // r7
  size_t refcount; // r7
  json_type v13; // r2
  size_t v14; // r6
  json_t *v15; // r0
  json_t *v16; // r1
  bool v17; // zf

  type = json1->type;
  if ( json1->type != json2->type )
    return 0;
  if ( json1 == json2 )
    return 1;
  switch ( type )
  {
    case JSON_OBJECT:
      if ( json1[1].type != json2[1].type )
        return 0;
      v6 = (hashtable_t *)&json1[1];
      v7 = hashtable_iter((hashtable_t *)&json1[1]);
      if ( v7 )
      {
        v8 = (const char *)hashtable_iter_key(v7);
        if ( v8 )
        {
          while ( 1 )
          {
            v11 = (json_t *)hashtable_iter_value((void *)(v8 - 16));
            if ( !v11 )
              break;
            if ( json2->type )
              return 0;
            v9 = (json_t *)hashtable_get((hashtable_t *)&json2[1], v8);
            if ( !v9 || !json_equal_0(v11, v9) )
              return 0;
            if ( json1->type == JSON_OBJECT )
            {
              v10 = hashtable_iter_next(v6, (void *)(v8 - 16));
              if ( v10 )
              {
                v8 = (const char *)hashtable_iter_key(v10);
                if ( v8 )
                  continue;
              }
            }
            return 1;
          }
        }
      }
      return 1;
    case JSON_ARRAY:
      refcount = json1[1].refcount;
      if ( refcount != json2[1].refcount )
        return 0;
      if ( refcount )
      {
        v13 = JSON_ARRAY;
        v14 = 0;
        while ( 1 )
        {
          v15 = type == JSON_ARRAY && json1[1].refcount > v14 ? *(json_t **)(json1[2].type + 4 * v14) : 0;
          if ( v13 != JSON_ARRAY || json2[1].refcount <= v14 )
            break;
          v16 = *(json_t **)(json2[2].type + 4 * v14);
          v17 = v16 == 0;
          if ( v16 )
            v17 = v15 == 0;
          if ( v17 || !json_equal_0(v15, v16) )
            break;
          if ( refcount == ++v14 )
            return 1;
          type = json1->type;
          v13 = json2->type;
        }
        return 0;
      }
      return 1;
    case JSON_STRING:
      return strcmp((const char *)json1[1].type, (const char *)json2[1].type) == 0;
    case JSON_INTEGER:
      return *(_QWORD *)&json1[1] == *(_QWORD *)&json2[1];
  }
  if ( type != JSON_REAL )
    return 0;
  return *(double *)&json1[1] == *(double *)&json2[1];
}

//----- (0004A0E4) --------------------------------------------------------
json_t_0 *json_object()
{
  char *v0; // r0
  _DWORD *v1; // r4
  void *v3; // r0

  v0 = (char *)jsonp_malloc(0x24u);
  v1 = v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = 0;
    *((_DWORD *)v0 + 1) = 1;
    if ( hashtable_init((hashtable_t *)(v0 + 8)) )
    {
      v3 = v1;
      v1 = 0;
      jsonp_free(v3);
    }
    else
    {
      v1[7] = 0;
      v1[8] = 0;
    }
  }
  return (json_t_0 *)v1;
}

//----- (0004A114) --------------------------------------------------------
size_t __fastcall json_object_size(const json_t *json)
{
  if ( json )
  {
    if ( json->type )
      return 0;
    else
      return json[1].type;
  }
  return (size_t)json;
}

//----- (0004A124) --------------------------------------------------------
json_t *__fastcall json_object_get(const json_t *json, const char *key)
{
  if ( !json || json->type )
    return 0;
  else
    return (json_t *)hashtable_get((hashtable_t *)&json[1], key);
}

//----- (0004A134) --------------------------------------------------------
int __fastcall json_object_del(json_t *json, const char *key)
{
  if ( !json || json->type )
    return -1;
  else
    return hashtable_del((hashtable_t *)&json[1], key);
}

//----- (0004A148) --------------------------------------------------------
int __fastcall json_object_clear(json_t *json)
{
  if ( !json )
    return -1;
  if ( json->type )
    return -1;
  hashtable_clear((hashtable_t *)&json[1]);
  json[3].refcount = 0;
  return 0;
}

//----- (0004A16C) --------------------------------------------------------
void *__fastcall json_object_iter(json_t *json)
{
  if ( !json || json->type )
    return 0;
  else
    return hashtable_iter((hashtable_t *)&json[1]);
}

//----- (0004A17C) --------------------------------------------------------
void *__fastcall json_object_iter_at(json_t *json, const char *key)
{
  bool v2; // zf

  v2 = json == 0;
  if ( json )
    v2 = key == 0;
  if ( v2 || json->type )
    return 0;
  else
    return hashtable_iter_at((hashtable_t *)&json[1], key);
}

//----- (0004A194) --------------------------------------------------------
void *__fastcall json_object_iter_next(json_t *json, void *iter)
{
  _BOOL4 v2; // r3

  if ( !json )
    return 0;
  v2 = iter == 0;
  if ( json->type )
    v2 = 1;
  if ( v2 )
    return 0;
  else
    return hashtable_iter_next((hashtable_t *)&json[1], iter);
}

//----- (0004A1B0) --------------------------------------------------------
const char *__fastcall json_object_iter_key(void *iter)
{
  if ( iter )
    return (const char *)hashtable_iter_key(iter);
  return (const char *)iter;
}

//----- (0004A1B8) --------------------------------------------------------
json_t *__fastcall json_object_iter_value(void *iter)
{
  if ( iter )
    return (json_t *)hashtable_iter_value(iter);
  return (json_t *)iter;
}

//----- (0004A1C0) --------------------------------------------------------
int __fastcall json_object_iter_set_new(json_t *json, void *iter, json_t *value)
{
  if ( !json )
    return -1;
  if ( json->type )
    return -1;
  if ( !iter || value == 0 )
    return -1;
  hashtable_iter_set(iter, value);
  return 0;
}

//----- (0004A1F4) --------------------------------------------------------
void *__fastcall json_object_key_to_iter(const char *key)
{
  if ( key )
    key -= 16;
  return (void *)key;
}

//----- (0004A1FC) --------------------------------------------------------
json_t *json_array()
{
  _DWORD *v0; // r0
  _DWORD *v1; // r4
  void *v2; // r0
  void *v4; // r0

  v0 = jsonp_malloc(0x18u);
  v1 = v0;
  if ( v0 )
  {
    v0[2] = 8;
    *v0 = 1;
    v0[1] = 1;
    v0[3] = 0;
    v2 = jsonp_malloc(0x20u);
    v1[4] = v2;
    if ( v2 )
    {
      v1[5] = 0;
    }
    else
    {
      v4 = v1;
      v1 = 0;
      jsonp_free(v4);
    }
  }
  return (json_t *)v1;
}

//----- (0004A234) --------------------------------------------------------
size_t __fastcall json_array_size(const json_t *json)
{
  if ( json )
  {
    if ( json->type == JSON_ARRAY )
      return json[1].refcount;
    else
      return 0;
  }
  return (size_t)json;
}

//----- (0004A248) --------------------------------------------------------
json_t *__fastcall json_array_get(const json_t *json, size_t index)
{
  if ( json )
  {
    if ( json->type == JSON_ARRAY && json[1].refcount > index )
      return *(json_t **)(json[2].type + 4 * index);
    else
      return 0;
  }
  return (json_t *)json;
}

//----- (0004A264) --------------------------------------------------------
int __fastcall json_array_extend(json_t *json, json_t *other_json)
{
  _BOOL4 v2; // r3
  char *type; // r1
  size_t refcount; // r2
  char *v7; // r5
  int v8; // r4
  int v9; // t1

  if ( !json )
    return -1;
  v2 = other_json == 0;
  if ( json->type != JSON_ARRAY )
    v2 = 1;
  if ( v2 || other_json->type != JSON_ARRAY || !json_array_grow((json_array_t *)json, other_json[1].refcount, 1) )
    return -1;
  type = (char *)other_json[2].type;
  refcount = other_json[1].refcount;
  if ( refcount )
  {
    refcount *= 4;
    v7 = (char *)other_json[2].type;
    do
    {
      v9 = *(_DWORD *)v7;
      v7 += 4;
      v8 = v9;
      if ( v9 )
      {
        if ( *(_DWORD *)(v8 + 4) != -1 )
          ++*(_DWORD *)(v8 + 4);
      }
    }
    while ( &type[refcount] != v7 );
  }
  memcpy((void *)(json[2].type + 4 * json[1].refcount), type, refcount);
  json[1].refcount += other_json[1].refcount;
  return 0;
}

//----- (0004A2E0) --------------------------------------------------------
json_t *__fastcall json_string_nocheck(const char *value)
{
  _QWORD *v2; // r0
  _QWORD *v3; // r4
  char *v4; // r0
  void *v6; // r0

  if ( !value )
    return 0;
  v2 = jsonp_malloc(0xCu);
  if ( !v2 )
    return 0;
  v3 = v2;
  *v2 = 0x100000002LL;
  v4 = jsonp_strdup(value);
  *((_DWORD *)v3 + 2) = v4;
  if ( !v4 )
  {
    v6 = v3;
    v3 = 0;
    jsonp_free(v6);
  }
  return (json_t *)v3;
}

//----- (0004A318) --------------------------------------------------------
json_t *__fastcall json_string(const char *value)
{
  if ( !value )
    return 0;
  if ( utf8_check_string(value, -1) )
    return json_string_nocheck(value);
  return 0;
}

//----- (0004A33C) --------------------------------------------------------
const char *__fastcall json_string_value(const json_t *json)
{
  if ( json )
  {
    if ( json->type == JSON_STRING )
      return (const char *)json[1].type;
    else
      return 0;
  }
  return (const char *)json;
}

//----- (0004A34C) --------------------------------------------------------
int __fastcall json_string_set_nocheck(json_t *json, const char *value)
{
  char *v4; // r6

  if ( !json )
    return -1;
  if ( json->type != JSON_STRING || value == 0 )
    return -1;
  v4 = jsonp_strdup(value);
  if ( !v4 )
    return -1;
  jsonp_free((void *)json[1].type);
  json[1].type = (json_type)v4;
  return 0;
}

//----- (0004A388) --------------------------------------------------------
int __fastcall json_string_set(json_t *json, const char *value)
{
  if ( !value )
    return -1;
  if ( utf8_check_string(value, -1) )
    return json_string_set_nocheck(json, value);
  return -1;
}

//----- (0004A3B4) --------------------------------------------------------
json_t *__fastcall json_integer(json_int_t value)
{
  json_t *result; // r0

  result = (json_t *)jsonp_malloc(0x10u);
  if ( result )
  {
    result[1] = (json_t)value;
    *result = (json_t)0x100000003LL;
  }
  return result;
}

//----- (0004A3D0) --------------------------------------------------------
json_int_t __fastcall json_integer_value(const json_t *json)
{
  if ( json && json->type == JSON_INTEGER )
    return (json_int_t)json[1];
  else
    return 0;
}

//----- (0004A3E4) --------------------------------------------------------
int __fastcall json_integer_set(json_t *json, int a2, json_t value)
{
  if ( !json || json->type != JSON_INTEGER )
    return -1;
  json[1] = value;
  return 0;
}

//----- (0004A3FC) --------------------------------------------------------
json_t *__fastcall json_real(double value)
{
  double v1; // d0
  json_t *result; // r0

  if ( fabs(v1) > 1.79769313e308 )
    return 0;
  result = (json_t *)jsonp_malloc(0x10u);
  if ( result )
  {
    *(double *)&result[1] = v1;
    *result = (json_t)0x100000004LL;
  }
  return result;
}
// 4A40A: variable 'v1' is possibly undefined

//----- (0004A440) --------------------------------------------------------
double __fastcall json_real_value(const json_t *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 4A440: variable 'result' is possibly undefined

//----- (0004A460) --------------------------------------------------------
int __fastcall json_real_set(json_t *json, double value)
{
  double v3; // d0

  if ( !json || json->type != JSON_REAL || fabs(v3) > 1.79769313e308 )
    return -1;
  *(double *)&json[1] = v3;
  return 0;
}
// 4A480: variable 'v3' is possibly undefined

//----- (0004A4A8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall json_number_value(const json_t *json)
{
  double result; // r0

  if ( json && json->type == JSON_INTEGER )
    *(double *)&json = (double)(__int64)json[1];
  LODWORD(result) = json;
  return result;
}
// 4A4A8: variables would overlap: r0.4 and r0.8

//----- (0004A4E0) --------------------------------------------------------
json_t *json_true()
{
  return &the_true_9029;
}

//----- (0004A4EC) --------------------------------------------------------
json_t *json_false()
{
  return &the_false_9033;
}

//----- (0004A4F4) --------------------------------------------------------
json_t *json_null()
{
  return &the_null_9037;
}

//----- (0004A4FC) --------------------------------------------------------
void __fastcall json_delete(json_t *json)
{
  json_t *v1; // r4
  json_type type; // r3
  __int64 v3; // kr00_8
  unsigned int v4; // r5
  json_t *v5; // r0
  size_t refcount; // r3
  bool v7; // zf
  size_t v8; // r3

  if ( !json )
    return;
  v1 = json;
  type = json->type;
  if ( json->type == JSON_OBJECT )
  {
    hashtable_close((hashtable_t *)&json[1]);
    json = v1;
    goto LABEL_8;
  }
  if ( type == JSON_ARRAY )
  {
    v3 = *(_QWORD *)&json[1].refcount;
    if ( (_DWORD)v3 )
    {
      v4 = 0;
      do
      {
        v5 = *(json_t **)(HIDWORD(v3) + 4 * v4++);
        if ( v5 )
        {
          refcount = v5->refcount;
          v7 = refcount == -1;
          v8 = refcount - 1;
          if ( !v7 )
          {
            v5->refcount = v8;
            if ( !v8 )
            {
              json_delete(v5);
              v3 = *(_QWORD *)&v1[1].refcount;
            }
          }
        }
      }
      while ( v4 < (unsigned int)v3 );
    }
    jsonp_free((void *)HIDWORD(v3));
    jsonp_free(v1);
    return;
  }
  if ( type == JSON_STRING )
  {
    jsonp_free((void *)json[1].type);
    jsonp_free(v1);
    return;
  }
  if ( (unsigned int)(type - 3) <= 1 )
LABEL_8:
    jsonp_free(json);
}

//----- (0004A57C) --------------------------------------------------------
int __fastcall json_array_clear(json_t *json)
{
  size_t refcount; // r2
  size_t i; // r4
  json_t *v4; // r0
  size_t v5; // r3
  bool v6; // zf
  size_t v7; // r3

  if ( !json )
    return -1;
  if ( json->type != JSON_ARRAY )
    return -1;
  refcount = json[1].refcount;
  if ( refcount )
  {
    for ( i = 0; i < refcount; ++i )
    {
      v4 = *(json_t **)(json[2].type + 4 * i);
      if ( v4 )
      {
        v5 = v4->refcount;
        v6 = v5 == -1;
        v7 = v5 - 1;
        if ( !v6 )
        {
          v4->refcount = v7;
          if ( !v7 )
          {
            json_delete(v4);
            refcount = json[1].refcount;
          }
        }
      }
    }
  }
  json[1].refcount = 0;
  return 0;
}

//----- (0004A5C4) --------------------------------------------------------
int __fastcall json_array_remove(json_t *json, size_t index)
{
  size_t refcount; // r2
  size_t v5; // r6
  json_t *v6; // r0
  size_t v7; // r3
  size_t v8; // r3

  if ( !json )
    return -1;
  if ( json->type != JSON_ARRAY )
    return -1;
  refcount = json[1].refcount;
  if ( refcount <= index )
    return -1;
  v5 = 4 * index;
  v6 = *(json_t **)(json[2].type + 4 * index);
  if ( v6 )
  {
    v7 = v6->refcount;
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      v6->refcount = v8;
      if ( !v8 )
      {
        json_delete(v6);
        refcount = json[1].refcount;
      }
    }
  }
  if ( refcount - 1 > index )
  {
    memmove((void *)(json[2].type + v5), (const void *)(v5 + 4 + json[2].type), 4 * (refcount + ~index));
    --json[1].refcount;
  }
  else
  {
    json[1].refcount = refcount - 1;
  }
  return 0;
}

//----- (0004A624) --------------------------------------------------------
int __fastcall json_array_set_new(json_t *json, size_t index, json_t *value)
{
  _BOOL4 v5; // r3
  json_type type; // r3
  size_t v7; // r6
  json_t *v8; // r0
  json_t **v9; // r3
  size_t v10; // r2
  size_t v11; // r2
  size_t refcount; // r3
  size_t v14; // r3

  if ( !value )
    return -1;
  if ( !json )
    goto LABEL_12;
  v5 = value == json;
  if ( json->type != JSON_ARRAY )
    v5 = 1;
  if ( v5 || json[1].refcount <= index )
  {
LABEL_12:
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v14 = refcount - 1;
      value->refcount = v14;
      if ( !v14 )
        json_delete(value);
    }
    return -1;
  }
  else
  {
    type = json[2].type;
    v7 = 4 * index;
    v8 = *(json_t **)(type + 4 * index);
    v9 = (json_t **)(type + 4 * index);
    if ( !v8 || (v10 = v8->refcount, v10 == -1) || (v11 = v10 - 1, (v8->refcount = v11) != 0) )
    {
      *v9 = value;
      return 0;
    }
    else
    {
      json_delete(v8);
      *(_DWORD *)(json[2].type + v7) = value;
      return 0;
    }
  }
}

//----- (0004A694) --------------------------------------------------------
int __fastcall json_object_set_new_nocheck(json_t *json, const char *key, json_t *value)
{
  bool v3; // zf
  _BOOL4 v5; // r3
  size_t v6; // r2
  int result; // r0
  size_t refcount; // r3
  size_t v9; // r3

  if ( !value )
    return -1;
  v3 = json == 0;
  if ( json )
    v3 = key == 0;
  if ( v3 )
    goto LABEL_9;
  v5 = value == json;
  if ( json->type )
    v5 = 1;
  if ( v5
    || (v6 = json[3].refcount,
        json[3].refcount = v6 + 1,
        (result = hashtable_set((hashtable_t *)&json[1], key, v6, value)) != 0) )
  {
LABEL_9:
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v9 = refcount - 1;
      value->refcount = v9;
      if ( !v9 )
        json_delete(value);
    }
    return -1;
  }
  return result;
}

//----- (0004A6E8) --------------------------------------------------------
int __fastcall json_object_update(json_t *object, json_t *other)
{
  _BOOL4 v2; // r3
  hashtable_t *v3; // r9
  void *v6; // r0
  const char *v8; // r0
  const char *v9; // r5
  char *v10; // r6
  json_t *v11; // r0

  if ( !object )
    return -1;
  v2 = other == 0;
  if ( object->type )
    v2 = 1;
  if ( v2 || other->type )
    return -1;
  v3 = (hashtable_t *)&other[1];
  v6 = hashtable_iter((hashtable_t *)&other[1]);
  if ( v6 )
  {
    while ( 1 )
    {
      v8 = (const char *)hashtable_iter_key(v6);
      v9 = v8;
      if ( !v8 )
        break;
      v10 = (char *)(v8 - 16);
      v11 = (json_t *)hashtable_iter_value((void *)(v8 - 16));
      if ( !v11 )
        break;
      if ( v11->refcount != -1 )
        ++v11->refcount;
      if ( json_object_set_new_nocheck(object, v9, v11) )
        return -1;
      if ( other->type == JSON_OBJECT )
      {
        v6 = hashtable_iter_next(v3, v10);
        if ( v6 )
          continue;
      }
      return 0;
    }
  }
  return 0;
}

//----- (0004A770) --------------------------------------------------------
int __fastcall json_object_update_existing(json_t *object, json_t *other)
{
  _BOOL4 v2; // r3
  json_t *v3; // r9
  void *v6; // r0
  const char *v7; // r4
  char *v8; // r1
  hashtable_t *v9; // r0
  void *v10; // r0
  json_t *v11; // r6

  if ( !object )
    return -1;
  v2 = other == 0;
  if ( object->type )
    v2 = 1;
  if ( v2 || other->type )
    return -1;
  v3 = other + 1;
  v6 = hashtable_iter((hashtable_t *)&other[1]);
  if ( v6 )
  {
    v7 = (const char *)hashtable_iter_key(v6);
    if ( v7 )
    {
      while ( 1 )
      {
        v11 = (json_t *)hashtable_iter_value((void *)(v7 - 16));
        if ( !v11 )
          break;
        if ( object->type || !hashtable_get((hashtable_t *)&object[1], v7) )
        {
          v8 = (char *)(v7 - 16);
          v9 = (hashtable_t *)v3;
          if ( other->type )
            return 0;
        }
        else
        {
          if ( v11->refcount != -1 )
            ++v11->refcount;
          json_object_set_new_nocheck(object, v7, v11);
          v8 = (char *)(v7 - 16);
          v9 = (hashtable_t *)v3;
          if ( other->type )
            return 0;
        }
        v10 = hashtable_iter_next(v9, v8);
        if ( v10 )
        {
          v7 = (const char *)hashtable_iter_key(v10);
          if ( v7 )
            continue;
        }
        return 0;
      }
    }
  }
  return 0;
}

//----- (0004A814) --------------------------------------------------------
int __fastcall json_object_update_missing(json_t *object, json_t *other)
{
  _BOOL4 v2; // r3
  hashtable_t *v3; // r9
  void *v6; // r0
  const char *v7; // r4
  size_t refcount; // r3
  void *v9; // r0
  json_t *v10; // r5

  if ( !object )
    return -1;
  v2 = other == 0;
  if ( object->type )
    v2 = 1;
  if ( v2 || other->type )
    return -1;
  v3 = (hashtable_t *)&other[1];
  v6 = hashtable_iter((hashtable_t *)&other[1]);
  if ( v6 )
  {
    v7 = (const char *)hashtable_iter_key(v6);
    if ( v7 )
    {
      while ( 1 )
      {
        v10 = (json_t *)hashtable_iter_value((void *)(v7 - 16));
        if ( !v10 )
          break;
        if ( object->type || !hashtable_get((hashtable_t *)&object[1], v7) )
        {
          refcount = v10->refcount;
          if ( refcount != -1 )
            v10->refcount = refcount + 1;
          json_object_set_new_nocheck(object, v7, v10);
          if ( other->type )
            return 0;
        }
        else if ( other->type )
        {
          return 0;
        }
        v9 = hashtable_iter_next(v3, (void *)(v7 - 16));
        if ( v9 )
        {
          v7 = (const char *)hashtable_iter_key(v9);
          if ( v7 )
            continue;
        }
        return 0;
      }
    }
  }
  return 0;
}

//----- (0004A8B4) --------------------------------------------------------
int __fastcall json_object_set_new(json_t *json, const char *key, json_t *value)
{
  size_t refcount; // r3
  size_t v8; // r3

  if ( key && utf8_check_string(key, -1) )
    return json_object_set_new_nocheck(json, key, value);
  if ( value )
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v8 = refcount - 1;
      value->refcount = v8;
      if ( !v8 )
        json_delete(value);
    }
  }
  return -1;
}

//----- (0004A8F4) --------------------------------------------------------
int __fastcall json_array_insert_new(json_t *json, size_t index, json_t *value)
{
  _BOOL4 v6; // r2
  json_t **v7; // r8
  json_t **type; // r0
  size_t v9; // r5
  size_t v11; // r3
  size_t refcount; // r3
  size_t v13; // r3

  if ( !value )
    return -1;
  if ( json
    && (json->type != JSON_ARRAY ? (v6 = 1) : (v6 = value == json),
        !v6 && json[1].refcount >= index && (v7 = json_array_grow((json_array_t *)json, 1u, 0)) != 0) )
  {
    type = (json_t **)json[2].type;
    v9 = index + 1;
    if ( type == v7 )
    {
      memmove(&type[v9], &v7[v9 - 1], 4 * (json[1].refcount - index));
    }
    else
    {
      memcpy(type, v7, v9 * 4 - 4);
      memcpy((void *)(json[2].type + v9 * 4), &v7[v9 - 1], 4 * (json[1].refcount - index));
      jsonp_free(v7);
    }
    v11 = json[1].refcount + 1;
    *(_DWORD *)(json[2].type + v9 * 4 - 4) = value;
    json[1].refcount = v11;
    return 0;
  }
  else
  {
    refcount = value->refcount;
    if ( refcount != -1 )
    {
      v13 = refcount - 1;
      value->refcount = v13;
      if ( !v13 )
        json_delete(value);
    }
    return -1;
  }
}

//----- (0004A99C) --------------------------------------------------------
int __fastcall json_array_append_new(json_t *json, json_t *value)
{
  _BOOL4 v4; // r5
  size_t refcount; // r3
  size_t v7; // r3
  size_t v8; // r3

  if ( !value )
    return -1;
  if ( !json )
    goto LABEL_8;
  v4 = value == json;
  if ( json->type != JSON_ARRAY )
    v4 = 1;
  if ( !v4 && json_array_grow((json_array_t *)json, 1u, 1) )
  {
    refcount = json[1].refcount;
    *(_DWORD *)(json[2].type + 4 * refcount) = value;
    json[1].refcount = refcount + 1;
    return 0;
  }
  else
  {
LABEL_8:
    v7 = value->refcount;
    if ( v7 != -1 )
    {
      v8 = v7 - 1;
      value->refcount = v8;
      if ( !v8 )
        json_delete(value);
    }
    return -1;
  }
}

//----- (0004A9F4) --------------------------------------------------------
int __fastcall json_equal(json_t *json1, json_t *json2)
{
  bool v2; // zf

  v2 = json2 == 0;
  if ( json2 )
    v2 = json1 == 0;
  if ( v2 )
    return 0;
  else
    return json_equal_0(json1, json2);
}

//----- (0004AA04) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t *__fastcall json_copy(json_t *json)
{
  json_type type; // r3
  json_t *v3; // r8
  void *i; // r0
  const char *v6; // r0
  const char *v7; // r6
  char *v8; // r7
  json_t *v9; // r0
  size_t refcount; // r3
  size_t j; // r4
  json_t *v12; // r1

  if ( !json )
    return 0;
  type = json->type;
  if ( json->type == JSON_OBJECT )
  {
    v3 = (json_t *)json_object();
    if ( v3 )
    {
      if ( json->type == JSON_OBJECT )
      {
        for ( i = hashtable_iter((hashtable_t *)&json[1]); i; i = hashtable_iter_next((hashtable_t *)&json[1], v8) )
        {
          v6 = (const char *)hashtable_iter_key(i);
          v7 = v6;
          if ( !v6 )
            break;
          v8 = (char *)(v6 - 16);
          v9 = (json_t *)hashtable_iter_value((void *)(v6 - 16));
          if ( !v9 )
            break;
          if ( v9->refcount != -1 )
            ++v9->refcount;
          json_object_set_new_nocheck(v3, v7, v9);
          if ( json->type )
            break;
        }
      }
      return v3;
    }
    return 0;
  }
  switch ( type )
  {
    case JSON_ARRAY:
      v3 = json_array();
      if ( v3 )
      {
        if ( json->type == JSON_ARRAY )
        {
          refcount = json[1].refcount;
          if ( refcount )
          {
            for ( j = 0; j < refcount; ++j )
            {
              v12 = 0;
              if ( j < refcount )
              {
                v12 = *(json_t **)(json[2].type + 4 * j);
                if ( v12 )
                {
                  if ( v12->refcount != -1 )
                    ++v12->refcount;
                }
              }
              json_array_append_new(v3, v12);
              if ( json->type != JSON_ARRAY )
                break;
              refcount = json[1].refcount;
            }
          }
        }
        return v3;
      }
      return 0;
    case JSON_STRING:
      return json_string_nocheck((const char *)json[1].type);
    case JSON_INTEGER:
      return json_integer_copy(json);
  }
  if ( type != JSON_REAL )
  {
    if ( (unsigned int)(type - 5) <= 2 )
      return json;
    return 0;
  }
  return json_real(*(double *)&json);
}
// 4AA04: variables would overlap: r0.4 and r0.8

//----- (0004AB08) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
json_t *__fastcall json_deep_copy(const json_t *json)
{
  json_type type; // r3
  json_t *v3; // r6
  void *i; // r4
  const char *v5; // r7
  const json_t *v6; // r0
  json_t *v7; // r0
  size_t refcount; // r3
  size_t j; // r4
  const json_t *v11; // r0
  json_t *v12; // r0

  if ( !json )
    return 0;
  type = json->type;
  if ( json->type == JSON_OBJECT )
  {
    v3 = (json_t *)json_object();
    if ( v3 )
    {
      if ( json->type == JSON_OBJECT )
      {
        for ( i = hashtable_iter((hashtable_t *)&json[1]); i; i = hashtable_iter_next((hashtable_t *)&json[1], i) )
        {
          v5 = (const char *)hashtable_iter_key(i);
          v6 = (const json_t *)hashtable_iter_value(i);
          v7 = json_deep_copy(v6);
          json_object_set_new_nocheck(v3, v5, v7);
          if ( json->type )
            break;
        }
      }
      return v3;
    }
    return 0;
  }
  switch ( type )
  {
    case JSON_ARRAY:
      v3 = json_array();
      if ( v3 )
      {
        if ( json->type == JSON_ARRAY )
        {
          refcount = json[1].refcount;
          if ( refcount )
          {
            for ( j = 0; j < refcount; ++j )
            {
              v11 = 0;
              if ( refcount > j )
                v11 = *(const json_t **)(json[2].type + 4 * j);
              v12 = json_deep_copy(v11);
              json_array_append_new(v3, v12);
              if ( json->type != JSON_ARRAY )
                break;
              refcount = json[1].refcount;
            }
          }
        }
        return v3;
      }
      return 0;
    case JSON_STRING:
      return json_string_nocheck((const char *)json[1].type);
    case JSON_INTEGER:
      return json_integer_copy(json);
  }
  if ( type != JSON_REAL )
  {
    if ( (unsigned int)(type - 5) <= 2 )
      return (json_t *)json;
    return 0;
  }
  return json_real(*(double *)&json);
}
// 4AB08: variables would overlap: r0.4 and r0.8

//----- (0004ABF0) --------------------------------------------------------
// Alternative name is 'jsonp_error_set_source.part.0'
void __fastcall jsonp_error_set_source_0(json_error_t *error, const char *source)
{
  size_t v4; // r0

  v4 = strlen(source);
  if ( v4 <= 0x4F )
  {
    sub_12058(error->source, source, v4 + 1);
  }
  else
  {
    strcpy(error->source, "...");
    j_strcpy(&error->source[3], &source[v4 - 76]);
  }
}

//----- (0004AC30) --------------------------------------------------------
void __fastcall jsonp_error_init(json_error_t *error, const char *source)
{
  if ( error )
  {
    error->text[0] = 0;
    error->position = 0;
    error->line = -1;
    error->column = -1;
    if ( source )
      jsonp_error_set_source_0(error, source);
    else
      error->source[0] = 0;
  }
}

//----- (0004AC54) --------------------------------------------------------
void __fastcall jsonp_error_set_source(json_error_t *error, const char *source)
{
  bool v2; // zf

  v2 = source == 0;
  if ( source )
    v2 = error == 0;
  if ( !v2 )
    jsonp_error_set_source_0(error, source);
}

//----- (0004AC60) --------------------------------------------------------
void jsonp_error_set(json_error_t *error, int line, int column, int position, const char *msg, ...)
{
  va_list va; // [sp+24h] [bp+18h] BYREF

  va_start(va, msg);
  if ( error )
  {
    if ( !error->text[0] )
    {
      error->line = line;
      error->column = column;
      error->position = position;
      vsnprintf(error->text, 0xA0u, msg, va);
      error->text[159] = 0;
    }
  }
}

//----- (0004AC98) --------------------------------------------------------
void __fastcall jsonp_error_vset(
        json_error_t *error,
        int line,
        int column,
        size_t position,
        const char *msg,
        va_list ap)
{
  if ( error )
  {
    if ( !error->text[0] )
    {
      error->line = line;
      error->column = column;
      error->position = position;
      vsnprintf(error->text, 0xA0u, msg, ap);
      error->text[159] = 0;
    }
  }
}

//----- (0004ACC4) --------------------------------------------------------
char *__fastcall arg_bad(const char *fmt, const char *arg)
{
  size_t v4; // r5
  size_t v5; // r0
  char *v6; // r5

  v4 = strlen(fmt);
  v5 = strlen(arg);
  v6 = (char *)malloc(v5 + v4);
  sprintf(v6, fmt, arg);
  return v6;
}

//----- (0004ACEC) --------------------------------------------------------
char *__fastcall opt_set_bool(bool *b)
{
  *b = 1;
  return 0;
}

//----- (0004ACF4) --------------------------------------------------------
char *__fastcall opt_set_invbool(bool *b)
{
  *b = 0;
  return 0;
}

//----- (0004ACFC) --------------------------------------------------------
char *__fastcall opt_set_bool_arg(const char *arg, bool *b)
{
  const char *v4; // r1
  const char *v5; // r1
  const char *v6; // r1

  if ( !strcasecmp(arg, "yes")
    || (LOWORD(v4) = 21368, HIWORD(v4) = (unsigned int)"ure_offset_value_chain_sensor" >> 16, !strcasecmp(arg, v4)) )
  {
    *b = 1;
    return 0;
  }
  else
  {
    LOWORD(v5) = 17780;
    HIWORD(v5) = (unsigned int)"t ASIC baud = %d, error!!!\n" >> 16;
    if ( !strcasecmp(arg, v5)
      || (LOWORD(v6) = 25936,
          HIWORD(v6) = (unsigned int)"data[3] = 0x%x, \t\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n" >> 16,
          !strcasecmp(arg, v6)) )
    {
      *b = 0;
      return 0;
    }
    else
    {
      return opt_invalid_argument(arg);
    }
  }
}

//----- (0004AD5C) --------------------------------------------------------
char *__fastcall opt_set_invbool_arg(const char *arg, bool *b)
{
  char *result; // r0

  result = opt_set_bool_arg(arg, b);
  if ( !result )
    *b ^= 1u;
  return result;
}

//----- (0004AD74) --------------------------------------------------------
char *__fastcall opt_set_charp(const char *arg, char **p)
{
  *p = (char *)arg;
  return 0;
}

//----- (0004AD7C) --------------------------------------------------------
char *__fastcall opt_set_floatval(const char *arg, float *f)
{
  int v2; // s0
  int *v5; // r5
  char *v6; // r3
  char *result; // r0
  char *endp; // [sp+4h] [bp-4h] BYREF

  v5 = _errno_location();
  *v5 = 0;
  strtof(arg, &endp);
  v6 = endp;
  *(_DWORD *)f = v2;
  if ( *v6 || !*arg )
    return arg_bad("'%s' is not a number", arg);
  result = (char *)*v5;
  if ( *v5 )
    return arg_bad("'%s' is out of range", arg);
  return result;
}
// 4AD98: variable 'v2' is possibly undefined
// 12210: using guessed type int __fastcall strtof(_DWORD, _DWORD);

//----- (0004ADCC) --------------------------------------------------------
char *__fastcall opt_set_longval(const char *arg, int *l)
{
  int *v4; // r5
  int v5; // r0
  char *v6; // r3
  char *result; // r0
  char *endp; // [sp+4h] [bp-4h] BYREF

  v4 = _errno_location();
  *v4 = 0;
  v5 = strtol(arg, &endp, 0);
  v6 = endp;
  *l = v5;
  if ( *v6 || !*arg )
    return arg_bad("'%s' is not a number", arg);
  result = (char *)*v4;
  if ( *v4 )
    return arg_bad("'%s' is out of range", arg);
  return result;
}

//----- (0004AE1C) --------------------------------------------------------
char *__fastcall opt_set_intval(const char *arg, int *i)
{
  char *result; // r0
  int l; // [sp+4h] [bp-4h] BYREF

  result = opt_set_longval(arg, &l);
  if ( !result )
    *i = l;
  return result;
}

//----- (0004AE34) --------------------------------------------------------
char *__fastcall opt_set_uintval(const char *arg, unsigned int *ui)
{
  char *result; // r0
  int l; // [sp+4h] [bp-8h] BYREF

  result = opt_set_longval(arg, &l);
  if ( !result )
  {
    if ( l < 0 )
      return arg_bad("'%s' is negative", arg);
    else
      *ui = l;
  }
  return result;
}

//----- (0004AE64) --------------------------------------------------------
char *__fastcall opt_set_ulongval(const char *arg, unsigned int *ul)
{
  char *result; // r0
  bool v5; // nf
  int l; // [sp+4h] [bp-8h] BYREF

  result = opt_set_longval(arg, &l);
  if ( !result )
  {
    v5 = l < 0;
    *ul = l;
    if ( v5 )
      return arg_bad("'%s' is negative", arg);
  }
  return result;
}

//----- (0004AE94) --------------------------------------------------------
char *__fastcall opt_inc_intval(int *i)
{
  ++*i;
  return 0;
}

//----- (0004AEA0) --------------------------------------------------------
char *__fastcall __noreturn opt_version_and_exit(const char *version)
{
  puts(version);
  fflush((FILE *)stdout);
  exit(0);
}
// 6D854: using guessed type int stdout;

//----- (0004AEBC) --------------------------------------------------------
char *__fastcall __noreturn opt_usage_and_exit(const char *extra)
{
  char *v1; // r0

  v1 = opt_usage(opt_argv0, extra);
  printf("%s", v1);
  fflush((FILE *)stdout);
  exit(0);
}
// 6D854: using guessed type int stdout;

//----- (0004AEF0) --------------------------------------------------------
void __fastcall opt_show_bool(char *buf, const bool *b)
{
  const char *v2; // r3
  int v3; // r4
  const char *v4; // r1

  LOWORD(v2) = 25936;
  v3 = *(unsigned __int8 *)b;
  v4 = "true";
  if ( !v3 )
  {
    HIWORD(v2) = (unsigned int)"data[3] = 0x%x, \t\tread_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x, \t\tread_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n" >> 16;
    v4 = v2;
  }
  j_strncpy(buf, v4, 0x50u);
}

//----- (0004AF14) --------------------------------------------------------
void __fastcall opt_show_invbool(char *buf, const bool *b)
{
  int v2; // r4
  const char *v3; // r1

  v2 = *(unsigned __int8 *)b;
  v3 = "false";
  if ( !v2 )
    v3 = "true";
  j_strncpy(buf, v3, 0x50u);
}

//----- (0004AF38) --------------------------------------------------------
void __fastcall opt_show_charp(char *buf, char *const *p)
{
  size_t v4; // r5
  char *v5; // r0
  const char *v6; // r1
  char *v7; // r4

  v4 = strlen(*(const char **)p);
  *buf = 34;
  v5 = buf + 1;
  v6 = *p;
  if ( v4 > 0x4E )
  {
    strncpy(v5, v6, 0x4Eu);
    buf[79] = 34;
  }
  else
  {
    v7 = &buf[v4];
    strncpy(v5, v6, v4);
    v7[1] = 34;
    if ( v4 != 78 )
      v7[2] = 0;
  }
}

//----- (0004AF74) --------------------------------------------------------
void __fastcall opt_show_intval(char *buf, const int *i)
{
  j_snprintf(buf, 0x50u, "%i", *i);
}

//----- (0004AF84) --------------------------------------------------------
void __fastcall opt_show_floatval(char *buf, const float *f)
{
  int v2; // r3

  snprintf(buf, 0x50u, "%.1f", v2, *f);
}
// 4AF9E: variable 'v2' is possibly undefined

//----- (0004AFA8) --------------------------------------------------------
void __fastcall opt_show_uintval(char *buf, const unsigned int *ui)
{
  j_snprintf(buf, 0x50u, "%u", *ui);
}

//----- (0004AFB8) --------------------------------------------------------
void __fastcall opt_show_longval(char *buf, const int *l)
{
  j_snprintf(buf, 0x50u, "%li", *l);
}

//----- (0004AFC8) --------------------------------------------------------
void __fastcall opt_show_ulongval(char *buf, const unsigned int *ul)
{
  j_snprintf(buf, 0x50u, "%lu", *ul);
}

//----- (0004AFD8) --------------------------------------------------------
const char *__fastcall first_opt(unsigned int *i, unsigned int *len)
{
  opt_table *v2; // r2
  opt_table *v3; // r5
  unsigned int v4; // r4
  const char *v5; // r4

  *i = 0;
  if ( !opt_count )
    return 0;
  v2 = opt_table_0;
  if ( opt_table_0->type == opt_type::OPT_SUBTABLE )
  {
    v3 = opt_table_0 + 1;
    v4 = 1;
    do
    {
      *i = v4;
      v2 = v3++;
      if ( opt_count <= v4++ )
        return 0;
    }
    while ( v2->type == opt_type::OPT_SUBTABLE );
  }
  v5 = v2->names + 1;
  *len = strcspn(v5, "|= ");
  return v5;
}

//----- (0004B038) --------------------------------------------------------
const char *__fastcall next_name(const char *names, unsigned int *len)
{
  int v2; // r3
  const char *v3; // r0
  bool v4; // zf
  const char *v5; // r4

  v2 = (unsigned __int8)names[*len];
  v3 = &names[*len];
  v4 = (v2 & 0xDF) == 0;
  if ( (v2 & 0xDF) != 0 )
    v4 = v2 == 61;
  if ( v4 )
    return 0;
  v5 = v3 + 2;
  *len = strcspn(v3 + 2, "|= ");
  return v5;
}

//----- (0004B068) --------------------------------------------------------
const char *__fastcall next_opt(const char *p, unsigned int *i, unsigned int *len)
{
  unsigned int j; // r3
  opt_table *v7; // r2
  const char *v9; // r4

  for ( j = *i; j < opt_count; *i = ++j )
  {
    v7 = &opt_table_0[j];
    if ( v7->type != opt_type::OPT_SUBTABLE )
    {
      if ( !p )
      {
        v9 = v7->names + 1;
        *len = strcspn(v9, "|= ");
        return v9;
      }
      p = next_name(p, len);
      if ( p )
        return p;
      j = *i;
    }
  }
  return 0;
}

//----- (0004B0DC) --------------------------------------------------------
void __fastcall check_opt(const opt_table *entry)
{
  __int64 v1; // r2
  bool v2; // cc
  const char *v4; // r4
  size_t v5; // r0
  opt_type type; // r5
  unsigned int v7; // r3
  int v8; // r3
  bool v9; // zf
  unsigned int len; // [sp+Ch] [bp-8h] BYREF

  v1 = *(_QWORD *)&entry->names;
  v2 = entry->type > (unsigned int)opt_type::OPT_PROCESSARG;
  if ( entry->type != opt_type::OPT_PROCESSARG )
    v2 = (unsigned int)(entry->type - 1) > 1;
  if ( v2 )
    errx(1, "Option %s: unknown entry type %u", (const char *)v1, HIDWORD(v1));
  if ( !entry->desc )
    errx(1, "Option %s: description cannot be NULL", (const char *)v1);
  if ( *(_BYTE *)v1 != 45 )
    errx(1, "Option %s: does not begin with '-'", (const char *)v1);
  v4 = (const char *)(v1 + 1);
  v5 = strcspn((const char *)(v1 + 1), "|= ");
  for ( len = v5; ; v5 = len )
  {
    if ( *v4 == 45 )
    {
      if ( v5 == 1 )
        errx(1, "Option %s: invalid long option '--'", entry->names);
      type = entry->type;
      ++opt_num_long;
    }
    else
    {
      if ( v5 != 1 )
        errx(1, "Option %s: invalid short option '%.*s'", entry->names, v5 + 1, v4 - 1);
      type = entry->type;
      v7 = (type - 2) & 0xFFFFFFFD;
      if ( !v7 )
        v7 = opt_num_short_arg;
      ++opt_num_short;
      if ( ((type - 2) & 0xFFFFFFFD) == 0 )
        opt_num_short_arg = v7 + 1;
    }
    if ( type == opt_type::OPT_NOARG )
    {
      v8 = (unsigned __int8)v4[v5];
      v9 = v8 == 61;
      if ( v8 != 61 )
        v9 = v8 == 32;
      if ( v9 )
        errx(1, "Option %s: does not take arguments '%s'", entry->names, &v4[v5 + 1]);
    }
    v4 = next_name(v4, &len);
    if ( !v4 )
      break;
  }
}

//----- (0004B1E8) --------------------------------------------------------
void __fastcall add_opt(const opt_table *entry)
{
  opt_table *v2; // r4
  const char *names; // r0
  opt_type type; // r1
  char *(*cb)(void *); // r2
  char *(*cb_arg)(const char *, void *); // r3
  unsigned int v7; // r12
  opt_table *v8; // r4
  opt_type v9; // r1
  char *(*v10)(void *); // r2

  v2 = (opt_table *)realloc(opt_table_0, 28 * (opt_count + 1));
  names = entry->names;
  type = entry->type;
  cb = entry->cb;
  cb_arg = entry->cb_arg;
  entry = (const opt_table *)((char *)entry + 16);
  opt_table_0 = v2;
  v7 = opt_count++;
  v8 = &v2[v7];
  v8->names = names;
  v8->type = type;
  v8->cb = cb;
  v8->cb_arg = cb_arg;
  v8 = (opt_table *)((char *)v8 + 16);
  v9 = entry->type;
  v10 = entry->cb;
  v8->names = entry->names;
  v8->type = v9;
  v8->cb = v10;
}

//----- (0004B230) --------------------------------------------------------
const char *__fastcall first_lopt(unsigned int *i, unsigned int *len)
{
  const char *opt; // r0

  opt = first_opt(i, len);
  if ( !opt )
    return 0;
  while ( *opt != 45 )
  {
    opt = next_opt(opt, i, len);
    if ( !opt )
      return 0;
  }
  --*len;
  return opt + 1;
}

//----- (0004B25C) --------------------------------------------------------
const char *__fastcall next_lopt(const char *p, unsigned int *i, unsigned int *len)
{
  const char *opt; // r0

  opt = next_opt(p, i, len);
  if ( !opt )
    return 0;
  while ( *opt != 45 )
  {
    opt = next_opt(opt, i, len);
    if ( !opt )
      return 0;
  }
  --*len;
  return opt + 1;
}

//----- (0004B288) --------------------------------------------------------
const char *__fastcall first_sopt(unsigned int *i)
{
  const char *result; // r0
  unsigned int len; // [sp+4h] [bp-8h] BYREF

  len = 0;
  result = first_opt(i, &len);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = next_opt(result, i, &len);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0004B2BC) --------------------------------------------------------
const char *__fastcall next_sopt(const char *p, unsigned int *i)
{
  const char *result; // r0
  unsigned int len; // [sp+4h] [bp-8h] BYREF

  len = 1;
  result = next_opt(p, i, &len);
  if ( !result )
    return 0;
  while ( *result == 45 )
  {
    result = next_opt(result, i, &len);
    if ( !result )
      return 0;
  }
  return result;
}

//----- (0004B2F0) --------------------------------------------------------
void __fastcall opt_register(
        const char *names,
        opt_type type,
        char *(*cb)(void *),
        char *(*cb_arg)(const char *, void *),
        void (*show)(char *, const void *),
        const void *arg,
        const char *desc)
{
  opt_table entry; // [sp+4h] [bp-20h] BYREF

  entry.type = type;
  entry.names = names;
  entry.cb = cb;
  entry.cb_arg = cb_arg;
  entry.desc = desc;
  entry.show = show;
  entry.u.tlen = (size_t)arg;
  check_opt(&entry);
  add_opt(&entry);
}

//----- (0004B318) --------------------------------------------------------
void __fastcall opt_register_table(const opt_table *entry, const char *desc)
{
  const opt_table *v2; // r4
  unsigned int v4; // r7
  opt_type type; // r3
  opt_table heading; // [sp+4h] [bp-20h] BYREF

  v2 = entry;
  v4 = opt_count;
  if ( desc )
  {
    heading.names = 0;
    memset(&heading.cb, 0, 16);
    heading.desc = desc;
    heading.type = opt_type::OPT_SUBTABLE;
    add_opt(&heading);
    type = v2->type;
    if ( type == opt_type::OPT_END )
    {
LABEL_7:
      opt_table_0[v4].u.tlen = opt_count - v4;
      return;
    }
  }
  else
  {
    type = entry->type;
    if ( type == opt_type::OPT_END )
      return;
  }
  do
  {
    if ( type == opt_type::OPT_SUBTABLE )
    {
      opt_register_table((const opt_table *)v2->names, v2->desc);
    }
    else
    {
      check_opt(v2);
      add_opt(v2);
    }
    ++v2;
    type = v2->type;
  }
  while ( type != opt_type::OPT_END );
  if ( desc )
    goto LABEL_7;
}

//----- (0004B394) --------------------------------------------------------
bool __fastcall opt_parse(int *argc, char **argv, void (*errlog)(const char *, ...))
{
  int v6; // r0
  unsigned int offset; // [sp+4h] [bp-8h] BYREF

  opt_argv0 = *argv;
  offset = 0;
  do
    v6 = parse_one(argc, argv, &offset, errlog);
  while ( v6 == 1 );
  return v6 == 0;
}

//----- (0004B3CC) --------------------------------------------------------
void opt_free_table()
{
  free(opt_table_0);
  opt_table_0 = 0;
}

//----- (0004B3E4) --------------------------------------------------------
void opt_log_stderr(const char *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+Ch] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)stderr, fmt, varg_r1);
  fputc(10, (FILE *)stderr);
}
// 6D848: using guessed type int stderr;

//----- (0004B414) --------------------------------------------------------
void __noreturn opt_log_stderr_exit(const char *fmt, ...)
{
  va_list varg_r1; // [sp+14h] [bp+8h] BYREF

  va_start(varg_r1, fmt);
  vfprintf((FILE *)stderr, fmt, varg_r1);
  fputc(10, (FILE *)stderr);
  exit(1);
}
// 6D848: using guessed type int stderr;

//----- (0004B440) --------------------------------------------------------
char *__fastcall opt_invalid_argument(const char *arg)
{
  size_t v2; // r0
  char *v3; // r4

  v2 = strlen(arg);
  v3 = (char *)malloc(v2 + 22);
  sprintf(v3, "Invalid argument '%s'", arg);
  return v3;
}

//----- (0004B464) --------------------------------------------------------
void __fastcall consume_option(int *argc, char **argv, unsigned int optnum)
{
  memmove(&argv[optnum], &argv[optnum + 1], 4 * (*argc - optnum));
  --*argc;
}

//----- (0004B484) --------------------------------------------------------
int __fastcall parse_one(int *argc, char **argv, unsigned int *offset, void (*errlog)(const char *, ...))
{
  int result; // r0
  char **v9; // r6
  char **v10; // r3
  unsigned int v11; // r4
  int v12; // t1
  const char *v13; // r0
  char *v14; // r11
  unsigned int v15; // r1
  unsigned int v16; // r12
  opt_table *v17; // r3
  unsigned int v18; // r0
  opt_table *v19; // r3
  opt_type type; // r0
  char *v21; // r7
  char *v22; // r11
  int v23; // r7
  const char *v24; // r0
  unsigned int v25; // r11
  const char *v26; // r8
  char *v27; // r7
  unsigned int v28; // r4
  unsigned int v29; // r1
  const char *v30; // r6
  size_t v31; // r0
  char *v32; // r2
  unsigned int v33; // r7
  const char *o; // [sp+8h] [bp-14h]
  unsigned int *offseta; // [sp+Ch] [bp-10h]
  unsigned int i; // [sp+10h] [bp-Ch] BYREF
  unsigned int len[2]; // [sp+14h] [bp-8h] BYREF

  if ( getenv("POSIXLY_CORRECT") )
  {
    result = (int)argv[1];
    v9 = argv + 1;
    if ( result )
    {
      if ( *(_BYTE *)result != 45 )
        return 0;
      v11 = 1;
      if ( *(_BYTE *)(result + 1) == 45 )
      {
LABEL_32:
        v23 = *(unsigned __int8 *)(result + 2);
        if ( !*(_BYTE *)(result + 2) )
        {
          consume_option(argc, argv, v11);
          return v23;
        }
        if ( *offset )
          _assert_fail("*offset == 0", "opt/parse.c", 0x3Bu, "parse_one");
        v24 = first_lopt(&i, len);
        if ( v24 )
        {
          offseta = offset;
          v25 = v11;
          v26 = v24;
          do
          {
            v27 = *v9;
            v28 = len[0];
            if ( !strncmp(*v9 + 2, v26, len[0]) )
            {
              v29 = v28 + 2;
              if ( v27[v28 + 2] == 61 )
              {
                v32 = v27;
                v16 = i;
                v33 = v28;
                v11 = v25;
                v14 = v32;
                o = v26 - 2;
                offset = offseta;
                v21 = &v32[v33 + 3];
                len[0] = v29;
                v19 = &opt_table_0[i];
                type = v19->type;
                if ( type != opt_type::OPT_NOARG )
                {
                  if ( !v21 )
                  {
LABEL_44:
                    v15 = *offset;
                    goto LABEL_18;
                  }
                  goto LABEL_21;
                }
                if ( v21 )
                {
                  errlog("%s: %.*s: %s", *argv, v29, o, "doesn't allow an argument");
                  return -1;
                }
LABEL_36:
                v21 = 0;
                v22 = v19->cb(v19->u.tlen);
                goto LABEL_24;
              }
              if ( !v27[v28 + 2] )
              {
                v16 = i;
                o = v26 - 2;
                v11 = v25;
                offset = offseta;
                v14 = v27;
                len[0] = v29;
                v19 = &opt_table_0[i];
                type = v19->type;
                if ( type == opt_type::OPT_NOARG )
                  goto LABEL_36;
                goto LABEL_44;
              }
            }
            v26 = next_lopt(v26, &i, len);
          }
          while ( v26 );
        }
LABEL_46:
        v30 = *v9;
        v31 = strlen(v30);
        errlog("%s: %.*s: %s", *argv, v31, v30, "unrecognized option");
        return -1;
      }
LABEL_15:
      v13 = first_sopt(&i);
      if ( !v13 )
        goto LABEL_46;
      v14 = *v9;
      v15 = *offset + 1;
      if ( *(unsigned __int8 *)v13 != (unsigned __int8)(*v9)[v15] )
      {
        do
        {
          v13 = next_sopt(v13, &i);
          if ( !v13 )
            goto LABEL_46;
          v15 = *offset + 1;
        }
        while ( (*v9)[v15] != *v13 );
        v14 = *v9;
      }
      v16 = i;
      v17 = opt_table_0;
      o = v13 - 1;
      v18 = i;
      *offset = v15;
      len[0] = 2;
      v19 = &v17[v18];
      type = v19->type;
      if ( type == opt_type::OPT_NOARG )
        goto LABEL_36;
LABEL_18:
      if ( v15 )
      {
        v21 = &v14[v15 + 1];
        if ( *v21 )
        {
          *offset = 0;
          goto LABEL_21;
        }
      }
      v21 = argv[v11 + 1];
      if ( !v21 )
      {
        errlog("%s: %.*s: %s", *argv, len[0], o, "requires an argument");
        return -1;
      }
LABEL_21:
      if ( type == opt_type::OPT_PROCESSARG )
      {
        opt_set_charp(v21, (char **)v19->u.carg);
        v16 = i;
      }
      v22 = opt_table_0[v16].cb_arg(v21, opt_table_0[v16].u.tlen);
LABEL_24:
      if ( v22 )
      {
        errlog("%s: %.*s: %s", *argv, len[0], o, v22);
        free(v22);
        return -1;
      }
      if ( *offset )
      {
        if ( (*v9)[*offset + 1] )
          return 1;
        *offset = 0;
      }
      consume_option(argc, argv, v11);
      if ( v21 )
      {
        if ( *v9 == v21 )
          consume_option(argc, argv, v11);
      }
      return 1;
    }
  }
  else
  {
    result = (int)argv[1];
    if ( result )
    {
      if ( *(_BYTE *)result == 45 )
      {
        v9 = argv + 1;
        v11 = 1;
LABEL_14:
        if ( *(_BYTE *)(result + 1) == 45 )
          goto LABEL_32;
        goto LABEL_15;
      }
      v10 = argv + 2;
      v11 = 1;
      while ( 1 )
      {
        v9 = v10;
        v12 = (int)*v10++;
        result = v12;
        ++v11;
        if ( !v12 )
          break;
        if ( *(_BYTE *)result == 45 )
          goto LABEL_14;
      }
    }
  }
  return result;
}

//----- (0004B77C) --------------------------------------------------------
char *__fastcall opt_usage(const char *argv0, const char *extra)
{
  size_t v3; // r7
  opt_table *v4; // r4
  unsigned int v5; // r8
  size_t v6; // r7
  size_t v7; // r0
  size_t v8; // r7
  size_t v9; // r5
  const char *desc; // r11
  char *v11; // r0
  char *v12; // r4
  int v13; // r0
  char *v14; // r1
  char *v15; // r4
  char *v16; // r7
  const char *sopt; // r12
  int v18; // r8
  int v19; // r0
  char *v20; // r5
  unsigned int v21; // r3
  int v22; // r7
  unsigned int v23; // r8
  int v24; // r2
  unsigned int v25; // r4
  unsigned int v26; // r4
  char *v27; // r3
  opt_table *v28; // r3
  const char *v29; // r2
  int v30; // r0
  unsigned int v31; // r4
  char *v32; // r3
  char *v33; // r0
  char *v34; // r0
  int v36; // r2
  opt_table *v37; // r3
  __int16 *v39; // [sp+0h] [bp-74h]
  const char *v40; // [sp+4h] [bp-70h]
  char *s; // [sp+Ch] [bp-68h]
  char *v42; // [sp+10h] [bp-64h]
  char *ret; // [sp+14h] [bp-60h]
  char buf[84]; // [sp+1Ch] [bp-58h] BYREF

  v3 = opt_num_short + 20 + strlen(argv0);
  if ( extra )
  {
    v3 += strlen(extra);
    if ( !opt_count )
      goto LABEL_13;
    v4 = opt_table_0;
  }
  else
  {
    if ( !opt_count )
    {
      extra = &byte_59398;
      goto LABEL_13;
    }
    v36 = 0;
    v4 = opt_table_0;
    v37 = opt_table_0;
    do
    {
      ++v36;
      if ( (char *(__fastcall *)(const char *))v37->cb == opt_usage_and_exit )
      {
        extra = (const char *)v37->u.carg;
        if ( extra )
        {
          v3 += strlen((const char *)v37->u.carg);
          goto LABEL_4;
        }
      }
      ++v37;
    }
    while ( v36 != opt_count );
    extra = &byte_59398;
  }
LABEL_4:
  v5 = 0;
  v40 = extra;
  do
  {
    while ( 1 )
    {
      v9 = v3 + 6;
      desc = v4->desc;
      if ( v4->type != opt_type::OPT_SUBTABLE )
        break;
      ++v5;
      v3 += 3 + strlen(v4->desc);
      ++v4;
      if ( v5 >= opt_count )
        goto LABEL_12;
    }
    if ( desc != opt_hidden )
    {
      v6 = strlen(v4->names);
      v7 = strlen(desc) + v6 + v9;
      v8 = v7 + 118;
      if ( !v4->show )
        v8 = v7 + 21;
      v3 = v8 + 1;
    }
    ++v5;
    ++v4;
  }
  while ( v5 < opt_count );
LABEL_12:
  extra = v40;
LABEL_13:
  v11 = (char *)malloc(v3);
  v12 = v11;
  ret = v11;
  if ( v11 )
  {
    v13 = sprintf(v11, "Usage: %s", argv0);
    v14 = v12;
    v15 = &v12[v13];
    v16 = v15 + 3;
    strcpy(&v14[v13], " [-");
    sopt = first_sopt((unsigned int *)buf);
    if ( sopt )
    {
      v18 = 0;
      do
      {
        if ( opt_table_0[*(_DWORD *)buf].desc != opt_hidden )
          v16[v18++] = *sopt;
        sopt = next_sopt(sopt, (unsigned int *)buf);
      }
      while ( sopt );
      if ( v18 )
      {
        v15 = &v16[v18 + 1];
        *(_WORD *)&v16[v18] = 93;
      }
    }
    v19 = sprintf(v15, " %s", extra);
    v20 = &v15[v19 + 1];
    v39 = &word_58FE4;
    v21 = opt_count;
    *(_WORD *)&v15[v19] = 10;
    if ( v21 )
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v28 = &opt_table_0[v22];
        v29 = opt_table_0[v22].desc;
        if ( v29 != opt_hidden )
        {
          if ( v28->type == opt_type::OPT_SUBTABLE )
          {
            v20 += sprintf(v20, "%s:\n", v29);
          }
          else
          {
            v30 = sprintf(v20, "%s", v28->names);
            v31 = v30;
            v32 = &v20[v30];
            if ( opt_table_0[v22].type == opt_type::OPT_HASARG )
            {
              v42 = &v20[v30];
              s = (char *)opt_table_0[v22].names;
              v33 = strchr(s, 32);
              v32 = v42;
              if ( !v33 )
              {
                v34 = strchr(s, 61);
                v32 = v42;
                if ( !v34 )
                {
                  v31 += 6;
                  strcpy(v42, " <arg>");
                  v32 = &v20[v31];
                }
              }
            }
            if ( v31 > 0x13 )
              v24 = 1;
            else
              v24 = 20 - v31;
            v25 = v31 + sprintf(v32, "%.*s", v24, "                    ", v39);
            v26 = v25 + sprintf(&v20[v25], "%s", opt_table_0[v22].desc);
            v27 = &v20[v26];
            if ( opt_table_0[v22].show )
            {
              strcpy(&buf[80], "...");
              opt_table_0[v22].show(buf, (const void *)opt_table_0[v22].u.tlen);
              v27 = &v20[v26 + sprintf(&v20[v26], " (default: %s)", buf)];
            }
            *(_WORD *)v27 = *v39;
            v20 = v27 + 1;
          }
        }
        ++v23;
        ++v22;
      }
      while ( opt_count > v23 );
    }
    *v20 = 0;
  }
  return ret;
}
// 4B91E: variable 'v39' is possibly undefined
// 58FE4: using guessed type __int16 word_58FE4;
// 59398: using guessed type char byte_59398;

//----- (0004BCF6) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_4BD38 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 4BCFA: variable 'v2' is possibly undefined

//----- (0004C348) --------------------------------------------------------
// Alternative name is '__aeabi_idiv0'
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (0004C3B8) --------------------------------------------------------
UDItype __fastcall _udivmoddi4(UDItype n, UDItype d, UDItype *rp)
{
  bool v3; // cf
  UDItype v4; // r4
  unsigned int v5; // r12
  unsigned int v6; // r1
  unsigned int v7; // r12
  char v8; // r8
  char v9; // r9
  UDItype v10; // r6
  UDItype v11; // r6
  unsigned int v12; // r2
  int v13; // off

  v3 = n >= d;
  LODWORD(v4) = n;
  if ( n < d )
    LODWORD(n) = 0;
  HIDWORD(v4) = HIDWORD(n);
  if ( !v3 )
  {
    HIDWORD(n) = n;
    goto LABEL_16;
  }
  v5 = __clz(HIDWORD(d));
  if ( HIDWORD(d) )
  {
    v6 = __clz(HIDWORD(n));
    if ( HIDWORD(v4) )
      goto LABEL_7;
    goto LABEL_19;
  }
  v6 = __clz(HIDWORD(n));
  v5 = __clz(d) + 32;
  if ( !HIDWORD(v4) )
LABEL_19:
    v6 = __clz(v4) + 32;
LABEL_7:
  v7 = v5 - v6;
  v8 = v7 - 32;
  v9 = 32 - v7;
  v10 = d << v7;
  if ( v4 >= d << v7 )
  {
    LODWORD(n) = 1 << v7;
    v4 -= v10;
    HIDWORD(n) = (1 << v8) | (1u >> v9);
  }
  else
  {
    n = 0;
  }
  if ( v7 )
  {
    v11 = v10 >> 1;
    v12 = v7;
    do
    {
      while ( v4 >= v11 )
      {
        v4 = 2 * (v4 - v11) + 1;
        if ( !--v12 )
          goto LABEL_15;
      }
      v13 = (v4 + (unsigned int)v4) >> 32;
      LODWORD(v4) = 2 * v4;
      HIDWORD(v4) += v13;
      --v12;
    }
    while ( v12 );
LABEL_15:
    v3 = __CFADD__((_DWORD)n, (_DWORD)v4);
    LODWORD(n) = n + v4;
    LODWORD(v4) = ((unsigned int)v4 >> v7) | (HIDWORD(v4) << v9) | (HIDWORD(v4) >> v8);
    HIDWORD(n) += v3 + HIDWORD(v4);
    HIDWORD(v4) >>= v7;
    n -= v4 << v7;
  }
LABEL_16:
  if ( rp )
    *rp = v4;
  return n;
}

//----- (0004C4D0) --------------------------------------------------------
void __fastcall init(int argc, char **argv, char **envp)
{
  void (__fastcall **v6)(int, char **, char **); // r5
  int v7; // r6
  int i; // r4
  void (__fastcall *v9)(int, char **, char **); // t1

  init_proc();
  v6 = (void (__fastcall **)(int, char **, char **))&_frame_dummy_init_array_entry;
  v7 = &_do_global_dtors_aux_fini_array_entry - &_frame_dummy_init_array_entry;
  if ( v7 )
  {
    for ( i = 0; i != v7; ++i )
    {
      v9 = *v6++;
      v9(argc, argv, envp);
    }
  }
}
// 6BEF0: using guessed type _UNKNOWN *_frame_dummy_init_array_entry;
// 6BEF4: using guessed type _UNKNOWN *_do_global_dtors_aux_fini_array_entry;

//----- (0004C514) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=1172 queued=817 decompiled=817 lumina nreq=0 worse=0 better=0
// ALL OK, 817 function(s) have been successfully decompiled
