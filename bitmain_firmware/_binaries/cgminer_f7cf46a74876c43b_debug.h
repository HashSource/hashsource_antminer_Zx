/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'cgminer_f7cf46a74876c43b_debug'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct thr_info;
struct cgpu_info;
struct _IO_marker;
struct hashtable_bucket;
struct pool;
struct thread_q;
struct device_drv;
struct api_data;
struct UT_hash_table;
struct UT_hash_bucket;
struct bitmain_ZCASH_info;
struct k_item;
struct io_data;
struct __blake2b_param;
struct __blake2b_state;
struct hashtable_pair;
struct k_list;

/* 1 */
struct Elf32_Sym
{
  unsigned __int32 st_name __offset(OFF32,0x110FC);
  unsigned __int32 st_value __off;
  unsigned __int32 st_size;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  unsigned __int16 st_shndx;
};

/* 2 */
struct Elf32_Rel
{
  unsigned __int32 r_offset;
  unsigned __int32 r_info;
};

/* 3 */
union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249
{
  unsigned __int32 d_val;
  unsigned __int32 d_ptr;
};

/* 4 */
struct Elf32_Dyn
{
  __int32 d_tag;
  union Elf32_Dyn::$A263394DDF3EC2D4B1B8448EDD30E249 d_un;
};

/* 5 */
struct Elf32_Verneed
{
  unsigned __int16 vn_version;
  unsigned __int16 vn_cnt;
  unsigned __int32 vn_file __offset(OFF32,0x110FC);
  unsigned __int32 vn_aux;
  unsigned __int32 vn_next;
};

/* 6 */
struct Elf32_Vernaux
{
  unsigned __int32 vna_hash;
  unsigned __int16 vna_flags;
  unsigned __int16 vna_other;
  unsigned __int32 vna_name __offset(OFF32,0x110FC);
  unsigned __int32 vna_next;
};

/* 7 */
typedef void _IO_lock_t;

/* 8 */
struct __va_list
{
  void *__ap;
};

/* 22 */
typedef unsigned int size_t;

/* 9 */
struct stratum_work
{
  char *job_id;
  char *prev_hash;
  unsigned __int8 **merkle_bin;
  char *bbversion;
  char *nbit;
  char *ntime;
  bool clean;
  size_t cb_len;
  size_t header_len;
  int merkles;
  double diff;
};

/* 10 */
enum pool_enable : __int32
{
  pool_enable::POOL_DISABLED = 0x0,
  pool_enable::POOL_ENABLED = 0x1,
  pool_enable::POOL_REJECTING = 0x2,
};

/* 79 */
typedef unsigned __int64 uint64_t;

/* 18 */
typedef unsigned int uint32_t;

/* 107 */
typedef int __time_t;

/* 106 */
typedef int __suseconds_t;

/* 75 */
struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};

/* 93 */
struct UT_hash_handle
{
  UT_hash_table *tbl;
  void *prev;
  void *next;
  UT_hash_handle *hh_prev;
  UT_hash_handle *hh_next;
  void *key;
  unsigned int keylen;
  unsigned int hashv;
};

/* 11 */
struct __attribute__((aligned(8))) work
{
  unsigned __int8 data[128];
  unsigned __int8 midstate[32];
  unsigned __int8 target[32];
  unsigned __int8 hash[32];
  unsigned __int8 equihash_data[1487];
  double device_diff;
  uint64_t share_diff;
  int rolls;
  int drv_rolllimit;
  uint32_t nonce;
  thr_info *thr;
  int thr_id;
  pool *pool;
  timeval tv_staged;
  bool mined;
  bool clone;
  bool cloned;
  int rolltime;
  bool longpoll;
  bool stale;
  bool mandatory;
  bool block;
  bool stratum;
  char *job_id;
  uint64_t nonce2;
  size_t nonce2_len;
  char *ntime;
  double sdiff;
  char *nonce1;
  bool gbt;
  char *coinbase;
  int gbt_txns;
  unsigned int work_block;
  uint32_t id;
  UT_hash_handle hh;
  double work_difficulty;
  int subid;
  bool devflag;
  timeval tv_stamp;
  timeval tv_getwork;
  timeval tv_getwork_reply;
  timeval tv_cloned;
  timeval tv_work_start;
  timeval tv_work_found;
  char getwork_mode;
  unsigned __int8 device_target[32];
};

/* 78 */
typedef unsigned int pthread_t;

/* 210 */
union sem_t
{
  char __size[16];
  int __align;
};

/* 88 */
typedef sem_t cgsem_t;

/* 12 */
struct thr_info
{
  int id;
  int device_thread;
  bool primary_thread;
  pthread_t pth;
  cgsem_t sem;
  thread_q *q;
  cgpu_info *cgpu;
  void *cgpu_data;
  timeval last;
  timeval sick;
  bool pause;
  bool getwork;
  bool work_restart;
  bool work_update;
};

/* 85 */
typedef __int64 int64_t;

/* 71 */
typedef unsigned __int8 uint8_t;

/* 84 */
typedef int proxytypes_t;

/* 104 */
struct __pthread_internal_slist
{
  __pthread_internal_slist *__next;
};

/* 103 */
typedef __pthread_internal_slist __pthread_slist_t;

/* 227 */
union __pthread_mutex_s::$30DFB618E49C377A3D62C6584A4CBE95
{
  int __spins;
  __pthread_slist_t __list;
};

/* 102 */
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;
  int __kind;
  unsigned int __nusers;
  union
  {
    int __spins;
    __pthread_slist_t __list;
  };
};

/* 77 */
union pthread_mutex_t
{
  __pthread_mutex_s __data;
  char __size[24];
  int __align;
};

/* 216 */
struct pthread_rwlock_t::$CCB4DB99CF5CB01AA915A81C32B982CA
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  unsigned __int8 __flags;
  unsigned __int8 __shared;
  unsigned __int8 __pad1;
  unsigned __int8 __pad2;
  int __cur_writer;
};

/* 90 */
union pthread_rwlock_t
{
  pthread_rwlock_t::$CCB4DB99CF5CB01AA915A81C32B982CA __data;
  char __size[32];
  int __align;
};

/* 229 */
struct cglock
{
  pthread_mutex_t mutex;
  pthread_rwlock_t rwlock;
};

/* 76 */
typedef cglock cglock_t;

/* 222 */
struct pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$1948864A517A55083A59240547837AC2::$620CBDB56FB461BCCDEBCCDB2BD438DA
{
  unsigned int __low;
  unsigned int __high;
};

/* 223 */
union pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$1948864A517A55083A59240547837AC2
{
  unsigned __int64 __wseq;
  pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$1948864A517A55083A59240547837AC2::$620CBDB56FB461BCCDEBCCDB2BD438DA __wseq32;
};

/* 224 */
struct pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$6F5B582BCFE66EA44995FCD80445B231::$620CBDB56FB461BCCDEBCCDB2BD438DA
{
  unsigned int __low;
  unsigned int __high;
};

/* 225 */
union pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$6F5B582BCFE66EA44995FCD80445B231
{
  unsigned __int64 __g1_start;
  pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$6F5B582BCFE66EA44995FCD80445B231::$620CBDB56FB461BCCDEBCCDB2BD438DA __g1_start32;
};

/* 226 */
struct pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447
{
  union
  {
    unsigned __int64 __wseq;
    pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$1948864A517A55083A59240547837AC2::$620CBDB56FB461BCCDEBCCDB2BD438DA __wseq32;
  };
  union
  {
    unsigned __int64 __g1_start;
    pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447::$6F5B582BCFE66EA44995FCD80445B231::$620CBDB56FB461BCCDEBCCDB2BD438DA __g1_start32;
  };
  unsigned int __g_refs[2];
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

/* 83 */
union pthread_cond_t
{
  pthread_cond_t::$78BB6D0798FC3C71A17D68FB8971D447 __data;
  char __size[48];
  __int64 __align;
};

/* 82 */
struct list_head
{
  list_head *next;
  list_head *prev;
};

/* 81 */
typedef __time_t time_t;

/* 14 */
struct cgminer_stats
{
  uint32_t getwork_calls;
  timeval getwork_wait;
  timeval getwork_wait_max;
  timeval getwork_wait_min;
};

/* 80 */
struct cgminer_pool_stats
{
  uint32_t getwork_calls;
  uint32_t getwork_attempts;
  timeval getwork_wait;
  timeval getwork_wait_max;
  timeval getwork_wait_min;
  double getwork_wait_rolling;
  bool hadrolltime;
  bool canroll;
  bool hadexpire;
  uint32_t rolltime;
  double min_diff;
  double max_diff;
  double last_diff;
  uint32_t min_diff_count;
  uint32_t max_diff_count;
  uint64_t times_sent;
  uint64_t bytes_sent;
  uint64_t net_bytes_sent;
  uint64_t times_received;
  uint64_t bytes_received;
  uint64_t net_bytes_received;
};

/* 72 */
typedef char CURL;

/* 74 */
struct __attribute__((aligned(8))) pool
{
  int pool_no;
  int prio;
  int64_t accepted;
  int64_t rejected;
  int seq_rejects;
  int seq_getfails;
  int solved;
  int64_t diff1;
  char diff[8];
  int quota;
  int quota_gcd;
  int quota_used;
  int works;
  uint8_t Target[32];
  double diff_accepted;
  double diff_rejected;
  double diff_stale;
  bool submit_fail;
  bool idle;
  bool lagging;
  bool probed;
  pool_enable enabled;
  bool submit_old;
  bool removed;
  bool lp_started;
  bool blocking;
  char *hdr_path;
  char *lp_url;
  unsigned int getwork_requested;
  unsigned int stale_shares;
  unsigned int discarded_work;
  unsigned int getfail_occasions;
  unsigned int remotefail_occasions;
  timeval tv_idle;
  double utility;
  int last_shares;
  int shares;
  char *rpc_req;
  char *rpc_url;
  char *rpc_userpass;
  char *rpc_user;
  char *rpc_pass;
  proxytypes_t rpc_proxytype;
  char *rpc_proxy;
  pthread_mutex_t pool_lock;
  cglock_t data_lock;
  thread_q *submit_q;
  thread_q *getwork_q;
  pthread_t longpoll_thread;
  pthread_t test_thread;
  bool testing;
  int curls;
  pthread_cond_t cr_cond;
  list_head curlring;
  time_t last_share_time;
  double last_share_diff;
  uint64_t best_diff;
  cgminer_stats cgminer_stats;
  cgminer_pool_stats cgminer_pool_stats;
  char prev_block[32];
  char *stratum_url;
  bool extranonce_subscribe;
  char *stratum_port;
  int sock;
  char *sockbuf;
  size_t sockbuf_size;
  char *sockaddr_url;
  char *sockaddr_proxy_url;
  char *sockaddr_proxy_port;
  char *nonce1;
  unsigned __int8 *nonce1bin;
  uint64_t nonce2;
  int n2size;
  char *sessionid;
  bool has_stratum;
  bool stratum_active;
  bool stratum_init;
  bool stratum_notify;
  stratum_work swork;
  pthread_t stratum_sthread;
  pthread_t stratum_rthread;
  pthread_mutex_t stratum_lock;
  thread_q *stratum_q;
  int sshares;
  bool has_gbt;
  cglock_t gbt_lock;
  unsigned __int8 previousblockhash[32];
  unsigned __int8 gbt_target[32];
  char *coinbasetxn;
  char *longpollid;
  char *gbt_workid;
  int gbt_expires;
  uint32_t gbt_version;
  uint32_t curtime;
  uint32_t gbt_bits;
  unsigned __int8 *txn_hashes;
  int gbt_txns;
  int height;
  bool gbt_solo;
  unsigned __int8 merklebin[512];
  int transactions;
  char *txn_data;
  unsigned __int8 scriptsig_base[100];
  unsigned __int8 script_pubkey[28];
  int nValue;
  CURL *gbt_curl;
  bool gbt_curl_inuse;
  size_t n1_len;
  unsigned __int8 *coinbase;
  int coinbase_len;
  int nonce2_offset;
  unsigned __int8 header_bin[128];
  int merkles;
  char prev_hash[68];
  char bbversion[12];
  char nbit[12];
  char ntime[12];
  double sdiff;
  double next_diff;
  int merkle_offset;
  timeval tv_lastwork;
};

/* 95 */
typedef int ptrdiff_t;

/* 94 */
struct UT_hash_table
{
  UT_hash_bucket *buckets;
  unsigned int num_buckets;
  unsigned int log2_num_buckets;
  unsigned int num_items;
  UT_hash_handle *tail;
  ptrdiff_t hho;
  unsigned int ideal_chain_maxlen;
  unsigned int nonideal_items;
  unsigned int ineff_expands;
  unsigned int noexpand;
  uint32_t signature;
};

/* 86 */
struct thread_q
{
  list_head q;
  bool frozen;
  pthread_mutex_t mutex;
  pthread_cond_t cond;
};

/* 16 */
enum dev_enable : __int32
{
  dev_enable::DEV_ENABLED = 0x0,
  dev_enable::DEV_DISABLED = 0x1,
  dev_enable::DEV_RECOVER = 0x2,
};

/* 91 */
enum alive : __int32
{
  alive::LIFE_WELL = 0x0,
  alive::LIFE_SICK = 0x1,
  alive::LIFE_DEAD = 0x2,
  alive::LIFE_NOSTART = 0x3,
  alive::LIFE_INIT = 0x4,
};

/* 15 */
enum dev_reason : __int32
{
  dev_reason::REASON_THREAD_FAIL_INIT = 0x0,
  dev_reason::REASON_THREAD_ZERO_HASH = 0x1,
  dev_reason::REASON_THREAD_FAIL_QUEUE = 0x2,
  dev_reason::REASON_DEV_SICK_IDLE_60 = 0x3,
  dev_reason::REASON_DEV_DEAD_IDLE_600 = 0x4,
  dev_reason::REASON_DEV_NOSTART = 0x5,
  dev_reason::REASON_DEV_OVER_HEAT = 0x6,
  dev_reason::REASON_DEV_THERMAL_CUTOFF = 0x7,
  dev_reason::REASON_DEV_COMMS_ERROR = 0x8,
  dev_reason::REASON_DEV_THROTTLE = 0x9,
};

/* 17 */
struct __attribute__((aligned(8))) cgpu_info
{
  int cgminer_id;
  device_drv *drv;
  int device_id;
  char *name;
  char *device_path;
  void *device_data;
  void *dup_data;
  char *unique_id;
  dev_enable deven;
  int accepted;
  int rejected;
  int hw_errors;
  double rolling;
  double rolling1;
  double rolling5;
  double rolling15;
  double total_mhashes;
  double utility;
  alive status;
  char init[40];
  timeval last_message_tv;
  int threads;
  thr_info **thr;
  int64_t max_hashes;
  const char *kname;
  bool new_work;
  double temp;
  int cutofftemp;
  int64_t diff1;
  double diff_accepted;
  double diff_rejected;
  int last_share_pool;
  time_t last_share_pool_time;
  double last_share_diff;
  time_t last_device_valid_work;
  uint32_t last_nonce;
  time_t device_last_well;
  time_t device_last_not_well;
  dev_reason device_not_well_reason;
  int thread_fail_init_count;
  int thread_zero_hash_count;
  int thread_fail_queue_count;
  int dev_sick_idle_60_count;
  int dev_dead_idle_600_count;
  int dev_nostart_count;
  int dev_over_heat_count;
  int dev_thermal_cutoff_count;
  int dev_comms_error_count;
  int dev_throttle_count;
  cgminer_stats cgminer_stats;
  pthread_rwlock_t qlock;
  work *queued_work;
  work *unqueued_work;
  unsigned int queued_count;
  bool shutdown;
  timeval dev_start_tv;
  int hidiff;
  int lodiff;
  int direction;
};

/* 96 */
struct UT_hash_bucket
{
  UT_hash_handle *hh_head;
  unsigned int count;
  unsigned int expand_mult;
};

/* 92 */
enum drv_driver : __int32
{
  drv_driver::DRIVER_bitforce = 0x0,
  drv_driver::DRIVER_modminer = 0x1,
  drv_driver::DRIVER_bitmain = 0x2,
  drv_driver::DRIVER_bitmain_c5 = 0x3,
  drv_driver::DRIVER_bitmainZCASH = 0x4,
  drv_driver::DRIVER_bmsc = 0x5,
  drv_driver::DRIVER_avalon = 0x6,
  drv_driver::DRIVER_avalon2 = 0x7,
  drv_driver::DRIVER_avalon4 = 0x8,
  drv_driver::DRIVER_bflsc = 0x9,
  drv_driver::DRIVER_bitfury = 0xA,
  drv_driver::DRIVER_blockerupter = 0xB,
  drv_driver::DRIVER_cointerra = 0xC,
  drv_driver::DRIVER_hashfast = 0xD,
  drv_driver::DRIVER_hashratio = 0xE,
  drv_driver::DRIVER_icarus = 0xF,
  drv_driver::DRIVER_klondike = 0x10,
  drv_driver::DRIVER_knc = 0x11,
  drv_driver::DRIVER_bitmineA1 = 0x12,
  drv_driver::DRIVER_drillbit = 0x13,
  drv_driver::DRIVER_bab = 0x14,
  drv_driver::DRIVER_minion = 0x15,
  drv_driver::DRIVER_sp10 = 0x16,
  drv_driver::DRIVER_sp30 = 0x17,
  drv_driver::DRIVER_MAX = 0x18,
};

/* 87 */
struct device_drv
{
  drv_driver drv_id;
  char *dname;
  char *name;
  void (*drv_detect)(bool);
  void (*reinit_device)(cgpu_info *);
  void (*get_statline_before)(char *, size_t, cgpu_info *);
  void (*get_statline)(char *, size_t, cgpu_info *);
  api_data *(*get_api_stats)(cgpu_info *);
  bool (*get_stats)(cgpu_info *);
  void (*identify_device)(cgpu_info *);
  char *(*set_device)(cgpu_info *, char *, char *, char *);
  bool (*thread_prepare)(thr_info *);
  uint64_t (*can_limit_work)(thr_info *);
  bool (*thread_init)(thr_info *);
  bool (*prepare_work)(thr_info *, work *);
  void (*hash_work)(thr_info *);
  int64_t (*scanhash)(thr_info *, work *, int64_t);
  int64_t (*scanwork)(thr_info *);
  bool (*queue_full)(cgpu_info *);
  void (*flush_work)(cgpu_info *);
  void (*update_work)(cgpu_info *);
  void (*hw_error)(thr_info *);
  void (*thread_shutdown)(thr_info *);
  void (*thread_enable)(thr_info *);
  void (*zero_stats)(cgpu_info *);
  bool copy;
  double max_diff;
  double working_diff;
  double min_diff;
};

/* 13 */
enum api_data_type : __int32
{
  api_data_type::API_ESCAPE = 0x0,
  api_data_type::API_STRING = 0x1,
  api_data_type::API_CONST = 0x2,
  api_data_type::API_UINT8 = 0x3,
  api_data_type::API_INT16 = 0x4,
  api_data_type::API_UINT16 = 0x5,
  api_data_type::API_INT = 0x6,
  api_data_type::API_UINT = 0x7,
  api_data_type::API_UINT32 = 0x8,
  api_data_type::API_HEX32 = 0x9,
  api_data_type::API_UINT64 = 0xA,
  api_data_type::API_INT64 = 0xB,
  api_data_type::API_DOUBLE = 0xC,
  api_data_type::API_ELAPSED = 0xD,
  api_data_type::API_BOOL = 0xE,
  api_data_type::API_TIMEVAL = 0xF,
  api_data_type::API_TIME = 0x10,
  api_data_type::API_MHS = 0x11,
  api_data_type::API_MHTOTAL = 0x12,
  api_data_type::API_TEMP = 0x13,
  api_data_type::API_UTILITY = 0x14,
  api_data_type::API_FREQ = 0x15,
  api_data_type::API_VOLTS = 0x16,
  api_data_type::API_HS = 0x17,
  api_data_type::API_DIFF = 0x18,
  api_data_type::API_PERCENT = 0x19,
  api_data_type::API_AVG = 0x1A,
};

/* 89 */
struct api_data
{
  api_data_type type;
  char *name;
  void *data;
  bool data_was_malloc;
  api_data *prev;
  api_data *next;
};

/* 98 */
typedef unsigned __int16 uint16_t;

/* 211 */
union in6_addr::$B80A5568EDCB3DEA112C17957211D170
{
  uint8_t __u6_addr8[16];
  uint16_t __u6_addr16[8];
  uint32_t __u6_addr32[4];
};

/* 19 */
struct in6_addr
{
  in6_addr::$B80A5568EDCB3DEA112C17957211D170 __in6_u;
};

/* 20 */
typedef uint16_t in_port_t;

/* 99 */
typedef uint32_t in_addr_t;

/* 21 */
struct in_addr
{
  in_addr_t s_addr;
};

/* 23 */
typedef unsigned __int64 UDItype;

/* 24 */
typedef unsigned __int8 UQItype;

/* 25 */
enum isa_feature : __int32
{
  isa_feature::isa_nobit = 0x0,
  isa_feature::isa_bit_ARMv3m = 0x1,
  isa_feature::isa_bit_mode26 = 0x2,
  isa_feature::isa_bit_mode32 = 0x3,
  isa_feature::isa_bit_ARMv4 = 0x4,
  isa_feature::isa_bit_ARMv5 = 0x5,
  isa_feature::isa_bit_thumb = 0x6,
  isa_feature::isa_bit_ARMv5e = 0x7,
  isa_feature::isa_bit_xscale = 0x8,
  isa_feature::isa_bit_ARMv6 = 0x9,
  isa_feature::isa_bit_ARMv6k = 0xA,
  isa_feature::isa_bit_thumb2 = 0xB,
  isa_feature::isa_bit_notm = 0xC,
  isa_feature::isa_bit_tdiv = 0xD,
  isa_feature::isa_bit_ARMv7em = 0xE,
  isa_feature::isa_bit_ARMv7 = 0xF,
  isa_feature::isa_bit_adiv = 0x10,
  isa_feature::isa_bit_ARMv8 = 0x11,
  isa_feature::isa_bit_crc32 = 0x12,
  isa_feature::isa_bit_iwmmxt = 0x13,
  isa_feature::isa_bit_iwmmxt2 = 0x14,
  isa_feature::isa_bit_ARMv8_1 = 0x15,
  isa_feature::isa_bit_ARMv8_2 = 0x16,
  isa_feature::isa_bit_cmse = 0x17,
  isa_feature::isa_bit_VFPv2 = 0x18,
  isa_feature::isa_bit_VFPv3 = 0x19,
  isa_feature::isa_bit_VFPv4 = 0x1A,
  isa_feature::isa_bit_FPv5 = 0x1B,
  isa_feature::isa_bit_lpae = 0x1C,
  isa_feature::isa_bit_FP_ARMv8 = 0x1D,
  isa_feature::isa_bit_neon = 0x1E,
  isa_feature::isa_bit_fp16conv = 0x1F,
  isa_feature::isa_bit_fp_dbl = 0x20,
  isa_feature::isa_bit_fp_d32 = 0x21,
  isa_feature::isa_bit_crypto = 0x22,
  isa_feature::isa_bit_fp16 = 0x23,
  isa_feature::isa_quirk_no_volatile_ce = 0x24,
  isa_feature::isa_quirk_ARMv6kz = 0x25,
  isa_feature::isa_quirk_cm3_ldrd = 0x26,
  isa_feature::isa_bit_smallmul = 0x27,
  isa_feature::isa_tune_co_proc = 0x28,
  isa_feature::isa_tune_ldsched = 0x29,
  isa_feature::isa_tune_strong = 0x2A,
  isa_feature::isa_tune_wbuf = 0x2B,
  isa_feature::isa_num_bits = 0x2C,
};

/* 26 */
struct arm_fpu_desc
{
  const char *name;
  isa_feature isa_bits[44];
};

/* 27 */
union _dont_use_tree_here_;

/* 28 */
struct _dont_use_rtx_here_;

/* 29 */
enum arm_cond_code : __int32
{
  arm_cond_code::ARM_EQ = 0x0,
  arm_cond_code::ARM_NE = 0x1,
  arm_cond_code::ARM_CS = 0x2,
  arm_cond_code::ARM_CC = 0x3,
  arm_cond_code::ARM_MI = 0x4,
  arm_cond_code::ARM_PL = 0x5,
  arm_cond_code::ARM_VS = 0x6,
  arm_cond_code::ARM_VC = 0x7,
  arm_cond_code::ARM_HI = 0x8,
  arm_cond_code::ARM_LS = 0x9,
  arm_cond_code::ARM_GE = 0xA,
  arm_cond_code::ARM_LT = 0xB,
  arm_cond_code::ARM_GT = 0xC,
  arm_cond_code::ARM_LE = 0xD,
  arm_cond_code::ARM_AL = 0xE,
  arm_cond_code::ARM_NV = 0xF,
};

/* 30 */
typedef unsigned int hashval_t;

/* 34 */
typedef int __off_t;

/* 35 */
typedef __int64 __quad_t;

/* 33 */
typedef __quad_t __off64_t;

/* 31 */
struct _IO_FILE
{
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  _IO_marker *_markers;
  _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned __int16 _cur_column;
  char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
  int _mode;
  char _unused2[40];
};

/* 32 */
struct _IO_marker
{
  _IO_marker *_next;
  _IO_FILE *_sbuf;
  int _pos;
};

/* 36 */
typedef double DFtype;

/* 37 */
typedef unsigned int USItype;

/* 39 */
enum __bitmask opt_type : __int32
{
  opt_type::OPT_NOARG = 0x1,
  opt_type::OPT_HASARG = 0x2,
  opt_type::OPT_PROCESSARG = 0x4,
  opt_type::OPT_SUBTABLE = 0x8,
  opt_type::OPT_END = 0x10,
};

/* 213 */
union opt_table::$E59A6B864CBE004D1CCF35FB265C4519
{
  const void *carg;
  void *arg;
  size_t tlen;
};

/* 38 */
struct opt_table
{
  const char *names;
  opt_type type;
  char *(*cb)(void *);
  char *(*cb_arg)(const char *, void *);
  void (*show)(char *, const void *);
  opt_table::$E59A6B864CBE004D1CCF35FB265C4519 u;
  const char *desc;
};

/* 40 */
typedef __va_list __gnuc_va_list;

/* 41 */
typedef __gnuc_va_list va_list;

/* 42 */
struct json_error_t
{
  int line;
  int column;
  int position;
  char source[80];
  char text[160];
};

/* 43 */
typedef __int64 json_int_t;

/* 44 */
enum json_type : __int32
{
  JSON_OBJECT = 0x0,
  JSON_ARRAY = 0x1,
  JSON_STRING = 0x2,
  JSON_INTEGER = 0x3,
  JSON_REAL = 0x4,
  JSON_TRUE = 0x5,
  JSON_FALSE = 0x6,
  JSON_NULL = 0x7,
};

/* 53 */
struct json_t
{
  json_type type;
  size_t refcount;
};

/* 52 */
struct hashtable_list
{
  hashtable_list *prev;
  hashtable_list *next;
};

/* 214 */
struct hashtable
{
  size_t size;
  hashtable_bucket *buckets;
  size_t num_buckets;
  hashtable_list list;
};

/* 50 */
typedef hashtable hashtable_t;

/* 45 */
struct json_object_t
{
  json_t json;
  hashtable_t hashtable;
  size_t serial;
  int visited;
};

/* 51 */
struct hashtable_bucket
{
  hashtable_list *first;
  hashtable_list *last;
};

/* 46 */
struct json_array_t
{
  json_t json;
  size_t size;
  size_t entries;
  json_t **table;
  int visited;
};

/* 47 */
struct json_string_t
{
  json_t json;
  char *value;
};

/* 48 */
struct json_integer_t
{
  json_t json;
  json_int_t value;
};

/* 49 */
struct json_real_t
{
  json_t json;
  double value;
};

/* 54 */
typedef int int32_t;

/* 55 */
struct strbuffer_t
{
  char *value;
  size_t length;
  size_t size;
};

/* 56 */
typedef void (*json_free_t)(void *);

/* 57 */
typedef void *(*json_malloc_t)(size_t);

/* 58 */
typedef int (*get_func)(void *);

/* 59 */
struct stream_t
{
  get_func get;
  void *data;
  char buffer[5];
  size_t buffer_pos;
  int state;
  int line;
  int column;
  int last_column;
  size_t position;
};

/* 228 */
union lex_t::$1F7039A2E3C9FAC01F17E2D7967BDDB2
{
  char *string;
  json_int_t integer;
  double real;
};

/* 60 */
struct lex_t
{
  stream_t stream;
  strbuffer_t saved_text;
  int token;
  lex_t::$1F7039A2E3C9FAC01F17E2D7967BDDB2 value;
};

/* 61 */
struct string_data_t
{
  const char *data;
  int pos;
};

/* 62 */
struct buffer_data_t
{
  const char *data;
  size_t len;
  size_t pos;
};

/* 63 */
typedef _IO_FILE FILE;

/* 65 */
typedef size_t (*json_load_callback_t)(void *, size_t, void *);

/* 64 */
struct callback_data_t
{
  char data[1024];
  size_t len;
  size_t pos;
  json_load_callback_t callback;
  void *arg;
};

/* 66 */
typedef hashtable_bucket bucket_t;

/* 67 */
typedef hashtable_list list_t;

/* 68 */
typedef hashtable_pair pair_t;

/* 215 */
struct __attribute__((aligned(4))) hashtable_pair
{
  size_t hash;
  hashtable_list list;
  json_t *value;
  size_t serial;
  char key[1];
};

/* 69 */
typedef int (*json_dump_callback_t)(const char *, size_t, void *);

/* 70 */
struct object_key
{
  size_t serial;
  const char *key;
};

/* 73 */
struct strategies
{
  const char *s;
};

/* 97 */
typedef unsigned __int16 sa_family_t;

/* 100 */
typedef unsigned int __socklen_t;

/* 101 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 105 */
union pthread_attr_t
{
  char __size[36];
  int __align;
};

/* 108 */
struct CSha256
{
  uint32_t state[8];
  uint64_t count;
  uint8_t buffer[64];
};

/* 109 */
typedef __blake2b_param blake2b_param;

/* 208 */
struct __blake2b_param
{
  uint8_t digest_length;
  uint8_t key_length;
  uint8_t fanout;
  uint8_t depth;
  uint32_t leaf_length;
  uint64_t node_offset;
  uint8_t node_depth;
  uint8_t inner_length;
  uint8_t reserved[14];
  uint8_t salt[16];
  uint8_t personal[16];
};

/* 110 */
typedef __blake2b_state blake2b_state;

/* 209 */
struct __attribute__((aligned(4))) __blake2b_state
{
  uint64_t h[8];
  uint64_t t[2];
  uint64_t f[2];
  uint8_t buf[256];
  size_t buflen;
  uint8_t last_node;
};

/* 111 */
typedef unsigned int __uint32_t;

/* 112 */
struct validData
{
  int n;
  int k;
  blake2b_state *digest;
};

/* 113 */
struct sha2_context
{
  uint32_t total[2];
  uint32_t state[8];
  unsigned __int8 buffer[64];
  unsigned __int8 ipad[64];
  unsigned __int8 opad[64];
};

/* 114 */
struct bm1740_work
{
  uint8_t header_55;
  uint8_t header_aa;
  unsigned __int8 test_patten : 1;
  unsigned __int8 reserve : 3;
  unsigned __int8 sno_valid : 1;
  unsigned __int8 type : 3;
  uint8_t workid;
  uint8_t work[140];
  uint16_t crc16;
};

/* 115 */
struct __attribute__((aligned(4))) bitmian_ZCASH_info_with_index
{
  bitmain_ZCASH_info *info;
  uint8_t chain_index;
};

/* 125 */
struct init_config
{
  uint8_t token_type;
  uint8_t version;
  uint16_t length;
  uint32_t baud;
  unsigned __int8 reset : 1;
  unsigned __int8 fan_eft : 1;
  unsigned __int8 timeout_eft : 1;
  unsigned __int8 frequency_eft : 1;
  unsigned __int8 voltage_eft : 1;
  unsigned __int8 chain_check_time_eft : 1;
  unsigned __int8 chip_config_eft : 1;
  unsigned __int8 hw_error_eft : 1;
  unsigned __int8 beeper_ctrl : 1;
  unsigned __int8 temp_ctrl : 1;
  unsigned __int8 chain_freq_eft : 1;
  unsigned __int8 auto_read_temp : 1;
  unsigned __int8 reserved1 : 4;
  uint8_t reserved2[2];
  uint8_t chain_num;
  uint8_t asic_num;
  uint8_t fan_pwm_percent;
  uint8_t temperature;
  uint16_t frequency;
  uint8_t voltage[2];
  uint8_t chain_check_time_integer;
  uint8_t chain_check_time_fractions;
  uint8_t timeout_data_integer;
  uint8_t timeout_data_fractions;
  uint32_t reg_data;
  uint8_t chip_address;
  uint8_t reg_address;
  uint16_t crc;
};

/* 124 */
struct bitmain_ZCASH_info
{
  cglock_t update_lock;
  uint8_t data_type;
  uint8_t version;
  uint16_t length;
  unsigned __int8 chip_value_eft : 1;
  unsigned __int8 reserved1 : 7;
  uint8_t chain_num;
  uint16_t reserved2;
  uint8_t fan_num;
  uint8_t temp_num;
  uint8_t reserved3[2];
  uint32_t fan_exist;
  uint32_t temp_exist;
  uint16_t diff;
  uint16_t reserved4;
  uint32_t reg_value;
  uint8_t chain_asic_num[4];
  uint8_t temp[4];
  uint8_t chain_status[4];
  uint8_t fan_speed_value[6];
  uint16_t freq[4];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t i2c_fd;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t timepoint;
  __attribute__((packed)) __attribute__((aligned(1))) work *work_queue[128];
  __attribute__((packed)) __attribute__((aligned(1))) thr_info *thr;
  __attribute__((packed)) __attribute__((aligned(1))) thr_info uart_tx_t[4];
  __attribute__((packed)) __attribute__((aligned(1))) thr_info uart_rx_t[4];
  __attribute__((packed)) __attribute__((aligned(1))) pthread_mutex_t lock;
  __attribute__((packed)) __attribute__((aligned(1))) init_config ZCASH_config;
  uint16_t crc;
};

/* 116 */
struct nonce_rb_format
{
  uint8_t Nonce[1344];
  uint8_t chip_addr;
  uint8_t work_id;
  uint8_t nonce_id;
  uint8_t diff0;
  uint8_t sha256[4];
  uint8_t chip_nonce[4];
  uint8_t chain_id;
};

/* 117 */
struct pmonitor_respond
{
  uint8_t header_aa;
  uint8_t header_55;
  uint8_t format;
  uint8_t pm_data[4];
  uint8_t chip_addr;
  unsigned __int8 crc5 : 5;
  unsigned __int8 reserve : 3;
};

/* 118 */
struct reg_respond
{
  uint8_t header_aa;
  uint8_t header_55;
  uint8_t reg_addr;
  uint8_t reg_data[4];
  uint8_t chip_addr;
  unsigned __int8 crc5 : 5;
  unsigned __int8 reserve : 3;
};

/* 119 */
struct dev_info
{
  uint32_t chainid;
};

/* 120 */
struct freq_pll_str
{
  unsigned int freq;
  unsigned int fildiv1;
  unsigned int fildiv2;
  unsigned int vilpll;
};

/* 121 */
struct pollfd
{
  int fd;
  __int16 events;
  __int16 revents;
};

/* 122 */
typedef char int8_t;

/* 123 */
typedef __int16 int16_t;

/* 126 */
struct reg_rb_format
{
  uint8_t reg_addr;
  uint8_t reg_data[4];
  uint8_t chip_addr;
  uint8_t chain_id;
};

/* 127 */
struct bm1740_txn_data
{
  unsigned __int32 txn_zero : 1;
  unsigned __int32 txn_shalow : 1;
  unsigned __int32 reaseve : 30;
};

/* 128 */
struct bm1740_start_nonce_offset
{
  uint32_t sno;
};

/* 129 */
struct bm1744_nonce_shift
{
  unsigned __int32 reserve : 27;
  unsigned __int32 shift : 5;
};

/* 130 */
struct bm1740_analog_mux_control
{
  unsigned __int32 diode_vdd_mux_sel : 3;
  unsigned __int32 reserve : 29;
};

/* 131 */
struct bm1740_pmonitor_ctrl
{
  unsigned __int32 coreid : 6;
  unsigned __int32 vtsel : 2;
  unsigned __int32 reserve : 24;
};

/* 132 */
struct bm1740_time_out
{
  unsigned __int32 timeout : 16;
  unsigned __int32 nonce_tx_timeout : 16;
};

/* 133 */
struct bm1740_chip_status
{
  unsigned __int32 crc5err : 8;
  unsigned __int32 crc16err : 8;
  unsigned __int32 ram_empty : 4;
  unsigned __int32 reserve : 11;
  unsigned __int32 clrerr : 1;
};

/* 134 */
struct bm1740_io_drive_strength
{
  unsigned __int32 co_ds : 4;
  unsigned __int32 bo_ds : 4;
  unsigned __int32 nrsto_ds : 4;
  unsigned __int32 clko_ds : 4;
  unsigned __int32 ro_ds : 4;
  unsigned __int32 tf_df : 4;
  unsigned __int32 rf_ds : 4;
  unsigned __int32 reserve : 4;
};

/* 135 */
struct bm1740_core_timeout
{
  uint32_t core_timeout;
};

/* 136 */
struct bm1740_nonce_tx_ok
{
  unsigned __int32 nonce_txok : 16;
  unsigned __int32 nid : 8;
  unsigned __int32 reserve : 7;
  unsigned __int32 txok_en : 1;
};

/* 137 */
struct bm1740_general_i2c_command
{
  unsigned __int32 data : 8;
  unsigned __int32 regaddr : 8;
  unsigned __int32 rwctrl : 1;
  unsigned __int32 devaddr : 7;
  unsigned __int32 ravalid : 1;
  unsigned __int32 reserve : 5;
  unsigned __int32 rwfail : 1;
  unsigned __int32 busy : 1;
};

/* 138 */
struct bm1740_misc_control
{
  unsigned __int32 hashrate_tws : 2;
  unsigned __int32 auto_rst_bp : 1;
  unsigned __int32 reserve4 : 2;
  unsigned __int32 tfs : 2;
  unsigned __int32 reserve3 : 1;
  unsigned __int32 bt8d : 5;
  unsigned __int32 invclko : 1;
  unsigned __int32 rfs : 1;
  unsigned __int32 reservex : 1;
  unsigned __int32 reserve2 : 8;
  unsigned __int32 addrpin : 2;
  unsigned __int32 latch_ci : 1;
  unsigned __int32 reserve1 : 5;
};

/* 139 */
struct bm1740_ticket_mask
{
  unsigned __int32 ticket_mask : 8;
  unsigned __int32 reserve : 24;
};

/* 140 */
struct bm1740_pll_parameter
{
  unsigned __int32 postdiv2 : 3;
  unsigned __int32 reserve4 : 1;
  unsigned __int32 postdiv1 : 3;
  unsigned __int32 reserve3 : 1;
  unsigned __int32 refdiv : 6;
  unsigned __int32 reserve2 : 2;
  unsigned __int32 fbdiv : 12;
  unsigned __int32 reserve1 : 3;
  unsigned __int32 locked : 1;
};

/* 141 */
struct bm1740_hash_rate
{
  unsigned __int32 hash_rate : 31;
  unsigned __int32 hash_rate_flag : 1;
};

/* 142 */
struct bm1740_chip_addr
{
  unsigned __int32 chip_addr : 8;
  unsigned __int32 reserve2 : 5;
  unsigned __int32 reserve1 : 3;
  unsigned __int32 chip_name : 16;
};

/* 143 */
struct sockaddr_x25;

/* 144 */
struct sockaddr_un;

/* 145 */
struct sockaddr_ns;

/* 146 */
struct sockaddr_iso;

/* 147 */
struct sockaddr_ipx;

/* 148 */
struct sockaddr_inarp;

/* 149 */
struct sockaddr_in6
{
  sa_family_t sin6_family;
  in_port_t sin6_port;
  uint32_t sin6_flowinfo;
  in6_addr sin6_addr;
  uint32_t sin6_scope_id;
};

/* 150 */
struct sockaddr_in
{
  sa_family_t sin_family;
  in_port_t sin_port;
  in_addr sin_addr;
  unsigned __int8 sin_zero[8];
};

/* 151 */
struct sockaddr_eon;

/* 152 */
struct sockaddr_dl;

/* 153 */
struct sockaddr_ax25;

/* 154 */
struct sockaddr_at;

/* 155 */
struct sockaddr
{
  sa_family_t sa_family;
  char sa_data[14];
};

/* 165 */
typedef int __syscall_slong_t;

/* 156 */
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};

/* 157 */
typedef int __blkcnt_t;

/* 158 */
typedef int __blksize_t;

/* 166 */
typedef unsigned __int64 __u_quad_t;

/* 159 */
typedef __u_quad_t __dev_t;

/* 160 */
typedef unsigned int __gid_t;

/* 161 */
typedef unsigned int __uid_t;

/* 162 */
typedef unsigned int __nlink_t;

/* 163 */
typedef unsigned int __mode_t;

/* 164 */
typedef unsigned int __ino_t;

/* 167 */
typedef k_item K_ITEM;

/* 170 */
struct k_item
{
  const char *name;
  k_item *prev;
  k_item *next;
  void *data;
};

/* 169 */
typedef k_list K_LIST;

/* 168 */
struct dupdata
{
  int timelimit;
  K_LIST *nfree_list;
  K_LIST *nonce_list;
  uint64_t checked;
  uint64_t dups;
};

/* 220 */
struct k_list
{
  const char *name;
  bool is_store;
  cglock_t *lock;
  k_item *head;
  k_item *tail;
  size_t siz;
  int total;
  int count;
  int count_up;
  int allocate;
  int limit;
  bool do_tail;
  int item_mem_count;
  void **item_memory;
  int data_mem_count;
  void **data_memory;
};

/* 171 */
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  int tm_gmtoff;
  const char *tm_zone;
};

/* 185 */
typedef int __fd_mask;

/* 172 */
struct fd_set
{
  __fd_mask fds_bits[32];
};

/* 173 */
struct sockaddr_storage
{
  sa_family_t ss_family;
  char __ss_padding[122];
  unsigned int __ss_align;
};

/* 174 */
struct __attribute__((aligned(4))) CMDS
{
  char *name;
  void (*func)(io_data *, int, char *, bool, char);
  bool iswritemode;
  bool joinable;
};

/* 176 */
struct __attribute__((aligned(4))) io_data
{
  size_t siz;
  char *ptr;
  char *cur;
  bool sock;
  bool close;
};

/* 175 */
struct io_list
{
  io_data *io_data;
  io_list *prev;
  io_list *next;
};

/* 177 */
struct __attribute__((aligned(4))) IPACCESS
{
  in6_addr ip;
  in6_addr mask;
  char group;
};

/* 178 */
struct APIGROUPS
{
  char *commands;
};

/* 181 */
enum code_severity : __int32
{
  code_severity::SEVERITY_ERR = 0x0,
  code_severity::SEVERITY_WARN = 0x1,
  code_severity::SEVERITY_INFO = 0x2,
  code_severity::SEVERITY_SUCC = 0x3,
  code_severity::SEVERITY_FAIL = 0x4,
};

/* 180 */
enum code_parameters : __int32
{
  code_parameters::PARAM_PGA = 0x0,
  code_parameters::PARAM_ASC = 0x1,
  code_parameters::PARAM_PID = 0x2,
  code_parameters::PARAM_PGAMAX = 0x3,
  code_parameters::PARAM_ASCMAX = 0x4,
  code_parameters::PARAM_PMAX = 0x5,
  code_parameters::PARAM_POOLMAX = 0x6,
  code_parameters::PARAM_DMAX = 0x7,
  code_parameters::PARAM_CMD = 0x8,
  code_parameters::PARAM_POOL = 0x9,
  code_parameters::PARAM_STR = 0xA,
  code_parameters::PARAM_BOTH = 0xB,
  code_parameters::PARAM_BOOL = 0xC,
  code_parameters::PARAM_SET = 0xD,
  code_parameters::PARAM_INT = 0xE,
  code_parameters::PARAM_NONE = 0xF,
};

/* 179 */
struct CODES
{
  const code_severity severity;
  const int code;
  const code_parameters params;
  const char *description;
};

/* 183 */
typedef __socklen_t socklen_t;

/* 182 */
struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  sockaddr *ai_addr;
  char *ai_canonname;
  addrinfo *ai_next;
};

/* 184 */
typedef int __jmp_buf[64];

/* 186 */
typedef int __ssize_t;

/* 187 */
struct sha256_ctx
{
  unsigned int tot_len;
  unsigned int len;
  unsigned __int8 block[128];
  uint32_t h[8];
};

/* 188 */
struct tq_ent
{
  void *data;
  list_head q_node;
};

/* 189 */
typedef timespec cgtimer_t;

/* 190 */
typedef __ssize_t ssize_t;

/* 191 */
struct cg_completion
{
  cgsem_t cgsem;
  void (*fn)(void *);
  void *fnarg;
};

/* 192 */
typedef unsigned __int64 __uint64_t;

/* 193 */
enum pool_strategy : __int32
{
  pool_strategy::POOL_FAILOVER = 0x0,
  pool_strategy::POOL_ROUNDROBIN = 0x1,
  pool_strategy::POOL_ROTATE = 0x2,
  pool_strategy::POOL_LOADBALANCE = 0x3,
  pool_strategy::POOL_BALANCE = 0x4,
};

/* 194 */
struct schedtime
{
  bool enable;
  tm tm;
};

/* 195 */
struct curl_ent
{
  CURL *curl;
  list_head node;
  timeval tv;
};

/* 196 */
struct _cgpu_devid_counter
{
  char name[4];
  int lastid;
  UT_hash_handle hh;
};

/* 197 */
struct JE
{
  char *buf;
  JE *next;
};

/* 198 */
struct stratum_share
{
  UT_hash_handle hh;
  bool block;
  work *work;
  int id;
  time_t sshare_time;
  time_t sshare_sent;
};

/* 199 */
struct block
{
  char hash[68];
  UT_hash_handle hh;
  int block_no;
};

/* 200 */
struct benchfile_layout
{
  int length;
  char *name;
};

/* 201 */
struct __sigset_t
{
  unsigned int __val[32];
};

/* 205 */
typedef int __pid_t;

/* 281 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$DDF278A5B88F81FEC3CBEE828E282CB3
{
  __pid_t si_pid;
  __uid_t si_uid;
};

/* 207 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 206 */
typedef sigval sigval_t;

/* 282 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$F43D85AC31CEBD8CC07B08111ABDF065
{
  int si_tid;
  int si_overrun;
  sigval_t si_sigval;
};

/* 283 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$002955E8B5DE3B92E30DFEF7AB65BFE2
{
  __pid_t si_pid;
  __uid_t si_uid;
  sigval_t si_sigval;
};

/* 204 */
typedef int __clock_t;

/* 284 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$353EAF26536A4016665766004ADC0BD6
{
  __pid_t si_pid;
  __uid_t si_uid;
  int si_status;
  __clock_t si_utime;
  __clock_t si_stime;
};

/* 285 */
struct __attribute__((aligned(4))) siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$E8B6F0BBDFDEB0F2D2A2272DA024FD9B
{
  void *si_addr;
  __int16 si_addr_lsb;
};

/* 286 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$534EC22A0813C1325C3E7D3262B5A8D3
{
  int si_band;
  int si_fd;
};

/* 287 */
struct siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$4B29161E04CAD4BCDD788B201A5E8E5E
{
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
};

/* 288 */
union siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F
{
  int _pad[29];
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$DDF278A5B88F81FEC3CBEE828E282CB3 _kill;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$F43D85AC31CEBD8CC07B08111ABDF065 _timer;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$002955E8B5DE3B92E30DFEF7AB65BFE2 _rt;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$353EAF26536A4016665766004ADC0BD6 _sigchld;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$E8B6F0BBDFDEB0F2D2A2272DA024FD9B _sigfault;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$534EC22A0813C1325C3E7D3262B5A8D3 _sigpoll;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F::$4B29161E04CAD4BCDD788B201A5E8E5E _sigsys;
};

/* 202 */
struct siginfo_t
{
  int si_signo;
  int si_errno;
  int si_code;
  siginfo_t::$A4FFDD2EE5DC83CCA6B0715BFE0C849F _sifields;
};

/* 203 */
typedef void (*__sighandler_t)(int);

/* 212 */
struct sbitem
{
  char *buf;
  size_t siz;
  size_t tot;
};

/* 218 */
struct _fpga_bt8d_t::$064BE3777DB068CE02E3BEEC5C09C92D
{
  unsigned __int32 bt8d_c0 : 6;
  unsigned __int32 reserved_0 : 2;
  unsigned __int32 bt8d_c1 : 6;
  unsigned __int32 reserved_1 : 2;
  unsigned __int32 bt8d_c2 : 6;
  unsigned __int32 reserved_2 : 2;
  unsigned __int32 bt8d_c3 : 6;
  unsigned __int32 reserved_3 : 2;
};

/* 217 */
union _fpga_bt8d_t
{
  _fpga_bt8d_t::$064BE3777DB068CE02E3BEEC5C09C92D u;
  uint32_t v;
};

/* 219 */
struct nitem
{
  uint32_t work_id;
  uint32_t nonce;
  timeval when;
};

/* 221 */
struct SHA256Context
{
  uint32_t state[8];
  uint32_t buf[16];
};

/* 230 */
struct complex_double
{
  double real;
  double imag;
};

/* 231 */
struct complex_float
{
  float real;
  float imag;
};

/* 232 */
enum arm_pcs : __int32
{
  arm_pcs::ARM_PCS_AAPCS = 0x0,
  arm_pcs::ARM_PCS_AAPCS_VFP = 0x1,
  arm_pcs::ARM_PCS_AAPCS_IWMMXT = 0x2,
  arm_pcs::ARM_PCS_AAPCS_LOCAL = 0x3,
  arm_pcs::ARM_PCS_ATPCS = 0x4,
  arm_pcs::ARM_PCS_APCS = 0x5,
  arm_pcs::ARM_PCS_UNKNOWN = 0x6,
};

/* 233 */
enum base_architecture : __int32
{
  base_architecture::BASE_ARCH_0 = 0x0,
  base_architecture::BASE_ARCH_2 = 0x2,
  base_architecture::BASE_ARCH_3 = 0x3,
  base_architecture::BASE_ARCH_3M = 0x3,
  base_architecture::BASE_ARCH_4 = 0x4,
  base_architecture::BASE_ARCH_4T = 0x4,
  base_architecture::BASE_ARCH_5 = 0x5,
  base_architecture::BASE_ARCH_5E = 0x5,
  base_architecture::BASE_ARCH_5T = 0x5,
  base_architecture::BASE_ARCH_5TE = 0x5,
  base_architecture::BASE_ARCH_5TEJ = 0x5,
  base_architecture::BASE_ARCH_6 = 0x6,
  base_architecture::BASE_ARCH_6J = 0x6,
  base_architecture::BASE_ARCH_6KZ = 0x6,
  base_architecture::BASE_ARCH_6K = 0x6,
  base_architecture::BASE_ARCH_6T2 = 0x6,
  base_architecture::BASE_ARCH_6M = 0x6,
  base_architecture::BASE_ARCH_6Z = 0x6,
  base_architecture::BASE_ARCH_7 = 0x7,
  base_architecture::BASE_ARCH_7A = 0x7,
  base_architecture::BASE_ARCH_7R = 0x7,
  base_architecture::BASE_ARCH_7M = 0x7,
  base_architecture::BASE_ARCH_7EM = 0x7,
  base_architecture::BASE_ARCH_8A = 0x8,
  base_architecture::BASE_ARCH_8M_BASE = 0x8,
  base_architecture::BASE_ARCH_8M_MAIN = 0x8,
};

/* 234 */
typedef arm_cond_code arm_cc;

/* 235 */
enum processor_type : __int32
{
  processor_type::TARGET_CPU_arm2 = 0x0,
  processor_type::TARGET_CPU_arm250 = 0x1,
  processor_type::TARGET_CPU_arm3 = 0x2,
  processor_type::TARGET_CPU_arm6 = 0x3,
  processor_type::TARGET_CPU_arm60 = 0x4,
  processor_type::TARGET_CPU_arm600 = 0x5,
  processor_type::TARGET_CPU_arm610 = 0x6,
  processor_type::TARGET_CPU_arm620 = 0x7,
  processor_type::TARGET_CPU_arm7 = 0x8,
  processor_type::TARGET_CPU_arm7d = 0x9,
  processor_type::TARGET_CPU_arm7di = 0xA,
  processor_type::TARGET_CPU_arm70 = 0xB,
  processor_type::TARGET_CPU_arm700 = 0xC,
  processor_type::TARGET_CPU_arm700i = 0xD,
  processor_type::TARGET_CPU_arm710 = 0xE,
  processor_type::TARGET_CPU_arm720 = 0xF,
  processor_type::TARGET_CPU_arm710c = 0x10,
  processor_type::TARGET_CPU_arm7100 = 0x11,
  processor_type::TARGET_CPU_arm7500 = 0x12,
  processor_type::TARGET_CPU_arm7500fe = 0x13,
  processor_type::TARGET_CPU_arm7m = 0x14,
  processor_type::TARGET_CPU_arm7dm = 0x15,
  processor_type::TARGET_CPU_arm7dmi = 0x16,
  processor_type::TARGET_CPU_arm8 = 0x17,
  processor_type::TARGET_CPU_arm810 = 0x18,
  processor_type::TARGET_CPU_strongarm = 0x19,
  processor_type::TARGET_CPU_strongarm110 = 0x1A,
  processor_type::TARGET_CPU_strongarm1100 = 0x1B,
  processor_type::TARGET_CPU_strongarm1110 = 0x1C,
  processor_type::TARGET_CPU_fa526 = 0x1D,
  processor_type::TARGET_CPU_fa626 = 0x1E,
  processor_type::TARGET_CPU_arm7tdmi = 0x1F,
  processor_type::TARGET_CPU_arm7tdmis = 0x20,
  processor_type::TARGET_CPU_arm710t = 0x21,
  processor_type::TARGET_CPU_arm720t = 0x22,
  processor_type::TARGET_CPU_arm740t = 0x23,
  processor_type::TARGET_CPU_arm9 = 0x24,
  processor_type::TARGET_CPU_arm9tdmi = 0x25,
  processor_type::TARGET_CPU_arm920 = 0x26,
  processor_type::TARGET_CPU_arm920t = 0x27,
  processor_type::TARGET_CPU_arm922t = 0x28,
  processor_type::TARGET_CPU_arm940t = 0x29,
  processor_type::TARGET_CPU_ep9312 = 0x2A,
  processor_type::TARGET_CPU_arm10tdmi = 0x2B,
  processor_type::TARGET_CPU_arm1020t = 0x2C,
  processor_type::TARGET_CPU_arm9e = 0x2D,
  processor_type::TARGET_CPU_arm946es = 0x2E,
  processor_type::TARGET_CPU_arm966es = 0x2F,
  processor_type::TARGET_CPU_arm968es = 0x30,
  processor_type::TARGET_CPU_arm10e = 0x31,
  processor_type::TARGET_CPU_arm1020e = 0x32,
  processor_type::TARGET_CPU_arm1022e = 0x33,
  processor_type::TARGET_CPU_xscale = 0x34,
  processor_type::TARGET_CPU_iwmmxt = 0x35,
  processor_type::TARGET_CPU_iwmmxt2 = 0x36,
  processor_type::TARGET_CPU_fa606te = 0x37,
  processor_type::TARGET_CPU_fa626te = 0x38,
  processor_type::TARGET_CPU_fmp626 = 0x39,
  processor_type::TARGET_CPU_fa726te = 0x3A,
  processor_type::TARGET_CPU_arm926ejs = 0x3B,
  processor_type::TARGET_CPU_arm1026ejs = 0x3C,
  processor_type::TARGET_CPU_arm1136js = 0x3D,
  processor_type::TARGET_CPU_arm1136jfs = 0x3E,
  processor_type::TARGET_CPU_arm1176jzs = 0x3F,
  processor_type::TARGET_CPU_arm1176jzfs = 0x40,
  processor_type::TARGET_CPU_mpcorenovfp = 0x41,
  processor_type::TARGET_CPU_mpcore = 0x42,
  processor_type::TARGET_CPU_arm1156t2s = 0x43,
  processor_type::TARGET_CPU_arm1156t2fs = 0x44,
  processor_type::TARGET_CPU_cortexm1 = 0x45,
  processor_type::TARGET_CPU_cortexm0 = 0x46,
  processor_type::TARGET_CPU_cortexm0plus = 0x47,
  processor_type::TARGET_CPU_cortexm1smallmultiply = 0x48,
  processor_type::TARGET_CPU_cortexm0smallmultiply = 0x49,
  processor_type::TARGET_CPU_cortexm0plussmallmultiply = 0x4A,
  processor_type::TARGET_CPU_genericv7a = 0x4B,
  processor_type::TARGET_CPU_cortexa5 = 0x4C,
  processor_type::TARGET_CPU_cortexa7 = 0x4D,
  processor_type::TARGET_CPU_cortexa8 = 0x4E,
  processor_type::TARGET_CPU_cortexa9 = 0x4F,
  processor_type::TARGET_CPU_cortexa12 = 0x50,
  processor_type::TARGET_CPU_cortexa15 = 0x51,
  processor_type::TARGET_CPU_cortexa17 = 0x52,
  processor_type::TARGET_CPU_cortexr4 = 0x53,
  processor_type::TARGET_CPU_cortexr4f = 0x54,
  processor_type::TARGET_CPU_cortexr5 = 0x55,
  processor_type::TARGET_CPU_cortexr7 = 0x56,
  processor_type::TARGET_CPU_cortexr8 = 0x57,
  processor_type::TARGET_CPU_cortexm7 = 0x58,
  processor_type::TARGET_CPU_cortexm4 = 0x59,
  processor_type::TARGET_CPU_cortexm3 = 0x5A,
  processor_type::TARGET_CPU_marvell_pj4 = 0x5B,
  processor_type::TARGET_CPU_cortexa15cortexa7 = 0x5C,
  processor_type::TARGET_CPU_cortexa17cortexa7 = 0x5D,
  processor_type::TARGET_CPU_cortexa32 = 0x5E,
  processor_type::TARGET_CPU_cortexa35 = 0x5F,
  processor_type::TARGET_CPU_cortexa53 = 0x60,
  processor_type::TARGET_CPU_cortexa57 = 0x61,
  processor_type::TARGET_CPU_cortexa72 = 0x62,
  processor_type::TARGET_CPU_cortexa73 = 0x63,
  processor_type::TARGET_CPU_exynosm1 = 0x64,
  processor_type::TARGET_CPU_xgene1 = 0x65,
  processor_type::TARGET_CPU_cortexa57cortexa53 = 0x66,
  processor_type::TARGET_CPU_cortexa72cortexa53 = 0x67,
  processor_type::TARGET_CPU_cortexa73cortexa35 = 0x68,
  processor_type::TARGET_CPU_cortexa73cortexa53 = 0x69,
  processor_type::TARGET_CPU_cortexm23 = 0x6A,
  processor_type::TARGET_CPU_cortexm33 = 0x6B,
  processor_type::TARGET_CPU_arm_none = 0x6C,
};

/* 236 */
typedef int (*htab_eq)(const void *, const void *);

/* 237 */
typedef hashval_t (*htab_hash)(const void *);

/* 238 */
struct _IO_FILE_plus;

/* 239 */
typedef __int64 DItype;

/* 240 */
enum _LIB_VERSION_TYPE : __int32
{
  _IEEE_ = 0xFFFFFFFF,
  _SVID_ = 0x0,
  _XOPEN_ = 0x1,
  _POSIX_ = 0x2,
  _ISOC_ = 0x3,
};

/* 241 */
typedef _IO_marker _IO_marker_0;

/* 242 */
typedef UT_hash_table UT_hash_table_0;

/* 243 */
enum __socket_type : __int32
{
  __socket_type::SOCK_STREAM = 0x1,
  __socket_type::SOCK_DGRAM = 0x2,
  __socket_type::SOCK_RAW = 0x3,
  __socket_type::SOCK_RDM = 0x4,
  __socket_type::SOCK_SEQPACKET = 0x5,
  __socket_type::SOCK_DCCP = 0x6,
  __socket_type::SOCK_PACKET = 0xA,
  __socket_type::SOCK_CLOEXEC = 0x80000,
  __socket_type::SOCK_NONBLOCK = 0x800,
};

/* 244 */
enum blake2b_constant : __int32
{
  blake2b_constant::BLAKE2B_BLOCKBYTES = 0x80,
  blake2b_constant::BLAKE2B_OUTBYTES = 0x40,
  blake2b_constant::BLAKE2B_KEYBYTES = 0x40,
  blake2b_constant::BLAKE2B_SALTBYTES = 0x10,
  blake2b_constant::BLAKE2B_PERSONALBYTES = 0x10,
};

/* 245 */
enum blake2s_constant : __int32
{
  blake2s_constant::BLAKE2S_BLOCKBYTES = 0x40,
  blake2s_constant::BLAKE2S_OUTBYTES = 0x20,
  blake2s_constant::BLAKE2S_KEYBYTES = 0x20,
  blake2s_constant::BLAKE2S_SALTBYTES = 0x8,
  blake2s_constant::BLAKE2S_PERSONALBYTES = 0x8,
};

/* 246 */
typedef uint32_t eh_index;

/* 247 */
enum I2C_TYPE : __int32
{
  I2C_TYPE::LOCAL = 0x0,
  I2C_TYPE::REMOTE = 0x1,
  I2C_TYPE::OFFSET = 0x2,
  I2C_TYPE::ID = 0x3,
};

/* 248 */
typedef validData validData_0;

/* 249 */
struct scan_freq_status
{
  int scan_freq_store_pos;
  uint32_t each_asic_invalid_nonce_each_2min[4][3];
  uint32_t each_asic_valid_nonce_each_2min[4][3];
  uint32_t each_asic_ox_status[4][3];
  uint32_t each_asic_min_freq[4][3];
  uint32_t each_asic_max_freq[4][3];
  uint32_t each_asic_freq[4][3];
  uint32_t is_asic_scan_freq_done[4][3];
};

/* 250 */
typedef _fpga_bt8d_t fpga_bt8d_t;

/* 251 */
struct __attribute__((aligned(4))) all_parameters
{
  uint32_t pwm_value;
  uint32_t duty_ns;
  uint8_t chain_exist[4];
  uint8_t chain_asic_in_full[4];
  uint32_t timeout;
  uint32_t fan_exist_map;
  uint32_t temp_sensor_map;
  uint32_t nonce_error;
  uint32_t chain_asic_exist[4][3];
  uint32_t chain_asic_status[4][3];
  int16_t chain_asic_temp[4][3][4];
  char whether_read_out_temp[4][4];
  int8_t chain_asic_iic[3];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t chain_hw[4];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t chain_asic_nonce[4][3];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t chain_asic_invalid_nonce[4][3];
  char chain_asic_status_string[4][19];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t total_nonce_num;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t fan_fd[6];
  uint8_t fan_exist[6];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t fan_event_count[6];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t fan_speed_value[6];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t temp[4];
  uint8_t chain_asic_num[4];
  uint8_t check_bit;
  uint8_t pwm_percent;
  uint8_t chain_num;
  uint8_t fan_num;
  uint8_t temp_num;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t fan_speed_top1;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t fan_speed_low1;
  __attribute__((packed)) __attribute__((aligned(1))) int32_t temp_top1;
  __attribute__((packed)) __attribute__((aligned(1))) int32_t temp_chip_top;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t temp_top_i[4];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t temp_top1_last;
  uint8_t corenum;
  uint8_t addrInterval;
  uint8_t max_asic_num_in_one_chain;
  uint8_t baud;
  uint8_t diff;
  uint8_t fan_eft;
  uint8_t fan_pwm;
  __attribute__((packed)) __attribute__((aligned(1))) uint16_t frequency;
  char frequency_t[10];
  __attribute__((packed)) __attribute__((aligned(1))) uint16_t freq[4];
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t i2c_fd;
  __attribute__((packed)) __attribute__((aligned(1))) pollfd pfd[6];
  __attribute__((packed)) __attribute__((aligned(1))) int max_local_temp[4];
  __attribute__((packed)) __attribute__((aligned(1))) int max_remote_temp[4];
};

/* 252 */
struct reg_buf
{
  uint32_t p_wr;
  uint32_t p_rd;
  uint32_t reg_value_num;
  reg_rb_format reg_buffer[100];
};

/* 253 */
struct nonce_buf
{
  uint32_t p_wr;
  uint32_t p_rd;
  uint32_t nonce_num;
  nonce_rb_format nonce_buffer[100];
};

/* 254 */
struct chain_inactive_cmd_t
{
  unsigned __int8 cmd : 4;
  unsigned __int8 all : 1;
  unsigned __int8 type : 3;
  uint8_t length;
  uint8_t reserve1;
  uint8_t reserve2;
  unsigned __int8 crc5 : 5;
  unsigned __int8 reserve3 : 3;
};

/* 255 */
struct set_address_cmd_t
{
  unsigned __int8 cmd : 4;
  unsigned __int8 all : 1;
  unsigned __int8 type : 3;
  uint8_t length;
  uint8_t chip_addr;
  uint8_t reserve1;
  unsigned __int8 crc5 : 5;
  unsigned __int8 reserve2 : 3;
};

/* 256 */
struct set_config_cmd_t
{
  uint8_t header_55;
  uint8_t header_aa;
  unsigned __int8 cmd : 4;
  unsigned __int8 all : 1;
  unsigned __int8 type : 3;
  uint8_t length;
  uint8_t chip_addr;
  uint8_t regaddr;
  uint8_t regdata[4];
  unsigned __int8 crc5 : 5;
  unsigned __int8 reserve : 3;
};

/* 257 */
struct get_status_cmd_t
{
  uint8_t header_55;
  uint8_t header_aa;
  unsigned __int8 cmd : 4;
  unsigned __int8 all : 1;
  unsigned __int8 type : 3;
  uint8_t length;
  uint8_t chip_addr;
  uint8_t regaddr;
  unsigned __int8 crc5 : 5;
  unsigned __int8 reserve : 3;
};

/* 258 */
enum input_cmd_allchip_type : __int32
{
  input_cmd_allchip_type::CMD_SINGLE_CHIP = 0x0,
  input_cmd_allchip_type::CMD_ALL_CHIP = 0x1,
};

/* 259 */
enum input_cmd_length_type : __int32
{
  input_cmd_length_type::INPUT_CMD_LEN_5 = 0x5,
  input_cmd_length_type::INPUT_CMD_LEN_9 = 0x9,
};

/* 260 */
enum input_cmd_type : __int32
{
  input_cmd_type::CMD_SET_ADDRESS = 0x0,
  input_cmd_type::CMD_SET_CONFIG = 0x1,
  input_cmd_type::CMD_GET_STATUS = 0x2,
  input_cmd_type::CMD_CHAIN_INACTIVE = 0x3,
};

/* 261 */
enum input_data_type : __int32
{
  input_data_type::WORK_INPUT = 0x1,
  input_data_type::COMMAND_INPUT = 0x2,
  input_data_type::BIST_INPUT = 0x3,
};

/* 262 */
union bm1740_reg
{
  bm1740_chip_addr chip_addr;
  bm1740_hash_rate hash_rate;
  bm1740_pll_parameter pll_parameter;
  bm1740_ticket_mask ticket_mask;
  bm1740_misc_control misc_control;
  bm1740_general_i2c_command general_i2c_command;
  bm1740_nonce_tx_ok nonce_tx_ok;
  bm1740_core_timeout core_timeout;
  bm1740_io_drive_strength io_drive_strength;
  bm1740_chip_status chip_status;
  bm1740_time_out time_out;
  bm1740_pmonitor_ctrl pmonitor_ctrl;
  bm1740_analog_mux_control analog_mux_control;
  bm1744_nonce_shift nonce_shift;
  bm1740_start_nonce_offset start_nonce_offset;
  bm1740_txn_data txn_data;
  uint32_t reg_bin;
};

/* 263 */
enum bm1740_reg_address : __int32
{
  bm1740_reg_address::REG_CHIP_ADDRESS = 0x0,
  bm1740_reg_address::REG_HASH_RATE = 0x8,
  bm1740_reg_address::REG_PLL_PARAMETER = 0xC,
  bm1740_reg_address::REG_TICKET_MASK = 0x14,
  bm1740_reg_address::REG_MISC_CONTROL = 0x1C,
  bm1740_reg_address::REG_GENERAL_I2C_COMMAND = 0x20,
  bm1740_reg_address::REG_NONCE_TX_OK = 0x24,
  bm1740_reg_address::REG_CORE_TIMEOUT = 0x28,
  bm1740_reg_address::REG_IO_DRIVE_STRENGTH = 0x30,
  bm1740_reg_address::REG_CHIP_STATUS = 0x34,
  bm1740_reg_address::REG_TIME_OUT = 0x38,
  bm1740_reg_address::REG_PMONITOR_CTRL = 0x3C,
  bm1740_reg_address::REG_ANALOG_MUX_CONTROL = 0x40,
  bm1740_reg_address::REG_BIST_STATUS = 0x48,
  bm1740_reg_address::REG_NONCE_SHIFT = 0x50,
  bm1740_reg_address::REG_START_NONCE_OFFSET = 0x54,
  bm1740_reg_address::REG_TXN_DATA = 0x58,
};

/* 264 */
typedef work work_0;

/* 265 */
typedef cgpu_info cgpu_info_0;

/* 266 */
typedef unsigned int speed_t;

/* 267 */
struct stat
{
  __dev_t st_dev;
  unsigned __int16 __pad1;
  __ino_t st_ino;
  __mode_t st_mode;
  __nlink_t st_nlink;
  __uid_t st_uid;
  __gid_t st_gid;
  __dev_t st_rdev;
  unsigned __int16 __pad2;
  __off_t st_size;
  __blksize_t st_blksize;
  __blkcnt_t st_blocks;
  timespec st_atim;
  timespec st_mtim;
  timespec st_ctim;
  unsigned int __glibc_reserved4;
  unsigned int __glibc_reserved5;
};

/* 268 */
typedef nitem NITEM;

/* 269 */
typedef sbitem SBITEM;

/* 270 */
struct ipv6_mreq
{
  in6_addr ipv6mr_multiaddr;
  unsigned int ipv6mr_interface;
};

/* 271 */
struct ip_mreq
{
  in_addr imr_multiaddr;
  in_addr imr_interface;
};

/* 273 */
struct __attribute__((aligned(8))) __pthread_unwind_buf_t::$C277420EBC3478189FF06E3E7E99E2B1
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

/* 272 */
struct __pthread_unwind_buf_t
{
  __pthread_unwind_buf_t::$C277420EBC3478189FF06E3E7E99E2B1 __cancel_jmp_buf[1];
  void *__pad[4];
};

/* 274 */
enum send_ret : __int32
{
  send_ret::SEND_OK = 0x0,
  send_ret::SEND_SELECTFAIL = 0x1,
  send_ret::SEND_SENDFAIL = 0x2,
  send_ret::SEND_INACTIVE = 0x3,
};

/* 275 */
struct lldiv_t
{
  __int64 quot;
  __int64 rem;
};

/* 276 */
enum benchwork : __int32
{
  benchwork::BENCHWORK_VERSION = 0x0,
  benchwork::BENCHWORK_MERKLEROOT = 0x1,
  benchwork::BENCHWORK_PREVHASH = 0x2,
  benchwork::BENCHWORK_DIFFBITS = 0x3,
  benchwork::BENCHWORK_NONCETIME = 0x4,
  benchwork::BENCHWORK_COUNT = 0x5,
};

/* 277 */
typedef SHA256Context SHA256_CTX;

/* 279 */
union sigaction::$A0D7C018272EA30F374433AF4EA79BEE
{
  __sighandler_t sa_handler;
  void (*sa_sigaction)(int, siginfo_t *, void *);
};

/* 278 */
struct sigaction
{
  sigaction::$A0D7C018272EA30F374433AF4EA79BEE __sigaction_handler;
  __sigset_t sa_mask;
  int sa_flags;
  void (*sa_restorer)(void);
};

/* 280 */
typedef __sighandler_t sighandler_t;

/* 289 */
typedef unsigned int uintptr_t;

/* 290 */
struct $8BF8CEFDD07FC02C86A88CD42330C887
{
  const char *name;
  proxytypes_t proxytype;
};

/* 291 */
typedef __sigset_t sigset_t;

/* 292 */
typedef int (*__compar_fn_t)(const void *, const void *);

/* 293 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 294 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 295 */
typedef __n64 int8x8_t;

/* 296 */
typedef __n64 uint8x8_t;

/* 297 */
typedef __n64 int16x4_t;

/* 298 */
typedef __n64 int32x2_t;

/* 299 */
typedef __n64 uint16x4_t;

/* 300 */
typedef __n64 uint32x2_t;

/* 301 */
typedef __n128 int8x16_t;

/* 302 */
typedef __n128 int16x8_t;

/* 303 */
typedef __n128 int32x4_t;

/* 304 */
typedef __n128 int64x2_t;

/* 305 */
typedef __n128 uint8x16_t;

/* 306 */
typedef __n128 uint16x8_t;

/* 307 */
typedef __n128 uint32x4_t;

/* 308 */
typedef __n128 uint64x2_t;

/* 309 */
typedef __n64 poly8x8_t;

/* 310 */
typedef __n64 poly16x4_t;

/* 311 */
typedef __n128 poly16x8_t;

/* 312 */
typedef __n128 poly8x16_t;

/* 313 */
typedef __n64 float16x4_t;

/* 314 */
typedef __n64 float32x2_t;

/* 315 */
typedef __n128 float16x8_t;

/* 316 */
typedef __n128 float32x4_t;

/* 317 */
typedef __n128 float64x2_t;

/* 318 */
typedef __n128 poly128_t;

/* 319 */
typedef int16x4_t int16x2_t;

/* 320 */
typedef uint16x4_t uint16x2_t;

/* 321 */
typedef float16x4_t float16x2_t;

